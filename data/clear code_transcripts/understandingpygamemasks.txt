00:00 - hello in this tutorial you will be
00:02 - learning how to use mask and pie game
00:04 - and you can use that in a couple of
00:06 - different ways
00:07 - most importantly using a mask enables
00:10 - you to do pixel perfect collisions
00:12 - but you can also use a mask to fill a
00:14 - surface or give it an outline
00:16 - and if you push it a bit further you can
00:18 - also color in the overlapping areas
00:20 - between two surfaces and all of these
00:23 - projects are going to be what we will
00:25 - cover in this video which should be a
00:28 - reasonably extensive introduction to
00:30 - using a mask in pie game
00:32 - so let's get started and talk about what
00:34 - a mask is in the first place
00:36 - if you have used pygame even for a
00:38 - little bit you will know two objects
00:41 - surfaces and rectangles or rects and
00:43 - short
00:44 - his surface holds an image and is
00:46 - basically a rectangle with pixels and
00:49 - each pixel represents a color and a
00:51 - transparency
00:52 - and a surface does not contain any
00:55 - positioning information or any means to
00:57 - check collisions with another surface
01:00 - all you can really do is to change the
01:01 - pixels to make it look different and to
01:03 - get some basic information about it
01:06 - now if you do need positions and
01:08 - collisions you would use erect this
01:11 - object is basically a rectangle with
01:13 - points that you can move and measure
01:15 - and you can also check if a rectangle
01:17 - collides with another rectangle or
01:19 - overlaps with a point
01:21 - however you always work with rectangles
01:24 - so if you want to check for collisions
01:25 - between irregular shapes you would
01:28 - struggle quite a bit
01:29 - but for that
01:31 - we can use a mask
01:33 - and a mask is somewhat similar to a
01:35 - surface
01:36 - in the sense that it contains
01:37 - information for each pixel and uses that
01:40 - to draw a shape however each pixel only
01:43 - stores either 0 or 1 instead of a color
01:47 - information
01:48 - 0 means that the space for this pixel is
01:50 - empty
01:51 - and a 1 means that the pixel is occupied
01:54 - now i assume by itself this is a bit
01:57 - confusing so let's do this a bit more
02:00 - practical
02:01 - usually a mask is generated from a
02:03 - surface
02:04 - and in that process pygame goes through
02:07 - every single pixel of that surface
02:10 - and if a pixel is transparent then it
02:12 - will create a zero for this particular
02:15 - pixel however if any of these pixels has
02:17 - a color it will be a one in the math
02:20 - and that way we can tell which parts of
02:22 - the image are occupied and which ones
02:24 - aren't
02:26 - and that information can then be used in
02:28 - a couple of different ways the most
02:30 - common one is for collisions because you
02:32 - can check if one mask overlaps with
02:34 - another mask on a pixel by pixel bases
02:37 - what you can also do is to take a mask
02:39 - and convert it back to a surface and
02:41 - then color each of the pixels that way
02:44 - you can turn an entire surface into a
02:46 - single color or color specific parts of
02:49 - a surface like the surrounding area or
02:51 - any overlapping surface
02:53 - and that is basically all you need for
02:55 - the basic theory so let's get started
02:58 - with the easiest kind of a mask a
03:00 - collision mask inside of a sprite
03:04 - and alright here we are in the code and
03:07 - i've already set up a couple of things
03:09 - now if none of this
03:12 - makes any sense to you you probably want
03:14 - to check out my introduction to pygame
03:16 - it explains all of this in quite a bit
03:18 - of detail but ultimately what we're
03:20 - seeing in here isn't all that difficult
03:22 - and let's run it first and then i can
03:24 - talk about it
03:26 - so if i run this code you can see a
03:28 - white background a big alpha and a red
03:30 - rectangle and the red rectangle i can
03:32 - move around with my mouse but besides
03:34 - that really nothing is happening
03:38 - so let's close it and let's talk about
03:40 - the code
03:41 - now the really easy parts here
03:44 - this part
03:45 - this part
03:46 - and let's say this part down here
03:49 - because all of these are the super basic
03:51 - setup for pygame
03:53 - so if you just want to create a basic
03:54 - window this is what you would need now i
03:57 - guess on top of that in this line here i
04:00 - am filling the background with a white
04:01 - color so we have a white background
04:03 - color
04:06 - now the actually more interesting parts
04:09 - are these two classes up here
04:11 - and i'll talk about them in just a
04:13 - second but first of all be aware
04:16 - down here
04:18 - each of these classes is initiated
04:21 - inside of a group single
04:23 - so we have one group single for the
04:25 - player and one group single for the
04:27 - obstacle and it is important to keep
04:29 - these two in separate groups you're
04:30 - going to see in a second why
04:32 - but well each group is ever called
04:34 - player and obstacle
04:37 - and then in our game loop
04:40 - we are drawing both of them and the
04:43 - player also gets updated
04:46 - why only the player gets updated you
04:48 - will see in a second
04:50 - but these are the two classes we are
04:51 - going to need
04:53 - so let's have a look at them
04:55 - the first class let's look at the
04:56 - obstacle that's the easier one and in
04:59 - here you can see well that not much is
05:01 - happening
05:02 - we are inheriting from the sprite class
05:05 - so we're getting a sprite and then in
05:07 - there we are creating an image and a
05:10 - rectangle so the basics you need for a
05:12 - sprite
05:15 - and i guess the one thing in here is
05:17 - that for this class we are importing an
05:20 - image and this image is in the same
05:22 - folder
05:23 - but that still isn't anything
05:25 - particularly complicated
05:28 - so with that we can minimize this class
05:31 - and not worry about it anymore so let's
05:33 - have a look at the player
05:35 - and this one is slightly more
05:36 - complicated but not that much
05:39 - i guess first of all we're importing a
05:40 - sprite and for the image we are creating
05:43 - a plain surface
05:44 - and we are filling it with a red color
05:48 - and by default we are placing the center
05:50 - of this image at a position 300 and 300.
05:54 - so all of this is going to be very
05:56 - similar compared to the obstacle except
05:58 - now we don't import an image we are
05:59 - creating one in pi game itself
06:01 - now the slightly more interesting part
06:03 - for this class is this bit here
06:06 - and what this one does is it checks if
06:09 - there's any kind of mouse position
06:11 - and this is going to exist as soon as we
06:13 - are moving our mouse and once i have
06:16 - that i want to set the center of the
06:17 - rectangle to wherever the mouse is going
06:20 - to be and that way all of the stuff up
06:23 - here is always going to follow the mouse
06:26 - and this is also why we have to update
06:28 - the player group because only with that
06:31 - we are calling this method here
06:34 - so let me minimize it and now we can
06:36 - start to work on the collisions
06:38 - and let's do this in the game loop and
06:41 - let me add a comment let's call this
06:43 - collision
06:45 - now usually what you would do in pygame
06:48 - to get a collision with sprites is
06:49 - pygame dot sprite dot sprite
06:53 - collide
06:54 - and then here you have to pass in three
06:56 - different arguments you need a sprite
06:58 - you need a group
07:00 - and you need what is called do
07:02 - kill and let's go through all of them
07:04 - one by one
07:06 - now the sprite has to be a single sprite
07:08 - and in my case i want to look at my
07:10 - player
07:11 - so essentially this player here that i'm
07:14 - passing
07:16 - in there
07:18 - however this player right now is not a
07:20 - sprite it's a group that contains a
07:22 - sprite so this is a group
07:25 - as a consequence we couldn't use players
07:28 - straight away here we will get an error
07:31 - but we can fix that quite easily
07:33 - all we need is player dot sprite and
07:36 - that way we're going to get one sprite
07:38 - inside of this class
07:40 - now next up we need a group and this one
07:43 - is quite a bit easier because we already
07:45 - have our obstacle group and this
07:47 - actually is a group so this we can just
07:49 - pass
07:50 - in here
07:52 - so literally what i want to do is to get
07:54 - my obstacle
07:56 - and with that let's get rid of these
07:57 - lines
07:58 - now i need a ducal argument
08:01 - and all this really means is if this
08:03 - sprite collides with a sprite inside of
08:05 - this group do we want to delete the
08:07 - sprite inside of this group so this can
08:10 - either be true or it can be false
08:14 - in my case i do want this to be false
08:16 - because i don't want to delete the alpha
08:18 - inside of this group
08:19 - and all right with that we have a sprite
08:21 - collision method
08:23 - now what this method is going to return
08:25 - is a list with all of the sprites that
08:27 - are overlapping or well colliding
08:30 - so what we could do for example is use
08:32 - this in an if statement
08:35 - let's say i want to print the word
08:38 - collision and now if i run this
08:42 - and i move my red rectangle somewhere to
08:44 - the alpha we get collision in the bottom
08:46 - left
08:47 - however if you look very closely
08:50 - the red rectangle didn't actually touch
08:52 - the alpha itself at least not the alpha
08:55 - as we can see it
08:57 - and the problem here is that sprite
08:58 - collide by default uses the rectangle of
09:00 - the class so we are basically checking
09:02 - the rectangle around the alpha
09:05 - which usually works but sometimes
09:07 - especially in this case really does not
09:10 - work well and there's this huge amount
09:12 - of white area around the alpha that
09:14 - still checks collision so this is not
09:16 - going to work
09:18 - now fortunately we can fix that very
09:20 - easily there are two things we need
09:22 - essentially
09:24 - number one for each of the classes we
09:27 - have to set a mask so the player and the
09:30 - obstacle are going to need a mass
09:32 - and then besides that we have to add one
09:35 - extra argument into spread glide to
09:38 - check for a mask and not for rectangle
09:41 - so let's start with the first one and
09:43 - let's give each of these classes a mask
09:46 - and this is actually incredibly easy all
09:49 - you need is to add another attribute
09:52 - called self dot mask
09:54 - and this has to be called a mask
09:56 - and now we have to generate a mask from
10:00 - this surface here or well the image of
10:03 - the sprite class
10:05 - and this is also very easily done all we
10:07 - need is pygame dot mass dot from
10:09 - underscore
10:11 - surface
10:13 - and this method is going to need one
10:15 - argument and that is the surface we want
10:17 - to convert into a mask which in my case
10:20 - is self dot image
10:22 - so all i'm really doing is i'm getting
10:24 - this image and i'm passing it in here
10:27 - and then we are good to go actually
10:30 - and now we have to do the very same
10:32 - thing for the obstacle so literally all
10:35 - i have to do is copy
10:37 - all of this
10:38 - and now this obstacle also has a mask so
10:41 - now i can minimize these two classes
10:43 - again
10:44 - and now we come to the second step
10:46 - that spread collide needs another
10:49 - argument argument number four and this
10:52 - is basically to tell it that we are
10:53 - looking for the mask and not for the
10:55 - rectangle
10:57 - and for this one we actually have a
10:59 - couple of options
11:00 - if you check the documentation you can
11:01 - find all of them so we have collide rect
11:04 - collide direct ratio collide circle
11:06 - collide circle ratio and collide mask
11:09 - collide rect is the default one
11:10 - basically and we want to check for
11:13 - collide mask obviously so what we have
11:15 - to pass in here is pygame dot sprite dot
11:19 - collide underscore mask
11:23 - and with that we have a mask collision
11:26 - that's literally all we needed so now
11:28 - let's run this again
11:29 - and now look very closely
11:32 - my red rectangle is inside of the
11:34 - rectangle of the alpha but we cannot see
11:36 - collision in the bottom left however
11:39 - once i touch the black part so let me be
11:42 - very careful
11:43 - now we can see it that's
11:45 - really all there is to the most basic
11:47 - kind of mask collision
11:50 - now let me actually
11:52 - make this a bit more visual so it's
11:54 - better to see so if there's a collision
11:57 - i want to get myplayer.sprite.image.fill
12:01 - and fill it with a green color
12:04 - if there is a collision
12:06 - and if that is not the case so else i
12:09 - want to copy
12:11 - all of this and fill it with red
12:13 - this way all of this should be easier to
12:15 - see so now let's run this
12:17 - and i'm getting an error
12:20 - this double colon shouldn't be there
12:23 - so now let's try this again and there we
12:24 - go so now i can move the red rectangle
12:27 - and if we're touching the alpha
12:29 - it turns green but if we are not even
12:32 - though we are in the rectangle of the
12:33 - alpha it's red and this is working even
12:36 - inside of the alpha so here every time i
12:38 - touch the alpha we get a green rectangle
12:42 - and this is working remarkably well so
12:46 - all good with this one this is actually
12:48 - really workable cool
12:51 - so with that we have the most basic use
12:53 - of a mask and pie game and i guess the
12:56 - one thing you really have to be careful
12:57 - here let me open both of these classes
13:00 - is that if either of these classes were
13:03 - animated you would have to create a new
13:05 - mask after every time you are running
13:07 - the animation
13:09 - basically think of any time you're
13:10 - changing this surface here you want to
13:13 - create a new mask
13:14 - but that's about the only mechanical
13:16 - thing you really have to worry about
13:18 - although i guess the other thing you
13:19 - also want to worry about is performance
13:22 - because mask collisions are quite a bit
13:25 - more performance heavy than normal
13:27 - collisions or well rectangle collisions
13:31 - because remember checking every single
13:33 - pixel inside of both sprites is quite a
13:36 - bit more difficult than just checking
13:38 - rectangles
13:40 - now there's one thing you can actually
13:41 - do to make all of this quite a bit more
13:43 - performant and that is that you first
13:46 - check a rectangle collision and only if
13:49 - you have a rectangle collision then you
13:50 - check a mask collision
13:52 - and this is really easily done all i
13:54 - have to do is copy
13:56 - all of this
13:58 - and create a new if statement
14:00 - with the normal sprite collision so no
14:02 - mask whatsoever and only if we have this
14:04 - kind of collision
14:06 - then i want to check a mask collision
14:08 - so this way you're only checking your
14:10 - mask collision if both of these sprites
14:13 - are very close to each other which
14:15 - especially if you have a lot of
14:16 - collisions is going to make your game
14:18 - run a lot faster but if i run this
14:21 - we still get the same result except now
14:24 - we are only checking a mass collision if
14:26 - the rectangle is roughly in this area
14:29 - here but if we're outside of it we're
14:31 - not checking it at all so this is going
14:32 - to help our performance quite a bit
14:35 - and all right so this is then the first
14:38 - project in a mask and this is probably
14:41 - how you want to use it in most games
14:43 - because it's really easy and incredibly
14:45 - useful
14:46 - but you can also use a mask much more
14:49 - flexibly so for the next project we are
14:52 - going to do the same thing but we are
14:54 - going to do it without a sprite class
14:59 - and i guess let's jump straight into the
15:01 - project and let's have a look at this
15:04 - and all right here we have a new project
15:07 - and if i run all of this
15:09 - we can again see the alpha and we have
15:11 - our red rectangle that we can move
15:13 - around with our mouse
15:15 - so let's first talk about
15:17 - how to set this up and then we can talk
15:19 - about the collisions
15:21 - now guys at the top we're importing the
15:22 - normal stuff and then we are setting up
15:24 - the basic things for pygame and we have
15:27 - one section
15:28 - where we are creating the player so we
15:31 - have a player surface that we are
15:33 - filling with a red color and then we
15:35 - have a player rectangle that by default
15:37 - is in this position
15:39 - although this position doesn't really
15:41 - matter because
15:43 - further down here
15:45 - as soon as we have a mouse position
15:47 - we are setting the center of this
15:49 - rectangle to wherever the mouse is going
15:52 - to be
15:53 - and this is very similar to the class we
15:55 - have just seen
15:57 - and once we have the rectangle and the
15:58 - surface
16:00 - we are splitting the player
16:02 - where the mouse is going to be
16:04 - now besides that we also have our
16:07 - obstacle down here and this one is just
16:09 - going to be a surface and we have a
16:11 - position so there isn't even a rectangle
16:14 - and all of this we are blitting in this
16:17 - line of code in our game loop and i
16:19 - guess besides that we're also filling
16:20 - the entire thing with a white background
16:22 - color we have our event loop
16:25 - and let me close all of this and all the
16:28 - way at the bottom
16:29 - we have the usual updating and our clock
16:32 - so this again it shouldn't be difficult
16:35 - if you have even the basic understanding
16:36 - of pygame if you don't i would really
16:39 - recommend to check out my basic pie game
16:41 - introduction
16:42 - now let's talk about collisions
16:44 - and in here if you wanted to do normal
16:47 - rectangle collisions
16:48 - you will basically create a rectangle
16:51 - for this obstacle but in this case we
16:53 - are not going to do that for the simple
16:56 - reason that we want to have mass
16:58 - collisions
16:59 - so the first thing we have to do is to
17:01 - create a mask for each of our surfaces
17:03 - and let's call it player underscore mask
17:07 - and i also want to have
17:09 - an obstacle underscore mask
17:12 - and this mask will be created in exactly
17:14 - the same way that you have seen in this
17:16 - bright part so this could actually be a
17:18 - good exercise
17:19 - have a look at the sprite part and see
17:22 - how we created the mask there and now
17:25 - try to do the same thing by creating a
17:27 - mask from the player's surface and from
17:29 - the obstacle surface as well
17:35 - all right let's do it together now so to
17:39 - create a mask from a surface we need
17:41 - pygame dot mask dot from underscore
17:45 - surface and in here we have one argument
17:48 - that in this case is going to be the
17:50 - player
17:51 - surface
17:53 - and then we can copy all of this for the
17:55 - obstacle
17:56 - and now this has to be the
17:59 - obstacle surface
18:01 - and now for run this we should not be
18:03 - seeing any difference and
18:05 - looks good
18:06 - i guess the one thing to look for here
18:08 - is if we're getting an error message
18:10 - which we don't so that's a good sign so
18:13 - now that we have our mask we can
18:14 - actually in our game loop
18:17 - look at the collisions and again let me
18:19 - add a new section here so collision
18:22 - and outside of the sprite class you
18:25 - essentially have two ways to check for a
18:27 - collision with a mask
18:29 - one is called overlap the other is
18:30 - called overlap area
18:32 - and both of these methods work in
18:34 - basically the same way
18:36 - the difference is in what they return
18:38 - an overlap basically returns one point
18:41 - if there's any point of overlap overlap
18:43 - area returns how big the overlap is so
18:47 - how many pixels are overlapping but
18:49 - let's start with overlap by itself
18:51 - and to trigger this again we need an if
18:53 - statement
18:54 - and we need one of the masks it doesn't
18:56 - really matter which one in my case i
18:59 - want to go with my player mask
19:00 - and then here we could have a call
19:02 - overlap or overlap area in my case i
19:06 - just want overlap
19:08 - and in here
19:09 - we have to pass in two arguments the
19:12 - first one is the other mass we want to
19:14 - check and the second one is called an
19:17 - offset and let's say for now if that is
19:20 - the case i want to print
19:23 - collision
19:24 - so let's figure out the parameters in
19:26 - here
19:27 - the mask is the easy part because all we
19:30 - really need is
19:33 - this obstacle mass up here and pass it
19:35 - in here as an argument literally all we
19:38 - have to do is pass in
19:41 - obstacle mask and we are good to go
19:45 - now then
19:46 - what is the offset
19:48 - and this is a slightly confusing part at
19:51 - times basically what pi game here wants
19:53 - is that we pass in an x and a y position
19:58 - so at the top left of this mask is in
20:01 - the same position as the top left of
20:03 - this mass
20:04 - why that is specifically necessary
20:06 - i have absolutely no idea but pygame
20:09 - does want it so let's
20:11 - add a couple more lines of code and
20:13 - let's fix this and i guess let's name
20:15 - this properly let's call it offset x and
20:18 - y
20:20 - so we have
20:22 - offset x and we have offset y
20:26 - and essentially what we are looking for
20:27 - in here is for example for x
20:30 - is how much of an x do we have to add to
20:33 - our player mask to put it in the same x
20:36 - position as our obstacle mask and let me
20:39 - actually draw what we are going to need
20:40 - here let's say in yellow
20:43 - we have our obstacle mask that looks
20:46 - like this and let me call it o and then
20:49 - besides that we have our player mask and
20:52 - let's place it somewhere
20:55 - here
20:56 - and let's call this one
20:57 - p
20:58 - basically what pie game wants to know is
21:01 - what is
21:03 - this distance here and this is going to
21:06 - be the offset for x
21:08 - and it wants to know
21:09 - what this distance here has to be and
21:11 - this is going to be offset y
21:14 - and then if you combine these two
21:15 - offsets you are getting to this position
21:18 - up here and that way the player mask and
21:20 - the obstacle mast have the same top left
21:22 - position and fortunately both of these
21:24 - points are fairly easy to get the first
21:27 - one we need is the top left position of
21:29 - the obstacle and this is stored up here
21:32 - in our obstacle pause and this is a
21:34 - tuple with x and y
21:36 - so let me copy this thing
21:38 - and in here i want the first item and
21:41 - then i want the second item so this is
21:44 - going to be x and y
21:46 - and from that i want to subtract my
21:50 - player
21:51 - rect dot
21:53 - left
21:54 - and
21:56 - my player act dot top
21:59 - and let's do a really quick example to
22:00 - illustrate how this is going to look so
22:03 - here again
22:05 - we have our obstacle and let's just
22:08 - focus on the x part now so this line
22:11 - here
22:12 - is position
22:14 - 100 and now let's place our player again
22:17 - somewhere down here
22:19 - we have our player
22:21 - and let's say the left of our player is
22:23 - at position let's say 300. so to place
22:26 - the left of our player to the left of
22:28 - the obstacle we would need this distance
22:31 - here and remember this number has to be
22:33 - negative because we want to move this
22:35 - player to this side and to get this
22:37 - number we would need 100 minus 300
22:41 - which would be the same as negative
22:44 - 200
22:45 - and this is exactly
22:47 - what we would get from this line here
22:49 - and then the same would be applying to
22:51 - the y position as well and i guess with
22:55 - that we literally have all we need let's
22:57 - actually try this and now if i just move
23:00 - close to the alpha we get nothing but if
23:02 - there's a collision we can see collision
23:05 - so this is working really well so this
23:08 - is then what you are going to need for a
23:10 - mask collision without a sprite class
23:14 - and i guess what we can also do is let's
23:16 - actually print what this thing is
23:18 - returning because that's kind of
23:20 - interesting
23:22 - so now let's run this and let's see what
23:24 - we get
23:25 - so now if i touch the alpha in the
23:28 - bottom right of my rectangle and there
23:30 - we go
23:31 - we get 49 and 49 so this point here
23:35 - although it does change to further we go
23:37 - down
23:38 - and basically what this means that our
23:40 - player mast is a mast that has 50 points
23:43 - on the x and on the y dimension exactly
23:46 - what we specified in the mask earlier so
23:48 - let me actually close this and go to the
23:50 - surface
23:53 - so in here we are creating a surface
23:55 - that is 50 by 50 pixels
23:58 - and then when we are using this surface
24:00 - to create the mask down here we are
24:02 - creating a mask with 50 by 50 pixels so
24:06 - our first pixel is 0 and 0 and our
24:09 - bottom right pixel is 49 and 49
24:13 - and essentially what this method here
24:15 - returns is the first pixel on the mast
24:18 - that has a collision
24:20 - so right now if i'm hitting the alpha
24:23 - with
24:23 - just the bottom right like this we get
24:26 - 49 and 49 so the bottom right pixel of
24:30 - this mask
24:31 - however if i go to the other side and
24:33 - let me scroll down all the way here
24:36 - now if i hit this alpha with the top
24:38 - left
24:39 - we should expect 0 and 0 because that's
24:42 - the first pixel in the mask and if i do
24:46 - that we indeed get 0 and 0. so this is
24:49 - exactly what we get here
24:51 - so if you have some incredibly specific
24:53 - need to check for one specific pixel on
24:56 - your surface this is how you would do it
24:59 - but
25:00 - probably not particularly useful all the
25:02 - time
25:02 - but with that we have a basic collision
25:04 - with a mask without a sprite now there's
25:06 - another thing that we can do and let me
25:10 - comment all of this out but i am going
25:13 - to keep the offset for x and y because
25:15 - we are going to need it
25:17 - right now our overlap triggers as soon
25:20 - as we have a single point but sometimes
25:23 - you don't really want that so if you
25:25 - want a more forgiving collision mechanic
25:27 - where collision only triggers if you
25:29 - have 5 or maybe 10 pixels of overlap
25:32 - but then you wouldn't use overlap you
25:34 - would use overlap area and let's work
25:37 - with that
25:38 - so again i want my player mast dot
25:42 - overlap
25:44 - except now i want overlap area but
25:47 - besides that i will need the same
25:49 - arguments so those two let me pass it in
25:51 - here
25:52 - and let's say again just for start let's
25:56 - print
25:57 - collision
25:59 - if i were to run this
26:01 - we would get pretty much the same result
26:03 - so as soon as there's any kind of
26:04 - collision we get collision in the bottom
26:07 - left so this is still working
26:09 - but now what is interesting about this
26:12 - method here let me copy all of it and
26:15 - let's see what it returns
26:17 - so now let me run all of this again
26:20 - and now if i touch the alpha we can see
26:24 - we get 1 10
26:26 - and then again 6
26:27 - and this is telling us how many pixels
26:29 - have been overlapping between our player
26:30 - mask and our alpha mask or while our
26:33 - obstacle mask whatever i called it
26:36 - and if i go all the way over this we get
26:39 - 2500
26:41 - and this is the number you get from the
26:43 - dimension of our player mask because
26:45 - this one is 50 times 50 pixels and if
26:48 - you multiply those two numbers you get 2
26:50 - 500.
26:52 - and all right so now really what we can
26:55 - do
26:56 - is check if this number
26:58 - let's say is greater or
27:02 - equal to
27:03 - let's say maybe ten
27:05 - so enough around this
27:07 - i can get a tiny offset but now as soon
27:10 - as i get something greater than 16
27:12 - we are triggering the collision again
27:14 - but again if there's only a tiny overlap
27:16 - we do not trigger a collision
27:19 - and of course if you set this number to
27:21 - something greater than the pixels in the
27:22 - mask let's say in this case
27:24 - 2501 we will never see this if statement
27:28 - get triggered so now we don't get
27:30 - anything because there aren't that many
27:32 - pixels in the mask but it could do
27:34 - something a bit more reasonable let's
27:36 - say 100
27:39 - and now
27:40 - i can't move
27:42 - a bit over the mast and it's a bit more
27:43 - forgiving so if that's your goal
27:46 - that's how you would do it so with that
27:48 - we have the second way to approach a
27:50 - mask now there is a third kind of
27:52 - overlap and that is called overlap mask
27:55 - and this one is going to return a mask
27:57 - with the overlapping pixels between our
27:59 - player mask and our obstacle mask
28:02 - and this is what you would be using to
28:04 - color in an overlapping area for example
28:07 - we're gonna see that later in this video
28:09 - actually but for now don't worry about
28:11 - it
28:12 - and instead let's use a mask to color in
28:15 - a surface or to give it an outline which
28:18 - is something you can do fairly easily
28:19 - with a mask essentially what we are
28:21 - going to do we are going to take the
28:23 - surface we already have then from this
28:26 - surface we are going to create a mask
28:29 - and then this mask we are going to
28:30 - convert back into a surface and this is
28:33 - essentially going to give us a black and
28:35 - white version of the surface we just
28:37 - created
28:38 - and then we are going to go for every
28:40 - single pixel of that new surface and
28:43 - change each pixel to a certain color now
28:45 - you might be asking why can't we go
28:47 - through the original surface and change
28:49 - the pixels there individually
28:52 - and the answer is actually quite simple
28:54 - in the original surface we probably have
28:57 - lots of different colors and this is
28:59 - making it quite difficult to separate
29:01 - the visible from the invisible pixels
29:03 - and the mask is going to fix that
29:05 - problem entirely you're going to see
29:07 - later on in this video what this is
29:09 - going to mean in practice but
29:10 - specifically in this part we're going to
29:12 - either fill a surface or we're going to
29:14 - give a surface an outline both of which
29:16 - can be done fairly easily with a mask
29:19 - so let's jump straight into the project
29:21 - and let's have a look at this
29:23 - so here again we have an incredibly
29:26 - simple setup let me run all of this and
29:29 - we can see our alpha and nothing else
29:31 - we don't even have to moving rectangle
29:33 - anymore because we don't need it so
29:36 - literally all we're doing right now
29:39 - is that we are importing an image and
29:41 - setting a position here
29:43 - and then
29:44 - down here we are blitting all of this
29:47 - and i guess we have a white background
29:48 - but that's just about it
29:50 - and the first thing we need is to create
29:53 - a mask and this is happening in the
29:55 - usual way so obstacle mask as a new
29:58 - variable
29:59 - and this one should be pygame dot mask
30:02 - dot from
30:03 - underscore surface
30:05 - and in here i again want my obstacle
30:08 - surface
30:09 - and now we have a mask
30:12 - by itself doesn't really do much but
30:14 - well we can use it and essentially let
30:17 - me add a comment here
30:19 - what i want to do now is to turn the
30:21 - mask back
30:23 - into a surface
30:24 - and i guess let's be a bit more
30:26 - consistent here let's give this one a
30:28 - comment as well
30:29 - i'm creating the
30:31 - obstacle
30:32 - essentially what i want to do in here i
30:35 - want to turn the obstacle mask back into
30:38 - a surface
30:39 - and let's call this new
30:42 - obstacle
30:44 - surface
30:45 - and to generate this one we first need
30:48 - our obstacle
30:50 - mask so the mask we have just created
30:55 - and now this mask has a method that is
30:58 - called to underscore surface and when we
31:01 - call it we don't need any arguments in
31:04 - here and now we have an entirely new
31:07 - surface so what we can do now is in our
31:10 - game loop i can copy this entire line
31:13 - with the obstacle surface and now i can
31:16 - blit this new surface and let's just see
31:19 - what happens
31:21 - now we can see something slightly weird
31:25 - so we can see that we can still see the
31:27 - alpha so all of this part here but now
31:30 - it's white and all of the other parts
31:33 - that used to be invisible are now black
31:35 - so all of this part with the pink color
31:38 - now
31:39 - and essentially what is happening if
31:41 - we're turning a mask back into a surface
31:44 - is that any pixels with a one so all of
31:47 - the white bits here are becoming a white
31:49 - part in the new surface and all the
31:51 - pixels with a zero are becoming black in
31:54 - the new surface
31:55 - so essentially what we are doing is we
31:57 - are turning all the visible pixels in
31:59 - our original surface into a white color
32:02 - and all the invisible pixels into a
32:04 - black color we are basically creating a
32:06 - silhouette from our original surface
32:09 - so now what we have to figure out is how
32:11 - to color in this thing and the first
32:14 - thing that we have to do is to get rid
32:15 - of the black color and this can be done
32:18 - quite easily all we need is the new
32:20 - obstacle surface and then the method set
32:23 - underscore color key
32:26 - and this needs an rgb tuple
32:29 - and the rgb tuple is going to specify
32:31 - which color in this surface should
32:33 - disappear and in my case that is pure
32:35 - black so 0 0 and 0.
32:38 - and now let's see what we get
32:42 - we get well a white color i guess the
32:45 - white background color isn't
32:46 - particularly helpful here let me change
32:49 - this to a gray so we can see a bit
32:51 - better what's happening
32:52 - and now
32:53 - if i run all of this again we can see a
32:56 - white alpha
32:57 - and this is this new obstacle so if i
33:01 - comment this out
33:02 - we can see the original let me move to
33:05 - the side so what we can see right now
33:08 - is the alpha of the original obstacle
33:10 - surface and right now we basically
33:13 - turned this surface into a white color
33:15 - so that's a pretty good start i suppose
33:18 - but now how can we change this to any
33:20 - color that we want
33:22 - because you probably don't want this to
33:24 - be white all the time you might be kind
33:26 - of tempted to go with something like new
33:28 - obstacle surface dot fill
33:31 - and then fill it with the color you want
33:32 - to go for let's say red in this case
33:35 - if i do this let's run this it's not
33:38 - going to work because the pixels
33:41 - that we have hidden here are just that
33:44 - they're hidden they're still there we
33:46 - just can't see them
33:48 - so if we are filling the entire surface
33:50 - these pixels are being filled in as well
33:53 - so this does not help so let me get rid
33:56 - of it because it really doesn't help us
33:58 - all that much
34:00 - what we actually have to do is a tiny
34:02 - bit more complex and let me explain it
34:04 - first
34:05 - essentially what we have to do is we
34:07 - have to go for every single pixel of
34:09 - this new obstacle surface and check if
34:12 - the color of that pixel is white and if
34:14 - that is the case we are going to change
34:16 - that pixel to a specific color and this
34:19 - we are going to do for every single
34:21 - pixel of the surface
34:23 - and we can quite easily identify the
34:25 - visible pixels because they are all
34:27 - white but in a normal surface with
34:29 - different colors this would be
34:31 - significantly more difficult
34:33 - and this is why we are using a mask in
34:35 - here i guess let's have a look at
34:38 - turning every single pixel of this new
34:40 - surface into a specific color
34:42 - so here i am back in the code and let's
34:45 - add a new section
34:47 - and let's call it filling in the surface
34:51 - with a color
34:53 - and now we have to figure out a couple
34:55 - of things the most important one is we
34:58 - have to figure out the size of our
34:59 - surface
35:00 - and this is well quite easily done we
35:03 - can get the size of our surface with new
35:05 - obstacle serve and get underscore size
35:09 - and this is going to return a width and
35:10 - a height
35:12 - and in our case this is what we can
35:13 - capture let's call it surf underscore w
35:17 - and serve
35:18 - underscore
35:20 - h
35:21 - for surface width and surface height
35:23 - and this information we can use to loop
35:26 - over every single point so for x in
35:29 - range
35:31 - surface
35:32 - with
35:33 - and then for y in range
35:37 - serv h and i guess just to illustrate
35:40 - what is happening here let's print all
35:42 - of this so print let's turn it into an f
35:44 - string
35:46 - where we have x
35:48 - let's do it like this so it's actually
35:51 - working let's call it x and we get
35:56 - y
35:57 - and let's run this
35:59 - and we basically get
36:02 - all the numbers from 0 and 0 then we
36:04 - increase the y all the way to 49
36:08 - oh no this one is larger so we get
36:10 - significantly more numbers we go all the
36:13 - way to
36:14 - [Music]
36:16 - quite a bit there we go
36:18 - so the alpha is 599 pixels high and
36:22 - this is then going to be our first
36:24 - go through and once we have that we
36:27 - start with x being 1 and then we do the
36:29 - same thing so we literally go through
36:30 - every single pixel of the alpha surface
36:33 - so this is working quite well
36:36 - now this information i can use to check
36:38 - every single pixel of this alpha surface
36:41 - and this happens with if
36:44 - my new obstacle surface
36:46 - and then get at
36:49 - and all this method is doing is it looks
36:51 - at a certain pixel and then gives me the
36:53 - color and this one needs an x and a y
36:56 - coordinate and this is going to look at
36:58 - a single pixel in our surface and it's
37:01 - going to return a color argument
37:04 - now in my case i know the color argument
37:06 - it will return for the visible pixels
37:08 - will be 255 255 and 255 short for white
37:12 - color
37:14 - so in my case really all i need to do is
37:16 - pick one of those and check if those are
37:19 - different from zero
37:21 - so i know that this pixel is white and
37:24 - well if it's any other color i know it's
37:26 - supposed to be invisible
37:28 - and once i have that information
37:30 - i can get my new obstacle surface again
37:33 - and then run set at
37:36 - which kind of does the similar thing
37:38 - what geta does except now we don't get a
37:40 - color we are setting a color
37:42 - and it needs again
37:45 - it to build with the x and the y
37:47 - argument
37:48 - and besides that it also needs a color
37:50 - argument and in my case i just want to
37:52 - go with orange
37:54 - and now if i run all of this
37:58 - we get an orange alpha
38:01 - so this is working quite well and sadly
38:04 - the logic here does get a tiny bit more
38:06 - complex
38:08 - so i would recommend you to go over this
38:10 - a couple of times just to make sure you
38:12 - understand the logic
38:13 - but really all we're doing is that we
38:15 - are looking at every single pixel of
38:17 - this alpha
38:18 - and if the pixel is white we are turning
38:20 - it orange and if it's any other color so
38:23 - in this case black we are just going to
38:25 - ignore it
38:27 - and that way we can turn the new mast
38:29 - surface into any color that we want
38:31 - while also ignoring the background black
38:35 - and the reason why we couldn't use the
38:38 - original mask is essentially this bit
38:40 - here
38:42 - because for surface generated from a
38:44 - mask we know that this position is
38:46 - always going to be white
38:48 - but in any other surface with various
38:50 - colors we couldn't guarantee this so we
38:53 - would always have the risk of one pixel
38:55 - accidentally being the wrong color and
38:57 - then it becomes invisible which would
38:59 - look very strange and the mask just
39:02 - ignores all of this
39:04 - and this is why we are going to use it
39:07 - now with that we can color in an entire
39:10 - surface and this is going to work with
39:12 - pretty much any kind of surface
39:14 - so this is quite good
39:17 - so then let's talk about how to give a
39:20 - surface an outline and there are two
39:23 - ways of doing this
39:24 - one that is very easy but also not
39:27 - exactly great then there's a slightly
39:29 - more complex one that well works much
39:32 - better and i guess it's best to explain
39:34 - both of them straighten the code that
39:36 - should make the most sense
39:39 - alright so here i am back in the code
39:42 - and the first thing i want to do is to
39:44 - comment out all of this because we are
39:46 - not going to need it for now
39:48 - but later on we are going to need it so
39:51 - don't delete it just yet
39:53 - and then also in the game loop i want to
39:56 - comment out the screen blit so if you
39:58 - ignored the commented out parts we are
40:01 - basically back to square one where we
40:03 - only have our alpha surface
40:05 - although we still keep our obstacle mask
40:09 - and now let's start with the first way
40:11 - to create an outline and this happens
40:13 - straight in the game loop and let me add
40:16 - a section here and let's call it the
40:18 - simple way to create an
40:21 - outline from a
40:22 - mask so basically what we can do in here
40:26 - is that every single mask including our
40:28 - obstacle mask
40:30 - have one specific method that is called
40:33 - outline
40:34 - and well this gives us the outline it's
40:37 - well quite straightforward
40:39 - and let's have a look what it gives us
40:41 - so if we run out of this
40:42 - we get a whole bunch of points
40:45 - right now they don't really tell us all
40:47 - that much
40:48 - but basically these points if i draw
40:50 - them in
40:51 - are all the points that are surrounding
40:54 - this alpha
40:56 - so if i drew all of this
40:59 - it will keep on going all the way let me
41:01 - speed this up a tiny bit
41:05 - so these are all the surrounding points
41:07 - ignore this bit it shouldn't look more
41:09 - like this now importantly what you have
41:12 - to be aware of that it does not give us
41:15 - the point inside of the alpha we only
41:17 - get the purple points outside of the
41:19 - surface if there's a hole inside of the
41:22 - surface it's not going to work we're
41:24 - going to fix that later with a different
41:26 - method
41:27 - but well now that we have that
41:30 - really all we have to do
41:33 - let me close this all we have to do is
41:35 - go for every single one of these points
41:37 - and draw a specific pixel in this
41:39 - position so what i can do is add for
41:42 - loop with four
41:45 - point in my outline
41:48 - and in here i want to use
41:49 - pygame.draw.circle
41:54 - let me spell this properly as well that
41:55 - might help
41:56 - and this needs our screen so the surface
41:59 - we want to draw on then we need a color
42:02 - in my case it's going to be red
42:04 - and then we need an x and a y coordinate
42:07 - we are going to create those in just a
42:09 - second
42:10 - and then we need a size let's say in my
42:12 - case a 3. oh well it's a radius it's
42:15 - looking for here
42:17 - so now we have to create an x and the y
42:19 - coordinate so it's going to be x and
42:21 - it's going to be y
42:23 - i guess we haven't done an exercise in a
42:25 - while so what i want you guys to do is
42:28 - to figure out the x and the y coordinate
42:30 - so try playing around with the outline
42:33 - points and see how far you get it really
42:36 - shouldn't be all that difficult
42:42 - so the first thing we need is the actual
42:45 - point and this point right now is a
42:47 - tuple with x and y and we want the first
42:50 - one so the x point
42:52 - and then for y we want to do the very
42:55 - same thing except now we want the first
42:58 - one
42:59 - and i guess now let's actually try this
43:02 - and this is almost working so we do get
43:06 - an outline but it misses the offset and
43:10 - the reason for that is remember
43:12 - a mask does not have any positioning
43:15 - information so the top left of the mask
43:18 - is basically always zero and zero
43:20 - and the same for a surface actually so
43:23 - this obstacle surface is only in the
43:25 - middle of the screen because we have the
43:27 - obstacle position and this one is 100
43:30 - and 100
43:32 - and this 100 and 100 we basically have
43:35 - to add to these points here and this is
43:38 - also very easily done all we need is the
43:41 - obstacle position
43:43 - with zero and then i can copy all of
43:46 - this and set it to one so that both the
43:49 - mask outline and the surface have the
43:51 - same offset
43:52 - so now let's run this again and there we
43:55 - go we have an outline
43:57 - if you have very simple surfaces this is
43:59 - already enough for most purposes
44:02 - actually so if you need nothing fancy
44:04 - this should work by itself
44:06 - and you could even make this a bit more
44:08 - pronounced let's say by giving it a 10
44:10 - although it might be a bit too much i
44:12 - guess it still works
44:14 - so now we can see it quite a bit more or
44:16 - if you set this to let's say a 2 or even
44:18 - a 1
44:20 - now it is significantly more subtle
44:22 - although the obvious problem is let me
44:24 - write again actually that if you want to
44:27 - color in the inner part the outline
44:30 - would never be able to do that so
44:33 - for this we would need a different
44:34 - approach but this one isn't that much
44:38 - more difficult it's just a bit more
44:40 - writing intensive
44:41 - and let me explain in theory what we are
44:43 - going to do
44:45 - essentially we are going to use again
44:47 - our filled in surface so the one we
44:50 - created in the first part of this
44:52 - section
44:53 - and this new surface we are going to
44:55 - blit multiple times behind our original
44:58 - surface
45:00 - and we are going to blit it in every
45:01 - single direction so left right up and
45:04 - down and then top right bottom right
45:06 - bottom left and top left and that way we
45:09 - are going to create an outline that is
45:12 - filling every single hole so let's jump
45:15 - straight back into our code and let's
45:17 - have a look at this
45:18 - so here i'm back in what we created
45:21 - earlier and the first we want to do is
45:23 - to let's comment out all of this so we
45:27 - can't see it anymore so again we are
45:29 - back to our alpha
45:32 - now what i want to do is to get back
45:34 - this part and this part
45:38 - and i also want to
45:39 - blit all of this again so now if i run
45:42 - the code we get back our orange alpha
45:46 - but now i don't want to have this alpha
45:50 - after the obstacle surface i want to run
45:52 - this one before
45:55 - and now what we get
45:57 - is well we can't see it anymore because
45:59 - it's behind the alpha
46:01 - but now what we can do is to mess with
46:03 - the position
46:04 - and let me actually demonstrate how this
46:07 - is going to look like so i can set my
46:09 - obstacle position with zero
46:11 - and my obstacle position
46:14 - with
46:15 - one so by itself this is not going to
46:18 - make any difference so if i run this
46:20 - same result
46:22 - but now what i could be doing is to
46:23 - change this position
46:25 - and give it an offset let's say 10
46:28 - and what we can see now
46:31 - is now we have a color to the right of
46:34 - the alpha all we have to do now is to
46:36 - apply this
46:38 - to every single of the eight sides we
46:40 - could possibly move in
46:42 - and
46:43 - well let me put this into a section to
46:45 - keep it simple so let's call it the
46:49 - complex way
46:50 - for a
46:52 - outline
46:54 - and in here since we are going to reuse
46:57 - this offset quite a bit i'm going to put
46:59 - this into a separate variable and let's
47:01 - call it offset
47:03 - and let's put it at 10.
47:05 - so we first have
47:07 - the offset to the right and i am
47:09 - incapable of spelling offset
47:12 - and now
47:13 - let me give a bit of space we have to
47:15 - copy this thing eight times
47:18 - so let me do the first four
47:20 - this one is moving to the right
47:22 - let me actually add a comment afterwards
47:24 - so we can see what's going on so this
47:25 - one is to the right and this one is
47:28 - going to be to the left so all we need
47:30 - for that is negative the offset
47:34 - and now if i run this
47:36 - we have a left and a right offset or
47:38 - well a kind of an outline
47:41 - and now we can copy this again
47:43 - and let's put this one at top
47:47 - now for this bit we don't need an offset
47:49 - in the x at all instead we need one for
47:52 - the y
47:53 - and now if i run this
47:55 - we can see we now have a top part
47:58 - although if you pay close attention you
48:00 - can see that we have this ugly bit and
48:03 - this ugly bit and these can only be
48:06 - fixed if we're moving the background to
48:08 - the top right and to the top left
48:10 - there's no fixing this if we just move
48:12 - up and left and right this is why we're
48:14 - using the other directions you can see
48:16 - it down here as well it looks really
48:18 - ugly there
48:20 - but we're going to fix those in a bit
48:25 - now before that we have to copy this
48:26 - thing one more time
48:28 - and now the offset is going to be plus
48:31 - because this one is
48:33 - the bottom
48:34 - and now if i run this
48:36 - we have a kind of working background and
48:40 - importantly here
48:41 - now we have a filled inside so this is
48:45 - covering every single hole inside of our
48:47 - surface so now what we have to do is to
48:50 - actually fix these bits here
48:52 - and this bit here
48:54 - and this is done by well
48:58 - continue going on and let me actually
49:00 - add proper white space here
49:02 - so now let's start this one with the top
49:06 - right
49:06 - now first of all since we're going up
49:09 - this has to be negative
49:10 - and since we're going to the right like
49:12 - in this part here we need this offset as
49:15 - well so let me add it here and now if i
49:17 - run this
49:19 - now you can see that we have fixed this
49:22 - part up here
49:24 - and i guess this part down here as well
49:28 - so now we can do the same thing for the
49:30 - bottom right and the bottom right is
49:33 - going to be a plus here so this is going
49:35 - to be the
49:37 - bottom right
49:39 - then we can do the same thing for the
49:41 - bottom
49:42 - left and this is just going to be
49:45 - negative for the x
49:47 - and finally
49:48 - we get the
49:50 - top left
49:52 - and for this we just need a negative
49:55 - offset for the y
49:56 - now if i want all of this
49:58 - we have a much nicer looking outline and
50:01 - i guess this one is a little bit thick
50:03 - so let's change to 10 to a four let's
50:07 - see how that looks
50:09 - yeah that is significantly better so
50:11 - this is a much nicer looking outline
50:13 - that you will probably want to rather
50:15 - use in the game or well depending on the
50:17 - complexity of your surface i guess and i
50:19 - guess you could simplify this with a
50:21 - smart for loop but in my case i'm not
50:23 - going to worry about it but it's
50:25 - something to keep in mind if you have an
50:27 - actual game
50:28 - but with that we have outlines and we
50:31 - have the ability to fill in the shape so
50:34 - that's another project done so we're
50:36 - almost finished there's one more project
50:38 - to go and this one is the most
50:40 - interesting one
50:42 - because for this one we're going to
50:44 - color in only the parts of a surface
50:46 - that are overlapping with another
50:48 - surface which is a really interesting
50:50 - effect for basically any kind of game
50:53 - and is a really good way to understand
50:54 - how a mask is going to work
50:57 - so let's talk about how this project is
50:59 - going to work and in the most basic
51:02 - sense it's essentially a combination of
51:04 - project 2 and project 3.
51:06 - so from project two we are going to get
51:08 - the overlap method except now we are
51:11 - going to use overlap mask and this one
51:14 - is going to give us the overlapping mask
51:16 - between well one mask and another
51:19 - and then from project number three we
51:22 - are going to turn this new mask into a
51:23 - surface and color every pixel in and
51:26 - that's literally all we are going to
51:28 - need it honestly isn't that much of a
51:30 - complicated project
51:32 - so let's jump straight into the code and
51:35 - let's have a look at this
51:37 - here i am back in the code and i already
51:40 - have a couple of things set up
51:42 - let's talk through them really quick it
51:44 - shouldn't take too long
51:46 - now as always here we have the usual
51:48 - setup now besides that we have the ship
51:51 - setup and the alpha setup and for the
51:54 - ship we have a surface a rectangle and a
51:57 - mask and be aware i already imported the
52:00 - mask this is the step we haven't done
52:02 - earlier now for the obstacle we have a
52:05 - surface a position and a mask
52:08 - and this is pretty much the same thing
52:09 - we had before so all of this should be
52:11 - fairly simple now then here we have the
52:14 - usual event loop and we are adding a
52:17 - background now a bit further down
52:20 - really all we are doing here is we are
52:22 - drawing the background then we are
52:24 - getting the mouse position and placing
52:25 - our ship and then we are updating
52:27 - everything so all of this should be
52:30 - pretty easy at this point with that we
52:33 - can get started to get all the stuff
52:35 - ready to actually get the mask first
52:39 - and let me add a new comment here and
52:42 - let's call this the
52:44 - new
52:45 - mask surface
52:47 - coloring
52:48 - i guess that makes sense i'm kind of bad
52:50 - at naming stuff but anyway
52:52 - now the first thing that we do have to
52:54 - check is if there's a connection between
52:56 - our ship and the obstacle and this
52:59 - happens again with an if statement so if
53:01 - ship mask dot
53:04 - overlap
53:05 - with our obstacle mask
53:09 - then
53:10 - we want to do stuff so let's call do
53:14 - stuff
53:15 - now there's one thing i did forget here
53:17 - and i hope you remember because what we
53:20 - need in here is in a tuple an x and a y
53:26 - and both of these should be an
53:28 - offset
53:30 - so we again have to get an offset
53:33 - one for x and one for y
53:37 - and let's see if you can remember what
53:38 - we have done in the second project so
53:41 - pause the video now and try to find
53:43 - these two offsets
53:49 - let's try together now
53:51 - and i guess let me write on both
53:53 - at the same time that should save a bit
53:55 - time now first of all we need to
53:57 - obstacle position and in here we need x
54:01 - or y i'm going to add those in a second
54:04 - and from those we are going to subtract
54:06 - the ship rect
54:08 - and then
54:09 - for
54:12 - the x position it's going to be left and
54:14 - zero so this is going to be x and for
54:16 - the y position it's obstacle position
54:18 - one and shipwrecked dot top
54:21 - so check out the earlier part to
54:23 - understand the logic here at this point
54:25 - it shouldn't be too difficult or at
54:26 - least i hope it won't be
54:28 - so now we can tell if there's a
54:31 - collision
54:32 - and let's just check if this is actually
54:34 - working
54:35 - just to make sure i didn't make a
54:36 - mistake like i did with the typing
54:39 - so now let's try this and we are getting
54:42 - a collision cool so this is already
54:44 - working
54:45 - nice start
54:47 - so now we know when there is a collision
54:50 - from this line here whenever this
54:52 - happens we want to create a new mask
54:55 - from the overlap between our ship and
54:57 - the obstacle and this i also want to
54:59 - store in a new variable and let's call
55:01 - it new
55:03 - mask
55:04 - and to get this one we again need our
55:07 - ship mask
55:08 - and then
55:09 - overlap
55:10 - but this time we are going to add mask
55:15 - and this is going to return the
55:16 - overlapping mask between these two
55:19 - objects here
55:21 - and it is going to need some arguments
55:23 - although the arguments are exactly the
55:25 - same that we have used before so i can
55:28 - just copy paste them and we are good to
55:30 - go
55:31 - so i guess what we can do now let's just
55:34 - print new mask and let's see what we get
55:38 - and now if i touch the alpha we get a
55:40 - mask that has this dimension
55:43 - and well we don't really have to worry
55:45 - about the specific details here but we
55:47 - know
55:48 - we are getting a mask so that's a pretty
55:50 - good sign
55:51 - and now we have to pick up the stuff we
55:53 - learned from the first project
55:55 - so we are going to turn this mask into a
55:59 - surface and then on this new surface
56:02 - we're going to go for every single pixel
56:04 - and color this pixel in a certain color
56:07 - so what we need first is let's call it
56:09 - new surface
56:12 - and this is going to be new mask dot 2
56:15 - underscore surface
56:18 - and this does not need any arguments
56:21 - and all right now we have a surface and
56:24 - i guess what we can do now
56:27 - is to actually blit this new surface and
56:30 - this should happen
56:32 - inside of this if statement let me
56:34 - actually demonstrate so what i want to
56:37 - do now is screen dot blit
56:40 - and i want to get my new surface
56:44 - but now i am also going to need a
56:46 - position
56:49 - and ideally this should be a rectangle
56:51 - unfortunately i do because this ship
56:54 - rectangle here we can totally use in
56:56 - here because the new mask we are
56:59 - creating is going to be essentially the
57:01 - same size as the ship
57:03 - so let's actually try how this is going
57:05 - to look so we are just going to use the
57:07 - ship
57:08 - rectangle
57:09 - so now let's try how this is going to
57:11 - work
57:12 - and now if i touch the alpha
57:14 - the ship turns black
57:16 - but if my ship goes over the alpha
57:18 - we can see the silhouette of the ship so
57:22 - this is working really
57:24 - well and now what we can also do for
57:28 - this new surface we can set a color key
57:31 - so i want to get my new surface
57:35 - and then i want to set my color key
57:39 - and the color i want to get rid of is 0
57:41 - 0 and 0. so the color black and let's
57:44 - add a bit of space here
57:46 - and now let's try this again
57:48 - and now
57:49 - when my ship touches the alpha
57:52 - we can see that we are just getting a
57:54 - white color so this is already working
57:57 - really really well so that's a pretty
57:59 - good sign so now all we really have to
58:02 - figure out is how to change this white
58:04 - color to essentially any color that we
58:06 - want to have
58:07 - and this is what we learned in the third
58:09 - project
58:11 - so let me give a bit more white space
58:14 - and before i start i would really
58:16 - recommend you to try this yourself
58:19 - because if you look at the passcode
58:21 - implementing this really shouldn't be
58:23 - all that difficult and it would be
58:24 - really good practice i think so try this
58:27 - yourself and see how far you get
58:33 - first of all we need a surface width and
58:36 - a surface height
58:39 - and this we get from our new surface
58:42 - and then get underscore size and this is
58:45 - going to return a tuple that we need for
58:47 - the width and the height
58:49 - now next up i want to go for every
58:51 - single pixel in the width and the height
58:54 - so for x in range
58:56 - surface width
58:58 - and inside of there for y in range
59:02 - surface
59:03 - h
59:05 - and now inside of here i want to check
59:08 - if my
59:10 - new surface dot get at
59:13 - so i want to check one specific pixel
59:15 - inside of this new surface
59:17 - and this should be at a position x and y
59:21 - and if this is white it's going to be
59:23 - 255 255 and 255 as a tuple so i can
59:27 - literally pick any number from this and
59:30 - check if this is different from zero if
59:33 - it is we know there's a pixel if it
59:35 - isn't we know it's going to be invisible
59:37 - or well black
59:39 - so now once we have that
59:42 - all we have to do is get our new surface
59:46 - and then set underscore at
59:49 - get our x and y again
59:52 - and now all we have to do is to pick one
59:55 - specific color let's say my case let's
59:58 - go with red
60:00 - and now let's try all of this
60:04 - and you can already see it now this is
60:06 - working pretty well
60:09 - so with that we have a ship that shows a
60:13 - outline that we can only see if it
60:15 - overlaps with the alpha
60:17 - so
60:18 - really wasn't all that difficult to
60:20 - implement i think
60:22 - so this is actually working really well
60:24 - cool
60:25 - so i hope that was helpful and i will
60:27 - see you around