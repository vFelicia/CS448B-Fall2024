00:00 - hello there in this video we are going
00:03 - to cover image manipulation with pillow
00:05 - in python
00:07 - and what we are going to do is we are
00:10 - going to take this image and we are
00:12 - going to change it a lot in a lot of
00:14 - different ways
00:16 - and after you have done all of this you
00:18 - should have a really good understanding
00:20 - of the pillow module i am basically
00:23 - going to cover all of it or at the very
00:25 - least i am going to cover all the
00:27 - important bits
00:28 - and the pillow module ultimately is
00:30 - fairly simple it just does have a lot of
00:32 - methods that you could be using
00:35 - i guess we can cover that when we
00:37 - actually work in code
00:39 - which i guess we can do right after
00:42 - installing pillow because it doesn't
00:43 - come with python by default
00:45 - and this is going to happen either in
00:47 - the powershell or on the terminal in my
00:49 - case i'm using the powershell because
00:51 - i'm on windows and in here you need pip
00:54 - install
00:56 - hello
00:57 - if you run this
00:58 - you can see some download
01:00 - and you have it installed
01:03 - if you're using a mac you should be
01:05 - typing pip free install pillow
01:09 - and you should be getting the same
01:10 - result
01:12 - pillow works both on windows and on mac
01:14 - os and on linux it's pretty flexible
01:16 - overall
01:18 - and alright with that we have it
01:19 - installed let's start with the first
01:21 - part
01:23 - and what we are going to start with is
01:24 - the basics of pillow and in here there's
01:28 - one really important concept
01:30 - and that is the image object
01:33 - this is basically where all of the
01:35 - actual image information is stored and
01:38 - this is what we're using to change save
01:40 - and display it
01:42 - basically what we are going to do for
01:43 - this entire video we are always going to
01:46 - have some kind of image object and this
01:48 - is what we are actually working with
01:51 - and i suppose we can actually create
01:53 - this straight away
01:54 - alrighty here we have a completely empty
01:58 - python file and the first thing i want
02:00 - to do is from pil that's the pillow
02:03 - library i want to import
02:06 - image and make sure here the first
02:09 - letter needs to be capitalized that is
02:12 - really important
02:14 - and once you have that you actually want
02:16 - to create an image and this you can do
02:19 - in two different ways let me add
02:21 - comments to make this a bit more
02:22 - organized the first way to create an
02:25 - image object is to create new image by
02:29 - import
02:31 - and for that we just need image.open
02:35 - and then the name of a file
02:38 - in my case my folder setup right now
02:40 - looks like this
02:42 - i have two images called picture and
02:44 - python and then i have my code so all of
02:47 - the project is in one folder which makes
02:50 - it kind of easy to access things all i
02:52 - really need is the name which in this
02:54 - case is going to be picture and don't
02:56 - forget the file ending in this instance
02:58 - this is jpg
03:00 - and now this is going to return an image
03:03 - object and this we want to save in the
03:05 - variable let's call it image
03:09 - and now if you run the code we are not
03:11 - getting an error that is looking pretty
03:13 - good
03:14 - and this image object we can now work
03:17 - with and at least for this video what we
03:19 - are going to do a lot is to just show
03:22 - the
03:23 - picture and this happens with image dot
03:26 - show
03:27 - if i run the code now we can see a
03:29 - preview of the image
03:31 - you can also
03:32 - as an argument inside of show add a name
03:35 - for the image you want to display
03:38 - let's say in this case red panda
03:40 - although if i run this again now
03:43 - you can't really see any kind of
03:45 - difference the reason is that this needs
03:48 - to be supported by the image viewer on
03:50 - your computer
03:51 - which usually is not the case and it
03:53 - really doesn't make much of a difference
03:56 - so most of the time there's no argument
03:58 - inside of show and well with that we
04:01 - already have the ability to import an
04:03 - image
04:04 - although what you see fairly often
04:06 - online is let me call it an alternative
04:09 - way to
04:11 - import an image
04:13 - is something like with image dot open
04:17 - ideally spelled correctly
04:20 - and then the file path
04:23 - which again is going to be picture dot
04:25 - jpeg
04:27 - and then as image
04:30 - and then in here we can work with this
04:32 - image for example i could
04:34 - run image.show
04:37 - and this code here i guess let me put it
04:40 - below show
04:43 - picture
04:44 - this here and this here functionally
04:47 - does the same thing we are importing an
04:49 - image and we are showing it to the user
04:52 - i suppose this approach here is a little
04:54 - bit cleaner because we are more specific
04:56 - when we are using the image but most of
04:59 - the time you are going to see something
05:01 - like this as a consequence let me
05:03 - comment it out and let me put it right
05:06 - below creating the image i think that
05:09 - makes the most sense
05:10 - so with that we can create an image by
05:12 - importing it alternatively you can also
05:16 - create a new image from scratch
05:20 - and this you would do with image.new
05:23 - and in here we are going to need two
05:25 - arguments the first one is the format
05:27 - the second one is the size
05:29 - format is something like rgba or rgb or
05:34 - whatever kind of color format you are
05:36 - going to look for a pillow supports most
05:39 - of them
05:40 - if you are completely new to colors and
05:42 - images rgb stands for red green and blue
05:46 - for every pixel of the image we having
05:48 - an amount of red an amount of green and
05:50 - amount of blue and we are mixing these
05:52 - three colors to get a new color for each
05:54 - pixel
05:55 - and a in this case stands for
05:57 - transparency meaning the image we have
05:59 - could also have some transparent bits
06:02 - usually rgba here is the safest option
06:05 - and for size we are looking for a tuple
06:08 - with the width and the height
06:10 - let's say in this case i want a width of
06:12 - 1000 and a height of 600.
06:15 - and this image again we can save in a
06:17 - variable
06:19 - let's call it image blank because right
06:21 - now this is just going to be black
06:23 - because we didn't add anything to it
06:26 - and now at the end i can get my image
06:28 - blank and show it if i run the code
06:31 - we can see a black screen
06:34 - and well with that we have covered how
06:36 - to create a new image
06:39 - we can also show it another thing that
06:41 - we can do besides showing it is saving
06:43 - the
06:44 - picture
06:46 - and this happens let's say i want to
06:49 - save this image here
06:51 - for that i need image dot save
06:54 - and in here i now need a string with the
06:58 - new name let me call it test underscore
07:02 - save
07:03 - and now really important
07:05 - you want a dot and then the file format
07:08 - for example if you want a png image you
07:10 - want to add png
07:12 - if you wanted a jpg you would add jpeg
07:14 - and so on and now let me comment out the
07:19 - show part and run the code now
07:22 - nothing happens but we don't get an
07:24 - error but now if i look at my folder
07:27 - again this one here
07:29 - besides picture we also have test save
07:32 - now
07:33 - and this is a png file
07:36 - meaning we have actually just covered
07:38 - how to convert different images using
07:39 - pillow we have started with a jpeg file
07:43 - and we end it with a png file and this
07:46 - would also work with other image formats
07:48 - image.save is quite flexible to just
07:51 - save in whatever format you need you
07:54 - could even be more specific and specify
07:57 - a format here for example something like
07:59 - png although most of the time you are
08:02 - not going to need it
08:03 - and with that we have all of the basics
08:06 - i guess there's one more thing we can
08:08 - cover for this section and that is image
08:12 - information
08:14 - and for this part all i really want is
08:16 - to get some basic information about the
08:18 - image for example i could print
08:21 - image.size that is probably the one you
08:24 - are going to use the most
08:25 - and let me comment out the safe line
08:28 - and run the code now and we get the size
08:31 - of the image is 1920 by 1280
08:34 - and image has a few more things that you
08:37 - can look at
08:38 - there is for example file name
08:41 - there is format
08:44 - and there is format underscore
08:46 - description
08:49 - that is horrible spelling
08:51 - and if i run this now we're getting
08:53 - quite a bit of information about the
08:55 - image we just imported
08:57 - and well with that we have covered all
09:00 - of the really basic parts of pillow at
09:03 - least to access an image
09:05 - obviously not particularly useful
09:07 - so let's start with some basic
09:09 - manipulation
09:11 - we are going to do some basic
09:13 - manipulation and what we are going to do
09:16 - is rotate flip prop and scale and we are
09:19 - also going to create a thumbnail which
09:21 - is just the smaller image you would use
09:23 - for previewing
09:24 - all right here i have another python
09:27 - file and i have already imported one
09:30 - image the same image of the red panda we
09:32 - have seen earlier
09:33 - and now i want to manipulate it in a
09:36 - couple of different ways
09:38 - i suppose we can start with rotating the
09:41 - image
09:42 - and all we need for that is the image
09:44 - itself and then dot rotate
09:47 - and in here we can specify
09:50 - an angle
09:51 - for example i could rotate the image by
09:53 - 60 degrees
09:55 - and the result is going to be another
09:58 - image and this image i want to save
10:00 - let's say in a variable called image
10:03 - rotate
10:04 - and with that we have rotated the image
10:09 - let me display it so image rotate dot
10:12 - show and if i run the code now
10:15 - we can see we have rotated the image by
10:17 - 60 degrees
10:20 - and in here i can add any other number
10:22 - for example 10 degrees
10:24 - would look like this
10:26 - and if i added something like 190
10:28 - degrees
10:29 - it would look something like this i
10:32 - suppose i can leave it at 60 degrees
10:35 - this one looked pretty okay although we
10:38 - do have a problem that right now we are
10:41 - cutting off the image you can see it
10:42 - here for example or on the other side
10:45 - here as well
10:47 - and this isn't ideal we are losing
10:49 - picture information
10:51 - also right now the entire background is
10:53 - black
10:54 - and for all of that pillow has a couple
10:57 - more things that we can do
10:59 - and all of those happen inside of the
11:01 - arguments for rotate
11:03 - for example what you could be specifying
11:05 - in here is expand and if you set this
11:07 - one to true and run the code again
11:10 - now
11:11 - we are expanding the entire image to
11:14 - cover
11:15 - these parts that we cut off earlier
11:19 - obviously as a consequence you are going
11:21 - to have a larger image but you are not
11:23 - losing any image information which is
11:25 - quite nice
11:27 - and to figure out what else you can do
11:29 - you can look at the documentation
11:32 - let me actually add it right here
11:34 - documentation
11:35 - you can find this one under this link
11:38 - and if i open this one
11:40 - we are getting a pretty long list of
11:44 - different things that the image module
11:46 - can do
11:47 - right now rotate is the only one i care
11:49 - about and in here all we have seen so
11:51 - far is angle and expand
11:54 - you could also use fill color to fill
11:57 - the background you can add some
11:58 - translation you could change the center
12:01 - you can do a ton of different things in
12:02 - here
12:03 - i suppose fill color is the one that we
12:06 - are caring about the most right now
12:08 - so let's have a look at that one
12:11 - meaning what i want to do is to add fill
12:13 - color here
12:15 - and now we need some color information
12:18 - and the simplest way to approach this is
12:20 - using a tuple with r g and b values
12:25 - and what we are doing in here is we are
12:28 - specifying the amount of red the amount
12:30 - of green and the amount of blue for
12:33 - every individual pixel
12:35 - and for each of these we can choose a
12:36 - value between 0
12:38 - and 255
12:41 - meaning if i choose 255
12:45 - 0
12:46 - and 0
12:48 - i only have red i have no green and no
12:51 - blue if i run the code now
12:54 - the entire background is going to be red
12:56 - because we only have red
12:59 - if i added 255 for all of them
13:03 - i would get white
13:05 - although this also is kind of annoying
13:08 - to work with because ideally we want to
13:10 - use real words for colors we don't just
13:13 - want to work with individual numeric
13:15 - values
13:16 - and for that pillow is happy to help you
13:19 - because we can import image and color
13:23 - and this is giving us access to a lot of
13:25 - different colors out of the box
13:28 - for example i could use image color dot
13:31 - get
13:33 - color
13:34 - and now for this one i can specify a
13:37 - color for example red
13:39 - and then the format i want and this in
13:41 - my case is going to be rgb
13:44 - and if i run this now we are getting the
13:47 - same outcome
13:48 - be aware here
13:50 - this line of code is just returning an
13:53 - rgb tuple it's more or less a dictionary
13:57 - i guess i can demonstrate this a bit
13:59 - better if i copy it and just print
14:02 - what this image color is returning if i
14:05 - run the code now and close the preview
14:08 - we are just getting an rgb tuple
14:10 - that's literally it it's nothing too
14:12 - complicated
14:14 - so all right with that i think we are
14:18 - pretty good on rotating images
14:22 - next up
14:23 - we can i guess we can work on cropping
14:25 - an image
14:27 - and for that i want image dot crop
14:30 - and this again is going to return an
14:33 - image and this i want to save as image
14:36 - crop
14:37 - and now the one important information we
14:40 - have to specify in here
14:42 - is a tuple with four bits of information
14:45 - and the four bits of information refer
14:47 - to positions
14:49 - the first one is the left x position
14:52 - then we have the top y position
14:55 - and we have the right
14:58 - x position
14:59 - and finally we have the bottom
15:03 - y position
15:05 - and i guess let me explain this in a bit
15:07 - more detail
15:08 - if this is our original image pillow
15:12 - declares that this top left point is the
15:14 - origin meaning this has the position 0
15:18 - and 0.
15:20 - and inside of this we want to specify
15:24 - some kind of rectangular shape to cut
15:27 - something out so this red area here is
15:30 - what i want to cut out and the size of
15:32 - this rectangle is determined by these
15:35 - four bits of information
15:37 - left x is this side here
15:41 - top y
15:42 - is this side here
15:44 - right x is going to be
15:47 - this side here and then finally bottom y
15:50 - is this side here
15:52 - and once we have specified all of these
15:54 - sides we have the entire size of the
15:57 - rectangle we want to cut out
15:59 - and let's do an example let's say i want
16:02 - to cut out the top left and the image i
16:05 - want to cut out should be 500 by 400
16:08 - pixels and this means that the left x
16:12 - should be 0 and the top y should be 0.
16:15 - the right x then should be 500 and the
16:18 - bottom y should be 400
16:21 - and if i bring this back on the image
16:24 - what we have created now let me undo a
16:26 - few things
16:28 - we are starting with 0 and 0 which is
16:31 - this point here
16:33 - and from that we are going 500 pixels to
16:35 - the right so the right side of the
16:37 - square we are cutting out is somewhere
16:39 - here
16:40 - and then the bottom part of the
16:41 - rectangle is 400 pixels which is
16:44 - somewhere here
16:45 - now that i have that
16:47 - i want to show my cropped image
16:50 - and if i run this
16:52 - we can see the top left of the image
16:55 - obviously not particularly helpful
16:59 - now to find the red panda in this image
17:02 - i already have a couple of numbers and
17:04 - those are looking like this
17:07 - and if i run the code now
17:09 - we can see the actual red panda
17:12 - so these are numbers you do have to play
17:14 - around with quite a bit to find just the
17:16 - right image you need
17:18 - but that is basically all you need for
17:20 - crop
17:21 - i suppose next up we can work on
17:25 - flipping the image
17:28 - or another way of putting this we can
17:30 - transpose the image
17:34 - and to get started i want my image flip
17:38 - horizontal
17:41 - and this i get with image dodge
17:44 - transpose
17:46 - in here i can pass in a ton of different
17:49 - arguments they're all part of the image
17:52 - module
17:54 - so make sure you capitalize this i here
17:56 - really important
17:58 - and inside of this we have transpose
18:02 - and inside of that we have all of our
18:04 - options
18:05 - for example in my case i want to flip
18:08 - the image
18:09 - from left to
18:11 - right
18:12 - and that way i am flipping this image
18:15 - here
18:17 - meaning now i can show that image run
18:20 - the code and we have flipped the image
18:24 - and along the same lines i can duplicate
18:27 - this line here and change this
18:29 - horizontal to vertical
18:32 - and to get the vertical flip
18:35 - we need top to
18:37 - bottom
18:38 - and now i can take this new image i can
18:41 - show it
18:42 - and there we go
18:44 - now the panda has to make sure it
18:45 - doesn't fall down
18:47 - and you do have quite a few more options
18:50 - these ones here
18:51 - i have used flip left right and flip top
18:54 - button you could also rotate the thing
18:56 - and it could transpose and transverse it
18:59 - transpose and transverse basically flip
19:02 - and rotate the image at the same time
19:05 - i honestly have no idea why you would
19:07 - ever want to use it but i guess let's do
19:09 - one example
19:11 - we can run image transpose
19:15 - and for this one we need image dot
19:19 - transpose
19:21 - and then again capital i image dot
19:24 - transpose
19:26 - and then inside of that i want transpose
19:30 - and this has to be all capitalized
19:32 - if i show this image
19:36 - we have the red panda rotated and
19:39 - flipped
19:40 - and again no idea why you would want
19:42 - this but you can do it
19:44 - all right and with that finally we can
19:47 - work on resizing the image
19:49 - this happens with image dot reset
19:53 - all that pillow wants in here is a tuple
19:55 - with the new width and a new height
19:58 - for example i could resize the image to
20:00 - 600 and let's say 1000
20:04 - and then save all of this in image
20:07 - underscore resize
20:09 - and if i
20:12 - show this image now
20:14 - we are getting the panda very much
20:16 - squashed
20:18 - and i guess the way you have to think
20:19 - about it that this is a very easy way to
20:23 - change the size of an image
20:25 - but it also is very
20:28 - prone to errors that you are ruining the
20:30 - aspect ratio of an image
20:32 - so a better way let me add a comment
20:35 - that example
20:38 - and better
20:39 - example
20:41 - you would usually want to add something
20:43 - like a scale
20:45 - factor
20:46 - let's say in my case i want to double
20:47 - the size of the image
20:49 - and now we are going to use this two to
20:53 - calculate the new size of the image
20:56 - and let me save this in a separate
20:58 - variable as well so new image size
21:02 - and this is supposed to be a tuple with
21:05 - a width and a height
21:07 - and we can get the size of the original
21:10 - image this we get with image dot size
21:13 - and for the width i want the first part
21:16 - of it or the one with the index zero
21:19 - and this i want to multiply with the
21:21 - scale factor and we have the new width
21:24 - and then i can copy all of this
21:27 - and instead of the width i want to get
21:29 - the height
21:31 - and once we have that i can get my image
21:35 - resize and let me call it better
21:38 - and here again i want to get
21:39 - image.resize
21:42 - and now i want to pass in the new image
21:45 - size
21:46 - and that way we are keeping the same
21:48 - aspect ratio
21:50 - so if i
21:52 - print the image
21:54 - resize better
21:56 - we shouldn't really see a difference
21:58 - except now this image is twice as big as
22:01 - the original
22:03 - a good way to illustrate this let me
22:06 - comment this part out
22:08 - and i want to image resize better and
22:12 - save this as
22:15 - double
22:16 - resolution
22:18 - and this should be a jpeg
22:21 - if i run the code now
22:23 - we get no errors that's usually a good
22:25 - sign
22:26 - and if i look at my folder
22:29 - my original image had the dimensions of
22:32 - 1920 by 1280 and the new one has 3840 by
22:36 - 2560 which is exactly twice the size of
22:39 - the original
22:40 - meaning this is working really well
22:45 - and with that we can cover filters and
22:47 - enhancements this is quite a bit more
22:50 - material although it is very easy to
22:52 - access essentially all we are going to
22:55 - do
22:56 - pillow can change vibrance contrast
22:58 - brightness and sharpness using image
23:00 - enhance
23:02 - and we can use filters for a lot of
23:04 - other things like blurring contouring
23:06 - embossing sharpening
23:08 - and there are like 10 other filters that
23:10 - can do quite a few more things
23:13 - they are really easy to access and once
23:15 - you have that you are pretty much done
23:18 - it really is easy so let's have a look
23:21 - at this straighten code
23:23 - here we are in a nearly empty python
23:26 - file all we are doing is we are
23:27 - importing pillow and we are opening the
23:30 - image we have already seen
23:32 - i guess the one other thing i've
23:34 - included is a reference to the
23:35 - documentation of image enhance
23:38 - let me open it to have a look
23:40 - here's the documentation and it really
23:43 - isn't that big we are starting with
23:45 - importing image enhance and inside of
23:48 - that we have a couple of subparts we
23:50 - have color contrast brightness and
23:53 - sharpness
23:55 - and that is literally it
23:57 - and at the top it tells you
23:59 - we have to create some kind of enhancer
24:02 - object
24:03 - and that enhancer object then is being
24:05 - used to alter the original image
24:08 - so let's implement that
24:11 - and for that first of all i have to
24:13 - import image enhance and then here make
24:17 - sure the i and the e are capitalized
24:20 - and now first of all we have to create
24:23 - an enhancer
24:26 - and since we have different enhancers i
24:28 - want to start with a color
24:30 - enhancer and to create this enhancer we
24:34 - first of all need image enhance and then
24:37 - dot
24:38 - color
24:39 - and now we need a reference to the image
24:41 - so i enter image and that is basically
24:44 - it
24:44 - and this one basically takes care of the
24:48 - vibrance of the image
24:50 - how you would be using it let me put
24:52 - this under another header let's call it
24:55 - applying the
24:57 - enhancer
24:59 - all you have to do to apply the enhancer
25:01 - is first get the color enhancer and then
25:03 - add dot enhance
25:06 - and now in here you can add an integer
25:08 - to determine how strong this enhancer is
25:11 - let's start with a 2 just to have
25:14 - something basic and this is going to
25:16 - return a new image
25:19 - let's call it the enhanced image and
25:22 - this is also what i
25:25 - want to print after i spell this
25:27 - properly so enhanced image dot show
25:30 - and now if we run this
25:33 - we can see the same red panda except now
25:36 - he is significantly more red as a matter
25:39 - of fact all the colors are a lot more
25:41 - vibrant
25:43 - and this we can push quite a bit more
25:45 - for example if i added f5 in here
25:48 - and run this again now we can see it
25:51 - much more that the colors are really
25:53 - really strong
25:55 - and if you added a zero in here
25:57 - you would get black and white or i
25:59 - suppose the absence of a vibrance of
26:01 - color
26:03 - one is the default this one looks like
26:05 - the original
26:07 - if you wanted to you can also add
26:08 - floating point numbers like 0.5 to wash
26:11 - the image out a little bit
26:13 - and well if you understand this part
26:16 - it's basically all you need to know
26:18 - if we come to the next one we can do the
26:21 - same thing with contrast enhancer and
26:24 - the only difference for this one is
26:25 - instead of color we are using contrast
26:28 - and i guess let me update the comment to
26:31 - contrast
26:32 - and that is it
26:33 - now instead of the color enhancer i want
26:36 - the contrast enhancer
26:38 - and then here again
26:40 - let's start with two to get some basic
26:42 - start and now we can see we have a lot
26:45 - more contrast between the colors
26:47 - if i set this to something like five
26:49 - it's even stronger
26:52 - and if i set this to a zero
26:54 - we can see nothing because a
26:57 - plane
26:58 - ray background has no contrast
27:01 - and the two other options you have
27:03 - besides contrast and color
27:06 - brightness
27:08 - and we have sharpness
27:10 - and those you get with
27:13 - you might have guessed we have
27:15 - bright
27:17 - nes
27:18 - and we have sharpness
27:22 - and let's start with brightness enhancer
27:25 - and again two
27:27 - and now we have a brighter image
27:29 - and if i am going with sharpness
27:32 - enhancer
27:34 - we get a sharper image i guess this one
27:36 - is a bit hard to see let's go with five
27:40 - and there you hopefully can see it
27:42 - youtube might butcher the video quality
27:44 - a bit but it definitely is sharper
27:47 - let me add some ridiculously high number
27:49 - like 500
27:51 - and now you should be able to see that
27:53 - this is having a lot of sharp edges
27:57 - and that we have all we need for image
28:00 - enhance it is a very simple part of
28:02 - pillow
28:03 - so next up we can start working on the
28:06 - filters and filters work in kind of the
28:09 - same way compared to image enhance
28:12 - we are basically taking an image and we
28:14 - are changing something for the entire
28:16 - picture like for example we could blur
28:18 - the entire image
28:20 - and once again at the top of the image
28:22 - we have a reference to the documentation
28:25 - part of this bit of pillow if i open
28:27 - this one
28:28 - and the website is looking like this and
28:31 - at the top you can find most of the
28:33 - filters a bit further down there are
28:35 - more
28:36 - i will cover most of them although not
28:39 - all i won't cover for example color 3d
28:41 - lut because i don't really know what
28:43 - it's doing it's fairly technical
28:46 - but the actual filters the stuff down
28:48 - here like box blur gaussian blur unsharp
28:50 - mask i will cover all of those
28:53 - so let's have a look
28:55 - and once again like an image enhance we
28:58 - have to import the specific part of
29:00 - pillow and this one is called image
29:03 - filter
29:04 - and once we have this we can apply some
29:07 - basic filters
29:10 - and applying these filters is super
29:12 - simple for example if i want to let's
29:15 - call it image blur
29:17 - i need the original image i have to
29:20 - apply a filter
29:21 - and now i need the specific filter i
29:23 - want and those specific filters i get
29:26 - from image filter and then dot the name
29:29 - of the filter in this case blur
29:32 - in all uppercase letters
29:35 - and with that i have my filtered image
29:38 - and since this filter returns a new
29:40 - image all i have to do is get my image
29:43 - blur and then show this one
29:45 - and i am getting a slightly blurred red
29:49 - ponder
29:50 - this blur filter cannot be changed so
29:53 - the blur amount is fixed although later
29:56 - on we're going to see another filter
29:58 - that can change the amount of blur
30:00 - and
30:01 - well if you understand it this far
30:04 - the same system applies to all of the
30:05 - other filters
30:07 - since i don't want to bore you let me
30:09 - just copy all of them in here they are
30:11 - looking like this we have filters for
30:13 - contour detail edge a few more edge
30:16 - thingies emboss sharp smooth and smooth
30:19 - more those are all of the basic filters
30:21 - that you can apply and i code those
30:24 - basic filters because there's no
30:26 - argument to determine how strong the
30:28 - filter is
30:29 - i suppose let me show a couple for
30:32 - example image edge is this one if i show
30:36 - it
30:38 - we have the edges much stronger in the
30:41 - image
30:42 - and this edge here is very similar
30:44 - compared to the sharpness enhancer there
30:47 - is a ton of overlap in terms of what you
30:49 - can do here think of pillow like
30:51 - photoshop there are always a ton of
30:53 - different ways to achieve the same
30:54 - outcome
30:56 - so it's totally fine if there's some
30:57 - redundancy in here
30:59 - i guess one that is going to be really
31:01 - obvious is the emboss filter because
31:03 - this one is looking like this
31:06 - and
31:07 - let's say image smooth more this one i
31:11 - think is a stronger blur
31:13 - although probably very hard to see on
31:14 - youtube but you get the idea these are
31:16 - all the basic filters you can apply
31:19 - now with that we have two more types of
31:21 - filters the first one is called rank
31:24 - filters
31:26 - and what those filters are doing they
31:28 - are sorting the pixels let me actually
31:30 - open the documentation
31:32 - and in here we have a medium filter a
31:35 - min filter and a max filter and i guess
31:37 - a rank filter
31:39 - and they are sorting all the pixel in
31:42 - the window in a given size
31:44 - probably doesn't mean too much to you it
31:46 - basically creates a weird kind of blur
31:49 - it's very hard to explain
31:51 - fortunately i don't have to explain it i
31:53 - can just show you
31:55 - let's create another image filtered
31:58 - minimum and the same syntax that applies
32:01 - we need image we need a filter we need
32:04 - image filter and now i want my min
32:07 - filter
32:09 - and this one is a method and it needs a
32:12 - size argument
32:13 - and let's start with size equal five
32:16 - and this one is a method because it
32:18 - needs an argument that is called size
32:21 - and let's start with five to see how it
32:23 - looks like
32:24 - and if i now show my image filled at
32:27 - minimum
32:29 - and run the code it looks like this
32:33 - basically what these filters do if i
32:36 - zoom in a tiny bit i think it's better
32:38 - to see let's look at the head
32:41 - basically pillow takes small clusters of
32:44 - colors and averages them out so the
32:46 - entire image looks a bit more bloppy or
32:49 - boxy it's really really hard to explain
32:53 - down here on the branch it's really good
32:55 - to see how this system works
32:58 - and the different filters we are using
33:00 - just use a different way to average
33:02 - these pixels
33:04 - and now besides the mint filter we can
33:06 - also create a
33:08 - median filter and we can create a max
33:13 - filter
33:14 - and those work by creating a median
33:16 - filter and a max filter
33:20 - and well with that we have the different
33:22 - ranked filters these are the kind of
33:24 - filters you would only ever use if
33:26 - there's a very specific use case for
33:28 - them
33:29 - if that doesn't apply to you just don't
33:31 - worry about them but some filters that
33:33 - you probably want to care about are
33:35 - called the multi-band filters
33:39 - and in here
33:40 - let me create one image as an example
33:43 - and this would be the box blur
33:46 - and for this one we need image we need
33:48 - filter once more
33:49 - i want my image filter yet again and now
33:52 - the filter i want to apply is called box
33:55 - blur
33:56 - and just like the rank filters
33:58 - we have to give them some kind of
34:00 - argument to determine how strong the
34:02 - effect is for all of the multiband
34:05 - filters that argument is called radius
34:08 - and in here for example i could use a
34:11 - radius of 20.
34:13 - and once i have that
34:15 - let me display it and i guess let me
34:19 - comment out all of this
34:21 - so it doesn't take that long to process
34:23 - all of it
34:24 - and now if i run it
34:26 - you can see a lot of blurring for the
34:28 - red panda
34:29 - it's probably much too strong so let's
34:32 - set this to a 10 might be better
34:35 - still very strong
34:37 - let's go with four that's probably much
34:39 - better yeah you can definitely see a lot
34:41 - of blurring now but the panda is still
34:44 - very recognizable with that we have box
34:47 - blur and there are two more multiband
34:50 - filters we can use
34:52 - the first one is called gaussian blur so
34:55 - let me call it gauss blur
34:57 - and finally the last filter is called
34:59 - unsharp
35:01 - or well it's called an unsharpening mask
35:04 - and to apply the gaussian filter we need
35:06 - gaussian
35:07 - blur
35:08 - and for the unsharp mask we need unsharp
35:12 - mask
35:14 - and with that we have pretty much all of
35:16 - the filters
35:18 - so let me show gaussian blur
35:21 - this one is just another kind of
35:23 - blurring it works more or less like the
35:25 - box blur except the effect looks
35:27 - slightly different
35:29 - the image unsharp filter
35:32 - is looking like this it's basically the
35:35 - opposite of blurring where we're adding
35:37 - a ton of contrast to the image
35:39 - well that is it for this section let me
35:42 - uncomment all the other parts
35:45 - these are all of the filters you're
35:47 - probably going to use in pillow
35:50 - we are very nearly done there's just one
35:53 - more small topic i do want to cover and
35:56 - this one is really important to
35:58 - understand how pillow works in general
36:00 - you see when we are covering all of
36:03 - these filters
36:04 - you always have to be aware that we are
36:06 - getting an image returned all of these
36:09 - filtered things are images meaning we
36:12 - could combine them with another filter
36:14 - let's say this image emboss here
36:17 - even though it was created by a filter
36:19 - is just an image so we could apply
36:22 - another filter to it afterwards as a
36:24 - matter of fact all of these things
36:27 - change an image and this is what we
36:30 - always do in pillow we are always
36:32 - applying one change after another to the
36:35 - same image to get a different kind of
36:37 - effect
36:38 - and let's actually do an example here
36:41 - i want to combine
36:43 - filters
36:44 - i guess let's add a bit more space
36:46 - and i want to combine a blur
36:49 - and an emboss filter so we can see
36:52 - what's going on
36:54 - and let me move the show part below that
36:58 - for this first of all i want to create
37:00 - the emboss filter and i suppose i can
37:03 - just copy it from here
37:06 - i want to have my emboss filter
37:09 - and if i print this one again
37:12 - and let me comment out everything else
37:16 - so it doesn't take too long to load
37:19 - there we go if i now run this we are
37:22 - getting the embossed image
37:25 - but now what we can do
37:27 - i can
37:28 - let's call this one the image
37:32 - emboss
37:33 - blur
37:35 - now instead of just taking the image i
37:38 - would take the image embers and apply
37:40 - another filter to it
37:42 - and let's say i want to apply the
37:43 - gaussian blur let me copy it from here
37:47 - and let's say a radius i want for two
37:51 - and now this image ambush blur i can
37:54 - show
37:55 - and we have an emboss effect plus a blur
37:58 - effect and that is how you want to think
38:00 - about images in pillow you can just
38:02 - apply more and more things to it just be
38:04 - aware you need an image for that
38:07 - but well if it got that far this should
38:10 - be a really powerful way to change any
38:13 - kind of image
38:14 - so for the next part we can look much
38:16 - deeper into pillow
38:20 - and what we are going to look at is
38:22 - colors in pillow
38:24 - and
38:25 - well
38:26 - pillow can do a lot with colors
38:29 - it can access and change colors of any
38:31 - image and it can also change the format
38:34 - of the image itself so we get different
38:36 - kinds of colors
38:38 - the problem is to understand how all of
38:40 - this works we need some theory and
38:43 - probably some photoshop as well so let's
38:46 - get started
38:48 - in the most basic sense any image
38:50 - consists of pixels for example the image
38:53 - we have seen so far has 1920 by 1280
38:56 - pixels
38:58 - and what that means in practice just to
39:00 - visualize it if this here is our image
39:04 - and inside of this image we have a huge
39:06 - amount of very very small dots
39:10 - and those are creating our image
39:12 - on the width we have
39:15 - 19 20 of them and in terms of height we
39:19 - have
39:20 - 12
39:21 - 80.
39:23 - these two numbers here so in total we
39:25 - have about 2.5 million pixels
39:28 - and every single pixel has a specific
39:32 - color
39:33 - and these colors can be expressed in a
39:36 - lot of different ways the one you might
39:38 - have seen so far is we are using a
39:40 - combination of red green and blue that's
39:43 - the one i've actually used earlier
39:45 - and these values usually go between 0
39:48 - and 255
39:49 - meaning for red we could have a value of
39:52 - 255 or green we could have a value of
39:55 - zero and for blue we could have zero as
39:57 - well
39:59 - the result would be we have a plain red
40:03 - color
40:04 - and this is the most common way to
40:06 - express colors but there are quite a few
40:08 - more cyan magenta and yellow are very
40:11 - commonly used for printing businesses
40:13 - where you actually want to print colors
40:16 - another way would be hue saturation and
40:17 - the lightness value
40:20 - and
40:21 - all three of these approaches can get
40:24 - you a lot of different colors
40:26 - but there are also ways to create color
40:28 - in an easier way
40:30 - for example what we could do
40:32 - for each pixel just assign the value
40:34 - between 0 and 255
40:38 - and 0 in this example is black and 255
40:41 - is pure white and anything in between is
40:43 - some shade of gray
40:45 - and we could make this even easier by
40:48 - just switching between 0 and 1 with 0
40:51 - being black and 1 being white
40:55 - obviously
40:56 - both of these examples wouldn't get you
40:58 - very high-res images but it is a valid
41:00 - way to express colors all i want you
41:03 - guys to take away from this is that
41:04 - there are different ways to express
41:06 - colors
41:08 - so let's have a look at all of this in
41:09 - photoshop alright here you can see the
41:12 - video i have used for this video so far
41:14 - and if i zoom in to let's say some part
41:18 - of the fur
41:19 - you can see every individual pixel
41:22 - and for each of those i can pick the
41:25 - specific color
41:27 - let's say for this bit here and if i
41:30 - open this color
41:31 - you can see the hsb values and you can
41:35 - see the rgb values
41:39 - hsb is for hue saturation and brightness
41:42 - i called this lightness value earlier
41:44 - but same thing and rgb stats for red
41:47 - green and blue and those are two
41:49 - different ways to express color
41:51 - the other way i have talked about just
41:52 - now as well is cmyk
41:55 - i guess you could also use a hexadecimal
41:56 - color there are lots of different ways
41:58 - of doing this
42:00 - the main thing you have to understand is
42:02 - that colors can be expressed in lots of
42:04 - different ways and this can influence
42:06 - what you need for a specific image
42:09 - and what we can do in photoshop if we go
42:12 - all the way to the top we can go to mode
42:14 - and in here right now we have rgb color
42:18 - with 8 bits
42:20 - what i could do here instead is change
42:22 - all of this to grayscale
42:25 - if i do it photoshop is going to
42:26 - complain that this is going to convert
42:28 - my image to black and white because i am
42:30 - changing my image from having three
42:32 - different colors for every pixel red
42:34 - green and blue to only having one color
42:38 - which is going to get rid of any kind of
42:40 - color and just leaves me with black and
42:42 - white
42:43 - and if i discard this and zoom out now
42:47 - all of this is black and white
42:50 - and if i click on any individual pixel
42:53 - now the only value we have left is for
42:56 - hsb we have brightness
43:00 - and that is the most common way to
43:01 - convert an image with rgb values to
43:03 - grayscale we are basically getting rid
43:06 - of all of the
43:07 - hue and saturation and we are just left
43:09 - with brightness
43:11 - another way to think about is in terms
43:13 - of rgb we are just averaging out all of
43:16 - the values
43:17 - so we have the same mode of red green
43:20 - and blue and that way we have some shade
43:22 - of gray
43:24 - and pillow is doing the very same thing
43:26 - so with that i think we have some good
43:29 - bases to understand how pillow is going
43:31 - to work with colors
43:34 - although before we are jumping into code
43:36 - there is one more thing i do want to
43:37 - address
43:38 - and that is that i am going to use numpy
43:40 - to illustrate how pillow works if you're
43:43 - a beginner you might not know what numpy
43:45 - is in the most basic sense it's a way to
43:47 - work with numbers in python it's a
43:49 - really popular module
43:51 - for this video i don't expect you to
43:53 - know it and you don't have to follow
43:55 - along i will just very rarely use it to
43:57 - illustrate some basic things however if
44:00 - you want to follow step by step you do
44:02 - have to install numpy and this happens i
44:05 - will pip install numpy or pip3 install
44:07 - numpy
44:09 - and with that we can actually jump into
44:11 - the code and let's have a look at all of
44:13 - this here we have a very basic setup
44:16 - once again and the first thing i want to
44:19 - work on is
44:21 - let me comment it in i want to analyze
44:23 - picture information
44:25 - and this you can do in quite a few
44:27 - different ways
44:30 - i suppose the easiest way to approach
44:32 - this is you get the image and then you
44:34 - get the method get pixel
44:37 - and in here you have to specify an x and
44:40 - a y coordinate and this is then the
44:42 - pixel you are going to look at
44:44 - for example if we look at the pixel 0
44:47 - and 0
44:48 - and then print the result
44:51 - we are getting the rgb value 100 105 and
44:55 - 5.
44:57 - and those are the values for red
44:59 - green
45:00 - and blue respectively we are combining
45:03 - these three colors to get another color
45:06 - i guess here we are back in photoshop
45:08 - and the pixel i have been looking at
45:11 - right now is the pixel all the way in
45:14 - the top left let me zoom in all the way
45:17 - we are looking at let me show my mouse
45:20 - we are looking at this pixel all the way
45:22 - in the top left here some shade of green
45:25 - and if i open this one we get 100 105
45:28 - and 5. those are the values we just
45:31 - looked at
45:32 - and i guess while we added i should
45:34 - mention i think i talked about this
45:36 - earlier but just to be sure
45:38 - if this here is our image the origin
45:41 - point is in the top left this point here
45:44 - is 0 and zero the point we have just
45:46 - looked at
45:48 - b sites get pixel we can also run image
45:51 - dot get
45:53 - colors
45:54 - and this one by itself right now is not
45:57 - going to work
45:58 - if i print all of this and comment out
46:02 - get pixel
46:03 - i would get none
46:06 - and the problem here is this get colors
46:09 - is going to get all of the colors we are
46:11 - using in our image
46:13 - the problem is
46:14 - if there are too many colors in the
46:16 - image this one is going to return none
46:18 - i have actually added a comment for that
46:21 - in my notes that might be helpful
46:23 - the max color argument is what we can
46:25 - specify in here and by default this one
46:28 - is 256
46:29 - and if the image has more colors than
46:32 - that get colors is going to return none
46:35 - meaning inside of this we have to define
46:38 - a new max
46:40 - color and for that we have to figure out
46:43 - how many colors we could possibly have
46:45 - at the maximum and the maximum amount of
46:48 - colors we could theoretically have is
46:50 - the number of pixels
46:52 - so if you want to make sure that this
46:54 - get colors always works you want to get
46:56 - the number of pixels and this is a
46:58 - number you can get quite easily all you
47:01 - have to do is get image size n0
47:04 - and multiply it with image.size
47:07 - with 1
47:08 - meaning we are multiplying the width by
47:10 - the height of the image and that way we
47:12 - are going to get all of the pixels
47:15 - and now if i run this
47:17 - we are getting an error because this is
47:20 - max colors let me fix it here and now if
47:22 - i run this there we go
47:25 - now we can see
47:27 - all of the colors that are being used
47:30 - inside of the image a huge list because
47:32 - the image is quite large remember we
47:34 - have 2.5 million pixels
47:37 - and what you have to understand about
47:38 - this list is that the first item is the
47:41 - amount of times we have this color and
47:43 - then the color itself
47:45 - meaning we have this color here one time
47:48 - and with that we have a way to find all
47:51 - of the colors used in the image
47:54 - now there are a few more ways to get
47:56 - more information about the image
47:58 - i guess these two here let me actually
48:00 - add proper comments is colors only
48:04 - but besides that maybe something i
48:06 - should have started with is
48:09 - getting
48:10 - picture
48:11 - information
48:12 - and in here i can for example print my
48:15 - image.mode and if i run this i get rgb
48:19 - the current picture format
48:21 - later in this section you are going to
48:23 - learn how to change this one as well
48:25 - now besides that
48:27 - you can also use get bands and this one
48:30 - is a method
48:31 - if i run this i get rgb basically the
48:34 - same information as i get before
48:36 - if you want to go overkill there is also
48:40 - an attribute that is called info that
48:42 - you should spell correctly and if you
48:44 - run this
48:45 - you are getting quite a bit more
48:47 - information i guess this party at the
48:49 - top
48:50 - is the really important bit
48:52 - if you know what you're doing with
48:53 - images this can be quite useful
48:55 - in our case though this really doesn't
48:57 - do all that much
48:59 - so let me comment this one out
49:01 - as a matter of fact get bans we also
49:03 - don't need but just for mode
49:06 - we get rgb
49:08 - and this one is kind of important to
49:11 - understand what is going on in our image
49:14 - because what you have to understand
49:16 - about this rgb is that we have three
49:19 - different layers
49:20 - we have one layer for red one layer for
49:22 - green and one layer for blue
49:25 - and you can access each of these
49:27 - channels let me actually add this in a
49:29 - separate part we have channels here
49:32 - and what you could be doing you can get
49:34 - image and get channel
49:37 - and in here you can access different
49:39 - channels you could either use letters
49:41 - like r for the red channel or you could
49:43 - use indexing like zero this would also
49:46 - be the red channel
49:47 - and one would be green and two would be
49:50 - blue but let's stick with r this is the
49:53 - easiest one to read
49:54 - and this is going to return another
49:57 - image so let me save this as another
50:02 - variable
50:03 - and now if i use red channel and show
50:06 - what we are getting
50:08 - we can see our red panda again except
50:11 - now we have some kind of black and white
50:14 - image
50:15 - and to understand this black and white
50:17 - image i am going to use numpy
50:20 - and this is all going to make sense in
50:22 - just a second but what i want to do i
50:24 - want to from numpy
50:27 - import array that is all i'm going to do
50:31 - and an array is basically a really fancy
50:33 - kind of list
50:34 - and what this array can do in pillow is
50:37 - convert this image here to a list of
50:40 - numbers and this list of numbers
50:42 - contains all of the pixels with their
50:44 - color information
50:46 - and let me comment out the show part
50:49 - here
50:50 - and printing this image as well
50:53 - and i guess i can add a
50:56 - numpy section here
50:58 - to use the array all we need is array
51:01 - and then we can insert the image itself
51:05 - if i run this now i get a very long list
51:08 - of numbers oh well not that long because
51:10 - numpy shortens it you can see it with
51:12 - the dots here
51:14 - but inside of this we can see the
51:16 - different pixels here again is our very
51:19 - first pixel the one with the color 100
51:21 - 105 and 5.
51:23 - this is the top left pixel the pixel to
51:26 - the right of that is going to be this
51:27 - one then we have this one
51:29 - and then we have about 2.5 million more
51:31 - pixels
51:33 - and this is how your computer sees an
51:35 - image
51:36 - and what you can also do with numpy
51:39 - is to get the shape of a certain kind of
51:42 - number set meaning if i run this now
51:45 - we get the height of the picture the
51:48 - width of the picture and then the depth
51:50 - of the picture i guess you could call it
51:53 - and this one here is three because we
51:56 - have three different layers for our
51:58 - image we have one layer for red one
52:00 - layer for green and one layer for blue
52:04 - and what we have done down here when we
52:07 - get the red channel
52:08 - we get the red layer by itself
52:11 - and this you can also illustrate let me
52:14 - copy this get channel and copy the array
52:17 - here and now instead of the original
52:19 - image i want to turn the red channel
52:22 - into a
52:25 - numpy array so we can see the individual
52:27 - numbers
52:29 - and now if i run this we can see another
52:32 - list of numbers
52:34 - and this might not tell you too much
52:37 - but the way it might make more sense is
52:40 - if i print both and not the shape the
52:44 - actual list itself
52:46 - meaning this here is our red channel and
52:49 - this here is the entire original image
52:53 - and the one thing you have to understand
52:55 - now is that this here on the left is the
52:57 - red channel we have
52:59 - 99 103 and so on
53:03 - and if i return to the red channel we
53:05 - have 100 99 103 these are all of our red
53:09 - colors in a slightly different format
53:11 - but don't worry about that
53:13 - numpy can be a tiny bit confusing about
53:15 - that
53:16 - all we have done with this get channel
53:18 - is we have just picked up the red colors
53:21 - and turned those into a grayscale image
53:24 - and the higher this number gets the
53:26 - closer we are getting to white and the
53:28 - lower this number gets the closer we are
53:30 - getting to black
53:31 - if i show this red channel image again
53:35 - the whiter a part is like this bit here
53:39 - or these parts down here the more red
53:41 - they had in the original image and the
53:44 - darker something is
53:45 - let's say like this part here
53:48 - or this bit here
53:51 - the less red they had in the original
53:54 - we are working with a long list of
53:56 - numbers for the image these numbers are
53:59 - organized in rgb tuples so we have red
54:01 - green and blue
54:03 - for the red channel we only have one
54:05 - number between 0 and 255
54:08 - and these numbers are then translated by
54:11 - our computer into an actual image that
54:13 - we can work with
54:15 - and well i think that was very boring
54:17 - but really important to understand how
54:18 - pillow works because once we have all of
54:21 - that let me comment out these parts we
54:24 - don't need them anymore
54:26 - we can come to the actually more
54:28 - interesting part
54:30 - and
54:31 - i guess i can copy it for my notes
54:33 - we have color conversions
54:36 - and here we can convert our image in
54:38 - lots of different ways
54:40 - and to understand how these conversions
54:42 - work we needed this bit of theory here
54:45 - so i hope that made sense
54:47 - the first kind of conversion we can do
54:49 - is turning our image into one bit
54:51 - grayscale image
54:54 - and to convert an image you need image
54:57 - dot convert
54:58 - and now in here you can add a certain
55:01 - kind of mode
55:03 - and there are lots of different ones you
55:04 - can have the one for one bit
55:07 - is done with the string one
55:10 - and this is going to return another
55:12 - image let me save this in the variable
55:15 - image
55:17 - ray scale
55:19 - one bit
55:20 - and now if i show this image grayscale
55:24 - one bit with the show method
55:26 - you can see we have something that looks
55:28 - pretty bad
55:30 - and what you have to understand about
55:31 - this image is that we only have two
55:34 - different colors we have black and we
55:37 - have white there's no other color
55:40 - it might look like it if you look at it
55:41 - from this angle but that's just your
55:43 - lizard brain playing tricks on you
55:46 - i can actually illustrate that we
55:48 - literally only have two colors using
55:50 - numpy again if i print
55:53 - an
55:54 - array
55:55 - with this image grayscale one bit
55:58 - and let me not show the image so things
56:01 - staying a bit cleaner
56:03 - now we get something weird we only have
56:05 - thoughts and true the reason for that is
56:08 - that numpy got a bit confused because
56:11 - this image here only contains zeros and
56:14 - ones
56:15 - and those numpy automatically converts
56:17 - to true and false so to booleans
56:20 - to overcome that we can change the data
56:22 - type to an integer and now if i run this
56:26 - you can see the actual number of this
56:28 - image
56:29 - and what you can see in here is we only
56:31 - have zeros and ones
56:34 - wherever we have zero we have a black
56:36 - pixel wherever we have a one we have a
56:38 - white pixel
56:40 - basically what happens with this kind of
56:42 - conversion if a pixel is bright enough
56:45 - the pixel becomes white if the pixel is
56:47 - not bright enough it becomes dark and
56:49 - one bit literally means we only have a
56:51 - zero or one
56:53 - this is the simplest forms of image
56:56 - storage
56:57 - another way to look at it is to look at
56:59 - the channels
57:01 - let me print this one i want to get my
57:04 - image grayscale one bit
57:06 - and i want to look at get
57:08 - bands
57:10 - and if i run this we are getting the
57:13 - channels down here we only have one
57:15 - channels we don't have the rgb channels
57:18 - anymore we only have the one channel and
57:20 - this channel only contains numbers
57:22 - between zero and one
57:25 - and with that we have grayscale
57:27 - conversion so this is one way to work
57:30 - with color
57:31 - besides that
57:33 - we also have eight
57:35 - bit
57:36 - grayscale
57:37 - and this is a better kind of grayscale
57:40 - essentially
57:41 - and this is also the image you have seen
57:43 - in photoshop
57:45 - let me add another variable and i'm
57:47 - going to call this one grayscale l
57:50 - the reason why i'm calling it grayscale
57:51 - l is because we need image convert and
57:54 - now the mode i'm looking for is called l
57:59 - actually capital l and now if i show the
58:02 - image with show
58:04 - we are getting a much nicer looking
58:07 - grayscale image
58:08 - if i zoom in
58:10 - you can very clearly see we have lots of
58:12 - different shades of grey
58:14 - to be a bit more specific
58:17 - let's show the numpy array again
58:20 - i want to look at the array of my
58:23 - grayscale l image
58:25 - and let me comment out this part and
58:28 - here you can see
58:29 - all of the numbers we have for every
58:30 - single pixel
58:34 - and again keep in mind every single
58:37 - pixel is a number between 0 and 255
58:42 - and the higher this number gets the
58:43 - brighter the pixel is
58:47 - although that being said
58:49 - if i print my grayscale and then get the
58:53 - bands
58:55 - we again only have one channel and that
58:58 - is the channel l
59:00 - meaning this is all the information we
59:02 - get there's only one layer
59:05 - cool and this is 8-bit grayscale still a
59:08 - fairly simple way to approach colors
59:10 - next up on the hierarchy is what is
59:13 - called a palette and this one is going
59:16 - to get a fair bit more powerful
59:18 - i guess
59:19 - let me create another variable that i
59:21 - call palette and to convert an image to
59:24 - a palette we need convert once more and
59:27 - the mode now is called p
59:30 - and if i show this palette with show
59:35 - we can see
59:37 - well if you look on youtube this
59:38 - probably looks more or less the same but
59:41 - if i zoom in a bit
59:43 - you i hope can see what's going on we
59:46 - only have a very limited amount of
59:48 - colors
59:50 - specifically we have 256 colors
59:54 - kind of like the 8-bit grayscale except
59:56 - now they're not black and white they
59:58 - have a different kind of color set
60:01 - or rather a specific kind of palette
60:03 - that we are using to make all of this
60:06 - look
60:06 - actually kind of good if you look at it
60:08 - from far enough away
60:10 - this was actually used by computers
60:12 - about 20 years ago to save hardware
60:14 - space because it doesn't look like a
60:16 - boring grayscale image but it's still
60:18 - fairly efficient to save
60:20 - now this palette can get quite confusing
60:25 - so let's talk about how it works
60:29 - when you are converting an image to a
60:31 - palette you have 256 colors in total let
60:36 - me add colors only
60:38 - and you can again print an array
60:42 - of this palette
60:44 - and let's do this again and not show the
60:46 - image
60:47 - and we are getting a bunch of different
60:49 - colors
60:51 - however what you have to be aware of
60:53 - these numbers here do not refer to a
60:57 - color all of these numbers are just
61:00 - references to the actual color
61:03 - and this is really important let me add
61:05 - a comment here
61:06 - not
61:07 - colors
61:09 - they are references to a color in a
61:14 - palette this is why all of this is
61:16 - called a palette
61:18 - and that palette we can get with
61:21 - the palette image again
61:23 - and then get
61:25 - palette
61:27 - and if i run this
61:28 - we are getting a typo because i am
61:30 - really bad at typing
61:32 - if you spell this correctly and run the
61:34 - code you are getting a very long list of
61:37 - numbers
61:38 - and this long list of numbers is
61:40 - probably really confusing so
61:43 - what does that mean
61:45 - and to understand what this number means
61:47 - let me rearrange it a bit using numpy
61:49 - again
61:51 - i want to print an array and the array
61:55 - or the numbers for the array are this
61:57 - one here
61:59 - and now this array i want to reshape
62:02 - we have 256 colors
62:05 - and each color is represented by a tuple
62:08 - of three individual colors
62:10 - and if i run this now
62:12 - you can see each individual color
62:15 - and this is an rgb tuple
62:18 - let me scroll up a tiny bit more to get
62:21 - to the first actual entry in here there
62:24 - we go
62:25 - when we are starting this
62:28 - list here
62:29 - we have just a bunch of zeros but at
62:32 - some point we have 51 0 and 0 and this
62:36 - is a very muted red
62:38 - if we go up to the original list so the
62:40 - list we got from this line here
62:43 - we again start with all of the zeros but
62:46 - at some point we get 51 0 and 0
62:51 - meaning all i have done down here is i
62:54 - have rearranged this long list into
62:56 - something that is a bit more readable
62:59 - all you really have to understand about
63:01 - this list is that we are moving in
63:04 - triplets
63:05 - these three items are the first color
63:08 - these three are the second color these
63:10 - three are the third color and so on
63:12 - and the list we are getting up here from
63:15 - the palette itself
63:16 - is a reference to this list for example
63:20 - this 24 here
63:23 - points to the 24 item inside of this
63:27 - list
63:29 - don't know maybe it is 0 51 and 204 that
63:34 - looks about like index 24.
63:38 - i should make this arrow a bit better i
63:40 - hope you get the idea
63:42 - just to summarize this what you have to
63:45 - understand for palette is that each
63:47 - pixel holds a reference to a palette of
63:50 - colors
63:51 - and this palette of colors is just a
63:53 - long list of rgb tuples
63:55 - and then the index for each pixel points
63:58 - to something like this and this is the
64:00 - color we are getting
64:02 - it honestly is kind of annoying
64:04 - especially since pillow is a bit weird
64:06 - about displaying the numbers which is
64:08 - why numpy is really useful in here and
64:12 - if you don't understand how palettes
64:13 - work this kind of system is probably
64:15 - unbelievably confusing
64:17 - what we can also do with palettes let me
64:20 - remove this line here and go on the next
64:22 - line
64:22 - we can change the amount of colors we
64:24 - have for example if i want a palette
64:28 - with only 16 colors
64:32 - i would again use image and convert
64:35 - i would use the p mode
64:37 - and now i need two more arguments
64:41 - the first one is called palette as well
64:44 - and here we need image dot
64:47 - palette and then dot adaptive
64:50 - this one is going to allow us to specify
64:52 - how many colors we want
64:54 - and once you have that one you can
64:56 - specify an amount of colors in this case
64:59 - 16
65:01 - and let me again comment out the earlier
65:04 - part
65:05 - and i want to get my palette 16 and show
65:09 - all of this
65:10 - and we are getting
65:12 - a image that looks much older so now we
65:16 - only have 16 colors in total in this
65:18 - entire thing
65:20 - what you can also do
65:22 - let me add another section here you can
65:24 - update the color
65:27 - palette i am very bad at spelling
65:29 - palette and just to keep things simple
65:32 - let's say for this palette 16 i want to
65:34 - update the palette to change the colors
65:37 - for that i first of all have to create a
65:40 - new
65:41 - palette all we have to do is get
65:45 - my original palette 16 palette and this
65:48 - i get with get pal let
65:51 - the same thing we have used up here and
65:54 - this is going to return a really long
65:56 - list of numbers
65:58 - i guess let me print what we are getting
66:01 - from this so far
66:03 - new palette
66:04 - is going to be a really long list of
66:06 - numbers
66:07 - and these numbers again
66:10 - in triplets here are the actual color of
66:13 - this image
66:14 - and if i change these numbers in here i
66:17 - can change what the colors look in the
66:19 - image
66:20 - and this i can do with list
66:22 - comprehension let's say x for x in this
66:26 - list
66:26 - and now when i get this new value i want
66:30 - to divide it by two
66:32 - i suppose we should use floor divide so
66:35 - we keep on using integers
66:38 - and now this new palette i can set as
66:41 - the palette for my palette 16 and this
66:44 - you do with put pellet
66:47 - and i want to insert my new pallet
66:49 - and if i now
66:52 - show my pallet 16 again
66:54 - the entire thing is significantly darker
66:57 - we have the brightness of every single
67:00 - pixel
67:01 - and with that we have covered all of the
67:04 - really basic color operations
67:08 - now these are
67:10 - different ways to create simple images
67:13 - and to play around with the format of
67:15 - pillow or of the images inside of pillow
67:18 - now you can convert images in a lot more
67:20 - ways
67:22 - here is the website and here are all of
67:25 - the modes you can work with the one you
67:28 - are going to work with the most is rgb
67:30 - or rgba
67:33 - and the ones you have just seen are 1 l
67:35 - and p
67:36 - and you can also work with a lot more
67:38 - numbers and down here you have even more
67:40 - options
67:42 - for all of these you are just working
67:44 - with very long lists of numbers and
67:46 - these lists either contain tuples with
67:49 - for example rgb values or you just have
67:52 - individual numbers that represent a
67:53 - color in the gray scale
67:56 - like these two here
67:58 - if you understand that part it should
68:00 - help you quite a bit to understand
68:02 - pillow itself
68:03 - cool now one more thing that we can do
68:06 - in here is to change individual pixels
68:09 - let me add another section change
68:11 - individual pixels
68:12 - and this one really isn't going to get
68:14 - too long
68:15 - all you need is image dot put pixel
68:19 - and now in here you need two bits of
68:21 - information you need a position and you
68:23 - need a color
68:25 - for the position let's say at position
68:28 - 100 and 200
68:31 - i want to put a red pixel and this red
68:34 - pixel i get with an rgb tuple with 255 0
68:38 - and 0.
68:39 - once i have that i can show my image run
68:42 - all of this
68:44 - and now somewhere in the top left i hope
68:47 - i can find it
68:48 - ah there we go
68:51 - here
68:53 - we have a red pixel the one we have just
68:56 - created
68:57 - and be aware here the color you need for
69:00 - this pixel depends on what color format
69:03 - you have
69:04 - this image is in rgb
69:07 - if we had grayscale if we had a
69:09 - grayscale image this would have to be an
69:11 - integer like 255 for white
69:14 - and once we have that what we can also
69:17 - do is change large numbers of pixels
69:21 - and all we need for that is for x in
69:24 - range image dot size of zero so we are
69:28 - cycling through the horizontal image and
69:30 - then for y in range
69:33 - image and size and one and this cycles
69:37 - through the vertical part of the image
69:39 - and what i can do for example in here is
69:42 - if image and get
69:45 - pixel
69:46 - of the current position so x and y
69:50 - and this is going to return a tuple with
69:53 - r g and b
69:55 - and in my case i could grab the r part
69:58 - so the one with the index zero
70:00 - and check if this one is above a certain
70:03 - threshold i don't know 200 as an example
70:06 - and if that is the case
70:09 - we can use image put pixel
70:12 - and place another pixel in this x and y
70:15 - position
70:17 - let's say for this one i want to place a
70:20 - black pixel
70:22 - if i run this what is going to happen
70:24 - pillow is going to calculate for a bit
70:27 - you can see in the entire image wherever
70:31 - our red color exceeded a certain
70:33 - threshold we are placing a black color
70:36 - all of these parts here
70:39 - and this would be one way to replace all
70:41 - of the colors in one go
70:43 - although you do have to be aware that
70:46 - this operation here is very slow in
70:49 - pillow
70:50 - if you wanted to do this more regularly
70:52 - you would want to use numpy arrays the
70:55 - stuff we have used or imported up here
70:58 - those are really powerful
70:59 - but this is something you can do
71:02 - this probably was a really boring
71:05 - section so sorry about that but if you
71:07 - got so far you should have a really good
71:10 - understanding about the numpy library
71:12 - and how it works under the hood this is
71:15 - really useful to understand later on
71:17 - what's going on alright with that we
71:19 - have finished another section
71:22 - and for the next bit we are going to
71:24 - look at image ops
71:26 - and this is just another subpart of the
71:29 - pillow library and image ops works
71:32 - somewhat like a filter we can for
71:34 - example change the contrast although
71:36 - image ops does a few bit more things as
71:39 - well like mirroring or flipping an image
71:42 - and it can add borders as well for
71:44 - example
71:45 - there are also some options in image ops
71:47 - that a filter cannot do
71:50 - but in terms of how to use it it works
71:52 - like a filter so let's have a look at
71:54 - all of this
71:55 - once again we have a nearly empty python
71:58 - file and in here besides image i want to
72:01 - import image ops or image ops i'm never
72:05 - sure which one is the right way to
72:06 - pronounce it and with this image ops you
72:09 - can do quite a few different things
72:12 - let me start with color changes
72:15 - and in here for example we could let me
72:18 - start with image
72:20 - contrast
72:22 - we can give an image a different kind of
72:23 - contrast
72:25 - and to apply this
72:26 - we need image
72:28 - ops
72:29 - and then we need auto contrast
72:34 - and in here we have two arguments we
72:37 - need so let me use named arguments we
72:39 - first of all need the image itself in my
72:42 - case this is the image we have
72:44 - and then we need a cutoff point i guess
72:47 - i can demonstrate what this does in
72:48 - practice for now let me set it to 20.
72:52 - and once we have that we have a new
72:54 - image and this we can just
72:57 - show and
72:59 - we can see something like this
73:02 - now the image has a ton of weird-looking
73:05 - contrast
73:07 - basically what this auto-contrast does
73:09 - it works kind of similar compared to the
73:11 - contrast in the enhanced part except
73:14 - this one is a bit smarter in terms of
73:16 - what kind of contrast it applies
73:19 - most of the time you would use a much
73:21 - lower value than 20 maybe something like
73:23 - 5
73:25 - and now this image has a lot more
73:27 - contrast but the contrast looks a bit
73:29 - more natural
73:31 - and now
73:32 - like with the filters we have a ton of
73:35 - different options that we could be using
73:38 - i guess one more that we could cover is
73:40 - image inverted
73:43 - and this one you get with image ops and
73:46 - invert and then here we just need the
73:48 - image itself
73:49 - i can show this as well and now we have
73:53 - the image inverted
73:55 - and i think i bought you enough in the
73:57 - last section so let me just copy in the
73:59 - other options we have we have solarize
74:02 - posterize grayscale and equalize
74:05 - and in here posterize and solarize have
74:09 - a few more parameters that you could be
74:10 - using like threshold and bits
74:13 - and those determine how strong the
74:14 - effect is
74:16 - for example for image posterize
74:19 - if i show this
74:21 - we are basically reducing the amount of
74:23 - colors we have
74:25 - if this is set to 2
74:27 - we have well two bits of colors if this
74:29 - is four we have
74:31 - a lot more colors so the image looks
74:33 - more natural
74:35 - if you set this to one
74:36 - you have basically only a very low
74:39 - amount of numbers
74:41 - now besides those there's one more and
74:44 - this is called let me call the variable
74:47 - colorize
74:49 - and this one we get with image ops dot
74:52 - color rice
74:54 - and in here we need an image once more i
74:58 - want to reuse my image
75:00 - and what we have to do in here besides
75:03 - the image itself is set a black
75:06 - and a white named argument
75:08 - and how this colorize works
75:11 - it wants basically a black and white
75:13 - picture and then it changes what is
75:15 - considered white and what is considered
75:17 - black
75:18 - so for example
75:20 - the black color you could assign to a
75:23 - green color
75:25 - and the white color you could assign to
75:27 - a red color the problem is right now
75:30 - this is not going to work i guess i
75:33 - could print the colorized image but we
75:36 - are going to get an error message and
75:38 - the error message is we have assert
75:41 - image mode has to be l
75:43 - and if you look at the last section
75:46 - image mode l
75:47 - is
75:49 - this one here the 8-bit grayscale
75:52 - what pillow is expecting is an image
75:55 - that consists of just numbers between 0
75:58 - and 255
76:00 - and to get there all we have to do is
76:02 - apply convert to the image and then put
76:05 - it in image mode l
76:08 - and now if i run this
76:11 - you can see a very strange looking image
76:14 - let me keep the black color as black and
76:18 - run this again now and i think now it's
76:20 - a bit easier to see
76:21 - what this one does is it changes how
76:24 - pillow is processing the image
76:27 - we don't have a grayscale anymore
76:29 - instead we go from black to red
76:32 - or if we are changing this from black
76:35 - here let's say to blue
76:37 - then our gradient for these colors is
76:40 - between blue and red
76:42 - and this is why i had this really boring
76:44 - section about how pillow works
76:46 - if you don't understand that part this
76:49 - bit here is going to be very confusing
76:52 - alright these are all of the parts you
76:54 - need to change colors
76:57 - let me comment them out because now we
76:59 - can do some other things
77:01 - we can this section are called dimension
77:04 - changes although it's not the most
77:06 - accurate name
77:07 - basically what you are doing in here you
77:09 - can either mirror an image and this
77:12 - happens with image ops again
77:15 - and you use mirror then you pass in the
77:18 - image you want to change and you are
77:20 - done
77:21 - so image mirror
77:23 - and now we have mirrored the image
77:27 - the same thing
77:28 - works by using flip so
77:32 - let me change the naming here and flip
77:34 - is flipping the image in the vertical
77:36 - axis
77:37 - so image flip
77:39 - and there we go now the panda is upside
77:41 - down again
77:42 - what you can also do is scale the image
77:45 - by a certain factor
77:47 - in this one you do with image ops and
77:50 - scale
77:51 - and in here we want an image again let
77:54 - me use a named argument
77:56 - and now to scale the image we need a
77:59 - factor and this factor changes the
78:01 - scaling both on x and y so the aspect
78:04 - ratio always remains the same i could
78:06 - for example pass a 2 in here and then
78:11 - show my image scale
78:13 - although you are not going to see much
78:15 - of a difference
78:16 - i suppose a better way to visualize this
78:19 - would be to pass in a 0.4 in here and
78:22 - now we have a much smaller image
78:25 - but with the same aspect ratio
78:28 - meaning if you want to scale an image
78:30 - this image scale here is much easier to
78:33 - use than the one i have used earlier in
78:36 - section 2
78:37 - this one here
78:39 - and once again pillow has a ton of
78:42 - methods that achieve basically the same
78:44 - outcome
78:46 - there is one more and that is called
78:48 - image contain
78:50 - and this one we get with image ops dot
78:53 - contain
78:54 - and in here we have to specify once more
78:57 - the image
78:59 - now how this size is going to work can
79:02 - be a tiny bit confusing but in the most
79:05 - basic sense pillow expects here a width
79:09 - and a height argument
79:11 - and basically what is going to happen
79:13 - is that contain is going to change the
79:15 - size of the image but the aspect ratio
79:18 - of the image will always stay the same
79:21 - and the numbers you pass in here are not
79:23 - going to be the numbers you actually get
79:25 - as image dimensions
79:27 - i guess let me do an example if i add
79:29 - 500 and 200
79:32 - pillow is going to resize the original
79:35 - image to try to fit inside of these
79:38 - dimensions however the aspect ratio is
79:41 - not going to allow that to fit these two
79:44 - numbers perfectly pillow would have to
79:46 - stretch the image which it is not going
79:48 - to do
79:49 - so it is going to pick the smaller of
79:51 - these two numbers
79:52 - and then change the other number to keep
79:54 - the aspect ratio
79:56 - if i
79:57 - show the image contained now we now have
80:00 - a much smaller image and if i showed the
80:03 - image information
80:05 - we now have on the left side
80:07 - 300x200 the 200 is what we specified
80:10 - that's the height of the image
80:13 - and when pillow scaled the image it
80:15 - realized it can reach a maximum height
80:18 - of 200 but to keep the aspect ratio it
80:21 - couldn't change the width to 500 so it
80:24 - kept the width to 300
80:26 - contain is what you would use if you
80:28 - want a specific pixel size
80:31 - and all right with that we have
80:33 - dimension changes there's one more part
80:35 - we can look at
80:36 - and that is adding and removing things
80:40 - and in here for example
80:43 - we could add image with a border and
80:46 - this one you get with image ops dot
80:49 - expand
80:51 - and then here at the minimum we need two
80:53 - named arguments oh well two arguments
80:55 - but i'm going to use named arguments we
80:57 - need the image and then we need a border
81:00 - and for the border we just need one
81:02 - number the border size in my case 100
81:05 - pixels
81:06 - and now if i show my image border
81:10 - we have a black border around the image
81:13 - and if you want to you can add a few
81:15 - more arguments in here
81:17 - and by default the color is black to
81:20 - change it you would need a fill argument
81:23 - and for example in here i could set an
81:26 - rgb tuple again let's say 255 255 and
81:30 - zero and now if i run this we should be
81:33 - getting yellow borders and there we go
81:36 - and there are three more things you can
81:38 - do you can add an image padded and this
81:42 - one works with image ops dot
81:45 - pad
81:46 - in here we need an
81:48 - image again and now we need a size
81:53 - and for the size
81:55 - let me use specific numbers here that is
81:57 - going to illustrate what this does a bit
81:59 - better let's say 1500 and 1 600. these
82:03 - numbers need to be bigger than the
82:05 - original image
82:07 - and now if i show my image padded
82:10 - you can see on the left and the right
82:12 - side some black bars
82:15 - but you cannot see bars on the top or
82:17 - the bottom
82:19 - the reason is
82:21 - that this padded only works on one side
82:24 - just like contain pillow tries to keep
82:26 - the aspect ratio so once we hit one of
82:29 - these sides pillow stops scaling the
82:31 - image or stops adding a padding
82:34 - there is also image fit and this one we
82:37 - get with image ops one more time and in
82:40 - here we want fit
82:42 - and once again we need image is equal to
82:46 - image
82:47 - and now for this one we need a size
82:50 - and let me add in 300 by 300 and let's
82:54 - see what happens
82:56 - so image fit if i run this
82:58 - we have cropped out the inner part of
83:01 - the image
83:02 - the way you have to think about it is
83:03 - that this was just about the entire size
83:07 - of the image
83:08 - and starting from the inside
83:12 - we have created an image with the height
83:15 - of 300 and a width of 300 as well
83:19 - i guess using the same number for width
83:21 - and height wasn't ideal here
83:23 - so let me change the width to something
83:26 - like 500 run this again
83:28 - and now you can see this a little bit
83:30 - better
83:31 - we are cropping the image from the
83:32 - center that's all that's happening here
83:35 - and actually the final part
83:38 - i can just copy because now we have a
83:40 - different way to crop the image
83:43 - and we don't need the size instead we
83:45 - have a border
83:47 - and for the border you have to specify
83:49 - one number
83:50 - let me define 100
83:53 - and this crop here works by cutting away
83:56 - from the border
83:58 - if i show the result we are getting an
84:01 - error the reason is that i forgot to
84:03 - change this fit to crop
84:06 - and now if i run this
84:08 - we are basically
84:10 - cropping this image from the border so
84:13 - we are moving this way
84:14 - i suppose the best way to visualize this
84:17 - is if i change this to a 400
84:20 - and now we are really close to the red
84:22 - panda
84:23 - and well with that let me uncomment all
84:26 - of those
84:29 - we have covered all of the basic parts
84:31 - of image ops
84:33 - so with this filters and enhance you can
84:37 - basically change the image to whatever
84:39 - you want and if you understand colors
84:41 - you have a good idea of what's going on
84:44 - these sections work really well together
84:47 - although there's one more thing that i
84:49 - haven't mentioned and that is the
84:51 - deformer although the deformer is
84:54 - getting a bit more complicated so i'm
84:57 - going to put all of this in a separate
84:58 - file
84:59 - and here we are we once more have a very
85:02 - minimalist setup
85:04 - and what i want to do
85:05 - is i want to run image
85:08 - ops
85:08 - dot
85:09 - deform
85:11 - and i want to deform the image i just
85:13 - import it
85:15 - now what does deform do and well this is
85:19 - probably one of the more complicated
85:20 - parts of pillow
85:22 - let me draw it right here to get the
85:24 - sense of what we are doing
85:26 - we are starting with an original image
85:30 - that could be the image we have imported
85:32 - right now
85:33 - and besides that we are going to create
85:36 - another image
85:38 - and what deform is doing or what it
85:41 - wants to do in the most basic sense
85:43 - it wants to cut out individual parts of
85:46 - the original image let's say we could
85:48 - cut out a part that looks something like
85:51 - this
85:52 - right now a pure rectangle but this
85:54 - could be any kind of shape
85:56 - and then this cutout we can put
85:58 - somewhere on the new shape we could put
86:00 - it in the same position
86:02 - although that would be kind of pointless
86:04 - we could also stretch it
86:07 - to something like this
86:10 - what we could also do in the original
86:13 - image
86:14 - we don't necessarily have to have a
86:15 - rectangle for example we could have a
86:18 - completely random shape that looks
86:20 - something like this
86:22 - the only limitation is it has to have
86:24 - four corners
86:26 - and if we put this on the new image
86:29 - it always has to be some kind of
86:31 - rectangle but if we put it somewhere
86:34 - here
86:35 - pillow is going to adjust the image
86:38 - it would for example in this case i
86:40 - think stretch out the corners to
86:43 - something like this
86:44 - and that way we can create a whole range
86:47 - of different effects for example what we
86:50 - could be doing let me clean this one up
86:52 - a bit
86:53 - we could select different parts of this
86:56 - image that are offset by a sine curve
87:00 - something like this
87:02 - and if these are then translated to the
87:03 - new image the image is going to be
87:06 - wobbled
87:07 - although i am not going to do that
87:09 - because that takes quite a while to
87:11 - implement
87:12 - and i want to keep things straight
87:14 - forward for this one
87:16 - for this d form
87:18 - it expects a second argument and this
87:20 - has to be a class or well it has to be
87:22 - an object but we are getting that from a
87:24 - class
87:25 - and in my case i want a deformer and
87:29 - make sure to add brackets here so we're
87:30 - turning a class into an object
87:32 - and now let's create the class for this
87:35 - object and this is deformer
87:38 - and in here we only need a single method
87:42 - and this one is called get mesh
87:45 - and it needs self as always but it also
87:48 - needs an image
87:50 - and now in here we have to cover a
87:52 - couple of important things
87:54 - number one we have to define a shape in
87:57 - the
87:58 - original image
88:01 - number two we have to define a rectangle
88:05 - in the new image
88:07 - and finally we have to return all the
88:11 - shapes
88:12 - and in here pay attention to the
88:14 - specific words
88:16 - we are defining a shape in the original
88:18 - image but we are defining a rectangle in
88:21 - the new image
88:22 - and that is intentional wording here in
88:25 - the new image we are always defining a
88:28 - rectangle
88:30 - but in the original we can define any
88:32 - kind of shape it just has to have four
88:34 - points
88:35 - i suppose let's get started on this that
88:38 - should explain all of this the best and
88:40 - i want to create variables here
88:42 - let's start with the source shape
88:46 - and for this
88:47 - we need a tuple with eight different
88:50 - points
88:51 - and for the target rectangle
88:54 - i want a target rectangle and since you
88:57 - can express a rectangle easier this one
89:00 - is also triple but it only needs four
89:02 - points
89:03 - i guess let's start with this one this
89:05 - one is easier to explain
89:07 - for this target rectangle the four
89:09 - points we are specifying are left
89:12 - top right and bottom
89:15 - let me cut it out and add the same thing
89:18 - as a comment
89:20 - and for example i could write in here 0
89:23 - 0 100 and 200
89:27 - and this would mean our rectangle starts
89:29 - on the left side and at the top
89:31 - so the left at the top is zero and zero
89:34 - then we have zero for the right side
89:37 - and the bottom would be 200
89:40 - if this was the entire new shape we
89:43 - would start here and here
89:46 - then the right side would have something
89:49 - like 100 points here and then the bottom
89:52 - would be somewhere down here to cover
89:54 - the 200 points
89:56 - something like this
89:58 - for the source shape this gets a good
90:00 - bit more complicated
90:03 - because in here we don't specify a side
90:06 - we are specifying a specific pixel
90:08 - position
90:10 - let me actually draw it this one can get
90:12 - incredibly confusing
90:14 - this here is our original image
90:18 - this picture here right now and in the
90:20 - tuple here i could for example specify
90:22 - zero and zero and this would put us
90:26 - all the way at the point here
90:29 - and what pillar wants is eight values in
90:32 - total here
90:33 - with these two points being the first
90:35 - tuple then we want tuple number one then
90:39 - tuple number two tuple number three as
90:42 - well
90:43 - and the one tuple we have specified so
90:45 - far is zero and zero and for tuple 1 and
90:48 - 1 we need another kind of position
90:51 - for example in here i could specify
90:55 - 200
90:56 - for the x position and 0 for the y
90:59 - position
91:00 - if i do that i get my second point and
91:03 - this would bring me somewhere here to
91:06 - position 200 and 0. and after that i
91:10 - would have to specify four more numbers
91:12 - for two more tuples
91:14 - it honestly is kind of annoying to
91:16 - explain now what i have done to just get
91:19 - started
91:20 - i got the width and the height of the
91:22 - original image and this we get with
91:24 - image dot size
91:27 - and for this tuple here let's do an
91:29 - actual example that should be much
91:31 - better i still want to start at position
91:34 - 0 and 0. this is going to be our first
91:37 - point
91:38 - let me underline it so we're not getting
91:40 - lost
91:41 - for the second point i want to stick on
91:43 - the left side
91:44 - but now
91:45 - i want to go all the way to the bottom
91:47 - so the height of the image i suppose we
91:49 - can draw all of this that should be even
91:52 - better
91:53 - the point we started on was this one
91:54 - here and the point we just created 0 and
91:58 - h is the point all the way down here
92:01 - we are still at position 0 or the x part
92:04 - but now for y we are at height or the
92:07 - height of the image
92:08 - next up
92:09 - i want the width and the height
92:12 - and these two numbers get us all the way
92:15 - to the bottom
92:16 - in here we have w
92:18 - and h
92:21 - and finally i want to go all the way to
92:23 - the top left
92:24 - and this one we get with w and zero
92:28 - which is this point up here w for x and
92:32 - zero for y i guess let me add zero and
92:35 - zero for top left as well
92:37 - and with that we have eight points and
92:39 - these eight points right now specify our
92:42 - entire original image
92:45 - and this entire image these eight points
92:47 - here we want to put
92:49 - on a new image
92:51 - with these
92:53 - dimensions here
92:54 - and for that we need the final bit and
92:57 - that is to return all of the shapes
93:00 - and what pillow wants here
93:03 - is it wants all of this returned inside
93:05 - of a list and then inside of another
93:08 - tuple
93:09 - and we have to start with the target
93:12 - rectangle and then with the source shape
93:15 - and that is all we need and this is
93:18 - going to return a new image as well
93:21 - which i can store in a variable
93:23 - and now if i show
93:25 - the form
93:27 - we get the entire image squashed to the
93:30 - top left
93:31 - now this obviously isn't particularly
93:33 - useful
93:34 - but these points here you could also
93:37 - influence for example if i just wanted
93:39 - to copy this image i could add w and h
93:43 - in here
93:44 - and now this image would be copied one
93:46 - to one
93:48 - but for example i could
93:51 - have the size of the width and now the
93:54 - image will be squashed on the left side
93:57 - and what is even better right now both
94:00 - the source shape and the target
94:01 - rectangle are rectangles so we're just
94:04 - scaling the image
94:05 - but if this one here wasn't a rectangle
94:09 - let's say for this is the first point
94:11 - the second point for the bottom right
94:13 - point this one here
94:14 - if the width wasn't on the right side
94:17 - let me actually draw this
94:19 - if i were to put this width somewhere
94:22 - let's say
94:23 - here
94:24 - then the shape we are getting from all
94:26 - of this
94:27 - would look something like i am kind of
94:30 - running out of colors this is a problem
94:32 - let me use blue the shape i would be
94:34 - getting now
94:35 - would look something like this
94:39 - we are not having a rectangle anymore
94:43 - but
94:43 - what pillow gets as a target is
94:46 - this rectangle here
94:48 - so pillow is then going to account for
94:50 - that and stretch out all of these pixels
94:54 - to turn this into a rectangle again
94:57 - let me demonstrate this we can get the
95:00 - width of the image minus 1000
95:03 - and
95:04 - let's fill out the entire target shape
95:07 - so it's easier to see
95:08 - if i run this now
95:10 - you can see
95:11 - the bottom right pixel all of this stuff
95:13 - here
95:14 - is massively stretched to this side
95:18 - and this happens because pillow tries to
95:20 - account
95:21 - for this irregular shape here
95:24 - and this is something you definitely
95:26 - want to go over a couple of times it
95:28 - took me like an hour to understand it
95:30 - it's really hard to work with when
95:32 - you're just getting started but if you
95:34 - understand it it is incredibly powerful
95:37 - let's actually do a more complicated
95:39 - example
95:41 - because
95:42 - what you can do in here
95:44 - is define more than one shape or more
95:48 - than one target and source area
95:51 - and in here i want to define a left side
95:54 - and for this i need a target and i need
95:57 - a source shape i guess let me be a bit
96:00 - more specific i need a target
96:02 - rectangle and a source shape for the
96:05 - target rectangle
96:07 - i want a tuple
96:09 - with zero zero
96:11 - width divided by two and the height by
96:14 - itself
96:16 - this is just going to get us half of the
96:19 - target image
96:20 - and for the source shape let me copy
96:22 - this in actually i have something like
96:24 - this and this is going to be really hard
96:26 - to read i should draw this
96:29 - the eight points we are
96:32 - getting from this r
96:34 - we are starting in the top left here and
96:36 - here again
96:37 - after that
96:38 - we are going all the way to the bottom
96:41 - to here
96:42 - next up we are going to half of the
96:44 - width and we are staying at the bottom
96:46 - so we are just about here
96:49 - and finally we are going to the middle
96:50 - of the top so we are here the result is
96:53 - going to be
96:54 - half of the image
96:57 - and this half of the image we are
96:59 - putting on the left side of the target
97:01 - image
97:02 - right now we are just copying the left
97:05 - side of the image
97:07 - obviously not particularly useful but
97:09 - now i can also add a right side and for
97:12 - this right side i again need a tuple
97:15 - with the target and the source
97:19 - for the target i now want to target the
97:22 - right side of the target image
97:24 - and this is going to be
97:26 - width divided by 2 for the starting
97:28 - point and we want 0 for the height
97:31 - and for the end we want w and h
97:34 - if i am drawing this one
97:36 - with divided by two and zero is getting
97:39 - us to this point here
97:41 - and then width and height basically
97:43 - bring us to the right side of the image
97:46 - and to the bottom of the image
97:48 - we are literally just on the right side
97:51 - of the image now
97:52 - and now we come to the actually
97:55 - interesting bit because for this one the
97:57 - coordinates are
98:00 - this point here
98:01 - and to understand what is happening let
98:03 - me actually show the outcome and for
98:06 - that we just have to return
98:08 - the different positions we get so we
98:10 - have the first transfer or deform and
98:12 - then the second one and if i run this
98:15 - now we can see something like this
98:18 - and what happened here is we copied the
98:21 - left side of the image one to one this
98:24 - goes up to just about here
98:27 - but for the right side we have copied
98:29 - the left side of the image copied it
98:32 - over and then reversed the direction
98:35 - and this is where deform becomes
98:37 - incredibly powerful you can do a lot of
98:40 - really funny things with it but let's
98:42 - talk about how this works and for that
98:44 - we have to go through these positional
98:46 - points
98:47 - and i hope you can still follow along i
98:49 - know this is getting really complicated
98:52 - here once again
98:54 - we have the original image
98:57 - and the points we are selecting we are
98:59 - starting with width divided by two and
99:02 - zero
99:03 - meaning we are starting here ish
99:06 - and next up we are going to width
99:08 - divided by two and height so we are
99:11 - moving all the way down here and we are
99:13 - ending on this point
99:15 - the next point is zero and height so we
99:17 - are moving here
99:20 - and finally we are going to zero and
99:22 - zero so the point up here and then we
99:25 - are closing the shape by going back to
99:27 - the original point
99:28 - and the reason why this flipped the
99:30 - image is because the direction of these
99:32 - points really mattered where the magic
99:34 - happened was in this arrow down here
99:38 - where we are moving from the right side
99:40 - to the left side and this is what's
99:42 - reversing the image
99:44 - probably go over this a couple of times
99:46 - eventually it will start make sense
99:49 - another example i did by myself is to
99:51 - flip the entire thing and this one you
99:53 - can add in here for the right side
99:56 - and this one is flipping the red panda
99:58 - on the halfway point
100:00 - and again i am primarily using
100:03 - rectangles but you don't have to you
100:05 - could add any kind of shape you want in
100:06 - here for example for this final width i
100:10 - could subtract 1000 pixels
100:14 - and now we are stretching out the entire
100:16 - image
100:17 - and if you understand how this works you
100:20 - can create some really advanced shapes
100:23 - like a fisheye lens or you could account
100:25 - for a fisheye lens you could wiggle the
100:27 - image you could do basically whatever
100:29 - you want it's really powerful
100:31 - and i'm going to leave it at that i
100:33 - don't want to make things even more
100:34 - complicated although if you want to
100:37 - learn more about it there is a really
100:39 - good example i found online and this one
100:42 - creates this kind of shape although to
100:45 - create it
100:46 - you need some slightly more advanced
100:49 - code that relies a bit more on math i
100:51 - suppose it's not that complicated you
100:53 - could definitely figure it out if you
100:55 - were able to follow along so far i'm
100:57 - going to add a link in the description
100:59 - or i guess i could just add it at the
101:01 - end here more advanced
101:04 - example there we go
101:07 - with that we have covered the most
101:09 - difficult part of this entire tutorial
101:11 - next up let's do something easier
101:14 - and for the next part we are drawing
101:16 - some shapes this one should be fairly
101:18 - straightforward and pillow can draw lots
101:20 - of different shapes like rectangles
101:22 - squares circles basically anything you
101:25 - want and we can also draw text
101:28 - i know that drawing here isn't the
101:29 - perfect word but they are in the same
101:32 - sub-module of pillow so
101:34 - i'm going to put them together all right
101:36 - here we are in a new python file and
101:40 - besides image i want to import image
101:43 - draw
101:44 - and now before we can start drawing we
101:46 - have to create a draw object and this
101:48 - you do with image draw dot draw
101:52 - and then the image you want to draw on
101:54 - which in my case is the image itself
101:56 - and this one is creates a draw
102:00 - object
102:01 - once you have that drawing becomes
102:03 - really easy let's start with drawing
102:06 - some basic shapes
102:07 - i could for example draw a rectangle
102:11 - and in here pillow expects a tuple with
102:14 - four different arguments
102:16 - we need the left the top the right and
102:19 - the bottom all in pixels for example i
102:23 - could add the left 0 and the top 0
102:26 - the right 100 and the bottom 200 and
102:30 - once i have all of that
102:31 - i can image dot show
102:35 - and we can see in the top left we have
102:38 - the outline of a rectangle
102:40 - let me zoom in a bit
102:43 - the left side of the rectangle is at
102:44 - position 0. the top is at position 0.
102:47 - the right side is at position 100 and
102:50 - the bottom is at 200
102:53 - and once you figured out that part the
102:55 - rest should be fairly simple
102:58 - for example you could put a rectangle at
103:00 - the position 200
103:02 - 400
103:04 - then 700 and 600
103:08 - and now we have a shape that is a bit
103:10 - more in the middle of the image
103:12 - if you don't like the colors you can
103:14 - also change that very easily
103:16 - for a fill color you need fill and in
103:20 - here
103:21 - you have to specify either a word like
103:23 - red or a tuple with rgb colors
103:27 - like 255 0 and 0. if i run this now we
103:31 - have a proper red rectangle
103:33 - you can also specify an outline this one
103:36 - has the same kind of color requirement i
103:39 - guess i can start with a word here
103:41 - yellow is totally fine and now we have
103:43 - yellow outlines you can also change the
103:46 - width of the outline to something like 5
103:49 - and now we have a thicker outline
103:52 - and that covers the rectangle and let me
103:55 - copy it actually
103:56 - because very similar to the rectangle is
103:59 - the
104:00 - ellipse because this one also needs a
104:03 - rectangle as an outline
104:05 - what pillow is doing internally when we
104:07 - are defining
104:08 - a rectangle like this one here
104:11 - it puts an ellipse inside of it
104:14 - something like
104:16 - this
104:17 - that is a horrible ellipse let me try
104:19 - this again
104:21 - okay a little bit better
104:23 - we are putting the ellipse inside of the
104:24 - box that surrounds it
104:26 - and let me give it some different colors
104:29 - i guess for this one 255 and for the
104:31 - outline we can go with
104:34 - purple i think is supported
104:36 - there we go
104:37 - now you can see they are in the same
104:39 - position but the ellipse is inside of
104:41 - the rectangle
104:42 - besides these two you can also draw a
104:45 - polygon
104:47 - and for this one we just have to specify
104:50 - a couple of individual points and those
104:52 - are just tuples inside of one larger
104:54 - tuple
104:55 - we have tuple one here tuple two and let
104:58 - me define
105:00 - four bolts in total like this
105:03 - and each tuple would need x and y
105:06 - positions i guess we can start with zero
105:09 - and zero so it's easier to understand
105:11 - then for the next tuple i go 100 pixels
105:14 - to the right but i stay on the top
105:16 - then for the next one i go to 100 and
105:19 - 100 and for the final one i go to 50 and
105:24 - 200
105:25 - and let's see what we get
105:28 - you can see in the top left
105:31 - we started at position zero and zero
105:33 - then we moved to i think this was one
105:35 - hundred and zero
105:38 - then we moved down
105:40 - to this point here one hundred and 100
105:45 - and then the final point was this one
105:48 - here and i believe this one was 50 and
105:51 - 200.
105:53 - and pillow connects all of these shapes
105:55 - and this is what we get and here again
105:58 - you can add more named arguments to add
106:01 - more customization
106:03 - if i run this one now we get some
106:05 - different kind of colors
106:06 - if you look at the documentation this
106:08 - one is really easy to figure out
106:10 - and the final one is very similar
106:13 - compared to the polygon this one is
106:14 - called line
106:16 - and then here again you need different
106:19 - points inside of a tuple i guess let me
106:22 - use different ones let's say 800 and
106:25 - 1000
106:26 - then 1000 and
106:29 - 1000 and 1200 and 1000 and i want to
106:35 - keep to three points and for the fill i
106:38 - want to go with black
106:40 - and in here you don't need an outline
106:43 - instead you would define a width
106:46 - and the width is just an integer could
106:47 - be 10
106:48 - and i guess one more interesting point
106:50 - you could add a joined outline and this
106:54 - is how the points connect with each
106:56 - other
106:57 - for example you could add a
107:00 - curve in here
107:02 - and if i run this now we can see a black
107:05 - line that looks really boring i guess
107:07 - the middle point here should be
107:08 - something like 1
107:10 - 500.
107:12 - that is much better although also not
107:14 - great let me put the 1100 so we can see
107:18 - the joint
107:19 - there we go
107:21 - if i zoom in
107:22 - the one interesting bit here is that
107:25 - this point here is curved out a tiny bit
107:28 - the reason why it is curved out is
107:30 - because of this curved named argument
107:32 - here
107:34 - if i get rid of it and run this again
107:37 - this one is looking much sharper and
107:39 - isn't even properly connected
107:42 - all right this is stuff you can figure
107:43 - out yourself really easily if you look
107:45 - for the documentation
107:47 - besides that we can also i call this one
107:49 - in my notes draw circle
107:52 - thingies
107:54 - i could not come up with a better name
107:56 - you are basically drawing round shapes
107:58 - like a pie chart for example but there
108:01 - are a couple of different ways to
108:02 - approach this the easiest one is draw
108:06 - dot arc
108:07 - and in here pillow is expecting just
108:10 - like for the rectangle and the ellipse
108:12 - some kind of rectangle in my case
108:14 - something like this
108:16 - and besides that it also wants a start
108:18 - and an end argument
108:21 - and
108:22 - let me just start with some numbers
108:24 - these are both angles the start angle
108:27 - could be 20 degrees and the end angle
108:29 - could be 180 degrees
108:31 - if i run this now
108:33 - it's very hard to see it's up here
108:36 - i suppose we can customize this already
108:38 - a fair bit
108:40 - i could for example change the width of
108:42 - this
108:43 - and now this is much more visible
108:46 - and the way you have to think about it
108:48 - is that
108:49 - angle 0 is here and this angle
108:53 - goes like this these are 20 degrees
108:56 - and 180 degrees all the way up here is
109:00 - to go halfway around it
109:02 - if you added 360 you would add again at
109:05 - the starting point
109:06 - let's actually play around with this
109:09 - if i add the starting point to 0 and the
109:11 - end point to 360 i have a full circle
109:16 - looks like this
109:17 - if i change the start point to 10
109:19 - degrees and the end point to something
109:21 - like 40
109:24 - i get with a very short slice of this
109:27 - and i guess what else you can do you
109:29 - could for example fill this with a color
109:32 - let's say red in my case
109:34 - and there you go now this thing is red
109:36 - there are two slightly more advanced
109:39 - versions of this arc so let me copy it
109:41 - once and the slightly better version is
109:44 - called chord or not better but more well
109:47 - powerful
109:49 - let me comment out the original one if i
109:51 - run this one
109:53 - we are now getting a slightly different
109:55 - shape it's very hard to see because the
109:57 - arc we are covering is very short if i
110:00 - change this to 180
110:03 - you can see it much better
110:05 - we are basically creating a half circle
110:07 - that is closed
110:08 - so here is i think 10 degrees here we
110:11 - have 180 degrees and then we are closing
110:15 - this half circle
110:17 - and finally i can duplicate all of this
110:20 - one more time
110:21 - and comment out the original besides
110:24 - chord we also have what is called pi
110:26 - slice
110:28 - and this should be spelled like this
110:31 - if i run this one
110:33 - we are now getting a pie chart that let
110:36 - me zoom in a bit
110:39 - here's the center of the pie chart
110:41 - here we have 10 degrees and here we have
110:44 - 180 degrees
110:47 - and with that you have the three
110:48 - different ways to create some circly
110:51 - thingies i still don't know how to call
110:53 - them
110:55 - and for the final part for the shapes we
110:57 - have drawing text and this one is really
111:00 - easily done
111:02 - all you need is draw.text and then here
111:05 - you need a position
111:06 - let's say in my case 1 300 and 640
111:11 - and then you need a word that is just
111:13 - going to be a string let's say panda
111:17 - if i run this now it's very hard to see
111:20 - but there we can see panda
111:23 - now this text this text right now
111:25 - doesn't look very good and to customize
111:27 - it we need something else and this is
111:30 - called image font
111:32 - and this one allows us to create a font
111:35 - and this you store in a separate
111:36 - variable and here use image font
111:40 - and then dot
111:42 - true
111:43 - type
111:44 - and truetype is a file format for fonts
111:48 - oh and i actually forgot to mention
111:51 - while i was recording this i forgot to
111:54 - add in the true type file format it's
111:58 - this one here in the code now
112:00 - and this is what we are going to import
112:03 - and for that all you need is the name of
112:05 - the file which in this case is
112:07 - hellogen.ttf
112:11 - and now we have font so when we are
112:13 - drawing the text we can specify that the
112:16 - font is the font
112:18 - and now if we run this
112:21 - we get a different font the issue is
112:24 - this is way too small to see
112:26 - but that is not a major problem because
112:29 - when we create a font we can set a size
112:32 - let's go with 80.
112:34 - and if i run this now this is much
112:37 - easier to see
112:39 - and if you want colors you could add
112:41 - something like fill and add what's the
112:44 - color i haven't used yet i think this
112:46 - one
112:47 - is a light blue
112:50 - it really doesn't matter choose whatever
112:51 - you want in here
112:53 - and for text you have a few more things
112:55 - you could be working with
112:57 - for example a line is something that is
113:00 - quite useful if you have more text
113:03 - and in here you could choose let's say
113:06 - something like center to center the text
113:09 - although in this case you're not going
113:11 - to see much of a difference
113:14 - the one parameter in here that is a bit
113:16 - more difficult to understand is the
113:18 - anchor
113:19 - for this one you always need two letters
113:22 - like m m for middle and middle
113:25 - and i think if i look at the
113:27 - documentation this should explain it the
113:29 - best
113:30 - and here we go and if you look at it you
113:33 - can see the entire guide all you need is
113:36 - here
113:37 - by default you are placing this top left
113:40 - point here
113:41 - and with the anchor you can customize
113:43 - which point you are placing
113:44 - for example
113:46 - if you place m
113:48 - and m here you are getting to the middle
113:51 - of the text
113:53 - if you used a different example
113:55 - let's say right and top
113:57 - you will be placing this point here
114:00 - and this way you can be much more
114:01 - deliberate when you position the text
114:04 - and when you are placing these arguments
114:06 - the first one is always for the
114:07 - horizontal the second one for the
114:09 - vertical
114:10 - i could place the right and the top here
114:12 - and now the angular or the placing
114:15 - position of the text would be the top
114:16 - right
114:18 - so if i run this now the text is a bit
114:20 - more to the right and a bit further down
114:22 - because i am placing this point here
114:25 - and with that
114:26 - we have all of different shapes you
114:28 - could be drawing in pillow it really is
114:31 - quite simple
114:34 - and with that we can come to the final
114:36 - part of this video and that is combining
114:38 - images and for this we have a couple of
114:41 - different ways
114:43 - we can use the inbuilt methods of the
114:45 - image object there are quite a few
114:47 - actually
114:48 - but what you're going to use most of the
114:50 - time for merging images is image jobs
114:52 - this one is much more powerful
114:55 - and in this section i'm also going to
114:57 - cover masking
114:59 - which is basically what you need to cut
115:01 - out alpha bits in an image
115:04 - and once again i have a new python file
115:07 - except this time it is a bit more
115:10 - complex or well not that much we are now
115:12 - importing three different images we have
115:15 - the panel we have already seen we have
115:17 - an owl and we have the python logo i
115:20 - suppose let me show them so owl.show
115:23 - we have an owl
115:25 - and we have
115:27 - the python logo looks like this
115:30 - i should mention at this point i have
115:32 - added a few more pictures to the project
115:34 - folder
115:35 - it now looks like this
115:38 - i have added the owl picture here and
115:40 - now we also have a mask this one we are
115:43 - going to use in just a bit
115:45 - what we can start with is merging
115:49 - images
115:52 - with let's call it image
115:54 - methods
115:55 - and we have a couple of methods that we
115:57 - could be using here
115:59 - all of them are part of the image class
116:02 - one for example is called blend
116:04 - and this one just takes two images let's
116:06 - say in my case my panda and the owl
116:09 - and for the third argument we need some
116:12 - kind of alpha value let's say for a
116:14 - start we can leave this at 1.0
116:17 - and this is going to return a new image
116:20 - which we can store let's call it image
116:22 - blend
116:24 - and this if i show it we get image blend
116:28 - and now we can see only the owl
116:32 - the reason is
116:34 - we are putting the owl on top of the
116:36 - panda and then we are basically using
116:39 - full alpha here so we're only showing
116:41 - the owl
116:42 - if i set this to something like 0.5
116:47 - then you can see a much better blend we
116:49 - have the owl in the foreground and the
116:51 - red panda in the background
116:53 - and that would be one way to combine
116:56 - these two images now there are two
116:58 - things you do need to consider here
117:01 - and that is that both images need
117:05 - same
117:06 - size and mode
117:09 - and right now both the panda picture and
117:11 - the old picture have the same size and
117:13 - they do have the same mode so we are
117:15 - good here however if i added the python
117:18 - image and run this again
117:20 - we are getting a value error that the
117:22 - images do not match because this
117:25 - python image here is much smaller and
117:28 - this can be a bit annoying but i will
117:30 - show you a few ways to play around with
117:32 - this
117:33 - now besides blend we also have image
117:36 - composite
117:38 - and this one again needs two images with
117:40 - the same size so in my case panda and
117:43 - owl
117:45 - and finally it is going to need a mask
117:48 - and the masks determine which parts are
117:50 - being cut out here i will cover masks in
117:53 - more detail later on in this section for
117:56 - now i just want to cover the entire
117:59 - image
118:00 - and a mask is just going to be another
118:03 - image where you can set a certain size
118:06 - for example what i could be doing here
118:08 - is just use image new
118:10 - and now i have to set a mode and usually
118:13 - a mask is in l mode
118:15 - where we just have black and white then
118:17 - we need a size of the image and this we
118:19 - get with panda.size
118:21 - so the size of the panda image
118:23 - and finally we can actually set a third
118:26 - parameter in here and this i don't think
118:29 - i have covered yet but this one is
118:31 - called color
118:33 - for now let me set it to 255 the maximum
118:36 - you can set in here at least for l
118:38 - values
118:39 - and this is now going to return a new
118:42 - image which again we can store let's
118:45 - call this image composite
118:48 - and
118:49 - this
118:51 - if i show it
118:53 - is going to look like this we only have
118:56 - the red panda
118:57 - the reason is because of this value here
119:00 - if i set this one to zero
119:02 - we can see only the owl
119:05 - and if i set this somewhere in the
119:07 - middle let's say at 100
119:11 - then we can see how these two images are
119:13 - merging with each other
119:15 - and to understand how all of this works
119:17 - you have to understand this number here
119:20 - it basically sets the gray value for
119:22 - this entire image
119:25 - if this was 0
119:27 - this entire thing would be black
119:29 - if it was 255 let me use a different
119:32 - color 255 all of this would be white
119:37 - and when we are using a mask white means
119:40 - we want to show all of it and black
119:42 - means we want to show none of it so the
119:44 - closer this thing gets to 255 the more
119:47 - we are showing off
119:49 - let me show it again
119:51 - so if this is 255 this mask here is
119:55 - white meaning if i show it we can only
119:58 - see the red panda
120:00 - this original one here
120:02 - is now using this mask and since the
120:04 - mask is all white we are showing this
120:07 - image entirely
120:08 - if it is zero
120:10 - the entire mask is going to be black
120:12 - meaning we are showing none of these
120:14 - pixels here and we can only see the owl
120:18 - which if i run this we can see the owl
120:20 - indeed
120:21 - and if i set any value in between let's
120:24 - say 50
120:26 - then we have some level of transparency
120:28 - in here
120:30 - again i will cover mass in more detail
120:32 - in just a bit
120:34 - and with that we have different ways to
120:37 - overlay images
120:38 - now the limitation we have right now is
120:41 - that these images always have to have
120:43 - the same size
120:44 - but that we can get around with image
120:47 - paste
120:49 - and this literally is we are calling one
120:51 - image and we are pasting another image
120:54 - on it it's just a method
120:56 - and in here i need two arguments i need
120:59 - the image and i need the position i want
121:01 - the image to be in
121:03 - for example in my case i want to put my
121:05 - python image on the panda image and for
121:08 - now at the position zero and zero
121:11 - and if i now show my panda
121:15 - you can see the python logo in the top
121:17 - left this one is looking pretty good
121:19 - although
121:20 - you can see quite a noticeable problem
121:23 - we still have the background
121:26 - and this is a problem in pillow right
121:29 - now
121:30 - if i show the image again in the file
121:32 - explorer
121:33 - we have transparency in here so this
121:36 - transparency does not show up in pillow
121:38 - to get the transparency we are again
121:41 - going to need a mask
121:43 - and now how this mask is going to work
121:47 - we again want the python image and if i
121:50 - run this now we have the proper cutout
121:54 - and now you could move this python logo
121:56 - around to wherever you want
121:58 - the first argument here is the
122:00 - x-coordinate the second one is the
122:02 - y-coordinate let's say 300
122:05 - and now the python logo is a bit further
122:07 - to the right and a bit further down
122:09 - notice here we are placing the top left
122:11 - point
122:13 - anytime you have any kind of transparent
122:15 - image that you want to put on something
122:16 - else you would use paste and then you
122:19 - would use the image
122:21 - python in this case
122:23 - and then the image itself as a mask
122:26 - and all right with that we have some
122:29 - basic ways to put one image on another
122:32 - but there is something much more
122:33 - powerful and this is called something
122:35 - like channel
122:37 - operations
122:38 - and this is something we have to import
122:41 - what we need is image
122:43 - shops
122:44 - and shops here stands for channel
122:46 - operations
122:48 - and this is the one part of pillow that
122:51 - is concerned entirely with combining
122:53 - different images
122:55 - i suppose a really easy one here is
122:58 - image and i want to create an overlay
123:00 - between my panda and my owl
123:04 - and this i'm going to get with image
123:07 - chops
123:08 - dot
123:09 - overlay
123:10 - and now on here we need two images and
123:13 - in my case i want my panda and my owl
123:15 - and now i want my image overlay if i run
123:18 - this
123:19 - we are getting an error because this
123:21 - needs to be an uppercase i
123:24 - here and here now if i run this
123:26 - there you can see we have the owl we
123:29 - have the repunda and we have the python
123:31 - logo although in my case i want to
123:34 - comment out all of this to keep things a
123:36 - bit more organized
123:38 - now if i run this again
123:40 - we only have the overlay with the owl in
123:42 - the foreground and image jobs has lots
123:45 - more methods that we could be using
123:47 - since they all work in the same way let
123:49 - me just copy paste them in we have
123:51 - darker lighter soft light hard light
123:53 - difference modulo and screen
123:56 - and they all work in the same way that
123:58 - we have one image another image and we
124:00 - are merging them together in some
124:02 - different way
124:03 - i guess let me do some examples here we
124:06 - have image screen for example the one
124:08 - all the way at the bottom this one looks
124:11 - like this very bright
124:13 - we also have image darker and this one
124:16 - if i run it
124:18 - only picks the darkest pixels between
124:20 - these two images
124:22 - for example you can see the owl here
124:25 - really well
124:26 - because the out has lots of dark pixels
124:29 - same with the panda legs here and here
124:32 - they are very dark so they're very easy
124:33 - to see and this blending mode always
124:36 - picks the darkest pixel and lighter does
124:39 - the exact opposite it always picks the
124:41 - brightest pixel meaning now we can see
124:44 - more of the red panda because he is a
124:46 - bit brighter
124:47 - i guess a good one here is image
124:49 - difference because this one is a bit of
124:52 - a nightmare image to look at
124:56 - but well i hope you get the idea all of
124:58 - those are really easy to implement
125:00 - but there are a few more
125:03 - and those are called more complex
125:06 - channel operations because all of those
125:09 - need more arguments besides two images
125:12 - the first one is image
125:14 - shops dot add
125:16 - and this one again needs two images in
125:19 - my case again i want the panda and the
125:21 - owl but now we also need scale and this
125:24 - by default is 1.0 and we need an offset
125:29 - and this by default is zero
125:31 - and this again is going to return
125:32 - another image let me call it image ahead
125:35 - did or just image add i think that makes
125:37 - more sense
125:39 - and now if i run image add
125:42 - we can see we have some kind of addition
125:45 - where we are combining the brightness of
125:47 - each pixel
125:48 - and these two arguments make this
125:51 - brighter as well for example for scale
125:53 - if we choose a higher number here like 5
125:56 - it makes all of this darker and if we go
125:59 - down to something like 0.5
126:04 - this thing is becoming even brighter
126:07 - let me keep it at 2 i think that looks
126:09 - better something like this
126:12 - and offset this one the higher you put
126:15 - it let's say 10
126:16 - the brighter the image becomes
126:19 - i'm not sure how these two parameters
126:21 - differ i couldn't really find anything
126:23 - good on them but if you add 100 in here
126:26 - the entire thing gets brighter
126:28 - just play around with this it's not that
126:30 - complicated
126:32 - and if we have add we also have subtract
126:36 - which i get with the subtract method
126:40 - and this one has the exact same named
126:42 - arguments we have scale and we have
126:43 - offset
126:44 - so my image subtract i can show it and
126:48 - now we get some slightly nightmarish
126:51 - result again
126:52 - again here play around with the
126:55 - parameters this one is quite easy to
126:57 - work with
126:58 - actually speaking of nightmare fuel when
127:01 - i played around with this there's one
127:03 - thing i did forget to mention and that
127:05 - is image blend
127:06 - if you add a really large number in here
127:09 - let's say 10
127:10 - and then
127:12 - show
127:13 - image blend
127:15 - you get
127:16 - some horrifying nightmare thing i
127:19 - really wanted to show that you probably
127:21 - are never going to use it
127:23 - but use it if you want to scare someone
127:25 - or something like that
127:27 - okay and then we have two more that i do
127:29 - want to show and the name here is going
127:32 - to be a bit weird i call this one image
127:35 - underscore logical underscore end
127:39 - the reason why i called it like that is
127:41 - because we are again using image jobs
127:43 - but now the method is called logical
127:46 - underscore and
127:48 - and in here we again need two images
127:51 - i want to use my panda and my owl once
127:53 - more and i want to show the result so
127:56 - image logical and
127:58 - but we are going to get an error
128:00 - and the error is that the image has a
128:02 - wrong mode
128:04 - what pillow wants for both of the images
128:07 - in here is they have to be in one mode
128:10 - meaning all of the pixels either one or
128:12 - a zero
128:14 - and this we can get by converting both
128:17 - to the one mode
128:20 - and now if i run this
128:22 - we get this kind of result
128:26 - and besides and we also have the or
128:28 - operator here if i show that one
128:32 - we get the exact opposite operation
128:36 - why you would want to use that honestly
128:38 - i have no idea i'm sure there's some
128:40 - really specific use case that you might
128:43 - need
128:44 - with that we have the more complex
128:47 - operations
128:48 - there is one more thing
128:51 - in the image jobs that is super easy and
128:54 - i'm not sure why this in there in the
128:55 - first place
128:57 - we can invert an image
129:00 - we need again
129:01 - image chops and now we need invert and
129:05 - in here we only need a single image
129:08 - let's say my panda again
129:11 - and if i show this image invert
129:15 - we get the inverted image of the panda
129:19 - and i think by now we have seen like
129:21 - five different ways to get the same
129:22 - result
129:23 - there are lots of different ways to get
129:25 - the same outcome in pillow it works
129:27 - somewhat like photoshop
129:29 - and well if you get this far
129:32 - this is pretty much all you can do with
129:35 - channel operations
129:37 - and with that i can comment out all of
129:40 - them
129:41 - because for the next part
129:44 - i want to talk about
129:47 - mass
129:48 - let's call it masking and the general
129:50 - idea of a mask is let me go over this in
129:53 - quite some detail i think that is
129:55 - important if this here is our image a
129:58 - mask in the most basic sense is just
130:01 - another image but this one needs to have
130:03 - some kind of alpha value how this works
130:06 - can be done in a couple of different
130:08 - ways
130:09 - the easiest one to explain is we could
130:11 - have an r g b
130:14 - a
130:15 - image and for the a part we make sure
130:18 - that some pixels are hidden for example
130:20 - we could have an image that only covers
130:23 - something like this of the screen
130:26 - and if we then apply this mask what you
130:29 - would actually see in the end would only
130:31 - be the part inside of the mask so all of
130:34 - this red bit here would be visible
130:35 - because this is what we are cutting out
130:37 - with the mask
130:38 - the best way to think about a mask is to
130:40 - compare to a cookie cutter with the
130:42 - yellow bit here being the dough and the
130:45 - red bit being the cutting part i'm not
130:47 - sure what the actual name is
130:49 - and in pillow this mask can work in a
130:51 - couple of different ways we could either
130:54 - use an rgba tuple where all the
130:56 - transparent pixels are the empty parts
130:59 - of a mask so this bit here would be
131:01 - invisible there's another way though
131:03 - that is i think a bit more common and
131:06 - that is to only use black and white
131:09 - images
131:10 - and in this case all the white parts
131:12 - would be visible and all the black parts
131:15 - would be hidden
131:16 - meaning in this case
131:18 - all of this stuff here would be visible
131:21 - and this bit here would be black i
131:24 - suppose let's implement all of this and
131:27 - that should illustrate it better
131:29 - but i do want to add a comment that a
131:31 - mask must have a specific mode
131:36 - we can have rgba 1 or l
131:40 - if you have any other mode this is not
131:42 - going to work
131:43 - first of all we have to actually import
131:45 - an image that we are going to use as a
131:47 - mask and this i'm going to save in a
131:50 - variable called mask and to get this
131:52 - image we need as always image open
131:56 - and in my case i want to import mask.png
132:00 - and this if i show the image
132:03 - looks like this
132:05 - on the top left we have black all of
132:08 - this stuff here
132:09 - and on the bottom right we have
132:11 - transparent pixels
132:13 - and this happens because this entire
132:15 - image is in the rgb format
132:18 - i can actually demonstrate this let me
132:21 - print mask dot
132:23 - mode
132:26 - and if i run this you can see we have
132:28 - rgba
132:30 - which means that this image is perfectly
132:33 - fine to use as a mask we have rgba
132:37 - now there are two ways to actually use
132:39 - it
132:40 - let's start with image mask i guess is a
132:43 - good name
132:44 - and a common way to cut something out in
132:47 - pillow is to use alpha underscore
132:50 - composite
132:51 - inside of this we need two arguments we
132:54 - need the mask we want to cut out from
132:56 - let's say the panda and then we are
132:58 - going to need the mask
133:00 - although i guess let me
133:03 - show the mass but we are going to get an
133:05 - error if i run this
133:06 - we get a value error that image has the
133:09 - wrong mode and we are referring to this
133:12 - panda image because this one has to be
133:14 - in the rgba mode as well
133:17 - both of these actually have to be for
133:20 - this method to work
133:21 - but this is not a problem we can convert
133:24 - this thing
133:26 - to an rgba tuple and now if i run this
133:30 - this is working just fine
133:32 - and essentially what's happening now is
133:35 - that pillow combines these two images by
133:37 - the transparency
133:38 - with the top left being black that's the
133:40 - stuff of the original image but the top
133:43 - left is well you can still see the red
133:45 - panda because there it was transparent
133:48 - and this is possible but usually kind of
133:52 - limited so not exactly what you want to
133:54 - use
133:55 - let me rename it to alpha for the simple
133:58 - reason that we can also use image mast
134:02 - with image dot
134:05 - composite
134:07 - and this is the one we have seen earlier
134:09 - actually
134:10 - we have used this one up here
134:14 - and for this one we need image 1 we need
134:16 - image 2 and we need a mask
134:19 - let's say in my case i want to have my
134:22 - panda i want to have the owl and then
134:25 - for the mask i want to have well this
134:27 - mask
134:28 - and if i now show this image masked this
134:31 - is a much better way to use a mask
134:34 - and
134:35 - well this looks horrible let me flip
134:37 - this around the owl should be on the top
134:39 - and the panda should be at the bottom
134:42 - that is feeling much better
134:44 - and basically what happens in here is
134:47 - that
134:48 - i guess let me cut this out
134:51 - by
134:52 - default we are putting the owl on top of
134:56 - the panda
134:57 - but because of the mast we are cutting
135:00 - out certain parts of the owl all the
135:02 - stuff in the mast if we're using rgb
135:05 - that are not transparent so we only get
135:08 - the owl if this was the image we are
135:11 - getting the owl in this bit here
135:14 - wherever there's no transparency
135:17 - although there is something really
135:19 - interesting and that is that right now
135:22 - this master's rgba but if i convert this
135:27 - into a grayscale image using l we are
135:30 - getting the exact opposite now why is
135:34 - that and to understand why this is
135:36 - happening
135:37 - let me actually show
135:39 - what we are getting when we are
135:40 - converting this mask
135:43 - now we can see the top left this bit
135:45 - here is still black this one did not
135:48 - change
135:49 - however on the bottom right this stuff
135:52 - used to be transparent but now it is
135:54 - just white
135:56 - and if we're using this image as a mask
135:59 - what pillow does is
136:02 - it turns all of these black pixels
136:03 - invisible so we can't see them
136:05 - whatsoever
136:06 - and all the white pixels are perfectly
136:09 - visible so those you can see
136:12 - we are still taking parts of the owl but
136:14 - now the parts that we are taking are the
136:17 - parts of the mast that are white
136:19 - which in this case is
136:22 - this bottom
136:24 - triangle here and since the other
136:26 - rectangle this bit top here is now
136:28 - invisible we can see the panda so we
136:31 - have the panda and the owl
136:33 - and if we used rgba this format here
136:38 - we used a different format where these
136:40 - bits down here were invisible and this
136:43 - is then what we cut away from
136:46 - i hope that makes sense masking can get
136:49 - a little bit tricky the main thing you
136:51 - have to understand is you always have to
136:53 - use rgba 1 or l
136:55 - if you don't you get an error message
136:57 - that is really common so use convert
136:59 - here quite aggressively
137:01 - and then
137:02 - if you use an rgba mask you're cutting
137:04 - out the invisible pixels
137:06 - if you use one or l you're cutting away
137:08 - the black pixels
137:10 - and once you have all of that you are
137:12 - done so this is the entire video i hope
137:16 - that was helpful