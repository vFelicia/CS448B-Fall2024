00:00 - [Music]
00:26 - in this video you will learn how to
00:28 - create five games in Python and while
00:30 - doing it we will touch on all the major
00:32 - parts of the
00:33 - language we will cover classes and
00:35 - inheritance dund statements working with
00:38 - lots of files storing permanent data
00:41 - will even cover decorators and multiple
00:43 - inheritance on top of that you will also
00:45 - learn how to organize and manage larger
00:48 - projects via that you will go very
00:50 - quickly from a beginner to a more
00:52 - confident and advanced coder and you get
00:54 - to do all of it while shooting at
00:56 - skeletons in terms of requirements I do
00:59 - expect you to know the basics of python
01:02 - like using functions and different data
01:03 - types and you should have at least once
01:06 - created a class yourself if you don't
01:08 - know what any of that means check out my
01:10 - introduction to Python and if you want
01:12 - to take your knowledge to the next level
01:14 - check out this video sponsor
01:16 - brilliant.org they offer courses on a
01:19 - broad range of subjects like math data
01:21 - science and software development for
01:24 - every subject you can start from scratch
01:26 - or jump straight into a course either
01:29 - way you will will get to a competent
01:30 - level fast that is because all lessons
01:33 - are highly interactive and engage you in
01:35 - a Hands-On way from the start not only
01:37 - is this a fun way to learn it's also
01:39 - great at getting you to develop problem
01:41 - solving skills and understanding
01:42 - underlying principles you can access
01:45 - brilliant from your computer or via an
01:47 - app it's super accessible so instead of
01:50 - wasting your time on Tik Tok or Twitter
01:52 - you can build a powerful habit that will
01:54 - make you a more competent person
01:56 - brilliant also keeps on adding new
01:58 - content just recently they added a
02:00 - section on Python and expanded their AI
02:03 - courses so check it out at brilliant.org
02:06 - Clear code you will get a 20% discount
02:09 - and the first 30 days are free so not
02:11 - much to lose all right to get started
02:14 - with game development we need to go over
02:16 - some Basics and don't worry this won't
02:18 - take long in the most basic sense video
02:21 - games function like movies you simply
02:24 - draw one image after another and then
02:26 - you play some sound the only difference
02:28 - is that video games dynamically generate
02:30 - each image so while a movie like the
02:32 - first load of the Rings has 260,000
02:35 - frames that never change a game like
02:37 - Super Mario can generate infinite frames
02:40 - and draw each individual one dynamically
02:42 - depending on things like player input
02:44 - and enemy movement but that's basically
02:47 - it usually games run at 60 frames per
02:49 - second and on each frame the game first
02:52 - checks some basic things like player
02:55 - input timers enemy movement or item
02:57 - interactions once it has that
02:59 - information it calculates where things
03:01 - need to be and once that is done it
03:04 - draws a frame doing this over and over
03:06 - again will get you a video game to
03:09 - implement all of that we will use py
03:11 - game Python's default game framework
03:14 - although pygame doesn't actually do that
03:17 - much primarily it allows you to draw
03:19 - images and play sounds get user input
03:22 - and then get and set the positions of
03:25 - objects there are a few more things that
03:27 - pame does beyond that but those are just
03:29 - add-ons to make your life a bit easier
03:32 - the advantage of that approach is that
03:34 - pame is really easy to learn we will
03:36 - cover all of the basics in the first
03:38 - game the downside is that you cannot
03:41 - rely on pre-made tools that you would
03:42 - expect in the game engine like gdo or
03:45 - Unity those are fancy parts like physics
03:47 - engines or network management although
03:50 - this isn't necessarily A downside since
03:52 - you are forced to build your own
03:53 - components you get much more practice at
03:56 - problem solving than a game engine user
03:58 - and if you want to do something else
04:00 - like data science or AI you can switch
04:03 - much more easily and those fields have
04:05 - better celeries and nicer work
04:08 - environments you really want to keep
04:10 - your options open because of that
04:13 - especially when you are getting started
04:15 - I would always recommend to start with a
04:17 - really basic tool like pame and then
04:20 - switch to a proper engine later on that
04:22 - being said if you want to jump straight
04:24 - into a game engine check out my
04:26 - introduction to good 4 anyway let's
04:29 - let's go a bit deeper into P game the
04:32 - two most important Concepts that you
04:34 - need to learn are surfaces and
04:35 - rectangles or rects in short surfaces
04:39 - are just images it could be an imported
04:42 - file or some text although it could also
04:45 - be an entire window basically for every
04:48 - pyam project you create a special
04:50 - surface that serves as the window this
04:53 - is called the display surface and on
04:55 - that you place other surfaces the other
04:58 - concept is a wct and that one is
05:00 - supposed to wrap around a surface and
05:02 - then place it in a specific position via
05:05 - those rectangles you also get collisions
05:08 - if you then add some basic input you
05:10 - already close to a game the one last
05:12 - thing that we need is to keep on drawing
05:14 - new frames for that we are using a
05:17 - simple while true Loop inside of it we
05:20 - get the user input and calculate where
05:22 - game objects need to be and from out of
05:24 - that we are drawing a new frame this we
05:27 - do over and over again until the player
05:30 - gets defeated or wants to quit and that
05:32 - is all you need for the basic Theory
05:35 - just two more things before we get
05:37 - started number one you need to install
05:40 - py game however if you look online you
05:43 - can find two versions of pame pame
05:45 - itself and pame C short for Community
05:49 - Edition the version that you want to use
05:51 - is pame C this one is more modern has
05:54 - more features and is more efficient it
05:57 - is also the only version that is
05:58 - actively worked on on the original pame
06:01 - is basically abandoned at this point you
06:04 - shouldn't use it anymore that being said
06:07 - pame c is backwards compatible with py
06:09 - game if you have that one installed and
06:11 - you find an old py game project you can
06:13 - run it just fine to install it on
06:16 - Windows you either open the Powershell
06:18 - or The Terminal and then type pip
06:19 - install pygame dce on Mac OS you open
06:23 - the terminal and type pip 3 install py
06:25 - game-
06:27 - CE that brings us to the second part you
06:30 - will have to download some
06:31 - resources if you look at the video
06:33 - description you can find a link to a GU
06:35 - page with all of the project resources
06:38 - download those to get the graphics and
06:40 - the audio files there's also a Google
06:42 - Drive Link in which you can find the
06:44 - code for each chapter and the final
06:46 - games with that we are ready to
06:49 - [Music]
06:54 - go and the first game will be the space
06:57 - shooter VI that we're going to cover all
06:59 - the basic concepts you can find all the
07:02 - files in the folder space
07:03 - shooter and the first thing that we have
07:06 - to cover is how to create a basic window
07:09 - this part isn't going to be terribly
07:10 - exciting but it is going to be the
07:12 - starting point for basically everything
07:14 - else so we are going to create a window
07:17 - we're going to give it a custom title
07:19 - and we are going to fill it with a
07:20 - background color after we have that we
07:23 - can work on the finer details but first
07:26 - of all we have to cover some basic
07:28 - groundwork and there are two concepts
07:30 - you have to understand to get started
07:32 - the first one is the display surface
07:35 - this is the main canvas that we are
07:37 - going to be drawing on or in other words
07:40 - this will be the window for the game and
07:42 - inside of this window we will display
07:45 - everything else also we can only ever
07:48 - have a single display surface besides
07:51 - that we are going to need an event Loop
07:54 - which is going to check all of the
07:55 - events these events could be keyboard
07:57 - mouse or controller input or could be
08:00 - timers on top of that it could also be
08:03 - UI interactions for example if you want
08:05 - to press X to close a window this would
08:08 - also be an event so we have to capture
08:10 - that if we want to be able to close our
08:12 - game something that is really
08:14 - fundamental so we have to cover it right
08:16 - away in fact what I would recommend
08:20 - before you are even starting to code is
08:22 - to open the documentation if you go to
08:24 - the pame C website you can go to
08:27 - documentation and there you see a link
08:30 - to every important topic of P
08:33 - game along with a quick start guide and
08:36 - a few more
08:37 - tutorials being able to read this
08:40 - website is incredibly important to
08:42 - understand py game so ideally have this
08:44 - thing open on the site while you code
08:46 - along also what you can see is a quick
08:49 - start guide we are going to create
08:52 - something fairly similar in this
08:54 - section although it's going to be a bit
08:57 - simpler here I am in the code editor
09:00 - and inside of the project you can see
09:02 - the folders I talked about earlier we
09:04 - have a couple of images we have a couple
09:06 - of audio files and inside of the code
09:09 - folder there's nothing at the moment now
09:11 - for this project I only want to have a
09:13 - single python file that I am going to
09:16 - call
09:18 - main.py later on we will work with
09:20 - multiple python files but that's not an
09:22 - issue for now now the first thing that
09:25 - you have to do to use pame is to import
09:27 - it which you do with import pame and
09:30 - after you have written this line run the
09:32 - code and you should be seeing your pame
09:35 - version your sdl version and your python
09:38 - version if you are getting an error
09:40 - message at this point something went
09:42 - wrong with the import so check that
09:45 - after we have that you want to do a
09:47 - general setup which first of all means
09:51 - that we have to run pygame do init this
09:54 - initializes pame and is really important
09:57 - for everything to run properly then
09:59 - being said you don't have to worry about
10:01 - the find details that much just make
10:04 - sure that you are always including it
10:07 - after we have that we want to create a
10:09 - display surface that we also want to
10:11 - store inside of a variable now for the
10:14 - name very often you are seeing screen
10:16 - although I prefer to call it display
10:19 - surface because that's a bit more
10:21 - descriptive but both are totally fine we
10:24 - will need py game. display. setor mode
10:29 - along with a tel that defines the width
10:31 - and the height of this window these two
10:34 - numbers you usually create inside of
10:36 - separate variables to access them later
10:38 - on in my case I want to create a window
10:43 - whift and a window height
10:48 - variable I want to go with 1280 by
10:53 - 720 and then copy those two numbers and
10:56 - paste them into the
10:57 - tupal and with that we are creating a
11:01 - window if I now run the code we can see
11:04 - a window for a very short amount of time
11:06 - and that is the intended experience what
11:09 - is happening now is that we are
11:11 - importing pame we are initializing it
11:13 - and then we are creating a window but
11:16 - after that the code is ending hence
11:18 - everything disappears including the
11:21 - window because of that we can only see
11:23 - the window for a fraction of a second to
11:26 - fix that we have to make sure that this
11:28 - code runs for ever or at least until we
11:31 - want to close it
11:33 - intentionally which we are going to do
11:35 - via a while loop and for now I'm going
11:38 - to set this to while true that way if I
11:41 - add the pass in there and run the code
11:43 - again we can see the window forever
11:47 - however if I now try to close it nothing
11:49 - is going to happen or well the game
11:51 - crashes so I want to close all of this
11:54 - and then add just a bit more code inside
11:57 - of this while true Loop
11:59 - we have to do two things number one is
12:02 - the event Loop once we have that we can
12:05 - actually close the game besides that I
12:08 - want to
12:10 - draw the game I don't think I have to
12:13 - explain this part first of all though
12:16 - for the event Loop we can get all of the
12:19 - events with py game. event. getet and to
12:23 - access all of them we will use a for
12:26 - Loop for event in py game. event .g get
12:31 - in there we can check for keyboard input
12:33 - for Mouse input for timers and for UI
12:37 - interactions or in other words we can
12:39 - check if the user wants to close the
12:41 - game which we can check via the type of
12:43 - the event if event. type is equal to
12:48 - pame do all in uppercase letters
12:51 - quit that is a constant that stands for
12:54 - closing the game which we're going to do
12:57 - via another variable called called
13:00 - Running which by default is going to be
13:02 - true and then for this while loop we're
13:05 - going to set this to while running and
13:09 - if the if statement triggers we will set
13:11 - running to
13:14 - false if I now run all of this again I
13:17 - can close the game and we are closing
13:21 - everything there's no more error message
13:22 - so this looks pretty good although
13:25 - there's one thing you should always do
13:27 - after this while loop and that is py
13:30 - game. quit this method is essentially
13:34 - the opposite of py game. init meaning it
13:37 - un initializes everything so we are
13:39 - making sure we are closing the game
13:41 - properly most of the time if you forget
13:43 - this one it's not going to be causing
13:45 - too many issues but sometimes it can
13:47 - cause a bug or at least weird Behavior
13:50 - so make sure to include it and this
13:52 - would be the most common way for a very
13:54 - basic pame setup which means after that
13:57 - we want to draw the elements of the game
14:00 - and for that we always have to call one
14:03 - method which is called pame do display.
14:07 - update or
14:09 - flip both methods do the same thing they
14:12 - take all of the elements that we have
14:14 - run in the while loop before and then
14:16 - draw them on the display
14:18 - surface the difference between them is
14:20 - that update updates the entire window
14:24 - while for flip you can specify that you
14:26 - only want to update a part of the window
14:29 - which in most case you don't really want
14:30 - to do so I usually use update by default
14:33 - that one is a bit simpler but both are
14:35 - totally fine so then what can we do to
14:39 - draw the game and for now let's say I
14:42 - want to fill the window with a red color
14:47 - how can we do that for that you want to
14:50 - look at the documentation so far we only
14:52 - really worked inside of pame so in there
14:55 - we have called py game. init py game.
14:58 - quit besides that we have looked at py
15:01 - game. display and in there we had set
15:04 - mode which does a whole bunch of
15:07 - things the return value of this is going
15:10 - to be a surface and if you go all the
15:13 - way to the top there we have another
15:15 - section called surface so if you click
15:17 - on that you can see all of the methods
15:20 - available for surface and the one that
15:23 - we care about at the moment is pygame
15:25 - Dos surface. fill click on that and then
15:29 - you can call fill along with a
15:32 - color you could specify a few more
15:35 - arguments but we don't really care about
15:37 - that which means back inside of py game
15:41 - I can get rid of the comment and then
15:44 - get the display surface along with the
15:47 - fil method in there we will need a color
15:50 - value and the easiest way to get colors
15:52 - in P game is the name of a color for
15:55 - example Red If You Now run the code this
15:58 - be s a bit intense but we are getting a
16:01 - red color so that is working really well
16:04 - you could also use blue in there there
16:06 - are a whole bunch of colors you could be
16:08 - going with to get all of the available
16:11 - colors inside of the pame documentation
16:14 - you want to go to color and there if you
16:16 - scroll down just a bit you can see the
16:19 - name colors so click on that and then
16:22 - you get a pretty long list of all of the
16:25 - colors you could be using here this list
16:27 - is quite extensive
16:32 - but anyway with that we have a pretty
16:34 - good starting point for p game and to
16:37 - finish off this part Let's do an
16:39 - exercise I want you guys to read the
16:41 - documentation and change the title of
16:44 - the window and as a reminder here's a
16:46 - link to the documentation pause the
16:48 - video now and try to figure this one out
16:49 - on your
16:53 - own if I run the code again and if you
16:56 - look in the top left you can see that
16:58 - our window title is pame window at the
17:01 - moment and we also have the icon of pame
17:05 - the icon I am going to keep but the
17:07 - title we do want to change how could we
17:10 - do that for that you want to look at the
17:13 - documentation and this part is under
17:16 - display there we have already used set
17:19 - mode and if you scroll down a bit we
17:22 - also have set caption this one set the
17:26 - current window caption the user all you
17:29 - really have to do is call py game.
17:31 - display. set caption and then insert
17:33 - some kind of string which means back
17:36 - inside of the code after we are creating
17:39 - the display surface I want to call py
17:41 - game. display and then set caption for
17:46 - this one we are going to need some kind
17:47 - of string let's call this one the space
17:51 - shooter if I now run all of this again
17:53 - in the top left you can see that our
17:55 - title has changed to space shooter
17:58 - perfect
17:59 - so with that we have finished the first
18:01 - part of py game although you might have
18:04 - a question if you look at the
18:07 - documentation how could you know that
18:09 - changing the title of the window was
18:11 - inside of display and well sometimes in
18:15 - documentation you simply have to look
18:17 - around to find the right answer High
18:19 - game ultimately doesn't have that many
18:21 - components so if you know a little bit
18:24 - you should usually have a good idea of
18:25 - where stuff is that being said you can
18:28 - use Google quite easily for example if
18:30 - you look to how to change py game window
18:34 - title then you find a whole bunch of
18:37 - answers so if you click on the first one
18:40 - they get py game. display. set caption
18:42 - along with a string so should be fairly
18:45 - straightforward alternatively you could
18:47 - also use Chad GPT if you look for how to
18:51 - change py game window title you should
18:55 - be getting a pretty decent answer
19:01 - there you go this worked pretty well
19:03 - although for a bit of caution when
19:05 - you're using an AI tool the answers can
19:08 - be wrong or at least incomplete so don't
19:11 - expect anything great from it but for
19:13 - very simple questions it can be really
19:15 - good anyway with that we have a basic
19:17 - window so now we can start drawing our
19:20 - game the next important part is
19:22 - displaying graphics and by the end of
19:24 - this section we will display an imported
19:26 - image and a generic plane Rec rectangle
19:29 - on top of that we will also be able to
19:31 - move things in a very basic way although
19:34 - that for now will be fairly experimental
19:37 - now there are two ways to display
19:39 - graphics in pame number one you could
19:42 - show an image or a text via a surface
19:45 - and number two you could draw pixels
19:47 - straight
19:48 - away using a surface is the most common
19:51 - way and this is what I am going to focus
19:53 - on this section although later on we are
19:56 - also going to draw pixels straight away
19:58 - but for now the topic that we have to
19:59 - focus on is a Surface which can display
20:03 - an image or a
20:05 - text usually a surface in py game is
20:08 - just an image so a PNG or jpeg there are
20:11 - lots of supported file formats a plain
20:13 - area or some render text or in other
20:16 - words if you want to create a surface
20:19 - you can either create a plain surface
20:21 - with py game. surface and then you
20:23 - specify a width and a height inside of a
20:25 - tub besides that you can import a Sur
20:29 - this happens with py game. image. load
20:31 - and then you specify a file path to some
20:33 - kind of jpeg or PNG file finally if you
20:37 - want to have a text surface you would
20:39 - need a font and then you render that
20:40 - font if you want to antialias the text
20:43 - and the color that you want for the
20:45 - text the text for now isn't too
20:47 - important I'll cover that later but we
20:49 - will create a plane surface and import
20:51 - an image and create a surface that way
20:54 - before that though we have seen a
20:57 - display surface and now we are covering
20:59 - a regular surface and those two are
21:02 - called very similar for a reason because
21:04 - they are well very similar the important
21:07 - difference between them is that the
21:09 - display surface is the main surface that
21:11 - we are going to draw on it's basically
21:13 - the main window of the game there can
21:15 - only be one and it will always be
21:17 - visible a normal surface on the other
21:19 - hand is an image of some kind you can
21:22 - have as many as you want but they will
21:24 - only be visible if they are attached to
21:26 - the display surface and this is an
21:28 - another step that you have to go through
21:31 - but other than that the two share quite
21:33 - a few attributes and methods for example
21:35 - you can fill both with a color via the
21:37 - fill method the one that we have already
21:40 - seen to fill the background color anyway
21:42 - with that we have covered all of the
21:44 - theory let's do some coding back inside
21:46 - of the code editor let me run the entire
21:49 - thing we have a window with a blue
21:51 - background now I think the blue
21:53 - background is a bit strong let's go with
21:55 - dark gray instead that one looks lot
21:59 - better after that I want to create a
22:03 - surface which we can store in a variable
22:05 - I usually called this one surf to create
22:09 - a basic surface without any kind of
22:11 - import you want to run pygame do
22:15 - surface which you have to call and then
22:17 - insert one argument which is a tuper
22:20 - with a width and the height of the
22:21 - surface that you want to create let's
22:24 - say I want to create a surface with a
22:26 - width of 100 pixels and a height of of
22:28 - 200
22:30 - pixels if I now run the code nothing is
22:34 - going to change and that is intended
22:37 - because this surface while it does exist
22:39 - needs to be attached to the display
22:42 - surface only then will it be visible and
22:45 - for that we have another method that we
22:48 - have to call inside of our game Loop we
22:52 - first of all need to Target surface
22:54 - which in our case is the display surface
22:57 - and then the method blit
22:59 - which stands for Block image transfer
23:02 - it's a fancy way of saying that you want
23:03 - to put one surface on another
23:05 - surface this method wants to have two
23:08 - arguments the first one is a surface
23:11 - that you want to put on this other
23:12 - surface which in our case is the surface
23:15 - the one we have just created and then we
23:17 - need a Target position this can be one
23:20 - of two things it can be a tuple with an
23:23 - X and A Y position it could also be a
23:26 - rectangle that we're going to cover in
23:27 - the next section
23:28 - well now though we have to specify two
23:31 - numbers let's go with 100 and
23:35 - 150 if I run the code now we can see a
23:40 - black rectangle inside of the window so
23:43 - that is definitely
23:45 - progress however I want you guys to
23:47 - think about one important thing and that
23:50 - is why this rectangle is in this
23:56 - position or in other words how do we we
23:58 - go from this number to this position
24:02 - that's a really important thing to
24:04 - understand for that we have to cover
24:06 - just a bit more Theory so here is our
24:09 - display surface this has a width and a
24:13 - height now in my case the width is
24:15 - 1280 and the height is
24:18 - 720 although you might have different
24:20 - numbers the specific here really don't
24:23 - matter though combined those two numbers
24:25 - are going to give us a coordinate system
24:28 - and the really important thing about
24:30 - this coordinate system is that the
24:31 - origin point is in the top
24:34 - left now if you're only familiar with
24:36 - high school math you probably have seen
24:38 - coordinate systems that look something
24:40 - like
24:42 - this where the origin point is in the
24:44 - bottom left so if you increase X you go
24:47 - to the right and if you increase y
24:49 - you're going up we are doing something
24:51 - fairly similar except that we are
24:54 - inverting the entire thing on the
24:55 - vertical axis which means if you
24:58 - increase X you are still going to the
25:00 - right however if you increase y then you
25:04 - are going
25:05 - down now this system initially can be
25:08 - really confusing and it does feel
25:10 - somewhat counterintuitive that being
25:12 - said most game engines work with this
25:14 - coordinate systems and you do get used
25:17 - to it quite fast so it's not too bad but
25:20 - anyway the one thing that you really
25:22 - want to remember is that the origin
25:23 - point is in the top left and that means
25:26 - that moving to the right means you are
25:27 - increasing X X and moving down means
25:30 - increasing y or if you want to go up you
25:32 - want to decrease Y and inside of the
25:35 - game we have placed a surface something
25:38 - like this now in this case I believe
25:41 - that we have moved 100 pixels to the
25:44 - right and then we moved 150 pixels down
25:49 - and then we have placed the top left of
25:51 - the surface at least for now we are
25:54 - always placing the top left of the
25:56 - surface
25:58 - but that is basically it if you
26:00 - understand that system you can place
26:02 - surfaces on the display surface so
26:05 - inside of the code if I run all of this
26:08 - again we have started from the top left
26:10 - this is our origin point then we moved
26:13 - 100 pixels to the right and then 150
26:16 - pixels down and then placed this point
26:19 - along with the rest of this surface you
26:23 - can also change these numbers for
26:24 - example the 100 could become a 300
26:29 - and if I then run the code the surface
26:32 - is a bit further to the right if I make
26:35 - this number much larger let's say
26:38 - 1,100 then we are going all the way to
26:40 - the right the same thing we can do on
26:42 - the vertical axis although here we do
26:45 - need to be a bit careful the larger this
26:47 - number gets the further down we go or in
26:50 - other words if I set this to 400 and run
26:53 - all of this again the surface is going
26:56 - down whereas if I said this to a zero
26:59 - then we are all the way at the top and
27:02 - also by the way you can make these
27:04 - numbers negative if I set this value
27:08 - to150 then the Surface starts to
27:11 - disappear but let's not do that this is
27:14 - much better also what you can do like we
27:17 - have done for the display surface down
27:20 - here you can fill the surface surface
27:23 - dot Bill and then you can specify a
27:26 - color let's say a color we have haven't
27:28 - used yet is orange if I run the entire
27:31 - thing again we get a Surface with
27:34 - another color and that would be the most
27:36 - fundamental way to display a graphic
27:38 - inside of P game and what we can also do
27:41 - at this point is to create a very basic
27:45 - animation the way that is going to work
27:47 - is at the moment we are always
27:49 - displaying this surface in this one
27:51 - particular
27:53 - position but that number we could change
27:56 - for example I could set an X position
27:59 - which by default is a 100 and if I then
28:03 - change the X position
28:05 - to the X variable and run out of this
28:08 - again we cannot see a
28:11 - difference however if I increase X by a
28:16 - certain amount and let's say by
28:18 - 0.1 and run all of this again now our
28:21 - rectangle is moving to the right not at
28:24 - a constant speed and this doesn't look
28:26 - great but at the very least we have a
28:28 - start and to understand what is going on
28:31 - here we have to go back what I talked
28:33 - about in the beginning to create any
28:35 - kind of video game you basically draw a
28:38 - whole bunch of frames which we are doing
28:40 - with a while loop this thing is being
28:43 - run multiple times per second and every
28:46 - time we are drawing it we are filling
28:48 - the background color with this surface
28:50 - and then we are drawing the surface in a
28:52 - certain position and since we are
28:54 - changing that position we are basically
28:57 - creating an animation
28:58 - by placing it in a different position on
29:00 - every single frame that's in the most
29:02 - basic sense what a video game really
29:05 - is and if you want to have a really
29:08 - interesting effect if you don't fill in
29:11 - the background color and run all of this
29:14 - again you can see that we are getting
29:17 - well something different what happened
29:19 - here is that pygame does not remove the
29:21 - previous image we are simply drawing on
29:24 - top of it so if you don't fill in the
29:28 - entirety of the display surface you can
29:30 - see the last
29:32 - frame which sometimes can be an
29:34 - interesting effect but basically always
29:36 - you want to avoid it it can lead to some
29:38 - funky Behavior so let's keep on filling
29:41 - the display surface and if I run out of
29:43 - this again we get a very basic animation
29:46 - with that we have a basic surface and
29:49 - let's rename this section to a plain
29:52 - surface because next up I want to create
29:55 - a Surface by importing an
29:58 - image whenever you are importing an
30:01 - image you are converting it right away
30:02 - to a
30:03 - surface and for now I want to go to
30:08 - images and then import player.png or
30:11 - this file and all of this we want to
30:13 - store in another variable let's call
30:15 - this one player uncore
30:19 - surface to import a surface we will need
30:22 - py game. image. load along with a file
30:27 - path we want to go to images and in
30:31 - there we have
30:32 - player.
30:34 - pnb here's our image folder and in there
30:37 - we have
30:40 - player.png now for this file path to
30:43 - work you need to be inside of the
30:46 - project folder or in other words this is
30:48 - the folder you need to have open inside
30:50 - of vs code if you only had the code
30:54 - folder open or you're using something
30:56 - like Sublime code you have to specify
30:58 - the file path from main.py in which case
31:01 - you would have to go up a folder first
31:04 - I'll talk about this in just a second
31:06 - but use every one of those two if you're
31:09 - getting an error in my case if I run the
31:11 - code now we are not getting an error
31:13 - message so the import has
31:16 - worked if you do get an error you
31:18 - probably have to add this bit to
31:21 - it anyway with that we have another
31:25 - surface which means when we are drawing
31:28 - the game we can blit the player surface
31:33 - instead of the surface we have seen
31:34 - earlier and if I now run all of this we
31:37 - get the players ship so that is looking
31:40 - really
31:41 - good with that we have a really basic
31:44 - import and there are other images you
31:46 - could be importing for example we have
31:49 - meteor
31:52 - PNG and we have laser. PNG
31:58 - although in my case I want to use
32:01 - player.png there are three important
32:03 - things you want to keep in mind when
32:05 - you're doing any kind of input in pame
32:08 - the first one is that depending on your
32:11 - code editor you might need a different
32:13 - relative path so when your code editor
32:16 - tries to find a file vs code always
32:19 - starts from the main Parent Directory
32:22 - which in my case is the entire project
32:23 - folder but Sublime a nav code editor
32:27 - would start from the python file itself
32:29 - meaning in there you have to specify
32:31 - that you want to go to the parent folder
32:33 - first and then from there you want to go
32:35 - to images and then to
32:37 - player.png let me actually demonstrate
32:40 - here we are back in the code and at the
32:41 - moment we are going to images and then
32:44 - to
32:45 - player.png and let's do all of that in
32:47 - the project folder right
32:49 - away so the file path we have specified
32:52 - is we are going to images and then to
32:55 - player.png and this is what we are
32:56 - importing
32:58 - that is working because currently inside
33:01 - of vs code we have this project folder
33:04 - open and this is our starting point
33:07 - however if I change
33:09 - this and only open the code
33:13 - folder so now I only have main.py and
33:16 - this is our starting point if I now run
33:19 - the code we are getting an error because
33:22 - there's no file player. PNG in images to
33:26 - actually get that we want to go uper
33:28 - folder and then we should be finding the
33:31 - file and now all of this works again so
33:34 - always be really careful when you are
33:35 - importing something via your code editor
33:38 - you should be aware of where the
33:39 - starting point is for the
33:41 - directory and that being said what you
33:43 - could also do is go to your file and
33:46 - then copy the absolute path that would
33:48 - also work but I tend to prefer relative
33:52 - ones just to be a bit
33:53 - clearer anyway in my case I always want
33:57 - to have the project folder open so I'm
33:59 - going to select this one then don't save
34:02 - so we are keeping open images and then
34:05 - player.png which is going to work just
34:08 - fine the next issue that we have to work
34:10 - on is that depending on your operating
34:12 - system you might need a different slash
34:14 - in the file path or in other words if
34:17 - you look at this path and this
34:21 - path one has a forward slash and the
34:24 - other has a backward
34:25 - slash when you go to Windows or Mac OS
34:28 - or Linux or some other operating system
34:31 - they all have some kind of preference
34:33 - now usually they are quite intelligent
34:35 - and would accept both but not all the
34:37 - time and you do want to be careful here
34:40 - so ideally all of this should be dynamic
34:43 - which we can do via another inbuild
34:45 - python method that one is called join
34:48 - and you want to import it all the way at
34:50 - the top via from os. paath import join
34:56 - all that this one is going to do is it
34:58 - takes a couple of folders or files and
35:01 - then joins them together with the
35:02 - appropriate file path for your operating
35:05 - system the way you would use it let me
35:07 - create a path via the join method in
35:11 - there you want to insert a couple of
35:14 - arguments that Define the file path so
35:17 - in my case I want to go to images and
35:20 - then to
35:22 - player.png and if I print that path you
35:26 - can see quite well what's going to
35:27 - happen
35:28 - we don't need the window and from this
35:31 - print path we getting images and then
35:35 - player.png and there you can actually
35:36 - see that on Windows the default slash is
35:39 - this one while I have used this one so
35:41 - ultimately my operating system is happy
35:43 - with either but it would be better to
35:45 - use this one just to be a bit more
35:47 - consistent so instead of using this
35:49 - hard-coded path you want to use the join
35:52 - method along with the file
35:55 - path if you run out of that you're
35:58 - getting the same outcome and your code
35:59 - is just a bit more robust finally
36:02 - there's one more thing that we want to
36:03 - cover and that is when you're importing
36:06 - an image you want to convert it to a
36:09 - format that pame can work with more
36:11 - easily that is going to increase our
36:13 - frame rate by quite a bit and converting
36:16 - is actually really easy you only really
36:18 - have two options after you have imported
36:20 - an image if the image has no transparent
36:24 - pixels then you want to call do convert
36:26 - on the surface
36:28 - if it does have transparent pixels then
36:31 - you want to call convert Alpha and then
36:33 - you done it's super easy to do or in
36:36 - other words back in the code after we
36:38 - have imported an image I want to call
36:41 - convert on it that way pyam can process
36:45 - this surface much more easily so we get
36:47 - better performance but if I run all of
36:50 - this we now get black stuff around the
36:53 - ship that is because the ship has Alpha
36:55 - values which means instead of convert we
36:58 - want to use convert Alpha if I now run
37:01 - out of this again we get the ship again
37:03 - and this looks pretty good so whenever
37:05 - you are importing surfaces into P game
37:08 - you either want to call convert or
37:09 - convert Alpha and then you are improving
37:11 - your performance substantially although
37:13 - if you don't do it usually it's not
37:15 - going to cause an error you just get a
37:17 - lower frame rate but anyway with that we
37:20 - have covered surfaces so at this point
37:23 - you can import a surface or you can
37:25 - generate a surface from scratch and and
37:27 - then place it on the display surface you
37:30 - can also move it around although this we
37:32 - have to refine later on which means we
37:34 - can finish up this part by doing an
37:36 - exercise I want you guys to import the
37:39 - star.png image and then Place 20 Stars
37:43 - randomly on the display surface using
37:45 - rent in for that should be the best way
37:48 - pause the video now and see how far you
37:52 - get I want to create a
37:55 - starcore surface which we can import via
37:59 - py game.
38:01 - image. and the thing that we want to
38:03 - import is
38:05 - start.png a fairly simple image to
38:08 - create a file path we want to use join
38:11 - then go to images and in there we have
38:16 - star.png which we also want to convert
38:19 - Alpha right away if I now run the code
38:22 - we are not getting an error message so
38:24 - this part has worked fairly well which
38:26 - means now we have to place all of these
38:29 - star surfaces on the display surface
38:31 - using a blit method now we want to place
38:34 - 20 of them but for now let's simply
38:36 - place a single one I want to call
38:38 - display surface
38:42 - dolit with the star surface and the
38:45 - position let's go with 300 and 500 if I
38:50 - now run all of this we can see a star so
38:53 - that's a pretty good start but I want to
38:55 - place 20 stars in a random position
38:58 - for that all the way at the top I want
39:00 - from random import Rand int and then use
39:06 - a for Loop or I in range
39:11 - 20 and then display surface. blit with
39:15 - the star surface and then I need a
39:17 - random X and a random y position both of
39:21 - which I'm going to create via random
39:24 - integer for the X position I want to go
39:26 - from zero all the way to the window
39:31 - Wii and for the Y position random
39:34 - integer from zero to the window
39:39 - height and with
39:41 - that we are getting a lot of stars in a
39:45 - random position but not in the way
39:47 - that's
39:48 - intended although it's a good error to
39:51 - talk about because what went wrong here
39:53 - is that we are getting a new random X
39:55 - and Y value on every frame of the game
40:00 - that way the stars are moving around at
40:02 - random which is looking really really
40:05 - bad one way around that would be after
40:09 - we have imported the star surface I also
40:11 - want to get
40:13 - starcore positions which we can create
40:17 - via a list comprehension I want to
40:20 - create a tupo with an X and A Y position
40:23 - for I in range 20
40:28 - and then both X and Y are basically
40:30 - going to be what we have created down
40:32 - here so I can cut out this part and then
40:35 - add it here with that we are getting 20
40:39 - star positions and those we are then
40:42 - going to use inside of this for Loop
40:44 - which means for
40:47 - position inside of the star positions
40:51 - and then display surface. lit with star
40:54 - surface and the
40:55 - position once we have that we are
40:58 - getting all of the stars always in the
41:00 - same position so that is looking much
41:04 - better we are nearly done there's just
41:06 - one more thing that I do want to cover
41:08 - and that is that the drawing order
41:11 - really matters at the moment we are
41:13 - always displaying the background color
41:15 - then we are drawing the ship and then we
41:18 - are drawing all of the
41:20 - stars because of that the Stars will be
41:24 - on top of the player which itself is on
41:27 - top of the dark gray background or in
41:30 - other words if I run display surface.
41:33 - fill after the ship and after the
41:37 - stars then we can only see the
41:40 - background and that should make sense we
41:42 - are first drawing the ship then we are
41:44 - drawing the stars and then we are
41:46 - filling the entire surface with a color
41:48 - as a consequence we can only see the
41:50 - color itself now in our case I first
41:53 - want to display the background then I
41:55 - want to display the Stars via the four
41:58 - Loop and then I want to show the
42:00 - ship so with that if I run things again
42:03 - now you can see the ship is on top of
42:05 - the Stars which looks much
42:08 - better and all right with that we have
42:10 - surfaces in this section we are going to
42:12 - cover placing surfaces via rectangles
42:15 - and rectangles in P game are incredibly
42:18 - important because they allow you to do a
42:20 - whole bunch of useful
42:22 - things most importantly they let you
42:25 - place surfaces much more elegantly
42:27 - besides that they can also detect
42:29 - collisions and they can be drawn those
42:32 - two things are really important but for
42:34 - now we are going to focus on placing
42:37 - surfaces and for that at the moment
42:40 - placing a surface kind of sucks since we
42:42 - are always placing the top left we don't
42:45 - really have much control over the
42:46 - placement itself or at the very least if
42:50 - we wanted to place it in a certain
42:51 - position we would have to do some math
42:54 - for
42:55 - example if this is is the display
42:57 - surface and we want to have a regular
43:00 - surface in the bottom right with pading
43:03 - to the right and to the bottom of 10
43:05 - pixels each now for this part we could
43:08 - place the top left then get the entire
43:11 - right side subtract the width of the
43:13 - surface and then plus the padding that
43:16 - would be possible but also very annoying
43:19 - also sometimes we just want to place the
43:21 - center or the right side of the surface
43:24 - and be really deliberate about this
43:26 - positioning all of that is something
43:28 - that rectangles can do really well the
43:31 - way they are going to work is that
43:32 - rectangles are just well rectangles with
43:35 - a size and a position we could have
43:37 - something like this any width and height
43:40 - is totally fine and you can place them
43:42 - in literally any position now on these
43:44 - rectangles we have a lot of points first
43:48 - of all we have a whole bunch of them
43:50 - with an X and A Y position for example
43:53 - we could measure where the top left is
43:54 - where the top right is where the center
43:56 - is where the M bottom is and so on on
43:59 - top of that we also have X and Y
44:02 - positions those for example could be the
44:04 - left side of the rectangle the top of
44:06 - the rectangle the bottom we also have
44:09 - Center X and Center y there's also width
44:12 - height and size of the rectangle so we
44:15 - can measure how wide or tall this
44:17 - rectangle is what is also really
44:19 - important is that you can measure and
44:21 - change each point this makes it very
44:23 - easy to check if a rectangle has gone
44:25 - too far to the right or if you have
44:27 - crossed a certain point and on top of
44:30 - that these points always stay relative
44:33 - to each other meaning if you're moving
44:35 - one of them you're moving all of them or
44:38 - in other words if you're moving the
44:40 - bottom left point in this direction you
44:43 - would also move the mid left point the
44:45 - midtop point the top right point in this
44:47 - direction now before we do actual coding
44:51 - there are two more minor things that I
44:52 - want to cover number one there are two
44:55 - kinds of rectangles rectangles and F
44:58 - rectangles or floating Point rectangles
45:02 - those two are nearly identical the only
45:05 - difference is that F rectangles store
45:07 - data as floating Point values while
45:10 - rectangles use integers for example with
45:13 - a rectangle or to be a bit more specific
45:16 - an F rectangle the left side could have
45:19 - a value of something like
45:23 - 100.45 while the rectangle would
45:25 - truncate these values to 100 as a
45:28 - consequence F rectangles are a lot more
45:31 - precise and because of that they are
45:33 - used much more often in fact rectangles
45:36 - are basically just there for backwards
45:39 - compatibility nowadays for pretty much
45:41 - any kind of project you want to use f
45:44 - rectangles when we are coming to
45:46 - movement later on this will become
45:48 - especially important and truncating
45:50 - position values with a rectangle is
45:52 - actually really bad and can cause a ton
45:54 - of problems so we always want to use f
45:57 - rectangles but in older examples you do
46:00 - see rectangles fairly often so be aware
46:02 - of that besides that you can create
46:05 - rects in basically two different ways
46:08 - the first one is that you can create a
46:09 - rectangle entirely from scratch this
46:12 - would I look like this or like this
46:14 - depending if you have a rectangle or an
46:16 - F rectangle in either case you have to
46:19 - specify a position and a size for that
46:22 - you could either use two tups or four
46:24 - values in sequence both would be working
46:26 - just fine just check the documentation
46:28 - although this you don't actually see
46:30 - that often what is much more common is
46:32 - that you create a rectangle from a
46:34 - surface and then the rectangle would
46:36 - have the same size as that surface this
46:39 - you do with get wrecked or get
46:42 - fcked and then you can specify a point
46:45 - with a position that way once again
46:47 - you're getting a position and a size for
46:49 - a rectangle and this second approach is
46:52 - going to become really important later
46:54 - on because when you detect collisions
46:56 - you want to have a rectangle with the
46:58 - size of the surface but anyway with that
47:01 - we have all of the theory so let's do
47:03 - some actual coding here we are back in
47:05 - the project and I first of all want to
47:08 - stop the animation so this X Plus equal
47:12 - 0.1 we should get rid of and then run
47:16 - all of this
47:17 - again and there we can see we have the
47:20 - spaceship along with the rest of the
47:21 - game and that works reasonably
47:24 - well however imagine you wanted to place
47:27 - the ship in a specific position at the
47:30 - moment we have a random top left point I
47:32 - think there was 100 pixels from the left
47:34 - and then 150 pixels down but what if you
47:37 - want to place the ship right in the
47:39 - middle of the window or you want to
47:41 - place it in the bottom right with
47:44 - petting on each side if you always place
47:47 - the top left this can get a bit tricky
47:50 - to calculate and rectangles make all of
47:53 - this significantly easier so after we
47:57 - have imported the player surface I want
48:00 - to create a player uncore rectangle
48:04 - which we do first of all with the
48:05 - surface in this case player surface and
48:08 - then get underscore F
48:12 - rectangle and in there we want to
48:14 - specify one of the points of the
48:16 - rectangle that we want to place and then
48:18 - the actual position for example I want
48:20 - to place the center point of the
48:22 - rectangle at position 0 and zero
48:27 - this zero and zero would be the position
48:29 - on the display surface or in other words
48:32 - it would be in the top left with that we
48:35 - have a rectangle and this rectangle we
48:37 - can use inside of the blit method so in
48:40 - there instead of a tuple we can use the
48:43 - player rectangle if I now run the code
48:47 - the center of the ship is all the way in
48:49 - the top left alternatively I could also
48:53 - place the top left point and that way
48:56 - the top left of the ship would be in the
48:58 - origin point of the display
49:01 - surface and that example isn't terribly
49:03 - useful so what I actually want to do is
49:06 - get this center of the rectangle and
49:08 - then place it right in the center of the
49:10 - window which we can do by using window
49:13 - Wii and window height or in other words
49:16 - I want to get the window WID and divide
49:19 - it by two and then the window height and
49:23 - divide it by two as well if I now run
49:25 - the code disip sh is right in the middle
49:28 - of the window and just for one more
49:30 - example imagine I want to place the ship
49:32 - in the bottom right with padding to the
49:34 - right into to the bottom for that I
49:37 - could place the bottom right of the ship
49:41 - the Tuple for that is going to be window
49:43 - width minus 10 and then window height
49:47 - minus 10 as well if I now run all of
49:51 - this we can see the ship is in the
49:54 - bottom
49:55 - right or in other words with this system
49:58 - we can place the ship super easily in a
50:00 - lot of positions although let's start by
50:02 - placing the ship in the center of the
50:03 - window I think that's a bit better like
50:06 - so now what you can also do is update
50:09 - individual points of this rectangle that
50:12 - way you would update all of them for
50:14 - example what we could do is to move this
50:17 - ship again we could pick the player
50:21 - rectangle and then the left side and
50:26 - remember what I talked about earlier
50:28 - inside of a rectangle we have two PS and
50:31 - integers or well for an F rectangle
50:34 - those would be floating Point values but
50:37 - when I place the top left or the center
50:39 - or the bottom right I always have to
50:42 - specify an X and A Y position but when
50:45 - I'm specifying the left side or the
50:47 - right side I only ever have to specify a
50:50 - single position because those only
50:52 - represent a single value like we are
50:55 - doing inside of player right left we
50:57 - could for example set to 100 that way
51:02 - our ship is now going to be much further
51:04 - to the left if I change this value to
51:08 - 150 we're going a bit further to the
51:11 - right and once again I can make all of
51:13 - this Dynamic and increase this value by
51:16 - 0.1 if I now run all of this the ship is
51:19 - moving to the right and this is also the
51:22 - part where floating Point rectangles
51:23 - become incredibly important because if
51:26 - you have a normal rectangle so at the
51:28 - moment we using get F rectangle to
51:30 - create a floating Point rectangle if we
51:33 - used get rectangle and run out of this
51:36 - again the ship isn't going to move at
51:39 - all that happens because the rectangle
51:42 - around the ship at the moment looks
51:44 - something like this and the left side
51:47 - has a value of let's say 600 and really
51:51 - important this is an integer meaning
51:53 - anything after the dot will simply be
51:56 - ignored
51:57 - and well what we are doing at the moment
51:59 - is adding plus 0.1 to it which means
52:03 - after one frame we are getting to
52:07 - 600.1 but since this rectangle always
52:10 - trunk gets the position value this point
52:12 - one will be removed entirely hence we
52:15 - are not moving that being said if you
52:17 - change this value to one then we should
52:19 - be seeing some movement and we do but
52:22 - this isn't what I actually want to do so
52:24 - let's keep this at 0.1 and then use a
52:27 - floating Point rectangle for basically
52:29 - any project nowadays I am using floating
52:31 - Point rectangles they are simply better
52:34 - although I guess we could make this just
52:35 - a bit faster but anyway this is
52:38 - basically what you need to get started
52:39 - with rectangles they don't really get
52:41 - that much more complicated I suppose one
52:44 - more thing that we could be doing is
52:46 - that at the moment we have used the
52:48 - rectangle and its values to move a
52:52 - surface what you can also do is measure
52:55 - these points but for example what you
52:57 - could be doing is print layer rectangle
53:00 - do right that way if I run all of this
53:03 - again you can see the right side of the
53:07 - player which by itself isn't terribly
53:09 - useful but for example you could be
53:12 - using this if I cut it out inside of an
53:15 - if statement that I only want to move
53:18 - the player to the right if player rec.
53:21 - right is smaller than the window Wii if
53:25 - I now run all of this again then we are
53:27 - moving to the right but at some point we
53:29 - are stopping so this is working really
53:32 - well and those are the two ways you're
53:34 - using rectangles to move stuff in P game
53:37 - you either measure a point or you move a
53:40 - point and after you have that you're
53:42 - using the blit method with a surface and
53:44 - a rectangle and then you are getting
53:46 - some movement remember in a video game
53:48 - any kind of movement is simply drawing a
53:51 - graphic in a different position and that
53:53 - you slowly update over time that's all
53:55 - you ever do
53:57 - which means we just have to do an
53:58 - exercise and then we are done with this
54:00 - part I want you guys to do three things
54:03 - number one import the meteor and place
54:06 - it in the center of the window and
54:08 - obviously for that use a rectangle
54:10 - besides that import a laser graphic and
54:13 - place it in the bottom left with 20
54:15 - pixels of padding to the left and to the
54:17 - bottom and finally make the player
54:20 - graphic Bounce from the left to the
54:22 - right
54:23 - continuously that should be quite a bit
54:25 - so pause the video now now and see how
54:27 - far you
54:29 - get number one I want to import a meteor
54:33 - graphic and place it right in the center
54:35 - of the window for that first of all we
54:39 - have to import meteor
54:42 - PNG that we can do under importing an
54:45 - image and I guess by now this should
54:46 - simply be called
54:48 - Imports in there I want to create a
54:52 - meteor uncore surface which we do with
54:56 - pame do image. load then using the join
55:00 - method I want to go to images and then
55:03 - import metor PNG also really important
55:07 - never forget convert Alpha after we have
55:10 - that I want to create a
55:13 - meteor underscore rectangle where we
55:17 - have the meteor surface and then use get
55:20 - F rectangle where I want to place the
55:23 - center the position for this has to be a
55:25 - tupal with an X and A Y value X is going
55:28 - to be window not height but width
55:32 - divided by two and Y is going to be
55:34 - window height divided by two that is
55:37 - going to give us a surface and a
55:38 - rectangle so now inside of the game Loop
55:42 - let's do it on top of the ship I want to
55:44 - call display surface. blit again with
55:49 - the meteor surface and the meteor
55:52 - rectangle let's run all of this and we
55:55 - have a meteor right in the middle of the
55:56 - window so that is looking pretty good
55:59 - although I suppose we should draw all of
56:01 - this before the player I think it's
56:02 - better if the player always on top of
56:04 - everything else next up we want to place
56:07 - the laser in the bottom left with 20
56:09 - pixels of padding for that we will need
56:12 - a laser unor surface with pame do image.
56:18 - load using the join method I want to go
56:21 - to images and then import laser. PNG and
56:25 - just a double check we are importing
56:27 - this laser. PNG and also as always
56:31 - convert
56:33 - Alpha after we have that we want to
56:35 - create a laser rectangle with the laser
56:39 - surface and then get F
56:42 - rectangle and since I want to place this
56:44 - one in the bottom left I want to place
56:46 - the bottom left
56:48 - point and for that I will need an X and
56:51 - A Y position and now let's think about
56:55 - it with we have the entire window
56:58 - looking something like this and we want
57:01 - to place the laser in this bottom left
57:03 - point which means from the left side we
57:06 - want to have an offset of 20 pixels oh
57:09 - and also we are placing this point which
57:12 - means for X we only want to go 20 pixels
57:14 - to the right but then for y we want to
57:17 - go all the way down to the bottom of the
57:19 - window and subtract 20 pixels from that
57:22 - that way we are getting to this point
57:25 - and if I could draw a straight line this
57:26 - would be much better visually but you
57:29 - get the idea so for X we want to have 20
57:32 - and for y we want to get the window
57:34 - height and subtract 20 from
57:38 - that now running all of this again we
57:40 - don't see anything because we are not
57:43 - calling the blit
57:45 - method once again let's do it before the
57:47 - player display surface dot lit with the
57:52 - laser surface and the laser rectangle
57:57 - next attempt and there we go in the
57:58 - bottom left we now have a laser that is
58:01 - making some progress and I think at this
58:03 - point you might become a little bit
58:06 - uncomfortable because we are importing a
58:08 - surface four times and we basically copy
58:11 - the same method four times which really
58:14 - isn't efficient also when we are
58:16 - displaying all of the graphics we using
58:18 - the same line three times with different
58:21 - arguments which also isn't great and
58:24 - don't worry later on we're going to make
58:25 - Auto of this much more efficient so that
58:28 - we can import hundreds of graphics with
58:30 - just one function we wouldn't have to
58:32 - write every single line by hand because
58:35 - that's just not a convenient way of
58:37 - working also later on we are going to
58:39 - learn about better ways of displaying
58:41 - multiple
58:42 - Graphics so with all of that there's
58:44 - just one more thing to do and that is
58:46 - move the player left and right and for
58:49 - that let's organize all of this a bit
58:51 - better so we are moving the player with
58:54 - these two lines move them a bit down
58:56 - and then at comment we have the player
59:01 - movement and essentially how we are
59:03 - going to approach this when we are
59:06 - creating the player we can add a player
59:10 - uncore Direction which by default is
59:13 - going to be
59:14 - one and then when we are moving the
59:16 - player we are getting the player
59:18 - rectangle and then use one of the points
59:21 - we could go with X here that's simply
59:24 - the left side those two values are
59:26 - identical and then increase this by the
59:29 - player Direction multiply it with the
59:32 - speed which in our case is going to be 0
59:34 - point let's say four and then we don't
59:37 - need this if statement for bit if I now
59:40 - run all of this again the player is
59:42 - moving to the right however if I set
59:45 - this value to a negative one and run the
59:48 - entire thing again the player is moving
59:50 - left so that is working really
59:53 - well which means inside of this if
59:56 - statement we want to check if the player
59:59 - is outside of the window which means
60:01 - player. rec. right is greater than the
60:03 - window wift or player w. left is smaller
60:09 - than zero or the left side of the window
60:12 - if either of those conditions are met
60:14 - then we want to change player Direction
60:17 - and multiply it with
60:19 - -1 if I now run all of this
60:22 - again we are bouncing left and right
60:26 - that is working really
60:29 - well so very happy with that and at this
60:32 - point we have covered the basics of
60:35 - rectangles now I guess there's one thing
60:37 - that I haven't covered and that is you
60:39 - can create rectangles from scratch
60:41 - entirely so for another comment a
60:44 - rectangle if you want to create a plain
60:47 - rectangle you simply would call py game.
60:50 - F rectangle this could also be py.
60:53 - rectangle if you want to have a normal
60:55 - rectangle Ang Le which we basically
60:57 - never want to do and inside of there you
61:00 - have to specify two two builds one for
61:02 - the position and another for the size
61:05 - this would be one way alternatively you
61:07 - could also specify the left the top the
61:10 - WID and the he both approaches are
61:14 - totally fine and at the end you are
61:16 - getting a rectangle that being said for
61:18 - our purposes at the moment this isn't
61:20 - particularly useful because we have no
61:22 - reason to create a rectangle like this
61:25 - but for now don't worry too much about
61:26 - it and for the last bit before we finish
61:29 - if you look at the documentation there
61:31 - you have rectangles and this is going to
61:34 - give you a long list of methods that you
61:37 - could apply to a rectangle if you go a
61:39 - bit further down you can see all of the
61:41 - points that I have talked about earlier
61:44 - the two that I haven't mentioned are X
61:46 - and Y which are simply left and top so
61:50 - if you want to know more about them just
61:52 - keep on reading all of this I will talk
61:55 - about it later as well and we are going
61:57 - to use rectangles a lot so this part of
62:00 - the documentation is going to be
62:02 - something you definitely want to be
62:03 - familiar with for example in there we
62:06 - have all of the Collision
62:08 - methods which are going to be super
62:10 - useful for a game just one more minor
62:13 - thing before we are finishing all of
62:15 - this when we are placing a surface via a
62:19 - rectangle what we actually do is placing
62:22 - the top left of the surface in the top
62:24 - left of the rectangle
62:27 - or in other words it doesn't matter if
62:28 - you use player rectangle or player
62:30 - rectangle dot top left the end result is
62:33 - going to be the same also while we are
62:36 - here the size of the rectangle does not
62:39 - need to match with the size of the
62:41 - surface for example what we could be
62:44 - doing the loaded player I can create
62:47 - another plain rectangle and then aign py
62:50 - game. F wrecked with a position of let's
62:54 - say and2 200 and then for the width and
62:57 - height I can use entirely random values
63:00 - let's say 200 and
63:02 - 620 if I now use this rectangle to
63:06 - position the player with the blit method
63:09 - and the
63:12 - rectangle we can still place the player
63:14 - in a certain
63:16 - position even though the rectangle is
63:18 - going to be much larger so while the
63:20 - player would occupy this space the
63:22 - rectangle would I think be something
63:24 - like this
63:26 - but as far as blit is concerned this
63:28 - doesn't matter because we are always
63:30 - placing wrecked dot top left although
63:33 - obviously this isn't what I want to do
63:35 - and generally it is a good idea to have
63:37 - a rectangle and a surface with the same
63:39 - size especially when it comes to
63:41 - collisions this will become really
63:43 - important although you don't necessarily
63:45 - have to do it but anyway I want to get
63:48 - rid of the rectangle and then we are
63:51 - done with this part with surfaces and
63:54 - rectangles covered we can work on moving
63:56 - stuff in much more
63:58 - detail we already have some movement but
64:01 - it's fairly crude and we can refine
64:03 - things a lot although for all of that we
64:06 - are going to need some
64:08 - Theory the general idea of how movement
64:11 - Works in literally any video game is
64:13 - that you are blitting a surface in a
64:16 - different position on every single frame
64:18 - so for example we can slowly draw the
64:20 - players ship further to the right and if
64:23 - these changes are gradual enough and we
64:25 - have a high enough range frame rate then
64:26 - your brain will think this is movement
64:29 - that is literally it so in pame when you
64:31 - are blitting a surface you can either
64:33 - change the XY tupal or the rectangle
64:35 - position that is literally it although
64:38 - fundamentally we are still just drawing
64:40 - a surface in a different position and
64:43 - that I can visualize quite well back
64:46 - inside of main. Pi we still have the
64:49 - ship moving left and right with a couple
64:51 - of other elements and what I want to do
64:54 - is add one more thing in the general
64:56 - setup I want to add a clock and the
64:59 - value for this is going to be py game.
65:02 - time. clock a clock object in pame is
65:06 - incredibly useful for two reasons number
65:09 - one it can control the frame rate at the
65:12 - moment our frame rate is simply this
65:15 - while loop or in other words if your
65:18 - computer can run this while loop 10,000
65:20 - time a second then your frame rate is
65:22 - going to be 10,000 time a second
65:24 - depending on your computer this might be
65:26 - faster or slower and we do want to have
65:29 - some control over this which we can do
65:32 - via the clock object the way you would
65:34 - do that is inside this wire Loop doesn't
65:38 - really matter where you put it I prefer
65:40 - to do it right in the beginning you can
65:43 - call clock dot pick and then enter an
65:47 - integer which is going to give you the
65:49 - frame rate of the game if you leave it
65:51 - empty you are going to get the maximum
65:53 - possible frame rate whatever words the
65:56 - speed of your computer determines the
65:57 - frame rate which is generally what you
65:59 - want that way you get the most amount of
66:02 - frames but if you change this to a 60
66:06 - and run all of this again now our ship
66:09 - is moving significantly slower and you
66:11 - can also see that the movement is quite
66:13 - a bit more choppy although this might be
66:16 - difficult to see on
66:17 - YouTube to make all of this more visible
66:20 - let me change the frame rate to one that
66:23 - way we're getting one frame per second
66:26 - and also while we doing this when we are
66:29 - moving the
66:30 - player I want to increase this number by
66:33 - a lot let's say 100 if I now run all of
66:37 - this again you can see how movement
66:39 - actually works we have the player and we
66:42 - are simply drawing it in a different
66:44 - position and that is literally
66:49 - it if you lower the frame rate far
66:51 - enough then movement is going to look
66:53 - very very static
66:56 - and you can already tell if I change the
66:57 - frame rate back to something very small
67:00 - let's say
67:02 - four then we are getting something that
67:04 - looks a lot more like movement and if I
67:07 - change it to
67:09 - 24 is usually the lowest frame rate that
67:12 - we perceive as motion although still not
67:15 - looking great but I hope you get the
67:18 - idea the fundamental thing that you have
67:20 - to understand for movement is that we
67:22 - are drawing a frame and on every single
67:24 - frame we are changing the player
67:25 - position a little bit and then for some
67:28 - reason the human brain doesn't see a lot
67:29 - of images the human brain sees movement
67:32 - that is fundamentally all we are doing
67:35 - that being said we can refine all of
67:37 - this in two important ways number one we
67:41 - want to use vectors to store a direction
67:43 - that way we can control the movement
67:44 - much better on top of that we want to
67:47 - include Delta time to make the movement
67:49 - frame rate
67:50 - independent so two important words here
67:53 - that we have to cover we are going to
67:55 - learn about vectors and we're going to
67:58 - learn about delta type let me talk about
68:01 - why those two are important first of all
68:03 - inside of the game via these three lines
68:06 - of code we are moving the player left
68:08 - and
68:10 - right which I don't actually want to do
68:12 - anymore so let me get rid of the if
68:14 - statement and also change this part I
68:17 - only want to move the player in One
68:18 - Direction let's say to the right by 100
68:22 - pixels on every single frame if I do
68:25 - that the player moves a little bit too
68:27 - fast let's say I want to change this to
68:30 - 20 and then the frame rate so clock.
68:33 - tick should be 10 if we note all of this
68:36 - again you can see the player is moving
68:38 - to the right however what if I wanted to
68:41 - move the player to the right and up at
68:43 - the same time for that we would need two
68:46 - lines of code player. r.x + 20 and
68:50 - player
68:51 - w.y minus equal let's say 10
68:56 - if I now run all of this again we get
68:59 - the player is moving up and right so
69:01 - that part is working but it's also kind
69:04 - of annoying because for a very simple
69:06 - thing we need two lines of code ideally
69:09 - what I would prefer is player wct Dot
69:13 - Center plus equal
69:16 - 20 and
69:19 - -10 that would be much easier and by the
69:22 - way what is happening here is that we
69:24 - are grabbing one of the twole points
69:26 - inside of the rectangle Center has an X
69:29 - and A Y position and we want to update
69:31 - both of them at the same
69:33 - time that however we cannot do at the
69:35 - moment if I run the code we are getting
69:37 - an error message that we have an invalid
69:41 - wrecked assignment on this line you
69:43 - simply cannot add a tuple or a list to a
69:46 - tuple position inside of a rectangle for
69:49 - that you are going to need a vector
69:52 - that's the first thing we are going to
69:53 - work on the second issue is going to to
69:55 - be frame rate Independence and you have
69:58 - already kind of seen the issue at the
70:00 - moment our frame rate is 10 and that is
70:03 - going to give us one kind of speed so
70:05 - our player moves at this speed but if I
70:08 - change the frame rate to 100 then our
70:12 - player moves significantly faster which
70:15 - is fine if we have a stable frame rate
70:17 - but later on we want to have a flexible
70:19 - frame rate meaning the game could run
70:21 - faster or slower on different computers
70:24 - and this we have to account for in the
70:25 - movement so that a player with a faster
70:28 - computer doesn't get much faster
70:30 - movement but anyway let's start with the
70:32 - movement I want to make sure that we can
70:34 - control the player Direction much better
70:37 - and for that we're going to look at
70:39 - vectors A Vector in P game and well
70:42 - basically anywhere else is a list with
70:45 - two values they are always going to be X
70:47 - and Y and you can only ever have two
70:50 - values at least in a 2d Vector there are
70:53 - also 3D and 4D vectors but in our case
70:56 - we are only ever working in a 2d space
70:58 - so our vectors will only ever have an X
71:01 - and A Y value those values you can read
71:04 - and
71:05 - change for example what you could be
71:07 - doing is create a vector with X being
71:09 - one and Y being five you could read the
71:13 - first part so x with indexing although
71:15 - nobody really does that what you rather
71:18 - see is that use vector. x and Vector doy
71:21 - and Via those you can get the value and
71:23 - you can update the value so with that we
71:25 - basically have a list that is
71:26 - constrained to two values so far this
71:29 - isn't exactly useful however via vectors
71:33 - we can do Vector math which is
71:34 - incredibly powerful if you multiply a
71:38 - vector by a number then you multiply
71:41 - both numbers inside of that Vector if
71:43 - you were to do all of that to a list you
71:45 - would simply duplicate all of the values
71:48 - so the difference here is quite
71:49 - noticeable we're going to do this in
71:51 - practice in just a second also you can
71:54 - add two vectors to together and then you
71:56 - get the sum of the individual numbers
71:59 - and finally what is really important to
72:01 - us is that you can add a vector to the
72:03 - Tuple position of a rectangle that way
72:06 - we can change both X and Y at the same
72:09 - time that was quite a bit so let's write
72:12 - some actual code first of all inside of
72:15 - the player Direction at the moment we
72:17 - only have netive -1 but I want to create
72:20 - a pame do math. Vector 2 and notice here
72:26 - there's also a vector three this one
72:28 - would have three values X Y and Z but
72:31 - this we don't really need so in our case
72:34 - we have a vector 2 with X and Y if you
72:37 - leave these values empty you're going to
72:39 - get a vector with 0 and zero which means
72:42 - if I leave it like this and then print
72:44 - the player
72:46 - direction we are getting an output of 0
72:49 - and 0 although in my case I want to have
72:52 - 24x and -10 for y we also don't need the
72:57 - print statement anymore and now if we go
73:01 - to these
73:03 - lines at the moment we are updating X
73:06 - and Y of the player rectangle
73:07 - individually but that we don't need
73:09 - anymore instead I want to get player W
73:12 - do Center plus equal the player
73:16 - Direction and
73:18 - now this is going to work although it's
73:21 - a bit fast let's change the frame rate
73:23 - back to p so we can see what's going on
73:27 - and now the player is moving to the top
73:29 - right and later on we can refine all of
73:32 - this to make it even more useful but
73:34 - this is something that you see really
73:36 - often that you take the two pit position
73:38 - of a rectangle and then add a vector to
73:41 - it to update
73:43 - it also what you could be doing so by
73:46 - default the values of the vector are 20
73:50 - and -10 however we could print layer
73:54 - Direction multiply it by two and then
73:57 - run the entire thing now as an output
74:00 - we're getting 40 and -20 the way you
74:03 - would be using this in an actual game is
74:06 - for the player direction we want to have
74:08 - fairly low
74:11 - values because that way we can define a
74:15 - player underscore speed which for now
74:17 - could be let's say
74:19 - 10 and then when we are updating the
74:23 - movement we are increasing the value by
74:25 - the player Direction multiplied with the
74:28 - player speed the result is going to be
74:32 - what we had before via this system you
74:35 - can separate the player Direction and
74:37 - the player speed so for example the
74:40 - player direction we can get simply via
74:41 - player input something we haven't done
74:44 - yet but that's going to be the next
74:45 - section actually oh and just for
74:48 - reference if you wanted to multiply a
74:51 - list let's say we have a list with 1 two
74:53 - and three and we are multiplying all of
74:56 - this with
74:57 - two if I run the code our output is
75:00 - going to be a list where every single
75:03 - value was
75:04 - duplicated or in other words math for
75:07 - vectors and math for a list is
75:09 - completely different those two just
75:11 - aren't comparable but anyway with that
75:14 - we have vectors something that you
75:16 - definitely want to use in P game they
75:18 - are super useful so the next issue that
75:20 - we have to work on is frame rate
75:23 - Independence and ultimately the issue we
75:26 - have here is that depending on the
75:28 - computer that the game is run on you
75:30 - might get wildly different frame rates
75:33 - and since we update the position on
75:34 - every new frame of the game the faster
75:36 - the game runs the faster the movement is
75:39 - going to be which isn't ideal you want a
75:42 - movement to always be the same
75:44 - regardless of the computer which we have
75:46 - to guarantee imagine you have two
75:48 - players one with a really fast computer
75:50 - and one with a really slow one the one
75:52 - with the better computer might run the
75:54 - game 10 times as fast If this means that
75:57 - all the movement in the game is 10 times
75:59 - as fast it just wouldn't be controllable
76:01 - anymore and let me visualize all of this
76:03 - a bit better using math so we have a
76:06 - table with three columns the first one
76:09 - is going to be the movement and we
76:12 - always try to move by 10 pixels this
76:16 - value doesn't change and also let me do
76:18 - all of this in the game right away for
76:20 - our player Direction I want a player to
76:23 - only move to the right so X is going to
76:25 - be one and Y is going to be zero hence
76:27 - we're not moving up or down and then the
76:30 - player speed is going to be 10 the value
76:32 - you have just seen in the
76:35 - table if we now go to this line the
76:39 - player should only move to the right
76:41 - let's try and there we go the player is
76:44 - moving to the right but depending on the
76:47 - frame rate this value might change so if
76:50 - we have a frame rate of
76:52 - 30 we're moving a bit faster if we're
76:55 - getting to a value of
76:57 - 60 we're moving quite a bit faster and
77:00 - if we get to
77:02 - 120 we're moving a lot
77:04 - faster and those numbers we have in the
77:07 - table the frames that we are setting in
77:10 - clock. tick is this frames per second it
77:14 - could be 30 it could be 60 it could be
77:16 - 120 it could also be something like a
77:20 - thousand since we only make 2D games the
77:23 - frame rate can actually become quite
77:25 - large something you definitely want to
77:26 - control for and finally the really big
77:30 - issue is this final column in which we
77:32 - are calculating the actual movement
77:35 - which is simply the movement multiplied
77:37 - by the frame rate and from that you can
77:39 - tell that we are getting wildly
77:41 - different movement speeds these numbers
77:44 - have to remain the same because inside
77:45 - of the code we are specifying the same
77:48 - speed so getting from this to a very
77:51 - different actual speed in the game
77:53 - simply isn't acceptable
77:55 - and to fix all of that we will need
77:57 - Delta time which is the time it taks
78:00 - your computer to render one frame for
78:03 - example if our frame rate is 60 frames
78:05 - per second then we can divide 1 second
78:08 - by 60 so it takes our computer
78:11 - 0.017 seconds to render one frame that
78:16 - value we can actually get from this
78:18 - clock object it's simply the return
78:20 - value so in there we can get DT short
78:23 - for Delta time
78:26 - and after that I can print Delta time
78:30 - and run the code and now you get in the
78:33 - bottom we have a Delta time of 8 or 9
78:38 - that is because our frame rate is
78:41 - 120 or in other words the values we
78:44 - getting down here are 1 / 120 and this
78:49 - number can fluctuate a bit hence we're
78:51 - getting either eight or n but if you do
78:54 - the actual Cal calculation the value
78:56 - would be
78:59 - 0.83 and I should mention that this
79:02 - calculation is in seconds but the return
79:04 - value from clock. tick is in
79:06 - milliseconds hence we're getting 809
79:09 - here and 0.008 in here if we change this
79:13 - value to a 30 and run all of this again
79:17 - then we're getting 33 or
79:20 - 34 and I guess from the slides the value
79:22 - we have used was 60 frames per second
79:25 - and if I run this we're getting 16 or 17
79:28 - milliseconds also if I leave this value
79:31 - empty and we let the game run as fast as
79:34 - possible in that case our Delta time is
79:38 - going to be zero or one which indicates
79:40 - that we're getting a frame rate of about
79:43 - a th000 frames per second or even more
79:46 - that's something we can actually measure
79:48 - after clock. tick we can get clock and
79:53 - then get FPS and don't forget to call
79:56 - this one if I now Run the game we can
79:59 - see our frame rate and if we don't limit
80:02 - it in my case the frame rate is
80:04 - somewhere between 1,000 and
80:07 - 1,250 although keep in mind in your case
80:10 - these numbers might be different and
80:11 - that is totally fine what is really
80:14 - important to understand for now is that
80:16 - Delta time for every computer can be
80:18 - different and we are simply measuring
80:20 - the difference in time between the
80:22 - current frame and the last frame or
80:24 - other words how long it takes your
80:26 - computer to render one frame and that
80:28 - information is incredibly useful to
80:31 - understand why let's have a look at
80:32 - another table the first three columns is
80:36 - what we have seen already in there we
80:38 - have a movement we have a frame rate and
80:41 - then we get the actual movement and
80:44 - these numbers being different is the
80:46 - actual problem so what we want is that
80:50 - all of these values are the same and for
80:52 - that we can use Delta time which is the
80:55 - time it takes to render one frame so for
80:57 - example if our frame rate is 120 our
81:00 - Delta time would be
81:03 - 0.08 if it's 60 we get 17 milliseconds
81:07 - if it's 30 we get 33 milliseconds if it
81:10 - was a th000 we would do 1 over a th000
81:14 - so this value would be
81:17 - 0.001 and that information is incredibly
81:19 - useful because that way we can do this
81:22 - calculation where we have the ual
81:24 - movement the frame rate and then Delta
81:27 - time if you add all of them together you
81:30 - are getting always the same movement
81:33 - regardless of the frame rate and the
81:35 - logic here should actually make a ton of
81:37 - sense all that we are doing is we are
81:39 - multiplying the frame rate with Delta
81:42 - time which essentially cancel each other
81:44 - out the value of these two combined is
81:47 - basically always one or in other words
81:51 - simply look at the frame rate and deltae
81:54 - time for example for 60 frames per
81:56 - second we get 60 and we are multiplying
82:00 - it with 1 over 60 the number we are
82:04 - getting here and those two numbers
82:06 - simply cancel each other out the end
82:08 - result is going to be one as a
82:11 - consequence the only thing that's really
82:13 - left is the actual movement that we care
82:15 - about and with that we can control for
82:18 - the frame rate let's implement it inside
82:21 - of the code we are already getting Delta
82:23 - time but this this at the moment is in
82:25 - milliseconds which is a bit awkward to
82:27 - use so I want to convert it to seconds
82:30 - which we can do by dividing it by a th
82:33 - and after that all that we really have
82:35 - to do to move the player is we want to
82:38 - get the player Direction multiply it
82:40 - with the player speed and then multiply
82:42 - it with Delta time if I run all of this
82:45 - we get some kind of movement at the
82:48 - moment this is really slow so let's
82:51 - change the player speed to let's say 100
82:55 - that way this feels a lot better
82:58 - actually this could be 300 let's try
83:01 - this again and yeah that feels
83:04 - better cool so with that we have the
83:07 - player speed and we get some kind of
83:10 - movement what is really important now is
83:13 - that this is independent of the frame
83:14 - rate which means if I change this value
83:17 - to a 10 and run all of this again we are
83:21 - getting the same speed although a lot
83:23 - fewer frames but that's expected because
83:25 - our frame rate is much lower although
83:28 - and this is the important part the
83:30 - actual speed of the ship has not changed
83:32 - we simply draw it less often and that is
83:35 - it with that we have covered Delta time
83:37 - and most importantly we have this line
83:40 - which is the standard to move anything
83:42 - in pi game where you have the two bit
83:44 - position of a rectangle and to it you
83:46 - add the direction via a vector multiply
83:49 - it with a speed and multiply all of this
83:50 - with Delta time via all of this we can
83:53 - move things very easily and we can move
83:55 - it independently of the frame rate
83:58 - finally then before we are finishing
84:00 - this section let's do another exercise I
84:03 - want you guys to make the players ship
84:04 - bounce around the window like an old DVD
84:06 - logo the end result should look
84:08 - something like this also in case you
84:11 - don't know what the DVD is here's a
84:12 - Wikipedia entry I have away pause the
84:15 - video now and see how far you
84:19 - get back in the game I want to start
84:22 - with the player Direction I think by
84:25 - default this one should be one and one
84:28 - that way if I run out of this again the
84:30 - player moves to the bottom right also
84:33 - the frame rate should be unlimited so
84:35 - the movement looks a bit nicer that
84:38 - feels better so now once the player
84:41 - touches this point we want to move the
84:43 - player in this direction for that before
84:46 - we are doing the actual player movement
84:48 - I want to check if ler rectangle dot
84:53 - bottom is greater than the window
84:57 - he if that is the case I want to get the
85:01 - player
85:02 - Direction and then change the Y part and
85:06 - all I really want to do is multiply it
85:08 - with -1 that way if we run the entire
85:12 - thing again we are bouncing up besides
85:15 - that we also want to check if player
85:17 - rectangle do right is greater than the
85:21 - window width if that is the case we want
85:25 - to get the player Direction Al now we
85:28 - want to get player Direction
85:30 - dox and then multiply it with
85:33 - negative-1 and now we are
85:38 - bouncing and then disappearing at the
85:40 - top so that part is looking pretty good
85:43 - next up once the play hits the top of
85:45 - the window we want to bounce down again
85:48 - that we can do inside of this if
85:50 - statement we simply want to add another
85:52 - part if player re
85:54 - top is smaller than zero if that is the
85:58 - case let's try this part we are bouncing
86:02 - down and at the bottom we are bouncing
86:04 - up again so only one more site to cover
86:07 - and that is going to be the second
86:10 - condition for the second if statement if
86:13 - layer w. left is smaller than zero and
86:19 - with
86:21 - that we are
86:24 - bouncing around quite well so with that
86:28 - we have movement that is much more
86:30 - robust next up we can work on the
86:33 - input I've made a mistake and you might
86:36 - have already noticed so sometimes we
86:39 - have the ship and the ship bounces
86:41 - around this screen something like this
86:45 - but some of the time the ship gets stuck
86:47 - on one of the walls so for example if we
86:50 - have a bottom Collision then the ship
86:52 - gets stuck here and Wobbles back and
86:56 - forth if we increase the speed of the
86:59 - ship to let's say
87:02 - 1,000 if we now Run the game there you
87:05 - could already see some weird Behavior it
87:08 - doesn't happen all the time but it could
87:11 - be an issue so essentially What's
87:13 - Happening Here is we have a ship moving
87:17 - like this and then once we hit a wall we
87:20 - are bouncing off these few lines here
87:23 - however there is a potential for a buck
87:26 - for example if the right side of the
87:29 - ship goes too far to the right so much
87:31 - further than the window whift let's say
87:33 - we are here we are still trying to move
87:35 - in this direction however when we are
87:38 - checking all of this again the ship is
87:42 - still too far to the right and as a
87:44 - consequence the direction of the ship
87:46 - will go this way and this is going to
87:49 - continue forever then we are basically
87:51 - stuck to this wall until we get lucky on
87:53 - the ship accidentally gets a bit further
87:55 - to the left now one way to start working
87:58 - on this is to add greater than or equal
88:01 - to this point or smaller than or equal
88:04 - to that would do a bit but it wouldn't
88:07 - fix the issue entirely now for this part
88:10 - since we are going to change these lines
88:11 - later on anyway I am not going to worry
88:13 - too much about it but what you would
88:16 - have to do if you're bothered by it you
88:18 - would need a separate if statement for
88:20 - each side for example if player wrecked
88:23 - do bottom is greater or equal than the
88:26 - window height if that is the case we
88:30 - want to set the player wck do
88:34 - bottom to the window height and then we
88:39 - also want to set the player Direction
88:42 - doy to -1 that way we are making sure
88:46 - that the player never exceeds the bottom
88:48 - of the
88:49 - window and later on when it comes to the
88:51 - pong game we are going to implement that
88:53 - logic
88:54 - although for now I'm not going to worry
88:56 - too much about it anyway this is going
88:58 - to cover the movement so let's work on
89:00 - the input although one more quick thing
89:03 - before we get to that if you look at the
89:05 - documentation there is no Vector
89:08 - entry instead what you would have to do
89:11 - is go to py game. math and in there we
89:14 - have a vector 2 and a vector
89:17 - 3 along with a whole bunch of additional
89:21 - information
89:24 - essentially when you are creating a
89:25 - vector in pame you can either write py
89:27 - game. math. Vector 2 or use the short
89:30 - hand with py game. Vector 2 both would
89:33 - get you the exact same result the last
89:36 - really major thing that we are going to
89:37 - need for a game is getting user input
89:40 - and for this part we're going to cover
89:42 - Mouse input and keyboard input by the
89:45 - end of the section we will be able to
89:46 - move the player around freely on the
89:48 - window either with the mouse or with the
89:51 - keyboard now getting input in pame can
89:54 - be done via two ways and one we have
89:56 - already seen that is the event Loop we
89:59 - already use this one to close the game
90:01 - and in there we could also get keyboard
90:03 - input and mouse
90:05 - input the one limitation here is that we
90:08 - can only ever have a single event Loop
90:11 - so if you have a complex game this part
90:13 - is going to get really messy the
90:16 - alternative to it would be pame dokey
90:18 - and py game.
90:20 - mouse those can also get the keyboard
90:23 - and the mouse in put and they are quite
90:25 - a bit more flexible they can be called
90:27 - anywhere in the code which makes them
90:29 - super useful to use in classes but other
90:32 - than that those two are fairly similar
90:34 - they both let you capture user input but
90:37 - there are some minor differences and
90:39 - I'll talk about them later now you might
90:41 - be wondering which one should you choose
90:43 - for
90:45 - input and well in my case I basically
90:48 - always use py game. key or py game.
90:50 - Mouse for a couple of reasons most
90:54 - importantly they are much easier to
90:56 - integrate with classes something that we
90:58 - are going to talk about in the next
90:59 - section but since you can call them
91:01 - anywhere in the code it makes them
91:03 - really easy to
91:04 - use and on top of that they can check if
91:08 - a button is being pressed
91:10 - continuously and I'm going to
91:11 - demonstrate this in the code in just a
91:13 - second but when you're using the event
91:15 - Loop you are checking the action of a
91:17 - button being pressed you are not
91:19 - checking if a button is being pressed so
91:22 - on practice if you you're holding down a
91:24 - button and then use the event Loop to
91:26 - capture the input you are only getting a
91:28 - single
91:30 - input whereas if you use py game. key
91:33 - and you check for the button press you
91:34 - would get continuous input if you want
91:37 - to move something around on the screen
91:39 - the second part is just better however
91:42 - it is totally valid to get input via the
91:44 - event Loop and sometimes that part is
91:47 - even necessary for example if you want
91:50 - to get touch input or the mouse wheel
91:52 - then you will have to use the event Loop
91:55 - and generally there's nothing wrong with
91:57 - using it just keep in mind that you
91:59 - would have to structure your game around
92:00 - it but other than that this part
92:03 - shouldn't be too difficult let's Jump
92:05 - Right In once again here we are in the
92:07 - code and the part that captures input
92:10 - already is this event
92:13 - loop at the moment we are checking if
92:15 - the event type is py game. quit I.E we
92:18 - are closing the window but you could
92:21 - check for quite a few more things and
92:23 - you would always use event. type for
92:27 - example in there we have pygame do e
92:31 - down if that is the case I can for
92:34 - example print key down if I now run the
92:38 - code I can press any button on the
92:40 - keyboard and we are getting key down so
92:44 - that part is working but it's not
92:46 - terribly useful to get a bit more
92:49 - information we can get
92:52 - event. key
92:54 - with that we are getting a value
92:58 - associated with every single key on the
93:00 - keyboard now this is always going to be
93:02 - an integer so at the moment this isn't
93:04 - particularly useful that being said for
93:07 - all of these values pyam has a constant
93:09 - to check what key we actually have the
93:12 - way you would use that is you would
93:14 - check if the event key is equal to pame
93:17 - and then
93:19 - Kore whatever key you are looking for
93:22 - there are quite a few options
93:24 - for example we could start with
93:27 - K1 order number one on your keyboard if
93:30 - I run the code now and I press any key
93:33 - we always get false but if I press one
93:35 - we are getting true so I know I am
93:37 - pressing this key or in other words what
93:40 - you could be doing is let me cut this
93:42 - part out and then we want to check if
93:45 - there's a key down event and if the
93:49 - event key is equal to py game. K1 if
93:52 - that is the case we want to print one so
93:55 - now I can run this
93:56 - again and if I press one we're getting
93:59 - one if I press anything else nothing is
94:01 - going to happen and that is the basics
94:05 - on how you can get keyboard input inside
94:08 - of the event Loop let's have a look at
94:10 - the documentation you want to look at
94:13 - event if you click on that you can get
94:17 - all of the event methods the one that we
94:19 - have already used is py game. event. get
94:22 - and that is by far the most most
94:23 - important one if you scroll down a bit
94:27 - you can see all of the main events that
94:30 - you could be looking for in there we
94:32 - have already used quit and we have used
94:34 - key down there's also key up there's
94:37 - Mouse motion Mouse button up and mouse
94:39 - button down those five are the ones that
94:42 - you are probably going to use the most
94:45 - and if you then look on the right you
94:47 - can see a few more parts that you could
94:49 - be using for example what key we are
94:51 - pressing and if there's a modifier
94:54 - or when it comes to Mouse motion we have
94:56 - the position and the buttons and that's
94:59 - basically all that you need to know
95:00 - about it but let's do all of this in
95:02 - code at the moment we only have keyboard
95:05 - input I also want to get mouse input for
95:08 - that I want to check if the event. type
95:12 - is equal to pame dot let's start with
95:15 - mouse
95:17 - motion this is going to trigger as soon
95:19 - as we have any kind of mouse movement so
95:23 - basically all the time let's for now
95:26 - print Mouse is
95:28 - moving for this part let me show my
95:31 - mouse and if I now Run the game I can
95:33 - move the mouse and we get mouse is
95:35 - moving as soon as I am moving the mouse
95:39 - once again this isn't terribly useful
95:41 - but what you could be doing here is
95:43 - print event.
95:46 - position that way we always get the
95:49 - position of this event which has to be
95:51 - the mouse
95:52 - position let's try and now you can see
95:56 - my mouse position in real time if we go
95:59 - all the way to the top left we are
96:00 - getting 0 and zero and all the way in
96:04 - the bottom right we getting nearly 1280
96:08 - by
96:09 - 720 and that is working pretty well and
96:12 - while we have that we can also get rid
96:15 - of this player Movement we also don't
96:18 - need to comment
96:19 - anymore and then do something like
96:24 - as soon as we have Mouse input I want to
96:26 - get the player rectangle and place the
96:30 - center to the event position I can now
96:33 - run the entire thing again and the ship
96:36 - is following the mouse that part is
96:39 - super easy and that is basically it with
96:42 - that we have keyboard and mouse input
96:44 - via the event Loop a pretty solid start
96:48 - but I wouldn't recommend using it hence
96:51 - I'm going to comment out all of this
96:54 - instead before we are drawing all of the
96:56 - game I want to do something else and
96:58 - that is going to be the input outside of
97:02 - the event Loop and that we can do via
97:04 - pame dokey or py game. mouse let's start
97:09 - with the mouse one this one is a bit
97:11 - easier to use so this mouse is an object
97:14 - and on there we can get the cursor get
97:16 - Focus get position get pressed get
97:18 - relative and so on the one I care about
97:21 - right now is get the position if you're
97:23 - calling this one you are getting the
97:25 - most position wherever you are calling
97:27 - this method so let's print it run the
97:30 - game and now I can once again track my
97:34 - mouse position and this has worked just
97:36 - as before so quite happy besides that we
97:39 - can also get rest which is going to give
97:43 - you the mouse buttons that are being
97:45 - pressed if I run this one we're getting
97:49 - a tuple with three values and if I press
97:52 - the left Mouse button we're getting true
97:54 - false false if I press the right Mouse
97:57 - button we get false false true and if I
97:59 - press the middle Mouse button so the
98:01 - mouse wheel we're getting faults through
98:02 - faults if I press all three at the same
98:05 - time we're getting three True Values and
98:08 - that's kind of it we basically have
98:10 - continuous input and then we are
98:12 - checking which buttons are being pressed
98:14 - if they are being pressed they are
98:16 - returning true to get one individual
98:18 - value you can simply use indexing for
98:21 - example if you want to check the left
98:22 - most button this would be index zero if
98:26 - I run this again I can check if the
98:28 - mouse button is pressed or not pressed
98:31 - the last Mouse input that you see fairly
98:34 - often is get relative this is giving you
98:37 - the relative Mouse speed and to explain
98:40 - how this one is going to work let's run
98:41 - the
98:42 - game right now once the game is running
98:45 - we're getting an output of zero and zero
98:48 - and this is effectively the mouse speed
98:50 - if I move the mouse around we're getting
98:52 - some values in here but if I stop moving
98:55 - this value goes back to zero and zero so
98:59 - effectively this is checking if the
99:02 - mouse is moving and how fast it is
99:04 - moving but that's basically all you need
99:06 - for the mouse input let me comment it
99:08 - out so we're not pring too much and next
99:11 - up we can work with pame do key dot get
99:15 - focused get just pressed get just
99:17 - released and get pressed those are the
99:20 - really important ones and get pressed is
99:22 - the one you basically always want to
99:25 - use that being said if I print the
99:28 - output we're getting way too much so in
99:32 - the game you are getting a giant list
99:37 - with all of the potential Keys being
99:39 - pressed like with the mouse buttons
99:41 - being pressed we're getting a list with
99:43 - all of the potential keys that could be
99:45 - pressed and if they're not pressed we're
99:47 - getting false if they are pressed we're
99:49 - getting true the problem for the
99:51 - keyboard is that we have a lot of value
99:53 - use so this isn't exactly feasible now
99:56 - the way you are supposed to use this is
99:59 - you should be storing the return value
100:02 - inside of a variable let's call it
100:05 - Keys you can use indexing on this and
100:08 - then use the Constance that you have
100:10 - seen inside of the event
100:13 - Loop for example I could use in here
100:16 - pame and
100:20 - kore1 if that is the case I want to
100:22 - print one and also this should be an if
100:26 - statement if I now run all of this again
100:29 - I can press one and we're getting an
100:31 - output of one if I press anything else
100:34 - nothing is going to happen so that is
100:38 - basically how you would get input via
100:40 - the keyboard outside of the event Loop
100:43 - and now I can talk about one important
100:45 - difference between the input from the
100:48 - event Loop and the input from the other
100:51 - methods when we getting the one being
100:53 - pressed from this part we're getting an
100:56 - output of one continuously as long as
100:59 - I'm holding down the key to demonstrate
101:02 - let me run all of this again I can press
101:04 - one hold it down and we get an infinite
101:07 - number of
101:09 - ones however if I comment out all of
101:12 - this and then uncomment this if
101:15 - statement I can run all of this again
101:17 - and now if I press one and hold it down
101:20 - we are only ever getting a single output
101:23 - or in other words the event Loop is
101:25 - checking the action of a button being
101:28 - pressed whereas P game. key. get pressed
101:32 - checks if a button is being pressed or
101:34 - not the difference is quite minor but
101:37 - really important to understand although
101:39 - if you do understand it then it should
101:42 - be fairly easy to use keyboard
101:44 - input so let me comment out the if
101:47 - statement inside of the event Loop and
101:50 - then move the player rectangle via
101:52 - keyboard
101:53 - input for that we already have a player
101:57 - Direction which by default should be
102:00 - zero and zero and since those are the
102:03 - default values I can leave this value
102:05 - empty
102:06 - entirely also the speed should be let's
102:09 - say
102:10 - 300 now the way we are going to use
102:13 - input is by changing the player
102:15 - direction or in other words I want to
102:17 - check for the keys and then check for
102:21 - kcore right for example and once I have
102:25 - that it's going to be player direction
102:27 - dox will be one and then to apply all of
102:31 - this we want to get the player rectangle
102:36 - Dot Center plus equal player Direction
102:41 - multiplied with player speed multiplied
102:45 - with Delta time if I now run all of this
102:48 - and I press right the player is moving
102:50 - to the right although he never stops
102:52 - moving moving to the
102:54 - right and that should make sense once we
102:57 - are pressing right once we always have
102:59 - this direction there's no way to return
103:02 - to a play Direction X being zero
103:05 - although for that we could add an else
103:07 - statement in which we are setting the
103:09 - player Direction dox back to zero that
103:13 - way I can move the player to the right
103:15 - only if I have actual input so that is
103:18 - working really well but we have a whole
103:20 - bunch of lines for something that should
103:22 - be really simple Le though this is kind
103:25 - of
103:25 - Overkill what is a much more elegant way
103:28 - of solving this is we can set the player
103:30 - direction dox to an integer of keys and
103:35 - pame do right the output would be
103:39 - exactly the same so I can run all of
103:41 - this and the player is still going to
103:43 - move to the right now the reason why
103:46 - this is working is because we have a
103:48 - Boolean value which can either be true
103:51 - or false and if we then use the in
103:54 - method true is going to become one and
103:56 - false is going to become zero and this
103:59 - is the value we actually add to player
104:01 - direction. X and what you can also do is
104:05 - copy all of this and then subtract pame
104:09 - do
104:10 - Kore left if I now Run the game again I
104:15 - can move left and right totally
104:17 - fine and I hope the logic for this one
104:20 - makes sense I guess it would be a good
104:22 - idea here to do some examples imagine K
104:25 - right is being pressed and K left is not
104:28 - being pressed as an output we would then
104:31 - get a value of one from right and zero
104:35 - from left and 1 minus 0 is going to be 1
104:39 - meaning we're moving to the right if we
104:42 - have K right not being pressed and K
104:45 - left being pressed then we're getting an
104:47 - output of 0 and 1 and 0 - 1 is -1 hence
104:53 - we are going
104:55 - left finally if both are being pressed
104:59 - then we are getting one minus one which
105:02 - is going to be zero so no movement at
105:04 - all and well with that we have very
105:07 - basic player
105:10 - input this line I want to duplicate and
105:13 - then get player Direction dot y for this
105:16 - we can check pame
105:18 - dok
105:20 - down minus pame do K up if I now run all
105:26 - of this I can move the player around in
105:30 - every possible Direction so this is
105:32 - working really well perfect we are
105:36 - nearly done there's just one more thing
105:38 - that I really have to cover and that is
105:41 - at the moment the speed of the player is
105:43 - inconsistent which you might find weird
105:46 - because we only have a single player
105:48 - speed the one that we are setting up
105:50 - here however if you run the game
105:53 - and if you only move left or right and
105:56 - up or down you're getting one speed but
105:59 - if you move diagonally all of a sudden
106:01 - you are moving quite a bit faster and
106:04 - this I can actually demonstrate a bit
106:06 - better I want to print the player
106:10 - Direction multiplied with the player
106:13 - speed this value is going to be a vector
106:17 - and on every single Vector we can get a
106:20 - magnitude which is the length of the
106:22 - vector which in this case would be the
106:24 - distance the player is moving on every
106:26 - single frame and in theory this number
106:29 - should always be the same but if we are
106:32 - trying this I can move left right up or
106:35 - down and we're getting 300 but if I move
106:38 - diagonally all of a sudden we're getting
106:41 - 424 or a much faster speed and if you
106:45 - think about it for a second it should
106:47 - make sense if we only move in one
106:49 - direction we're getting one of these
106:51 - inputs I.E we are moving 300 pixels to
106:55 - the right to the left up or down however
106:59 - if we get two inputs at the same time
107:02 - then we are moving to the right by 300
107:05 - pixels and we're moving up by 300 pixels
107:08 - which means the actual distance being
107:10 - traveled is this line which is going to
107:13 - be much more than 300 in our case it's
107:16 - going to be
107:17 - 424 so this number we have to account
107:21 - for and to way you would do that is by
107:24 - changing the player Direction this one
107:27 - can only have a value of zero and one
107:30 - for example if we are only moving to the
107:33 - right then the value for this one would
107:35 - be one and zero however if we moved to
107:40 - the right and down then this value would
107:43 - be one and one for x and y and because
107:46 - of these two ones we are getting a much
107:49 - greater movement so what we have to
107:51 - figure out is that when we're moving to
107:53 - the right we have a direction of one or
107:57 - rather the length of player Direction
108:00 - when we only moving to the right is
108:01 - going to be one if we moving to the
108:04 - right and down I.E we have this and this
108:08 - then the length of the vector will be
108:10 - greater than one and to fix that we have
108:13 - to change the length of this line and
108:15 - this line so that the actual distance
108:18 - traveled is also going to be a one and
108:21 - that part is actually really easy
108:23 - because there is an inbuilt method for
108:25 - that this process of converting the
108:27 - length of a vector to a one is called
108:30 - normalizing a vector and basically all
108:32 - that's happening is you are changing
108:34 - these numbers so that the overall length
108:37 - of the vector is one with the number
108:39 - staying proportional the way you would
108:41 - do that before we are actually moving
108:43 - the
108:44 - player I want to update player Direction
108:49 - and set it to player direction do normal
108:54 - now if you're running the code at the
108:55 - moment this is going to give us an error
108:58 - that we cannot normalize a vector of
109:00 - length zero we are trying to change the
109:02 - length of a vector to one while keeping
109:05 - X and Y
109:07 - proportional but if both X and Y of a
109:10 - vector are zero then this isn't possible
109:13 - High game simply doesn't know in which
109:15 - direction we want to go hence it cannot
109:17 - normalize the length of the vector to
109:20 - one and this is exactly the error we are
109:22 - getting here fortunately the way around
109:25 - that is fairly simple we only want to do
109:28 - that if layer direction is different
109:32 - from zero and inside of an if statement
109:36 - any Vector on P game is going to be faly
109:38 - if the values are zero and zero if you
109:41 - have any other value then it's going to
109:42 - be truthy which means else we simply
109:45 - want to keep the player Direction and
109:48 - with that I can run all of this again
109:51 - and now no matter and what direction I
109:53 - am going in the speed of the player is
109:56 - always going to be
109:58 - 300 I guess unless I stop moving but you
110:01 - get the idea and to actually see what
110:04 - happened let me only print the player
110:08 - Direction with that we are getting an X
110:11 - and A Y value and if I move left or
110:13 - right this is going to be one or
110:15 - negative 1 or 1 or negative - 1 for X
110:19 - and Y however if I move diagonally we
110:22 - are getting 0.7 and
110:25 - 0.7 those numbers are changed because of
110:29 - normalization and with these two numbers
110:31 - the length of the direction is going to
110:33 - be one so I hope that part wasn't too
110:35 - complicated basically if you want to
110:38 - have very simple keyboard input you
110:40 - would use these three lines and then
110:42 - actually move a rectangle via this
110:44 - fourth line now before we continue let's
110:47 - have another look at the documentation
110:49 - and there we have py game. key and py
110:51 - game. mouse
110:53 - inside of key you can get all of the
110:55 - methods and there are quite a
110:58 - few the one we have used so far is get
111:00 - pressed there's also get just pressed
111:03 - and get just
111:06 - released you could get a few more but
111:09 - they aren't too important and besides
111:12 - that inside of mouse we have get pressed
111:15 - get position get relative you could also
111:17 - set the position you can make the mouse
111:19 - invisible or get if the mouse is visible
111:22 - and so
111:23 - on the most important methods in here
111:26 - are get position and get
111:28 - pressed and to practice all of that
111:31 - let's do an exercise I want you guys to
111:33 - capture the input for the space bar if
111:36 - this one is pressed print fire laser on
111:39 - top of that use the keyboard input to
111:41 - trigger it only once and for that do not
111:44 - use the event Loop you should figure
111:47 - this one out via py game. key meaning
111:49 - you will have to read the documentation
111:51 - at least a little bit
111:53 - pause the video now and see how far you
111:57 - get back inside of the code I want to
112:01 - check let's do it after the player
112:04 - movement if keys and high game.
112:11 - Kore
112:13 - space if that is the case I want to
112:15 - print fire or fire laser I think I
112:18 - called it doesn't really matter what you
112:20 - do in
112:21 - here if I can I run the code I can press
112:24 - space and we're getting fire laser the
112:26 - issue is we're getting this fire laser
112:28 - on every single frame of the game which
112:31 - at the moment is a th times per second
112:34 - which really really isn't
112:36 - ideal I want to make sure if the player
112:39 - is pressing this button we are only
112:41 - triggering fire laser
112:43 - once and for that let's have a look at
112:46 - the documentation I want to look at
112:48 - pygame dokey and in there first of all
112:52 - the one list you should be familiar with
112:54 - is this one here it contains all of the
112:57 - keyboard
113:00 - constants besides that we have get
113:03 - pressed and get just pressed the
113:06 - difference between these two is that get
113:09 - pressed checks for buttons constantly
113:11 - whereas get just pressed is only getting
113:14 - the most recent key presses other than
113:16 - that they work in basically the same way
113:19 - which means I can get the recent key
113:22 - Keys via pame dokey. getet just
113:27 - rest and if I then use all of those keys
113:30 - with the same constant I can run this
113:32 - again and if I now press space and hold
113:35 - it we are only getting fire laser once
113:38 - although I can press it again and once
113:40 - again we are only getting it once on
113:43 - every press of the key so that is
113:45 - looking pretty good and the other input
113:47 - is still working just fine so that is
113:50 - all working pretty well that being said
113:53 - this logic still isn't ideal because if
113:56 - I run the game again and I press space
113:59 - really quickly we are still getting a
114:02 - lot of fire laser so in an actual game
114:04 - the player would be able to shoot way
114:06 - too many lasers and for that we are
114:08 - going to implement a timer later on I
114:10 - think for now it's not too important the
114:13 - actually important part for now is that
114:14 - you can get keyboard input Mouse input
114:17 - either via dedicated methods or via the
114:20 - event Loop if you can do that you can
114:23 - get keyboard input in P game in this
114:25 - part we are going to cover Sprites which
114:28 - are not going to change the game so by
114:30 - the end of the section the game is still
114:31 - going to look like
114:33 - this however we're going to organize
114:36 - everything significantly better and that
114:39 - is all that Sprites are doing it doesn't
114:41 - sound like a lot but once the game
114:43 - becomes even a bit more complex you
114:45 - basically cannot do it without Sprites
114:48 - let's talk about it basically for any
114:51 - project you want to be using classes and
114:54 - by the way if you don't have that much
114:56 - experience with them check out my
114:58 - introduction to python this one covers
115:00 - classes in a lot more detail at this
115:02 - point I will assume that you know
115:04 - classes at least reasonably well now in
115:06 - our case the code is already becoming
115:09 - messy for the player we have a surface a
115:12 - rectangle some code for the movement and
115:14 - some code for firing so quite a few
115:17 - lines even though the player doesn't
115:18 - actually do that much it simply moves
115:21 - around and then PR Sprints when we are
115:23 - pressing fire if the player was able to
115:25 - do more and we had other objects the
115:27 - code would become incredibly messy
115:29 - really fast so we have to organize all
115:32 - of this a lot better using classes and
115:35 - for that we can use a Sprite Which is
115:37 - the best way to use classes in pame not
115:40 - the only one though but it's essentially
115:42 - the
115:43 - default basically a pame Sprite is an
115:46 - inbuilt class that always contains a
115:48 - surface and a rectangle and that is
115:50 - literally it it's just a class with a
115:52 - surface and a rectangle and then you can
115:54 - add anything else that you
115:56 - need or in other words for sprite we
116:00 - have a pygame class called py game.
116:02 - sprite. Sprite and from this class we
116:05 - are going to
116:07 - inherit after we doing that we have to
116:10 - overwrite self. image which contains the
116:12 - surface and self. rectangle which
116:14 - contains the rectangle only then is the
116:17 - class going to work
116:19 - properly let's try off this in practice
116:21 - here we we are back in the code and I
116:23 - want to create a class all the way in
116:26 - the top this one is going to be the
116:28 - player and for inheritance we need
116:31 - parentheses and then pygame dos sprite.
116:34 - Sprite after that we will need a thunder
116:38 - init method which is going to run as
116:41 - soon as we are creating one instance of
116:43 - this class and in this thunder in method
116:47 - we always need self and after we have
116:49 - this method we have to do three things
116:52 - the first one is like with any other
116:54 - inheritance we have to call Super Dunder
116:57 - init to initialize the parent
117:00 - class after that for a pame Sprite we
117:04 - will need self. image and self.
117:08 - rectangle the image is going to contain
117:11 - the surface that we want to display or
117:14 - in our case we want py game. image. load
117:17 - and
117:18 - player.png along with convert Alpha for
117:22 - the rectangle we want to do basically
117:25 - what we have done down here so let me
117:27 - copy
117:28 - it we want to get the player surface and
117:31 - then get F rectangle and place the
117:33 - player in the middle of the window the
117:35 - only difference now is that we don't
117:37 - have a player surface inside of this
117:39 - method what we have is self.
117:43 - image this one actually stores the
117:46 - surface and with that we have a very
117:49 - simple pame Sprite that contains a
117:51 - surface and the rectangle although if I
117:54 - am running the code now nothing is going
117:56 - to change we can still see the player
117:58 - but that happens
117:59 - because we get all of this stuff which I
118:02 - don't want anymore so I'm going to
118:03 - comment it out and then we are doing all
118:06 - of this which I also don't want anymore
118:10 - and I also don't want to display the
118:13 - player using the blit
118:14 - method if I now run the code again we
118:18 - can only see the meteor the background
118:19 - and the laser so to use the pame Sprite
118:24 - class first of all we have to create one
118:27 - instance of this class let's do it where
118:31 - we used to have the player I want to
118:33 - create a player variable and then one
118:35 - instance of the player class after we
118:39 - have that at the end of the game loop I
118:42 - want to call display surface. blit and
118:45 - we could get player. image and player.
118:49 - rectangle if I now run all of this again
118:52 - you can see we have a players
118:54 - ship although at the moment it doesn't
118:57 - do anything because we do not capture
118:59 - any kind of input which we are going to
119:01 - reintroduce in just a second first of
119:04 - all though this is not the proper way to
119:06 - display a Sprite let me remove it right
119:09 - away instead let's talk about it in a
119:12 - bit more detail to display a Sprite you
119:16 - could use surface. blit with Sprite out
119:18 - image and Sprite out rectangle although
119:20 - that is not a good approach approach
119:22 - what is much better is to use a pame
119:25 - group and for that we are going to need
119:27 - a bit of theory so for a spread group we
119:31 - have the basic issue that in a proper
119:33 - game we want to display dozens if not
119:35 - hundreds of
119:37 - Sprites and pame Sprite groups are
119:39 - designed around that they can do three
119:42 - things they can draw all of the Sprites
119:44 - they can update all of the Sprites and
119:46 - they can organize the Sprites for
119:48 - drawing we simply get the group and then
119:51 - draw on a surface
119:52 - and this is going to draw all of the
119:54 - Sprites on that
119:55 - surface this would work with hundreds if
119:58 - not thousands of Sprites which is much
120:00 - easier to use than calling surface. blit
120:02 - a thousand times besides that we have
120:05 - group. update and we could pass in any
120:08 - amount of arguments in there this would
120:10 - call an update method on every Sprite
120:12 - inside of that group with those
120:15 - arguments and finally you can also Loop
120:18 - over Sprites to use them in other
120:20 - methods so for example in just a bit
120:23 - when we are creating the meteors we are
120:25 - going to place each meteor Sprite into
120:27 - two groups one to display them and one
120:30 - to organize them that way we always know
120:33 - when we have a meteor Sprite although
120:36 - first of all let's create a single one
120:38 - for the player before we are creating
120:40 - any Sprite I want to create a Sprite
120:43 - group that I call all Sprites because
120:46 - we're going to place every single Sprite
120:48 - in there to create a group we need p .s
120:53 - sprite. group and then when we are
120:56 - actually running the game so in the
120:58 - while loop we want to get that group all
121:03 - Sprites and then we have a draw method
121:06 - and an update method that can accept any
121:09 - amount of arguments but now let's simply
121:12 - work with the draw method and we want to
121:14 - draw on the display
121:17 - surface that is a start but if I run the
121:19 - game we still cannot see the player here
121:23 - that is because when we are creating the
121:25 - player we are not attaching it to the
121:28 - spreite group and to fix that we can go
121:31 - in one of two ways number one after we
121:34 - have created one instance of the player
121:36 - class we can get all Sprites and then
121:39 - use the add method and add the player to
121:42 - it if I now run all of this we can see
121:45 - the player however this isn't usually
121:48 - what you see because it's well an
121:50 - unnecessary line what is much more
121:53 - common when you are creating a Sprite
121:56 - you are passing in the groups that you
121:59 - want this Sprite to be attached to after
122:02 - that when you're coing super Dunder in
122:04 - it you can pass the groups in there that
122:07 - way this Sprite will be added to this
122:09 - group automatically when we are creating
122:11 - the Sprite as a consequence we don't
122:15 - need this add method anymore but we do
122:18 - have to add all Sprites to the player
122:20 - class when we are creating one instance
122:22 - of
122:23 - it with that I can run all of this again
122:26 - and we can still see the player besides
122:28 - that what we can
122:30 - do before we are calling the draw
122:33 - method in fact before we are drawing
122:36 - anything inside of the game I want to
122:39 - call all
122:41 - Sprites do update for now without any
122:47 - arguments and also this recent Keys
122:50 - should be commented out
122:53 - by the way I am fully aware that the
122:55 - code is starting to get a bit messy we
122:57 - will clean this one up in just a bit
123:00 - first of all though before you're
123:02 - drawing anything call all Sprites do
123:04 - update this is going to call an update
123:07 - method on all of the Sprites inside of
123:10 - this
123:11 - group now in our case the player doesn't
123:13 - have an update method which means if we
123:16 - are running the code nothing is going to
123:19 - happen however if I am adding an update
123:24 - method to the player for now only with
123:26 - self then I can print ship is being
123:32 - updated and if I now run all of this
123:34 - again we are getting ship is being
123:37 - updated which means this update method
123:39 - is running just fine and in turn that
123:42 - means we can recreate all of this logic
123:47 - that part is actually going to be your
123:49 - exercise I want you guys to recreate the
123:51 - player movement logic inside of the
123:54 - player class and for all of this the
123:56 - code shouldn't really change all that
123:58 - much you just have to adapted to use it
124:00 - inside of object oriented
124:03 - programming pause the video now and see
124:05 - how far you
124:09 - get I suppose we should start by
124:11 - cleaning things up just a bit first of
124:14 - all we don't need this comment down here
124:17 - anymore and also we don't need the input
124:21 - inside of the event event
124:22 - Loop and after that I want to cut out
124:26 - all of the stuff we have commented
124:28 - out and then paste it below the player
124:33 - class with that inside of the update
124:36 - method we first of all want to get all
124:38 - of the keys after we are getting that we
124:42 - want to update the player Direction
124:44 - although at the moment player Direction
124:47 - doesn't exist inside of this class to
124:50 - fix that I want to create another
124:52 - attribute self. Direction which by
124:54 - default is simply going to be a pame do
124:57 - Vector 2 without any values after we
125:01 - have
125:02 - that I can copy those two lines paste
125:06 - them in there and clean all of this up
125:09 - the only change that we have to make is
125:11 - that this should now be self. Direction
125:13 - dox and self. direction. Y instead of
125:17 - player direction also at this point we
125:20 - have to make sure that we are
125:21 - normalizing the
125:22 - Vector that is going to happen in just
125:24 - the same way instead of play direction
125:27 - we want to have self. direction.
125:28 - normalize if we have a self. direction
125:31 - if that is not the case we want to keep
125:33 - self. Direction and then finally I want
125:37 - to get the actual movement for the
125:40 - player which is player. rec. Center plus
125:43 - equal direction speed and Delta time
125:47 - most of this doesn't exist anymore but
125:49 - let's go through it step by step the
125:51 - player rectangle now is self. rectangle.
125:54 - Center then we are getting self.
125:57 - direction and that we want to multiply
125:59 - with self. speed this self. speeed
126:03 - doesn't exist at the moment so we can
126:05 - create it inside of the dunder ined
126:07 - method self. speed is going to be I
126:10 - believe it was 300 yeah 300 that's a
126:14 - really good start and also at this point
126:16 - we do have Delta time because Delta time
126:20 - is in the global scope so we can use it
126:22 - inside of the
126:24 - class which means at this point if I run
126:27 - the game we can move the player around
126:30 - and this is looking really good now that
126:33 - being said you shouldn't have stuff in
126:35 - the global scope it's just not good
126:37 - practice so what is a much better way of
126:40 - handling all of this is when we are
126:42 - calling the update method we are passing
126:44 - Delta time in there and
126:48 - then inside of the update method we have
126:51 - to add one parameter to capture it which
126:55 - we can also call Delta time the end
126:57 - result though is going to look exactly
126:59 - the same besides that we also have to
127:03 - recreate this logic I think at this
127:06 - point this shouldn't be too hard anymore
127:08 - we simply want to get all of the recent
127:11 - keys and then check if recent Keys py
127:15 - game. Cas space is pressed and if that
127:18 - is the case we want to print fire laser
127:20 - with that we don't need the comments
127:23 - anymore and Run the game if I press
127:26 - space we're getting fire laser so that
127:28 - is working just fine and with that we
127:31 - have a player Sprite that is getting
127:32 - quite a bit more complex if I now
127:35 - minimize it and we don't need this stuff
127:38 - for the player
127:39 - anymore if you now look at the actual
127:42 - game Loop to display and update the
127:44 - player we simply have to call all
127:47 - Sprites do update with Delta time then
127:49 - all Sprites do draw on the target
127:52 - surface later on we are also going to
127:55 - create meteors and lasers dynamically
127:57 - which means at this point we can remove
127:59 - those two
128:01 - lines which is cleaning up things quite
128:03 - a bit more and finally when we are
128:06 - creating the Stars at the moment we are
128:09 - importing a star surface and then we are
128:13 - getting 20 random
128:15 - positions after that we are using
128:17 - another for Loop to displaying all of
128:19 - them in the actual game that we can also
128:22 - simplify by using a Sprite which means I
128:25 - want to create another class let's call
128:28 - this one star which also needs to
128:30 - inherit from pygame dos sprite. Sprite
128:33 - and by the way this part could be your
128:35 - exercise as well I want you guys to
128:38 - create 20 star Sprites and display them
128:40 - on the screen in random positions so the
128:43 - end result will be the same but the code
128:45 - should be much more organized pause the
128:47 - video now and see how far you get with
128:49 - this one
128:53 - first of all we want to call a Dunder
128:55 - init method where we have self and we
128:59 - have the groups like we have done for
129:02 - the player so there we also had Dunder
129:04 - in it with self and
129:06 - groups after that what you should always
129:09 - remember is to call Super Thunder init
129:13 - with the groups besides that we will
129:16 - need self. image and self. rectangle for
129:20 - the image I want to have the star
129:23 - surface let me cut it out actually and
129:26 - then we will need a rectangle and this
129:29 - is going to be a bit different compared
129:30 - to what we have done in the original
129:32 - when we created the star positions we
129:35 - use this comprehensions to create 20 X
129:38 - and Y T builds using Rand
129:40 - int that was necessary because we had to
129:44 - create all of the positions before we
129:46 - are running the
129:47 - game if we created all of the random
129:50 - values inside of the game they would
129:52 - update on every frame of the game which
129:54 - wasn't ideal but now we don't have to do
129:57 - that anymore because we going to create
129:59 - All of the Stars before the game is
130:01 - running
130:03 - anyway so for self. rectangle we can
130:06 - simply get self. image. getet F
130:11 - rectangle and then set the center to an
130:16 - xyle and those values we can copy for X
130:20 - I want to have random integer from zero
130:23 - to the window Wii and for y I want to
130:25 - have a random
130:27 - integer that goes from zero to the
130:29 - window height after that we don't need
130:32 - these two lines
130:34 - anymore also that's basically it for the
130:37 - class now we have an image and a
130:40 - rectangle and now to actually create the
130:42 - Stars I want to use another for Loop for
130:46 - I in range 20 and and then create one
130:52 - instance of the star class with the
130:55 - groups in our case we only have a single
130:57 - one all
130:59 - Sprites once we have that we don't need
131:02 - the for Loop inside of the game
131:06 - anymore and that's basically it the
131:08 - stars are still going to be drawn via
131:10 - the draw method of the group so I can
131:12 - run the game and we are still getting
131:15 - stars and the ship is moving although
131:18 - there are two things we have to refine
131:20 - the first one is that now the ship is
131:22 - below all of the
131:24 - stars that is happening because we are
131:28 - creating All of the Stars after the
131:32 - player and inside of a group all of the
131:35 - Sprites are being sorted by the time of
131:37 - their creation the later a Sprite is
131:39 - being created the later it will be drawn
131:42 - or in other words if we are creating the
131:44 - player after the Stars I can run the
131:46 - game again and now the player is on top
131:49 - of the Stars which looks a bit better
131:51 - better on top of that we can optimize
131:54 - the entire thing because when we are
131:56 - creating one star we are always
131:59 - importing a surface and since we are
132:01 - creating 20 Stars we are doing 20
132:03 - Imports but well we are importing the
132:06 - same surface 20 times which is not
132:09 - efficient at all so what would be much
132:12 - better here is to import the surface
132:15 - before we are creating the star let's
132:17 - call it starcore surface and then we are
132:21 - only importing it
132:22 - once after that when we are creating
132:25 - this star I want to pass this surface in
132:28 - there this should be the star surface
132:32 - after that when we are creating the star
132:34 - inside of Thunder init I want to have a
132:37 - surface and this surface will be
132:39 - assigned to self.
132:41 - image that way we are only doing a
132:44 - single import then using the same
132:46 - surface 20 times which is significantly
132:49 - more efficient generally importing
132:52 - anything is quite Hardware intensive so
132:55 - you ideally want to do all of that in
132:57 - the beginning of the game and then reuse
132:59 - the surfaces although now if I run the
133:02 - game we getting the same output so in
133:05 - practice since our game is really small
133:07 - this isn't going to make a
133:09 - difference and with that we have a
133:12 - player class and a star class and inside
133:14 - of the actual game you can see this is
133:17 - becoming significantly more organized
133:21 - we have one part where we are updating
133:23 - all of the game and then another part
133:25 - where we are drawing
133:27 - everything besides that we have Delta
133:30 - time and the event Loop but that's
133:31 - basically it via a Sprite you can
133:34 - organize your game significantly better
133:36 - and as soon as you have even slightly
133:38 - more complex projects this will become a
133:41 - necessity and going forward I will be
133:44 - using a lot more Sprites so if you
133:46 - struggle with classes more generally
133:49 - definitely check out some kind of
133:50 - introduction to them it's going to be
133:52 - really important the next important part
133:55 - is going to be working with Time by
133:57 - those we can create meteors and control
133:59 - the laser spawn time let's talk about it
134:02 - in our case we want to use time in two
134:04 - ways number one we want to create a
134:07 - timer that triggers every x amount of
134:09 - seconds and number two we want to have a
134:11 - cool down timer for the laser ultimately
134:15 - those need two different approaches for
134:17 - the first timer we want it to run
134:20 - continuously and then trigger within a
134:22 - certain interval although for the laser
134:24 - we want to have a timer that starts
134:26 - whenever we want and then runs for a
134:28 - certain amount of time to create these
134:31 - two timers first of all the Interval
134:33 - Timer or a timer that triggers every x
134:35 - amount of seconds this we can create
134:38 - with an inbuilt pame tool we basically
134:41 - create a custom event and then set a
134:43 - timer for that event once we have that
134:46 - we can capture that event in the event
134:47 - Loop like any other user
134:50 - input for the custom timer we would have
134:53 - to rely on a pyam method that captures
134:55 - the time or more specifically the time
134:58 - since the game has started and that we
135:00 - can use to create a custom timer
135:03 - basically all that we are going to do is
135:05 - we are capturing a starting point and
135:07 - then measure the time that has passed
135:08 - since that starting point if the
135:10 - difference between these two numbers is
135:12 - large enough then we want to run some
135:13 - code and then we have a custom timer
135:16 - none of this should be terribly
135:17 - difficult so let's Jump Right In I want
135:20 - to start by creating another section we
135:22 - can do this one all the way at the
135:24 - bottom before the while running Loop in
135:27 - there I want to create custom events or
135:31 - to be a bit more specific I want to
135:33 - create a meteor event so a timer that
135:37 - triggers twice a second and every time
135:39 - it triggers it creates a meteor for that
135:42 - first of all we will need a custom event
135:44 - that I want to store in a variable
135:46 - called meteor event and to create this
135:49 - one we want pame event and then custom
135:53 - type this is going to create a custom
135:56 - event and once we have that we can use
135:59 - py game. time.
136:02 - settimer for this one we will need two
136:05 - arguments number one is an event that we
136:07 - want to trigger which in my case is
136:09 - going to be the meteor event after that
136:12 - we will need a duration in milliseconds
136:14 - if you add 500 in here you would have a
136:17 - duration of half a second and with that
136:20 - we have created created a timer the way
136:23 - we are going to use that is inside of
136:25 - the event Loop we have to check for if
136:30 - event. type is equal to a meteor event
136:35 - if that is the case I want to
136:38 - print create
136:42 - meteor let's run all of this and in the
136:45 - bottom of the window we can see create
136:47 - meteor every half second and that runs
136:51 - continuously so it's looking pretty good
136:55 - perfect and well that's basically all
136:57 - you need to know to create an Interval
136:59 - Timer it it doesn't get any more complex
137:02 - so that would be the first kind of timer
137:04 - besides that inside of the player at the
137:08 - moment we are printing fire laser every
137:12 - time the player presses a button or in
137:14 - other words if I comment out this
137:18 - line and Run the game every time I press
137:21 - space we are printing fire laser and
137:24 - this happens as fast as I can press the
137:26 - button which shouldn't be the case there
137:28 - should be some kind of delay between
137:31 - different laser shots so we have to
137:33 - create a timer inside of the player
137:36 - class and essentially what we want to
137:38 - check if this is the time of the entire
137:42 - game where we start on this point and
137:45 - this is basically Infinity we want to
137:47 - check if the player has shot at this
137:49 - point in time let's say after 1 second
137:53 - then we want to wait for let's say
137:57 - 0.4 seconds only after that point has
138:00 - passed can we shoot again to implement
138:03 - that logic we will need a couple of
138:05 - attributes so let me create a timer or
138:09 - rather a cool down section we want to
138:13 - have first of all self. cancore shoot
138:17 - which by default is going to be true
138:19 - besides that I want to have a self.
138:23 - laser uncore shoot uncore time which by
138:27 - default is going to be zero and finally
138:30 - self.
138:32 - cool down
138:35 - duration which is the length of the cool
138:37 - down in my case 400 milliseconds and the
138:40 - way we are going to use that first of
138:43 - all if the player presses the space
138:45 - button we want to add a second condition
138:48 - and self. can shoot
138:51 - by default can shoot is true so this one
138:54 - is not going to make a difference
138:57 - however once we are running this if
138:59 - statement I want to set self dot can
139:02 - shoot to false with that if I run all of
139:07 - this again I can press space and we can
139:09 - only ever a shoot a single laser for the
139:12 - obvious reason once we have shot a laser
139:14 - can shoot is false so this if statement
139:16 - is never going to trigger to account for
139:19 - that I want to create another method
139:22 - let's call it the laser
139:25 - timer no need for custom parameters and
139:28 - in there we basically want to check
139:30 - first of all if not self do can shoot we
139:34 - only want to run any code in here if the
139:36 - player currently cannot
139:39 - shoot and then we want to get the
139:42 - current time which we can get via py
139:46 - game. time.get kcks this will get you
139:50 - the amount of time that has passed since
139:52 - the start of the game in milliseconds or
139:54 - to be a bit more specific the time since
139:57 - we have called pame do init just to
139:59 - demonstrate if I print that current time
140:03 - and then also we have to make sure that
140:05 - we are calling self. laser timer if I
140:10 - now run all of this I can press space
140:12 - and we're getting the time and it's
140:16 - increasing so that is working pretty
140:18 - well so with that we can get the time
140:21 - continuously besides that we will have
140:23 - to know when the player shot the laser
140:26 - which happens inside of this if
140:28 - statement and to get that we want to get
140:31 - self. laser shoot time and use py game.
140:35 - time.get ticks again now at this point
140:39 - you really have to understand that this
140:41 - if statement is only triggered once
140:44 - whenever the player shoots a laser
140:46 - however this Define laser timer or more
140:49 - specifically this this current time is
140:51 - being run
140:53 - continuously because of that we can
140:55 - check one point in time and after that
140:58 - check how much time has passed combined
141:00 - all that we really want to do is if
141:03 - current time minus self do
141:08 - laser shoot time is greater or equal to
141:12 - self. cooldown duration if that is the
141:15 - case we want to set self. can shoot back
141:18 - to true
141:21 - and that should be all if I now Run the
141:23 - game I can press space and even if I
141:25 - press it really fast we only get it
141:28 - every 400
141:30 - milliseconds to test all of this a bit
141:32 - better let's change the cool down
141:34 - duration to 2,000 or 2 seconds I can now
141:38 - press space as fast as I want but we
141:40 - only get fire laser every 2 seconds and
141:43 - let me go over the logic really quickly
141:45 - this is the timeline of the game where
141:48 - we start with py game. init this would
141:50 - be .0 and then the game could run as
141:53 - long as we need it to run if the player
141:56 - presses space then this if statement is
141:59 - going to trigger and we are capturing
142:01 - one point in time let's say in here and
142:04 - this could be
142:06 - 1,200 milliseconds since the start of
142:08 - the game and this point we are only
142:11 - capturing once after that we are calling
142:15 - Define Laser Time continuously which
142:17 - means this current time increases it
142:21 - would first be here then it would be
142:22 - here here here here and so on this
142:25 - number keeps on growing after we have
142:28 - that we are checking this line where the
142:31 - current time minus the laser shoot time
142:33 - is greater than the cool down duration
142:35 - or in other words our coolon duration
142:37 - would be 2 seconds we would be
142:40 - roughly at this line and Via this if
142:45 - statement we simply check if we are
142:48 - exceeding this point or not which at
142:49 - some point is going to be the case and
142:53 - that is it with that you can create a
142:55 - custom
142:56 - timer and also disc covers the two
142:59 - approaches to time and py game if you
143:01 - understand them you can create basically
143:03 - any kind of timer and later on in this
143:06 - video we're going to use this kind of
143:09 - logic to create a much more powerful
143:12 - timer but that's going to be a topic for
143:14 - later for now I want to use the timers
143:18 - meaning I want to create a laser and
143:19 - then a me
143:21 - and let's start with the laser although
143:23 - both of these classes are going to be
143:25 - fairly similar I want to create a class
143:28 - laser which has to be a pygame Dos
143:31 - sprite.
143:33 - Sprite in there as always we want to
143:36 - have a under init method with self we
143:39 - want to have a surface a position and
143:42 - then the groups we will need groups to
143:45 - assign it to a spreite group the
143:46 - position to place the laser in the right
143:48 - position which is going to be in front
143:50 - of the player and then the surface we
143:53 - want to import first of all and then
143:55 - reuse every time we are creating a laser
143:57 - you do not want to import every time the
143:59 - player shoots fortunately we already
144:02 - imported a laser surface so that part is
144:05 - quite easy although we don't need the
144:07 - laser rectangle
144:09 - anymore after we have that inside of the
144:13 - dund in method I want to call Super dot
144:17 - init and pass the groups in there after
144:20 - that we will need self. image which is
144:23 - going to get this surface and finally
144:26 - self. rectangle will be self. image and
144:31 - get F rectangle where we want to place
144:35 - the mid bottom this one is going to get
144:38 - the position the way you want to think
144:41 - about this one is that this will be our
144:43 - player and we want to create a laser
144:46 - right in front of it which means from
144:48 - the point of view of the player the
144:50 - laser should be in the mid top but from
144:53 - the Laser's perspective we should be
144:55 - placing the mid bottom anyway with that
144:59 - we have a laser class so now every time
145:02 - the player presses space we don't want
145:05 - to print laser anymore instead we want
145:08 - to create one instance of a laser for
145:11 - which we will need a surface that would
145:13 - be the laser surface then we will need a
145:16 - position which is going to be self. wct
145:19 - do mid top and finally for the groups we
145:22 - only have a single one all
145:25 - Sprites I can now Run the game and every
145:28 - time I press space we can create a laser
145:32 - now at the moment the cool down for the
145:33 - laser is really really large so we are
145:36 - only creating a laser every two
145:39 - seconds let's change that part right
145:41 - away this should be
145:42 - 400 if I now run out of this again we
145:45 - can create a laser at a much more
145:48 - reasonable Pace cool that covers
145:51 - creating the laser besides that though
145:54 - we also want to make sure that the laser
145:56 - is moving for which we will need an
145:58 - update method with self and Delta time
146:01 - basically all that we want to do is
146:03 - self. rec. Center minus equal some kind
146:08 - of speed for now let's say 400 and this
146:11 - we want to multiply with Delta time also
146:14 - this should be Center y we only want to
146:16 - move one point I can now run all of this
146:20 - and and we have a laser that is moving
146:23 - so that is looking really good with that
146:26 - we basically have a laser wasn't
146:28 - actually that difficult now at this
146:31 - point though you do want to be careful
146:33 - if the game runs long enough we will
146:35 - have a huge amount of laser
146:38 - Sprites they are not going to be visible
146:40 - but they will still exist hence they
146:42 - take up some processing time which could
146:45 - become very
146:47 - inefficient well this game it's not
146:48 - going to make a difference because the
146:50 - game as well really simple but for more
146:53 - complex game this could actually be an
146:55 - issue so what we want to do if this is
146:58 - the window of the game and we have the
147:00 - player somewhere in there if the player
147:03 - is shooting a laser and the laser passes
147:07 - the top of the window I.E we are exiting
147:10 - this point then we want to destroy the
147:12 - laser Sprite that we can do with if
147:16 - self. w. bottom
147:20 - is smaller than zero then we know the
147:24 - laser is above the window so it's not
147:27 - visible anymore if that is the case we
147:30 - can destroy the Sprite using the kill
147:33 - method now in the game this is not going
147:36 - to be
147:37 - visible although I guess I could
147:39 - demonstrate this we want to check if
147:41 - self. rec. bottom is smaller than 200 if
147:46 - that is the case the laser is simply
147:48 - going to disappear at this position so
147:52 - you can tell it is
147:54 - working in my case though this one
147:56 - should be zero and with that we have a
147:59 - proper laser class next up we want to
148:02 - create a meteor which is also going to
148:06 - be pygame dos sprite. Sprite and this
148:10 - part is going to be your exercise I want
148:12 - you guys to create a meteor on every
148:14 - meteor event on top of that I want you
148:17 - guys to destroy the meteor Sprite after
148:19 - 2 seconds or in other words create a
148:22 - timer inside of the meteor and start a
148:25 - timer once the meteor has been
148:30 - created first of all we will need a
148:33 - thunder init method where we have self a
148:36 - surface a position along with the groups
148:41 - next up super don't forget to call this
148:44 - one and then thunder in it where we pass
148:49 - the groups to the parent class and then
148:52 - we will need self. image and self.
148:56 - rectangle the image we're going to get
148:58 - from the surface I.E the parameter and
149:01 - then the rectangle is going to be self.
149:04 - image. getet F rectangle where we are
149:07 - placing this Center in the position that
149:10 - we are getting from the parameters and
149:12 - just as a reminder we are already
149:15 - importing a meteor surface although at
149:17 - this point we don't need the meteor
149:19 - rectangle anymore and looking at all of
149:22 - this I think we can organize things just
149:24 - a bit better we are not using the plain
149:26 - surface anymore this one can go entirely
149:29 - instead of that I want to have an import
149:31 - section where we are importing the star
149:34 - surface the meteor surface and the laser
149:39 - Surface after that we are creating a
149:42 - whole bunch of Sprites and then we have
149:44 - to custom
149:47 - event and before that we are doing the
149:49 - general setup
149:51 - which I think overall feels much cleaner
149:55 - all right now we have a
149:57 - meteor but this is not going to be
150:00 - visible in the game so we have to make a
150:03 - few more changes most importantly every
150:07 - time the meteor event triggers I want to
150:10 - uncomment all of that then we want to
150:12 - create one instance of the meteor class
150:15 - which means meteor and we have to pass
150:18 - in a surface which is going to be the
150:20 - meteor surface then we will need a
150:23 - position and for now let's simply say
150:26 - 400 and 500 two entirely random numbers
150:30 - we will change them in just a second
150:32 - besides that for the groups all
150:37 - Sprites if I now Run the game we are
150:41 - getting a meteor and since this one is
150:43 - always in the same position we are not
150:45 - going to see much of a
150:47 - change but at the very least it's
150:49 - working
150:50 - so we need to customize these numbers or
150:53 - in other words we want to have an X and
150:56 - A Y
150:57 - number both of those should be random
151:00 - for X I want to have a random integer
151:03 - between zero and the window wi for y for
151:08 - now I want to have a random integer that
151:10 - goes from zero to the window height or
151:14 - in other words at the moment we are
151:16 - spawning a meteor somewhere on the
151:19 - window
151:21 - let's try that and there we are getting
151:24 - meteors all over the window that part is
151:26 - working really well at this point we can
151:29 - also make the meteors move which we are
151:31 - doing via an update method Define update
151:34 - with self and Delta
151:36 - time all that we want to do in there is
151:39 - self. rec. Center
151:43 - Y and to this we want to add some kind
151:46 - of speed let's say 400 multiplied with
151:50 - Delta time I can now run all of this and
151:53 - we're getting meteors that are moving
151:54 - down so that's a pretty good start the
151:57 - reason why this is looking weird is
151:59 - because we are creating the meteor right
152:02 - in the middle of the
152:03 - window so the player can see when a
152:06 - meteor is being created to avoid that
152:09 - when we are setting the Y position we
152:11 - want to be on top of the window or in
152:14 - other words we want to be in a position
152:16 - randomly between -200
152:21 - and 100 let's try off this again and now
152:26 - this is looking quite a bit
152:29 - nicer the game is definitely coming
152:33 - together although that being said we can
152:36 - customize the meteor class just a bit
152:39 - more there are two things I want to do
152:41 - in there actually number one and this
152:43 - was part of the exercise so let's start
152:45 - with it we want to destroy every meteor
152:48 - Sprite after 2 seconds
152:50 - or in other words we want to have self.
152:54 - startor time which is going to be py
152:56 - game. time.get tick that way we know
153:00 - when the timer is supposed to start we
153:03 - can also set a self. lifetime which is
153:07 - going to be 2,000 milliseconds or 2
153:09 - seconds after that inside of the update
153:12 - method we want to check if py game.
153:18 - time.get 6
153:20 - minus self. star time is greater or
153:24 - equal to self. Lifetime and if that is
153:28 - the case we want to kill the Sprite
153:31 - let's try out of that and I think the
153:32 - meteors shouldn't reach the
153:34 - bottom and there you can see they
153:36 - disappear slightly before which was
153:39 - intentional so you can see it's working
153:42 - for the actual game we probably want to
153:44 - go with
153:47 - 3,000 so the player cannot see immed
153:50 - disappearing and that part is looking
153:52 - pretty good so I am quite happy with
153:54 - that now you might be wondering why
153:57 - aren't we using the laser logic where we
153:59 - are simply checking if a laser is above
154:02 - or below a certain position and then we
154:04 - destroy it for example for the meteors
154:06 - we can check if a meteor is below the
154:08 - bottom of the window and well you could
154:11 - do that it would actually be more
154:13 - efficient I simply wanted you guys to
154:15 - practice timers a bit more this approach
154:18 - is actually better
154:20 - although you should be familiar with
154:21 - both of
154:22 - them anyway with that we are destroying
154:25 - a Sprite after a certain amount of time
154:28 - besides that at the moment the meteors
154:30 - are always going in a straight line
154:33 - which isn't ideal I want to give each
154:36 - meteor a direction which is going to be
154:38 - a p game and Vector 2 for which we will
154:42 - need X and Y now why is always going to
154:45 - be one we always want to go down at the
154:48 - same speed
154:50 - however for X I want to have a random
154:52 - value and that should be a floating
154:54 - point value because we want to stay
154:56 - below
154:57 - one for which we are going to need
155:00 - another part from random this one is
155:02 - called
155:03 - uniform and uniform Works quite easily
155:07 - we want to specify two floating Point
155:08 - values we want to start attive 0.5 and
155:12 - then go to
155:14 - 0.5 after we have that when we are
155:17 - updating the position of the meteor we
155:19 - want to get a tet position center is
155:22 - totally fine and then get self.
155:25 - direction multiplied with self. speed
155:28 - multiplied with Delta time now self.
155:31 - speeed doesn't exist let's create it
155:34 - self. speed and this could also be a
155:37 - random integer let's say between 400 and
155:42 - 500 with that the game is going to feel
155:45 - much more organic and this is looking
155:49 - pretty good
155:50 - so very happy with that later on we are
155:53 - also going to rotate the meteors which
155:56 - is going to make things look even better
155:58 - but for now I think we have made some
156:00 - pretty solid progress to actually create
156:03 - a game we will need collisions so by the
156:06 - end of this section we can check if a
156:09 - meteor hits the player or if the player
156:11 - hits a meteor via a laser once we have
156:14 - all of that we basically have a game now
156:17 - collisions and py game you can do
156:18 - broadly into two ways number one you can
156:21 - use rectangle collisions a rectangle can
156:25 - check for collisions via a single point
156:27 - another rectangle or a list of
156:30 - rectangles besides that we also have
156:33 - Sprite collisions mostly what you're
156:36 - doing in there is you are checking the
156:38 - collisions between a single Sprite and
156:40 - Sprites inside of a group although there
156:42 - are quite a few variations for all of
156:45 - that you want to look at the
156:47 - documentation here we are and to get
156:49 - started you want to look at rectangles
156:52 - if you scroll down just a bit you can
156:55 - see all of the Collision methods I guess
156:58 - we can start up here the first one would
157:01 - be contain this one checks if a
157:03 - rectangle is inside of another rectangle
157:06 - then there's Collide point and this one
157:08 - checks if a point is inside of a
157:10 - rectangle after that we have Collide
157:12 - rect a really common method this one
157:15 - checks if there's an overlap between two
157:18 - rectangles and just just in case you're
157:20 - wondering contains means that a
157:22 - rectangle has to be entirely inside of
157:24 - another rectangle for this to trigger
157:27 - whereas Collide rectangle simply needs a
157:29 - simple overlap and well then we have a
157:32 - few more methods but I think they're all
157:34 - fairly straightforward so if you click
157:36 - on one of them let's say Collide wrecked
157:39 - you can see what pyam is expecting we
157:42 - need a rectangle and then we are calling
157:44 - Collide wrecked and pass in another
157:46 - rectangle the return value is going to
157:48 - be Boolean so I true or false and they
157:51 - basically all work in more or less the
157:53 - same way anyway besides that we can look
157:58 - at the Sprites which I haven't shown yet
158:00 - but they live in this section under
158:02 - Sprite and there you can create a pam.
158:05 - sprite. Sprite and if you go just a bit
158:09 - further down we can see all of the
158:11 - Collide methods by far the most common
158:15 - one is Sprite Collide besides that
158:17 - though we have Collide wrecked collide
158:19 - cor ratio Collide circle and a few more
158:22 - later on we are also going to use
158:24 - Collide mask but this one we haven't
158:26 - covered yet for now I only care about
158:29 - Sprite
158:30 - Collide this one at a minimum wants to
158:33 - have three arguments a single Sprite a
158:36 - group of Sprites and then do kill we
158:39 - basically check all of the Sprites
158:40 - inside of a group and if any of those
158:42 - Sprites collide with the single Sprite
158:44 - then we are storing those inside of a
158:46 - Sprite list that's the return value and
158:49 - do kill means that we are going to run
158:52 - the kill method on a Sprite that is
158:54 - colliding with the single Sprite and
158:57 - well that is basically it here we are
159:00 - and I want to start by creating some
159:02 - rectangle collisions although for real
159:04 - game you want to use Sprite collisions
159:07 - simply because you are going to work a
159:09 - lot with Sprites but you should be able
159:12 - to handle both anyway at the moment we
159:16 - have a player and in there we have a
159:19 - rectangle that is what I'm going to use
159:21 - for now which means inside of while
159:25 - running I can check and let's add
159:28 - another section here test
159:31 - Collision I want to get player.
159:34 - rectangle and then use Collide any of
159:37 - those methods and for now Collide
159:40 - point this one is checking if the
159:42 - rectangle is colliding with any point
159:45 - meaning we have to specify an X and A Y
159:48 - point for example in there we could add
159:51 - a 100 and 200 and that I want to
159:57 - print let's try off that and by default
160:00 - we are getting faults but if I move to
160:02 - one point up here we are getting true so
160:07 - this part is working quite well although
160:09 - I suppose it's very hard to see
160:12 - something that you could also do is use
160:14 - py game. mouse. getet position that way
160:19 - I I can show my mouse and by default we
160:21 - getting false because the mouse is not
160:23 - colliding with the spaceship however if
160:25 - I have a over it we're getting true so
160:27 - this is also working just fine another
160:31 - method that you do see very often is
160:33 - Collide rectangle for this one though we
160:37 - are going to need another rectangle
160:39 - let's create one before we are running
160:42 - the game I want to have a test
160:45 - rectangle which we are going to create
160:47 - via py game. f rect and by the way frre
160:51 - or normal rectangle doesn't matter for
160:53 - rectangle collisions they all work in
160:55 - the same way for this one we want to
160:58 - have a left top width and height let's
161:01 - say the left could be zero the top could
161:03 - also be zero and then the width will be
161:06 - 300 and the height will be 600 that
161:10 - means if this is our window the test
161:14 - rectangle is going to be roughly
161:16 - capturing this size and that we can
161:19 - check for inside of the game I want to
161:22 - check for player rec. cidere with the
161:25 - test rectangle if I now Run the game we
161:28 - get false by default but if I go to the
161:30 - top right we're getting true and then I
161:33 - can go outside of this area and we're
161:34 - getting false again so that is working
161:37 - pretty well and that is basically all
161:40 - you have to do for rectangle collisions
161:42 - they don't really get that much more
161:44 - complex although there's one important
161:47 - thing you should keep in mind when when
161:49 - we're talking about collisions in pame
161:51 - we don't really talk about collisions
161:54 - instead pame only really checks overlaps
161:57 - I.E if one rectangle overlaps with
162:00 - another rectangle but that is never
162:02 - going to change the position of either
162:04 - of those rectangles meaning if you want
162:07 - to have a game and the player is
162:08 - constrained by a wall or a house this
162:11 - would require extra Logic on your part
162:14 - something we are going to work on in the
162:15 - next game it's not terribly hard to do
162:19 - but but you do have to make it yourself
162:20 - just keep that in mind anyway with that
162:23 - we have rectangle collisions meaning we
162:25 - don't need this test collisions anymore
162:28 - and we can also get rid of this test
162:31 - rectangle next up we can work on Sprite
162:35 - collisions which are going to be much
162:37 - more useful and for now I want to check
162:40 - if a meteor is colliding with the player
162:44 - for that though we have a problem
162:46 - because at the moment all of our Sprites
162:48 - are in in a single Sprite Group which
162:51 - makes it really hard to separate all of
162:53 - them for that I want to create another
162:55 - Sprite group let's call it meor unor
162:58 - Sprites which is going to be pygame dos
163:01 - sprite. group the same thing we have
163:03 - done before and then when we are
163:06 - creating a single meteor instead of
163:09 - adding a single group we want to have
163:12 - two groups all Sprites and meteor
163:15 - Sprites and this is totally fine to do
163:18 - we are going to have all Sprites for the
163:20 - update and the display part and then the
163:22 - meteor Sprites are going to be used to
163:24 - classify all of the meteors or other
163:27 - words when we are working with a Sprite
163:29 - we know what we are working with besides
163:32 - that we also have the player inside of a
163:34 - separate variable that way we can always
163:36 - identify the player and by the way so
163:39 - far I haven't really talked about it but
163:41 - when you are creating a Sprite you're
163:44 - getting a return value of that Sprite so
163:46 - you can reference it via a variable but
163:49 - you don't really have to do that for
163:51 - example when we are creating a meteor
163:53 - we're not storing it inside of a
163:54 - variable we are simply attaching it to a
163:56 - group and then call it a day both
163:59 - approaches are totally fine to do now
164:01 - attaching a Sprite to a variable is
164:03 - something you only really want to do
164:05 - when you want to reuse that Sprite a lot
164:08 - or rather when you want to get very easy
164:10 - access to it which we do want to do for
164:12 - the player but for the meteor we don't
164:14 - really need
164:15 - it anyway after we have that before we
164:18 - are drawing the game still inside of
164:20 - update we want to check for collisions
164:23 - which we can do with pame DOs sprite.
164:26 - Sprite
164:28 - Collide this is the most important
164:30 - Sprite Collision method and in there we
164:33 - have to specify three arguments at a
164:35 - minimum the first one is a single Sprite
164:38 - Which in my case is going to be the
164:39 - player besides that we want to check a
164:42 - group of Sprites which is going to be
164:45 - our meteor Sprites and finally we have
164:49 - do kill or in other words if any of the
164:52 - Sprites inside of metor Sprites is
164:54 - colliding with the player do we want to
164:57 - destroy that Sprite that has collided
165:00 - for now let's say this one should be
165:03 - false and after we have that I can print
165:07 - the return value if I now try all of
165:10 - this by default we have an empty list
165:12 - but once there is an overlap we get a
165:14 - value inside of that list so that part
165:17 - is working pretty well now now so far we
165:20 - only ever get a single value but if I
165:22 - managed to overlap with two meteors we
165:24 - would have two values I suppose what we
165:27 - could be doing for the meteor event I
165:29 - want to change this to 50 that way we're
165:31 - getting a whole bunch more meteors and
165:33 - now you can see this list can contain
165:36 - many more values as many Sprites as we
165:39 - are colliding
165:41 - with or if you look at this if the game
165:43 - isn't running we're getting a collision
165:45 - with one meteor here and if I scroll up
165:48 - a bit and at some point we should have
165:50 - multiple
165:51 - collisions there for example we have a
165:53 - collision with two
165:55 - Sprites and if we set do kill to true
166:00 - then we are getting rid of any meteor
166:02 - that is colliding with the player so
166:04 - that is also working quite
166:07 - well and keep in mind what can sometimes
166:10 - be a bit confusing if you set do kill to
166:12 - true you are destroying the Sprite
166:15 - however the return value is still going
166:18 - to give you access ACC to that Sprite
166:19 - for one frame or if I scroll up a bit
166:23 - sometimes we do get the value and this
166:25 - sort of logic can be really helpful so
166:27 - after you have destroyed a Sprite you
166:29 - might want to do something else for
166:31 - example what you do see very often is
166:34 - that you don't want to print all of the
166:36 - collisions instead you want to use an if
166:39 - statement to check if you have any kind
166:42 - of
166:44 - collision if that is the case let's say
166:46 - print collision and this is still going
166:49 - to work even if we are killing the
166:51 - meteor on
166:53 - collision and this can only work if you
166:55 - have access to the Collision Sprite or
166:57 - in other words the return value of this
166:59 - cannot be an empty list once we have a
167:01 - collision in fact what you see even more
167:03 - often is that you assign the return
167:06 - value to a variable let's call it
167:09 - Collision
167:11 - Sprites you are checking if Collision
167:14 - Sprites is
167:16 - truthy and once you have that you can
167:18 - get Collision Sprites and get the first
167:20 - item to get the collided Sprite so if I
167:24 - try out of
167:25 - that we are getting the Sprite that we
167:28 - are colliding with so that part is
167:30 - working reasonably well that is
167:32 - basically it for sprite collisions the
167:34 - really important thing that you have to
167:36 - understand is that you can get access to
167:38 - a couple of methods via py game. Sprite
167:40 - and then the name of the method check
167:43 - the documentation for more details and
167:45 - after that you have to make sure that
167:47 - you have access to all of the Sprites
167:49 - which usually happens via either a group
167:52 - or by assigning a Sprite to a variable
167:56 - collisions or rather overlaps in py game
167:58 - aren't really that hard to get which
168:01 - means we can do an exercise I want you
168:03 - guys to check for collisions between the
168:05 - lasers and the meteors and then destroy
168:07 - both once there is a collision for that
168:10 - you would have to do a bit of creative
168:12 - thinking see how far you get and don't
168:14 - worry too much about it if you can't do
168:16 - it this one is getting slightly more
168:17 - advanced I have way pause the video now
168:20 - and see how far you
168:24 - get to check for the collision between
168:27 - the lasers and the meteors we first of
168:29 - all need to get access to all of the
168:31 - lasers and for that when we are creating
168:34 - a laser that happens on this line we
168:38 - want to assign a laser to all Sprites to
168:41 - display and draw it and then we also
168:43 - want to have another group called laser
168:46 - Sprites this one doesn't exist at the
168:48 - moment but we can create it quite easily
168:51 - below the meteor Sprites I want to have
168:53 - a laser Sprites Group which is going to
168:56 - be pame dos sprite. group with that we
169:00 - have access to all of the lasers so
169:02 - that's the first step next up we want to
169:05 - check if any Sprite inside of the lasers
169:07 - collides with any Sprites inside of the
169:10 - meteors and there we kind of have a
169:12 - problem if you look at the documentation
169:15 - for Sprites you don't really have a
169:17 - method for the that I suppose we do have
169:20 - group collides but this one simply
169:22 - checks if we have group one and group
169:24 - two we want to have a bit more detail we
169:28 - want to check for every single laser we
169:30 - don't want to check for the entire laser
169:32 - group so we can't really use this method
169:35 - however what we can do is to Loop over
169:38 - every single Sprite inside of this group
169:40 - and then Calla Sprite Collide or in
169:43 - other words inside of the game Loop we
169:45 - are currently checking if the player
169:47 - collides with a meteor besides that I
169:50 - want to do four laser in laser Sprites
169:56 - that way I get access to every
169:58 - individual laser Sprite and once I have
170:00 - that I can call pame Dos sprite. sprite
170:05 - light wave the individual laser and the
170:09 - metor Sprites and do kill should be true
170:14 - if I now run all of this and I press
170:17 - space the laser is going to destroy all
170:19 - of the
170:21 - meteors that part is working well but
170:24 - it's not ideal yet the laser simply
170:26 - destroys all of the meteor Sprites but
170:28 - that shouldn't happen once there's a
170:30 - collision the laser should also be
170:32 - destroyed for that I want to get the
170:35 - collided
170:37 - Sprites as a list and store all of the
170:42 - collisions if that exists I.E if
170:45 - collided Sprites then I I also want to
170:49 - get the laser and kill it if I now run
170:52 - all of this again I can shoot a laser
170:54 - and both the meteor and the laser
170:56 - disappear although that's a bit hard to
170:59 - see let's change the meteor spawn timer
171:02 - back to 500 and that way I can shoot at
171:07 - individual meteors and they disappear so
171:10 - that part is working quite
171:12 - well that being said we should keep this
171:14 - game Loop a bit more organized so what I
171:17 - think would be a more elegant is to put
171:19 - all of this into a separate
171:22 - function which means below the classes I
171:25 - want to Define collisions no need for
171:28 - custom parameters and we basically want
171:30 - to cut out all of this and then call
171:35 - cisions after that inside of collisions
171:39 - we have all of the code although we
171:41 - would need to organize things a bit
171:43 - better if I now run all of this
171:45 - everything should still work just fine
171:49 - and that is looking pretty
171:54 - good and yeah I get an overlap I can
171:56 - destroy the meteors quite happy the last
171:59 - thing that I want to cover is that once
172:01 - a player is being hit by a meteor we
172:03 - want to end the game which in practice
172:06 - means we want to set running to fals
172:08 - unfortunately this we cannot do right
172:10 - away so we couldn't simply set running
172:13 - to vaults because we would simply create
172:17 - a local variable inside of this function
172:19 - or in other case if you run the
172:22 - game The Meteors do disappear but the
172:25 - game doesn't end as far as python is
172:27 - concerned we have a running variable
172:29 - inside of this function and then a
172:31 - global running variable and those have
172:33 - nothing to do with each other to fix
172:35 - that we want to set Global
172:39 - running that way those two connect and
172:42 - then if the player collides with meteor
172:44 - the game is simply over although that
172:47 - being said this approach isn't ideal
172:49 - because you want to avoid having global
172:52 - variables for now I think it's fine
172:54 - because we are just getting started but
172:56 - for the next game we are going to
172:57 - approach this slightly differently but
173:00 - anyway with that we have
173:02 - collisions at this point we basically
173:04 - have a game that being said we can make
173:07 - all of this look significantly nicer and
173:10 - for that we are going to display a few
173:12 - more things and also we're going to work
173:15 - on the color so by the end of this
173:16 - section we have a much nicer looking
173:19 - game there are two major things that I
173:21 - want to cover in this bit number one is
173:24 - displaying text which is actually fairly
173:27 - straightforward you first of all have to
173:29 - create a font object which means you
173:33 - have to define a font style and a size
173:35 - for the font after you have that you can
173:38 - simply use this font to render some text
173:40 - and then you get a Surface and that
173:43 - surface you can use like literally any
173:44 - other surface the only difference is
173:46 - that this surface has some text instead
173:48 - of an image but that's literally
173:51 - it besides that we can draw things and
173:55 - for that pame has a draw a module which
173:58 - lets you for example draw rectangles
174:00 - circles lines and pretty much any kind
174:02 - of shape so those are going to be the
174:04 - two major topics that we are going to
174:06 - cover let's start with some text back
174:09 - inside of the game we have to first of
174:12 - all let's do it under import create a
174:15 - font and this we do with pame . font.
174:20 - font make sure that you are spelling the
174:22 - second font with a capital f we will
174:24 - need a font and a font size for the font
174:28 - size we could go with 20 and by default
174:30 - a font can also be none then we are
174:33 - using a default font that looks pretty
174:35 - bad but it gets the job done so with
174:37 - that we have a font after that we can
174:42 - use font. render to create a surface and
174:46 - this we need three arguments the first
174:48 - one is some kind of string with a bit of
174:51 - text whatever you want to render then we
174:53 - have anti-alias for which we will need a
174:56 - Boolean value anti Ling means that we
174:59 - are smoing out the edges of a surface
175:02 - most of the time you want this value to
175:04 - be true or in other words you want to
175:06 - smooth out the edges of any kind of
175:08 - surface just a bit to make them look
175:10 - better the only exception is pixel art
175:12 - fonts if you antias those they are going
175:15 - to look really weird finally we will
175:17 - need a color and we will talk about
175:19 - colors in just a bit as well for now
175:21 - though I simply want to have a
175:22 - red and this is going to give us a text
175:26 - surface or just a surface that happens
175:28 - to have some
175:30 - text and well that is basically it once
175:33 - we have that inside of the game Loop we
175:36 - could run
175:38 - display surface do blit with the text
175:43 - surface and a position let's say 0 and
175:46 - zero and then in the top left you can
175:49 - see some text that part is working
175:51 - pretty well that is literally all you
175:54 - need for this part although if you want
175:56 - to have a custom font which you
175:58 - basically always want to have you would
176:01 - have to import a font file that
176:04 - fortunately we do have because if you
176:06 - look under images there's a file called
176:08 - oxenium bold.ttf
176:11 - ttf is a font file and that we want to
176:14 - import which we are going to do via the
176:17 - join method I want to go to images and
176:20 - then import
176:23 - oxium Das bold.ttf
176:28 - if I now run all of this again and you
176:30 - look at the text it is looking quite a
176:33 - bit nicer which is a good start but the
176:36 - color doesn't really fit now you could
176:39 - go with white here for example and that
176:41 - would help but ideally we want to have
176:43 - more control over our colors and that we
176:47 - can do in P game although I haven't
176:48 - covered it yet so let's do it now to
176:51 - create colors in py game you can
176:53 - basically follow three approaches the
176:56 - first one are the inbuilt color names
176:58 - like a string green red blue yellow so
177:01 - on you do have quite a few inbuilt
177:04 - ones but those are still fairly crude if
177:07 - you want to have more detail you want to
177:09 - have either an RGB tupal or a hexad deal
177:13 - value to start with RGB tbls those are
177:16 - simply a t with three value
177:18 - the first one for red the second one for
177:20 - green and the final one for blue and all
177:23 - of these values have to be between 0 and
177:26 - 255 we have zero being the absence of
177:28 - the color and 255 being the full amount
177:31 - of that color for example if we have 255
177:35 - 0 and Z then we are getting a pure red
177:38 - because we have no green or blue if you
177:41 - have 0255 and 255 you're getting a light
177:44 - blue or in other words you are mixing a
177:46 - full amount of green and a full amount
177:48 - of blue finally if you have 200 for each
177:51 - you're getting a grayish color and
177:54 - that's basically it besides that you
177:56 - have hexadecimal values which always
177:58 - starts with the hashtag symbol then you
178:01 - have two characters for red two
178:02 - characters for green and two characters
178:05 - for blue now the slightly confusing
178:07 - thing about those is that for each value
178:10 - we can specify a value from zero to F or
178:13 - in other words we go from 0 to 9 and
178:15 - then we continue with a b c d e and and
178:18 - F so for example we could have values
178:20 - that look like this where to get the
178:22 - full amount of red we would have F and F
178:25 - this might look weird but in practice it
178:27 - means with a single value you can
178:29 - express a much greater range and that's
178:31 - why we are using this and well that's
178:34 - basically it all you have to understand
178:36 - about hex values is that we are using
178:37 - two values for each color and we always
178:40 - go with red green and blue although in
178:43 - practice you wouldn't do this by hand
178:44 - anyway you would use some kind of
178:46 - computer system to give you values that
178:48 - you need and you simply select the color
178:50 - that you like all you have to do for
178:53 - that is go to Google and then look for a
178:55 - Color Picker Google even has an inbuilt
178:59 - one and there you can select any color
179:01 - that you like and then you're getting a
179:03 - hexa decimal value and an RGB value now
179:07 - there are a few more ways to express a
179:09 - color but we don't really care about
179:10 - those hex values and RGB values is all
179:13 - we really need which means inside of the
179:16 - code inside of white I could specify a
179:19 - tuple with red green and blue for
179:24 - example a value here could be 200 50
179:29 - and 100 and we would get a purple-ish
179:33 - color not ideal yet but we can work on
179:36 - it alternatively what you could be doing
179:39 - instead of a tupo you can specify a
179:41 - string that starts with a hashtag symbol
179:45 - then specify two values for red two
179:47 - values for green and then two values for
179:49 - blue let's say five five that way you'll
179:53 - be getting another color that looks
179:55 - somewhat similar those are the three
179:58 - ways to express color in P game or at
180:01 - least the ways you would be using most
180:02 - of the time besides that if you look at
180:05 - the documentation there is a whole color
180:08 - module and this one gives you a lot more
180:10 - control over the
180:12 - color now this could be incredibly
180:14 - useful but in practice I basically never
180:17 - use it
180:18 - you simply don't need that much control
180:20 - over the color but in some very specific
180:23 - projects this might be useful now in our
180:28 - case I want to change the background
180:30 - color which we are setting here at the
180:34 - moment this is dark gray and this really
180:36 - doesn't feel right instead the color
180:38 - that I want to go for is a hexadecimal
180:40 - value with 3 a for Red 2 e for green and
180:45 - three f for blue if I run all of this
180:48 - now we get something much better
180:52 - looking and everything else still works
180:54 - just fine and for the text I guess
180:58 - instead of this random color we could go
181:01 - with
181:02 - 255 255 and 255 which arguably is a pure
181:07 - white color so not that much
181:10 - gained I suppose just to have something
181:12 - a bit more customized we can set this to
181:16 - 240 so we're not getting a perfect white
181:18 - which usually feels a bit too strong but
181:22 - anyway play around with this at this
181:23 - point you have all the tools to create
181:25 - your own
181:26 - colors what I want to do instead is to
181:29 - display a score via text or in other
181:32 - words this text surface shouldn't
181:35 - display a static word text it should
181:37 - display the time since the start of the
181:39 - game meaning all of this needs to be
181:41 - dynamic and this I want to have in a
181:43 - separate function let's call it Define
181:46 - display under score
181:49 - score no need for custom arguments and
181:52 - in there first of all we want to create
181:55 - a text surface I can cut it out from
181:58 - where we used it earlier and paste it in
182:00 - there antias and the color can stay the
182:03 - same but for the actual text information
182:06 - we want to have a separate value let's
182:09 - call this one the current time and we
182:13 - have already seen how to create this one
182:15 - we simply want py game. time.get X now
182:19 - this is going to return a number but
182:21 - font. render always wants to have a
182:23 - string and if you pass anything else in
182:25 - there you are going to get an error
182:28 - which means in our case we want to use S
182:30 - Str to create a string and then pass the
182:32 - current time in there and well that's
182:35 - basically it now we have a surface so
182:37 - next up we can create a text rectangle
182:41 - via text surface and get F
182:45 - rectangle we want to place the mid
182:49 - bottom for that we will need X and Y X
182:53 - is going to be the window WID divided by
182:56 - two and Y is going to be the window
182:58 - height minus 50 pixels that way we are
183:03 - in the bottom center of the
183:05 - window finally I want to get the display
183:09 - surface and then blit the text surface
183:13 - along with the text
183:15 - rectangle and with that we have the
183:17 - entire logic inside of a single function
183:20 - which feels nice and clean so after we
183:23 - have that in the bottom of the game
183:26 - after we are drawing everything else I
183:29 - don't want to display the text surface
183:32 - instead I want to call display score
183:36 - without any arguments if I now run out
183:38 - of this you can see we have a score in
183:41 - the bottom now I guess the text is a bit
183:44 - small so what we can do about that is
183:47 - increase the font size instead of 20
183:51 - let's go with 40 and that feels much
183:54 - nicer also what you can do you can
183:58 - display the score before or after all of
184:00 - the Sprites if you do it before the
184:03 - player can be on top of the score which
184:06 - I guess is a decent effect I don't know
184:08 - it's fairly subjective just choose
184:10 - whatever you
184:11 - like and if you feel like that the score
184:13 - is increasing too fast you could Flo low
184:17 - divide this for example by
184:20 - 100 then it doesn't feel that strong
184:23 - anymore once again this is fairly
184:26 - subjective just choose what you think
184:27 - looks good there isn't a universal
184:29 - answer for any of this anyway with that
184:33 - we have a score next up then we can work
184:36 - on drawing things and for that we have
184:38 - to look at py game. draw if you look at
184:41 - the documentation there we have draw and
184:44 - there you can for example py. draw.
184:47 - rectangle polygon Circle ellipse Arc
184:50 - line lines AA lines and that's basically
184:53 - it in case you're wondering the
184:55 - difference between line and AA line is
184:57 - that we are anti-aliasing the
184:59 - line which means an AA line is going to
185:02 - look a little bit less pixelated than a
185:04 - regular line and to use all of that
185:07 - let's do a couple of experiments so
185:09 - after we are drawing everything else I
185:11 - want to have a draw test for that we can
185:16 - use pame do draw and for now let's start
185:19 - with line for which we will need a
185:22 - couple of arguments the first one is the
185:24 - surface to draw on in my case this will
185:26 - be the display surface then we will need
185:28 - a color since this point doesn't matter
185:31 - too much let's go with red then we will
185:33 - need a start position and an end
185:35 - position for the start position for now
185:38 - let's go with zero and zero and the end
185:40 - position could be 500 and
185:43 - 600 after that you can also set the line
185:46 - WID let's go with 10
185:48 - and now if I run out of this we have a
185:51 - random line on top of the game that's
185:53 - kind of all we have to do in here and
185:56 - you can see this thing is quite
185:58 - pixelated might be hard to see on
186:00 - YouTube but if you run this on your own
186:02 - you can definitely see it if you don't
186:04 - like that look you can change this to a
186:06 - a line that way you would be getting rid
186:09 - of the pixels although a a line doesn't
186:11 - have a line withd so this we would have
186:13 - to get rid of if I now run this again
186:16 - you get a line that is looking a bit
186:18 - less pixelated but since you can Define
186:20 - the WID it's not terribly useful anyway
186:24 - what is much more interesting and let's
186:25 - go with line so we can set a line wi of
186:30 - 10 instead of having a static point you
186:33 - could also use py game. mouse. getet and
186:38 - this should be get PA actually if I now
186:41 - run this again and I can show my mouse
186:43 - you can see that we can move both the
186:45 - ship and this line works just fine I
186:49 - suppose what we could also do is layer
186:53 - do rect do
186:55 - Center and now we get a line to the
186:58 - center of the ship that's kind of all
187:00 - you need for the draw method besides
187:03 - line two things that you see all the
187:06 - time are pam. draw. rectangle and pam.
187:10 - draw.
187:11 - ellipse both work basically in the same
187:14 - way actually let's start with the
187:18 - rectangle for this one we will always
187:20 - need a Target surface which in our case
187:22 - will always be the display surface then
187:25 - we need a color let's keep on going with
187:27 - red and then we need a rectangle in this
187:31 - case we can use player. rectangle if you
187:34 - simply run it like this you are drawing
187:37 - a rectangle on top of the player so this
187:40 - part is working fairly well and if you
187:42 - change rectangle to ellipse then pame is
187:46 - going to draw an ellipse in this
187:48 - rectangular area so those two methods
187:50 - are basically working in the same way
187:52 - although for now I do want to work with
187:53 - a rectangle just a bit more because you
187:57 - can specify a few more arguments
187:59 - actually quite a few the first one is
188:01 - the whift by default it's zero but if
188:04 - you set it to anything higher let's say
188:06 - 10 then you are only drawing the border
188:09 - and you don't fill it anymore also if
188:12 - you specify another argument you would
188:14 - set a border radius let's go with 10 for
188:16 - this one as well
188:18 - and then you have rounded
188:20 - Corners I think you get the
188:23 - idea drawing a p game really isn't that
188:26 - complicated which means we don't need
188:28 - this draw test anymore and instead we
188:31 - can do an exercise I would you guys to
188:33 - draw a box around the score text also
188:36 - make sure that you adding rounded
188:37 - corners and for an extra challenge add
188:40 - padding between a text and the rectangle
188:43 - for that you would have to look at the
188:45 - documentation this one is a bit beyond
188:47 - what we have done so far so don't worry
188:49 - if you can't do this extra part but
188:52 - anyway pause the video now and see how
188:53 - far you
188:56 - get back in the code I want to work
188:59 - inside of display score and there we
189:02 - already have a text rectangle this is
189:05 - what we want to draw via py game. draw.
189:09 - rectangle we want to draw on the display
189:13 - surface or the color we want to go with
189:16 - the same color as the text so 240 240
189:19 - and 240 after that we will need a
189:22 - rectangle which is going to be our text
189:26 - rectangle then we will need some kind of
189:28 - Border width let's go with five for now
189:31 - and we will need a border radius I guess
189:33 - 10 could be going okay let's try out of
189:36 - that and we are getting well we getting
189:39 - something this doesn't look ideal but at
189:40 - the very least we have a border around
189:42 - the score but this we have to refine so
189:46 - how can we add padding between a text
189:47 - and the border and unfortunately this we
189:50 - cannot do inside of the draw method
189:53 - however what we can do is mess with the
189:55 - rectangle for that I want to look at the
189:58 - documentation and then the rectangle in
190:01 - there you have a move method and you
190:04 - have an inflate
190:06 - method inflate simply grows or shrinks a
190:10 - rectangle and you can specify an X and A
190:13 - Y value although a better name here
190:15 - would be horizontal and vertical size
190:17 - changes or in other words if this is our
190:21 - rectangle the inflate method would keep
190:24 - the same center point but then expand it
190:27 - in the horizontal or the vertical axis
190:30 - and if you had negative numbers you are
190:32 - shrinking the rectangle that's all you
190:34 - really do which means when we are
190:36 - drawing the rectangle we don't want to
190:39 - have the text rectangle itself we want
190:41 - to have text rectangle do inflate and
190:44 - for the numbers let's say 20 and 30 if I
190:48 - now run this this is already looking
190:51 - quite a bit nicer so definitely an
190:54 - improvement the issue is though we have
190:57 - some text that has a bounding box like
191:00 - this with the actual text being roughly
191:03 - here the reason why we have this bottom
191:06 - stuff is because some letters go quite a
191:08 - bit further down like a p for example
191:10 - but for numbers this isn't really going
191:12 - to be an issue which means in our case
191:15 - we want to move the entire rectangle up
191:18 - by just a bit and that we can also do so
191:22 - essentially what's happening at this
191:23 - point we have a text rectangle and then
191:26 - we are calling inflate and this is going
191:28 - to return another rectangle on which we
191:31 - can call another method which is the
191:33 - move method which is going to return
191:35 - another rectangle that has been moved by
191:37 - an X and A Y amount now X in our case is
191:40 - going to be zero we only want to move up
191:43 - by a little bit let's say -10
191:47 - if I run this again and that is
191:49 - definitely looking better I think this
191:51 - value should be a bit lower and the
191:55 - inflate for y should also only be 20 and
191:58 - that is looking much
192:01 - nicer I think the vertical inflate could
192:05 - still be smaller let's say 16 let's try
192:08 - it again and well we are heading in the
192:11 - right direction but this is something
192:13 - you have to play around with I think 10
192:16 - is actually best
192:17 - yeah that looks like a pretty reasonable
192:20 - amount once again the numbers here are
192:23 - fairly subjective so play around with
192:25 - this and choose whatever you think looks
192:27 - best with that we can draw text we can
192:29 - choose custom colors and we can draw
192:31 - random shapes things that are really
192:33 - important to make our game look better
192:36 - all right in this part we're going to
192:38 - finish up the space shooter and there
192:40 - are a couple of things I want to work on
192:43 - the easiest one is going to be sound I
192:46 - don't think I have to explain this one
192:48 - besides that we also want to transform
192:49 - the meteor surfaces and make them rotate
192:52 - after that we're going to add better
192:54 - collisions by using a mask which is a
192:57 - slightly more advanced Topic in P game
192:59 - and finally we're going to add an
193:01 - explosion animation if you add all of
193:03 - these things you are making the game
193:05 - look quite a bit nicer and let's go
193:07 - through the topics one by one the first
193:09 - one that I want to start with is using a
193:12 - mask first question here is what is a
193:15 - mask and well it's basically an object
193:19 - that checks which pixels of a surface
193:21 - are visible invisible pixels will be
193:24 - black and visible pixels will become
193:26 - white or in other words our player
193:28 - surface would become something like this
193:31 - which in itself doesn't seem terribly
193:34 - impressive but via this system you can
193:36 - do two things number one you can get
193:39 - Pixel Perfect collisions because now we
193:41 - know which pixels have actual content
193:44 - and besides that you can create
193:46 - silhouettes
193:47 - which is super useful to make the play a
193:49 - flash for example or you could add an
193:50 - outline to a surface and for more detail
193:53 - on all of this you want to look at the
193:55 - documentation under a mask in there you
193:59 - can get all of the methods in quite a
194:01 - bit more detail and the most important
194:04 - method that you have to be aware of in
194:05 - the beginning is py game. M.R surface
194:09 - that way you are creating a mask from a
194:13 - surface this is what you're using most
194:15 - of the time to create a mask
194:17 - although it's not the only way to
194:20 - experiment with all of this let's have a
194:22 - look at our player class at the moment
194:25 - we have a single surface in here and
194:27 - that is self. image which is something
194:29 - that we can use and let me add a section
194:33 - at the bottom for the mask I want to
194:36 - create a mask which I can do bya py
194:39 - game. mask. from underscore surface and
194:43 - in there we have to add a surface which
194:45 - in this case will be self.
194:48 - image and that by itself doesn't do
194:50 - anything if I run the game nothing is
194:53 - going to change however I can visualize
194:56 - this mask by turning it back into a
194:58 - surface let's call this one the mask
195:01 - surface and this we get with mask and
195:04 - then dot to surface that way we have
195:07 - turned a mask back into a surface and
195:09 - that we can use to overwrite self. image
195:13 - I want to set this to the mask surface
195:16 - and if I now run of this you can see
195:18 - what's going on we have turned all
195:20 - visible pixels white and all invisible
195:22 - ones black and that is what a Mas does
195:26 - and the way you are using this system
195:28 - most of the time is with collisions
195:30 - because right now our Collision object
195:33 - is a rectangle meaning if this is the
195:37 - outline of the ship very roughly then
195:41 - the actual Collision shape would look
195:43 - like this that is the rectangle that we
195:46 - have created and on top of that if we
195:49 - have a
195:50 - meteor while the meteor itself is round
195:53 - the Collision shape of the meteor is
195:55 - also a rectangle which means if you have
195:58 - a meteor in this position we still get a
196:01 - collision even though visually to the
196:03 - player there was no Collision
196:05 - whatsoever which for a game can be very
196:08 - frustrating so this is something we want
196:09 - to avoid to avoid that we want to know
196:12 - which pixels of a surface are visible
196:14 - and that we do via a mask
196:17 - that is the most common way of using a
196:19 - mask besides that what you could also do
196:23 - on this mask surface if you were to hide
196:25 - the black pixels then you would have a
196:27 - flash effect and you can hide pixels of
196:30 - one color on the surface quite easily
196:33 - for that you want to get the surface in
196:35 - this case M surface and then set a color
196:39 - key setting a color key means that
196:41 - you're making all of the pixels of one
196:43 - color invisible in our case this should
196:47 - be the black pixels and if I now run all
196:50 - of this again we have the ship in
196:53 - perfect white this could be useful if
196:56 - you want to make an object flash after
196:58 - it got hit which is something I am going
197:00 - to cover later but for now we don't
197:02 - really care about
197:03 - it instead what we want to do is to get
197:07 - rid of all of the surfaces and then turn
197:11 - the mask into an attribute meaning this
197:13 - should be self. mask and this self do
197:16 - mask is another part of a Sprite class
197:20 - but if you add it you can Implement mask
197:23 - Collision fairly easily although for
197:25 - that to work we have to add a mask for
197:28 - all of the Sprites which ultimately is
197:31 - fairly easy you will always need the
197:33 - same line let me copy it actually for
197:35 - the star we don't need that because
197:37 - they're not supposed to collide with
197:38 - anything but for the laser we will need
197:41 - self. mask and for the meteors we will
197:44 - need another self. mask
197:48 - and that way all of the collidable
197:50 - objects have a mask so how can we use it
197:53 - inside of the collisions for that let's
197:57 - have a look at the documentation we want
197:59 - to look at the Sprites if you scroll
198:01 - down there a bit we have once again all
198:03 - of the Collision methods the one that we
198:06 - are already using is called Sprite
198:08 - Collide and if you look a bit further
198:10 - down we also have Collide mask and you
198:13 - could use both of them although I would
198:16 - recommend and Sprite Collide if you
198:18 - click on that so far we have used Sprite
198:21 - group and do kill but there is a fourth
198:23 - argument cided it basically means that
198:26 - we can specify in a bit more detail what
198:28 - kind of collision we want and in there
198:32 - we can look for collide mask you could
198:34 - also look for example for Circle or some
198:37 - kind of ratio but those aren't too
198:39 - common besides that if you go a bit
198:42 - further down we have Collide mask and in
198:45 - there we're calling pame dos sprite. CID
198:48 - mask and then add in two Sprites the
198:51 - return value is going to be an X and A Y
198:53 - position which you can read more about
198:55 - here although this method we don't
198:57 - actually need because back in the code
199:00 - we can simply expand Sprite Collide by
199:02 - just a bit for that I want to add a
199:05 - fourth argument pygame dos sprite. cite
199:10 - mask and that is literally it if I now
199:13 - run the code and this is going to be
199:15 - quite hard to demonstrate but for
199:17 - example there you can see I can dodge
199:19 - the meteors much
199:22 - better and if we collide with them it is
199:25 - a Pixel Perfect
199:27 - collision and the same thing you could
199:28 - also do for the lasers although for them
199:30 - I don't think it's very necessary
199:33 - because lasers are essentially
199:34 - rectangular so not much Point adding a
199:37 - mask and one thing that you generally
199:39 - want to keep in mind is that using a
199:40 - mask is very very Hardware intensive if
199:44 - you do it for every Collision you are
199:46 - going to than your performance pretty
199:48 - hard and actually while I'm recording
199:50 - this I realized that when we are calling
199:53 - py game. sprite. CID mask we don't
199:55 - actually have to create a mask attribute
199:58 - inside of the class because if you read
200:00 - the documentation then you can see that
200:03 - if a Sprite has a mask attribute we are
200:05 - going to use that one otherwise we are
200:07 - going to create a mask from the image
200:09 - automatically and since we want to use
200:12 - the image anyway we don't need this line
200:15 - for any of the Sprite class
200:17 - sorry about that fairly minor mistake
200:20 - although I'm going to leave it in there
200:21 - for the player just so that you can copy
200:23 - it anyway with that we have a mask
200:27 - something slightly more advanced in pame
200:29 - and if you want to know more about it
200:31 - check out this dedicated video in there
200:33 - I cover masks in a lot more detail next
200:36 - up I want to transform surfaces or in
200:39 - other words I want to use pame do
200:41 - transform to change surfaces this is
200:44 - just another module in pame and this one
200:46 - can for for example scale flip rotate
200:48 - blur gray scale invert and quite a few
200:50 - more things to a surface once again in
200:53 - the documentation if you look at
200:55 - transform you can find all of the
200:57 - options a really simple one would be
201:00 - rotate in there we have to call py.
201:03 - transform. rotate pass in a surface and
201:06 - an angle and then the return value is
201:09 - going to be another surface and the same
201:11 - logic applies to basically all of them
201:14 - you pretty much always call py game.
201:16 - transform and a method and pass in a
201:17 - surface with a couple of extra Arguments
201:20 - for that for example when we are
201:23 - creating the player we can once again
201:25 - mess with the image and let me add
201:28 - another section
201:30 - transform test we could simply overwrite
201:34 - self. image via pygame do transform Dot
201:39 - and then one of these
201:41 - methods the one I've already talked
201:43 - about is rotate and in there we first of
201:46 - all need a surface which in this case is
201:48 - going to be self. image and then we need
201:51 - an angle let's go of 90° and now if I
201:54 - run all of this the ship is rotated
201:57 - 90° besides that another common method
202:00 - would be scale or scale to X scale tox
202:03 - is the simpler one and there we simply
202:05 - want to have a surface self. image and
202:08 - with that we have the player being twice
202:10 - as large if you read up on the other
202:14 - methods you can do basically anything
202:17 - I guess what you can also do is use
202:19 - grayscale that way our ship is going to
202:21 - be black and white pam. transform
202:24 - doesn't fundamentally get that
202:26 - complicated there's just one thing that
202:28 - you really want to keep in mind
202:30 - transforming a surface can reduce the
202:32 - quality this doesn't apply to all of the
202:34 - transform methods for example if you use
202:37 - grayscale this doesn't really have an
202:38 - effect but if you rotate something too
202:41 - often then you are going to notice a
202:43 - loss in quality but let's go through it
202:45 - step by step if you rotate a surface
202:47 - once you are going to lose a very minor
202:50 - amount of quality this is so minor that
202:53 - it's never going to be visible however
202:55 - if you rotate a surface a thousand times
202:57 - per second then the quality is going to
202:59 - Decay very fast and very noticeably and
203:03 - let's do an example for that let's say I
203:05 - want to rotate the player surface
203:07 - continuously or in other words inside of
203:10 - the update method I want to add another
203:13 - section continuous row rotation I want
203:18 - to get self. image and then assign py
203:20 - game.
203:22 - transform. rotate then get self. image
203:26 - and then a rotation number for
203:31 - that under transform test I want to have
203:34 - self. rotation which by default is going
203:37 - to be zero but before we are applying
203:40 - the rotation I want to increase self.
203:43 - Rotation by a small amount let's say 10
203:47 - and don't forget to multiply it with
203:48 - Delta time if I now insert self.
203:51 - rotation into py. rotate and Run the
203:54 - game you can see that the game gets
203:57 - really weird and in fact the frame rate
204:00 - crashes as well so this isn't ideal if I
204:04 - change the rotation speed to one you can
204:07 - see a bit better what's going on so
204:10 - there you can see the ship simply
204:11 - disappeared and the basic issue is for
204:14 - all of this if this is the full rotation
204:18 - where we start at zero and then go in
204:23 - 360° at the moment we are always jumping
204:26 - by a very small amount and then use the
204:28 - new Surface to jump again for another
204:32 - rotation and we keep on doing that
204:34 - forever until the game crashes which
204:38 - admittedly isn't too long that is
204:40 - because every time we are doing this
204:43 - kind of rotation we are lowering the
204:45 - quality and we are changing the surface
204:47 - a bit and if you're doing this too often
204:50 - you are getting some really weird
204:52 - Behavior which you absolutely want to
204:55 - avoid and the way to avoid this is to
204:58 - only rotate a surface once which kind of
205:01 - sounds weird but basically what we are
205:03 - going to do we are going to always keep
205:06 - the original surface and from there Jump
205:10 - by a certain amount and then display
205:12 - this new Surface however on the next
205:14 - frame we are once again starting on on
205:16 - the original surface and then simply
205:19 - rotate a little bit further and then use
205:22 - the new
205:23 - Surface since we always start from the
205:25 - original surface we only ever have a
205:27 - single rotation which is not going to
205:30 - affect the quality or at least not in a
205:32 - noticeable way to achieve something like
205:35 - that we want to store self. image in
205:38 - some other attribute let's call itself.
205:41 - original
205:43 - surface this is going to be pame image.
205:48 - load the thing we have already done and
205:50 - then for the image I want to have self.
205:53 - original Surface after we have that when
205:57 - we are assigning a new image we are not
206:00 - using the image itself instead we are
206:02 - using self. original surface on top of
206:05 - that let me change the rotation speed to
206:07 - something like 20 if I now run the code
206:10 - you can see that we have a rotation and
206:13 - we are getting some loss in quality so
206:16 - it is definitely visible especially on
206:18 - this surface now depending on what kind
206:20 - of art you have this will be more or
206:22 - less visible this also depends on the
206:25 - speed if I change this to
206:27 - 100 then it's already looking quite a
206:30 - bit better although this still isn't
206:32 - amazing you can see way too many pixels
206:35 - and to fix all of that we have to look
206:37 - at the documentation in there I want to
206:40 - look at transform and then have a look
206:43 - at the rotation methods there are two
206:45 - that we can use use pam. transform.
206:48 - rotate is what we have already used this
206:50 - one rotates an image besides that we
206:53 - have pam. transform. Roto Zoom this one
206:57 - does two things it scales and rotates an
207:00 - image at the same time on top of that it
207:04 - applies a filter when it's doing that
207:06 - which effectively means it Smooths out
207:08 - the entire thing and gets rid of pixels
207:12 - which for most Graphics is what you want
207:13 - to do it looks much better most of the
207:16 - time which means back inside of pame I
207:19 - want to py game. transform. Roto Zoom
207:24 - still use the original surface and the
207:26 - rotation but then for the scale we have
207:29 - to add a one in here to keep this value
207:32 - constant if I now run all of this the
207:36 - ship is looking significantly better so
207:39 - this is what you would want to use most
207:40 - of the time but it's not a universal
207:44 - thing very often rotate is what you
207:46 - actually want this depends very much on
207:48 - your game and you should experiment to
207:50 - see what works best there simply isn't
207:53 - the universal answer but for the ship I
207:56 - don't actually want a rotation so let me
207:58 - get rid of all of this stuff we don't
208:00 - want to have any
208:02 - transform and also we want to keep the
208:04 - original image with the surface that way
208:08 - that is looking pretty good what we
208:10 - actually want to do is to rotate the
208:13 - meteors that part is going to be your
208:16 - your exercise I want you to make the
208:18 - meteors rotate and also give them a
208:20 - random rotation speed pause the video
208:23 - now and see how far you
208:27 - get when we are adding this surface we
208:31 - want to store it under self. original
208:34 - surface and this can get the
208:36 - surface and you don't even have to
208:38 - change self. image since we're getting
208:40 - the same surface for both of them other
208:42 - than that I want to have self. rotation
208:45 - under score speed which can be a random
208:48 - integer let's say for now between 20 and
208:52 - 50 after that when we are updating all
208:56 - of this I want to overwrite self. image
209:00 - with high game do transform dot rotate
209:05 - or Roto zoom and for this one I want to
209:08 - use Roto Zoom to have a bit better
209:11 - quality for the surface we want to have
209:13 - self. original surface and then we going
209:17 - to need an angle which at the moment we
209:19 - don't have for that I want to have self.
209:22 - rotation which by default is going to be
209:25 - zero and then before we are updating
209:27 - self. image self.
209:30 - rotation plus equal self. rotation speed
209:35 - multiplied with Delta time then we can
209:39 - pass self. rotation in there put a scale
209:42 - we want to keep one if I now run all of
209:45 - this this we have the meteors rotating
209:50 - so that's not looking
209:51 - terrible I guess what we could be doing
209:53 - is increase the speed this could maybe
209:55 - be 40 to 80 let's try it
210:00 - again and yeah that is looking a bit
210:03 - better but we're getting some weird
210:05 - wobbly Behavior if you keep on looking
210:07 - at the meteors they do move a bit
210:11 - weird that is because we are changing
210:13 - the image but the rectangle always stays
210:16 - the same which shouldn't be the case
210:18 - because for this image we now have New
210:21 - Dimensions we want to also overwrite
210:24 - self. rectangle and assign it to self.
210:27 - image. getet F rectangle and set the
210:30 - center to self. re. Center or in other
210:35 - words we are creating a new rectangle
210:38 - with the same Center position as the
210:39 - last rectangle that way I can run out of
210:42 - this again the meteors are moving much
210:45 - more naturally which feels quite a bit
210:49 - nicer perfect with that we have the
210:52 - meteor rotation and that we can improve
210:55 - even more with an animated explosion for
210:58 - that we have to go through a couple of
210:59 - steps first of all we need to import a
211:02 - whole bunch of explosion images after
211:05 - that we have to create an explosion
211:07 - class and whenever a laser hits a meteor
211:10 - we want to create one instance of that
211:12 - class this is then going to play an
211:15 - animation and after the animation is
211:16 - done the class disappears or rather the
211:19 - instance of the class disappears if you
211:22 - want to try this on your own it could
211:24 - also be a really good exercise although
211:26 - it's getting a bit more advanced what I
211:29 - want to do is to create a new class
211:32 - animated
211:34 - explosion which is also going to be a
211:36 - pame Dos sprite. Sprite for that we
211:40 - going to need a thunder init method and
211:43 - for that we want to have a list of
211:46 - surfaces I usually call that frames I
211:49 - think that name makes the most sense but
211:51 - it's basically a list of surfaces
211:53 - besides that we want to have a position
211:56 - and we will need the groups super do
211:59 - Dunder init with the groups and then we
212:03 - will need self. image and self.
212:07 - rectangle now the rectangle is going to
212:09 - be fairly simple self. image doget F
212:12 - rectangle and we want to place this
212:14 - Center at the position but then we have
212:17 - to assign a surface to self. image and
212:20 - for that basically we want to get frames
212:22 - and pick the first item and I think I am
212:25 - jumping ahead just a bit so let's have a
212:27 - look at the project folder there we have
212:30 - images and in there we have explosion
212:33 - which is simply a folder full of images
212:36 - we want to import all of them and then
212:38 - play them in sequence after the sequence
212:40 - is done we are going to destroy the
212:43 - animated explosion class for that though
212:47 - we have to import all of these frames
212:49 - and that's going to happen in our import
212:52 - section I want to store all of the
212:54 - explosion uncore frames in a single list
213:00 - and that we can do via list
213:01 - comprehension or in other words when
213:04 - you're looking at the folder we know the
213:06 - file name starts at zero and then goes
213:08 - all the way to 20 and we always working
213:11 - with a PNG file meaning we can do for I
213:15 - in r
213:17 - 21 that way we going up to 21 but not
213:20 - including it and this should be I for I
213:24 - in range 20 if I do this so far and
213:27 - print the explosion frames then we're
213:30 - getting a list with the integers from 0
213:32 - to 20 that is a good start but not
213:35 - exactly what I want because what I
213:37 - actually want is to use the join method
213:40 - we're going to images then we're going
213:42 - to explosion and in there we want to
213:45 - have all of the f names or in other
213:47 - words images explosion and then an F
213:50 - string where we are using I do PNG if I
213:55 - now run all of this again we are getting
213:58 - a list with a whole bunch of
214:01 - paths and that we can use inside of P
214:05 - game. image. load and also don't forget
214:10 - to call convertor
214:13 - Alpha the line is getting a bit longer
214:15 - ER but I think it's still manageable
214:18 - fundamentally we are not really doing
214:20 - anything complicated we are simply
214:22 - running this py game. image. load inside
214:24 - of a for Loop let's try off this again
214:28 - and we are getting a list of surfaces
214:31 - that is perfect so with that we can get
214:35 - one image which is going to be the first
214:38 - item inside of
214:39 - frames next up when we have a collision
214:43 - between the lasers and the meteors
214:46 - besides killing the laser I also want to
214:48 - create one instance of the
214:51 - animated
214:53 - explosion for which we are going to need
214:56 - the explosion
214:58 - frames the position is going to be the
215:00 - top of the laser I.E laser. w. midtop
215:05 - and then groups is simply going to be
215:07 - all
215:08 - Sprites if I now run all of this and I
215:11 - can shoot at a meteor we're getting the
215:14 - first frame of the explosion doesn't do
215:17 - anything at the moment but we are
215:19 - getting
215:20 - there so to create an animation we
215:23 - basically want to change self. image and
215:26 - always assign a different index from
215:28 - self. frames and that needs to run
215:31 - inside of the update method and there we
215:34 - will need self and data time just as
215:36 - before we basically want to do something
215:38 - like self. image is going to be the
215:44 - frames
215:46 - and then some kind of index and this
215:48 - index has to increase over
215:51 - time for that first of all we have to
215:54 - store all of the frames inside of an
215:56 - attribute that way we can access them in
215:59 - the update method besides that I also
216:01 - want to have self. frame index which by
216:05 - default is going to be zero when we
216:08 - assigning self. image I want to get
216:10 - self. frames although you could also
216:12 - just use frames in there and then self.
216:15 - frame Index this we want to do when we
216:18 - are creating one instance of the class
216:20 - and in the update method but then before
216:23 - we are doing that inside of update we
216:25 - want to increase self. frame index by a
216:28 - certain amount let's say five and also
216:32 - this needs to be multiplied with Delta
216:34 - time now this is not going to work for
216:36 - two reasons number one is that when we
216:40 - are using indexing we always need an
216:42 - integer which by default is going to be
216:45 - the case but remember Delta time is
216:47 - something like
216:48 - 0.0
216:50 - something if we multiply that with the
216:53 - speed we are going to get a floating
216:55 - point value which is not going to work
216:57 - with indexing which means when we are
217:00 - assigning the frame index we want to
217:02 - convert this number to an integer and
217:05 - that should actually work already at
217:06 - least for a bit if I now shoot at a
217:08 - meteor you are getting an explosion but
217:11 - then the game Should Crash the issue we
217:13 - have is that the list index is out of
217:16 - range or in other words this Frame index
217:19 - continues indefinitely but we only have
217:21 - a finite number of surfaces inside of
217:23 - self. frames to fix that you want to use
217:27 - the modulus operator along with the
217:29 - length of self. frams also I want to
217:33 - increase the animation speed to make
217:35 - this look a bit better if I now shoot at
217:38 - a
217:39 - meteor you can see we have the animation
217:42 - playing forever now in case you don't
217:45 - know what modulus does it basically
217:47 - gives you the remainder of any division
217:50 - operation if you had 10 modulus 3 you
217:54 - would get a one because the next clean
217:57 - division that you could be doing is 9 /
218:00 - 3 this one would get you a three but
218:03 - then we have a remainder of one now in
218:06 - our case the length of self. frames is
218:09 - 20 and self. frame index can grow
218:12 - indefinitely and if you did 10
218:16 - modulus 20 you would get
218:20 - 10 however if you did something like
218:24 - 25
218:26 - modulus 20 you would have a remainder of
218:30 - five and that is exactly what we want
218:33 - because we have gotten to 25 and this
218:35 - would not be in the original frames
218:38 - anymore instead what we want is the
218:40 - fifth frame or more specifically we
218:42 - simply want to get rid of the 20 in the
218:45 - beginning and keep the five
218:47 - understanding modulus and python is
218:48 - incredibly important so if you don't
218:51 - understand the logic here definitely do
218:53 - some research that being said we don't
218:55 - actually want to use it because if I run
218:58 - the game again having the animation
219:00 - playing forever would look a bit weird
219:03 - instead I want to check if self. frame
219:06 - index is smaller than the length of
219:11 - self.
219:13 - rames only if that is the case do I want
219:15 - to assign a new self. image and for that
219:18 - we don't need modulus anymore if that is
219:20 - not the case else meaning frame index is
219:23 - greater than the length of the frames or
219:25 - in other words the animation has
219:26 - finished then we want to
219:29 - discard the
219:30 - Sprite with that I can shoot at a meteor
219:35 - let's hope there's going to be one
219:36 - nearby and we get one
219:39 - animation and then the explosion
219:41 - disappears perfect and with that you
219:45 - have a basic animation logic that's all
219:47 - there is to it all you need for a basic
219:50 - animation is that you are going to
219:52 - overwrite self. image you could either
219:55 - play it once or continuously and that's
219:57 - really all there is to animations in P
219:59 - game with that we can cover the final
220:02 - part playing sounds this is actually
220:04 - fairly simple we have to first of all
220:07 - create a sound object that we do with py
220:10 - game. mixer. sound along with a file
220:12 - path after we have that we can play stop
220:16 - rewind set volume and so on anything
220:19 - that you would want to do with a music
220:20 - file and by the way if you look at the
220:23 - pame documentation there we have music
220:26 - and we have mixer although this is a bit
220:29 - deceptive if you click on music you are
220:32 - also getting to a subpart of mixer so
220:35 - ultimately just go to mixer right away
220:37 - then you have the main module and in
220:39 - there if you go down just a bit we
220:43 - should be getting to
220:45 - pame mixer. sound that is the main
220:48 - module that you are using for sound and
220:50 - you can create it in a whole bunch of
220:52 - different ways but basically you always
220:55 - either insert a file name or some kind
220:57 - of data to get a sound file and then you
221:00 - can use sound. playay sound. stop Fade
221:02 - Out set volume and so on which means
221:06 - back inside of the code we first of all
221:09 - have to import a couple of files and for
221:12 - that if you look at the folder we have
221:14 - four files that we want to
221:16 - import let's start with the laser sound
221:19 - that we want to store in a variable for
221:22 - that I need py game. mixer. sound then
221:25 - use the join method to go to audio and
221:29 - then I want to import laser. wav and
221:33 - that is it we now have a laser
221:36 - sound to play it we want to go to the
221:41 - place where we are creating one instance
221:43 - of a laser that happens in here I want
221:46 - to get the laser sound and then play it
221:50 - if I now play the game I can shoot the
221:52 - laser and we're getting a laser sound if
221:56 - you find this laser sound too loud when
221:59 - you are importing
222:01 - it you can get the laser sound and then
222:04 - the method set volume where we have to
222:07 - add a floating point value which goes
222:09 - from 0 to 1 with one being the full
222:12 - amount if you add a 0.5 in there and run
222:15 - this again the laser is now 50% as loud
222:20 - and that is basically it for sounds so
222:22 - to finish the game we simply have to
222:24 - import a few more sound
222:27 - files for that I want to copy the laser
222:31 - sound and get first of all the explosion
222:35 - sound which we getting from explosion.
222:39 - wav then I can duplicate this line one
222:41 - more time and we want to have a damage
222:44 - sound
222:45 - which is going to be damage do
222:49 - OG finally we have a game uncore
222:54 - music for which we will need py game.
222:57 - mixer. sound one more time the file is
223:00 - called gamore music.
223:03 - wav with that we have all of the sound
223:06 - files we just have to figure out when to
223:08 - play them the explosion sound I want to
223:12 - play when we have a collision between a
223:14 - laser and a meteor in here explosion
223:19 - sound. playay let's try and there we go
223:25 - this is working pretty
223:27 - well now alternatively you could also
223:31 - run explosion sound when we are
223:35 - creating an animated explosion inside of
223:39 - the thunder in it method and there we
223:41 - would get the same result
223:47 - just choose whatever you think is better
223:49 - it doesn't really matter both work just
223:51 - fine besides that we have the damage
223:54 - sound that we want to play whenever the
223:56 - player gets hit which happens in here
223:59 - although for this game once the player
224:01 - is hit the game is over anyway so we
224:03 - don't actually need a damage sound let's
224:08 - remove it finally we have game music
224:11 - this is the background music which we
224:13 - want to play right away
224:16 - I guess we can do it right after game
224:19 - music. although before we are doing that
224:22 - I think for the game music we want to
224:24 - set the volume to something lower let's
224:26 - say
224:27 - 0.4 let's
224:30 - [Music]
224:37 - try cool that is working reasonably well
224:41 - now before we are finishing the one last
224:44 - thing that I do want want to cover is
224:46 - when you are playing a music file you
224:48 - can specify the amount of Loops if you
224:52 - add a five in here you playing the music
224:54 - file five
224:56 - times and if you had a negative one in
224:59 - there you are playing it
225:01 - indefinitely which is what we want for
225:03 - the game music we have finished our
225:05 - first game and at this point you are
225:07 - aware of all of the main concepts of P
225:10 - game although there are quite a few more
225:12 - specific Concepts that we are going to
225:14 - cover for example for the next game
225:16 - we're going to add a camera and actual
225:18 - collisions along with a few more extra
225:21 - things that actually make a
225:29 - game all righty the second game in the
225:31 - series is going to be a vampire Survivor
225:33 - style topown shooter this project is
225:36 - going to be much closer to an actual
225:38 - game and there are a couple of key
225:41 - Concepts that I want to cover most
225:43 - importantly we have collisions and a
225:46 - camera those are essential parts that
225:48 - you basically always need besides that
225:51 - we will also cover creating levels in an
225:54 - editor in which we can move things
225:56 - around super easily that is going to
225:59 - make it much easier to build actual
226:01 - games finally we are going to work on
226:04 - proper animation control or in other
226:07 - words we going to take the basic
226:08 - animation logic and make it more
226:10 - sophisticated that way for example we
226:12 - can animate the player moving in
226:14 - different direction directions you will
226:16 - see later what I am talking about first
226:18 - of all though we have to set up the
226:20 - basics for that let's start with the
226:22 - project folder here we go there are four
226:25 - subfolders inside of the project folder
226:28 - audio is super simple this one is just a
226:31 - couple of audio files then we have the
226:34 - code folder and in there we have main.py
226:36 - and
226:37 - settings.py they don't do very much and
226:40 - we will have a look at them in just a
226:42 - second besides that we have data and
226:44 - images and those two folders are quite a
226:47 - bit more extensive inside of images for
226:49 - example we have the gun we have the
226:52 - enemies and those are always animations
226:55 - meaning we have multiple images that we
226:57 - have to import and also inside of the
227:00 - player we have the different states and
227:03 - then inside of each stage we have an
227:05 - animation of the player walking in that
227:07 - direction besides that we have a data
227:10 - folder and this one you don't really
227:12 - have to understand at the moment but in
227:15 - there we have Graphics maps and a tile
227:17 - set the map or world. TMX is what
227:20 - actually contains the level I will talk
227:22 - about that in much more detail later for
227:25 - now we have to create a basic game and
227:28 - what I want to have is a very basic
227:29 - setup in which the player can move
227:31 - around or in other words I want to have
227:33 - a spread class with one image for the
227:36 - player this one can be static for now
227:38 - and then the ability to move
227:40 - around which we're doing via input and a
227:43 - move method and at at this point this
227:45 - shouldn't be impossible meaning this
227:47 - could be an exercise right away I want
227:50 - you guys to set up the basic game which
227:53 - means I want you guys to create a player
227:55 - class with an imported player image that
227:56 - can walk around and this should be a
227:59 - Sprite also for the overall logic of the
228:02 - game contain all of this inside of a
228:04 - game class that way we can avoid Global
228:08 - variables also all of this should be
228:10 - inside of main.py I should actually
228:13 - demonstrate here we are in the code and
228:15 - there is main. pi doesn't do anything at
228:17 - the moment and inside of settings.py we
228:20 - are importing pame and we have a window
228:22 - whift and a window height use all of
228:24 - that inside of main.py to create the
228:27 - basic game setup pause the video now and
228:30 - see how far you
228:33 - get I want to start by creating a class
228:36 - called game no need for inheritance but
228:39 - we will need a thunder init method
228:42 - although without any parameters in there
228:45 - we want to run py game.it to initialize
228:48 - the entire thing and then create self
228:51 - dot display uncore surface which is
228:56 - going to be py game. display. set
228:59 - uncore
229:01 - mode that why we are creating the
229:03 - display surface inside of a class for
229:06 - the dimensions I want to have window WID
229:09 - and window height from settings. PI I
229:13 - suppose while we are here we can can
229:14 - also change the window title with py
229:16 - game. display. set caption I am going to
229:20 - call it
229:22 - survivor but choose whatever you like
229:25 - besides that we also want to have self.
229:27 - clock for the frame rate which we get
229:29 - with py game. time.
229:33 - clock and that is all we need to get
229:35 - started besides that I want to have a
229:38 - run method in there we are going to have
229:42 - a well true Loop or rather I want to
229:45 - have while self. running and this is
229:49 - what I forgot inside of the dunder init
229:50 - method self. running should by default
229:54 - be true and once we have that we will
229:56 - need Delta time we want to have the
229:59 - event Loop we want to update the game
230:03 - and finally we want to draw stuff first
230:06 - of all Delta time we're getting with
230:08 - self. clock. tick without any argument
230:12 - and divide it by a thousand that way we
230:14 - get Delta time in milliseconds for the
230:17 - event loop I want for event in py game.
230:21 - event. get at the moment I only want to
230:24 - check if the event. type is equal to P
230:30 - game do quit all in uppercase letters if
230:34 - that is the case self. running should be
230:38 - false that way we can close down the
230:41 - game and what is really important after
230:43 - we are finishing the while loop gr we
230:46 - also want to run py game. quit or the
230:49 - opposite of py game.it just to have a
230:52 - clean exit that was fairly easy and
230:54 - update for now we can simply ignore
230:57 - because we don't have anything to update
230:59 - inside of dwo we want to call pame do
231:03 - display do update or do flip both would
231:08 - be acceptable since we used update in
231:10 - the last game I'm going to keep on using
231:12 - that but you could use ior
231:15 - that is it now we have a game class and
231:18 - this we have to call I want to create
231:21 - one instance of the game class and then
231:25 - game.
231:27 - run if I now run everything we are
231:30 - getting a basic pame window so that is
231:33 - working really well yeah just one more
231:36 - thing that I do want to do over the
231:38 - course of this game we are going to
231:40 - create multiple files and I want to make
231:42 - sure that I only ever run this main.py
231:45 - file for that we can check if Thunder
231:49 - name is equal to this string Thunder
231:55 - main that way we are checking if the
231:58 - file is the current main file and only
232:00 - if that is the case do we want to run
232:02 - the code if I run all of this again this
232:05 - is not going to make a change and if you
232:07 - forget it it probably also won't be the
232:09 - end of the world but it's a neat
232:12 - Safeguard to avoid some potential
232:13 - problems we now have a basic game
232:17 - class after that we want to create the
232:20 - player and this I want to do in a
232:23 - separate python file which means inside
232:27 - of the code folder I want to create a
232:29 - new python file let's call it player
232:33 - dop in there I'm going to create the
232:36 - player class although first of all we
232:38 - will need from settings and import
232:42 - everything then class
232:45 - layer this has to be a Sprite this needs
232:48 - to be a Sprite or in other words we want
232:50 - to inherit from py game. sprite.
232:53 - Sprite after that we will need a Dunder
232:56 - init method with self I want to have a
233:00 - position and I want to have the
233:03 - groups next up we have to call super.
233:07 - Dunder
233:09 - init along with the groups once we have
233:13 - that self. image and self.
233:17 - rectangle for the image for now we can
233:20 - simply call pygame do image. load along
233:25 - with the join method for the path we
233:28 - want to go to images then we want to go
233:32 - to the player and I guess we can start
233:34 - with down zero. PNG so once again we
233:38 - want to go to images then we want to go
233:41 - to the player then we want to go to the
233:43 - downstate and finally
233:47 - 0.png also do not forget to convert
233:51 - Alpha all of this that way we have our
233:55 - player surface for the rectangle I want
233:58 - to get self. image. getet F rectangle
234:01 - and place this
234:03 - Center the position for this is what
234:05 - we're getting from the parameter also I
234:08 - realized there is a typo this should be
234:10 - pygame dos sprite.
234:12 - Sprite so with that that we have a
234:15 - player class this I want to use inside
234:18 - of main.py for that we first of all have
234:21 - to import it from player import the
234:25 - player class next up I want to create
234:29 - one instance of this player class and
234:31 - store it inside of self. player for that
234:34 - we will need player along with a
234:37 - position and a
234:39 - groups to start with the position I
234:42 - simply go with 400
234:44 - and
234:46 - 300 entirely random positions this we're
234:48 - going to change later on
234:50 - anyway after that we will need a group
234:54 - which we don't have at the moment but
234:56 - I'm going to create one in just a second
234:58 - and call it all Sprites let's do it
235:00 - right away actually I want to have a
235:02 - bunch of groups later on although for
235:04 - now I simply want to have self. all
235:09 - Sprites with pygame DOs sprite. group
235:14 - and just to keep things a bit more
235:16 - organized I want to have groups Sprites
235:19 - and I also want to have a let's call it
235:22 - setup with that we have a couple of
235:25 - basic things after
235:27 - that before we are calling py game.
235:30 - display. update I want to get self. all
235:33 - Sprites and draw on self. display
235:36 - surface and I suppose while we are here
235:39 - we can also call self. all Sprites do
235:42 - update with Delta time I can now run the
235:45 - code and we can see the player it
235:48 - doesn't do anything at the moment but we
235:49 - have something so next up we have to
235:53 - work on two important things we want to
235:56 - get the
235:58 - input for now let me add pass in here
236:02 - and we want to have a move method with
236:05 - self and Delta
236:07 - time both of which are going to be
236:10 - called inside of the update method in
236:12 - there we're also getting Delta time
236:15 - I want to call self. input and self.
236:19 - move I am going to start with the move
236:21 - method just so we have something to look
236:24 - at I want to get self. re. Center plus
236:29 - equals self. Direction multiplied with
236:33 - self. speed multiplied with Delta time
236:37 - we do have Delta time but we don't have
236:39 - direction or speed those we have to
236:42 - create under m movement section self.
236:47 - direction is going to be py game. Vector
236:51 - 2 but now with a direction of one and
236:54 - zero that way we are going to the right
236:57 - self. speed is going to be 500 if I run
237:01 - main. Pi we have some movement although
237:05 - we can see the last frame to fix that
237:08 - before we are drawing all of the Sprites
237:10 - I want to get self. display surface do
237:13 - fill
237:14 - with a black color let's TR off this
237:18 - again and we get proper movement after
237:22 - we have that for the direction we should
237:25 - have Zer and zero by default which are
237:27 - the default values so I'm going to leave
237:28 - it
237:29 - empty and then I want to check for the
237:32 - input which is going to be a local
237:34 - variable pame do
237:36 - key dot get pressed don't forget to call
237:42 - this one and then we want to update
237:45 - self. Direction dox and self. Direction
237:50 - doy for X I want to get the integer
237:53 - value of these and py game.
237:59 - Kore right from that I want to subtract
238:03 - the integer value of py game. K under
238:08 - score left let's start by trying this
238:11 - one so self. direction. Y is going to be
238:13 - commented out
238:14 - inside of my Pi I can now move left and
238:19 - right so that part is working pretty
238:22 - well just as a reminder at this point
238:24 - P.K right and py game. K left are
238:27 - Boolean values they can never be true or
238:30 - false and in our case via integer we are
238:34 - turning true into a one and false into a
238:36 - zero if we then subtract one from the
238:38 - other we can check for both at the same
238:41 - time this is the exact same logic that
238:43 - we have inside of the space shooter and
238:46 - for self. direction. y we want to do
238:49 - basically the same thing so let me copy
238:52 - all of this and check for pame dok down
238:57 - minus py game.
238:59 - Kore up with that I can run main. pi and
239:04 - move in all four directions that's a
239:06 - really good start however if I move left
239:10 - and right we have one speed the same
239:12 - move up and down but if I go diagonally
239:15 - all of a sudden we are moving quite a
239:17 - bit faster that happens because we are
239:20 - not normalizing self. Direction which we
239:23 - can do fairly easily self. direction is
239:26 - going to be self. direction.
239:29 - normalize but this we can only do if the
239:32 - vector has a direction I.E we want to
239:36 - check if self. Direction has any value
239:39 - that's not zero and zero if that is not
239:42 - the case else we simply want to keep
239:44 - self.
239:46 - Direction and with that inside of main.
239:49 - Pi the movement is now constant or
239:51 - rather the movement speed is
239:54 - constant and that covers the exercise so
239:57 - by the end of it I have written 40 and
240:00 - 20 lines so in about 60 lines we have
240:04 - created a reasonable starting point for
240:06 - our
240:08 - game and I hope you could follow along I
240:10 - did speed things up quite a bit but for
240:13 - the mentally all of this is very similar
240:16 - compared to what we have done in the
240:17 - space shooter so if you get stuck on any
240:19 - of these topics definitely play around
240:22 - with them in your own time in this
240:24 - section we going to cover collisions
240:27 - which means by the end of it you can
240:29 - stop the player movement using some kind
240:31 - of object we are not really going to use
240:33 - proper Graphics just to keep it simple
240:36 - later on we can add all of that fairly
240:38 - easily first of all though we have to
240:40 - cover some basic theory about collisions
240:43 - and to most fundamental issue is that
240:45 - rectangles can only check overlaps
240:48 - meaning we know if there's a collision
240:51 - but we don't know what to do with it
240:53 - instead what we want for an actual
240:55 - Collision is that if there's an overlap
240:57 - I.E a collision then we also want to
240:59 - update the position of the player or in
241:02 - other words if we have the player
241:04 - overlapping with an obstacle then we
241:06 - want to move the player a bit further to
241:08 - the left so we are stopping at that
241:10 - obstacle since we can move all the sides
241:12 - of a rectangle this this shouldn't be
241:14 - too difficult however there is a bit of
241:18 - a complication the problem is that we do
241:21 - not know on which side the Collision
241:23 - happened for example if we have
241:25 - something like this we could have a
241:27 - collision on the right side of the
241:30 - player that seems to be the most obvious
241:32 - case however we could also have a
241:34 - collision on the bottom of the player on
241:36 - the top of the player or on the left
241:39 - side of the player all of those are
241:41 - equally possible for example for the
241:44 - left side case it could be that this
241:46 - player is moving really fast to the left
241:49 - and then within a single frame we are
241:51 - moving all the way over there which is
241:54 - entirely possible and simply looking at
241:57 - a single frame with a collision can be
241:59 - really
242:00 - deceptive which means first of all we
242:02 - have to get the Collision side that
242:05 - process is going to involve two steps
242:07 - first of all we're going to separate the
242:09 - dimensions we are moving and checking
242:12 - the collisions only on the hor izontal
242:14 - axis and then on the vertical one you
242:17 - could also do this the other way around
242:18 - the order here doesn't matter too much
242:21 - what matters is that we are only
242:22 - checking a single axis that way we only
242:26 - have to figure out if the player is to
242:27 - the left or to the right of the obstacle
242:30 - so if we have something like this at the
242:33 - moment we only want to know if the
242:36 - Collision happened on the left side or
242:38 - on the right side of the obstacle and
242:41 - the easiest way to figure this one out
242:43 - is to look at the direction of the
242:45 - player for example if the player moves
242:47 - to the right then we know the Collision
242:50 - must have happened on the left side of
242:52 - the obstacle or in other words if
242:55 - there's an overlap and the player is
242:57 - moving to the right then the Collision
242:59 - must have happened on the left side of
243:01 - the obstacle at least as long as the
243:04 - obstacle itself is not moving which we
243:06 - are going to assume for now and that's
243:08 - the basic logic we are simply checking
243:10 - if there's an overlap between two
243:12 - objects and on the moving object we're
243:14 - going to check the direction which is a
243:16 - very easy thing to implement but it's
243:19 - not without its problems the most
243:21 - important issue is that this approach
243:23 - only works if a single object is
243:26 - moving for example in this game the
243:29 - player can only collide with trees rocks
243:31 - and the hills all of which are static
243:33 - the player cannot collide with any of
243:35 - the enemies since those are moving the
243:38 - Collision logic would break for
243:40 - collisions between two moving objects we
243:42 - would need some more logic
243:44 - which we are going to implement in the
243:46 - next game that is going to be a pong
243:48 - game and in there we have a player padal
243:50 - and a ball both of which can move
243:52 - meaning in there we have to check
243:54 - collisions between two moving objects
243:57 - which isn't that much more difficult to
243:58 - implement but you do want to have some
244:01 - groundwork first anyway with that we
244:04 - have all of the theory out of the way
244:05 - let's do some coding although first of
244:08 - all back inside of the code we have a
244:10 - problem we only have the player and the
244:13 - the player cannot collide with anything
244:16 - to fix that inside of the code folder I
244:19 - want to create another python file
244:21 - Sprites dop I want from settings and
244:25 - import everything and then create a
244:29 - class let's call it Collision Sprite
244:32 - this also needs to be a pyam Dos sprite.
244:36 - Sprite for which once again we will need
244:38 - a thunder init
244:41 - method for which we are going to need a
244:43 - position size and groups super. Dunder
244:48 - init with the groups and then we will
244:51 - need self. image and self.
244:54 - rectangle the image is going to be
244:56 - pygame do surface and then we pass the
245:00 - size right through to make sure that we
245:02 - can see self. image I want to fill it
245:05 - with a blue color after that for the
245:08 - rectangle self. image. getet F rectangle
245:13 - in which we are placing the center with
245:15 - the position that would be a very basic
245:18 - Collision Sprite that we are going to
245:20 - use inside of main.py first of all from
245:24 - Sprites I want to import everything
245:28 - later on we're going to add a few more
245:30 - classes in there after that inside of
245:32 - thunder in it I want to create a random
245:35 - amount of instances of this class which
245:38 - we can do with a 4 I in Range Loop let's
245:42 - say I want to create six Collision
245:44 - objects and then I want to have a
245:47 - collision Sprite for which I'm going to
245:50 - need a random position and a random size
245:53 - let's call it position size and for
245:56 - groups we want to have self. all Sprites
245:59 - now to get random values I want from
246:02 - random import Rand in for the position I
246:06 - want to have an X and A Y local variable
246:10 - which we both get via Rand int for x is
246:13 - going to be zero all the way to the
246:16 - window Whi and for y it's going to be a
246:20 - Rand int from zero to the window he
246:24 - those numbers we can then pass into the
246:26 - position I want to have a tuple with X
246:29 - and
246:30 - Y after that I want to have a width and
246:34 - a height for this surface which I'm also
246:37 - going to create via random integer I
246:40 - guess the numbers here could go from 60
246:42 - to 100
246:44 - for width and for the height also random
246:47 - integer that side those from 50 to
246:51 - 100 entirely random numbers and later on
246:54 - when we actually import objects those
246:56 - are not going to be relevant anyway for
246:59 - the size I want to have width and height
247:02 - if I now run all of this we get a bunch
247:05 - of random objects somewhere on the
247:08 - window so that's a really good start
247:11 - although before we continue we we have
247:13 - to make sure that we have easy access to
247:15 - all of these Sprites for that I want to
247:19 - create another group self.
247:22 - Collision Sprites which is simply going
247:24 - to be pygame dos sprite. group every
247:28 - time I am creating a collision Sprite I
247:31 - want this Sprite to be in all Sprites
247:34 - and self. collision
247:36 - Sprites on top of that the player needs
247:40 - to know where all of these Collision
247:42 - Sprites are which means I'm going to
247:44 - pass self. Collision Sprites in there as
247:48 - an
247:49 - argument but now you have to be careful
247:51 - because those two lines do something
247:52 - fundamentally different inside of the
247:55 - Collision Sprite we adding the Sprite to
247:58 - two groups all Sprites and collision
248:01 - Sprites however for the player we are
248:04 - only adding the Sprite to self. all
248:07 - Sprites but on top of that we are giving
248:09 - player one more argument self. Collision
248:12 - Sprites but the player itself is not in
248:16 - this group it only has access to it and
248:19 - that should make sense we don't want the
248:21 - player to collide with itself that would
248:23 - just give us some weird
248:24 - Behavior so next up inside of the player
248:28 - we are going to need one more parameter
248:31 - Collision underscore
248:33 - Sprites that we also want to store under
248:36 - movement as an attribute itself do
248:40 - Collision
248:42 - Sprites is going to be Collision Sprites
248:46 - with that setup we can keep the
248:47 - Collision logic inside of the player or
248:50 - in other words inside of the player I
248:52 - can create another method let's call it
248:55 - Collision for which we will need self
248:58 - and we will need the direction or the
249:01 - axis that we want to work in this could
249:03 - either be horizontal or vertical
249:06 - although for now we are simply going to
249:08 - add pass in there because before we are
249:11 - going to write anything inside of
249:12 - collision we have to work inside of the
249:15 - move method at the moment we are
249:17 - updating both of the axes at the same
249:20 - time simply because we are updating the
249:22 - center via a Direction but this I want
249:25 - to split into horizontal and vertical
249:28 - movement which fortunately is very
249:30 - easily done I want to duplicate this
249:32 - line and then increase self.
249:36 - re. X and self. re
249:40 - doy self. r.x is simply the left side of
249:43 - the rectangle and self. directy is the
249:45 - top side of it to that I want to add
249:48 - self. direction dox for the horizontal
249:51 - movement and for the vertical One self.
249:54 - Direction doy if I now run all of this
249:58 - we are still getting the same kind of
250:00 - movement so at the very least we didn't
250:02 - break anything once we have that after
250:05 - we have done all of the horizontal
250:07 - movement I want to call self. Collision
250:10 - on the horizontal axis
250:13 - next up then we are going to do all of
250:15 - the vertical movement and then we are
250:17 - checking the vertical Collision that
250:20 - means we are first going to move on the
250:22 - horizontal axis the player either left
250:26 - or
250:27 - right after which we are going to check
250:30 - for a collision for example if this is
250:33 - our player we might have a collision
250:36 - here we now have to figure out if the
250:39 - player is to the left of the obstacle or
250:41 - to the right if the the player was on
250:44 - the left side of the obstacle and we
250:46 - have an overlap something like this then
250:48 - we want to resolve this collision by
250:50 - moving the player a bit further to the
250:52 - left to the left side of the obstacle
250:56 - but first of all for that we have to get
250:58 - all of the
250:59 - obstacles which we can do via a for Loop
251:03 - for sprite in self. Collision Sprites in
251:08 - there first of all we want to check if
251:10 - Sprite Dot wct . Collide rect along with
251:17 - self.
251:19 - rectangle if that is the case for now
251:22 - let's simply print
251:24 - overlap if I now run main. pi and I
251:28 - overlap with any of the obstacles we are
251:30 - getting overlap so that part is working
251:33 - pretty well but this is something we
251:36 - have already seen a couple of times so
251:38 - this isn't particularly special however
251:41 - what we can do instead of printing
251:44 - overlap I want to check if
251:47 - direction is equal to let's start with
251:52 - horizontal meaning we only want to check
251:54 - left or right collisions and in there I
251:57 - can check if the player is to the left
251:59 - or the right of an obstacle via self.
252:02 - Direction dox and if that one is greater
252:06 - than zero then I know the player is
252:09 - moving to the right which means for the
252:11 - Collision I want to get self. rec. right
252:16 - and set it to sprite. rec.
252:20 - left I can now run main. pi and if I am
252:23 - only moving to the right and do nothing
252:25 - else and I hit an obstacle the player
252:29 - stops so that part is indeed working the
252:32 - issue is if I do anything else or any
252:35 - other site nothing is going to work and
252:37 - if we are overlapping and moving to the
252:39 - right we are teleporting on top of that
252:43 - you might be wondering why is there such
252:45 - a big gap between the player and an
252:47 - obstacle so all of this that happens
252:50 - because the player image is quite
252:52 - large if you look at the project folder
252:55 - under images the player and we have down
252:59 - you can see there's a ton of white space
253:01 - to the left and to the right of the
253:03 - player that is necessary because when
253:05 - the player is moving left we are using
253:08 - some of that space for the
253:10 - lags and don't worry we are going to
253:12 - count for that in just a bit first of
253:15 - all though I want to finish up the
253:17 - Collision logic and also you don't have
253:18 - to write this if statement on one line
253:21 - it could also be something like this
253:23 - although since we are only doing a
253:24 - single thing I prefer to keep the if
253:26 - statement on a single line besides that
253:30 - we also want to check if self. direction
253:33 - dox is smaller than zero I.E we are
253:38 - moving to the left if that is the case
253:41 - self. rec. left should be sprite. w.
253:46 - right let's try that
253:48 - one I can now move to the left and if I
253:52 - collide with an obstacle the player
253:54 - stops the right side Collision also
253:56 - works just fine so I am quite happy with
254:00 - that definitely making progress and just
254:04 - to go over the entire logic one more
254:06 - time at the moment we are moving the
254:08 - player only left and right if this is
254:11 - our player at the moment we are only
254:14 - moving to the right after that we are
254:17 - checking for collisions meaning we are
254:20 - looping through all of the Sprites and
254:22 - then we're using a w Collision if that
254:25 - one triggers we could have something
254:27 - like this if that is the case we are
254:31 - checking one of two if statements one of
254:33 - those
254:35 - two in our case we know that self.
254:38 - direction dox is greater than zero
254:40 - because the player is moving to the
254:42 - right if that is the case we are setting
254:45 - the right side of the player to the left
254:47 - side of the obstacle or in other words
254:49 - we getting this side and setting it to
254:53 - this position I.E we are moving the
254:55 - player a bit to the
254:58 - left and that is literally all we do
255:01 - with this system we have basic
255:03 - collisions and well the same thing we
255:06 - can do in an El statement for the
255:07 - vertical movement I simply need to check
255:10 - if self. Direction doy is smaller than
255:14 - zero if that is the case we're moving
255:17 - up and if there's a collision self. re.
255:22 - toop should be sprite. re. bottom then
255:26 - we can duplicate all of this because
255:28 - next up I want to check if self.
255:30 - Direction doy is greater than zero in
255:33 - other words we are moving down and if
255:36 - there's a collision I'm going to set
255:38 - self. re. bottom to sprite. re. toop and
255:43 - that is all we need for the collisions
255:45 - on all four sides if I now run main. Pi
255:49 - we're getting a collision on all of the
255:51 - sides and this works super
255:54 - reliably so very happy with that this
255:57 - would also work with two collisions at
255:59 - the same time let me try this again so
256:02 - there you can
256:04 - see we have two obstacles at the same
256:07 - time I cannot move to the right and I
256:09 - cannot move up so this part is working
256:12 - perfectly fine
256:15 - great with that we have basic
256:18 - collisions however we are not done yet
256:20 - because at the moment our player has a
256:22 - shape that's roughly like
256:25 - this or in other words those are the
256:28 - visible pixels but the entire surface is
256:31 - this
256:33 - large as a consequence we do have a bit
256:36 - too much white space to the left and to
256:38 - the right of the player this I don't
256:41 - like and want to remove
256:43 - which we can actually do fairly easily
256:46 - at the moment our collisions are done
256:48 - via the
256:49 - rectangle which is going to have the
256:51 - same size as the image which is not what
256:53 - I want I want to create self. hitbox
256:57 - uncore rectangle which is going to be
257:00 - self. wct do inflate at the moment we
257:04 - only want to change the Wii let's say by
257:07 - minus 40 for now the height we can keep
257:11 - so this one is going to get a zero
257:13 - with that we have a hitbox rectangle
257:16 - this is what I actually want to use for
257:18 - the
257:19 - collisions and to use it we have to
257:21 - update the move method and the Collision
257:24 - method or in other words we first of all
257:27 - want to move the hitbox
257:28 - rectangle both on the horizontal and on
257:31 - the vertical axis after that we want to
257:34 - set the center of the rectangle to the
257:36 - center of the hitbox those two always
257:39 - have to keep the same Center positions
257:41 - besides that for the collisions we want
257:44 - to check with the hitbox of the player
257:46 - instead of the rectangle of the player
257:48 - and all of this is going to be your
257:50 - exercise so what I want you guys to do
257:52 - is to implement the hitbox logic for the
257:54 - collisions pause the video now and see
257:56 - how far you
257:59 - get back in the code first of all we
258:03 - have to update the movement because we
258:05 - only want to move self. hitbox rectangle
258:10 - on the horizontal and on the vertical
258:13 - AES now this code wouldn't crash but now
258:16 - we do not get movement anymore simply
258:19 - because the Sprite is drawing the image
258:21 - wherever the rectangle is and we are not
258:23 - moving the rectangle anymore to fix that
258:27 - I want to set self doir do Center to
258:30 - self. hitbox rectangle do Center since
258:35 - we are not checking for collisions with
258:36 - the hitbox rectangle inside of main. Pi
258:39 - the player can simply walk through all
258:41 - of the obstacles
258:44 - to account for that inside of collision
258:47 - we want to check if sprite. rec. cidere
258:51 - and self. hitbox rectangle on top of
258:54 - that if there is a collision so for
258:57 - example on this line we don't want to
259:00 - update self. rectangle instead we want
259:03 - to update self. hitbox rectangle that we
259:07 - want to do for all of the
259:10 - rectangles if I now run may not p again
259:14 - I get proper Collision logic again and
259:17 - now the player gets much closer to these
259:20 - obstacles especially when we are
259:22 - comparing this to the original it looks
259:24 - much better although there's still a
259:27 - little bit of a gap that we can now fix
259:29 - with this inflate method let's go with
259:32 - 50
259:34 - and we are getting closer but there's
259:37 - still a bit of space between them maybe
259:41 - -60 is the right number
259:43 - number and there you can see now we have
259:45 - a Pixel Perfect
259:47 - Collision or well not exactly Pixel
259:50 - Perfect because we're not using a mask
259:51 - but it looks good to the player and
259:53 - that's really all we need so with that
259:56 - we have basic Collision logic something
259:58 - really important for any kind of game
260:00 - and fundamentally we are really not
260:02 - doing anything too complicated so the
260:05 - entire Collision logic took maybe 10ish
260:07 - lines to right we are simply getting the
260:10 - player rectangle and then setting it to
260:12 - to one of the sides of the
260:15 - obstacle and to know which side we are
260:17 - working with we are checking the
260:19 - direction the player is moving in and
260:21 - that is literally it it is time to
260:24 - import the level data by the end of this
260:26 - section we have some actual stuff in the
260:28 - game that is nice to look at although
260:30 - for the full effect we are also going to
260:32 - need a camera which we don't have yet
260:35 - that is going to be the next section
260:37 - anyway to create a preper level we are
260:40 - going to need an editor that will be can
260:42 - place images and see the result right
260:44 - away and there are quite a few different
260:46 - level editors but one of the really
260:48 - popular ones is called tiled that you
260:51 - can get at map editor. org I have used
260:54 - this one for a whole bunch of projects
260:56 - it's entirely free and really nice to
260:58 - use and the files you create in tile can
261:01 - also be imported into pame super easily
261:03 - that being said for this video I will
261:06 - only cover how to import tile Maps I
261:08 - will not cover how to create them if you
261:11 - are interested in that check out my
261:12 - dedicated video in there I cover all of
261:15 - the details of tiled including how to
261:17 - create a map anyway if you go to map
261:21 - editor. org you can see tiled if you go
261:24 - down a bit you can also see a couple of
261:26 - games that have been using it I guess
261:28 - the really famous one is Shovel Knight
261:29 - there's also axom Verge and Carion all
261:32 - really good
261:33 - games in our case though we simply want
261:35 - to download on
261:37 - itch.io there you can click on download
261:40 - now and you could set a price but you
261:42 - don't have to you can simply go to no
261:44 - thans take me to downloads and then you
261:46 - can download the version that works for
261:48 - your operating system in my case I'm
261:51 - working on Windows but if you have Mac
261:53 - or Linux go with the other
261:55 - ones then you have a download after that
261:58 - part is done you want to open the file
262:02 - and simply click on next and agree to
262:05 - everything and then you should be done
262:07 - afterwards you can launch tiled if I
262:10 - click on finish then we are getting
262:12 - getting to something like this this is
262:14 - the titled editor in there you could
262:16 - create a new map or a new tile
262:20 - set what those words mean you are going
262:23 - to see in just a second in fact I think
262:26 - the best way to approach this is to look
262:28 - at the project folder so in there we
262:30 - have a data folder which contains
262:32 - Graphics maps and tile sets the main
262:36 - thing that you want to work on is a map
262:39 - and there you can see we have a tiled
262:40 - symbol that should also work for you
262:43 - if you click on that one you can see a
262:46 - tille map so the main thing you see on
262:49 - the window is the map that we have
262:51 - created and this is going to be our
262:53 - actual level on the right side this
262:56 - bottom area this contains the tile sets
263:00 - and at the moment I have two a world
263:02 - tile set and on there if you hold
263:04 - control and use the scroll wheel you can
263:06 - zoom in and out one tile set is going to
263:09 - be all of the graphics the other tile
263:12 - set objects simply contains a whole
263:14 - bunch of objects like trees and pillars
263:17 - and rocks and besides that we have a
263:20 - whole bunch of layers the bottom one is
263:23 - ground then we have entities collisions
263:25 - and objects so how does all of this work
263:29 - for that let's have a look at the
263:30 - project
263:32 - folder we have three main components
263:35 - Graphics maps and tile sets the way
263:38 - those are going to work is that we are
263:41 - importing all of the graphics into
263:45 - tiled if you open this one you can for
263:47 - example see on the tile sets we have the
263:50 - world tile set the one you have just
263:52 - seen Under World tile set on top of that
263:56 - what tiled is doing it is separating
263:59 - this graphic into individual tiles one
264:03 - would be this one the next one would be
264:05 - this one then we have another one here
264:07 - and so on we are simply separating the
264:09 - graphic into smaller bits and these
264:12 - smaller bits are effectively a tile set
264:15 - or in other words if I go back to
264:18 - data we are importing the graphics and
264:21 - storing them as a tile set that way we
264:24 - can pick one part of the graphic and
264:26 - then this tile set is going to be used
264:29 - inside of a map to create a new kind of
264:33 - graphic or in other words if I had back
264:36 - to tiled and I have the ground layer
264:39 - selected if I now select one of these
264:42 - tiles I can go to the map and zoom in
264:46 - and simply place them as I like I can
264:49 - also select multiple and place them in
264:52 - there and that is how you create the
264:55 - entire map for this entire thing I spent
264:58 - about half an hour laying out all of
265:00 - these parts and that way we have created
265:04 - a tile
265:05 - map which is what we actually want to
265:07 - import into P game and in the most basic
265:11 - sense that's all you have to understand
265:12 - about tiled although I guess there's one
265:15 - more thing that you want to keep in mind
265:17 - there are two kinds of layers that you
265:19 - could be working with inside of tiled
265:22 - what I have covered so far is a tile
265:24 - layer and this you can see via this grit
265:27 - symbol that means we have a tile layer
265:30 - besides that we can also have an object
265:32 - layer those have these pink speech
265:35 - bubbly kind of looking things those work
265:38 - in a very similar way but there are some
265:40 - key differences for example
265:42 - if we are looking at the objects those
265:45 - would be all of the trees the pillars
265:47 - and the Rocks the main way those differ
265:49 - from the tile set is that they can be
265:51 - placed freely anywhere on the
265:54 - map while a tile set always has to
265:57 - conform to a grid so I can only ever
266:00 - select one of these grid positions I
266:02 - cannot go outside of it also when we
266:05 - importing all of them into pame they do
266:06 - work just a little bit
266:08 - differently ultimately for all of these
266:11 - objects the way you want to approach
266:13 - them is that if I go to the top left we
266:17 - have a whole bunch of ground tiles all
266:19 - of those they're all grass then we have
266:21 - an object that one is simply a tree or
266:24 - rather a couple of
266:26 - trees and those for now we want to
266:29 - import which means inside of py game we
266:31 - want to get the ground layer and the
266:33 - objects layer collisions and entities we
266:36 - are going to ignore for now and for all
266:39 - of these objects if you look on the left
266:42 - there here we have
266:43 - properties for example if I am clicking
266:46 - on the tree we have an X and A Y
266:49 - position so if I'm moving this tree you
266:51 - can see this position is updating we
266:54 - also getting a width and a height and
266:56 - all of these numbers we can use inside
266:58 - of py game and for the ground let me
267:01 - hide all of the other stuff for all of
267:03 - the tiles for example for this top tile
267:06 - we have three major attributes that we
267:09 - care about we have an X position a y
267:11 - position
267:12 - and a surface the surface for basically
267:15 - all of those would be a plain grass tile
267:17 - but for example for this one here we
267:20 - have mostly grass but then also a corner
267:22 - for the stone besides that we have a
267:26 - position but the position is on a GD
267:28 - meaning for this top tile the position
267:30 - would be zero and zero and if you go one
267:33 - tile further to the right the position
267:36 - would be 1 and zero really important to
267:40 - understand here is that we are not
267:42 - working with pixel positions or in other
267:45 - words when we are importing all of this
267:47 - into pame we have to convert a grid
267:49 - position into a pixel
267:51 - position which arguably is fairly simple
267:55 - all righty but with that we have another
267:57 - question how can we import all of this
268:00 - into py game that topic you could
268:03 - approach in two ways number one you
268:06 - could export all of this as a CSV file
268:10 - here's also Json or good scene and Via
268:13 - that you could import them into other
268:15 - programs while that's possible it's also
268:18 - quite a hassle so not something I would
268:20 - recommend what is a much better way is
268:22 - to use a python module that does all the
268:24 - work for us for that you want to open
268:26 - the terminal and then type pip install P
268:31 - TMX then python is going to load
268:34 - something for a second and then you have
268:35 - py TMX a module that can import TMX
268:39 - files super easily and with that finally
268:42 - we can start working inside of
268:45 - pame first of all we have to import the
268:48 - PMX module although we don't want all of
268:52 - it we simply want from
268:55 - PMX do util uncore py game and then
269:00 - import load py game via this method we
269:04 - can import a TMX map and then use it
269:06 - inside of the code and I suppose for all
269:09 - of that we can create a separate setup
269:13 - method without any custom parameters and
269:16 - first of all I want to import the map
269:19 - which we are doing via load
269:22 - pame after that for the path we want to
269:26 - go to data then to maps and then to
269:29 - world. TMX or in other words we want to
269:33 - use the join method then go to data
269:36 - after that we have maps and finally we
269:39 - have world. TMX
269:42 - once we have that let's print the
269:45 - map and after we have covered all of the
269:47 - groups I want to call Self do setup if I
269:51 - now run all of
269:53 - this we getting the game although we
269:56 - don't care about that at the moment and
269:57 - then we are getting a tiled map if you
270:01 - get anything else something has gone
270:02 - wrong so double check your steps now on
270:05 - this map we want to access all of the
270:07 - individual layers for example we want to
270:10 - get the ground layer or the objects
270:12 - layer and later on also the collisions
270:14 - and the entities layers for that we want
270:17 - to get the map and then get layer by
270:21 - name that is the most common way to
270:23 - access one of the layers after that
270:26 - we're going to need a name and for now I
270:29 - want to look at the objects layer the
270:33 - layer inside of tiled that contains all
270:35 - of the trees all of the rocks and the
270:37 - pillars and stuff like that inside of
270:39 - this layer we have a whole bunch of
270:41 - indiv ual objects all of which we can
270:44 - access via a for Loop for obj in map.
270:48 - getet layup by object name and inside of
270:51 - this thing you can now print obj dox obj
270:55 - doy and obj do image to get the X
270:59 - position to Y position and the surface
271:02 - which means if I run all of this now we
271:05 - are getting a whole bunch of data and
271:09 - that is looking pretty good all we have
271:12 - to figure out now is how to turn this
271:14 - data into a
271:15 - Sprite Which we can do easily because
271:18 - under Sprites we already have a
271:20 - collision
271:22 - object this we simply have to modify a
271:24 - bit we want to keep a position but
271:27 - instead of a size we want to have a
271:30 - surface and then when we are creating
271:32 - self. image we want to use that
271:35 - surface we don't want to fill the image
271:38 - anymore but we want to keep self. image.
271:42 - getet F rectangle after that we don't
271:46 - need this for I in range six for Loop
271:49 - anymore let me get rid of it entirely
271:53 - instead inside of the for Loop forget
271:56 - layer by name I want to create a
271:59 - collision Sprite for the position we
272:03 - will need obj dox and obj doy both of
272:08 - those have to be inside of a
272:10 - tubow after that we are going to need a
272:12 - surface which is obj do image finally
272:17 - for the groups self. all Sprites and
272:19 - self. collision Sprites and with that if
272:23 - I run all of this you can see we have a
272:27 - whole bunch of trees and since the
272:29 - player collided on a collision object we
272:31 - get some weird Behavior but that's
272:32 - totally fine that we can fix by changing
272:35 - the starting position of the player to
272:37 - 500 if I now run all of this again we
272:41 - can see that the player can move around
272:43 - and we have a whole bunch of trees so
272:46 - that is working really well we are also
272:48 - not needing the print statements anymore
272:50 - and that covers the first part besides
272:53 - that I also want to import the ground
272:55 - layers or in other words I want to only
272:59 - look at the ground layer at the moment
273:02 - and this is working a bit different
273:03 - because remember now we are working with
273:05 - a tiled layer whereas objects was an
273:08 - object layer now to use a tiled layer we
273:11 - we are still going to use map. getet
273:13 - layer by name and the layer we now want
273:16 - to get is called ground but after this
273:19 - one we want to add dot tiles that way we
273:22 - are returning the tiles and make them a
273:25 - bit more accessible or in other words
273:28 - when we are using the for Loop we can
273:30 - use 4 x y and let's call it image in
273:36 - map. getet layer by name and after that
273:39 - I can print X I can print Y and finally
273:44 - I can print the image if I now run all
273:48 - of this we are getting a huge amount of
273:51 - data we're getting for example 51 and 49
273:55 - this is the X and Y position on the grid
273:57 - it is not a pixel position and then
274:00 - we're getting a surface and that's
274:02 - really all we need that being said for
274:05 - the ground we want to have another kind
274:07 - of sprite because those Sprites should
274:09 - not be collidable or in other words
274:12 - inside of Sprites dop I want to create
274:15 - another class called
274:17 - Sprite this one is also going to be
274:20 - pygame dos sprite. Sprite and then
274:24 - Define Thunder
274:26 - init for which we are going to need self
274:29 - a position a surface and the
274:32 - groups and Well for now this Sprite
274:35 - class is going to be basically identical
274:38 - compared to the Collision
274:39 - Sprites so I can simply copy paste the
274:42 - lines and then we are good to go then
274:45 - inside of main. Pi we want to create one
274:49 - Sprite for now with the X and Y
274:53 - position after that for the surface we
274:56 - want to use the image and for the groups
274:58 - we want to use self. all
275:01 - Sprites that should be all we need to
275:03 - get something and well if you now look
275:06 - in the top left there we do have some
275:09 - weird thing that is because we use the X
275:12 - and Y position from the grid meaning all
275:15 - of the numbers are way too small to fix
275:18 - that we have to multiply all of these
275:20 - numbers with the tile size the top left
275:23 - Tile For example would have a grid
275:25 - position of 0o and zero and we know that
275:28 - the width of this tile and also the
275:30 - height is both
275:32 - 64 but then for the next tile this one
275:36 - here we have a grid position of 1 and
275:39 - zero the top position is simply going to
275:41 - to be zero however for the left side
275:44 - this one here we want to have 1 * 64
275:49 - that way we are getting all the way to
275:52 - this point and by the way the tile size
275:54 - you can set when you are creating a map
275:57 - but this you want to plan out so when I
275:59 - got the graphics I checked what kind of
276:01 - tile size we had this is really
276:03 - important to know before you are
276:05 - starting although in our case under
276:07 - settings we have a tile size this we can
276:10 - simply use or in other words when we are
276:13 - getting the position for the Sprites I
276:15 - want to get X and Y and then multiply it
276:18 - with the tile size if I now run all of
276:21 - this we can see that we have the proper
276:25 - level although all of the objects
276:28 - disappeared but we still have collisions
276:30 - so what
276:32 - happened well this is an issue we had
276:34 - earlier when we are drawing all of the
276:37 - Sprites we are sorting these Sprites by
276:39 - the time of their creation and and since
276:41 - we are creating all of the Sprites after
276:44 - the Collision objects they are being
276:45 - drawn on top that is a very easy thing
276:48 - to fix we simply want to create all of
276:50 - these objects after the Sprites if I now
276:53 - run all of this again you can see that
276:56 - we have something much better
277:00 - looking and the collisions also work
277:02 - reasonably well so I am mostly happy
277:04 - with that that being said if you compare
277:07 - this image at the moment with what we
277:10 - have inside of tiled the objects don't
277:13 - line up exactly I guess a really good
277:15 - way to illustrate is if you look at this
277:18 - tree how it relates to these rocks the
277:22 - top of the tree is basically right
277:24 - around this corner but inside of the
277:27 - game this is looking different so what
277:29 - happened the answer to that is fairly
277:32 - simple when we are placing a collision
277:34 - Sprite the position that we are placing
277:36 - is the top left if I now run m.p again
277:40 - this is looking looking much better
277:43 - although it's not perfect yet if we are
277:46 - comparing all of this to tiled and pay
277:48 - close attention to the top of the tree
277:51 - and the corners of the stones if I run
277:54 - the game again you can see quite well
277:56 - that this isn't what we are getting that
277:59 - is because when we are placing all of
278:01 - the background Sprites we are placing
278:04 - the center but when we are placing the
278:06 - objects or in other words the Collision
278:08 - Sprite we are placing the top left
278:10 - position in other words we are placing a
278:13 - different position now generally when
278:15 - you're getting anything from tiled you
278:17 - want to place the top left position if
278:20 - you do that and run all of this again
278:22 - now this is looking exactly like what we
278:24 - have en tiled but anyway at this point
278:27 - you should be confident to import tiled
278:29 - layers or object layers from tiled Let's
278:32 - do an exercise I want you guys to import
278:36 - the Collision layer from tiled and then
278:38 - create invisible Collision objects from
278:40 - the rectangle on that layer or in other
278:43 - words here we are back in tiled and I
278:45 - want to look at the Collision layer if I
278:47 - make this one visible you can see that
278:50 - we have a whole bunch of rectangles
278:54 - those basically Define the environment
278:56 - or the collision with the
278:59 - environment I want you guys to import
279:01 - all of
279:04 - those and then create a collision object
279:07 - that the player cannot see simply
279:10 - because we already have the Graphics
279:12 - from the tiled layer and a minor tip for
279:15 - this one when you're importing objects
279:17 - in py game you can get the Whi and the
279:20 - height quite easily you also get with
279:22 - wift and do height and also in the code
279:26 - you can reuse the Collision Sprite for
279:28 - all of that pause the video now and see
279:30 - how far you
279:33 - get I want to have or obj in map. getet
279:39 - layer by name and and I want to look at
279:42 - the collisions layer since this one
279:45 - isn't visible it doesn't really matter
279:47 - where you put it it could be before or
279:49 - after the other four Loops it's entirely
279:51 - up to you in there we want to create a
279:55 - collision Sprite for which we are going
279:57 - to need a position a surface and the
279:59 - groups the position is super easy we
280:02 - simply want to have obj dox and obj doy
280:06 - for the surface we kind of have a
280:09 - problem because because when we imported
280:12 - all of the objects we got obj do image
280:16 - but this we cannot use for this for Loop
280:18 - simply because we are importing
280:20 - rectangles or in other words if I
280:22 - comment out this line for now and then
280:26 - print obj do image and run the code we
280:30 - are simply getting a whole bunch of none
280:33 - which means obj do image isn't a good
280:35 - way to approach
280:37 - this however what we can do is create
280:41 - pame do
280:43 - surface and then create a surface with
280:46 - the size of these
280:48 - rectangles that is possible because we
280:50 - can get the width and the height of all
280:52 - of them via obj do width and obj do
280:56 - height finally then we want to create
280:59 - the groups and in my case I only want to
281:02 - get self. Collision
281:04 - Sprites that way the player can collide
281:07 - with them but they are not visible if I
281:10 - run all of this now
281:11 - I can try to go down but I am not able
281:15 - to go to the cliff also if I go to this
281:18 - Stony Hill thing like so the player has
281:22 - a collision and this is working really
281:25 - well although for this part I was a bit
281:27 - lazy because when you look at these
281:30 - Collision layers you can see they don't
281:32 - really line up with the cliff graphic
281:34 - that is because later on we will spawn
281:38 - the player inside of this Center area
281:41 - and then the area around it is sealed
281:43 - off meaning this area around here is
281:47 - never going to be reachable by the
281:48 - player so it doesn't really matter how
281:50 - large these rectangles are on the left
281:52 - side of the cliff at least on this side
281:55 - unfortunately we cannot place the player
281:57 - in there yet because we don't have a
281:58 - camera so there wouldn't be any point to
282:00 - it that we can work on next but for now
282:03 - we have made some pretty solid progress
282:05 - and now we are able to import stuff from
282:08 - til now that we have a level we can work
282:10 - on a camera by the end of this part we
282:13 - have a proper level that the player can
282:15 - explore makes the entire game feel
282:17 - significantly better for that though we
282:20 - have kind of a problem at the moment
282:22 - that is that we can only see things that
282:24 - are on the display surface or other
282:27 - words if this is our display surface and
282:30 - so far our window at least in my case
282:32 - was always 1280 by
282:35 - 720 on there we have a player and we
282:38 - have a bunch of objects however ever
282:41 - what happens when we have an object
282:43 - outside of it what do we do then or in
282:46 - other words at the moment we can only
282:49 - see things that are between the
282:51 - positions Z and zero so the origin point
282:55 - and the bottom right or the window width
282:58 - and window height for example in our
283:00 - case the top left position of this
283:02 - object might be
283:05 - 1400 and 100 for X and Y this at the
283:10 - moment would not be visible how can we
283:11 - change that and first of all for that we
283:15 - have one major limitation and that is
283:18 - that the display surface cannot be
283:20 - changed it always starts at zero and
283:23 - zero and then continues to the display
283:26 - Dimensions I suppose you could resize
283:28 - the window But ultimately that doesn't
283:30 - help you very much instead to create a
283:34 - camera we have to change where all of
283:36 - the elements are drawn and to understand
283:38 - how this is working let's look at the
283:40 - display surface again and one more time
283:43 - we have a whole bunch of objects and one
283:45 - object outside of it now what we cannot
283:48 - do is move the entire display surface to
283:50 - the right to make it visible that is
283:52 - simply not possible but what we can do
283:55 - is the opposite we can move all of the
283:57 - other objects in the opposite
284:00 - direction and when I say move I am a bit
284:02 - incorrect here because we are not moving
284:05 - anything what is really important to
284:08 - understand is that the position of the
284:10 - Sprite or rather direct inside of it
284:12 - does not change the only thing that
284:15 - changes is that we are drawing things in
284:17 - a different
284:18 - position if we change the position of
284:21 - the rectangles our Collision logic would
284:23 - stop working so this is not something
284:25 - that we can do so the question then is
284:28 - how can we draw stuff in a different
284:31 - position and for that we can customize a
284:34 - Sprite group or more specifically the
284:36 - drawing logic of a Sprite Group which
284:39 - actually is quite simple because because
284:41 - all that is happening inside of group.
284:43 - draw is a for Loop that blits all of the
284:46 - Sprites on the surface or in other words
284:48 - we are looking at all of the Sprites
284:49 - inside of the group and then we're doing
284:51 - surface. blit with sprite. image and
284:53 - sprite. rectangle that's all that's
284:55 - happening in there so let's play around
284:58 - with that once again here we are in the
285:01 - code and at the moment we are drawing
285:04 - all of the Sprites via self. all Sprites
285:08 - or in other words inside of the run
285:10 - method we calling self. all Sprites DOD
285:12 - draw with a Target surface which in our
285:15 - case is the display
285:17 - surface this we want to change and for
285:20 - that I want to create a new python file
285:23 - which means inside of the code folder I
285:25 - want to create let's call it groups. Pi
285:29 - first of all we're going to need from
285:31 - settings and import everything after
285:34 - that I want to create a class called all
285:39 - Sprites which has to en it from pygame
285:42 - dos sprite.
285:44 - group and for now all that we are going
285:46 - to do in here is Define Dunder init with
285:50 - self and nothing else and then call
285:53 - Super do Thunder init that way we have a
285:57 - copy of a Sprite Group which we can use
286:00 - inside of main.py I want from groups
286:04 - import all Sprites and that I can use to
286:07 - replace this py. sprite. group if I add
286:11 - all Sprites in here and run the
286:13 - code we are getting the very same
286:16 - outcome which should make sense we are
286:18 - basically just wrapping the basic pyam
286:21 - group inside of another class although
286:24 - with the setup we can customize things
286:27 - but first of all let's recreate the
286:29 - original functionality of this group for
286:31 - that we will need Define draw with self
286:35 - and some kind of surface that we want to
286:37 - draw on if I add pass in here for now
286:41 - we are not going to see anything because
286:44 - we are now overwriting this draw method
286:48 - and since we are not doing anything we
286:50 - cannot see any surfaces to get that
286:53 - functionality back we want for sprite in
286:56 - self that way we can access all of the
286:58 - Sprites inside of this group and then we
287:01 - want to get a Surface and call the blit
287:03 - method with sprite. image and sprite.
287:07 - rectangle after we doing that
287:11 - we can see the game again and it works
287:13 - just as
287:14 - before that part was actually fairly
287:17 - simple I suppose one thing that we could
287:19 - be doing to simplify this code just a
287:22 - bit is that we always want to draw on
287:25 - the display surface so adding this
287:27 - argument here doesn't really make sense
287:30 - instead inside of Thunder AIT of all
287:33 - Sprites I want to get self. display
287:36 - uncore surface and then get the display
287:40 - surface which we can get via py game.
287:44 - display.
287:46 - getor surface that way you are getting
287:49 - the display surface from anywhere inside
287:51 - of the code and that we can use inside
287:54 - of the for Loop self. display surface.
287:57 - blit because of that the parameter
287:59 - surface is not needed anymore and inside
288:03 - of main. Pi we don't need the
288:05 - argument but we can run the game and
288:08 - everything works just as before
288:11 - we have now created a customized drawing
288:14 - method and this we can push much further
288:17 - because what you have to understand is
288:19 - that when we are calling the blit method
288:22 - we are placing this surface in the
288:23 - position of this
288:25 - rectangle and as a reminder we are
288:28 - basically always placing the top left
288:30 - position of the rectangle so if I run m.
288:32 - Pi again once again the same result but
288:36 - what we can do now to the top left
288:38 - position of the rectangle we can add and
288:41 - offset via a vector 2 for example in
288:45 - there I could add 500 and 100 inside of
288:49 - the game now we are drawing every single
288:51 - element at an offset or in other words
288:53 - from the top left we are 500 pixels to
288:57 - the right and 100 pixels down and really
289:02 - important this is just where elements
289:04 - are drawn the actual position of the
289:06 - rectangles has not changed which means
289:08 - if I move around the collisions work
289:11 - just as before and let me get to a
289:13 - better position there you can see I have
289:15 - a collision with a tree and this works
289:18 - perfectly fine so the main thing you
289:20 - have to understand is that inside of
289:22 - this logic when we are drawing the
289:24 - rectangle we are simply adding a vector
289:26 - two and to create a camera we simply
289:29 - have to customize these numbers for that
289:33 - I want to turn the vector into an
289:35 - attribute self. offset which is going to
289:38 - be pame do Vector 2
289:41 - by default with zero and zero and this
289:44 - offset I want to use inside of the blit
289:47 - method self.
289:49 - offset on top of that when we are
289:52 - drawing everything I want to have a
289:55 - Target uncore
289:57 - position which we are getting inside of
290:00 - draw from self. player. re. Center this
290:06 - is the position we want to follow or in
290:07 - other words the camera should follow the
290:09 - player once we have that we want to get
290:13 - self. offset dox and later self. offsety
290:17 - as well but for now let's only do one
290:20 - dimension I suppose for now let's simply
290:22 - start with Target position and zero if I
290:25 - now run the code you can see that we get
290:29 - some
290:30 - movement and the issue here is that well
290:34 - the camera movement and the player
290:36 - movement go in the opposite directions
290:38 - if the player moves to the right the
290:40 - entire entire thing is drawn further to
290:42 - the left to flip that around we simply
290:44 - want to have a negative number if I now
290:47 - run main. Pi we are getting something so
290:52 - now the player is always on the left
290:54 - side of the
290:57 - window so essentially what is happening
291:00 - now is that we are getting the origin
291:02 - point from the offset of the player and
291:05 - then from that we are adding the top
291:07 - left of the rectangle that way if the
291:10 - player gets f to the right we are
291:11 - drawing everything at that offset but we
291:14 - don't want the player to be constantly
291:15 - on the left border and for that we want
291:18 - to add another value which is going to
291:20 - be window wift / two to get that we want
291:25 - to subtract window wift divided by two
291:28 - and also we want to apply the negative
291:30 - value to the entire thing if I now run
291:35 - main. Pi we have the player in the
291:37 - center and we have a camera so that is
291:41 - working really well although we are not
291:44 - covering the vertical axis which
291:46 - fortunately is fairly simple we simply
291:49 - have to duplicate this line and then
291:51 - change self. offset doy to Target
291:54 - position one and then minus window
291:57 - uncore height with that we have a camera
292:02 - and I can explore the level although the
292:04 - Collision is a bit wonky but we're going
292:06 - to fix that later on as
292:08 - well other than that though the player
292:11 - can explore the level and we are nearly
292:15 - there we're going to cover the starting
292:17 - position of the player in just a second
292:19 - but for now this is all you need for a
292:22 - basic player camera where you place the
292:24 - top left of the rectangle and then you
292:26 - add an offset the offset you're getting
292:28 - from the position of some kind of Target
292:31 - this is almost always going to be the
292:33 - player so next up we have to work on the
292:36 - starting position for that inside of til
292:40 - we we have another layer called entities
292:42 - on there we have a whole bunch of
292:44 - markers and let me hide all the other
292:46 - stuff there you can see on entities we
292:49 - simply have a whole bunch of markers
292:51 - that's all we do in here and if you look
292:55 - at one of those this one for
292:57 - example we have an X and A Y position
293:00 - and that is about it however if we look
293:03 - at this marker we have a name and that
293:06 - is player which means that this marker
293:09 - is supposed to be the starting position
293:10 - position of the player and all of the
293:12 - other positions are going to be starting
293:14 - positions for the opponents that we
293:17 - cover later first of all though back
293:19 - inside of main.py in the setup method I
293:23 - want to add one more for Loop and I
293:26 - think generally a bit more white space
293:27 - in here would be quite nice I want for
293:30 - obj and this could also be marker
293:33 - markers are just other objects the name
293:35 - here doesn't really matter so much and I
293:37 - want to keep it consistent so for obj
293:40 - and in map. getet layer by name we want
293:43 - to look at the entity layer and for now
293:47 - let's simply print the object that we
293:49 - are getting if I run the game we are
293:52 - getting a whole bunch of tiled
293:55 - objects some of those are called none
293:58 - others are called enemy and then we have
294:01 - a player all the way in the
294:03 - beginning or in other words if you look
294:05 - at
294:06 - til this one was the starting position
294:08 - for the player then we have add a non
294:11 - value here and here and none just means
294:13 - we have no value for the name but if I
294:15 - click on this one we have enemy and the
294:18 - issue why we have some nonv values is
294:20 - because I forgot to add a name but that
294:22 - is quite easily fixable if you go to
294:24 - objects there you can see all of the
294:26 - objects on that layer and I simply
294:29 - forgot a couple of those and that you
294:31 - can fix quite easily by selecting all of
294:33 - them and then change the name to enemy
294:36 - after that we have a much better system
294:39 - where we have a marker with enemy or a
294:41 - marker with
294:42 - player and that name we can access I
294:45 - want to get obj do name I can run this
294:48 - again and now we are getting lots of
294:50 - enemies and one player at the moment we
294:54 - only care about the
294:56 - player because that we can use via if
295:00 - objname is equal to player and if that
295:04 - is the case we want to create one
295:06 - instance of the player that we have so
295:08 - far done inside of Thunder init and then
295:10 - create that one in there because of that
295:14 - we can use obj dox and obj doy for the
295:20 - position once we have that we are
295:23 - getting an error that game object has no
295:26 - attribute player the reason for that is
295:29 - that this if statement never triggers
295:31 - because the name of this object is
295:33 - player with a capital P if I now run
295:36 - this again we have the player in the
295:38 - proper starting position and now we can
295:40 - can actually move around properly and we
295:43 - have something that looks much much
295:45 - nicer this is getting very close to an
295:47 - actual game so quite happy with that
295:51 - however there is another issue and that
295:53 - issue is called wise
295:55 - sorting you might have already spotted
295:57 - that in the game basically if there are
295:59 - overlaps between Sprites you want to
296:01 - make sure that the right one is on top
296:04 - for example what we could be having is
296:05 - the player being behind a tree which
296:08 - does look right but you could also have
296:10 - something like this where the player is
296:12 - below a tree and this doesn't look right
296:15 - anymore instead we want to have
296:16 - something like this and in our game it
296:19 - needs to be possible for the player to
296:21 - be behind a tree and in front of a tree
296:24 - and more generally if I run the game and
296:27 - you look for overlaps for example there
296:29 - you can already see one where we have
296:31 - the pillar thing being on top of the
296:34 - tree that just doesn't look good also we
296:37 - have another tree here that has the
296:39 - shadow on the other
296:40 - tree the reason why all of this is
296:43 - happening at the moment is because we
296:45 - are sorting all of these Sprites by the
296:47 - time of their creation this does work
296:50 - for the background Sprites because those
296:52 - are always supposed to be in the
296:53 - background but for the actual objects
296:56 - like the trees and the rocks and the
296:58 - pillars we can't rely on that logic
297:01 - anymore or in other words in our case
297:03 - the player since we are creating this
297:05 - one last is always going to be on top of
297:08 - everything else but sometimes we want
297:10 - the player to be behind other things and
297:13 - to make all of this a bit more visible
297:15 - when we are creating the player at the
297:19 - moment the hitbox covers the entire
297:21 - width of the surface this is not what we
297:24 - actually want we do want to have some
297:26 - vertical
297:27 - overlaps to get those let's change the
297:31 - inflate method for the height to -30 if
297:34 - I now run main. Pi I can let's try this
297:38 - one I can move on top of a tree or I can
297:42 - do something like this where the player
297:44 - is slightly in front of that palm tree
297:47 - this is still not that much of an effect
297:49 - so let's go with 60 here as well if I
297:53 - now run this again and let's get the
297:55 - proper effect that we want if I'm in
297:57 - front of a pillar you can see that the
297:59 - player's overlapping so it looks like
298:01 - the player is actually in front of it
298:03 - which is the effect that we
298:07 - want however if we are behind it then
298:09 - the effect bre breaks really really fast
298:12 - so how can we get that effect and
298:14 - basically you want to sort all of the
298:16 - Sprites by the center white
298:18 - position which means for the tree we
298:22 - always have one Center position roughly
298:25 - here and then if a Sprite has a lower
298:28 - Center y position for example for this
298:30 - player let's put some values on it this
298:32 - could be a center y of 100 while the
298:36 - tree has a center white position of 150
298:40 - since 100 is the smaller value the
298:42 - player should be drawn
298:43 - behind however then for these other
298:46 - Sprites we're getting a center y value
298:49 - of 200 and since that value is greater
298:53 - than 150 the player should be drawn on
298:55 - top with that system we are avoiding
298:59 - this
299:00 - situation and implementing all of this
299:02 - is actually really simple you are simply
299:04 - going to need a sord method and I think
299:07 - you could figure this one out on your
299:08 - own so I want you guys to implement the
299:10 - Y sort system or in other words use the
299:13 - sort method to sort all of the Sprites
299:16 - when they are drawn by their Center
299:17 - White position pause the video now and
299:20 - see how far you get and don't worry if
299:22 - you can't figure this one out on your
299:23 - own it does get a bit more
299:27 - advanced back in the code I want to look
299:30 - at the groups because we are drawing all
299:32 - of the Sprites inside of this four
299:34 - Sprite in self a loop and we want to
299:37 - sort all of the Sprites which means this
299:39 - self needs to be inside of sorted but
299:43 - this at the moment is not going to
299:46 - run because we cannot compare different
299:49 - Sprites they are simply too complex to
299:52 - get around that we have to set a custom
299:55 - key and for that key we will need a
299:57 - Lambda function with one parameter which
300:00 - I usually call Sprite after that we
300:03 - simply need Sprite do Rec do Center y if
300:07 - I now run M note Pi we are getting
300:10 - something really really strange the
300:12 - issue now is that we are sorting all of
300:14 - the Sprites via the center wi position
300:17 - and don't worry I'm going to explain
300:18 - this line in just a second first of all
300:21 - though let me hide the background
300:23 - Sprites I can simply comment them
300:26 - out and now this is working a bit better
300:30 - and if I look at this pillar now the
300:33 - player is in front of it and if the
300:34 - player is behind it the player is
300:36 - actually behind it and all that is
300:39 - happening now is that we are always
300:40 - comparing the center position of the
300:42 - player with the center position of the
300:46 - Sprite whichever is greater will be
300:48 - drawn later and this is dynamic at the
300:51 - moment the center wi position of the
300:53 - player is below the Sprite and now it's
300:56 - on top hence the player will be drawn on
300:58 - top this system works for all of the
301:01 - Sprites so if we're going to this pillar
301:03 - you can see it is now behind the
301:06 - tree which does look a lot better if we
301:09 - we add all of the Sprites they mess this
301:12 - thing up quite a bit because they are
301:14 - also included in the
301:16 - system or in other words we have to make
301:18 - sure that we are excluding the ground
301:20 - Sprites from the Sorting logic first of
301:23 - all though let's talk about the sorted
301:26 - method basically what it does is it
301:29 - looks at some kind of list in our case
301:32 - that is self or a list of all of the
301:34 - Sprites inside of this group and then it
301:37 - goes through every single one
301:39 - individually
301:40 - and it wants to sort all of these values
301:42 - from the lowest to the highest value but
301:44 - that's not possible at the moment
301:46 - because if you have five different
301:48 - Sprites it doesn't know how to sort them
301:50 - and for that we have the key essentially
301:52 - sorted puts every single Sprite inside
301:56 - of this Lambda function and then via
301:58 - this Lambda function we are extracting
302:01 - one value from the Sprites which is
302:03 - returned automatically and that way we
302:06 - are getting a value that can be sorted
302:08 - the center wi position of all of the
302:10 - Sprites if you worked a little bit with
302:13 - a sorted method it should be fairly
302:15 - straightforward although if you haven't
302:17 - this might be a bit confusing so
302:18 - definitely experiment with this just a
302:21 - bit anyway to make the system work
302:23 - properly we have to exclude all of these
302:27 - Sprites for that I'm going to give them
302:30 - another attribute self. ground and this
302:33 - one is going to be
302:35 - true after that when we are drawing
302:37 - everything I want to get the ground
302:41 - Sprites and then let's call it the
302:43 - object uncore
302:45 - Sprites to get the ground Sprites I want
302:48 - to use list
302:49 - comprehension with Sprite for sprite in
302:54 - self but I only want to get a Sprite if
302:57 - they have the grounds
303:00 - attribute which means if has attribute I
303:04 - want to look at the
303:05 - Sprite and the attribute ground for the
303:08 - object Sprites I simply want to get all
303:11 - of the other Sprites which means if not
303:14 - has attribute and then Sprite and ground
303:18 - after that we want to go through both of
303:20 - these lists which we can do with another
303:23 - for Loop or layer in the list round
303:26 - Sprites and object Sprites and the order
303:30 - here is really important inside of a for
303:32 - Loop you always start with the first
303:34 - item then you go to the second one and
303:36 - so
303:37 - on and in our case we always want to
303:40 - start with the ground Sprites after we
303:43 - have that I want to do the for Loop for
303:45 - the actual Sprite drawing and then
303:47 - instead of self I want to get the layer
303:51 - if I now run main. Pi again we have the
303:54 - background always in the background and
303:57 - the logic for the Sorting still works
304:00 - just fine so the player can be behind a
304:02 - tree and in front of a tree this would
304:06 - also work on a pillar so there we have
304:08 - both sides and everything else still
304:10 - works just fine so I am very happy with
304:14 - that although I feel like inside of the
304:18 - player we could subtract an even larger
304:20 - number let's say minus 990 if I now run
304:24 - this again we should be getting a much
304:27 - greater overlap and we do this is
304:29 - actually much much nicer so quite happy
304:33 - with that now the game is feeling much
304:36 - more threedimensional and on top of that
304:38 - we have a proper camera so with that we
304:41 - have another really important part of
304:42 - the game next up we have to work on the
304:45 - proper animations of the
304:47 - player with that it looks like the
304:50 - player is actually walking
304:51 - around now we have already seen basic
304:55 - animations and we are going to keep the
304:57 - basic logic or in other words we're
305:00 - going to import images and then update
305:02 - self. image inside of a
305:04 - Sprite however we need to add State
305:07 - Management for example if if the player
305:10 - is moving to the right then we want to
305:11 - play the right animation frames on top
305:14 - of that if the player stops moving then
305:16 - we want to stop the animation and I
305:19 - think looking at the project folder is
305:21 - going to help a bit here if we go to
305:23 - images and the player there we have the
305:26 - four different states for example if I
305:29 - click on right we have four frames with
305:31 - the player walking to the right and in
305:33 - practice for self. frames we're going to
305:36 - have a dictionary where we have a state
305:38 - and then the value is a list of surfaces
305:41 - the states could be left right up and
305:43 - down after we have that inside of
305:45 - animate we have to get the state first
305:48 - and then we updating self. image with
305:50 - the
305:51 - surfaces first of all for that though we
305:54 - have to do a couple of imports and for
305:56 - that we have an issue because for the
305:59 - player we have to import quite a few
306:01 - things so for each folder we have four
306:04 - different surfaces and that we want to
306:06 - import all at
306:08 - once and want to avoid importing all of
306:11 - this manually back in the code I want to
306:14 - work inside of player. piy and let me
306:17 - minimize
306:18 - everything there we go to get started we
306:22 - want to import all of the surfaces for
306:24 - the player and that I want to do in a
306:26 - separate method let's call it load
306:30 - images no need for custom parameters and
306:33 - in there we want to create self. frames
306:37 - which is going to be a dictionary with
306:39 - four key value pairs we have the left
306:43 - State and the associated value for now
306:45 - is going to be an empty list this we
306:48 - want to duplicate three times because
306:52 - the other states are right then we have
306:56 - up and we have down really important at
307:00 - this point the names of these Keys have
307:02 - to match the folders inside of the
307:06 - player because in just a second we are
307:08 - going to use them for the path
307:11 - essentially we want to look at the
307:13 - player folder and then go over all of
307:15 - the sub folders for that we will need
307:18 - another python method that so far we
307:21 - haven't seen yet or rather you have seen
307:24 - it but I didn't talk about it if you go
307:26 - to settings there we have from OS import
307:29 - Walk and Walk is allowing you to well
307:32 - walk through a folder the way you're
307:34 - using walk is you call Walk and then you
307:37 - have to insert a file path which we are
307:40 - also going to do via the join method I
307:42 - want to go to images and then to the
307:46 - player after we have that I want to
307:49 - print the result although for that to
307:52 - work we have to call the load images
307:56 - method which we need to do before we are
307:58 - creating an image self. load images and
308:03 - now let's run
308:05 - main.py and we are getting a generator
308:08 - object not particularly useful but what
308:11 - we can do is to wrap all of this inside
308:15 - of a list function that way we can see
308:18 - the content let's try it again and there
308:21 - you get a list with a whole bunch of
308:24 - information I think to see all of this a
308:26 - bit better inside of player let's put
308:29 - all of this into a for Loop or in other
308:32 - words I want to cut out the walk method
308:34 - and then do for info in walk inside of
308:39 - that we are going to print info if I now
308:42 - run
308:43 - m.p we are getting something much more
308:46 - readable we are getting five tbil
308:49 - returned and the first value that we are
308:51 - getting returned is just a little bit
308:54 - different compared to the other values
308:57 - although generally you always getting
309:00 - three values returned the first one is
309:03 - the folder path you are currently in the
309:05 - second value is all of the sub folders
309:09 - and the final value are the file names
309:12 - so basically what is happening here is
309:14 - the first entry that we are getting is
309:17 - the parent folder or images and player
309:19 - in there we have to sub folders down
309:21 - left right and up and no other actual
309:24 - files like pgs for example after we have
309:28 - that we are going through all of the
309:30 - subfolders which means we have down left
309:33 - right and up in all of those folders we
309:36 - don't have any subfolder which means the
309:39 - second value is an empty
309:41 - list however the third value is going to
309:44 - be all of the PNG files in this
309:47 - folder although I should be specific
309:50 - here we are not getting an actual file
309:52 - we are simply getting the name of one so
309:55 - how can we use that to actually import
309:57 - all of the data and first of all we know
310:00 - that we are always getting three values
310:02 - returned we are getting the folder PA we
310:06 - are getting the subfolders
310:09 - and finally we're getting the file
310:12 - uncore names and in our case we only
310:15 - want to look at the folders with actual
310:17 - file names which means if file names
310:21 - that way we are ignoring the parent
310:23 - folder or in other words we are looking
310:26 - at down left right and
310:28 - up if that is the case I want to look at
310:31 - all of the individual file names for
310:34 - file uncore name in file names
310:39 - if I print that file name and run
310:43 - main.py you can see that we are getting
310:46 - zero PNG one PNG and so
310:49 - on those are all of the file names and
310:53 - if you combine that with the file path
310:55 - you can get the full underscore path for
311:00 - which we can use the join method once
311:02 - again I want to combine the folder path
311:05 - with the file name the return value if
311:08 - we approve printing full path inside of
311:11 - main.py is going to be the proper path
311:13 - to all of these files and that we can
311:17 - use to import a surface all we need is
311:20 - py game. image. load along with the full
311:24 - path and then convertor Alpha that would
311:28 - be giving us a surface but so far this
311:31 - isn't useful because we have to get the
311:33 - surface into the appropriate list so how
311:37 - can we combine this dictionary with this
311:39 - this for Loop and well we simply need
311:42 - another for Loop for state in
311:45 - self.
311:47 - rams. keys and as a reminder the keys of
311:51 - the dictionary are going to be the
311:52 - states of the player left for example is
311:55 - the left Running
311:57 - Animation after we have that I can
312:00 - indent the inner for Loop and then
312:03 - update the join method we want to go to
312:06 - images player and then get this state
312:09 - the one that we getting from the
312:10 - dictionary once we have that we can get
312:14 - self. frames along with the state and
312:18 - then aend the surface to the
312:21 - list at the end of all of this I can
312:24 - print self. frames and if I run the game
312:30 - we are getting a
312:32 - dictionary where we have a state for
312:35 - example left and then the associated
312:37 - value is a list with a whole bunch of
312:40 - surfaces that is all we need for the
312:42 - import although sometimes you do want to
312:45 - be a bit careful here when you are going
312:47 - through the file names you are not
312:49 - guaranteed to have them sorted which is
312:52 - really important for an animation or in
312:54 - other words when you're looking at these
312:56 - animations let's say for right again we
312:59 - always want to start on zero then go to
313:01 - one then two then three and then so on
313:04 - you really want to make sure that these
313:06 - are sorted from the lowest to the
313:08 - highest value if that isn't the case
313:10 - you're going to get some really weird
313:12 - Behavior fortunately in our case we know
313:15 - how to sort things so when we getting
313:17 - these file names we want to sort them
313:21 - for which once again we are going to
313:23 - need a key because remember inside of
313:26 - file name we getting something like the
313:28 - string
313:30 - z.png and we want to extract the Zero
313:33 - from
313:34 - that which
313:37 - means for the key we want to have a
313:39 - Lambda function with a name and on this
313:44 - name we want to split it wherever we
313:47 - have a
313:49 - DOT that way we are separating the
313:51 - actual file name from the file ending
313:54 - and we only care about the name so index
313:57 - zero all of this we want to convert to
314:01 - an
314:02 - integer that way the string one or
314:04 - string two would become an actual number
314:06 - that can be sorted
314:09 - now the result in my case is not going
314:10 - to be visible but it is a good Safeguard
314:13 - so I would always recommend to include
314:16 - it anyway with that we have covered the
314:20 - import next up then we can actually
314:23 - create an image for that though we will
314:26 - need self. State and we will need self.
314:31 - frame uncore
314:33 - index the state for now can simply be
314:36 - down and the frame index is going to be
314:38 - zero
314:39 - finally then we can create let's do it
314:43 - right before the update method Define
314:46 - animate with self and Delta time there
314:49 - are two things we have to do in here
314:51 - number one we have to get this state
314:54 - number two is the actual
314:57 - animation and let's start with the basic
314:59 - animation I want self. frame index plus
315:03 - equal some kind of Animation speed let's
315:06 - say five multipli with Delta time
315:09 - after that self. image is going to be
315:13 - self. frames then we will need self.
315:17 - State and on that we can call integer
315:20 - self. frame index with modulus of length
315:26 - and self do rames with the same self do
315:31 - state that should give us a very basic
315:34 - animation although we have to make sure
315:36 - that we are actually calling self.
315:38 - animate with Delta time if I now run
315:41 - may. Pi we're getting a down walking
315:44 - animation all we have to do now is
315:46 - update self. state to get a different
315:48 - kind of animation for example if I set
315:51 - the starting state to right and run this
315:56 - again now the player is walking to the
315:58 - right for that we have to cover this
316:01 - state the way you want to think about it
316:04 - is how do we know if the player is
316:06 - walking to the right and in my case I
316:08 - know that from the direction so if self.
316:11 - direction dox is greater than zero we
316:13 - know the player is walking to the right
316:16 - or rather the way I am approaching this
316:18 - is if self. direction dox is different
316:22 - from zero then I want to get self. State
316:27 - and set it to right if self. direction
316:31 - dox is greater than zero if that is not
316:35 - the case else it should be left with
316:39 - that I can go right I can go left and we
316:43 - get the proper animation that is looking
316:45 - pretty good the same thing we can also
316:48 - do for the vertical movement I simply
316:50 - want to duplicate those lines and then
316:52 - check for self. direction doy and self.
316:56 - state is going to be down if self.
316:59 - Direction doy is greater than zero if
317:02 - that is not the case we are going
317:04 - up let's TR this again and now I can go
317:08 - in all all four
317:10 - directions that being said there's one
317:12 - limitation at the moment that is that
317:14 - the player never stops walking so even
317:16 - without any keyboard input the player is
317:18 - walking to the right and if I go around
317:21 - and stop moving the player keeps on
317:24 - walking and fixing that is going to be
317:27 - your exercise I want you guys to only
317:30 - display the first animation frame if the
317:32 - player doesn't move really important
317:35 - here keep the current Direction so if
317:38 - the player has has moving to the right
317:40 - and then stops the player should still
317:43 - face to the right but not animate
317:45 - anymore pause the video now and see if
317:48 - you can figure this one out on your
317:52 - own all righty let's try together now
317:55 - and the way I started is that we know we
317:58 - only want to update the animation if the
318:00 - player is moving or in other words frame
318:02 - index should only change if we have a
318:05 - direction which means instead of adding
318:08 - some animation speed and Delta time I
318:10 - want to get self. frame index plus 5 *
318:16 - Delta time so far no change but then we
318:19 - can add an if statement that we only
318:21 - want to do all of that if self.
318:23 - direction is the case if that is not the
318:26 - case else frame index should always be
318:30 - zero that is actually all we needed I
318:33 - can now walk around and if I stop moving
318:35 - the player doesn't animate
318:37 - anymore and this works pretty well and
318:41 - by now our player is actually becoming a
318:43 - fairly complex class so we have 65 lines
318:46 - of code and we are doing quite a few
318:48 - different things but fundamentally for
318:51 - example for animate there isn't really
318:53 - anything too complex in here we are
318:56 - simply checking if the player's walking
318:58 - left or right then we are looking at the
319:00 - frame index and updating it if the
319:02 - player is moving or setting it to zero
319:04 - if he is not finally we are updating the
319:07 - image with the frame frames the state
319:10 - and then the frame
319:11 - index I hope none of this is too
319:14 - complicated I suppose the one slightly
319:16 - challenging part is going to be the
319:18 - import so I hope it still made sense if
319:21 - you're massively confused let me know in
319:23 - the comments next up we have to add the
319:26 - gun and fundamentally this isn't going
319:29 - to be too difficult we simply have to
319:31 - float a Sprite around the player and
319:32 - then rotate it that's kind of the basic
319:35 - idea but the details can get a bit more
319:39 - difficult let's go through it one by one
319:41 - in the most basic sense the gun is just
319:43 - another Sprite that rotates around the
319:45 - player the only really difficult part is
319:48 - to get the angle or in other words we
319:50 - want to get the angle between the player
319:52 - and the
319:53 - mouse however the mouse position is
319:56 - always going to be on the display
319:57 - surface so in our case between Z and
320:00 - zero and the display width and height
320:03 - the player on the other hand isn't
320:04 - linked to those Dimensions anymore
320:06 - because of the camera as a consequence
320:10 - we would need to do one of two things we
320:12 - could either get the offset of the
320:13 - camera and include that in the
320:16 - calculations which would be possible but
320:18 - kind of a headache instead what is much
320:21 - easier is to use the fact that the
320:23 - player will always be in the center of
320:24 - the window because of that if this is
320:27 - our display surface we know that the
320:30 - player is always right in the center so
320:33 - all we need to know is what is the
320:34 - relationship to the mouse to this point
320:36 - are we up here are we here are we we
320:38 - here are we here and we always want to
320:41 - know what's the angle to the center of
320:43 - the window that is actually all we need
320:46 - to know for all of that I want to work
320:49 - inside of the Sprites minimize the other
320:54 - classes and then create another class
320:57 - called gun which also needs to be a pame
321:00 - Dos sprite. Sprite we will also need a
321:04 - thunder init method with self the play
321:08 - player and the groups I suppose to get
321:11 - started we want to have the player
321:14 - connection for that we want to store
321:16 - self. player which is going to get the
321:18 - player then we will need a distance to
321:20 - the player which I have set to 140 next
321:24 - I want to have another attribute called
321:27 - player uncore Direction which is going
321:30 - to be a vector 2 with a default
321:34 - direction of one and zero this value we
321:38 - going to update later it's basically
321:40 - going to be the direction from the gun
321:42 - to the player this will be super
321:44 - important to rotate the gun but first of
321:46 - all we have to set up the Sprite so
321:49 - Sprite set up and in there super under
321:54 - init with the
321:57 - groups besides that we want to have
321:59 - self. image and self. rectangle although
322:03 - truth be told since we want to rotate
322:06 - this image later on we also want to
322:08 - store a self. let's call it Gore
322:12 - surface this we get with py game. image.
322:16 - load I want to use the join method and
322:19 - then go to images there we have the gun
322:23 - and in that folder we have gun.png or in
322:27 - other words if I go to images there we
322:30 - have gun and there we have gun.png in
322:34 - the same folder we also have the bullet
322:36 - that one we are going to use later also
322:38 - as always do not forget convert Alpha
322:40 - then for self. image we simply want to
322:43 - get self. gun surface finally for the
322:46 - rectangle I want self. image. getet F
322:53 - rectangle in which we want to place the
322:55 - center of the gun for the position
322:58 - imagine that this is the player and the
323:00 - player Center is here from this point we
323:04 - want to go in the player Direction by
323:06 - the distance and that's place the center
323:10 - of the gun or in other words at the
323:12 - moment we want to go to the right by 100
323:16 - and 40 pixels and then place the center
323:20 - of the gun the math for that is actually
323:22 - fairly simple we first of all want to
323:24 - get self. player. rec. Center plus self.
323:29 - player Direction multiplied with self do
323:34 - distance with that we have the gun right
323:36 - next to the player that that means
323:39 - inside of main.py I am already importing
323:41 - the gun from the Sprites so that we
323:43 - don't have to do anymore besides that in
323:46 - the setup method after we have the
323:49 - player I also want to create one
323:51 - instance of the gun and store it in an
323:54 - attribute self. gun is going to be gun
323:57 - with two arguments self. player and for
324:00 - the groups self do all
324:03 - Sprites if I now Run the game we have a
324:07 - gun right next to the player that being
324:09 - said if the player runs around the gun
324:11 - doesn't update with it that we can fix
324:14 - quite easily because inside of the gun I
324:18 - want to have an update method with self
324:20 - and Delta time that being said though
324:23 - for this class we don't need Delta time
324:26 - to indicate that I'm going to add an
324:28 - underscore for now all that we want to
324:30 - do in here is self. re. Center is equal
324:35 - to self. player. re.
324:39 - Center plus self. player Direction
324:43 - multiplied with self. distance the very
324:46 - same thing that we have done just a
324:47 - second ago and I hope the logic here
324:50 - makes sense initially when we are
324:52 - getting the position for the gun we are
324:54 - placing it right next to the player but
324:56 - then we also have to check if the player
324:58 - position updates and then we are always
325:01 - placing the gun relative to the player
325:03 - that way later on WE simply have to
325:05 - change the player Direction and then we
325:07 - get a different position position
325:09 - although first of all let's try all of
325:10 - this if I now run around the gun follows
325:13 - the
325:14 - player on top of that what I can do
325:18 - inside of the gun for the direction
325:22 - let's go with zero and one with that the
325:26 - gun should be below the player so that
325:28 - is working pretty well that means next
325:31 - up I want to self get underscore
325:35 - direction that is going to be just
325:37 - another method
325:39 - get
325:42 - direction without any custom parameters
325:45 - most importantly in there we will need
325:47 - the mouse position and we will need the
325:51 - player
325:52 - position both of those are going to be
325:55 - Vector twos that will make the math a
325:57 - lot easier the mouse position we can get
326:00 - very easily pame do mouse doget position
326:04 - don't forget to call this one and this
326:06 - will return a tupo with an X and Y
326:09 - position which we can pass right into a
326:12 - pame vector 2 and then we have a vector
326:15 - for the player position you might be
326:18 - tempted to go with something like pame
326:20 - do Vector 2 and then self. player. rec.
326:24 - Center the same thing we have done
326:27 - earlier this would not work simply
326:30 - because inside of the display surface we
326:33 - have a top left position of 0 and zero
326:37 - and we can only go as far is the window
326:38 - width and window height and the mouse
326:41 - position cannot leave this area the
326:44 - smallest mouse position is going to be
326:45 - zero and Zer and the largest one in my
326:48 - case is going to be
326:51 - 1,279 and
326:53 - 719 or one pixel short of the display
326:56 - width or height that is because we start
326:58 - counting from zero but the same logic
327:01 - does not apply to the player since we
327:03 - have a camera the player could actually
327:05 - be somewhere down here with an X and by
327:08 - position of let's say 600 and
327:13 - 4,000 way below the display surface and
327:16 - we can only see the player because we
327:18 - are offsetting all of the graphics and
327:21 - this does work for the game but it would
327:23 - not work to get the angle between the
327:25 - mouse position and the actual player
327:28 - position and that we have to account for
327:31 - which in our case is fairly simple
327:33 - because we know that the player is
327:35 - always in the center of the window or in
327:37 - other words we have window width divided
327:39 - by two and
327:42 - window height divided
327:45 - two that is all we need to get the
327:47 - player position relative to the mouse
327:50 - and after we have that we simply want to
327:52 - get self. player
327:55 - Direction and set it to the mouse
327:58 - position minus the player position in
328:01 - this Vector we want to
328:04 - normalize and that is actually all we
328:06 - need I I'm not going to talk too much
328:09 - about Vector math but essentially what
328:11 - we're doing here if this is the display
328:14 - surface we have the origin point in the
328:17 - top left then we have the player in the
328:19 - center and let's say our Mouse could be
328:22 - here what we want to get with the player
328:25 - direction is this new Vector that goes
328:29 - from the player to the mouse position
328:32 - and to get that you want to get the end
328:34 - point and subtract the start point this
328:38 - is a common operation and very basic
328:40 - Vector math anyway though for now let's
328:43 - simply print self. player Direction with
328:46 - that inside of the game I can move my
328:49 - mouse around and this is working pretty
328:51 - well also you can see in the bottom left
328:54 - if I move the window just a bit to the
328:56 - side if my mouse is all the way on top
329:00 - of the
329:01 - player like this the mouse is perfectly
329:04 - on top of the player and then we get
329:06 - zero and negative 1 if I go a bit to the
329:09 - right eventually we would get one and
329:11 - zero below we would get zero and one and
329:14 - then negative 1 and zero at least
329:17 - roughly it's a bit hard to get the exact
329:19 - point but you get the idea that being
329:22 - said we also want to rotate the gun
329:25 - surface for that I want to have another
329:28 - method rotate uncore gun no need for
329:31 - custom arguments we simply want to
329:32 - create rotate gun ultimately what we
329:36 - want to do in here is self do image and
329:39 - then get high game.
329:42 - transform. road to
329:45 - zoom with self. gun surface really
329:49 - important at this point do not use self.
329:51 - image we always want to start the
329:54 - rotation from the original
329:56 - surface after that we will need some
329:58 - kind of angle and for the scale we want
330:01 - to stick to one so then how can we get
330:05 - the angle that is going to be a local
330:08 - variable and for that we want to use a
330:11 - ton 2 which we have to import all the
330:15 - way at the top I want from math import a
330:19 - ton 2 also the
330:22 - greas all right so question what is Aon
330:27 - 2 and well imagine you have a right
330:30 - angled triangle and what aon2 wants is a
330:35 - width and a height once it has those it
330:39 - is going to give you the angle of the
330:41 - triangle which is exactly what we want
330:44 - although it's going to return all of
330:46 - that in radians that we have to convert
330:48 - to degrees and for that we are importing
330:50 - degrees from the math module and by the
330:52 - way all of this is trigonometry which is
330:55 - another really important part in game
330:58 - development you at the very least want
331:00 - to know what sign cosine and tangents do
331:04 - this topic isn't too difficult and I
331:06 - guess let me know if you want a separate
331:07 - tutor tutorial on that anyway what we
331:10 - want is to call Aon 2 and then we have
331:13 - to insert the two sites with self.
331:16 - player Direction dox and self. player
331:19 - Direction
331:20 - doy all of this is going to return an
331:23 - angle but this angle is in radians while
331:26 - we need degrees for that we can use
331:28 - degrees the thing we have just imported
331:31 - to convert all of
331:33 - this and with that I can run main. pi
331:37 - and with we are getting something let me
331:39 - show my mouse actually you can see that
331:42 - the gun is rotating but it's not
331:45 - rotating in the right way to fix that we
331:48 - have to subtract 90 from the angle if I
331:51 - run that we have the gun rotating
331:55 - properly that is much better the issue
331:58 - here is that the starting point of these
331:59 - angles is simply different which we can
332:02 - account for very easily although there's
332:05 - one more issue let me actually show
332:07 - main. pi
332:08 - if my mouse is on the right side of the
332:10 - player this is working perfectly fine
332:12 - but if we are on the left side then the
332:15 - gun should be flipped around otherwise
332:18 - it's going to look a bit funny we simply
332:20 - want to check if self.
332:24 - player direction dox is greater than
332:29 - zero that means we are on the right side
332:32 - of the player if that is the case self.
332:34 - image should do this however if that is
332:38 - not the case else meaning the mouse is
332:40 - on the left side of the player then I
332:43 - still want to get a rotated image but on
332:46 - top of that self. image should also be
332:49 - py game. transform and we want to flip
332:53 - the entire thing for that we want to get
332:56 - self. image and rotate it not on the
333:00 - horizontal axis but on the vertical one
333:02 - so false and
333:04 - true I can now try all of this again and
333:07 - it's it's not going to work just yet the
333:09 - right side is working and on the left
333:11 - side we are getting some funky Behavior
333:15 - to understand this issue let's print the
333:18 - angle that we are getting and run main.
333:22 - Pi
333:23 - again if we now go to the left side you
333:26 - can now see that we are getting a
333:27 - negative value from 90 all the way to
333:32 - 270 and those values being negative is
333:35 - the entire issue because of that the gun
333:38 - is rotating in the wrong way which we
333:40 - can fix very easily we simply need the
333:42 - absolute value let's try of this again
333:46 - and now the gun is behaving just in the
333:49 - right way so this is looking really good
333:52 - that means we don't need the print
333:54 - statement anymore and we have the gun
333:57 - rotation although for the proper gun we
333:59 - are going to need a bullet that part is
334:02 - going to be your exercise what I want
334:04 - you guys to do is when the player
334:06 - presses the left Mouse button then
334:08 - launch a bullet in the direction of the
334:10 - gun on top of that the bullet should
334:13 - start at the end of the gun so it looks
334:15 - like the gun is actually firing all of
334:17 - the bullets should be reasonably
334:19 - straightforward pause the video now and
334:21 - see how far you
334:25 - get first of all we have to figure out
334:28 - where to capture the input for the mouse
334:30 - button and that we can do either in the
334:32 - game class or inside of the player I'm
334:36 - going to go with the game class because
334:38 - in here we also want to create the
334:40 - bullets in just a bit that
334:43 - means I want to create
334:45 - Define
334:47 - input with self and then check if py
334:51 - game. Mouse doget uncore pressed don't
334:56 - forget to call this one and Via this
334:57 - method we are going to get all of the
334:59 - mouse buttons although we only care
335:02 - about the left one which is the index
335:04 - zero if that is the case I want to print
335:08 - shoot for
335:09 - now after we have that inside of the run
335:12 - method before we are updating everything
335:15 - else I want to get self. input let's try
335:20 - and this is working reasonably well the
335:24 - issue is that we are checking this input
335:28 - on every single frame of the game which
335:31 - would give us way too many bullets so we
335:33 - have to moderate things quite a bit
335:36 - which we have already seen I I want to
335:37 - add another condition and self. cancore
335:42 - shoot if the if statement then triggers
335:45 - self. cancore shoot should be
335:50 - balse and we want to get self. shoot
335:53 - uncore time which we get via pame do
335:57 - time and get Pi now for that to work
336:00 - inside of Dunder in it we don't need the
336:03 - Sprites anymore but I do want to have a
336:05 - gun timer for which we have can shoot
336:09 - this one should be true by default and
336:13 - self. shoot time the default value for
336:16 - this one will be zero besides that I
336:19 - want to have a self. gun pool
336:23 - down which I have set to 100
336:26 - milliseconds or in other words in the
336:28 - game we can shoot 10 bullets per second
336:31 - perfect once we have that we will also
336:34 - need another method with the
336:38 - Gore timer for which we want to check if
336:42 - not self do can
336:45 - shoot if that is the case we basically
336:48 - want to get the current time via pame
336:52 - DOT time.get ticks and then check if the
336:57 - current time minus self. shoot time
337:02 - greater or equal to self. gun cool down
337:08 - if that is the case self do can shoot is
337:11 - going to be
337:13 - R and finally inside of the run
337:17 - method we can do that before we are
337:19 - capturing the input self. gun timer with
337:24 - that inside of the game if I hold down
337:26 - the mouse button we are still getting a
337:28 - lot of input but a lot less than before
337:32 - and if I change the gun cool down to
337:36 - something like 600 it it should be much
337:39 - more visible there you can see we get
337:41 - one shoot printing every 600
337:45 - milliseconds so that was the first part
337:48 - next up we have to figure out whenever
337:51 - we are getting this input we want to
337:53 - create a
337:54 - bullet or in other words I want to
337:57 - create an instance of a bullet class for
338:02 - which I'm going to need a surface of a
338:04 - bullet a starting position a Direction
338:08 - and then the groups for all of that I
338:11 - want to go to Sprites and then create
338:14 - all the way at the end another class
338:17 - called
338:18 - bullet once again we are creating a
338:21 - pygame Dos sprite. Sprite then we will
338:24 - need a Dunder init method with self the
338:28 - surface the position a direction and the
338:32 - groups next up we will need to call
338:34 - Super Dunder in it as the group groups
338:37 - in there and then we have to create
338:40 - self. image and self. rectangle those
338:44 - two actually fairly simple because we
338:47 - already get a Surface via the parameters
338:50 - and self. rectangle is simply going to
338:52 - be self do image do get F rectangle in
338:58 - which we are placing this Center and
339:00 - once again we are getting the value via
339:02 - the parameters so now we have to figure
339:04 - out all of the arguments the surface is
339:07 - the easier part because if you look at
339:09 - images there we have gun and the bullet
339:12 - this is what we want to
339:13 - import for that I want to create another
339:17 - method called load images for now in
339:21 - there we are only going to create a
339:24 - self. bullet
339:27 - surface which we can get via py game.
339:30 - image.
339:32 - load and then via the join method we go
339:35 - to images gun and bullet.png
339:42 - also we want to convert Alpha all of
339:45 - this once again and that's all we need
339:47 - inside of this method for now although
339:49 - in the next section we're going to reuse
339:52 - this to import all of the enemy images
339:54 - as well but for now that's not really an
339:56 - issue that being said though we do have
339:59 - to call it inside of the setup method I
340:02 - want self. load
340:05 - images with that we have a surface self
340:09 - do bullet
340:11 - surface next up we will need a position
340:15 - and for that I want to create a separate
340:18 - local variable now for the starting
340:21 - position we obviously want to start on
340:23 - the bullet itself which means self. gun.
340:26 - w. Center and then add a bit of an
340:31 - offset in the direction that we are
340:32 - currently facing which means plus self.
340:36 - gun. player
340:38 - Direction multiply it with some value
340:41 - depending on how much distance you want
340:43 - in my case I went with 50 on top of that
340:46 - for the direction of the bullet we
340:48 - simply want to reuse the gun direction
340:51 - or rather the gun player Direction
340:54 - finally for the groups I want to have a
340:56 - tuple with self. all Sprites and
340:59 - self.
341:01 - bullet Sprites a group that does not
341:04 - exist at the moment but inside of
341:07 - thunder in it I can duplicate the
341:09 - Collision Sprites and then create bullet
341:12 - uncore
341:14 - Sprites that should actually be it for
341:17 - the bullet if I now run all of this and
341:19 - let me show my mouse if I press a button
341:24 - we are getting a
341:28 - bullet we can also walk around and this
341:32 - is working pretty well that being said
341:36 - while testing this game game I realized
341:38 - that the input is a bit clunky because
341:41 - we are using the mouse input and then
341:43 - inside of the player for the input we
341:46 - are checking for the arrow keys which
341:48 - makes it kind of awkward on the keyboard
341:51 - to fix that what we can do is check
341:54 - either keys py game. kri or the keys
341:59 - along with pame do Kore D that would be
342:05 - the D key on the keyboard the same thing
342:07 - we have to do for the other side so on
342:09 - there we want to check for the a key
342:12 - then for self. direction doy when we are
342:14 - checking down I want to check for Kore s
342:19 - if we're going down
342:21 - or Kore W if we are going up and that
342:26 - should be it if I now run main.py I can
342:29 - walk around with W ASD or with the arrow
342:32 - keys we are getting the same result
342:37 - besides that the bullets also work
342:39 - perfectly fine I can even hold down the
342:41 - mouse button and we keep on creating
342:44 - bullets they do not move but that we can
342:47 - fix right now actually all we have to do
342:51 - inside of the bullet we first of all
342:53 - need a few more
342:55 - attributes I want to have self.
342:59 - Direction which we're getting from the
343:02 - direction parameter then self. speed I
343:06 - set this one to 1
343:08 - 1,200 and then we can create an update
343:11 - method with self and Delta
343:13 - time all that we really want to do in
343:15 - here is self. rec. Center plus equal
343:19 - self. direction multiplied with self.
343:23 - speed multiplied with Delta
343:26 - time with that if I shoot a bullet the
343:29 - bullet actually moves in the right
343:32 - direction so this is looking pretty good
343:37 - however at this point we do have to be
343:39 - careful because these bullets never
343:41 - disappear and if we can create 10
343:43 - bullets per second we very quickly end
343:46 - up with way too many bullets so there
343:48 - should be some way to get rid of these
343:51 - bullets you could either delete them
343:53 - when they collide with an obstacle or
343:55 - you could add a timer I'm going to go
343:57 - with a
343:58 - timer which means I want to get self dot
344:01 - let's call it spawn time which is going
344:05 - to be py game. time. get ticks on top of
344:09 - that I want to have self. life
344:13 - time I want these bullets to live for
344:16 - one second after that inside of the
344:19 - update method if py
344:21 - game. time. get ticks minus self. spawn
344:27 - time is greater or equal to self.
344:30 - Lifetime then we want to kill the Sprite
344:34 - to make sure that this is working inside
344:37 - of the run method we can do this one all
344:39 - the way at the end I want to print self.
344:43 - bullet Sprites if you simply print a
344:46 - group you get the number of Sprites
344:48 - inside of it or if I run all of this I
344:51 - can press space and we are getting the
344:53 - number of Sprites and there you can see
344:56 - the bullets work just as before but we
345:00 - at the most get two
345:03 - Sprites so that part is actually working
345:05 - pretty well although I really ized the
345:08 - reason why we are getting so few bullets
345:09 - is because the gun cool down is 600 this
345:13 - should only be 100 let's rise again and
345:17 - now we're getting a whole bunch more
345:18 - bullets but only 10 at the
345:21 - most which is a really good thing for
345:24 - performance but anyway with that we have
345:27 - the bullet mechanic which gets us very
345:30 - close to a complete game the only major
345:33 - thing that we now have to add are the
345:34 - enemies that's going to be the next
345:36 - section we are nearly done with the game
345:38 - the last major part that we have to
345:40 - cover is how to add the enemies for that
345:43 - we have to go through a couple of steps
345:45 - first of all we will need a timer that
345:47 - triggers twice per second and every time
345:51 - it triggers we want to create one
345:53 - instance of the enemy and that enemy
345:55 - needs to do a couple of things it always
345:58 - needs to walk towards the player and it
346:00 - needs to be able to collide with objects
346:03 - on top of that it should always play a
346:05 - walking animation and for that we will
346:08 - also need to import the animation frames
346:11 - I think at this point all of this is
346:13 - reasonably straightforward as a
346:14 - consequence all of this could be an
346:16 - exercise so try to figure this one out
346:19 - on your own and see how far you
346:24 - get back inside of the game I want to
346:27 - work inside of Sprites and create
346:30 - another class called
346:32 - enemy which as before is going to be
346:35 - pygame dos sprite.
346:38 - Sprite then for the dunder init method I
346:42 - want to get a starting position a bunch
346:45 - of frames the groups the player and the
346:49 - Collision uncore Sprites after we have
346:53 - that super Dunder
346:56 - init with the groups also I want to
346:59 - store the player as an attribute I.E
347:02 - self. player is the player that player
347:04 - by the way we need to get the proper
347:06 - direction of this enemy also I can see
347:09 - an issue right away I have a typo inside
347:12 - of pame after we have that we want to
347:15 - create the image for that at the moment
347:19 - we have an issue because we don't have a
347:21 - single surface or rather later on we are
347:23 - not going to have a single surface
347:25 - instead we have a whole bunch of frames
347:28 - the walking animations we are importing
347:31 - if you look at the images folder there
347:34 - we have enemies and for example for the
347:35 - bat we have 012 and
347:38 - 3.png which are all one part of the
347:41 - walking animation or I guess for the bad
347:44 - the flying animation to account for that
347:47 - I want to create self. frames and self.
347:51 - frame uncore index which is going to get
347:54 - frames and zero after that we can create
347:58 - self. images which is going to be self.
348:01 - frames and then we use self. frame index
348:05 - for the indexing also what we could be
348:07 - setting in here is self. animation
348:10 - uncore
348:12 - speed I went with six for this one next
348:15 - up we have to figure out the rectangle
348:18 - which ultimately is going to be self.
348:20 - rectangle self. image. getorf rectangle
348:25 - we want to place the center and the
348:27 - value will be the position from the
348:29 - parameters on top of that I want to
348:31 - create self. hitbox rectangle which we
348:36 - get via self. re. inflate and I want to
348:41 - reduce the size of this by -20 and
348:45 - ne40 besides that I also want to store
348:48 - all of the Collision Sprites as an
348:50 - attribute meaning self. Collision
348:52 - Sprites is Collision Sprites nearly done
348:56 - besides that we also want to have self.
348:59 - Direction which is simply a pame do
349:02 - Vector 2 without any values and I want
349:05 - to have self do
349:07 - speed for which I want to go with
349:11 - 350 that is quite a bit next up inside
349:14 - of the game class I want to create a
349:17 - timer which we can do right below the
349:19 - gun timer we also want to have an enemy
349:23 - timer for this timer I want to use the
349:25 - event Loop which means I want to have an
349:28 - enemy event and then create py game.
349:32 - event. custom
349:35 - type after that
349:37 - p game. time.
349:41 - settimer with self. enemy event and
349:46 - 300 also I want to create one more
349:49 - attribute which is going to be the spawn
349:52 - underscore positions by default this
349:56 - will be an empty list the reason why we
349:58 - are going to need this one if you look
350:00 - at tiled we have on the entities layer
350:03 - all of the markers and at the moment we
350:06 - are only using the player one this one
350:08 - here but we also want to use all of
350:11 - these other enemy markers for a random
350:13 - starting position which basically means
350:16 - we want to place the position of all of
350:18 - these markers inside of this list that
350:21 - way we can very easily pick one of them
350:23 - to get that we want to look at the setup
350:27 - method because in there we are already
350:30 - getting all of the Markus although at
350:32 - the moment we only look at the player if
350:35 - that is not the case l
350:37 - I want to get self. spawn positions and
350:41 - then append obj dox and obj doy after we
350:46 - have that we can work inside of the
350:49 - event Loop because now we can check if
350:53 - event. type is equal to self. enemy
350:57 - event if that is the case I want to
351:00 - print spawn enemy if I now run all of
351:04 - this we are getting an attribute error
351:07 - that game object has no attribute spawn
351:10 - positions and I think I know what the
351:12 - issue here is inside of the init
351:16 - method we are running the setup method
351:18 - here but only afterwards we are creating
351:21 - the spawn positions which means when we
351:24 - are trying to append a value to the
351:26 - spawn positions this attribute doesn't
351:28 - exist at the
351:30 - moment fixing that is super easy we
351:33 - simply have to move the setup method all
351:35 - the way to the bottom and I guess while
351:37 - we are here I think it's also going to
351:39 - be a good idea to move load images right
351:42 - before with that we can create a more
351:44 - General setup section which feels a bit
351:46 - cleaner also before we are trying all of
351:49 - this I realized that I am printing the
351:52 - bullet Sprites inside of the game Loop
351:55 - if I now try all of this we're getting
351:57 - spawn enemy every few milliseconds every
352:01 - 300 milliseconds to be a bit more
352:04 - specific now that we have that
352:07 - whenever this event occurs we want to
352:09 - create an enemy for which we are going
352:12 - to need first of all a position that
352:15 - part is quite easy we want to get choice
352:17 - and self. spawn positions now choice we
352:21 - have to import all the way at the top
352:23 - from random import Rand in and
352:27 - choice next up we have to get a whole
352:31 - bunch of frames which we can't really do
352:33 - at the moment let's leave this one empty
352:35 - for now for the groups I want to have a
352:38 - tupo with self. all Sprites and self.
352:42 - enemy
352:44 - Sprites this one does not exist at the
352:46 - moment
352:48 - so I want to duplicate the bullet
352:50 - Sprites and rename this to self. enemy
352:55 - Sprites next up we need a player that is
352:58 - simply self. player and for the
353:01 - Collision Sprites we want to have self
353:02 - do Collision Sprites nearly done we are
353:05 - just going to need all of the frames and
353:08 - for that I want to work inside of load
353:10 - images because in there we want to do
353:13 - all of the
353:14 - Imports this is going to be quite
353:16 - similar compared to what we have done
353:18 - inside of the player there we have load
353:21 - images and we have used the walk method
353:24 - to walk through this folder something
353:26 - similar I do want to do although first
353:28 - of all I want to get all of the
353:31 - available folders which for the player I
353:34 - have kind of done in a janky way I
353:36 - simply created a dictionary with all of
353:38 - the folder names but this isn't
353:40 - particularly elegant because ideally I
353:43 - want to get these values dynamically
353:45 - generated which we can get via the walk
353:48 - method I can simply get join then go to
353:52 - images and the enemies and then turn all
353:56 - of this into a list on this list I want
354:01 - to get index zero or the first item if I
354:04 - print that folders and and run all of
354:07 - this we are getting name frames not
354:10 - defined that's okay for now but we are
354:12 - also
354:13 - getting this value here where we have
354:16 - the name of the folder and then a list
354:18 - of all of the subfolders this is what I
354:20 - actually want which means I going to
354:22 - have index one that way I'm getting all
354:24 - of the folder names after we have that I
354:27 - want to create self. enemy uncore frames
354:31 - which is going to be an empty dictionary
354:34 - and then for folder in
354:37 - folders in there I'm going to get a
354:39 - folder path I would be getting the
354:42 - subfolders next but those I don't care
354:44 - about so an underscore and then the file
354:46 - underscore
354:48 - names all of this in walk join we want
354:52 - to go to images then we want to go to
354:55 - the enemies and then we want to get the
354:58 - folder once we have that we can create
355:01 - self. enemy frames and create a key
355:05 - value pair the key should be the name of
355:07 - the folder and the associated value is
355:10 - simply an empty list after that for file
355:14 - underscore name in file names first of
355:19 - all we will need a full underscore path
355:22 - that we can create via the join method
355:25 - we simply want to combine the folder
355:26 - path with the file
355:29 - name and then we can create a surface or
355:33 - rather we can import a surface bya pame
355:36 - image. load with default path and
355:40 - convert Alpha finally I want to get
355:43 - self. enemy
355:46 - frames with the folder key and then a
355:50 - pend the surface nearly done the last
355:53 - thing that I want to do is to sort the
355:55 - file names so sorted method and then we
355:59 - want to use a key which is going to be a
356:03 - Lambda value with a name par parameter
356:07 - this name at the moment is something
356:08 - like
356:11 - 0.png and we want to extract the zero
356:13 - and convert it to an integer for which
356:16 - we need name do split we want to split
356:20 - this thing wherever we have a DOT and
356:22 - then pick index zero after that we want
356:26 - to turn all of this into an
356:28 - integer and with that we're getting all
356:30 - of the frames after this method I want
356:33 - to print self. enemy frames and run all
356:37 - of this now we are going to get a name
356:40 - error again because we are not using
356:42 - frames inside of the enemies but before
356:45 - that we have a larger dictionary where
356:48 - the key would be an enemy and then we
356:50 - have the walking animation that is
356:52 - actually all we need so we don't want
356:55 - the print statement
356:56 - anymore
356:58 - instead when we are creating one enemy I
357:02 - want to use the choice method to pick
357:05 - one of the en enemy animation frames
357:08 - which I can do via self. enemy frames
357:12 - and then get the values although this
357:15 - wouldn't work immediately because Choice
357:17 - cannot work with values directly what we
357:20 - need to do instead is to turn all of
357:21 - this into a list if I now run all of
357:25 - this we getting an attribute error that
357:27 - non-type object has no attribute get F
357:30 - rectangle let's have a look for that
357:32 - inside of the player I simply have a
357:35 - typo this should be self. image not
357:38 - self.
357:39 - images with that let's R off this again
357:42 - and the game doesn't crash anymore and
357:44 - we can see a whole bunch of enemies in
357:46 - random
357:47 - positions so that is working pretty well
357:51 - for these enemies now we have to do two
357:54 - things both of which are going to happen
357:57 - inside of the update method I want every
357:59 - single enemy to move along with Delta
358:03 - time and to self. animate also with with
358:06 - Delta time move we can do later because
358:09 - this one is getting a bit more complex
358:11 - but for animate we simply have to call
358:13 - self. animate with Delta time once again
358:16 - then we want to increase self. frame
358:19 - index or in other words plus equal self.
358:22 - animation speed multiplied with Delta
358:25 - time after that self. image is going to
358:28 - be self. frames with integer of self.
358:33 - frame index modulus length of self.
358:38 - frames that should give us an
358:41 - animation let's try and there we go this
358:44 - is looking pretty
358:45 - good if I find a skeleton those also
358:49 - work
358:50 - fine perfect that looks pretty good next
358:54 - up then we have to work on the Move
358:56 - method for that we need to do two
359:00 - things Define move with self and Delta
359:04 - time in there we need to do broadly two
359:08 - things we first of all want to get a
359:11 - direction and after that update the
359:15 - wrecked position really important for
359:18 - the wed position we also want to include
359:21 - the Collision logic but step by step
359:24 - first of all we want to get the
359:26 - direction for which we are going to need
359:28 - the player position and the enemy
359:32 - position or the position of this class I
359:35 - am using enemy position here to keep
359:37 - things a bit more understandable also
359:40 - both of these values should be Vector
359:41 - twos I.E P game Vector 2 and for the
359:45 - player position we simply want self.
359:48 - player. rec. center for the position of
359:52 - the enemy we also want to have a pame
359:55 - vector 2 with self. re. center and for
360:00 - self. direction we simply want to get
360:03 - the target position I.E the player
360:06 - position minus the enemy position the
360:09 - same thing we have done for the gun and
360:12 - all of this we want to normalize which
360:14 - means I want to add normalize at the end
360:16 - of all of this that way when we are
360:18 - doing the movement we can simply
360:20 - multiply the Direction with a speed and
360:22 - we always get a consistent result
360:25 - speaking of which for the basic movement
360:28 - all we want to do is self. do Center
360:31 - plus equal self. direction multipied
360:35 - with self do speed multiplied with Delta
360:39 - time with that if I run main. Pi all of
360:44 - the enemies are moving towards the
360:46 - player that is working pretty well but
360:49 - without collisions this is going to look
360:50 - just a bit silly which means we also
360:53 - want to add a Define collisions with
360:57 - self and then the
361:00 - direction now for that I am going to go
361:03 - to the player and then simply copy the
361:06 - Collision method and then we can update
361:08 - the movement although I do have to
361:11 - mention this is not elegant ideally you
361:14 - would use inheritance to create a parent
361:17 - class for the enemies and the player
361:21 - that has the Collision method that way
361:23 - both of them can inherit the same method
361:25 - so we don't have to copy paste things we
361:27 - are going to do something like that
361:29 - later on although for now I want to keep
361:31 - things simple anyway I first of all want
361:34 - to split the movement into horror
361:35 - izontal and vertical Parts which means
361:39 - we want to update self. rec. Center X by
361:41 - self. Direction dox multiplied with
361:44 - self. speed and Delta time then for the
361:48 - vertical Movement self. Center y plus
361:50 - self. direction. y multiply it with
361:53 - speed and Delta time now you could also
361:56 - go and this is what we have done for the
361:58 - player you could go with X and
362:01 - Y I suppose we could actually do that
362:04 - self. r.x and self. r.y that just feels
362:08 - a bit cleaner also we are not using the
362:10 - hitbox yet but that's going to come in a
362:13 - second now after we doing the horizontal
362:15 - movement I want to call self. Collision
362:18 - with the horizontal
362:21 - collisions this I can then duplicate
362:23 - because after we're doing the vertical
362:25 - Movement we want to check the vertical
362:27 - collisions if I now try to run main. Pi
362:31 - this is not
362:33 - working and I think I know why in inside
362:36 - of collisions we are using the hitbox
362:38 - rectangle but when we are doing the
362:40 - movement we are using the rectangle
362:42 - which isn't ideal so instead of the
362:45 - rectangle I want to use the hitbox
362:48 - rectangle although for that to work then
362:51 - at the end of The Movement we have to
362:52 - set self. re. Center to self. hitbox
362:57 - rect do center with that we should get
363:01 - the hitboxes and the proper collisions
363:04 - let's go up here and and we should be
363:06 - able to see that monsters are also
363:09 - constrained by the environment so that
363:12 - is working really
363:14 - well and with that we have the
363:24 - enemies we are nearly done with the
363:26 - second game we just have to add some
363:28 - minor bits to finish up the entire
363:30 - project there are two major things that
363:32 - I want to work on number one are the
363:34 - collisions so so that if an enemy gets
363:37 - hit it disappears and if the player gets
363:39 - hit the game ends on top of that we need
363:42 - to add some audio which should be fairly
363:44 - straightforward in fact this could be an
363:47 - exercise right away I want you guys to
363:49 - add the collisions between the bullets
363:51 - and the Monsters if a bullet hits a
363:53 - monster then kill that monster Sprite on
363:56 - top of that add all of the
364:01 - sounds I want to add another method
364:04 - let's do it right before the run method
364:07 - Define bullet uncore
364:11 - Collision no need for custom parameters
364:14 - and in there we need to check if we have
364:16 - bullets in the first place for that
364:19 - inside of thunder in it we know that we
364:22 - have a bullet Sprites
364:24 - group that we can use simply by checking
364:27 - if self. bullet
364:30 - Sprites if we don't have bullets there's
364:33 - no reason to check any of these
364:34 - collisions if however we do have some
364:37 - then we want to check for bullet in.
364:41 - bullet Sprites next up we want to check
364:44 - the Collision uncore Sprites which we
364:49 - get via pame dos sprite. Sprite
364:53 - Collide in which we need a single Sprite
364:56 - a group of Sprites and then do kill for
365:00 - now the single Sprite is going to be the
365:04 - bullet the group is going to be self.
365:07 - enemy Sprites and to kill is going to be
365:10 - true although this we are going to
365:11 - change later on after that inside of the
365:15 - run
365:16 - method when we are updating the game I
365:19 - want to call self. bullet Collision I
365:23 - can now run all of this and if a bullet
365:26 - hits an enemy the enemy disappears so
365:29 - that is looking pretty good that is
365:32 - looking quite nice so now we can refine
365:35 - all of this first of all what we can do
365:38 - is use a Mas for the Collision via pame
365:41 - dos
365:42 - sprite. light mask that way we are using
365:47 - a mask for the collisions meaning we
365:48 - have a lot more Precision that being
365:51 - said most of the objects that we are
365:53 - working with for example the bullet or
365:55 - the bats are fairly rectangular so this
365:59 - isn't going to make a massive change
366:01 - what is going to be much more noticeable
366:03 - is that I want to have a delay between
366:05 - the bullet hit and the Sprite death for
366:08 - that I want to set do kill to false and
366:11 - after that check if we have Collision
366:14 - Sprites if that is the case I want to go
366:17 - through all of them I.E for sprite in
366:20 - Collision
366:22 - Sprites and then call a method sprite.
366:26 - destroy this destroy method does not
366:29 - exist at the moment but we can create it
366:31 - inside of Sprites the enemy class I want
366:34 - to have a method called destroy inside
366:39 - of this method there are fundamentally
366:42 - two things that I want to do number one
366:44 - I want to start a timer once this timer
366:48 - runs out we are actually destroying the
366:50 - Sprite besides that I want to change the
366:55 - image once its Sprite has been hit we
366:58 - want to change the entire thing to a
367:00 - white surface that's the part we can
367:02 - work on right away actually for that I
367:04 - want to create a new Surface via py
367:07 - game. mask. from surface and then use
367:11 - self. frames and
367:14 - zero in other words the first frame of
367:17 - the walking animation this I want to
367:18 - turn right away back to a surface that
367:23 - way if we are overwriting self. image
367:27 - with the surface we can see the mask or
367:29 - in other words we can see a silhouette
367:31 - that is black and white at the moment
367:34 - this is only going to run for a single
367:36 - frame so it wouldn't be particularly
367:38 - visible but what we can also do is set
367:42 - self. deore time to py game. time.get Pi
367:49 - and to use this attribute I want to work
367:51 - inside of the dander init method and add
367:54 - a timer section with self. death time
367:58 - this one can be Zero by default and then
368:01 - self. deore
368:04 - duration I said this one to 400
368:07 - milliseconds once we have that inside of
368:10 - the update method I only want the enemy
368:13 - to move and animate if self. death time
368:18 - is equal to zero that can only be the
368:22 - case if the enemy has not been hit by a
368:24 - bullet once it has been hit however we
368:26 - are overwriting this surface that way if
368:30 - I run main. pi and we hit an enemy the
368:33 - enemy stops moving and we get this
368:35 - silhouette so that part is working
368:37 - pretty
368:39 - well that being said though I only want
368:41 - to get the white part which we can get
368:44 - via surface and setor color
368:48 - key that we are going to use to remove
368:51 - all of the black pixels via that I can
368:55 - shoot the enemies and we only get the
368:59 - white
369:00 - outline that works pretty
369:03 - well next up then I to create a deore
369:08 - timer that is going to check if High
369:12 - game. time. get Pi or in other words the
369:16 - current
369:17 - time from that we want to subtract self
369:20 - do death time and if the resulting value
369:24 - is greater or equal to self dode
369:27 - duration then we want to kill this
369:31 - Sprite and to call this death timer we
369:33 - want to check if the death time is
369:35 - different from zero or in other words
369:38 - else self do death timer inside of the
369:43 - game I can now hit the enemies and they
369:47 - do disappear after a short amount of
369:49 - time so that looks pretty
369:52 - good on top of that the last thing that
369:55 - we need for this Collision is once a
369:57 - bullet hits an enemy the bullet should
369:59 - also disappear which we can do very
370:02 - easily if there are Collision Sprites I
370:05 - want to kill the bullet let's try this
370:09 - one and if I had a bat or any of the
370:12 - enemies the bullet also disappears a bit
370:14 - hard to see but you get the idea anyway
370:17 - with that we have the bullet Collision
370:19 - besides that I want to have another
370:22 - method with layer uncore Collision all
370:26 - we want to check in there is py game.
370:29 - Sprite do Sprite cite with self. player
370:34 - self do
370:35 - enemy Sprites and for du kill I want to
370:39 - go with fals although this value doesn't
370:42 - really matter all that we want to do is
370:45 - check if there's any return value and if
370:47 - that is the case self. running should be
370:54 - false finally to make all of this work
370:56 - besides the bullet Collision we also
370:58 - want to have self. layer Collision now
371:02 - truth be told you could combine these
371:04 - two Collision methods since for both of
371:08 - them we are not doing very much but I
371:11 - think it's a bit better organized if you
371:13 - have them separately anyway let's try
371:17 - and if I now collide with an enemy the
371:19 - game simply
371:20 - ends I suppose what we should also be
371:23 - doing is use a mask with pame do sprite.
371:29 - Collide mask this part is actually
371:33 - really important because remember the
371:35 - surface of the player is actually really
371:38 - large which means that the Collision
371:40 - would actually be really easily
371:41 - triggered but if we do include
371:44 - it you can see that we have to hit an
371:47 - enemy straight away now for the
371:49 - balancing of the game I didn't spend too
371:52 - much time on it so it is very very easy
371:55 - to die and you might want to include a
371:57 - health mechanic but that you can do in
371:59 - your own time the last thing that I want
372:01 - to add are the sounds and then we are
372:03 - done with this project for the that I
372:06 - want to work inside of Dunder innit and
372:11 - add an audio
372:14 - section we don't really have that many
372:16 - audio files if you look at the audio
372:18 - folder we have an impact sound a music
372:20 - sound and a shoot sound to import all of
372:23 - those we want to have self. shotor sound
372:27 - which we get with pame do mixer do
372:32 - sound then we will use the join method
372:35 - to go to
372:37 - audio and then shoot. wav for which I
372:42 - also want to set the volume right away
372:45 - shoot sound. set volume with
372:50 - 0.4 besides that we have self. impactor
372:54 - sound which we can get with the same
372:56 - method that we have used for the shoot
372:58 - sound the only thing that we have to
373:00 - change is that this is impact.
373:03 - OGG finally we want to have self. music
373:08 - one more time we will need py game.
373:11 - mixer. sound go to audio and then import
373:16 - music. wav and I realized there's a typo
373:20 - this should be OG cool that covers all
373:23 - of the Imports if I now Run the game it
373:26 - doesn't crash so that looks pretty good
373:30 - meaning we just have to figure out when
373:31 - to play these sounds and then we are
373:33 - good to go both for the shoot sound I
373:37 - want to check the input because in here
373:40 - we are creating a bullet which means I
373:43 - can get self do shoot sound and play the
373:46 - entire
373:48 - thing that sounds pretty
373:51 - good cool after that we have the impact
373:55 - sound and this we check when we have a
373:58 - bullet collision between the enemies and
374:01 - the
374:01 - bullets or in other words if there are
374:04 - Collision Sprite
374:05 - we want
374:07 - self. impact sound.
374:11 - playay that should be all we need if I
374:14 - now hit an
374:19 - enemy we're getting a
374:21 - sound finally we will need the
374:23 - background music and that part is the
374:26 - easiest because the music we want to
374:28 - play right away self. music. playay and
374:33 - for Loops we want to have negative 1 so
374:36 - this one plays forever and I think for
374:38 - the background music we do want to set
374:40 - the volume a bit lower self. music. set
374:44 - volume to 0 let's say
374:47 - 0.3 and with
374:58 - that that is working pretty well now
375:01 - this game isn't terribly well balanced
375:03 - so what you could be doing for example
375:06 - when you are in the Sprites you could
375:08 - update the enemy movement speed the
375:11 - lower this one is the easier the game
375:12 - will become you could also work on the
375:15 - timer if enemies spawn less often then
375:18 - they are easier to handle on top of that
375:21 - you could also add a health mechanic for
375:22 - the player so that we could be hit
375:24 - multiple times without dying but in my
375:27 - case I'm going to call it a day at this
375:28 - point for the next project we are going
375:31 - to make pong now the overall game isn't
375:34 - going to be too different difficult but
375:35 - there are three major things that I want
375:37 - to focus on the most important one are
375:40 - collisions between moving objects we
375:43 - have already seen some basic logic for
375:45 - that and we are going to refine this
375:47 - quite a bit and for the collisions
375:49 - between the ball and the pedal this kind
375:51 - of logic is fundamental besides that I
375:54 - want to use a lot more inheritance for
375:57 - example the player and the opponent are
375:59 - very very similar so we can use
376:01 - inheritance to make our code much more
376:03 - efficient and elegant
376:05 - finally I want to add a saving mechanic
376:08 - so that when we are restarting the game
376:10 - the score is sticking around however
376:12 - before we can work on any of these
376:14 - topics we have to start with the setup
376:17 - and this can be an exercise right away I
376:19 - want you guys to do a whole bunch of
376:21 - things number one create a basic game
376:23 - Loop and the player then get the player
376:26 - input and then move it up and down while
376:29 - constraining it to the
376:31 - screen also create a ball that bounces
376:33 - around the window without any collisions
376:36 - yet and finally for all of this use the
376:38 - info from
376:39 - settings.py speaking of which here is
376:42 - the project folder and we only have two
376:45 - subfolders code and data data actually
376:48 - at the moment is entirely empty and
376:51 - inside of the code we have main.py and
376:54 - settings.py let's have a look at those
376:56 - two here we are and inside of main.py we
376:59 - are simply importing everything from
377:01 - settings in settings we have a bit more
377:04 - we are importing py game and then we are
377:07 - importing the join method besides that
377:09 - we have window width and window height
377:11 - and then finally we have a bunch of
377:14 - dictionaries for example in there we
377:17 - have the size of the padal this can be
377:19 - both the player and the opponent and the
377:21 - ball besides that we have various speeds
377:24 - and we have a whole bunch of colors with
377:27 - that system we can customize the game
377:30 - from inside of the settings which is
377:32 - generally a good idea you want to have
377:34 - all of the really important stuff in one
377:36 - place so you can make changes really
377:38 - quickly and that is what I want you guys
377:40 - to use to create the basic outline the
377:43 - end result should look something like
377:44 - this I suppose I should also mention we
377:47 - are not importing any images instead
377:50 - when you're creating the player and the
377:52 - ball create a surface from scratch for
377:55 - now all of those can be perfect
377:57 - rectangles anyway pause the video now
377:59 - and see how far you
378:03 - get I want to get started by creating a
378:07 - class called game no need for
378:08 - inheritance but we will need a Dunder
378:11 - init method in there first of all we
378:14 - want to call py game. init and create a
378:18 - display surface attribute which we get
378:21 - with py game.
378:23 - display.
378:25 - setor mode in which we want to add a
378:29 - tupal with the window width and the
378:31 - window height I can copy all of that
378:34 - from settings and then we are good to go
378:37 - besides that we can also change the
378:39 - window title with py game. display.
378:42 - setor caption and
378:45 - pong finally I want to create self.
378:49 - clock via py game.
378:51 - time. that should be the basic setup
378:54 - although I forgot one thing self.
378:56 - running for the while loop and by
378:58 - default this one should be true after
379:01 - that we want to have a run method
379:03 - without any custom parameter
379:05 - and then wild self.
379:08 - running in there we first of all want to
379:11 - get Delta time for which we need self.
379:14 - clock do pick don't forget to call it
379:18 - and then divide it by
379:20 - 1,000 that way we're getting Delta time
379:22 - in milliseconds afterwards for event in
379:26 - py game. event. get at the moment we
379:29 - only want to check if the event. type is
379:33 - equal to pyam do quit if that is the
379:37 - case self. running is going to be
379:40 - false next up we have the actual game
379:43 - logic in there later on we want to have
379:45 - an update part and a drawing part at the
379:48 - end of the drawing part we have to call
379:50 - pygame do display. update or flip also
379:55 - after the while loop we have to call
379:57 - pygame do quit cool with that we have
380:01 - the basic game class back in the global
380:04 - scope of main. Pi I want to check if
380:07 - Dunder name is equal to Dunder main if
380:11 - that is the case I want to create one
380:14 - instance of the game class and then call
380:17 - game. run let's try all of this and we
380:22 - are getting a black window that looks
380:24 - really good next up from settings.py I
380:28 - want to start using the colors and we
380:30 - already have a background color which
380:33 - means I can copy the key from colors and
380:36 - then inside of the drawing method self.
380:39 - display surface. fill with colors and
380:44 - BG let's try that and we getting a much
380:48 - nicer background color that looks good
380:51 - with that covered we can start working
380:54 - on the Sprites first of all for that we
380:56 - will need self. all Sprites which is
380:59 - going to be pame dos sprite. group on
381:03 - top of that I also want to have self.
381:06 - pedor Sprites which also is pygame Dos
381:09 - sprite.
381:11 - group padal Sprites is just going to be
381:14 - used to have collisions between the ball
381:15 - and the padal they are not going to do
381:17 - anything
381:18 - else self. all Sprites however we want
381:22 - to update I.E self. all Sprites do
381:25 - update with Delta time and after we are
381:28 - filling this screen self. all Sprites do
381:31 - draw on self. display surface
381:35 - that's a good setup next up inside of
381:38 - the code I want to add another python
381:41 - file let's call it Sprites
381:44 - DOI we will need from settings and
381:48 - import everything and then we have to
381:50 - create at the moment two classes one is
381:53 - going to be the player and the other
381:56 - will be the ball although for now let's
381:59 - focus on the player this one will be a
382:02 - pygame Dos sprite. Sprite
382:06 - then we will need a Dunder in it method
382:08 - with self then we will need the groups
382:12 - and an xcore position don't forget
382:16 - afterwards we have to call Super Dunder
382:18 - in it and pass in the groups finally
382:21 - then for the Sprite to work properly we
382:23 - will need an image we will need a
382:27 - rectangle and I guess along with that we
382:29 - also want to cover the
382:31 - movement for the image if you look at
382:34 - files we don't have a folder with images
382:38 - so there's no point in trying to import
382:40 - anything instead what we're going to do
382:42 - for self. image we want to have pame do
382:46 - surface for which we are going to use
382:49 - settings.py in there we have the size of
382:52 - the pedal or in other words size and
382:56 - pedal that's all we need for now for the
382:59 - image besides that I want to have self.
383:02 - rectangle which we get with self image.
383:05 - getet F rectangle in which we want to
383:08 - place this Center this one requires a
383:11 - tupal with X and Y X is going to be set
383:16 - via X position what we going to get in
383:19 - just a bit from the xos parameter for
383:22 - why we simply want to be in the middle
383:24 - of the window I.E window height / by two
383:28 - I suppose with that we have a very basic
383:31 - player Sprite class that we can use
383:33 - right away which means inside of main.py
383:37 - I want from Sprites import
383:40 - everything and then after we have the
383:44 - groups self. player is going to be the
383:48 - player for which we're going to need the
383:50 - groups first of all self. all Sprites
383:53 - and self. pedal Sprites and then we need
383:57 - an X position for this one I went with
384:00 - window with minus 50 I suppose you could
384:03 - also set this this value inside of the
384:06 - settings it's entirely up to you and
384:08 - while looking at this I feel like this
384:10 - value should be inside of settings. pi
384:13 - as well so what we can do under size we
384:17 - can also have a
384:19 - position for which we have a player key
384:23 - and the value for this one is going to
384:25 - be a tuple with window width minus
384:31 - 50 and then window height div by
384:35 - two on top of that I want to have one
384:38 - for the
384:40 - opponent which is simply going to be 50
384:43 - and window iight divide it by two with
384:46 - that set up we don't need this argument
384:49 - at all also inside of Sprites we don't
384:51 - need an exposition for the center we
384:54 - simply want to have B and then get the
384:57 - player key that does feel a lot
385:00 - cleaner and with that if I now run the
385:03 - code on the right side side you can see
385:05 - the player doesn't do very much and it's
385:08 - also not looking great but at least we
385:10 - have
385:11 - something first of all what we can do to
385:13 - make all of this look a bit better is
385:15 - self. image. Bill with colors and I
385:19 - believe the color for this one is called
385:23 - pedal that way we're getting some more
385:25 - colors now we are going to refine the
385:28 - image in just a bit but for now I think
385:30 - this is good enough what is much more
385:32 - important is the movement
385:35 - for which we are going to need a
385:36 - direction and since the player can only
385:38 - move up and down this doesn't have to be
385:41 - a vector it can simply be an integer and
385:44 - by default I want to go with zero and to
385:47 - move this thing I want to have a move
385:49 - method with self and Delta time for now
385:53 - let's add pass in here and then I want
385:56 - to have a defined get underscore
386:00 - Direction which is going to cover the
386:02 - input now you might be wondering why am
386:04 - I not calling this input and the reason
386:07 - is later on we going to have two get
386:09 - direction methods one for the player
386:12 - that takes keyboard input the other is
386:15 - going to be for the opponent and this
386:17 - one is going to check the ball position
386:19 - since I want to call both of them at the
386:21 - same time they are going to have the
386:22 - same name for now don't worry too much
386:25 - about it when we get to it I will
386:27 - explain it in much more detail anyway
386:29 - for now for get direction we simply want
386:31 - to get the keys with pame dokey and get
386:36 - rest and then set self. direction to the
386:40 - integer of keys and P game. Kore down
386:47 - minus integer of
386:50 - keys and py game.
386:54 - Kore up with that we are getting a
386:56 - Direction so next up for move I simply
386:59 - want to get self. rec. Center y plus
387:05 - equal self. direction multiplied with
387:09 - self. speed this one doesn't exist yet
387:12 - and multiply it with Delta time to make
387:15 - this work we will need self. speed which
387:19 - we are also getting from settings. PI
387:21 - there we have the speed this I want to
387:24 - turn into an attribute of this
387:26 - class in other words speed and layer
387:30 - finally we have to create a update
387:33 - method it with self and Delta time and
387:37 - then call self. get direction and self.
387:41 - move that way inside of main. Pi I can
387:44 - move up and down that's looking pretty
387:47 - good the one limitation is that the
387:49 - player can leave the screen that's no
387:52 - good although fairly fixable we want to
387:55 - check self. rect dotop and set it to
387:59 - zero if self. re. toop is smaller than
388:04 - zero if that is not the case else we
388:07 - simply want to keep self. rec.
388:10 - toop then I can duplicate all of this
388:12 - and set self. rec. bottom this one
388:16 - should be the window height if self. re.
388:21 - bottom is greater than the window he if
388:27 - that is not the case we simply want to
388:29 - keep self. re. bottom or in other words
388:32 - we don't want to make any changes and
388:35 - that is actually all we need I can now
388:37 - try to run the game and the player
388:39 - cannot leave the screen
388:41 - anymore the same with the bottom side so
388:45 - that is working pretty well and all
388:48 - right with that we have a basic player
388:51 - class next up we can work on the ball
388:56 - class which is also going to be a pame
388:59 - Dos sprite. Sprite and we don't need the
389:02 - player anymore
389:04 - we are going to need a thunder init
389:07 - method with self the groups the pedal
389:12 - underscore Sprites and that's it for now
389:16 - although later on there's going to be a
389:17 - bit
389:18 - more first of all as always super
389:21 - Thunder init with the groups then we
389:25 - need an image and the wrecked and
389:28 - movement section for the image at the
389:31 - moment the paddle is simply going to be
389:33 - a rectangle I.E self. image will be pame
389:36 - do surface with the dimensions of the
389:40 - ball size and ball on top of that self.
389:45 - image. fill with colors and I believe
389:49 - this one is called ball or in other
389:52 - words we are grabbing this key value
389:54 - pair for the rectangle we want to get
389:57 - self. rect which will be self. image.
390:01 - getet F rectangle we want to place the
390:04 - center straight in the middle of the
390:06 - window or in other words window wi
390:09 - divided by two and window height divided
390:13 - by two once again we have a basic
390:16 - outline of a Sprite that we want to use
390:18 - to create self dot ball which will be
390:22 - one instance of the ball class for which
390:25 - first of all we will need the groups we
390:27 - only want to ball to be in all Sprites
390:30 - and then make sure that the ball class
390:32 - has access to the padal Sprite group
390:37 - what I really want to mention at this
390:38 - point is that the ball itself is not
390:41 - inside of pedal Sprites it simply has
390:44 - access to them a really important
390:46 - difference let's try all of this and we
390:49 - can see something that looks like a ball
390:51 - in the center of the window to make this
390:53 - ball move we first of all need self do
390:57 - Direction which has to be a py game.
391:01 - vector 2 we need a value for x and y
391:05 - both of those should be random for that
391:08 - we will need from random import choice
391:11 - and
391:13 - uniform for the x value we simply want
391:16 - to get either one
391:19 - or-1 or in other words we're going left
391:21 - or right that we can get by putting them
391:24 - into a tupal and then putting the tupal
391:26 - into the choice method as an
391:29 - argument now for why I want to have a
391:32 - random value between two two floating
391:34 - Point values that we can get via
391:38 - uniform it works like random integer
391:40 - except for this one we're getting random
391:42 - floating Point values I want to get a
391:45 - value between
391:46 - 0.7 and
391:48 - 0.8 both of those are positive which
391:52 - isn't ideal if we didn't make any
391:54 - updates to it the ball would always go
391:56 - down because we always have a positive y
391:59 - value to fix that I'm going to multiply
392:02 - this with choice and -1 and one that way
392:07 - we get a direction that can be randomly
392:10 - up or down I hope this part isn't too
392:12 - complicated we are basically just
392:15 - creating two random values for X and Y
392:19 - next up to actually get some movement we
392:21 - want to have a move method with self and
392:24 - data time and all we want to do is self.
392:27 - re do Center plus equal self. direction
392:32 - multiplied with with the speed of the
392:35 - ball which we get from settings in there
392:38 - we have speed and ball and finally we
392:41 - will need Delta time after that to make
392:44 - sure we are calling the move method
392:46 - update self Delta time and self. move
392:50 - with data
392:51 - time let's try off this and the ball is
392:55 - moving in random directions let's try
392:58 - this a couple of
393:01 - times and that is looking pretty good
393:06 - cool we are nearly done with the basic
393:08 - setup the one other thing that I want
393:11 - for now is that the ball should be able
393:13 - to bounce around the screen for which we
393:16 - will need another method let's call it
393:18 - wall
393:20 - Collision no need for custom parameters
393:23 - all we really want to do in here is for
393:25 - example if self. re. toop is smaller or
393:29 - equal to zero then self. re. toop is
393:33 - going to to be zero and self. Direction
393:37 - doy we want to multiply with -1 or in
393:42 - other words if this is the top of the
393:44 - window and the ball crosses it then we
393:47 - are going to set the top of the ball to
393:49 - the top of the window and move the ball
393:52 - in the opposite direction at least on
393:54 - the vertical axis the same thing we want
393:57 - to do on the bottom side for that I can
394:00 - copy all of this and then check self. re
394:04 - do bottom is greater or equal to the
394:08 - window
394:09 - height if that is the case self. rec.
394:12 - bottom is going to be equal to the
394:14 - window height and self. Direction doy is
394:18 - going to be multiplied with -1 that
394:21 - would cover the top and the bottom those
394:23 - two parts we're going to keep in the
394:25 - final game although for now for testing
394:28 - purposes I also want to have a bounce on
394:30 - the left and right side of the window
394:32 - that is going to make it much easier to
394:34 - test collisions in just a bit for that I
394:38 - want to basically duplicate all of this
394:40 - two more times because now we want to
394:41 - check self. re. right is greater or
394:45 - equal to the window wi if that is the
394:48 - case self. re. right will be equal to
394:52 - the window wi and self. direction dox we
394:56 - are multiplying with negative one
394:58 - finally I want to copy the first if
395:01 - statement and then self. re. left is
395:06 - smaller or equal to zero if that is the
395:08 - case self. re. left is going to be zero
395:11 - and self. direction dox we are
395:13 - multiplying with -1 with that we have
395:17 - bouncing we just have to call self. Wall
395:20 - collision and then run main.
395:24 - pi and we have some bouncing Behavior no
395:27 - collisions yet but that we are going to
395:29 - work on in the next part other than that
395:32 - this is working pretty good good and I
395:34 - hope at this point this kind of setup
395:36 - isn't too difficult you should be able
395:38 - to create basic Sprites and make their
395:41 - move via a vector on top of that you
395:44 - should also be reasonably comfortable at
395:46 - this point to get player input we have
395:49 - covered this kind of logic twice already
395:51 - so I hope it's not too difficult now
395:54 - before we finish up this part there's
395:56 - one more thing that I would like to do
395:58 - at the moment we only have perfect
396:00 - rectangles which doesn't look great I
396:04 - want to have for the ball a proper
396:06 - Circle and for the player I want to have
396:09 - rounded Corners let's start with the
396:11 - ball and for that I still want to keep
396:14 - the surface but I'm going to add another
396:17 - argument which is called a flag and for
396:20 - this I want to get py game. SRC Alpha
396:24 - with that value we enable Alpha values
396:27 - on this image if I don't fill the entire
396:30 - thing with a color and run main. Pi we
396:33 - cannot see the ball anymore but the ball
396:36 - does exist it's simply not visible that
396:39 - is actually super useful because now we
396:41 - can get py game. draw. Circle so
396:45 - basically what we are going to do we're
396:47 - going to make the original surface
396:48 - invisible and then draw a circle on top
396:51 - of it with that set up we cannot see the
396:53 - background the only thing visible in the
396:55 - game will be the ball itself for this I
396:58 - want to draw on self. image and then get
397:01 - a color value which we already already
397:03 - have colors and ball finally we will
397:07 - need a position and now you have to be
397:09 - careful because so far whenever we use
397:12 - py game. draw we drew on the display
397:15 - surface but this we are not doing
397:17 - anymore we are drawing on self. image
397:20 - which is a surface that is much smaller
397:24 - this self. image is a Surface like this
397:27 - that is 30X 30 pixels and when we are
397:32 - getting the position for the circle
397:34 - we want to get the center of this thing
397:36 - which will be relative to the top left
397:38 - or in other words we want to go 15
397:41 - pixels to the right and 15 pixels down
397:44 - and those values we want to get from
397:47 - settings as well I want to have a t ball
397:50 - with X and Y for X I want to get the
397:54 - size then I want to get the ball size on
397:58 - there I want to get index zero and then
398:01 - divide all of this by two for the Y
398:05 - value I want to do basically the same
398:07 - thing except now it's going to be index
398:09 - one and finally we're going to need a
398:12 - radius which is going to be one of these
398:15 - values let's simply go with size ball 0
398:18 - / by 2 if I now run m not Pi again we
398:23 - are getting a circle so that is working
398:25 - pretty well now looking at this line it
398:28 - does get a bit more complex especially
398:31 - the position and the radius years all
398:34 - that we are really doing in here we have
398:37 - a surface that is 30X 30
398:41 - pixels those values we're getting from
398:43 - size and
398:45 - ball after that when we are drawing the
398:48 - circle we want to get the center of this
398:52 - surface and for that we are getting the
398:55 - width of the ball and divide it by two
398:57 - that way we are going from the top left
398:59 - and going halfway after that for the Y
399:03 - position
399:04 - we are once again starting from the top
399:06 - left and we're getting half of the
399:08 - height of the
399:09 - surface combined we are defining this
399:12 - Center Point finally then for the radius
399:16 - we simply go from the center and then
399:18 - get a radius that touches the outer
399:21 - border of the surface once we have
399:23 - thought of that we can draw a circle
399:26 - around that point that is basically it
399:30 - we don't need the image fill part
399:32 - anymore and after that we can work on
399:35 - the player for which we first of all
399:38 - have to set a flag with py game and SRC
399:42 - Alpha after that I want to use pam.
399:46 - draw. rectangle I want to draw on self.
399:50 - image the color is going to be colors
399:53 - and
399:54 - padal and finally I need to get a pame
399:59 - do F rectangle that I want to use for
400:02 - the drawing and for this one once again
400:05 - it's really important to understand that
400:07 - we are not drawing on the display
400:08 - surface we are drawing on self. image
400:12 - which at the moment I believe is a
400:14 - surface that is 40 pixels wide and 100
400:19 - pixels tall the rectangle that we want
400:21 - to create should start in the top left
400:25 - and then have the same width and the
400:27 - same height compared to the
400:29 - surface which means when we are defining
400:33 - the position we want to have zero and
400:36 - zero that way we are in the top left of
400:38 - the
400:40 - surface and those I want to have inside
400:43 - of a tupal or in other words when I'm
400:45 - defining this rectangle I want to have a
400:47 - tuple for the position and a tuple for
400:50 - the size for the position I want to have
400:52 - zero and zero and for the size I can
400:55 - simply reuse the size of the padal the
401:00 - same thing we have used inside of pame
401:03 - surface once we have that we have a
401:06 - rectangle but when we are drawing all of
401:09 - this we can Define more Arguments for
401:11 - the WID I want to have a value of zero
401:14 - and then for the Border radius I want to
401:16 - go with let's say 10 then we don't need
401:20 - self. image. fill anymore and if I run
401:23 - main. Pi we have rounded corners for the
401:26 - player pedal so that is working really
401:29 - well although I think they are a bit
401:32 - strong let's go with four instead and I
401:36 - think that is looking a bit better but
401:39 - once again play around with these
401:40 - numbers and just see what looks good
401:42 - anyway with that we have a pretty good
401:45 - start next up we can work on collisions
401:48 - with the basic setup out of the way we
401:51 - can work on collisions and really
401:53 - important for this project we have
401:55 - collisions between two moving objects or
401:58 - in other words both the pedal and the
401:59 - ball are moving which is not something
402:02 - we can account for with the Collision
402:03 - logic we have used so far but let's go
402:06 - through it step by step and start with a
402:09 - recap at the moment we have covered
402:12 - collisions between a moving and a static
402:14 - object we first of all separate the
402:17 - dimensions and then we check for
402:19 - overlaps via the rectangles for example
402:21 - we could have the player and an obstacle
402:24 - after that we use the direction of the
402:26 - moving object to determine the Collision
402:29 - side or in other words if we have to
402:31 - play on the obstacle again if the player
402:33 - is moving to the right then we know the
402:35 - Collision must have happened on the
402:37 - right side of the player or in other
402:39 - words if you have only a single moving
402:41 - object and this object is moving to the
402:43 - right then we can only really have a
402:45 - collision on the right side of that
402:47 - moving object once we have that we have
402:49 - to update the position of the moving
402:51 - object or in other words we are setting
402:54 - the right side of the player to the left
402:56 - side of the obstacle that would be one
402:59 - side if we cover the three others we
403:01 - have a proper Collision system
403:03 - however there is a major weakness and
403:06 - that is once the other object starts to
403:08 - move then all of this is falling apart
403:11 - and the key issue is once both of these
403:13 - objects are moving we cannot reliably
403:16 - tell on which side of collision happened
403:19 - for example if this is the player and
403:21 - the obstacle and the player is moving to
403:23 - the right we would assume that the
403:25 - Collision happened on the right side of
403:26 - the player however what happens if the
403:29 - obstacle is moving to the right at a
403:31 - much greater speed so that for example
403:34 - in the last frame the player was roughly
403:37 - here and the obstacle was somewhere here
403:42 - if that is the case we should have a
403:44 - collision like this where the right side
403:46 - of the obstacle is colliding with the
403:48 - left side of the player to account for
403:51 - all of that we have to make some updates
403:53 - to our Collision logic that being said
403:56 - we are going to keep some parts we are
403:58 - still going to separate the dimensions
404:00 - and we are checking for overlaps Via
404:02 - rectangle
404:03 - this part doesn't
404:05 - change after that however we are going
404:08 - to check the current and the previous
404:10 - position of both objects or in other
404:13 - words if this is the obstacle and the
404:15 - player only on the horizontal axis for
404:18 - example this would be the center of the
404:19 - player this will be the left side of the
404:21 - player and this will be the right side
404:22 - of the player and we can tell at the
404:25 - moment we have a collision on this point
404:27 - or rather an overlap to be a bit more
404:29 - specific and this happened on the
404:31 - current frame in the game but on top of
404:34 - that we also want to store what happened
404:36 - on the last frame and then let's say the
404:38 - player was here and the obstacle was
404:41 - here which means we know that the
404:43 - obstacle was further to the left than
404:45 - the player and is simply moving really
404:48 - fast to the right and this we have to
404:50 - include in our Collision
404:52 - calculation for example to check for the
404:55 - right Collision of the player we still
404:58 - want to check if the player right is
405:00 - greater than the obstacle left this this
405:03 - is what we have done here we know that
405:05 - the player right is greater than the
405:07 - obstacle left this is giving us one
405:10 - overlap but on top of that we are
405:12 - checking this second condition where the
405:15 - right side of the player needs to be
405:18 - below the left side of the obstacle with
405:21 - that we know that on the previous frame
405:24 - the player was on the left side of that
405:26 - obstacle which in this case is not going
405:29 - to be the case overall we know there was
405:33 - no Collision on the right side of the
405:34 - player however if we are doing all of
405:37 - this from the other side the obstacle
405:39 - then we do get a collision and let's go
405:41 - through it one more time we have the
405:44 - first Collision where we are checking if
405:46 - the right side of the obstacle this
405:49 - point is greater than the left side of
405:52 - the player which in this case very much
405:55 - is the case the right side of the
405:57 - obstacle is a much greater value than
405:59 - the left side of the player on top of
406:02 - that we want to check if the right side
406:05 - of the obstacle on the last frame was
406:08 - below the left side of the player on the
406:11 - last frame as well which is also the
406:13 - case meaning this condition triggers as
406:16 - well which means overall we know that
406:18 - the obstacle should have collided on the
406:21 - left side of the player and this logic
406:23 - we can apply to all of the other sides
406:25 - as well once we have all of that we have
406:28 - a proper Collision mechanic for all of
406:31 - that I want to work inside of the ball
406:34 - class and add a right below move Define
406:39 - collision for which we will need self
406:42 - and the direction we are working in
406:44 - first of all in there we want to check
406:46 - for sprite in self. pedal uncore Sprites
406:51 - which is something that I should have
406:53 - created inside of the dunder init method
406:55 - and there we need self. pedal Sprites
407:00 - which is the value we are getting from
407:02 - the parameter
407:03 - up here at the moment this one simply
407:06 - contains the player Sprite and later on
407:09 - the opponent will also be in there once
407:11 - we have that we want to check if sprite.
407:14 - rec. collide rect with self. rectangle
407:19 - we are checking if there's an overlap
407:21 - between the player and the ball
407:23 - something we have also done before after
407:26 - that I want to check if the direction is
407:29 - equal to horizontal and now we want to
407:32 - check check for two conditions if self.
407:35 - re. right is greater than sprite. re.
407:40 - left on top of that we want to have a
407:43 - second condition where self dot let's
407:46 - call it the old uncore
407:48 - rectangle. right is smaller or at least
407:53 - equal to sprite. Old re do left these
407:58 - two old rectangles don't exist at the
408:00 - moment we are going to create them in
408:02 - just a second
408:04 - though if that is the case we simply
408:06 - want to set self. re. WR to sprite. rec.
408:12 - left and this is the logic I have just
408:14 - talked about where we are checking a
408:17 - moving object and then first of all
408:19 - check if we have an overlap at all on
408:21 - the horizontal axis and then we check if
408:24 - the old rectangle was to the right of
408:27 - the left side of the Sprite on the
408:29 - previous frame the question now is how
408:31 - can we get this old rectangle or in
408:34 - other words how can we start a rectangle
408:36 - position on the last frame that part is
408:39 - actually fairly simple inside of Thunder
408:41 - init when we are creating the rectangle
408:45 - I also want to have self. _ rectangle
408:49 - and for now I simply want to get self.
408:52 - rect and then copy the
408:54 - rectangle that way we getting a new
408:56 - rectangle with the same position and the
408:59 - same size after that inside of the the
409:02 - update method before we are applying any
409:05 - kind of movement I want toose self. old
409:08 - rect and then get self. rectangle once
409:11 - again and copy it by our that system on
409:14 - every single frame we are storing the
409:17 - position of the rectangle and then
409:19 - updating the position of that rectangle
409:22 - we have the last frame and the current
409:24 - frame and that is all we need although
409:27 - the same thing we also have to do to the
409:29 - player in there or the player below the
409:33 - rectangle we will also need self. old
409:36 - rect which is going to be self. re.
409:41 - copy and this we want to do before we
409:44 - are doing anything else inside of the
409:46 - update method nearly done the last thing
409:49 - that we have to do is to call this
409:51 - Collision method and this is going to
409:53 - happen inside of the move method in
409:56 - there I first of all want to separate
409:58 - the dimensions for the movement we want
410:00 - to move self. r.x and self. doy for h
410:06 - plus self. Direction dox and self.
410:09 - Direction doy multiplied with speed and
410:12 - Delta time after the horizontal movement
410:15 - I want self. collision and
410:18 - horizontal after the vertical movement
410:21 - self do collision and vertical this part
410:24 - doesn't exist at the moment but that we
410:26 - can work on later first of all inside of
410:29 - main. Pi if the ball now collide
410:33 - with the player we are getting a
410:37 - collision this isn't too amazing yet
410:40 - because the ball simply keeps the
410:41 - direction to account for that we can
410:44 - simply set self. Direction dox multiply
410:48 - equal
410:50 - with1 that way we're getting a proper
410:52 - bounce so let's try this
410:55 - one and there we go this part is working
410:59 - and it would also work while the player
411:01 - is moving although truth be told this
411:04 - part isn't too impressive yet what is
411:07 - going to be much more interesting is the
411:10 - vertical Collision let's say I want to
411:12 - check if self. rec. bottom is greater or
411:17 - equal to sprite. rec. toop and self.
411:23 - olds w. bottom is smaller or equal to
411:29 - Sprite dot old score
411:33 - w. toop if that is the case I want to
411:37 - set self.
411:39 - w. bottom to sprite. w. toop or in other
411:45 - words we are checking if the bottom of
411:48 - the ball is colliding with the top of
411:50 - the player and besides that we are
411:53 - checking if on the previous frame the
411:55 - bottom of the ball was on top of the
411:57 - player as well now testing this is going
412:00 - to be a bit of a challenge and I think
412:03 - to test all of this a bit better let's
412:06 - set the ball speed to something much
412:08 - lower
412:10 - 50 if we now test all of this and it's
412:13 - going to be really slow let me speed
412:15 - this one up just a
412:17 - bit okay you can now see we have a
412:19 - collision between the pedal and the ball
412:23 - and this is also the basic logic for
412:25 - collisions between two moving objects
412:28 - all you really have to add is the
412:31 - overlap and then the position position
412:32 - of the rectangles on the last frame now
412:35 - in our case I always want the ball to
412:37 - bounce if there's a padal collision
412:40 - which means self. Direction doy multiply
412:44 - equal -1 if we have a vertical Collision
412:48 - I suppose what we could be doing is set
412:50 - the ball speed back to
412:52 - 450 and let's try this and there we are
412:56 - getting a proper Collision that looks
412:58 - good with that we are nearly done we
413:00 - just have to add two more sides to our
413:02 - Collision logic that part is going to be
413:05 - your exercise I want you to add the last
413:08 - two sides of the Collision logic pause
413:10 - the video now and see how far you
413:14 - get at the moment we are checking the
413:17 - right side of the ball and the left side
413:20 - of the player the alternative would be
413:22 - if self. w. left is smaller or equal to
413:29 - sprite. wct do right and I think it's
413:33 - generally a good idea to use greater
413:35 - than or equal to for all of these
413:37 - comparison
413:38 - operators although in practice it's not
413:41 - going to make much of a difference
413:43 - besides that and self.
413:46 - old. left is greater than or equal to
413:50 - Sprite do
413:53 - altore
413:54 - rectangle. right if that happens to be
413:57 - the case self. rec. left is going to be
414:01 - Sprite . rec.
414:04 - right and also in our case self.
414:07 - Direction
414:09 - dox multiply equal
414:13 - -1 and besides that for the vertical
414:16 - Collision we want to check self. rec.
414:20 - toop is smaller than or equal to sprite.
414:24 - rec. bottom and self. old
414:29 - rectangle. top is greater than or equal
414:32 - to Sprite do _ rectangle do bottom and
414:39 - then self. re. toop is equal to sprite.
414:44 - re. bottom and self. Direction doy
414:48 - multiply equal with
414:51 - -1 that is all we need I can now try
414:55 - main. pi and we have a collision on the
414:58 - top of the player and we can try this
415:01 - one again again there we could see a
415:04 - pretty good
415:06 - collision and you can play around with
415:08 - this quite a bit more but fundamentally
415:11 - it looks pretty good and I hope overall
415:13 - the logic here isn't too complicated the
415:17 - major thing that you have to understand
415:18 - is that we are always checking the
415:20 - current overlap and the previous overlap
415:22 - that's literally it since overall we are
415:25 - checking for ton of conditions this can
415:27 - get a bit complex but I think it's still
415:30 - manageable once you have been using this
415:32 - a couple of times it becomes fairly
415:34 - straightforward the next really
415:36 - important part that I want to cover is
415:38 - going to be inheritance by that system
415:41 - we are going to create the opponent with
415:43 - only a couple of lines of code the way
415:46 - it's going to work is that for now you
415:48 - have to understand that both the player
415:50 - and the opponent paddles are really
415:52 - similar they are going to have the same
415:54 - setup and move code so we can share
415:56 - quite a few things between them the only
415:59 - real difference between them is how the
416:00 - move direction is updated for the player
416:03 - we getting keyboard input while for the
416:05 - opponent we are checking the ball
416:07 - position because of that we can create a
416:10 - pedal parent Sprite that cover setup and
416:13 - move and then the player and the
416:16 - opponent both are going to inherit from
416:18 - that with that system it's going to be
416:21 - much easier to write reusable code so
416:24 - let's have a look inside of Sprites we
416:27 - have the player class and for the
416:30 - opponent we want to have the same dund
416:32 - init method and the same move method
416:35 - also we want to keep the update method
416:37 - as well as a consequence all of this
416:40 - should go into another class called
416:43 - padal this one needs to be a pygame Dos
416:47 - sprite.
416:48 - Sprite and for the dunder init method of
416:51 - this class we want to use the one we
416:54 - have created for the player we can
416:56 - simply cut it out and paste it in there
416:59 - and now we are creating a very basic
417:03 - Sprite unfortunately now the player
417:05 - class is not going to work anymore but
417:08 - what we can do is make the player class
417:11 - inherit from the pedal that way all of
417:14 - this will become available all we need
417:16 - to do is call a Dunder in it method
417:19 - inside of the player and for that we
417:22 - will need the groups but now if we are
417:25 - calling super Thunder init inside of it
417:29 - we are calling this thunder init method
417:31 - and only inside of this thunder init
417:33 - method of the pedal class are we
417:35 - creating the actual
417:37 - Sprite although the pedal itself doesn't
417:40 - really care all that we need to pass
417:42 - through are the groups and then we are
417:43 - done which means inside of main. Pi we
417:47 - are getting the very same result so that
417:50 - is looking really good the only change
417:53 - that we want to make is that we want to
417:55 - have a custom speed for the player and
417:57 - for the opponent later on which means we
417:59 - want to have self. speed inside of the
418:02 - player on top of that what we can also
418:05 - do is move the move method into the
418:08 - paddle class like
418:11 - so and the same thing we can do to the
418:14 - update method since those are going to
418:17 - be useful for the opponent as well we do
418:19 - want to have them inside of the parent
418:22 - class which means all that's really left
418:25 - inside of the player is get direction
418:27 - and a very basic Dunder init method
418:31 - however inside of Main Pi we still have
418:34 - the same functionality so now finally we
418:38 - can create the
418:41 - opponent which is going to be a child of
418:44 - the pedal class all that we need inside
418:47 - of this one is a thunder init method and
418:51 - we will need a get direction method and
418:55 - creating those is going to be your
418:57 - exercise I want you guys to create the
419:00 - proper opponent pedal the class should
419:02 - be paddle This is what we already have
419:05 - and then to get the direction you
419:07 - basically want to do something like if
419:09 - the vertical center of the opponent is
419:11 - smaller than the vertical center of the
419:13 - ball then the opponent should move down
419:15 - that's all you need for the direction
419:18 - this can be done in a single line of
419:19 - code so pause the video now and see how
419:22 - how you
419:25 - get first of all we will need thunder in
419:28 - it with self the groups and we are also
419:32 - going to need access to the ball after
419:34 - that super Thunder innit with the groups
419:39 - and that way we are calling all of this
419:43 - which means we already have a Sprite and
419:46 - for now I am going to comment out get
419:48 - direction because what we can already do
419:52 - inside of main.py I can create an
419:56 - opponent class for the groups we need
419:59 - self. all Sprites and self do pedal
420:02 - Sprites for the ball I want self. ball
420:06 - if I now run all of this we are getting
420:09 - an attribute error that opponent object
420:11 - has no attribute get direction that
420:14 - happened because inside of Sprites we
420:17 - have a very basic setup meaning we get
420:20 - all of this but then because of the
420:23 - inheritance we are also getting this
420:25 - update method which is trying to get the
420:27 - old rectangle but then it wants to get
420:30 - the direction which can do for the
420:32 - player but we cannot do it for the
420:34 - opponent because we do not have get
420:37 - direction inside of it if we uncomment
420:39 - all of this and then for now add self
420:42 - and pass in
420:43 - there then this problem should be solved
420:46 - we can now get a direction afterwards we
420:49 - are trying to call self. move which does
420:52 - exist inside of the parent class meaning
420:54 - it should be working however if we are
420:56 - trying main. Pi we're getting another
420:59 - attribute error that there's no speed in
421:01 - inside of the opponent which should be
421:04 - obvious because inside of this thunder
421:06 - in it there's no speed for the player we
421:10 - are creating a speed separately which is
421:13 - also what we want to do for the opponent
421:15 - inside of the dunder init method I want
421:17 - to have speed and opponent the key value
421:21 - pair that we are getting in here if I
421:23 - now run main. Pi if I move the player
421:26 - you can see that we have an opponent
421:28 - although the issue is that the opponent
421:30 - is on the wrong side so this is no good
421:33 - this happens because when we are
421:35 - creating the parent we are setting self.
421:38 - rectangle to this position how can we
421:41 - fix that and well when we are creating
421:44 - the opponent we can simply overwrite
421:47 - self. rectangle or to be a bit more
421:49 - elegant we can update self. re. Center
421:53 - to PA and the opponent the value that we
421:58 - are getting from this dictionary
422:02 - and now inside of m.p we have the
422:05 - opponent in the right position that is
422:07 - working really well all we need at this
422:09 - point is the get direction method first
422:11 - of all for that we need to know where
422:14 - the ball is inside of the game and we
422:16 - are already passing the ball as an
422:18 - argument into this class which we want
422:20 - to store as an attribute self. ball is
422:24 - ball and then basically we want to get
422:27 - self. direction which as a reminder is
422:30 - simply an integer it can be one or
422:33 - negative 1 in my case I want this to be
422:35 - one if self. ball. Rec do Center
422:40 - Y is greater than self. rect do Center y
422:45 - if that's not the case else it should be
422:48 - -1 imagine that this is the opponent and
422:51 - we have the ball somewhere here in this
422:53 - case we have the center of the opponent
422:55 - here let's say this is a 100 while the
422:58 - center of the ball is something like 100
423:01 - 50 with those numbers this if statement
423:04 - is going to trigger as a consequence the
423:07 - direction of the opponent will be one or
423:10 - in other words we are moving down and
423:13 - that's the basic logic if I now run
423:15 - main. Pi we are already calling get
423:18 - direction so this method is running
423:20 - already and it's looking pretty good now
423:23 - the opponent is following the
423:25 - ball and this is working forever and at
423:29 - some point the opponent does miss the
423:31 - ball which which is perfect so with that
423:33 - we have the opponent and we didn't have
423:35 - to write very much code to set all of
423:37 - this up and the same for the player the
423:40 - actual logic inside of this one is very
423:42 - very simple the actual work happens
423:45 - inside of the padal and this is going to
423:48 - be reusable which also means that you
423:50 - can make updates in here very easily and
423:53 - for a more complex project this is
423:55 - basically always something that you want
423:57 - to do it makes your code much more
424:00 - easily manageable to finish up this game
424:03 - I want to add a score and a saving
424:05 - mechanic that way the game becomes much
424:07 - more interesting and we also cover a
424:09 - really important game mechanic after
424:11 - this we are also going to add some more
424:13 - minor bits but those aren't too
424:15 - important first of all saving in a game
424:18 - simply means that we want to store some
424:19 - data
424:20 - permanently in our case when we are
424:23 - closing the game we are going to create
424:25 - some kind of text file with the score
424:28 - and when the game is starting again we
424:30 - are loading that text file
424:32 - that's all that's really happening in
424:33 - here the only thing that we really have
424:36 - to worry about is the file format and I
424:39 - want to use something that is called
424:40 - Json or JavaScript object
424:44 - notation this is a really common format
424:47 - to pass data around online and python
424:49 - can use it really really
424:51 - well although truth be told you could
424:54 - also just create a text file or an Excel
424:56 - file or if you really want it you could
424:58 - store the data in a JPEG file it is
425:00 - entirely up to you but Jason usually is
425:02 - the default and just for an example this
425:06 - is what ad Jason fire looks like it is
425:09 - fairly similar to a python dictionary
425:11 - although you do have to be careful here
425:13 - Json is not python it's an entirely
425:16 - separate file format it just happens to
425:18 - look very similar now to implement all
425:21 - of this first of all I want to have a
425:23 - score section in my Dunder ined method
425:26 - of the game where we are creating a
425:29 - score dictionary for which we have a
425:33 - player key with zero and we have an
425:36 - opponent key as well so this dictionary
425:40 - is going to keep track of the score and
425:43 - that we want to display I.E Define
425:46 - display underscore score no need for
425:49 - custom parameters and in there we want
425:51 - to display the player score and the
425:54 - opponent
425:56 - score for both we are going to need some
425:58 - text or in other words we want to create
426:01 - a player surface and for that we want to
426:05 - do something like self. font. render a
426:08 - font we don't have at the moment right
426:11 - below the score self. font is going to
426:14 - be py game. font.
426:17 - font for the font style I will go with
426:20 - the default one none for the font size I
426:24 - want to have something fairly
426:26 - large
426:28 - 160 with that we have a font that means
426:31 - we can get self. score and the player
426:36 - that being said inside of the random
426:38 - method we always need a string so we
426:41 - have to convert this right away using
426:43 - the string
426:45 - method afterwards we have anti-alias
426:48 - which should be true and then we will
426:50 - need a color which we are getting from
426:53 - colors and in there is BG detail I think
426:58 - I called it the final entry BG detail
427:01 - that is going to give us a player
427:03 - surface next up we need a player
427:06 - rectangle or in other words where we
427:08 - want to display this surface I want to
427:11 - get the player surface and then get F
427:13 - rectangle I want to place the
427:16 - center and for X I want to have window
427:20 - Wii / 2 plus a 100 or Y I simply want to
427:25 - get window height divided by
427:27 - two finally self. display surface do
427:31 - blit with the player surface and the
427:34 - player rectangle to make sure we are
427:37 - testing all of this inside of the run
427:40 - method before we are drawing all of the
427:42 - Sprites but after we are drawing the
427:44 - background I want self. display score
427:48 - let's try and there we can see the
427:51 - player score it doesn't do anything at
427:53 - the moment but at least we have
427:55 - something after that I can copy all of
427:59 - this and then rename player to
428:04 - opponent for all of those I want to have
428:07 - the
428:08 - opponent also for the score we want to
428:11 - have the
428:14 - opponent and then for the position we
428:17 - don't want to go 100 pixels to the right
428:20 - we want to go 100 pixels to the left
428:23 - let's try all of that and there we have
428:25 - two scores that looks good finally I
428:28 - want to add a line separator
428:32 - here which simply is going to be pam.
428:35 - draw doline on self. display
428:39 - surface with the BG detail color then we
428:44 - will need a start position and an end
428:46 - position along with a line width for the
428:49 - start position I want to get 4X window
428:51 - width divided by two and zero we are in
428:55 - the midtop of the window then for the
428:58 - end position window wi divided by two
429:01 - and and window height and for the line
429:04 - WID I went with 10 if I now run all of
429:07 - this again we have a line separating the
429:09 - two sides of the field that looks good I
429:12 - suppose you could argue that the line
429:14 - width is just a bit large maybe six is a
429:17 - bit better just choose whatever you like
429:19 - the most in here there really isn't a
429:21 - universal answer anyway with that we are
429:25 - displaying the
429:27 - score which means whenever we are
429:29 - updating the score we are actually
429:31 - showing the result now to get those
429:33 - values I want to create an update score
429:38 - method with self and the side that we
429:41 - want to update inside of this method
429:44 - self. score and then by default pick the
429:49 - layer but only if side is equal to layer
429:54 - if that is not the case else I want to
429:57 - get the
429:58 - opponent that way I am getting one of
430:00 - the value vales and I want to increase
430:02 - this value by one and that's all we need
430:05 - to update the score for one of the sides
430:09 - and this method is going to be called
430:11 - from inside of the ball class which
430:14 - means in there we want to have self.
430:16 - update
430:18 - score after that when we are working
430:20 - with the ball we will need one more
430:23 - parameter update uncore score and this
430:27 - we want to turn into an attribute right
430:29 - away self. up underscore score is going
430:33 - to be update score that's a good start
430:36 - next up when we have a wall Collision
430:40 - for the left and the right side instead
430:43 - of making the ball bounce we want to
430:45 - update the score which means we don't
430:47 - need those two if statements anymore and
430:50 - we can replace them with if self. re.
430:54 - write is greater or equal than the
430:57 - window Wii or self. wct do left is
431:03 - smaller or equal to zero if that is the
431:06 - case we want to self. update score for
431:10 - the argument we will either need player
431:12 - or the
431:14 - opponent by default I want the player
431:17 - but only if self. Rec do X is smaller
431:22 - than the window wift divided by two or
431:26 - in other words if the ball is on the
431:28 - left side of the field then I want to
431:30 - insert player
431:31 - if that is not the case else we're going
431:34 - to insert opponent Let's test all of
431:37 - this and let me miss the ball and the
431:40 - score should update and it does
431:43 - although the issue is we are not
431:46 - resetting the ball so this method keeps
431:48 - on triggering to fix that I want to run
431:51 - self. reset which is a method that does
431:54 - not exist at the moment to fix that
431:57 - Define reset with self and no other
432:00 - parameter
432:01 - all that we need in here is first of all
432:04 - self. rec. Center we want to place the
432:07 - ball right in the middle of the window
432:09 - which means window width divided by two
432:12 - and window height ided by two on top of
432:15 - that I want to randomize the direction
432:18 - again the same thing that we have done
432:20 - up here in fact we could simply copy the
432:23 - line and paste it in there if I now try
432:28 - all of this again the ball is resetting
432:30 - in the middle of the window and that's
432:32 - already feeling quite a bit better
432:35 - that's a really good start now we can
432:37 - start working on saving the score at the
432:40 - moment the score is not permanent
432:42 - whenever we restart the game this is the
432:44 - score that we are starting with to fix
432:47 - that we need to do two things number one
432:50 - when we are quitting the game we want to
432:52 - create adjacent file that stores the
432:55 - score data and then when we are starting
432:58 - the game again we want to load that file
433:00 - and and overwrite self. score for all of
433:04 - that first of all we will need another
433:07 - python module which is called Json and
433:11 - this one comes with python so you should
433:13 - already have
433:14 - it after that when we are exiting the
433:18 - game I want to create a file which we
433:21 - are doing with open and then we have to
433:25 - specify a file path which we are once
433:27 - again doing via the join method I want
433:30 - to go to the data folder and then create
433:33 - a score. txt file and in case you're
433:37 - wondering in our file path we have the
433:39 - code folder and then we have data which
433:42 - at this point is entirely empty this
433:45 - would be the first argument inside of
433:47 - open the second one has to be a w short
433:50 - for writing on other boards we are
433:53 - indicating that we want to write this
433:56 - file and then inside of python we have
433:59 - to store all of this data as a variable
434:01 - I'm going to call it score uncore
434:05 - file inside of this whiff statement we
434:08 - want to call Json and then dump in there
434:12 - we want to pass in self. score so the
434:15 - data we want to save and then the score
434:18 - file the file that we actually want to
434:20 - write in and with that we are done if I
434:24 - now Run the game and let me get a
434:26 - different score than zero and zero if I
434:29 - now exit the game we didn't get an error
434:32 - but if I'm looking at our folders inside
434:35 - of data we have score. txt and in there
434:39 - we have the player score and the
434:40 - opponent score that was literally it
434:43 - with that we can create external
434:47 - files next up then when we are starting
434:50 - the game we want to load that file which
434:53 - we're doing in a similar way once again
434:56 - I want to use with open and then the
434:59 - join method in which which I go to data
435:02 - and then score. EXT important now we do
435:08 - not want to add a second argument like
435:10 - we have done down here because we only
435:13 - want to read this file we do not want to
435:15 - write any kind of data in there at this
435:17 - point and this we want to store as the
435:19 - score file we want to get Json load and
435:24 - the score file this is going to load all
435:27 - of the Json data and return a dictionary
435:30 - in our case this is going to be self.
435:34 - score and well that is basically it I
435:37 - can now comment out the original Self do
435:39 - score if I now Run the game we have the
435:42 - score from the last game so this is
435:44 - working really well and if I am getting
435:48 - another score let me try to defeat the
435:51 - opponent at least once and that is
435:53 - working and if I am
435:56 - getting another few points in
435:59 - there if I I now open score. txt we have
436:03 - once again updated the score this is
436:06 - working really well that means we are
436:09 - nearly done there's just one more thing
436:11 - that we want to be conscious
436:13 - of if the game starts for the first time
436:17 - and score. txt does not exist so let me
436:20 - simply delete this file if we are now
436:23 - trying to run the code the issue is that
436:25 - we do not have score.
436:27 - txt that is something we can fix fairly
436:30 - easily we want to indent this if
436:32 - statement one more time and then add try
436:35 - which is telling python to try this line
436:37 - of code and if we are getting an error
436:40 - and if we are getting an error then we
436:42 - want to do an accept
436:45 - statement or an other words if we have
436:49 - this Json file we want to create a score
436:52 - from that data but if we don't so accept
436:56 - then we want to create a new self. score
436:59 - dictionary I can run the game and by
437:02 - default we have no score but once we are
437:04 - getting something I can close the game
437:07 - and we are getting score. txt and that
437:10 - is all you need for a very basic saving
437:13 - mechanic wasn't actually so
437:15 - bad that also nearly finishes the game
437:19 - there are just two more things that I
437:20 - want to do both of those are going to be
437:23 - your exercise number one I want to have
437:26 - a delay when the ball resets that way
437:29 - the player has a bit of time to to
437:31 - adjust and besides that I want to add
437:33 - Shadows to the pedals and the ball a
437:36 - fairly Minor Detail but it's going to
437:38 - make the game look much better by the
437:40 - end of it you should have something like
437:42 - this so pause the video now and see how
437:45 - far you
437:48 - get righty let's get started with the
437:52 - ball reset or which I want to create a
437:57 - timer inside of the dander ined method
438:00 - of the ball we will need self. startor
438:04 - time which is going to be py game.
438:07 - time.get uncore tix on top of that I
438:11 - want to have self. duration I put this
438:14 - one at
438:15 - 1,200 once we have that I want to create
438:20 - below
438:21 - reset a timer method which is going to
438:25 - check if py game. time.get ticks so the
438:29 - current time minus self. start time is
438:34 - greater or equal than self. duration if
438:38 - that is the case we want the ball to
438:40 - start moving which in my case I'm going
438:43 - to do via self. speed modifier if this
438:48 - timer times out this value is going to
438:50 - be one if it doesn't self. speed
438:54 - modifier is going to be
438:57 - zero and then inside of the move method
439:01 - we are multiplying the actual movement
439:03 - with self. speed modifier so if this
439:07 - value is zero we do not get any movement
439:10 - for all of that we have to under
439:13 - movement at self. speeed modifier and
439:17 - set it to zero also we have to call the
439:20 - timer before we are doing any movement
439:23 - self. timer with that if I run m. Pi
439:28 - after about 1 second we're getting some
439:29 - movement so so that is looking pretty
439:32 - good after that inside of the reset
439:36 - method I want to update self. start time
439:41 - with py game. time.get
439:44 - X that way inside of the game once we
439:49 - are getting an update to the score we
439:52 - have to wait a second and then the ball
439:54 - starts moving again so that is working
439:57 - pretty well let's try it one more time
440:01 - and that is working
440:02 - perfect that covers the first part next
440:06 - up I want to work on the shadows for
440:09 - that first of all I want to give all of
440:11 - the entities another surface let's do it
440:15 - right below the image I want to have a
440:17 - shadow
440:20 - surface for which we will need self.
440:24 - shadowcore surface which is going to be
440:27 - a surface with the same size as the
440:29 - image or words self. image. copy on this
440:33 - new Surface we also want to draw a
440:36 - circle in fact I can duplicate this
440:38 - entire line although we want to draw on
440:42 - self. Shadow surface for the colors I
440:47 - want to get the ball Shadow although the
440:50 - position and the radios should stay
440:51 - identical so with that we have a shadow
440:54 - surface how can we display it for that I
440:58 - want to create a custom Sprite Group
441:01 - which means inside of the code folder I
441:04 - want to add groups. I first of all in
441:09 - there from settings import everything
441:12 - and then class all
441:15 - Sprites with pygame DOs sprite.
441:20 - Group after that we will need a thunder
441:23 - init method with self and nothing else
441:27 - and we need Super do Dunder in it also I
441:32 - want to get self. display surface via py
441:37 - game. display. getet
441:40 - Surface after that I want to create a
441:43 - custom draw method for this one first of
441:47 - all we have to get the default Behavior
441:50 - which we get via for sprite
441:53 - in and then self. display surface. blit
441:57 - with sprite. image and Sprite right do
442:02 - rectangle after that inside of main. Pi
442:05 - I want from groups import all
442:10 - Sprites this all Sprites is then going
442:12 - to be our all Sprites group and when we
442:17 - are running the game and drawing all of
442:19 - this we do not need an argument anymore
442:22 - other than that though everything else
442:24 - is still working just fine so that's a
442:27 - really good start what we now need for
442:30 - the Shadows before we are drawing the
442:32 - actual Sprites we want to have another
442:35 - for Loop which is also going to be for
442:38 - sprite in self except that now we are
442:41 - calling self. displays surface. blit
442:45 - with sprite.
442:47 - shadowcore surface and for the position
442:51 - we want to have sprite. rec. toop left
442:55 - plus some offset let's say pame do
442:58 - Vector 2 with five and five
443:01 - now this at the moment is not going to
443:02 - work because the pedals do not have a
443:06 - shadow surface that we can fix quite
443:08 - easily because both pedals have the same
443:11 - parent class in there below the image we
443:14 - can add a shadow surface which for now
443:18 - is going to be Shadow surface with self.
443:21 - image. copy after that if I'm trying to
443:25 - run all of this we are getting an
443:27 - attribute error that all Sprites has no
443:29 - Shadow surface surf that is because this
443:33 - should be Sprite do Shadow surface
443:36 - instead of self let's try this again and
443:39 - now we can see some sort of Shadow so
443:43 - it's working reasonably well to refine
443:46 - all of this inside of the padal I want
443:49 - to draw another rectangle like we have
443:52 - done in the original except now this
443:54 - should have a pedal Shadow color the one
443:58 - that we getting from the settings or so
444:00 - we want to draw on the shadow surface
444:04 - let's try out of that and definitely
444:06 - getting better the one thing I don't
444:09 - like about this one at the moment is let
444:12 - me draw this actually if this is the
444:15 - padal our shadow at the moment would
444:18 - look something like
444:20 - this where you can very much see that we
444:23 - have two separate surfaces one here and
444:25 - one here and I want to have them connect
444:28 - a bit better in other words I want to
444:29 - have a proper line like this which would
444:33 - look much more like a shadow to get
444:36 - something like this I want to add
444:38 - another four Loop for I in range let's
444:43 - say five and then when we are drawing
444:46 - the Shadow the vector offset is going to
444:49 - be set by the I argument that we getting
444:51 - from the four Loop that way we are
444:54 - drawing multiple Shadows at an offset
444:56 - which is going to make all of this look
444:58 - much better
445:01 - the rest of the game though still works
445:02 - just fine perfect so with that we have a
445:06 - proper Shadow although this isn't a
445:08 - perfect setup because we are drawing
445:11 - five extra surfaces on every single
445:14 - frame what would be much better is to
445:16 - create all of these surfaces in the
445:18 - dunder init method and then blit them at
445:21 - once but for our purposes I don't think
445:24 - performance is ever going to be an
445:27 - issue so I would say at this point we
445:30 - are basically
445:32 - done that covers another
445:38 - [Music]
445:44 - game for Game number four we are going
445:47 - to create a basic platformer game in
445:51 - there you can jump around and shoot at
445:53 - things it's fairly
445:55 - straightforward and most of the logic we
445:58 - already know there are just three things
446:00 - that are going to be somewhat new the
446:03 - most important one is going to be the
446:05 - platform of logic besides that I want to
446:08 - have more organized Imports and I want
446:11 - to create better timers two things that
446:13 - are incredibly helpful for any even
446:16 - slightly more advanced project although
446:18 - before we get to any of this we have to
446:20 - start with the platformer setup by the
446:23 - end of this part we will have something
446:25 - like this this part is also going to be
446:28 - an exercise I want you guys to set up
446:31 - the level and for that load the level
446:33 - data from the titled map then create a
446:36 - player Sprite that can move and Collide
446:39 - and for this one the easier collisions
446:40 - are fine although you could also use the
446:43 - more advanced ones but they're not
446:45 - really necessary for this project and
446:47 - finally add a camera that follows the
446:49 - player and if you open the project
446:52 - folder you can see that we already have
446:54 - a couple of things inside of main.py we
446:57 - have a game class and this one
446:59 - initializes is the basic stuff and then
447:01 - creates two groups then we have a run
447:05 - method where we are doing the usual
447:07 - stuff all of that is giving us a basic
447:10 - window with a background color inside of
447:14 - settings.py we have a few more basic
447:16 - things but none of them are too
447:18 - complicated also if you look at the
447:20 - project folder besides the code folder
447:23 - with Graphics maps and title sets we
447:25 - have a whole bunch of images those you
447:27 - don't have to worry about at this point
447:29 - and we have a bunch of audio files those
447:32 - also don't matter too much at this point
447:34 - what you want to primarily work in is
447:36 - code and data and Via those try to
447:39 - finish the exercise see how far you
447:44 - get inside of the game class I want to
447:48 - create a setup method and for now I want
447:51 - to load the TMX map or in other words I
447:54 - want to create a local variable let's
447:56 - call it TMX map this I get via load pame
448:01 - where I want to go to data and
448:04 - Maps if I show this in the file explorer
448:07 - we want to go to data maps and there we
448:10 - have world. TMX this is the file we want
448:13 - to load world. TMX if you open that file
448:17 - by the way you are going to get
448:19 - something like this where we have three
448:22 - layers main decorations and entities on
448:26 - the main layer we have the actual level
448:29 - on decorations we have a whole bunch of
448:32 - well
448:33 - decorations and finally for entities we
448:36 - have the player start position this one
448:38 - up here and then we have a couple of
448:40 - areas all of those are for the warm
448:42 - enemies not too important for now so
448:45 - don't worry about it all that we care
448:47 - about at this point is decoration and
448:49 - Main to set up the level which means to
448:52 - get started I want for x y and the image
448:57 - in GMX map and get layer by name the
449:01 - layer that we want to load is called
449:03 - main since this one is a tile layer I
449:05 - want to add Tiles at the end that why I
449:08 - am getting XY and image decoded right
449:11 - away I want to create a very simple
449:13 - Sprite class in which we can add an X
449:16 - and Y position then the image and then
449:20 - the groups the groups we actually
449:21 - already have all Sprites and collision
449:24 - Sprites those we want to add in there
449:26 - right away s a tuple self. all Sprites
449:29 - and self. Collision Sprites also
449:33 - remember X and Y inside of tiled is a
449:36 - grid coordinate but we want to have all
449:38 - of this as a pixel position for that
449:41 - from settings we want to get the tile
449:43 - size and multiply it with both of those
449:46 - values with that we can create a basic
449:49 - Sprite for which I want to create a new
449:52 - python file Sprites
449:55 - dop in there we want from settings and
449:58 - import everything
450:00 - and then create a class called Sprite
450:03 - wave pygame dos sprite. Sprite then we
450:07 - will need a Dunder init method with self
450:11 - a position a surface and the groups
450:15 - afterwards we can call Super Thunder
450:19 - init and pass the groups right through
450:22 - self. image is going to be the surface
450:24 - and self. will be self. image doget
450:30 - F rectangle in which we are going to
450:32 - place the top left wherever the position
450:35 - is that covers the basic spread class
450:37 - back inside of main.py I want from
450:41 - Sprites import
450:43 - everything that way this Sprite should
450:46 - be working all that we have to do is let
450:49 - me add another section load game in
450:52 - which we want to call self. setup and
450:55 - with that we get one part of the level
450:58 - that looks really good while we are here
451:01 - we can also duplicate those two lines
451:04 - because besides main we also have
451:06 - decoration which should only be in self.
451:09 - all Sprites there should be no
451:11 - collisions with those tiles but other
451:14 - than that this is all we had to do for
451:16 - this part after that I want for obj in
451:21 - TMX map and get layer by name
451:26 - entities that is an object layer on
451:28 - which we have the player starting
451:30 - position which we can identify via the
451:33 - name player or in other words I want to
451:36 - check if obj do name is equal to player
451:42 - and if that is the case I want to create
451:45 - a player class for now in there I want
451:48 - to have the position objx and obj doy
451:52 - then I will need self. all Sprites for
451:55 - the groups and self. collision Sprites
451:58 - for the collisions later we are going to
452:00 - add a bit more but that's not an issue
452:02 - for now I first of all want to create
452:05 - another class called layer and important
452:09 - for this one I want to inherit from
452:11 - Sprite the class that we have just
452:14 - created we will always need a thunder in
452:17 - it method and we need what we have
452:20 - specified here a position groups and
452:22 - collision Sprites self position groups
452:26 - and collision uncore
452:31 - Sprites then we will need Super thunder
452:34 - in nit and important now we are calling
452:38 - this thunder init method for which we
452:41 - will need a position a surface and the
452:44 - groups now we do have a position and a
452:47 - groups via the parameters that part is
452:50 - fine but we don't have a surface at the
452:52 - moment which is totally fine we can
452:55 - simply create a surface via pame do
452:58 - surface
453:00 - for now the dimensions are going to be
453:03 - let's say 40 and 20 also while we are
453:07 - here I want to create an attribute self.
453:10 - Collision unor Sprites is going to be
453:13 - Collision Sprites with that if I'm
453:16 - running main. Pi we can see a very basic
453:20 - player
453:21 - thingy although I think it should be
453:24 - quite a bit taller instead of 20 let's
453:26 - go with
453:27 - 80 that feels much more realistic that
453:31 - would be the basic player I want to call
453:33 - an update method with self and Delta
453:36 - time for which we are going to need
453:38 - self. move and this move method is going
453:42 - to consist of two parts the move method
453:45 - itself with self and data time and then
453:49 - we will need Define collision with self
453:53 - and E direction to get started with
453:56 - moving we want to get self. w.x
454:00 - plus equal self. direction which doesn't
454:04 - exist at the moment and for that we can
454:06 - actually create a
454:09 - movement and collision section which is
454:13 - going to contain Direction P game.
454:16 - Vector 2 that is a part we have seen a
454:18 - couple of times by now and also in this
454:21 - bit I want to have self. speeed for for
454:24 - this one I went with
454:27 - 400 with that we have self. Direction
454:30 - multiplied with self. speed multiplied
454:33 - with Delta time this I can duplicate
454:36 - because the next line should be self. re
454:38 - doy and I realized for X we want self.
454:42 - Direction dox and for y self. direction.
454:45 - y that way we have the horizontal and
454:48 - the vertical movement afterwards we have
454:50 - to call self. Collision with
454:54 - horizontal and
454:57 - vertical that would cover the basic
454:59 - movement to test all of this I want to
455:01 - have an input method in which we are
455:04 - getting the keys and then py game. key
455:07 - doget uncore rest at least for now I
455:11 - want to update self. Direction dox and
455:14 - set it to the integer of keys and py
455:19 - game. Kore right minus let me copy all
455:24 - of this and change K right to K left
455:29 - then we can duplicate all of this and
455:31 - then K down minus K up also we want to
455:37 - get self. direction and set it to self.
455:41 - direction.
455:43 - normalize if self. direction if that is
455:46 - not the case we simply want to get self.
455:49 - direction also before we are moving I
455:52 - want to call self.
455:54 - input with that if I run main. Pi the
455:58 - player can move around just fine that is
456:02 - looking pretty good for the collisions I
456:05 - want to check for sprite in self.
456:09 - Collision Sprites if
456:12 - sprite. rec. cide wed with self.
456:18 - rectangle and by the way for this
456:20 - project you could be using hitboxes but
456:23 - you don't really need to if you want to
456:25 - add it do it in your own time afterwards
456:28 - if Direction
456:30 - is equal to
456:32 - horizontal then we want to check if
456:35 - self. direction dox is greater than zero
456:40 - then we know self. re. write should be
456:43 - equal to
456:45 - sprite. do left then we can duplicate
456:48 - all of this and check if the direction
456:51 - is smaller than zero in which case self.
456:55 - re. left should be sprite. re. right
456:59 - next up I want to duplicate all of this
457:02 - and then check the vertical collisions
457:05 - in which we want to check self.
457:06 - direction. y if this one is greater or
457:09 - smaller than zero if it is greater than
457:13 - zero we are moving down and want to
457:15 - check the bottom of the player if this
457:18 - one collides with the Sprite we want to
457:20 - set the bottom to the top of the Sprite
457:23 - and vice versa if the player is moving
457:25 - up and we have a collision then self.
457:28 - rec. Toop should be sprite. w. bottom if
457:33 - I now run around we're getting
457:35 - collisions with the level finally then
457:38 - we are going to need a camera for that
457:42 - inside of the code folder I want to add
457:45 - groups
457:46 - dop as always we will need from settings
457:50 - and import everything then class all
457:55 - Sprites which is going to be a child of
457:57 - pygame Dos sprite.
458:00 - group a Dunder init method is always
458:03 - needed although this one without custom
458:05 - parameters and we want to call Super
458:07 - Dunder init also self.
458:11 - displore surface is going to be py game.
458:15 - display and get
458:17 - surface that's the easy part besides
458:20 - that we want to have a custom draw
458:22 - method with self and a Target uncore
458:26 - position via this target position we
458:28 - want to influence uence self. offset on
458:32 - X and
458:34 - Y and at this point I realized I have
458:36 - forgotten to create self. offset this
458:39 - one is simply a pame vector 2 self.
458:43 - offset dox is going to be the negative
458:46 - value of Target position zero or the
458:49 - horizontal position of the player and
458:51 - from that we are subtracting window Wii
458:54 - divided by two a very similar thing we
458:57 - want to do for self. offset doy
459:00 - except for this one we want to get the
459:01 - vertical position and subtract
459:05 - window height divided by two that way we
459:09 - are getting the offset for the camera
459:11 - that we can use with force sprite in
459:14 - itself and self. display surface. blit
459:19 - with sprite. image and sprite. rec. toop
459:25 - left plus self. offset with that back
459:30 - inside of main.py when we are calling
459:33 - all Sprites do draw we do not want to
459:36 - have the argument anymore and also when
459:39 - we are creating all Sprites this should
459:42 - be all
459:44 - Sprites and for that to work we have to
459:47 - add from groups import all Sprites
459:51 - nearly done the last thing that we have
459:53 - to do is when we are calling the draw
459:55 - method we have to get the player
459:57 - position for which we want to store the
460:00 - player in an attribute self. player is
460:02 - going to be the player Sprite and then
460:06 - self. player. re.
460:09 - Center let's try and we have a camera
460:14 - that is looking pretty good with that we
460:17 - have a basic setup via a few classes so
460:21 - I hope at this point this exercise
460:23 - wasn't impossible and if you could
460:25 - follow along you already know pame
460:27 - pretty well we have to Basics out of the
460:30 - way we can work on the platformer logic
460:32 - which is going to give us an actual
460:34 - platformer game and quite honestly we
460:37 - don't really have to make that many
460:40 - changes for the platformer movement the
460:43 - player is still going to control left
460:45 - and right movement however for up and
460:48 - down the player doesn't have control
460:49 - anymore instead we are using gravity and
460:52 - jumping or in other words we have to
460:55 - increase Direction doy by increasingly
460:58 - large number numbers that way it looks
461:00 - like the player is affected by gravity
461:03 - and when the player jumps we are setting
461:05 - Direction y to some static negative
461:07 - value and we'll talk about this in just
461:09 - a second in a lot more detail that being
461:12 - said though including Delta time with
461:14 - the full speed does include a bit more
461:17 - math which I want to avoid so we're
461:20 - going to set the frame rate to 60 frames
461:21 - per second although if you want to have
461:23 - the full platform experience check out
461:26 - this video in there I create a proper
461:28 - super nintend Nintendo style platformer
461:30 - including an Overworld if you have
461:32 - gotten so far you can follow along with
461:34 - this tutorial just fine back in the code
461:37 - first of all I want to update the frame
461:39 - rate and this I have actually already
461:42 - done because when we are calling the
461:44 - take method we are passing in the frame
461:46 - rate that we getting from settings. PI
461:49 - there we have a frame rate of 60 we
461:52 - already limited our frame rate which for
461:55 - a platformer can be a good idea it makes
461:57 - your math just a bit easier after we
461:59 - have that inside of the move method I
462:02 - want to add a comment with the
462:04 - horizontal movement this is the part
462:07 - we're not going to touch but we do have
462:09 - to make some changes to the vertical bit
462:12 - for now what I want to do if this is the
462:14 - player we should have a downward
462:17 - movement that is getting larger and
462:18 - larger the longer we fall just like real
462:21 - world gravity for that in the dunder
462:24 - init method of the player I want to add
462:27 - another attribute self.
462:29 - gravity which I have set to 50 before we
462:33 - are updating self. r.y I want to update
462:36 - self. Direction doy and increase this
462:41 - value by self. gravity multiplied with
462:45 - Delta time afterwards on the next line
462:47 - self. rec. Y is going to be increased by
462:50 - self. Direction although for this we
462:53 - don't need speed and Delta time anymore
462:56 - and what is happening now on the first
462:58 - line when then we are increasing self.
463:00 - Direction doy we are making this value
463:03 - larger and larger on every single frame
463:06 - because we keep on adding to the
463:08 - existing value on top of that this self.
463:11 - direction we are adding to the vertical
463:13 - position of the
463:15 - player that way we are falling at an
463:17 - increasingly large speed although if I
463:20 - run main. Pi we are well we are falling
463:24 - and we have collisions but if I keep on
463:26 - falling we are falling at a constant
463:28 - rate rate what is the issue
463:31 - here and well if you look at the player
463:34 - in the input method we are normalizing
463:38 - the direction Vector because of that all
463:41 - of these values are normalized or in
463:43 - other words the entire length of the
463:45 - vector never exceeds one fortunately
463:47 - that is very easily fixable we simply
463:50 - have to remove those two lines and then
463:52 - if I run main. Pi we are getting proper
463:56 - gravity although it's still not ideal
464:00 - let me run all of this again so we have
464:02 - some basic gravity but if I fall again
464:04 - we are falling really fast the issue for
464:07 - all of this is imagine that we have the
464:10 - player standing on a platform and also
464:15 - because
464:17 - of those two lines we keep on increasing
464:20 - the gravity on the first frame the
464:22 - player move down by this amount and then
464:25 - be constrained by the platform which is
464:28 - totally fine a few frames later we go a
464:31 - bit further down because of the gravity
464:33 - and we are still constrained by the
464:36 - platform however after some more time
464:39 - the gravity puts the player so far down
464:41 - that we are skipping the platform
464:43 - entirely as a consequence the player
464:46 - teleports right through and all of the
464:48 - collisions stop working we are simply
464:50 - moving too fast for them to fix that we
464:53 - want to work inside of the collisions
464:57 - specifically when the the rectangle
464:59 - bottom of the player collides with the
465:01 - top of an obstacle if that is the case
465:05 - then we also want to set self. Direction
465:08 - doy
465:10 - to0 with that if we are on the floor the
465:13 - gravity doesn't keep on increasing which
465:16 - means we get proper gravity and if I
465:19 - fall down again we get a much nicer
465:22 - gravity
465:23 - Behavior now other than that we can't
465:25 - really do very much but at least this
465:28 - part is working
465:29 - next up then I want to implement a jump
465:32 - mechanic for which inside of input I
465:35 - want to check if keys and py game.
465:40 - Kore space I want to set self. Direction
465:44 - doy to -20 with that inside of the game
465:50 - I can now jump around and this is giving
465:53 - us a very basic platformer that's
465:56 - looking really good but it's not ideal
465:58 - yet because the player can jump the
466:02 - entire time even if we are not on the
466:04 - floor so essentially we are
466:07 - flying which could be a nice effect but
466:10 - not what I want for this
466:11 - game we only want to allow a jump if the
466:15 - player is on the floor for that I want
466:18 - to add another attribute self.
466:21 - onore floor which by default let's set
466:25 - this one to fults and only allow a jump
466:29 - if we are pressing space and self dot on
466:33 - floor so how can we tell if the player
466:35 - is on the floor that part is going to be
466:38 - your exercise I want you guys to find a
466:41 - way to detect if the player is on the
466:43 - floor or not try to figure this one out
466:46 - on your
466:49 - own I want to work inside of the
466:52 - Collision
466:54 - method and effectively if we have a
466:57 - vertical Collision
466:59 - where the player is moving down then we
467:01 - are already setting Direction doy to0
467:04 - that means we must be on the floor in
467:08 - other words self. on floor is going to
467:10 - be true although you also need to be
467:13 - careful here because at the moment we
467:16 - are only ever enabling on floor we are
467:19 - never disabling it or in other words if
467:22 - I now run main not
467:24 - Pi the player can still jump around in
467:28 - the air
467:29 - to fix that at some point we have to set
467:33 - self. on floor to false and this I want
467:37 - to do inside of the vertical movement
467:40 - before we are doing anything else in
467:42 - there self dot on floor should be false
467:47 - so that basically on every single frame
467:48 - of the game we are first setting on
467:51 - floor to false then we are doing all of
467:53 - this and inside of the collisions if the
467:57 - player collides with the floor then we
467:59 - are setting on floor to True once we
468:01 - have that inside of main Pi I can only
468:04 - jump if the player is on the floor so I
468:07 - keep on pressing space but we only ever
468:10 - get a single jump that being said I am
468:12 - not the biggest fan of this approach
468:15 - ideally before we getting the input I
468:18 - would want to self. check uncore floor
468:24 - and put all of this into a separate
468:27 - method which we can Al do fairly easily
468:30 - for that I want to have a check uncore
468:33 - floor method without any custom
468:36 - parameters also self. on floor inside of
468:40 - collisions and inside of move should
468:43 - disappear instead what I want to do
468:46 - inside of check floor I want to create a
468:49 - bottom rectangle which we're going to do
468:52 - via py game. F
468:55 - rectangle in which we first of all need
468:57 - a position this this can be 0 and zero
469:00 - we will change that in a second anyway
469:03 - and the width of this rectangle is going
469:04 - to be self. rect do width and a height
469:08 - of two imagine this is the player and we
469:12 - want to check if this player is on the
469:15 - floor what I want to do for that is
469:17 - create another rectangle right below the
469:20 - player and check if this rectangle
469:22 - collides with any of the floor tiles and
469:26 - that rectangle is going to be the bottom
469:28 - rectangle although at the moment the
469:29 - position of this rectangle is off I want
469:32 - this always to be at the bottom of the
469:34 - player and for that we can add in
469:36 - another method move to because in there
469:40 - you can specify a specific point that we
469:42 - can place in my case this is going to be
469:45 - the mid top the position of this point
469:48 - should be self. rec. mid bottom so one
469:52 - of the limitations of py game. re or py
469:55 - game. F re is that we are always placing
469:57 - the top left so whatever Point you're
469:59 - specifying in here is always going to be
470:01 - the top left which very often isn't what
470:04 - you want and using move two is a really
470:07 - handy way to get around that so next up
470:10 - we want to check if this rectangle is
470:12 - colliding with any of the Collision
470:15 - Sprites for that you could write a for
470:18 - Loop but I prefer another approach the
470:21 - way I approach this I am first of all
470:23 - going to create a level rects list I
470:27 - want to use list comprehension and then
470:29 - get sprite. Rec for sprite in self.
470:34 - Collision Sprites that way I am getting
470:38 - a list of rectangles that Define the
470:40 - level and then I want to get the bottom
470:43 - rectangle and check Collide list with
470:46 - the level recks that we have just
470:48 - created and just to demonstrate what is
470:51 - happening here let me print the return
470:54 - value and then run main. Pi we are now
470:59 - getting 34 35 51 59 60 and seemingly a
471:05 - random integer what does it mean and
471:08 - also really important if we don't have a
471:11 - bottom Collision then we getting ne1
471:14 - essentially Collide list is going to
471:16 - look at the collisions between the
471:17 - bottom rectangle and the level
471:19 - rectangles and it's going to return an
471:21 - integer of the index of the rectangle
471:24 - that we are colliding with and if
471:26 - there's no Collision we getting negative
471:28 - one or in other words if we have a
471:30 - negative one then we know there's no
471:33 - Collision which means we can do
471:35 - something like self dot on floor is
471:39 - going to be true if we have a bottom wck
471:43 - with Collide list and this value needs
471:46 - to be greater or at least equal to zero
471:50 - if that is not the case else this value
471:52 - should be false once we have that the
471:55 - player can only jump if we are on the
471:58 - floor
471:59 - also we can refine all of this by simply
472:01 - passing the list comprehension straight
472:04 - into Collide list that way we are saving
472:07 - one line and the code feels a bit more
472:10 - elegant and if you want to have a more
472:13 - advanced platformer being able to detect
472:15 - collisions with the floor or the walls
472:17 - is really important so with this logic
472:20 - you could also very easily detect a
472:22 - collision with the left or the right
472:24 - side of the
472:26 - player but anyway there's just one more
472:28 - thing that I want to do back inside of
472:30 - the game there's one issue right now if
472:33 - I jump and we have a top Collision the
472:36 - player hovers in the air for just a bit
472:39 - which is a very strange effect if I find
472:43 - another area you can see it even better
472:45 - here if once again this is the player
472:48 - and the player is moving up because we
472:50 - are jumping and then we have some kind
472:53 - of top
472:55 - Collision we are stopping the player at
472:58 - the bottom side of this Collision but
473:00 - the player direction is still pointing
473:02 - up and it takes a while for Gravity to
473:05 - pull it down again that way it looks
473:08 - like the player is hovering in the air
473:10 - and this we can fix quite easily by
473:13 - setting self. Direction doy to Z if we
473:20 - have a top or bottom
473:22 - Collision that way inside of main. Pi I
473:26 - can collide with the top and to player
473:28 - fults down
473:30 - immediately and this is feeling a lot
473:34 - better and once again all of this can be
473:36 - organized just a bit better I want to
473:40 - remove the indent and cut out self.
473:45 - Direction and for self. direction being
473:48 - smaller than zero this should also not
473:51 - be indented anymore and all we really
473:53 - want to do is set self. direction if we
473:56 - have the vertical direction that way
473:58 - back inside of main. Pi we should be
474:01 - getting the same result let's try it
474:03 - here that is looking really good so this
474:06 - seems to be working pretty well
474:10 - perfect and also our code is feeling a
474:13 - lot more organized quite honestly there
474:16 - really wasn't that much of a change
474:17 - compared to a top down game although for
474:20 - the animations we do have to include a
474:22 - few more bits that's going to be the
474:24 - next section for the next part we are
474:27 - going to cover Imports and animations by
474:30 - the end of it we have a basic player
474:32 - animation and we also have the very
474:34 - basic
474:35 - enemies at this point the enemies don't
474:37 - do very much but that we can work on
474:40 - later and there isn't going to be that
474:42 - much new stuff for this section we are
474:45 - going to use basically the same
474:47 - animation logic that we have already
474:48 - seen the only change is that we have to
474:51 - update the state management for the
474:53 - player who account for the platform of
474:55 - logic that being said when we are doing
474:57 - the input ports I want to centralize
474:59 - them quite a bit more or in other words
475:02 - I want to have one method that loads all
475:04 - of the files and then we don't have to
475:06 - worry about it anymore inside of the
475:09 - game class I want to create a method
475:13 - called load uncore assets no need for
475:17 - custom parameters and in there I want to
475:20 - load all of the graphics and all of the
475:23 - sounds for example in there I want to
475:26 - have self. player frame
475:29 - which should be a list with the
475:30 - animation frames of the player or in
475:32 - other words to visualize all of this
475:34 - inside of images we have a very basic
475:38 - player animation it really doesn't do
475:40 - very much all of this we want to import
475:43 - for that I want to create a separate
475:46 - function import uncore folder in which
475:49 - we can specify the file path I want to
475:52 - go to images and in there we have the
475:55 - player this I want to import which which
475:58 - doesn't exist at the moment for which we
476:01 - want to create another python file let's
476:04 - call it support. Pi in there as always
476:08 - we will need from settings and import
476:12 - everything and then I want to start by
476:14 - creating an import image function this
476:18 - is not going to import an entire folder
476:21 - so we couldn't use it for the player
476:23 - import but what we could be using it for
476:25 - let me comment out the player stuff and
476:27 - instead I want to import self.
476:31 - bullet surface or in other words what we
476:35 - want to start importing is inside of
476:37 - images we have gun and there's bullet
476:40 - and fire I want to import the bullet for
476:42 - now via a more convenient method or in
476:45 - other words I want to run import uncore
476:49 - image with a file path we want to go to
476:53 - images then we want to go to gun and
476:57 - finally we want to go to Bullet notice
477:00 - here I am not specifying the file type
477:03 - we do not addpng at the end and that is
477:06 - intentional also what we are going to
477:08 - need is from support import everything
477:14 - that way we have this import image and
477:17 - first of all what I want in there is to
477:19 - unpack all of the arguments which are
477:21 - going to be the path so all of this
477:23 - stuff we want to have straight away and
477:27 - just so you can see what we are getting
477:29 - via this unpacking parameter I want to
477:31 - print the path and then call load assets
477:35 - which we have to do before we are
477:36 - calling the setup method self. load
477:39 - assets and now if I run all of this we
477:42 - getting a tupo with the three arguments
477:45 - we have specified and because of this
477:48 - unpacking parameter we can specify as
477:51 - many arguments as we want we are always
477:53 - going to get a tupal with all of them
477:55 - which we can actually use to create a
477:58 - full path right away using the join
478:01 - method we simply have to add the path in
478:03 - here although for that we want to unpack
478:06 - the path one more time that way we are
478:09 - splitting up this tupal into three
478:11 - values and then we can use it inside of
478:14 - the join method the end result is going
478:17 - to be if I print the full path we
478:21 - getting the full path to this file
478:24 - images gun and bullet that is looking
478:27 - really good although we are also going
478:28 - to need the file format this I want to
478:31 - be able to specify inside of the
478:34 - parameters in there I want to have a
478:37 - format and since we are almost always
478:39 - working with a PNG file this should be
478:41 - the default or in other words if we
478:43 - don't specify anything we should be
478:46 - getting a PNG file and to add that to
478:48 - theault path I simply want to add an F
478:52 - string with Dot and then the
478:56 - format that way I can run main.py again
478:59 - and we are getting images gun and
479:01 - bullet.png that is working really well
479:05 - that we can now use to import a surface
479:09 - via py game. image. load with the full
479:14 - path and now we have to decide do we
479:17 - want to convert all of this or convert
479:19 - Alpha all of this which depends on the
479:22 - image having Alpha values or not which
479:25 - we cannot really detect meaning this has
479:27 - to be another parameter I want to know
479:30 - if there are alpha values inside of this
479:32 - image and by default I am going to
479:34 - assume that there are some because
479:36 - that's usually what you see and then run
479:39 - convert Alpha if Alpha is true and if
479:43 - that is not the case we want to run all
479:46 - of this once again except now only
479:50 - convert without Alpha and that is
479:53 - basically
479:54 - it at the end of all of this we want to
479:56 - return the surface
479:58 - and then we are getting the surface
480:01 - inside of this parameter I can print
480:03 - self. bullet surface run all of this and
480:08 - we are getting a surface we are still
480:10 - doing a basic import via py game. image.
480:13 - load but we are now adding a few more
480:15 - extra things to make all of this quite a
480:17 - bit more convenient not a major change
480:20 - but if you have to import hundreds of
480:22 - images this can be a massive difference
480:25 - and by the way all of this can be made
480:26 - quite a bit more elegant right away we
480:29 - don't actually need a surf variable we
480:31 - can return the surface from py game.
480:34 - image. load right away the result would
480:37 - be identical so with that we can import
480:40 - a single image much more elegantly
480:43 - besides that I also want to be able to
480:45 - import a folder for which once again we
480:49 - want to specify a path and unpack it
480:52 - right away via that we are going to
480:55 - import all of the player frames we are
480:59 - already calling import folder and
481:01 - getting images and player notice here
481:04 - this is a path to a folder not to an
481:07 - image so what we want to do is import
481:09 - all of the images inside of this folder
481:13 - I first of all want to create a local
481:16 - variable called frames and this has an
481:19 - empty list by
481:21 - default afterwards we want to do for
481:25 - folder uncore path and then
481:28 - subfolders and finally file uncore names
481:32 - in walk join and then unpack the path
481:38 - this is the logic we have already seen a
481:39 - couple of times we are basically using
481:42 - the walk method to walk through a folder
481:44 - and get the folder path the subfolders
481:46 - and the file names in there I want to
481:49 - have for file uncore name in file
481:54 - names and then create a full underscore
481:59 - path which we're doing via the join
482:02 - method where we are getting the full
482:04 - folder path and then the file name via
482:08 - this we can create a surface with py
482:11 - game. image. load the full path and for
482:16 - this we basically always want to convert
482:19 - Alpha now you could make this a bit more
482:21 - flexible like we have done in import
482:23 - image and add a custom parameter
482:26 - although I don't think this is really
482:28 - necessary after that I want to get the
482:30 - frames and then append the Surface by
482:34 - the end of
482:35 - it I want to return the
482:40 - r with that back inside of main. Pi I
482:43 - can print self. player frames run all of
482:48 - this and we are getting a list of
482:51 - surfaces that is all we need for the
482:54 - player animation frames or rather the
482:56 - import of the player animation frames
482:59 - now this I want to change in two ways
483:02 - the first one is easy once again we
483:05 - don't really need this local surface
483:06 - variable we can simply append High game.
483:10 - image. load to frames straight away also
483:14 - since we're not using subfolders there
483:16 - should be an underscore besides that
483:18 - this slightly more important change is
483:20 - that I want to sorted the file names
483:25 - just to make sure that they are being
483:26 - imported in order for that we will need
483:29 - a key with a Lambda function where we
483:33 - have a name parameter and once again as
483:35 - a reminder what we're getting with the
483:38 - file name is something like
483:41 - 0.png and we want to isolate the zero
483:44 - and turn it into an integer that way we
483:47 - can sort all of these
483:49 - values which means I want to create an
483:51 - integer get the name and split it
483:54 - wherever we have a DOT and then pick the
483:58 - first value the end result is going to
484:01 - be the same but in some cases it might
484:03 - prevent a bug but anyway with that we
484:06 - have the basic graphic Imports what we
484:08 - can now do besides the bullet surface we
484:11 - also want to have a fire uncore surface
484:14 - that we are getting via import image and
484:17 - we want to get images gun and fire next
484:21 - up I want to have self. bore frames
484:25 - which we're getting from import folder I
484:29 - want to go to images there we have the
484:31 - enemies and in there we have the b or in
484:35 - other words if you look at the images
484:38 - folder there we have enemies and the B
484:40 - frames there are only two images in
484:43 - there besides that we have the worm and
484:45 - this one looks really similar or in
484:48 - other words I can duplicate this line
484:50 - and then get the worm frames with images
484:54 - enemies and worm and that that is
484:58 - covering all of the Imports for the
485:00 - graphics now we have to figure out how
485:02 - to use them for that I want to work
485:05 - inside of the Sprites for a basic
485:08 - animation I want to have a class
485:11 - animated Sprite Which is going to
485:14 - inherit from the Sprite class that we
485:16 - have created so let me open it this is
485:19 - going to be the parent class which means
485:22 - when we are calling thunder in it I want
485:25 - to specify besid self the frames a
485:28 - position and the groups after that when
485:32 - we are calling super thunder in nit we
485:35 - are calling this thunder init method for
485:38 - which we do have a position that we
485:40 - don't have a surface but then once again
485:43 - we have a group's parameter so we have
485:46 - to figure out this surface for that we
485:49 - need just a bit more information I want
485:51 - to have three attributes self. frames
485:55 - self. frame uncore index and self.
486:00 - animation uncore
486:03 - speed the values for all of them are
486:06 - going to be the frames
486:08 - parameter the value zero and for the
486:11 - animation speed I went with 10 once we
486:13 - have that inside of super Dunder init we
486:17 - can get the surface via self. frames and
486:21 - self. frame index that's basically it
486:25 - besides that I also want to have an
486:28 - animate method wave self and Delta time
486:32 - in there self. frame index plus equals
486:35 - self do animation speed multiplied with
486:39 - Delta time and self. image is going to
486:42 - be self do frames with an integer of
486:46 - self. frame index then modulus with
486:50 - length of self. frames that would be a
486:55 - really basic animated Sprite class
486:58 - and I hope you can see at this point why
487:00 - inheritance is quite useful for this
487:02 - class we never specify the image or the
487:04 - rectangle all of that is handled via the
487:07 - parent class and that system we're going
487:10 - to expand on quite a bit because
487:12 - animated Sprite is never going to be
487:14 - used inside of the game the only way
487:17 - that we are going to use it is as the
487:20 - parent class for the player and there we
487:23 - want to have the animated Sprite for
487:26 - that to work we have to make a few
487:29 - changes most importantly when we are
487:32 - creating one instance of the player I
487:34 - want to have a bunch of frames and also
487:38 - we don't want to have a surface anymore
487:40 - instead I want to pass the
487:43 - frames through to the parent class
487:46 - because now when we are calling this
487:48 - Stander init method we are effectively
487:51 - running all of this for which we are
487:53 - going to need frames positions and
487:56 - groups and I really realiz the order
487:58 - here is a bit messed up the first
488:00 - argument needs to be
488:02 - frames then we have the position and
488:04 - then we have the groups once we have
488:07 - that inside of main. Pi when we are
488:10 - creating the player instance we have to
488:14 - add one more argument self. player
488:17 - frames and now if I run all of this we
488:21 - have a very basic player image which
488:24 - isn't animated yet because we we are not
488:27 - calling the animate method that is a
488:31 - very easy thing to fix inside of update
488:33 - self. animate with Delta time after that
488:38 - we are getting the
488:41 - animation that is looking pretty good
488:45 - and once again notice here we didn't
488:47 - write any logic inside of the player for
488:50 - the animation all of that happens inside
488:52 - of the parent class which makes it much
488:55 - easier for us to organize all of this
488:58 - although truth be told we do have to
489:00 - override the animate method I want to
489:02 - have inside of the player Define animate
489:05 - with self and Delta time or in other
489:08 - words at this point from animated Sprite
489:11 - this method is not going to work anymore
489:14 - that is necessary because for the player
489:16 - we have to account for the different
489:17 - states for example if the player is not
489:19 - moving then we shouldn't have an
489:21 - animation but step by step first of all
489:24 - let's recreate the very basic logic I
489:27 - want to have self. image is going to be
489:30 - self. frames and then via the integer we
489:34 - are doing self. frame index
489:38 - modulus with the length of self. frames
489:42 - also we're going to need self. frame
489:45 - index plus equal self do animation speed
489:50 - multiplied with Delta time although this
489:54 - we only want to do if a certain
489:56 - condition is true in my case if self.
489:59 - direction dox is different from zero or
490:02 - in other words we only want to update
490:04 - the animation if the player is moving
490:06 - left or right with that back inside of
490:09 - main. Pi if I'm not moving we have no
490:12 - animation however once I'm going left or
490:14 - right the player is animating that is
490:18 - working quite well also if the player
490:20 - stops moving else then I want to set
490:25 - self. frame index to zero that way we
490:29 - are going back to the starting position
490:31 - let's
490:32 - try and I can move around if I'm moving
490:37 - we get the walking animation but if I
490:38 - stop moving the player is Idle the one
490:42 - major thing that is missing at this
490:43 - point is that the player is always
490:45 - facing to the right to fix that I want
490:49 - to inside of the dander init method add
490:52 - another attribute self. flip and by
490:55 - default this one is going to be faults
490:58 - next up after we have gotten the part
491:00 - from the animation I want to add another
491:03 - thing to self. image or in other words I
491:06 - want to run py game.
491:08 - transform. flip with self. image self.
491:13 - flip this is for the horizontal flip and
491:15 - for the vertical flip this one should
491:17 - always be false that why by default we
491:20 - are not going to get any change however
491:23 - if we are setting self. flip to
491:27 - through then the player is always going
491:30 - to be flipped with the animation still
491:32 - working just fine which means we just
491:35 - have to update this value in real time
491:38 - which we're doing inside of this if
491:40 - statement if we have movement or in
491:42 - other words if self. direction dox is
491:45 - different from zero then we want to set
491:47 - self. flip to self. Direction dox being
491:53 - smaller than zero this is going to
491:55 - return a Boolean value if if we are
491:57 - moving right it's going to be true if we
491:59 - moving left it's going to be false and
492:01 - this is then going to influence the flip
492:04 - method I can move to the right and to
492:06 - the left and we always get the proper
492:09 - facing Direction so this is working
492:12 - quite well the last thing that I don't
492:14 - like is that if the player is jumping we
492:17 - still are playing The Walking animation
492:19 - which looks really weird to fix that
492:23 - before we are doing anything in the
492:25 - image I want to check if not self. onf
492:29 - floor or in other words this if
492:31 - statement is checking if we are in the
492:33 - air and if that is the case self. frame
492:36 - index should be zero let's try now and
492:39 - if I'm on the floor we have the walking
492:41 - animation but if I am jumping we are
492:44 - getting the first frame so this is kind
492:47 - of working the issue is we don't want to
492:49 - have the frame with the index zero we
492:52 - want to have the index one that is going
492:55 - to look much better now it looks like
492:56 - the player is
492:58 - jumping which I like much better and
493:01 - this we can make just a bit more elegant
493:04 - I want to set self. frame index to
493:08 - one if the player is not on the floor if
493:12 - that is not the case else then we want
493:14 - to keep self. frame index and then we
493:17 - also don't need the other stuff
493:19 - anymore and that feels a bit
493:22 - nicer the end result though is still
493:25 - going to be just the same
493:27 - perfect and with that we have a very
493:30 - basic player animation which is getting
493:32 - us very close to a proper
493:35 - platformer to finish up all of this
493:37 - let's do an exercise I want you guys to
493:39 - do two things number one create a class
493:42 - for the be and to worm later on those
493:44 - two are going to behave differently so
493:46 - we will need two classes although both
493:49 - should animate from animated
493:50 - Sprite then create one instance of each
493:53 - in the level and really important for
493:55 - this one both of these enemies should be
493:58 - animated besides that write a function
494:00 - to import all of the audio files you
494:03 - don't have to play them at this point I
494:05 - simply want to have all of the files
494:07 - inside of the game that should be quite
494:09 - a bit of work pause the video now and
494:11 - see how far you
494:14 - get righty to get started with the
494:17 - enemies I want to create another class
494:20 - called
494:21 - e and this one for the parent is going
494:24 - to have an animated Sprite Which which
494:27 - means when we have the dunder init
494:29 - method we want to have a bunch of frames
494:32 - a position and the groups and then I
494:35 - want to call Super Thunder init in which
494:39 - we are calling this thunder init method
494:42 - for that we already have all of the
494:44 - arguments we need the frames the
494:48 - position and the groups and that is all
494:51 - we need to get started so inside of
494:54 - main.py when we are calling the setup
494:57 - method I want to create one instance of
495:00 - a b somewhere on the level for that we
495:03 - will need self. B frames the input for
495:07 - that we have done earlier this value
495:09 - here for the position let's go with 500
495:13 - and 600 to entirely random values
495:17 - finally for the groups I want to have
495:18 - self. all Sprites for now after that if
495:22 - I run the game you can see we have one B
495:25 - inside of the level doesn't do anything
495:27 - at the moment but at the very least we
495:29 - have something and to animate this B you
495:33 - could simply write an update method
495:35 - inside of the class don't forget Delta
495:37 - time and then call self. animate with
495:40 - Delta time if you do that we have an
495:44 - animated B so this is all we needed for
495:47 - this part next up I want to copy all of
495:51 - this and then create a
495:53 - warm
495:55 - class which for now at least is going to
495:58 - stay identical to the b class which
496:00 - means inside of main. Pi I want to
496:03 - create a warm and for that we will need
496:06 - self. warm frames for the position let's
496:10 - go with 700 and
496:13 - 600 and then self. all
496:16 - Sprites I can run the game now and we
496:19 - are getting a warm somewhere in the air
496:22 - not perfect yet but that we can work on
496:24 - in the next bit before for that we want
496:28 - to import all of the sounds for which we
496:31 - could do something like import image or
496:33 - in other words we could wrap py game.
496:36 - mixer. sound in some other stuff to make
496:39 - it more efficient but I want to go a bit
496:41 - further I want to have self. audio and
496:43 - this is going to be a dictionary that
496:45 - will be created via audio
496:49 - importer the file path for this one is
496:51 - simply going to be
496:53 - audio this function doesn't exist at the
496:55 - moment so in inside of support. Pi I
496:59 - want to have audio uncore
497:03 - importer for which we need a path
497:05 - parameter that we are unpacking right
497:08 - away in there first of all I want to
497:11 - create an audio dictionary which doesn't
497:14 - have any values by
497:16 - default then once again I will need for
497:19 - folder uncore PA we don't care about
497:22 - subfolders so underscore and then file
497:25 - underscore names in walk join and
497:28 - unpacking the path in there we want to
497:31 - check for file uncore name in file
497:35 - names and now we don't have to sort the
497:38 - file names because we don't care about
497:40 - the order of the sound files this one
497:41 - simply doesn't matter I want to create a
497:44 - full underscore path via the join method
497:48 - I want to combine the folder path with
497:50 - the file name once we have that I can
497:54 - get the audio dictionary and then create
497:56 - create a key which should be the name of
497:59 - the audio file and I should actually
498:01 - explain so at the moment we don't need
498:03 - code data or images I want to look at
498:06 - the audio folder in there we have
498:08 - impact. OG music. wav and shoot.
498:13 - wav for this audio dictionary the key
498:17 - should be the name of the file without
498:19 - the file ending which I can get via the
498:22 - file name and then use the split method
498:25 - once again to split all of this wherever
498:28 - we have a DOT and then pick the first
498:30 - value that way we're getting the name of
498:32 - the file without the file ending and the
498:35 - associated value should be py game.
498:38 - mixer. sound with the full uncore path
498:43 - and that is literally it at the end of
498:45 - all of this we can return the audio
498:48 - dictionary and that we are capturing
498:51 - inside of self. audio in other words if
498:54 - I print self. audio and run the entire
498:57 - game we are getting a dictionary with
499:01 - three sound files or rather three key
499:04 - value pairs the name of the file and
499:07 - then the sound object and to use that
499:09 - all we would really need to do for
499:11 - example to play the background music is
499:13 - self. audio and then the music with play
499:18 - inside of the
499:19 - [Music]
499:22 - game we are getting some music
499:27 - although this isn't something that I
499:28 - want to do because it would be really
499:30 - distracting anyway with that we have a
499:34 - whole bunch of imports and we have the
499:36 - player animations for the next section
499:39 - we are going to add proper timers which
499:41 - are going to do quite a bit inside of
499:43 - the game for example we have a cool down
499:46 - for the bullets and every time the
499:47 - player shoots a bullet we have a short
499:49 - fire animation both of those things are
499:51 - going to be heavily influenced by the
499:53 - timers on top of that we have a repeated
499:56 - timer that creates a b enemy and all of
499:59 - this we want to have as flexible as
500:01 - possible or more generally games rely
500:04 - heavily on timers for example for this
500:07 - game whenever the player shoots a bullet
500:09 - we have a cool down we spawn a b every X
500:12 - seconds we have a fire sprite animation
500:14 - for a bit that gets destroyed after a
500:16 - few milliseconds and all of the enemies
500:19 - will die after 0.2 seconds after being
500:22 - shot for all of these things we will
500:24 - need a timer or other words ideally we
500:28 - want to have a reusable timer that can
500:30 - do number one be easily called
500:33 - anywhere it should also call a function
500:35 - on timeout and it should be repeatable
500:38 - and for all of this we have already seen
500:40 - the most fundamental Logic for a timer
500:42 - we are simply getting the current time
500:44 - subtract the start time and if the
500:46 - resulting value is greater than some
500:47 - duration we are doing something this is
500:50 - some very basic logic but this I want to
500:52 - expand upon and also at this point I do
500:55 - not want to use the build python events
500:57 - anymore because those just aren't that
501:00 - flexible and the system that we are
501:01 - going to create will be much better for
501:04 - all of that back inside of the code I
501:07 - want to create another python file
501:10 - timer. Pi first of all we will need from
501:13 - settings and import everything
501:16 - afterwards we have a timer class without
501:20 - any inheritance I want to have a Dunder
501:23 - init method with quite a few parameters
501:26 - the most important one will be the
501:28 - duration besides that we have a function
501:31 - with a default value of none then we
501:34 - have a repeat value also with a default
501:37 - value of none and we have an
501:41 - auto start parameter that by default is
501:44 - going to be false after that I want to
501:47 - set self. duration to the
501:51 - duration I want to set self. start time
501:55 - to Z
501:57 - and finally self. active is going to be
502:01 - false by are those three values we can
502:05 - create an update
502:07 - method in which we are fundamentally
502:10 - going to check if the
502:13 - current time minus self. start time is
502:18 - greater or equal to self. duration and
502:21 - if that is the case we want to do
502:23 - something now this is not going to work
502:25 - at the moment because we do not have the
502:27 - current time for that we would need py
502:30 - game. time.get Pi next up if this if
502:34 - statement does happen to be the case we
502:36 - want to run self.
502:40 - deactivate and while we are here I also
502:43 - want to create an activate method
502:46 - without any custom parameters so we want
502:48 - to have activate and deactivate for both
502:51 - of those methods for self. activate we
502:55 - want to have self.
502:56 - active being through and self. start
503:01 - time is going to be py. time.get uncore
503:05 - tick for deactivate we are going to do
503:08 - basically the opposite self. active will
503:12 - be BS and self. start time we can set
503:16 - back to zero and that is all you need
503:19 - for a basic timer to go over it really
503:21 - quickly by default we have the dander in
503:24 - it method and to activate the timer we
503:26 - are calling activate in there we're
503:29 - getting the start time which we are
503:32 - using inside of the update method and
503:34 - there we are checking the current time
503:37 - and subtracting the start time if the
503:40 - resulting value is greater than self.
503:42 - duration then we are calling self.
503:45 - deactivate which is going to set self.
503:47 - active to false and to start time to
503:49 - zero so with that via self. active we
503:52 - can check if this timer is active or not
503:55 - and the way you would be using that
503:57 - let's start inside of the player we
504:00 - don't need any of the other
504:03 - classes I want to work inside of the
504:05 - dunder init method and create a timer
504:08 - section for the player we only want to
504:10 - have a shoot uncore timer which is going
504:14 - to be the timer class we have just
504:15 - created and for that we have to import
504:18 - from timer import timer for now we can
504:22 - only set a duration 500 or half a second
504:26 - we working in milliseconds here next up
504:29 - when we are calling the input method I
504:31 - also want to check if keys and high
504:35 - game. Kore s that is the S key on the
504:39 - keyboard that I want to use for firing a
504:41 - bullet if that is the case
504:44 - shoot bullet if we run this without
504:48 - anything else I can press s and we're
504:50 - getting shoot bullet on every single
504:52 - frame of the game or in other words we
504:54 - will be shooting a bullet 60 times times
504:56 - per second which obviously would be way
504:59 - too many
505:00 - bullets so we are going to need a
505:03 - cooldown timer which we get via the
505:05 - shoot time or in other words we want to
505:08 - check two conditions if the player is
505:10 - pressing a button and self. shoot
505:15 - timer. active and also this should be
505:18 - self. shoot timer inside of thunder in
505:20 - it also also we want to check if this
505:23 - shoot timer is currently not active or
505:27 - in other words after the player shoots
505:29 - one bullet we want to get self do shoot
505:32 - timer and activate it so while the timer
505:34 - is running the player is not able to
505:37 - shoot a bullet just one more thing
505:39 - before we can use all of this the timer
505:42 - is only going to work if we are calling
505:44 - the update method which at the moment we
505:46 - are not doing for this self do shoot
505:48 - timer so nothing would happen to fix
505:51 - that inside of the update method before
505:53 - we are doing anything else self do shoot
505:57 - timer do
505:59 - update that way inside of the game if I
506:02 - hold down s we are only getting one
506:05 - bullet every 500
506:07 - milliseconds and if I
506:10 - increase the duration to let's say
506:14 - 1,500 I can try all of this again and
506:17 - now we are getting much fewer
506:20 - bullets looking pretty
506:22 - good besides that inside of the timer I
506:25 - want to have three more
506:27 - things we want to call a function once
506:30 - this if statement triggers then we want
506:33 - to make the timer repeatable and be able
506:35 - to auto start all of this and auto start
506:38 - just to explain it basically activates
506:40 - the timer when we are creating it so we
506:43 - don't have to call activate on it to get
506:45 - started with the function I first of all
506:48 - want to store this as an attribute self.
506:51 - Funk is going to be Funk before we are
506:55 - deactivating the timer I want to check
506:57 - if self. Funk exists and if that is the
507:01 - case I want to call it although before
507:04 - we continue there's one more thing that
507:05 - I want to add self. start time is
507:09 - different from zero when we are getting
507:12 - started the start time is going to be
507:14 - zero and there is a chance that py
507:16 - game.get tick is also going to return
507:18 - zero which means all of this would be
507:20 - running and then we would trigger this
507:22 - one as well and Via this second
507:24 - condition we are avoiding all of that a
507:28 - fairly minor point but it can be a bit
507:30 - annoying anyway to test all of this
507:33 - inside of thunder in it of the game
507:34 - class I want to have a timer as well
507:38 - let's call this one the bore timer for
507:42 - which we will need a timer class that we
507:44 - don't have yet from timer import
507:48 - timer the duration of this one is going
507:51 - to be 200 and then we want to call a
507:54 - function self.
507:57 - creatore B this one doesn't exist at the
508:00 - moment so we have to create it Define
508:04 - create underscore B without any custom
508:08 - parameters inside of this method I
508:11 - simply want to create a b which we have
508:13 - already done so in there we have a b and
508:17 - once again don't forget we have to call
508:20 - before we are doing anything else self.
508:22 - B timer and I realized once again I have
508:25 - forgotten the self anyway after that
508:28 - self. b timer. update now this is still
508:32 - not going to work because this timer
508:35 - does not start by default what we would
508:37 - have to do is call Self dob timer.
508:43 - activate and let's add a slightly larger
508:46 - value so let's say after 2 seconds we
508:49 - want to call this method which would
508:51 - create one instance of a b if I run the
508:55 - game and and after 2 seconds we get a B
508:58 - this has worked really well with that we
509:01 - can do an exercise I want you guys to
509:03 - add the repeat and the auto start
509:05 - functionality to the timer pause the
509:08 - video now and see how far you
509:12 - get Auto starts is the easier part
509:15 - actually all we have to check for this
509:16 - one is if auto start is true then we
509:20 - want to call self. activate right away
509:24 - with that inside of main Hood pi we
509:26 - don't need this activate anymore instead
509:30 - when we are creating one instance of the
509:32 - timer I want to add auto start and set
509:36 - this one to true if I now run all of
509:39 - this we should still be getting a b and
509:41 - we do perfect besides that we have to
509:44 - work on repeat that should be an
509:47 - attribute self. repeat is going to be
509:51 - repeat and basically all that we have to
509:53 - do once all of this is running out and
509:56 - we are calling
509:57 - deactivate we want to check if self.
510:00 - repeat is the case self do activate that
510:05 - way inside of main.py for the B timer I
510:09 - want to set repeat to R and I guess to
510:13 - make all of this a bit more visible I
510:15 - want to have random values from random
510:20 - import Rand int and then for the B
510:23 - position for now I want to have a Rand
510:25 - ROM
510:27 - integer between 300 and 600 and the same
510:32 - I want to have for the Y position also
510:36 - for the timer I want to have a duration
510:38 - of 500 and now let's try all of this and
510:42 - we should be getting a whole bunch of
510:44 - bees that is looking really good perfect
510:48 - and I hope from looking at this thing
510:50 - you can tell that this is much better
510:52 - than the inbuilt python events we don't
510:54 - have to create a custom event or work in
510:56 - the event Loop we are simply creating a
510:58 - timer and then call a function whenever
511:00 - it times out and that's basically it
511:03 - nearly done there's just one more thing
511:04 - that I want to do because in actual
511:07 - larger projects what I ended up doing a
511:10 - lot is checking for self. shoot timer.
511:12 - active and this active you can get rid
511:16 - of you would need let's do it right
511:19 - below Dunder in nich we want to have
511:21 - Define Thunder pool this is is what's
511:26 - being called if you put this timer
511:28 - inside of an if statement the default
511:31 - functionality for this one is that you
511:32 - are always returning true which is not
511:35 - what we want to do in our case we want
511:38 - to return self. active that way inside
511:42 - of the player we can simply check and
511:45 - not self. shoot timer and the return
511:48 - value would be this timer being active
511:50 - or not active or in other words if I run
511:53 - main. pi and I press s and hold it down
511:56 - we are only getting shoot bullet every
511:58 - 1.5 seconds I believe whatever we
512:01 - specified inside of the timer and well
512:04 - with that we have a really powerful
512:07 - timer that we can now use to add a whole
512:10 - bunch of things to our game right below
512:12 - the Sprites I want to create a class
512:15 - called bullet which for the parent is
512:19 - going to have a Sprite after that we
512:21 - will need Thunder a knit with self a
512:25 - surface a position a direction and the
512:29 - groups after that we have to call super.
512:32 - Thunder
512:35 - init in which we are calling this
512:38 - thunder init
512:39 - method for which we will need a position
512:42 - a surface and the groups besides that I
512:46 - want to have some extra stuff for the
512:48 - movement self. Direction needs to be an
512:53 - attribute and then we have self do speed
512:56 - which I have set to
512:58 - 850 besides that we will need an update
513:02 - method with self and Delta time and then
513:05 - call self. rect dox plus equals self.
513:09 - Direction multiplied with self. speed
513:13 - multiplied with Delta time so with that
513:16 - we have a very basic bullet that we now
513:20 - want to create whenever the player
513:22 - presses the S button and the timer isn't
513:24 - active also the bullet we want to have
513:28 - inside of another Sprite group self.
513:33 - bullet unor
513:35 - Sprites pame dos sprite. group this is
513:39 - the part we have seen plenty of times by
513:41 - now to create a bullet below create B I
513:45 - want to have create underscore bullet
513:49 - for the parameters we will need a
513:51 - position and a direction both of those
513:54 - we are going to get from the player
513:56 - although for now I simply want to create
513:59 - a
514:00 - bullet where we already have a surface
514:03 - self. bullet surface we imported this
514:06 - inside of load assets not too long ago
514:10 - for the position and the direction we
514:13 - are simply going to use the
514:15 - parameters finally for the groups I want
514:17 - to have a tupal with self do all Sprites
514:21 - and self. bullet Sprites this create
514:24 - bullet we now have to add to the player
514:28 - I want to have self. create bullet
514:31 - inside of the player for that to work
514:34 - back inside of the Sprites the player is
514:36 - going to need one more parameter create
514:39 - uncore bullet I suppose we can store
514:42 - that one as an attribute right at the
514:44 - top create underscore bullet it's going
514:48 - to be create bullet and this create
514:51 - bullet we want to call instead of the
514:54 - print statement create bullet and then
514:58 - we are going to
515:00 - need a position and a direction for the
515:04 - position at the moment I simply want to
515:06 - get self. rec. Center and for the
515:09 - direction this one should be
515:13 - -1 if self do flip and if it is not the
515:18 - case else it should be one or in other
515:20 - words if the player is facing to the
515:22 - left then we are returning -1 and if not
515:25 - not then we are facing to the right so
515:27 - the Bullet should have a direction of
515:29 - one let's try all of this and if I press
515:32 - s we are getting a bullet not too many
515:36 - because the timer cool down is really
515:37 - large but at least we're getting
515:41 - something I suppose for that we can
515:44 - change the cool down to 500
515:47 - milliseconds that way all of this is
515:49 - going to feel quite a bit
515:52 - better next up the main issue we have at
515:55 - the moment
515:56 - is that the bullet is always facing to
515:58 - the right because we are not making any
516:00 - updates to the surface for that I want
516:03 - to have an
516:06 - adjustment
516:09 - section where we are updating self.
516:12 - image all we need in here is py game.
516:16 - transform.
516:18 - flip with self.
516:21 - image and then for flip X the only thing
516:24 - that we really care about we want to get
516:26 - direction and check if this value is
516:28 - equal
516:30 - to1 or in other words this is only going
516:32 - to be true if the bullet is going to the
516:34 - left or flip y we want to have
516:37 - fults if I now run main. pi and I look
516:40 - to the right we get a bullet facing to
516:42 - the right and if I face left the bullet
516:45 - is also facing left although if you look
516:47 - at the player the starting position of
516:49 - the bullet just isn't
516:51 - ideal or in other words the way you have
516:56 - the issue happens because if this is our
516:59 - player the starting position is always
517:01 - the center and the point we are placing
517:04 - for the bullet is the top left we would
517:07 - always get something like this which
517:10 - really is not ideal to fix that I want
517:13 - to work inside of create bullet and
517:17 - create a custom x value I always want to
517:21 - get the original player Center position
517:24 - or position zero
517:26 - to that I want to add the direction and
517:30 - multiply it with a value that I think is
517:32 - large enough after some testing I landed
517:35 - on
517:36 - 34 but this we only want to do if
517:40 - direction is equal to one or in other
517:43 - words we are going to the right if that
517:45 - is not the case else we still want to do
517:49 - all of this but then we also want to
517:51 - account for the top left position in
517:54 - other words sell dot bullet surface and
517:58 - then get whiffed after we have that
518:02 - instead of the position I want to have a
518:04 - tupal with X and position
518:08 - one just to test all of this inside of
518:10 - Sprites I want to set the bullet speed
518:13 - to zero if I now run main. pi and I look
518:18 - to the right I can create a bullet it's
518:20 - right in front of the player and on the
518:22 - left side we are also right in front of
518:25 - the player player that means we can set
518:27 - the bullet speed back to
518:30 - 850 and we get bullets that look
518:33 - significantly better cool now to
518:36 - understand this line we have a player
518:39 - with a center position that is what
518:42 - we're getting from the position
518:43 - parameter if the player is facing to the
518:46 - right then we want to do all of this
518:49 - meaning we are going from this point a
518:52 - bit further to the right by 34 pixels
518:56 - and then we are placing the top left of
518:57 - the bullet I think that part is fairly
519:01 - straightforward however if we are moving
519:04 - to the left then we are doing all of
519:07 - this we still start from the center of
519:10 - the player and then we are going to the
519:12 - left by 34 pixels that covers this bit
519:17 - but then you have to remember that we
519:18 - are placing the top left of the bullet
519:20 - meaning the bullet would be roughly here
519:24 - which obviously is wrong what we want to
519:26 - place is the right side of the bullet in
519:29 - other words we want to move the entire
519:31 - thing by its own width and this we're
519:33 - doing with this last
519:35 - line and that is basically it with that
519:39 - we have the
519:40 - bullets that covers all we need for this
519:42 - class besides that I also want to have a
519:45 - fire class which is also going to
519:48 - inherit from the Sprite class now for
519:51 - this one we first of all want to have a
519:54 - thunder init method with self a surface
519:57 - a position groups and we also need the
520:01 - player basically for this one every time
520:04 - the player fires a bullet we also want
520:06 - to have a fire animation or well fire
520:10 - animation might overstate things just a
520:12 - bit if you look at images scun there we
520:16 - have a fire image this we want to show
520:19 - for a very short amount of time if the
520:21 - player fires a bullet and then via a
520:23 - timer destroy it right after and for
520:27 - that we're going to need the player so
520:29 - this fire animation moves with the
520:30 - player it would look really weird if it
520:33 - didn't do that for that we will need a
520:36 - super Dunder init
520:39 - method with the surface the position and
520:43 - the
520:44 - groups that way we are getting all of
520:47 - this on top of that I want to store
520:49 - self. player as an attribute and also I
520:53 - want to know when we are creating all of
520:55 - this if the player is flipped or not
520:57 - which means self. flip will be player.
521:01 - flip on top of that I want to create
521:04 - self. timer which is going to be a timer
521:08 - that has a duration of 100 and it's also
521:12 - going to auto start and once this thing
521:16 - times out we want to call a function
521:19 - which is going to be self. kill we want
521:22 - to call the inbuilt kill method of the
521:24 - Sprite
521:25 - which we can totally do let's try all of
521:28 - this inside of main.py besides creating
521:31 - a bullet I also want to create a fire
521:34 - instance for the surface I want to have
521:37 - a fire surface for the position for now
521:41 - let's stick with the position of the
521:43 - player groups is simply going to be
521:45 - self. all Sprites and the player will be
521:48 - self. player if I now run all of this we
521:52 - are getting an error that Tuple object
521:54 - has no attribute get F rectangle and I
521:58 - think that usually means we are adding
522:01 - some wrong arguments somewhere you
522:03 - probably saw it
522:04 - already the order of the arguments are
522:07 - wrong we first of all need a position
522:10 - then we need a surface and then we need
522:12 - the
522:13 - groups if we now run out of this we are
522:16 - getting a fire Sprite that is pointing
522:20 - mostly in the wrong direction and the
522:21 - position is also not great but at least
522:24 - we have something oh and on top of that
522:27 - it also doesn't disappear that happens
522:29 - because the timer is not being updated
522:32 - which means we need an update method
522:34 - with self and Delta time although Delta
522:36 - time we don't care about and then self.
522:40 - timer.
522:41 - update if I now run all of this I can
522:45 - shoot a bullet and we get a very short
522:48 - fire animation that's a good start but
522:51 - we also have to update the position for
522:54 - that since we have to player available
522:56 - we can do all of that fairly easily if
522:58 - self. player.
523:02 - flip then I want to set self. re.
523:06 - midr to self. player. re. mid left on
523:11 - top of that since we are now facing to
523:13 - the left we want to flip the entire fire
523:16 - image or in other words self. image is
523:19 - going to be py
523:21 - game.
523:23 - transform. flip
523:26 - with self. image true and
523:29 - false if that is not the case else then
523:33 - we simply want to set self. do midle to
523:38 - self. player. re. Mid right that is a
523:42 - good start but on top of that I want to
523:44 - copy all of this and then inside of the
523:47 - update method do all of this except
523:50 - updating the image that way this fire
523:53 - animation goes along with the player
523:56 - which is quite important if I now fire
523:59 - all of this you can see that we have a
524:03 - basic fire animation although the
524:05 - position is a bit off this thing has to
524:07 - move down just a little bit that is
524:10 - quite easily done inside of Thunder init
524:12 - I want to have self. let's call it y off
524:17 - set which is going to be a pame do
524:20 - Vector 2 with zero and let's say eight
524:24 - pixels after we have that whenever we
524:27 - are updating the
524:30 - position of the rectangle we always want
524:33 - to add the Y offset that way if I shoot
524:38 - the bullet we get the proper nozzle fire
524:41 - animation and that is looking pretty
524:44 - good and I think now I can also
524:46 - demonstrate why you need this part if I
524:50 - comment it out and run main dop again
524:53 - and shoot a bullet
524:55 - sometimes you can see if the player is
524:57 - moving the fire animation doesn't move
524:59 - along with the player which is kind of a
525:01 - weird
525:02 - effect meaning we really want to include
525:05 - this
525:05 - part nearly done there's just one more
525:08 - part I do want to work on let me move
525:11 - away from the bees and if I shoot a
525:14 - bullet and turn right away we getting a
525:17 - slightly weird effect when we are
525:20 - creating the fire animation and the
525:22 - player is facing to the right and if we
525:25 - are then turning around the entire thing
525:27 - falls
525:28 - apart to avoid that if the player turns
525:31 - around while we have a fire animation we
525:34 - want to Simply destroy the entire thing
525:36 - or in other words if self. flip is
525:41 - different from self. player do flip if
525:46 - that is the case self. kill that way if
525:49 - I run main.
525:51 - Pi I can move a bit further to the right
525:54 - and as soon as as I shoot and turn
525:56 - around the fire
525:58 - disappears and with that we have the
526:01 - fire animation that covers another
526:03 - really important part with that covered
526:05 - we just have to figure out the enemy
526:07 - logic and the bullet
526:11 - [Music]
526:14 - collisions to finish up the game I want
526:17 - to work on the enemy Logic for the B we
526:20 - want to have a Sprite that is slowly
526:21 - moving to the left we have some vertical
526:24 - movement as as well and for the worm we
526:26 - are going to move this thing in a
526:28 - predefined area on top of that we will
526:31 - also add the collisions between the
526:32 - bullets and the enemies and the enemies
526:34 - and the player finally we can add some
526:36 - audio files and then we have the entire
526:39 - project done shouldn't be too difficult
526:42 - for all of this back inside of the code
526:45 - I want to work inside of the Sprites and
526:48 - looking at all of this we don't need the
526:49 - timer. piy groups. piy or support. Pi
526:52 - file anymore instead we want to look at
526:55 - the worm and the bee those two classes
526:58 - are identical at this point on top of
527:01 - that they are going to share a bit more
527:04 - code in just a bit to account for all of
527:06 - that I want to create another class
527:09 - called
527:10 - enemy which is going to have an animated
527:13 - Sprite as the parent for this we going
527:17 - to need a thunder init method with self
527:21 - braams position and groups in there we
527:26 - are going to need Super and thunder in
527:30 - knit which means we are calling animated
527:32 - Sprite thunder in it and then pass
527:35 - through all of the arguments which means
527:37 - for the B the parent class should be the
527:40 - enemy class and the same for the worm
527:43 - that already means inside of the enemy
527:46 - class we can call update with self and
527:49 - Delta time and then self. animate also
527:53 - with Delta time because of that we don't
527:56 - need this update method anymore and we
527:59 - are already simplifying the code inside
528:02 - of m.p the animations should still work
528:05 - and they do cool for both of these
528:09 - classes I want to create a move method
528:13 - which is also going to need Delta time
528:15 - and for now we're going to add pass in
528:17 - there for both of them this move method
528:21 - we are going to call inside of the
528:23 - parent class cell do move now we have to
528:26 - figure out the actual movement for the B
528:30 - this is fairly simple we want to have
528:32 - self. rect dox minus some amount for
528:37 - that value I want to create self. speed
528:40 - which is going to be random and this we
528:43 - want to multiply with Delta time for
528:45 - that to work we will need self. speed
528:49 - which is going to be set by a parameter
528:52 - speed with that back inside of main. Pi
528:56 - when we are creating a b we will need
528:58 - one more argument also to organize all
529:01 - of this just a bit better I want to use
529:03 - named
529:05 - arguments we have frames we have a
529:09 - position and then we have the groups
529:13 - besides that we will need speed which is
529:16 - going to be a random integer between 300
529:20 - and 500 if I now run all of this we have
529:23 - pce that are moving to the right so this
529:26 - is already working quite well perfect
529:29 - although now the starting position
529:31 - doesn't really work anymore what I want
529:33 - to have if this is the entire level the
529:36 - bees should be spawning on the right of
529:39 - it for that first of all when we are
529:42 - setting up the level we need to know how
529:45 - wide this TMX map is we need TMX map and
529:50 - then do whift if I now run all of this
529:53 - we are getting the number
529:56 - 45 to understand this value you want to
529:59 - go to the tile map and then map and map
530:02 - properties that is going to give you
530:04 - this dialogue on the left and all the
530:07 - way at the top you can see the width
530:09 - which is 45 in my case or in other words
530:12 - our map has 45 columns that's literally
530:16 - all that this means which we can
530:19 - use I want to define a self. levore for
530:25 - whift which is going to be TMX map. wift
530:28 - multiply it with the tile size once we
530:31 - have that back inside of create B for X
530:35 - we want to have self. LEL wift plus some
530:40 - kind of offset let's go with the window
530:43 - whift just to be sure and since the
530:46 - player cannot see this value anymore we
530:48 - don't need Randomness meaning Rand in
530:52 - and
530:53 - disappear that is looking pretty good if
530:56 - I now run all of this and I move all the
530:59 - way to the right at some point there
531:02 - should be some bees coming our way and
531:04 - that is working pretty well next up we
531:07 - also want to cover the entire height of
531:09 - the map meaning we have to do basically
531:11 - the same thing we have done before
531:14 - besides a level Whi I want to have self.
531:17 - levore height which is going to be TMX
531:21 - map. height multiplied with the tile
531:24 - size
531:26 - after that for this value we do need
531:29 - Randomness we want to have a value
531:31 - between zero so all the way at the top
531:33 - and self. level height once we have that
531:38 - I can run the game and at some point we
531:41 - could be seeing bees covering the entire
531:46 - height and that is working pretty
531:49 - well although for the movement of the
531:52 - bees I want to add a bit more randomness
531:55 - and for that I want from math import sin
532:00 - this is giving us a signed function and
532:03 - what that is doing if you put this on a
532:07 - graph we need some kind of x value and
532:12 - along this value the sign function is
532:13 - going to look something like this we
532:17 - basically get a wave that fluctuates
532:19 - between 1 and -1 and in our case the x
532:23 - value is going to be the time and just
532:26 - to demonstrate what we are going to do
532:28 - inside of the
532:29 - player I want to in the update method
532:34 - print the sign function with pame do
532:39 - time.get ticks if I now run all of this
532:43 - you can see that we getting a whole
532:45 - bunch of output and this output is
532:48 - always between nearly one and then
532:51 - nearly -1 and it goes between those two
532:54 - values really really quickly that is all
532:57 - that we are doing in
532:59 - here now in the player we don't need it
533:02 - but inside of each instance of the
533:06 - B we want to use all of that to
533:09 - influence self. doy to that value we
533:13 - want to add the sign value of py game.
533:17 - time.get six don't forget to call it and
533:20 - this value will now be between 0 and 1
533:24 - which is not going to do very much for
533:27 - the vertical position but we can
533:29 - multiply it with some sort of
533:33 - amplitude and also don't forget whenever
533:36 - we have Movement we have to multiply
533:38 - things with Delta time now amplitude
533:40 - doesn't exist at the moment although we
533:43 - can create it self. amplitude is going
533:46 - to be a random integer that we have to
533:49 - import from random import Rand in I want
533:53 - to have a random value between 500 and
533:57 - 600 with that if I run all of this again
534:01 - and we have to wait for the Beast for
534:03 - just a second we should be getting
534:06 - something and well this is kind of
534:08 - working but it's not ideal yet that is
534:11 - because the frequency is way too
534:14 - high to fix that I want to have self.
534:18 - frequeny which is also going to be a
534:21 - random integer in my case between 300
534:24 - and 600 and this value we want to use to
534:28 - divide get. tick or in other words
534:31 - divide by self do
534:33 - frequency with that we should be getting
534:36 - a proper outcome if I now Run the game
534:40 - and we could be seeing bees moving in a
534:44 - much more organic way this is much
534:49 - nicer perfect that covers the movement
534:52 - of the be next up I also want to have a
534:56 - constraint because once again we keep on
534:59 - creating bees and we have to make sure
535:02 - that we are getting rid of them at some
535:03 - point as
535:04 - well now in this case this is fairly
535:07 - simple we simply want to check if self.
535:11 - re. right is smaller or equal to zero if
535:16 - that is the case we want to kill the
535:19 - Sprite and also this constraint method
535:22 - we want to call inside of the parent
535:24 - class self.
535:26 - constraint to make sure that the game
535:28 - doesn't crash we also have to add the
535:31 - same method to the worm class meaning in
535:33 - here
535:34 - con
535:36 - straint without without any custom
535:38 - parameters and this one is going to get
535:40 - pass for now with that we have to be
535:43 - enemy next up we have to work on the
535:47 - worm inside of til we have an object
535:50 - layer called entities this one contains
535:52 - the player that's the part we have
535:54 - already seen besides that we have a
535:57 - whole bunch of rectangular
536:00 - areas and the way those are going to
536:03 - work I want to spawn a worm roughly here
536:07 - and then make it move to the right if
536:10 - the worm goes too far to the right let's
536:13 - say we are ending up here then the
536:15 - direction of this enemy should be
536:16 - reversed the same thing we want to do on
536:19 - the left side and I think you know where
536:21 - this is going this is going to be your
536:23 - exercise I want you guys to create the
536:25 - worm movement logic pause the video now
536:28 - and see how far you
536:32 - get first of all we have to import all
536:35 - of the areas that is going to happen
536:38 - inside of setup after we are creating
536:41 - the player now we already are creating
536:43 - one instance of the worm that we want to
536:46 - keep however first of all we want to
536:49 - check if obj do name is equal to worm
536:54 - and just to make sure if you go back to
536:56 - tiled and you click on one of these
536:58 - areas you can see name worm if that is
537:01 - the case we want to create one instance
537:05 - of the worm and then add a couple of
537:08 - arguments the frames can stay as they
537:10 - are and at least for now we can also
537:13 - keep the groups but we have to update
537:15 - the position this one simply doesn't
537:17 - work anymore and what I want to do
537:20 - instead is create a pame f rectangle
537:24 - with the size of the rectangle inside of
537:27 - til that we can get via obj dox obj do y
537:32 - obj do width and obj do height with that
537:38 - we have a rectangle that defines the
537:40 - area that the worm can move in although
537:43 - to use that inside of the worm we need
537:46 - to update the parameters instead of a
537:48 - position we now have a rectangle to turn
537:51 - that into a position at least for the
537:53 - super under init method we want to get
537:56 - wreck. top left and that should already
538:00 - do something if I now Run the game we're
538:03 - getting multiple worms and they are in
538:06 - the area position at least roughly now
538:10 - obviously the worm should always be on
538:12 - the ground for that I want to update
538:15 - self. w. bottom
538:19 - left and set it to rect dot bottom left
538:25 - that way the worms are always going to
538:27 - be on the floor which is already feeling
538:29 - a lot better I also want to keep the
538:32 - rectangle let's call it maincore
538:36 - rectangle this is just going to be the
538:38 - rectangle from the parameter after than
538:40 - that we want to have self. speed which
538:43 - can be a random integer between 160 and
538:48 - 200 also we will need self. direction
538:52 - which can be one by default
538:54 - afterwards for the move method I want to
538:57 - get self. rect dox plus equal self.
539:01 - direction multiplied with self do speed
539:05 - multiplied with Delta
539:07 - time with that since we are already
539:10 - calling the move method all of the worms
539:12 - are moving to the right which is a good
539:16 - start but not ideal yet because they are
539:19 - supposed to turn around for that we will
539:21 - need the constraint method and the basic
539:24 - logic just to reiterate if this is the
539:27 - area the worm is starting in the bottom
539:30 - left and also moves to the right if we
539:33 - are then outside of this area we want to
539:36 - go the other way now for that you could
539:39 - check if the right side of the worm is
539:41 - greater than the right side of the area
539:44 - and do the same thing for the left side
539:46 - although that would be a bit of an
539:48 - Overkill because what we can do instead
539:51 - is to check if not self do main
539:56 - rectangle do contains with self.
540:00 - rectangle this way we are checking if
540:03 - the rectangle is not entirely contained
540:05 - by the main rectangle anymore which can
540:08 - only happen if we are too far to the
540:10 - left or too far to the right if that is
540:12 - the case self. Direction multiply equal
540:16 - minus one with
540:19 - that we should be getting the proper
540:22 - constraint this is looking really good
540:26 - just one more change that we have to
540:27 - make whenever we are doing this we also
540:31 - want to invert all of the frames so that
540:34 - it looks like the worm is moving in the
540:35 - right direction all we have to do for
540:37 - that is overwrite self.
540:40 - frames which we can do via py game.
540:43 - transform. flip and in there we want to
540:46 - get a Surface and then true and false
540:50 - this we're doing for every surface in
540:52 - self. frames once we have
540:57 - that we're getting the proper animation
541:00 - and that is looking pretty good now once
541:03 - again this could be optimized just a
541:05 - little bit more because now inside of
541:08 - the game every time the worm is hitting
541:09 - a specific point we are transforming two
541:13 - surfaces what you could do instead
541:15 - inside of load aets load the worm frames
541:19 - and then invert them right inside of
541:21 - this method afterwards you can simply
541:24 - load the right frames depending on what
541:26 - you have inside of the worm that would
541:28 - also work but for this game it's not too
541:30 - much of an issue and I think at this
541:32 - point if you want to implement it you
541:34 - can do it on your own anyway with that
541:37 - we have both of the enemies which means
541:40 - now we can work on the Collision
541:45 - methods Define
541:47 - collision and those are going to be the
541:49 - collision between the bullet and the
541:51 - enemies and the enemies and the player
541:53 - first of all I want to have the
541:55 - collision between the bullets and the
541:59 - enemies for bullet in self. bullet
542:04 - Sprites and then get all of the Sprite
542:08 - collisions which we're getting via pame
542:10 - dos sprite. Sprite
542:13 - cite in there we want to get one bullet
542:17 - and then self.
542:19 - enmore Sprites this one doesn't exist
542:23 - yet we will change that in just a second
542:26 - finally we will need to kill which
542:28 - should be
542:29 - false now before we can continue we want
542:33 - to work inside of the dunder init method
542:36 - and then create the enemy sprite's
542:41 - group this we want to use both for the
542:43 - worm and for the bees meaning those
542:46 - should be in self. all Sprites and self.
542:50 - enemy
542:51 - Sprites the be we are creating inside of
542:55 - the create B method and in there for the
542:57 - groups I want to have all Sprites and
543:00 - self. enemy
543:02 - Sprites with that this line should be
543:05 - working and I suppose while we are here
543:07 - we can also add py game.
543:10 - sprite. polite mask right
543:14 - away next up we want to check if Sprite
543:18 - Collision then we want to get the bullet
543:21 - and kill it and for Sprite in Sprite
543:27 - Collision we want to call sprite.
543:30 - destroy once again this method does not
543:34 - exist but that we can change because
543:36 - inside of the enemy
543:38 - class we can have Define
543:42 - destroy which for now is simply going to
543:44 - call self. kill all we have to do now is
543:48 - after we recording all Sprites update
543:50 - self.
543:52 - Collision let's try all of this now and
543:54 - if I shoot at one of the worms they
543:56 - disappear this should also work a second
543:58 - time perfect and once I hit a b there we
544:03 - go this is also working although this I
544:06 - want to refine a
544:07 - bit by using a mask inside of the enemy
544:11 - or in other words first of all I want to
544:14 - create self.
544:17 - Deathcore timer which is going to be a
544:20 - timer with a duration of 200
544:22 - milliseconds
544:24 - and the function self. kill as soon as
544:28 - we are calling the destroy method we are
544:31 - starting this timer self. death timer.
544:34 - activate besides that I also want to set
544:37 - self. animation speed to zero and then
544:41 - self. image should be pame do mask. from
544:47 - surface with self. image and that we
544:50 - want to turn to a surface straight away
544:54 - also self. image and set color key with
544:58 - a black color that way once the Sprite
545:00 - is being destroyed we don't have an
545:02 - animation anymore and the entire image
545:05 - is going to be a white silhouette on top
545:07 - of that I want to stop the movement of
545:09 - the enemy which we can do inside of the
545:12 - update method I only want to call move
545:14 - and
545:15 - animate if not self. death timer as soon
545:22 - as a death timer is running
545:24 - we don't want to call move or animate
545:26 - anymore you could also put a constraint
545:28 - in there it doesn't really matter once
545:31 - we have that if I now shoot at a worm
545:34 - we're getting a white silhouette for a
545:36 - short time and this doesn't change that
545:39 - happens because self. death timer.
545:42 - update was not called let's try this
545:45 - again and I can shoot at the worm and it
545:47 - disappears perfect this happens a second
545:50 - time as well very good and now I have to
545:53 - hit a b let's hope I get one there we go
545:57 - this is also working which means with
545:59 - that we have the proper enemy
546:02 - logic that was basically it and I hope
546:05 - from the logic here you can see how
546:07 - inheritance can be incredibly powerful
546:10 - inside of the B and the worm class we
546:13 - are not actually doing very much we are
546:15 - simply initializing a couple of basic
546:17 - values then we have a very simple move
546:20 - method and then a fairly simple
546:22 - constraint method
546:24 - that's pretty much it a lot more of the
546:26 - logic happens inside of the parent enemy
546:28 - class the animations are covered inside
546:31 - of animated Sprite and the very basic
546:33 - setup happens inside of the Sprite class
546:36 - that way the entire thing is much more
546:38 - manageable and for a larger project we
546:41 - would be writing a lot less code the
546:44 - last thing that we really have to work
546:45 - on is the collision between the enemies
546:50 - and the player all we need for this part
546:53 - is if pygame dos sprite. Sprite collide
546:57 - with self. player self. enemy Sprites
547:02 - and the DU kill argument doesn't really
547:03 - matter let's go with folds and then we
547:06 - want to have pygame DOS sprite.
547:08 - Collide underscore mask if that returns
547:13 - anything then we want to set self.
547:16 - running to bals let's try that part and
547:21 - now as soon as I get hit by a worm the
547:23 - game should be over and it is perfect
547:26 - that means the last thing that we have
547:28 - to implement is the audio that means
547:31 - inside of Thunder init after we are
547:34 - loading all of the assets we are running
547:36 - the setup I guess in there we can start
547:39 - the music all the way at the bottom I
547:42 - want to get self. audio and then get
547:46 - music remember for this part the name of
547:50 - each of the files is the file name
547:52 - without the file end
547:54 - this file we want to play with loops
547:59 - being1 let's
548:01 - [Music]
548:04 - try cool that part is working and just
548:07 - why we're testing the other audio files
548:09 - I want to comment out this part so next
548:13 - up we have to work on the shooting
548:15 - mechanic that means whenever we are
548:17 - creating a bullet we also want
548:20 - to self. audio
548:24 - shoot and
548:28 - play and now every time I'm shooting a
548:30 - bullet we are getting another sound
548:34 - whenever we are hitting an enemy that
548:36 - happens inside of collision we want to
548:39 - play self. audio this one is called
548:44 - impact and then play it with
548:49 - that we are getting a sound every time
548:52 - we're hitting an enemy
548:54 - me and with that we are done this is the
548:58 - entire game the last thing I suppose
549:00 - that we have to do is uncomment the
549:03 - background music this covers another
549:06 - pretty fancy
549:08 - game so I hope this was useful and at
549:10 - this point you should have a really good
549:12 - understanding of P game which means
549:14 - there's just one more game to go and for
549:16 - that we're going to work a lot more with
549:18 - user interfaces there is just one more
549:21 - game that is left to make and that is
549:24 - the Pokémon inspired one the major Focus
549:26 - here is going to be on the UI system
549:30 - essentially we are going to create a
549:31 - menu and the player can select different
549:33 - options generally Pokemon games aren't
549:36 - terribly sophisticated you essentially
549:38 - have a database and you access all of
549:40 - that via a UI system although the
549:43 - details can become a bit more advanced
549:46 - now if you want to make a really fancy
549:48 - RPG in this kind of style check out my
549:50 - dedicated video for all of that I am
549:53 - also Al using py Game meaning if you
549:55 - could follow along so far you will feel
549:56 - right at home anyway for now we want to
549:59 - set up the basic Sprites so that we have
550:02 - the player monster and the opponent
550:05 - let's Jump Right In we already have a
550:06 - couple of things ready most importantly
550:10 - inside of main.py we have a game class
550:13 - with all of the basic setup and then we
550:15 - have a game Loop if you run all of this
550:18 - you getting a basic window doesn't do
550:21 - anything at the moment but that we can
550:23 - work on later besides that we have
550:25 - support. Pi in there we have a folder
550:29 - importer and it stores the data as a
550:31 - dictionary which means the file name is
550:34 - going to become the key and the
550:36 - associated value will become a surface
550:38 - besides that we have an audio importer
550:40 - function which is going to work in a
550:42 - very similar way we have an audio
550:44 - dictionary and in there we are creating
550:47 - key value pairs with the file name
550:49 - becoming the key and to mix a sound file
550:52 - becoming the value besides that we have
550:54 - a timer that we have already seen in the
550:56 - last game and then we have settings in
550:59 - which we have pame the join and the walk
551:02 - method then we are defining a window
551:04 - width and the window height and then we
551:06 - have four
551:07 - dictionaries colors is a very simple one
551:10 - in there we are simply defining a couple
551:12 - of colors then we have monster data and
551:15 - this one gets a bit more complex we
551:17 - always start with a key and this is the
551:19 - name of a monster the associated value
551:22 - is then going to be another dictionary
551:24 - with the monster element and the amount
551:26 - of health and that is all we have for
551:28 - the monsters there are no levels or
551:30 - attack points we simply have the element
551:32 - and the health besides that we have the
551:35 - abilities this is going to be another
551:37 - dictionary where we have the name of the
551:39 - attack and then a damage an element
551:42 - along with an
551:44 - animation finally we have the element
551:46 - data which is going to tell us how well
551:49 - an element works against another element
551:51 - for example if we have fire and we
551:54 - attack a plant then we are doing twice
551:56 - as much damage for now this data isn't
551:59 - too important but later on we are going
552:02 - to rely quite heavily on it anyway
552:05 - before we continue here is the project
552:07 - folder and so far we only looked at the
552:10 - code files besides that we have a couple
552:13 - of audio files and then inside of images
552:16 - we do have quite a bit more for now the
552:18 - most important files are inside of back
552:21 - there we have the back sides of the mon
552:23 - monsters and then we have the front of
552:25 - the monsters as well there are a few
552:28 - more things for example inside of simple
552:30 - we have each monster in a much smaller
552:33 - graphic then we have the other folder in
552:36 - there we have the background and the
552:37 - floor for each monster this folder is
552:39 - fairly simple but then we have attacks
552:41 - and inside of attacks we have something
552:43 - that we haven't seen yet where we have
552:46 - multiple graphics on a single PNG file
552:49 - later on we will have to break up those
552:51 - into individual parts Parts but once
552:54 - again this isn't something we have to
552:56 - worry about at the moment below the
552:59 - groups I want to create a data section
553:03 - where first of all we are defining all
553:05 - of the player monsters and this is going
553:08 - to be a list of
553:11 - names for example in there I want to
553:14 - have the individual strings of the
553:17 - monsters let's go with three examples
553:19 - for now we want to have spu C and
553:24 - jaana and by the way to get all of the
553:26 - monster names you want to look at
553:28 - Monster data and in there you can find
553:31 - all of them for now I want to have some
553:33 - static data so it's a bit easier to go
553:35 - along but later on this will be
553:38 - randomized once we have that I want to
553:40 - create self. player monsters for which
553:45 - we want to create another list and in
553:47 - there we have a monster class that
553:51 - doesn't exist at the moment we will work
553:53 - on that in just a second first of all
553:55 - though for name in player monster list
554:00 - for each monster we want to have a name
554:04 - and a surface the name we are getting
554:07 - from the list comprehension the surface
554:09 - we have to import for that I want to
554:12 - create another method
554:15 - define import uncore
554:18 - assets without any custom parameters and
554:21 - for now I want to have all of of the
554:23 - back uncore surfaces for which I can use
554:27 - support. Pi I simply want to folder
554:30 - import and then go to a specific folder
554:34 - which in my case is going to be images
554:36 - and then back in there we have a whole
554:39 - bunch of images that we want to import
554:43 - and then store inside of a
554:45 - dictionary images and back and also I
554:49 - want to print self. back surfaces
554:53 - after we have that inside of the dunder
554:56 - init method self. import assets if I now
554:59 - run all of this we getting name error
555:02 - Monster not defined because this class
555:04 - doesn't exist that is totally fine first
555:07 - of all though what is much more
555:08 - important if you scroll up we have a
555:11 - dictionary with the monster name and the
555:13 - monster graphic so next up for the
555:16 - surface inside of the monster class we
555:19 - want to get self. back surfaces and then
555:22 - pick one of the surfaces via the monster
555:25 - name and for that it's really important
555:27 - that the monster names you define inside
555:29 - of the player monster list aligns with
555:32 - the file names that you are importing in
555:34 - back surfaces if that doesn't work you
555:37 - are going to get an error anyway once we
555:39 - have that inside of the code folder I
555:43 - want to create a new python file
555:45 - monster. piy in which we want from
555:49 - settings import everything and 10 class
555:54 - monster with pame do sprite. Sprite then
556:01 - we will need a thunder in it method with
556:04 - self a name and a surface at this point
556:08 - you might be wondering don't we also
556:10 - need the groups and well this is what we
556:13 - have done so far but for this particular
556:16 - game I don't want to do it which means
556:19 - inside of the Stander init method I
556:21 - simply want to call Super Thunder init
556:24 - without any arguments which is totally
556:26 - fine to do the reason for that is when I
556:30 - am creating all of the monsters I only
556:33 - want one of the monsters to be visible
556:35 - and only that one individual monster
556:37 - that is visible should be inside of all
556:41 - Sprites we'll cover that later first of
556:43 - all though we will need self. image and
556:47 - self.
556:49 - rectangle the image is really simple we
556:52 - simply get this surface for the
556:55 - rectangle I want to have self. image and
556:58 - get F
557:01 - rectangle in which we are placing the
557:04 - bottom left for the position I want to
557:07 - have
557:08 - 100 and the window he if this is the
557:12 - main window we want the player monster
557:15 - to be here in other words we want to
557:18 - place the bottom left in the bottom of
557:20 - the window with a bit of padding to the
557:23 - left finally I want to store the name as
557:26 - an attribute which means selfo name is
557:29 - name once we have that inside of main.py
557:33 - I want from Monster import
557:36 - monster once we have that inside of the
557:39 - game we still cannot see anything but at
557:42 - the very least the game doesn't crash
557:44 - anymore after we have to play a monsters
557:46 - I want to get a single Monster and
557:48 - stored in an attribute self. monster is
557:51 - going to be self. player monsters with
557:53 - index zero and this one monster I want
557:57 - to add to all Sprites which I'm doing
558:00 - via self. all Sprites and add self
558:04 - monster with that we can see one of the
558:07 - monsters in the bottom left and to make
558:10 - all of this look a bit better I want to
558:12 - import all of the background
558:15 - surfaces inside of import assets self.
558:19 - BG surfaces is going to be
558:23 - the Importer we want to go to images and
558:26 - in there we have other if you look at
558:30 - images there we have other which
558:33 - contains bg.png and floor.png once we
558:37 - have that before we are drawing anything
558:40 - else I want to get self. BG surfaces and
558:43 - then
558:45 - BG this we want to blit on the display
558:48 - surface self. display surface. blit with
558:52 - the surface and the position is going to
558:54 - be a tuple with Zer and
558:57 - zero I can now run all of this and this
559:00 - is already looking a lot
559:03 - better next up then inside of the
559:07 - monsters I want to create another class
559:10 - called
559:11 - opponent which is also going to be a
559:13 - pygame Dos sprite. Sprite for which we
559:17 - will need a thunder in it method with
559:20 - self name surface and this one is going
559:23 - to get groups since we are only ever
559:26 - going to create a single opponent we can
559:29 - add those to the groups which means
559:31 - super thunder in knit with the groups
559:36 - then we will need self dot image which
559:39 - is going to be the surface and self.
559:43 - rectangle which is going to be self.
559:45 - image and get F
559:48 - rectangle in which I want to place the
559:50 - mid bottom at the position window WID
559:55 - minus
559:56 - 250 and 300 I hope at this point you get
560:00 - some intuition where these points are
560:03 - but just to go over it really quickly we
560:05 - are placing the mid bottom at position
560:08 - window wh minus 250 going from the right
560:12 - 250 pixels from the top we are going 300
560:16 - pixels so we'll be on this point which
560:20 - is going to define the bottom of the
560:21 - monsters so so we're getting something
560:23 - like this to see all of that inside of
560:27 - main.py I want to import monster and
560:31 - opponent afterwards inside of the data
560:35 - section I want to create self do
560:39 - opponent via the opponent class and for
560:43 - that I will need a monster uncore
560:46 - name I will need a surface and self. all
560:51 - Sprites getting the once the name and
560:53 - the surface is going to be your exercise
560:56 - or in other words I want you guys to
560:57 - import the front surfaces and then use
561:00 - them to create one
561:02 - opponent this opponent by the way should
561:04 - be
561:05 - random try to figure this one
561:10 - out first of all inside of import assets
561:13 - we will need the front
561:16 - surfaces which we're getting via folder
561:18 - importer there we want to go to images
561:21 - and then
561:23 - and just to test things I want to have
561:25 - an opponent uncore name which for now
561:29 - let's go with
561:30 - atro then this opponent I want to use
561:33 - for the name and for the
561:36 - surface I want self. front
561:39 - surfaces and then pick one entry via the
561:42 - opponent name I can now run all of this
561:45 - and we are getting the opponent this is
561:48 - working for another example let's go
561:50 - with
561:51 - synl should also work just fine and it
561:54 - does this is looking good which means we
561:56 - just have to get a random name for which
562:00 - we will need from random import Choice
562:05 - and then use the choice method for which
562:07 - we are going to need a list which in our
562:09 - case is the monster data and we want to
562:12 - get the keys I can now run all of this
562:15 - again and we are always going to get a
562:18 - random
562:19 - opponent next up inside of the monster I
562:22 - want to add some data to get started I
562:26 - want to get the element of the monster
562:28 - and stored as self.
562:30 - element this we get via monster data the
562:34 - monster name and then the
562:37 - element or in other words we are going
562:40 - to monster data pick this dictionary and
562:43 - then get the element also while we are
562:45 - here I want to create self. health and
562:48 - self.
562:49 - maxcore health which we are also getting
562:52 - from the same dictionary which means I
562:55 - want to have monster data
562:58 - name and not the element but health and
563:02 - by default when we are creating the
563:04 - monster health and Max Health should be
563:07 - the same which means we can do something
563:09 - like this where self. health is the same
563:12 - as Max health is the same as Monster
563:14 - data name and health by that system we
563:17 - can easily create two identical values
563:20 - nearly done the last thing I want to get
563:22 - is self.
563:24 - abilities for which I basically want to
563:27 - get four random values from the
563:29 - abilities data that we can do via
563:32 - another subm module of random the one we
563:35 - want to import is called sample what
563:38 - this one is going to do if you call it
563:41 - you have to add some kind of list which
563:43 - in my case once again is going to be the
563:46 - abilities data and I want to get the
563:48 - keys and then I have to specify a second
563:51 - argument which just the number of values
563:53 - that I want to get in my case four that
563:56 - way we are getting four random values
563:58 - from this dictionary and just to make
564:00 - sure all of this is working I want to
564:02 - print self. name self. element self.
564:08 - abilities and finally self.
564:11 - Health if I now run main.py we getting a
564:15 - monster name the monster element the
564:17 - monster abilities and the Monster Health
564:21 - now all of this we also want to do for
564:23 - the opponent ideally we want to create
564:27 - another class called creature which
564:30 - would give us all of this stuff the
564:33 - issue is when we are creating the
564:35 - rectangle we are placing different
564:37 - points the bottom left for the player
564:39 - and the mid bottom for the opponent
564:42 - getting both of those into one parent
564:44 - class would be kind of a hassle to get
564:46 - around that I am going to create a class
564:49 - without thunder in it I simply want to
564:52 - have a method get
564:54 - uncore data in which we have to enter as
564:58 - an argument self and in name once we
565:02 - have that I want to get all of this and
565:05 - paste it in there that way we are
565:07 - setting self. element self. health and
565:10 - self. abilities simply by having the
565:12 - name that means we don't need all of
565:15 - this inside of the monster
565:17 - anymore we only want to call self. getor
565:21 - data with the name and to get access to
565:25 - this method I want to use multiple
565:28 - inheritance the Sprite should inherit
565:30 - from py game. sprite. Sprite and the
565:34 - creature since the creature doesn't have
565:36 - a Dunder ined method we can keep the
565:38 - super Dunder in it method the end result
565:41 - is going to be the very same we are
565:44 - still getting all of our monsters on top
565:47 - of that what we can also do for the
565:49 - opponent is ADD creature
565:52 - and then
565:53 - call self. getet data for which we will
565:58 - need the name also for the opponent we
566:01 - will need self. name which we are also
566:04 - doing inside of the monster so this we
566:06 - can put in there as well that way all of
566:11 - this looks a lot more
566:13 - organized if I now run
566:15 - main.py we are getting one additional
566:18 - output this monster is called pouch and
566:20 - the data for him we're getting down here
566:23 - once again we're getting a monster name
566:25 - a monster type a list with the attacks
566:28 - and the health amount that is a really
566:31 - good start next up I can get rid of the
566:34 - print statement and we have created a
566:37 - basic setup for the game I suppose
566:39 - there's one more thing that I would like
566:40 - to do to make the monster stand out a
566:43 - bit more there should be a floor below
566:46 - them which we can get via floor.png
566:52 - this I want to display below all of the
566:54 - monsters now for that you could create a
566:57 - custom Sprite group but since we don't
567:00 - really want to do anything in there I
567:02 - think it's a bit
567:04 - Overkill what is a bit more
567:06 - straightforward is another method draw
567:09 - monster
567:11 - floor no need for custom parameters all
567:14 - that we want to do in here is for sprite
567:17 - in
567:18 - self. all
567:20 - Sprites and then create a floor uncore
567:25 - rectangle which we are getting via self.
567:28 - BG
567:30 - surfaces with the floor image on this
567:34 - thing we want to call get F rectangle
567:38 - and then place this Center to sprite.
567:41 - rec. Mid bottom and for some offset I
567:45 - want to add py game. Vector 2 with Zer
567:50 - and -10 once we have that self. display
567:54 - surface. blit with self BG surfaces and
567:59 - the
568:01 - floor along with the floor
568:05 - rectangle this we now have to call
568:08 - before we are drawing all Sprites but
568:10 - after the background self. draw monster
568:15 - floor and now we can see a floor below
568:18 - the opponent and below our own monster
568:22 - which I think looks much
568:24 - better anyway with that we have the very
568:27 - basic setup next up we can work on the
568:30 - UI now that we have the basic setup we
568:33 - can work on the UI for now we are only
568:36 - going to cover the general menu and the
568:37 - attack menu which work basically in the
568:40 - same way and for all of that the theory
568:42 - is actually really simple a menu is just
568:46 - some text surfaces placed together for
568:48 - example if you want to create a menu
568:50 - like this all you really need is some
568:53 - kind of background this could be a
568:55 - surface and then a few text options
568:58 - that's basically it usually you create
569:01 - those via some kind of for Loop that way
569:04 - you can access all of the options via
569:06 - the index this would be zero one and two
569:10 - that is basically all that we are going
569:11 - to do for all of that back inside of the
569:14 - code I want to create a new file UI
569:19 - DOI once again we will need from setting
569:22 - settings and import everything then I
569:25 - want to have a class called UI in there
569:28 - we will need a thunder in it method with
569:32 - for now self and a
569:34 - monster this thing is first of all going
569:37 - to need the display
569:39 - uncore surface via py game. display and
569:44 - get surface and we are also going to
569:47 - need a font for which we are going to
569:49 - use the inbuilt one py game. font. font
569:52 - with none and 30 besides that I want to
569:56 - set a left side and a top side of the
570:01 - menu for which I'm going to get the
570:04 - window Wii divided by two and then
570:06 - subtract 100 pixels for the top side I
570:10 - am going to get the window height divid
570:12 - it by two and add 50 pixels we basically
570:16 - want the top left of the menu to be
570:18 - roughly in the center of the window with
570:20 - just a bit of an offset
570:22 - once we have that I want to create a
570:25 - draw method and all we really want to do
570:27 - in here is for example draw the general
570:31 - menu which is just going to be another
570:33 - method
570:34 - General at the moment I simply want to
570:37 - add print and General in there because
570:41 - to test all of this inside of main.py we
570:44 - will need from UI import
570:48 - UI after that in the game Stander ined
570:51 - method
570:53 - we want to have a UI section with self.
570:57 - UI and UI this one wants to have one
571:00 - argument which is going to be a monster
571:03 - that we have been storing inside of
571:05 - self. monster with that we can go back
571:08 - to the UI class although there's one
571:11 - thing I forgot we want to store self.
571:13 - monster as an attribute self. monster is
571:17 - Monster after we have that inside of the
571:20 - game class in the run me
571:22 - fit under draw after we are drawing all
571:26 - of the Sprites self. ui.
571:29 - draw I can now run all of this and we
571:33 - getting a general output that is looking
571:35 - really good that means inside of this
571:38 - General method we can start working on a
571:41 - basic menu first of all I want to define
571:43 - a rectangle that defines the size of the
571:46 - entire thing which is simply going to be
571:48 - a pame f rectangle with a left a top a
571:53 - width and a
571:55 - height the width is going to be 400
571:58 - pixels and the height will be 200 for
572:01 - the left side I want to have self do
572:03 - left and add 40 pixels for the top side
572:07 - self do top plus 60 pixels and just to
572:11 - make sure we can see what's going on py
572:13 - game. draw. rectangle on self. display
572:17 - surface for the color I want to go to
572:20 - colors and then get the white color in
572:24 - other words inside of settings there we
572:27 - have the colors and I want to pick the
572:28 - white one next up we need the rectangle
572:31 - to draw the one we have just created the
572:34 - Border width will be zero and the corner
572:36 - radius will be four then I want to
572:39 - duplicate all of this and choose the
572:41 - color gray we are still going to draw
572:44 - the rectangle but now I want to have a
572:46 - border width of four that way we are
572:49 - getting a gray rectangle around this
572:51 - area
572:52 - or in other words inside of main. Pi we
572:55 - are getting an area for the menu that is
572:58 - looking pretty good with that we have
573:01 - the
573:02 - background next up we want to have the
573:05 - actual menu part of this menu for which
573:08 - we will need the amount of columns and
573:10 - the amount of rows which in my case are
573:13 - both going to be
573:15 - two after we have that I want for call
573:19 - in columns and for Row in rows that way
573:26 - I am getting either zero and one for the
573:28 - columns and zero and one for the rows
573:31 - and the general way that you want to
573:32 - think about it if this is the menu we
573:35 - have just created this bit here we want
573:38 - to separate this thing into two columns
573:41 - and two rows inside of each cell we then
573:45 - want to display some
573:48 - text and for that we using this for Loop
573:51 - Loop effectively we want to get a center
573:54 - position for each of
573:56 - those or in other words inside of the
573:59 - inner for loop I want to get an X
574:01 - position and a y position the X position
574:05 - is simply going to be rect do
574:09 - left plus rect do wift divided by 4 plus
574:16 - re do WID / 2 multipied with column a
574:22 - bit more logic but I hope it's not too
574:24 - complicated let's go through it step by
574:26 - step we first of all starting on the
574:28 - left side of the rectangle this line
574:31 - here then we're adding rec. width
574:33 - divided by four that way we getting from
574:36 - the left side to the first horizontal
574:38 - Center this side here finally rec. width
574:42 - divided by two multiplied with the
574:44 - column and remember the column we're
574:46 - getting from the four Loop this one
574:48 - could either be zero or one if it is
574:52 - zero then this entire value will become
574:54 - zero so we are staying on this
574:58 - line if it is one however then this
575:01 - value will become one and we are adding
575:04 - half the width of the rectangle which
575:07 - would bring us to this horizontal Center
575:11 - and with that we have two Center points
575:13 - that is basically all we need a very
575:16 - similar logic we want to apply for the
575:17 - vertical points we want to go rect do
575:20 - top last plus rect do height / 4 plus
575:26 - rect do height / 2 multiply it with the
575:31 - row once we have that we can create a
575:35 - text surface and a text
575:38 - rectangle the text surface is going to
575:40 - be self. font.
575:44 - render and for now the text is simply
575:46 - going to be option antas should be true
575:50 - and for the color I want to go with
575:52 - black these values by the way we are
575:55 - going to change in just a second so
575:57 - whatever you put in there isn't too
575:58 - important at the moment for the
576:01 - rectangle I want to get the text surface
576:03 - and then get F rectangle in which we
576:06 - want to place the center and Position
576:09 - will be X and Y finally self. display
576:13 - surface. blit with the text surface and
576:16 - the text rectangle with that we are
576:20 - nearly done the last thing that I have
576:22 - forgotten is that the columns and the
576:24 - rows need to be inside of a range
576:27 - function that way we can use them for a
576:30 - four Loop if I now try all of this we
576:33 - getting four options that cover the
576:35 - entire size of the background that is
576:37 - looking pretty good next up I want to
576:41 - customize what I am displaying I don't
576:43 - always want to display option for that
576:46 - inside of thunder in knit I want to have
576:50 - let's call this a control section in
576:52 - which we are setting the general
576:56 - options which is going to be a list with
576:59 - a
577:00 - attch then we have heal next up we have
577:05 - switch and finally we have Escape those
577:08 - are the four options that we want to
577:10 - display which means inside of the text
577:14 - surface I don't want options for the
577:16 - string I want to get self and general
577:20 - options and then pick one index for that
577:24 - we will need this
577:27 - index I suppose for now to test if this
577:29 - is working let me add a zero in there if
577:32 - I now run main I we're getting the first
577:35 - value so this is working which means we
577:38 - just need to customize this for that
577:41 - once again we have the entire menu with
577:43 - two columns and two rows in there for
577:47 - the indexes I want to have 0 1 2 and
577:51 - three the formula to get these values is
577:55 - column + 2 * Row for example if column
578:00 - is zero and row is zero then the overall
578:03 - output is going to be zero as well which
578:06 - would bring us in this top left
578:08 - part however if column is zero and row
578:11 - is one then the overall result will be
578:14 - two which will bring us down here and
578:18 - that's basically all you need if I now
578:19 - run main. pi we getting the four General
578:23 - options that's basically all you need
578:26 - although there's one thing that's
578:28 - missing and that is input for that I
578:32 - want to have another method Define input
578:35 - I want to get all of the keys in there
578:37 - and then pame do key and get just
578:41 - pressed the adjust part here is really
578:44 - important we only ever want to get a
578:47 - single button press we do not want to
578:49 - check for button being pressed down
578:50 - Contin
578:52 - L now we have to figure out how to
578:54 - connect the input to the general menu
578:58 - and for that inside of thunder in it I
579:00 - want to create one more attribute self
579:03 - dogen index which is going to be a
579:07 - dictionary in which we have the column
579:10 - which by default has a value of zero and
579:13 - a row with the same default value once
579:16 - we have that inside of input I want to
579:20 - get self do General index and update the
579:23 - Row first of all I essentially want to
579:27 - increase this value by the integer of
579:31 - keys and high game.
579:35 - Kore down and from that I want to
579:39 - subtract basically the same value except
579:43 - this is going to be Kore up and this
579:46 - should look somewhat familiar it's
579:48 - basically a top down movement system I
579:51 - also want to duplicate all of this
579:53 - because besides the rows we want to
579:55 - update the column in which we are
579:57 - getting K
579:59 - right minus
580:01 - Kore left that covers the very basic
580:05 - input we just have to call the method
580:07 - which I want to do inside of an update
580:10 - method self do input and then inside of
580:16 - main.py self. ui. update I can now run
580:21 - this and nothing is going to happen that
580:24 - is because we are not doing anything in
580:27 - terms of output to fix that I want to
580:30 - print self. General
580:33 - index if I now run all of this we're
580:36 - getting column 0o and row zero if I
580:39 - press to the right we're getting column
580:40 - 1 column 2 column 3 and so on and if I
580:43 - go to the left then we're getting
580:45 - negative numbers the same also works for
580:47 - the row this is a pretty good start next
580:51 - up we have to figure out how to use the
580:54 - general index inside of the method to
580:57 - highlight one bit of text for that
581:00 - highlight I want to set a custom color
581:02 - If an item is selected I want to get
581:04 - colors and then get the gray
581:09 - color and to figure out if we are
581:11 - selected I want to check if the column
581:14 - the one that we're getting from the for
581:16 - Loop is equal to self dogen index
581:21 - index and the column on top of that I
581:25 - also want to check if the row is equal
581:28 - to self. General index and the row if
581:33 - both of these conditions are met then we
581:35 - know the current item is selected if
581:38 - that is not the case else we simply want
581:40 - to get colors and black once we have
581:44 - that instead of always drawing a black
581:47 - color we want to get the color we have
581:49 - just defined which means now inside of
581:52 - main Pi I can select one of these four
581:55 - options that is a really good start
581:58 - however if I go further and further to
582:00 - the right at some point the menu doesn't
582:02 - work
582:04 - anymore if you try this on your own it's
582:07 - going to be a bit more visible but
582:09 - basically if you go too far to the right
582:10 - you are selecting index 5 or 10 which we
582:14 - don't have
582:15 - anymore our menu only goes to two and
582:18 - two so we want to limit those values
582:21 - inside of the input for that I want to
582:24 - remove the plus equal and then get the
582:27 - starting value and to that I want to add
582:31 - what we have already added so so far we
582:34 - are doing the same thing but all of this
582:36 - I now want to put into a tball and then
582:39 - I can use the modulus operator and limit
582:43 - all of this to two rows the same thing I
582:46 - want to do for the columns so I can
582:48 - simply copy all of this then put the
582:51 - entire thing into a dupal and
582:55 - finally modulus 2 that way inside of
582:59 - main. Pi if I only press down we are
583:02 - still always getting the right value
583:05 - this also works with left and right and
583:07 - now we are always staying inside of the
583:12 - menu next up I want to check if keys and
583:16 - py game. Kore
583:19 - space if that the case I want to print
583:23 - the currently selected item which I can
583:25 - get via self. General options and then
583:29 - indexing and the formula we have already
583:32 - seen to get the value we want to have
583:34 - the column plus 2 * the
583:37 - row which in this case means self dogen
583:41 - index and the column plus self. general
583:46 - index and row multiplied by two
583:51 - if I press space we're getting attack
583:53 - this also works for heal escape and
583:56 - switch so with that we have a very basic
584:01 - menu so next up if the player is
584:04 - selecting a tack then we want to display
584:06 - a different menu the one for the
584:09 - attacks to get that system rolling I
584:12 - want to add one more attribute self.
584:16 - state which by default is going to be
584:20 - gen
584:21 - and inside of the draw method I only
584:24 - want to call the General method if self.
584:27 - state is general which we can check via
584:30 - a match case statement match self. State
584:35 - and we want to check the case General if
584:38 - we have that we want to call Self
584:43 - dogen finally instead of printing the
584:45 - output from the value I want to update
584:47 - self. State and it should be the return
584:51 - value that we are getting meaning if we
584:54 - click on attack then the state should
584:55 - also be
584:57 - attack with that inside of main.py if I
585:00 - click on a tack the menu
585:02 - disappears simply
585:05 - because we are not doing anything
585:07 - anymore inside of the draw method after
585:09 - that we have to implement the attack
585:11 - menu which is going to be your exercise
585:14 - I want you guys to modify UI General to
585:16 - also display abilities on top of that
585:20 - you can make this method a bit more
585:22 - flexible to account for any number of
585:24 - rows and columns at the moment we're
585:26 - setting rows and columns as a local
585:28 - variable but inside of the for Loop we
585:31 - always assume that we have two rows and
585:33 - two
585:34 - columns which isn't particularly elegant
585:37 - so try to make this more flexible pause
585:40 - the video now and see how far you
585:45 - get first of all I want to rename
585:48 - General to quad SEL
585:52 - since we are going to use this method
585:53 - for attacks in general we should have a
585:55 - name that reflects all of that that also
585:58 - means inside of draw self. quad
586:03 - select next up we have to make this
586:06 - thing a bit more flexible so that we can
586:09 - display any kind of list at the moment
586:13 - we are displaying the general options
586:16 - besides that from the monster we also
586:18 - want to be able to display the ability
586:21 - which I think we're inside of creature
586:23 - the abilities is a list with four values
586:26 - and this we also want to be able to
586:28 - display which we can actually do fairly
586:31 - easily because we have the monster
586:33 - available or in other words instead of
586:36 - General options we could get self.
586:39 - monster do abilities and since that is a
586:43 - list as well inside of main. Pi we're
586:46 - getting the four attacks of this monster
586:49 - to get those values dynamically inside
586:51 - of the parameter I want to specify an
586:54 - index and I want to specify the options
586:57 - then for the color I don't want to have
587:00 - the general index I simply want to get
587:02 - the
587:03 - index same thing for the row and with
587:07 - that we are using the index besides that
587:09 - for the text surface I don't want to
587:12 - have the abilities I want to have the
587:15 - options oh and also this shouldn't be
587:17 - self. Index this should just be the
587:19 - index we we are using the parameter
587:22 - value with that next up if the case is
587:26 - General I want to have quad select the
587:29 - index is going to be self dogen
587:32 - index while the options are going to be
587:35 - self dogen
587:38 - options let's try all of this and it's
587:41 - still working good sign after that if
587:45 - the case is the string attack then self.
587:50 - what select with self
587:54 - dot let's call this one the attack which
587:58 - does not exist at the moment after that
588:00 - self. monster.
588:04 - abilities just one more thing that we
588:06 - need inside of the control section I
588:09 - want to have a self. attack
588:13 - index after that inside of main.
588:17 - Pi I can click on attack and we are are
588:21 - getting the different attack
588:24 - options although at the moment we cannot
588:26 - do any kind of input that is because
588:29 - inside of the input method we are only
588:34 - updating the general index that we only
588:37 - want to do if self. state is equal to
588:43 - General if that is not the
588:46 - case or in other words if self. state is
588:50 - equal to to a
588:51 - tag then we want to do all of this so
588:54 - for now we can duplicate it all and
588:57 - update
588:59 - self. tack
589:01 - index for both the row and the column
589:05 - the values for that is going to be
589:07 - basically the same thing we have done
589:09 - before and for now I simply want to
589:12 - print what we are getting instead of
589:14 - General options I want to have self.
589:17 - monster.
589:19 - abilities and then
589:21 - self. attack index for the row and the
589:24 - column all of this we want to print and
589:29 - then I can still select the different
589:31 - options on attack I can click on one
589:34 - attack and we're getting the output that
589:36 - covers the basic exercise next up I want
589:39 - to clean all of this up and make it a
589:41 - bit more
589:42 - flexible we are specifying that we have
589:45 - two rows and two columns but when we
589:48 - getting X and Y we always assume that we
589:51 - have two values or in other words these
589:54 - numbers shouldn't be static they should
589:56 - be dynamic depending on what we are
589:58 - specifying in the rows and the
590:00 - columns also when we getting the input
590:03 - we getting modulus
590:05 - 2 which should also be relative to what
590:08 - we are specifying in the rows and
590:10 - columns for that in the control section
590:14 - I want to set self. rows and self do
590:19 - columns which are still going to be two
590:21 - and
590:23 - two that way we don't need those rows
590:26 - and columns
590:28 - anymore and instead I'm going to use
590:30 - self. columns and self. rows this isn't
590:35 - going to change anything because we are
590:37 - still using the same values but with
590:40 - that system for example in the input
590:43 - when we are getting the row we don't
590:45 - want to have modulus 2 instead we want
590:47 - to have self. rows the same thing for
590:51 - the columns this should be self do
590:53 - columns the same thing we want to do for
590:55 - attack self. rows and self.
591:00 - columns the end result should still be
591:03 - the same that is looking fairly good
591:07 - perfect so next up we can account for a
591:11 - greater number of
591:12 - options and just to demonstrate what I'm
591:15 - talking about here if we had six options
591:18 - in total or in other words we had two
591:20 - two rows and three columns and then for
591:23 - the general options let's say I also
591:25 - want to have items and
591:28 - catch if I now run all of this we are
591:32 - getting something but we should be
591:34 - inside of the available area so how can
591:37 - we organize this better for that inside
591:40 - of UI I first of all want to update rec.
591:44 - wift divided by four this should be
591:47 - divided
591:48 - by self. columns multiplied by two that
591:53 - way we are getting the proper start
591:55 - position and then when we are adding the
591:58 - value we don't want to get wed with
592:01 - divided by two this should be wed with
592:03 - divided by self do columns with that
592:06 - inside of main. Pi we are getting
592:10 - everything inside of one menu the same
592:13 - thing we want to do for the vertical
592:14 - position self do rows multiplied by two
592:18 - and then Rec do height divided myself do
592:21 - rows that means when we are specifying
592:24 - the rows and the columns I can flip this
592:26 - one around to three and two we are still
592:30 - getting six values overall but now we
592:32 - have two columns and three rows that is
592:35 - looking really good although not
592:37 - actually what I want to do I don't want
592:39 - to have items or catch and we should
592:42 - only have two rows and two columns but
592:46 - now all of this is much more
592:48 - flexible if you want to have a larger
592:50 - menu this is how you would do it now you
592:53 - could also streamline the input method a
592:55 - bit but later on I want to add more
592:57 - stuff in here so I'm not going to do it
593:00 - also I think at this point this part has
593:02 - gotten quite long so let's finish it for
593:04 - now with the first part of the menu
593:06 - covered we can start with the second
593:08 - part in which we are going to switch
593:10 - between different monsters or rather
593:13 - we're going to get the menu to switch
593:15 - between different
593:17 - Monsters the actual functionality is
593:19 - going to come later
593:21 - and fundamentally the system for all of
593:23 - this is going to be similar compared to
593:25 - what we have already done in some ways
593:28 - it's even going to be easier because we
593:30 - only working in one
593:31 - dimension but there are some other parts
593:33 - that are going to be a bit more complex
593:35 - so let's Jump Right In and do all of
593:37 - this straight away I want to keep on
593:39 - working inside of ui. Pi and then add
593:43 - another case inside of
593:46 - draw the case is going to be so
593:50 - switch if it is the case I want to call
593:53 - self. switch which does not exist at the
593:56 - moment so Define
593:59 - switch no need for custom parameters on
594:02 - this one and once again first of all we
594:05 - want to create a rectangle for the
594:07 - entire area which is going to be py
594:09 - game. F rectangle for the left side I
594:13 - want self. left plus 40 the same thing
594:17 - we have seen inside of the Quad select
594:20 - rectangle in fact we can copy most of
594:22 - the
594:23 - arguments the left side and Wii should
594:26 - be the same although for the top I want
594:29 - to keep self. top but then subtract a
594:33 - 100 pixels from
594:35 - it for the height I want to have 400
594:39 - pixels to test all of this I want to
594:41 - call pam. draw. rectangle like we have
594:45 - done before in Quad select in fact I can
594:48 - copy all of this and paste it in there
594:52 - since we are setting the state to what
594:54 - we're getting from General options and
594:56 - general options include switch this
594:59 - should already work which means inside
595:02 - of self. Pi I can click on switch and we
595:05 - are good to
595:06 - go this menu looks all
595:09 - right that means once again we have
595:12 - covered the background so next up we
595:15 - want to cover the menu part of this menu
595:19 - for which we have to create one more
595:20 - attribute self.
595:23 - visible
595:24 - monsters which I have set to four but
595:27 - this is going to be flexible basically
595:29 - for this menu we want to go through
595:32 - every single Monster that the player has
595:34 - which we're getting from main.py in
595:37 - there we have a list with the player
595:39 - Monsters the issue now is though that we
595:42 - don't have this available inside of UI
595:45 - which means we have to create one more
595:47 - parameter the player uncore
595:50 - monsters which we also want to store as
595:53 - an attribute self. player uncore
595:57 - monsters is going to be player
596:00 - monsters that means inside of main notp
596:03 - when we are creating the UI I also want
596:05 - to add self. player
596:08 - monsters after we have that I can add a
596:10 - four loop with four I in range of the
596:15 - length of self. layer monsters via that
596:20 - that I want to get an X position and a y
596:23 - position the X position is simply going
596:25 - to be re. Center X while the Y position
596:30 - is going to be re. top plus rect do
596:34 - height divided by self Dov visible
596:37 - monsters multiplied by
596:40 - two and to that we want to add rect do
596:44 - height divided by self. visible monsters
596:47 - multiplied with I this is the same
596:50 - formula that we have used inside of quad
596:53 - select this one or this one or in other
596:56 - words this is the entire menu and we
597:00 - want to create vertical cells like this
597:04 - for all of that we always want to get
597:05 - the center which will be the center of
597:08 - the rectangle that part is super easy
597:11 - and for why we want to start at the top
597:14 - of this rectangle then we get rec.
597:17 - height divided by self. visible monsters
597:19 - time to that would get us to this
597:23 - Original Point finally we want to add
597:26 - the vertical movement to get to the next
597:29 - Center like this like this and so on
597:33 - once we have that I want to get the name
597:35 - of the monster which we have via self.
597:39 - player
597:40 - monsters which as a reminder is simply
597:43 - going to be a list which means we can
597:45 - use
597:46 - indexing via I this would give us one
597:49 - moner moner from which we want to get
597:51 - the name or in other words we are
597:54 - getting one of those monsters and each
597:56 - monster has a name via that we can
598:00 - create a text surface with self. font.
598:04 - render with the name of the monster anti
598:07 - LS should be true and for the color I
598:10 - want to go with black next up I want to
598:12 - have a text rectangle which is going to
598:15 - be the text surface and get F rectangle
598:20 - in which for now I want to place this
598:22 - center with the position X and Y finally
598:26 - self. display surface. blit with the
598:30 - text surface and the text
598:34 - rectangle let's try if I now click on
598:37 - switch we're getting three monsters
598:39 - that's looking pretty good although we
598:42 - should have a few more monsters to test
598:43 - all of this let's say never monster
598:45 - could be dolphin then we have pouch and
598:50 - let's say
598:51 - Laria just to make sure of this is
598:53 - working this is looking good and inside
598:55 - of switch we can see four of the
598:59 - monsters but in the code we have six
599:02 - Monsters the reason why you can't see
599:04 - them is because the last two monsters
599:06 - are outside of the window or in other
599:09 - words if I from self. toop subtract
599:12 - something like 300
599:16 - pixels and go to switch then you can see
599:19 - all all of the monster names although
599:22 - this part isn't ideal yet but we can
599:25 - work on it for now I'm going to keep
599:27 - this position but later on we will
599:30 - change it first of all though we only
599:33 - want to display elements that are inside
599:35 - of this rectangle which we can do with
599:39 - if
599:41 - rect do Collide point and text rectangle
599:47 - do Center only if that is the case do we
599:50 - want to display the text if I run all of
599:53 - this again we can only see some of the
599:57 - monsters that is looking pretty
600:00 - good next up I want to work on the input
600:04 - in there we will need another L if
600:07 - statement L if self. state is equal to
600:13 - switch if that is the case I want to
600:15 - update self. switch uncore index
600:20 - which does not exist at the moment that
600:23 - we can fix inside of the dunder init
600:26 - statement self. switch index is going to
600:30 - be
600:32 - zero and then self. switch index is
600:35 - going to be pretty much what we have
600:37 - seen up there with the rows for attacko
600:40 - General except now we want to have this
600:43 - switch index and this one is an integer
600:47 - so no indexing needed to that
600:50 - we want to add the integer of keys k
600:53 - down minus K up and limit all of this
600:56 - with modulus and self. visible monsters
601:01 - next up to select anything inside of
601:04 - switch we want to select a custom color
601:08 - which is going to be another local
601:09 - variable which should be colors and
601:14 - gray if I is equal to self. switch index
601:21 - if that is not the case else it should
601:23 - be colors and black and that color we
601:27 - want to use when we are rendering the
601:29 - text which means instead of black I want
601:32 - to have the
601:33 - color let's try this one and inside of
601:38 - switch I can select different options
601:41 - that's looking pretty good however that
601:44 - is not the system that I actually want
601:46 - if this is our menu at the moment we can
601:49 - display play four elements 1 2 3 and
601:54 - four if we go beyond that we are simply
601:56 - going back to
601:58 - one but that's incorrect because what
602:01 - you cannot see is that below we have two
602:04 - more monsters those are not visible
602:07 - because of this if statement if I
602:10 - temporarily comment it out and fix the
602:13 - indent and run main. Pi again inside of
602:16 - switch you can see that we are are
602:20 - entirely ignoring the last two
602:22 - monsters which obviously isn't ideal
602:25 - what I would rather want is that if we
602:28 - go with the index below four then I want
602:30 - to move up all of the
602:32 - elements for that I want to first of all
602:37 - reimplement the if statement and then
602:40 - before the for Loop add a vertical
602:44 - offset which by default is going to be
602:46 - zero and this V offset we are going to
602:49 - add add to the Y position at the moment
602:53 - this is not going to do anything however
602:56 - if I change this to let's say 150
603:01 - pixels then we are drawing everything a
603:04 - bit further
603:05 - down and if I make this number negative
603:09 - then you can see that we can see a
603:12 - couple of other elements we cannot
603:14 - select them because of the modulus but
603:17 - that's something we can work on but now
603:19 - though the default value for the offset
603:21 - should be zero also inside of input
603:25 - something better would be the length of
603:28 - self. player
603:30 - monsters that is going to cover an
603:32 - important part next up I want to work
603:35 - more on V of set because this should
603:38 - only be zero if self. switch index is
603:43 - smaller than self. visible monsters if
603:48 - we are between zero and four and this
603:50 - value should not do anything however if
603:53 - that is not the case then we want to
603:56 - move up all of the items so we can see
603:58 - the monsters a bit further down we just
604:01 - have to figure out by how much we want
604:03 - to move up and my case this is going to
604:07 - be self. switch index minus self.
604:11 - visible
604:13 - monsters this
604:15 - number should be negative
604:19 - that way if switch index is five and
604:22 - visible monsters are four then we know
604:24 - from this calculation that we have to go
604:27 - up by one entry and this we want to
604:29 - multiply with w dot height divided by
604:35 - self. visible monsters that way we get
604:38 - the height of one of the
604:41 - cells with that if I run main. pi and go
604:44 - to switch I can go down and if I keep on
604:48 - going down at some point
604:50 - the entire menu moves up although
604:52 - there's an offset of one
604:55 - element that we can fix quite easily by
604:57 - simply adding plus one if you now try
605:01 - all of this again we are getting a menu
605:04 - that shows all of the monsters which is
605:06 - feeling significantly better and that is
605:09 - going to give us the vertical offset
605:11 - although there's a problem if I run
605:13 - main.py
605:15 - again and I click on switch you can see
605:18 - that the first Monster we can select is
605:20 - the current active monster they are both
605:22 - called spu this we want to avoid and
605:25 - while we add it we want to add a few
605:27 - more restrictions so at the moment we
605:30 - simply get all of the player monsters
605:33 - but later on we do not want to be able
605:36 - to select the monster that's currently
605:37 - on the field on top of that we do not
605:40 - want to select a monster that doesn't
605:41 - have any
605:42 - health for that I want to create another
605:46 - attribute available monster
605:50 - which we are going to get via list
605:52 - comprehension I want Monster for monster
605:56 - in self. player monsters but only if the
606:00 - monster from this for Loop is different
606:04 - from self. monster that why we are
606:07 - excluding the currently active monster
606:09 - and I want to check if monster. health
606:13 - is greater than zero and as a reminder
606:17 - once again inside of monster we getting
606:19 - the health for the monster which is
606:22 - later going to change although for now
606:24 - this part isn't going to do very much
606:27 - with that we have available monsters
606:30 - those we want to use inside of input we
606:32 - want to check modulus and then self.
606:36 - available
606:37 - monsters on top of that inside of switch
606:42 - we want to use for I in range length
606:45 - self
606:46 - dot available monsters
606:50 - when we are getting the name there
606:51 - should be available monsters as well via
606:55 - that if I run main.py again inside of
606:57 - switch we have gotten rid of the first
606:59 - Monster but other than that we still
607:02 - have five the ones that we have defined
607:04 - earlier looking pretty good besides that
607:08 - if you look at a project folder there we
607:10 - have images and then we have a folder
607:12 - called Simple in there we have the
607:15 - simple monster images those I want to
607:18 - display next to the name inside of the
607:20 - switch menu which means we first of all
607:23 - have to import all of this and then
607:25 - display them next to the name that part
607:27 - is going to be an exercise I want you
607:29 - guys to display the simple images next
607:31 - to the name and for that you can choose
607:34 - a position that you like the specifics
607:36 - here don't really
607:40 - matter I want to work inside of main.py
607:43 - and specifically in import assets I want
607:46 - to create a number attribute self.
607:49 - simple underscore surfaces which we are
607:52 - getting via the folder importer I want
607:54 - to go to images and in there we have
607:57 - SIMPLE so in the folder images and
608:01 - simple those simple surfaces we have to
608:04 - get into the UI which we can do fairly
608:06 - easily via another argument self. simple
608:11 - surfaces next up in the UI I want to
608:14 - have another parameter simple underscore
608:17 - surfaces we can store that right at the
608:20 - top self. simple uncore surface is going
608:24 - to be simple
608:26 - surfaces that covers that part next up
608:30 - inside of switch we already have the
608:33 - monster name from that we can select a
608:36 - surface I am going to call this one the
608:38 - simple underscore surface for which I
608:42 - will need the simple surfaces and then
608:44 - use indexing to get a key value pair the
608:47 - key will be the name of the monster
608:50 - after that I want to have a simple
608:52 - rectangle which is going to be simple
608:54 - surface and get F
608:57 - rectangle for which I want to place this
609:00 - Center at position x - 100 and Y let's
609:08 - display all of that right below where we
609:10 - display the text I also want display
609:12 - surface do blit with the simple surface
609:15 - and the simple rectangle also I realized
609:19 - this should be self. simple surfaces if
609:23 - I now run all of this again and I go to
609:25 - switch we can see all of the monsters
609:29 - that's looking pretty
609:30 - good another thing that I would like to
609:33 - add for the text position I want to
609:36 - place the mid left that way the text is
609:40 - aligned to the left side which I think
609:42 - looks just a bit better but anyway with
609:46 - that we have a pretty functional menu
609:49 - although at the moment if I press space
609:51 - nothing is going to happen to fix that I
609:54 - want to work inside of input and then
609:57 - check in the L if statement for switch
610:00 - if the space key is pressed which we
610:02 - have already done a couple of times this
610:04 - should be straight forward for now I
610:07 - simply want to print the current
610:09 - selected monster which we can get from
610:11 - self. available monsters and then
610:14 - indexing with self. switch index let's
610:18 - try and in switch I can select this
610:21 - monster this monster and well you can
610:24 - see a Sprite so this doesn't do very
610:27 - much but on this Sprite we have one
610:30 - attribute which is going to be the name
610:33 - then we can get the name so that is
610:35 - looking pretty good although this we can
610:38 - make a bit more elegant instead of
610:40 - printing one attribute inside of the
610:43 - monster I want to set a method that
610:45 - returns a value whenever we are printing
610:48 - this class the D method we need for that
610:50 - is called repper in which we can return
610:53 - a value whenever we are printing this
610:56 - class in my case I want to have an F
610:59 - string with self do name and I suppose
611:04 - then we can add self. Health divided
611:09 - by self. Max
611:13 - Health with
611:15 - that if I now select a monster we
611:18 - getting the name of the monster along
611:20 - with the Monster Health this is working
611:22 - pretty well one last minor thing while
611:25 - we are here if the player goes to the
611:29 - attack menu or the switch menu there's
611:31 - no way to go back to implement that I
611:34 - want to add if keys and P game.
611:39 - Kore Escape then I want to set self.
611:43 - State back to General and then also I
611:47 - want to reset all of the indexes
611:50 - the general index the attack index those
611:53 - I want to set back to zero and zero for
611:57 - everything and also I want to get the
612:00 - switch index and this one should also be
612:03 - zero that way we are starting back from
612:06 - scratch let's try this one I can select
612:09 - attack press escape and we are back in
612:11 - the main menu if I go to switch I can
612:14 - also reset and that's looking pretty
612:16 - good finally for this switch menu the
612:20 - top side should be self the top minus
612:22 - 100 although minus 140 I think is going
612:26 - to look a bit better let's TR off this
612:28 - now and we have the monster menu we can
612:31 - go back and that's working pretty well
612:34 - perfect that covers another really
612:36 - important part now that we have the
612:38 - basic menus in place I want to make the
612:40 - entire game interactive meaning we can
612:43 - attack the opponents and the opponents
612:44 - can attack us the logic for all of that
612:47 - isn't going to be too difficult let's
612:49 - Jump Right In back in the code first of
612:52 - all in the game class I want to have
612:55 - another method that I called
612:58 - getor
613:00 - input this one doesn't really get direct
613:03 - user input instead we're going to pass
613:06 - this get input into UI and then via that
613:09 - whenever we are getting input in UI we
613:12 - are returning values to main.
613:15 - Pi you will see in a second how that
613:17 - works but for now for the parameters I
613:21 - want to have this state and some data
613:25 - although the default value for that is
613:26 - going to be none and I suppose for now
613:29 - we can simply print the state and the
613:34 - data after that when we are creating the
613:38 - UI I want to
613:40 - insert self. getet input and important
613:44 - here we are passing around the method we
613:46 - are not calling it that way inside of UI
613:51 - we can capture get input and stored as
613:55 - an attribute let's do at the top getor
613:59 - input is going to be get input what that
614:02 - means inside of the input method for
614:06 - example when we are selecting an attack
614:09 - I can call self. getet input and then
614:13 - insert this state so self. state in my
614:17 - case and some data
614:19 - for that at the moment we are only
614:21 - printing the data but I want to store it
614:23 - as a local variable called a tech and
614:27 - this attack we are passing into get
614:30 - input I can run all of this and inside
614:32 - of attack we getting the attack State
614:35 - and the attack this also works with the
614:37 - other attacks so a pretty good start
614:41 - after that when we are switching I want
614:44 - to call self. getet input once again
614:47 - with self. state and the monster that we
614:50 - have selected this doesn't need to be in
614:52 - a separate variable although you could
614:54 - do that as well next attempt just to
614:57 - make sure everything is working I can
614:59 - select a monster and I get switch and a
615:02 - monster perfect while we are here I can
615:05 - also add two more L if statements L if
615:09 - self. state is equal to heal and if that
615:13 - is the case I want to call self. get
615:16 - input with heal
615:19 - no need for extra arguments heal doesn't
615:22 - do very much also after the player
615:25 - selected heal I want to set self. State
615:28 - back to
615:30 - General which in fact is something I
615:33 - want to do whenever the player presses
615:37 - space or in other words if the player is
615:40 - switching between monsters and selects
615:43 - one then we want to go back to the main
615:45 - menu that was quite a bit let's try
615:49 - if I now go to attack and select one we
615:52 - get the output and we are going back to
615:54 - the main menu the same for switch that's
615:57 - looking pretty good and if I click on
616:00 - heal we're getting heal and not much
616:03 - else
616:04 - happening finally then for
616:08 - escape I want to add one final L if
616:11 - statement if self. state is equal to
616:17 - escape if that is the case self. get
616:22 - input with escape and if that is the
616:25 - case inside of main. Pi what we can
616:27 - already do is if state is equal to
616:32 - escape then self. running should be
616:36 - false that way I can escape and the
616:39 - game's over that way we can get data
616:43 - from the UI now we have to figure out
616:45 - how to actually use it inside of the
616:47 - game
616:49 - or all of that let me minimize
616:51 - everything actually I want to work
616:54 - inside of get input because in there we
616:57 - have to check for a couple of different
617:00 - possibilities and I suppose we can
617:02 - organize this a bit better I want to
617:04 - check if state is equal to a
617:09 - tack if that is the case we want to call
617:12 - the method apply underscore a
617:16 - attack a method that does not exist
617:18 - exist at the moment but in there we want
617:20 - to Target self. opponent and then use an
617:24 - attack which we are getting via the data
617:27 - the check for the Escape state is going
617:29 - to be an L if statement also we don't
617:33 - need the print statements
617:35 - anymore that looks a bit cleaner next up
617:38 - I want to have toine apply underscore a
617:42 - attack with self a Target and the attack
617:48 - for now in there I simply want to get
617:50 - the Target and update the health of that
617:53 - Target I suppose for now to keep things
617:56 - simple I want to reduce that amount by
617:58 - 20 just to make sure that this is
618:00 - working inside of the run
618:03 - method all the way at the end I want to
618:05 - print self. opponent. Health if I now
618:10 - run all of this I can attack the
618:12 - opponent and we're lowering the health
618:14 - of that opponent that's a good sign
618:19 - although not exactly the system that I
618:21 - have in
618:22 - mind what I want instead after the
618:25 - player get the input we are switching
618:28 - over to the
618:29 - opponent then the opponent does
618:31 - something and then it's our turn again
618:34 - for that inside of thunder in it I want
618:36 - to have the attribute player uncore
618:39 - active which by default is going to be
618:42 - true also inside of the run method we
618:46 - are only updating the UI if self. player
618:51 - active next up after we have gotten
618:54 - input from the UI I want to set self.
618:58 - player active to
619:01 - false that way at the moment we should
619:04 - only be able to attack once after that
619:07 - we cannot update the menu anymore that's
619:09 - looking good after that I want your
619:12 - opponent to do something but there
619:14 - should be a delay between the player
619:16 - turn and the opponent turn if you don't
619:18 - include that the entire thing is going
619:20 - to feel much too fast fortunately for
619:22 - all of that we have timers that we are
619:26 - already importing and those timers we
619:28 - have created in the last
619:30 - game to use them inside of Thunder init
619:34 - I want to have a timers section which is
619:37 - going to be self. timers and there we
619:40 - are going to have two key value pairs
619:42 - first one is player end that is going to
619:45 - be a timer with a duration of 1,000
619:48 - and if it times out I want to call the
619:50 - function self. opponent uncore turn
619:55 - while we are here I want to create a
619:57 - second key value pair that one is going
619:59 - to be the opponent end if that is the
620:03 - case we are going to call ler turn for
620:07 - all of that not to crash we have to
620:10 - create two more methods opponent
620:13 - underscore turn and we will need layer
620:17 - underscore turn
620:19 - both of those get passed for
620:22 - now and then after we have gotten the
620:25 - input I want to get self. timers with
620:29 - the player end and then activate it also
620:34 - never forget you have to call the update
620:36 - method on all of these timers which I
620:39 - also want to do in a separate
620:41 - method Define update uncore timers with
620:45 - self and all we have to do in here is
620:48 - for timer in. timers do
620:52 - values and then timer.
620:55 - update that way we are updating all of
620:58 - the timers inside of this
621:00 - dictionary then we have to call the
621:02 - method inside of the run method before
621:05 - we are updating anything else self.
621:08 - update timers with that we have the
621:11 - basic setup to make sure that this is
621:13 - working when we are calling opponent
621:15 - turn which happens after the player
621:17 - input when the timer times out then I
621:21 - want to
621:22 - print opponent turn let's
621:27 - try I can attack the opponent and after
621:30 - a second we getting opponent turn that's
621:32 - looking good we first of all want to get
621:35 - a random
621:37 - attack which we can get via the choice
621:40 - method which we are already
621:43 - importing the list we want to pick from
621:46 - is self. opponent do
621:49 - abilities once we have that self. apply
621:53 - attack the method we have already
621:55 - created this
621:58 - one and then we want to Target self.
622:03 - Monster and the attack to make sure that
622:07 - this is working inside of apply attack I
622:09 - also want to print the attack that we
622:13 - are getting let's try this one I can now
622:16 - attack the opponent with let's say
622:18 - scratch then we're getting scratch and a
622:21 - second later we're getting
622:23 - Splash and that's all we can do we are
622:26 - not updating the menu anymore that we
622:28 - can fix right away actually after the
622:31 - opponent turn we want to call self.
622:35 - timers with the opponent end timer and
622:39 - activate this one once this time it
622:42 - times out we are calling player turn in
622:45 - which for now we simply want to set self
622:48 - do player active back to
622:51 - true that way I can attack with nuke
622:55 - we're getting another attack and then
622:57 - after a second I can use the menu
623:00 - again let's say I want to use another
623:02 - attack spiral and then after a second we
623:05 - are getting another attack and do we
623:07 - always get the same attack no we don't
623:09 - that was coincidence perfect Randomness
623:12 - can be a bit tricky next up I want to
623:15 - properly calculate the damage that we
623:17 - are getting
623:19 - for that if you look at settings we have
623:21 - two dictionaries that we have to work
623:23 - with the first one is abilities data
623:26 - there we're getting all of the attacks
623:28 - and then the base damage along with the
623:30 - element this dictionary we can access
623:33 - via the attack besides that we have
623:36 - element data which is telling us how
623:38 - good an element is versus the target
623:42 - this I can use to calculate the proper
623:44 - damage amount and getting that value is
623:46 - going to be your exercise I want you to
623:48 - calculate the proper damage amount pause
623:51 - the video now and see how far you
623:55 - get first of all I want to get the
623:58 - attack
623:59 - data for which we want to get the
624:03 - abilities data dictionary and then pick
624:08 - the one key value pair that we're
624:10 - getting from
624:11 - aack via that I can print a tack data
624:16 - and let's see what we are getting if I
624:18 - attack with spark we're getting damage
624:21 - element and animation and damage here is
624:24 - the base
624:25 - damage which we can already use we have
624:28 - the base damage that we are getting from
624:32 - Attack data and damage next up we want
624:36 - to calculate the element multiplier we
624:39 - will need the target uncore element
624:44 - which we can get from the Target and
624:46 - that is going to be a monster which has
624:49 - an
624:50 - element or in other words we can simply
624:53 - get target.
624:55 - element for the attack underscore
624:58 - element we simply want to get attack
625:01 - data and in there we have an element we
625:05 - are simply picking this key value pair
625:07 - once we have that we can get an attack
625:10 - underscore multi
625:13 - player for which we want to use this
625:16 - final
625:17 - dictionary for this one we want to pick
625:20 - the element of the attack and then the
625:23 - element of the target which means I want
625:26 - to get the element data then the attack
625:31 - element and finally I want to get the
625:35 - target element and just to make sure
625:37 - that this is working let's print all of
625:40 - this via an F string I want to print the
625:45 - attack element
625:48 - then I want to have the target
625:51 - element I want to have the base damage
625:55 - and finally I want to have the attack
626:00 - multiplier let's try all of this and if
626:03 - I attack with spark which is a fire
626:05 - attack we are getting fire PL 35 and two
626:10 - that's looking pretty good also we got a
626:12 - second entry for fire fire 35 and
626:15 - one which means we attacking fire with
626:18 - fire so our damage multiplier is going
626:21 - to be one this is working quite well
626:24 - with all of that we can calculate the
626:27 - full damage amount it's simply going to
626:29 - be base damage multiplied with the
626:32 - attack multiplier and all of this we can
626:35 - clean up quite a bit we don't need this
626:37 - many lines of code for example the base
626:40 - damage we are only using once so we can
626:42 - use it directly in there for the attack
626:46 - multiplier we are also accessing another
626:48 - dictionary so in there we can get the
626:51 - target element straight away and we can
626:54 - get the attack data element that way we
626:57 - are doing all of this in three lines of
627:00 - code which I think is also much more
627:02 - readable finally to make sure everything
627:04 - is working I want to print an F string
627:08 - with target. health and then
627:13 - target. maxcore Health if I now run all
627:17 - of them this I can attack a plant
627:20 - monster with a fire attack let's go
627:23 - spark and that does quite a bit of
627:25 - damage just to double check we have done
627:28 - 70 damage with this one attack and we
627:31 - have used the spark attack which we can
627:33 - check inside of ability St we have spark
627:38 - which has a base damage of 35 which we
627:41 - have multiplied by two because we have
627:43 - attacked a plant monster with a fire
627:45 - attack whereas the opponent attacked us
627:47 - and only did 20 damage that could have
627:50 - been for example because the opponent
627:52 - use scratch which does 20 damage and the
627:55 - attack element is normal which has no
627:57 - multiplier for
627:59 - anything I suppose we should be a bit
628:01 - more careful I also want to print the
628:05 - attack that we are getting so one final
628:09 - test I can attack a fire monster with a
628:13 - normal attack and we are doing 20 damage
628:16 - whereas the opponent has used luk which
628:19 - is
628:20 - doing 50
628:22 - damage and the multiplier is one because
628:25 - we are attacking fire with fire back in
628:28 - the game I want to attack now with a
628:31 - splash attack which is doing 60 damage
628:34 - overall we went from 100 to 40 that is
628:38 - because splash does 30 damage and we are
628:41 - attacking with water and our Target is
628:44 - fire I think this is working pretty well
628:47 - so with that we have made the game
628:49 - interactive although this isn't terribly
628:52 - visible yet because we have no attack
628:54 - animations and no Health to display that
628:57 - we're going to do in the next section so
628:59 - for the next section we want to make the
629:00 - entire thing much more visual which
629:03 - means we have a health bar and attack
629:06 - animations the health bars are going to
629:08 - take a bit of math but it's not too bad
629:11 - the attack animations are also going to
629:12 - be a fairly basic animation the one
629:16 - difficulty might be if you open the
629:18 - project folder under images we have the
629:21 - attacks and for each attack we have one
629:24 - PNG file which contains multiple
629:27 - Graphics those we have to separate
629:29 - inside of pame which we can do but it
629:32 - will take just a bit more logic and
629:35 - start inside of the UI in there I want
629:38 - to add one more thing Define I call this
629:42 - one
629:43 - stats as always first of all I want to
629:46 - have a background which is going to be a
629:49 - rectangle via py game. F
629:53 - rectangle in which I want to have self
629:55 - do left self. top and for the dimensions
630:00 - I want 250 along with 80 for width and
630:04 - height after that I can copy from switch
630:08 - the py game. draw for the background and
630:11 - the Border like so to see the results
630:15 - inside of the draw method I want to call
630:19 - self.
630:21 - stats let's try main. pi and there you
630:24 - can see one additional box although if
630:27 - we calling switch this one is looking a
630:29 - bit weird to fix that inside of UI I
630:34 - only want to call this method if self.
630:38 - state is different
630:41 - from
630:44 - switch let's try this
630:46 - again and if I select switch we cannot
630:50 - see the name of the monster anymore
630:52 - that's working pretty well after that
630:55 - once we have the background I want to
630:57 - get the actual data which means I most
631:01 - importantly want to have a name surface
631:04 - self. font. render with self. monster.
631:10 - name for nlus I want this to be true and
631:13 - for the colors I want colors and black
631:18 - then we need a name underscore rectangle
631:21 - which is the name surface get F
631:24 - rectangle in which I want to place the
631:27 - top left for which I want to have the
631:30 - wct dot top
631:33 - left plus pame do Vector 2 for just a
631:38 - bit of an offset for X I want to have
631:41 - rect dot Wii multiplied with 0.05
631:48 - which means when we getting this
631:49 - background rectangle we have 5% of the
631:52 - width as padding to the left
631:54 - side or the top I simply want to have 12
631:58 - pixels also I can see at typo this
632:00 - should be monster. name finally self.
632:04 - display surface do blit with the name
632:07 - surface and the name
632:10 - rectangle let's try this one and we are
632:13 - getting the monster name perfect after
632:16 - that I want to have the health
632:20 - bar for which first of all I want to
632:23 - define a health rectangle pame do F
632:28 - rectangle and now I have to figure out
632:30 - some numbers that Define the size and
632:32 - the position of the health bar I want
632:34 - the left side to be aligned with the
632:36 - monster name which means name rectangle
632:40 - do left for the top I want to have name
632:44 - rectangle do bottom plus a bit of
632:47 - petting let's say 10 for the Wii I want
632:51 - to have W do WID multiplied with
632:57 - 0.9 or 90% of the width of the entire
633:00 - background for the height finally I want
633:03 - to have 20
633:04 - pixels just to make sure we can see
633:06 - what's going on py game. draw do
633:10 - rectangle wave self. display surface
633:14 - then I want to have colors and gray and
633:17 - finally the health
633:19 - rectangle if I now run main. Pi we can
633:23 - see a rectangle for the health of the
633:25 - player doesn't do anything at the moment
633:28 - but that's going to be the next part I
633:30 - want to have self. draw uncore bar for
633:35 - which I want to use a couple of
633:36 - arguments the first one is the health
633:38 - rectangle for the size and the position
633:42 - besides that I want to have self.
633:45 - monster. health or the current amount
633:48 - and finally self. monster. maxcore
633:52 - Health this method doesn't exist at the
633:55 - moment so we have to create it draw bar
633:58 - we have self a rectangle a value and a
634:02 - max value and now we have to talk about
634:05 - the basic problem in here at the moment
634:08 - via the rectangle we are getting some
634:11 - area that we want to use for the health
634:14 - bar let's say for Simplicity this thing
634:17 - has a w of 100 pixels and let me add
634:22 - pixel in there just to be clear the
634:24 - issue we now have for the player monster
634:27 - let's say the current health is going to
634:29 - be 60 and the max health is going to be
634:35 - a 100 how can we get the width of the
634:39 - bar from these two numbers and for that
634:42 - first of all inside of the health bar we
634:46 - have to know how many pixels do we get
634:48 - from one Health Point that is a value we
634:51 - can calculate fairly easily I'm going to
634:53 - call this
634:55 - ratio I want to get w. WID and divided
634:59 - by the max value that way in our example
635:03 - if the width of the rectangle is 100
635:05 - pixels and Max health is also 100 then
635:08 - each pixel represents one Health Point
635:12 - and all of that we are storing in the
635:13 - ratio variable via that value we can
635:17 - create I call this the progress
635:20 - rectangle which is going to be another
635:23 - py game. F rectangle in which we want to
635:26 - get a top left position and a size via
635:30 - two tballs the top left is simply going
635:32 - to be wrecked dot top left for the size
635:37 - I want to have a width and a height the
635:39 - height is easy we simply want to get
635:41 - rect do height or in other words the
635:44 - height we're getting from the rectangle
635:46 - that we are passing in there as an
635:48 - argument for the wi though we want to
635:52 - get the value and multiply it with the
635:55 - ratio and that is basically it I can now
635:58 - call py game. draw.
636:02 - rectangle on self. display
636:05 - surface with colors and red and finally
636:10 - the progress
636:12 - rectangle if I now run main. Pi we are
636:16 - getting some health and if I attack the
636:17 - opponent the opponent attacks us we are
636:19 - losing health I can do this multiple
636:22 - times and we keep on losing Health
636:25 - that's looking pretty good next up below
636:29 - the UI for the player I want to have
636:31 - another class that I have called
636:34 - opponent UI and there I want to
636:37 - duplicate what I have done inside of
636:39 - stats meaning I want to display the
636:41 - opponent monster name and give them a
636:43 - health
636:44 - bar this part is going to be your
636:46 - exercise so create a UI for the opponent
636:50 - with the name and the health bar pause
636:52 - the video now and see how far you
636:56 - get to get started I want to define a
636:59 - thunder init method with self and a
637:03 - monster then we will need self. displore
637:07 - surface with py game. display doget
637:11 - surface afterwards I want to have self.
637:15 - monster as the monster and we will need
637:19 - self. font which will be py game. font.
637:23 - font with none and 30 after that I want
637:27 - to have a draw method in which we are
637:30 - defining a background via a rectangle py
637:35 - game.
637:36 - fere and for the position I will go with
637:39 - zero and zero for now you will see in
637:41 - just a second why for the dimensions I
637:44 - want to have 250 and 80 the same thing
637:48 - we have used for the
637:50 - player although we don't need the player
637:53 - UI
637:54 - anymore after we have that I want to on
637:58 - this rectangle use move two that way we
638:01 - can place the mid left right away I want
638:04 - this value to be 500 for x and for y I
638:08 - want to have self. monster. re. Center y
638:13 - after that we can do the usual I want to
638:15 - copy py game. draw for the background
638:18 - and for the
638:19 - Border after we have that inside of
638:22 - main. Pi under UI I want to
638:27 - create self
638:30 - dot
638:32 - opponent UI and the value is going to be
638:37 - opponent UI with self.
638:42 - opponent opponent UI is not available at
638:44 - the moment that we can change by
638:47 - changing from UI import
638:50 - everything with that we getting the
638:52 - opponent UI to display it inside of the
638:55 - run method I want to call self. opponent
638:59 - UI and then draw with that we're getting
639:04 - an area for the opponent and if I run
639:07 - this a couple of times we getting a
639:09 - different position for this box every
639:11 - time because it updates along with the
639:14 - opponent that's looking good you could
639:17 - make all of this static as well it's
639:19 - entirely up to you that part isn't
639:21 - really important for me what I want to
639:23 - work on is a name surface which we are
639:26 - getting via self. font. render with
639:29 - self. monster. name through for
639:33 - antialias and then colors and
639:37 - black next up I want to have a name
639:39 - uncore rectangle with the name surface
639:43 - get F rectangle in which I want to to
639:47 - place the top left and this is going to
639:49 - be very similar compared to what we have
639:51 - done for the player rect do top left
639:54 - plus pame do Vector 2 with rect do wift
640:00 - multiplied with
640:01 - 0.05 and 12 finally self. display
640:05 - surface. blit with the name surface and
640:09 - the name
640:10 - rectangle let's try this one and we are
640:14 - getting the opponent name that's a good
640:17 - signed next up I want to work on the
640:20 - health once again we want to create a
640:23 - health rectangle which is going to be py
640:26 - game. F
640:29 - rectangle with name w. left name W do
640:35 - bottom +
640:37 - 10 wct do WID multipied with
640:42 - 0.9 and 20 the very same numbers we have
640:45 - used for the player monster after that I
640:48 - want to calculate the ratio to figure
640:50 - out how much health is one
640:53 - pixel or in other words I want to get
640:56 - the health rectangle do WID and divided
641:01 - by
641:01 - self do monster.
641:05 - maxcore Health once we have that I can
641:08 - calculate the progress uncore rectangle
641:11 - which will be a pame f rectangle once
641:14 - again with health rectangle top left for
641:18 - the position and for the size I want to
641:21 - have self.
641:23 - monster. health multiplied with the
641:26 - ratio that would be the width and the
641:29 - height is going to be Health rectangle
641:31 - do
641:33 - height and that is all we
641:36 - need we can now draw a couple of things
641:39 - pam. draw. rectangle with self. display
641:44 - surface then colors gray and a health
641:49 - rectangle for the background then
641:51 - duplicate all of this we want to have a
641:53 - red color with the progress
641:56 - rectangle that's all we need in here and
641:59 - now I can attack the opponent and the
642:01 - opponent loses Health the same happens
642:04 - to us and this we can do multiple times
642:07 - looking pretty good to make all of this
642:09 - more visible I want to create an attack
642:12 - animation for that inside of the code I
642:16 - want to create
642:17 - attack
642:19 - dop this is going to be a very simple
642:22 - sprite from settings import everything
642:26 - and then create a Class A attack
642:28 - Animation Sprite Which is going to be a
642:31 - pygame Dos sprite.
642:34 - Sprite defined under a knit with self a
642:39 - Target
642:40 - rames and
642:43 - groups next up we want to have super
642:45 - thunder in it with the groups and self.
642:50 - Frames self. frame uncore index with the
642:55 - arguments frames and zero once we have
642:58 - that we can create self. image which is
643:01 - going to be self. frames and then self.
643:04 - frame index self. rectangle is going to
643:07 - be self. image and
643:10 - getorf
643:11 - rectangle in which I want to place the
643:14 - center at target. re.
643:18 - Center we are simply creating an
643:20 - animated Sprite this we have seen a
643:22 - couple of times by now after that I want
643:25 - to have an update method with self and
643:27 - Delta time in there I want to have self.
643:31 - frame index plus equal 5 * Delta time
643:36 - and for this animation I want to check
643:38 - if self. frame index is smaller than
643:41 - length of self.
643:45 - frames if that is the case I want to
643:47 - update self. image and set it to self.
643:51 - frames index integer of self. frame
643:56 - index and else if that is not the case
643:59 - we want to call the kill method to
644:01 - discard this Sprite that would be a very
644:04 - basic attack Animation Sprite now we
644:07 - have to figure out how to use it for
644:09 - that inside of main.py I suppose we can
644:12 - start by importing it R Tech Import for
644:17 - attack Animation Sprite after that every
644:21 - time we are applying an attack I don't
644:23 - want to print anything anymore instead I
644:25 - want to create one instance of the
644:27 - attack Animation Sprite for which we
644:30 - will need a Target that we already have
644:32 - after that we will need some frames this
644:35 - part we don't have at the moment the
644:37 - groups though we do have self. allore
644:41 - Sprites so how can we get the frames and
644:44 - basically for that inside of import
644:47 - assets I want to create self. attack
644:53 - frames which I want to import via a tile
644:56 - uncore
644:57 - importer in which we have to specify the
645:00 - amount of columns which in our case is
645:02 - going to be four and then the folder
645:04 - path images
645:07 - and a
645:10 - Texs this tym portter doesn't exist at
645:12 - the moment we will work on that in just
645:14 - a second first of all though inside of
645:17 - attack Animation Sprite I want to get
645:20 - self. attack frames and then pick one
645:23 - frame via the name of the attack that
645:26 - would be all we need for this attack
645:28 - Animation Sprite so now we have to
645:30 - figure out the tile importer
645:32 - method this I want to create inside of
645:35 - support. Pi Define tile importer with
645:41 - the amount of columns and then unpacked
645:44 - the path to get started in here here we
645:47 - will do a couple of familiar things I
645:50 - want to have a dictionary called attack
645:52 - frames no values at this point then for
645:56 - folder underscore path underscore and
646:00 - file names in walk join and the path
646:07 - this is something we have seen multiple
646:08 - times at this point after that for file
646:12 - uncore name in file
646:14 - names then I want to create a foldcore
646:19 - path via the join
646:22 - method folder path and file name via
646:27 - that we can create a surface P game.
646:31 - image. load with the full path and
646:35 - convertor Alpha but this we do not want
646:38 - to attach right away to the attack
646:40 - frames inste what I want to do inside of
646:44 - attack frames I want to create a key
646:47 - value pair the key is going to be file
646:50 - name do split wherever we have a DOT and
646:54 - then pick the first entry or in other
646:56 - words we get the file name without the
646:58 - file ending the associated value for now
647:01 - is going to be an empty list and what I
647:04 - want to do if I open all of the attack
647:09 - animations let's have a look at scratch
647:12 - all of this is one image which isn't
647:15 - ideal for me I want to set separate this
647:17 - thing into four separate parts and then
647:21 - attach every individual bit to the
647:24 - attack frames list the one we have just
647:27 - created for that first of all we will
647:30 - need to know how wide the cutout width
647:34 - needs to be and for that I want to get
647:37 - the full width of the surface so Surf
647:40 - and get
647:43 - with this we want to divide by the
647:46 - amount of columns that we have so by
647:48 - default pame doesn't know how many
647:50 - images we have on this one PNG file this
647:53 - we have to specify ourselves and in my
647:56 - case it's always going to be four which
647:58 - is why I added four in there after that
648:02 - I want four column in cols and this CS
648:05 - needs to be inside of a range function
648:09 - what we want to do in here is
648:11 - essentially create a cutout surface
648:15 - which is going to be a very simple pame
648:17 - do surface with the cutout WID for the
648:21 - Whi and then surface
648:24 - get
648:25 - underscore he and don't forget to call
648:28 - this one on this cutout surface I want
648:32 - to blit the part that we have cut out
648:34 - from the original the trick for that is
648:38 - we want to get the original surface and
648:40 - then position zero and zero and finally
648:43 - we can specify another argument which is
648:46 - going to be the area that we want to
648:48 - blit which needs to be a rectangle or in
648:51 - other words I want to get a cutout
648:53 - rectangle which does not exist at the
648:56 - moment to create it cut out underscore
649:00 - rectangle I want to have pame do f wck
649:05 - with the left side the top side the
649:08 - width and the height the width and
649:10 - height are the really easy part we want
649:12 - to have the cut out width and for the
649:14 - height we simply want to get what we
649:17 - have already used surface and get
649:19 - height for the top this part is even
649:22 - easier it's always going to be zero
649:24 - finally for the left side I want to get
649:27 - the cutout WID and multiply it with the
649:31 - column if this is the entire surface
649:34 - that we have imported this one here and
649:36 - we have four
649:40 - columns this value would give us first
649:43 - of all this
649:44 - side and this would happen on the first
649:47 - four Loop then on the next Loop we are
649:49 - going here then we are going here then
649:52 - we are going here and then we are done
649:54 - and with that we have a cutout rectangle
649:57 - this we then want to attach to the list
649:59 - we have created earlier for that I can
650:03 - copy the name of the key that we want to
650:06 - use and then aend the cutout surface
650:11 - nearly done with all of this we simply
650:13 - want to return the attack frames and
650:16 - then inside of main Pi we should not be
650:19 - getting an error message anymore on top
650:22 - of that if I now attack the opponent we
650:25 - are getting an error and the key error
650:28 - is spiral that means when we are picking
650:31 - from the attack frames there's no spiral
650:34 - file in there which you can double check
650:37 - inside of the attacks there's no spiral
650:40 - in there that is because there's one
650:42 - thing I
650:43 - forgot if you look at settings there we
650:46 - have the abilities and each ability has
650:48 - an animation this is the actual name of
650:51 - the file that we want to
650:53 - import or other words we are already
650:55 - getting the attack data from this we
650:59 - want to
651:01 - get the
651:04 - animation if I now run all of this and I
651:06 - attack we are getting
651:09 - animations this also works with
651:11 - different
651:13 - ones so that is looking pretty good
651:17 - although obviously we have to get rid of
651:19 - the black stuff around them all we need
651:22 - for that when we are creating the cutout
651:25 - surface on this line we want to set a
651:28 - custom flag P game. SRC
651:31 - Alpha that way all of this is looking
651:34 - significantly
651:37 - better and we are getting our attack
651:40 - animations nearly done with this part
651:43 - there's just one more thing I forgot in
651:44 - the last part when the player is getting
651:48 - input from the UI at the moment we only
651:51 - have attack and Escape besides that
651:54 - though another simple thing is L if
651:57 - state is equal to health or rather this
652:01 - should be
652:02 - heal if that is the case I want to get
652:05 - self. monster. health and increase it by
652:10 - 50 besides that I want to create an
652:13 - attack Animation
652:15 - Sprite on self. Monster or the frames I
652:20 - want to have the attack frames with the
652:23 - key green you could make this more
652:26 - flexible but for the healing effect I
652:28 - always want to use the same animation so
652:31 - this can stay constant finally for the
652:33 - groups self do all Sprites with that I
652:37 - can heal and the monster well we are
652:41 - definitely healing but this is kind of
652:44 - strange to fix that part we can do
652:46 - something
652:47 - fancy inside of the monster when we are
652:51 - updating the
652:52 - health I always want to make sure that
652:54 - we are never exceeding the maximum
652:56 - health and for that we can use a
652:59 - property getter and a property Setter
653:02 - the way that is going to work first of
653:04 - all I want to turn Health into a private
653:07 - attribute which we can do by adding a
653:09 - single underscore and afterwards I want
653:13 - to have a decorator called property
653:17 - below which we're going to create a
653:19 - health method with self and nothing else
653:23 - and this is simply going to return Self
653:26 - doore
653:28 - Health with that system we are storing
653:31 - the actual information inside of
653:33 - underscore Health but whenever from
653:36 - outside of the class we want to read
653:38 - Health we are calling this method
653:41 - instead that way by default the game is
653:44 - still going to work just fine although
653:46 - if I try to attack then we get property
653:49 - health of opponent object has no
653:51 - Setter that we can fix inside of the
653:54 - monster by adding a property
653:57 - setter this we get via health. Setter
654:01 - and then once again create a health
654:05 - method with self and this one is going
654:07 - to need a value basically now whenever
654:11 - we are trying to update Health we are
654:13 - calling this method and adding the new
654:15 - value inside there as an argument which
654:18 - means we are capturing the new value via
654:20 - the value parameter and then when we
654:23 - updating Self doore Health I want to
654:27 - limit this to never go below zero and
654:29 - never exceed the max Health which we can
654:31 - do first of all I had a Min function
654:34 - which always picks the lower of two
654:36 - values in there I want to get the max
654:39 - health and I want to get the value so if
654:43 - I now run all of this again I can heal
654:47 - the monster does heal but we never go
654:50 - beyond the maximum health looking pretty
654:53 - good besides that when we are setting
654:57 - the value I want to wrap this inside of
655:00 - a Max function which is going to pick
655:02 - the larger of two values and in my case
655:05 - I want to get zero and the value that
655:08 - way this value can never become negative
655:11 - and that is basically it with that we
655:13 - have a property getter and a property
655:15 - setter
655:16 - that ensures that the health of the
655:18 - monster never exceeds the maximum health
655:21 - which is a really nice functionality so
655:23 - for example when you're calling
655:25 - something like Monster Health Plus 50
655:28 - you don't want to have to worry about
655:29 - the maximum or the minimum Health this
655:31 - part should be abstracted away which is
655:34 - something you see very often with this
655:36 - kind of
655:37 - [Music]
655:40 - system we are nearly done with the game
655:43 - there are just a few more minor bits
655:44 - that we have to add
655:46 - most importantly we need to be able to
655:48 - switch monsters and to defeat monsters
655:52 - then we can add some sound files and
655:54 - then we are pretty much good to go to
655:56 - get started with switching the monster I
655:59 - want to work inside of get input and
656:02 - then check if L if state is equal to
656:08 - switch that is only going to be the case
656:11 - if we are getting UI and input switch
656:17 - in there we are passing in self. state
656:19 - along with the available monster if that
656:22 - is the case I want to call self. monster
656:26 - and kill it after that self. monster is
656:31 - going to be data or in other words
656:33 - whatever we are getting from the UI
656:36 - which is also going to be a
656:38 - monster next up self. Sprites do add
656:42 - self. monster after that we have to
656:46 - update the UI which means self. ui.
656:50 - monster is going to be self. monster
656:54 - that is basically all we need if I now
656:56 - switch to let's say jakana we're getting
656:59 - jakana and we have another monster
657:02 - although if I go back to switch we still
657:04 - have jakana inside of the switch menu
657:07 - this shouldn't be the case to fix that
657:10 - inside of UI I want to work in the
657:12 - update method and then keep on updating
657:15 - the available monsters vi list
657:18 - comprehension Monster for monster in
657:21 - self. player monsters if
657:25 - monster is different from self. Monster
657:29 - and monster. health is greater than zero
657:34 - that way we account for the currently
657:35 - active monster and for Monsters being
657:37 - defeated let's try all of this again and
657:41 - I can now switch to let's say gfin that
657:44 - looks good and if if I switch again
657:47 - we're getting spu that's
657:49 - perfect now you could make D
657:51 - functionality just a bit more elegant
657:54 - for example by updating the available
657:56 - monsters every time Monster Health
657:58 - changes or with switching a monster if
658:01 - your frame rate dips too lad this is
658:02 - something you might want to do but in
658:04 - our case performance isn't that much of
658:06 - an issue so I'm not going to worry too
658:08 - much after that inside of main.py I want
658:12 - to detect if a monster has been
658:14 - defeated I for that we can start inside
658:18 - of the opponent
658:20 - turn every time it's the opponent turn I
658:23 - want to check if self.
658:27 - opponent. health is smaller or equal to
658:31 - zero if that is the case I want to do
658:33 - something but pass for now if that is
658:36 - not the case else I want to do the stuff
658:38 - we have already done if the monster is
658:41 - however defeated then I want to set
658:44 - self. player active to
658:46 - R besides that self. opponent. kill and
658:52 - then I want to get a new monster which I
658:55 - want to store as Monster uncore name and
658:58 - get that via Choice list monster data
659:02 - and
659:03 - keys that way we're getting a random
659:06 - monster name via that I want to create a
659:09 - new
659:10 - opponent with the monster name then we
659:14 - will need surfaces which we can can get
659:16 - via self. front
659:18 - serves and the monster name once again
659:23 - finally for the groups self. all Sprites
659:26 - after all of that
659:28 - self. opponent UI do monster is going to
659:33 - be self.
659:35 - opponent that's basically all we need if
659:38 - I now run all of this I can attack this
659:40 - monster with a fire attack it disappears
659:43 - and we're getting another monster
659:45 - although if you paid close attention you
659:47 - have seen something
659:49 - else let me pick another attack and pay
659:52 - close attention to what's happening on
659:53 - the screen we're getting a shadow right
659:55 - below the attack and something else went
659:57 - wrong as well step by step first of all
660:02 - when we are drawing all of the floors
660:05 - that happens inside of draw monster
660:07 - floor in there we are drawing a floor
660:11 - below all of the Sprites which worked so
660:13 - far but now we also have aack Sprite
660:16 - which shouldn't have a
660:17 - floor to account for that I want to add
660:20 - another instance if is
660:23 - instance I want to check the
660:26 - Sprite and then check if it is from
660:30 - Monster a
660:31 - creature so in there I want to have
660:34 - creature which I believe we have to
660:36 - import from Monster I want to import
660:41 - everything only if that is the case do
660:44 - we want to draw a floor
660:47 - let's try off this again and now if I
660:49 - attack we can only see a floor below the
660:53 - monsters that's looking pretty good so
660:56 - next
660:58 - up after we are defeating an opponent
661:00 - once it disappears and that's looking
661:03 - pretty good although the UI doesn't
661:05 - update something is going wrong here the
661:08 - issue is we are creating a new opponent
661:12 - but we are not overwriting self.
661:14 - opponent once we are doing that things
661:17 - should be working if I now attack the
661:20 - opponent with a fire attack it
661:22 - disappears and we are getting another
661:24 - opponent if I defeat this one with
661:26 - Splash we are getting yet another
661:29 - opponent and this I can keep on doing
661:33 - forever that's looking pretty
661:35 - good and there's one thing I so far
661:37 - haven't covered the kill method doesn't
661:41 - actually destroy the Sprite instead it
661:43 - simply removes it from any group which
661:46 - in practice means you cannot see it
661:47 - anymore and it won't be updated but the
661:50 - Sprite is still there which sometimes
661:52 - can be a bit confusing but once you
661:55 - understand how it works it's quite
661:56 - manageable anyway with that we have the
661:59 - opponent turn next up the player turn if
662:03 - the monster is defeated so if defeated
662:06 - then we want to have the next Monster or
662:10 - in other
662:11 - words if spu is defeated then we want to
662:14 - get the next monster with health which
662:16 - might be cleave and then if no monsters
662:21 - we end the
662:23 - game implementing this part will be your
662:26 - exercise so change monsters if the
662:28 - current one is defeated and end the game
662:30 - if all monsters are
662:35 - defeated I want to check if self.
662:39 - monster.
662:41 - health is smaller or equal to zero
662:45 - if that is the case I want to get all of
662:48 - the
662:49 - available
662:51 - monsters for which I can use list
662:53 - comprehension once again Monster for
662:56 - monster inself dopler
663:00 - monsters but only if
663:03 - monster. health is greater or equal to
663:08 - zero then I want to check if there are
663:11 - available monsters in the first
663:13 - place if that is the case I want to kill
663:16 - the current monster self. monster.
663:20 - kill and then create a new
663:23 - monster with the first item from the
663:26 - available
663:27 - ones after that self. Sprites do add
663:32 - with self.
663:34 - monster finally we have to update the UI
663:38 - and there I want to get the monster with
663:41 - self.
663:42 - monster let's try all of this
663:46 - and I want to attack the opponent with
663:48 - spiral that's not going to do very much
663:49 - damage and the monster gets
663:52 - defeated and nothing is
663:54 - happening and that is because this if
663:57 - statement should only check if health is
664:00 - greater than zero if I now try out off
664:04 - this again and let me just attack the
664:07 - monsters and hope I don't kill them too
664:11 - fast we got defeated and now we have
664:13 - another monster perfect you might be
664:16 - wondering at this point why for this
664:18 - list comprehension don't we have to
664:20 - check if we have the current monster
664:23 - like we have done in UI for the
664:25 - available monsters and there we are
664:28 - checking if the monster is equal to the
664:30 - current
664:31 - monster this we don't need because this
664:34 - is only going to run if the current
664:36 - monster has been defeated meaning it's
664:38 - going to disappear
664:40 - anyway besides that if we don't have any
664:43 - more available monsters then we simply
664:46 - want to set self. running to
664:50 - bals that covers everything so next up
664:54 - for the player I only want to have two
664:58 - monsters let's try all of this now and
665:01 - let's hope I don't defeat the opponents
665:04 - too
665:05 - fast that was a good attack that was too
665:09 - strong that one doesn't do any damage
665:12 - okay that's one monster gone and next up
665:16 - I could choose weaker attacks this one
665:19 - doesn't do any damage and now the game
665:21 - is over perfect although there's one
665:24 - issue I did realize if we only have a
665:27 - single Monster so let's hope I get
665:30 - defeated
665:32 - quickly there we go if I only have a
665:35 - single Monster and I go to switch we are
665:37 - getting integer modulo by zero which
665:41 - happens inside of the
665:44 - input inside of switch we are doing
665:47 - modulus and then the length of the
665:49 - available monsters which is a value that
665:52 - can become zero and doing modulus zero
665:55 - is going to get you well something
665:57 - really
665:58 - strange to avoid that case we simply
666:01 - want to check if self. available
666:04 - monsters only if that is the case do we
666:07 - want to allow any input in there with
666:10 - that I can only have a single Monster
666:12 - Run the game and inside of switch
666:15 - nothing is going to happen and with that
666:18 - we have basically the entire game the
666:21 - last thing that we have to add are the
666:22 - sound
666:23 - effects which we can already import
666:26 - quite easily
666:28 - under import
666:31 - assets I want to add self.
666:35 - audio for which we have inside of
666:38 - support audio importer this I want to
666:41 - use audio importer and then go to AUD
666:45 - the yo the same folder that we have
666:47 - already seen a couple of times in there
666:51 - we have a whole bunch of attack sounds
666:53 - and background music that's all we need
666:55 - to play those I want to look at apply
666:59 - attack and then get self.
667:02 - audio and then we need the file name if
667:05 - you look at those files you can see that
667:08 - we have the same name that we are
667:10 - getting from the animation from each of
667:12 - the attack for example we have scratch
667:15 - fire explosion which means inside of
667:18 - audio I simply want to get the attack
667:20 - data and then once again the
667:24 - animation and this I want to play we
667:27 - should be getting sound
667:30 - effects that is working quite
667:33 - well
667:35 - perfect the last thing then we have to
667:38 - start playing the
667:40 - music which I suppose we can do inside
667:43 - of thunder in knit after we importing
667:45 - all the assets I want self. audio with
667:50 - music and play the entire thing as an
667:54 - argument in there I want to have
667:55 - negative one so this one plays
668:00 - [Music]
668:07 - forever perfect that is working really
668:10 - well just one more thing that I forgot
668:13 - when the player gets healed we are also
668:15 - getting getting the attack animation
668:17 - which means in there I also want to get
668:19 - self. audio with the green animation
668:22 - sound and play that one with that inside
668:26 - of the
668:29 - game we are getting a sound effect
668:32 - perfect and that finishes up the entire
668:35 - game so I hope all of this was useful
668:38 - and thanks for watching