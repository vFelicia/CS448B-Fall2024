00:00 - hello there in this tutorial we are
00:02 - going to be creating snake in godot
00:04 - and i will be going through these steps
00:06 - to achieve the entire thing
00:08 - and i do expect that you already know
00:10 - the basics of good dough
00:12 - if you don't check out these videos to
00:14 - get you started on the basics and to
00:16 - start this entire thing off let's start
00:17 - talking about how the game is going to
00:19 - work on a logical level
00:21 - and there are three main steps that we
00:23 - have to cover
00:24 - the first one is that we have to create
00:26 - a grid and for that i am going to use a
00:28 - tile map
00:29 - and usually tile maps are used to layout
00:32 - a level
00:32 - but they are actually quite flexible and
00:34 - you can use them for lots of different
00:36 - purposes
00:37 - which is what we are going to do and
00:39 - once we have the grid
00:40 - we are going to look at every single
00:42 - cell inside of this grid
00:43 - and then we're either going to measure
00:45 - what's inside or we're going to place
00:47 - something inside there
00:48 - and what we're going to place in there
00:50 - is either a part of our snake or the
00:52 - apple
00:53 - and our snake is actually just an array
00:55 - of different grids that we put together
00:57 - and then we're moving these points in
00:59 - certain time intervals super easy
01:01 - actually
01:02 - and then we come to the third part that
01:04 - we are going to add proper graphics
01:06 - and for that we are going to look at the
01:08 - snake and compare each part of the snake
01:10 - relative to the rest of the body
01:12 - so for example when we look at the head
01:14 - we look at the item before it
01:15 - and from that relation we determine what
01:17 - direction the head has to face in
01:19 - and really the only fundamental concept
01:21 - you have to understand is how to use
01:23 - code to influence tile maps
01:25 - so before we get into the actual game
01:27 - let's first play around with that for a
01:29 - little bit i think that's going to be
01:30 - quite useful
01:31 - alright so here we are in an empty scene
01:33 - of godot
01:34 - nothing is happening right now the only
01:37 - thing is that i already imported a
01:39 - couple of files
01:40 - so i have a font i have a couple of
01:42 - graphics and i have one
01:44 - sound file nothing spectacular
01:47 - and before we start with the tire maps i
01:50 - first want to resize our window
01:52 - so that we have a square so for that i
01:54 - go to project settings
01:56 - i scroll down to window and
01:59 - i went with 800x800
02:04 - so that we have a proper square and now
02:07 - i close it
02:07 - and there we go we have a bluish square
02:11 - cool and to get started i want to create
02:14 - a basic note
02:16 - that i'm going to call let's call it
02:18 - main game
02:20 - and as a child of this i'm going to add
02:22 - a tile
02:23 - map and this tile map is going to hold
02:27 - both our snake and our apple so let's
02:30 - call it snake apple
02:31 - although it's not the greatest name but
02:33 - well it's fine i guess
02:35 - and this snake apple is going to get two
02:37 - tile sets
02:38 - so let me create them so on the right i
02:40 - go to tile set
02:41 - and new tile set and then i click on it
02:43 - again
02:44 - and we get to our tile set editor
02:48 - and there i'm going to start with the
02:49 - snake sprite sheet so i just drag it in
02:52 - and they can see our snake so let me
02:54 - zoom in a little bit
02:56 - and this thing we are going to separate
02:58 - into separate different parts
03:00 - so for that i'm going to create a new
03:01 - atlas
03:03 - and i'm going to click on snapping and
03:06 - then i select the entire region
03:08 - and right now you're going to realize
03:09 - that the tile set doesn't line up
03:11 - properly
03:12 - so especially when you look at the head
03:13 - for example it's split into four
03:15 - different parts
03:17 - so we have to adjust a couple of things
03:19 - the first one is the step size
03:20 - it's going to be 40 and 40. oh yeah and
03:24 - these graphics are all 40 pixels by 40
03:26 - pixels
03:26 - just to mention that and then for the
03:28 - subtitle size this also has to be 40 and
03:31 - 40.
03:32 - and once we have that now this entire
03:34 - thing lines up perfectly fine
03:36 - and now i can reselect the region and
03:39 - this is looking much better
03:40 - cool and we could change the icon for
03:44 - this just to make it look a bit nicer
03:45 - and let's go with this one
03:48 - and that's pretty much it so now i can
03:50 - deselect it
03:51 - and go back here and we have our snake
03:54 - dot sprite sheet
03:56 - and there's one important thing right
03:58 - now we look at the name
03:59 - you can see snag underscore
04:00 - spritesheet.png and followed by
04:03 - zero that zero is going to become
04:05 - important later on
04:06 - but we come to that in a bit but now we
04:09 - can
04:10 - like any tile set just pick up a
04:12 - different part of this
04:13 - and draw something with it and i can
04:15 - just pick different elements
04:16 - and draw them on the screen there's one
04:18 - thing i forgot
04:20 - that right now our tiles are too large
04:23 - so i go to cell and the inspector and
04:25 - change this to
04:26 - 40 times 40. and
04:29 - now this is working much better so the
04:32 - one title
04:33 - that i have used as a basic block for
04:35 - now is this one
04:37 - and we can just use it to just paint all
04:39 - over the entire thing
04:42 - and this is how you would create a basic
04:44 - setup for a level
04:45 - that you just pick up random items from
04:47 - this and you build
04:49 - different levels from it which works
04:51 - super well but i don't want to do any of
04:53 - that
04:56 - okay went a bit too far back
04:59 - so i don't want to place any of these
05:01 - elements randomly on the screen
05:03 - i want to use code to put them in very
05:05 - specific positions
05:07 - and for that i first give our main game
05:10 - a script
05:11 - and i want it to be empty and the rest
05:14 - can stay
05:15 - as it is so click on create and now i
05:18 - want to go with funk
05:19 - underscore ready so just to get it
05:21 - tested
05:22 - and whatever this scene is ready i want
05:24 - to do a certain thing
05:26 - and now we can actually talk about using
05:28 - code to influence a tile map
05:30 - and there are a couple of methods that
05:32 - are really useful
05:34 - so let me just create a test variable
05:35 - that i call var test
05:38 - and in that we're going to store
05:41 - something we are going to print
05:43 - once the scene is ready so the most
05:45 - basic one
05:46 - if i target my tire map would be get
05:51 - cell and into this you have to place an
05:54 - x and
05:55 - y so let's just go with zero and zero
05:57 - which would be the top
05:58 - left coordinate and now if i save the
06:02 - entire scene
06:03 - as main game
06:06 - i can run this and let's see what
06:08 - happens in the output
06:10 - we get -1 which is shorthand for this
06:13 - cell is
06:13 - empty but what we could be doing now if
06:16 - i go back to it
06:19 - and let's just fill it with this one for
06:21 - now so the top left one this is going to
06:23 - be
06:23 - zero and zero and if we look at the
06:25 - bottom of the viewport you can actually
06:27 - see
06:27 - zero and zero that's the coordinate so
06:30 - if i go down
06:31 - we can see a preview of what's in there
06:35 - so now we run this entire thing again
06:39 - and i look at output we get zero and
06:42 - this zero
06:43 - is the same zero that we got for the
06:45 - snake here
06:46 - so we know that on this position we have
06:48 - the first tile set
06:50 - which is going to be super useful
06:53 - and actually let me add the second tile
06:56 - set so if i
06:57 - reopen the tile set i want to create
07:01 - a second one with the apple.png let's
07:04 - create a new atlas
07:05 - select it and that's all we needed so
07:08 - now i can go out of it again
07:12 - and now we can see we have our snake
07:14 - with zero
07:16 - and the apple with one so now if i place
07:19 - the apple
07:20 - in this position and now if we were to
07:22 - run this again
07:23 - i would expect one as the output and
07:26 - let's try it
07:27 - and there we go we have one so this is
07:30 - the easiest way to measure something
07:32 - in the tile map so this is already quite
07:35 - useful
07:37 - what we can also do and let me add a
07:39 - couple more
07:40 - tiles and let me actually make a little
07:42 - snake
07:44 - so that we have a bit more to look at
07:51 - so now we have a snake and we have an
07:53 - apple and what i want to do now
07:55 - is to find all the cells that are being
07:57 - used and for that
07:59 - we can get get used cells
08:03 - and if i run this we can get
08:07 - all the different cells that are being
08:08 - used so this is also quite useful
08:11 - and to make this even better i can
08:13 - change this to get used
08:14 - cells by id and now if i were to pass in
08:18 - 0 we would get our snake and if it were
08:20 - to pass in 1 we would get our apple
08:23 - and let's try this so i just want the
08:24 - apple so one
08:26 - and i run this again and this should
08:28 - give us zero and zero because the app is
08:30 - in the top left
08:32 - and we get that cool
08:35 - so with that we have two ways to get all
08:38 - the cells we need to find so this is a
08:40 - really good start
08:42 - so with that we can talk about how to
08:44 - set a cell instead of just getting the
08:46 - information
08:47 - so let me get rid of the print statement
08:50 - and instead of getting a cell
08:52 - i want to set a cell
08:55 - which is called set cell and in here
08:59 - we have to pass in a couple of arguments
09:01 - the first one is the x and the
09:03 - y-coordinate
09:04 - so my case i'm going to go with zero and
09:06 - zero
09:07 - next up we have to give the id of the
09:09 - tile set we want to use
09:11 - so if i pass in 0 we will get the snake
09:13 - if i pass
09:14 - n1 we will get the apple and for now
09:17 - let's go with 0 because i want to use
09:19 - the snake
09:20 - next up we have three more arguments
09:22 - that are called flip x
09:24 - flip y and transpose for now i'm going
09:27 - to set all of them to false because we
09:29 - are not going to use them
09:30 - but they are effectively used to rotate
09:33 - the tile around in its place
09:35 - which we are going to use more later on
09:37 - but for now don't worry about it
09:39 - and finally we have one more argument
09:41 - that is called auto tile coordinate
09:44 - and this one would allow us to select a
09:46 - certain tile from this tile
09:48 - set but for now i'm going to leave it
09:51 - empty
09:52 - and actually this doesn't have to be
09:53 - stored in a variable so i can just get
09:55 - rid of this
09:56 - and just to make this a bit clearer let
09:58 - me get rid of the entire tile set
10:01 - so we know exactly what's going to
10:03 - happen so now i have an
10:05 - empty tile set but when i run the code
10:09 - we see in the top left the one tile we
10:12 - have set via the code once the scene is
10:14 - ready
10:15 - and since we didn't specify a specific
10:17 - subtile we are always going to get the
10:19 - top left tile
10:20 - in this tile set which in my case is a
10:23 - tail that points to the left
10:26 - but what i can do now if i go back to my
10:28 - code
10:29 - i can set a subtitle set which has to be
10:31 - a vector
10:32 - 2. and in here we have to pass in an x
10:37 - and a y and let me explain how this is
10:40 - going to work
10:41 - and this is best explained by going back
10:42 - into our scene and i still have my title
10:44 - set open
10:46 - so in here you can see two rows one and
10:49 - two
10:49 - and then lots of columns so we have one
10:52 - two three
10:52 - four five six seven eight different
10:55 - columns
10:56 - and in the vector we just created the x
10:58 - is going to target the column
11:00 - and the y is going to target the row so
11:02 - for example
11:03 - 0 and 0 would be the first item
11:06 - but if we passed in 1 and 0 so x 1 y 0
11:09 - we will go to this cell here and let's
11:13 - actually try this
11:15 - so for now let's just pass in 0 and 0
11:18 - which should not make any change and
11:21 - we still got a tail pointing to the left
11:24 - cool
11:24 - but now let's change x to one
11:28 - and now we get a tail pointing in the
11:31 - other direction
11:32 - and to make this a bit more clear let's
11:35 - go with two and zero
11:36 - and this should give us the head and
11:38 - there we go we have the head pointing to
11:40 - the right
11:41 - which is if i go back to the tile set
11:45 - we have x 0 1 and 2 and for y it's just
11:48 - going to be 0.
11:50 - so this way we can put any kind of tile
11:53 - on the map
11:54 - and with that we have all the basics we
11:56 - need to make this game work
11:57 - so let's start placing the apple
11:59 - randomly on the screen
12:02 - and the logic for this is super simple
12:05 - all we need is to create two random
12:06 - numbers
12:07 - for x and y and then use those two
12:10 - numbers to place the apple randomly
12:11 - somewhere on our map
12:13 - so let's go straight into our code and
12:16 - let's take care of this
12:19 - so here i am where i left off just a
12:20 - second ago and i'm going to go back into
12:23 - my code
12:24 - and i am for now just going to get rid
12:26 - of all of this
12:27 - so i'm just going to put pass in here so
12:29 - gudo doesn't freak out about error
12:31 - messages
12:32 - and before i go into the other parts i
12:34 - first want to create
12:35 - some constants for now this snake
12:39 - is going to be zero and constant apple
12:43 - is going to be one and this is just
12:46 - going to make it a little bit clearer
12:48 - later on
12:48 - when i select specific tile sets which
12:50 - tile set we are working with and that's
12:52 - all that's happening here
12:54 - and besides that since i have to use the
12:56 - apple position quite a bit
12:57 - i also want to make this a variable so
13:00 - let's call it apple pause and i am just
13:04 - going to leave it empty
13:05 - however once the scene is ready i want
13:07 - to place this apple
13:08 - so i'm going to create apple
13:12 - boss is going to get a return value from
13:16 - a function i call
13:17 - place apple so let's create a function
13:21 - so funk plays
13:25 - apple it doesn't need any arguments
13:29 - and in here i want to create a var x and
13:33 - a var y which are both going to be
13:35 - random numbers
13:37 - and to create a random number we need
13:38 - rand i
13:40 - but i don't want any random number i
13:43 - want a random number between 0
13:45 - and 20 and 20 i got from
13:49 - let me open my time up again so
13:52 - our entire window right now is 800
13:55 - pixels wide and 800 pixels high
13:57 - and each of these cells is 40 pixels
13:59 - high and 40 pixels wide and if we divide
14:02 - 800 by 40 we get 20. so this is going to
14:06 - be the max amount of cells we have
14:09 - and the entire game is going to be
14:10 - static although you could make this more
14:12 - responsive quite easily but that's not
14:14 - the point of this tutorial
14:15 - so i'm just going to keep it static and
14:17 - just use integers
14:19 - so both get rand i mod
14:22 - 20. so that both x and y
14:25 - is going to be a random number between 0
14:28 - and 20
14:29 - and to not get the same numbers every
14:30 - time i am going to add the randomize
14:33 - method
14:34 - and all this one does that make sure
14:36 - that we don't get the same random number
14:37 - every time we run the game which would
14:39 - look quite weird
14:40 - and now that we have that all we have to
14:42 - do is to return
14:44 - a vector 2 that has the x
14:48 - and the y coordinate so every time
14:51 - this ready method is being run our upper
14:54 - position is going to get a random vector
14:55 - with an x and a y position
14:58 - so now i can close this method because
15:01 - we are not going to use it for
15:02 - a little bit and i'm also going to
15:05 - create
15:05 - another function that i'm going to call
15:08 - draw
15:09 - apple so this draw apple actually takes
15:12 - this apple position
15:13 - and puts an apple on the screen and all
15:17 - this one has to do
15:18 - is to target our snag apple and
15:21 - set cell and in here
15:25 - i need apple pause dot x
15:28 - apple pause dot y
15:32 - so the numbers we created in this place
15:34 - apple
15:36 - then i want to get the tile set apple
15:40 - and that's pretty much all we needed so
15:42 - now with a drawable function
15:44 - that does all it needs to do and for now
15:47 - let's just call this drawapple in our
15:50 - ready function
15:51 - so draw apple and
15:54 - let's see if this is working so we got
15:57 - an apple on the screen
15:58 - cool and let's try it again and there we
16:01 - go now
16:02 - we have a different apple and one more
16:04 - time just to be sure
16:06 - now we have an apple in a different
16:07 - position nice
16:10 - so this is already a basic start with
16:13 - very few lines of code we can place an
16:15 - apple randomly on our screen
16:18 - and with that covered let's take care of
16:20 - our snake
16:21 - and for now we are just going to draw a
16:23 - static snake the movement is going to
16:25 - come in the next part
16:27 - and the drawing of the snake works
16:28 - really similar compared to the apple
16:31 - with the only difference now is that we
16:33 - don't have a single position we want to
16:34 - place
16:35 - instead we are going to have an array
16:37 - with multiple positions
16:39 - and we really just cycle through all of
16:40 - them and draw each of these points
16:43 - and that's pretty much it it's
16:44 - surprisingly simple
16:46 - so let's jump right into our code and
16:48 - let's take care of this
16:49 - here i'm back in my basic setup and i
16:51 - want to go back straight into my code
16:54 - and for now i want to create a new
16:56 - variable
16:57 - that i'm going to call snake body
17:01 - and this snake body is going to store
17:04 - all the parts of our snake
17:06 - so it is going to store quite a few
17:07 - different vector 2 positions
17:10 - and just to get it started i want to
17:11 - give it a couple of points
17:14 - so i start with vector 2 and now we need
17:17 - an x and the y position
17:19 - very much like the apple we created
17:20 - earlier or the apple position
17:22 - more specifically and i went with
17:26 - 5 on the x and 10 on the y so it's
17:29 - roughly in the middle of the screen
17:30 - but moved slightly to the left and this
17:33 - would be the head of our snake
17:35 - so next up i create another vector 2 it
17:38 - is going to be 4 on the x and 10 on the
17:41 - y
17:42 - so this position of the snake is one
17:44 - field further to the left
17:46 - than the head and let me copy the entire
17:49 - thing
17:51 - and give it one more position this time
17:54 - three
17:55 - and let me properly assign it to the
17:58 - variable
17:59 - all right so all i have to do now
18:02 - is take each of these points and draw
18:04 - them
18:05 - so let me minimize all of this and
18:08 - create a new function
18:09 - that i call func draw snake
18:13 - and this function later on is going to
18:15 - become quite massive
18:17 - because it will draw lots of different
18:18 - graphics but for now
18:20 - just to get the basic logic working i
18:22 - just want to draw a plane block for
18:24 - every part of the snake
18:26 - it's not going to look great but we're
18:28 - going to take care of the looks later on
18:30 - so really all i want to do in here is
18:32 - for let's call it block
18:34 - in snake body i want to
18:37 - get my snake apple tile map i am really
18:40 - starting to regret the naming here
18:43 - but anyway set cell
18:46 - and now i need a couple of arguments the
18:48 - first one is the x and the y
18:50 - on the tile map and this one is going to
18:52 - be block.x
18:54 - and block dot y
18:57 - so we take let's say this first vector
19:00 - this is going to be this block and then
19:03 - we take the x
19:04 - and y of this to place it and the tiles
19:07 - that we want to use
19:08 - is the one for snake and this right now
19:11 - is going to give us let me open it again
19:16 - so if we left the code like this we
19:17 - would only get the
19:19 - snake tail pointing to the left which i
19:21 - don't want
19:22 - what i want is this plane block all the
19:24 - way to the right
19:27 - and to target this i have to
19:32 - let's say add in faults for x flip
19:35 - y flip and transpose and for the auto
19:39 - tile coordinate i'm going to add
19:41 - a vector 2 and i believe this one had
19:44 - 8 and 0. oh and it is
19:47 - vector 2. did i forget something
19:51 - no it looks good and let's actually try
19:54 - this
19:55 - so once our scene is ready besides draw
19:58 - apple
19:58 - i also want to draw our snake
20:02 - and let's see if this is working
20:05 - all right there we go we have the basic
20:07 - parts of our snake
20:09 - let me close it and with that covered
20:12 - we can actually start talking about
20:14 - moving the snake
20:15 - so let's work on that and this is the
20:18 - part where we get really
20:19 - interesting logic so let me talk about
20:22 - how to move this snake
20:24 - right now our snack has three different
20:26 - points 5 10
20:27 - 4 10 and 3 10 and let's say i want to
20:30 - move this snake
20:31 - one cell further to the right to achieve
20:34 - that i have to take the head
20:35 - and move it one cell further to the
20:37 - right
20:39 - then i have to take the cell in the
20:40 - middle and move it where the head
20:42 - used to be then i take the third cell
20:45 - and move it where the second cell used
20:46 - to be
20:48 - and that way we have moved the entire
20:50 - snake oneself over to the right
20:53 - and this process we are going to do
20:55 - really often about five times per second
20:58 - and here's how this is going to work in
20:59 - code
21:01 - we start by creating a copy of our snake
21:04 - body
21:05 - but this isn't going to be a perfect
21:06 - copy because when we copy it we only
21:08 - copy all the elements besides the last
21:11 - one
21:11 - so every time we do this we remove the
21:13 - last part of the snake
21:15 - and to make up for this we're going to
21:17 - create a new cell at the beginning of
21:19 - the snake
21:20 - and this new cell is going to be the sum
21:22 - of the previously first item in our
21:24 - snake body
21:25 - plus the direction the snake is supposed
21:27 - to go in and the direction is going to
21:29 - be set by the player
21:31 - and this we are going to cover later on
21:33 - but now we would just suppose our snake
21:35 - is moving to the right
21:36 - and that's really all we needed so now
21:39 - let's actually implement it
21:41 - and the very first thing i want to do is
21:43 - to maximize the code editor so we have a
21:45 - bit more space
21:46 - cool now i want to create a new function
21:50 - that i called move snake
21:53 - it doesn't need any arguments so let's
21:55 - jump right in
21:57 - and the first thing i want to do is to
21:59 - create a
22:00 - body copy of our snake
22:03 - so i want my snake body and i want to
22:07 - take a slice
22:08 - which is done with the slice method and
22:11 - in here we need two arguments
22:13 - the first one is the index we want to
22:14 - start on which in my case is zero
22:16 - because i want to start right at the
22:17 - beginning
22:19 - but then we want to go all the way to
22:22 - the end
22:23 - minus one so we take the entire snake
22:26 - body
22:26 - besides the last element and
22:29 - unfortunately
22:30 - we can't just write -1 godot doesn't
22:32 - support that
22:34 - instead what i have to do is snake body
22:38 - dot size and this would give us the
22:41 - number of items inside of this list
22:44 - and then i have to go minus two and the
22:47 - minus two here is important
22:48 - because we start counting from zero so
22:51 - if you wanted the entire list we would
22:52 - have snake body dot
22:54 - size minus 1 but we want all the
22:56 - elements besides the last one so it has
22:58 - to be -2
23:01 - but alright now we have a copy of our
23:03 - snake
23:04 - besides the last element so now we have
23:07 - gotten rid
23:08 - of the tail and to make up for this we
23:10 - have to create a new head
23:12 - so i create a variable new head and for
23:15 - this one
23:16 - i want to get my body copy
23:19 - and get the first element in there so
23:21 - the one with index zero
23:23 - and towards this one i want to add a
23:26 - snake
23:27 - direction which is also going to be a
23:29 - vector
23:30 - and this is going to move this first
23:32 - element into a specific direction
23:34 - and we haven't created this one yet so
23:36 - let's do that
23:38 - so bar snack direction
23:41 - and this is later going to be determined
23:43 - by the player input
23:45 - but for now i just want to make this a
23:47 - vector 2
23:48 - and let's say 1 and 0. so this means it
23:51 - would move to the right
23:53 - and that's pretty much all we needed so
23:56 - all we have to do now
23:57 - is take our body copy
24:01 - and insert a one new head in there
24:05 - and i want it to be inserted at index
24:07 - zero so right at the beginning
24:09 - and i want my new head
24:13 - and this is the entire logic we needed
24:14 - that i talked about just a second ago
24:17 - we start by creating our original snake
24:19 - body and copy all the elements besides
24:22 - the last one
24:22 - so effectively we are going to get rid
24:24 - of the tail
24:26 - and to make up for that we use these two
24:28 - lines where we are going to create a new
24:30 - head that moves our snake in a new
24:32 - direction
24:33 - and now all we have to do is i want to
24:35 - get my
24:36 - snake body back and
24:40 - set this to body copy
24:43 - so that way we can keep on working with
24:44 - our snack body and not have to work with
24:46 - a different variable
24:48 - and all right this is all we needed
24:51 - except there's
24:52 - one more thing because we don't want to
24:54 - call this function once
24:56 - we want to call it multiple times so we
24:59 - have to find some
25:00 - way to call this function lots of times
25:02 - and to do that i just went with a basic
25:04 - timer
25:06 - so i just click a timer and
25:09 - i call this snake tick
25:13 - and here for the wait time i went with
25:16 - 0.2
25:18 - and this is supposed to be autostart but
25:20 - not one short
25:22 - and then every time this triggers i want
25:25 - to send a signal
25:27 - on snake take timeout and this is
25:28 - connected to our main game
25:31 - cool so every time this one ticks
25:34 - i want to call move
25:37 - snake and what i can do as well now
25:41 - i can take raw apple and draw snake
25:44 - and also place them inside here
25:48 - so we keep on drawing them and updating
25:51 - them as well later on
25:53 - and let's actually try this and see if
25:55 - it works
25:58 - so now you can see we have a movement
26:01 - but the movement kind of has a problem
26:04 - so our snake keeps on growing but this
26:07 - isn't because the vector doesn't work
26:09 - the vector keeps on having just three
26:11 - elements
26:12 - the reason why our snake is growing is
26:14 - because we don't delete the old cells
26:18 - so what we have to do every time before
26:20 - we move our snake
26:21 - we have to delete all the snake tiles so
26:24 - what i want to do
26:25 - before all of the movement happens
26:27 - delete tiles
26:30 - and snake now right now
26:33 - this function doesn't exist and kudo is
26:35 - going to give me an error
26:36 - so let me copy the name
26:40 - and create this function so func delete
26:43 - tiles
26:44 - and this one does need an argument it
26:46 - needs the
26:47 - id and this one is supposed to be an
26:50 - integer
26:51 - and all i want to do in here is to get
26:53 - all the cells of a certain id
26:55 - so i have the snake or the apple and
26:58 - delete all of them
26:59 - so i'm going to start by creating a new
27:01 - variable that i call
27:03 - cells and to get all the cells
27:06 - all i need is our snake apple
27:09 - dot get used cells by id
27:14 - and pass in the id we pass into
27:17 - so whatever we pass into delete tiles is
27:19 - also going to be deleted
27:21 - which in this case is going to be snake
27:24 - but this one right now is only going to
27:26 - give us all the used cells
27:27 - so we don't delete them this is going to
27:29 - come now
27:30 - because what i want to do is for cell in
27:34 - cells then i want to target
27:38 - my snack apple again and to delete cells
27:41 - we are still going to use set cell
27:45 - and we target the vector we are going to
27:48 - get
27:48 - from the cell so cell x and cell
27:51 - dot y but what we can do now
27:55 - is pass in a negative one for the tile
27:58 - set id
27:59 - and if this is negative one we are just
28:01 - going to get rid of whatever is in this
28:02 - tile
28:04 - so really all that we are doing in this
28:06 - function is we first get all the
28:08 - different cells by a certain id
28:10 - and then we tell godot to delete all the
28:12 - cells inside of this tile set
28:14 - and now this should be working so let's
28:17 - try
28:20 - and there we go we have a snake moving
28:21 - to the right so this is looking much
28:23 - better
28:25 - but obviously we can't move it so
28:28 - let's work on that so in this section we
28:30 - are going to give the player the ability
28:32 - to control the snake
28:33 - and really all we're going to do is to
28:36 - influence the snake direction we created
28:38 - earlier by using the input method
28:41 - and this is quite easy to do let's jump
28:42 - right back into godot and let's take
28:44 - care of this
28:45 - so here i'm back in my code and i want
28:48 - to create
28:50 - a new function that covers
28:54 - any kind of player input so underscore
28:57 - input event
28:59 - and this function is going to be
29:00 - triggered every time the player makes
29:02 - any kind of input and what i want to do
29:05 - in here
29:06 - is if input
29:09 - is action just pressed
29:13 - and i would just keep with the
29:14 - predefined one and let's start with
29:16 - ui up so if the player is going to press
29:19 - up
29:20 - i want to get my snake direction
29:26 - this one and set this to vector
29:29 - to the x is going to be zero and the y
29:32 - is going to be minus one because we want
29:34 - to move upwards
29:36 - and let me actually move both of them on
29:38 - the same line so it's a bit easier to
29:40 - read
29:41 - and now all i have to do is copy this
29:45 - thing
29:45 - four times and change the different
29:48 - directions so this is going to be
29:50 - right this is going to be left
29:55 - and this is going to be down
29:58 - so for right we go with one and zero
30:02 - or left we're going to go with minus one
30:05 - and zero and then for ui down this is
30:08 - going to be zero
30:10 - and one and that's
30:13 - pretty much it so now whenever we create
30:16 - the new hat
30:17 - instead of just moving the snake to the
30:19 - right we move it wherever the player
30:21 - last pressed the button
30:24 - so let's actually try this so our game
30:27 - is still running that's a good start but
30:29 - now if i press up
30:30 - my snake is moving up and this is
30:32 - working in all the different directions
30:35 - cool so now we have a moving snake
30:40 - now obviously this isn't perfect yet
30:42 - because i can move the snake backwards
30:44 - basically
30:46 - which well would break the game quite
30:48 - fast if it actually was a usable game
30:50 - we also can't touch the apple but all of
30:52 - that is going to come later
30:54 - for now i'm quite happy with this so
30:56 - with that covered let's give our snack
30:58 - the ability to eat the apple
31:00 - and once we're doing that our snack is
31:02 - supposed to grow by one cell
31:04 - and the logic here is surprisingly
31:06 - simple because we only require two bits
31:08 - of information and we have both of them
31:11 - so first off we need the position of the
31:13 - apple and this we have it's a vector two
31:16 - and second we need the head of our snake
31:18 - which we can also get it's just the
31:20 - first element in our snake body
31:22 - and really all we have to do is check if
31:24 - both of these are equal to each other
31:26 - and if that's the case our snack has
31:28 - eaten the apple and for now if that
31:30 - happens
31:31 - i just want to put the apple in a
31:32 - different position growing the snake
31:34 - happens afterwards
31:36 - so here i'm back in my code and let me
31:39 - scroll down a bit
31:41 - and let's create a new function here
31:44 - so i want to create a new function that
31:46 - i am going to call
31:48 - check apple eden
31:51 - potentially not the greatest name but
31:53 - well it's fine
31:55 - in here i want to check if apple
31:59 - pos is equal to snake
32:04 - body and we just want to check the first
32:07 - index
32:08 - oh and i have to use a proper comparison
32:11 - operator
32:12 - and then we're good to go so if this
32:14 - statement is true
32:15 - we know the head of our snake is in the
32:17 - same position as the apple
32:19 - which basically means our snake is
32:20 - eating the apple
32:23 - and if that is the case i want to get my
32:25 - apple
32:27 - pause again and again
32:30 - place the apple which is the function we
32:33 - have created earlier
32:34 - right in the beginning this part here
32:37 - and all this function is doing is it
32:38 - creates
32:39 - random positions and places the apple so
32:42 - we don't have to write anything new here
32:45 - because this function just places the
32:46 - app in a new position
32:48 - so now all we have to do is on our
32:51 - timeout function
32:52 - is also called check apple eaton
32:56 - and let's try this and see what happens
32:59 - so the game is still starting that's a
33:00 - good start
33:01 - and i missed the apple cool and
33:05 - nice this is working pretty well
33:10 - so we get our apple in a new position
33:13 - every time
33:18 - so this part is working but
33:21 - obviously this doesn't really target the
33:23 - main requirement of the game because we
33:25 - want to grow the snake
33:27 - and we already have most of the code let
33:29 - me explain what's going to happen
33:31 - so far every time we moved our snake we
33:34 - get rid of the tail
33:35 - and move the head one cell further in
33:37 - whatever direction we wanted to go in
33:39 - and now to grow our snake for one tick
33:42 - of our game
33:42 - we are not going to get rid of the tail
33:44 - but we are still going to add a new head
33:47 - and that way our snake is going to grow
33:49 - by one cell
33:50 - and that's really it let's actually
33:52 - implement it and let me go all the way
33:54 - to the top because i want to create a
33:56 - new variable
33:58 - and this variable i call at apple
34:02 - and by default it is going to be
34:05 - false and now when i
34:08 - move our snake i only want to do this
34:13 - if at apple
34:17 - let's say let's keep it simple so i only
34:19 - want to do this if add apple
34:20 - is false and if that's not the case
34:24 - i want to do this so if add apple is
34:27 - true
34:28 - i'm going to copy all of this
34:32 - and now literally the only change i have
34:34 - to make is to change this from -2
34:37 - to -1 so
34:40 - now we are actually copying the entire
34:43 - list
34:44 - and adding a new hat to it and that way
34:46 - we're adding a new cell
34:48 - to the snake but we are only going to do
34:50 - this
34:51 - for one tick of our game so once this
34:53 - has run once
34:55 - i want to set add apple back to
34:58 - false and then when we
35:02 - eat the apple so back here i would just
35:04 - add
35:05 - add apple to true
35:09 - and i think that's all we needed let's
35:10 - try so
35:12 - we have our moving snake we get an apple
35:15 - and our snack is growing
35:16 - nice let me try one more
35:19 - and i think this is working really well
35:24 - so that way we have already the basics
35:28 - of our game
35:32 - so with that covered let's talk about
35:34 - fail states that we are actually able to
35:36 - lose our game
35:38 - and let's talk about all the
35:39 - possibilities that could lead to a
35:41 - failure state
35:42 - the easiest one is if we're moving too
35:44 - far to the left to the right
35:45 - up or down so if that happens we want to
35:48 - end the game
35:49 - also we want to end the game if the
35:51 - snake overlaps with itself
35:54 - and right now this could happen for two
35:56 - different reasons
35:57 - one is that the snake bites its own tail
36:00 - or that the player is moving in reverse
36:02 - so we have to cover both of these and
36:05 - we already have all the information we
36:07 - need to cover all of this
36:08 - so i think it's best to jump right into
36:10 - our code and let's take care of this
36:14 - so here i'm back in my code and i want
36:16 - to create a new function
36:19 - that i'm going to call check game
36:22 - over and the first thing i want to do
36:26 - because i want to check the head of our
36:28 - snake quite often
36:29 - i'm going to create a new variable that
36:31 - is going to be this snake head
36:33 - so snake body zero
36:36 - just to save me some writing and now
36:40 - we have to cover two different failure
36:42 - states the first one
36:43 - is snake leaves the screen
36:47 - and the second one would be snake bites
36:51 - its own tail
36:54 - so let's start with snake leaves the
36:56 - screen that one's the easier one
36:58 - and really all we have to check is if
37:02 - hat.x is either
37:05 - greater than 20 or
37:08 - head dot x is smaller than
37:11 - zero so if we're going too far to the
37:14 - right
37:15 - or too far to the left then the game is
37:16 - going to be over
37:18 - but we also have to check up and down so
37:20 - our head
37:22 - dot y is smaller than 0 or head
37:25 - dot y is greater than 20.
37:29 - so if any of these conditions is true we
37:31 - know our snake has left the screen
37:33 - and what happens then let's say i want
37:35 - to reset
37:37 - the game which is a function we haven't
37:39 - created yet
37:40 - but that comes in just a second actually
37:42 - let's do it right now
37:45 - because godot is incredibly annoying
37:47 - about
37:48 - any kind of mistake so all i really want
37:52 - to do in here
37:53 - is that if we have a game over state i
37:55 - want to reset our snake so put it back
37:57 - into the original position
37:59 - so i go all the way to the top and just
38:01 - copy
38:02 - these vector positions
38:05 - and then i just want to take our snake
38:07 - body
38:08 - and give it the original vector
38:10 - positions again
38:11 - so that way we're going to put our snake
38:14 - back into its original position
38:15 - and get rid of all the extra bodies we
38:17 - have added to it
38:19 - and along with that i want to get my
38:22 - snake direction and by default i want to
38:26 - set this
38:26 - to vector 2 to 1 and 0.
38:30 - so that by default our snack is moving
38:32 - to the right
38:33 - and now all i have to do is to copy
38:36 - check game over
38:38 - and call it in our timeout function
38:42 - and let's try this
38:46 - so i just going to move it outside of
38:48 - the screen and
38:50 - well we are getting a game over
38:54 - although what i don't really like about
38:56 - it is that if we're moving outside our
38:58 - snake is going to move
38:59 - quite a bit further
39:03 - and the main reason for that is that
39:04 - this snake timeout function is only
39:06 - called every 200 milliseconds
39:09 - so what i can do instead is to create
39:12 - funk underscore process
39:17 - and check our game over state in there
39:21 - and if we run this now we are checking
39:24 - our fail state much faster
39:31 - so with that we can start working on the
39:33 - second part
39:34 - that the snake bites its own tail and
39:37 - this one is also quite simple to achieve
39:39 - so what i want to do is for block in
39:43 - snake body
39:47 - but i don't want to check the entire
39:49 - snake body instead i only want to take
39:51 - a slice and now i want the entire snake
39:54 - body
39:55 - besides the hat because i already have
39:57 - the head and i want to compare the hat
39:59 - in relation to the rest of the body so
40:01 - this is going to be 1
40:03 - and snake body dot size
40:10 - minus one so what's happening in here
40:14 - is that we look at every block of our
40:15 - snake besides the head
40:17 - so we are starting at the first index
40:20 - and then we go all the way to the end of
40:21 - the snake
40:24 - and in here all we have to check is if
40:27 - lock is equal to our head
40:31 - and if that's the case i just want to
40:34 - reset our game again and let me try this
40:38 - and all i have to do is to move
40:39 - backwards so now we can see
40:41 - i can reset our snake because we're
40:43 - moving inside of the snake
40:46 - but i could also play this for a second
40:48 - and try it that way
40:53 - so this is working quite well nice
40:56 - so the last thing we have to cover for
40:58 - this part is that when we get player
41:00 - input
41:00 - so this entire section here we can't
41:03 - reverse
41:05 - which is very easy to add because all i
41:08 - have to check is
41:08 - if we're going upwards then we can't go
41:11 - downwards
41:12 - so i have to add another if statements
41:15 - so
41:15 - if not snake
41:19 - direction is equal to vector
41:22 - 2 and 0
41:25 - and 1. and only if that is the case our
41:28 - snag direction can change
41:31 - so there are three steps to make the
41:32 - snake direction work
41:34 - we first check for player input right
41:36 - now this is the player pressing up
41:39 - and then if the player is pressing up we
41:42 - are checking if the player is not moving
41:44 - downwards
41:46 - and only if that is not the case then we
41:48 - set the snake direction to go upwards
41:51 - and this logic we have to apply to all
41:53 - of them so
41:54 - let me copy this line
41:58 - and now we want to go right so our snag
42:00 - direction cannot be left
42:02 - which is minus one then we have snake
42:06 - left
42:08 - and in here our snack direction cannot
42:10 - be right
42:11 - so this is going to be one and zero
42:14 - and finally if we are going down our
42:17 - snake cannot be moving upwards
42:19 - so this would be -1 and that should
42:22 - cover it so let's try
42:24 - so our snake is still working and i'm
42:25 - pressing to the left right now
42:27 - or i'm pressing down right now but we
42:30 - can't move in that direction
42:31 - but the rest of the controls still work
42:33 - perfectly well cool
42:35 - so with that we have the really basic
42:39 - parts of a snake game
42:41 - and with that part covered we can talk
42:42 - about making the game look a bit
42:44 - nicer and this is going to be the most
42:46 - complex part of this entire tutorial
42:49 - so let's go through it really really
42:51 - slowly
42:53 - what we are going to do is we are going
42:55 - to cycle for each part of the snake
42:57 - and compare each bit with the bit before
43:00 - and after it
43:01 - and then depending on the relationship
43:03 - with the neighbors we are going to place
43:05 - a specific kind of graphic
43:06 - so for example for our head if the next
43:09 - block is to the left
43:10 - we know our head has to face to the
43:12 - right or if we are in the middle of the
43:14 - snake if there's a block below and to
43:16 - the right of a block
43:17 - then this block has to be a curve that
43:19 - goes right and down
43:21 - but since there are quite a few
43:22 - different possibilities we
43:24 - are going to end up with lots of
43:25 - different if statements
43:27 - so let's go through it slowly and i
43:29 - explain why we implement it
43:31 - so here we are back in the code and i
43:33 - have minimized all the functions besides
43:35 - draw snake
43:36 - because this is where all the graphics
43:38 - stuff is going to happen
43:40 - and let me comment out this part for now
43:44 - because we are going to replace the
43:46 - entire thing
43:48 - and what i want to do in here is to
43:49 - cycle for every block of the snake
43:52 - so you could go for block in snake
43:56 - body however that would not work
44:00 - because besides the block of the snake
44:02 - we also want to know the index of this
44:04 - block
44:05 - because the index could be used to find
44:07 - the neighbors of this block
44:09 - and unfortunately godot does not have an
44:11 - enumerate method
44:12 - so this one wouldn't be working but
44:15 - instead what we can do
44:18 - is for let's call it block index
44:21 - in snake body dot
44:25 - size so this way our block index would
44:28 - just be 0
44:29 - 1 and 2 and then we can create a new
44:31 - variable
44:32 - that is called block and this block is
44:35 - going to be
44:36 - snake body and the index is going to be
44:40 - block index and now i could
44:43 - actually let me copy the previous one
44:47 - so this is the drawing we had earlier
44:50 - and let me run off this to see if it's
44:52 - working
44:53 - and yeah we get the exact same result
44:56 - so this one is still working quite well
44:58 - nice
45:00 - but now i don't want to draw all of
45:02 - these elements anymore
45:03 - instead i want to draw individual
45:06 - elements
45:07 - so for example i want to target the head
45:09 - or the tail
45:10 - and let's actually start with the head
45:13 - and targeting the head is
45:14 - really easy because the head is always
45:16 - the very first element so all we have to
45:18 - do
45:18 - is if log index
45:22 - is equal to zero and if that is the case
45:26 - we know we have the head and in here we
45:29 - have to figure out
45:30 - what the relation between the head and
45:32 - the next block is going to be
45:33 - so for that i'm going to create a new
45:35 - variable that i call
45:37 - head direction or head dear just to keep
45:39 - it a bit shorter
45:41 - and for this one i'm going to create a
45:43 - new function that i call
45:44 - relation 2 and this is just checking the
45:47 - relationship between
45:48 - two vectors and it's supposed to check
45:51 - snake
45:52 - body 0 so the head itself
45:55 - and snake body 1 so the next block
46:00 - so let's create this function so
46:03 - func relation 2
46:07 - and i want a first block
46:11 - that is going to be a vector and then
46:14 - a second log which is also going to be a
46:18 - vector 2.
46:20 - and now all i have to do in here is to
46:21 - subtract one vector from the other
46:24 - and i call this block relation
46:28 - and really all we have to do is get the
46:30 - second block
46:32 - minus the first block and this is going
46:35 - to give us a vector that points in one
46:37 - of four directions
46:39 - it could be 1 0 minus one zero zero one
46:42 - and zero minus one depending on how
46:45 - these blocks relate to each other
46:47 - so for example if the head of our snake
46:49 - is in position five
46:50 - and ten and the second block is at
46:52 - position five
46:53 - and four then we can subtract the first
46:56 - one from the second one and then we get
46:57 - minus one and zero and this would tell
47:00 - us that the second block is to the left
47:02 - and with that all we have to do is
47:06 - if log relation
47:10 - is equal to vector 2
47:13 - and let's go with 0 and -1
47:16 - and if that is the case i want to return
47:20 - left and now we have to do the entire
47:22 - thing
47:23 - for all the four blocks oh sorry
47:26 - this is supposed to be -1
47:29 - and 0. so now let's say if this is
47:32 - 1 and 0
47:35 - this would be right if this is
47:39 - 0 and 1
47:42 - this would be bottom and
47:45 - 0 and -1 this would be let's call it top
47:50 - so all that's happening in here is that
47:51 - we are subtracting one vector from the
47:53 - other
47:54 - and this is going to tell us where these
47:56 - blocks are in relation to each other
47:58 - and now in our drawsnake function
48:02 - we can use that information so if head
48:06 - deer is equal to
48:09 - right then i want to get
48:13 - my snake apple tile map and i want to
48:15 - set
48:17 - the cell and now
48:20 - x and y and the entire set is going to
48:23 - stay the same
48:24 - actually all of them are going to stay
48:25 - the same at least for now let's just
48:27 - copy
48:28 - the entire thing so for this entire
48:31 - block
48:32 - we know that this is supposed to be the
48:34 - head facing to the right
48:36 - so what we can do now instead of taking
48:38 - this plane rectangle
48:39 - let me open the tile map again
48:41 - [Music]
48:43 - so right now we're taking this piece but
48:45 - now we want to take the head facing to
48:47 - the right
48:48 - so this would be two and zero
48:51 - and two and zero
48:54 - and that's pretty much all we have to do
48:57 - all i have to do
48:58 - now is to copy this line
49:01 - for each of the different directions so
49:04 - let me copy it four times
49:06 - and now i want to look at if my head is
49:08 - facing left
49:10 - up or down
49:14 - and now to pick the different graphics
49:16 - we can go in two different routes
49:18 - we could either select a different kind
49:20 - of vector
49:21 - so for example vector left instead of
49:24 - two and zero
49:26 - would be three and one
49:31 - so this would be one way to approach it
49:33 - or
49:34 - we could just flip the entire thing in
49:35 - the x direction so i could just set this
49:37 - to true
49:38 - and we would have the same outcome both
49:40 - would work just fine it's really up to
49:42 - you what you want to go for
49:45 - and then for up let me look it again so
49:48 - this one would be four and zero
49:50 - and we just have to flip it in the y
49:51 - direction so this would be
49:54 - four and zero and then this would be
49:58 - true and then for down we would just
50:00 - have to take
50:01 - four and zero and that is all we need
50:05 - for the head
50:05 - let's try this now let's hope it's
50:07 - working
50:10 - and it is not
50:14 - ah and the reason is quite simple that
50:16 - right now
50:17 - we are drawing all of this but then we
50:19 - are drawing this on top
50:21 - so i only want to get this line here
50:24 - if none of this is true so now let's try
50:28 - it again
50:31 - and there we go
50:34 - something has gone wrong a tiny bit
50:37 - which i think is quite useful to
50:38 - illustrate the principle
50:42 - so for now we know that going left and
50:44 - right at least shows us a head but the
50:46 - head is going in the wrong direction
50:48 - which is very easy to address because
50:51 - all we have to do
50:52 - is to change the flip x to
50:55 - the inverse value so true and false
50:59 - and now let's try again and now for left
51:02 - and right
51:03 - we have the head of our snake
51:06 - nice oh and
51:10 - for up and down this is not up this is
51:12 - top
51:13 - and down is autumn
51:16 - so now let's try this again and
51:21 - well we get something at least now but
51:24 - what you can see
51:25 - now this is that i have picked the wrong
51:28 - element
51:29 - but that's not a problem so this one is
51:32 - supposed to be
51:32 - three because we start counting at zero
51:35 - so now let's try it again
51:38 - and ah we are almost there i just
51:40 - inverted them
51:43 - final step this has to be volts
51:47 - and through and
51:50 - now let's try it there we go this feels
51:54 - much better
51:57 - so i think you can already tell this is
52:00 - going to be a lot of if and else
52:02 - statements
52:02 - and when i set up the entire system i
52:05 - went a lot with trial and error
52:07 - to figure out in what way each element
52:10 - has to point
52:12 - which can be quite confusing but if you
52:15 - work with this for a little bit it
52:16 - actually gets fairly straightforward
52:19 - and now that we have the head we can
52:21 - take the tail
52:22 - actually super easily because it's the
52:24 - exact same logic except on the other
52:26 - part
52:28 - so now to target the tail i want if
52:31 - block index
52:34 - is equal to snake body dot
52:37 - size and -1
52:41 - so this one is always going to give us
52:43 - the last element in our snake
52:45 - and for this one i want to create a new
52:47 - variable that i call
52:48 - tail direction
52:52 - and here again i can use my relation to
52:55 - function
52:56 - and i want to place in here snake body
52:59 - -1 so the last element and then
53:03 - snake body -2
53:06 - so the element before the last element
53:08 - and once i have that
53:10 - i can just copy the entire part for the
53:13 - head
53:15 - and paste it in here because it's the
53:17 - exact same logic
53:18 - except now i have to rename a couple of
53:21 - things
53:22 - or let me call this head here instead of
53:24 - head direction
53:26 - it's going to make the entire thing a
53:27 - good bit more compact
53:29 - so
53:33 - tail direction oh and an important part
53:37 - is that this has to be an
53:38 - l if statement so the entire thing is
53:41 - going to work and we don't overwrite
53:43 - the original one with this else
53:46 - statement down here
53:48 - so let's actually try how this is going
53:49 - to look
53:51 - and now well i guess this is some kind
53:54 - of snake game
53:56 - it could be a fun multiplayer game but
53:57 - well it's up to you
54:00 - okay so instead of getting a head i want
54:02 - to get a tail
54:03 - to make this thing look decent and i
54:05 - have to tailor position 0 0
54:07 - and 0 1. so this is going to be
54:10 - 0 0 and
54:14 - this is 0 and 1
54:17 - and 0 and 1. and we probably have to
54:20 - adjust it
54:21 - so let's have a look so
54:24 - it is working but each direction is
54:27 - exactly the wrong way
54:29 - but the entire logic else is still
54:32 - working fine
54:33 - cool so all we have to do
54:37 - is for the left and the right is to
54:39 - invert the horizontal direction
54:41 - so instead of true for x flipped is
54:43 - going to be false
54:44 - and for false is going to be true and
54:47 - then for
54:47 - top and bottom the false y
54:51 - flip has to be true and the true for the
54:54 - bottom has to be
54:55 - false and now let's try the entire thing
54:58 - again
55:00 - and there we go we have the
55:03 - head and the tail of our snake and they
55:06 - work perfectly fine
55:10 - let's say one more and yeah this is
55:13 - working really well
55:14 - nice so with that we have the head
55:18 - and let me put it away and we have the
55:20 - tail and let's move that away as well
55:23 - so now we can start working on all the
55:25 - parts in between
55:27 - and so far we only have to know one
55:29 - neighbor for each block
55:31 - so for the head we had to know the block
55:32 - that came before it and for the tail we
55:34 - had to know the block that came after it
55:36 - but for all the middle parts we need to
55:38 - know the block that came before it
55:40 - and the block that came after it so even
55:43 - more logic to make all of this work
55:45 - but again let's work through it step by
55:47 - step so
55:48 - here i'm back in my code and i want to
55:50 - put all of this inside of an
55:52 - else statement and because of that i
55:56 - also move
55:56 - all of this in there as well and the
55:59 - first thing we have to get here
56:01 - is to get the actual position of the
56:02 - previous end of the next block
56:04 - and i'm going to store both of them in
56:06 - their own variable so let's call this
56:08 - previous block and i want
56:12 - var next lock and
56:16 - previous block is going to be snake
56:19 - body and i want my
56:23 - block index and it's going to be
56:26 - plus one and we can do the very same
56:29 - thing
56:31 - for the next block except now this has
56:34 - to be -1
56:36 - so this way we have a block ourselves
56:38 - our main block here
56:40 - and then we have a previous block and
56:42 - the next block
56:43 - and the relation between these three
56:45 - blocks is going to tell us what kind of
56:47 - block we need for the block itself
56:49 - although there's one more change i want
56:51 - to make that i don't want to block
56:52 - itself
56:54 - i want the block's relationship with our
56:56 - current block
56:57 - and for that all i have to do is to
56:59 - subtract the block itself
57:01 - so minus block and this is going to give
57:05 - us
57:05 - exactly the same thing that we have seen
57:07 - down here that we're just going to
57:09 - subtract
57:09 - one block from the other and
57:12 - unfortunately we couldn't use this
57:14 - function anymore
57:14 - because we are going to need a bit more
57:16 - information from these blocks
57:18 - but okay let's do some more if
57:20 - statements
57:21 - and for now i want to work on all the
57:23 - blocks that are either horizontal
57:24 - or vertical because these are quite easy
57:27 - to get
57:28 - and really all we have to know here is
57:30 - that if our previous block
57:32 - and our next block have the same x
57:34 - position then we know it's going to be a
57:36 - vertical block
57:37 - and if they have the same y values then
57:39 - they are going to be a horizontal block
57:42 - so really all we have to do is if
57:44 - previous
57:45 - block dot x is equal to
57:49 - next block next block dot
57:52 - x and if that is the case let me copy
57:55 - the entire set cell method again so
57:58 - these three stay the same
58:00 - every single time but now
58:03 - i want to cover the vertical cell
58:07 - which is going to be zero one
58:10 - two three four so four zero and four
58:13 - one are the vertical and the horizontal
58:15 - cell so
58:17 - this is going to be four
58:20 - and one and now i can copy the entire
58:24 - thing
58:25 - and i just want to check the y
58:27 - attributes
58:28 - and if they are true then this is going
58:30 - to be four and zero
58:32 - and let's try this now
58:36 - and there we go if we're going
58:39 - just left and right this is already
58:42 - looking
58:43 - really good but if you're going up and
58:45 - down
58:46 - something is going wrong so let's
58:49 - investigate that part
58:51 - and again the reason for this problem is
58:53 - that i forgot to set an
58:55 - l if statement so that this one did
58:57 - actually work
58:59 - but the problem is that then godot went
59:02 - with this statement
59:03 - and then use the else statement and
59:05 - paint it over this initial if statement
59:08 - so that's why it didn't work but now
59:10 - with an el if statement
59:11 - this is only going to run if neither of
59:14 - these work out
59:15 - so now let's try it
59:18 - and there we go if we go all the way
59:22 - horizontal
59:23 - or vertical then this is working really
59:25 - well
59:27 - so all we have to do now is to figure
59:29 - out the corners
59:31 - and this is arguably the most complex
59:33 - part of this entire thing
59:35 - so let's talk through it very slowly and
59:38 - all of this is going to end up
59:40 - in another else statement and let me get
59:44 - rid of this bit here entirely now
59:46 - because we're not going to need it
59:47 - anymore
59:48 - for the corners we have all the
59:50 - information we need
59:51 - to draw the right one but we do have to
59:53 - think about the logic here quite a bit
59:55 - so let's use an example let's say we
59:58 - have one block on position
59:59 - five and ten and then we have one block
60:02 - to the right
60:02 - at position six and ten and then one
60:05 - block above this block
60:06 - so position five and nine and let's say
60:09 - the one to the right is the next block
60:11 - and the one on top is the previous block
60:14 - and all we have to check now is next
60:16 - block.x is equal to one
60:17 - and previous block.y is equal to -1 but
60:21 - we have to check these blocks from two
60:22 - different positions
60:24 - so the snake could either come from the
60:25 - right and go upwards or the snake will
60:27 - come from the top and go to the right
60:29 - so when we check the relation between
60:31 - these blocks we have to check both
60:33 - possibilities
60:34 - and that's pretty much it it probably is
60:37 - going to be
60:37 - quite complicated so i would recommend
60:39 - going over this a couple of times but
60:42 - let me actually implement it
60:44 - so let's start if previous
60:47 - block dot x is equal to -1
60:52 - and next block dot y
60:57 - is also equal to -1 so we have a block
61:00 - to the left and the block above
61:02 - but we also have to check the or that if
61:05 - next block dot x
61:09 - and previous
61:12 - log dot y
61:16 - both equal to -1
61:22 - then we're going the same corner but the
61:24 - other direction
61:25 - but if either of these are true then we
61:28 - just want to draw a corner
61:33 - so again i copy snakeapple all of these
61:36 - still stay the same
61:38 - but now i'm going to copy i think this
61:42 - is number five
61:43 - and let me open our tile map again
61:47 - so now i want these four blocks here
61:49 - that are the different corners
61:51 - it's going to be 0 1 2 3 4 and 5.
61:55 - so i have 5 6 5 1 and 6
61:58 - 1. and these are the blocks i want to
62:00 - target now
62:02 - and i will probably have to work around
62:05 - with these different ones
62:06 - so let's see how far we get with this
62:08 - one
62:10 - so it's still working but now if i get
62:12 - around the corner
62:14 - we can see that we're going up and to
62:16 - the left or we're going down and to the
62:18 - right
62:25 - so what we have to do is to flip both of
62:28 - these
62:29 - to true
62:32 - and that way if we're going right and
62:36 - up we have a proper corner nice
62:45 - so now i can copy these two lines
62:50 - and again copy them four times for each
62:53 - different possibility
62:55 - and now one previous blocked x is minus
62:57 - one and i want to go with minus one
63:00 - and one
63:03 - and then for the next block x is still
63:05 - minus one
63:07 - and previous block dot y is just going
63:09 - to be
63:10 - one and if that is the case i think i
63:14 - just have to flip
63:15 - this one around so now instead of going
63:17 - right and up we're going right and down
63:19 - and let's try this so now we can go
63:23 - right and up and right and down nice
63:26 - and we can also get top and left
63:30 - because it's the same corner
63:33 - so this starts to come together quite
63:36 - well
63:37 - nice oops
63:41 - that wasn't intentional okay
63:44 - now we can cover the next one where we
63:46 - have x is one
63:48 - and y is negative one and next block
63:52 - is going to be one and previous block is
63:56 - going to be minus -1
63:58 - and i think for this one we have to flip
64:00 - around the previous one entirely so this
64:03 - is
64:04 - false and true and let's try this one
64:06 - now
64:10 - and seems to be working nice
64:15 - and every other part is still working
64:17 - perfectly fine
64:19 - and now for the final one we just go
64:21 - with one and
64:23 - one and one and one
64:26 - and for this one i think both have to be
64:28 - false
64:30 - and this is pretty much it let's try it
64:33 - now
64:36 - and we have a fully functioning snake
64:38 - nice
64:40 - and yep i think this works really well
64:46 - so i assume if you look at this
64:49 - entire block here even further up
64:53 - all the way up till here this is quite a
64:56 - bit of advanced
64:57 - coding or at least let's say slightly
64:59 - more advanced
65:02 - so i would really recommend to go over
65:03 - this a couple of times and ideally draw
65:06 - all of the vectors
65:07 - it is really good to visualize how all
65:09 - of these relate to each other
65:12 - and honestly when i laid out the entire
65:14 - logic by myself
65:15 - i just draw them out and went by trial
65:18 - and error
65:19 - because just doing all of this in your
65:21 - head is really complicated
65:23 - but if you understand the basic logic
65:24 - all of this actually becomes
65:26 - really simple but okay now we have
65:29 - finished our
65:31 - drawing snake function so i can close it
65:33 - and not worry about it again
65:35 - but now while we're at it let me go back
65:38 - to the scene again
65:39 - we don't have a background which well
65:42 - would be kind of nice to add
65:44 - and for this one i was quite lazy
65:46 - because i already have the grass
65:48 - background
65:49 - and all i have to do is to add a
65:52 - texture rectangle
65:55 - and put it behind our snake
65:58 - tile map and place it in there
66:03 - and we have two blocks and these are
66:06 - also 40 by 40 pixels
66:08 - so they are already covering the same
66:10 - block size
66:13 - and now all i really have to do
66:16 - is to go to layout and click on full
66:18 - rect
66:20 - and then in the inspector click on
66:22 - expand
66:23 - and stretch mode is supposed to be tile
66:27 - and that way we get the entire
66:29 - background so let's try now
66:32 - and there we have a much better looking
66:35 - game so
66:36 - this is already getting much much better
66:44 - so very nice and we are actually quite
66:48 - close to finishing the entire game
66:50 - the one thing left to do is to talk
66:52 - about the score and to add some sounds
66:54 - and that's pretty much it both of these
66:56 - are really easy to get
66:57 - so let's start with the score and all we
67:00 - have to do to get the score
67:01 - is to measure the length of our snake
67:03 - body array because
67:05 - every time our snake eats an apple this
67:07 - one gets longer by one unit
67:09 - and then we just have to display that
67:11 - number minus our starting length which
67:14 - is super easy to do so let's jump right
67:16 - in so
67:17 - here i am back in my main game scene and
67:20 - to get our score i want to put all of
67:22 - this into a new scene
67:24 - that i will just put down as a 2d scene
67:27 - and let's call this one score seems like
67:29 - a good name
67:30 - and for now all i want to put in here is
67:33 - a
67:33 - label that i will call
67:37 - score text and by default just so we can
67:41 - see it let's put a zero in there
67:43 - so now if i zoom all the way in we can
67:45 - see our zero
67:48 - and furthermore i can give it a custom
67:50 - font
67:51 - on the right under custom fonts i give
67:53 - it a dynamic font
67:54 - and i click on it again and i click on
67:57 - font
67:59 - and drag in poets in one the font i had
68:01 - in my font
68:02 - folder and now this is looking a little
68:05 - bit nicer
68:06 - and while we're at it i also changed the
68:08 - color of the font so i go to custom
68:10 - colors
68:10 - and click on font color it's not
68:13 - supposed to be black
68:14 - instead the font hexadecimal is
68:17 - 3 8 4 a
68:20 - 0 and c which is
68:24 - a dark greenish color which i think
68:26 - works well with the theme
68:27 - and since i want to reuse it i click on
68:29 - the plus in the bottom here
68:31 - and now i saved it so we can reuse it
68:33 - later and now i have the number
68:35 - and i want to save this scene i am also
68:37 - going to do this in the main folder
68:39 - and score is still a fine name and now
68:42 - back in our main game
68:44 - i am just going to put an instance of
68:46 - this score
68:47 - as a child to our main game and now if i
68:51 - run the entire scene
68:53 - i can see the zero in the top left it
68:55 - doesn't do anything right now but we are
68:57 - going to take care of that
68:58 - right now and let me explain how i want
69:02 - to do that
69:02 - i am going to put my score scene into a
69:05 - group
69:06 - and this group is going to have an
69:07 - update method and every time our snake
69:10 - eats an apple
69:10 - i'm going to trigger this update method
69:12 - and pass in the length of our snake
69:15 - and that way we can update the score
69:17 - every time the snake eats an apple
69:19 - so we are going to use a very simple
69:21 - group setup for godot to make all of
69:23 - this work
69:24 - so back in the editor i go to score and
69:27 - with my score selected i go to node
69:29 - and groups and i'm going to give it a
69:31 - group and let's call this
69:33 - score group
69:37 - and now we can see the icon next to
69:39 - score
69:40 - and besides that i also want to give it
69:42 - a script
69:44 - and i'm going to leave all of this let's
69:46 - leave it empty
69:47 - seems fine and now in here
69:51 - i have to create a new function that i
69:54 - call update
69:55 - score and this update score is going to
69:59 - take one argument
70:00 - that i'm going to call snake length
70:04 - and then all i want to do is to get my
70:07 - score text
70:08 - dot text and this is going to be
70:12 - a string of the snake length
70:16 - so literally all that happens in here is
70:18 - that whenever we call this method
70:20 - we are taking our score text and setting
70:22 - the string of the text to whatever the
70:24 - snake length is going to be
70:26 - and now that we have that we can go back
70:28 - to our main game scene
70:30 - and let me clean this up a little bit so
70:33 - it looks a little bit
70:34 - neater okay this looks better
70:40 - there we go okay now in
70:43 - our function for check apple eaton i'm
70:46 - going to open this one
70:48 - and every time this is happening all i
70:50 - want to do
70:51 - is get tree and
70:54 - call group
70:58 - and i want to call my score
71:02 - group and inside of that score group
71:06 - the method i want to call i called
71:08 - update
71:10 - score or at least i think i did
71:13 - uh yes i did and the argument i want to
71:16 - pass into it
71:17 - is snake body dot
71:21 - size and now with that this
71:25 - should theoretically be working let's
71:26 - try so i run the game
71:29 - still shows zero and now whenever i eat
71:32 - the first apple we get
71:33 - three we're gonna fix that in a second
71:35 - but if i eat
71:36 - another apple we get to four and then we
71:40 - get to
71:40 - five and let's try one more just to be
71:43 - sure
71:44 - and we get to six cool so this is
71:46 - working
71:47 - and now the only problem with the score
71:49 - is that when we eat our first apple we
71:51 - don't go to one
71:52 - instead we are going to free and the
71:54 - reason for that
71:56 - is that our snack body by default has
71:58 - three vectors inside
72:00 - and then when we eat the first apple
72:02 - this size is supposed to be four
72:04 - but we only update the snake body after
72:07 - this is
72:08 - run but since all of that is constant
72:11 - all i have to do
72:12 - is to get my snake length and subtract
72:15 - two
72:16 - and that's pretty much it so now let me
72:19 - get back to my main game
72:20 - and let's try this again now we still
72:23 - start at zero
72:24 - and if i now go up we get to one
72:27 - and then we will get to two and
72:30 - so on so this is working nice and well
72:34 - cool so now we have a score and
72:37 - all we really have done here is that we
72:39 - have taken the length of our snake
72:42 - minus the starting position with some
72:44 - minor adjustments
72:46 - so what we have to do now let me run the
72:49 - game again
72:50 - is that we have to place the score in a
72:53 - nicer position because i don't want it
72:54 - to be this random number in the top
72:56 - left of the screen and we could approach
72:59 - this topic in a couple of different ways
73:02 - one way would be to use control notes
73:04 - and this would be a perfectly valid way
73:06 - but i'm not going to use it instead i'm
73:08 - going to write some code to place the
73:10 - text in the bottom right
73:11 - for the simple reason that the game is
73:13 - really simple and static so we don't
73:15 - really need any kind of fancy setup
73:17 - so let's have a look at this so i go
73:19 - back to my score scene
73:20 - and the first thing i want to do is to
73:23 - add another sprite
73:25 - and this is going to be the apple
73:27 - because i want to have an apple next to
73:28 - my score
73:30 - so in graphics i'm going to drag my
73:32 - apple as a texture in there so now we
73:34 - have an apple
73:35 - and the text and let me rename the
73:38 - sprite
73:39 - to apple and now i have to set up the
73:42 - entire thing in code
73:44 - and the first thing i need is the actual
73:46 - screen dimensions
73:48 - so i need to know how large the window
73:49 - is to place something in the bottom
73:51 - right
73:52 - and for that when the scene is ready
73:55 - i want to create a new variable that i
73:57 - have called screen
73:59 - size and to get the screen size
74:02 - or more specifically the viewport size i
74:05 - need get
74:06 - viewport dot size
74:10 - and this is going to give us a vector
74:12 - that shows the x and the y dimensions of
74:14 - our viewport
74:15 - and now once our entire scene is ready
74:20 - i want to use that information to place
74:22 - the apple and to score
74:24 - and let's start with the apple i think
74:26 - that's a bit easier to illustrate
74:28 - so i want to get my apple and i want to
74:30 - set the position
74:32 - and for the position i'm going to need a
74:34 - vector 2
74:36 - and in here i need an x and a y position
74:39 - and i have both of them it's just the
74:41 - screen size
74:43 - dot x and screen size
74:47 - dot y but now if i run this entire scene
74:52 - we can see that we can't see the top
74:54 - left of the apple but the center of the
74:56 - apple is in the corner of the screen so
74:58 - this is no good
75:00 - so i have to move both of these a bit
75:02 - further to the left and a bit
75:03 - up and the numbers i have come up with
75:06 - are 60
75:07 - and 40. and now if i run the scene
75:12 - we can see the apple in the bottom right
75:14 - so this one looks quite nice
75:16 - and with that i want to get my score
75:19 - text
75:20 - and do the same thing to it with one
75:22 - difference that we couldn't just place
75:24 - the position of the text
75:26 - because this one is a control node so
75:28 - instead what we have to do
75:30 - is to get the rect position
75:34 - and once we have that we can do the same
75:36 - thing we have done to the upper position
75:38 - so this one also takes a vector 2 vector
75:41 - 2
75:43 - and i can literally just copy the entire
75:45 - coordinates for the apple
75:48 - and move them slightly further to the
75:50 - right so instead of
75:51 - 60 i go to -40 and then i also place the
75:55 - y position a bit further up so 50.
75:58 - and let's try this now and
76:01 - it's very hard to see because we have a
76:03 - gray background but you can see the zero
76:05 - there very
76:06 - faintly but if i go back to my main game
76:09 - scene
76:09 - and let me actually set up a main scene
76:12 - so
76:13 - main game if i run this you can see it
76:16 - much better
76:17 - and the score also still works so
76:21 - this is all coming together quite nicely
76:23 - the only problem now
76:25 - is that i think there should be some
76:26 - kind of background behind the score
76:29 - because just having the apple and this
76:31 - text on the screen
76:32 - well it looks a bit weird so what i want
76:35 - to do is to draw on the screen
76:36 - and this fortunately we can do very
76:38 - easily all i need is the funk
76:41 - underscore draw method and in here
76:44 - we can draw a method that is called draw
76:47 - rect
76:48 - and this one is going to need two
76:49 - arguments at the minimum
76:51 - the first one is a rect to d and the
76:53 - second one is a color
76:55 - so what i'm going to do is i'm going to
76:57 - create a bg rect
76:58 - in just a second and to create color i
77:01 - just have to write color and here we
77:03 - have three different options
77:05 - we have just color we have color 8 which
77:07 - stands for color 8 bit
77:09 - and then we have color n which stands
77:11 - for color name
77:13 - i want to go with color 8. and in here
77:16 - we have to pass in three numbers the
77:18 - amount of red the amount of green and
77:20 - the amount of blue
77:21 - and for each of those we have to get a
77:23 - number between 0 and 255
77:26 - with 0 being the absence of the color
77:28 - and 255 being the full amount of the
77:30 - color
77:31 - so for example for red i want 166
77:36 - which is a bit more than 50 percent of
77:38 - red
77:39 - then i want 209 for green and i want
77:43 - blue so for this color
77:46 - we have a lot of green a bit less red
77:49 - and very little blue
77:51 - so this would cover the color itself but
77:53 - now we have to create the actual
77:55 - rectangle we want to draw
77:57 - so i want to create var bg
78:01 - rect and this has to be
78:04 - erect 2 and for this rect2d
78:08 - we either have to pass in two vector 2ds
78:11 - one vector2d for the position and one
78:13 - vector to d for the size
78:15 - or we just pass in four different
78:16 - numbers that are for x
78:18 - y width and height i'm going to go with
78:20 - the second approach because i have used
78:22 - way too many vectors in the last hour
78:24 - so let's work through them the first one
78:27 - is the x position
78:28 - and i have the x position for now it's
78:30 - just apple dot
78:32 - position dot x this isn't going to be
78:35 - perfect but for now it is good enough
78:38 - next up i want the y position and this
78:40 - is also going to be the apple
78:42 - dot position except now it's going to be
78:44 - y
78:46 - and now i need the width and the height
78:48 - or the width at least for now i'm just
78:50 - going to go with 100
78:52 - and for the height since i know that the
78:54 - apple is 40 pixels high
78:56 - i am just going to go with 40. and
78:59 - now if i run this entire game
79:03 - um well it is there but it is very hard
79:06 - to see
79:06 - so let me close this game and let me
79:09 - just open the scene by itself
79:12 - ah so this is much easier to see
79:15 - so now we can see that we have placed
79:18 - the top left of this rectangle
79:20 - in the center of our apple so it's a
79:22 - start but it's not perfect
79:24 - let's fix it since i know that the apple
79:27 - is 40 pixels wide and 40 pixels high
79:29 - all i have to do is to subtract 20 from
79:32 - the x
79:33 - and the y position and
79:36 - with that we should already have a much
79:38 - better rectangle
79:40 - nice so this one is looking quite a bit
79:41 - better already
79:43 - but now the problem is for the width i
79:46 - don't want a generic number
79:47 - instead i want to combine the width of
79:49 - the apple and the width of the text
79:52 - and let me put this into its own
79:54 - variable just so it's a bit clearer
79:56 - so let's call this var score
80:00 - with and how i am going to get this
80:03 - is i'm going to get my apple i'm going
80:06 - to go with get
80:08 - rekt which is going to give us a
80:10 - rectangle of the outlines of the apple
80:12 - and of this rectangle i want the size
80:15 - and this is going to give us a vector
80:17 - with the x and the y dimension
80:19 - and of that i only want the x one
80:22 - so this entire line is going to give us
80:26 - 40 because i already know that my apple
80:28 - is 40 pixels high and 40 pixels wide
80:31 - and towards that i want to get my score
80:33 - text and do the same thing
80:35 - so get rekt
80:38 - then i want the size and then i want the
80:41 - x value of the size
80:44 - and that's all i needed so now i can
80:46 - type in score
80:48 - with and let's try the entire thing now
80:52 - so now something weird that this entire
80:54 - rectangle is
80:55 - too wide but all we have to do to fix it
80:58 - is to subtract a few pixels from this
81:00 - rectangle
81:02 - in my case i went with 16 and let me
81:05 - actually add it all the way up here
81:07 - so minus 16 and now if i run it
81:11 - now we get a proper rectangle and i
81:13 - really don't know why godot makes this
81:15 - much longer than it's supposed to be
81:17 - it might be a problem with the font i
81:19 - really can't tell
81:20 - if you know let me know in the comments
81:24 - but okay now we have a proper rectangle
81:26 - that we can work with
81:28 - and what we can also do is if i copy
81:32 - the entire rectangle i can add one more
81:35 - argument
81:37 - for false and this argument here is the
81:40 - fill argument and by default it's
81:42 - true so since we didn't pass anything in
81:45 - here this is true
81:46 - and if this one is true godot is filling
81:48 - the rectangle
81:50 - however if this one is set to false
81:52 - godot is only drawing a frame around the
81:54 - rectangle
81:56 - so let me illustrate this by just adding
81:58 - 0
81:59 - and 0 and 0 in here so now we should be
82:02 - drawing a black frame around the
82:04 - rectangle
82:05 - and let's try this and there we go it's
82:08 - a little bit hard to see
82:09 - let me run the actual game this is much
82:12 - better to see
82:13 - so now we have a black rectangle around
82:14 - the score that makes it much easier to
82:16 - see
82:18 - and all of this is coming together quite
82:20 - well
82:21 - nice but now for the color i want to use
82:26 - 56 for red
82:30 - i want to use 74 for green and i want to
82:33 - use 12 for blue
82:34 - and this is going to be the exact same
82:36 - color as our text
82:38 - so now if i run out of this this is
82:40 - starting to look a bit nicer
82:42 - cool so now we have our score
82:47 - and all of this is working really well
82:50 - so
82:51 - all is good and with that covered we can
82:53 - finish the game by adding a sound and
82:55 - fixing some minor bugs
82:57 - and let's start with the sound that is
82:59 - the super easy part
83:01 - so here i'm back in my main game scene
83:03 - and all i have to do
83:04 - is to add a new node that is going to be
83:07 - an
83:08 - audio stream player and i have called
83:11 - this
83:11 - crunch sound
83:15 - and into this i am adding my crunch
83:18 - sound
83:20 - and now we have a sound we can work with
83:23 - and really all i have to do is if my
83:25 - apple is eaten
83:27 - i am also going to call this so
83:30 - i just target my crunch sound and click
83:33 - on play so let's try this one now
83:40 - and i can hear a crunch sound so
83:43 - that is the really easy part cool
83:47 - and right now there's one possible bug
83:50 - that can be quite annoying
83:52 - since we're placing the apple randomly
83:54 - on the screen there's a small chance
83:56 - that the apple lands exactly on the body
83:58 - of the snake
83:59 - which well i don't want but fortunately
84:02 - this is very easily fixed
84:03 - all we have to do in our process
84:05 - function is when the apple is
84:07 - overlapping with the body of the snake
84:09 - then we want to reposition the apple and
84:12 - once we have that
84:13 - we have finished the game so let's jump
84:15 - right in and finish the game
84:17 - alright so here we are back in the
84:19 - editor and i want to go back to my code
84:22 - and move all the way to the bottom to my
84:23 - process function
84:26 - and in here all i have to do is check if
84:29 - my
84:30 - apple pause in
84:34 - snake body and if that is the case
84:37 - i want to get my apple pause
84:40 - and place it in another random position
84:43 - which we
84:44 - already can do with the place apple
84:46 - function
84:47 - and well that is literally it this is
84:50 - all we have to do
84:52 - so now whenever we are running
84:56 - let me find it whenever running check
84:57 - apple eaten
85:00 - and replace the apple then
85:03 - we also check if the apple lands
85:06 - somewhere on the snake
85:07 - and if that is the case we want to
85:08 - reposition the apple
85:10 - and we want to do this immediately so it
85:12 - has to be in the process function
85:14 - and now let me run the game to see if it
85:17 - still works
85:18 - and this still seems fine we can also
85:20 - eat the apple
85:22 - and well that's it so this should be a
85:26 - fairly decent slate game so i hope you
85:29 - enjoyed this and i will see you around