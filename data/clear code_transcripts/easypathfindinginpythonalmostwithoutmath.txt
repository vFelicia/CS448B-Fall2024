00:00 - hello there in this tutorial we are
00:02 - going to create this basic pathfinding
00:04 - project where we can move around a
00:06 - roomba in a room and well the roomba
00:08 - always finds the shortest path between
00:10 - the two points it's ultimately a fairly
00:13 - simple project that is quite useful for
00:15 - basically any kind of game
00:17 - now pathfinding does involve quite a bit
00:20 - of math and it can get fairly
00:21 - complicated however you don't actually
00:24 - have to do it yourself because python
00:26 - has a module dedicated entirely to path
00:28 - binding
00:29 - so we are going to use that and
00:31 - essentially we are going to create two
00:33 - projects the first one will introduce
00:35 - the pathfinding module itself and this
00:38 - one will be fairly short because it's a
00:40 - pretty simple module
00:42 - and for the second part we will use the
00:43 - pathfinding module to create an actual
00:45 - useful project now before we get into
00:47 - the code i think it is going to be
00:49 - useful to cover some basic pathfinding
00:51 - theory and don't worry it's going to be
00:54 - short
00:54 - whenever we talk about pathfinding we
00:57 - basically talk about two things
01:00 - number one we have a grid of points and
01:02 - some of these points can be walked over
01:04 - and some cannot
01:06 - for example a grid could look like this
01:09 - where a one is a movable field and the
01:11 - zero is a wall
01:12 - and inside of this grid we also define a
01:15 - start and the target cell and between
01:17 - those two points we are trying to find
01:19 - the shortest path
01:21 - now finding that shortest path is the
01:23 - second part and this is also the
01:25 - actually difficult part because finding
01:27 - this shortest path requires quite a bit
01:30 - of math
01:31 - as a matter of fact there are quite a
01:33 - few different mathematical approaches to
01:35 - figure this path out the most famous
01:38 - mathematical model to achieve this is
01:39 - called a star but there are quite a few
01:42 - more and if you want to get into the
01:44 - math it can really get quite complex
01:49 - but with that we can get started with
01:51 - the pathfinding module and first of all
01:54 - we have to install it and this is going
01:56 - to happen in the usual way
01:58 - so either in the terminal or on the
01:59 - powershell type pip install pathfinding
02:02 - and you should be good to go
02:04 - and with that we can create a really
02:06 - simple pathfinding project and just for
02:09 - reference i have taken this project from
02:11 - the official tutorial of the module i'll
02:13 - put a link to it in the description
02:16 - and here i have a completely empty sheet
02:19 - of code and first of all i have to
02:21 - import a couple of things so let's start
02:24 - by
02:25 - import path
02:27 - find ding
02:28 - and if i run the code now
02:30 - i can see finished and we are not
02:32 - getting an error message so i know that
02:35 - this module here is installed and
02:38 - everything is good if you get an error
02:40 - message here something did go wrong so
02:42 - do check that however for this module we
02:45 - don't actually want to import everything
02:47 - so let's change this a tiny bit for now
02:50 - from pathfinding i want to import a very
02:53 - specific thing and what i want to import
02:55 - is pathfinding dot core dot grid
03:00 - and from this i want to import the class
03:03 - called grid
03:05 - and do make sure here that the first
03:07 - letter has to be capitalized that is
03:09 - quite important
03:10 - and this class is going to be well
03:13 - creating our grid so
03:15 - let's use this right away
03:17 - and for this grid we actually need some
03:20 - kind of map and in my case i have
03:23 - created one already that i called a
03:25 - matrix it looks like this
03:27 - now every time we have a one in this
03:29 - field
03:30 - we can move over the cell but we cannot
03:33 - move over a zero
03:34 - and later on we are going to have a much
03:36 - more complex map for now this is just
03:39 - for illustration and now that we have
03:41 - that
03:42 - we have to actually create a grid and
03:44 - let me actually create a comment here to
03:46 - illustrate this so create a grid and
03:49 - this grid is going to be stored in a
03:51 - variable that i'm going to call grid and
03:53 - for this we are going to use the grid
03:56 - class so the one we have literally just
04:00 - imported this one here
04:02 - and this grid is going to need one named
04:04 - argument and this is called the matrix
04:06 - parameter
04:08 - and in our case we already have a matrix
04:10 - i just called it matrix
04:12 - so literally all we're doing is we're
04:14 - importing this one here as a named
04:15 - argument for the parameter that is also
04:18 - called matrix
04:19 - now that we have that
04:21 - we have to define a start and an end
04:23 - cell so number two
04:25 - create is start and end
04:29 - cell
04:30 - and this also is going to be stored in a
04:32 - variable so i want a start cell and i
04:35 - want an end cell
04:37 - and in here we have to make a choice
04:39 - because essentially
04:41 - we have to pick one of these cells
04:44 - and well define a start point and we can
04:46 - literally pick any cell that we can walk
04:48 - on so we couldn't pick this one here but
04:51 - we could pick literally any other cell
04:53 - and how you create this is we first have
04:56 - to get our grid again so the one we have
04:58 - just created
05:00 - and on this we have to create a node
05:04 - and in this node we have to define an x
05:07 - and a y cell and in my case let's just
05:10 - go with 0 and 0. so
05:14 - right now
05:15 - this 0 and 0 here
05:18 - would be
05:20 - the top
05:21 - left cell
05:22 - in our grid and then for the n cell
05:26 - let's do the same thing except now i
05:28 - want to get a different cell let's say
05:30 - in my case i want five and two and i
05:33 - guess just to be clear here this five is
05:36 - going to be 0 1 2
05:39 - 3
05:40 - 4 and 5. so we are on this column here
05:45 - and then this 2
05:47 - is going to be
05:49 - 0 1 and two so we're essentially
05:52 - targeting the bottom right cell
05:55 - and that is literally all we need for
05:57 - now now that we have that
06:00 - we can go to the next step that's going
06:02 - to be number three and this is going to
06:04 - be to create a finder with a movement
06:09 - style
06:10 - now a finder basically is the
06:12 - mathematical model that gets us from
06:14 - here all the way to here
06:16 - and this is another thing we have to
06:18 - import so
06:20 - all the way at the top from pathfinding
06:26 - dot finder dot in my case a star
06:30 - i want to import the a
06:33 - star
06:34 - binder
06:35 - and
06:36 - for this class here be really careful
06:39 - with the naming and the capital letters
06:41 - it can be quite finicky but this finder
06:44 - is going to use the specific
06:45 - mathematical model that is called a star
06:48 - so this is one kind of math to get us
06:49 - from point a to point b
06:51 - and there are quite a few more if you
06:54 - check the documentation you can find all
06:55 - the relevant ones
06:57 - and now that we have that
06:59 - we can create what is called a finder
07:02 - and this one also has to be stored in a
07:03 - variable
07:04 - and this is then going to be an instance
07:07 - of the class
07:09 - and that is all we needed we are almost
07:13 - there next up
07:14 - let's call this number four we have to
07:17 - use the finder to find the path
07:21 - all we have to do is getting our finder
07:24 - and then calling the method find
07:26 - underscore path
07:28 - and in here we have to pass in three
07:30 - different arguments the start cell the
07:33 - end cell
07:34 - and the grid
07:36 - so that is all information we already
07:39 - have defined early on
07:42 - it really isn't all that bad once you
07:44 - get the hang of it so i hope that makes
07:46 - sense and now this method here is going
07:50 - to return two things
07:52 - and let's stop both in the variable
07:54 - first of all it's going to return the
07:56 - path
07:57 - and second up is going to return what is
07:59 - called the runs
08:00 - and runs basically means how many cycles
08:03 - or how many cells we have to go through
08:05 - to get to the end of the path
08:07 - can be sometimes useful but in most
08:09 - cases you don't really need it and well
08:13 - with that we have our path so what we
08:15 - can do now is to print the result so
08:19 - let's print
08:20 - our path
08:21 - and if we run the code now
08:24 - we can see
08:25 - a couple of two builds
08:27 - and let's actually go through and see
08:29 - what happens here
08:31 - in our grid
08:32 - we start in cell zero and zero that is
08:35 - this point here
08:37 - then we go one further to the right so
08:39 - we get to this point here that is this
08:41 - one covered then we go to two and zero
08:44 - so that's this one then we go to three
08:46 - and zero that's this one then we go to
08:49 - four and zero this one then five and
08:51 - zero that's this one and then we go
08:54 - downwards so five and one and then five
08:56 - and two and that's the last two cells
09:00 - and that is well
09:01 - the shortest path we could possibly take
09:04 - or i guess at least one of the shortest
09:05 - paths there are couple possible shortest
09:07 - ones in here
09:09 - so let me minimize this again
09:12 - and i guess just for completion
09:15 - what we could also print is runs
09:18 - and this would get us 17. so this finder
09:23 - ran through this matrix 17 times to find
09:26 - this path here
09:28 - it's well not the most relevant
09:30 - information it really doesn't concern us
09:33 - too much
09:34 - although
09:35 - it does tell you one relevant thing and
09:38 - that is that pathfinding is really
09:41 - hardware intensive so what you want to
09:43 - be aware of is that you should be using
09:46 - pathfinding as little as possible
09:48 - because if you use it too much it is
09:50 - going to tank the performance of your
09:52 - game quite substantially so keep that in
09:55 - mind i will talk about it more in the
09:57 - actual project
09:58 - with that we have some very basic
10:00 - pathfinding now there's one more thing
10:02 - that we could be adding because right
10:05 - now
10:06 - we don't have diagonal movement so all
10:09 - we can do in this a-star finder is move
10:12 - right left
10:13 - up and down
10:15 - which in the game sometimes isn't
10:16 - particularly realistic because you might
10:19 - also be able to move to the top right or
10:21 - bottom left and so on so how could we
10:24 - add these different directions
10:26 - and well adding this is kind of
10:29 - cumbersome although not too difficult
10:32 - it is mostly a writing thing
10:34 - essentially in this asta finder class
10:37 - we have to add one argument and that is
10:40 - called diagonal underscore
10:43 - movement
10:44 - now the problem is the argument we have
10:47 - to pass into here has to be another
10:49 - class that we also have to import from
10:51 - the pathfinding module it is called from
10:54 - pathfinding
10:56 - dot core
10:57 - dot diagonal
10:59 - movement from this we want to import
11:02 - diagonal
11:04 - movement
11:05 - and now what we want to do
11:07 - we can pass in this class in here so
11:10 - diagonal movement and then dot
11:13 - all ways
11:15 - so we always want to allow diagonal
11:17 - movement
11:18 - and well that is now all we needed
11:20 - although this part here i do find a
11:22 - little bit cumbersome but it's not too
11:24 - bad i suppose but now i've run all of
11:26 - this again we are getting a slightly
11:29 - different path so we start with zero and
11:32 - zero one and zero
11:34 - two and zero three and zero but now we
11:37 - go to four and one and five and two
11:41 - so this is essentially our path
11:46 - and i guess this one is slightly faster
11:48 - than the one we had before
11:50 - and well now we have diagonal movement
11:53 - it wasn't actually all that bad
11:54 - so that's a pretty good sign
11:57 - and well with that we have our basic
12:00 - project so now all you have to do is to
12:03 - implement all of this in some kind of
12:05 - project wherever you want to have it in
12:07 - my case it's going to be pie game but it
12:10 - could literally be anything else so i
12:11 - guess with that let's start talking
12:14 - about the actual project that is going
12:16 - to look much more interesting
12:18 - now for this project i try to make it as
12:21 - simple as possible so we can focus on
12:23 - the pathfinding part and this is most
12:26 - notable in how the level is set up or
12:28 - the room you can see right now
12:30 - essentially this entire room is just one
12:32 - picture
12:33 - and this picture is composed of
12:35 - individual tiles with each tile being 32
12:38 - by 32 pixels wide and high and then for
12:41 - the grid i essentially played around and
12:43 - placed zero wherever we have a tile with
12:46 - a wall and one wherever we have a tile
12:48 - with a floor
12:50 - but by themselves the grid and the
12:51 - background art are completely separate
12:54 - they just happen to look the same now
12:56 - this makes the project quite inflexible
12:59 - although in a real project you could set
13:02 - this up significantly better if you want
13:04 - to understand how to set something like
13:06 - this up check out my tileset video it
13:08 - explains all of this in much more detail
13:10 - but in this case i try to keep this
13:12 - project as simple as possible but all
13:14 - the other parts are perfectly functional
13:16 - path finding so you could use them in
13:19 - essentially any kind of game
13:21 - now one more thing before we get into
13:23 - the actual code and that is our folder
13:25 - setup right now i have one folder with
13:28 - the code and all of the artwork which
13:30 - essentially means i have one python file
13:32 - then the background image then a roomba
13:35 - image and then one more image for the
13:37 - selection box thing i'm not really sure
13:39 - how to call it but with that we have all
13:42 - we need so let's jump straight into our
13:45 - actual project
13:46 - and it is going to look like this i
13:48 - already have a very basic setup so
13:51 - essentially what i have in here is a
13:53 - basic input of pygame then the basic pie
13:56 - game setup then our game loop and i'm
13:59 - simply drawing and updating all the
14:01 - stuff that we have if you have no idea
14:03 - what any of this means check out my
14:05 - introduction to pygame it is going to go
14:07 - over all of this in a great amount of
14:09 - detail and well besides that i have also
14:12 - already imported all the stuff we need
14:14 - for the path finding so this is the
14:16 - stuff you have just seen a couple of
14:18 - minutes ago
14:19 - so all right with that we can add a
14:22 - couple of things towards this and let me
14:24 - add another section here let's call it
14:26 - the game
14:27 - setup
14:28 - and then here we need two things first
14:30 - of all we need the background and i call
14:33 - this bg underscore surface and literally
14:36 - all we need for this one is pygame
14:38 - dot image
14:40 - dot load
14:42 - and
14:43 - i call this one map.png
14:47 - and as always
14:48 - don't forget to convert
14:51 - this thing so our game runs a little bit
14:53 - better and now all we have to do in our
14:56 - game loop
14:57 - i want to get my screen and bleed this
15:00 - background image so bg underscore serve
15:04 - and the top left should be in position 0
15:06 - and 0.
15:08 - so if i run all of this
15:10 - we can see our basic background image
15:14 - and this is literally just an image
15:15 - nothing fancy whatsoever
15:18 - so all right let's close this and with
15:21 - that
15:22 - we can start creating our grid for the
15:24 - pathfinding and for this grid again
15:27 - we are going to need a matrix
15:30 - this one is going to look
15:33 - quite a bit larger
15:36 - in fact it looks like
15:38 - this
15:40 - and well this thing is a little bit
15:43 - larger but if you look at this a tiny
15:46 - bit more closely
15:48 - for example
15:50 - here you can see
15:52 - the wall for the bathroom on the left
15:54 - side and here you can see the wall
15:58 - on the right side of the bathroom
16:00 - or if you look on top
16:03 - here you can see the kitchen table area
16:06 - that we can't move through
16:08 - here you can see one wall of the kitchen
16:11 - and i guess if you actually draw it out
16:14 - it does become a bit easier to see so
16:16 - here we have a pillar here we have
16:17 - another pillar and here we have another
16:20 - wall
16:21 - so this is essentially how the entire
16:23 - project is going to work
16:25 - i have a background art and on top of
16:27 - the background art i have an actual
16:29 - pathfinding grid and those two happen to
16:31 - have the same coordinates but that's the
16:33 - only connection they have i could
16:34 - totally change any of these points to
16:37 - get a different kind of pathfinding
16:38 - setup
16:39 - so i hope that makes sense
16:41 - but also this thing is getting quite
16:43 - wieldy so let me minimize it and then we
16:45 - don't have to worry about it
16:47 - and now with that we can actually start
16:51 - creating our basic pathfinding and i'm
16:54 - going to organize this in two classes
16:56 - and let's start with the first one that
16:59 - i have called path finder
17:02 - there's no inheritance but we are going
17:04 - to need an init method
17:06 - and for the unit method we need dunder
17:09 - init as always we need self and for this
17:12 - one i want to have a matrix
17:15 - and then inside of this let me add a
17:17 - comment for the basic setup and in here
17:20 - first of all i want to have myself dot
17:23 - matrix
17:24 - and just store the matrix by itself
17:28 - and that in a second is going to be just
17:31 - this matrix here that we are going to
17:33 - pass in there it is not going to be a
17:36 - grid yet so we are not creating the grid
17:39 - class
17:40 - and you're going to see in a second why
17:41 - this information is useful by itself
17:44 - it's essentially there to place the
17:46 - mouse cursor but don't worry too much
17:48 - about it for now
17:49 - now besides that i do also want to
17:52 - create the actual grid so self.grid is
17:55 - going to be the grid class and in here
17:58 - matrix is going to be the matrix
18:01 - now on top of that i also want to import
18:04 - another image for this class and let's
18:06 - call this one select
18:08 - surface
18:10 - and for this one all i want is
18:11 - pygame.image.load
18:14 - and this one is called
18:16 - selection.png
18:19 - and for this one we need convert alpha
18:22 - because it has some alpha values
18:24 - and this is literally just the selection
18:26 - image we need to display where the mouse
18:28 - cursor is
18:30 - and let's actually start by creating an
18:32 - instance of this class right in our game
18:34 - setup so in here i'm going to create a
18:37 - path finder and this is just pathfinder
18:41 - and the one argument we are going to
18:43 - pass in here is the matrix
18:45 - so this matrix up here that we just pass
18:48 - in there and nothing else
18:50 - so when we are going to run this code
18:53 - um everything runs but we can't see
18:55 - anything from the pathfinder yet because
18:57 - we are not using this class in any
18:59 - meaningful way but this is going to
19:02 - change now because i'm going to give
19:04 - this class an update method that needs
19:07 - self and nothing else
19:10 - and the first thing i want to do in here
19:12 - is to display where the mouse is so the
19:14 - player actually knows what cell is going
19:17 - to be selected
19:18 - and this let's call it self dot draw
19:22 - active cell
19:25 - so we have to create this method now so
19:28 - draw
19:29 - active
19:30 - cell
19:32 - we need self as usual but nothing else
19:35 - and now in here we have a problem
19:38 - that right now we have a mouse position
19:41 - so we can tell the x and the y
19:43 - coordinates of our mouse
19:45 - but this is not the information that we
19:47 - are going to need because the
19:48 - information we do want
19:51 - is the index for the row and for the
19:54 - column
19:55 - in which of these cells our mouse is
19:57 - going to be
19:59 - so for example if we are in the cell all
20:01 - the way up here
20:03 - i want to have the coordinates 0 and
20:05 - zero
20:06 - or if we are in the one right next to it
20:09 - this one should be zero and one so row
20:12 - zero and column one
20:14 - and this information
20:16 - we would have to get from a mouse
20:18 - position that could for example be
20:20 - 10
20:21 - and 35
20:24 - and i guess a better way to illustrate
20:26 - this let me actually do this straight in
20:27 - the game that might make more sense
20:30 - so for now i have my mouse position and
20:34 - i get my mouseposition with
20:35 - pygame.mouse.get
20:38 - underscore position
20:40 - and let's just print our mouse position
20:44 - and don't forget to actually call this
20:46 - update method in our game loop
20:49 - so
20:50 - path finder
20:52 - dot
20:54 - draw active cell for now
20:57 - and if i run this
20:58 - so now in the game you can see my mouse
21:00 - and if i move around you can see the
21:02 - position of the mouse cursor in our game
21:05 - and if i move all the way to the top
21:07 - left you can see at some point 0 and 0
21:11 - if i hit exactly the right pixel
21:14 - there we go
21:14 - now this position is useful but i do
21:17 - have to convert it because this top cell
21:19 - right now is going to be 0 and 0. but my
21:22 - mouse position is going to be something
21:24 - like 16 and 19 for example you can see
21:26 - it in the bottom left and this number i
21:28 - would have to convert to 0 and 0 because
21:30 - this is going to be one cell
21:32 - and then if a mouse is one field to the
21:34 - right it's going to be right now 50 and
21:36 - 14
21:38 - this would need to be 1 and 0. so we are
21:41 - in column 1 and row 0.
21:44 - and this has to be applicable to the
21:47 - entire field so we convert our mouse
21:49 - position to a position inside of a
21:51 - coordinate system specifically
21:54 - one field inside of this coordinate
21:56 - system and this fortunately isn't all
22:00 - that difficult
22:01 - so
22:03 - really all we have to do is we need to
22:05 - get a row
22:06 - and a column
22:08 - and this could be a really interesting
22:10 - exercise so try to figure this problem
22:12 - out yourself that you want to convert
22:15 - your mouse position with x and y that
22:17 - could be any number
22:18 - into a coordinate system with a tile
22:21 - size of 32 and 32
22:24 - so that for example 16 and 16 for x and
22:26 - y becomes 0 and 0 for the row and the
22:29 - column but something like 50 and 10 is
22:32 - going to be 1 and 0 for the row in the
22:34 - column
22:40 - and this really is the sort of thing
22:42 - that is really easy to overthink but
22:45 - solution is actually surprisingly easy
22:48 - so essentially
22:50 - this most position here is going to
22:52 - return an x and a y
22:55 - so for now i just want to get the row
22:58 - which is going to be 1 or our y position
23:02 - and what i want to do is to get the
23:04 - floor division and divide it by 32 with
23:07 - 32 being our tile size
23:10 - and let's actually do an example let's
23:12 - say for our mouse position
23:14 - we have the position 50
23:17 - and then we're going to apply the floor
23:19 - division and divide this by 32.
23:22 - now if we were to just divide this by 32
23:25 - we would get something like
23:27 - 1.56
23:29 - but since we are doing a floor division
23:31 - all our result is going to be is a 1. so
23:35 - all of this information is going to
23:36 - disappear and we are left with a one
23:39 - and then this one is actually all we are
23:42 - going to need so this is going to be our
23:45 - row then
23:46 - and if we use a different number let's
23:49 - say if we used 16
23:51 - and applied
23:53 - and at the floor division by 32 again
23:56 - this would get us to 0.5
23:59 - but again since we're doing a floor
24:01 - division anything after the period is
24:03 - going to disappear so this 0.5 is going
24:06 - to disappear and we are left with a zero
24:09 - so we know that at the position 16
24:12 - we are going to be on the row of zero so
24:15 - this is going to give us exactly the
24:17 - right coordinate point that we are going
24:19 - to need
24:20 - but now we can just copy all of this and
24:23 - apply the same thing to the column
24:25 - except now
24:26 - we need the x and not the y position and
24:29 - with that we have our row and our column
24:31 - so now we can use that information to
24:33 - create a rectangle with an x and a y
24:36 - position this is going to be pygame dot
24:39 - rect
24:40 - and in here we are going to need one
24:43 - tuple with the left and the top
24:46 - and then another tuple with the width
24:49 - and the height and the width and the
24:51 - height are both going to be very simple
24:53 - because they're both 32
24:55 - now the left and the top are slightly
24:57 - more complex well not that much to be
24:59 - honest
25:00 - so for the left i want to get my column
25:03 - and multiply this by 32
25:05 - and then for my top i want to get my row
25:08 - and multiply this by 32 and that way we
25:12 - are turning our coordinate system into a
25:14 - specific position on our map except this
25:17 - one is now going to be always in a
25:19 - specific position so it looks like we're
25:20 - following a grid and now what we can do
25:24 - we can get our screen surface
25:26 - and blit and we have our self dot select
25:30 - surface
25:31 - and we have our rectangle
25:33 - and now let's try to run all of this
25:36 - and now we have our selection
25:38 - thing
25:40 - so this green rectangle here is whatever
25:43 - cell we have selected and this right now
25:45 - is following the grid really nicely
25:48 - but there's one downside right now
25:51 - that this green cell is even displayed
25:53 - over a wall or
25:55 - one of these tiles that we are not
25:56 - supposed to move over
25:58 - and this i want to change
26:00 - i only want to run this code here
26:03 - if this information
26:05 - is on top of a cell that we can move
26:08 - over
26:09 - and i guess this could also be a pretty
26:10 - good exercise so try to figure out how
26:13 - to change all of this here
26:15 - to only display this code
26:18 - if we are in our matrix
26:20 - over a one
26:28 - the first thing we are going to need is
26:31 - the information in the matrix
26:33 - what cell we are on so if we are on a
26:36 - one or on a 0.
26:38 - and for that
26:39 - i'm going to create another variable
26:41 - that i call current cell
26:44 - value
26:45 - and this information we can get from the
26:47 - matrix we already have in our class
26:51 - and well literally all we need is
26:53 - self.matrix
26:55 - and in here we first need the index of
26:58 - the row
26:59 - and inside of that we need the index of
27:01 - the column
27:04 - so if i open the matrix again
27:08 - the row here is literally going to
27:10 - select by indexing
27:12 - which of
27:13 - these rows or well lists we are going to
27:16 - look at and then the column is going to
27:18 - look inside of each of those and see
27:21 - which
27:22 - number we're going to pick inside of
27:24 - this list so quite simple actually
27:27 - and well now
27:29 - all we have to do
27:30 - is
27:32 - if our current cell value
27:34 - is equal to one
27:35 - [Music]
27:36 - then we want to run
27:38 - those two lines
27:40 - and if that is not the case well we
27:42 - don't want to do anything
27:44 - and now if i run all of this
27:46 - i still can see my green rectangle but
27:48 - now if i go over wall it disappears
27:51 - and if i go again on the floor now it
27:54 - reappears so this way we have a
27:56 - selection box thing so the player can
27:59 - tell where we are supposed to move
28:01 - so this part
28:03 - wasn't actually so bad
28:05 - cool so now i can minimize this method
28:08 - here and not worry about it again and
28:11 - now with that we can actually start
28:13 - talking about the pathfinding itself
28:17 - and this is going to involve a couple
28:19 - more steps
28:21 - but in the most basic sense here's what
28:23 - we are going to do in our pathfinder
28:26 - class
28:27 - we are going to add some functionality
28:29 - with the pathfinding module to find the
28:31 - start position and an end position
28:34 - and then we are going to have one
28:35 - attribute where we are going to store
28:36 - that information
28:38 - now on top of that
28:39 - we are going to create a whole other
28:41 - class called roomba
28:43 - and this room bar essentially is going
28:45 - to look at the pathfinder class and see
28:48 - if there's any path information
28:50 - and as soon as there's a path
28:52 - information it is going to follow that
28:54 - path
28:55 - now how that pathfinding is going to
28:57 - work specifically we are going to look
28:58 - at in a second let's do this step by
29:01 - step so for now let's work the
29:03 - pathfinding into this actual project and
29:05 - then we can work on the actual movement
29:07 - of the character or well the roomba
29:09 - so here we are back in the code and the
29:12 - first thing i want to do is in our init
29:14 - method i want to add another section for
29:17 - the path finding
29:19 - and in here i'm going to create another
29:21 - attribute that is just going to be path
29:23 - and this is going to be an empty list
29:25 - and now
29:26 - inside of this class i'm going to define
29:29 - another method that i'm going to call
29:32 - create path
29:34 - and this needs self and nothing else
29:38 - and in here
29:39 - we need to get
29:40 - three major things we first need start
29:43 - cell
29:44 - then we are going to need an n cell
29:47 - and then we need to get our path from
29:49 - all of this
29:50 - and i guess
29:52 - let's go for them one by one
29:55 - now first of all
29:56 - i want to get a start x
29:59 - and a start
30:01 - y
30:02 - cell
30:03 - and in a bit once we have our roomba
30:06 - we are going to give the roomba a method
30:08 - to do all of this
30:10 - but for now i'm just going to go with
30:11 - one and one so the top left of our
30:14 - movable cells
30:15 - but later on this one is going to become
30:18 - much more flexible and once we have that
30:21 - i want to get my actual start
30:23 - node so this is going to be self
30:26 - dot grid
30:28 - dot node
30:29 - and in here i want to pass in my start x
30:32 - and my start y
30:35 - so this is
30:36 - the exact same thing we have done
30:38 - earlier to get the start position
30:40 - and now for the end position we want to
30:43 - find our mouse position again and to
30:46 - achieve that i can just copy these lines
30:48 - of code again
30:50 - and minimize this part
30:52 - and now we have the cell we are
30:55 - currently selecting with our mouse
30:57 - and i guess for consistency let's call
31:00 - this and
31:01 - underscore y
31:02 - and and
31:05 - underscore x and let's move them after
31:08 - each other
31:09 - and this way it's going to be a little
31:10 - bit clearer to read
31:12 - although one part annoys me a little bit
31:14 - right now that i just want to move them
31:17 - around
31:19 - so that end x comes first and end y
31:22 - comes second and all right with that we
31:25 - have an end x and an end y
31:27 - so
31:28 - now we have that
31:29 - we can create a proper endnote so self
31:32 - dot grid dot node again
31:35 - and this time again and
31:37 - x and and
31:39 - y
31:40 - and now we have start and we have an end
31:44 - so now with that
31:46 - we can create the actual path and this
31:49 - part i would really recommend for you to
31:51 - try yourself
31:53 - so open the previous project again and
31:56 - try to implement this kind of thing
31:58 - yourself that you create a finder and
32:01 - from this finder you create a path that
32:03 - you are just going to print for now
32:10 - all right so first of all we have to
32:13 - create a finder
32:14 - and this finder is going to be an a star
32:17 - finder and in here i want to get my
32:20 - diagonal movement
32:22 - to be a diagonal movement dot always
32:27 - so this way our roomba can move in the
32:29 - diagonal direction
32:31 - now once we have that information i want
32:33 - to run finder
32:35 - dot find underscore path
32:38 - and in here i have my start i have my
32:40 - end and i have my grid
32:44 - and grid is self dot grid
32:47 - and all of this is essentially what we
32:50 - have done in the first simplified
32:52 - project except now we are actually using
32:54 - it in a real project
32:56 - now this finder here
32:58 - is going to return the path and the runs
33:00 - and in my case i only really care about
33:02 - the path and i want to set this path as
33:05 - self dot path
33:08 - and then for the runs i'm just going to
33:10 - use an underscore to indicate that i
33:12 - don't really care what happens to this
33:13 - information
33:15 - but essentially whatever is going to be
33:17 - returned by this method here
33:19 - is going to be stored in this self.path
33:23 - and now what we can do
33:26 - is print our self dot path
33:30 - except now we kind of have a problem
33:33 - because we have a method
33:35 - but we don't really know when to run it
33:39 - and there's a massive thing you
33:41 - absolutely have to avoid because
33:43 - technically you could run self.create
33:47 - path in here and if we were to do that
33:50 - we would get a new path on every frame
33:52 - of our game and right now
33:55 - we have 60 frames in our game
33:58 - the problem is
33:59 - this kind of pathfinding is really
34:01 - hardware intensive so if we actually
34:04 - tried this our frame rate would drop
34:06 - down really really hard
34:09 - basically no computer can run
34:10 - pathfinding this often
34:12 - so instead let's not do that and a much
34:16 - better idea is that every time we click
34:18 - a mouse button we are going to run this
34:21 - method and to do that
34:23 - we are going to look at this for loop
34:25 - here
34:26 - and really what i want to do is if
34:30 - the event dot type
34:32 - is equal to
34:34 - pygame dot
34:36 - mouse button down
34:39 - then i want to get my path finder
34:41 - and run my create path
34:44 - so this way we are only going to create
34:47 - a path whenever the player clicks a
34:49 - button
34:50 - which is much more reasonable and much
34:51 - more efficient and i guess with that we
34:54 - are not going to use this for loop
34:56 - anymore so i can minimize it
34:58 - and now in this code
35:00 - let's try it and if i click anywhere we
35:03 - are getting a path
35:05 - so we know the pathfinding is working
35:08 - just fine the problem now if i click
35:10 - again
35:12 - we just get well
35:14 - an empty list
35:17 - essentially once we are running all of
35:19 - this
35:20 - our start node is going to be in the
35:23 - same position as our endnote so by
35:25 - default pathfinding doesn't really care
35:28 - what we define in here once we have run
35:31 - this line
35:33 - we always set the end and the start
35:35 - position
35:37 - and this way we can run this path
35:38 - finding once however if we try to run it
35:41 - a second time it's going to return an
35:43 - empty list because our start node and
35:45 - our endnote are in the same position so
35:48 - that's not helpful but fortunately we
35:50 - can change that behavior all we have to
35:53 - do is self dot grid dot clean up
35:57 - and that way all of this is going to be
36:00 - reset at the end of the path
36:02 - and once we have that we're going to
36:04 - recalculate this position
36:06 - and this position here
36:08 - so now let me print
36:12 - self.path
36:13 - again
36:14 - and now let's run all of this
36:16 - so now if i click right next to our
36:18 - start position
36:20 - we go from 1 1 to 1 and then 3 2. so
36:23 - this is our path right now but if i
36:25 - click all the way down here
36:27 - we are getting a very very long path but
36:31 - well we always get a new path no matter
36:33 - where we click
36:34 - so this is working really well
36:37 - however i guess just printing the path
36:39 - looks kind of boring so let's draw the
36:42 - entire thing and for this i'm going to
36:45 - create another method that i'm going to
36:47 - call draw path
36:49 - it needs self add nothing else
36:52 - and now in here i first want to check if
36:56 - self.path has anything in there so if
36:59 - self.path is empty this if statement is
37:01 - not going to run
37:03 - but if it is going to run
37:05 - i want to create another list with
37:08 - points
37:09 - and essentially what we have to do is
37:13 - call pygame.draw.lines
37:17 - and in here we have to pass in a couple
37:19 - of arguments
37:20 - first of all we need to display surface
37:23 - then we need a color and in my case the
37:26 - color i have chosen
37:28 - as the code of this
37:31 - although you could literally choose
37:33 - whatever color you want in here it well
37:35 - doesn't really matter
37:37 - now next up
37:38 - we want to tell if all of the lines we
37:40 - are drawing are going to be closed or
37:43 - open so this is a boolean statement in
37:45 - my case i want this to be open so we
37:48 - don't connect the first and the last
37:49 - point
37:51 - now next up
37:52 - we are going to need points so all the
37:54 - points we are going to create in just a
37:56 - second
37:58 - and then finally we are going to need a
38:00 - line width which in my case is 5 but
38:03 - well choose whatever number you want it
38:05 - really doesn't matter
38:07 - and all that this method here is going
38:09 - to do it is going to draw a couple of
38:11 - lines between all the points we are
38:13 - going to pass in here
38:14 - and these points have to be in here
38:17 - and now
38:18 - we kind of have a problem again because
38:21 - all the points in the path so this path
38:24 - here
38:25 - are going to be something like 0 and 0
38:27 - or 1 and 1 or something like 20 and 10
38:31 - but for these points we want actual x
38:34 - and y positions
38:36 - so we kind of have to do the opposite of
38:38 - what we did earlier but we converted the
38:40 - mouse position into a grid now we have
38:42 - to convert a grid to actual positions
38:46 - and this is going to be a for loop so
38:48 - four point in self dot path so i want to
38:52 - go through all the points in this path
38:55 - and inside of this i want to create an x
38:58 - and a y position and first of all
39:01 - i want to get point
39:03 - zero so in our self.path this would be
39:06 - the column
39:07 - and to convert this from a grid back to
39:11 - an actual position i just want to
39:12 - multiply this by 32
39:16 - and then i could do the very same thing
39:18 - for y except now this has to be a one
39:22 - and this is going to work for now
39:24 - although we do want to make a change in
39:26 - just a second but now literally all i
39:29 - want to do is to get my points variable
39:32 - and append
39:34 - x and y
39:36 - and this has to be appended as a tuple
39:40 - and now once we have that i can call
39:42 - this method so self.draw path
39:45 - and let's see what happens
39:47 - we can see that nothing is working
39:51 - so let's check in our loop ah and the
39:54 - mistake i made here is that draw active
39:56 - cell it should be update instead so
39:59 - we're calling all of this not just the
40:01 - active cell
40:03 - so
40:04 - now let's try this again
40:06 - so now if i click now we're getting a
40:08 - path and if i click again we are getting
40:11 - a different path
40:12 - and all the way in the bottom right now
40:14 - we keep on getting working paths
40:17 - so this is
40:19 - kind of working not all that bad
40:22 - the problem we have now is that our path
40:25 - always goes to the top left of our cell
40:27 - which looks a bit strange
40:30 - so instead i want to move the points of
40:33 - this path to the center of each of the
40:36 - tiles and not to the top left and this
40:38 - is also quite easily done
40:41 - so back in my draw path all i really
40:43 - have to do
40:44 - is to put both of these
40:46 - into brackets
40:48 - and then add plus 16. so plus half the
40:52 - size
40:54 - of each of the tiles
40:56 - another one is again this is going to
40:58 - look much better so i hope you can see
41:00 - the difference this is
41:02 - now our path always ends in the center
41:05 - of the tile not in the top left
41:07 - but everything else works just fine
41:10 - and this way we also don't overlap with
41:12 - the walls so this is looking pretty good
41:16 - so this is then already some pretty good
41:20 - working path finding that works very
41:23 - reliable
41:24 - and there's one additional thing i have
41:26 - been drawing and it is right now
41:27 - whenever we have a corner it looks a
41:29 - little bit ugly because the draw lines
41:33 - feature in pie game just doesn't look
41:35 - very good so i essentially just drew a
41:38 - circle on top of each of the corner to
41:40 - make it look a bit more rounded
41:42 - and this happens with pygame dot draw
41:45 - dot
41:46 - circle
41:47 - and make sure it's inside of this for
41:49 - loop
41:50 - and in here we are going to need the
41:52 - screen again so our display surface
41:55 - besides that i want to have the same
41:58 - color and then besides that i need an x
42:01 - and a y position and fortunately those
42:04 - two i already have so they are very easy
42:07 - to get and now finally i need a radius
42:10 - which in my case is two and let me get
42:13 - rid of this comma here and now let's run
42:15 - this it's going to be very difficult to
42:16 - see
42:17 - but maybe you can tell very slightly
42:19 - that now the corners look a bit more
42:21 - rounded i guess
42:23 - let me exaggerate this a touch
42:25 - so now now you can see what's going to
42:28 - happen
42:29 - and essentially if we turn the circle
42:31 - radius a bit down
42:34 - okay that might even be too large
42:36 - two i think is just enough so this way
42:40 - it looks a bit
42:41 - let's say a tiny bit more rounded it's
42:43 - very very hard to see
42:46 - so with that
42:47 - we basically have our basic pathfinder
42:50 - module so this one is working really
42:53 - well
42:54 - now obviously this still doesn't help us
42:56 - all that much because we need the actual
42:58 - roomba
43:00 - and let's start working on this one now
43:02 - and for this we have to talk about how
43:05 - the movement is going to work
43:07 - and the core logic is essentially going
43:09 - to be this we are going to have a room
43:11 - bar and whatever we click we are going
43:13 - to give this roomba a path
43:16 - and once this roomba has a path it is
43:18 - going to go for every single point
43:20 - inside of this path and essentially
43:22 - what's going to happen is the roomba
43:24 - looks at its current position and at the
43:26 - first point in the path and then the
43:29 - roomba is going to move towards that
43:30 - path
43:32 - and once the roomba is hitting that
43:33 - point it is going to recalculate the
43:35 - direction
43:36 - and this way it's going to move through
43:38 - all of the possible points and
43:39 - eventually ends at the final one and
43:42 - once we are running out of points it is
43:44 - going to stop moving
43:45 - and by the way this is the very same
43:48 - logic i have used for the overworld in a
43:50 - mario game in an earlier tutorial so
43:53 - check this one out if you want to apply
43:54 - this kind of logic in a different
43:56 - context it's basically working in the
43:58 - same way
43:59 - but i guess let's implement all of this
44:01 - straight in the code that's usually
44:03 - going to be the best way
44:05 - here we are back in the code and i want
44:07 - to create another class
44:10 - and let's call this one class
44:12 - roomba
44:14 - it's going to be pygame.sprite.sprite
44:17 - for the inheritance
44:19 - because we are going to create a sprite
44:21 - quite obviously
44:23 - and now in here we are going to need an
44:25 - init method
44:27 - that for now needs self
44:29 - and let's say nothing else for now
44:31 - although it will need something else
44:33 - later on
44:34 - and in here i want to create a basic
44:37 - setup first
44:39 - and the first we need is super dots
44:42 - under init
44:44 - as always
44:46 - and then we are going to need self.image
44:48 - and and self.rect
44:51 - and well for the image all we are going
44:53 - to do is import an image so
44:56 - pygame.image.load
44:58 - and we have a file called roomba.png
45:01 - i am terrible at spelling png and this
45:04 - as always we need to convert alpha to
45:07 - use it a bit more efficiently
45:09 - and now for the rectangle i want self
45:12 - dot image dot get underscore act
45:15 - and for the center i have put this thing
45:18 - at
45:19 - 60 and 60.
45:21 - so it's roughly in the top left of the
45:24 - screen although the specific position
45:26 - really doesn't matter all that much
45:28 - now
45:29 - next up
45:30 - i'm going to add another section that i
45:32 - called movement in a comment and in here
45:35 - i'm going to set self.position for now
45:38 - it's going to be self.rect.center
45:42 - why this one is important you're going
45:43 - to see in just a second
45:45 - but besides that i want to set
45:47 - self.speed at 0.6
45:51 - and this is literally just going to be
45:52 - how fast the roomba is going to move
45:55 - now finally i want one more section and
45:58 - i call this one the path
46:00 - and in here we're also going to have
46:02 - self.path
46:04 - and this again is just going to be an
46:06 - empty list
46:07 - and in just a bit we're going to pass
46:09 - the path
46:11 - that we created in our pathfinder inside
46:15 - this path here
46:16 - and then finally we need to get this
46:18 - thing it direction
46:20 - which is going to be a
46:21 - pygame.math.vector2
46:26 - which i can set to 0 and 0.
46:31 - so by default this isn't going to do
46:32 - anything
46:34 - and i guess the direction could be in
46:36 - the movement i think it makes a bit more
46:38 - sense there
46:40 - all right so now
46:42 - we have our basic roomba
46:45 - and let's start by drawing this thing so
46:48 - back in my pathfinder
46:49 - i'm going to add another section here
46:52 - and let's call this one roomba
46:54 - and in here self.character
46:57 - is going to be
46:58 - pygame.sprite.group
47:02 - single
47:03 - and inside of this group single
47:06 - i am going to create this
47:08 - roomba actually let's call it not
47:10 - character but rumor that makes a bit
47:12 - more sense
47:13 - so we're going to create inside of this
47:15 - group single an instance of the roomba
47:17 - class
47:18 - and for now it doesn't have any
47:20 - arguments so we can just leave it at
47:22 - that so now i can minimize this init
47:24 - method
47:25 - and in the update method
47:28 - i can
47:29 - roomba
47:30 - updating and
47:32 - drawing
47:33 - and really what i want to do in here is
47:36 - self.rumba
47:39 - and self.roomba.draw
47:44 - on the screen
47:46 - so this is going to be very simple
47:48 - updating with sprites
47:49 - again if you have no idea how any of
47:51 - this works check out my introduction to
47:53 - pygame it's going to help you enormously
47:57 - but all right now i can minimize this
47:59 - one as well
48:00 - and if i run the code might work yep now
48:03 - we can see in the top left we have our
48:05 - roomba so all the way up here
48:08 - it doesn't really do anything right now
48:10 - but that we are going to work on well
48:13 - now
48:14 - and the first thing we have to work on
48:16 - is when we create our path
48:19 - right now we always start in this
48:20 - position
48:21 - but
48:22 - i want to get this position from the
48:24 - current center of our roomba
48:27 - so ideally what i would like to do is
48:29 - self dot roomba
48:32 - dot sprite so this actual sprite inside
48:36 - of this bright single class
48:38 - and this one should have a method called
48:40 - get coordinate
48:42 - to give us the position of what cell
48:45 - it's currently on
48:46 - and well that is what we have to create
48:49 - now
48:50 - so in here define
48:52 - get underscore coordinate
48:55 - in itself and nothing else
48:58 - and in here again we have to convert an
49:01 - actual position
49:02 - into a tile coordinate
49:04 - and i think we haven't done an exercise
49:06 - in a while so try to do this yourself
49:10 - and this should be fairly similar
49:11 - compared to what we have done with the
49:13 - mouse so try to figure this one out
49:15 - yourself
49:21 - all right so essentially i want to get a
49:23 - column i want to get a row and once i
49:26 - have those two bits of information i
49:28 - want to return
49:30 - the column and the row
49:33 - so how can i get them well first of all
49:36 - i need the center of this roomba
49:40 - and this i can get with
49:42 - self.rect.center x for the column
49:45 - and for the row it is going to be center
49:48 - y
49:50 - so this is going to give me the actual
49:52 - position on the screen and this i have
49:55 - to floor divide by 32 again
49:58 - and well that's literally all we needed
50:02 - so this is pretty much the same thing we
50:05 - have done for the mouse
50:07 - so same logic here essentially
50:12 - so this now we can minimize and not
50:14 - worry about it again
50:17 - and i guess now let's try all of this
50:20 - so now when i run this
50:22 - now we can see that our roomba starts in
50:24 - this position
50:27 - very hard to see because it's well the
50:29 - same cell so it doesn't really count but
50:32 - you're going to see later on this is
50:34 - going to work better
50:36 - but for now we don't get an error
50:37 - message that's usually a good sign but
50:40 - next up we have to create another method
50:44 - and this i have called
50:47 - set
50:48 - path
50:49 - it is going to need self and then the
50:51 - path we want to set and really all
50:54 - that's going to happen here is self.path
50:57 - is going to be the path we pass in it
50:59 - and now for this path
51:01 - i want to call this
51:03 - once we have an actual path in our
51:05 - pathfinder
51:07 - so in here self dot roomba dot sprite
51:11 - dot
51:13 - set path i think i called it yeah
51:16 - and in here self dot path
51:19 - so literally all that's going to happen
51:21 - is
51:22 - once we are running all of this and we
51:25 - have an actual path we want to run
51:27 - this path i am then going to pass inside
51:29 - of this roomba
51:31 - so then we can work with this path
51:33 - inside of this sprite individually
51:36 - so as a matter of fact we don't have to
51:37 - worry about this class at all anymore
51:40 - it's all going to work inside of this
51:41 - roomba
51:42 - and that's going to make our life a fair
51:44 - bit easier
51:46 - and now inside of set path we have to do
51:49 - two more things
51:50 - first of all we have to self and i call
51:53 - this one create
51:56 - underscore collision underscore rex
52:00 - i'm gonna explain in a second what this
52:02 - one does and then after that self dot
52:06 - get underscore direction
52:08 - so
52:09 - what are these two methods doing
52:12 - well get direction i think is well
52:14 - fairly obvious it gets the direction and
52:17 - let me actually draw this
52:18 - right now we have our roomba here
52:22 - and let's say we have a point here we
52:24 - have a point here we have a point here
52:27 - and what get direction does
52:29 - is it looks at the current position
52:32 - of our room bar and then calculates the
52:34 - direction to the next point
52:37 - and then the room bar is going to move
52:39 - in that direction
52:41 - and then we are going to check if this
52:44 - roomba is going to collide with this
52:46 - point
52:47 - and once that does happen we're going to
52:49 - recalculate the direction so this one
52:52 - here and then our roomba is going to
52:54 - move this way
52:56 - and that way our roomba is going to
52:58 - follow this path all the way to the end
53:02 - the problem we have now though is how do
53:03 - we check the collision and for this in
53:06 - my case
53:07 - i have created a rectangle at each of
53:09 - these points and this is what create
53:12 - collision rect does
53:15 - it essentially goes through every single
53:16 - point in our self.path and places a
53:19 - rectangle at every single one of these
53:21 - points
53:22 - and this we can then use to change the
53:24 - direction of our roomba
53:26 - and well now we have to create these two
53:29 - methods so
53:32 - let me actually create them so define
53:35 - this one
53:39 - for now let me add pass in here and
53:42 - neither of them need any argument so
53:44 - that's going to make things a fair bit
53:46 - easier
53:47 - and let's start by create collision
53:49 - rectangles that one actually isn't all
53:51 - that difficult
53:53 - and then here first of all we want to
53:55 - check if self.path even exists because
53:58 - if it doesn't there's no point running
54:00 - any of this
54:02 - and i guess in here what could happen is
54:05 - if the player clicks on the roomba
54:07 - and we are running all of the
54:09 - pathfinding in here but since we click
54:12 - on the roomba itself the path is going
54:13 - to be empty because the start and the
54:15 - end cell are the same position
54:17 - so this way we do want to check if even
54:20 - if the player clicks on something in the
54:21 - field we are checking for errors and now
54:25 - inside of here i want to create self dot
54:28 - collision underscore rex
54:31 - and for now this is just going to be an
54:33 - empty list
54:34 - as a matter of fact i want to create
54:36 - this list right
54:39 - when we are initiating this roomba class
54:42 - and this again is just to make sure that
54:45 - we always have this attribute available
54:47 - even if we don't call this method
54:49 - just in case it's not strictly necessary
54:52 - now we are going to do kind of the same
54:55 - logic we have done earlier in our
54:57 - pathfinder for
54:59 - drawing the path so very similar to what
55:02 - we have done here because in here
55:05 - we looked at all the points inside of
55:06 - the path
55:08 - converted each point to position in our
55:10 - field and then in here just draw a point
55:12 - through them
55:13 - but what we want to do for our roomba or
55:16 - the collision rectangles in here is we
55:20 - don't want to draw a point instead we
55:22 - want to create a rectangle but well the
55:24 - basic logic is the same so for point in
55:27 - self.path
55:30 - i again want to create an x and a
55:34 - y coordinate
55:36 - and well here the same logic applies so
55:39 - i want point for x it's going to be 0
55:43 - multiplied by 32
55:45 - and on top of that we're going to add
55:47 - 16. so half the size to make sure that
55:50 - we are in the center of this tile
55:53 - and now i can copy all of this
55:55 - change this to a 1 and then we have the
55:57 - x and the y position
55:59 - so this is actually not that hard
56:02 - now next up
56:04 - we want to use that information to
56:05 - create a rectangle
56:07 - and this is just going to be pygame.rect
56:12 - and in here again
56:14 - we are going to the tubal with the left
56:16 - and the top
56:17 - and then another tuple with the width
56:19 - and the height
56:21 - now the width and the height are going
56:22 - to be quite simple in my case the
56:24 - rectangle is just going to be a
56:26 - dimension of 4 and 4. so it's 4 pixels
56:29 - wide and 4 pixels high
56:32 - and since our speed is 0.6 this should
56:35 - very easily be enough
56:37 - and now for the left
56:39 - i essentially want to get the x and y
56:43 - although right now
56:45 - this would not work and let me explain
56:49 - why
56:50 - essentially if this is
56:53 - one of the tiles in our game so this is
56:55 - 32 by 32 pixels
56:58 - and our x and y right now would be
57:00 - exactly in the middle of that
57:03 - but if we just place these points in
57:05 - here we always place the top left so our
57:08 - rectangle would look something like
57:10 - this
57:11 - which well would be kind of a problem
57:14 - because there is a chance that the rumor
57:16 - might move something like this and miss
57:18 - the rectangle entirely so we have to
57:20 - give this thing an offset to actually
57:22 - place the center of it
57:24 - and that is well very simple all we have
57:27 - to do is to subtract half of the width
57:30 - and half of the height of it
57:33 - and that way we move this rectangle
57:36 - exactly in the center of each of these
57:38 - points and well once we have that
57:42 - all we have to do is get self dot
57:44 - collision rect
57:46 - and append the rectangle
57:50 - and with that
57:51 - we are creating a bunch of rectangles
57:53 - along the path
57:55 - and now we can minimize this and we
57:58 - should never need to open it again
58:00 - unless i made a mistake always a chance
58:02 - for that now next up
58:04 - we have to work on our get direction
58:08 - and in here
58:09 - we need if self dot
58:13 - collision rex so if there's any point
58:16 - inside of our collision rectangles
58:18 - because if there's no point left we know
58:20 - we have reached the end of the path
58:22 - and if that's the case we shouldn't be
58:24 - moving anymore
58:25 - but once there are collision rectangles
58:28 - i want to get a start position and end
58:31 - position
58:32 - and then i want to set the
58:34 - self.direction and
58:36 - minus the start
58:38 - and i want to normalize
58:41 - all of that so this is going to be very
58:43 - simple vector math because the start and
58:45 - the end are both going to be a vector
58:48 - and if you subtract the n from the start
58:49 - of a vector you get the direction
58:51 - between the two vectors um if you don't
58:54 - know vector math this might seem weird
58:56 - but i guess check out the vector math
58:58 - it's super useful
58:59 - but essentially now what we have to get
59:02 - is the vector for our start and the
59:04 - vector for our end
59:06 - and the start is the really simple one
59:08 - all we need here is pygame.math.vector2
59:14 - and in here i want to set
59:15 - myself.position
59:17 - so this is the position we created
59:19 - further up here
59:21 - and then
59:23 - for the end i also want to get
59:25 - pygame.math.vector2
59:29 - and for the end i want to get the first
59:33 - collision rectangle so self dot
59:35 - collision rex
59:37 - and zero
59:39 - and this is going to be a rectangle not
59:41 - a position so from this
59:43 - we have to get the center and that is
59:47 - kind of all we needed now i also want to
59:50 - add an else statement
59:52 - that if we are running out of collision
59:55 - rectangles
59:56 - i want to set self.direction
60:00 - back to pygame.math.vector2
60:05 - and this should just be 0 and 0. so
60:08 - essentially we're not moving at all
60:11 - and then self.pair
60:15 - should also be an empty list so that
60:17 - once we got through all of the
60:18 - collisions
60:20 - we get rid of the path again
60:22 - so we are definitely not going to move
60:24 - anymore
60:25 - and all right with that we can finally
60:28 - create an update method for this roomba
60:32 - and in here all i want to do is
60:35 - self.position
60:36 - is going to be plus equal self.direction
60:42 - multiplied by self.speed
60:45 - so essentially what we're going to do
60:47 - right now
60:48 - is
60:49 - we have
60:50 - this point here
60:51 - and this point starts at the center of
60:54 - our roomba and this point we are going
60:57 - to move
60:58 - in this direction
61:00 - at this speed here and the direction we
61:03 - are going to get from the position of
61:05 - the first point in our path
61:09 - and then self.rect.center
61:12 - is going to be self dot position
61:16 - so this way we make sure we actually
61:17 - place the roomba at the position that we
61:21 - have set here
61:22 - now why is this important why couldn't
61:25 - we just go straight with
61:28 - self.req.center here
61:30 - why do we need position at all
61:32 - and the reason is that
61:34 - vectors and pygame are not exactly
61:38 - perfectly compatible
61:40 - so when we place a rectangle so a
61:43 - rectangle like here
61:44 - we always place integers
61:47 - whereas vectors like self.direction is
61:50 - always going to be a float and pygame
61:53 - converts a float to an integer
61:55 - automatically so that's not the problem
61:58 - the problem is when these two numbers
61:59 - are converted we are losing some
62:01 - information
62:03 - so if you always edit the direction here
62:05 - you might get a slight offset that's not
62:08 - intended because a float here might be
62:11 - 0.78
62:13 - completely random number
62:15 - but when pygame places this rectangle
62:18 - this 0.78 is just going to be zero
62:21 - and if you keep on adding these tiny
62:23 - offsets eventually this center is going
62:26 - to be in a completely different position
62:29 - because every movement is going to add a
62:31 - tiny additional offset
62:33 - and this well obviously isn't going to
62:35 - be great and the way around that is to
62:38 - store all of this information inside of
62:40 - this position and this position is
62:42 - always going to be a floating point
62:43 - number
62:44 - and
62:45 - then when we place this rectangle we
62:48 - always place this in the same position
62:50 - so that way we avoid adding the error
62:52 - and again check out my overworld
62:53 - tutorial it's going to explain all of
62:55 - this in much more detail but alright i
62:58 - guess let's actually run all of this
63:00 - finally to see what's going to happen so
63:03 - the game still runs now if i click on
63:05 - something
63:07 - we are moving in completely the wrong
63:09 - direction
63:10 - good to know although
63:13 - it's not entirely wrong and i guess let
63:17 - me explain why
63:18 - so right now the origin point of our
63:20 - roomba is here
63:22 - and the first point that we are going to
63:25 - create for our path is going to be here
63:29 - and then the second point is going to be
63:31 - here the third point is here then here
63:33 - and so on essentially our path is going
63:36 - to be this this and then i assume
63:39 - something like this
63:40 - and the reason why our roomba is going
63:42 - to the top left is because this initial
63:45 - first bit here let me overemphasize it a
63:48 - tiny bit so the direction is actually
63:50 - working the problem is now that once we
63:53 - are colliding with any of these
63:55 - collision rectangles we don't actually
63:57 - change the direction so this is
63:59 - something we have to add
64:01 - but everything else seems to work
64:04 - so
64:05 - let's add a collision mechanic and this
64:07 - is just going to be another method
64:10 - and let's call this one check
64:13 - collisions
64:15 - it needs self and nothing else
64:17 - and in here first of all as always i
64:19 - want to check if self dot collision
64:22 - reacts even exists because if it doesn't
64:25 - there's no point running any of the
64:26 - stuff inside of it
64:28 - and now inside of this i want to check
64:30 - for rect in self dot
64:34 - collision rectangles so i want to look
64:36 - at all of the rectangles inside of this
64:38 - list and what i want to do is if
64:42 - rect.collide
64:44 - point
64:46 - self.position
64:48 - so essentially
64:50 - i am
64:51 - looking at this self.position so the
64:55 - position we are moving down here
64:57 - and if this point is in any of the
64:59 - rectangles i want to run some code
65:02 - and what i want to run is self dot get
65:05 - underscore direction again
65:08 - except now i don't want to get the point
65:11 - i'm currently on let me actually explain
65:13 - this
65:14 - so
65:15 - let's say right now this is our roomba
65:18 - and right now we have
65:21 - a point here
65:22 - and a point here
65:24 - and our roomba
65:26 - has moved to this point
65:29 - and now happens to be
65:31 - right on top of it
65:33 - and now we're running get direction so
65:36 - this one here
65:37 - the problem we have now is that
65:39 - getdirection always picks the first
65:42 - point from this path
65:44 - which in our case
65:46 - would still be
65:47 - this point here so the point our roomba
65:50 - is already on top of so if we were to
65:53 - run the code like this we would get a
65:55 - weird result essentially the rumor
65:57 - wouldn't work at all
65:59 - but this is a problem we can work around
66:01 - quite easily
66:02 - literally
66:03 - all we have to do
66:05 - once we are colliding with this point we
66:07 - want to delete that point so delete
66:10 - self dot collision
66:13 - rects and the first item
66:16 - so once we are colliding with the point
66:18 - we are going to delete that point and
66:20 - then get a new direction and that way
66:22 - our roomba is always going to move
66:24 - towards the next point once it reaches
66:26 - the current point and now all we have to
66:28 - do is to actually call this method
66:31 - and i have called this right after the
66:33 - first line so self dot check collisions
66:37 - and now let's run this again
66:40 - so now
66:41 - we are actually moving this roomba and
66:44 - this is looking really good
66:48 - but now at the end
66:50 - oh it's actually working okay
66:52 - so
66:53 - problem now is that this is kind of slow
66:58 - so let's increase the speed a tiny bit
67:00 - so the speed right now
67:02 - 0.6 let's put this to a 2.
67:07 - and now this is looking significantly
67:10 - nicer
67:14 - and i'm just realizing drawing the
67:16 - points here looks kind of bad when i run
67:19 - it often enough
67:20 - but well by itself this is actually
67:22 - working
67:23 - really well
67:27 - and
67:28 - you can even click it whenever you want
67:30 - and this is going quite well
67:37 - and well
67:38 - it's working super well already
67:42 - and okay so with that we are nearly done
67:46 - there's one more thing i would like to
67:49 - add
67:50 - and let me minimize all of these methods
67:52 - because they're kind of
67:54 - hard to read right now
67:59 - okay so here we have our two classes
68:02 - they have gotten quite a bit complex
68:04 - over time
68:06 - but the one thing i would like to add
68:08 - now is that once the roomba is reaching
68:12 - the end point
68:14 - i want to empty
68:16 - this
68:17 - self.path
68:19 - it's not strictly necessary
68:21 - but from the game logic point of view
68:25 - once the roomba is reaching the end of
68:26 - this path the path isn't necessary
68:29 - anymore and if you have a more complex
68:32 - project it might interfere with
68:34 - something else
68:36 - and well all we need for that is another
68:38 - method
68:40 - that i'm going to call empty underscore
68:43 - path
68:44 - it needs self and nothing else
68:47 - and literally all we are doing in here
68:49 - is self dot path
68:53 - is going to be an empty list
68:56 - and then when we create this roomba
68:59 - i'm going to pass
69:00 - this empty path into it
69:04 - and
69:05 - now inside of the roomba class
69:08 - we can create an instance of empty path
69:13 - and now in here let's put it down here
69:16 - next to path so self dot empty path is
69:20 - going to be empty path
69:23 - and now what i want to check is in my
69:26 - collisions
69:27 - that i already check if collision racks
69:30 - exist at all but once we reach the end
69:33 - of this collision rex should be empty
69:36 - and if it's empty
69:38 - an else statement
69:40 - should be running
69:42 - and what i can do in here is run self
69:44 - dot empty the path
69:47 - and this should then empty the path
69:50 - so that in our pathfinder
69:53 - we don't have anything in here anymore
69:55 - which feels a bit cleaner
69:57 - and now let's run all of this again
70:01 - we are getting an error
70:03 - all right it should be self dot empty
70:05 - path
70:07 - so now let's try this again and there we
70:09 - go
70:10 - so now you don't really see a difference
70:12 - except now the path disappears because
70:14 - we are deleting it which i think is a
70:16 - bit better
70:18 - and
70:19 - all right this is feeling quite nice i
70:23 - guess it's still a bit slow and i hate
70:24 - the points let me get rid of those so
70:28 - drop half um
70:30 - let's get rid of this drawing here looks
70:33 - a bit ugly
70:35 - now that look at it
70:38 - and then for the speed let's set this to
70:40 - a free this should definitely be fast
70:42 - enough and now let's run off this again
70:45 - and now with our roomba
70:48 - so this is working really well
70:51 - and well
70:53 - now you have all you need to create
70:55 - pathfinding in basically any kind of
70:57 - game so this sort of system you can
70:59 - pretty much create wherever you want
71:02 - it's pretty flexible when it comes down
71:04 - to it
71:06 - so
71:07 - well with that i hope you enjoyed this
71:08 - tutorial and i will see you around