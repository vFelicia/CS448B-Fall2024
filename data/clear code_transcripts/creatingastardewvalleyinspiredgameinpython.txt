00:00 - [Music]
00:16 - hello there in this tutorial we will
00:19 - create a staryuvatic Style game in
00:21 - Python and this is going to have a ton
00:24 - of stuff like farming and foraging we
00:26 - can cut down trees and trade items
00:28 - there's also a day and night cycle and
00:30 - different kinds of weather the entire
00:33 - game was also made entitled so you can
00:35 - expand it yourself
00:36 - speaking of I am using the free version
00:39 - of the sproutland asset pack by cup
00:41 - nubel which is amazing there's also a
00:45 - paid version with more stuff if you want
00:46 - to expand the game yourself although for
00:48 - this video you don't need to spend any
00:50 - money before I start I do want to
00:53 - emphasize that this is not a beginner's
00:55 - tutorial to be able to follow you will
00:58 - need to have a good understanding of
01:00 - pygame if you want an introduction or
01:02 - reminder I would recommend my
01:04 - introduction to pygame and my video on
01:07 - using Delta time if you have those two
01:09 - you should have a really solid
01:10 - foundation during the video I will also
01:13 - mention a couple of videos that explain
01:15 - some more advanced Topics in detail
01:17 - those can be helpful but you are not
01:19 - going to need them to follow along
01:21 - alternatively I also have a paid course
01:23 - where you learn all of pie game by
01:25 - making four pretty cool games check this
01:27 - one out if you are interested and sorry
01:30 - about the requirements but if I did this
01:32 - tutorial from scratch it would easily be
01:34 - 20 hours long
01:36 - finally the entire project is inside of
01:38 - one folder and I will be working in the
01:41 - code subfolder I will explain while
01:43 - coding when and how to access elements
01:45 - in here I also save the progress for
01:48 - every chapter and you can find that on
01:49 - GitHub
01:51 - and with all of that I hope you enjoy
01:53 - alrighty so let's get started and I
01:57 - already have a couple of lines of code
01:59 - ready just to get started let's have a
02:01 - look at those here I have my code and I
02:04 - have main.pi and I have settings.pi both
02:08 - already have quite a bit and I am
02:10 - working in main.pi for now if I execute
02:14 - the code with all of this I can see a
02:16 - black window that doesn't do anything
02:18 - right now but we do have a start
02:21 - and all of the stuff in settings we are
02:24 - going to use later but well for now
02:26 - don't worry about it besides these two
02:28 - lines here those determine the width and
02:31 - the height of our window now if you have
02:34 - a very small or very large monitor you
02:37 - could change these numbers to something
02:38 - else whatever is appropriate for you the
02:41 - rest of the game is going to scale with
02:42 - that
02:44 - at least within reason don't make it 5x5
02:46 - pixels that would be a weird game
02:49 - and I guess really quick let's go over
02:51 - what we have
02:52 - all the way at the top we are importing
02:55 - pygam and sys and settings
02:57 - High games should be obvious but since
02:59 - we need all the way down here to close
03:01 - the game properly other than that we are
03:03 - not using it
03:05 - after the Imports we are creating a
03:07 - class called game inside of that we have
03:10 - an init and a run method most of the
03:13 - game is going to run inside of the run
03:15 - method in here we have the game Loop and
03:18 - this one is checking right now if we are
03:20 - closing the game here and then we are
03:23 - getting Delta time and we are updating
03:25 - the game
03:26 - besides that in the init method we are
03:29 - creating a display surface we are
03:31 - creating a clock and we are also
03:33 - initiating Pi game so all things
03:35 - considered a very simple class
03:38 - and finally all the way at the end we
03:41 - are checking if we are in the main file
03:43 - then we are creating an object from the
03:45 - class and then we are calling the run
03:47 - method and this run method contains the
03:49 - loop that contains our game so with that
03:52 - we have the main setup although there's
03:55 - one more change that I would like to
03:57 - make and that is if I run the game again
04:00 - in the top left we have a window title
04:03 - and right now it says Pi game window
04:05 - which doesn't feel good so I want to
04:08 - change that one and this could be a
04:11 - really good exercise for you what I want
04:13 - you guys to do is to change the title of
04:15 - the window and if you want to code along
04:17 - pause the video now and try to figure
04:19 - this one out yourself
04:24 - after we are creating the display
04:25 - surface we have to call pygame dot
04:28 - display dot set underscore caption
04:31 - and in them we can type in the name in
04:35 - my case I want to name the game Sprout
04:38 - land after the asset pack although you
04:41 - could name it whatever you want and if
04:44 - you run out of this now you can see in
04:45 - the top left we have sproutland this
04:47 - feels much better
04:48 - although granted a very small change
04:52 - but alright with that we have our setup
04:55 - now if none of the things I've just
04:58 - talked about make any sense check out my
05:00 - introduction to pygame this one is going
05:02 - to explain all of this in much more
05:04 - detail and if you are lost already the
05:06 - rest of the tutorial is just going to
05:08 - get harder so definitely get ready for
05:11 - it
05:12 - now there is one thing that we do have
05:15 - to start thinking about because later on
05:18 - the game is going to become quite
05:19 - complex and I want to keep the basic
05:22 - main.pi as clean as possible it
05:25 - shouldn't really do too much
05:26 - as a consequence inside of this while
05:29 - loop I want to run another object and
05:32 - this object actually contains the level
05:34 - let me actually implement it and then
05:36 - you see in a second what I mean
05:37 - basically what I want to do is I want to
05:40 - create a new file and this one I want to
05:42 - save as level dot pi
05:46 - for this level I want to import Pi game
05:49 - and from settings import everything
05:54 - and this level is going to be a class so
05:58 - class level
06:00 - and this class level is going to have
06:01 - one method that I'm going to call run
06:04 - this one itself and Delta time because
06:07 - we need Delta time available inside of
06:09 - our game to make everything frame rate
06:11 - independent
06:13 - and inside of this I want to for now
06:16 - just print Run game and this is all we
06:19 - need
06:20 - in main.pi I want to from Level import
06:24 - level
06:27 - and inside of the init method of the
06:29 - class I want to create an attribute
06:31 - level that is going to be the level
06:36 - and now inside of my run method of the
06:39 - game
06:40 - before I update the display I want
06:44 - self.level dot run
06:47 - that way we are always calling this run
06:50 - method here although don't forget this
06:52 - one needs Delta time the one we have
06:55 - gotten here
06:57 - if you don't know what Delta time is
07:00 - it's a bit more technical but I've made
07:03 - a whole video on it so check this one
07:04 - out you basically are going to need it
07:06 - to follow along for this video so well
07:09 - it is getting quite complex
07:11 - unfortunately there's no way around it
07:14 - if I run all of this now
07:17 - we can see Run game in the bottom left
07:19 - so we are continuously updating this
07:22 - method here and this means we can run
07:24 - the entire game inside of it
07:27 - which is helping considerably to keep
07:30 - the entire game clean and organized and
07:33 - for a project of this size this is
07:35 - really important
07:37 - now before I'm finishing the section
07:39 - there are a couple more things that I do
07:41 - want to do first of all when we are
07:44 - creating this class I want to run a
07:46 - Dunder init method and in here first of
07:50 - all I want to create another attribute
07:53 - for the display surface
07:56 - and this one I'm getting with
07:59 - pygame.display.get underscore surface
08:03 - this display surface is the same as this
08:06 - self.screen here
08:08 - and this allows the level to draw
08:11 - straight on the main display that we are
08:13 - going to display to the player which
08:16 - makes organizing the entire thing much
08:18 - easier
08:19 - and let me add comments here to make all
08:21 - of this a bit easier to follow let's
08:24 - call it get the display surface
08:28 - now besides that we need Sprite
08:33 - groups
08:35 - and for now I just want to create one
08:38 - attribute that I call all Sprites and
08:42 - this is going to be pygame dot Sprite
08:44 - dot group
08:46 - s are a key feature of Pi game and they
08:49 - help us to draw and update any kind of
08:52 - Sprite in the game and Sprites is what
08:55 - you use to basically do anything in pi
08:57 - game so our player is going to be a
08:59 - Sprite any kind of tree or plant is
09:02 - going to be a Sprite and none of this
09:04 - works without a group
09:06 - in my case what I want to do inside of
09:09 - run I first of all want
09:11 - self.displaysurface dot fill with a
09:15 - black color so we don't accidentally see
09:17 - the previous frame after that I want
09:20 - self.all Sprites dot Raw
09:24 - and in here we need the surface we want
09:26 - to draw on and in my case I want to draw
09:28 - on the display surface meaning this is
09:31 - what we have to pass in here
09:33 - I can just copy it and paste it in here
09:37 - and besides that I also want self dot
09:40 - all Sprites dot update
09:42 - now this method we are not going to use
09:44 - for now but later on this is what
09:47 - updates all of the Sprites inside of it
09:49 - like the player for example
09:52 - but now back in main.pi I can run all of
09:56 - this and we cannot see any change and
09:59 - that is because we haven't really made
10:01 - any changes to the logic of the game
10:02 - although if you want to see something
10:04 - you could change this black to something
10:06 - like red
10:08 - and now we have a red background
10:09 - although I want to keep this black
10:12 - and there we go
10:14 - so with that we have a basic setup so
10:17 - let's get started with the player now
10:20 - the player is going to become quite
10:21 - complex so I am going to do all of this
10:24 - over multiple steps
10:26 - but we do have to get started somewhere
10:28 - so let's create a really basic player
10:31 - here we are back in the code and for the
10:33 - player I want to have a separate python
10:35 - file
10:36 - meaning I'm going to create a new one
10:38 - and save it as player dot pi
10:42 - just as before we have to import Pi game
10:45 - and also from settings import everything
10:51 - once we have that I want to create a
10:54 - class layer and this one needs to
10:56 - inherit from pygame dot Sprite dot
10:59 - Sprite because it is going to be Sprite
11:02 - in here we need a Dunder init method and
11:05 - this one eventually is going to have a
11:07 - lot of parameters although for now all I
11:10 - want is self
11:11 - then I want a position and then I want
11:14 - to group the Sprite is supposed to be
11:16 - part of and the first thing we have to
11:18 - do inside of the init method is called
11:21 - super and Dunder init
11:23 - and in here we have to pass in the group
11:27 - that way as soon as we are creating an
11:29 - instance of this class the object is
11:31 - going to be inside of this group which
11:33 - is super handy
11:35 - besides that we will need self dot image
11:39 - this is what this Sprite is going to
11:42 - look like and this needs to be some kind
11:44 - of surface now later on we're going to
11:47 - import a lot of surfaces but for now we
11:51 - don't really have that available as a
11:54 - consequence I'm going to create a plane
11:56 - surface
11:57 - and this I get with pygame DOT surface
12:00 - this one is going to need a width and a
12:03 - height and the numbers here don't matter
12:05 - since we are going to change them anyway
12:06 - but let me go with 64 by 32.
12:10 - now this image right now is going to be
12:12 - completely black and since we are
12:15 - putting this on another black surface as
12:17 - we can see in the level we're not going
12:19 - to see anything
12:21 - we will change that I want to fill the
12:24 - image with the color let's go with green
12:27 - finally we are going to need a self dot
12:31 - rectangle and this one will take care of
12:33 - the position
12:35 - this rectangle we create with self dot
12:38 - image dot get underscore rect and in
12:41 - here as the argument we have to pass in
12:43 - where we want to place it and I want to
12:46 - place the center of this rectangle
12:47 - wherever the position is
12:50 - in this position we are getting from the
12:53 - parameters
12:55 - with that we have a very simple player
13:00 - spread class now we just have to use it
13:03 - and this is going to happen inside of
13:05 - level in here I want from player import
13:09 - player
13:11 - to keep everything organized inside of
13:13 - the level I want to create a setup
13:16 - method this one itself as always and
13:19 - then here we are going to create an
13:21 - attribute called self.player and this is
13:25 - going to be an instance of the class
13:27 - player
13:29 - the player we have created here
13:31 - and this player is going to need two
13:33 - arguments the position and the group so
13:36 - let me copy both of them and paste them
13:39 - in here
13:40 - for now the position is going to be
13:42 - completely random but we are going to
13:44 - need a tuple with an X and A Y position
13:48 - in my case let's go with 640 and 360.
13:53 - the middle of the screen
13:56 - besides that we need a group and the
13:58 - group here is self dot or Sprites the
14:02 - group we have created earlier on and now
14:04 - we're just passing it in here
14:06 - we are nearly done the last thing that
14:09 - we have to do is to actually call the
14:11 - setup method and this happens inside of
14:13 - the init method so in here self dot
14:16 - setup
14:18 - and now we should be able to see
14:20 - something so back in main.pi I am going
14:23 - to run my code and we can see we have a
14:27 - green thing
14:28 - although I realized I confused the width
14:31 - and the height
14:32 - so back in my player this should be 32
14:36 - for the width and 64 for the height
14:40 - that is looking much better
14:43 - so now we can see something but we
14:45 - cannot interact with anything which
14:47 - means inside of the player I want to get
14:51 - some kind of input
14:54 - and don't forget self that one is really
14:57 - important
14:58 - now to get all of the available keys
15:00 - that are being pressed we need pygame
15:03 - dot key dot get underscore rest this one
15:08 - is returning a list with all of the keys
15:11 - that are potentially being pressed and
15:13 - this I want to save in a variable let me
15:15 - call it keys
15:17 - and this list I can access with for
15:20 - example via keys and then square
15:23 - brackets and now
15:26 - highgame has a couple of predefined
15:28 - names for example for the up Arrow we
15:30 - need K up
15:33 - and if that is the case for now let me
15:36 - just print
15:37 - up
15:39 - all that is left to do now is to figure
15:41 - out when to call this input method here
15:44 - and for that we will need an update
15:47 - method then itself and Delta time
15:52 - how this is going to work is
15:54 - inside of level we have our all spreads
15:57 - group and this all spreads group has a
16:00 - draw and an update method the update
16:03 - method is the really important part
16:04 - right now
16:06 - because this one holds the update method
16:08 - on all of the children
16:11 - meaning effectively what is going to
16:13 - happen is that this update method here
16:15 - calls this update method
16:18 - as a consequence for the level or the
16:22 - group more specifically we have to pass
16:24 - in Delta time as well the Delta time we
16:28 - get from the parameters here and this
16:30 - Delta time we get all the way at the
16:32 - beginning inside of Main
16:34 - in just a bit this is actually going to
16:36 - become useful
16:38 - but now inside of the player all we have
16:42 - to do is call Self dot input
16:45 - and this should be working so now if I
16:48 - go back to my main.pi run all of this
16:51 - and now if I press up in the bottom left
16:53 - you can see up
16:56 - which means I get some input
16:58 - all we have to do now is to cover the
17:01 - other directions and then we should be
17:03 - good to go
17:04 - and the usual system works like this
17:07 - if we're not pressing up then I want to
17:10 - check if keys and pygame dot k
17:14 - underscore down so we are pressing the
17:17 - down button and if that is the case
17:19 - I want to print down for now
17:23 - and with that we have up and down
17:25 - besides that let me copy all of this I
17:30 - also want to check for right and I want
17:34 - to check for left
17:36 - and then obviously the text has to be
17:39 - right
17:40 - and it should be left
17:43 - and with that if I run main.pi
17:46 - we got left right up and down all of the
17:49 - four directions
17:50 - what do we now have to figure out is how
17:52 - to translate all of this into actual
17:54 - movement
17:55 - and for that we need a few more
17:59 - attributes let me put it all the way in
18:01 - the init method with a comment let's
18:03 - call it movement attributes
18:06 - and the ones before let's call them
18:09 - General setup
18:11 - bottom movement I want to have first of
18:14 - all self dot Direction and this is going
18:17 - to be a vector so pygame dot math dot
18:20 - Vector 2 and this Vector is going to
18:23 - have an X and the Y part
18:25 - depending in which way the player should
18:27 - move so for example if x is 1 then the
18:30 - player should move to the right
18:32 - and by default this Vector 2 is supposed
18:35 - to be empty so it should have 0 and 0.
18:38 - and this is the default value so I can
18:40 - just leave it like this
18:42 - and all that we are going to do inside
18:45 - of here is change this direction so
18:49 - basically inside of keys for up I want
18:52 - to set self dot Direction dot y
18:57 - two minus 1.
18:59 - this I can now copy and do it for down
19:03 - this one is just going to be one for
19:06 - right we are targeting X and this one is
19:10 - going to be positive one and left is
19:12 - going to be X being negative 1.
19:18 - and with that we have the four different
19:20 - directions
19:21 - although now we do have a problem and
19:24 - let me isolate the vertical directions
19:27 - just to illustrate what the problem here
19:29 - is right now later on
19:31 - we are moving the player in whatever
19:33 - this direction is pointing at so for
19:36 - example if Y is negative one we want to
19:39 - move up
19:41 - and this is what we are getting in here
19:44 - the problem is in this setup right now
19:47 - once we press up once
19:50 - direction.y is always going to be
19:52 - negative one even if we release the
19:55 - button and this is obviously not great
19:57 - because once you move up once the player
20:00 - never stops moving up which well we have
20:02 - to change
20:04 - this fortunately though is very easy to
20:06 - change because all we have to do is add
20:08 - another else statement and let me copy
20:11 - the direction here because now the
20:13 - direction should be zero
20:15 - which means now if we're pressing up the
20:18 - direction of Y is negative one if we are
20:21 - pressing down direction is positive one
20:23 - and if we're pressing neither then
20:25 - Direction node Y is zero so we're not
20:27 - moving in the vertical axis at all
20:30 - and that is all we need here so I can
20:33 - remove the white space and for the
20:35 - horizontal axis I have to do the same
20:37 - thing so here self dot Direction dot X
20:41 - is going to be zero
20:43 - and with that we have our basic
20:46 - Direction what I can do now at the end
20:49 - of all of this I can print self dot
20:52 - Direction and now in main.pi if you're
20:55 - on all of this and I can have the
20:57 - different directions inside of my Vector
20:58 - this is working really well
21:01 - there are two more attributes that we
21:04 - need to make all of this work the first
21:06 - one I always call Self dot pause and
21:10 - this is also going to be a vector
21:12 - so let me copy this one here and now we
21:15 - have another vector
21:17 - now if you are familiar with pi game you
21:21 - probably always store the position
21:22 - inside of the rectangle however the
21:25 - problem with this approach is that a
21:27 - rectangle always stores the position as
21:29 - an integer
21:30 - but if we want to use Delta time so this
21:34 - one here to move everything in the frame
21:36 - rate independent way we are very often
21:38 - getting floating Point values which
21:41 - wouldn't work here at all as a
21:43 - consequence I am going to store the
21:45 - position
21:46 - inside of a vector and this is going to
21:48 - be what self dot pause is for
21:51 - and this is also what we are going to
21:53 - move and then at the end we are going to
21:56 - update the rectangle depending on where
21:58 - the position is
22:00 - all of that is going to make much more
22:02 - sense later on but for now for the
22:04 - starting position of cell.poss I want
22:06 - self.rect.center
22:09 - finally I want self dot speed and this
22:13 - is just going to be how fast the player
22:15 - is
22:16 - I put this to 200 but just choose
22:18 - whatever you think looks good
22:21 - and with that I can get rid of this
22:24 - print statement here and add another
22:27 - function or one method and this one is
22:30 - going to be move in here we need self
22:32 - and Delta time
22:34 - and essentially what I want to do in
22:36 - here I want to move myself dot pause and
22:39 - how I want to move it is by getting
22:41 - myself dot Direction
22:44 - multiplied by self dot speed multiplied
22:48 - by Delta time
22:50 - and after I have done that I want to set
22:54 - self.direct.center to self.pos
22:58 - and now
22:59 - after the input if I call Self Dodge
23:02 - move with Delta time
23:04 - we should be having a moving player so
23:07 - let's try and run main.pi and I can move
23:10 - around this is working really well
23:16 - and this is also frame rate independent
23:19 - and this is why this entire system is
23:21 - really important by using Delta time
23:23 - again check out my video on it if you
23:25 - want more detail it does get a bit more
23:28 - technical but if you didn't do this
23:31 - and change the frame rate for example in
23:34 - this self.tick you could set the frame
23:37 - rate for example with 60 or you could
23:39 - set a thousand or you could set 10. with
23:43 - this setup the frame rate doesn't matter
23:45 - but if you didn't do it then the
23:47 - movement would be faster or slower
23:48 - depending on how high the frame rate is
23:49 - which would be a massive problem
23:53 - all right in this case
23:55 - we have our basic movement
23:59 - now there's one more important thing
24:01 - that we have to do and that is inside of
24:03 - this move method if I run the code again
24:08 - if I move left and right or up and down
24:10 - I have one speed however if I move in
24:13 - the diagonal Direction like this the
24:16 - player moves noticeably faster and that
24:19 - is a problem you can see it pretty well
24:21 - here
24:22 - now why is that happening and let me
24:25 - draw on the screen to explain
24:27 - if the player is only moving in One
24:29 - Direction let's say the player is moving
24:31 - to the right like this
24:33 - at a speed of 1. that's not the actual
24:36 - speed but one is a very simple number to
24:38 - use
24:39 - and if we only move up we are also going
24:42 - to have a speed of 1. this is what we're
24:44 - getting from Direction
24:46 - the problem now is if we are combining
24:49 - these two numbers we are getting a
24:51 - different kind of length so let me
24:54 - rearrange to drawing a tiny bit and
24:56 - let's say I want to move by one unit to
24:58 - the right and by one unit up
25:01 - then the actual distance I am going to
25:03 - move is going to look like this
25:06 - and the distance of this length here is
25:10 - what we are getting from Pythagoras
25:12 - Theorem
25:13 - it is 1 square plus one square and then
25:17 - we are taking the square root of all of
25:18 - this the result in this case would be
25:21 - something like 1.4
25:24 - and this result means that if we move
25:27 - diagonally the player would move about
25:28 - 40 faster than if we just move left or
25:31 - right or up or down
25:33 - which obviously is going to be a problem
25:35 - so we have to adjust for that
25:37 - and the way you adjust for that is
25:39 - called
25:41 - normalizing a vector
25:44 - and normalizing a vector basically just
25:47 - means that well we're making sure the
25:50 - direction of the vector is always one
25:53 - and this is an inbuilt function into Pi
25:56 - games so you don't have to think about
25:57 - it too much all we have to do is get
25:59 - self dot Direction
26:01 - and we have to assign it to
26:03 - self.direction.normalize
26:07 - don't forget to call it
26:08 - and we are nearly done
26:11 - the last problem we have is that we can
26:13 - only normalize a vector if the vector
26:15 - has a length and Bishop makes sense I
26:18 - guess to illustrate what this one is
26:20 - doing is let's say we have a vector of
26:23 - one and one
26:26 - what normalize would now do is convert
26:28 - these two numbers so that the vector
26:30 - overall has a length of one which in
26:34 - this case would get us the numbers
26:35 - something like 0.7 and 0.7
26:41 - I can actually demonstrate this a bit
26:43 - better so let me print a vector after we
26:46 - are normalizing it so now I want to
26:48 - print self dot Direction
26:52 - and run all of this again
26:54 - and we are already getting an error that
26:57 - we cannot normalize a vector with a
26:58 - length of zero and this should make
27:01 - sense
27:02 - for normalized to work Pi game needs to
27:04 - know in what direction the vector is
27:06 - pointing but if the vector is 0 and 0 it
27:09 - doesn't point in any direction so
27:11 - normalize wouldn't work
27:14 - but this we can fix quite easily all we
27:16 - have to do is check if the vector has
27:19 - any kind of length and this we get with
27:21 - self dot Direction dot magnet toot don't
27:25 - forget to call it and if this is greater
27:28 - than zero only then do we want to do all
27:30 - of this
27:31 - and now let's try it again if I move
27:34 - left and right we have a direction of
27:36 - one if I move up and down it is one as
27:39 - well but now if I move diagonally it's
27:41 - 0.7 or negative 0.7 and this is
27:44 - important to keep the speed constant
27:48 - and all right I hope that makes sense
27:50 - there is just one more thing that I want
27:53 - to do before we finish off this part and
27:55 - that is later on
27:57 - I have to work with these two lines more
28:00 - to implement the Collision mechanics and
28:03 - for that I have to separate
28:05 - these two lines into the horizontal
28:08 - movement and into the
28:12 - vertical movement
28:15 - so first of all I don't want to update
28:18 - the entire position Vector I only want
28:20 - to update for the horizontal part the X
28:23 - dimension
28:24 - so for example instead of updating
28:27 - position by itself I only want to update
28:29 - X
28:31 - and as a consequence we have to update
28:33 - the other Vector as well and update the
28:36 - rectangle 2 and this could be a really
28:38 - good exercise for you to finish off this
28:40 - section so if you want to code along
28:42 - pause the video now and try to update
28:44 - the vector and the rectangle
28:47 - and see how far you get
28:53 - for position.x we don't want to get the
28:56 - entire Direction Vector instead I only
28:59 - want to get X of the direction
29:01 - self.speed and Delta time can remain the
29:04 - same then for the rectangle I don't want
29:06 - to set the center I want to set the
29:08 - center X
29:09 - and then this should be self.post.x
29:13 - and with that we have the horizontal
29:15 - movement now I have to copy all of this
29:17 - give me some white space and paste it in
29:20 - here and now I basically have to switch
29:22 - all of these X's to a y
29:28 - and there we go the result in terms of
29:31 - if I run may not Pi again we are not
29:33 - going to see a difference but later on
29:36 - for the Collision we do want to have
29:38 - control over the horizontal and the
29:40 - vertical movement individually
29:43 - but this I will talk about in much more
29:45 - detail later on for now we have a pretty
29:48 - solid setup
29:49 - in this section we're going to import
29:51 - the player graphics
29:53 - and there's quite a lot of stuff that we
29:56 - have to import let me actually
29:59 - open the folder here we go and inside of
30:02 - Graphics we have the character and then
30:05 - here we have all of the different
30:07 - animations for example down is a down
30:10 - movement and here we have the player
30:12 - walking down
30:14 - and well we have to import all of these
30:18 - different animations
30:21 - now you could do all of this by hand and
30:24 - it would be possible but not really
30:27 - practical because there are way too many
30:29 - animations
30:30 - fortunately you don't have to you can do
30:32 - all of this with python to automate the
30:34 - entire process so let's have a look at
30:36 - all of this
30:38 - here we are back in the code and I want
30:41 - to work inside of the player and let me
30:43 - minimize all of the methods so things
30:46 - are a bit easier to read
30:48 - for the import I want to add another
30:51 - method let's call it import assets
30:55 - this one itself and nothing else and
30:58 - inside of here
31:00 - I basically want to create a dictionary
31:03 - called self dot animations and this
31:07 - dictionary
31:08 - is going to have a ton of key value
31:10 - pairs for example one key would be up
31:14 - and this would be up walking and then
31:17 - the value associated with this key would
31:19 - be a list with a bunch of surfaces that
31:22 - correspond to the up movement
31:25 - now for that I have this is something
31:29 - you do have to copy from the notes
31:31 - this is looking like this here are all
31:34 - of the different states the player could
31:36 - be having
31:37 - we have up down left and right these are
31:39 - the movement ones then we have all of
31:42 - those with idle then with the whole the
31:45 - X and the water
31:46 - these are all of the animations
31:49 - and these also correspond if I open the
31:52 - folder again
31:53 - here we have all of the different states
31:55 - and for the name corresponds with the
31:58 - key of this dictionary so we have down
32:00 - here and we have down here this is
32:03 - really important
32:05 - because what this allows us to do
32:09 - is I can do for animation in self dot
32:14 - animations dot ease
32:17 - don't forget to call it
32:20 - and in here first of all I'm going to
32:23 - need a full path
32:25 - and the full path is basically I have to
32:28 - go up one folder and I have to go to
32:30 - graphics and then I have to go to
32:32 - character and don't forget another
32:35 - forward slash
32:36 - and then I have to add the animation
32:39 - because the animation name is also the
32:41 - folder name
32:43 - let me demonstrate what this means here
32:46 - is the file setup again and right now we
32:49 - are working inside of the player and
32:52 - from there we have to go up one folder
32:54 - to the project then we go to Graphics
32:57 - then we go to character and now we have
32:59 - to select all of these different folders
33:02 - which is what we are doing with this
33:05 - line here along with the for Loop and
33:08 - now essentially all I want to do is get
33:10 - myself.animations dictionary target
33:14 - one
33:15 - of the key value pairs
33:18 - and then I have to actually import all
33:20 - of the services now this I'm going to do
33:22 - in a separate folder that I called
33:24 - import folder
33:26 - and this one is going to need the full
33:28 - path so it knows what to import
33:31 - and this import folder I generally put
33:33 - in a separate file because it's quite a
33:36 - handy one to reuse so let me create a
33:39 - new file that I want to save as support
33:41 - dot pi
33:43 - and in here we need a function called
33:46 - import folder
33:48 - and this one needs a path as a parameter
33:51 - but nothing else
33:53 - and this is what the player so inside of
33:56 - the player I want from support import
34:00 - everything
34:02 - so now we have to create this file here
34:05 - and let me add a bit of white space
34:07 - and now we can work on it first of all I
34:11 - want to create what I always call is
34:13 - surface list and this by default is
34:16 - going to be empty and in here we're
34:18 - going to store all of the surfaces and
34:21 - this is also what we are going to return
34:22 - at the end of this function
34:25 - so now we just have to figure out how to
34:29 - actually access the folder and for that
34:31 - we need a specific module
34:34 - is we have to import but it comes with
34:36 - python we need from OS import walk
34:40 - and walk allows you to walk through
34:43 - different folders
34:44 - let me actually demonstrate what it does
34:46 - so for let's call it folder in walk and
34:52 - then we have to pass in the path
34:55 - and that is the path we are getting from
34:57 - the parameters and we're just passing it
34:59 - through and I guess in here let me just
35:01 - print what we get the folder
35:04 - and now since we're calling this inside
35:06 - of the player we just need to make sure
35:08 - inside of the init method all the way at
35:11 - the beginning this is really important
35:13 - I want to self dot import assets
35:18 - and this has to be all the way at the
35:20 - top of the init method because later on
35:23 - when we create the image we need this
35:26 - self animations dictionary
35:28 - but now if I run out of this
35:31 - we are getting a ton of different things
35:34 - at the bottom and this is what walk does
35:38 - it basically returns a list
35:41 - with all of the contents of the folder
35:43 - for example the first folder here is the
35:46 - app folder this one doesn't have any
35:48 - subfolders and inside of this folder we
35:51 - have a couple of files they always
35:54 - called 0 1 2 and 3. they all have the
35:57 - same name but they are different files
36:01 - and this is what we want to use to
36:03 - import things now keep in mind a really
36:07 - important thing here is that all of
36:08 - these are just names we're not actually
36:11 - importing anything for pi game we are
36:13 - just going through a folder and looking
36:15 - at all of the file names but this is
36:17 - something we can definitely work with
36:18 - now first of all since this walk is
36:22 - returning a couple of things that we
36:23 - don't need we can unpack this quite a
36:27 - bit
36:27 - so the first one we get is the folder
36:31 - name
36:32 - the second thing we get is the always a
36:36 - list of subfolders and the final thing
36:38 - we get is the actual content let's call
36:41 - it image files now folder name and
36:44 - subfolder I just do not care about so
36:47 - I'm going to replace the folder name and
36:49 - the subfolder to underscores that way I
36:53 - indicate that I don't care about them
36:55 - so now let me print the image files and
36:59 - let's run main.pi again
37:01 - and now all I get is a list with names
37:04 - of images and this is what I really care
37:07 - about
37:08 - once I have that I need another for Loop
37:11 - because remember image files is another
37:13 - list so I need four let's call it image
37:17 - in IMG files
37:20 - and now let's keep on printing things if
37:23 - I now print the image and run this again
37:25 - I am always getting the name of the
37:28 - image for each file now this right now
37:31 - is a bit confusing because the name of
37:33 - each individual image is fairly
37:35 - repetitive but these are all different
37:37 - files in different folders
37:39 - so all we have to do now is to convert
37:42 - all of this into a full path so now I
37:46 - have to do three things to finish off
37:48 - this function first of all I need a full
37:51 - path and this full path is going to be
37:54 - the path we already have that's a path
37:56 - to the folder and then we have to attach
37:59 - the name of the image itself
38:01 - after we have that I can create an image
38:05 - surface so this is the inbuilt pygame
38:08 - surface that we actually want to create
38:11 - and once we have the surface I want to
38:13 - get my Surface list and append wow that
38:17 - is misspelled I want to append the image
38:21 - surface
38:23 - meaning we have to get the full path and
38:25 - the image surface and this I think could
38:28 - be a really good exercise for you try to
38:30 - combine the path to the folder and the
38:33 - image to get the full path and then for
38:35 - the image surface you have to import
38:37 - pygame and then use the full path to
38:39 - import one specific surface so pause the
38:43 - video now and try to figure this one out
38:44 - yourself
38:48 - ready for default path I want to get the
38:52 - path itself and this is getting me my
38:54 - folder and to that I want to add the
38:57 - image remember the image is just the
38:59 - name of the file not the actual image
39:02 - now this would almost work let me
39:05 - actually comment out these other two
39:07 - lines and let me print the full path you
39:11 - might already guess what the problem
39:12 - with this here is if I run this
39:16 - we have the name of the folder let me do
39:18 - this all the way at the top so up here
39:21 - for example is the name of the folder
39:23 - and then 0.png is the name of the file
39:27 - this is a really good start but we do
39:30 - need a slash to separate the two
39:33 - meaning in here besides the image
39:37 - we have to add
39:39 - a slash
39:43 - and now if I run this again
39:45 - we have the whole path towards this one
39:48 - specific image
39:50 - so I can remove the print statement and
39:54 - now I can actually use this full path to
39:57 - import an image as a surface now for
39:59 - that to work obviously I need Pi game
40:04 - and what I want to do in here is pygame
40:06 - dot image dot load and now I need the
40:09 - full path
40:10 - although important here you also have to
40:13 - add convert Alpha that way we are
40:16 - converting this image to something
40:18 - that's easier to work with in pi game as
40:20 - a consequence our code is going to run
40:22 - much faster
40:23 - now I can uncomment the append line and
40:26 - we should be good to go
40:29 - back in my player after I've run this
40:33 - for a loop I want to print self dot
40:37 - animations
40:38 - and let's see what we get
40:40 - that is looking pretty good we are
40:43 - getting a dictionary
40:45 - with a key and a ton of surfaces as the
40:50 - values
40:51 - now we don't know what each individual
40:54 - surface looks like but I'm pretty
40:56 - confident that this is going to work
40:58 - all we have to do now if I minimize this
41:01 - method here is when we are creating the
41:04 - image I have to pick one of these
41:07 - surfaces now for that we need a few more
41:10 - attributes to make all of this work
41:11 - efficiently
41:13 - and the way I approach this is I add two
41:16 - more attributes the first is self dot
41:18 - status and this could for example be up
41:21 - or it could be down or it could be
41:24 - something like down X if you want the
41:26 - downwards X animation but for now let's
41:29 - keep to down actually down idle is a
41:32 - good one I suppose
41:33 - besides that we need what I call the
41:36 - frame index and this by default is going
41:40 - to be zero now the frame index is going
41:42 - to make much more sense once we're doing
41:45 - the animations in the next bit well now
41:47 - don't worry too much about it
41:49 - how we are going to use all of this is
41:51 - instead of creating a plane surface I
41:55 - want to get myself dot animations this
41:58 - is a dictionary with key value pairs
42:01 - where each key is going to be accessed
42:03 - via this status meaning inside of this I
42:07 - want to access the key value pairs with
42:09 - self dot status
42:11 - and this list I am accessing with self
42:14 - dot frame index
42:17 - and now I can get rid of the image fill
42:21 - and we should be seeing the player let's
42:24 - try
42:25 - and there we go we have one frame of the
42:28 - player
42:29 - now since we don't have animations yet
42:31 - this doesn't look too impressive but
42:34 - well what you can do now for example
42:36 - this could be down X and let's try this
42:41 - one there we have the first frame of the
42:43 - X animation this could also be
42:46 - let's say left
42:49 - water and then we get this kind of
42:53 - Animation here oh well it's not an
42:54 - animation it's just the surface but we
42:56 - do have a very good start
42:59 - in this section we are going to animate
43:01 - the player now for that we are going to
43:05 - need quite a bit of logic so let's go
43:08 - through it one by one
43:09 - here we are back in the code and I want
43:12 - to keep on working in the player now for
43:15 - the animations to work there are two
43:17 - things we need first of all
43:20 - inside of
43:22 - the shelter animations dictionary we
43:25 - have to go through the list of services
43:27 - because they are the animation
43:30 - and this is actually a fairly simple
43:32 - method this we can start with in just a
43:34 - second the much more complicated bit is
43:38 - getting the self.status so we have to
43:41 - know if the player is moving or idling
43:43 - or using the x or the water or the whole
43:46 - and this is going to determine what
43:48 - animations we need getting the status is
43:50 - quite a bit more complicated but let's
43:53 - start with the actual animation that one
43:55 - is actually quite simple
43:56 - I first of all have to create another
44:00 - method let's call it animate this one
44:02 - itself and it also needs Delta time
44:05 - and basically what I want to do in here
44:08 - I want to get myself dot frame index and
44:12 - increase it in my case I went with four
44:15 - multiplied by Delta time
44:17 - and then after that I'm going to get
44:20 - myself dot image
44:22 - so what the Sprite actually looks like
44:24 - and I set this to self dot animations I
44:28 - get myself dot status
44:30 - and then I get myself dot frame index
44:35 - the way you have to think about it let
44:37 - me open the folder again and let's say
44:40 - for down inside of down we have four
44:43 - different images zero one two and three
44:46 - and we are using self.frame index to go
44:50 - through them so we have first zero then
44:52 - one then two and then three
44:55 - and all I'm really doing is I am
44:58 - increasing self.frame index to pick up
45:01 - all of these numbers that's literally
45:03 - all that's happening here
45:05 - however there are two major problems
45:07 - here number one is that we can only ever
45:11 - take the index with an integer but this
45:14 - operation here is going to return a
45:17 - floating Point number as a consequence
45:19 - this self.frame index has to be
45:22 - converted to an integer which is very
45:25 - easily done besides that the other
45:27 - problem is that each animation has a
45:31 - finite amount of frames for example down
45:33 - has four frames inside
45:36 - however this line here is going to be
45:39 - very quickly on a higher number than 4.
45:42 - so we have to make sure that we are
45:44 - always looping through this and this we
45:47 - are doing in an if statement if self dot
45:50 - frame index
45:52 - is greater or equal than the length of
45:56 - self Dot
45:58 - animations and then here once again I
46:02 - need self dot status if that is the case
46:05 - I want to set self dot frame index back
46:09 - to zero
46:10 - so what this one does if I open the
46:13 - folder again
46:14 - and let me try to get everything on the
46:18 - screen
46:22 - something like this looks good
46:26 - we are basically starting with
46:28 - self.frame index being zero which is
46:31 - getting us this first image here
46:34 - after that we are increasing the frame
46:36 - index by a certain number
46:39 - and then down here we're getting the
46:42 - integer of that number so at some point
46:45 - this is going to be one this is going to
46:47 - be 2 and this is going to be 3.
46:51 - after that we're going to end up with a
46:54 - number larger than 3. so we are going to
46:56 - be somewhere down here
46:59 - which would be causing an error and for
47:01 - that we have this line here
47:04 - this one is making sure that this
47:07 - doesn't happen and instead we're moving
47:09 - back to zero
47:11 - and with that we have prop animations
47:14 - all that's left to do now is to actually
47:16 - call it so inside of update all the way
47:19 - at the end I want self dot animate
47:23 - don't forget to pass in Delta time in
47:25 - here and now if I run this
47:30 - now the watering animation isn't great
47:33 - but the animation for down does look
47:36 - much better
47:37 - so
47:39 - here we go this is down movement if I
47:42 - just move down this is already looking
47:43 - pretty good
47:45 - and what I actually want to start with
47:47 - is down idle
47:50 - if it runs now there we go we have the
47:52 - player idling and looking straight at us
47:55 - this is looking really good
47:57 - so this was the easy bit now we have
48:01 - animations the one thing we now have to
48:04 - figure out is how to set this
48:06 - self.status to capture all of the
48:09 - different animation States and there are
48:12 - quite a few different states we have to
48:14 - account for all of these
48:17 - the really easy ones we can get in input
48:20 - because in here if we are for example
48:23 - pressing up we know that the player is
48:25 - moving up which means in this we can set
48:28 - self dot status
48:30 - to something like up
48:33 - then I can copy this and change this to
48:35 - down copy it again and change it to
48:39 - right and copy it one more time
48:41 - and change it to left
48:45 - and with that we already have the
48:47 - walking directions so now if I start all
48:49 - of this
48:50 - I can move left right up and down and we
48:54 - already have some very basic animations
48:56 - that look pretty good
49:01 - really good start
49:02 - besides that let me minimize input
49:06 - I want to check if the player is idling
49:09 - so if we go for example from moving up
49:11 - and we stop moving then I want to switch
49:14 - to up idle which in practice means I
49:18 - have to add underscore idle to the
49:21 - status of the player
49:23 - and to do all of that I want to create
49:26 - another method let's put it below input
49:30 - and yeah I want to get
49:32 - status
49:34 - needs itself and nothing else and in
49:38 - here
49:39 - I want to check if the player is not
49:43 - moving
49:44 - then I want to add underscore idle to
49:48 - the status
49:51 - and again if you want to code along this
49:53 - could be a really good exercise for you
49:55 - so try to figure this one out yourself
49:58 - and see how far you get if you want a
50:00 - tip this should be doable in two lines
50:03 - of code
50:07 - first of all we have to figure out if
50:10 - the player is moving or not and this we
50:12 - have actually already done this happened
50:14 - inside of move because we know if
50:18 - self.direction. magnitude so the length
50:21 - of the direction Vector if that is zero
50:23 - we are not moving so I can just copy it
50:26 - minimize the move method
50:28 - and now
50:31 - if the magnitude is equal to zero then I
50:35 - know the player is not going to move
50:38 - which is covering the first bit let me
50:41 - put it at the top here besides that I
50:44 - have to add underscore idle to the
50:46 - status
50:48 - which in a very simplified way would
50:50 - just be self dot status plus equal
50:54 - underscore idle and don't forget this is
50:58 - supposed to be a string
50:59 - all we are really doing for the status
51:01 - here is we are manipulating different
51:03 - strings to represent the status of the
51:06 - player that's literally all it is
51:10 - now this is a good start but it would
51:14 - cause a problem really really quick
51:16 - let me actually demonstrate so after I'm
51:19 - getting the input and before I am moving
51:21 - or animating I want to get self.get
51:24 - status
51:26 - and now if I run main.pi
51:29 - we're getting an error that we have a
51:32 - key down idle and idle
51:35 - and basically what happened here is that
51:37 - if the player is not moving python keeps
51:40 - on adding underscore idle towards the
51:42 - status we're not stopping at one we're
51:45 - adding more and more and that way we are
51:47 - getting an error so we have to make sure
51:49 - that we only ever have a single
51:51 - underscore idle in this status
51:54 - which we can get very easily all we need
51:56 - is self dot status
51:59 - dot split
52:02 - and I want to split wherever we have an
52:05 - underscore and then pick the index 0.
52:09 - this one here is going to return a list
52:12 - and the first item of this list is
52:14 - always going to be the status so this
52:16 - would be up down left right and so on
52:19 - and only to that I want to add the
52:22 - underscore idle that way we will only
52:24 - ever have a single idle inside of any
52:27 - kind of status
52:28 - and this I want to assign I don't want
52:30 - to add it to the status
52:33 - and now
52:34 - the player is idling and if I move
52:36 - downwards we are walking this also works
52:39 - with up it works with left it works with
52:42 - right and this is looking really good
52:45 - so now we have some basic animations
52:48 - that are definitely improving already
52:52 - so let me get rid of the comments here
52:55 - and
52:57 - we have the first bit covered
53:01 - the other bit we need is the tool use I
53:05 - guess let me add General comments here
53:07 - to make this a bit easier to follow
53:09 - let's call this the movement
53:12 - actually the idle is better
53:16 - now for the tool use the code is getting
53:19 - quite a bit more complex because besides
53:22 - get status we also have to add the input
53:25 - and we have to be able to select
53:27 - different kinds of tools
53:29 - so let's do all of this in a separate
53:32 - section
53:33 - so let's work on the tools for this to
53:36 - work we need a few parts that
53:37 - interconnect quite a bit so well let's
53:41 - Jump Right In and let's have a look at
53:42 - all of this once again here I have
53:45 - main.pi and I want to keep on working
53:48 - inside of layer and specifically I want
53:51 - to work inside of the init method and in
53:54 - here I want to add another section let
53:57 - me call this one tools
53:59 - and for now I want to add one more
54:01 - attribute that I call selected tool
54:06 - and this could for example be an X it
54:10 - could be a whole or it could be water
54:12 - short for watering can I guess for now
54:14 - let's stick with the ax that one is
54:16 - really easy to see
54:18 - and for now we don't have any way in the
54:21 - game to change the tool that's going to
54:23 - be in the next section because I do want
54:25 - to keep things a bit more organized but
54:28 - well now that we have the select a tool
54:31 - I want to go to my input and then here
54:34 - besides the directions let me actually
54:37 - add a comment directions
54:40 - I want to add another section and let me
54:44 - call this one tool use
54:46 - and in here first of all I want to check
54:49 - if we are pressing a certain key which I
54:51 - get with if keys and then pygame dot in
54:56 - my case for the tool I have k space
55:00 - now basically what I want to do in here
55:03 - is if this condition is true
55:06 - I want to run a timer for the tool use
55:13 - so for example if the player is pressing
55:15 - space then we should have half a second
55:17 - of tool use being activated in some sort
55:20 - of timer
55:22 - and if that timer is active inside of
55:24 - get status we are always adding
55:26 - underscore X to this status
55:29 - now for that we need a timer and this is
55:33 - not inbuilt into Pi game so we have to
55:35 - make it ourself
55:36 - and this I'm doing in a separate file
55:38 - and this one I want to save as timer dot
55:42 - pi
55:43 - and here as always we have to import Pi
55:46 - game after we have that I want to create
55:49 - a class timer
55:51 - and this one needs a Dunder init method
55:54 - in here we need itself we need a
55:57 - duration
55:58 - and then we need a function that by
56:01 - default is going to be none
56:03 - the duration should make sense this one
56:05 - is really simple it's just how long the
56:07 - timer is going to be the function is
56:10 - going to be if we want to execute some
56:12 - code once the timer has run out
56:15 - something we are going to see in just a
56:17 - second but for now don't worry too much
56:19 - about it
56:20 - inside of this I want to create some
56:22 - attributes so duration is going to be
56:26 - duration
56:27 - and self dot Funk is going to be Funk so
56:31 - we're just capturing the parameters
56:33 - besides that I want to have two more I
56:36 - want to have self dot start underscore
56:39 - time this one is zero and then I want to
56:42 - have self DOT active and this by default
56:46 - is going to be false and for this timer
56:49 - we have a couple of methods we have
56:53 - activate
56:55 - we have
56:58 - deactivate and we have up date
57:02 - and all three will need self but no
57:06 - other parameter besides that
57:08 - and let me go through how the timer is
57:11 - going to work we always start at some
57:13 - kind of start time Zero by default and
57:16 - this is what we are getting here
57:19 - after we have declared that we will
57:21 - continuously check the time which means
57:24 - we're checking the time here here here
57:26 - here here here here and so on
57:29 - continuously throughout
57:31 - and besides that we also have a duration
57:35 - and the duration could for example be
57:37 - let me put it here at 300 milliseconds
57:42 - and now all we are really going to do is
57:44 - we are continuously checking if these
57:46 - red dots are before or after the 300
57:52 - meaning once that is the case we want to
57:54 - run some code so let's Implement that
57:57 - first of all for activate this one is
58:00 - very simple what I want to do in here is
58:02 - if the timer is active I want to set
58:04 - active to true
58:07 - and besides that I also want to set self
58:10 - dot start time to
58:14 - pygame.time.get underscore ticks
58:18 - this is really important because this
58:21 - starting time here doesn't necessarily
58:23 - have to be zero
58:25 - we could very well start a timer at some
58:27 - point in our game
58:29 - so this zero might be something like
58:31 - 1240
58:34 - which means we started a timer about one
58:36 - second into the game we're doing all of
58:38 - this in milliseconds
58:40 - and if the timer has a duration of 300
58:43 - then this number here would be
58:47 - 1540. so these numbers are all relative
58:49 - it's really important for all of this to
58:51 - work
58:52 - now besides that if I want to deactivate
58:55 - the timer I want to set self DOT active
58:58 - to false and just to be sure self dot
59:02 - start time is going to be zero
59:04 - finally inside of update the actual
59:08 - timer happens and this is some horrible
59:11 - spelling there we go first of all inside
59:13 - of update I want to have my current time
59:16 - and this I get with
59:19 - pygame.time.get underscore ticks
59:22 - the same line we have used up here the
59:24 - difference now is that this update
59:26 - method will be called continuously which
59:29 - means that this
59:31 - highgame.time.getix will always get our
59:33 - current time
59:35 - and basically what I want to check is if
59:38 - my current time minus my self thought
59:41 - start time is greater or equal than self
59:46 - dot duration for example if my current
59:50 - time is something like 1500 my start
59:53 - time is something like 1000 and my
59:57 - duration is something like 300
60:01 - then the result here would be 500 is
60:04 - greater or equal than 300 which would be
60:06 - true so our timer should have run out
60:10 - now if that is the case first of all I
60:14 - want to self dot deactivate the timer I
60:17 - want to run all of this here
60:19 - besides that in case we have defined a
60:23 - function we want to run if the timer has
60:25 - run out
60:27 - I want to check if self.funk so if a
60:30 - function exists and if that is the case
60:32 - I want to call Self dot bunk
60:36 - and with that we have a timer class that
60:39 - we can use inside of the player now for
60:42 - that first of all we have to import it
60:46 - which we do with from timer import timer
60:52 - and with that covered I want to add
60:54 - another section let me put it before the
60:57 - tools and this I'm going to call timers
61:00 - in here I want to create a dictionary
61:02 - that I call timers
61:05 - in here we have a couple of key value
61:07 - pairs the key is just the name of the
61:10 - timer let's call this one tool use and
61:13 - now I can create a timer and let's say
61:16 - for the tool use I want to have a
61:18 - duration of 350 milliseconds
61:21 - and once this has run out I want to call
61:24 - a function that I called
61:27 - self.use underscore tool
61:30 - really important here you do not want to
61:33 - call this function you just want to pass
61:34 - it into this class
61:36 - and this one doesn't exist right now so
61:39 - we do have to create it let me put it
61:41 - actually right at the top here so things
61:43 - are easier to see
61:45 - so use tool
61:48 - and this one needs self and nothing else
61:51 - now this used tool for now is not going
61:54 - to do anything all I want to do is print
61:56 - let's say self dot selected tool
62:00 - later on this one is going to do quite a
62:02 - bit more but for now I just want to
62:04 - minimize it more importantly for now
62:06 - inside of the input
62:10 - I want to get myself dot timers and in
62:15 - here
62:17 - the tool use timer the one we created
62:21 - just a second ago
62:23 - and this timer I want to activate
62:26 - and now this we can use inside of get
62:29 - status
62:31 - and really all I want to do is if self
62:34 - dot timers and Tool use if this one is
62:40 - active then for now let me print tool is
62:46 - being used
62:49 - and let's try if this one is working
62:53 - so now if I press space we get tool is
62:56 - being used so something is happening but
62:59 - this is looking weird and it never stops
63:03 - so we do have to make some adjustments
63:05 - here
63:06 - now first of all the one thing I do want
63:08 - to change is the player should not be
63:10 - able to move once we are using a tool
63:13 - which means once this timer is active
63:16 - the player shouldn't be allowed to do
63:18 - anything else
63:19 - and for that I want to indent all of
63:23 - this one level
63:25 - and I want to have an if statement if
63:28 - not self dot timers and Tool use
63:34 - if this one is active
63:37 - so only if we are not using a tool the
63:40 - player is allowed to move around and to
63:44 - use a tool we couldn't use a tool if the
63:46 - player is already using a tool that
63:49 - should make sense
63:51 - now besides that I also want to set self
63:54 - dot direction to an empty Vector so
63:57 - pygame.math.vector2
64:00 - the reason is think of if the player is
64:04 - moving to the right and then starts
64:07 - using a tool here
64:08 - if we didn't add this line here the
64:11 - player would just keep on moving to the
64:14 - right while using the tool which would
64:16 - be very strange and we wouldn't be able
64:18 - to stop it because remember the player
64:21 - is not allowed any kind of input while
64:23 - we are using a tool so we have to stop
64:25 - the player otherwise we would get some
64:27 - weird results
64:29 - but once we have that
64:32 - inside of get status
64:35 - all I really want to do is update my
64:38 - self.status
64:40 - so that I have a string that could for
64:43 - example be right and X so X is going to
64:48 - be what we are getting from our selected
64:52 - tool
64:53 - could also be whole or could be water
64:54 - but for now I want to keep it with x
64:57 - meaning this is going to work kind of
65:00 - like this line here except now we're
65:02 - adding a different word under after the
65:04 - underscore
65:05 - which means this could be a really good
65:08 - exercise for you
65:10 - copy this line here and adapt it so you
65:13 - are incorporating the selected tool let
65:16 - me minimize the input so we can see it a
65:19 - bit better if the timer is active you
65:22 - are supposed to have the status so up
65:25 - left down or right plus an underscore
65:27 - plus the X
65:32 - all right all you have to do is first of
65:34 - all copy this line here or this part of
65:38 - the line so we just have up left down or
65:41 - right by itself and to that I want to
65:44 - add an underscore and then I want to add
65:49 - self dot selected tool
65:52 - and with that we should be good to go
65:55 - let's try this one now and now if I
65:58 - press space
66:00 - we have something
66:02 - so we do have animation the problem is
66:04 - the animation never stops
66:07 - which I guess is a start but we do have
66:10 - to work on it the main reason why this
66:12 - happens is because we don't actually
66:14 - update these timers what I forgot to do
66:16 - is to call this update method
66:19 - continuously
66:20 - and to do that let's put all of this in
66:23 - a separate method although it's going to
66:25 - be a very short one
66:27 - let's call it update timers this one
66:31 - itself and nothing else as always and in
66:34 - here all I want to do is for a timer in
66:36 - self dot timers dot values
66:41 - because remember we have several timers
66:44 - as an attribute this one is a dictionary
66:46 - and then the key is the name and the
66:49 - value is the actual timer and this is
66:52 - what we are getting here
66:53 - and all I want to do is call timer dot
66:56 - update
66:58 - and now inside of the update method of
67:01 - the player I want self dot update timers
67:05 - and now let's try this again
67:09 - so now we have a animation that is very
67:14 - inconsistent though
67:16 - and the reason why that is happening
67:20 - is
67:23 - let me go back to input
67:27 - in here we have to add one more line
67:30 - and that line is going to be self dot
67:33 - frame index is going to be zero the
67:36 - reason we need that is let's say we have
67:39 - our frame indexes could be 0 1 2 or 3.
67:43 - and essentially what we are doing is we
67:45 - always go from one to the other to the
67:48 - other and then we are going back to the
67:51 - start
67:52 - when we are pressing space so this line
67:55 - here we want to play a new animation
67:59 - the problem is frame index doesn't know
68:02 - that so when we start this animation we
68:05 - might already be on frame index being 2
68:07 - and as a consequence we are playing not
68:10 - the first frame but we are playing one
68:12 - frame that is already maybe at the end
68:14 - of the animation which would be looking
68:16 - very strange
68:18 - and if we add frame index being 0 this
68:21 - is being fixed we always start the
68:23 - animation from the start so now let's
68:25 - try this again
68:27 - and there we go we have
68:30 - a proper X animation this one looking
68:33 - quite nice
68:35 - what you could also do is replace this x
68:38 - with a hole
68:41 - and now we have the whole
68:44 - and you could also change it with water
68:47 - and if I do that we have the watering
68:50 - can
68:51 - so with that we have our different tools
68:54 - although we are not able to change
68:56 - between different tools and we also
68:58 - can't see which tool is currently being
69:00 - selected
69:02 - I guess let's work on that in the next
69:03 - major part
69:05 - in this part we are going to work on
69:08 - switching between the different tools
69:10 - and since we already have timers there
69:13 - isn't actually that much to do so let's
69:16 - Jump Right In and let's have a look at
69:18 - all of this
69:19 - back in the code I want to keep on
69:21 - working inside of player.pi
69:24 - and now first of all I want to check if
69:28 - the player is pressing a button to
69:29 - change the tool this happens inside of
69:32 - input
69:33 - a in here
69:35 - I want to add another section let's call
69:37 - it change tool and for this one I want
69:41 - to check my keys again and then here
69:43 - pygame dot k underscore Q
69:47 - so we are pressing the Q button on the
69:49 - keyboard I couldn't really think of a
69:51 - better one if you can't find a better
69:53 - key just go with that if that is the
69:56 - case I want to do something now what
69:59 - that something is going to be
70:00 - is going to be determined inside of the
70:03 - init method so right now the selected
70:06 - tool is always going to be one specific
70:09 - string but I want to make this a bit
70:11 - more flexible
70:13 - and what I want is first of all I want
70:15 - to have an attribute that is called
70:17 - tools and in here we have the whole
70:21 - we have the X and we have water
70:25 - and besides that I want to have a seat
70:28 - in text and this by default is going to
70:32 - be zero
70:33 - and then when we select the tool I am
70:36 - not going to get a string instead I want
70:39 - to have self dot tools and then self Dot
70:44 - this shouldn't be seed this should be
70:46 - tool index sorry about that
70:48 - so I want self.tool index
70:52 - and right now since our tool index is
70:55 - zero we are picking the first element
70:58 - from this list
70:59 - and what I basically want to do inside
71:04 - of this if statement here is I want to
71:08 - self dot tool index plus equal one
71:13 - and after we have that I want to update
71:16 - myself dot selected tool
71:19 - and this is just going to be self dot
71:22 - tools and then self dot tool index
71:27 - now this is fine in theory but in
71:29 - practice this is going to break let's
71:31 - actually try
71:32 - so main.pi I want to run it and now if I
71:35 - press Q
71:36 - we are getting list index is out of
71:39 - range
71:41 - the reason is
71:42 - to us pressing q1 might just be pressing
71:46 - Q once to pie game it looks like we are
71:49 - pressing Q for a certain amount of time
71:51 - and it keeps on adding this plus 1 to
71:54 - the tool index continuously
71:57 - I can actually visualize this that is
71:59 - much better than explaining it so if I
72:03 - print the tool index and run this again
72:05 - and if I now press Q
72:08 - we are getting one two and three and
72:13 - then we are running out of numbers and I
72:16 - should get rid of the print statement
72:18 - let me look for it really quick
72:20 - let me comment out this print statement
72:22 - here and let me just add a pass in here
72:25 - that way it's a bit easier to see what's
72:27 - going on if I now press Q
72:29 - we're getting one two and three and then
72:33 - we're getting an error because we are
72:35 - trying to use these numbers for indexing
72:37 - and this list doesn't have to have many
72:39 - indexes
72:42 - as a consequence we are getting an error
72:44 - and the problem is that pygam tries to
72:47 - add more and more numbers
72:49 - the way around that is we need a timer
72:52 - that after every time we are pressing
72:54 - the button we want to wait a couple of
72:57 - milliseconds
72:58 - now fortunately we already have a very
73:01 - good system to work with timers so I
73:04 - want to create another timer and this
73:07 - one I call tool switch
73:10 - and this one is going to be another
73:11 - timer
73:13 - and this one has a duration of 200
73:15 - milliseconds
73:17 - there is no second argument because we
73:19 - don't really want to call it function
73:20 - after this one is over we just care if
73:23 - this time as active or not
73:25 - once we have that
73:27 - and not self dot timers and in here I
73:33 - want tool switch
73:35 - DOT active the player should only be
73:39 - able to change the tool if we are
73:41 - pressing q and if the tool switch timer
73:44 - is not active inside of the if statement
73:47 - the first thing that we are going to do
73:48 - is self dot timers and tools which and
73:54 - this timer I want to activate
73:57 - that way we are only ever adding a
73:59 - single number to this tool index and
74:02 - we're not doing it continuously
74:05 - so now let's try this again if I press Q
74:07 - we get one we get two now we get three
74:10 - and we're getting an error this error we
74:13 - are getting because even though now I am
74:16 - only adding a single number we can still
74:19 - add as many numbers as we want but what
74:22 - I want to do instead
74:24 - is that if we are exceeding the length
74:28 - of this list I want to set the tool
74:30 - index back to zero
74:34 - so if tool index is greater than length
74:40 - of tools then I want to set the tool
74:44 - index to zero and this could be a really
74:48 - good exercise for you so if you want to
74:50 - code along possibly now and try to
74:52 - figure this one out yourself this should
74:54 - be doable on a single line of code
74:56 - although two would also be doable
75:02 - alrighty basically all I want to do is I
75:05 - want to set myself dot to index and now
75:09 - I want to get
75:11 - self.tool index by itself
75:14 - but this only if a certain condition is
75:17 - true and that condition is self dot tool
75:21 - index
75:23 - is smaller than the length of self Dot
75:27 - tools
75:29 - and if that is not the case so else I
75:33 - want to set tool index to zero
75:36 - and now let's try this again now I can
75:39 - press Q we get 1 2 0 1 2 and so on
75:43 - and I can never go beyond the length of
75:46 - self.tools
75:49 - and now
75:50 - we already have all of the tools
75:54 - because remember we are updating our
75:57 - selected tool and this is what we're
75:59 - using inside of the status so we don't
76:02 - have to make any more changes this is
76:04 - all we need
76:06 - so with that we are able to change our
76:08 - tool
76:09 - wasn't actually so bad or at least I
76:12 - hope this wasn't too difficult
76:15 - now while we are here we can go in two
76:18 - different directions now
76:20 - we can either work on the overlay or we
76:22 - can work on the seats now I think it's
76:25 - best to start with the seeds because the
76:27 - seeds work basically in the same way as
76:29 - the tools do and once we have that we
76:32 - can create the entire overlay in one go
76:34 - so let's do the seats right now
76:37 - and this is going to be
76:40 - started inside of the Thunder and it
76:43 - method right below tools and here I want
76:46 - to have my seats
76:49 - and for the seats I want to have self
76:51 - dot seeds and in here we only have two
76:55 - we have corn and we have tomato
77:00 - then we have self dot seed index and
77:03 - this by default is going to be zero and
77:05 - then we have self dot select hit
77:08 - underscore seed and this is going to be
77:11 - self dot seed index
77:15 - we are basically doing the same thing we
77:17 - have done for the tools except now we
77:19 - are storing all of this in different
77:21 - attributes
77:24 - which means now the tool use and the
77:26 - change tool are going to be very similar
77:29 - as well
77:31 - we have a seat use
77:34 - and we have a change seat part
77:39 - and those are going to be very similar
77:41 - compared those two as a consequence this
77:43 - could also be a really good challenge so
77:46 - try to copy those two
77:49 - to update this seat
77:52 - if you want to start if the player is
77:55 - pressing Ctrl or left control then I
77:57 - want to use a seat and if the player is
78:00 - pressing e then I want to change the
78:02 - seat
78:04 - so pause the video now and see if you
78:06 - can figure this one out
78:07 - and remember here you are going to need
78:10 - some more timers
78:15 - all right let's try it together now
78:17 - first of all I need two more timers
78:20 - because I have a tool use I have a tool
78:22 - switch besides that let me actually
78:24 - duplicate both of those
78:29 - I want to have a seat use and a seat
78:32 - switch
78:34 - and for the seed use I want to have a
78:36 - method called use seed
78:40 - and you could change the numbers here I
78:43 - really don't care about it
78:45 - now first of all
78:47 - I have to create another method just
78:50 - like use tool I need use underscore seed
78:54 - need self and nothing else and for now
78:56 - let me add pass in here
78:59 - then I can minimize the function and now
79:03 - we can work on duplicating these two
79:06 - lines
79:07 - and we are very much duplicating them so
79:10 - let me copy and paste things
79:11 - first of all if keys and now we are
79:14 - checking hey underscore
79:18 - and the name for the left control button
79:20 - is l c t r l
79:23 - short for left control
79:26 - if that is the case
79:30 - I want to activate my seduce timer
79:33 - and the other two lines I want to keep
79:36 - as they are
79:37 - after that I want to copy the if
79:40 - statement for change tool
79:42 - and this one is going to be k e and not
79:47 - timers seat switch
79:50 - if that is the case I want to activate
79:52 - my seat switch timer and now the index
79:56 - here is going to be
79:59 - for the seat
80:02 - so I'm basically replacing tool with
80:04 - seat and that is all we are going to
80:07 - need in here
80:09 - now unfortunately there's no animation
80:11 - for the seat so instead what I want to
80:15 - do is I just want to print
80:18 - let's say for left control use seed
80:24 - and then for change seat I want to print
80:26 - self dot selected seed so we can tell
80:30 - what's going on and now let's try
80:34 - and we're getting an error that I made a
80:37 - typo somewhere
80:40 - so inside of the init method
80:44 - this method here should be UC not used
80:47 - seed so now let's try this again and
80:50 - there we go if I press left control we
80:53 - get use seat
80:54 - and if I press e we get I have a corn or
80:58 - tomato
80:59 - so this is working really well
81:03 - and with all of that we have a ton of
81:07 - different inputs for the player without
81:09 - too much work actually
81:12 - so let me remove the print statements
81:14 - and now I can minimize the input this
81:17 - one is getting quite chunky
81:19 - okay I'm quite happy with this section
81:22 - so in the next section we are going to
81:24 - work on the overlay so we can tell
81:25 - what's going on
81:27 - in this section we are going to create
81:29 - the overlay which honestly isn't all
81:32 - that difficult all we essentially are
81:35 - going to do is put some images on top of
81:37 - the entire game
81:40 - and then those images are going to
81:42 - change depending on what the player has
81:43 - selected both for the tool and for the
81:45 - seats so let's Jump Right In once more I
81:49 - have main.pi open and I want to create a
81:52 - new python file that I'm going to save
81:54 - as overlay dot pi
81:57 - in here I want to import Pi game and
82:01 - also I need from settings import
82:03 - everything
82:05 - and now I want to create a class called
82:08 - overlay
82:10 - there's no need for inheritance and I do
82:13 - need a thunder init method
82:16 - we need itself as always and now we also
82:19 - need the player because the overlay
82:21 - needs to know what the player currently
82:23 - has selected
82:25 - inside of that I want to have a general
82:28 - setup in here we need two things first
82:31 - of all I need self dot display surface
82:35 - that is the same thing we have done
82:37 - inside of the level this way we can draw
82:40 - straight on the display surface and we
82:43 - can keep all of this inside of the
82:45 - overlay class
82:47 - display dot get underscore surface
82:53 - besides that I want to store the player
82:55 - in an attribute so self dot player is
82:59 - going to be player
83:01 - besides that I need to do some imports
83:05 - because in here I need self.tools and
83:09 - self dot seats
83:11 - and those are not the same seeds and
83:13 - tools that the player has instead let me
83:16 - rename it actually these are all
83:18 - surfaces more specifically they are
83:21 - dictionaries with key value pairs
83:25 - for example one key for the tools could
83:27 - be X and then the value would be a
83:30 - surface of an ax
83:32 - now for that we have to import a couple
83:35 - of images let me show you what we are
83:37 - going to import actually
83:40 - here is the project folder I want to
83:42 - look at graphics and inside there we
83:45 - have overlay inside of that we have X
83:48 - corn hoe tomato and water and this is
83:51 - what we want to import
83:55 - now here you could import everything
83:57 - manually but once again that's not
84:00 - really a pleasant way to work in well
84:02 - any programming language so I'm going to
84:05 - use dictionary comprehension
84:07 - how that is going to work for the tool
84:09 - surfaces I want to have a tool and this
84:13 - is going to be the key and then I want
84:15 - to have a surface as the value and this
84:17 - I want to do for Tool in layer dot tools
84:23 - which means inside of player
84:26 - I want to look at all of these tools and
84:30 - from this data I want to create a key
84:32 - value pair
84:34 - and the tool can actually remain the
84:36 - same so if we leave it like this the
84:38 - tool or the key would be whole X or
84:41 - water which is totally fine
84:43 - the one thing we have to change is the
84:45 - surface
84:47 - what I want to do in here is pygame dot
84:50 - image dot load and inside of that we
84:54 - need an F string now to keep things a
84:57 - bit shorter I want to store the path
84:59 - separately so let me call it path
85:01 - actually let's call it overlay path that
85:04 - makes a bit more sense
85:06 - and all this is is a string we go up one
85:10 - folder we go to graphics
85:13 - and then we go to Overlay and don't
85:15 - forget the final forward slash
85:18 - and this I want to use inside of this F
85:20 - string so overlay path
85:23 - after that I want to look at the tool
85:27 - so the tool could either be X whole
85:29 - water or could be one of the seeds and
85:32 - this is also how each of the files here
85:35 - are named so this is very handy finally
85:38 - one important thing don't forget we are
85:41 - looking at PNG files also really
85:43 - important you want to convert Alpha all
85:47 - of this which makes all of this fairly
85:49 - long but very easy to work with and once
85:53 - I have that
85:55 - I can copy the entire thing
85:57 - and paste it in here and all I really
85:59 - have to do is to replace tool
86:02 - with seed make sure you call this
86:05 - player.seeds and then this tool should
86:09 - also be seed
86:11 - but other than that we should be good to
86:14 - go
86:15 - let me actually print
86:17 - tool surface and
86:21 - seats surface just to make sure that
86:24 - this is working oh actually we have to
86:26 - create the object from the class first
86:28 - of all
86:28 - and this happens inside of level
86:31 - so in level I want from overlay import
86:36 - overlay
86:38 - and now when we are creating everything
86:40 - I want to create self dot overlay
86:45 - and this is going to be the overlay
86:48 - class and then here don't forget we have
86:50 - to pass in self Dot player
86:54 - now for that to work you have to create
86:57 - this overlay after the setup method
86:59 - because inside of setup we are creating
87:01 - the player
87:02 - and now once we have that let's run
87:05 - main.pi and we are getting an error the
87:08 - name Tool surface is not defined let's
87:10 - have a look
87:12 - ah I forgot
87:15 - self here
87:16 - now let's try this again and there we go
87:20 - we're getting dictionaries with key
87:22 - value pairs that all look pretty good
87:25 - cool I'm very happy with this so now we
87:29 - have access
87:30 - to the player and we have all of the
87:32 - services that we do need all I have to
87:35 - do now is to create another method and
87:37 - let's call this one display
87:40 - in here we need self and nothing else
87:42 - and now I want to show the tools and I
87:47 - want to show the seats
87:49 - and for this one first of all I need the
87:52 - tool surface because right now we have a
87:55 - dictionary with key value pairs but what
87:58 - we want is one specific surface we have
88:02 - to select one surface from this
88:04 - dictionary
88:05 - and this we get with self dot tools
88:09 - surfaces
88:11 - and what I want to select from here is
88:13 - self dot player dot selected tool
88:18 - remember here the selected tool could
88:21 - either be X it could be whole or could
88:23 - be water
88:24 - and this is also what we're using as a
88:27 - key inside of Tool's surface
88:29 - and let's actually try so I want to
88:32 - display this tool and this I get with
88:35 - self.displaysurface DOT lit enter here I
88:39 - need a surface which is my tool surface
88:42 - and for now I'm going to place this at
88:44 - position 0 and 0.
88:48 - with that covered I have to make sure I
88:51 - actually call the display method of
88:53 - overlay and this happens after we are
88:57 - drawing all of the Sprites you could
89:00 - just run this line all the way at the
89:01 - end of the run method so in here self
89:04 - dot overlay dot display and now let's
89:09 - try
89:10 - and now in the top left I can see my
89:12 - selected tool and if I change my
89:15 - selected tool this graphic updates as
89:17 - well so this is very nice the problem is
89:20 - it shouldn't be in the top left
89:22 - and for that we have to update these
89:25 - numbers here
89:26 - or to have a bit more control I want to
89:29 - create a tool rectangle
89:31 - and this one we get with tool surface
89:35 - dot get underscore rect and in here
89:38 - since I want a tool to be in the bottom
89:41 - left I want to place the mid bottom and
89:45 - the position here I am storing in my
89:48 - settings because in there I have overlay
89:51 - positions that way it's a bit easier to
89:54 - adjust all of the settings later on
89:55 - there are a lot more similar
89:58 - dictionaries in here as well
90:00 - so these are the numbers I do want to
90:02 - use
90:03 - which is quite simple all I have to do
90:06 - is I have to get my overlay
90:09 - positions let me just double check if I
90:12 - spelled this correctly actually let me
90:14 - copy all of this and paste it in here
90:16 - that looks pretty good
90:18 - and in here I want to get my tool
90:21 - and now when I am using the blit method
90:26 - I want to use my tool rectangle for the
90:29 - positioning
90:30 - and now let's run this again and this is
90:33 - looking really good
90:34 - and with that all we have to do now is
90:37 - to copy all of this for the seeds and I
90:40 - think this could be a really good
90:41 - exercise for you basically what you want
90:44 - to do is copy all of this except now it
90:46 - should be for the seeds so pause the
90:48 - video now and if you want to follow
90:49 - along try this one yourself
90:54 - just as before I want to create a seed
90:58 - surface and this I get with self dot
91:01 - seed surfaces and in here self dot
91:05 - player dot selected underscore Siege
91:10 - after I have that for the positioning I
91:12 - want to get a seed underscore rectangle
91:16 - and this I get with my seed surface this
91:20 - should not have an S
91:22 - and get underscore wrecked once again I
91:25 - want to place the mid bottom and the
91:28 - position here I can copy it from the
91:31 - tools
91:32 - I want to get my overlay positions and
91:35 - get the key seat
91:37 - that is going to be this one here
91:39 - finally all I have to do is self dot
91:42 - display surface dot lit
91:45 - and I want to have my seed surface
91:49 - and then my seed rectangle
91:52 - and with that
91:54 - let's run main.pi and we are getting an
91:56 - error that I forgot
92:00 - the square brackets here
92:02 - now let's try this again and there we go
92:04 - now in the bottom left we have the seats
92:07 - and the tools and we can switch between
92:09 - them this is working really well
92:12 - and is surprisingly satisfying
92:15 - all right cool with that we have the
92:17 - overlay that was all that was needed
92:21 - now that we have the player we can start
92:23 - working on the camera and the floor
92:25 - those two kind of have to come together
92:28 - because without the floor we wouldn't
92:30 - see what the camera is doing and without
92:32 - the camera we wouldn't be able to see
92:34 - what the floor is looking like in total
92:36 - and I know I am repeating myself a lot
92:39 - but for the camera there is a whole set
92:42 - of logic I will go over the basics but I
92:45 - have made a whole video on cameras in
92:47 - detail in pi game so check this one out
92:49 - if you want to go into much more detail
92:52 - once again here I have the code and
92:55 - before I do anything else I want to
92:57 - close a couple of files we don't need
92:59 - overlay anymore and we don't need the
93:02 - timer.pi anymore those two are basically
93:04 - finished and well we don't have to worry
93:06 - about them and I do want to keep things
93:08 - a bit more organized besides that the
93:11 - level should be right next to main.pi
93:14 - because those two files are the most
93:16 - important ones and inside level.pi I
93:20 - want to create the camera this is going
93:22 - to be a separate class
93:24 - and let me call it camera group and this
93:29 - one has to inherit from pygame dot
93:31 - Sprite dot group basically what this one
93:34 - is going to do or how this one is going
93:36 - to work instead of putting all of the
93:39 - Sprites into a normal Pi game group
93:41 - we're going to create a special kind of
93:43 - group and Via this group we are going to
93:46 - get the camera
93:47 - for that to work though first of all we
93:50 - have to initiate the group by itself and
93:54 - this one itself and nothing else and in
93:56 - here we need the super Thunder init
93:59 - method
94:00 - so that the group works by itself now
94:03 - once we have that I can replace the
94:06 - group we created like an hour ago with
94:09 - the camera group and so far since we
94:13 - have basically created another group
94:15 - there shouldn't be any difference
94:16 - meaning if I run main.pi nothing has
94:19 - changed
94:21 - which is a good start at the very least
94:24 - we didn't break anything
94:26 - but now that we have more control over
94:28 - what the group is doing we can customize
94:30 - this thing quite a bit
94:32 - and one thing you could be doing for
94:34 - example is get self dot display surface
94:38 - in here as well with pygame dot display
94:41 - dot get underscore surface
94:44 - that way this camera group can draw on
94:47 - the display surface straight away which
94:50 - you could use by creating a customize
94:53 - draw method and this one itself and
94:56 - nothing else at least for now
94:59 - now the way a normal group draws a
95:02 - Sprite so this line here essentially all
95:06 - that it does is it runs a for loop with
95:08 - four Sprite in self dot Sprites
95:12 - don't forget to call it for some reason
95:14 - this is a method and now in here we are
95:18 - calling
95:19 - the display surface with blit and then
95:23 - we are passing in Sprite dot image and
95:26 - Sprite Dot rect
95:28 - this is basically all that is happening
95:30 - inside of a normal group for the draw
95:32 - method
95:33 - which is also the reason why every
95:35 - Sprite always needs an image and a
95:37 - rectangle if you didn't have those you
95:40 - wouldn't be able to draw the Sprite so
95:42 - they are mandatory
95:43 - so now that we have a customized draw I
95:46 - can comment out this drawer here and
95:49 - instead I want to run self dot
95:53 - allsprites dot customize draw and let's
95:57 - call it actually let me call it custom
95:59 - draw that makes a bit more sense
96:02 - custom draw that fits better
96:04 - and now if I run this
96:07 - everything still works just as before
96:09 - there's no difference
96:11 - although now we don't have to pass in
96:14 - the display surface anymore in here
96:16 - which already is a minor Improvement
96:18 - although not that much of a difference
96:21 - with that we have a start for the camera
96:24 - logic although we don't have a camera
96:26 - yet but well this method is going to
96:29 - become quite a bit more extensive
96:31 - although right now we have a problem
96:34 - because any kind of camera I would
96:36 - create would be impossible to see
96:38 - because the background is pure black so
96:41 - even if we move left or right you
96:43 - wouldn't be able to see it because it's
96:45 - well all black
96:47 - as a consequence we first of all need
96:49 - some kind of floor so we can see what's
96:52 - going on and for that we have to import
96:55 - the floor now the floor is very simple
96:57 - it is one big image if I open the
97:00 - project folder inside of Graphics there
97:03 - we have world and inside of there we
97:05 - have the ground and I guess let me open
97:07 - this one all this is is one big image
97:10 - and you can see here
97:13 - we have for example the trader and we
97:16 - have a whole bunch of objects all the
97:18 - way over here and the rest of the map so
97:23 - all of this stuff here is really empty
97:25 - now all of this is going to work in
97:27 - detail I will explain in the next few
97:29 - sections for now just don't worry about
97:32 - them
97:33 - but don't worry I didn't make a mistake
97:36 - all of this is intentional
97:39 - so let me move this away and this image
97:42 - we want to import
97:44 - although for it to work we first of all
97:47 - need another class to actually use it
97:49 - inside of Pi game and for that I want to
97:52 - create a new python file that I want to
97:55 - save as
97:57 - let's call it Sprites dot Pi because in
98:00 - here we are going to have more than one
98:03 - and I want to import pygame and from
98:07 - settings import everything
98:10 - and for now we just want to create a
98:13 - very generic class so let me call it
98:15 - generic and this one is going to be a
98:17 - Sprite so pygame dot Sprite dot Sprite
98:20 - in here as always we need the dunder
98:23 - init method this one itself and besides
98:26 - that we need a couple of arguments we
98:29 - first of all need to position
98:31 - after that we need the surface we want
98:34 - to import or we want to use then we want
98:36 - the groups so
98:38 - this is kind of similar to the player
98:41 - where we have a position and a group so
98:44 - where the Sprite should start and what
98:46 - group it should be part of however for
98:49 - the generic Sprite it needs a surface
98:51 - because we might add different kinds of
98:54 - images in here
98:55 - now first of all here as always you need
98:58 - the dunder init method with the groups
99:01 - inside that is missing something that's
99:04 - looking better
99:05 - and now we need sales.image and we need
99:08 - self.rect
99:10 - the image is just going to be the
99:12 - surface
99:13 - which means we're taking this surface
99:15 - from the arguments and passing it in
99:17 - here that's all that's going to happen
99:19 - and for the rectangle we get self.image
99:23 - dot get underscore rect and now we're
99:26 - placing the top left wherever the
99:28 - position is
99:30 - the position we are again getting from
99:32 - the arguments and passing it in here
99:34 - now we just have to figure out how to
99:36 - use it and this I am going to do inside
99:39 - of a level which means first of all I
99:42 - need from Sprites import generic
99:47 - and now inside of setup I have to import
99:51 - it by using this generic class
99:54 - I want to create an instance of the
99:56 - generic class and now I need different
99:59 - Arguments for the various parameters let
100:02 - me copy them and paste them in here
100:04 - and let me use named arguments so this
100:07 - is a bit easier to see
100:09 - the position is super easy it's just
100:12 - going to be 0 and 0.
100:14 - or the this is terrible performing
100:19 - let me clean this up a tiny bit
100:22 - for the surface all we have to do is to
100:24 - import pygame dot image and load and now
100:29 - we need the file path which is one
100:31 - folder up then we go into Graphics then
100:34 - we go into world and then we get ground
100:38 - dot PNG
100:40 - as always don't forget to call convert
100:43 - Alpha on all of this
100:46 - finally we need the groups and this one
100:48 - is easy just like for the player we need
100:51 - self dot all Sprites
100:53 - this one should be working already so
100:56 - let me try and there we go now we can
100:58 - see the background and now we need the
101:01 - camera to see the rest of the level so
101:03 - right now we can only ever see the top
101:05 - left of the map which wouldn't be
101:07 - helpful but this is already looking much
101:09 - better
101:12 - however before we can do that there's
101:15 - one major problem right now the floor is
101:19 - only behind the player because we are
101:21 - creating it before we are creating the
101:23 - player which means if I created the
101:26 - player before this generic class and run
101:29 - this again
101:30 - we wouldn't be able to see the player
101:32 - because the player is behind the ground
101:34 - which is not well good at all
101:38 - and this leads us to one of the 3D
101:42 - effects we need for the game if you look
101:44 - at settings
101:46 - we have what is called layers all of
101:49 - this
101:51 - and this I want to use to draw the
101:54 - different elements of the map most of
101:56 - the game is going to happen inside of
101:57 - Main in here for example we have the
102:00 - player all of the plants and the trees
102:02 - and stuff like that
102:03 - and the ground should be all the way
102:06 - here
102:07 - what we are essentially going to do
102:09 - inside of this custom draw method we are
102:14 - going to cycle through this list and
102:17 - then draw things one by one meaning the
102:19 - water will be drawn first then the
102:21 - ground then the soil then the soil water
102:22 - and so on and the rain drops all the way
102:25 - at the end that way we get a
102:27 - three-dimensional effect where different
102:29 - things are on top of other things
102:31 - there's actually going to be a second
102:33 - three-dimensional effect but that's
102:34 - going to come later I don't want to
102:36 - overwhelm you guys
102:37 - now for all of this to work we first of
102:40 - all have to assign each Sprite one of
102:43 - these layers
102:44 - which means right now the Sprites need
102:47 - one layer and the player is going to
102:49 - need a layer and let me get started for
102:52 - the player
102:53 - right below the rectangle I want to
102:56 - assign what I called Z
102:59 - and Z is this going to be layers so the
103:03 - dictionary from settings and the player
103:06 - should be on Main
103:08 - so I can just copy it and paste it in
103:10 - here and now the player has a z position
103:14 - this means that inside of the game every
103:16 - single Sprite has an X position we have
103:21 - a y position and besides that we are
103:25 - going to have a z position
103:28 - X and Y are always going to come from
103:32 - the rectangle here and Z is going to be
103:35 - a separate variable but both of those
103:38 - work very closely together
103:40 - now besides that for the Sprites we also
103:43 - have to determine what the Z position is
103:46 - going to be and this might potentially
103:49 - change as a consequence I want to have Z
103:52 - as a parameter although here I do want
103:55 - to have a default parameter where if we
103:58 - don't get an argument Z should be on the
104:00 - main layer
104:01 - and don't forget to turn the parameter
104:04 - into an attribute so self.z is going to
104:07 - be Z
104:08 - now that being said for the ground so
104:12 - the ground we are creating here
104:14 - the floor is not supposed to be on the
104:17 - main layer instead
104:19 - it is supposed to be so Z is supposed to
104:23 - be in layers
104:25 - and this key here is called Ground
104:30 - let me copy it and paste it in here
104:34 - now we have a z position
104:37 - we just have to figure out how to
104:39 - actually use it this is going to happen
104:41 - in here
104:43 - and this I believe could be a really
104:46 - good challenge for you
104:48 - so try to use this dictionary here and
104:52 - draw Elements by the order inside of
104:55 - this layers dictionary meaning the
104:57 - higher the number is the later it should
104:59 - be drawn if you want a quick tip this
105:02 - should be a for Loop but pause the video
105:04 - now and try to figure this one out let's
105:07 - see if we can do it
105:11 - the way this is going to work first of
105:13 - all we have to cycle through the layers
105:15 - dictionary let's call it for layer in
105:19 - layers dot values
105:22 - we don't actually care about the keys
105:25 - they just don't matter
105:27 - and all of the drawing is going to
105:29 - happen inside of this for Loop and all I
105:33 - really want to do is I only want to draw
105:35 - a Sprite so after going through all of
105:38 - the Sprites I want to check if Sprite
105:40 - dot Z
105:41 - is actually the same as the layer the
105:45 - layout being one of the values of the
105:47 - layers dictionary and only if that is
105:50 - the case I want to draw this layer
105:54 - and that should be it let's try
105:57 - and now I can see my player again
105:59 - even though the player is being created
106:04 - before we are creating the floor
106:07 - which means this logic here is working
106:09 - just fine cool so with that we actually
106:12 - already have some sort of camera but not
106:15 - a real camera yet
106:17 - let's actually work on it properly now
106:18 - so for the camera and once again check
106:22 - out my dedicated video on camera logic
106:24 - this one is really important to
106:26 - understand
106:27 - but first of all what we need here is we
106:30 - have to create some kind of offset and
106:32 - this is going to be a vector so pygame
106:34 - dot math Dot vector2
106:38 - and how this is going to work think of
106:42 - this one here is the player and
106:45 - everything else so all of this stuff
106:47 - here
106:49 - is going to be the rest of the map and
106:51 - how the camera is going to work is if
106:53 - the player is moving to the right we are
106:56 - going to shift the entire map to the
106:59 - left now when I say shift the entire map
107:01 - to the left I don't mean to actually
107:03 - move it instead we're going to draw it
107:06 - in a different position the actual
107:08 - position doesn't change
107:11 - which means in practice when we are
107:13 - doing displayservice.blit
107:16 - sprited image is going to stay exactly
107:18 - the same which means in practice when we
107:21 - are calling this display surface.blit
107:23 - this one doesn't change the position it
107:26 - just draws a Sprite in a certain
107:28 - position wherever this rectangle is
107:30 - going to be but this rectangle you can
107:33 - move around perfectly fine
107:35 - and the way I want it to work is by
107:38 - making it relative to the player
107:40 - and for that first of all when I do
107:42 - custom draw I want to look at the player
107:45 - because this is what the camera should
107:47 - be following and now I want to have my
107:51 - offset dot X and I also want to do this
107:54 - for y
107:55 - and the logic here let me do it for X
107:58 - and Y together because it's going to be
108:00 - fairly similar
108:01 - I want to look at my player.rect DOT
108:05 - Center and for X is going to be X and
108:08 - for y it's going to be Center y
108:10 - so right now I am getting the position
108:12 - of the player
108:14 - and from that I want to subtract this
108:17 - green
108:19 - and then for X this is going to be the
108:22 - width and for y this is going to be the
108:25 - height divided by 2 for both what that
108:29 - basically means is the offset is going
108:32 - to be by how much we are going to shift
108:35 - every single Sprite relative to the
108:37 - player and we have to figure out by how
108:40 - much we want to move them
108:42 - and this logic here ensures that the
108:45 - player is always in the center of the
108:47 - camera
108:48 - if this one here is the player we always
108:51 - want to have an offset that points at
108:54 - the top left of the window
108:56 - which means we want to go half the
108:58 - screen width to the left and half the
109:01 - screen width up and then we're ending up
109:03 - on the point up here this is what we
109:06 - have to use to draw everything now for
109:10 - that first of all I want to create an
109:12 - offset rectangle
109:14 - and this we get with Sprite dot image
109:17 - dot get underscore rect and this we get
109:21 - with Sprite dot rect dot copy and this
109:25 - offset rectangle I actually want to
109:27 - offset so I want to get the offset
109:29 - rectangle again and now I want to move
109:31 - the center by minus equal the offset
109:36 - and this offside rectangle is what I'm
109:39 - going to use to draw the image and now
109:42 - there's one more thing we need and that
109:44 - is when I'm calling Custom draw I have
109:47 - to insert the player fortunately we do
109:50 - have the player inside of self dot
109:53 - player so let me pass it in here and now
109:56 - let's run all of this
109:57 - and now if I move around we have a
110:00 - camera
110:02 - and this is feeling pretty good we are
110:06 - definitely making progress
110:08 - although a lot of stuff is missing right
110:10 - now and this tends to look a bit weird
110:11 - but well we're getting there
110:18 - and I am fully aware that I didn't
110:21 - really go into detail for this entire
110:23 - logic so I hope you could kind of follow
110:25 - along but if you check out my videos on
110:28 - cameras this is explaining all of this
110:30 - in so much more detail so check this one
110:32 - out if you are interested
110:34 - the logic here unfortunately gets quite
110:37 - complex and I don't want this video to
110:39 - be 20 hours long
110:42 - but all right let me remove some white
110:45 - space and then we are basically done for
110:48 - this part
110:50 - in this part we are going to import all
110:52 - of the other elements and we are going
110:54 - to fake 3D a tiny bit more and I guess
110:58 - let's go for this one by one and let's
111:00 - start by importing all of the elements
111:02 - we have already done this to an extend
111:04 - but well now we have to do more of that
111:07 - now there is a tiny bit of theory that I
111:11 - do have to cover and that is that the
111:13 - entire game was designed and tiled which
111:16 - is a free program that you can use to
111:18 - design levels it's really powerful
111:21 - and I am using another module called Pi
111:23 - TMX to import all of this data now let
111:27 - me go through what all of this means by
111:29 - looking at tiled here we go this is all
111:32 - of tiled so in here I could for example
111:35 - move things around
111:37 - and design the level to look slightly
111:40 - different
111:42 - and doing all of this took quite some
111:45 - time there's a ton of things in here so
111:48 - if you look on the top left there are a
111:50 - ton of layers that you could be working
111:51 - with and well all of this is very
111:54 - complex
111:56 - and once again I have made a complete
111:59 - video on all of this so if you want to
112:01 - have a ton of detail check that one out
112:03 - I just don't have the time for this
112:06 - video to go over tiles separately all I
112:08 - am going to do is import all of this
112:10 - data into Pi game
112:12 - so let's do all of that
112:14 - once more here I have my python setup
112:18 - and I want to continue working inside of
112:20 - a level and let me minimize all of the
112:22 - methods so this is a bit easier to see
112:25 - and I can minimize the camera group
112:27 - now first of all I have to import Pi TMX
112:32 - this happens with from PI TMX
112:36 - dot util underscore Pi game I have to
112:40 - import load underscore Pi game
112:44 - and really important here Pi TMX you
112:47 - have to install separately it does not
112:49 - come with python so I have on the
112:51 - Powershell or on the terminal type pip
112:53 - install Pi TMX or pip3 install Pi TMX
112:56 - depending on Mac or Windows
112:59 - now this I want to use inside of the
113:02 - setup method and then here let me add a
113:05 - bit of white space first of all we have
113:07 - to load a file
113:09 - if I open the project inside of data we
113:13 - have map dot TMX this is what I want to
113:17 - import all of the data is in here
113:20 - and this I am loading with load pygame
113:23 - and in here I need the path to this file
113:27 - I have to go one folder up then I have
113:29 - to go to data and in the app we have map
113:32 - dot TMX
113:35 - and now we have to import a ton of
113:39 - different things so let's start by
113:42 - building the house I think this is quite
113:44 - good to illustrate how this is going to
113:45 - work now the house if I go back to tiles
113:48 - the house consists of a couple of
113:51 - different layers let me go through them
113:53 - one by one so if I hide all of them and
113:55 - zoom in let me hide all of this as well
113:59 - we have a house floor
114:01 - then we have house walls then we have
114:04 - the furniture at the bottom and then we
114:05 - have the furniture at the top and all of
114:07 - these layers we have to import
114:09 - separately
114:10 - and really important all of these have
114:13 - to be on a different layer inside of Pi
114:15 - game
114:16 - which means back in pie game or the
114:18 - house we have a couple of different
114:19 - layers
114:21 - most importantly house bottom is going
114:23 - to be for the bottom and the rest of the
114:25 - house is going to be in Main and this is
114:28 - really important
114:30 - so let's go through it one by one
114:32 - first of all to access the data I need
114:35 - to store all of this inside of a
114:37 - variable let me call it TMX underscore
114:39 - data and now I can use it
114:42 - and this has a ton of methods that we
114:45 - could be accessing the one I want to use
114:48 - now is called TMX data dot get
114:51 - underscore layer underscore
114:53 - by underscore name
114:56 - and now we need a name of a layer
114:59 - the one we could be using in here for
115:01 - example is House Furniture bottom
115:04 - and this if I look at tiled is this name
115:08 - here House Furniture bottom
115:10 - and what I want to do is to add tiles
115:13 - after this that way I am getting all of
115:16 - the tiles inside of this layer and I can
115:19 - use them inside of a for Loop and what
115:22 - I'm getting here let me add the for Loop
115:25 - first
115:26 - so this for Loop is going to return a
115:29 - list that I can unpack right away and
115:31 - the list consists of x y and a surface
115:35 - really quick back entitled when I'm only
115:39 - looking at the house furniture bottom
115:42 - and let me hide everything else
115:47 - and this is in-house decoration there we
115:50 - go
115:51 - in this we have a couple of different
115:53 - tiles and each tiles is one of these
115:56 - well little cells inside of a grid I
116:00 - just want to import this carpet thingy
116:03 - and this other carpet thingy here this
116:05 - is all I really want and each of those
116:07 - is going to have an X position a y
116:09 - position and then what you see is the
116:11 - surface this is what we are importing
116:13 - which means I already have a class to
116:16 - capture all of this data that is my
116:18 - generic class
116:20 - and in here I need a position I need a
116:23 - surface and I need my groups oh and also
116:28 - I need the Z position first of all for
116:31 - the position you might be tempted to
116:33 - just add X and Y in here but that
116:36 - wouldn't be a good idea because this X
116:39 - and Y position is not a pixel position
116:41 - instead if I return to tiled
116:44 - and zoom out a bit
116:47 - there you go
116:49 - the position we are looking at is the X
116:52 - and Y position on this grid so for
116:54 - example all the way in the top left this
116:56 - cell here has the grid position 0 and 0.
117:00 - and the one to the right of it so this
117:03 - one here is going to have one and zero
117:06 - but all of these tiles have a size of 64
117:10 - by 64. so the actual starting position
117:12 - of this cell here is not going to be 1
117:15 - and 0 it is going to be
117:18 - 64 and 0. we are essentially multiplying
117:22 - the position by 64. or rather the size
117:25 - of the tile
117:27 - and this position we have available in
117:29 - pi game as well it is inside of settings
117:32 - all the way at the top we have the tile
117:34 - size
117:35 - all I have to do is to multiply X and Y
117:38 - by the tile size now at the surface we
117:42 - already have it is just the surface we
117:45 - are importing up here
117:47 - then we need the groups and this one is
117:50 - also fairly easy because all we need in
117:52 - here is self dot all Sprites
117:55 - and for Z I want to have my layers and
117:59 - the house furniture bottom
118:01 - should be inside of the layer house
118:05 - bottom this one here
118:07 - we copy it and paste it in here and this
118:11 - should be all we need
118:14 - there we go this should already be
118:17 - working now let's try
118:20 - and I do have to walk down a tiny bit
118:22 - because the house is somewhere down here
118:25 - there we go there we have a carpet and
118:28 - it is below the player because of the
118:29 - layers
118:31 - that is a really good start
118:34 - now there's a bit more stuff that I want
118:36 - to put on this layer and as a
118:39 - consequence I'm going to wrap this for
118:41 - Loop inside of another for Loop and what
118:45 - I want to do is for layer in the list in
118:50 - here I have house floor and then I have
118:54 - the house furniture bottom and now for x
118:59 - and y and surface is going to be for the
119:03 - layer
119:05 - this way I am using the same for Loop
119:08 - for the house floor layer and for the
119:10 - house furniture bottom layer now if I
119:12 - try this
119:14 - we are getting an error because I forgot
119:16 - the colon so now let's try this
119:19 - and if I now walk down I should be
119:23 - seeing the house floor and the carpet
119:25 - this is looking pretty good
119:27 - although in here the one limitation is
119:30 - that this house floor has to come before
119:32 - the house furniture bottom this house
119:35 - furniture bottom is only drawn on top of
119:37 - the house floor because it is being
119:39 - created afterwards if we reverse the
119:42 - order here let me add it like this then
119:45 - you would not be able to see the house
119:46 - furniture bottom
119:48 - let me try it now and
119:53 - you can see you well cannot see the
119:55 - carpet
119:56 - but we only have two elements here so
119:59 - this isn't really that much of an issue
120:00 - this works just fine as it is
120:03 - with that we have
120:06 - two layers out of quite a few
120:10 - now this entire thing I now want to copy
120:13 - because there are two more layers that
120:15 - work in kind of the same way
120:18 - we have the house walls
120:21 - and we have the house furniture top
120:25 - those are going to work in basically the
120:28 - same way for this line and this line the
120:31 - one difference is that those two should
120:33 - be on the main layer and now let me try
120:37 - if I now walk to the house
120:39 - always takes a second yeah you can see
120:42 - the entire house
120:44 - right now it is always below the player
120:47 - but this we are going to change very
120:49 - soon
120:51 - but well we have a house
120:53 - admittedly this setup here could be a
120:56 - bit more elegant but I don't want to add
120:59 - too many for Loops but you could totally
121:01 - do it if you want to
121:02 - there's quite a bit of repetition in
121:04 - these lines here
121:06 - all right there is one more thing that
121:08 - we do need and that is the fence let me
121:12 - illustrate this entitled
121:14 - here's entitled and right now everything
121:16 - is hidden so let me make most of the
121:20 - stuff visible so we can see what's going
121:22 - on
121:23 - defense I am talking about is this fence
121:26 - here this is what I want to import now
121:29 - and this is going to work very similar
121:32 - compared to the house
121:33 - which means this could be a really good
121:36 - exercise for you I want you guys to
121:38 - cycle through the layer is called fence
121:42 - it's like it for this layer and import
121:44 - the surface with the X and the Y
121:47 - position using the generic class and
121:50 - this should be inside of its own for
121:51 - Loop so possibly now and try to figure
121:54 - this one out
121:57 - we need 4 x y and the surface in t m x
122:05 - underscore data dot get layer by name
122:08 - and the layer we want to look at is
122:10 - called fence and then here don't forget
122:13 - we need tiles
122:15 - once we have that we need the generic
122:17 - class
122:18 - and in here we need a position we need a
122:21 - surface we need a group and we need a
122:25 - layer or rather a z position
122:29 - the position is super easy this is the
122:31 - one we have already done multiple times
122:33 - let me just copy it from the house so
122:36 - position this one and surface we also
122:39 - already have
122:41 - now for the groups for now we only have
122:43 - a single spread group so self dot all
122:46 - Sprites is going to remain the same
122:48 - finally for Z I do want the fans to be
122:52 - on the main layer and since that is the
122:55 - default parameter I can just leave it as
122:57 - it is as a matter of fact or this line
123:00 - here I could actually remove layers.main
123:03 - because this is what we get anyway
123:06 - let's do it like this and now let's try
123:09 - and there we can see the fence this is
123:12 - looking very nice
123:17 - righty there are three more things that
123:21 - we do have to import we have the water
123:23 - we have the trees and we have some wild
123:27 - flowers
123:29 - and all three of those are going to be
123:31 - their own class because they are all
123:33 - slightly different so let's create some
123:37 - more classes
123:39 - this is all going to happen inside of
123:41 - Sprite
123:42 - first of all I want to create a class
123:45 - called water and this is also going to
123:47 - be a Sprite but despite we are getting
123:50 - from generic which means water is going
123:53 - to inherit from generic
123:55 - and since generic is a Sprite water is
123:58 - also going to be a Sprite and in here as
124:00 - always we need a thunder init method and
124:04 - this one needs self it needs a position
124:07 - it needs frames not a surface we need
124:11 - groups and we need Z
124:13 - the major thing about the water is that
124:16 - the water is going to be animated
124:19 - and this means we kind of need the same
124:22 - setup for the animation that we have
124:24 - seen for the player it's inside of
124:26 - animate basically this kind of setup
124:29 - here
124:30 - so we need a couple of frames like we
124:33 - have seen in here and then we need an
124:35 - entire method to Loop over all of these
124:37 - frames
124:39 - and the frames are going to be stored
124:41 - inside of the method frames
124:44 - let me add a comment here and let's call
124:47 - this animation setup in here we first of
124:49 - all need an attribute with frames and
124:52 - this is just going to be frames what we
124:54 - are getting from the parameters
124:55 - then we need self dot frame underscore
124:58 - index is a zero by default and once we
125:02 - have that we can start with this Sprite
125:06 - setup and in here all we need is this
125:09 - super Thunder init method and for this
125:14 - one we need the init method of the
125:16 - generic class all of these parameters
125:19 - here
125:20 - position is what we are getting from the
125:23 - position from the water and let me use
125:25 - named arguments here that is a bit
125:27 - easier to follow I think
125:29 - for the surface I want to get myself dot
125:32 - frames and then here self dot frame
125:36 - underscore index
125:39 - and this should probably be on multiple
125:41 - lines otherwise it's kind of hard to
125:44 - read for the groups all I want is the
125:46 - groups I am getting from the parameters
125:49 - of the water class
125:50 - and finally for Z all we need here is
125:54 - inside of settings we have water
125:58 - this is what I want to pass inside of
126:01 - the Z argument here
126:03 - and this doesn't animate yet but we do
126:06 - need a few more things so back in level
126:08 - let's start creating this thing and
126:11 - first of all as always I need this kind
126:15 - of line here so let me just copy it
126:18 - the name of the layer we need here is
126:20 - called water
126:21 - and what I want to do is to create a
126:24 - water tile although right now we don't
126:26 - have water available inside of level
126:29 - meaning besides generic I want to import
126:32 - water
126:33 - for this one we need all of these
126:37 - parameters
126:39 - position is going to remain basically
126:42 - the same I can just copy things and
126:44 - paste them in here
126:45 - the other easy one is the groups because
126:47 - once again we only have a single group
126:49 - so far so this is always going to be all
126:52 - Sprites
126:54 - the problem we have is we need the water
126:57 - frames
126:58 - which if you open the project folder
127:01 - again are inside of graphics and in the
127:04 - app we have water and we have four
127:06 - different frames and this one to animate
127:09 - but for that we have to import all of
127:11 - them
127:12 - fortunately we already have a function
127:14 - that Imports an entire folder and
127:17 - converts it into surfaces the same thing
127:20 - we have used for the player so we can
127:22 - reuse all of this
127:25 - for that to work though we first have to
127:27 - make it available inside of level.pi
127:29 - which means from support I want to
127:33 - import everything
127:34 - and now I can use import folder
127:38 - and for the water I want to have some
127:40 - water frames and this is going to be
127:43 - input folder and the file path we need
127:46 - here
127:47 - is one folder up then we have graphics
127:51 - and then we have water
127:52 - and these water frames we want to use in
127:55 - here
127:56 - and now let's see if this is going to
127:59 - work already
128:00 - so if I move over this side there is
128:04 - going to be some water this is looking
128:06 - really good
128:07 - and if I move further down we should be
128:09 - able to see some more water
128:12 - there we go so now we have water except
128:15 - it's all static so now we have to
128:16 - animate it
128:18 - that is going to happen inside of
128:20 - Sprites and in here
128:23 - I want to create an animate function oh
128:26 - well method in itself and Delta time
128:30 - I think we could do another really good
128:33 - exercise so like for the player
128:36 - we have to create an animate function so
128:39 - try to create this one for the water
128:41 - basically what you have to do is copy
128:43 - the thing you have seen for the player
128:44 - and then make sure you're actually
128:45 - calling it so try this one yourself and
128:49 - see if you can figure it out
128:53 - I think a really good way here is to
128:55 - look at both of the files next to each
128:57 - other it's a bit hard to see but I hope
129:00 - you get the idea we are basically going
129:01 - to copy all of this so first of all we
129:05 - need self dot frame index and we want to
129:09 - increase this by a certain number for
129:11 - the water I went with 5 and multiply
129:14 - this by the other time but this five
129:16 - here is entirely subjective play around
129:18 - with this
129:19 - after that I want to check if my self
129:23 - dot frame index is greater or equal than
129:27 - the length of self dot frames
129:31 - if that is the case I want to set self
129:34 - dot frame index to zero
129:38 - finally I want to update self dot image
129:41 - and this is going to be
129:44 - self dot frames and in here don't forget
129:47 - we need an integer of self dot frame
129:51 - index
129:53 - and that is all we need all we have to
129:56 - do now is to figure out when to call
129:58 - this animate method and this we are
130:00 - doing inside of the update method in
130:03 - here we need self and Delta time and all
130:06 - I really have to do in here is called
130:07 - self dot animate and pass in Delta time
130:11 - technically you could just add all of
130:13 - these lines here and paste them inside
130:15 - of the update method it would work
130:17 - perfectly fine but I think this is a bit
130:19 - more organized it well is entirely up to
130:22 - you
130:23 - but now we should be having animated
130:25 - water let's try and let's walk to the
130:28 - water
130:30 - and there we go we have animated water
130:33 - this is looking quite nice
130:38 - so I can minimize the water and now we
130:41 - can work on the next kind of sprite I
130:44 - guess a really easy one would be the
130:46 - class wild Lao work
130:49 - and this one like the water has to
130:51 - inherit from generic and in here we need
130:55 - a Dunder init method
130:57 - and this one needs self it needs a
130:59 - position it needs a surface and we need
131:02 - the groups
131:04 - and after that we need a super and a
131:07 - thunder in its method and once again we
131:11 - need these three parameters
131:15 - we don't need Z because all of the wild
131:17 - flowers are supposed to be on the main
131:19 - layer and the wildflowers for now are
131:23 - going to stay just like that we're not
131:25 - going to make any more changes although
131:27 - later on they are going to change a tiny
131:29 - bit which is why we need a separate
131:31 - class
131:32 - but not if we have them inside of
131:35 - level.pi I want to import the wild
131:38 - flower
131:40 - and this one if I copy these two lines
131:43 - here
131:45 - I want to look at the layer called
131:47 - decoration
131:50 - let's have a look at child how this
131:52 - looks
131:53 - the layer I am looking at is this one
131:55 - here decoration and in there if I hide
131:59 - and unhide it it's all of these small
132:02 - elements inside of the forestry area
132:05 - and these I want to import now there if
132:08 - you look at the layers in the top right
132:11 - these are slightly different compared to
132:12 - the tire layers we have already seen
132:14 - basically these are objects and this we
132:17 - can move around easily whereas these
132:20 - with the square icon are all tiles
132:24 - but again check out my original video it
132:26 - explains all of this in much more detail
132:28 - the difference honestly isn't that bad
132:31 - I shouldn't have actually copied this
132:33 - line instead what I should have been
132:35 - doing is for obj in TMX data dot get
132:40 - layer by name and the layer we are
132:43 - looking at is called decoration this one
132:45 - doesn't change
132:46 - and now in here we are getting an obj
132:50 - and this obj has an X it has a y and it
132:54 - has an image and this one is the surface
132:56 - so this is what we are going to use
132:59 - and now I want to create a wild flower
133:03 - and in here let me copy the parameters
133:07 - we need we need a position we need a
133:10 - surface and we need the groups what a
133:12 - position we need obj dot X and obj Dot Y
133:16 - and those are actual pixel positions so
133:20 - we don't have to multiply them with
133:21 - anything
133:22 - for the surface we need obj dot image
133:26 - and for the groups once again we need
133:28 - self dot all Sprites
133:32 - let's run this again and now we can see
133:35 - a whole lot more stuff on the map
133:38 - this is already starting to look much
133:40 - better
133:42 - finally we are going to need some trees
133:45 - so I'm going to create a class called
133:47 - three
133:48 - this one is also going to inherit from
133:51 - generic and in here we need a Dunder
133:55 - init method with self we need a position
133:58 - we need a surface we need the groups and
134:01 - besides that I also want to have a name
134:04 - of the tree
134:05 - why that name is going to matter let me
134:08 - visualize all of this entitled
134:10 - inside of tiled here you can see all of
134:13 - the trees and they all have a name the
134:16 - name you can see here so a tree could be
134:18 - called small or large
134:21 - and this is what I want to use for the
134:24 - name that way I can tell if a tree is
134:26 - going to be small or large that's
134:27 - basically all it is
134:29 - although later on this is also going to
134:31 - determine where the apples are going to
134:33 - be on the tree
134:35 - for example for a larger tree we would
134:38 - have this entire surface to place apples
134:40 - or small tree we would only have this
134:42 - surface here and inside of here I want
134:46 - to have a super Thunder init method
134:49 - and this one is going to need a position
134:51 - a surface and the groups
134:54 - all of these we are getting from the
134:57 - parameters so we can just leave it as it
134:59 - is
134:59 - although later on the trees are going to
135:02 - become quite substantially more
135:04 - extensive
135:05 - but for now all we have to do is
135:08 - or obj in TMX data dot get layer by name
135:14 - and the layer I am looking for is called
135:17 - trees
135:19 - and in here I want to create a tree
135:22 - although first of all I do have to
135:24 - import it with re
135:27 - and the arguments we need let me copy
135:30 - the parameters
135:32 - the position we can just copy from the
135:35 - wildflowers this one here
135:37 - so position is covered
135:39 - the surface is going to be obj dot image
135:43 - order groups once again we have self dot
135:47 - all Sprites and for the name this one we
135:50 - get with obj DOT name and now if I run
135:54 - this
135:57 - here you can see a huge amount of trees
135:59 - and this is looking really nice
136:02 - so the entire thing is definitely coming
136:04 - together
136:06 - so there's only one more thing that I do
136:08 - want to cover although for that we need
136:10 - a tiny bit of theory let's talk about it
136:13 - I want the various elements to overlap
136:16 - at the very least the elements inside of
136:18 - the main layer so for example if the
136:21 - player is behind in the y-axis it should
136:24 - be drawn below the other elements for
136:27 - example if we have the player here and
136:29 - the player is behind a sunflower the
136:31 - player should be behind the sunflower or
136:34 - rather below the sunflower
136:37 - and if the player is in front and the
136:39 - y-axis the player should be drawn in
136:41 - front of the other elements so if the
136:43 - player is in front of it it should be
136:45 - drawn on top of the sunflower and this
136:48 - effect is really nice in the game it
136:50 - makes it look much better
136:52 - it's also very easy to implement so
136:54 - let's Jump Right In back in the code I
136:56 - want to minimize the setup method and I
137:00 - want to work inside of the camera group
137:02 - I have to work inside of all of this and
137:06 - this line here in particular is really
137:08 - important because right now we are just
137:11 - drawing all well cycling through all of
137:14 - the Sprites and this I want to sort
137:18 - and the way I want to sort it let's say
137:21 - we have two elements like this I want to
137:25 - sort them by the white position which
137:27 - means the further down the center of a
137:31 - Sprite is the later it should be drawn
137:33 - in this case this part here should be
137:35 - drawn first and this Sprite should be
137:37 - drawn after that that way this Sprite
137:39 - here is always on top of this other
137:42 - Sprite
137:43 - and since this is going to happen on
137:45 - every single frame of the game this can
137:47 - also change to get all of this we need a
137:51 - key for this sorted function
137:53 - this always has to be a Lambda function
137:56 - and into this Lambda function I want to
137:58 - pass in this Sprite
138:00 - what I want to look at from the Sprite
138:02 - is
138:03 - sprite.rect.center y
138:06 - that is literally all I needed so now if
138:09 - I run all of this again you can already
138:11 - see it with the fence but it's kind of
138:13 - weird but the sunflowers make it look
138:15 - much nicer so now
138:19 - the player can walk through all of this
138:22 - and it's looking significantly better so
138:25 - this is really really nice
138:29 - and that way the game feels much more
138:31 - three-dimensional it also works with the
138:33 - house let me walk there so for example
138:36 - here
138:37 - we can walk through all of this
138:40 - and well this is very very nice
138:45 - cool this was a very large section but
138:48 - we basically imported the entire game so
138:51 - massive progress
138:52 - with the level and the play and place we
138:56 - can work on the collisions and let me
138:58 - cover a tiny bit of theory how the
139:00 - collisions are going to work first
139:01 - because that can be kind of confusing
139:04 - let's say we have an object here and we
139:09 - have the player moving in some kind of
139:11 - Direction and we want to check if the
139:13 - player is colliding with this obstacle
139:15 - what we are going to do for that is we
139:18 - are first going to check if the player
139:20 - is overlapping with the obstacle for
139:22 - example the player could be here and we
139:24 - have an overlap detecting this is really
139:27 - easy the difficult bit is to figure out
139:30 - where the Collision came from in this
139:32 - case it might look like the Collision
139:34 - came from this side but it might have
139:36 - happened that the player was moving
139:37 - really fast in this direction for
139:39 - example or the player could have come
139:41 - down this side here
139:43 - as a consequence we're going to add a
139:45 - bit more code to figure out where the
139:47 - player came from in this case since the
139:50 - only object that can move is the player
139:52 - we can check the player Direction so for
139:54 - example if the player was moving in
139:56 - let's say this direction here we know
139:59 - the Collision must have happened on this
140:01 - side because the player was moving in
140:03 - this direction
140:05 - and once we have the bit of information
140:06 - let me clean this up a tiny bit
140:09 - if we know that the player moved in this
140:11 - direction and our Collision happened
140:13 - here then we want to move the player
140:15 - back to something like this
140:20 - and then we have the entire Collision
140:23 - logic
140:24 - it honestly isn't that bad but you do
140:27 - need some Theory here and one more time
140:30 - I made a whole separate video on it so
140:31 - check this one out if you are interested
140:34 - but other than that let's Implement all
140:36 - of this alrighty here I'm back in the
140:38 - code and I want to do a couple of things
140:40 - first before we start with the Collision
140:42 - Logic the most important part is that
140:45 - all of the Sprites let me minimize them
140:50 - there we go all of the Sprites and the
140:52 - player are going to need a hitbox or
140:55 - some kind of collision rectangle we
140:57 - could be using the rectangle itself but
141:00 - that would not be a good idea
141:03 - for two reasons actually first of all
141:05 - for the player the rectangle is going to
141:08 - be really large
141:10 - if I open the project folder inside of
141:12 - graphics and let's look at the character
141:14 - for something like left X
141:17 - in here if I open this okay it's going
141:20 - to be very hard to see but if I zoom in
141:22 - you can kind of see by the shade this
141:25 - entire surface here has a size of this
141:28 - this is the entire image and the
141:31 - rectangle we are creating from this has
141:34 - the same dimensions and this is much
141:36 - larger than the actual image the reason
141:38 - why it is so large is because we have to
141:40 - capture the entire image and the bunny
141:43 - has to be in the middle if that wasn't
141:46 - the case the character would move around
141:47 - if the size changed so all of these
141:50 - surfaces have the same size and that is
141:51 - really important
141:54 - because of that we couldn't use the
141:55 - rectangle but what we can do
141:59 - is create self Dot hitbox
142:02 - and this hitbox is what we actually use
142:04 - for the collisions
142:05 - and for this one all I want to do is
142:09 - self.direct.copy so we are copying the
142:12 - rectangle and this I want to inflate
142:15 - all that inflate is doing is it takes a
142:17 - rectangle and it changes the dimension
142:20 - while keeping it centered around the
142:22 - well Center
142:24 - there's an argument here we need a tuple
142:26 - with a width and a height by how much we
142:28 - want to shrink or increase it in my case
142:31 - I want to shrink it by 126 pixels on the
142:34 - horizontal axis and negative 70 pixels
142:37 - on the vertical axis
142:39 - next up this hitbox has to be moved
142:42 - along with the rectangle and this is
142:45 - going to happen inside of the move
142:47 - method
142:49 - so in here what I usually do is after
142:53 - I've moved the position I am moving the
142:55 - hitbox so self dot hit that is terrible
142:59 - spelling self dot hitbox dot Center X
143:05 - is going to be self.post.x
143:09 - and then
143:12 - self.rect.centerx is going to be self
143:14 - dot hitbox dot Center X
143:18 - although in here I actually realized I
143:21 - forgot one important thing and that is
143:24 - that this self-deposited x needs to be
143:26 - rounded
143:28 - if we didn't include that pygame would
143:30 - truncate these values which means a 1.9
143:34 - for example would be truncated to one
143:37 - whereas the proper value would be a two
143:40 - and this is what we get by rounding
143:42 - which is why we need the rounding here
143:45 - if you don't do that you are going to
143:47 - get occasionally wrong Behavior oh well
143:50 - incorrect Behavior
143:52 - but all right now that we have that I
143:54 - have to do the same thing for the
143:55 - vertical movement so self dot hitbox dot
143:58 - Center why
144:00 - is going to be rounded self dot post dot
144:03 - y
144:05 - and now self.rect.center Y is going to
144:07 - be self.hitbox Dot Center y with that we
144:12 - have a hitbox for the player and now all
144:14 - of the Sprites are going to need a
144:16 - hitbox as well let's start with generic
144:19 - and then here I just want to create a
144:22 - hitbox with self.rect DOT copy
144:27 - and this I want to inflate and the
144:30 - number here I want to be a bit more
144:32 - flexible so for the width I went with
144:34 - negative self.rect dot with
144:37 - and multiply this by 0.2
144:41 - then I'm going to copy all of this
144:44 - and then for the height this is going to
144:47 - be
144:48 - self.rect.hive multiplied by negative
144:51 - 0.75
144:54 - the numbers here you definitely just
144:56 - want to play around with it is fairly
145:00 - subjective it really depends how you
145:02 - want this to look
145:03 - mostly for the width you want to have a
145:05 - fairly small number because you don't
145:07 - want to shrink it too much on the
145:09 - horizontal axis for the vertical axis
145:11 - you do actually want quite a large
145:13 - number and this again is because of the
145:15 - overlap let me show the slide again
145:17 - actually
145:18 - the overlap for all of this works really
145:21 - well because when we created this there
145:23 - was no Collision but once we have
145:25 - Collision we really have to be aware
145:28 - that this rectangle here shouldn't be
145:32 - too tall because if the sunflower would
145:35 - have a collision rectangle that covers
145:37 - the entire height the main character
145:39 - would never be able to go behind it we
145:41 - would always get stuck on top as a
145:43 - consequence you do want quite a high
145:45 - negative number for the vertical axis
145:48 - all right with that let me minimize the
145:50 - generic class so we have a lot of space
145:52 - water doesn't need any hitbox because it
145:55 - cannot be collided with and next up we
145:58 - need the Wildflower
145:59 - and this is now the reason why this is a
146:02 - separate class because in here I want to
146:04 - have a hitbox and this is going to be
146:06 - self Dot rect
146:09 - dot let me copy it and then I want to
146:12 - inflate the entire thing and I want to
146:15 - inflate this by Static numbers for the
146:17 - horizontal axis which is negative 20 and
146:19 - for the height I want to go with
146:21 - negative self.rect dot height
146:25 - and this I want to multiply with
146:29 - 0.9 finally we have the three although
146:33 - in here we don't actually have to make
146:35 - too many changes because the tree can
146:37 - take the hitbox from the generic class
146:39 - so this hitbox is still going to apply
146:42 - inheritance here makes our life a lot
146:45 - easier that covers a lot of the setup
146:47 - there's one more thing that we need back
146:49 - in level inside of the init method I
146:53 - need another group
146:55 - the group I want to create is called
146:58 - self.collision Sprites and this is going
147:01 - to be a plain piegame.sprite.group
147:05 - the only reason I'm going to create this
147:07 - group is because I have to keep track of
147:09 - what Sprites can be collided with so any
147:12 - spriter player can collide with is going
147:14 - to be inside of this group and inside of
147:16 - this group that way I can identify them
147:19 - easily which makes my life a lot easier
147:22 - and now when we are creating all of the
147:26 - collidable Sprites that is going to be
147:29 - for example defense we can collide with
147:33 - so in here
147:35 - self.ul Sprites I want to put in a list
147:38 - and besides that self.collision Sprites
147:42 - the same is also going to apply to the
147:45 - trees and to the decoration
147:47 - so let me Target both
147:50 - and all Sprites should be in a list
147:52 - along with self.collision Sprites
147:57 - you might be wondering if house walls
147:59 - and House Furniture top also need
148:01 - Collision Sprites the answer is not
148:04 - really but I'm going to cover that in
148:06 - just a bit
148:08 - but that's going to come in just a bit
148:11 - the one thing we need now is that the
148:14 - player needs to know where all of the
148:16 - Collision Sprites are because we are
148:18 - going to run the Collision method inside
148:20 - of the player
148:21 - which means I want to pass
148:24 - self.collision Sprites into the player
148:27 - I do want to mention here for the player
148:30 - the player Sprite is inside of all
148:32 - Sprites and then besides that the player
148:35 - is going to have a separate parameter
148:37 - for the Collision Sprites but the player
148:39 - Sprite itself is not inside of the
148:42 - Collision Sprite we just have a
148:44 - reference to it whereas the decorations
148:47 - are both in all Sprites and in the
148:50 - Collision Sprites this is a
148:52 - fundamentally different concept here so
148:53 - I hope you get the difference but now to
148:56 - make all of this work inside of player
148:57 - the player is going to need one more
148:59 - parameter and let's call this the
149:01 - Collision
149:03 - rights
149:05 - and this we have to capture let me put
149:08 - it below the movement attributes in here
149:10 - we have collision and I want to get
149:13 - myself dot Collision Sprites as an
149:17 - attribute
149:19 - and I guess to keep things organized I
149:21 - could put the hitbox in here as well it
149:23 - does seem to make sense
149:25 - and now I can minimize the init method
149:27 - and now inside of the move method we can
149:31 - work with the collisions or more
149:32 - specifically I want to create a separate
149:35 - method that I'm going to call collide
149:40 - actually I guess Collision makes a bit
149:42 - more sense it doesn't really matter and
149:45 - in here I need self and I need the
149:47 - direction
149:48 - first of all in here I want to look at
149:51 - every single Sprite inside of the
149:53 - Collision Sprites so form Sprite in self
149:56 - dot Collision Sprites dot Sprites in
150:01 - here I want to check has attribute
150:04 - if this Sprite I am looking at has an
150:07 - attribute called hitbox
150:09 - they should all do but this is a good
150:12 - way to make sure and that we just skip
150:14 - any kind of collision if that isn't the
150:16 - case it well makes our life a bit easier
150:18 - now once I have that I want to check if
150:21 - there's any kind of overlap and this I
150:23 - get with Sprite dot hitbox dot Collide
150:28 - direct and now I want to check with self
150:30 - Dot hitbox
150:32 - if that is the case we know there is
150:35 - going to be some kind of overlap the
150:37 - problem is we don't know where the
150:39 - overlap came from this is why I talked
150:40 - just a second ago so here we have an
150:43 - obstacle and the player might be
150:46 - somewhere here we know the overlap is
150:49 - here the problem is we don't know where
150:52 - the player came from the player could
150:54 - have come from here the player could
150:55 - have come from here the player could
150:57 - have even come from here and moved
150:59 - really fast meaning we have to figure
151:01 - out where this came from
151:03 - and the best way to think about this is
151:06 - first of all you want to separate the
151:08 - dimensions so we first have
151:11 - let me call it we first have horizontal
151:13 - and after we have done that we are doing
151:15 - vertical
151:17 - this is also the reason why down here we
151:20 - split the movement into horizontal and
151:22 - vertical movement
151:23 - in here
151:25 - the logic gets much easier we still have
151:27 - an obstacle and now the player overlaps
151:30 - again something like this but now we
151:33 - only have to check if the Collision
151:34 - happened on the left or on the right
151:39 - now it's still perfectly possible that
151:42 - the player came this way here and moved
151:44 - really fast
151:45 - so I want to check the direction of the
151:48 - player meaning if the player was moving
151:50 - to the right I know that the Collision
151:53 - must have happened on the left because
151:55 - if the player is moving to the right any
151:57 - kind of collision has to happen on the
151:59 - left of the obstacle meaning this side
152:02 - here
152:03 - and this is what we have to implement
152:05 - now
152:06 - first of all I want to check the
152:08 - direction and if this is horizontal
152:12 - then I want to check the player
152:14 - Direction so if self dot Direction dot X
152:18 - is greater than zero if that is the case
152:22 - we are moving right or the player is
152:25 - moving right
152:26 - as a consequence if there is a collision
152:28 - then I want to set self dot hitbox dot
152:32 - right is going to be Sprite dot hitbox
152:35 - dot left
152:37 - and besides that if self dot Direction
152:41 - dot X is smaller than zero this means we
152:44 - are moving left
152:46 - then self.hitbox.left
152:50 - is going to be Sprite
152:52 - dot hitbox dot right
152:55 - there are two more things we need in
152:57 - here and that is we have to update
152:59 - self.rect Dot Center X so the rectangle
153:03 - the player actually sees because right
153:05 - now we are just updating the hitbox
153:07 - we're not updating the rectangle itself
153:10 - so where the player appears on the
153:12 - screen
153:14 - and this should be for
153:16 - self.hitbox.center X is finally for the
153:19 - movement we have to update self.post.x
153:21 - and this I also want to set
153:25 - myself.hitbox.center X is and this is
153:29 - the entire Logic for the horizontal
153:31 - collisions
153:32 - all I have to do now is after we have
153:35 - done all of the movement for the
153:37 - horizontal movement then I want to call
153:39 - Self Dot
153:41 - Collision
153:43 - like this and pass in horizontal in here
153:47 - and now this should be working let's try
153:50 - if I now okay this is getting a bit
153:53 - weird because we spawned on something
153:55 - but if I just move left and right
153:58 - we definitely have some collisions now
154:00 - if I move up and down this doesn't work
154:01 - at all but just by itself this is
154:04 - looking pretty good
154:08 - which means all we have to do now is to
154:12 - also check if Direction
154:16 - is equal to vertical
154:19 - let me add a bit of white space here and
154:22 - this is going to be your exercise
154:24 - basically what I want you guys to do is
154:27 - to copy the logic here and apply it on
154:29 - the vertical axis so pause the view now
154:32 - and see if you can figure this one out
154:37 - first of all I want to check if self dot
154:40 - Direction dot Y is greater than zero if
154:44 - that is the case I know I am moving down
154:47 - which means I want to set
154:49 - self.hitbox.bottom
154:52 - to Sprite dot hitbox dot top I guess let
154:57 - me draw what this means
154:59 - this line here means we are checking if
155:02 - the player is moving down so the player
155:05 - like this is moving down
155:07 - and now we also know that there has been
155:10 - some kind of collision the Collision
155:12 - object now is pink I hope it still makes
155:15 - sense
155:15 - and now we have to resolve this
155:18 - Collision this is happening inside of
155:20 - this line here
155:22 - we are putting the bottom of the player
155:24 - this line here at the top of the
155:27 - obstacle
155:28 - which means we are moving the player up
155:31 - by this amount and that way it appears
155:34 - that the player is on top of the
155:35 - obstacle
155:36 - and it appears like that because it
155:39 - literally is so next up we need
155:43 - self.direction.y is smaller than zero
155:45 - and if that is the case we are moving up
155:50 - and this means
155:52 - self.hitbox.top is going to be Sprite
155:54 - dot hitbox dot bottom
155:57 - besides that we also have to update
156:01 - self.rect.center Y and this is going to
156:04 - be self dot hitbox dot Center y
156:08 - and finally besides that
156:11 - self.post.y is also going to be
156:14 - self.hitbox.center Y and with that we
156:17 - have the entire Collision logic so let's
156:20 - try
156:21 - and we do have a bit of a problem
156:22 - because we always spawn outside of this
156:25 - fence
156:26 - um which causes a few problems
156:28 - so let me move around here
156:31 - and now if I just move around the forest
156:34 - here yes lots of things I can collide
156:36 - with
156:40 - and we do have some problems so
156:43 - something is not right and I think I
156:45 - know what it is because back in the
156:48 - player
156:49 - I am not calling the Collision after the
156:51 - vertical movement
156:52 - meaning let me copy the Collision here
156:55 - and this should be vertical
156:58 - now let's try this again
157:00 - so now we have the same problem we are
157:02 - spawning right on top of the fence which
157:04 - causes weird Behavior but other than
157:05 - that
157:06 - now we have proper collisions
157:09 - let's see if this is working this is
157:12 - looking pretty good
157:15 - and if I walk through here I can walk
157:17 - behind the bushes but I cannot walk
157:19 - through all of the trees
157:22 - and this is looking pretty good
157:29 - so I am quite happy with this
157:34 - nice this is working very well
157:37 - there are two problems we have right now
157:39 - number one is the starting position of
157:42 - the player meaning inside of setup the
157:46 - player is just being spawned in a random
157:48 - position which isn't ideal and besides
157:51 - that
157:52 - we need some kind of mechanism to
157:55 - prevent the player from moving outside
157:56 - of the map so like this
157:59 - and let's go through them one by one
158:01 - the starting position of the player is
158:03 - the easier thing and for that we need
158:06 - tiled once more if I open this one there
158:09 - is an entire layer called player
158:12 - and inside of that we have a couple of
158:16 - objects and one is called start this is
158:19 - a simple node
158:20 - and this one we can use to set positions
158:23 - and this is where I want to spawn the
158:24 - player which means back in my code I let
158:29 - me add another comment here player is
158:32 - probably the best name for this spelling
158:34 - it correctly would also help
158:36 - what I want to do in here is for obj in
158:40 - TMX data dot get layer by name and this
158:44 - layer is literally called player and
158:47 - what I want to check is if obj.name is
158:50 - equal to start
158:53 - if that is the case I want to create the
158:57 - player and the starting position of the
158:59 - player is going to be obj dot X and Dot
159:05 - y
159:06 - if I run this again we are starting
159:08 - right in the middle of the map so this
159:10 - is much better
159:13 - now we have to figure out the other
159:16 - kinds of collision so let me run the
159:18 - game again I can for example just walk
159:20 - through the house which feels a bit
159:22 - strange
159:24 - for that if I open tiled again there is
159:27 - an entire layer called Collision if I
159:30 - make this one visible you can kind of
159:32 - tell what's going on I basically drew a
159:36 - couple of tiles all across the level and
159:39 - this is limiting the player this is what
159:42 - I want to import and then use it for
159:43 - collisions this I am doing inside of
159:46 - level and let me do it I guess right
159:49 - before the player makes sense
159:51 - and here I want to have some Collision
159:53 - tiles and that is some terrible spelling
159:57 - Collision tiles
159:59 - since we are now working with a tile
160:01 - layer again I want for x y and surface
160:06 - in TMX data dot get layer by name
160:11 - this layer is called Collision don't
160:14 - forget we also need tiles
160:16 - in here I want to create a generic tile
160:19 - and this one is going to need a position
160:21 - a surface and a group
160:25 - what you have to consider here is that
160:28 - for the group I want to only place it in
160:32 - self.collision Sprites this is the one
160:35 - Sprite that is not going to be in all
160:37 - Sprites
160:38 - as a consequence it is not going to be
160:41 - drawn or updated but it is going to
160:43 - exist and since this one isn't going to
160:45 - move we don't really have to update it
160:48 - that way even though we have a Sprite
160:51 - with a surface it is not going to be
160:53 - visible
160:54 - but besides that everything else remains
160:56 - basically the same so I have X and Y and
161:00 - both of these
161:01 - need to be multiplied with the tile size
161:07 - for the surface all I really want to do
161:10 - is create a pygame DOT surface
161:13 - and this one should be pile size and
161:16 - tile size that way we are creating a
161:21 - empty surface or well a black surface
161:23 - with the dimensions of 64 by 64 which is
161:26 - all we need for this Sprite
161:28 - and with that we should be having
161:31 - collisions so let me run main.pi again I
161:34 - am not able to walk through the house
161:36 - anymore
161:37 - on top of that if I try to walk on the
161:40 - water I can also not do that anymore and
161:43 - if I walk further to the right
161:45 - this one also doesn't work so this is
161:49 - much better
161:50 - I guess I can demonstrate what would
161:53 - happen if we added these generic Sprites
161:56 - to all Sprites as well so if I add this
161:59 - to self dot all Sprites
162:03 - it would look something like this so
162:06 - these are the Sprites we are actually
162:07 - colliding with
162:09 - and well it doesn't feel great but you
162:12 - can tell what's going on so this is the
162:15 - entire
162:16 - religion map of the level
162:19 - but I do not want to show them so let me
162:22 - undo all of this
162:23 - there we go and now we have all of the
162:27 - collisions that we need
162:30 - in this part I want to work on the trees
162:33 - so that we can hit the trees and that
162:36 - the trees all have apples there are
162:38 - quite a few different things we need so
162:40 - let's Jump Right In
162:41 - here we are back in the code and I want
162:44 - to work on my trees let's get started by
162:47 - giving the trees some apples
162:52 - for that first of all we need an apple
162:55 - surface this we get with pygame DOT
162:58 - image dot load and the file path here
163:01 - let me just copy it to save me a bit of
163:03 - writing this file path here inside of
163:06 - the project folder we are looking at
163:09 - refix and in the app we have root and in
163:13 - the app we have if I make it a bit
163:15 - larger we have the Apple this is what
163:17 - we're importing is simple image after
163:20 - that we need a list of possible
163:22 - positions for the apple and this we have
163:25 - in the settings let me minimize all of
163:28 - this so it's easier to read we have one
163:31 - dictionary with small and large and the
163:35 - values here are lists with positions and
163:38 - these names here refer to small or large
163:41 - trees and these are positions on the
163:43 - tree where we could have an apple
163:45 - this I want to create as an attribute so
163:48 - self dot let's call it Apple pause is
163:52 - going to be apple underscore pause
163:54 - that's the dictionary from the settings
163:57 - file
163:58 - and from this
164:01 - I want to pick the list that is
164:04 - appropriate and this I'm getting by
164:05 - using the name remember here the name of
164:07 - the trees is either small or a large and
164:09 - this is why this works
164:11 - finally each of the trees is going to
164:14 - have its own Sprite Group which I'm
164:16 - going to call Apple Sprites this is just
164:20 - going to be pygame dot Sprite dot group
164:22 - now once we have that I actually have to
164:25 - use that to create some apples this I
164:28 - want to do in a separate method that I'm
164:31 - going to call create fruit we need self
164:34 - and nothing else and in here
164:37 - basically what I want to do is for
164:40 - position and self dot Apple position I
164:45 - want to have some random number
164:47 - generator to tell if we want to create
164:49 - an apple in a position or not now for
164:52 - that I am going to need Rand int so from
164:55 - random import Rand int
164:59 - and now all I really want to do is rant
165:02 - end
165:03 - generating a number between 0 and 10 and
165:06 - if that number is smaller than 2 I want
165:09 - to create an apple
165:10 - and the Apple here is just going to be a
165:13 - generic object this one is going to need
165:15 - a position a surface and a group
165:19 - all the stuff we're getting from the
165:20 - generic class up here let me go through
165:23 - them one by one because we do have to be
165:24 - a bit careful here although the surface
165:26 - is very easy all we need is self dot
165:29 - Apple surface actually this would just
165:31 - be apple surface because it's singular
165:34 - for the position you might be very
165:36 - tempted to just go with position by
165:38 - itself here because if you look at
165:40 - settings we have e-list and this looks
165:44 - like a position and it kind of is but
165:47 - it's a bit misleading
165:49 - the way you have to think about it if
165:51 - this one here is the entire map of the
165:54 - game
165:55 - and we have a tree somewhere here
165:59 - the position that is inside of the list
166:02 - refers to the position on the tree
166:06 - and the number is the distance from the
166:08 - top left of the tree not the top left of
166:12 - the entire game meaning every time we
166:15 - are creating an apple we have to add the
166:18 - top left of the game and then we have to
166:20 - add the offset of the Apple
166:22 - and let's do this separately for the
166:24 - variables we have X and Y and this I
166:28 - think could actually be a really good
166:30 - exercise for you try to get the actual
166:33 - position of the Apple you want to get
166:35 - the position of the Apple the position
166:37 - we already have and then add it to the
166:40 - top left of the tree and see how far you
166:43 - get
166:46 - all right let's do it for the X and I
166:49 - want to get position 0. that is always
166:51 - the X this is let me bring the drawing
166:54 - back up and let me clear up a tiny bit
166:56 - this position 0 is basically telling me
166:59 - how far from the left of the tree I want
167:02 - to go to this I have to add self.rect
167:05 - dot left and this self-directed left is
167:09 - the left side of the tree
167:11 - meaning this side here is this side or
167:16 - in other words it is this distance here
167:19 - combined we are getting this entire
167:21 - Arrow here and this is where we want to
167:23 - place the actual Apple
167:25 - at least on the horizontal axis for the
167:28 - Y this is going to look very similar we
167:30 - want pulse 1 and then self.rect dot top
167:34 - and this is the actual X and Y position
167:37 - we want this is what I want to pass in
167:40 - here for X and Y
167:42 - finally for the group
167:44 - I want to have two groups in here the
167:47 - first one is easy I want to have self
167:48 - dot Apple Sprites
167:51 - besides that I also want to put all of
167:55 - these apples into all Sprites because
167:57 - that's the only way to display them to
167:59 - the player the problem is we don't
168:01 - really have those available anywhere
168:04 - inside of this entire python file we
168:07 - only really have them inside of the
168:09 - level so this all Sprites
168:11 - now the workaround here is every single
168:15 - Sprite has the attributes of what
168:17 - Sprites it is part of and this we can
168:19 - access with self dot groups and these
168:22 - are all of the groups the tree Sprite is
168:24 - in
168:25 - this I do have to call and this is going
168:27 - to return a list and from this list I
168:30 - want to pick the first element
168:33 - and this first element if I look at my
168:36 - level where I am creating the trees
168:40 - this one here the first element is going
168:43 - to be all Sprites the second element is
168:45 - going to be Collision Sprites
168:47 - this is what I'm getting with this line
168:50 - here
168:51 - so that way I am placing each apple into
168:53 - Apple Sprites that's the Sprite group of
168:56 - the tree and then into all Sprites that
168:58 - way they are going to be visible
169:00 - there's one more thing that we need and
169:02 - let me put all of this over multiple
169:04 - lines with named arguments
169:06 - otherwise this is going to be very hard
169:08 - to read this one is groups and finally
169:13 - the one thing I forgot is we need a z
169:16 - position
169:17 - fortunately this one is very easy we
169:19 - need layers
169:21 - and inside of settings inside of layers
169:25 - we have a fruit layer this is where the
169:28 - apples should be on
169:30 - every time we are creating the tree I
169:33 - want to call Self dot create fruit and
169:37 - this should be working let's try so I
169:39 - now run main.pi and look at a tree we
169:43 - can see
169:44 - quite a lot of apples this is looking
169:46 - very nice
169:50 - I am very happy with this we are
169:52 - definitely making progress
169:54 - next up I want to have the logic that we
169:58 - can hit the player and let me minimize
170:00 - create fruit we don't need it anymore
170:03 - so let me call this the tree at tributes
170:07 - in here first of all each tree is going
170:10 - to have an amount of Health which I'm
170:12 - always going to set to five but choose
170:15 - whatever you want in here besides that I
170:17 - also want self dot alive and by default
170:20 - this is going to be true if this one is
170:22 - false the tree for example wouldn't
170:25 - create fruits but this is going to come
170:27 - later
170:28 - besides that I also want to have what I
170:30 - call self.stump underscore surface and
170:34 - this is what the tree is going to look
170:36 - like if the tree was destroyed so once a
170:39 - life is false we want to display a stump
170:41 - surface instead of the tree
170:43 - and this we have to import with pygame
170:45 - DOT image.load
170:48 - and in here I want to create an F string
170:51 - because we have to decide between two
170:53 - different files so there's one stem for
170:55 - the small tree and one for the large
170:57 - tree
170:58 - for both we have to go up one folder
171:00 - then to graphics and there's a folder
171:02 - called stumps and here I want to work
171:05 - with variables and this should be
171:08 - small
171:09 - if name
171:11 - is equal to small and if that is not the
171:16 - case it should be large
171:19 - and don't forget this should be PNG this
171:22 - is getting really large and I made a
171:24 - typo so let's put this on a separate
171:27 - line
171:28 - let's call this the stump path
171:32 - so I want to get this out of here
171:34 - and paste it in there
171:37 - and place this stump path in here and
171:40 - now don't forget we also have to convert
171:42 - Alpha this one there's one more thing
171:45 - that we do need and that is a timer so I
171:48 - want to have self dot invol underscore
171:51 - timer it's going to be a timer that
171:54 - lasts for about 200 milliseconds why we
171:57 - need this timer I'm going to visualize
171:58 - in just a second for now just follow
172:00 - along but this is basically all we need
172:03 - for the three attributes
172:05 - now that we have that I want to create
172:07 - another method and this I'm going to
172:10 - call damage
172:12 - here we need self and nothing else this
172:15 - method is well damaging the tree so I
172:18 - want self.health minus equal 1.
172:22 - and this is going to be damaging
172:26 - the
172:27 - three
172:28 - besides that every time we're hitting
172:30 - the tree with an X I also want to remove
172:34 - an apple but I only want to do that if
172:37 - there is an apple meaning first of all I
172:40 - want to check the length of self dot
172:42 - Apple Sprites dot Sprites
172:46 - if this list here is zero there is no
172:49 - point in removing an apple so I only
172:51 - want to do this if this list is greater
172:53 - than zero if that is the case I want to
172:56 - pick a random apple and store it in a
172:59 - variable and to pick a random Apple I
173:02 - need the choice function and this one I
173:04 - also get from random so besides Rand int
173:07 - I want to import choice
173:09 - and in here I want choice and I want
173:12 - self dot Apple Sprites
173:15 - dot Sprites and this random apple I want
173:20 - to destroy with the kill method
173:22 - so now we just have to figure out how to
173:26 - call this damage method
173:28 - and this is going to happen inside of
173:32 - the player although for that to work we
173:35 - need a few more things so let me
173:36 - minimize everything inside of the player
173:38 - first of all the player needs to know
173:41 - where all of the trees are and for that
173:44 - to work back in my level let me minimize
173:46 - all of these methods as well I want to
173:49 - create another group and this I called
173:52 - self dot three
173:55 - brights again this is just going to be
173:58 - pygam.sprite.group all of the trees that
174:01 - I am going to create which happens down
174:04 - here
174:05 - each tree is supposed to be in all
174:07 - Sprites Collision Sprites and also in
174:11 - self.3 Sprites
174:13 - really important here make sure that
174:16 - self at all Sprites is the first Sprite
174:19 - inside of the list
174:21 - if that is not the case then
174:24 - inside of create fruit this line here
174:27 - would not work anymore so be careful
174:29 - here
174:30 - but now that we have that I can minimize
174:33 - the setup actually I can't because I
174:36 - have to pass
174:37 - into my player this one here
174:41 - let me put all of this over multiple
174:43 - lines because this is also getting
174:45 - really hard to read
174:47 - we have a position
174:49 - we have a group I think it was a
174:52 - singular group right yeah just group
174:54 - besides that we have Collision
174:59 - Sprites and finally I want to add one
175:02 - more parameter and this is called trees
175:05 - and this is going to be self dot re
175:08 - Sprites
175:10 - and now inside of the player in the init
175:13 - method I want to create three
175:16 - Sprites next up I have to convert all of
175:20 - this into an attribute let me put it all
175:22 - the way at the bottom here and let me
175:24 - create another section that I call
175:26 - interaction there are going to be quite
175:29 - a few things we need to interact with
175:30 - but in here I want to have myself Dot
175:34 - three Sprites and this is going to be
175:37 - the tree Sprites parameter now we have
175:40 - to figure out how to actually Target
175:42 - this thing and this is going to happen
175:44 - inside of a use tool
175:46 - remember this we created ages ago about
175:50 - two hours by now but this method is
175:53 - being called every time we are using a
175:55 - tool and in here I want to check what
175:58 - tool we are currently using so if self
176:00 - Dot
176:02 - selected tool is equal to let's start
176:07 - with a hole if that is the case I want
176:10 - to pass for now
176:12 - besides that I can duplicate this line
176:15 - I want to check if the selected tool is
176:18 - an X and this is what we want to work on
176:21 - in this part but for now let me add a
176:23 - pass in here and finally I also want to
176:26 - check
176:28 - if I'll select the tool is water
176:31 - although in here for now also going to
176:34 - be a pass
176:35 - if we are using the X I want to check
176:38 - for 3 in self Dot 3 Sprites Dot brights
176:45 - don't forget to call it
176:47 - and now I want to check if we are
176:49 - actually hitting the tree which means if
176:52 - 3 and now I have to figure out if we are
176:57 - actually hitting the tree the problem is
176:59 - I don't really have any way to know
177:02 - which point I'm actually targeting
177:04 - meaning let me comment out all of this
177:07 - for now and let me run the code
177:09 - and I'm getting an arrow because I
177:12 - didn't import the timer
177:14 - so from timer import timer now let's try
177:19 - this again we are getting another error
177:22 - that the player
177:24 - this is probably happening in level
177:27 - this should be 3 underscore Sprites
177:32 - now it's working
177:33 - right now I can use the different tools
177:36 - and this is working perfectly fine for
177:38 - all of them
177:39 - the issue is right now we have no idea
177:42 - which point we are targeting for example
177:45 - if I'm using the X I want to know that I
177:48 - am basically targeting this point here
177:51 - let me use the X again this looks about
177:54 - right
177:55 - and this point I have to get in my code
178:00 - so back in my player let me minimize the
178:03 - init method and in here
178:05 - I want to create another method that I'm
178:09 - going to call get underscore Target
178:11 - underscore position and all I really
178:13 - want to do in here is I want to create
178:16 - another attribute that I'm going to call
178:18 - self.target position
178:21 - this is going to be the same for all of
178:22 - the tools which makes it quite easy to
178:24 - work with and the basic logic here is
178:28 - if this is our player and this is the
178:32 - center of the player for each of the
178:34 - tools for example if the player is
178:35 - looking to the left
178:37 - then I want the tool to be somewhere
178:41 - here
178:42 - a certain distance to the left of the
178:44 - player and a bit further down
178:47 - the reason why I have to move it down is
178:49 - because most of the tools like the X for
178:52 - example they go in this direction here
178:55 - basically what I want to do I want to
178:58 - get self.rect.center
179:00 - and then I'm going to need some kind of
179:02 - offset
179:03 - and this offset
179:06 - I am getting from my settings because in
179:08 - here we have player tool offsets and
179:11 - these are a bunch of offsets that we can
179:13 - work with meaning this is what I want to
179:16 - copy
179:18 - paste it inside of the player and now we
179:22 - have a dictionary that we want to take
179:24 - some information from
179:25 - notice here the keys are called left
179:28 - right up and down which is the same as
179:32 - the status of the player
179:33 - which is very handy because now we can
179:36 - get self.status dot split
179:39 - and as always we want to split it
179:41 - wherever there's an underscore and then
179:43 - pick the index 0 of that list
179:46 - and this is basically all we need for
179:50 - this one method I guess importantly do
179:53 - not forget to call it
179:54 - right after the timers so self dot get
179:57 - Target position
180:01 - now the problem is that this target
180:03 - position is going to be really hard to
180:06 - see at least for now for testing
180:08 - purposes we do need some way to
180:10 - visualize it and I just realized this
180:11 - should be status not stats
180:14 - and since this isn't something the
180:16 - player is supposed to see
180:18 - we can just do this really quick so for
180:21 - testing purposes back in level dot Pi
180:23 - all the way at the end of custom draw I
180:26 - added a tiny bit more code that looks
180:28 - like this
180:29 - if you go through this basically what we
180:31 - are doing is we are drawing a rectangle
180:34 - another rectangle and a circle
180:37 - the result is going to look like this
180:41 - this is telling us the red line is the
180:46 - rectangle of the player the green line
180:49 - is the Collision rectangle and the blue
180:52 - dot this one here is the target position
180:56 - so if I use a tool
180:59 - you can kind of see where it's going and
181:01 - this also works with the X and with the
181:03 - watering can
181:05 - and well this way you can play around
181:08 - with this quite a bit more
181:10 - although for the actual game you don't
181:12 - need it so most of the time you're just
181:15 - going to comment it out or remove it
181:17 - entirely
181:18 - but I guess let me keep it for now
181:20 - because now we know that the target
181:22 - position so the blue dot looks pretty
181:25 - good
181:28 - now with that we can uncomment this part
181:31 - here and now for the tree I want to look
181:35 - at the rectangle of the tree and I want
181:38 - to check if this tree is colliding with
181:41 - a point
181:42 - the point that I want to check is self
181:44 - dot Target position
181:46 - if that is the case I want to
181:50 - get the tree and then run the damage
181:52 - method
181:54 - which is this damage method here let's
181:57 - try if this is working
181:58 - so back in the game
182:04 - we are already getting a problem because
182:07 - even if I don't use the X the apples all
182:10 - disappear
182:11 - which I guess kind of looks cool but not
182:14 - ideal also this one should be commented
182:17 - one of the main reasons why it happened
182:19 - is if I open the timer again
182:24 - in here this line is causing the problem
182:27 - because there is a chance that our
182:30 - current time minus the start time is
182:32 - bigger than the duration so this could
182:34 - run forever
182:35 - and as a consequence we might trigger
182:38 - this function by accident and a really
182:40 - easy way to fix that is to add another
182:42 - end statement here that we want to check
182:45 - self.start time is different from zero
182:50 - and now let's run may not Pi again
182:53 - and now if I am colliding with a tree
182:57 - nothing happens and if I use the X also
183:00 - nothing happens
183:03 - let's try different tools okay nothing
183:05 - happens in general
183:07 - and the reason why that is happening
183:09 - inside of timer every time we are
183:12 - deactivating the timer
183:14 - we're setting the start time to zero
183:16 - meaning this is not going to run
183:18 - the activate has to be after this if
183:20 - statement and now inside of the player
183:24 - let me just
183:26 - print tool use
183:30 - just to try if this is working so now if
183:32 - I use the X I can say tool use in the
183:35 - bottom left
183:36 - and I guess now we can try to hit a tree
183:39 - there we go the Apple disappeared
183:42 - and this is working quite well
183:50 - and let me close the timer again now we
183:53 - are done with it
183:55 - back in the Sprites I want to have
183:59 - another method that checks if the tree
184:03 - is still alive so check def
184:06 - and basically all I want to do is if
184:09 - self.health is smaller or equal than
184:11 - zero
184:13 - then the tree is going to die let me
184:15 - just print that
184:18 - we just have to figure out when to call
184:20 - Jack death in my case I went with an
184:23 - update method that itself and Delta time
184:25 - like any update method and then here I'm
184:28 - going to call
184:29 - self.check Def
184:31 - actually to be a bit better here we only
184:34 - want to check def if self dot alive is
184:37 - true
184:38 - and now let me run main.pi again
184:44 - if I hit a tree with my X we get to use
184:48 - tool use and now we get that
184:51 - this is looking really good which means
184:54 - what we can do in here now is I can set
184:57 - self dot alive to false although there
185:01 - are a few more things that I do want to
185:03 - change first of all self dot image so
185:06 - what this Sprite actually looks like
185:08 - should be self dot stump service
185:11 - and since we are updating the image we
185:14 - also have to update self.rect
185:17 - this I get with self dot image dot get
185:20 - underscore rect and I want to place the
185:24 - mid
185:25 - bottom should be wherever the previous
185:31 - self.rect.mit bottom was what that means
185:34 - is if this one here is the original tree
185:37 - and we want to create a tree stump that
185:40 - is a bit smaller
185:42 - we now have to figure out in this line
185:44 - where we want to place this rectangle
185:47 - finally we also have to update the
185:49 - hitbox
185:51 - and this we get with
185:53 - self.direct.inflate actually I think
185:56 - good practice here is to copy the entire
185:58 - thing
186:00 - and now in here we are going to need a
186:04 - weft and a height or an X and the y
186:07 - basically the same thing for the three
186:09 - stumps I always went with negative 10
186:11 - and negative self.rect dot height and
186:15 - multiply this by 0.6
186:19 - let's try
186:21 - so if I now go to a tree hit the tree a
186:26 - few times there we go we have a tree
186:28 - stump I can do this with the other tree
186:30 - as well
186:32 - and we get a different kind of tree
186:34 - stump and this section is getting quite
186:37 - long so let's finish it now but in the
186:39 - next section we are going to finish up
186:41 - the trees we are nearly done with the
186:44 - trees there's only one more major thing
186:46 - that I would like to add and that is
186:48 - some particle effects so that when an
186:51 - apple disappears or when a tree
186:52 - disappears I want to show some white
186:54 - object that flashes on the screen you
186:57 - will see in a second what I mean but it
186:58 - looks quite nice once more here we have
187:01 - main.pi and I want to work inside of the
187:04 - Sprites inside of the tree in here
187:08 - whenever one of the apples disappears
187:11 - that happens here I want to basically
187:15 - create a white apple on top of the
187:17 - disappearing Apple that way we're
187:19 - indicating which Apple disappears
187:22 - also whenever the tree dies
187:25 - which happens inside of this method here
187:27 - I want to do the same thing for the tree
187:29 - so for a couple of milliseconds we have
187:31 - a white tree and then we can see the
187:33 - tree stump
187:35 - both of these are being created with
187:38 - another class let me create it right
187:40 - here and I'm going to call this one
187:42 - class particle this particle is also
187:46 - going to be a generic Sprite so it
187:48 - inherits like all of the other Sprites
187:50 - from the generic class in here as always
187:54 - we are going to need the Thunder init
187:57 - method we need self we need a position
188:01 - we need a surface we need the groups and
188:04 - we need a z layer for the parent class
188:09 - to work we need this super and tender
188:11 - init method
188:13 - this one for generic add position groups
188:17 - and the Z layer
188:19 - meaning I can copy them in here and most
188:23 - of them we don't really have to worry
188:25 - about too much
188:27 - as a matter of fact if you look at this
188:29 - closely those parameters and those
188:31 - arguments are basically identical the
188:34 - only thing I really want to change is I
188:36 - do not want to have the default argument
188:38 - now the way this particle is going to
188:41 - work is it is going to be a Sprite but
188:43 - this Sprite is going to self-destroy
188:45 - really quickly it basically has an
188:48 - internal timer let's create this one
188:49 - actually right now
188:51 - we can use the update method here and
188:53 - this one needs self and Delta time just
188:57 - so that we capture Delta time in here I
189:00 - am let me save it as the current time
189:03 - the current time I'm getting with
189:06 - pygame.time.get underscore ticks once I
189:09 - have that all I really want to do is if
189:11 - my current time minus some kind of start
189:16 - time we'll create that one in just a
189:18 - second it's greater than a certain kind
189:21 - of duration if that is the case I want
189:25 - to destroy this Sprite that way we are
189:28 - only showing this Sprite for let's say
189:30 - half a second and then it disappears
189:33 - besides that this particle is always
189:36 - going to have the same surface as for
189:38 - example a tree except it is going to
189:40 - color the entire thing White
189:42 - and that way we have some kind of
189:44 - particle effect it's a fairly minimal
189:46 - one but it does the job for this game
189:48 - we need to do two more things we need to
189:51 - get iteration and this one I should have
189:55 - put in the init parameters so in here
189:58 - duration and I do want to have a default
190:00 - value let's say 200.
190:02 - now that we have all of that I want to
190:05 - create self dot start time and this one
190:08 - is
190:10 - pygame.time.get underscore ticks
190:13 - I suppose I should mention the
190:15 - difference between this start time here
190:16 - and this current time is that the start
190:20 - time here is only being taken once
190:25 - it's basically one point in time
190:27 - whereas the current time is being
190:30 - continuously updated meaning from this
190:33 - point here we are checking another
190:34 - current time another current time
190:36 - another current time and so on and at
190:39 - some point we are hitting the duration
190:42 - meaning that this distance here is
190:45 - greater than the duration and then we
190:46 - are destroying the Sprite besides that I
190:49 - have to store my duration as an
190:52 - attribute and this I just get from my
190:54 - duration
190:56 - and this is the basic setup besides that
190:59 - we need to create the White surface
191:04 - in this we are doing via a mask
191:07 - for that I want to create a mask surface
191:10 - this I'm getting from pygame dot mask
191:13 - Dot from underscore surface
191:17 - this one needs one surface and the
191:19 - surface we have is self dot image
191:22 - now once we have that I want to create a
191:26 - new Surface
191:27 - and this new Surface we get with the
191:30 - mass surface and then two underscore
191:32 - surface
191:34 - this new Surface now is going to be a
191:36 - black and white silhouette of the
191:38 - original self.image
191:40 - any pixel that had any kind of color
191:42 - value is going to be white and any kind
191:45 - of transparent value will be black I can
191:47 - visualize this in just a second actually
191:49 - but what we need to do now is to get rid
191:51 - of all of the black color values what
191:54 - you do with new Surface and we have to
191:56 - set a color key
191:58 - the color we want to get rid of is going
192:01 - to be black so a tuple with 0 0 and 0.
192:04 - and this new Surface I want to set as
192:07 - the image of this Sprite
192:09 - there we go and this should be all we
192:12 - need for the entire class all we have to
192:14 - figure out now is when to create it and
192:17 - this happens for example inside of the
192:19 - tree or example
192:22 - when we are destroying an apple I want
192:25 - to play this particle effect
192:27 - let's do it right below the random apple
192:30 - I want to create a particle for this
192:33 - particle I want to have
192:36 - not these parameters I want to have
192:38 - these parameters
192:41 - I suppose for Simplicity we could get
192:44 - rid of the duration here because we're
192:46 - not going to need it for now
192:47 - and well now we have to figure out the
192:49 - position the surface groups and a z and
192:53 - I think this could be a really good
192:54 - exercise try to pass in all of these
192:57 - arguments and see if you can create this
192:59 - particle effect it should already be
193:01 - working once you have created it
193:06 - let's put them all on separate lines so
193:10 - I can work with named arguments and that
193:12 - should make all of this much easier to
193:13 - read
193:14 - first of all we need a position we
193:17 - already have the random Apple we want to
193:19 - destroy I want to get this random apple
193:22 - I want to get the rectangle of this
193:24 - random apple and then I want to get the
193:26 - top left
193:28 - because this particle should be in the
193:30 - same position as this apple
193:33 - along the same lines it should also have
193:35 - the same surface So Random Apple dot
193:39 - image
193:40 - for the groups we need to do basically
193:42 - the same thing we have done for the
193:44 - apples
193:45 - which means I want to have myself dot
193:48 - groups don't forget to call it and now I
193:50 - want to have the element with the index
193:52 - 0.
193:54 - now looking at all of this since we are
193:56 - doing this quite often it might be a
193:58 - good idea to put a reference to the self
194:02 - that all Sprites inside of the tree but
194:05 - um you can do this in your own time it
194:07 - isn't going to make much of a difference
194:10 - finally Ford is that parameter I also
194:13 - realized it doesn't really have a
194:15 - separate layer but you don't really need
194:17 - one you can put it inside of the fruit
194:19 - it also be inside of raindrops it
194:22 - honestly doesn't matter at this point
194:23 - let's go with fruit I guess it fits in
194:25 - there quite well
194:27 - we need layers and then there I want to
194:30 - have the fruit
194:31 - and with that we should be having a
194:34 - particle effect let's try if I run out
194:37 - of this it's the runs that's generally a
194:39 - good sign and let's use this tree here
194:42 - and there we go we have a very basic
194:45 - particle effect it is indeed very subtle
194:48 - but it certainly does work
194:52 - let me minimize the damage method and
194:55 - now we want to do the same thing for the
194:57 - tree Once the tree is being destroyed
194:59 - which we can also do quite easily once
195:02 - again I want to create a particle and
195:06 - now once again let me get all of the
195:09 - parameters we need
195:10 - and I guess for this one we can also
195:12 - change the duration
195:14 - so in here I want to have all of these
195:17 - arguments the position is going to be
195:21 - self.rect.top left
195:23 - the surface is going to be self dot
195:25 - image spelled correctly would be good as
195:28 - well
195:29 - then for the groups once more self dot
195:32 - groups with the index 0
195:35 - and for that I want to have layers
195:40 - and I guess we can put this on the fruit
195:43 - layer as well
195:45 - since this is a slightly larger object
195:47 - let's go for duration of 500. and this
195:50 - should be all we need let's try this one
195:52 - now and this one is only going to play
195:55 - once the tree is dead so we have to hit
195:58 - a tree a couple of times
196:01 - there we go I guess the effect is a tiny
196:04 - bit long
196:06 - uh let's go with 300. let's try this one
196:10 - although at this point this is quite
196:13 - subjective so you can just go with
196:14 - whatever you think looks best
196:18 - and yeah I think this is okay
196:21 - and with that we have some basic
196:23 - particle effects and these we can also
196:25 - reuse later on for the plants which is
196:27 - very nice
196:29 - which means we have covered another
196:31 - major section
196:32 - to finish off the tree we have to create
196:35 - a player inventory so that a player gets
196:37 - an apple or some wood whenever we hit a
196:40 - tree
196:41 - which means we have to connect the
196:42 - player and the tree with each other
196:44 - which is a fairly straightforward thing
196:46 - to do so let's Jump Right In once more
196:49 - we are in the code and first of all we
196:51 - have to look at the player specifically
196:54 - inside of the init method let me put it
196:57 - above the interactions and right below
197:00 - the tools and the seeds this one I want
197:02 - to call inventory because if you want to
197:05 - add something to the player the player
197:07 - needs to have some kind of system to
197:09 - store data
197:10 - and for now the player is only going to
197:13 - have a single dictionary and this I call
197:15 - Item inventory although later on there's
197:18 - going to be a bit more
197:19 - and in here we're going to have a couple
197:22 - of different key value pairs let me copy
197:24 - them in actually so you don't have to
197:25 - watch me write
197:27 - we have
197:28 - these four what an apple is what the
197:31 - player gets from the trees and Corner
197:33 - tomato is what we're getting from the
197:34 - soil
197:36 - by default all of them are going to be
197:37 - zero and let me line them up a bit nicer
197:41 - so
197:43 - this is looking better
197:46 - and these numbers we want to increase
197:47 - whenever the player for example gets a
197:50 - piece of wood or an apple
197:52 - which means we have to connect the
197:54 - player all of this here with the tree
197:58 - and since they are in different files we
198:01 - have to work via the level to make all
198:04 - of this work
198:06 - and let me minimize everything
198:10 - so we're not getting lost
198:11 - right now the level only has three
198:13 - methods even though it is quite a chunky
198:15 - class already but I want to add another
198:18 - method in here
198:19 - and this one I'm going to call player
198:22 - underscore add
198:24 - besides self we are going to need an
198:27 - item so the item we want to add to the
198:29 - player
198:30 - what is going to happen in here is I am
198:33 - targeting the player I want to get the
198:36 - item inventory of the player the one we
198:39 - just created
198:40 - from a dictionary I want to get the item
198:43 - this would be one of these key value
198:47 - pairs
198:48 - and this I want to increase by one
198:52 - I suppose you could make this a bit more
198:54 - flexible by adding another parameter
198:56 - that would be the amount for example but
198:58 - in my case I will always stick with one
199:01 - because I do want to keep things simple
199:03 - and this tutorial is already getting
199:04 - quite long
199:06 - this method I have to pass into the
199:09 - trees which means inside of setup when I
199:13 - am creating the trees this happens here
199:16 - and once again let's do this over
199:19 - multiple lines with named arguments
199:22 - so we're not getting completely lost
199:27 - we have the groups and finally this one
199:29 - was called the name
199:32 - the one additional argument we want to
199:34 - add is let's call it player add
199:37 - and this is going to be self dot player
199:40 - add make sure here not to call it
199:43 - because we only want to call it from
199:45 - inside of the tree object
199:48 - which means inside of the tree we're
199:51 - going to need another parameter
199:54 - layer add and this one we also have to
199:57 - store somewhere in the attributes
199:59 - let's do it here and self dot player add
200:03 - is going to be player add
200:06 - now that we have that
200:08 - when we are damaging the tree there is
200:11 - stuff here I want to run
200:15 - self.player ad and give the player an
200:18 - apple
200:20 - which should be all we need I guess
200:23 - inside of the level in the run method
200:26 - all the way at the bottom let me print
200:30 - itself dot player dot item inventory so
200:33 - we can tell what's going on if I run
200:36 - this now you can see in the bottom left
200:38 - the inventory of the player and if I now
200:41 - hit a tree we have one apple
200:43 - yes I can do multiple times we have two
200:45 - apples three apples that is looking
200:47 - really good
200:49 - so that is basically all we need for the
200:52 - apples
200:53 - the one last thing for the tree we have
200:55 - to do is whenever the tree dies we have
200:57 - to give the player some wood and this
200:59 - could be a fairly easy exercise for you
201:02 - so try to figure this one out yourself
201:06 - I hope that this one is fairly easy at
201:09 - this point all you need is self dot
201:11 - player ad and in here you have to add
201:14 - some wood
201:15 - let's run all of this again
201:18 - and for this one I have to hit a tree
201:21 - multiple times
201:24 - there we go now we have one word this is
201:26 - working very well
201:28 - with that I can get rid of this print
201:31 - statement here and minimize the run
201:33 - method in fact I can minimize all of
201:35 - these methods so things are easier to
201:38 - see
201:39 - and with that we are basically done with
201:42 - the basic tree although the next section
201:45 - is we have to make sure that the trees
201:47 - get new apples once we are sleeping
201:50 - which means we have to work on the logic
201:52 - to start a new day
201:54 - but that is going to be the next section
201:57 - so let's start the work on restarting
201:59 - the day for now all this means is all of
202:02 - the trees are getting some new fruits
202:04 - but later on there's going to be quite a
202:06 - bit more besides that we also have to
202:08 - work on some transitions but let's do
202:10 - all of this straight in code it isn't so
202:13 - hard it's more an organizational thing
202:15 - but let's have a look at all of this
202:18 - all right once again we are inside
202:20 - main.pi and let's start by talking about
202:23 - what we need basically I want to start a
202:26 - new day when I stand here or when the
202:28 - player stands here and presses enter so
202:30 - right next to the bat which means we
202:32 - have to check an input and we need to
202:34 - check if the player is on top of this
202:36 - carpet or at least inside of this area
202:39 - for this I already have some basic setup
202:42 - inside of tiled let's have a look at
202:44 - that
202:45 - here we have tiled if I zoom in there is
202:49 - one object
202:50 - that is called bad that is right next to
202:53 - the pad this is an empty area that I
202:56 - want to import and if the player is
202:58 - inside of this area and presses enter
203:00 - Then I want to start a new day
203:03 - once again if you want more detail on
203:05 - tiled check out the dedicated video
203:08 - now this I want to import but for the
203:12 - import I need another dedicated Sprite
203:15 - that Sprite let me put it right here I
203:20 - have called interaction
203:22 - once more this inherits from the generic
203:25 - Sprite
203:26 - although other than that it is going to
203:28 - be fairly simple we have an init method
203:30 - as always and in here we have self we
203:34 - have a position we have a size we have
203:37 - the groups and finally we have a name
203:41 - we do not need a surface in here for the
203:45 - simple reason that this kind of sprite
203:46 - is never visible anyway
203:48 - speaking of we can just create the
203:51 - surface in here and the surface we are
203:53 - creating with pygame DOT surface and
203:56 - we're passing the size in here that is
203:58 - the size we are getting from the
204:00 - parameters
204:01 - other than that I have to call the
204:04 - parent init method with super Dunder
204:06 - init and pass the surface the position
204:09 - and the groups in here
204:12 - does that position really doesn't matter
204:14 - because again this is not going to be
204:16 - visible so we can just leave it as it is
204:19 - finally we have to get self.name and
204:22 - store it as an attribute the name if I
204:25 - open tiled again
204:26 - is what you can see on the left side
204:30 - here we have a name besides the bad by
204:33 - the way this is what you are going to
204:34 - see in quite a bit
204:37 - we have the trader meaning if the player
204:41 - stands inside of this area and presses
204:42 - enter we want to open some kind of menu
204:44 - for trading but well that is something
204:48 - for later but now I just want to work
204:50 - with the bad
204:51 - but other than that we have finished the
204:54 - entire interaction class it wasn't
204:57 - actually so bad
204:58 - now we have to import it this happens
205:01 - inside of level inside of setup in here
205:05 - this is getting quite extensive the
205:08 - layer we want to work in is the player
205:11 - layer let me add a bit of white space
205:13 - here because this is the same layer
205:15 - where we have the player except now I
205:19 - want to check if obj dot name is equal
205:23 - to bet
205:26 - if that is the case I want to create the
205:29 - inter
205:30 - action Sprite well that to work I need
205:34 - to import it meaning all the way at the
205:36 - top of the tree I want to have the
205:39 - interaction Sprite
205:42 - now back in here let me copy all of the
205:46 - parameters we need we need those four
205:48 - and all of those should be fairly
205:51 - straightforward for the position
205:53 - we need this same thing we have seen for
205:56 - the player so obj.x and obj Dot y
205:59 - I can just copy paste them and for the
206:02 - size we are doing something fairly
206:03 - similar except for X and Y we need width
206:07 - and we need eight
206:09 - for the group I actually want to create
206:11 - a whole new group let me do it all the
206:15 - way inside of the init method this one
206:18 - I've called self dot interaction
206:22 - rights
206:25 - but this is once again just another
206:27 - pygame.sprite dot group
206:35 - self dot interaction Sprites we don't
206:38 - need self at all Sprites here because
206:40 - again this kind of sprite is not going
206:42 - to be visible
206:43 - finally we need the name of this kind of
206:47 - Sprite
206:48 - you could write just bad in here this
206:50 - would be perfectly fine alternatively
206:53 - you could also use obj dot name you
206:56 - would be getting the same result
206:58 - and with that we have an area next up
207:02 - the player needs to know about this area
207:04 - because right now these interaction
207:07 - Sprites only exist inside of the level
207:09 - and the player has no idea about them
207:12 - as a consequence for the player which is
207:16 - right on top I want to add let me call
207:19 - it interaction and this is going to be
207:22 - self dot interaction Sprites that way
207:25 - the player has an attribute to know
207:27 - where these interaction Sprites are
207:31 - so with that inside of the player we are
207:33 - going to need one more parameter
207:36 - interaction
207:38 - this I want to store below my tree
207:41 - Sprites and let's call it interaction is
207:45 - going to be interaction
207:47 - with that the player knows where these
207:50 - kind of Sprites are all we have to do
207:52 - now is check if the player is inside of
207:55 - this area and presses the enter button
207:57 - which we are doing if I minimize all of
208:01 - the methods this is going to happen
208:03 - inside of input
208:05 - all the way at the bottom of this method
208:10 - I need another if statement if keys are
208:14 - pygame DOT a underscore return this is
208:19 - telling me if the player has pressed the
208:21 - enter button or not after I know that I
208:24 - want to know if the player collided with
208:26 - the bad Sprite for example and this I
208:29 - want to store in collided interaction
208:31 - Sprite
208:34 - this we are getting with pygame.sprite
208:36 - DOT Sprite or light
208:39 - and in here we need three arguments we
208:41 - need a Sprite we need a group and we
208:43 - need what is called do kill
208:46 - this Sprite in this example is just
208:49 - going to be self
208:50 - and we want to check the Sprite so the
208:53 - player Sprite against all of the
208:55 - interaction Sprites which we get with
208:57 - self dot interaction
209:00 - do kill
209:01 - is supposed to be false and basically
209:03 - what it means is if the player which is
209:07 - self in this example if this one
209:10 - collides with the Sprite inside of this
209:13 - group do we want to destroy this Sprite
209:16 - which in this case we don't want to do
209:20 - which is why this one is going to be
209:21 - false
209:23 - and now that we have that I want to
209:25 - check if collided interaction Sprite
209:28 - exists in the first place or rather if
209:31 - it is truthy because that is only the
209:33 - case if it has a Sprite inside
209:35 - if that is the case I want to check my
209:38 - collided Sprite the first item inside
209:41 - that can only have a B1 and of that I
209:43 - want to check the name that is the name
209:46 - we have created here if this name is
209:50 - Trader
209:53 - well now I want to pass but later on we
209:55 - are doing something else in here
209:56 - obviously
209:57 - if that is not the case which means we
210:00 - have the bad then I want to do something
210:03 - else
210:04 - one thing I do want to do in here is ADD
210:07 - self dot status is going to be left idle
210:14 - the main reason for that is
210:17 - if
210:19 - this is the player and we have the bad
210:22 - here
210:23 - if the player presses enter I want the
210:25 - player to point Towards the bed
210:28 - it would be kind of weird if the player
210:29 - looked to the right then we press enter
210:31 - and then we start a new day it's kind of
210:34 - feeling bad
210:35 - let's try this one actually it should be
210:38 - working
210:39 - and we're getting an error that element
210:41 - property with does not exist do you mean
210:44 - with
210:45 - this happened inside of the level and
210:48 - here we need width
210:50 - not a stress again this is looking
210:52 - better and now if I look to the right
210:56 - and press enter the player is looking to
210:58 - the left so this is working very good
211:02 - with that we can tell if the player is
211:04 - next to the bed and pressing enter so
211:07 - with that we can actually start working
211:09 - on the day transition
211:12 - for that we have two elements we need to
211:15 - cover first of all we have to basically
211:17 - restart the level in our case this just
211:20 - means all of the trees are going to get
211:22 - some new apples if they are still alive
211:25 - besides that we also have to play some
211:27 - kind of transition that indicates we
211:29 - have a new day
211:31 - let's start by resetting the entire
211:33 - level
211:34 - which is going to happen inside of level
211:36 - and I really want to hide the setup
211:39 - method this one is really large
211:42 - and all of the reset logic should be in
211:45 - a dedicated method called reset
211:47 - this one doesn't need any parameters and
211:50 - in here we basically want to reset
211:53 - everything
211:54 - which for now is just going to be the
211:56 - trees
211:57 - or rather the apples on the grease
212:03 - the way I approach this I first of all
212:05 - have to get every individual tree which
212:07 - I get with 4 3 in self dot three Sprites
212:11 - dot Sprites
212:15 - in here we actually have not too much
212:18 - work to do because if you look at the
212:21 - tree we have a dedicated function if I
212:25 - minimize everything we have a function
212:27 - called create fruit and this one creates
212:30 - all of the fruits that we need meaning
212:32 - all we really have to do is call tree
212:34 - dot create
212:36 - root
212:38 - although now we do have a problem
212:39 - because we are not destroying the
212:41 - existing apples
212:42 - that however is quite easily done all we
212:45 - have to do is for apple in three dot
212:50 - Apple
212:51 - underscore Sprites
212:54 - Dot writes don't forget to call it and I
212:58 - want to destroy with the kill method all
213:01 - of the apples
213:02 - with that we are getting rid of all of
213:04 - the apples and we are creating new
213:06 - apples which is basically every set
213:09 - what we now have to figure out is when
213:12 - to call this method because remember we
213:15 - are updating the level inside of the
213:19 - player not inside of the level class
213:21 - itself
213:22 - which means I have to connect the reset
213:24 - to the player although there's going to
213:27 - be another problem because besides the
213:29 - player this reset also needs to be
213:32 - connected to a transition effect
213:34 - oh that is going to work is basically
213:38 - the entire screen is going to go dark
213:41 - then we are resetting the level and then
213:43 - we're making the screen go back to
213:45 - normal
213:47 - inside of this transition reset is going
213:50 - to be played here which means we need a
213:53 - system where the player the level and
213:55 - the transition all work together
213:58 - and this well let's go for it step by
214:01 - step first of all inside of the player
214:04 - oriented method I want to have one more
214:07 - attribute this I called self dot sleep
214:10 - by default this one is going to be false
214:14 - if the player now presses enter and goes
214:17 - to bed all the way down here I want to
214:19 - set self dot sleep
214:22 - to Roo
214:24 - that way we know if the player is
214:26 - sleeping or not and this we can use to
214:28 - start a transition
214:31 - that is going to happen inside of the
214:33 - level inside of run
214:35 - all the way at the end
214:37 - I want to check if player this should be
214:41 - self Dodge player dot sleep
214:44 - then I want to do something like
214:47 - self.transition this one doesn't exist
214:49 - yet dot lay
214:51 - and this one is going to need Delta time
214:54 - now this transition is going to be a
214:57 - separate class and this class is going
214:59 - to call the reset method once we are in
215:02 - a certain point of the transition
215:03 - animation which basically means inside
215:07 - of the init method
215:09 - I want to create
215:13 - self.transition this is going to be in
215:15 - transition class we will create in just
215:18 - a second and this one is going to get
215:20 - self dot reset
215:22 - and it's going to get self.player
215:25 - with that we can actually create this
215:29 - new class
215:30 - let me save it as transition dot pi
215:35 - once again we have to import Pi game for
215:38 - the obvious reasons and we need from
215:40 - settings import everything
215:43 - the class we want to create is called
215:45 - transition
215:47 - no need for inheritance but I do need a
215:50 - Dunder init method because this one
215:52 - needs self reset and the player
215:57 - inside of this we first of all need to
215:59 - get the display surface because we want
216:03 - to be able to draw on the level itself
216:06 - this one we get with pygame dot display
216:08 - dot get underscore surface
216:12 - besides that we have to capture the
216:14 - reset method inside of an attribute
216:19 - and we have to do the same thing for the
216:21 - layer
216:24 - let me call this part here setup
216:30 - and besides that we are going to need an
216:33 - overlay image
216:37 - or the overlay image we are basically
216:40 - going to create a black image and then
216:42 - we're going to change the transparency
216:44 - or rather the blending mode but in this
216:46 - case this is going to be the same I'm
216:48 - going to explain this as we implement it
216:50 - but first of all I need self
216:53 - dot image
216:55 - and this is going to be pygame dot
216:58 - surface
216:59 - and the dimensions here
217:01 - we are getting from the settings because
217:03 - I want to have the screen width and the
217:05 - screen height
217:06 - let me copy this screen with paste it in
217:09 - here
217:10 - and the second one should be screen
217:12 - height
217:14 - this right now is giving us a surface
217:16 - the size of the entire window that is
217:19 - entirely black
217:21 - besides that I also want to have self
217:24 - dot color this one is 255 by default and
217:28 - then self dot speed
217:30 - this one is going to be negative 2.
217:33 - how these two attributes are going to
217:36 - work I think the best way to explain
217:38 - this is let's use them right away so I
217:41 - want to have some kind of play method
217:43 - that needs self
217:45 - and in here I want to self dot color
217:50 - plus equal self dot speed
217:55 - and that information I can use to fill
217:57 - my image so self dot image dot fill
218:01 - and in here I need an RGB Tuple we need
218:04 - red we need green and we need blue
218:07 - in this case since we only care between
218:10 - a black and a white color they can all
218:13 - be the same color
218:16 - this image I now want to Blitz on top of
218:20 - the entire game which means self.display
218:23 - surface dot lit I need self.image the
218:27 - top left should be at position 0 and 0.
218:30 - and for now let's just leave it like
218:34 - this
218:36 - and play it because you're probably
218:39 - confused at this point
218:40 - things are going to make a lot of sense
218:42 - in just a second or at least I hope they
218:44 - will
218:45 - first of all for all of this to work we
218:47 - have to import from transition import
218:50 - transition
218:52 - that means this one here is going to
218:55 - work and now inside of the run method
219:01 - layout.sleep is also going to work
219:04 - although here that's a time we don't
219:06 - actually need
219:08 - now with that let's try main.pi and
219:12 - let's press enter next to the bat
219:15 - and we're getting some very strange
219:17 - effect and we're getting an error
219:18 - message
219:20 - let's try it again really quick
219:24 - if I run this first of all we get white
219:26 - and then we go darker and darker and
219:29 - that is exactly what I wanted
219:31 - the entire logic is going to happen
219:33 - inside of play
219:35 - in here
219:36 - cell for color on the first frame is 255
219:40 - which with the fill method here
219:43 - means we are turning the entire image
219:46 - white all of these self.colors are 255
219:49 - and those are the values for pure white
219:54 - and if you put this on top of the
219:57 - display surface we are getting a white
219:59 - image
220:00 - however now we are updating in this line
220:04 - the color
220:06 - which means on every single frame the
220:09 - color is going to be a tiny bit darker
220:12 - because of that we started with a white
220:14 - image and it became darker and darker
220:17 - and at some point this after color got
220:20 - negative and this is where we get the
220:22 - error
220:23 - and this doesn't seem very much right
220:26 - now but we can make this look much
220:28 - better by adding another argument inside
220:31 - of the blitz method
220:33 - the argument we need here is called a
220:36 - special underscore Flags
220:39 - what we can do with this is set the
220:40 - blending mode
220:42 - the one we want is pygame dot lend
220:45 - underscore rgba underscore mult
220:49 - and now if I run this and try the same
220:53 - thing again
220:55 - now we have a much nicer transition
220:59 - how this blending mode works it
221:01 - basically gets rid of all of the white
221:02 - values so the brighter value is the less
221:06 - visible it is going to be and the Pure
221:08 - White value is going to be completely
221:09 - invisible
221:11 - that way at the beginning we are not
221:13 - seeing any of this image but the darker
221:16 - it gets the more we see of it and at
221:18 - some point it turns the entire screen
221:21 - pure black although right after that the
221:24 - entire thing crashes that we do have to
221:26 - work on
221:28 - fortunately it's not that difficult all
221:30 - we have to do is if self dot color is
221:34 - smaller or equal then zero and if that
221:37 - is the case I want to set self dot speed
221:41 - and multiply it with negative one
221:45 - besides that if self dot color is
221:48 - greater than 255
221:51 - because now after these two lines
221:54 - we are increasing the color continuously
221:58 - and at some point it's going to be
222:00 - greater than 255 which is also going to
222:03 - be a problem
222:04 - we do need to limit that one as well
222:07 - if that is the case at least for now I
222:09 - want to set self dot color to 255.
222:14 - and with that we should be having a
222:16 - transition
222:17 - let me play main.pi and let's see how
222:20 - this is going to look
222:22 - we are still getting an error let's have
222:25 - a look I guess the main reason here is
222:28 - that once we get below zero
222:31 - we are only changing the speed we're not
222:33 - changing this number
222:35 - and as a consequence for this one frame
222:37 - things are falling apart but that we can
222:40 - fix quite easily all we have to do is
222:42 - set self.color to zero
222:45 - with that it should be working
222:49 - if I now walk next to the bed
222:52 - and this is working really well
222:58 - we are very nearly done
223:01 - there are three more things that we have
223:04 - to do let me write them all the way at
223:06 - the top number one we have to call the
223:09 - reset method number two we have to wake
223:12 - up the layer and number three we have to
223:17 - set the speed to negative two
223:22 - at the end of the transition
223:26 - I am pretty sure you can already tell
223:28 - where this is going this is going to be
223:30 - your exercise
223:32 - work through these three parts and try
223:34 - to implement them yourself and see how
223:36 - far you get
223:40 - the reset method I want to call when we
223:44 - are reaching this point here all I have
223:47 - to do is called self dot reset because
223:50 - reset we have stored here and this is
223:52 - the one we created in level.pi and this
223:55 - is all we needed
223:57 - let's try this one actually I created it
223:59 - but never tested it
224:01 - meaning now let's have a look at some
224:03 - trees
224:04 - you can see we have
224:07 - two apples on most of those trees
224:10 - and now if I go to bed
224:17 - and look at the trees again they are
224:20 - looking different which means the reset
224:22 - method has worked
224:24 - next up we have to wake up the player
224:27 - that should happen once the entire
224:29 - transition is over all the way at the
224:31 - bottom self dot layer dot sleep should
224:35 - be false
224:37 - on top of that while the player is
224:40 - sleeping I don't want the player to be
224:42 - able to move that would be kind of weird
224:44 - this happens inside of the player and
224:47 - all the way at the top here
224:49 - I only want to allow any kind of input
224:51 - if we are not using a tool and
224:55 - if we are not self dot sleep
225:00 - this one we can also test quite easily
225:03 - now if I press enter I will try to move
225:05 - to the left
225:06 - and I tried and now I can move again
225:09 - after a couple of milliseconds meaning
225:11 - this one is working as well
225:14 - finally we have to set the speed to
225:17 - negative 2 at the end of the transition
225:18 - this is also going to happen at the
225:21 - bottom
225:22 - all we have to do here is set self dot
225:25 - speed to negative 2. with that we are
225:29 - done
225:30 - this is the entire transition
225:33 - I guess we should probably try this a
225:35 - couple of times
225:37 - but this is working once if I try again
225:40 - now and this is working again and it
225:43 - keeps on working just fine with that we
225:45 - have a daytime transition and this one
225:49 - is going to update all of the trees as
225:51 - well
225:51 - later on once we have plans we are also
225:54 - going to make updates to those
225:56 - and that I guess we can actually start
225:58 - working on next
226:01 - with the trees finished we can start
226:03 - working on the soil and there is going
226:06 - to be a ton of logic in here basically
226:09 - what we have to do is we need one class
226:11 - that covers all of the soil and this
226:13 - glass has to be connected to all of the
226:15 - watering and all of the plants which is
226:18 - going to be a very chunky python file
226:21 - just to warn you probably for next hour
226:24 - maybe to we are going to work just on
226:27 - the soil you have been warned but for
226:30 - now just to get started let's create the
226:33 - very basic logic for the soil so if the
226:35 - player uses the hole we want to create
226:38 - one soil tile
226:40 - once again I am inside my project and I
226:44 - want to create a new file that I'm going
226:46 - to call Soil dot pi
226:49 - in here I have to import by game and I
226:53 - need from settings import everything
226:56 - with that covered I want to create a new
226:59 - class called soil layer
227:03 - no need for inheritance but in here I
227:06 - want to have a niche or Dunder init
227:08 - method with self and for now all
227:12 - Sprites
227:14 - because in here each of the soil patches
227:17 - is going to be a dedicated Sprite and to
227:20 - make them visible we have to attach them
227:22 - to all Sprites
227:23 - as a consequence we do need them
227:25 - available inside of the class
227:28 - a inside of this class I want to add one
227:31 - section let's call it
227:34 - Sprite roops
227:37 - and in here I want to have self dot or
227:39 - Sprites
227:40 - as by all Sprites besides that since I
227:45 - do want to have easy access to all of my
227:47 - soil patches I want to create another
227:49 - attribute that I call
227:51 - self.soil Sprites and this is just going
227:54 - to be another pygame dot Sprite dot
227:58 - Group after that we are going to need
228:02 - graphics and for now this is going to be
228:05 - very simple we have a single self dot
228:09 - soil underscore surface
228:11 - and this is something we are going to
228:13 - import
228:15 - here we have the project I want to go to
228:17 - Graphics in there we have the soil
228:22 - and in the app we have a bunch of
228:25 - different things but now all I want to
228:27 - import is the file called o what all of
228:30 - the other files do you will see in the
228:32 - next major part for now just don't worry
228:35 - about them it's honestly better for you
228:36 - meaning all I want to do is pygame dot
228:39 - image dot load
228:41 - the path we need here is one folder up
228:44 - then graphics
228:46 - then we need soil
228:49 - and in the app we have o dot PNG with
228:52 - that we do have a setup but now we do
228:56 - have a couple of problems first of all
228:58 - not every single tile in our map should
229:01 - be farmable let me demonstrate this
229:03 - entitled actually here's the entire
229:06 - level and I think it should be quite
229:08 - obvious that not every single tile here
229:11 - should be farmable in fact I only want
229:15 - this area here to be farmable
229:19 - this is also going to exclude the house
229:22 - and the path
229:24 - none of these should be farmable only
229:26 - the stuff that is inside of this area I
229:29 - hope you can see what I'm talking about
229:33 - for that there is a whole other layer
229:35 - called farmable if I make this one
229:37 - visible you can kind of see what I am
229:39 - talking about only the pure green tiles
229:42 - here should be farmable meaning this is
229:45 - what we have to import and then only if
229:48 - the player hits one of these areas only
229:51 - there we are going to create a soil tile
229:54 - however now we do have another problem
229:57 - and that is that we have to manage quite
230:00 - a bit of data and this I want to address
230:03 - early because it is becoming really
230:05 - important basically later on for every
230:08 - single one of the tiles we have to check
230:10 - a couple of different things let me add
230:12 - a couple of comments here in terms of
230:14 - what we need so requirements
230:18 - for each of the tiles we need to know
230:22 - if the area is farmer bill that's the
230:26 - thing you have just seen
230:28 - besides that later on for the plans we
230:31 - also need to know if the soil has been
230:34 - watered
230:35 - and we have to know if the soil has a
230:39 - plant already for example if we want to
230:42 - plant a new plant we cannot plant that
230:44 - new plant if the soil patch has a plant
230:46 - already I hope that sentence makes sense
230:49 - meaning we need to have quite a robust
230:52 - way to manage all of this data as a
230:55 - consequence I'm going to store all of
230:57 - this information in one grid
231:00 - that for now is only going to store if
231:03 - we have a farmable area or not but let's
231:06 - do all of this in a separate method that
231:08 - I called create soil underscore grid
231:12 - in here we don't need any parameters
231:15 - and in here I want to create one list
231:19 - that contains other lists and one list
231:21 - for each tile of the game
231:24 - let's do this entitled actually so when
231:27 - you look at these specific tiles here
231:29 - each of these cells is one tiled and in
231:33 - the grid I am going to create every
231:35 - single tile is going to be one list and
231:38 - this list is going to contain a couple
231:39 - of different pieces of information the
231:42 - one we're going to care about now is if
231:44 - it is farmable or not
231:47 - which I'm going to do by just adding a
231:49 - capital f inside of the list if it is
231:51 - farmable and well there's not going to
231:54 - be an F if it's not formable that way we
231:56 - can always tell which one we have
231:58 - although to create this we first of all
232:01 - have to know how tall the map is for
232:04 - that I have to import the background
232:07 - image or the floor this one I get with
232:09 - pygame DOT image dot load
232:12 - the file path here is one folder up then
232:15 - we have Graphics then we have the world
232:17 - and then we have ground dot PNG
232:21 - this one we don't have to convert
232:23 - because we're not going to show it to
232:24 - the player instead what I want to do I
232:28 - just want to know how many tiles we
232:29 - actually have in the entire thing
232:32 - I want to know how many horizontal and
232:34 - how many vertical tiles we actually have
232:36 - this information I get by simply taking
232:39 - the whole width and dividing it by the
232:41 - tile size
232:43 - for example for the horizontal tiles
232:46 - I want to get my ground and then get
232:49 - underscore with
232:51 - and floor divided by the tile underscore
232:55 - size
232:56 - this I also need for the vertical tiles
233:00 - and this I can all do on one line so V
233:02 - tiles in here
233:04 - and this one I get with ground dot get
233:07 - underscore height
233:10 - although this one also has to be floor
233:11 - divided by tile underscore size
233:15 - I guess while we're here let me actually
233:17 - print the H tiles and the V tiles
233:22 - also I do want to call this method here
233:25 - in the init method so self dot create
233:27 - soil grid
233:29 - although first of all I do want to
233:32 - create this soil file inside of my level
233:35 - that way I can show you what the
233:38 - progress is while we are making it that
233:40 - should make all of this easier to follow
233:43 - all I really want here is from soil
233:46 - import soil layer
233:50 - this soil layer should become an
233:52 - attribute let's call it soil underscore
233:55 - layer
233:56 - and here soil layer really important we
234:00 - have to pass in one argument and that is
234:02 - going to be all Sprites
234:04 - which we get up here
234:07 - and now if I run all of this we can see
234:10 - we have 50 horizontal tiles and 40
234:13 - vertical tiles
234:15 - which if I look at tiled
234:17 - and look at map and map properties we
234:20 - have in the top left
234:23 - the width and the height and this is 50
234:26 - and 40. so this one is working just fine
234:29 - this I can now use to create a list of
234:32 - lists with every single tile being one
234:35 - individual list this is going to happen
234:37 - inside of soil.pi and what I want to
234:41 - create is self dot grid
234:45 - this one we are going to do with list
234:47 - comprehension and let me add a bit of
234:50 - white space in here because this one
234:52 - gets slightly more complicated
234:56 - first of all I want to go through every
234:58 - single one of my columns and I want to
235:00 - create an empty list for my column in
235:04 - range
235:05 - page tiles
235:08 - although this is only a single one so
235:11 - I'm going to put this in another list
235:14 - comprehension
235:15 - which is going to be for rho in range V
235:20 - tiles
235:21 - now I can get rid of the white space
235:26 - and let me just print what we actually
235:29 - get so self dot grid
235:31 - run all of this and we are getting
235:35 - a very long list of lists the entire
235:39 - thing is one long list inside of this
235:43 - list we have one list for each row
235:46 - inside of the game
235:48 - and then inside of this row we have one
235:52 - more list for each individual cell
235:55 - now that we have that we have to
235:57 - actually check inside of tiled
235:59 - let me open it again we have to know
236:02 - which of these tiles are farmable and
236:05 - for that we need Pi TMX again meaning I
236:08 - want from PI TMX dot util underscore Pi
236:14 - game import load underscore Pi game
236:18 - once I have that I want to use load Pi
236:22 - game and load my TMX data file that I
236:25 - get by going up one folder there we have
236:29 - data in the app we have map dot TMX
236:33 - since we are only going to use this once
236:35 - I can use a method straight away and
236:38 - that is get layer by name
236:43 - the layer we need is called Pharma bill
236:47 - and on this one we want to get the tiles
236:51 - because this one allows us to use all of
236:53 - this inside of a for Loop
236:55 - meaning and here this is the one we have
236:57 - already seen we have 4X Y and a surface
237:01 - in load Pi game
237:04 - although for this one we don't really
237:05 - care about the surface meaning I'm going
237:07 - to use an underscore to just ignore it
237:10 - or to indicate that I don't care about
237:12 - it
237:13 - what I now have to do is to figure out
237:16 - which of these grid cells corresponds to
237:18 - the X and Y values and then add a
237:21 - capital f for each of those which is
237:24 - honestly very simple all I need is
237:26 - self.grid
237:27 - and first of all I need the row which is
237:30 - the Y position this is going to give me
237:32 - another list and on this list I want to
237:35 - get the X position which is the column
237:38 - and now I'm getting a list and I want to
237:41 - append a capital f to that
237:45 - that is basically it if I now print self
237:48 - dot grid
237:51 - and run all of this we are getting an
237:54 - even stranger list
237:56 - what we're seeing in here is every
237:59 - single cell where we have a capital F
238:00 - this cell can be farmed
238:03 - what you should be seeing here actually
238:05 - is the first couple of lists should be
238:07 - entirely empty because on the top of the
238:09 - map there's nothing farmable and we only
238:12 - get a bit further down and actual F tile
238:18 - I suppose we can make this a bit easier
238:21 - to read by going for Row in self dot
238:25 - grid
238:27 - and then print the row
238:31 - if I now run all of this this is well
238:35 - still very difficult to read but you can
238:38 - see it a tiny bit better this one here
238:40 - is the first row there's nothing and
238:42 - this continues for a couple more rows
238:44 - quite a few actually
238:46 - and at some point for this row here we
238:48 - have a couple of empty cells and then we
238:50 - start having four cells that are
238:53 - actually being farmable if I look at
238:55 - this inside of tiled you can see on the
238:58 - first row we have a lot of nothing and
239:01 - then we have four cells that are going
239:03 - to be farmable
239:05 - which is a pretty good sign that this is
239:07 - going to work
239:09 - I guess for one double check on the next
239:11 - row we have a couple more cells that are
239:13 - farmable and then we have a gap and a
239:16 - few more cells
239:18 - let's check this one out
239:20 - on the next row we have a gap then we
239:23 - have six thumb cells then we have
239:26 - another Gap and then a few more
239:28 - foundable tiles so this is looking
239:30 - pretty good
239:32 - with that we have a great
239:34 - that can store at least one bit of
239:37 - information
239:39 - it is going to get a bit more
239:40 - complicated later on actually
239:43 - what we now have to figure out is how
239:45 - the player can hit all of those with the
239:48 - hole for that I want to create another
239:51 - method and this I called create Hit
239:54 - rects no need for any kind of parameters
239:57 - here and what we are going to do is for
240:00 - every single tile we are going to create
240:02 - a rectangle that the player can hit
240:04 - this I'm going to store in self dot hit
240:07 - rects which is just going to be a list
240:11 - and now I have to cycle through
240:14 - myself.gridlist and convert all of the
240:17 - cells into actual positions and for that
240:20 - I am going to need the enumerate method
240:24 - let's go through it slowly
240:26 - I first of all want to get for Row in
240:30 - self dot grid and inside of that I want
240:34 - for cell in row
240:38 - let me give a bit of white space here to
240:40 - explain what is going to happen
240:42 - we essentially have a list
240:45 - that is going to contain let me draw it
240:48 - really quick so we have a couple of
240:50 - lists and inside of each list we have a
240:53 - few more lists
240:55 - the first for Loop this one here goes
240:59 - through all of the lists and then the
241:02 - inner for Loop this one here goes
241:04 - through these lists here which is
241:06 - basically horizontal axis
241:08 - the problem we have right now is we need
241:10 - to know on what list we are on for
241:13 - example we have to know that this one is
241:15 - list zero this one is list one this one
241:17 - is list two and so on
241:20 - and for that we need enumerate
241:22 - I want to put both of these inside of an
241:26 - enumerate function that way we are first
241:30 - getting the index we are on and then the
241:32 - actual information
241:33 - let's call this one the index row
241:37 - and the second one I called the index
241:41 - column
241:42 - inside of this we can actually check
241:44 - every individual cell and I want to
241:46 - check if f is inside of the cell
241:51 - if that is the case
241:53 - I want to create an X position I want to
241:57 - create a y position and then I want to
242:00 - create a rectangle and this rectangle I
242:04 - want to append to
242:05 - myself.hittrex.append.rect
242:09 - and now for the position and the
242:11 - rectangle I think this could be a really
242:13 - good exercise I hope you're not entirely
242:15 - lost at this point
242:17 - but try to figure out we are now
242:19 - creating a couple of rectangles and for
242:21 - each rectangle we have to convert the
242:24 - position in the grid to an actual X Y
242:27 - position inside of our game
242:30 - so try if you can figure this one out
242:33 - we know where each cell is inside of the
242:36 - grid we also know what the tile size is
242:38 - if you want a hint but pause the video
242:41 - now and try to figure this one out
242:42 - yourself
242:46 - this is actually fairly simple all we
242:49 - need for the X position is the index
242:51 - column multiplying it by the tile size
242:55 - well why this is going to be the index
242:59 - row also multiplied by the tile size
243:03 - finally then for the rectangle we have
243:05 - Pi game Dot rect
243:07 - and and here we need X we need Y and
243:10 - then we need the tire size and the tile
243:13 - size
243:14 - meaning for this rectangle X and Y is
243:17 - the top left and the tile size is always
243:19 - going to be 64 by 64. and that way we
243:23 - have a rectangle created for every
243:27 - single cell that has an F
243:30 - do not forget to call this one down self
243:33 - dot create Hit rects
243:38 - and now we actually have something the
243:40 - player can hit
243:42 - although I guess for this one we have to
243:45 - create another method let's call this
243:47 - one get hit
243:49 - in here we need itself and I want to
243:51 - have a point and this is the point the
243:54 - player can hit
243:56 - in here I want to check for wrecked in
243:59 - self dot hit underscore rects
244:02 - and I want to check for each rectangle
244:05 - if the rectangle was being hit by the
244:08 - point we have specified in the parameter
244:10 - which we get with rect DOT Collide point
244:14 - and the point we're getting from the
244:16 - parameter
244:17 - if that is the case I have to convert
244:20 - this rectangle position back into my
244:24 - grid and that way I can identify if I
244:26 - have a list with an F or not
244:30 - and well for that I have to do basically
244:32 - the opposite I have done here
244:35 - I need an X and I need a y position and
244:39 - for the X I want to get my rect.x and
244:44 - floor divided by the tile size
244:47 - this I also want to do for y except now
244:49 - it's rect.y
244:51 - flow divided by the tile size
244:56 - the way you want to think about it let's
244:58 - say we have one tile here and another
245:01 - tile here the first tile starts at
245:04 - position zero and zero the second one at
245:08 - position 64 and 0. these points here
245:15 - if we now for example for X have
245:18 - something like
245:20 - 91. if I Fluor divide 91 by 64 we are
245:26 - going to get 1. which is going to be
245:30 - this tile here that way I have converted
245:34 - a pixel position this one here into an
245:37 - actual tile position that we can use to
245:39 - get information from this self.grid
245:42 - and with that I can check if the string
245:45 - f is in self dot grid and once again we
245:51 - have the entire list of lists we first
245:53 - want to get Y for the rows and then we
245:55 - want to get X for the columns
245:58 - and now if that is the case I want to
246:01 - print let's call it Farm Bill
246:05 - what we now have to check is how to call
246:08 - this self dot get hit
246:10 - my solution to that is I'm going to pass
246:13 - a reference to the entire soil layer
246:15 - into the player which happens inside of
246:18 - the level inside of the setup method
246:22 - when I create the player the player is
246:25 - going to have one more parameter that I
246:28 - called soil layer this is going to be
246:30 - self dot soil layer
246:34 - that way inside of the player
246:36 - I can create another attribute
246:40 - soil layer
246:42 - don't forget to turn this parameter into
246:45 - an actual attribute
246:47 - self.soil layer is soil layer and now
246:52 - when we are using the tool
246:54 - I can get rid of the print statement and
246:58 - when we're using the whole I want to get
247:01 - self.soil layer and that way I can
247:05 - Target or use this method here
247:08 - which means inside of player I want dot
247:12 - get
247:14 - and the position is the same Target
247:16 - position we have used for the X
247:19 - Target position in here and now this
247:22 - should be working let's try
247:25 - although we're getting an error the
247:27 - level object has no attribute soil layer
247:29 - let's have a look
247:31 - inside of level we need a soil layer and
247:34 - I think it is called it soil
247:36 - ah no the problem is I am creating soil
247:39 - layer after the setup method that is a
247:43 - very easy thing to fix all I need is the
247:44 - soil layer before this setup method now
247:47 - if I run this there we go and I can use
247:50 - the hole and we get farmable if I use
247:53 - this here but if I go further to the
247:55 - right and use it here we are not getting
247:58 - anything
247:59 - and let me make this a bit smaller there
248:01 - we go
248:02 - with that we know where we are hitting
248:06 - something
248:07 - or more importantly if that is farmable
248:09 - or not
248:11 - if that is the case I want to get myself
248:14 - dot grid
248:17 - with the Y and the X and append
248:23 - a capital X
248:25 - this is telling me that on this tile we
248:28 - have a soil patch
248:30 - once I have that I want to run another
248:32 - method that I call create soil
248:36 - tiles
248:37 - this one for now is going to seem quite
248:40 - weird but it is going to make much more
248:42 - sense in the next video but for now
248:46 - all that is create soil tiles is going
248:50 - to do
248:51 - we need itself in here as always
248:54 - I want to get rid first of all of all of
248:57 - the existing soil tiles which I get with
249:00 - self dot soil Sprites dot empty
249:04 - after that I want to look through the
249:08 - entire grid and wherever there's an X I
249:11 - want to create a soil tile
249:13 - which means once again I can basically
249:16 - copy
249:17 - all of this here
249:20 - paste it in there
249:22 - and in here what I want to check is if
249:25 - capital x is in the cell and if that is
249:30 - the case
249:31 - I want to create a soil tile
249:34 - this one doesn't exist right now let me
249:37 - minimize a couple of methods so we have
249:39 - a bit more space we don't need any of
249:42 - this
249:43 - all the way at the top I want to create
249:45 - another class that I call Soil tile
249:48 - this one is a Sprite so we need pie game
249:51 - dot Sprite dot Sprite
249:54 - after that we have to create a Dunder
249:56 - init method this one itself a position a
250:00 - surface and the groups it's supposed to
250:02 - be part of
250:03 - then we have to call this super Thunder
250:06 - init method
250:08 - and pass the groups in here
250:10 - after that we need self.image this is
250:14 - just the surface we're getting from the
250:15 - parameters and we need self.rect this
250:18 - one we are getting with self dot image
250:20 - dot get underscore rect
250:23 - and the top left should be the position
250:28 - the position and the surface here are
250:30 - really important
250:31 - finally this one is going to need a
250:34 - self.z position this one fortunately is
250:37 - very easy because if you look at the
250:40 - settings we have a dedicated layer for
250:43 - the soil this I want to copy and paste
250:46 - it in here
250:48 - and now we have a basic soil tile all we
250:52 - have to do now is to pass in all of the
250:54 - information into the class to create it
250:58 - for the position this is something we
251:01 - have already seen inside of create Hit
251:04 - rectangles we basically want to do this
251:06 - one here again
251:07 - I guess I can just put it straight in
251:10 - here
251:11 - and with that we have the position the
251:14 - surface we also have that is inside of
251:17 - the dunder init this soil surface here
251:20 - this is what we want to paste in there
251:23 - finally for the groups I want to have
251:26 - self dot all Sprites because they are
251:29 - supposed to be visible and then self
251:33 - dot I call this one the soil Sprites
251:36 - soil Sprites
251:40 - and since this is getting quite long let
251:42 - me put it over multiple lines we have
251:44 - the position
251:47 - we have the surface
251:49 - and we have the groups that is much
251:53 - easier to read
251:54 - and with that we should have a basic
251:57 - start let's try all of this if I now hit
252:01 - the floor we have a soil tile
252:04 - this is working really well
252:07 - and if I hit
252:10 - some other field we're not getting
252:12 - anything
252:15 - with that we have the start of this soil
252:18 - tile and we also have a really efficient
252:20 - system to organize our data which is
252:23 - really important
252:25 - although this is getting a very long
252:27 - section so let's finish it for now let's
252:30 - keep on working on the soil patch
252:31 - Graphics the one really important thing
252:34 - I want to cover in this section let me
252:36 - demonstrate it when we place one patch
252:39 - it looks like this when we place another
252:41 - one right next to it it looks like this
252:45 - which is okay for a basic game but
252:47 - ideally it should be looking something
252:49 - like this
252:51 - that is what we are going to create in
252:54 - this section we are going to create our
252:56 - own Auto titling system that creates
252:58 - nice looking soil patches
253:01 - this is also the reason if I jump into
253:03 - my code
253:04 - inside of soil layer we have this weird
253:08 - setup here that every time the player is
253:11 - hitting the soil we are getting rid of
253:14 - all of the soil Sprites and then drawing
253:16 - them from scratch what this allows us to
253:19 - do is to draw all of the soil patches
253:21 - together and that way we can control
253:24 - different Graphics depending on the
253:25 - position of each soil patch or rather if
253:29 - one patch is next to another patch then
253:31 - they should get a specific kind of
253:33 - graphic
253:34 - that is what all of this here is for
253:36 - although for all of this to work we are
253:40 - going to need a whole lot more Graphics
253:42 - this is going to happen all the way at
253:44 - the top
253:45 - right now we only have a single soil
253:48 - surface
253:49 - instead what we need if I open the
253:52 - folder again inside of Graphics inside
253:54 - of soil we have to import all of these
253:58 - different elements this is what I've
253:59 - shown earlier and now basically what all
254:03 - of them do I guess I can't really make
254:05 - them larger but if you look at them
254:08 - individually for example here we have
254:10 - the left tile this is going to be placed
254:13 - if there is one tile to the right of
254:17 - this tile
254:18 - we also have a title called LR short for
254:21 - left and right this one we want to place
254:24 - if there's a tile to the right and
254:26 - another tile to the left
254:28 - there's also a file called X all the way
254:31 - at the bottom and this one is supposed
254:33 - to be placed if we have tiles all around
254:36 - it
254:39 - so I hope the logic here makes sense
254:40 - basically each of these tiles is going
254:43 - to be placed relative to where the other
254:45 - tiles are but for that we have to import
254:48 - all of them
254:50 - now this I want to save in self.soil
254:54 - underscore surfaces
254:56 - and in here you might be tempted to use
255:00 - the support file this one here and use
255:02 - import folder that however would not
255:06 - work because we need to know which file
255:08 - we are working with in all of the
255:11 - examples so far we didn't really care
255:13 - about what specific image we had we just
255:15 - used all of them but for this one we
255:18 - need to know which tile we are working
255:19 - with
255:20 - as a consequence I want to create
255:23 - another function in here I want to
255:26 - create import folder
255:29 - dictionary
255:31 - we again need a path
255:33 - although now we want to create a surface
255:37 - dictionary
255:38 - what I want to have in here is obviously
255:41 - a key value pair with the value being a
255:45 - surface one of the surfaces we are going
255:47 - to import however the key should be
255:50 - something like write it should be left
255:52 - it could also be something like X or LR
255:57 - and this is what we are getting from the
255:59 - folder so I want the key to be the name
256:02 - of each of these files and the file
256:04 - itself the value
256:05 - and that is what we have to create in
256:08 - here and this I believe could be a
256:11 - really interesting exercise look at this
256:14 - logic here and adapt it so that we are
256:17 - creating a dictionary with key value
256:19 - Pairs and at the end of it return the
256:22 - entire thing
256:23 - pause the video now and try to figure
256:25 - this one out
256:29 - a lot of the stuff I can just copy the
256:32 - first three lines are going to remain
256:33 - identical
256:35 - because in here we are just accessing
256:38 - every individual file path that we are
256:40 - going to need so no change so far
256:43 - as a matter of fact the surface is also
256:46 - going to remain the same so a lot of the
256:48 - stuff remains identical
256:50 - the one difference now is when we are
256:52 - getting the surface dictionary I don't
256:56 - just want to append something instead I
256:58 - have to get a specific key or rather I
257:01 - have to create a specific key
257:03 - this I want to be the file name which I
257:07 - get with image and the image right now
257:10 - would be something like l dot PNG the
257:13 - PNG I do want to get rid of that I'm
257:16 - getting with split I want to split it
257:19 - wherever we have a DOT
257:21 - and then I want to get the index 0 of
257:24 - this list
257:25 - this is always going to give me the name
257:27 - of the file without the file ending
257:30 - this is going to be my key and the value
257:32 - is going to be the image surface
257:36 - and that is all we needed all we have to
257:39 - do now is to return this surface
257:41 - dictionary and we are good to go
257:45 - now back to soil.pi and in here I have
257:49 - to import from so Port import let's say
257:54 - everything
257:55 - and now I want import folder underscore
257:59 - dictionary and the file path I need is
258:03 - this one here
258:05 - I guess just to try if this is working
258:07 - let me print
258:10 - self.soil surfaces and run the entire
258:14 - thing
258:17 - the game doesn't crash that is generally
258:19 - a good sign and now we are getting what
258:22 - I wanted we have a key with for example
258:25 - B this stands for bottom and we have a
258:28 - surface associated with it
258:31 - in this we have multiple times these are
258:34 - all of the files that we wanted
258:36 - with that I can close the support file
258:38 - because we are not going to need it
258:40 - anymore
258:42 - I can also get rid of the print
258:44 - statement here this one is needed either
258:48 - and with that we are coming to the
258:52 - really fun part basically what we now
258:55 - have to do is to create the entire Auto
258:57 - tiling option so let me go through it
258:59 - step by step first of all I want to add
259:02 - a let me call it tile options in here
259:05 - I'm going to determine what is to the
259:08 - left to the right to the top and to the
259:09 - bottom of the current cell
259:12 - which means we are going to cycle in
259:15 - here through every single cell in our
259:17 - grid one cell could look like this I
259:21 - have to know what is on the right on the
259:24 - left on top and on the bottom
259:27 - this is going to determine what graphic
259:29 - we are getting in here so first of all I
259:32 - want to have easy access to all of these
259:34 - options
259:35 - which I'm going to store in a variable
259:37 - we have top we have right we have left
259:39 - and we have bottom
259:41 - I want to check if we have a capital X
259:44 - in for example for the top self dot grid
259:49 - and then usually we went with Y and X
259:53 - although those we don't have available
259:55 - right now but we do have the index row
259:58 - and the index column those we can use
260:02 - index column is basically X this one we
260:04 - can use like this and Y is going to be
260:08 - the index row this we can use here
260:10 - although for the index row since we do
260:13 - want to have the cell on top of our
260:15 - current cell this needs to be negative
260:18 - one
260:19 - and I guess while we are here we can
260:21 - also do the bottom because this one is
260:23 - very similar we can basically copy the
260:26 - entire line and instead of a negative
260:29 - one we have a positive one
260:31 - four right and left we are also checking
260:34 - for a capital x except now we are
260:38 - checking in the row and we are checking
260:43 - index column
260:46 - minus one
260:47 - this is working because we have the row
260:49 - quite easily accessible and this we can
260:52 - use
260:53 - this I want to copy one more time oh and
260:56 - I just realized write should be plus one
260:58 - and left should be -1
261:01 - and with that we know for each of the
261:03 - tiles what the neighbors are doing now
261:06 - this system is still fairly simple
261:08 - because if I open the graphic again
261:11 - or most of the tiles we are only
261:13 - checking the four directions but there
261:16 - are four more we have the top right the
261:19 - bottom right the bottom left and the top
261:22 - left I am not going to check any of
261:24 - those because that would become
261:26 - incredibly complex and I don't really
261:28 - need it but if you want to have a proper
261:31 - auto trading system you would have to do
261:33 - it which would lead to a ton of if
261:36 - statements
261:37 - but let's go through it one by one now
261:39 - first of all I need to get some kind of
261:42 - tile type
261:43 - and this by default is going to be an o
261:47 - if I open this thing here again o is the
261:52 - default one the one we have already seen
261:54 - and this is a nice default one if
261:56 - everything else fails having this one
261:58 - probably isn't going to be too bad
262:01 - and now this we can use inside of soil
262:05 - tile because in here we have a surface
262:07 - this I want to replace with soil
262:09 - surfaces which is a dictionary and this
262:13 - dictionary I can access with my tile
262:16 - type
262:17 - and let's try this one right now if I
262:20 - run main.pi and use the whole everything
262:23 - works just as before that is a good sign
262:26 - and what I can do now I could for
262:29 - example change this to an LR
262:32 - run main.pi again
262:34 - and now we are getting a different kind
262:37 - of tile
262:39 - all we have to figure out now is to make
262:41 - all of this a lot more flexible
262:44 - which is going to involve a huge amount
262:47 - of if statements
262:49 - let's start with the really easy one all
262:52 - sides this one should illustrate the
262:54 - logic here quite well basically what I
262:57 - want to check is
262:58 - all of these are either true or false
263:01 - and I want to check if all of them are
263:04 - true
263:05 - this could for example be if L and B and
263:10 - R and L
263:12 - if that is the case
263:14 - I want to have the tile type
263:17 - to B and X
263:20 - this should be an equal sign and now
263:24 - let's try this one
263:28 - so here we have the center tile and I
263:30 - want to create tiles to the left and to
263:32 - the right and now to the bottom and
263:34 - there we go the thing updated
263:38 - this was the easiest kind of side
263:41 - although this we can clean up a tiny bit
263:44 - this we're doing with the all function
263:46 - and the all function checks if all
263:49 - values inside of an iterable like a list
263:52 - are true meaning in here we can pass t r
263:55 - b and left
263:57 - and we should be having the same result
264:00 - also let me put all of this on the same
264:03 - line
264:03 - because we are going to have a lot of
264:05 - lines
264:07 - let's try this one again
264:14 - it should still have the same result
264:18 - and it does this is looking really good
264:22 - that is covering all of the sides so
264:25 - next up we can start working on the
264:30 - horizontal tiles only
264:33 - this means I want to check if I have a
264:36 - tire and if there is a tile to the left
264:39 - or to the right or to both sides
264:45 - meaning we are going to have three
264:47 - different if statements here the first
264:49 - one we want to check if L is true so
264:52 - there's a tile on the left and not any
264:57 - inside of top right and bottom any kind
265:02 - of works like all except now we want to
265:05 - check if any of those is true
265:07 - for auto work all of them have to be
265:09 - true for any to trigger
265:12 - only a single one in there has to be
265:14 - true
265:15 - and let me illustrate the logic here
265:18 - let's say we have a tile like this and
265:21 - we only want to check if there is a tile
265:24 - on the left of it this is what we are
265:26 - doing in here
265:28 - if this is true we would ideally want
265:30 - some kind of graphic that would look
265:32 - something like this
265:35 - this would be working by itself but we
265:38 - also have to check that there are no
265:40 - tiles on top to the right or at the
265:43 - bottom of the style which is what we are
265:46 - doing here
265:47 - if that was the case we would be needing
265:49 - some kind of other condition
265:52 - which we are going to do in a bit but I
265:55 - do not want to confuse the different if
265:56 - statements here
265:58 - each of those should be unique
266:01 - if that is the case though I want to
266:03 - have my tile type and now the tile
266:05 - should be right
266:08 - which means if a tile only has a tile to
266:11 - the left and nothing else we want tile
266:13 - type to be right
266:16 - let's try this one
266:18 - I have a tile here and if I had another
266:21 - one this one is going to be to the right
266:23 - I can continue doing this
266:26 - and now you can kind of see the one to
266:28 - the right works really well but the one
266:30 - in the middle gets a bit confused
266:33 - but that is something we can work on
266:37 - although first of all I can cover the
266:39 - right side which is kind of simple all I
266:41 - need is if R is true and now Bishop B T
266:47 - L and B
266:49 - we are basically doing the inverse of
266:51 - this one here and this one should be l
266:54 - then I can copy this one more time and
266:57 - now I want to check if we have a title
266:59 - to the left and to the right which means
267:02 - I want to check if R is true and if L is
267:06 - true and if we don't have top and bottom
267:10 - if that is the case
267:13 - the tile type I want is left and right
267:17 - with that I should be having the
267:20 - horizontal logic
267:21 - if I run this now
267:23 - I can create some tiles here and this is
267:27 - looking very good although if I go down
267:29 - we are getting some weird results
267:32 - but that we can start working on in the
267:36 - next part
267:37 - which is going to be vertical only
267:40 - in here I want to check if we have a
267:43 - tile on top and not any tiles inside of
267:47 - the list right left and bottom
267:50 - if that is the case the tile type I want
267:53 - should be autumn
267:56 - I can copy this one more time because
267:58 - now we can check if we have a tile at
268:00 - the bottom and I also want to check if
268:03 - we have no tiles to the right to the
268:04 - left and to the top
268:07 - if that is the case I want to have a
268:09 - tile with the type T finally one more
268:12 - time now I want to check if we have a
268:14 - tile on the bottom and on the top
268:18 - and not
268:20 - do the right to the left and that is it
268:22 - if that is the case the tiles I have are
268:26 - T and B
268:27 - with that we have the vertical tile
268:30 - types let's try this one so now if I
268:34 - only go down
268:37 - this is also looking really good and I
268:40 - can still use
268:42 - the horizontal ones as well although now
268:44 - if I connect them we are again getting
268:46 - weird results
268:49 - which means we need some more if
268:52 - statements
268:53 - let's go with the corners for this one
268:56 - if this is the tile I for example have
269:00 - to check if there is a tile to the left
269:02 - and the tile to the bottom if that is
269:06 - the case this should be a corner like
269:07 - that
269:08 - which if you could follow along so far
269:10 - should be fairly doable
269:13 - it's going to look kind of similar
269:15 - compared to these lines at the end here
269:17 - let me copy it actually
269:19 - for this one I want to check if we have
269:21 - a tile to the left and a tile to the
269:23 - bottom and I do not want to have a tire
269:26 - on the top and the tile on the right and
269:29 - if all of that is the case I want to
269:32 - have a top right tile this logic is
269:34 - going to continue like that so let me
269:37 - just copy from my notes it's going to
269:39 - look like this these are all of the
269:42 - different kind of Corners we could
269:44 - possibly have
269:45 - if I try this one now I can go down
269:49 - and now if I go to the right we have a
269:52 - corner
269:53 - the thing we are still missing though
269:55 - are T shapes because if I do this things
269:58 - are falling apart once again
270:02 - which is going to be another section and
270:05 - this is going to be T shapes in here for
270:08 - example I want to check if we have a
270:11 - tile and there is another tile on the
270:14 - top on the bottom and to the right if
270:18 - that is the case I want to have this
270:19 - kind of T shape which means in here I
270:22 - want to have if all and the tiles I want
270:25 - to look at are let's start with top
270:28 - bottom and right
270:31 - also I have to check and not left
270:35 - if that is the case I want to have a
270:37 - tile type of epr
270:41 - let's try this one
270:44 - now I have my tile and I have a tile to
270:47 - the top
270:48 - to the right I'm at the bottom and to
270:51 - the right and there we go we have a t
270:53 - piece and now if we add one more
270:55 - direction we have an X piece so this is
270:57 - working just fine
270:59 - this I now have to copy a couple of
271:00 - times because we have to cover the other
271:02 - sides as well
271:04 - next up would be top bottom and left and
271:08 - not right if we have that we have a
271:11 - title called TBL
271:14 - copy it one more time now we have
271:18 - left right and top and not bottom
271:24 - if that is the case the tile I want to
271:27 - use is called
271:28 - lrb finally the last one I want to check
271:33 - if we have left right and bottom and not
271:37 - the top and if that is the case I want
271:39 - to have LRT
271:41 - and with that we should have a proper
271:45 - auto titing system so let's try the
271:47 - entire thing now I can just go around
271:49 - create more tiles
271:51 - this is looking pretty good
271:54 - and yeah I am quite happy with this
271:56 - although you can probably see there are
272:00 - some minor thingies
272:01 - these little bits here
272:05 - they exist because the auto telling
272:07 - system here is not perfect for example
272:12 - this tile here is technically a corner
272:15 - Tire where we have a tile to the bottom
272:17 - and to the right
272:19 - and Corner tiles always have this kind
272:21 - of bit here at the end this we could get
272:24 - rid of by adding a bit more Logic for
272:26 - this tile to also check if there's
272:28 - something to the bottom right
272:30 - although in my case I think this looks
272:33 - fine and if we added more logic here
272:35 - this would become even more complex and
272:39 - I think this is already quite a lot of
272:41 - if statements so I'm going to leave it
272:43 - as it is
272:44 - and now I can minimize all of this and
272:48 - we have definitely made a ton of
272:50 - progress
272:52 - for this part we are going to work on
272:54 - the watering logic which with the
272:57 - current system in place isn't all that
273:00 - difficult to do let's Jump Right In and
273:03 - let's do it step by step
273:04 - once more we have the entire project and
273:07 - I want to start inside of the player let
273:10 - me minimize everything
273:12 - and we already have the use tool method
273:15 - here
273:16 - inside of there we have selected tool
273:19 - being water if that one is being
273:21 - triggered I want to once again get
273:24 - myself dot soil layer remember here the
273:27 - player has access to the entire soil
273:29 - layer this we have also used for the
273:31 - hole however now I want to use a method
273:34 - called water which doesn't exist right
273:36 - now but will in just a second in here
273:39 - once again we need our Target position
273:42 - and with that we can return to the soil
273:45 - file and all we have to do now is to
273:48 - create another method let's do it below
273:52 - get hit I call this one water in here we
273:55 - need itself and the target position what
273:58 - I want to check in here is if this
274:00 - target position hits any of the soil
274:02 - Sprites any of those here
274:05 - oh also I forgot the soil surface we can
274:08 - get rid of because we don't need it
274:10 - anymore
274:11 - for the water I want to check for soil
274:14 - Sprite in self.soil
274:19 - Sprites and there's already typo in
274:22 - there dot Sprites
274:25 - I want to check if soil Sprite dot rect
274:30 - dot the light point
274:32 - and in here I can add my target position
274:35 - and let's try this one first if that is
274:38 - the case I want to print
274:41 - soil tile watered and the rest should
274:46 - already work let's try I want to create
274:48 - a water tile change to the watering can
274:51 - and now use it and we get soil tile
274:55 - watered which means this here is already
274:59 - working
275:00 - this means I have to do two things
275:02 - number one I want to add an entry to the
275:07 - soil red
275:08 - which means I want to add a capital W to
275:12 - the cell
275:13 - besides that number two I want to create
275:16 - a water Sprite this is going to indicate
275:20 - that there is water on this tile
275:23 - let's start with number one in here we
275:26 - have the same problem again we have a
275:28 - position for this soil Sprite but we
275:31 - need a cell position
275:33 - which means we have to do some
275:35 - conversion
275:36 - we need an X position and a y position
275:39 - and what we need in here is the soil
275:42 - Sprite dot rect.x floor divided by the
275:47 - tile size
275:49 - this I want to do again for y let me
275:52 - copy the entire thing except now this
275:55 - should be rec.y that way I can use these
275:58 - positions to access the grid which I get
276:01 - with self dot grid
276:03 - and now I want to have my y then I want
276:07 - to have my X and then I get a list and
276:10 - to this list I want to append a capital
276:13 - w
276:15 - that way we know which tiles have been
276:18 - watered and which ones haven't
276:20 - besides that number two I want to create
276:23 - a water tile to visually indicate that
276:27 - we have indeed water this soil tile this
276:29 - water tile I want to create inside of
276:33 - this python file which is class water
276:36 - tile once again this is going to be a
276:39 - Sprite so pygame dot Sprite dot Sprite
276:43 - we also need a dander init method for
276:46 - the obvious reasons this one needs a
276:48 - position a surface and the groups
276:52 - and we also need a super Dunder init
276:55 - method this one gets the groups as well
276:59 - although this class is going to be
277:02 - fairly simple all we're going to do in
277:03 - here is self.image is what we're getting
277:06 - from the surface
277:08 - self.rect is going to be self dot image
277:11 - dot get underscore erect with the top
277:14 - left being the position like this
277:18 - and finally we're going to need self.z
277:23 - this self.set we are getting from layers
277:26 - and inside of settings
277:29 - we have a soil water layer this I want
277:32 - to copy and paste in here
277:34 - I guess if you're being specific here
277:36 - this water tile and the generic tile are
277:41 - basically identical but I do want to
277:43 - keep things as separated as I can here
277:45 - but you could be a bit more aggressive
277:47 - with inheritance here it's entirely up
277:49 - to you
277:50 - and with that we have the water tile I
277:54 - just have to call it now and for this
277:56 - one we need a position we need a surface
277:59 - and we need the grooves and that is
278:02 - going to be your exercise there are a
278:04 - couple of steps to it number one copy
278:07 - the position from the soil Sprite
278:12 - meaning this water tile should be in the
278:15 - same position as this soil Sprite here
278:17 - which should be very easy to get
278:20 - number two for the surface I want you
278:24 - guys to import the folder with the path
278:28 - let me copy it really quick the path is
278:31 - going to be this one from this folder
278:35 - randomly select one surface
278:39 - finally I want you guys to create one
278:43 - more group let's call it water Sprites
278:49 - and the water tile should be in all
278:51 - Sprites and inside of water Sprites so
278:54 - pause the video now and try to work
278:56 - through all four of those tasks and see
278:58 - how far you get
279:01 - I guess to make it easy to read let's
279:03 - store it in a separate variable but all
279:06 - we really want in here is the soil
279:08 - spread itself then dot rect which stores
279:10 - the position and then top left that is
279:15 - basically it
279:17 - for number two we have to import another
279:19 - folder and this should happen inside of
279:22 - the init method
279:24 - let's do it right below Graphics it does
279:26 - seem to make sense here I call this one
279:28 - water underscore serves and in here we
279:32 - only want to import a folder which means
279:34 - import folder
279:36 - the file path being this one here
279:40 - in case you are interested if I open the
279:42 - graphics part we have soil water and
279:46 - then there we have three different water
279:49 - kind of tiles
279:51 - from those we want to select one
279:53 - randomly
279:55 - again let's do that in a separate
279:57 - variable let's call it surface and in
280:00 - here I want to use the choice function
280:02 - which we don't have yet but we can get
280:05 - it with from random import choice
280:10 - and I want to get a random self dot
280:13 - water surface and this is going to be
280:16 - part number two and three actually
280:21 - finally we need one more group this I am
280:24 - going to do up here and I want to create
280:27 - self.water underscore Sprites I think I
280:30 - called it yes
280:32 - this is going to be just another group
280:34 - so let me copy it and there we go
280:37 - now when we are assigning the groups I
280:40 - want to have self dot all Sprites and
280:43 - self dot water Sprites
280:47 - and that is all we needed with that I
280:50 - suppose I can get rid of all of the
280:52 - comments because they are getting a bit
280:54 - annoying
280:55 - there we go this feels much better
280:59 - and now if I run main.pi again I can
281:03 - still use the hole and if I now use the
281:05 - water we have a water tile
281:08 - and I can do a couple more tiles and use
281:11 - the watering can again
281:13 - there we go this is working really well
281:17 - the last thing we need is that once I
281:20 - restart the game I want to destroy all
281:22 - of the water tiles and also get rid of
281:25 - the W for every single tile
281:28 - that is going to be a separate method
281:31 - let's call it remove water
281:34 - no need for any arguments in here and
281:37 - there are two things that we have to do
281:38 - number one is we have to destroy
281:43 - all water
281:45 - Sprites and the second one is clean up
281:49 - the grid
281:50 - the first one is really simple all we
281:53 - need is for a Sprite in self dot water
281:56 - Sprites
281:59 - dot Sprites and I want to just destroy
282:04 - all of the Sprites that is going to be
282:07 - the first part
282:09 - the second part is going to be for Row
282:13 - in self dot grid
282:16 - and then for cell in row what I want to
282:20 - check in here is if there is a capital W
282:23 - inside of this cell if that is the case
282:27 - I want cell dot remove
282:30 - and the capital w
282:33 - all I have to figure out now is when to
282:36 - call this method this is going to happen
282:38 - inside of level.pi in here once again
282:42 - let me minimize everything and I want to
282:45 - work inside of the reset method
282:48 - there is going to be another section
282:50 - let's call it soil
282:52 - and all I have to do is self.soiler and
282:56 - remove underscore water
282:59 - if I run main.pi again I can create a
283:03 - couple of soil patches water them and
283:07 - now if I restart the day
283:10 - this is still working fine and there we
283:12 - go this is looking really good
283:16 - so with that we have the watering logic
283:19 - we are not quite done yet with the
283:21 - watering logic because we need the rain
283:23 - this is going to consist of two
283:26 - different parts number one we need the
283:28 - actual rain animation so that the player
283:31 - can tell if it's raining or not
283:33 - besides that if it is raining I want to
283:35 - automatically water all of the soil
283:37 - Sprites so that is what we're going to
283:40 - work on let's Jump Right In back in the
283:43 - code I want to create a new file that I
283:46 - want to save as Sky dot Python and here
283:50 - I want to import Pi game and I also want
283:53 - from settings import everything
283:57 - and I want to create a class called rain
284:01 - there is no need for inheritance but I
284:04 - do want a Dunder init method
284:07 - although in here all we want is all
284:10 - Sprites once again so that we can draw
284:13 - in here without having to leave the
284:15 - class itself
284:17 - this we have to save inside of an
284:19 - attribute so self.ul Sprites is going to
284:22 - be all Sprites
284:25 - once we have that I want to have a few
284:28 - more graphic files we need self dot rain
284:31 - underscore drops and I want self dot
284:36 - rain underscore floor
284:39 - both are going to use the import folder
284:44 - function except with a different path as
284:49 - a consequence I have to import
284:52 - from support import let's say import
284:56 - folder for this one
284:58 - just to have a look at them inside of
285:01 - the project I have graphics and in there
285:04 - I have rain in here we have drops and
285:06 - floor drops are very simple raindrops
285:10 - basically just straight lines
285:13 - for the floor we have a whole animation
285:16 - or it's not really an animation we can
285:18 - just play them separately but this is
285:20 - what we are going to import
285:22 - let me just copy the file path it is
285:24 - going to be this one
285:26 - and it is going to be this one
285:30 - there's one more thing that we do need
285:32 - and that is we need to know the size of
285:35 - the entire map basically what is going
285:37 - to happen
285:39 - if this here is the entire map I want to
285:43 - randomly create little rain animations
285:47 - all throughout it
285:51 - and for that to work I need to know how
285:53 - wide the entire map is and how tall the
285:57 - entire map is
285:58 - that is information I can get from the
286:01 - ground image which we have to load with
286:03 - pygame DOT image dot load and for this
286:07 - one let me copy the file path as well it
286:10 - is this one and this is literally just
286:12 - the ground nothing else all I want to
286:14 - know is get dice
286:17 - and this I want to store in self Dot
286:21 - let's do it via two variables we have
286:23 - floor W and self dot floor
286:28 - h
286:29 - once we have that we are going to need
286:32 - two separate methods one for create the
286:35 - floor
286:36 - and besides that
286:39 - we need create
286:42 - drops
286:44 - and after that I want to have an update
286:46 - method that is creating both of those so
286:50 - self dot create floor and self dot
286:53 - create drops in here now we have to
286:57 - figure out what to do in my case all I'm
287:00 - really going to do is create a drop
287:03 - class which doesn't exist yet so we have
287:06 - to create it and this I want to create
287:09 - inside of this file as well plus drop
287:14 - now this is going to be a
287:16 - pygame.sprite.sprite although I do want
287:19 - this to inherit from generic to save me
287:22 - a bit of writing as a consequence I need
287:25 - from
287:26 - Sprites import generic
287:30 - I am getting much worse at spelling
287:32 - essentially what I want to do is to
287:34 - import this generic class here
287:38 - we are using this all throughout and you
287:40 - could even put the drop in here it would
287:42 - be perfectly fine but I think in here it
287:45 - does make a bit more sense
287:46 - all I want is to create another init
287:49 - method in the oven itself we need a
287:51 - surface we need a position we need to
287:54 - know if this one is moving or not then
287:56 - we need the groups and then we need a z
287:58 - position
287:59 - and how the drop is going to work it is
288:03 - going to be kind of similar compared to
288:06 - if I minimize all of this it is going to
288:09 - be kind of comparable to the particle
288:12 - we're going to create the object for a
288:14 - short period of time and then destroy it
288:16 - which means we are going to have a timer
288:19 - for each object and then destroy it
288:20 - after a couple of milliseconds
288:22 - now for that I want to have a random
288:25 - live
288:26 - time
288:28 - which I'm getting with Rand int which we
288:31 - don't have in here yet meaning from
288:33 - random import Rand int
288:37 - the duration here I want to go with 400
288:41 - to 500.
288:43 - besides that for the timer I want to
288:46 - have self dot start time and this we get
288:49 - with
288:50 - pygame.time.get underscore ticks also
288:54 - let me comment here that this should be
288:58 - the general setup
289:00 - because in here I guess this should be
289:03 - at the top I also want to have a super
289:05 - Dunder init method the arguments we need
289:09 - for this one are the same that we have
289:10 - four generic we need these four
289:14 - all four of them are going to come from
289:17 - the attributes that we are passing in
289:20 - when we are creating the drop so there
289:22 - isn't anything we have to do right now
289:24 - although what we do have to do is to
289:27 - work on the moving part basically how
289:29 - that is going to work if we have a
289:31 - raindrop so the things that are going
289:34 - down those are supposed to be moving
289:36 - whereas the raindrops on the bottom so
289:39 - the round things those are going to be
289:41 - staying in place
289:43 - which means I want to have another
289:45 - attribute that I called moving and this
289:48 - is going to capture the moving parameter
289:50 - if self dot moving is true
289:54 - then we need a position and this is
289:57 - going to be pygame dot math Dot vector2
290:01 - and
290:02 - selfdirect.top left
290:04 - besides that we also need a direction
290:07 - and the direction here is going to be
290:09 - pygame dot math Dot vector2 and for the
290:14 - value here I went with negative 2 and 4.
290:18 - those directions mean we are going two
290:20 - units in the negative Direction and
290:23 - we're going four units down as a
290:25 - consequence our actual movement is
290:27 - something like this
290:29 - finally we need self dot speed
290:32 - which is going to be a random value as
290:35 - well between 200 and 250.
290:38 - now these three attributes is the same
290:41 - thing you have seen a couple of hours
290:43 - earlier inside of the player so if I
290:47 - show the init method somewhere in here
290:49 - we have Direction position and speed
290:51 - these are the attributes you basically
290:54 - always need to move anything inside of
290:56 - Pi game
290:57 - finally I want to have an update method
291:01 - in here don't forget we do need Delta
291:03 - time
291:04 - and I want to check if self Dodge moving
291:08 - if that is the case self dot pause
291:10 - should be plus equal self dot Direction
291:14 - multiplied by self.speed multiplied by
291:18 - Delta time
291:19 - and once we have that
291:21 - self.rect dot top left
291:24 - should be
291:26 - rounded
291:28 - self.post.x and
291:31 - rounded self dot post dot y we are
291:35 - basically assigning the top left of the
291:37 - rectangle to position.x and we're using
291:40 - round to avoid the truncating that pygen
291:43 - does by default
291:44 - this is going to be the movement and
291:48 - besides that we are going to need a
291:51 - timer
291:53 - that I want to destroy this timer if it
291:56 - has lived longer than the lifetime
291:59 - and this is going to be your exercise
292:01 - create a timer that you are destroying
292:03 - this Sprite after the lifetime has run
292:05 - out pause the video now and try to
292:07 - figure this one out
292:11 - all we need here is
292:14 - pygame.time.get underscore ticks this is
292:18 - getting our current time
292:19 - from that I want to subtract self dot
292:22 - start time
292:23 - if that difference is greater or equal
292:26 - then self Dodge lifetime
292:29 - we know the lifetime has been exceeded
292:31 - as a consequence we want to kill this
292:34 - Sprite
292:35 - and that is all we need for the drop
292:39 - now we just have to create it inside of
292:41 - here and inside of here
292:46 - so let me copy all of the parameters we
292:49 - need and paste them in here and in here
292:53 - or create floor the surface is going to
292:56 - be self dot
292:59 - raindrops and from this we want to
293:01 - randomly select one of them for that we
293:04 - need Choice which we don't have yet but
293:07 - we can import it very easily
293:09 - for the position I need to have an X and
293:12 - A Y position for X this should be a
293:15 - number between 0 and the width of the
293:19 - map
293:21 - that is what we created up here
293:23 - which means I need Rand int that goes
293:29 - from 0 all the way to self dot floor
293:32 - width
293:33 - and this I also want to do for the Y
293:36 - position and this should go from zero to
293:39 - the floor height
293:40 - next up we have moving for the floor
293:42 - tiles this is going to be false
293:45 - then we have the groups and the groups
293:48 - are going to be quite simple because in
293:51 - here all we have is self dot all Sprites
293:54 - finally we need the Z position and for
293:58 - this one if you look at settings
294:00 - we have rain floor
294:03 - this I want to copy
294:06 - and paste it inside of layers and there
294:09 - we go this is all we need for the floor
294:12 - and now I can basically copy all of this
294:15 - and do the same thing for the raindrops
294:18 - it's going to be fairly similar for the
294:21 - surface we want to have rain this should
294:24 - actually be raindrops and here this
294:26 - should be rain lower sorry about that
294:29 - the position can remain the same moving
294:32 - should be true ropes can remain the same
294:35 - although for the Z position we have
294:38 - raindrops that's the layer all the way
294:41 - on top
294:42 - this I want to paste in here
294:45 - and there we go this is covering the
294:48 - entire ring class
294:50 - so let me minimize the Raindrop and
294:53 - basically everything in here as well
294:56 - all we have to figure out now is when to
294:59 - call this rain method here and that is
295:02 - going to happen inside of the level
295:05 - first of all I want from sky
295:08 - import rain
295:11 - this I have to turn into an actual
295:14 - object
295:16 - let me add another comment here actually
295:18 - to organize this a bit better let's call
295:20 - it the sky because there's going to be a
295:22 - bit more
295:23 - in here we have self.rain and this is
295:27 - going to be the rain which needs self
295:29 - dot all Sprites
295:32 - besides that I want to have another
295:35 - attribute here that I called self dot
295:37 - reigning
295:39 - and this by default let's say for now it
295:42 - is going to be true so it's easier to
295:44 - test but later on this is going to be
295:46 - random and now inside of the run method
295:51 - before we are doing the overlay let me
295:54 - add a few comments here actually
295:56 - transition overlay
295:59 - I want to have my rain
296:02 - all I have to do for that is check if
296:04 - self dot rating is true and if that is
296:08 - the case I want to have self.rain.update
296:12 - that way we are calling this update
296:15 - method here which is going to generate
296:17 - raindrops and those drops we are going
296:20 - to see hopefully in the game
296:23 - so let's try
296:25 - and there we go we have the rain
296:29 - and honestly this is actually a fairly
296:32 - simple effect all we are doing is we are
296:35 - creating random Sprites that are either
296:36 - moving for the rain or that are staying
296:38 - static on the bottom
296:41 - and well this is the entire rain graphic
296:43 - if you go over this it really isn't that
296:46 - complicated or at least I hope it isn't
296:48 - with that I can close the sky.pi file
296:52 - although we are going to see it later
296:53 - but for now we don't need it
296:56 - what we need now which is much more
296:58 - important we have to update all of the
297:01 - soil tiles if it is raining and for that
297:05 - inside of soil.pi let me minimize
297:08 - everything once again because this is
297:10 - getting quite extensive
297:12 - I want to create another method that I
297:16 - want to call right below water water
297:18 - underscore all
297:20 - no need for any arguments in here
297:22 - and once again I want to go through all
297:25 - of my grid cells
297:27 - for that let me copy the nested for loop
297:31 - again one more time and paste it in here
297:35 - I want to check if there's a capital X
297:38 - in the cell and
297:41 - W is not in the cell already which
297:46 - basically means we are going through all
297:49 - of the cells and we are checking if
297:51 - there's an X meaning there's a soil tile
297:54 - but this soil tile hasn't been watered
297:56 - yet
297:57 - but we do want to make sure that it does
298:00 - get watered which means first of all I
298:03 - want to append a w to the cell and after
298:07 - that I want to create all of the water
298:09 - tiles again
298:11 - and in here let me copy it from the
298:15 - water
298:16 - we basically want to copy this entire
298:18 - thing although we do have to make some
298:21 - changes because for this one we have a
298:24 - position inside of a cell and this we
298:27 - have to convert to an actual pixel
298:29 - position the main thing you have to
298:30 - understand about the soil layer is we
298:33 - are working with two different systems
298:34 - one is we have all of the positions
298:37 - inside of the grid and that is basically
298:40 - a table besides that we have all of the
298:42 - pixel positions in the actual game
298:45 - switching between them is really simple
298:48 - in this case we need an X and A Y
298:50 - position and those we get
298:53 - for X it's going to be the index column
298:57 - multiplied by the tile size and for y
299:00 - it's going to be the index row
299:02 - multiplied by the tile size
299:05 - this X and Y we now want to paste into
299:08 - the position for x and y and we are good
299:12 - to go
299:13 - the surface is going to be the same
299:15 - surface we had up here I just want to
299:17 - pick a random water tile I can just
299:19 - paste it straight in here and groups can
299:22 - remain identical those work just fine
299:25 - with that we have a function that can
299:27 - water all of our soil tiles we know to
299:31 - figure out when to call it and this has
299:34 - to happen in two separate places
299:37 - number one is when we get hit or rather
299:40 - when the soil gets it we are attaching
299:43 - an X inside of the cell here
299:46 - if that is the case I want to pass in if
299:50 - self dot reigning which is not something
299:53 - we have yet but we are going to in just
299:55 - a second
299:56 - if that is the case I want to call
299:59 - self.water all the problem we have right
300:02 - now is that the soil layer doesn't know
300:04 - if it is raining or not this we only
300:07 - know inside of the level
300:09 - although that is a problem that is very
300:12 - easily fixed all we have to do inside of
300:14 - the init method after we have Set the
300:16 - rain I want to get myself dot soil layer
300:20 - and set raining
300:23 - who self dot reigning
300:26 - also when we are resetting the day I
300:30 - have to do the same thing
300:31 - which means in here in a bit I want to
300:33 - randomize the rain every time we are
300:36 - resetting the day once we have updated
300:38 - that I want to get myself dot soil layer
300:41 - again and set raining back to self Dot
300:46 - reigning and now we always know if it is
300:50 - raining inside of this class here which
300:54 - means if I run main.pi and I use the
300:57 - whole we automatically get water Sprites
301:00 - this is looking really good
301:03 - and if I switch off the rain all the way
301:07 - at the top
301:09 - here so raining should be false
301:12 - let's try this now we don't have rain
301:14 - and we don't have water at least not by
301:16 - default
301:19 - so all right with that we have some
301:22 - basic rain logic although what I also
301:25 - want when we are resetting the day and
301:29 - it is raining I want to automatically
301:31 - water all of the existing soil tiles
301:34 - because right now in the logic here we
301:37 - are only watering new tiles we don't
301:39 - water existing tiles
301:41 - which means when I'm resetting the day I
301:44 - want
301:45 - if self dot reigning is true then self
301:49 - dot soil layer dot water underscore all
301:54 - let's try this one
301:56 - oh and I do have to switch on the rain
301:58 - and to test this one let's randomize the
302:02 - rain
302:02 - meaning when I'm creating the rain I
302:05 - want to have a random chance to create a
302:08 - rain which I'm getting with rent int
302:10 - which I don't think I have available yet
302:13 - I do not I need from random import Rand
302:18 - int
302:20 - and in here I'm just creating a number
302:22 - between 0 and 10 and if this number is
302:26 - let's say greater than 7 this is going
302:29 - to be true
302:30 - although for now for testing purposes
302:32 - I'm going to set this number to a 3
302:35 - which means we're going to have a ton of
302:38 - rain
302:40 - this I also want to do down here
302:42 - actually I can copy the entire line
302:45 - like
302:46 - so
302:48 - and now for every day we have a pretty
302:51 - high chance to generate rain
302:53 - if I run this
302:55 - it's raining right now but we can still
302:57 - get started and let's go to bed
303:01 - and let's hope there we go now there's
303:04 - no rain so there's no water on them and
303:07 - I guess let me water one of them just
303:09 - for testing purposes
303:10 - if I now go to sleep again
303:13 - it's not raining
303:15 - now it's raining again and all of the
303:18 - soil tiles have been watered so this is
303:21 - working really well very nice
303:25 - and with that we have the basic watering
303:30 - logic so another major step forward next
303:33 - up we can start working on the plans
303:36 - let's get started with the plans since
303:38 - we already have a ton of logic in the
303:41 - soil this shouldn't be so bad actually
303:44 - but once again let's go for this step by
303:46 - step
303:47 - the very first thing we need is inside
303:49 - of the player we need to know if the
303:52 - player is planting some seeds
303:55 - for that we already have a method that
303:58 - is called use seed right now there's
304:01 - nothing in there but that is going to
304:04 - change
304:05 - I want to get a soil layout once again
304:07 - and now call a method that I called
304:10 - plant seed for this one we need two
304:14 - arguments the first one is going to be
304:16 - self dot the target position the second
304:19 - one is self dot selected not tool but
304:22 - seat and I hope this makes sense we have
304:26 - to know what Target we are hitting and
304:28 - we want to know what kind of seat we are
304:30 - using this is all made inside of the
304:32 - player and now in the soil in the soil
304:36 - layer I want to minimize all of the
304:40 - methods and let me put it let me put it
304:45 - all the way below the water in here I
304:49 - want to have land underscore seed
304:52 - we need self we need a Target position
304:57 - and we need a seat and once again we
305:01 - have to check if we actually hit a soil
305:03 - Sprite Which we get with four soil
305:06 - Sprite in self dot soil Sprites dot
305:11 - Sprites I want to check if soil Sprite
305:14 - dot rect dot Collide point and the point
305:19 - I want to check is the target position
305:21 - if that is the case once again I have a
305:25 - pixel position and this I want to
305:27 - convert to a position inside of the grid
305:30 - which means I need my soil Sprite Dot
305:35 - rect.x and floor divided by the tile
305:39 - size
305:40 - I can duplicate this line and change the
305:43 - X to a y and that way I'm getting my y
305:45 - position inside of the grid
305:48 - if that is the case I want to get myself
305:50 - dot grid with my Y and X
305:54 - this is going to give me the cell and I
305:57 - want to append a capital p short for a
306:00 - plant
306:01 - that way we know we have a plant inside
306:04 - of this cell now this should only be
306:06 - possible once which means I can already
306:09 - check if a capital P is not
306:14 - in
306:16 - self dot red with y and x and only if
306:22 - that is the case I want to create a
306:25 - plant now that we have that I want to
306:27 - create a planned object
306:30 - this I am creating also inside of this
306:33 - python file with class land and this one
306:37 - is also going to be pygame.sprite dot
306:39 - Sprite
306:40 - I want to have a Dunder image method
306:43 - with self we need a plant pipe so do we
306:48 - want corn or tomato then we want groups
306:51 - next up I need the soil for the
306:53 - positioning and let's say that's it for
306:55 - now as always I need the dunder in it
306:58 - method with the ropes
307:02 - I have to convert the plant type
307:05 - parameter into an attribute so
307:07 - self.plant type is plant type
307:10 - and then I have a couple of frames
307:13 - depending on what kind of plant we have
307:15 - meaning here's the project I have
307:18 - Graphics inside of there we have fruit
307:21 - and there's corn and tomato not the best
307:24 - naming but it really doesn't matter
307:26 - inside of corn we have these different
307:29 - files and inside of tomato we have those
307:32 - this is what we are going to import this
307:35 - we get with import folder and the file
307:38 - path here is let me just copy it right
307:41 - away we have to go into graphics and
307:44 - fruit and in there we have two
307:46 - subfolders and those subfolders I want
307:49 - to get with an F string
307:52 - because what we can use in here is the
307:55 - plant type
307:56 - besides that we need self.h
308:00 - by default this is going to be zero
308:02 - after that we also need
308:05 - self.max.h so that we know when the
308:08 - plant is reaching the full h
308:10 - this we can get with self dot frames and
308:14 - get the length of it and subtract 1 from
308:16 - that
308:18 - finally I want to have
308:20 - self.grow underscore speed which is
308:24 - telling me how fast this kind of plant
308:26 - is growing and for that inside of
308:29 - settings I have a dictionary this is
308:32 - what I want to use
308:33 - meaning I can use grow speed in here
308:38 - and then get the planned type
308:40 - I guess I should really comment all of
308:43 - this a bit better to make it a bit
308:45 - easier to understand let's call this
308:47 - section here the plant growing
308:51 - and the stuff at the top is going to be
308:54 - the setup
308:56 - also there's one thing I forgot we have
308:58 - to turn the soil into an attribute so
309:01 - self.soil is going to be soil once we
309:04 - have all of that we can work on this
309:07 - Sprite set up
309:09 - first of all here we need self.image
309:12 - this is very easy because we have a
309:15 - bunch of frames I want to use self.h for
309:18 - the indexing
309:19 - besides that I have to create
309:23 - self.rect this I'm getting with self dot
309:26 - image dot get underscore rect I want to
309:29 - place the mid
309:31 - bottom
309:32 - and the position I'm getting from
309:34 - soil.rect Dodge mid
309:37 - or Tim
309:39 - although here we have a problem this is
309:42 - going to be the size of a soil tile but
309:45 - each plant is going to be about this
309:48 - tall and since we're placing the bottom
309:51 - of the plant at the bottom of the soil
309:54 - tile we're going to be somewhere here
309:56 - and I want there to be some kind of
309:59 - offset
310:00 - this I created separately and I called
310:03 - it self dot y underscore offset
310:07 - this is going to be negative 16 if the
310:11 - planned
310:12 - pipe
310:13 - is equal to corn and if that is not the
310:17 - case it's supposed to be negative 8. the
310:20 - reason here is that the various plans
310:22 - are very different in size we do have to
310:24 - account for that
310:26 - and to use that I have to turn it into a
310:29 - vector which means
310:32 - pygame.math.vector2 this needs to be
310:34 - capitalized
310:36 - for X it's supposed to be 0 and for y it
310:39 - is going to be self dot y offset
310:43 - we are nearly done the last thing we
310:45 - need is self.z in here we need layers as
310:49 - always and for the plans we actually
310:52 - have two different layers
310:54 - the one we are going to start with is
310:57 - the round plant
311:00 - this I want to paste in here and this
311:02 - means if you look at the settings the
311:04 - plans are always going to be below the
311:06 - player by default I want the plants to
311:10 - be non-collidable so the player can just
311:12 - walk on top of them but once they have
311:14 - grown I want them to be on the main
311:16 - layer and the player should be able to
311:18 - collide with them but that's going to
311:20 - come in a bit I guess for now we have
311:22 - added a ton of stuff so let's actually
311:25 - create one of the plants and see how far
311:29 - we get so when I create a plant I need a
311:32 - plant type the groups and the soil this
311:35 - one should be fairly simple because the
311:37 - plant type is going to be the same as
311:39 - the seed
311:40 - the soil is also going to be very simple
311:42 - because all we need in here is the soil
311:45 - Sprite
311:46 - for the groups I do want to have one
311:49 - group specifically for the plants
311:53 - this is going to happen in the init
311:55 - method of the soil layer in here I want
311:57 - to have
311:58 - stealth.land underscore Sprites once
312:02 - again this is just going to be
312:03 - pygame.spright.group
312:06 - and now for the groups each plant should
312:09 - be inside of self dot all Sprites it
312:15 - should be inside self dot plan not types
312:19 - but Sprites
312:21 - and let me fix this typo here and let's
312:24 - actually try this
312:26 - so in the game I can use a hole and now
312:29 - if I press left control
312:31 - we get some seats that we can walk over
312:34 - and this I can do multiple times also
312:37 - with E I can change the seat and now we
312:39 - get a tomato this is working
312:41 - surprisingly well
312:44 - cool so I'm very happy with that what we
312:47 - now have to figure out is how to make
312:48 - the plants grow
312:52 - inside of the plant
312:55 - we need an update or some kind of an
312:57 - update method
312:59 - this one I called grow
313:03 - there is no need for an argument in here
313:05 - and now we have a problem because the
313:08 - plant needs to know if the soil that is
313:10 - in was watered but this information we
313:13 - don't have available right now what I
313:15 - want to happen is that each plant can
313:18 - access the soil layer and check out
313:21 - self.grid to know if the tile it is in
313:24 - was watered or not
313:26 - and for that I am going to create
313:29 - another method
313:31 - that is going to be fairly simple though
313:34 - I call this one check
313:38 - watered
313:39 - in here we need some kind of position
313:44 - this position will be entered by the
313:46 - plant itself
313:47 - I want to get the actual cell and right
313:50 - now once again we have a pixel position
313:53 - this we have to convert into an actual
313:56 - grid position so we can access the grid
313:58 - the same thing we have done here
314:00 - actually
314:01 - let me copy the entire thing actually
314:06 - and fix the indentation
314:10 - there we go
314:12 - to get the cell all I want is self.grid
314:15 - and Y and then X
314:17 - once I have that I can check is what
314:21 - third
314:22 - and it's watered we are getting with
314:24 - capital w in cell
314:27 - meaning this could ever be true or false
314:31 - and that is the information I want to
314:34 - return so return is watered
314:36 - now this method I am going to pass into
314:40 - a plant whenever we create it which
314:43 - happens down here each plant is going to
314:45 - have access to self dot check water
314:50 - for this we have to create another
314:52 - attribute of the soil I want to have
314:55 - Czech watered
314:58 - this we have to turn into an attribute
315:00 - so self dot check water is check watered
315:06 - and now we can create this grow method
315:10 - all I have to do is check if self dot
315:15 - check watered with
315:19 - self.rect.center remember here check
315:21 - what it needs a position and I'm just
315:23 - going to go with the center remember
315:25 - here check what it did need a position
315:29 - if that is the case I want to add self
315:33 - dot h plus equals self dot grow
315:38 - speed
315:39 - and after I have that I can run
315:42 - self.image it's going to be self dot
315:45 - frames and I can use self.h again
315:48 - although now we do have to be careful
315:50 - because this age could be a floating
315:53 - point value which we couldn't use for
315:56 - indexing but if we turn it into an
315:58 - integer this is going to work again and
316:00 - after that I can turn this into a
316:03 - rectangle
316:04 - which I am getting with self dot image
316:07 - actually let me copy this one here
316:12 - because it isn't going to change besides
316:14 - that now the main reason why I am
316:17 - updating the rectangle is because the
316:19 - image is going to change and we might
316:21 - have different dimensions
316:23 - which means we have to get a new
316:25 - rectangle but other than that this is
316:28 - the basics of the grow method what we
316:31 - now have to figure out is when to call
316:33 - it or that inside of the soil layer I
316:37 - created another method update plans
316:42 - all agent here is four planned in self
316:45 - dot plant Sprites dot Sprites I want
316:49 - plant dot grow
316:51 - and this method I now want to call
316:54 - inside of the level
316:57 - when we are resetting the day so in here
317:01 - let's do it all the way at the top we
317:03 - have the plants
317:06 - self dot soil layer Dot
317:10 - update underscore plans
317:14 - and that should basically be it I guess
317:18 - the one thing you want to be careful
317:19 - about here is that this should be called
317:22 - before all of this because for example
317:24 - if we called it after it's raining with
317:27 - this method here we might water all of
317:29 - them and then update all of the plants
317:31 - which would be a tiny bit weird
317:33 - let's try
317:35 - so I want to grow some corn make sure I
317:40 - am watering it and now let's update the
317:43 - entire day
317:45 - and we are getting an error that name
317:47 - soil Sprite is not defined
317:50 - this probably happened inside of here
317:54 - ah right
317:56 - check water has the problem right now
317:58 - that this should be
318:01 - position
318:02 - zero
318:03 - and
318:05 - position one because what we actually
318:09 - pass in here inside of the plant is
318:13 - self.rect.center which is giving us a
318:15 - tuple with an X and A Y position
318:18 - now let's try this again next attempt
318:21 - I want to plant some corn again and
318:24 - start a new day
318:26 - and we are getting another error
318:33 - this one happens down here inside of
318:35 - plant.grow so let's have a look at this
318:38 - one and the problem is happening
318:40 - somewhere in here
318:42 - the problem is we don't have the soil as
318:45 - an attribute this we can fix with self
318:48 - dot soil
318:50 - ready next attempt
318:52 - let's try it again
318:55 - let's see if I made another mistake
318:58 - now it's working and there we go this
319:00 - definitely grew
319:02 - let me water it by hand
319:07 - and start another day and there we go
319:10 - this keeps on growing and now if I start
319:13 - another day it should be fully grown
319:15 - there we go now if I start another day
319:18 - this is going to crash because we are
319:21 - running out of frames but this was
319:23 - expected
319:24 - other than that this is working just
319:26 - fine
319:27 - we do have a very good start now we just
319:30 - have to make some more updates to the
319:32 - plant and then we are nearly done with
319:34 - the plants and with most of the game
319:36 - actually
319:37 - first of all once the plant is reaching
319:40 - the max age I want the plan to stop
319:43 - growing which happens inside of grow all
319:46 - I want to do in here is if self.h
319:50 - is greater or equal than self dot max
319:54 - age and if that is the case self.h is
319:59 - going to be self dot Max h
320:02 - although if that is the case I want to
320:05 - indicate that the plant is ready for
320:07 - harvesting
320:09 - which I am doing via another attribute
320:12 - that I called Harvest bill
320:16 - and harvestable is going to be true once
320:19 - this condition here is true so we can
320:21 - set this to true
320:24 - with that the game is not going to crash
320:27 - anymore although what I also want to do
320:29 - is if the plan starts to grow it should
320:31 - be on the main layer and the player
320:33 - should be able to collide with it
320:35 - this could be a good exercise
320:39 - if the planned H is greater than zero so
320:45 - if we have one and above then the plant
320:47 - should be on the main layer
320:49 - and pause the video now and see if we
320:51 - can figure this one out
320:56 - for this one we need an if statement and
320:59 - I want to check if self.h is greater
321:02 - than zero if that is the case I want to
321:05 - update self.z which now should be inside
321:09 - of
321:10 - layers and the main layer although there
321:16 - is one thing you really want to be
321:18 - careful about because self.h could be a
321:21 - floating point value and we only want to
321:24 - do this line here if the plant is
321:27 - greater than one
321:29 - which we can get quite easily
321:32 - with integer
321:33 - if you didn't do this
321:35 - self.h might be something like 0.7 which
321:39 - would be greater than zero but the plant
321:41 - itself would still be a tiny seat
321:44 - which the player should walk on top so
321:47 - integer ensures that we have a certain
321:51 - kind of plant size
321:53 - if I run the game now let's hope it
321:55 - doesn't crash I can land something
322:00 - and if I now update the entire thing it
322:03 - doesn't crash and now we should be
322:05 - behind and in front of all of the stuff
322:09 - so this is working just fine
322:13 - what we now have to figure out is the
322:15 - Collision mechanic and for that if I
322:18 - look at the player again at Collision
322:22 - in here the plants don't have collisions
322:24 - yet because they don't have a hitbox
322:27 - which we're checking here
322:30 - but that we can fix quite easily once a
322:33 - plant has a certain age it should have
322:36 - self dot it box
322:39 - and this is just going to be
322:42 - self.direct.com p
322:45 - and this I want to inflate
322:47 - and now I need an X and A Y Dimension
322:51 - again for X is going to be negative 26
322:54 - and for y it is going to be self dot
322:57 - rect dot height
323:00 - multiplied by 0.4 and this should be
323:04 - negative that is all we needed if I now
323:08 - run main.pi and let's create a tomato
323:11 - for now
323:12 - if I plant this one although I think
323:14 - this takes two days to grow but that's a
323:16 - good way to double check
323:17 - so now I can still walk over the tomato
323:20 - plant but if I sleep again
323:25 - now we have a grown plant and there is
323:29 - no Collision yet and I also know why
323:33 - the reason is that plants are not inside
323:37 - of the Collision Sprites method
323:41 - so when I'm creating a plant
323:44 - it needs to be inside of self.collision
323:49 - brights
323:51 - the problem is the soil layer doesn't
323:54 - have that one although that we can
323:57 - change I want another attribute with the
324:00 - Collision Sprites
324:02 - and let me put this right below all
324:04 - Sprites self dot Collision Sprites is
324:07 - going to be Collision
324:09 - Sprites
324:11 - now inside of level when I create the
324:15 - soil layer which happens here
324:18 - I also want to pass in self-dodge
324:20 - Collision Sprites
324:22 - now let's try this again
324:25 - I want to plant some corn because that
324:27 - one is faster and now if I restart the
324:30 - day
324:32 - we have something and now we have
324:35 - collisions
324:38 - this is looking really good
324:44 - cool so with that we have the basics of
324:48 - the plant
324:50 - although we cannot Harvest them but that
324:53 - is going to be the next section with the
324:57 - plans being done the last thing we have
324:59 - to do is the harvesting part or at least
325:02 - the last thing we have to do for the
325:03 - plants there's going to be quite a bit
325:04 - more
325:06 - let's Jump Right In and once again let's
325:09 - go through it step by step
325:11 - back in the code what I basically now
325:14 - have to figure out is if a plant is
325:18 - harvestable so this line here is true
325:21 - and I have a collision with the player
325:23 - so this player here then I want to
325:27 - destroy the plant and update the player
325:29 - inventory
325:30 - all of this is going to happen inside of
325:33 - level.pi
325:34 - I want to create let's call it plant
325:39 - collisions
325:42 - or Collision
325:44 - there's no need for any parameters in
325:46 - here first of all I want to check if
325:49 - there are any plans in the first place
325:51 - which I get with self dot soil layer dot
325:55 - plant
325:56 - underscore Sprites
325:58 - if there are no plans this is not going
326:01 - to trigger and then there's no point
326:03 - doing any of all of this
326:05 - if there are no plans this would not
326:07 - trigger in here I want to check for a
326:10 - plant in self dot soil layer dot plant
326:14 - Sprites dot Sprites
326:17 - that way I can access every individual
326:19 - plant and what I want to check is if
326:22 - planned dot Harvest bill
326:26 - and the
326:28 - planned.rect dot collide rect with self
326:33 - dot player Dot hitbox
326:36 - we are checking if the plant can be
326:38 - harvested and if the plant is colliding
326:41 - with the player if that is the case I
326:44 - want to destroy this plant
326:47 - make sure to call this plant Collision
326:49 - right after update which happens here I
326:54 - want to run
326:55 - self.plant religion
326:59 - and now let's try all of this
327:01 - we're getting an error
327:04 - that the inside of level
327:07 - this should be planned Sprites so should
327:11 - this one here
327:13 - now let's try this again
327:15 - there we go I can plant some corn and
327:18 - water this
327:20 - and now I have to do a bit of
327:25 - restarting the day
327:28 - but the game is definitely coming
327:30 - together
327:31 - now it's raining so I can go straight
327:33 - back to sleep
327:35 - and now if I Collide both this it
327:38 - disappears cool this is a very good
327:41 - start
327:42 - although we do have to do a few more
327:44 - things in here
327:46 - first of all I want to run self dot
327:49 - player
327:52 - underscore add
327:54 - and in here I want to get the plant and
327:58 - then dot planned underscore type
328:02 - that way we are updating the player
328:04 - inventory so there's an actual reason to
328:06 - harvest something
328:08 - and this we should probably test so once
328:11 - again all the way at the end of the run
328:13 - method I want to print self dot player
328:17 - dot item inventory
328:21 - if I run this now
328:23 - we get the entire inventory and I want
328:26 - to plant some corn
328:28 - now I have to restart it's still raining
328:31 - it's also raining and we need one more
328:34 - day
328:36 - and now if I collide with this we get
328:40 - corn one this is working very well
328:44 - so let me delete this print statement
328:47 - here again and now we can keep on
328:49 - working in here
328:51 - I also want to create a particle when
328:53 - the plant disappears which we don't have
328:56 - available yet we do not
329:00 - but I can import it quite easily
329:03 - I want a partake kill which we're
329:06 - getting from the Sprites this one here
329:11 - and now I need all of the arguments to
329:15 - create it
329:16 - so let me copy these ones here paste
329:20 - them in here
329:21 - and now we have to figure out all of
329:23 - them again
329:24 - order position I want to have land dot
329:28 - direct dot top left
329:30 - for the surface I want to have plant dot
329:33 - image and for the groups this should be
329:35 - self dot all Sprites
329:38 - for that layer I want to have the layers
329:41 - and in here this should be Main
329:44 - this should be all we need once again
329:47 - let's try this
329:52 - and I do hope it starts to rain this is
329:56 - looking good running again one more time
329:59 - and now we should have a particle effect
330:02 - and there we go this is looking good the
330:05 - last thing we need is whenever we
330:07 - destroy the plant we still have inside
330:10 - of the grid
330:13 - let me minimize the plans
330:15 - the last thing we need inside of this
330:18 - soil grid
330:19 - we have to remove the capital P that way
330:22 - we can create another plant
330:24 - for this one I need self dot soil layer
330:28 - once again and now we need the grid
330:32 - the problem is right now we only have an
330:35 - X in the Y position and for the grid we
330:38 - need rows and columns
330:40 - which means we need a row and we need a
330:44 - column
330:45 - and once we have that I want to remove
330:48 - any kind of capital p
330:51 - and this column is going to be your
330:53 - exercise
330:54 - see if you can figure this one out
331:00 - for the row we are going to need the Y
331:02 - position of the plant which we get with
331:05 - plant dot rect.center y
331:09 - and this I want to flow divide by the
331:12 - tile size
331:13 - for the column this is going to work in
331:17 - the same way except now we need Center X
331:20 - and with that we should be good to go
331:23 - so now if I run main.pi again
331:27 - now if I plant some corn and restart the
331:31 - day
331:33 - it's raining again we do have to wait
331:35 - until the thing grows completely
331:38 - now this should be working and now we
331:42 - are getting an error because I'm in a
331:44 - typo
331:46 - this should be tile size okay once again
331:51 - let's try this again
331:55 - and testing a game can be very annoying
331:59 - it's not raining but I guess all of this
332:01 - is good way to test all of this
332:05 - let's try it one more time now it is
332:07 - raining it keeps on growing and now it
332:10 - is completely grown
332:12 - if I touch it it disappears and now I
332:14 - should be able to create a new plant so
332:17 - let me plant a tomato and there we go we
332:20 - have a tomato
332:21 - I guess
332:23 - if I restart the day just to be sure all
332:26 - of this is working
332:28 - one more time and it is growing cool so
332:32 - this is working as well
332:34 - with that we have the harvesting logic
332:37 - this honestly wasn't so bad or at least
332:40 - I hope it wasn't
332:42 - there isn't actually that much more to
332:44 - do but there's one thing I did forget to
332:47 - do and that is the night transition or
332:50 - the daytime transition let's do this one
332:53 - next
332:54 - for the day transition we kind of have
332:57 - to do the same thing we have done for
332:59 - the transition between different days we
333:01 - are basically creating an image on top
333:04 - of the entire game and then we use
333:06 - blending modes to merge the two
333:08 - I probably should have done this a
333:10 - couple of hours ago when we worked on
333:12 - the transition but well here we are
333:15 - back in the code I want to do all of
333:17 - this inside of my sky because it kind of
333:20 - fits in there
333:21 - let me reopen it we need the sky in here
333:25 - besides the drop and the rain all the
333:28 - way at the top I want to have let's call
333:30 - it sky
333:33 - we need a dander init method in here
333:36 - with self and now first of all we need
333:39 - the display surface
333:41 - which as always we get with
333:44 - pygame.display.get underscore surface
333:47 - besides that we are going to need an
333:49 - image that covers the entire window
333:52 - which I called self dot full
333:55 - surface just surface fine
333:57 - and this we get with pygame DOT surface
334:02 - and in here I can once again for my
334:05 - settings get the screen width and the
334:07 - screen height
334:08 - definitely copy in the screen with and
334:10 - this screen height and now we have a
334:13 - full surface
334:15 - once I have that I want to let me call
334:18 - it display
334:19 - in here we need itself and we also need
334:22 - Delta time
334:23 - and essentially all I want to do here is
334:27 - self.display surface dot lit I want to
334:30 - have myself dot full surface at the
334:33 - position 0 and 0 that will be covering
334:36 - the entire window
334:37 - and finally we need a special blacks
334:41 - which in this case is going to be pygame
334:44 - dot lend underscore rgba underscore mult
334:49 - right now this is going to be entirely
334:51 - black so there isn't too much point but
334:54 - let's use it right away also I want to
334:57 - close the soil at least for now to keep
334:59 - things a bit more organized I can also
335:02 - close the Sprites because I don't think
335:04 - we need it at all anymore inside of the
335:07 - level I want besides rain also import
335:10 - sky
335:12 - and the sky has to be an attribute
335:14 - let's put it right here self dot sky is
335:18 - going to be sky
335:19 - once we have that inside of the run
335:22 - method after the rain
335:25 - I want to have the day time
335:29 - like that and this we get with self.sky
335:33 - dot display
335:35 - and here we do need data time although
335:37 - not right now but we do need it to call
335:40 - the method
335:41 - if I run this now everything is going to
335:44 - be black
335:45 - the reason is we are putting a black
335:47 - surface on top of the entire window
335:49 - which well isn't particularly helpful
335:53 - although what I want to do now is self
335:56 - dot start
335:57 - color
335:59 - and this dark color is going to be a
336:01 - list with the values 255 255 and 255.
336:07 - before I am displaying this surface I
336:10 - want to fill it with that color so self
336:13 - dot colorserve.fill with self dot start
336:17 - color
336:18 - once we have that we shouldn't be seeing
336:20 - anything we can see the game itself this
336:23 - is looking as always
336:26 - but now what we can do with this setup I
336:29 - could for example change this to a0 and
336:31 - if I now run this again
336:33 - we got a bunch of weird colors
336:37 - and this way we can control how the game
336:39 - is going to look like
336:42 - in my case I want to transition from a
336:45 - pure white color
336:46 - to myself dot end color which is going
336:51 - to be the Tuple 38 101 and 189 just to
336:57 - illustrate what this one is going to
336:59 - look like let me run it in the game it's
337:02 - going to look like this
337:04 - this is very much night time
337:07 - all we have to figure out now is how to
337:10 - transition from this value to this value
337:12 - here how this is going to look like is
337:14 - I'm going to look at every individual
337:16 - value and subtract it by a certain
337:18 - amount let's say negative 2.
337:21 - and this I'm going to do until we are
337:23 - reaching this particular point
337:26 - this point here so we can see it
337:29 - this is also going to happen for the
337:30 - second one this is going to go until
337:32 - this point here and for this one as well
337:35 - up to this point here
337:37 - this I am getting with for Value in self
337:41 - Dot and color
337:44 - although in here I do need the enumerate
337:48 - method because I need to know what index
337:51 - I am on so I have my index and I have
337:53 - the value
337:54 - I want to check if self dot start not
337:58 - time but color
338:00 - is greater than the value and if that is
338:04 - the case self dot start color with the
338:08 - index should be minus equal 2 multiplied
338:12 - by Delta time
338:13 - also when I am filling all of this this
338:16 - should be the start color
338:18 - we are looking at every single color
338:20 - inside of n color against this we are
338:23 - checking on this line here
338:26 - if the corresponding value inside of
338:29 - start color let's say the first one 255
338:31 - is greater than the end color 38 in this
338:35 - case and if that is the case we want to
338:38 - reduce the start color value by a
338:40 - certain amount
338:42 - and this we want to do until we reach
338:43 - the end point and with that we should be
338:46 - having a transition let's try now
338:48 - and we are getting an error
338:51 - this one here should be start color and
338:53 - index
338:56 - and now all I have to do is wait
339:01 - I guess while I'm doing that I can run
339:04 - around a bit to check out the entire
339:06 - level I've been very focused on specific
339:08 - tasks but well the entire game is coming
339:11 - together pretty nice
339:14 - also here you can see the trader and now
339:16 - since we have a collision block here we
339:18 - cannot move over him anymore
339:21 - we're going to work on the trader in
339:22 - just a second
339:27 - and everything else is working really
339:30 - well
339:33 - okay probably I'm just going to speed up
339:35 - this entire game because I am running
339:37 - out of things to talk about so let's
339:40 - speed it up a bit
339:43 - all right I think at this point you can
339:45 - definitely tell things are getting
339:47 - darker
339:51 - this is definitely working
339:53 - all we have to figure out now is once we
339:56 - have all of this color here we have to
340:00 - set it back to the starting position so
340:02 - 255 255 and 255 whenever we are
340:07 - resetting
340:09 - the entire day
340:11 - this is also going to be fairly simple
340:13 - all we have to do let me add another
340:16 - comment here Sky I want to get self.sky
340:19 - dot start color
340:22 - is going to be 255 255 and 255.
340:27 - and that if I now wait a tiny bit let me
340:32 - speed all of this up
340:38 - all right now I can definitely tell
340:39 - things are getting darker so let me
340:42 - restart the day
340:45 - and there we go this is much brighter
340:48 - with that we have the daytime cycle
340:51 - really wasn't that bad
340:53 - and this is literally all we need for
340:56 - the sky meaning I can minimize it and
340:59 - close the entire python file
341:01 - and we are almost done
341:04 - the last major bit of the game is going
341:06 - to be the merchant so let's work on that
341:09 - one there are quite a few different
341:11 - elements we have to cover here back in
341:13 - the code first of all the player is
341:16 - going to need let me minimize everything
341:19 - the player is going to need a full
341:21 - inventory we already have a couple of
341:24 - things in here we have this kind of
341:26 - inventory but we are going to need a
341:29 - tiny bit more
341:30 - we also need
341:32 - self.seat underscore inventory and this
341:36 - one is going to have two key value pairs
341:39 - we have corn and by default let's say we
341:43 - have five and besides that we have
341:46 - tomato python here would also work well
341:50 - finally besides that we are going to
341:53 - need self Dot money
341:55 - and for starting value here let's go
341:57 - with 200 it's entirely arbitrary this is
342:01 - going to be the inventory for the player
342:03 - and this is also what we're going to
342:04 - access when we are doing the merchant
342:07 - although before we are coming to that
342:09 - there's one more thing that I want to do
342:11 - and that is that the player shouldn't be
342:13 - able to use a seat once we are running
342:15 - out of seed
342:17 - for example the player can only use corn
342:19 - if this number here is at least one
342:23 - let me minimize the init method and all
342:26 - of this happens inside of use seed
342:29 - all I want to do in here is if self dot
342:32 - seat inventory and then I want to pick
342:37 - myself Dot selectedseed
342:40 - and only if this is greater than zero
342:43 - then I want to plant a seed
342:46 - besides that inside of here as well I
342:49 - want to get myself dot seed inventory
342:52 - get the selected self dot selected seat
342:56 - again and subtract it by one
342:59 - with that we can start working on the
343:01 - merchant itself
343:03 - let me explain how it's going to work
343:05 - here we are back entitled and the trader
343:08 - is all the way in the top left
343:10 - what you can see around the trader is
343:13 - inside of player we have a Trader area
343:17 - this is going to work kind of like the
343:19 - bad if the player is inside of this area
343:21 - presses enter then we are going to start
343:24 - the merchant menu
343:26 - back in the code when we are creating
343:29 - the level more specifically when we are
343:31 - running the setup method in here a bit
343:34 - further down we are checking for the
343:36 - start position of the player if there is
343:39 - a bad and besides that I want to check
343:41 - if obj dot name is equal to
343:47 - Trader if that is the case I want to
343:50 - create another interaction object
343:52 - meaning I can duplicate this line here
343:54 - and paste it in here with that we are
343:58 - actually done all of these arguments
344:00 - here can stay identical since we're
344:02 - getting information from tiled all of
344:04 - this is going to be done automatically
344:06 - the only major change here is going to
344:08 - obj name because this one now is going
344:11 - to be Trader instead of bad
344:13 - but with that we have the interaction
344:16 - object we have to do a tiny bit more
344:18 - inside of the player inside of the input
344:22 - method all the way at the bottom
344:25 - we have created this line a couple of
344:28 - hours ago and that is if the player is
344:31 - inside of the interaction area and we
344:33 - have Trader then we want to do a certain
344:36 - thing basically what I want to do is to
344:39 - run a method called
344:40 - self.talk girl underscore shop
344:44 - this one doesn't exist right now but
344:47 - basically what I want to do is inside of
344:49 - the level
344:50 - I want to create another method let me
344:53 - minimize everything in here so it's a
344:55 - bit easier to see inside of the level
344:57 - class
344:58 - I want to let me do it below player ad
345:03 - this one I want to call toggle
345:06 - underscore shop
345:07 - in here we need self and nothing else
345:09 - and this is a fairly simple method
345:13 - all I really want to do in here is self
345:16 - dot shop active is going to be not self
345:21 - dot shop
345:22 - active
345:24 - meaning whenever we are running this
345:26 - method we are switching shop active
345:29 - either on or off this attribute doesn't
345:32 - exist right now so we do have to create
345:34 - it this happens inside of the init
345:37 - method in here let's put it under
345:40 - another section
345:41 - shop
345:43 - and by default this one needs to be
345:45 - false
345:47 - if this one is true though we are going
345:49 - to show the shop menu but that is going
345:51 - to come later first of all we have to
345:54 - pass this method here into the player
345:57 - which happens inside of setup and in
346:01 - here we have the player and the player
346:04 - is going to get another parameter toggle
346:08 - shop which is going to be self dot
346:11 - toggle shop
346:13 - for that to work inside of the player
346:15 - all the way at the top
346:17 - let me minimize the input method and
346:20 - inside of the init method we need toggle
346:24 - shop
346:25 - and for this one inside of interaction I
346:31 - want to create another attribute self
346:33 - dot org Girl shop it's going to be
346:37 - toggle shop
346:38 - and with that we should be having a
346:41 - pretty good start
346:43 - I suppose we can test this inside of
346:48 - the run method all the way at the bottom
346:51 - I want to print
346:53 - self Dot
346:55 - shop active
346:57 - and this we should be able to influence
347:00 - with the player so let's run the game
347:04 - and we're getting thoughts right now
347:06 - that is a very good sign and if I walk
347:09 - to the merchant
347:11 - and if I press enter right next to him
347:13 - we're getting true if I press it again
347:16 - we are getting false so this is a very
347:19 - good sign and with that we can start
347:22 - working on the actual Merchant for that
347:24 - I want to create a new file
347:27 - and save it as menu Dot pi
347:32 - in here as always we are going to need
347:34 - import pygame and we also need from
347:37 - settings import everything
347:40 - after that I want to create a new class
347:43 - that I call menu
347:45 - and here we need it under a niche method
347:50 - this one itself it needs the player and
347:54 - it also needs toggle menu so we can
347:58 - switch off the menu from inside of the
348:00 - menu inside of this I want to have a
348:04 - general setup
348:06 - for this I want to turn the player into
348:09 - an attribute so self.player is player
348:13 - the same I want to do for the toggle
348:16 - menu so self.toggle menu is going to be
348:18 - toggle menu
348:20 - and besides that I am going to need two
348:22 - more things first of all I need the
348:25 - display surface this as always I'm
348:28 - getting with pygame dot display dot get
348:32 - underscore surface
348:35 - and besides that I need self dot font
348:38 - the font we get with pygame DOT Bond dot
348:43 - font be careful here about the
348:45 - capitalization the first font is
348:47 - lowercase the second font is uppercase
348:50 - this we want to call and in here we need
348:53 - a font style and we need a size
348:56 - the size is easy because we just want an
348:59 - integer in my case 30. for the font we
349:03 - need an actual file
349:04 - in my case here's the project folder and
349:08 - we have font and in there we have a file
349:10 - called lychee soda this is what I want
349:13 - to import
349:14 - the file path for that is going to be a
349:17 - string and I want to go one folder up to
349:20 - font and then to Li Chi so da Dot ttf
349:27 - and with that I have a font with all of
349:30 - that covered basically what I want to do
349:32 - I want to create an update method that
349:36 - one itself and nothing else
349:39 - and this is actually going to show the
349:41 - menu although we do have to do quite a
349:44 - bit of work to get this one done for now
349:46 - just to see if this is working I want to
349:49 - show some blank surface
349:52 - which means I want
349:54 - self.d display surface dot Blitz in here
349:58 - I want to create a surface from scratch
350:01 - and this one is going to have a
350:03 - dimension of let's say
350:05 - one thousand and one thousand
350:08 - the position here is going to be 0 and
350:11 - 0. the way we are going to call it
350:13 - inside of level dot Pi I want to get rid
350:17 - of print shop active and instead first
350:21 - of all at the top I want from menu
350:24 - import menu
350:28 - inside of the init method I want to
350:31 - create an object from the class so self
350:34 - dot menu is going to be menu
350:38 - the two arguments we need here from menu
350:41 - we need player and toggle menu
350:44 - layout is really easy because we have
350:46 - self dot player
350:48 - toggle menu is also very easy because in
350:51 - here we have self dot this one is called
350:53 - toggle shop though but same thing I can
350:56 - just paste it in here and we are good to
350:59 - go
351:01 - inside of the run method I have to do
351:04 - some reorganizing
351:06 - the first two lines can stay identical
351:08 - and let me add a few more comments here
351:10 - to make all of this a bit clearer
351:12 - the first two lines are let's call it
351:15 - drawing logic
351:18 - after that we have the updates
351:21 - in here I want to check if
351:24 - self.shop active
351:26 - if that is the case I want self Dodge
351:29 - menu dot update I think I called it yeah
351:33 - update I want to call this method here
351:36 - and only if that is not the case so else
351:39 - I want to do these two lines here
351:43 - if the menu is active the player cannot
351:46 - move anyway so there's no point updating
351:48 - all of the Sprites or any of the planned
351:51 - collisions it's simply not necessary as
351:54 - a matter of fact I want to stop the
351:56 - entire game while the menu is open this
351:59 - is going to include the rain as well
352:01 - which means it's only supposed to rain
352:04 - if raining is true and not self dot shop
352:08 - active
352:10 - only then do I want to update the rain
352:13 - the overlay however can stay here
352:16 - let's put all of this under the weather
352:19 - section actually
352:21 - and let me remove these comments I think
352:24 - this makes the most sense
352:27 - with that we have the entire run logic
352:31 - let's try it
352:33 - so it may not pi
352:35 - it still works and now I want to run to
352:37 - the shop
352:42 - and in here I want to press enter and
352:45 - the game is crashing
352:47 - because inside of menu this one should
352:50 - be Pi game dot surface and while I'm
352:54 - here I also realized this should be
352:57 - inside of another Tuple now let's try
353:00 - this again
353:09 - and next to the merchant I press enter
353:12 - and now we have a big black rectangle
353:15 - and the rest of the game also doesn't
353:17 - update which is a very good sign which
353:20 - means this one is working we just have
353:23 - to add more logic to it the most
353:25 - important one for now is that we need an
353:28 - input method so that we can switch off
353:31 - the menu as well
353:33 - this is actually going to be your
353:35 - exercise
353:37 - I want you guys to get the input
353:41 - and then
353:42 - if the player presses
353:46 - Escape close the menu
353:51 - pause the video now and try to figure
353:53 - this one out it should be fairly doable
353:59 - first of all we have to get all of the
354:01 - keys this we get with pygame DOT key dot
354:05 - get underscore pressed
354:08 - once we have that I want to check if
354:11 - keys and pygame Dot a underscore Escape
354:16 - if that is the case I want to run self
354:18 - dot toggle menu don't forget we also
354:22 - have to call Self dot input but other
354:25 - than that this should be it
354:28 - back at main.pi let's run this again
354:33 - and right next to the merchant I press
354:35 - enter and now if I press Escape
354:38 - the game continues and this I can do
354:40 - multiple times this is working really
354:42 - well
354:43 - so with that we can toggle the menu
354:46 - with that we can actually start creating
354:49 - the proper one and for that I first of
354:52 - all want to have a couple of options the
354:55 - most important one for now is self dot
354:57 - with and this one I set to 400. this is
355:02 - going to be the entire window and inside
355:05 - of it roughly here I want to have the
355:08 - menu inside of the menu we're going to
355:11 - have individual entries like so
355:15 - what width is determining right now is
355:18 - the width of this entire menu
355:21 - besides that I also want self.space that
355:25 - is the space between the elements this I
355:27 - set to 10 and then self dot padding and
355:31 - this I set to 8. once we have that
355:34 - information I want to create the actual
355:37 - menu entries
355:39 - and for that first of all we are going
355:41 - to need all of the I call this one the
355:44 - options
355:45 - what this is going to be inside of the
355:48 - player in the image method we have the
355:52 - inventory this is going to be what I
355:55 - want for the options for the menu
355:57 - and I am going to combine all of those
355:59 - into one list self dot player dot item
356:04 - underscore inventory and I only really
356:07 - care about the keys here don't forget to
356:09 - call this and this I want to turn into a
356:13 - list
356:14 - this list I want to combine with the
356:17 - seats
356:18 - let me copy it and to combine the two
356:20 - lists I need plus and copy this list and
356:25 - I want to have the seed inventory
356:29 - this one here
356:30 - to make sure this one is working let me
356:33 - print what we get self dot options
356:38 - and now if I run this and close the game
356:42 - you can see we have all of the different
356:45 - options
356:47 - what Apple cotton tomato are the
356:49 - inventory of the player so the items
356:51 - corn and tomato are the seeds although
356:54 - now we do have a problem let me run it
356:57 - again actually
356:58 - inside of this list I need to know which
357:01 - of these items can be sold and which
357:03 - ones can be bought
357:05 - the items should be only sellable so
357:09 - these four items I want to be able to
357:11 - sell and these two items here I can only
357:13 - buy as a consequence I need to figure
357:16 - out where I'm drawing this line here
357:18 - where we end the selling menu and start
357:21 - the buying menu for that I created
357:24 - another attribute that I called cell
357:27 - border
357:29 - this is basically self Dodge player
357:32 - Dodge item inventory I am getting the
357:36 - length of it and from this I'm
357:39 - subtracting negative one later on I'm
357:42 - going to cycle through this list and for
357:45 - every item I'm going to check the index
357:46 - and check if it is smaller or greater
357:49 - than this border
357:50 - if it is smaller we are selling if it is
357:53 - greater we are buying and with that I
357:56 - can create a self dot setup method
357:59 - let's do it right below this one doesn't
358:02 - need any arguments
358:05 - the most important thing I have to do in
358:07 - here is to create the text surfaces
358:12 - all of those are going to be stored in
358:14 - the list and the list I called text
358:17 - surfaces
358:18 - for now it's just going to be an empty
358:21 - list
358:21 - all of these items are going to be
358:23 - created with four item in self dot
358:27 - options
358:28 - that is the list we have created up here
358:31 - all I have to do is to create a text
358:34 - surface and this I am getting with
358:36 - self.font.render
358:40 - in here we need a string we need
358:44 - anti-alias and we need a color the color
358:47 - is the easiest bit I just want to have
358:49 - black in here
358:51 - anti-alias should be false and the
358:54 - string should just be the item
358:57 - once I have that text surface I want to
358:59 - get myself dot text surfaces and append
359:03 - the individual text surface
359:06 - I also just realized this one should be
359:09 - set up not input now with that we have a
359:13 - list of surfaces
359:15 - this we can now use inside of the update
359:18 - method in here I can get rid of this big
359:21 - black rectangle and instead I want to do
359:24 - for text
359:26 - surfaces in self dot text surfs
359:31 - although remember what I explained
359:33 - earlier
359:35 - for this logic here to work to separate
359:37 - between the buy and the cell menu I need
359:40 - to know the index of every item inside
359:42 - of this for loop as a consequence I'm
359:45 - going to use the enumerate method here
359:49 - and let's call this one text index
359:53 - I suppose for now all we have to do is
359:56 - self dot displaysurface dot lit
359:59 - we have a text surface and for the
360:03 - position
360:04 - let's say we can go with a hundred for x
360:08 - and for y I want to have the text index
360:13 - multiplied by 50. let's try all of this
360:16 - now
360:18 - and once again I have to walk to the
360:21 - trader
360:26 - here we are at the trader if I run this
360:29 - we can see the different entries so this
360:31 - is looking really good we can also end
360:33 - the menu and this is working very well
360:37 - very good we are making progress
360:41 - although now we do have a problem right
360:44 - now the height is basically random so we
360:48 - have to figure this out more
360:49 - deliberately this is also going to
360:51 - happen inside of the setup method
360:54 - besides the text surfaces I want to have
360:57 - self dot total
361:00 - height by default this is going to be
361:03 - zero
361:04 - inside of the for loop I want to get
361:07 - this total height and plus equal self
361:11 - Dodge text
361:14 - surface
361:15 - and then get underscore hype
361:19 - although don't forget I also want to add
361:22 - Plus
361:23 - self dot heading multiplied by two and
361:28 - this I want to put in Brackets that
361:31 - looks a bit cleaner each of those text
361:34 - entries let's say we have three for now
361:38 - inside of those the text is only one
361:41 - part in the middle
361:43 - and there should be some space or some
361:45 - padding between the top and the bottom
361:47 - of the text this is what we're getting
361:49 - with self.padding the entire height
361:51 - though is what we're getting from
361:54 - self.total height
361:55 - this is what we're going to use in just
361:57 - a second to Center the entire menu
362:00 - although there's one more thing that we
362:02 - do need because if I open the drawing
362:05 - again
362:06 - between each of the entries so this
362:10 - space here there should be some more
362:12 - space that is the space we have set up
362:15 - earlier in here
362:17 - to get that number let's do it here I
362:20 - want to get self dot total height and I
362:25 - want to add a number number I want to
362:27 - get the
362:29 - text surfaces and I want to know how
362:31 - many items I have so I want to have the
362:33 - length
362:34 - right now that number would be free
362:36 - because we have 1 2 and 3 elements
362:40 - from that I want to subtract 1. for the
362:42 - simple reason that we only have one
362:44 - space for any two elements as a
362:47 - consequence if we have three elements in
362:50 - total we want to have two spaces between
362:53 - them all of this I want to put inside of
362:56 - another bracket and this I want to
362:58 - multiply with self Dot base
363:03 - and now I have the total height
363:06 - this I can use to calculate self Dodge
363:09 - let's call it menu top
363:12 - this is going to be the top part of the
363:14 - menu
363:15 - for this number I need in my settings
363:18 - the screen height
363:21 - and this I want to divide by two
363:24 - from this number I want to get myself
363:26 - dot total height and divide this by 2 as
363:30 - well
363:31 - this here is going to be the entire
363:33 - screen and Screen height divided by 2
363:36 - would be roughly this point here
363:39 - from that I want to subtract self.total
363:41 - height divided by 2.
363:43 - that would be roughly let's say here
363:47 - with this being the first half and the
363:50 - other half would be below so one half
363:52 - here that way the menu is always going
363:55 - to be in the middle
363:57 - there's one more attribute I want and
363:59 - this I called self dot Main rect this is
364:04 - going to be the bounding box for the
364:06 - entire menu and this is going to be a
364:08 - rectangle so pygame.rect
364:11 - in here we need the left the top the
364:13 - width and the height
364:15 - figuring those numbers out could
364:17 - actually be a really good exercise so
364:19 - try to figure them out yourself and see
364:22 - how far you get
364:25 - there are three numbers in here that
364:27 - should be fairly simple the top is what
364:30 - we have just done it's just self.menutop
364:34 - so I can place this one in here the
364:36 - width is also very easy that is the
364:38 - number we have created up here
364:40 - which means I want to have self dot with
364:44 - height is also easy this is just going
364:47 - to be self dot total height
364:49 - the only minor complication is the left
364:52 - side to get this one we kind of need the
364:56 - same logic we have used here I first of
364:58 - all want to get my screen with and this
365:02 - I want to divide by two
365:04 - from that I want to subtract self dot
365:07 - with and subtract this by 2 as well
365:11 - way of that we should be having a
365:13 - rectangle that is in the center of the
365:15 - window and also is as tall as all of the
365:18 - text elements
365:20 - I guess let me minimize the setup method
365:22 - and try this one I guess for now we can
365:26 - comment out this for Loop here and
365:28 - instead
365:30 - I want to pygame dot draw dot rect I
365:35 - want to draw on self dot display
365:37 - underscore surface the color let's go
365:41 - with red and the rectangle is going to
365:43 - be self dot main rectangle and just for
365:47 - testing purposes it's going to be kind
365:49 - of annoying to always walk towards the
365:51 - merchant
365:53 - so inside of the player let me go to the
365:56 - input method
366:01 - and then here if the player is pressing
366:03 - enter I want to toggle the shop already
366:07 - like this
366:08 - now if I run the game I am getting an
366:12 - error
366:13 - this happens inside of menu inside of
366:16 - setup and this self.text surface
366:19 - shouldn't be itself it's just a text
366:22 - surface so we're getting this one here
366:24 - now let's try this again we're not
366:26 - crashing and now if I press enter
366:28 - we're getting a menu in the middle of
366:30 - the window I can also press escape and
366:33 - the game continues as always
366:34 - so this is working quite well I suppose
366:38 - next up we can start working on another
366:41 - important UI element and that is display
366:45 - underscore money
366:47 - there's no need for any arguments in
366:49 - here and all we are going to do in here
366:52 - is first of all we need a money service
366:56 - or rather
366:57 - since we have local variables this can
367:00 - be a text surface
367:02 - all I want in here is
367:04 - self.font.render in here again we need a
367:07 - string we need anti-alias and we need a
367:10 - color the color once again is going to
367:13 - be black and anti-alias is going to be
367:16 - false
367:17 - it is false here because I have pixel
367:19 - fonts which don't look good when the
367:21 - anti-alias them finally for the string
367:24 - what I want to access is inside of the
367:27 - player in the init method
367:30 - I want to access this money attribute
367:33 - here this I get with self dot player Dot
367:37 - money
367:39 - although this I want to put inside of an
367:42 - F string
367:43 - like this
367:46 - because that way I can add a dollar sign
367:48 - before
367:49 - once I have that I can create a text
367:52 - rectangle this is just going to be the
367:55 - textsurface dot get underscore rect
367:59 - and in here I want to place the mid
368:01 - bottom
368:02 - for the position here I want to have
368:04 - this green
368:07 - width divided by 2 so we are right in
368:10 - the middle and then I want to have this
368:12 - green height and subtract 20 from here
368:16 - that's why we are slightly off-centered
368:18 - from the bottom of the window
368:19 - once we have those two bits I can get
368:22 - myself dot display surface and Blitz the
368:26 - text surface and the text
368:30 - rectangle
368:32 - and now all I have to do is to run
368:36 - self.display money and this should be
368:39 - working
368:40 - so inside of minor Pi I press enter and
368:43 - we can see the money in the bottom
368:44 - center of the window
368:46 - this is working very well although
368:48 - there's one more element I want to add
368:51 - and that is a background for this text
368:55 - this I get with pygame DOT draw Dot rect
369:00 - and in here I want to draw on self.d
369:03 - display surface
369:04 - the color for this one should be white
369:06 - the rectangle I want to use in here is
369:09 - the text rectangle although I do want to
369:12 - inflate this one by a tiny bit let's say
369:15 - 10 and 10 pixels
369:18 - if I run this now
369:20 - this is already looking much better
369:22 - although I do want to have some rounded
369:24 - borders
369:26 - this I can also get very easily
369:28 - I need to add two more arguments
369:31 - the first one is the Border width which
369:33 - in my case is going to be zero and then
369:36 - we have the Border radius which in my
369:39 - case is going to be six and this 6 here
369:41 - determines the Border radius or how much
369:43 - rounding we get
369:45 - if I run this now
369:47 - we have some rounded borders which makes
369:49 - the entire thing look much nicer
369:52 - I guess you can play around with
369:53 - different numbers here let's try four
369:57 - yeah I guess this one looks a bit better
369:58 - but again this is pretty subjective so
370:02 - choose whatever you think is best
370:04 - with that we have finished the money
370:06 - this is all we need in this one
370:08 - I guess next up we can work on all of
370:12 - the actual entries and we already have
370:15 - some good starting points here we have
370:18 - access to all of the text surfaces and
370:21 - we know their index
370:22 - this I can use inside of another method
370:26 - let me call it show entry in here we do
370:30 - need a couple of arguments I want to
370:33 - have a text surface so the text I want
370:35 - to show then I want to have the amount
370:38 - like so then I need the actual position
370:42 - and this is going to be top with all of
370:45 - that I can start working on this and
370:48 - first of all in here I need a background
370:52 - after that we are going to create the
370:55 - text and later on we also going to show
370:59 - an amount
371:01 - but let's get started with the
371:02 - background
371:04 - in here I want to create a BG rectangle
371:07 - this is just going to be a pi game
371:10 - wrecked and once again we need a left a
371:12 - top a width and a height left we can get
371:15 - fairly easily because we have self dot
371:19 - main rectangle dot left
371:22 - since this main rectangle is in the
371:24 - center of the window this makes it very
371:26 - easy for us to get positions top is
371:29 - going to be what we're getting from the
371:31 - parameters this top here the width is
371:34 - going to be self dot with the one we
371:37 - have created all the way up here and
371:39 - finally the height is going to be text
371:42 - surface dot get underscore hype don't
371:46 - forget to call it
371:47 - and to this I want to add self dot
371:50 - adding multiplied by two
371:53 - once I have that all I want to do is
371:55 - pygame dot draw Dot rect and in here
371:59 - self.display surface the color should be
372:03 - white
372:04 - I want to draw the background rectangle
372:06 - and I want to go with 0 and 4 for the
372:10 - Border radius
372:12 - with that we already have a pretty good
372:14 - start all we have to do now is inside of
372:18 - this for Loop we have to figure out how
372:20 - to actually call this show entry let me
372:23 - add a bit of white space and first of
372:25 - all in here we need to get the top and
372:29 - the top is going to be self dot main
372:31 - rectangle dot top
372:34 - plus the text index
372:38 - and this I want to multiply with a
372:40 - couple of things most importantly the
372:43 - text surface and I want to get the
372:45 - height of that
372:47 - although to that I have to add self dot
372:51 - padding multiplied by two and I have to
372:54 - add self dot space think of this one
372:58 - here is the main rectangle this one here
373:03 - and by default we are getting the top
373:06 - this line here
373:08 - and for every item we want to get the
373:11 - distance downwards that we get by
373:13 - multiplying the text index by the height
373:16 - of the text the padding and the space
373:20 - for example if the text index is zero
373:22 - all of this is going to be zero so the
373:25 - first item is going to be all the way at
373:27 - the top here
373:28 - for item number one we would be
373:31 - somewhere here let's say this one could
373:34 - be 100 because the text height would be
373:38 - something like 70
373:40 - the padding could be two times ten and
373:45 - let's say for the space we also have pen
373:49 - and all of this we want to multiply by
373:52 - one as a consequence the result here is
373:54 - going to be 100 and this 100 is going to
373:57 - be the top of this text entry and this
374:01 - is what we can use in self dot show
374:04 - entry let me copy all of the parameters
374:06 - here so top is what we have just
374:09 - calculated text surface is also what we
374:12 - are getting from here
374:13 - for the amount for now let's just say
374:16 - zero we're going to work on this in just
374:18 - a second
374:19 - but for now if I run main.pi again and
374:22 - press enter now we can see all of the
374:25 - background fields and those are
374:27 - perfectly centered which is looking very
374:29 - nice
374:30 - definitely progress
374:32 - although let me get rid of this line
374:35 - here so we're not drawing the text
374:37 - anymore and also this drawing here so we
374:41 - don't have the red background
374:43 - now if I run this again
374:45 - this is looking much cleaner cool so
374:49 - with that we can start working on the
374:51 - text
374:53 - for this one I want to create a text
374:55 - rectangle once again this is going to be
374:58 - pygame Dot rect and again we need a left
375:02 - atop a width and a height
375:05 - or this one I want to get the text
375:08 - surface and get underscore rect in here
375:12 - once again I want to place the mid left
375:14 - I need an X and A Y position
375:18 - or rather I need a left and a top
375:21 - position to be a bit more specific
375:23 - for the left side I want to have self
375:26 - dot mainreact dot left and now I want to
375:30 - have an offset let's say 20.
375:33 - for the top I want to have the BG
375:35 - rectangle and in here I want to have
375:38 - this Center y position
375:41 - once I have that I can run
375:43 - self.displaysurface dot lit and pass in
375:47 - the text surface and the text rectangle
375:51 - let's try this one now
375:54 - and there we go this is looking really
375:56 - good
375:57 - finally we need the amount
376:01 - for this one first of all I want to
376:03 - create an amount surface
376:06 - this once again I get with
376:08 - self.font.render
376:10 - in here we need some text we need
376:13 - anti-alias and once again the color
376:16 - the color
376:18 - is always going to be black anti-alias
376:20 - is always going to be false and the text
376:23 - itself is going to be the amount
376:25 - although here this we have to convert to
376:29 - a string
376:30 - because by default amount is a number
376:33 - and pygame doesn't like that it always
376:35 - wants a string for the render method now
376:38 - that we have that we can create an
376:40 - amount rectangle
376:42 - this we get with a mount surface dot get
376:45 - underscore Rec and for this one I want
376:48 - to place the mid right
376:50 - again we need a left and a top and for
376:54 - the left side what I want in here if
376:57 - this is one text box
377:01 - or rather one of the BG rectangle
377:04 - inside of there we have the text
377:07 - rectangle and the text is somewhere here
377:09 - ish with a offset from the left
377:13 - for the amount surface I want the exact
377:15 - opposite I want to come from the right
377:17 - side and have something like this
377:19 - which means draw the left side here we
377:22 - want to have the right side
377:25 - of the main rectangle and then go to the
377:27 - left a bit
377:29 - which means I want to have self dot Main
377:32 - rect
377:33 - dot write and subtract let's start with
377:37 - 20 pixels although for the top all I
377:40 - want is the BG rectangle and then Center
377:43 - y again and let me clean this up a tiny
377:46 - bit there we go all we have to do now is
377:49 - get
377:50 - self.displaysurface dot Blitz and pass
377:53 - in the amount surface and the amount
377:56 - rectangle
377:58 - if I run this now
378:00 - this is looking pretty good
378:04 - although we do have to figure out the
378:06 - actual numbers for the amount
378:08 - that however isn't that difficult or at
378:11 - the very least it's certainly possible
378:13 - first of all inside of the for loop I
378:16 - want to get let's call it an amount list
378:19 - and this amount list is going to be very
378:22 - similar compared to this options here as
378:24 - a consequence I can just copy it
378:27 - and paste it in here except now we don't
378:30 - look at the keys instead we are looking
378:32 - at the values this way if I open the
378:36 - player we are getting all of these
378:39 - values here inside of one list
378:42 - and this list has the same order as this
378:46 - list here
378:47 - as a consequence
378:50 - we can get the amount
378:52 - simply by looking at the amount list and
378:55 - using the text index
378:58 - and that is what I want to pass in here
379:02 - if I now run this again press enter
379:04 - we're getting lots of zeros but then we
379:07 - are getting 5 and 5. those are the two
379:10 - seeds
379:11 - and with that we have the basics of the
379:16 - menu
379:17 - although we cannot select anything and
379:19 - let's do this right now I guess we can
379:21 - keep the entire Merchant in one big
379:24 - section for the selection we need a few
379:27 - more things most importantly let me add
379:30 - this section here and let's call it
379:33 - movement
379:36 - there one thing we need here is self dot
379:39 - index
379:40 - by default 0 here is totally fine and
379:43 - how I'm going to use this when I'm
379:46 - creating show entry let me minimize
379:48 - everything else
379:49 - there's going to be one more parameter
379:52 - and that is going to be selected
379:55 - and if selected is true so if selected
380:01 - then I want to for now just draw a
380:04 - border around this particular box which
380:07 - I'm getting with self dot display
380:09 - surface for the drawing the color here
380:12 - should be black
380:14 - and I want to get the background
380:16 - rectangle although now I want to have a
380:19 - border width of four
380:21 - and four for the Border radius if you
380:24 - specify a border width the content or
380:27 - the filling disappears for this
380:29 - rectangle but let me show what actually
380:32 - happens if I press enter now
380:34 - we are getting an error because I forget
380:37 - to add the argument in here I want to
380:40 - have either true or false and what I'm
380:44 - checking is if self dot index is equal
380:48 - to the text index
380:50 - now if I run this and press enter now by
380:54 - default the first item is going to be
380:56 - selected however if I go to my menu and
381:00 - set this index to let's say F3 and run
381:04 - this again
381:05 - now
381:06 - we have tomatoes selected
381:10 - and all I really have to do inside of
381:12 - the menu is to change this index to
381:15 - select a different item and this I am
381:17 - doing inside of input all I want to do
381:21 - in here is if keys and Pie game dot k
381:26 - underscore up if that is the case I want
381:29 - to set self dot index minus equal 1.
381:34 - then I can copy all of this
381:37 - and change the up to down
381:40 - and this one should be a plus one
381:42 - now I can set index back to zero and now
381:46 - let's try this actually if I press enter
381:48 - now and press down
381:51 - something weird is happening the thing
381:53 - disappears oh well it kind of works but
381:56 - it moves way too fast and this is a
381:59 - problem we have encountered earlier
382:01 - basically inside of the init method hi
382:05 - game for this one for example checks if
382:07 - the down key is being pressed but pie
382:09 - game checks this about a hundred times
382:12 - per second as a consequence if we are
382:15 - pressing it down pygame registers this
382:17 - line let's say 20 times
382:20 - even though for us it seems like we are
382:22 - only pressing the key once
382:25 - and as a consequence we need a timer
382:29 - this one we already have I want from
382:32 - timer import timer
382:35 - and the timer I want to create in here
382:37 - so self dot timer is going to be timer
382:41 - for this one we only need a duration and
382:45 - for the duration for this one I went
382:47 - with 200 milliseconds
382:49 - now inside of the input method when I'm
382:52 - pressing either up or down I want to
382:55 - activate this timer so
382:57 - self.timer.activate
383:00 - but all of this should only be possible
383:03 - if the timer is not active meaning if
383:06 - not self dots timer DOT active
383:10 - finally there's one more thing that we
383:12 - need and that is we have to update the
383:14 - timer which I'm doing all the way to top
383:16 - of the input method self dot timer dot
383:19 - update
383:20 - I hope you remember the timer actually
383:22 - we created this one a couple of hours
383:24 - ago let me open it actually so inside of
383:27 - the timer this one here we have all of
383:30 - this
383:31 - and this is what I'm using inside of the
383:32 - menu right now
383:34 - but with that this should already be
383:37 - working if I run this now I can open the
383:39 - menu and I can move up and down this is
383:41 - working really well the problem right
383:43 - now is if I move too far up the thing
383:45 - disappears and also if I move too far
383:47 - down it disappears
383:50 - this we want to control for
383:53 - meaning I want to clamp the values
384:00 - all this really means in practice is I
384:02 - want to have myself dot index and if
384:04 - this one is below zero
384:06 - I want to set self dot index
384:09 - to length of self dot options
384:14 - minus one
384:15 - this means if we are going below zero we
384:19 - are going to the end of the list
384:20 - this is also going to work the other way
384:22 - around that if self dot index is greater
384:26 - than
384:27 - the length of the list -1 then I want to
384:30 - set self dot index to zero
384:34 - and now let's run this again and if I
384:37 - move down this still works if I move up
384:39 - we are getting to the bottom of the list
384:41 - and if I move downwards we are going
384:43 - back to the top
384:45 - so this is working perfectly fine
384:49 - okay next up when we are showing the
384:52 - entry
384:54 - let me minimize everything once more
384:58 - the next thing I want to do is that let
385:01 - me run the game again
385:03 - and we have what Apple corn automatic
385:06 - selected I want to have a cell text
385:09 - roughly here
385:12 - for all of these and if we have corn or
385:15 - tomato selected there should be a buy
385:18 - text here
385:19 - and this is what I'm going to create now
385:23 - first of all for that inside of the
385:26 - setup we have to import or well create
385:28 - two more things
385:30 - those two things are going to be the buy
385:32 - or sell text surface
385:36 - in here I want to have self dot by text
385:39 - and I want to have self dot cell text
385:43 - both of those are going to be
385:47 - pygame.font.render and again we need
385:50 - three arguments the first one is the
385:52 - text let's leave this one empty for now
385:54 - after that we want faults for the
385:56 - anti-alias and for the color we want
385:58 - black
386:00 - for the buy text this should just be buy
386:02 - and for the cell text it should be cell
386:06 - with that we have two surfaces
386:10 - we just have to figure out when to
386:12 - actually show them
386:14 - that is going to happen inside of show
386:17 - entry
386:18 - specifically I only want to show this
386:21 - when this specific entry is selected
386:24 - how this is going to work I am first
386:26 - going to check if self dot index
386:30 - is greater than self dot cell order this
386:34 - is the board that we created in the init
386:36 - method
386:37 - right here this one is checking the
386:41 - length of the inventory so if we are
386:45 - inside of the length of this border we
386:47 - want to sell if we are Beyond it we want
386:49 - to buy
386:50 - let me add comments here this one is
386:52 - going to be buy and if this one is not
386:54 - true so else then we want to sell
386:58 - actually I think this one is a bit
387:00 - confusing let me do this the other way
387:02 - around so if we are below this we want
387:05 - to sell and if we are Beyond it we want
387:07 - to buy
387:09 - and all we have to do now is self dot
387:12 - display
387:14 - surface.blit and in the cell one I want
387:17 - to display self Dot
387:20 - I call this one cell text
387:24 - for the position let's say for now we
387:27 - are going to go with 0 and 0. and for
387:30 - the buy text this is going to be by text
387:34 - and let's try this one although it's
387:36 - going to look a bit funny and we have an
387:39 - issue inside of the setup method this
387:43 - shouldn't be Pi game it should be self
387:45 - dot font dot render if I now run this
387:47 - again this is working and now in the top
387:50 - left you can see cell cell and now we
387:53 - have Buy Buy
387:55 - although for the Tomato something did go
387:58 - wrong so we have to make some minor
388:00 - adjustments here but other than that
388:02 - this is working pretty good
388:03 - I guess the problem here is inside of
388:06 - Entry this should be smaller or equal if
388:10 - I now run this again we get cell cell
388:13 - and buy and buy there we go this is
388:15 - working just fine
388:19 - although the position of the buy and
388:21 - sell text we do have to work on although
388:24 - the position is looking a bit weird
388:26 - let's work on that one and for this I
388:29 - want to create another rectangle let's
388:31 - call it the position rectangle
388:34 - in here I want to have self dot for cell
388:37 - I want to have the cell text and get
388:41 - underscore rect
388:42 - for this one I have to place the mid
388:45 - left
388:46 - and once again I need a left and I need
388:48 - a top the top is the really easy part
388:50 - because I get my background rectangle
388:53 - Dot Center y
388:55 - for the left I want to have myself dot
388:58 - mainrectangle dot left and to this one I
389:02 - want to add 150 pixels
389:05 - I can place the position rectangle in
389:08 - here and this should be working let's
389:11 - try
389:12 - and we are getting an error that this
389:15 - should be
389:16 - Get Wrecked with lowercase letters
389:20 - and now we get cell
389:23 - in the perfect positions although bi is
389:26 - still looking a bit weird
389:28 - but that we can work on all I have to do
389:31 - is duplicate this one here paste it in
389:34 - there and now we want to get the buy
389:37 - text
389:39 - surface but the rest is going to remain
389:42 - the same
389:44 - meaning if I run this now we get cell
389:46 - cell and bye bye because I didn't paste
389:51 - the position rectangle in here for the
389:53 - position now this should be working
389:56 - sales or sell and buy and buy this is
389:58 - working perfectly fine
390:02 - cool I am really happy with this
390:07 - so let me minimize show entry and the
390:10 - setup all we have to do now inside of
390:13 - input is to actually make the menu do
390:16 - something
390:17 - for that inside of this if statement
390:20 - here I want to add another if statement
390:23 - and now I want to check if keys and
390:26 - pygame dot k underscore space
390:29 - if that is the case first of all I want
390:32 - to activate the timer so
390:33 - self.timer.activate
390:37 - after that I want to get the item
390:41 - so I want to create another variable
390:42 - called current item
390:45 - and for this one I want to have myself
390:47 - dot options
390:49 - and use self.index
390:53 - I suppose let me print what we actually
390:55 - get with current item and if I run
390:58 - main.pi if I now press space we get wood
391:01 - Apple corn tomato corn and tomato this
391:05 - is working just fine
391:07 - now I have to figure out do I want to
391:09 - sell or do I want to buy
391:13 - that is information we can access quite
391:15 - easily
391:16 - because I once again want to check if
391:19 - self.index is smaller or equal than self
391:23 - dot cell order
391:26 - if that is the case I do want to sell if
391:29 - it is not the case so else I want to buy
391:32 - if I am selling it should be
391:34 - self.player.item.inventory
391:38 - and I want to check the current item
391:41 - if that is greater than zero I want to
391:44 - do something so this should all be an if
391:47 - statement
391:48 - let me copy the entire line here because
391:51 - what I want to do if this is the case
391:53 - this should be reduced by one
391:56 - and on top of that I want to get myself
391:59 - dot layer
392:02 - Dot money
392:04 - and I want to increase that amount by a
392:07 - certain number this number I'm getting
392:10 - from settings and here I can minimize a
392:12 - ton of different things
392:15 - in here we have sale price and purchase
392:18 - prices
392:19 - for now I only care about the sale price
392:22 - this I want to access and I want to use
392:25 - the current item as the index
392:27 - this should be all we need for now for
392:30 - the else I want to add a pass and just
392:33 - to test this inside of the player let's
392:35 - give the player a couple of items
392:38 - like this
392:40 - and now if I run this again I press
392:42 - enter I have lots of different items I
392:45 - could be selling and if I press space
392:48 - the amount gets reduced and our money
392:50 - increases
392:51 - and let me try to sell all of my word
392:55 - if I now get to zero I cannot sell
392:57 - anymore
392:59 - but I can still sell other things so
393:01 - this is working perfectly fine
393:03 - so with that all we have to do is to
393:06 - check the buy part and we are basically
393:09 - done in here first of all I need to get
393:12 - the seed price this I'm getting again
393:15 - from settings in there we have purchase
393:17 - prices
393:18 - I want to get and in here I want to get
393:21 - my current item as the index now I want
393:23 - to check if the player has enough money
393:25 - for it which means if self dot player
393:28 - Dot money is greater or equal than the
393:31 - seed rice
393:33 - then I want to get
393:37 - self.player.seed underscore inventory
393:40 - and I want to get the current item again
393:43 - I want to plus equal one
393:46 - and then self dot layer Dot money
393:51 - is going to be minus equal the purchase
393:54 - price of the current item there we go
393:56 - and this should be it let's try
394:01 - so I can still sell things but now if I
394:04 - try to buy things
394:05 - my money goes down and
394:08 - let me hold space pressed and at some
394:11 - point we should be reaching zero
394:15 - there we go now we are zero and I cannot
394:17 - buy any more seats
394:21 - I can still self install and now that I
394:23 - have money again I can buy some tomato
394:24 - seeds
394:26 - until I am running out of money and
394:30 - there we go this is working fine
394:34 - so with that we have created the entire
394:38 - menu
394:39 - and that finishes basically the main
394:41 - part of the game all we have to do now
394:43 - is to add some sounds and then we are
394:45 - done for the final bit we have to add
394:47 - the sound let's Jump Right In this
394:49 - really shouldn't take too long here we
394:51 - are back in the code and what I want to
394:53 - work with let me open the folder
394:56 - here's the entire project and I want to
394:59 - look at audio in here we have a couple
395:01 - of different files that I want to use
395:04 - the main problem is we have to figure
395:06 - out when and where to use them
395:09 - but that really shouldn't be too
395:11 - difficult
395:12 - let's start with the X for this one I
395:15 - want to look at my Sprites so let's open
395:17 - this one again
395:20 - in the Sprites I want to minimize
395:23 - everything because I only want to focus
395:25 - on the tree
395:27 - basically inside of the tree whenever we
395:29 - damage a tree I want to play the X sound
395:33 - let me add another comment here play
395:36 - sound
395:37 - basically all I want to do is self dot X
395:40 - sound dot play and that is basically it
395:43 - for that I have to import it this
395:47 - happens in the init method
395:49 - let's call this one sounds all I need in
395:53 - here is self dot X sound and this is
395:57 - what I get from pygame dot mixer dot
396:01 - sound
396:02 - spelled like that
396:04 - the file path we need here is one folder
396:07 - up then audio and in there we have a
396:09 - file called x dot MP3
396:13 - and with that we should be ready
396:17 - if I now run main.pi and walk towards a
396:21 - tree and hit that one with an ax
396:24 - foreign
396:27 - pretty good
396:30 - so next up we need the sound effect if
396:33 - the player gets a thing this is going to
396:36 - happen inside of level because in here I
396:40 - have the player ad method I basically
396:43 - want to play something like self dot
396:46 - success dot lay
396:49 - in this success we have to import and
396:51 - this happens let's do it all the way at
396:54 - the bottom
396:55 - music this I call Self dot success
396:59 - and this once again we get with
397:02 - pygame.mixer.sound the file once again
397:05 - is one folder up audio and the file is
397:09 - called success dot wav
397:12 - although for this one by default I think
397:14 - it's a bit loud as a consequence
397:17 - self.success dot set underscore volume
397:21 - and in here 0.3 I think sounded good
397:27 - and now anytime the player gets any kind
397:29 - of item we are playing that sound
397:33 - so let's run main.pi
397:35 - and let's say I want to get an apple
397:40 - that sounds not too bad
397:42 - and if a tree disappears this also plays
397:46 - cool so this is working it's also going
397:49 - to play when we are picking up a plant
397:51 - but that takes a while to test so I
397:53 - think we're good for the next tool I
397:56 - want to work on the whole and for that I
397:58 - want to reopen my soil layer or soil.pi
398:02 - and I want to minimize everything in the
398:05 - soil layer
398:07 - I want to add sounds
398:10 - and in here I want to create self dot ho
398:13 - sound
398:15 - and this one I get with
398:17 - pygame.mixer.sound the file path here is
398:20 - one folder up audio
398:22 - and in there I have ho.wav
398:27 - this I want to make a little bit less
398:29 - loud though so
398:30 - I want to set the volume to 0.4 and this
398:36 - now if I minimize all of the methods I
398:39 - want to play whenever the soil gets it
398:41 - so in here
398:43 - let's do it all the way to the top
398:46 - self dot ho sound dot play and with that
398:50 - we should be having another sound
398:52 - so if I now release this one
398:56 - possibly a bit loud
398:58 - I want to change the set volume to 0.1
399:02 - and now let's try this
399:06 - definitely an improvement
399:08 - it's going to get better once we have
399:10 - background music but I'm kind of happy
399:11 - with this next up I want to work on the
399:14 - watering sound this one is going to
399:16 - happen inside of the player in here all
399:19 - the way at the bottom here
399:22 - I want to add
399:23 - a sound section and this I called self
399:26 - dot water ring
399:28 - this once again we get pygame.mixer dot
399:32 - sound
399:33 - the file path here is one folder up
399:35 - audio
399:36 - and the file name is called water dot
399:39 - this one is an MP3
399:44 - and whenever we are using a tool and the
399:47 - selected tool is water I want to play
399:50 - self.water Ring
399:53 - although for this one I also want to
399:55 - change the volume so self dot watering
399:58 - dot set underscore volume is going to be
400:02 - 0.2 if I now run main.pi again select
400:06 - the watering can
400:08 - foreign
400:10 - just fine cool
400:12 - yes one more that I forgot and that is
400:15 - inside of soil besides the hole we also
400:18 - have self dot plant
400:20 - and this one let's call it plant sound
400:22 - actually plant sound
400:24 - once again pygame.mixer dot sound and in
400:28 - here one folder up audio
400:30 - and this one is called
400:33 - planned and the file ending is a DOT wav
400:39 - let me just duplicate itself dot plan
400:42 - sound dot set underscore volume let's go
400:45 - with 0.2
400:48 - this one I want to play whenever we are
400:51 - planting a seat in here
400:53 - so all the way at the top I want
400:56 - self.plant sound dot play that way this
401:01 - one will only be played if we are
401:03 - actually hitting the soil if I run this
401:05 - I first have to create a soil patch and
401:08 - now if I plant some seed
401:12 - not the greatest sound effect but it
401:14 - certainly works
401:15 - and all right with that we have all of
401:18 - the minor sound effects the one last
401:20 - thing we have to do is to play the
401:21 - background music and this could be a
401:23 - really good exercise for you figure out
401:25 - where you could play the background
401:27 - music and import it and play it
401:32 - all of this is going to happen inside of
401:34 - level I guess theoretically you could
401:36 - also play it in main.pi but level.pi is
401:39 - a bit more flexible in here I want to
401:42 - import music so self dot music and this
401:45 - we get with pygame DOT mixer dot sound
401:49 - the file name here is called well we
401:52 - have to go to audio first and I want to
401:54 - import music
401:56 - which in this case is an MP3 file
401:59 - what we also have to do to play it is
402:01 - self Dodge music dot play and in here
402:05 - Loops needs to be -1 so that we play
402:08 - this continuously now for the background
402:10 - music I have been a bit lazy because you
402:13 - probably want to change the volume
402:14 - depending on the daytime or play
402:16 - different kinds of music depending on
402:17 - what kind of weather you have but well I
402:20 - just have one kind of background music
402:22 - but this video is getting long enough
402:24 - you can work on this yourself but now if
402:26 - I run this
402:32 - foreign
402:39 - now before I finish the entire thing
402:41 - there are some very minor things I do
402:43 - want to change
402:44 - first of all inside of the player if I
402:48 - minimize everything again so we can see
402:50 - what's going on inside of the input in
402:53 - here I have to clean up this self or
402:55 - toggle shop that's the one I forgot
402:57 - earlier
402:58 - here we go and now this one is done so
403:02 - let me close the entire player
403:04 - besides that in the level I want to set
403:08 - the rain to something greater than 7.
403:11 - because the rain really shouldn't happen
403:13 - that often this I also have to update
403:16 - let me minimize all of the methods once
403:19 - more in the reset method this one should
403:24 - be like this finally inside of the
403:27 - Sprites in here once again I want to
403:30 - minimize everything and in the tree I
403:32 - created an involved timer and this one
403:34 - simply isn't necessary I just mixed up
403:37 - my notes but now we are done with the
403:41 - entire thing this was literally all we
403:44 - needed and let's make sure this is also
403:45 - running
403:51 - foreign
404:02 - this is looking really good so well done
404:06 - if you have gotten this part this was a
404:08 - really long tutorial so I hope you
404:10 - enjoyed it and I'll see you around