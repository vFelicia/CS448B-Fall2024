00:03 - hello there
00:04 - in this tutorial we are going to be
00:06 - creating this snake game and python with
00:07 - the pygame module
00:09 - and this is intended for absolute
00:11 - beginners so you don't have to know
00:12 - anything about the pygame module
00:14 - although you do have to know the basics
00:16 - of python programming in general
00:18 - at least a little bit and i will go for
00:20 - these steps to create the entire game
00:23 - and if you already know the basics of
00:24 - pygame skip ahead to this step
00:26 - then you go straight to the snake game
00:28 - but for everybody else just continue
00:30 - watching and we're gonna talk about how
00:31 - games work in general
00:33 - that is going to be really useful to
00:34 - understand what we are doing a little
00:36 - bit later on in this video
00:39 - so let's talk about how games work and i
00:41 - think this is best done by using an
00:43 - example
00:44 - so here's an image from the first level
00:45 - of super mario world
00:48 - and this image is composed of several
00:50 - elements
00:51 - we start with the background then we add
00:53 - a floor and some bushes
00:54 - then mario himself and finally some
00:56 - indicators at the top
00:58 - and each of these elements is just a
01:00 - picture that you could even download and
01:01 - use yourself
01:03 - and the important thing to note here is
01:05 - that this image
01:06 - is not just drawn once instead it is
01:08 - drawn multiple times per second in what
01:10 - is called a game loop
01:12 - and then to turn this into a game we
01:15 - have to add two more things
01:17 - number one is player input so that you
01:19 - have to know what the player wants to do
01:21 - and number two is that on each cycle you
01:24 - also reposition where elements are
01:25 - supposed to be drawn
01:27 - so in total there are three steps we
01:29 - check for player input
01:30 - we position elements on the screen and
01:32 - then we draw all of these elements
01:34 - and if that happens often enough you get
01:36 - a video game
01:37 - so let's look how this would work in
01:39 - practice so we first want to check for
01:41 - the player input
01:42 - and let's say the player is pressing the
01:43 - button to the right and as a consequence
01:46 - we want to move mario 5 pixels to the
01:48 - right
01:48 - and after that we draw the entire image
01:51 - with mario being 5 pixels further to the
01:53 - right
01:54 - and all of this would happen in one
01:55 - cycle of the game loop
01:57 - and on the next cycle we do the same
01:59 - thing again so if the player keeps on
02:01 - pressing right we still keep on moving
02:02 - mario to the right
02:04 - and redraw the entire thing again and
02:06 - then we keep on redoing this about 60
02:08 - times per second
02:10 - and as a consequence the player is
02:11 - perceiving all of this as an interactive
02:13 - medium
02:14 - and in an actual game much more is
02:16 - happening than just moving a player to
02:17 - the right
02:18 - so for example for mario if he is moving
02:20 - to the right
02:21 - we also want to play a walking animation
02:24 - which further adds to the illusion that
02:25 - mario is walking instead of just being
02:27 - repositioned on the screen
02:29 - but we could also move around enemies or
02:31 - we could give the player power ups
02:33 - or we could add some coins or timers or
02:35 - really anything that would constitute
02:37 - parts of a game
02:38 - and if you understand that logic you can
02:40 - make a game in basically anything
02:43 - as long as you can get these free
02:44 - elements and this could even be a game
02:46 - in microsoft excel this would also be
02:48 - possible but in our case we will use
02:51 - pygame so let's have a look at that but
02:54 - pygame is an external module so you do
02:57 - have to install it from an external
02:58 - source
02:59 - but that is quite easy if you use pip
03:01 - either under powershell or on a terminal
03:04 - in both cases all you have to do is type
03:06 - pip install pygame and you should be
03:08 - good to go
03:09 - although there's one minor complication
03:12 - that if you have pygame 3.9 so the
03:14 - latest version that came out a couple of
03:16 - weeks ago
03:17 - the main version of pygame right now
03:19 - does not work because it wasn't updated
03:21 - yet
03:22 - but that isn't really a problem because
03:24 - there's a newer version of pygame that
03:25 - isn't fully released yet
03:27 - but for our purposes it is perfectly
03:29 - sufficient
03:31 - so if you have the very latest version
03:32 - of pygame all you have to do is type pip
03:34 - install pygame equals equals 2.0.0.dev22
03:40 - and then you should be good to go
03:41 - there's no other change you have to make
03:44 - and with that let's start writing some
03:46 - code here we are
03:47 - in an empty sheet of code but for now
03:50 - the very first thing we have to do
03:51 - is to import pygame which should make
03:54 - sense that if you want to use pygame you
03:55 - have to import it
03:57 - and in here if i execute the code if you
04:00 - are getting
04:00 - this message then the input worked well
04:03 - and along with that we get a hello from
04:05 - the pygame community message
04:07 - along with the link to the website but
04:09 - nothing that's really relevant here
04:10 - so let me close all of that so now we
04:13 - have imported pygame and we can use it
04:15 - but by itself nothing happened yet and
04:18 - to make something happen we have to add
04:20 - a couple more things
04:21 - the very first spring is pygame dot init
04:26 - and this line is quite simple but really
04:28 - important it effectively starts the
04:30 - entirety of pygame
04:31 - so pygm consists of several modules
04:34 - let's say one module for the sound
04:36 - another module for the graphics
04:37 - and all of these have to be started and
04:40 - much later in this tutorial
04:42 - we are going to work a little bit more
04:44 - with pygame.net
04:45 - but for now this is the one line we need
04:47 - to start pygame
04:49 - but if we run the code now we still
04:51 - can't see anything
04:52 - except the welcome message and to
04:55 - actually see something
04:56 - we have to create what's called a
04:57 - display surface and the display surface
05:00 - is basically what the player sees in the
05:02 - end so you might call this the main game
05:05 - window
05:06 - and this also has to be stored in a
05:07 - variable
05:09 - and this is usually called screen
05:12 - and how we create a display service is
05:14 - with pygame dot display
05:17 - dot set mode a slightly weird name but
05:20 - well it is what it is
05:22 - and in here we have the tuple with our
05:24 - width and the height
05:25 - of the window we want to get and let's
05:28 - say in my case
05:30 - i want to go with 400 times
05:33 - 500 so our window is going to be 400
05:36 - pixels wide and 500 pixels high
05:39 - and if i run this code you are going to
05:41 - see something really briefly
05:43 - so let me run it and there we could see
05:46 - a window for a very short period of time
05:49 - and this is by design so right now
05:52 - pygame knows that it's supposed to
05:53 - display a window
05:55 - but it doesn't know for how long to
05:56 - maintain this window
05:58 - and because of that it creates the
06:00 - window and then closes it immediately
06:01 - afterwards
06:03 - and to keep it open we have to create
06:05 - our main game loop
06:07 - and this is just a plain while loop and
06:10 - this while loop we are going to close
06:12 - from the inside
06:13 - so this can just be set to wild true so
06:16 - this while loop by itself unless we stop
06:19 - it from the inside
06:20 - is never going to stop and now in this
06:23 - while loop
06:23 - we need to have one line that is called
06:25 - pygame dot display
06:27 - dot update and what this basically does
06:31 - and let me add a bit of white space is
06:34 - that let's say
06:35 - in this while loop we're going to draw
06:37 - all our elements
06:40 - so for example for snake we're going to
06:41 - draw our background we're going to draw
06:43 - the snake
06:44 - we're going to draw a couple of fruits
06:46 - all of this is going to be drawn
06:47 - in here and then what pygame.display
06:50 - does
06:50 - is that it takes all of this information
06:52 - and displays it on the main display
06:54 - surface
06:55 - so that the player can see it so this is
06:58 - the very minimum you need to display
06:59 - anything
07:00 - and if i run the code now this would be
07:03 - working
07:04 - but i would not recommend to run it
07:06 - right now
07:07 - for the simple reason that we wouldn't
07:09 - be able to close it because we didn't
07:11 - implement this functionality just yet
07:14 - and to implement that we need what is
07:15 - called an event
07:17 - loop and an event loop is well it's a
07:20 - loop that looks for different events
07:22 - and each event could be something
07:23 - different but most of the time an event
07:26 - is some kind of user input so this could
07:29 - for example be you pressing a button
07:31 - like
07:31 - left or right up or down on your
07:32 - keyboard it could also be a mouse
07:34 - movement or us
07:35 - closing the window by pressing the
07:37 - little x on the top right
07:39 - it could also be something else like a
07:40 - timer for example
07:42 - we are actually going to see this later
07:44 - on but let's go for this step by step
07:46 - and the very first thing i want to check
07:48 - is if we are going to press the little x
07:50 - at the top of the window
07:51 - so i have to create a very basic event
07:53 - loop
07:54 - and this is just a for loop so i want to
07:57 - check for
07:58 - event in pygame.event.get
08:03 - so at the start of every loop of our
08:05 - game
08:06 - we are going to check for every possible
08:08 - event and then we can do something with
08:10 - these events
08:12 - and what we have to look for is event
08:14 - dot
08:15 - type and this is going to tell us what
08:17 - kind of event we have
08:20 - and this has to be an if statement so if
08:23 - a certain event type is equal to
08:25 - something we want to do something else
08:27 - and the thing we want to look for right
08:28 - now is pygame.quit
08:31 - and this event type is closing the
08:33 - window by pressing the x button
08:35 - and if that is the case i want pygame
08:38 - dot quit and this for all practical
08:41 - purposes is the opposite of pygame.init
08:45 - but by itself sometimes this can cause
08:47 - some complications
08:49 - that some other parts of the program
08:51 - might still be running so
08:52 - this usually is not enough we want
08:55 - another line of code
08:56 - and what we want is cis dot
08:59 - exit and this is another python module
09:03 - so we have to import it so at the top of
09:05 - our code
09:06 - i import pygame and cis
09:09 - and this is a fairly straightforward
09:12 - module
09:12 - it gives you access to lots of system
09:14 - functionality
09:16 - and what sys.exit does is it basically
09:18 - ends any kind of code
09:20 - that it's being run on so in our case if
09:22 - we run sister exit we make sure our code
09:25 - is definitely closed
09:27 - so with these two lines we make very
09:29 - much sure that our game is going to be
09:31 - closed
09:32 - with that being covered let's try to run
09:34 - our code now and let's see what happens
09:36 - and there we go we have a window that is
09:38 - 400 pixels wide
09:40 - and 500 pixels high and right now it's
09:42 - all black for the simple reason that we
09:44 - haven't drawn anything yet
09:46 - but that we're going to cover in just a
09:47 - second but for now
09:49 - we are able to create a basic pie game
09:51 - window so that's a good start
09:53 - but there's one more thing that's
09:54 - important for the basic setup
09:56 - and let me explain what this is right
09:58 - now our game loop so our wild true loop
10:01 - is going to run as fast as our computer
10:03 - allows it to run
10:04 - so for a really slow computer it might
10:06 - run 10 times per second
10:08 - but for a really fast computer it might
10:10 - run 10 000 times per second
10:12 - and this could be a problem because on
10:14 - different computers the game's speed
10:16 - might be completely different because of
10:18 - this difference
10:19 - so we have to make sure that our game
10:21 - runs at least somewhat consistently
10:23 - and even on the same computer it might
10:25 - run differently depending on how busy
10:26 - our scene is going to be
10:28 - so we want to make sure that our game
10:30 - doesn't run faster than a certain
10:32 - maximum frame rate
10:33 - and for that we have to create a clock
10:36 - object and all the clock object does
10:38 - is that it limits how fast our wire loop
10:41 - is going to run
10:43 - and it's ultimately quite a simple thing
10:44 - to achieve so let's go right back into
10:46 - our code and let's implement this
10:48 - so below our screen variable i am going
10:52 - to create a new variable that i call
10:54 - clock and this is going to create a
10:56 - clock object by typing pygame dot time
10:59 - dot spelling it properly
11:03 - and here do make sure the first letter
11:05 - is capitalized that is important
11:07 - but besides that this is all we have to
11:09 - do so this is a clock object that can
11:12 - help us influence time and pie game
11:15 - but all i want to do is right at the end
11:17 - of our game loop
11:19 - i want clock dot tick and in here
11:23 - we effectively have to pass in the frame
11:25 - rate
11:26 - so how many times this while loop can
11:28 - run per second
11:29 - and in my case i am going to go with 60
11:33 - which is usually a good middle ground
11:35 - for games but you could make this a much
11:37 - larger number if you really wanted to
11:40 - and with this our game is never going to
11:42 - run faster than 60 frames per second
11:44 - or in other words this while loop is
11:46 - never going to execute more than 60
11:48 - times per second
11:50 - which makes our game quite a bit more
11:52 - consistent now there's still the other
11:54 - possibility that our game might run too
11:56 - slow and this is something we don't have
11:58 - a simple solution for
11:59 - this is basically game design that you
12:01 - have to make sure that your game never
12:02 - runs too slow
12:04 - and you are doing that by not having too
12:05 - many elements on the screen for example
12:08 - but in our case since our game is so
12:10 - incredibly simple
12:11 - this is not going to be an issue but
12:14 - alright
12:14 - with that covered we have a very basic
12:17 - window that runs at a maximum of 60
12:19 - frames per second
12:20 - so this is a pretty good start and now
12:23 - let's talk about how to add basic
12:25 - visuals to this
12:27 - to really understand pygame you have to
12:30 - understand
12:30 - two basic elements they are called
12:32 - surfaces
12:33 - and rectangles and let's start with
12:36 - surfaces
12:37 - and here's something slightly confusing
12:39 - earlier in this tutorial
12:41 - we created a display surface and this
12:44 - is different to a regular surface
12:47 - although not that
12:48 - much and let me explain it like this our
12:50 - display surface is the big
12:52 - canvas that our entire game is going to
12:54 - run on and there can
12:55 - only be a single display surface and the
12:58 - display surface is also displayed by
13:00 - default
13:01 - for the simple reason that if we didn't
13:03 - have it we wouldn't have a game
13:05 - now a regular surface does the same
13:07 - thing it is still a layer that we can
13:09 - put stuff on
13:10 - but we can have as many surfaces as we
13:13 - like
13:14 - and each surface is only displayed if we
13:16 - write code for that
13:17 - so you could have quite a few different
13:19 - surfaces if you didn't write code to
13:21 - display them
13:21 - they would be invisible so if you want
13:24 - to use a surface
13:25 - you need to follow two steps you first
13:27 - have to create a surface and then you
13:29 - have to put the surface on the screen
13:32 - and creating a surface can be done in
13:34 - three basic ways
13:35 - if you import an image you are going to
13:37 - create a new surface with the image on
13:39 - it
13:40 - the same is going to happen with text so
13:42 - if you create any kind of text the text
13:44 - is always going to be on a new surface
13:47 - and number three is that you could just
13:49 - create an empty surface that doesn't
13:50 - have anything on it
13:51 - so it would just be black by default
13:53 - although you could also fill it with any
13:55 - color you want
13:56 - and for the second step you have to take
13:58 - the surface and put it on the target
14:00 - surface where you want it to be
14:02 - in our case this is always going to be
14:04 - our display surface
14:06 - although you could also put one surface
14:08 - on any other surface as well
14:10 - but that's quite a bit of talk let's
14:11 - actually play around with this
14:13 - so here i'm back in my code and for now
14:16 - i just want to create
14:17 - a basic test surface and this is going
14:20 - to be
14:20 - just an empty surface and how to create
14:23 - this
14:24 - is pygame dot surface and this
14:28 - kind of like set mode is going to need
14:31 - a tuple with a width and a height
14:35 - and let's make this let's say 100 pixels
14:39 - by 200 pixels and that is
14:42 - all we needed so now we have another
14:43 - surface but if we run the code now
14:46 - we wouldn't be able to see it because we
14:48 - didn't put it on the display surface
14:51 - and this we have to do in our while loop
14:53 - and what i want to do
14:55 - is to put our test surface on our screen
14:58 - display surface
15:00 - and for that we first have to type
15:02 - screen to get our display surface
15:04 - and then blit which stands for block
15:06 - image transfer
15:08 - and then here we need the surface and a
15:11 - tuple with the x
15:12 - and the y position so our surface is
15:15 - going to be our test surface
15:17 - and for x let's go with 200 and for y
15:20 - let's go with 250. so hypothetically
15:24 - we should see something right now so
15:26 - let's try it
15:28 - and our code is running but we still
15:30 - can't see it
15:31 - oh well technically we can but it
15:34 - doesn't help us too much for the simple
15:35 - reason
15:36 - that both our screen and our test
15:39 - surface are both black
15:41 - so technically while they are both
15:43 - visible we can't see them because they
15:45 - have the exact same color
15:47 - so we have to figure out how to add
15:48 - color to each of them
15:50 - and the easiest way to give them color
15:52 - is to use the fill command
15:55 - and let's do this actually on the screen
15:57 - itself
15:58 - so let me add another line of code
16:01 - and i want to fill the screen with a
16:03 - greenish color
16:06 - and for that we need screen dot fill
16:10 - and in here we need some kind of color
16:12 - argument
16:13 - and there are two ways of achieving this
16:15 - in pi game number one
16:17 - is an rgb tuple and number two is a
16:19 - color object
16:21 - the color object is easier to explain
16:23 - you just type pygame.color
16:25 - and insert the string of a name of a
16:27 - color and then pygame picks a specific
16:29 - color that was predefined
16:31 - so for example i could type in here
16:33 - pygame.color
16:35 - and let's go with gold and now if i run
16:38 - this we should see a golden background
16:40 - color
16:40 - and there we go and now we can also see
16:42 - our test surface
16:44 - and here think about the starting
16:46 - position this one is going to become
16:47 - a bit more important in a second but for
16:50 - now we have a basic color
16:52 - but in my case i don't want a predefined
16:55 - color
16:56 - instead i want to define my own color to
16:58 - keep the entire thing consistent in tone
17:01 - and to create a custom color we need
17:03 - what is called an rgb tuple
17:05 - so let me explain what that is rgb
17:08 - stands for red
17:09 - green and blue it's literally that
17:11 - simple and what we basically do
17:13 - is we determine the amount of color for
17:15 - each of these values
17:17 - so for example we could have a hundred
17:18 - percent red zero percent green and zero
17:21 - percent blue
17:22 - and if we then put these colors together
17:24 - we have a red color
17:26 - and that's really all it is the only
17:28 - thing you really have to remember
17:29 - is that the lowest value you can give
17:31 - for each color is zero and the highest
17:33 - 255
17:34 - with 255 being 100 of this color
17:38 - so in my case i'm going to go with an
17:40 - rgb tuple of 175
17:42 - 215 and 70. so our color is going to
17:46 - have
17:46 - quite a bit of green a bit less red and
17:49 - very little blue
17:50 - and this combined is going to give us a
17:52 - greenish color so let's actually
17:54 - implement this
17:55 - so here i'm back in my code and let me
17:57 - get rid of the color object
17:59 - and i want to create an rgb tuple so i
18:01 - create
18:02 - another list and then here i type 175
18:06 - 215 and 70.
18:10 - and now let's try this and there we go
18:14 - now we have a greenish background and if
18:17 - you want to challenge yourself and code
18:18 - along
18:19 - here is going to be a short exercise try
18:22 - to get
18:23 - this test surface and fill it with a
18:26 - blue color
18:28 - and if you want to do it pause the video
18:29 - now and try to do it yourself
18:35 - so this could be done before the while
18:38 - loop
18:38 - and i just want to get test surface dot
18:41 - fill
18:43 - and in here to get a blue color we could
18:45 - either go pygame dot
18:46 - color and in here type blue
18:50 - and if we run the code now our test
18:53 - surface is going to be blue
18:55 - alternatively i could just add an
18:58 - rgb tuple that has 0 red 0
19:01 - green and 255 of blue and if i run this
19:05 - code
19:06 - we have the exact same outcome and with
19:10 - that we have already covered the very
19:12 - basic colors
19:13 - but here's one thing i really want you
19:15 - guys to pay attention to
19:17 - that our test surface we have placed on
19:20 - position 200
19:21 - and 250 and this point is
19:24 - exactly half way of our display so the
19:26 - point we placed it on
19:28 - is right in the middle of the screen but
19:30 - our test surface
19:32 - is very much not in the middle of the
19:33 - screen
19:35 - so what's the problem here and it's not
19:37 - really a problem it's just how pie game
19:39 - works
19:39 - when we specify this point we specify
19:42 - the top
19:42 - left of this surface so of our rectangle
19:46 - the top left point is going to be at
19:48 - position 200
19:49 - and 250 and we are going to get more
19:52 - control over this
19:53 - in just a bit but before that i do want
19:56 - to cover an animation just to cover it
19:57 - on a basic level
19:59 - right now it looks like our surface is
20:01 - being static and well it kind of is
20:03 - but the main principle here is that this
20:06 - image is being redrawn every time this
20:08 - while loop is running
20:09 - and the reason it is static is because
20:11 - the position we put it on is always the
20:13 - same
20:13 - but we could totally change it so let me
20:16 - close it
20:17 - and let's say i want to move the x
20:19 - position so this one
20:21 - and for that i can just add a variable
20:23 - in here
20:24 - and create the variable early on so
20:26 - let's call this x-pos
20:28 - and by default it is 200 so exactly what
20:31 - we had so far
20:32 - so let me run it and we get the exact
20:34 - same result
20:35 - but what we can do now is just to add
20:38 - x plus plus equal one
20:42 - and now let's run the code again and see
20:44 - what happens and there you can see
20:47 - our surface is going to move slightly to
20:49 - the right
20:50 - and this looks like an animation but
20:52 - basically what happens
20:53 - is that every time this wallop is
20:56 - running
20:57 - it is going to put the surface on this x
20:59 - position but this exposition gets
21:01 - slightly larger every time we call it
21:04 - and because this happens at such small
21:06 - increments and so often
21:07 - that to us it looks like a fluid
21:09 - movement so we consider this an
21:11 - animation
21:12 - and we could also do it the other way so
21:14 - with
21:15 - and now let's try it again now our
21:17 - surface is moving the other way so it's
21:18 - going to the left
21:22 - and with that we have really basic
21:24 - animations
21:25 - but there's one thing that is important
21:27 - to keep track of
21:28 - and let me change this back to 200
21:32 - and now i want to move the y position
21:34 - and let me just
21:36 - put an x position in here not great
21:38 - naming but it really doesn't matter
21:40 - and now i want you guys to make a guess
21:42 - is this surface going to move upwards
21:44 - or downwards and what we basically do
21:47 - is make the x position smaller so this
21:49 - one starts at 200 then becomes 199 then
21:52 - 198
21:53 - and so on and let's actually run this
21:55 - and see what happens
21:57 - and here you can see even though our x
22:00 - is getting smaller
22:01 - our surface is moving upwards which
22:04 - can be quite confusing but let me
22:06 - explain what this means
22:07 - the origin of our display surface is in
22:09 - the top left
22:10 - so if you want to go to the right you
22:12 - have to increase x and if you want to go
22:14 - to the left you have to decrease
22:15 - x this part should feel quite natural
22:18 - however if you want to go downwards you
22:20 - have to increase y
22:21 - and if you want to go up you have to
22:22 - decrease y
22:24 - which is the part that can get quite
22:26 - confusing
22:27 - although this is also the part that is
22:29 - really common in video game development
22:32 - and this is going to take you some time
22:33 - to get used to but ultimately it's not
22:35 - that bad
22:37 - and let me close this and let's do the
22:39 - opposite so i want to increase y
22:41 - and and now our test surface is moving
22:44 - downwards
22:46 - [Music]
22:48 - so this is one thing that can get quite
22:50 - confusing
22:52 - but all right let me get rid of these
22:55 - variables because we don't want to go
22:57 - for animations anymore
22:58 - so i just want to place this thing back
23:00 - at position 200 and 250.
23:03 - and let me write again and this is still
23:05 - working and now here's one thing that i
23:07 - talked a tiny bit about earlier
23:09 - that we don't really have all that much
23:11 - control about how to place this surface
23:14 - so for example if we wanted to place the
23:16 - center of the surface we couldn't really
23:19 - do it
23:19 - or let's say if we wanted to place the
23:21 - bottom right we just couldn't really do
23:23 - it
23:24 - and to fix that pie game has another
23:26 - concept that is called a rectangle or
23:28 - wrecked in short
23:29 - and let's talk about those and
23:31 - incidentally they are also the second
23:32 - part on how to draw something in pie
23:34 - game
23:35 - and well a rack is just a rectangle
23:39 - that you can either put around something
23:40 - else or use for drawing
23:43 - and this rectangle has lots of different
23:45 - points that we can
23:46 - influence and you can see all of them on
23:48 - the screen right now
23:50 - and these points are super useful not
23:52 - just for moving something
23:53 - but also to measure if two objects are
23:55 - overlapping for example
23:57 - or if something is moved outside of the
23:58 - screen or you could also measure how
24:00 - large an object is
24:02 - and there are two ways to create a
24:04 - rectangle you could either create one by
24:06 - itself
24:07 - or you could take an existing surface
24:09 - and create a rectangle around it
24:11 - and then once you have a rectangle you
24:13 - can do quite a few different things with
24:15 - them
24:16 - but let's actually play around with this
24:17 - in code
24:19 - so here we are back in our code and the
24:21 - very first thing i want to do
24:22 - is to create a new rectangle let's call
24:25 - this test
24:27 - rectangle and this is just going to be
24:30 - pygame dot rect
24:32 - and in here we have to pass in four
24:35 - different pieces of information
24:36 - we need an x position a y position a
24:39 - width
24:40 - and a height and let's put this thing at
24:43 - position 100 let's say 200
24:46 - and let's give it a width and a height
24:48 - of let's say 100 each
24:52 - and here again this x and y is still
24:55 - going to be the top
24:56 - left but we are going to get more
24:58 - flexible in this in just a second
25:00 - so now we have a rectangle but if we run
25:03 - the code we
25:04 - are not going to be able to see it so
25:05 - this isn't going to do all that much
25:07 - but what i could be doing now is use
25:12 - pygame.draw.rect
25:14 - draw this rectangle and in here
25:17 - i have to pass in three pieces of
25:19 - information i need the surface to draw
25:21 - on
25:21 - i need a color and i need a rectangle
25:25 - so our rectangle is going to be our test
25:27 - rect
25:28 - our surface is going to be our screen
25:31 - and for the color
25:33 - let's go with pygame dot color
25:36 - and i want to go with we haven't used
25:38 - red yet let's go with that
25:40 - and now let's try this and there we go
25:43 - we have another rectangle and this one
25:46 - is not a new surface
25:47 - it's a different kind of object and
25:50 - later on when we create our snake
25:52 - we are going to be drawing lots of
25:53 - different rectangles that we are going
25:55 - to each put on the screen
25:57 - and you might be asking yourself what's
25:58 - the really big difference between
26:00 - creating a new surface and putting that
26:01 - on screen or creating a rectangle and
26:04 - drawing that
26:05 - and well it depends on what kind of job
26:07 - you want to do usually
26:09 - drawing a rectangle is a much simpler
26:11 - task so it takes less code and less
26:12 - processing power
26:14 - and most of the time for surface you
26:16 - don't just fill the surface you add
26:18 - something else
26:18 - to it so that just filling a surface and
26:21 - putting on the screen doesn't really
26:23 - happen if you want to do that you would
26:25 - just use a rectangle
26:26 - and there are quite a few different
26:27 - things we could draw this could also for
26:29 - example be an
26:30 - ellipse and now if we run this we get a
26:33 - circle
26:34 - and there are quite a few different
26:35 - shapes you could be drawing but i don't
26:37 - want to draw anything just yet
26:39 - and i also don't want to create a
26:40 - surface like that just yet
26:43 - instead what i want to do is to get this
26:46 - test surface
26:47 - and use that to create a rectangle and
26:50 - for that we need
26:51 - test surface dot get wrecked
26:55 - and what this one is doing is it gets
26:57 - this surface
26:59 - and it puts a rectangle around it but
27:02 - the really useful thing now is that in
27:04 - the parenthesis
27:05 - we can specify on what point we want to
27:08 - place it on
27:09 - so for example i could type center
27:12 - and now in here add an x and a y
27:14 - position
27:15 - so for example now if i add in here 200
27:19 - and 250 this rectangle would be placed
27:22 - right in the center of the screen and
27:25 - then
27:25 - when i use blit or original test surface
27:28 - i could use this rectangle to actually
27:30 - place the surface
27:32 - so let me remove those two points and
27:34 - insert test
27:36 - wrecked and now if we run this
27:40 - we get our surface right in the middle
27:42 - of the screen
27:43 - and there is quite a few different
27:45 - things going on right now so let me go
27:46 - through them one by one in terms of what
27:48 - i have just done
27:50 - i have first created a new surface
27:52 - called test surface
27:53 - and this surface is 100 pixels wide and
27:55 - 200 pixels high
27:57 - then i have drawn a rectangle around the
27:58 - surface and i have placed this rectangle
28:01 - right in the middle of our screen and
28:03 - then i have used this rectangle to
28:05 - actually
28:05 - place the test surface on the screen and
28:08 - we could also use another point
28:09 - for example i could use top
28:13 - right and then we'd be placing the top
28:15 - right
28:16 - so now the top right corner is in the
28:18 - center of the screen and this way you
28:20 - get a ton of control over how you place
28:21 - elements on the screen
28:23 - and let's actually try to move this
28:24 - rectangle to move our surface
28:27 - so i want to get our test rectangle
28:30 - and i want to move the right position
28:33 - and just add plus equals let's say one
28:36 - and let's try this now and now again we
28:38 - can see our surface moving to the right
28:41 - and the important point here is that if
28:44 - we move any point on the rectangle we
28:45 - are going to move
28:46 - all the points on the rectangle so we
28:48 - could for example also move the left of
28:50 - the rectangle
28:52 - and we'll have the exact same result so
28:54 - this one doesn't really matter
28:56 - and all right with that we have covered
28:58 - the absolute basics of pygame
29:00 - that was quite a bit of material so if
29:03 - you feel overwhelmed
29:04 - don't worry too much because i will go
29:06 - very slowly through all of this
29:08 - while i actually create the game so let
29:10 - me get rid
29:11 - of all of this material besides this
29:13 - green dot fill color
29:16 - so now we are back to a very basic setup
29:18 - that's just a green background color and
29:20 - doesn't do anything else
29:21 - and on that we are going to create our
29:24 - snake game
29:25 - but before we come to the actual code
29:26 - for the game let's first talk about the
29:28 - logic
29:29 - on what we are going to do and there are
29:31 - two main concepts you have to understand
29:33 - for the snake game to work number one is
29:36 - that we are effectively creating a grid
29:38 - on our display but we are not really
29:41 - creating a grid
29:42 - we are just simulating it and instead
29:44 - what we are going to do
29:45 - is that every time we are moving we can
29:48 - only move in certain increments
29:50 - so let's say every time you move you
29:51 - have to move by the amount of 40 pixels
29:54 - and since you can only move by that
29:55 - amount you are effectively moving in a
29:58 - grid
29:58 - although it's not really a grid it just
30:00 - looks like one and into this grid we are
30:03 - going to put our snake and that's going
30:04 - to be the second major concept
30:07 - and effectively our snack is going to be
30:08 - a list with different positions
30:10 - and each of these positions is a block
30:13 - and all we are going to do to move the
30:14 - snake is to update each of the block in
30:16 - a certain direction
30:18 - and then we are drawing the block and
30:19 - that gives us a snake
30:21 - ultimately it's actually a really simple
30:23 - logic but i think there was a ton of
30:25 - material covered let's actually start
30:26 - talking about the snake
30:28 - now that we have covered the basic logic
30:29 - of pygame and also logic to make the
30:31 - snake game work
30:32 - we can actually start making our game
30:35 - and i'm going to start setting up our
30:37 - board
30:37 - and placing one piece of fruit in there
30:39 - and the reason for that is that the
30:41 - fruit works in almost the same way that
30:42 - the snake does
30:44 - so the fruit is a really nice way to
30:45 - start with the board and see how we can
30:47 - place elements in there
30:49 - here we are in the code that we have set
30:50 - up earlier and the first thing i want to
30:52 - do
30:53 - is to change the size of our window so
30:55 - these two coordinates
30:57 - because right now they are fixed but i
30:59 - want them to be a bit more flexible
31:02 - and essentially what i want to achieve
31:04 - is that we have one variable with the
31:06 - number of cells
31:07 - and another variable with the size of
31:08 - each cell and then those two numbers
31:10 - combined create the size of our screen
31:13 - so if we always fill the entire screen
31:14 - regardless of how big the cells are or
31:16 - how many cells we have
31:18 - and for that i'm going to create two new
31:20 - variables
31:21 - the first one is going to be cell size
31:24 - and i've set this to 40 and then we need
31:27 - a cell
31:29 - number and this one i've set to 20
31:32 - and at least for now you could change
31:33 - these numbers to whatever you want it
31:35 - doesn't really matter until we add
31:37 - graphics to the entire game
31:39 - but now for the dimension of the screen
31:41 - i want the cell number
31:43 - multiplied by the cell size
31:46 - both for the x and for the y
31:50 - so now when i run the screen we are
31:53 - getting a screen that is 800 by 800
31:55 - pixels wide
31:56 - or 40 times 20. so this seems to work
31:59 - quite well
32:00 - and that's really all we need to set up
32:02 - the basics of our game
32:04 - so with that covered we can start
32:06 - creating our fruit
32:08 - and this is going to be a class or well
32:10 - it's going to be an object but we have
32:12 - to create a class for that
32:14 - it doesn't need to inherit anything and
32:16 - when i initiate it
32:19 - i own itself and now i want to achieve a
32:23 - couple of things with this class
32:26 - so let me just write it in the comments
32:29 - number one
32:30 - is that i want to create an x
32:33 - and y position so we can actually place
32:36 - it somewhere on the grid
32:38 - and besides that i also want to draw
32:41 - a square so whatever this position is i
32:43 - want to draw a square which is going to
32:45 - be the fruit
32:46 - and later on we are going to add
32:48 - graphics to this but for now this isn't
32:50 - going to matter
32:51 - so i want to create self.x and let's say
32:53 - for now this is going to be
32:55 - 5 and then i want self dot y
32:59 - and let's go with 4. so right now these
33:02 - are fixed numbers i am going to change
33:03 - them just a bit
33:05 - and having these two numbers along with
33:08 - a cell
33:08 - size would actually be enough to already
33:11 - draw a rectangle
33:12 - however i'm going to put one step in
33:14 - between but i'm going to store these two
33:17 - values
33:17 - inside of a vector 2d and let me explain
33:20 - why
33:21 - throughout this entire tutorial we are
33:24 - going to work very extensively with
33:25 - two-dimensional data
33:27 - so we want to have a really efficient
33:28 - way to work and store two-dimensional
33:30 - data
33:31 - so that we can change an x in the
33:32 - y-coordinate really easily
33:35 - and vectors are perfect for that and to
33:38 - explain
33:38 - why let me illustrate a difference
33:40 - compared to a list with two values
33:42 - you can see a vector that has an x
33:44 - coordinate of 5 and a y
33:45 - coordinate of 4 and at a normal python
33:48 - list with 5 and 4.
33:49 - and right now both of these express the
33:51 - exact same information
33:53 - and the first advantage of vectors is
33:55 - that accessing the x into y is a bit
33:57 - clearer compared to a list
33:59 - so if you want to access the x or the y
34:01 - for a vector
34:02 - we can just take the vector place x
34:04 - afterwards and then we get the x
34:06 - and the same for y and for a list we
34:08 - would have to use indexing and just add
34:10 - square brackets into 0
34:12 - or 1. and while this is quite a minor
34:14 - advantage it does make our code
34:16 - considerably more readable if we have
34:18 - more code
34:18 - so this is a nice thing to have but the
34:21 - really
34:22 - important thing that really helps us
34:24 - with vectors is vector math
34:26 - and here's what this means let's say we
34:28 - have our list and we want to move this
34:29 - cell to the right
34:31 - and moving something to the right just
34:33 - means increasing the x by the amount of
34:34 - one so in the list we would use indexing
34:38 - to get the x value and then just add one
34:40 - to it
34:41 - and this would be a fairly
34:42 - straightforward operation and don't get
34:44 - me wrong we could use
34:45 - lists for the entire game it would be
34:47 - doable but also kind of annoying to work
34:49 - in
34:50 - because in vectors doing this kind of
34:51 - thing is much easier
34:53 - because when we have a vector we can
34:54 - just create another vector that has a
34:56 - value of 1
34:57 - and 0. so this would be a movement to
34:59 - the right and then we can just add this
35:01 - vector to the original vector
35:03 - and if you add two vectors together you
35:05 - get the sum of both of the x values and
35:07 - both the y values
35:09 - so if you wanted to move the vector to
35:10 - the right we could just add a plus
35:13 - right vector and then we have moved it
35:14 - we would not need to identify any
35:16 - specifics of the vector we could just go
35:18 - straight ahead
35:19 - and especially for the snake later on
35:22 - this is going to be
35:22 - so much better to work with but alright
35:26 - i hope that makes sense and now let's
35:28 - actually implement it
35:29 - so here we are back in our code and i
35:31 - want to add these two values inside of a
35:33 - vector
35:34 - so i create a new attribute with self
35:36 - dot let's call it position
35:38 - and to create a vector 2d in pi game we
35:40 - need
35:41 - pygame dot math dot
35:45 - and in here we have to create an x and a
35:48 - y value
35:49 - which we already have we just created
35:51 - them
35:52 - and this is terrible spelling self and
35:55 - self so we just place these two values
35:59 - inside of this vector and then we have a
36:02 - two-dimensional vector
36:04 - and there's one more change i do want to
36:06 - make that i don't want to type
36:08 - pygame.math every single time i just
36:10 - want to type vector2
36:12 - so in the import i'm going to type from
36:16 - pygame.math import
36:20 - vector2 and that way i can just type
36:24 - vector2 which is going to save me so
36:26 - much writing
36:28 - and with that we have a really efficient
36:30 - way to store two-dimensional data that
36:32 - we later can use to draw a square
36:34 - so that's quite nice and with that
36:37 - covered
36:38 - i want to create a new method that i
36:40 - call draw fruit
36:42 - so this one is well it draws the fruit
36:45 - and let me get rid of these two comments
36:48 - all right so what i want to do in here
36:50 - is first create
36:53 - a rectangle
36:56 - in the right position and then i want to
36:59 - draw the
36:59 - rectangle so let's work through them
37:03 - the first one is to create a rectangle
37:06 - and let's call this one fruit rect
37:11 - and this one is just going to be a pie
37:13 - game
37:14 - wrecked object and this one is going to
37:16 - need an x-coordinate
37:18 - a y-coordinate then we need a width and
37:21 - a height
37:22 - so we need four different pieces of
37:24 - information and two of them are super
37:26 - easy to get because width
37:28 - and height are just going to be our cell
37:30 - size so i can literally just copy
37:32 - cell size and paste it in there
37:36 - and then we are already halfway there
37:38 - and then we have to figure out the x
37:40 - and the y and well this is going to be
37:43 - for now this position
37:45 - so what i want to get is self dot pause
37:47 - this would be
37:48 - the entire vector but i only want to get
37:51 - the x position so in this case this
37:54 - would be 5
37:55 - and then i want to do the same thing for
37:57 - our y position
37:58 - so self.y which will get us this value
38:02 - which is 4. and that is literally all we
38:05 - need to create a basic rectangle
38:07 - and now we can get to drawing it and
38:09 - really all we have to do
38:11 - is type pygame.draw.rect which draws a
38:14 - rectangle
38:15 - and in here we need three different
38:17 - pieces of information
38:18 - we need a surface to drawn a color and
38:21 - then
38:22 - a rectangle that we want to draw and we
38:24 - already have most of this information
38:27 - so our rectangle is just going to be the
38:29 - fruit rectangle we just created
38:32 - and the surface we want to draw on is
38:34 - this green surface so our main display
38:36 - surface
38:37 - so that is already getting us quite far
38:40 - ahead
38:40 - now we need to work on the color and
38:42 - this is going to be an rgb tuple and for
38:46 - that the amount of red
38:47 - is going to be 126 the amount of green
38:50 - is 166
38:51 - and the amount of blue is 114
38:54 - and for now this is just going to be a
38:56 - plain darkish green
38:58 - it doesn't look particularly good but
38:59 - later on we are going to replace it
39:01 - anyway
39:01 - so it doesn't really matter and all
39:04 - right
39:04 - this is actually almost all we need so
39:07 - let's actually create a basic fruit just
39:09 - to see how this would look like on our
39:11 - game
39:12 - so i'm going to create a new object with
39:15 - the fruit class and then in our main
39:19 - game loop
39:20 - after screen.fill i type fruit dot
39:24 - draw our fruit so that we can actually
39:26 - see it on the game
39:28 - and let's run this and see what happens
39:30 - so now we can't see our green rectangle
39:32 - but there are two problems number one is
39:35 - that the rectangle is way too far in the
39:37 - top left
39:38 - so something went wrong when we placed
39:40 - it and number two if you look at the
39:42 - bottom of the screen
39:43 - is that python is giving us a warning
39:45 - about implicit
39:47 - conversion to integrals using int and
39:49 - both of these
39:51 - we can fix quite easy because they
39:52 - happen in the same line
39:54 - in this line here so let's work for them
39:58 - step by step
39:58 - and the first one is the actual placing
40:00 - of this rectangle
40:02 - so right now for example this
40:04 - self.post.x is five
40:07 - so when pygame places it it literally
40:09 - places it 5
40:10 - pixels from the left but we don't want
40:13 - to place it 5 pixels
40:14 - instead we want to place it 5 times the
40:17 - cell size
40:18 - and same for position.y right now it's
40:20 - placed 4 pixels from the top
40:22 - but instead we want to place it four
40:24 - pixels multiplied by the cell size
40:27 - so literally all we have to do in here
40:29 - is to multiply
40:30 - this by cell size and this is what i
40:33 - explained earlier
40:34 - that we don't really create a grid
40:37 - instead we move each object by one pixel
40:39 - and then multiply it by the cell size
40:42 - and this creates the illusion of a grid
40:44 - and this is really all we need
40:46 - and let's try this so
40:49 - this is looking so much better and just
40:52 - to test
40:53 - let me change both of these to zero so
40:55 - we can tell
40:56 - if they are in the top left and
40:59 - there we go now we have our square in
41:01 - the top left
41:03 - and just to make one more test let's put
41:05 - it to 10
41:06 - so now it should be on the left and
41:08 - roughly in the middle of the screen
41:11 - and there we go this seems to be working
41:13 - now
41:14 - so now we actually have a basic grid
41:16 - that we can use to place
41:17 - elements on and with that we can also
41:21 - work on the second problem
41:22 - that way of an implicit conversion to
41:24 - integers and what this basically means
41:27 - is that pygame.rec wants to have
41:28 - integers for all of its values but
41:30 - getting values from a vector is always
41:32 - going to be a float
41:33 - even if we pass integers into it so
41:36 - right now
41:37 - python converts both of these into
41:38 - integers by itself
41:40 - but this might be removed in a future
41:42 - version of python
41:44 - so to make sure our code is going to
41:45 - work in the future we have to do this
41:48 - manually which is super easy to do all
41:50 - we have to do
41:51 - is to put the end method around it and
41:53 - we're good to go so let me do it for
41:55 - both of them
41:56 - and now if we run it we don't get an
41:59 - error message anymore
42:00 - and all seems to be good cool and really
42:02 - all the integer method does is it takes
42:04 - a value and turns it into an integer
42:06 - that's really all that happens here and
42:08 - before we finish this part there's
42:10 - one more change i do want to make that
42:12 - right now both of these values
42:14 - are fixed but we want them to be random
42:17 - and to do that we have to import another
42:20 - module
42:20 - the random module which can generate
42:23 - random numbers
42:24 - and what we want is random.rand
42:28 - int which generates a random integer
42:30 - from one value to another
42:33 - and we always want to start at zero and
42:35 - we want to go all the way to our cell
42:37 - number
42:38 - so cell number however there's
42:42 - one more thing we do have to do that
42:45 - rent in
42:45 - goes from this number all the way to
42:47 - this number and it also
42:49 - includes this number so this could be a
42:52 - number from 0
42:53 - to 20. and whenever we draw a rectangle
42:56 - this position is going to be the top
42:58 - left so there's a very small chance that
43:00 - the top left might be something like 0
43:02 - and 800 and this would be outside of our
43:05 - window
43:06 - so we have to subtract 1 from this
43:10 - and this ensures that we are always on
43:12 - screen
43:13 - and since we have a square we can just
43:15 - copy the entire thing for our y position
43:17 - and with that done let's try it a couple
43:19 - of times so we have a random square here
43:22 - let me close it and let's try it again
43:24 - we have a different position
43:26 - and one more time we have another
43:28 - different position
43:29 - cool and for now this is all we needed
43:32 - for the fruit
43:33 - so i can close it and we are going to
43:35 - make one more change later on to it but
43:37 - for now it's working as intended
43:39 - and alright now that we have covered the
43:41 - basics of the grid we can actually start
43:43 - creating our snake
43:45 - and the snake is going to work in a
43:47 - really similar way compared to the fruit
43:49 - the only difference being that now we
43:51 - don't just draw one block on the screen
43:52 - we draw multiple but we are still going
43:56 - to use
43:56 - vectors so effectively what we are going
43:59 - to do is we have a list with all the
44:00 - blocks now a snake
44:02 - and we cycle through this list and draw
44:03 - all of these blocks
44:05 - so let's start with that and once we
44:07 - have that we can talk about moving the
44:08 - snake
44:10 - so here we're back in our code and i
44:12 - want to create a new class
44:14 - that i call snake and i'm going to
44:17 - initiate it
44:18 - as always there's nothing special we
44:20 - need here
44:22 - and for now i only want to have a single
44:24 - attribute
44:25 - that is going to be the body of our
44:27 - snake and this is going to store
44:29 - all the vector 2s that create our snake
44:32 - and in here we are going to place all
44:33 - the blocks that constitute our snake
44:36 - and let me actually add some just to
44:38 - visualize this so i want vector 2
44:42 - and let's go with 5 and 10. so this is
44:45 - roughly in the middle
44:47 - then i want to have another vector and
44:50 - one more let's start with three
44:52 - and are going to be six and seven
44:55 - so this is just going to be three blocks
44:58 - right next to each other
45:00 - and this is also what the player is
45:01 - going to see when the game is being
45:03 - started
45:04 - so this would always be the starting
45:05 - position but you could change it as much
45:07 - as you want
45:08 - but all right now i need a method that
45:11 - draws
45:11 - our snake does not need any parameters
45:15 - and all i want to do in here is for
45:18 - block
45:19 - in self.body
45:22 - so i'm going to cycle through all of
45:24 - these vectors
45:26 - and i want to do something with each of
45:28 - them and in here
45:30 - very similar compared to our draw fruit
45:33 - i
45:33 - want to create a
45:36 - rectangle from the position and then
45:40 - draw the rectangle
45:43 - so this is going to be incredibly
45:44 - similar to our draw fruit method
45:46 - actually
45:47 - so let's go through it step by step and
45:49 - this could actually be an exercise if
45:51 - you want to challenge yourself
45:52 - try to cycle through this list and draw
45:54 - all of these vectors
45:56 - and this should look incredibly similar
45:58 - compared to these two lines
46:00 - so pause the video now if you want to go
46:02 - along and try this yourself
46:05 - so the very first thing i want to do is
46:08 - to create a new rectangle
46:10 - i call this one block
46:13 - and what we need again is pie game.rect
46:16 - and here we need an x a y a width
46:20 - and a height and again the width and the
46:23 - height
46:24 - are super easy it's again the cell size
46:26 - so all i want
46:27 - is the cell size for the width and the
46:29 - cell size for the height
46:31 - now for the x i want the block
46:34 - so this block here which right now let's
46:36 - say for the first element would be the
46:37 - vector of
46:38 - 5 and 10. and since we're looking at the
46:40 - x this is going to be
46:42 - x so this is literally the same thing we
46:45 - have done here
46:46 - and from there we have to multiply this
46:48 - by our cell size
46:50 - and then to avoid the warning by python
46:53 - again
46:53 - we have to put all of this into an
46:55 - integer statement
46:57 - and that's basically it so now i can
47:00 - copy the entire thing
47:02 - and place it in for the y and then
47:04 - change
47:05 - block dot y and
47:08 - here what you could be doing to make all
47:10 - of this a bit more readable
47:12 - is to create all of this on a few
47:15 - separate lines
47:16 - so our x position would be all of this
47:19 - and then i can copy it and create our
47:22 - y position
47:26 - and then in here i could just write x
47:29 - position
47:31 - y position so this would have the exact
47:34 - same outcome
47:35 - although i guess this one is quite a bit
47:37 - easier to read
47:38 - but it's ultimately up to you but okay
47:41 - now we have a rectangle
47:42 - we just have to draw it so again i want
47:46 - pygame.draw.rect
47:48 - and in here i still want our screen
47:50 - surface to draw on
47:52 - and now i'm going to need a new color
47:55 - and i went with 133
47:57 - 191 and 122
48:01 - and then for the rectangle we just want
48:03 - our block rectangle
48:05 - and with that we have drawn all of these
48:08 - vectors
48:09 - so now all we have to do is to create an
48:12 - object from this class
48:17 - and then in our game loop just called
48:19 - snake dot
48:20 - draw snake
48:23 - and let's see if this is going to work
48:25 - [Music]
48:26 - and
48:26 - there we go we have our basic snake
48:29 - although i think right now the color is
48:31 - a bit hard to see
48:33 - so let me close it and go all the way
48:35 - back to our snake
48:37 - and let's change the green value to 111
48:40 - this is going to turn the entire thing
48:42 - quite a bit more red and let's try it
48:44 - now
48:44 - and there we go this is quite a bit
48:46 - easier to see but ultimately it doesn't
48:49 - matter all that much because we are
48:50 - going to replace all of this with proper
48:52 - graphics later on
48:53 - but i think for now this is a bit nicer
48:55 - to work with
48:57 - but okay now we have drawn all the basic
49:00 - things we need to make the game
49:01 - workable but our snake doesn't move and
49:04 - let's work on that
49:06 - okay so let's talk about how to move the
49:08 - snake so here's a snake
49:10 - and let's say we want to move this snake
49:11 - one field further to the right
49:13 - to achieve that we take the hat and move
49:16 - it one block further to the right
49:17 - then we take the block before the head
49:19 - and move it to where the head used to be
49:21 - and then we go through the entire snake
49:23 - and do this to every block
49:25 - so that the position of every single
49:26 - block takes the position of the block
49:28 - that came before it
49:30 - and that way every single block follows
49:32 - the head of our snake
49:33 - and this is how we are going to move the
49:35 - snake so we are not actually moving the
49:37 - snake
49:38 - instead we are taking each of the block
49:40 - and putting them in different positions
49:41 - and this simulates the illusion of
49:43 - movement
49:45 - and here's how we are going to simulate
49:46 - this in our code
49:48 - besides our self.bodylist we are going
49:50 - to add a self.direction
49:52 - and this gives us the direction that the
49:53 - snakehead is going to take in the next
49:55 - turn
49:56 - and then in our game at certain
49:58 - intervals we take the first element of
50:00 - our self.body list
50:01 - which is the head and move it by the
50:03 - direction and this way we're moving the
50:05 - head of the snake
50:07 - and then we're going to create a new
50:08 - list that copies our entire self.body
50:11 - except for the last element
50:13 - and to this new list we are going to add
50:15 - our head and that way we have moved
50:17 - every single item inside of the list
50:19 - one step further and we also added a new
50:22 - item at the front for our head
50:23 - so that's quite a bit of logic so let's
50:25 - actually implement it
50:27 - and there are two more things that we
50:28 - really need to make this work
50:30 - number one is that we need some player
50:32 - input so that we can control the snake
50:34 - and number two is that we have to create
50:36 - a basic timer
50:37 - and then we only want to move our snake
50:39 - whenever this timer triggers
50:40 - and in my case this is about every 150
50:43 - milliseconds
50:44 - so quite a few things to cover and let's
50:46 - just start very simple and we only want
50:48 - to move our snake to the right
50:50 - so here we are back in our code and i'm
50:52 - still working in my snake class
50:54 - and what i want to do is to create a new
50:56 - method
50:57 - that i call move snake
51:00 - it doesn't need any parameters and in
51:03 - here we are going to move our snake
51:05 - and the first thing i want to do is to
51:07 - create a copy of our body
51:11 - and this i can just do with self.body
51:13 - and then using slicing
51:15 - so right now this would copy our entire
51:17 - list but we don't want to copy the
51:19 - entire thing
51:20 - we only want to have the first two
51:22 - elements so we are going to go
51:24 - from the first element to the one
51:26 - element before the last
51:28 - so this list right now would only give
51:30 - us these two elements
51:31 - so this element here at the end would
51:33 - just disappear which is exactly what we
51:35 - want because we want to move the snake
51:36 - forward
51:38 - and then to this list i want to
51:41 - insert another element right at the
51:44 - beginning
51:44 - and this is going to be our head that we
51:46 - are moving so this has to be at
51:48 - index 0 so it's right at the start of
51:50 - the list and the value it is going to
51:53 - have
51:54 - is the previously first item of our list
51:58 - plus a direction and this direction
52:02 - we are going to create from player input
52:04 - but for now
52:06 - it is just going to be a vector 2 that
52:09 - points to the right
52:10 - and let me just type it properly vector
52:12 - 2.
52:13 - let's say for now it's going to be 1 and
52:15 - 0 so it moves to the right
52:18 - so this is self.direction
52:21 - and this is really all we need for the
52:23 - basics of our snake movement
52:25 - so we copied the entire self the body
52:27 - list but
52:28 - removed the last item and then for the
52:31 - hat
52:31 - we're adding one more element right at
52:33 - the front that is going to be the first
52:35 - element of the previous list
52:36 - last the direction we want to go in and
52:39 - that way the entire snake is moving
52:40 - forward
52:42 - now for the last bit all we have to do
52:44 - is self.body
52:47 - is our body copy so that
52:50 - we are returning the entire list back to
52:52 - our body because this is the one we are
52:53 - going to draw
52:54 - and i don't want to change this entire
52:55 - thing again and
52:58 - really this is all we needed to move our
53:00 - snack in the most basic way
53:01 - but here's the problem now i don't want
53:03 - to execute this method all the time
53:05 - i only want to execute it at certain
53:07 - intervals in my case every 150
53:10 - milliseconds
53:11 - so we need to create a timer and timers
53:14 - in pygame work within the event loop so
53:17 - this part here
53:18 - because this event loop can look for
53:20 - different things right now we only look
53:22 - for one specific event that we are
53:24 - closing the game
53:25 - but there could be lots of other events
53:28 - and in a bit we are going to add more
53:29 - events for player input
53:31 - but we could also add another event that
53:33 - is just a timer that triggers every few
53:35 - milliseconds
53:36 - and this we are doing in two lines of
53:38 - code the first one
53:40 - i am going to call screen update and
53:42 - this is going to be a variable that we
53:44 - don't want to change
53:45 - and this one is a pygame dot user
53:48 - event and let me just type it properly
53:51 - so this would be a custom event that we
53:54 - could trigger
53:55 - and how we triggered is by creating a
53:57 - timer
53:59 - and to create a timer we need pygame dot
54:01 - time
54:02 - dot set timer
54:05 - and in here we need our event so screen
54:08 - update and then how often we want to
54:11 - trigger it
54:12 - so my case 150 and this is
54:15 - in milliseconds so this event is going
54:18 - to be triggered every 150 milliseconds
54:21 - and then in the event loop we can
54:23 - capture it
54:24 - so if event dot
54:27 - type is equal to screen update
54:32 - then we want to do something and what i
54:34 - want to do
54:35 - is to get our snake and i called the
54:38 - method move snake so snake dot
54:42 - move snake and this is all we needed so
54:45 - let's try this now
54:47 - and there we go we have a moving snake
54:49 - that moves to the right
54:51 - obviously right now we can't control it
54:53 - so it's not particularly useful
54:54 - but it is working so with that covered
54:58 - let's actually work on keyboard input
55:00 - and this still
55:02 - happens in the event loop so we can just
55:04 - keep on working in here so again
55:06 - if event dot type
55:10 - and this time we look for pygame dot key
55:13 - down
55:14 - so this is going to be triggered
55:15 - whenever we press any button on the
55:17 - keyboard
55:18 - but we want to check for specific keys
55:20 - so we have to look for
55:22 - if event dot key
55:25 - is equal to let's say in this case
55:27 - pygame
55:28 - dot k up and this pygame dot
55:32 - k up would be the up key on your
55:34 - keyboard so when we press this
55:36 - then we want to do something and what we
55:38 - want to do
55:39 - is to get our snack again and
55:42 - what i want to change is the direction
55:45 - so right now
55:45 - our direction is going to be one and
55:47 - zero so we're moving to the right
55:50 - but if i press up this should be
55:53 - back door two and we don't want to move
55:56 - to the right
55:56 - and we move up so minus one so now if we
56:00 - run the game
56:02 - we are still moving to the right but if
56:03 - i press up we start to move upwards
56:05 - so this is working quite well and now
56:08 - all we have to do
56:09 - is to copy this line a couple of times
56:11 - for each direction we want to go
56:12 - in and this could actually be a really
56:14 - good exercise for you to understand
56:16 - vectors so if you want to code the long
56:18 - pause the video now
56:19 - and try to add three more if statements
56:22 - go left
56:22 - down and right
56:26 - let's do it together now so i want to
56:29 - take
56:30 - this entire thing and just copy it a
56:32 - couple of times
56:34 - and the first one let's go with right
56:37 - this one is going to be one and
56:40 - zero then let's go
56:44 - now with down and down
56:47 - it's just y equals one and then finally
56:51 - we wanna go to the left and left is
56:54 - going to be minus one
56:55 - and zero and that is pretty much it
56:59 - so let's try the entire thing now and
57:00 - let's see how this works
57:02 - so we can still run around and
57:05 - this is working really well
57:09 - obviously right now i can go over our
57:12 - fruit and nothing is going to happen
57:14 - but this we are going to cover in the
57:16 - next part which is going to come now
57:18 - actually
57:19 - so now we have a snack that can be moved
57:20 - around and we have a fruit on the field
57:23 - now let's try to bring them together and
57:25 - for that i'm going to create a third
57:27 - class
57:28 - that i called main and this one is going
57:30 - to actually contain the logic of our
57:32 - code
57:33 - which is going to make it much easier to
57:35 - maintain where things are going to be
57:38 - and i think this is best explained by
57:40 - implementing it straight away
57:42 - so let's jump right into our code and
57:44 - let's implement it
57:45 - so here we're back in our code and let
57:47 - me minimize the snake and the fruit so
57:49 - we have a bit more space
57:51 - and i want to create another class that
57:53 - i called
57:54 - main and when we initiate it
57:59 - i want this main to have our snake
58:02 - and this is literally creating the snake
58:05 - object
58:06 - and then also the same for our fruit
58:09 - so that whenever we are creating an
58:11 - object from this class
58:12 - we are also creating two more objects
58:15 - from these two classes here
58:17 - so that the entire game can happen
58:18 - inside of this one class
58:20 - and then this main class is going to
58:22 - have a couple of methods to maintain the
58:24 - game
58:24 - the first one i called update and what's
58:28 - going to happen in here
58:30 - is that we are moving the snake so i
58:32 - copy this one from the event loop
58:34 - and place it in here
58:37 - and i can also get rid of these two
58:39 - objects because we don't need them
58:41 - anymore
58:43 - and instead for all of this i'm going to
58:46 - create
58:46 - our main game
58:50 - and this is going to get main and then
58:53 - in the event update
58:54 - i call main game dot update
58:58 - so we don't actually change our game but
59:00 - now whenever we call screen at update
59:02 - so this event here we are calling
59:05 - maingame.update
59:07 - and maingame.update moves the snake
59:10 - and there's one more change we have to
59:11 - make this has to be self.snake
59:13 - so we are targeting this one so the
59:16 - snake itself
59:17 - remains unchanged just how we trigger it
59:19 - is going to be slightly different
59:21 - and then i'm also going to do the same
59:23 - for
59:24 - raw elements so all the stuff that we
59:27 - want to draw
59:28 - is going to happen inside of this method
59:30 - so right now
59:32 - we draw our snake and our fruit in the
59:34 - main game loop
59:35 - but i want both of these to be in here
59:40 - so that all of this happens inside of
59:42 - our main class
59:44 - so in our actual game loop we can just
59:46 - call
59:47 - maingame dot draw
59:50 - elements and this is
59:54 - quite a good practice that you want to
59:56 - keep this main game loop as clean as
59:58 - possible
59:59 - okay let's actually try to see if this
60:02 - still works
60:04 - and it does not because name our snack
60:07 - is not defined
60:08 - when we are calling our directions
60:10 - because
60:11 - we have to change this one here to main
60:14 - game
60:15 - dot snake and then it should be working
60:18 - so let me copy all of these
60:22 - and let's try it again now
60:25 - and there we go nothing much changed so
60:28 - far
60:30 - and you don't necessarily have to do
60:32 - this kind of step but it is going to
60:33 - make it much
60:34 - easier to organize your game
60:37 - okay so all of this is still working and
60:40 - a really nice advantage we have right
60:42 - now
60:42 - is that both of the snake and the fruit
60:45 - are in the same class
60:46 - so we can check where they are in
60:47 - relation to each other so for example if
60:50 - the head of our snake
60:51 - is on top of the fruit we want to do
60:52 - something with the fruit and with the
60:54 - snake
60:55 - and let's actually do that so i'm going
60:57 - to create
60:59 - a new method that i called check
61:03 - collision it's not actually a collision
61:05 - they just happen to be on the same spot
61:08 - and what i want to check in here is if
61:11 - self dot fruit dot position
61:15 - so this vector here
61:19 - if that is identical
61:22 - to self.snare dot
61:26 - body and the first element so this is
61:29 - going to be the head of our snake
61:31 - and this is our fruit position and if
61:33 - they are in the same position
61:34 - our snake is eating the fruit so then we
61:37 - want to do certain thing
61:39 - and for now let's just test if this is
61:40 - working so i want to print
61:42 - snack and let's try to run the code
61:47 - and nothing is happening because i
61:51 - forgot to call
61:52 - this method so in our update method
61:55 - i want to call self dot
61:58 - check collision and now let's try this
62:03 - and there we go we can go over the fruit
62:06 - and we print a statement so we know this
62:09 - if statement is working so that's quite
62:11 - nice
62:12 - and there are two things i want to do
62:13 - when our snake is colliding with the
62:15 - fruit
62:16 - number one is i want to reposition
62:20 - the fruit so that it's ending up in a
62:23 - new position
62:24 - and then besides that i want to add
62:26 - another
62:27 - block to the snake
62:31 - which is the main point of the game that
62:32 - you make the snake as long as possible
62:35 - and let's start with the fruit that
62:36 - one's the easier part so i want to
62:38 - target our self.fruit
62:40 - and then i want to add a new method that
62:42 - i call the randomize
62:44 - so let's create this one so let me close
62:47 - the main one for now
62:48 - and all the randomized method has to do
62:50 - is to create new random numbers in here
62:53 - so pretty much literally the same lines
62:56 - of code
62:57 - so i can just copy all of them create a
62:59 - new method that i call
63:01 - random mice and just
63:04 - copy these three lines of code because
63:06 - they create a random position
63:08 - and place the element there and i can
63:10 - just call self.randomize
63:12 - and that's all we needed to move the
63:14 - fruit so let's try this
63:17 - so it's still working and we get a new
63:21 - position for our fruit
63:22 - and let's try it again and there we go
63:25 - this works really well
63:27 - last one there we go cool
63:31 - so this is the first part that we want
63:34 - to
63:35 - reposition our fruit so this one's done
63:39 - now we come to the second part adding
63:41 - another block to our snake
63:43 - and this one is also actually super easy
63:46 - so
63:46 - again we want to target our snake
63:49 - and i want to add a new method that is
63:52 - called add block
63:54 - so let's create this method so let me
63:57 - close mine again
63:58 - and open snake
64:01 - and now let's create add block
64:06 - and now we have to think about what we
64:08 - are going to do
64:09 - because doing this is actually super
64:11 - easy but you do have to think about what
64:13 - you are going to do
64:15 - and ultimately it goes back to these
64:18 - three lines of code
64:20 - and specifically this line here that
64:23 - right now we copy our self.body list
64:25 - and take every element except the last
64:28 - one
64:28 - so that we are moving the entire snake
64:30 - forwards but if we want to add a block
64:33 - to the snake
64:34 - all we have to do is to remove this one
64:36 - and take the
64:37 - entire body and we are still going to
64:40 - add a new position at the front
64:42 - so we are extending the snake but this
64:44 - is really all we have to do for the
64:45 - change
64:46 - so let me revert this back and how i
64:49 - implemented this is i created a new
64:50 - attribute that is called
64:52 - self dot new block
64:55 - and by default it is false and what add
64:58 - block does
64:59 - is it changes self dot new block
65:03 - to true and if self taught
65:06 - new block is true so in our move snake
65:10 - if self dot add block
65:13 - is true so let's just type it in full
65:17 - then i want to copy the entire block
65:21 - and not delete anything
65:24 - and if that is not the case i just want
65:27 - to
65:28 - move the entire snake without adding
65:30 - anything towards it
65:33 - and that is pretty much it
65:36 - so let's try it and there's one more
65:38 - thing i do have to add
65:41 - so oh i realized there's a typo this is
65:45 - an app lock
65:46 - this is new block if this one is true so
65:49 - now let's try
65:50 - it and now
65:53 - when we pick up something
65:56 - our snake is going to extend for all
65:59 - eternity
66:00 - which i guess is a little bit funny but
66:03 - not the intended thing we want to
66:04 - achieve
66:05 - and the reason why this happens is
66:07 - because this log through
66:09 - stays true so once we are colliding with
66:11 - the fruit it is always going to extend
66:14 - which we don't want but we can fix it
66:16 - super easily
66:18 - by changing self.new block to false
66:22 - and now let's try it again
66:26 - so now our snake every time we collect
66:29 - the fruit
66:29 - is going to get a tiny bit longer and
66:32 - this seems to be working
66:33 - really well so this already is a really
66:36 - basic snake game
66:38 - and well takes no time at all to create
66:42 - it
66:43 - and with that we have our basic logic
66:45 - but the problem right now is that our
66:47 - snake cannot die
66:49 - so let's work on that and there are two
66:51 - conditions that could lead our player to
66:53 - fail
66:53 - number one is that the snake hits itself
66:56 - or that the snake hits any of the screen
66:57 - walls
66:59 - so effectively we have to add two if
67:02 - statements
67:03 - so let's start working on it so here i'm
67:06 - back in my code
67:06 - and i want to work in our main class
67:09 - function
67:10 - and i want to create a new method that i
67:13 - call check
67:14 - bail doesn't need any parameters
67:18 - and in here we want to check if
67:22 - snake is outside
67:25 - of the screen
67:29 - and check if snake hits
67:33 - itself and let's start with the first
67:35 - one
67:36 - that we want to check if the snake is
67:37 - outside of the screen
67:39 - and this is actually going to be super
67:41 - easy to check effectively all i want to
67:43 - do
67:43 - is if the snake is between 0 and the
67:46 - number of our cells so in this case 20
67:49 - and if that is not the case then we want
67:51 - to go to the game over screen
67:53 - and we only have to check this for the
67:55 - head of our snake because the rest of
67:56 - the body always follows the head
67:58 - so only the head really matters when we
68:00 - check for game over
68:01 - but let's implement this so i want to
68:03 - check if not
68:05 - 0 is smaller or equal
68:09 - then our self dot snake dot body
68:14 - zero and this is smaller or equal than
68:18 - cell number so there's quite a few
68:21 - things going on right now so let me talk
68:23 - through it
68:24 - self.snack.body is the body of our snake
68:27 - and 0
68:27 - is going to be our head so let me open
68:30 - it right now
68:31 - this would be this element here at
68:33 - position 5 and 10.
68:36 - and we want to check if this is outside
68:38 - of the field so if it is not between
68:40 - zero
68:41 - and the number of cells and there's one
68:43 - thing i forgot
68:44 - this one here is a vector and we can't
68:47 - compare vector to
68:48 - one single number so we have to check
68:50 - this for x
68:52 - so that we only check left and right and
68:54 - we are going to add the top and the
68:56 - bottom in just a second
68:58 - but for now if that is the case we want
69:01 - to do something
69:02 - so let me create a new method that i
69:04 - call dot game
69:06 - over so def
69:10 - dot game over and at least for now if
69:13 - our game is over
69:14 - i just want to quit the entire thing so
69:16 - i copied these two lines
69:18 - and paste them in here but we are going
69:20 - to change this later on
69:22 - in our update method we actually have to
69:24 - call it so
69:25 - self dot check fail
69:30 - so in theory right now if our snake is
69:32 - too far to the left or too far to the
69:34 - right
69:34 - it should fail so let's try and let's
69:37 - just go to the right
69:38 - and the game is over cool
69:41 - but there's one bug right now that this
69:44 - cell number
69:45 - at the highest point would be 20 but our
69:47 - cell furthest to the right is cell
69:48 - 19 so we could in theory go one
69:52 - field outside of the game which i don't
69:54 - want so i just removed the is equal to
69:56 - and we have to be smaller than this
69:57 - number so now if i try this again
70:02 - our snake or game fails whenever we hit
70:04 - the right wall
70:05 - so that's perfect but now the problem is
70:07 - that this is only going to work for left
70:09 - and right so we have to improve this if
70:11 - condition to also check for the top and
70:13 - the bottom of the screen
70:15 - and this could again be your challenge
70:17 - so pause the video now and try to do
70:19 - this yourself
70:23 - so really all we have to do is to add an
70:25 - or statement
70:26 - and copy the entire thing and then
70:29 - change it to
70:30 - y so we are going to check if the head
70:33 - of our snake
70:34 - is not too far to the left or to the
70:35 - right or if it's not too far up or down
70:39 - and this is really all we have to do so
70:41 - let's try all of this now
70:42 - and let me try to go game over from the
70:44 - top of the screen and this is working
70:46 - cool so now we have the condition to
70:48 - check if the snake has hit any of the
70:50 - walls
70:51 - so with that covered we can check if it
70:54 - hit itself
70:55 - and really what this means is we want to
70:57 - check if the head of the snake has
70:59 - collided with any other part of the
71:01 - snake
71:02 - so i'm going to start by cycling for
71:03 - every single block of the snake
71:05 - except for the head so for block
71:08 - in self.snake and i only want to go from
71:12 - the element with the index 0
71:14 - all the way to the end so we don't take
71:16 - the entire snake we only take all the
71:18 - elements that come after the head
71:20 - and in here i want to have an if
71:22 - statement
71:23 - that if any of these blocks is equal to
71:28 - self.snake0 and if that is the case
71:32 - we go back to game over and this would
71:35 - be the proper logic
71:36 - although i did just realize i made a
71:38 - typo this should be
71:40 - snake.body and same for this one
71:42 - snake.body
71:43 - because snake is the actual object we
71:45 - created and body is the actual part that
71:47 - contains all of the blocks
71:49 - and while we add it i also realized i
71:51 - made another mistake
71:53 - and let me go all the way to the top to
71:54 - explain what i did wrong
71:56 - so when we are creating our snake it is
71:58 - moving to the right
72:00 - so the vector is one and zero however
72:03 - the problem now
72:04 - is that our snake is actually facing to
72:06 - the left not to the right
72:08 - as i initially intended it and
72:11 - you can see this quite easily that the
72:13 - very first item is this point here
72:15 - at position 5 and 10. so in theory this
72:18 - should be the point furthest to the
72:19 - right
72:20 - but it's not because the second and the
72:22 - third item have greater x values
72:25 - so this one is to the right of this one
72:27 - and this one
72:28 - is to the right of both of these which
72:30 - basically means that the head of our
72:32 - snake is to the left of the body of the
72:34 - snake
72:34 - and since we are moving the head of the
72:36 - snake to the right it is going to move
72:38 - inside of itself
72:40 - so we do have to fix this and sorry
72:42 - about that but there are two ways of
72:43 - fixing this it's really easy to do
72:45 - number one you could either move the
72:47 - head by default to negative one
72:49 - so that we are moving the head of the
72:50 - snake to the left and all would be good
72:53 - but i don't really like that because
72:55 - it's too close to the wall
72:56 - and instead what we can do is change
72:59 - these two vectors to
73:00 - four and three on the x positions so
73:02 - that they are to the left
73:04 - of the head and with that covered let me
73:06 - go back
73:07 - down to our check fail logic
73:10 - and let's try this and the snake is
73:13 - still going to move
73:14 - that seems to be working quite well and
73:17 - let me pick
73:18 - up a couple of items so i can actually
73:19 - move them to myself
73:25 - and yeah it seems to work so cool
73:28 - now we know this is going to work and
73:31 - this
73:32 - is the basic check fail logic however
73:34 - there's one problem right now
73:36 - and let me run the game again now the
73:38 - snake is moving to the right and i could
73:40 - just destroy myself
73:41 - by clicking to the left and the problem
73:44 - here
73:45 - is all of this code here
73:48 - that we could always change direction
73:51 - let's say
73:51 - going up even if we are going down so
73:54 - that we have to add some code here that
73:56 - our snake cannot reverse
73:57 - itself because then we would instantly
74:00 - destroy ourselves
74:01 - and this can very easily be done with
74:03 - just adding another if statement
74:06 - so right now we check if event key is
74:08 - the up key
74:10 - and now i want to check if maingame
74:14 - dot snake dot direction dot y
74:17 - is different than one and only if that
74:21 - is the case
74:22 - we want to execute this line of code and
74:25 - let me explain what this means
74:27 - so when we're pressing the up key we
74:28 - want to go up
74:30 - however if we are moving downwards this
74:33 - is not supposed to work because then we
74:35 - would fail immediately
74:36 - so we want to check if our current
74:38 - direction in the y direction
74:40 - so this part here is anything
74:43 - but one because if it's one we're moving
74:46 - downwards
74:47 - so only if it's different from one then
74:49 - we can actually do
74:50 - this line of code here and this line of
74:52 - code we just have to copy
74:54 - a couple of times and change it for the
74:57 - different directions
74:58 - so for right it would be x and
75:01 - -1 so that if we are going to the right
75:04 - we cannot currently go
75:05 - left that just wouldn't make sense we
75:07 - would just reverse immediately
75:10 - then for down we would again look at y
75:12 - but it would have to be
75:13 - minus one minus one
75:16 - and then finally to go left then we
75:20 - again have to look at
75:21 - x and we can only go to the left if our
75:23 - snake currently
75:24 - is not going in the right direction and
75:27 - all right
75:28 - this is basically all we need so let's
75:30 - try it now
75:31 - and now i'm moving to the left and i
75:34 - can't
75:34 - reverse direction you can't really see
75:36 - it but it does work
75:38 - and we can still pick up all the other
75:40 - elements
75:42 - so all of this is working
75:45 - so nice and i can still get game over
75:48 - from moving into a wall
75:50 - so with that we have created a really
75:52 - basic snake game
75:53 - so this one is going really well but it
75:56 - really doesn't look all that good and
75:58 - also we can't tell a score
76:00 - so this is the stuff we are going to
76:02 - start working on now
76:03 - that we are going to start making this
76:05 - game a lot prettier
76:07 - and this is going to involve quite a bit
76:09 - more code but ultimately
76:10 - it's a really good practice to learn how
76:12 - to use if statements and the enumerate
76:14 - method
76:14 - but let's start with really simple one
76:16 - that i just want to display a proper
76:18 - fruit instead of just a rectangle
76:20 - and let's jump right into the code i
76:21 - think that's going to be the easiest way
76:23 - to approach this topic
76:24 - so here we are back in our code and the
76:26 - very first thing i want to do
76:28 - is to actually import an image of our
76:30 - apple and i'm going to do
76:32 - this where i initiated all the other
76:34 - elements and i want to
76:36 - import an apple and to import an image
76:39 - we need
76:41 - igame.image.load
76:43 - and then the file direction and this has
76:45 - to be a string
76:46 - and in my case i have a folder called
76:48 - graphics
76:49 - and in this folder there's an image
76:51 - called apple.png
76:54 - and here again this is only going to
76:56 - work if your code is in the same folder
76:58 - as this graphics folder so make sure you
77:00 - have them in the right place and then
77:02 - also
77:02 - i want to convert alpha this image
77:06 - so pygame can work with it easier so all
77:09 - that this method does is it takes this
77:10 - image here
77:11 - and it converts it to a format that
77:13 - pygame can work with easier so our game
77:15 - can run better
77:16 - but okay this is all we needed for the
77:18 - apple so now
77:20 - when we have our fruit class we can
77:23 - instead of drawing a rectangle we can
77:24 - draw an apple
77:25 - so let me comment this line out because
77:27 - we don't need it anymore
77:29 - but we are still going to need the
77:30 - rectangle so keep that one
77:32 - and really all we have to do is to use
77:35 - screen
77:36 - dot blit and now we need a surface and a
77:39 - rectangle
77:40 - our surface is going to be this apple
77:42 - here
77:43 - that whenever we import an image into
77:45 - pygame it is going to be on its own
77:47 - surface
77:48 - so we can just add apple in here and
77:50 - after that we need a rectangle
77:52 - or at least some kind of position and we
77:54 - also have that it's just this fruit
77:56 - rectangle so i just type in
77:58 - through direct and this is literally all
78:01 - we needed it's
78:02 - surprisingly simple so let's try it off
78:05 - this now and see if it works
78:06 - and yeah it does we have an apple
78:09 - and it still works with randomizing and
78:12 - all of this
78:13 - works super well
78:17 - and there we go so this already covers
78:20 - our entire fruit class
78:22 - now i can close it and we never need to
78:24 - open it again
78:26 - and with that part covered we can
78:27 - actually put the graphics on for our
78:29 - snake
78:30 - and this is going to be the most complex
78:32 - part of this entire tutorial
78:34 - but in general terms here's what we are
78:36 - going to do
78:37 - we are going to go for every single
78:39 - block in our self.snackdoll body
78:41 - and look at how each block relates to
78:43 - the block before and after itself
78:46 - and from this relation we can tell what
78:48 - kind of block to put in this place
78:50 - so effectively we are going to create a
78:53 - really long if statement that checks a
78:54 - huge range of different factors
78:57 - and i think this is really best
78:59 - explained while actually doing it
79:01 - so here we are back in our code and the
79:04 - very first thing i have to do
79:05 - is to actually import all the images we
79:07 - need for the snake and this is going to
79:09 - look very similar compared to this apple
79:11 - import
79:12 - except now we are going to import quite
79:14 - a few more
79:15 - and since we only jump for the snack
79:17 - itself i'm going to do this in the snake
79:19 - class
79:19 - when we are initiating it and in here i
79:23 - already have all of the lines ready and
79:25 - let me paste them in
79:27 - so this is quite a few different
79:29 - graphics that are being imported
79:31 - we have all the possible head positions
79:34 - all the possible tail positions
79:36 - then a vertical and a horizontal body
79:39 - and finally all the curved body parts
79:41 - so in total 14 different images and
79:44 - these are all the possible graphics that
79:46 - could be used for our snake
79:47 - and now that we have all the graphics we
79:50 - just have to figure out where to put
79:51 - them in our game
79:52 - and this is going to happen in our draw
79:55 - snake function
79:57 - so let me close everything else and let
79:59 - me give some space so we can focus on
80:01 - this part
80:03 - and first of all this part that we used
80:06 - to have
80:07 - we don't need any more so i'm just going
80:09 - to comment it out
80:10 - actually let me get rid of it entirely
80:13 - so we need all the space
80:15 - we can get and here let me go through it
80:18 - really slowly the first thing we want to
80:20 - do is we want to look at all the blocks
80:22 - in our snake body so we want to look at
80:25 - for
80:25 - block in self dot
80:29 - body but this by itself would not be
80:32 - enough
80:32 - because we want to look at more things
80:34 - we don't just want to look at the block
80:36 - itself we also want to look at the
80:38 - blocked accounts before
80:39 - and the block that comes after and for
80:42 - that
80:43 - we are going to need the enumerate
80:46 - method
80:47 - and what enumerate does is that it gives
80:49 - us an index on what object we are
80:51 - inside of our list so we have to type in
80:54 - index and then block so index is the
80:57 - index we're on
80:58 - and block is the actual object that we
81:00 - are going to look at
81:01 - so for example in our body right now we
81:04 - will get an index of
81:05 - 0 and then vector 2 would be our block
81:08 - and for the second entry this would be
81:10 - index 1 and the block would be the
81:12 - vector
81:13 - and this would allow us to access quite
81:15 - a few more blocks that are not the block
81:17 - itself
81:17 - so this one is really useful and in here
81:20 - we have to do lots of different things
81:22 - now and let me just write them out
81:24 - so number one is we still need
81:27 - a rect for the positioning
81:31 - so maybe i shouldn't have deleted the
81:33 - earlier one but we can just write it
81:34 - again
81:35 - so it doesn't matter too much and once
81:37 - we have that
81:38 - just to get started we want to figure
81:40 - out
81:42 - what direction is the face
81:45 - heading so in what ways are snake
81:47 - looking
81:48 - and this is going to be quite a bit
81:50 - larger so let's code until that point
81:52 - so let me start by creating direct again
81:55 - and this again
81:56 - is the same thing we have seen earlier
81:58 - where we literally just take the x and
82:00 - the y position
82:01 - from our block and from that
82:04 - we create a pygame direct object
82:08 - and it has an x position a y
82:11 - position and then we have cell size and
82:15 - cell size for the x and the y size so
82:18 - this is the same thing we have done
82:19 - earlier
82:20 - and this we still need this is what we
82:22 - use to actually place the image and get
82:24 - the position
82:25 - so this was the easy part now we have to
82:28 - think about how can we identify
82:30 - different parts of the snake
82:32 - so for example how can we tell which
82:33 - part is a hat and which part is a tail
82:36 - and for that the index is incredibly
82:38 - valuable
82:39 - because all we have to do is if index
82:42 - is equal to zero because index zero is
82:46 - always going to be the first
82:47 - element and our hat is always going to
82:50 - be our first element
82:51 - so this is all we needed so if that is
82:53 - the case
82:54 - we want just like for the fruit screen
82:57 - dot
82:57 - blit and in here we have to enter a
82:59 - surface and a rectangle
83:01 - we do have the rectangle that's our
83:03 - block rect
83:04 - and just to pick one of the hats so we
83:07 - have four different heads for each
83:08 - direction
83:09 - let's start with head right
83:15 - and if that is not the case so else at
83:17 - least for now
83:18 - we just want to do the same thing we
83:20 - have done earlier so pygame.draw.rect
83:24 - and i want screen and i forgot the color
83:28 - we had so let's just go
83:29 - with 150 100 and
83:33 - and then log rect so effectively what we
83:37 - are going to do
83:38 - is that we create a rectangle at the
83:40 - position where we need it
83:42 - and if this rectangle is the first no
83:44 - self.body list
83:45 - we are going to place the right facing
83:47 - head of our snake there
83:49 - and if that's not the case we just draw
83:50 - a plane rectangle
83:53 - and let's actually try this and i made a
83:55 - typo it's
83:56 - enumerate and now it gets blue so this
83:58 - looks much better
83:59 - so now let's try it again and there we
84:01 - go we have an incredibly weird looking
84:04 - graphic
84:05 - but we do have a graphic of a snake hat
84:07 - that kinda works
84:09 - so at least we're making some progress
84:11 - cool
84:12 - let's step in the right direction so
84:14 - this line here
84:15 - is kind of working but the problem we
84:17 - have right now
84:18 - that let's put in number three the snake
84:23 - head direction is not
84:26 - updating so what i want to achieve is
84:29 - that if we are moving upwards the
84:30 - snakehead is also looking upwards
84:32 - and we do have all the graphics to make
84:35 - this
84:36 - work but we do have to figure out how to
84:38 - select the right image
84:40 - and how i solve this is by putting all
84:42 - of the logic for this
84:44 - into its own method so i have self
84:47 - update head graphics
84:52 - and this is going to create a new self
84:54 - hat attribute
84:55 - and this is what we are going to use in
84:58 - the end
84:59 - so this method here effectively picks
85:04 - one of these four whichever is
85:05 - appropriate for the direction we are
85:07 - going
85:08 - so let's create that one so i go to def
85:12 - update add graphics
85:15 - and in itself and here's how this is
85:18 - going to work
85:19 - we are going to take the head of our
85:20 - snake so the first element in self.body
85:23 - and subtract it from the item that comes
85:25 - right before it
85:26 - and that way we get the relationship
85:28 - between the two or in more mathematical
85:30 - terms we are going to subtract one
85:32 - vector from the other and from the
85:33 - result we are going to get how they
85:35 - relate with each other
85:36 - so if one vector is above or below or to
85:38 - a left or to the right of the other
85:40 - and here again vectors are incredibly
85:42 - useful because we can just subtract from
85:44 - each other and understand how they
85:45 - relate to each other
85:47 - but okay i created a new variable that i
85:49 - called had
85:50 - relation terrible name but i could not
85:53 - think of something better
85:55 - and what i want to do is i want to go to
85:57 - self.body
85:59 - and get the second item so the one with
86:01 - the index one
86:02 - [Music]
86:04 - and let me just type it properly and
86:08 - from that i subtract
86:09 - our head so self.body zero
86:12 - so this is going to result in a new
86:14 - vector that could point in one of four
86:16 - directions
86:17 - and from this direction we're able to
86:19 - tell how the head relates to the block
86:20 - that comes before it
86:22 - and really all we have to do is if had
86:27 - relation is equal to vector 2
86:30 - and let's start with the first one 1 and
86:33 - 0.
86:34 - so this would mean that those two
86:36 - combined end up with one
86:37 - and zero which means that our head is to
86:40 - the left of the next block
86:42 - so if that is the case self dot head
86:46 - is going to be self dot head
86:50 - left and since we have quite a few if
86:52 - statements i am going to keep them on
86:54 - the same line just to make it a bit more
86:55 - readable
86:57 - and now all we have to do is copy this
86:59 - thing a couple of times
87:01 - change this to l if statements
87:04 - and now update the different vectors so
87:07 - the easiest part would be
87:09 - changing this to minus one so then this
87:11 - one would be at dot
87:12 - right then if this is zero
87:16 - and this is one so this would mean
87:19 - there's a block
87:19 - below the head of our snake so our snake
87:22 - is looking
87:23 - up and then for the final one by the
87:26 - process of elimination
87:28 - the snake has to be looking down and
87:32 - that's basically it
87:33 - so let's see if i get this right and
87:35 - let's try it now
87:37 - and yeah there we go our snakehead is
87:40 - updating quite nicely
87:42 - so this is quite a good start okay so
87:46 - this would cover the head of our snake
87:47 - so i can close this method and not look
87:50 - at it again
87:50 - and now we come back to our if statement
87:53 - and let me get rid of this part here
87:55 - because we fixed that bit
87:57 - so now we have the head of our snake now
88:00 - the next
88:01 - easy bit or easy-ish bit is to get
88:04 - the tail end so the last block
88:08 - that we want to cover and this we can
88:10 - also address
88:11 - really easily because this part is
88:13 - always going to be the last one
88:15 - so we can use l if index is equal to
88:19 - last item in self.body
88:23 - so we have to figure out some code to
88:25 - get the last item
88:27 - in this self.body list
88:30 - and well all we need is the length
88:33 - of our self.body so this is all the
88:36 - items in there
88:38 - and then -1
88:41 - because we start counting from zero and
88:44 - with that
88:44 - we always get the last item so if we
88:47 - have that we can do the same thing we
88:48 - have done for the head so screen dot
88:50 - blit
88:51 - and this time it's self.tail and we
88:54 - still need our block
88:55 - rect and self.tail does not exist yet
88:59 - but we do have if i open our knit method
89:01 - again we have all the different
89:03 - directions
89:04 - for the tail so i am effectively going
89:06 - to copy the method we used for the head
89:09 - this one and create the same one for the
89:12 - tail
89:13 - so let me close all of this and create
89:17 - self dot update tail
89:20 - graphics and again
89:24 - if you want to code along this could be
89:25 - a nice exercise
89:27 - so look at the update head graphic and
89:30 - try to figure out the logic for the tail
89:33 - but okay pause the video now if you want
89:34 - to go to long
89:35 - and i'm going to continue myself in a
89:37 - couple of seconds
89:38 - [Music]
89:42 - okay welcome back let's try to do it
89:44 - together now
89:46 - so i want to create a new method dev
89:49 - update tail graphics
89:53 - and just to save me some writing i'm
89:56 - going to copy
89:57 - the entire line for the head
90:01 - and just paste it in here and now it's
90:03 - going to be
90:04 - tail relation and now we
90:08 - don't want to look at the second and the
90:09 - first element instead we want to look at
90:11 - the last element and the element that
90:13 - comes before the last one
90:14 - so we know our last one is minus one and
90:17 - then the one before
90:18 - is minus two so this one is quite easy
90:20 - to start and then i have to change
90:23 - all of the tail relation
90:27 - l if statements and also change all of
90:31 - this to
90:32 - tail might have benefited from naming my
90:36 - variables better
90:37 - but never mind okay here we go so
90:40 - this would actually almost work so let
90:42 - me try
90:44 - and i forgot one equal sign
90:48 - let's try it again now there we go and
90:51 - there we go
90:54 - we have a nicely functioning
90:57 - tail cool so that was surprisingly easy
91:01 - actually so
91:02 - the same logic that we used for the hat
91:04 - we can use for the tail
91:06 - so now we have covered the tail
91:10 - with that we can start working on the
91:12 - actual body or the rest of the body
91:14 - and this is all going to end up in an
91:16 - else statement
91:18 - and in here it is starting to become
91:20 - important to figure out what is the next
91:22 - and the previous block
91:23 - so i want to know what is my previous
91:26 - block and what is my next
91:30 - lock and we know the block we're on
91:32 - right now that's just block
91:34 - so in here the index again is going to
91:37 - be incredibly useful
91:38 - because all we have to do is self dot
91:42 - body and then index plus one
91:46 - minus log and then for the next block
91:51 - we have to do the same thing except we
91:53 - subtract index minus one
91:55 - so just to explain what happens here we
91:58 - are indexing from self.body
92:00 - and index is going to be our current
92:02 - element and then we either add one
92:04 - or subtract one to get the next or the
92:06 - previous block
92:08 - which i think is quite straightforward
92:10 - and then from that we are going to
92:11 - subtract our current block
92:13 - to get the relation between the two and
92:16 - this is going to result in a new vector
92:18 - that again can point in one of four
92:20 - directions
92:21 - and from that we can tell what kind of
92:22 - block we need and now we can start with
92:25 - the horizontal
92:26 - or vertical body parts so these are
92:28 - going to be body parts that either are
92:29 - entirely horizontal or entirely vertical
92:32 - so i don't go around the corner at all
92:34 - and this
92:35 - is really easy to get because all we
92:37 - have to check is if previous block
92:39 - and next block have the same x or
92:42 - y-coordinates because if that is the
92:44 - case the block between these two blocks
92:46 - has to be either horizontal or vertical
92:48 - depending on if we look at x or y
92:51 - so let's implement this with another if
92:54 - statement
92:55 - and what i want to know is if previous
92:57 - block
92:58 - dot x is equal to
93:01 - next block dot x and
93:04 - if both of these have the same x
93:06 - coordinate we know it's going to be a
93:08 - vertical block
93:09 - so we can use screen dot blit
93:13 - and this is going to be self dot
93:16 - vertical and then block rect
93:20 - and let's try this oh right as a typo i
93:24 - have to get rid
93:25 - of yeah let's get rid of it entirely
93:28 - because it's just going to cause errors
93:30 - otherwise so now some parts of our snake
93:32 - we don't draw
93:34 - but i think that illustrates it even
93:36 - better what is missing
93:37 - so now we can see our snake is working
93:40 - when we're going up and down
93:42 - but if we're going left or right or
93:43 - around the corner things are missing
93:46 - but otherwise our snake is still working
93:49 - quite nicely
93:50 - so we are making quite decent progress
93:54 - looks actually quite funny but okay now
93:57 - i want to copy this entire if statement
94:02 - and now i just have to check the y parts
94:06 - and if those are identical we know our
94:08 - block is
94:09 - horizontal and i want to make this
94:12 - an alif statement so let's try this one
94:15 - now
94:16 - and we can see we have horizontal and a
94:19 - vertical body part for our snake
94:22 - we don't have any corners but that's
94:23 - going to come next besides that
94:25 - everything seems to be working quite
94:26 - nicely so we are making some decent
94:29 - progress
94:30 - so now we come to the most complicated
94:33 - part
94:34 - where we have to look at the corners of
94:35 - our snake
94:37 - and all of this is going to be inside of
94:39 - another else
94:41 - statement and let me explain the
94:44 - logic here to get this done and i
94:47 - think the best way to explain this is by
94:49 - using an example
94:50 - so let's say we want to create a corner
94:52 - where we go left and then
94:53 - up or we go down and right it's going to
94:55 - be the same corner
94:57 - and really all we have to do is to check
94:59 - the x and the y position of our previous
95:02 - and next block and we have the
95:04 - information to achieve all of this
95:06 - but you probably have to look over this
95:07 - a couple of times it is a little bit
95:09 - confusing
95:10 - but okay here we are back in our code
95:13 - and what i want to do
95:14 - is screen dot blit
95:17 - and i want to blend self dot body
95:22 - tl so this is top left so the corner is
95:25 - going up and left
95:27 - and again we need our block rect
95:30 - so we are now so we now have to figure
95:32 - out when to trigger this corner
95:34 - so all of this goes inside of
95:38 - an if statement a pretty long if
95:40 - statement actually so we want to check
95:42 - if
95:43 - previous block dot x is equal to -1
95:48 - and next block dot y
95:53 - is also equal to -1 or we could start
95:56 - from the other way
95:57 - where our previous block dot y
96:01 - is equal to -1 and
96:04 - next block dot
96:07 - x is equal to minus one
96:11 - and let's try this one so
96:14 - top left there you can see it we have
96:16 - one corner
96:20 - and we can also go bottom right and this
96:22 - would still be working
96:24 - bottom left i mean sorry and there we go
96:27 - we have our first corner
96:31 - and now all we have to do is to copy
96:34 - this if statement
96:39 - a couple of times and change our
96:42 - attributes
96:43 - and of course the image we're actually
96:45 - blitting so i would have
96:46 - bottom left i would have
96:50 - top right and then the remaining one
96:53 - would be bottom right and the
96:56 - coordinates would be
96:58 - previous block x minus one and next
97:00 - block
97:01 - should be one and then previous block
97:04 - would be one for y and the x would be
97:08 - minus one
97:09 - then we have four top right the previous
97:13 - block x
97:14 - would be one
97:18 - and next block y would be minus one
97:21 - or alternatively we would have the y
97:24 - part would be minus one
97:26 - and next block would just be one
97:29 - and for the final one we would have one
97:32 - and one
97:34 - and same for the other way around as
97:35 - well
97:37 - okay and those are all the bits let's
97:39 - actually try this together
97:41 - and this looks pretty good okay
97:45 - cool so this is actually drawing
97:48 - graphics quite efficiently
97:49 - [Music]
97:50 - and works even if we go really close to
97:54 - each other
97:54 - and looks quite clean
97:58 - okay and all of this is probably quite
98:00 - confusing
98:02 - and honestly when i figured this out i
98:04 - went by trial and error thinking about
98:05 - all of this gave me a headache
98:07 - so if this doesn't make full sense don't
98:10 - worry about it
98:11 - it really is kind of annoying to think
98:12 - about but really all we are doing
98:15 - is we look at our previous block and our
98:18 - next block
98:18 - and how they relate to our current block
98:21 - and from that we can tell what kind of
98:22 - corner we need
98:24 - but granted it does get quite confusing
98:27 - but okay with all of that one done
98:28 - i can get rid of the comments
98:32 - and we have our basic snake and we
98:34 - created an el
98:35 - if statement that covers basically an
98:36 - entire page cool
98:38 - always feels good so now i can close
98:40 - drawing snake
98:41 - and not worry about this for a while and
98:44 - for the next part
98:45 - i want to update the grass so it starts
98:47 - to look a little bit nicer
98:49 - and let's actually jump right in i think
98:51 - that's going to be the easiest way to
98:52 - approach this
98:53 - so here we are back in our code and in
98:56 - our class main
98:57 - i want to create a new method that
99:00 - i call define raw
99:03 - grass and this one well it draws the
99:06 - grass
99:08 - so we have a checkerboard style grass
99:09 - pattern on our field to make it look a
99:11 - bit more interesting
99:12 - and to achieve this kind of effect all
99:14 - we really have to do is cycle through
99:16 - each of the line
99:17 - and draw a slightly darker green
99:19 - rectangle if we have an odd or an even
99:21 - number
99:22 - so to start this off i'm going to create
99:25 - just to save me some writing later on
99:27 - a grass color variable and this is just
99:29 - going to be an rgb tuple
99:31 - with 167 209
99:35 - and 61. so this is a dark greenish color
99:39 - and now we have to cycle through every
99:41 - single cell on our field
99:42 - and either draw a darker rectangle or
99:45 - not draw a darker rectangle
99:47 - and to start this one off simple let me
99:49 - just start with the first
99:50 - line this one is going to make it quite
99:52 - a bit easier so i want to start with for
99:55 - column in
99:59 - range cell number
100:02 - so this would cover the horizontal axis
100:05 - of our entire field
100:06 - and for each of those i want to create a
100:09 - new grass
100:10 - rectangle and this is just going to be a
100:13 - pie game wrecked
100:14 - object and here we need an x a y a width
100:17 - and a height just as we have always used
100:20 - and with and hive again is just going to
100:22 - be
100:22 - cell size the one we have always used
100:25 - i almost regret not naming this with a
100:27 - shorter name but okay
100:29 - now we need two more pieces of
100:30 - information the first one is y
100:32 - and for now this is just going to be
100:34 - zero because we want to work with the
100:35 - first row
100:36 - but we are going to change this later on
100:38 - so
100:39 - now we are going to need our x
100:40 - coordinate
100:42 - and we could just start with this call
100:44 - so our column
100:45 - multiplied by cell size
100:50 - so this would give us a rectangle and
100:53 - now
100:53 - we can just draw it with
100:55 - pygame.draw.direct
100:57 - and i think by now you should know it so
100:59 - this is screen the service want to draw
101:01 - on
101:01 - then the color it's already predefined
101:04 - and then our grass
101:06 - rect so this right now would cover the
101:10 - entire first line of our field
101:12 - and let's actually illustrate this so
101:14 - when we come to draw elements
101:15 - below all the other elements i want self
101:19 - dot draw press
101:23 - and let's try this and you can see
101:27 - the very first line of our field is
101:29 - slightly darker
101:31 - so we do manage to draw at least a
101:33 - little bit
101:34 - but well it's not great yet so we have
101:37 - to make some more changes
101:40 - and the first change i want to do is
101:41 - that i only want to draw every second
101:43 - field not every field and you could
101:46 - approach this in two different ways
101:48 - you could either draw all the fields
101:49 - that start with an even number or all
101:51 - the fields that start with an odd number
101:53 - which one you go for it doesn't really
101:55 - matter but really
101:56 - all this is is if call
102:00 - mod 2 gets us a 0
102:03 - only then do we want to draw all of this
102:07 - and let's try this and now we can see
102:11 - we have only every second field working
102:14 - for this
102:15 - so this is already working quite nicely
102:18 - so now we have to do this thing for
102:21 - every second line in our field
102:23 - so what i want to do is to go for
102:28 - row in range
102:32 - cell number so we go for every single
102:35 - row in our field
102:37 - and now we are going to do this
102:39 - operation again
102:40 - except for the row not for the column
102:44 - so we want to only draw this kind of row
102:47 - if the row
102:48 - starts on an even number so if rho
102:50 - divided by two
102:52 - is equal to zero and if i run this
102:56 - oh forgot the if statement so if row
103:01 - and i have to indent everything as well
103:04 - try now
103:08 - ah and this doesn't work right now
103:11 - because we are still starting at
103:13 - position zero
103:14 - so we have to make an update to this one
103:17 - so right now we are drawing this
103:18 - multiple times
103:19 - but we always start at position zero so
103:21 - they're all drawn on top of each other
103:23 - but all we have to replace it with is
103:26 - our
103:27 - row multiplied by our cell size
103:30 - and let's try this one now and there we
103:33 - go
103:34 - this is starting to look much nicer and
103:37 - now we have at least every second row
103:40 - working properly and everything still
103:43 - works
103:44 - okay so now all we have to do
103:47 - is if this is not the case so
103:50 - we go for an else statement
103:54 - then we want to do this entire thing
103:57 - again
103:58 - and let me copy it properly
104:03 - except now we want to check all the odd
104:06 - fields
104:07 - and this is working
104:11 - so this is looking at least a bit more
104:14 - interesting
104:15 - and there really isn't all that much
104:17 - left to go for for a proper game
104:20 - the two more things i want to add is a
104:21 - score and a sound effect
104:23 - and let's start with the score and to
104:26 - get a score we need some text
104:28 - and text and pie game needs a couple of
104:30 - steps to work
104:31 - so let's talk through them ultimately
104:33 - there are three steps we have to be
104:35 - aware of
104:36 - number one is that we have to create a
104:38 - font object and this one is going to
104:40 - determine what our text looks like and
104:42 - how large it is
104:43 - then we have to use this font to render
104:45 - some text and this is actually creating
104:47 - some text
104:48 - so for all practical purposes we are
104:49 - writing something and this text is going
104:51 - to end up on a new surface
104:53 - exactly like the pictures we have
104:55 - imported so far and then for the final
104:57 - step we have to blit the image on our
104:59 - actual game screen
105:00 - and that is pretty much it so let's
105:04 - start creating the basic score and once
105:06 - we have that we can make it look nicer
105:08 - so here we are back in the game code and
105:10 - the first thing i want to do
105:11 - in our main setup part i want to create
105:14 - a new font and i call this
105:17 - game font and to create a font we need
105:20 - pygame dot font
105:21 - dot bond and to make sure the second
105:24 - font has to start with an uppercase
105:25 - letter this one is important
105:28 - and in here we need two pieces of
105:30 - information the first one is the font we
105:32 - want to use
105:32 - and then font size font size is the
105:35 - easier part this one is just an integer
105:37 - i went with 25 and for the font
105:40 - we could just go with none and then we
105:42 - get a default font for pygame
105:44 - but i want to import a font and for that
105:47 - i need to give the name of the font i
105:49 - want to use
105:50 - and this has to be a ttf file that i
105:52 - downloaded earlier
105:54 - and you can get a ttf file really easily
105:56 - from websites like daffon.com for
105:58 - example
105:59 - and there are plenty of free ones just
106:00 - check it out but in my case
106:02 - the file is located in the folder called
106:04 - font and the name of the file
106:06 - is poets 1
106:10 - dash regular dot etf
106:13 - and with that we have imported a font so
106:16 - our text is going to look like whatever
106:17 - this one looks like
106:19 - and the size is going to be 25 so these
106:21 - are the two basic things we have to
106:23 - start with
106:24 - and now in our main class i want to
106:27 - create a new method
106:29 - and let me minimize all the other
106:31 - methods i have
106:32 - so far just to make it a bit easier to
106:35 - see what's going on
106:37 - there really is quite a bit of stuff
106:38 - going on by now
106:40 - i want to create a new method that is
106:42 - called draw
106:43 - score does not need any parameters
106:47 - and in here we have to create our score
106:50 - and there are quite a few bits of
106:51 - information we first need
106:53 - to draw all of this the first one is the
106:56 - actual
106:56 - score text so we have to figure out what
107:00 - is our actual score and put this into a
107:03 - text
107:04 - and the basic logic i went with is that
107:06 - the length of our
107:08 - self.snake.body
107:10 - is going to be our score so the longer
107:12 - our snake is the higher of a score we
107:14 - get
107:15 - so this will be the basic part that
107:16 - determines our score but we are starting
107:18 - with three blocks
107:19 - inside of our snake so i have to reduce
107:21 - this by three so that we start with zero
107:24 - but then all of this has to be a string
107:26 - so that we can
107:27 - display it easier so i put it in the str
107:30 - method
107:30 - that works very similar compared to the
107:32 - end method except now it turns any kind
107:34 - of value inside of this
107:36 - into a string instead of an integer and
107:39 - with that
107:40 - we are getting our basic score so this
107:43 - is a good way to start
107:44 - and with that i can create the actual
107:46 - score
107:47 - and this would be a score surface so let
107:49 - me write it properly
107:50 - and to create this we first need our
107:53 - game font
107:54 - so what we created down here and we want
107:58 - to render it
107:59 - and in here we need three pieces of
108:01 - information
108:02 - the first one is the text then if you
108:04 - want to end the alias it
108:06 - and then we need a color and let me talk
108:08 - for them step by step
108:10 - the first one for our text is just going
108:11 - to be our score text
108:13 - so what we created up here and for the
108:16 - color
108:16 - i am just going to go with an rgb tuple
108:18 - again which this time
108:20 - is 56 74 and 12
108:24 - which is a fairly dark color that has
108:26 - slightly more green than the other
108:27 - values
108:28 - finally we need the anti-alias text and
108:30 - this one either has to be
108:32 - true or false and anti-aliasing just
108:35 - means we make the text a bit smoother
108:37 - and unless you're working with pixel art
108:39 - or you work on a really slow computer
108:41 - this is usually best left for true and
108:44 - it makes our text look a bit nicer
108:46 - but ultimately this really isn't going
108:48 - to make that much of a difference
108:50 - especially for a simple game like ours
108:51 - so i just leave it with true
108:53 - alright now we have a text surface that
108:55 - we just have to put on the screen
108:57 - so this is going to go with screen dot
108:59 - blit
109:01 - and now we do have a score surface
109:04 - but now we need to get a position of
109:06 - this text
109:08 - and here we have to determine where we
109:10 - want to put it on our screen
109:12 - and i want to put it in the bottom right
109:14 - ish of our game
109:16 - and to get it there i'm going to add a
109:18 - few more variables
109:20 - just to make it easier to read so i
109:22 - create a scorex variable
109:25 - that is again going to be an integer of
109:28 - cell
109:28 - size times cell
109:32 - number so this would be the right end of
109:34 - the screen
109:35 - and from that i want to remove a couple
109:38 - of pixels
109:40 - so i removed 60 from there meaning that
109:43 - we go all the way to the right of the
109:44 - screen
109:45 - and then go a bit further to the left so
109:47 - we are in the right end of the screen
109:50 - and then i'm going to do the same thing
109:51 - for y that again
109:53 - i want to go all the way down to the
109:54 - bottom of the screen but now i want to
109:56 - go a bit up again
109:58 - so let's make this a bit less 240 and
110:01 - from these two bits of information we
110:03 - can create a score rectangle
110:05 - and here i want to get our score surface
110:09 - and get the rectangle around it so when
110:11 - we create this score surface with some
110:13 - text
110:13 - it has some dimensions and with get rekt
110:16 - we can access all of them
110:17 - and even better we can immediately place
110:20 - this
110:21 - rectangle somewhere on the screen and
110:23 - right now i'm placing the center
110:25 - and what we pass in here is an x and a y
110:29 - position where we want to place it
110:31 - and for this we can use these two bits
110:33 - of information
110:34 - so this would be our score
110:37 - x and score y
110:40 - and now that we have a rectangle we can
110:42 - just place this into the position for
110:44 - our screen dot blit
110:45 - and this is pretty much all we need for
110:48 - the score
110:49 - so now when we come to draw elements i
110:52 - want also to draw a score
110:55 - so self dot draw score
110:59 - and let's see if this is working and it
111:02 - is
111:02 - not because i made a typo this should
111:06 - be poet sen 1
111:09 - so now let's try this again and there we
111:11 - go in the bottom right of our screen
111:13 - we can see a number and every time we
111:15 - pick up an apple
111:16 - this one goes up and let's try one more
111:20 - and this seems to be working quite well
111:22 - cool
111:23 - so with this bit of code we get our
111:26 - score
111:27 - but by itself the score looks a bit
111:29 - bland so i want to add two things to it
111:32 - number one i want to add an apple to the
111:34 - left of it
111:35 - and number two below the score i want to
111:37 - add a plain rectangle
111:39 - so that it stands out a bit more from
111:40 - the background and both of these are
111:42 - quite easy to get
111:43 - so let's add them now so what we
111:45 - ultimately want to achieve
111:47 - is screen dot blit again and this time
111:50 - we want to use our apple again
111:52 - the one we imported down here and then
111:55 - again we need a position for the apple
111:57 - so we have to write some code for this
111:59 - position
112:00 - and the position is supposed to be at
112:02 - this apple is slightly to the left
112:04 - of our score so we have to use our
112:07 - current existing score
112:09 - and place the apple to the right of it
112:11 - which fortunately
112:12 - we can do quite easily and i think to
112:15 - make our code a bit easier i'm gonna put
112:17 - the two screened up blitz together
112:19 - and then all the setup part goes into
112:21 - one big chunk of code
112:23 - that should make it a bit easier to see
112:25 - okay what i want to do
112:26 - is apple rect to get the position
112:31 - and this is going to be our apple and
112:33 - get
112:34 - wrecked again and for this rectangle we
112:37 - don't want to place the center
112:39 - instead we want to place the mid
112:42 - right and where the mid-right is
112:44 - supposed to be
112:45 - is on the left of this apple here so
112:48 - for the x i want score correct
112:52 - dot left and for the y i want scorect
112:57 - dot center y and that's basically all we
113:00 - needed so now when we blit the apple
113:02 - we need apple and apple rect and let's
113:05 - try
113:07 - and there we go we have an apple next to
113:09 - our score
113:10 - and let me explain what happens here so
113:13 - on the score
113:14 - we place the center of our rectangle on
113:16 - these positions
113:17 - that are roughly in the bottom right of
113:19 - the screen but
113:20 - when we create our apple rectangle we
113:23 - take the mid
113:24 - right point of this rectangle we place
113:26 - it on the left of our score rectangle
113:28 - and the y position is going to be the
113:29 - middle of the score rack so what we
113:31 - effectively do is that we place the
113:33 - upper right on the same height as the
113:34 - score rack
113:35 - and the x position is going to be
113:36 - slightly to the left and with that we
113:39 - have the two basic points
113:40 - the only thing left to do is to create a
113:42 - slight background so that both of these
113:44 - stand out a bit more
113:45 - although i think by itself you could
113:47 - even leave it like that
113:48 - but um it's up to you doesn't look too
113:50 - bad right now
113:52 - so i want to create a bg rectangle for
113:54 - the background
113:56 - and this is going to be a pie game dot
113:58 - wrecked object
114:00 - and in here we need an x position a y
114:02 - position a width
114:04 - and a height so let's go through all of
114:07 - these step by
114:08 - step so our rectangle is supposed to
114:10 - start at the top left of our apple
114:13 - and these are points we can get very
114:15 - easily so i want
114:16 - apple rect dot left and for the y
114:21 - apple wrecked dot top so that our
114:24 - background starts at the top left of our
114:26 - apple
114:28 - and the height is the next easiest part
114:30 - because all we want
114:32 - is the upper rect dot height
114:36 - so our rectangle starts at the top left
114:38 - of the apple and takes the entire height
114:40 - of the apple
114:41 - for the simple reason that the apple is
114:42 - larger than the text so if we cover the
114:44 - entire apple we also cover the text as
114:46 - well
114:47 - so now we need the width and for the
114:50 - width we want to cover both the apple
114:52 - and the text so this is going to be
114:55 - our apple right dot with plus
114:59 - score rect dot with and
115:04 - this should cover the entire rectangle
115:07 - so once we have that i want to use
115:10 - pygame.draw.rect
115:12 - draw on the screen the color i want to
115:14 - go with
115:15 - is 164 209 and
115:18 - 61 so the dark grass color and i want to
115:22 - draw our bg
115:23 - rectangle and let's try this
115:26 - so if you look very closely you can see
115:28 - it especially if i go below it
115:31 - there you can definitely see it so this
115:33 - is working
115:35 - but it's very hard to see so what i am
115:37 - going to do
115:38 - is to draw a frame around this box
115:42 - and drawing a frame around the box
115:45 - is very easy to do in pie game so let me
115:47 - copy the first rectangle
115:49 - and all we have to do to draw a frame
115:51 - around it is to add another argument
115:54 - so in my case this would be two but the
115:57 - problem here right now would be
115:58 - that we have a rectangle with one color
116:00 - and the frame around it has the same
116:02 - color
116:03 - so we couldn't really see the frame and
116:05 - to fix that i'm just going to copy the
116:06 - text color
116:08 - and let's try this now so now this looks
116:12 - much better
116:13 - and now you can see that the box is a
116:15 - little bit too narrow
116:17 - so that the number is too far to the
116:18 - right and it touches the frame which
116:20 - doesn't look good
116:21 - so we have to make it slightly larger
116:24 - this is the width argument and all i
116:27 - want to do
116:28 - is to make this slightly larger so i'm
116:30 - going to add plus
116:31 - let's try six and let's try now
116:35 - and yeah this looks much better now it's
116:37 - roughly in the middle
116:39 - and there we go this is working pretty
116:42 - well
116:43 - so with that part covered we have a
116:45 - score
116:47 - and now we can work on adding some
116:49 - sounds to our game
116:51 - and adding sound in pie game is actually
116:53 - super easy
116:54 - but there's one thing you do have to be
116:55 - aware of that is a little bit annoying
116:58 - but i think it's best to jump right into
117:00 - our code and let's add the sound
117:01 - and then we can talk about the problems
117:03 - with sound and pygame
117:05 - and i only want to add a single sound
117:07 - that when our snake collides with fruit
117:09 - then we want to play a crunchy sound
117:12 - and we could add more sounds like a
117:14 - background music or game over sound but
117:16 - if you can get one sound you can get all
117:18 - of them and i don't want to over
117:19 - complicate things
117:21 - so we are just going to stick with a
117:22 - single sound
117:24 - and let's do all of this so here we are
117:27 - back in our code
117:28 - and i want to import our sound to our
117:31 - snake
117:32 - because that's the only place where we
117:33 - actually going to need it
117:35 - so right in the indent method that gets
117:37 - really extensive by now
117:39 - i want to add a new attribute that i
117:41 - call crunch
117:43 - sound and to import a sound we need
117:46 - pygame
117:47 - dot mixer dot sound
117:50 - and here again this sound has to start
117:52 - with an uppercase letter
117:53 - otherwise it's not going to work and now
117:56 - we need the file name
117:57 - and in my case i have a folder called
117:59 - sound and in there there's a file called
118:03 - crunch.wav
118:04 - and with that we have imported a sound
118:07 - so that's the first step we need
118:09 - and then for the snake i want to create
118:12 - a new method
118:13 - and let me minimize all of the
118:16 - other methods so this is a bit easier to
118:19 - see what we are doing
118:21 - okay so all the way down in this method
118:25 - i want to create a new method that's
118:26 - called play
118:28 - brunch sound and this
118:31 - only needs a single line of code we want
118:34 - self.crunch
118:36 - sound dot play and so now whenever we
118:40 - execute this method we are going to play
118:42 - the crunch sound
118:43 - and let me close the entire thing again
118:45 - and now in our main class
118:48 - when we get to check collision
118:51 - we also want to play this sound so self
118:54 - dot snake
118:55 - dot lay crunch sound
118:58 - and let's actually try this
119:04 - [Music]
119:06 - so this seems to be working but the
119:09 - problem we have
119:09 - right now is that the sound has a slight
119:13 - delay
119:14 - so that it doesn't play right when we
119:15 - eat the fruit instead it plays about
119:17 - half a second later
119:19 - which can be really weird the reason is
119:21 - that pie game first buffers a sound
119:23 - before it plays it
119:25 - and this creates a short delay between
119:26 - the chord being triggered and the sound
119:28 - playing
119:29 - but we can fix that quite easily so let
119:32 - me close
119:33 - our main class and what we have to do
119:36 - is work with pygame.init at least a tiny
119:40 - bit
119:40 - and in pygame.init there's a method
119:43 - called mixer
119:44 - and mixer is responsible for all the
119:46 - sounds and what we want to do
119:48 - is pygame.mixer.3
119:53 - init and in here there are quite a few
119:56 - arguments you could pass
119:57 - into it and it can get quite technical
120:00 - but i have found four numbers that work
120:02 - really well so these four give you a
120:04 - good sound
120:04 - and play the sound immediately but if
120:06 - you want to know more about sound in pi
120:08 - game there's the documentation that
120:09 - gives you a lot more detail
120:11 - so i would just copy the numbers and
120:13 - don't worry too much about it
120:16 - but let's try it with these numbers
120:22 - and we are getting a sound immediately
120:25 - so this
120:26 - is now working
120:30 - and with that we are nearly done there's
120:33 - one more thing i do want to cover though
120:34 - that i forgot to check
120:35 - earlier that let me go back to our main
120:41 - when we check collisions and we create
120:44 - a new fruit on the field there is a very
120:47 - small chance that our fruit
120:48 - lands on the body of our snake which
120:51 - would be very confusing
120:53 - so we have to add a little bit of extra
120:55 - code here
120:56 - that if the fruit is on the rest of the
120:58 - body of the snake we want to randomize
121:00 - it again
121:01 - so really all that we want to do is for
121:03 - block
121:04 - in self.snake.body
121:08 - and here we don't want to check for the
121:10 - hat so this would be from one
121:12 - all the way to the end with index 0
121:14 - being the head and everything else being
121:16 - the body and this is what we want to
121:17 - check
121:18 - and really what we want to check is if
121:20 - block
121:22 - is equal to self dot
121:25 - fruit dot pause
121:29 - and if that is the case we just want
121:31 - self dot
121:33 - root dot mice
121:37 - so really odd it is happening here is
121:39 - that we are checking
121:40 - every single block of our self that's
121:42 - negative body and check if it happens to
121:44 - be on the same position as the fruit
121:47 - and if that happens we want to put the
121:48 - fruit in a different place
121:50 - and that way we ensure that our fruit is
121:53 - never on top of the snake body
121:55 - and this is quite difficult to show
121:57 - because well
121:58 - it depends on a lot of random chance and
122:00 - ideally it's something we want to avoid
122:01 - happening
122:03 - but with all of that covered we have
122:04 - created a pretty nice snake game
122:07 - and there's one final thing i do want to
122:10 - change
122:11 - that whenever we die the game just ends
122:14 - which isn't ideal and really all i want
122:18 - to do is that if our player fails
122:19 - i want to put the snake back in the
122:21 - default position so we don't really have
122:23 - a game over menu instead we just restart
122:25 - the game immediately
122:27 - but you could be adding all the menus
122:29 - you wanted but i think in this case it
122:30 - doesn't really make sense
122:32 - but let's actually implement this so we
122:35 - have to go to our game over
122:37 - and see what happens in here right now
122:40 - we are just ending the game
122:42 - which well isn't great instead i want to
122:45 - get
122:47 - self.snake.reset
122:49 - so this method doesn't exist right now
122:51 - so we have to create it
122:53 - and let's close our main class and go
122:56 - back to the snake
122:58 - and here we really start to have quite a
123:00 - bit of stuff in there
123:02 - but let's add one more it's going to be
123:04 - the final one
123:05 - and i called this reset and
123:09 - what is supposed to happen here is that
123:12 - we take our initial self.body
123:16 - and just recreate the basic points so
123:19 - really we just take
123:21 - ourselves the body where we started
123:24 - and that is literally all we are to do
123:28 - and we don't even have to update the
123:30 - score because the score just checks how
123:31 - long this list is
123:33 - so we don't really have to do anything
123:35 - so let me try this now
123:38 - and our game still starts the score also
123:41 - works
123:42 - and now let me fail and we move back to
123:45 - the starting position
123:46 - so this is quite well let's try it again
123:49 - and yep it works quite well so
123:52 - most of the game is done there's one
123:55 - last thing that is a little bit annoying
123:57 - and let me illustrate this so right now
123:58 - our direction is downwards and we start
124:00 - again our snake goes downwards again
124:02 - so when we restart the game we also have
124:04 - to change the starting
124:06 - direction so all we have to do
124:09 - is go back all the way to the top and
124:11 - change this value
124:13 - and actually all we have to do is to
124:15 - change this
124:16 - to zero and zero and then let me copy
124:20 - the entire line
124:22 - and further down for the reset method
124:25 - i also want to set the direction back to
124:27 - 0 and 0
124:28 - when we reset the snake and let's try
124:31 - this
124:33 - so if i don't press anything the snake
124:35 - isn't moving if i press something
124:36 - we are starting to move
124:40 - and i can pick up a couple of apples the
124:43 - score is working
124:45 - if i go game over our snake isn't moving
124:47 - again
124:48 - and only if i start pressing the button
124:50 - it is starting to work
124:52 - so all of this is working really well
124:55 - and well that is it for the entire game