00:09 - hello there in this tutorial we are
00:12 - going to be creating breakout in pygame
00:15 - and for this project i really wanted to
00:17 - make sure to include graphics updates
00:19 - sounds and all the stuff that makes the
00:21 - game actually look good so we don't just
00:23 - have a boring game that is well just a
00:26 - demo
00:27 - and all of this is going to be part of
00:28 - this tutorial and i guess there really
00:30 - isn't that much else to talk about so
00:33 - let's jump straight into the first part
00:36 - the project setup
00:37 - i already have a couple of things ready
00:39 - in the project so i don't have to type
00:41 - out some boring bits
00:43 - and before we are going to look at our
00:45 - code we have to talk about the folders
00:48 - let's have a look at those
00:51 - i have one folder with three subfolders
00:54 - we have code graphics and sounds and
00:58 - code right now has two files main and
01:01 - settings i will have a look at those in
01:03 - just a second
01:04 - besides that we have sounds and graphics
01:07 - sounds is the easier one we just have a
01:10 - couple of sounds that's basically all it
01:12 - is
01:13 - the graphics folder is a bit more
01:15 - extensive because we do have quite a bit
01:17 - in here
01:19 - so we have blocks other and upgrades
01:22 - now other is quite simple we just have a
01:25 - couple of basic images
01:26 - and besides that upgrades has a couple
01:29 - more images that really isn't anything
01:31 - complicated
01:33 - now the one more complex folder is
01:35 - blocks because what we have in here is a
01:37 - lot more folders for each color and the
01:40 - player and then inside of each of these
01:42 - folders
01:43 - we have a lot of smaller graphics i will
01:46 - explain later what they actually do
01:49 - we basically use them to create a proper
01:52 - surface for each of the blocks in the
01:54 - player
01:55 - this is basically all we are going to
01:57 - need for this entire project and we are
01:59 - going to work in code entirely so in
02:02 - here is where we are going to do
02:03 - everything and with that
02:06 - lets have a look at main and settings
02:08 - and here i have both of these files open
02:11 - and if i run all of this
02:13 - we can see a plain black window that
02:15 - doesn't really do anything right now
02:18 - and i guess before we properly start
02:20 - with this project let's talk through
02:22 - what we already have main.pi is the main
02:26 - file and this is much more important
02:29 - settings.pi right now
02:31 - only has the window width and the window
02:33 - height so that determines the width and
02:35 - height of the window that one should be
02:36 - fairly obvious
02:38 - and this is what we're importing up here
02:41 - now besides that we're importing pygame
02:43 - and sys to make pygame run and time we
02:46 - are going to use for delta time
02:48 - and then
02:49 - we have a fairly simple class
02:52 - and once we are creating this class down
02:54 - here we are creating one instance and
02:56 - then we are calling the run method of
02:58 - this class so let's have a look what
03:00 - happens inside of the class it's not
03:02 - very much right now
03:04 - in the end it method so up here
03:07 - we are essentially just initiating
03:09 - pygame and creating a display surface
03:12 - with the window width and the window
03:13 - height from settings
03:16 - and then in the run method we are using
03:19 - this last.time here along with these two
03:23 - lines
03:24 - to get delta time
03:26 - and then delta time later on is going to
03:28 - be used to update all of the elements in
03:30 - the window and besides that we have our
03:33 - event loop that right now only checks if
03:35 - we are closing the window
03:37 - and all the way at the end
03:40 - we are updating our window so we are
03:42 - drawing whatever we created but right
03:44 - now we haven't created anything so all
03:46 - of this is black
03:48 - and this is our entire setup for now
03:50 - it's really simple and just about the
03:52 - most basic setup for pygame you can have
03:55 - if none of what i have just said made
03:57 - any sense check out my introduction to
03:59 - pygame it is going to explain all of
04:01 - this in quite some detail
04:04 - and i guess for this section let's add a
04:07 - really quick challenge that should be
04:09 - fairly easy so right now if i run this
04:12 - code we can see in the top left we have
04:14 - pygame window and i want to rename this
04:17 - to breakout or to really any kind of
04:20 - custom string i don't really care so
04:22 - much what it is and try to do this
04:24 - yourself and see how far you get
04:29 - in the init method
04:31 - we have to call pygame dot display
04:35 - dot set underscore caption
04:37 - and then here we have to pass in a
04:39 - string in my case breakout and that is
04:42 - going to rename the caption of the game
04:44 - so now we have breakout which looks a
04:47 - little bit better
04:49 - all right so with that we have the first
04:52 - section covered
04:53 - and the first major section i do want to
04:56 - work on is to create the background and
04:59 - this by itself isn't terribly
05:01 - complicated but there's one major issue
05:04 - that we do have to work on
05:06 - that the background image always has to
05:08 - cover the entire window if it didn't do
05:11 - that it would look a bit weird
05:13 - so we have to scale the background image
05:15 - but when we are scaling it we want to
05:18 - make sure we have a constant aspect
05:20 - ratio so we're not squishing the image
05:22 - or making it wider or narrower than it's
05:24 - supposed to be
05:26 - now what does that actually mean in
05:27 - practice and let me illustrate
05:30 - here we right now have our window or a
05:33 - box that has the same size as our window
05:35 - and we have the background
05:37 - and this background we want to stretch
05:40 - and we can stretch this in a couple of
05:41 - different ways we could for example
05:44 - stretch it like this
05:46 - which in this case would work but it
05:49 - would stretch the image a tiny bit which
05:52 - i don't really like
05:53 - instead what i want to do
05:55 - i want to scale this thing with a
05:57 - constant aspect ratio
05:59 - so that it grows in width and height at
06:02 - the same speed
06:04 - and this i feel looks nicer although in
06:08 - our case the background is so abstract
06:10 - it really doesn't matter very much
06:12 - but this is essentially what i want to
06:14 - achieve
06:15 - so let's try to implement all of this
06:17 - and let's see how far we get here i am
06:19 - back in the code and the first thing i
06:22 - want to do is to create another section
06:25 - in the ended method
06:27 - and let's call this one background
06:30 - and all i really want to do in here is
06:32 - create another attribute called self bg
06:35 - and this bg is going to be created in
06:38 - another method that i called create bg
06:41 - and this needs to be self dot create bg
06:44 - so now we have to create this method so
06:48 - define create bg
06:51 - and the only argument we need in here is
06:53 - self because we don't pass anything else
06:55 - in there and now first of all
06:58 - we have to actually import an image that
07:01 - i want to store in bg original
07:04 - and this we get with pygame.image.load
07:08 - and i want to go up a folder i want to
07:11 - go to my graphics folder
07:13 - and there we have a folder called other
07:15 - and in there we have bg.png
07:18 - and don't forget to convert this one for
07:20 - pygame to run a bit better
07:22 - and now what we can do just to get
07:25 - started i want to return this bg
07:28 - original meaning that after we have run
07:31 - this our bg gets this surface
07:34 - and right now all of this is a bit of a
07:36 - pointless setup but we are going to add
07:38 - a bit more in this method in just a
07:40 - second for now i just want to make sure
07:42 - this is working so now essentially what
07:45 - i want to do
07:46 - in my game loop before we are updating
07:48 - the window
07:50 - let's call it draw the frame
07:54 - and in here all i really want to do is
07:56 - self dot display surface dot lit
07:59 - self dot bg at the coordinate zero and
08:02 - zero and let's see what we get
08:06 - and there you can kind of see the issue
08:08 - we just had that our background doesn't
08:11 - cover the entire window which well looks
08:14 - kind of bad
08:15 - and there's one easy thing you could be
08:18 - doing
08:19 - so
08:19 - right now we want to scale our bg
08:22 - original and the result i would like to
08:25 - store in let's call it scaled vg
08:28 - and to scale anything in pi game we need
08:30 - pygame dot transform dot scale
08:35 - and in here we need two arguments we
08:37 - need a surface and we need let's call it
08:39 - a new scale
08:41 - now the surface we already have that's
08:43 - our bg original
08:46 - and the new scale would better be named
08:49 - new size actually
08:51 - because this one is going to be a
08:52 - trooper with a width and a height
08:55 - so for example what we could be doing we
08:57 - could copy the entire width of our
08:59 - window and place those two arguments in
09:03 - here
09:05 - and now if we are returning scaled bg
09:08 - what we get
09:10 - is something that fills our entire
09:11 - window
09:13 - the problem now is that we are squishing
09:15 - our image so this image is more narrow
09:18 - than it's actually supposed to be
09:20 - which in this case isn't too much of a
09:22 - problem but in lots of other games it
09:24 - would look very silly
09:26 - so this is something i want to work on
09:29 - but if you want to leave it like this
09:30 - that's also totally fine
09:32 - and let me explain by illustrating the
09:35 - original image so bg original
09:39 - essentially what i would like to do in
09:40 - here i have the height of this
09:44 - image available this is something pi
09:47 - gain can give me
09:48 - let's call this one h
09:51 - and i want to multiply this one by a
09:54 - certain number let's call it the
09:55 - question mark for now
09:57 - and the result
09:59 - of this multiplication should give us a
10:02 - new surface that has the height of this
10:06 - entire window
10:08 - and let's call this one h
10:10 - w
10:11 - and once we have this number
10:14 - i want to multiply this with the width
10:17 - of this image as well so this entire
10:20 - thing here
10:22 - is also going to be multiplied with this
10:24 - yellow question mark and that way we are
10:26 - scaling both the height and the width by
10:28 - the same number
10:29 - so the aspect ratio of this image is not
10:32 - going to change
10:33 - so the question then is how can we get
10:36 - this question mark
10:37 - and i always feel like plotting in real
10:40 - numbers here is the best way to think
10:41 - about it
10:42 - and the height of the image we have
10:44 - right now is 512
10:47 - and the height of the entire window is
10:50 - 720
10:52 - so essentially what we need to figure
10:54 - out is 512 multiplied by what number
10:58 - gets us to 720
11:02 - and this is the sort of thing that's
11:04 - really easily solvable
11:06 - essentially all we have to do is the
11:09 - question mark is going to be 720
11:13 - divided by
11:14 - 512
11:17 - so we just move to 512 to the other side
11:21 - and that way we are going to get the
11:23 - number of our question mark
11:25 - and the number we would be getting here
11:27 - is something like 1.5
11:30 - so i essentially want to multiply this
11:32 - 512 by 1.4
11:34 - and i also want to multiply the width of
11:36 - this image by 1.4
11:39 - and well that is basically all we are
11:42 - going to need
11:43 - now with that in mind let's implement
11:45 - all of this
11:46 - and i would actually recommend you to
11:49 - try to implement this one yourself so
11:51 - now you know the basic theory this
11:53 - shouldn't be too difficult to implement
11:59 - first of all i want to get some kind of
12:01 - scale vector so that's the 1.4 i just
12:05 - got
12:06 - and in here we want to get the window
12:09 - height
12:10 - and divide this by the height of our
12:12 - background and this we get with dot get
12:16 - underscore height
12:18 - so now we can print our scale vector and
12:22 - let's see what we get and what we get is
12:25 - 1.4 and a tiny bit so this is looking
12:29 - really good
12:30 - so now we can create a scaled width and
12:34 - a scaled height
12:37 - and basically what we are going to do in
12:39 - here i want to get my bg original
12:43 - and get the width
12:45 - and multiply this by the scale factor
12:49 - and the same thing i can do with the
12:51 - height so bg original dot get underscore
12:55 - height
12:57 - and i want to multiply this by the scale
12:59 - factor as well
13:01 - and now finally i can uncomment my
13:04 - scaled bg and i don't want to pass in
13:07 - window width and window height
13:09 - instead i want to pass in my scaled
13:12 - width and my scaled height
13:16 - and now return the scaled vg
13:20 - and let's see what we get
13:22 - and this one is looking significantly
13:24 - nicer
13:25 - it's probably kind of hard to see but it
13:28 - does look better and it's one of those
13:30 - many small differences that all combined
13:32 - really makes the game look nicer
13:35 - but alright
13:36 - with that we have our background so
13:39 - that's a pretty good start
13:41 - so now that we have that we can start
13:43 - work on the player at least to a certain
13:46 - extent let me explain what we are going
13:48 - to do
13:50 - what i want the player to be able to do
13:51 - for now
13:52 - is that the player can accept some input
13:55 - the player can use that input to move
13:56 - around the player is going to be
13:58 - constrained to the window and that's
14:00 - kind of all we are going to do
14:03 - later on the player is also going to
14:05 - receive graphics and lasers but i don't
14:08 - want to get ahead of myself let's keep
14:10 - it a bit more focused so let's just work
14:13 - on these three parts for the player and
14:16 - none of them is particularly difficult
14:18 - so let's jump straight back into the
14:20 - code and here we are
14:23 - and what i basically want to do is to
14:26 - create a new python file and this one i
14:29 - am going to save as sprites dot pi
14:32 - because in here we are going to have all
14:35 - of our sprites for the ball the player
14:37 - the blocks basically everything
14:39 - and this one is going to import my game
14:43 - and from settings import star
14:46 - and now i want to create a class i
14:50 - called player and this should be spelled
14:54 - properly and this one has to inherit
14:56 - from pygame.sprite
14:59 - and now we are going to need an init
15:02 - method for this setup
15:05 - and this one for now is only going to
15:08 - need groups so the groups we want to
15:10 - place this sprite in and which group we
15:13 - would like to place it in we get in the
15:15 - dunder for super init
15:18 - method
15:19 - and in here if we add groups as an
15:21 - argument
15:22 - high game is automatically adding this
15:24 - player to whatever group we pass in here
15:26 - which is really handy
15:29 - and now
15:30 - i want to let's call it setup
15:34 - so i want to add
15:36 - self.image
15:38 - and for now this image is just going to
15:40 - be pygame dot surface
15:44 - and now we need a width and a height
15:47 - and both of these sizes should be
15:49 - relative to our window which basically
15:52 - means that i want the width of the
15:53 - player to be ten percent of the window
15:55 - and the height of the player should be
15:57 - five percent of the window height
15:59 - and achieving that is kind of simple
16:03 - because we already know the window width
16:05 - and the window height
16:06 - and basically all i want to do is i want
16:09 - to get my window width
16:12 - and floor divide this by 10
16:14 - and that way i get 10 of my window
16:17 - height as a nice integer that is a bit
16:19 - easier to work with although you could
16:21 - also just divide this it doesn't matter
16:23 - that much
16:24 - and for the height i want to get my
16:26 - window underscore height
16:28 - i am terrible at spelling that
16:31 - and flow divide this by 20
16:33 - and that way we get 5 percent of the
16:35 - window height
16:36 - and that is all we needed
16:39 - so now i want to get myself.image and
16:42 - fill this one with a red color
16:45 - now the color here doesn't actually
16:47 - matter that much because we are going to
16:49 - replace all of this later on anyway for
16:52 - now i just want to make sure it's not
16:54 - black which would look a bit boring now
16:57 - we have our image next up let's add a
17:00 - position comment in here and i want to
17:03 - actually place this surface
17:05 - and for that we need self.rect
17:08 - and this we get with
17:10 - self.image.getunderscorerect
17:13 - and in my case i want to place the
17:15 - center of this surface and for this one
17:18 - i need x and y
17:22 - and for the x-coordinate i want this to
17:24 - be straight in the middle of the window
17:26 - so
17:27 - window width
17:29 - and divide this by two
17:31 - i guess to stay consistent let's flow
17:33 - divide this but this one really doesn't
17:35 - matter
17:36 - now for the y position let me draw what
17:39 - i would like to do this here is going to
17:42 - be our entire window
17:44 - and my player i would like to be
17:47 - somewhere here ish
17:50 - with some kind of offset from the bottom
17:53 - and in my case i always want there to be
17:55 - a 20 pixel offset between the bottom of
17:58 - the player and the bottom of the window
18:01 - i guess if the window gets really large
18:03 - or really small this might be an issue
18:04 - but i think this is generally a good
18:06 - number
18:07 - so how can we implement this
18:10 - and well the easiest way is that this
18:12 - center isn't perfect here it should
18:14 - instead be mid bottom
18:17 - meaning now we don't place the center of
18:19 - this rectangle we place the middle of
18:21 - the bottom side
18:23 - and now basically what we can do we can
18:25 - get to window height
18:28 - and from that subtract 20 pixels
18:32 - and that way when we are placing this
18:34 - rectangle there is going to be this
18:35 - distance between the bottom of the
18:37 - player and the bottom of the window so
18:39 - with that we have a very basic sprite
18:42 - for our player
18:43 - let's actually display it in main.pi and
18:46 - see how this looks
18:48 - and this could be a challenge for you
18:50 - try to display this sprite on the window
18:53 - it doesn't have to do anything for now
18:55 - just see if we can actually use a sprite
19:00 - first of all we have to import this
19:02 - sprite so from sprites import player
19:08 - and now to actually use this sprite
19:11 - we have to place it inside of a sprite
19:13 - group so let's call it here group setup
19:18 - and let's be a bit more specific sprite
19:20 - group setup
19:21 - because later on we are going to have
19:23 - quite a few different spread groups
19:26 - but for now
19:28 - what i want to create is self dot all
19:31 - sprites
19:32 - and this one is just going to be
19:34 - pygame.sprite.group
19:38 - and we are going to place every single
19:40 - sprite inside of this group
19:42 - and this group will then draw and update
19:44 - every single sprite and any other group
19:47 - we are going to create later we'll just
19:49 - check which kind of group another sprite
19:51 - belongs to to check what they are
19:53 - supposed to do
19:55 - but none of them are going to update or
19:57 - draw anything
19:59 - and now
20:00 - let's
20:01 - create another comment
20:04 - and let's call it the setup for sprites
20:08 - and basically what i want to do is self
20:11 - dot player
20:13 - is going to be the player class and in
20:16 - here we need one argument that is groups
20:20 - and i only have a single group and that
20:22 - is all sprites so this is what i want to
20:25 - pass in here
20:26 - and if i run this now we can see nothing
20:30 - because we have to draw
20:32 - all sprites so self dot all sprites dot
20:37 - draw
20:38 - and i want to draw this on self dot
20:40 - display
20:42 - underscore surface
20:44 - and now if i run this we can see our
20:47 - player this one is already looking not
20:49 - bad at all
20:50 - so now our player can be seen
20:53 - and to move it first of all
20:55 - we need to get some kind of input
20:58 - so for that
20:59 - i am going to create another method i
21:01 - called input and this one doesn't need
21:03 - any arguments
21:04 - and now
21:06 - i want to get every possible keyboard
21:08 - input so pygame dot key dot get
21:12 - underscore
21:13 - rest
21:14 - and now i want to check if inside of
21:17 - this list we get the right or the left
21:19 - keyboard and if we don't get either of
21:21 - those we are not going to do anything
21:24 - but if the player is pressing right or
21:26 - left i want to give my player a
21:28 - direction and this direction has to be
21:30 - stored in the class itself as an
21:32 - attribute so let's create
21:35 - self.direction
21:37 - and this one i'm going to create as a
21:40 - vector so pygm.math.vector2
21:43 - and this one by default can be left
21:45 - empty so it's 0 and 0.
21:47 - and now if ease
21:50 - and
21:51 - igame dot k underscore right
21:55 - then self dot direction
21:59 - is going to be 1
22:01 - and now we can copy all of this
22:04 - turn this into an l if if the player is
22:07 - pressing
22:09 - left
22:10 - and if that is the case x should be
22:12 - negative one
22:14 - and finally if neither of those are the
22:16 - case then
22:17 - self.direction is going to be zero
22:21 - so basically all we are going to do here
22:24 - is if the player is pressing right we
22:26 - have a positive direction
22:28 - if the player is pressing left we have a
22:30 - negative direction
22:31 - and if the player is pressing neither of
22:33 - those two we have no direction at all
22:35 - and now that we have that
22:37 - we have to create an update method not
22:41 - upgrade update
22:43 - and this one itself and importantly we
22:46 - are also going to need delta time
22:48 - because remember
22:50 - we want to move this thing with delta
22:52 - time and we don't have any clock so our
22:55 - game runs as fast as our computer can
22:57 - run it
22:58 - so if we didn't use delta time our game
23:01 - would not be running at a constant speed
23:04 - which would be kind of a problem
23:06 - but this we can account for
23:09 - now in the input method first of all i
23:11 - want to get myself.input
23:14 - and now
23:15 - we have our direction
23:17 - now what you could be doing now is
23:20 - something like self.reg.x
23:22 - plus equal
23:24 - self.direction
23:26 - multiplied by some kind of speed and
23:30 - multiply this by delta time
23:32 - but this wouldn't be a good approach
23:34 - although speed we do want to use let me
23:36 - actually create this one so self.speed
23:39 - by default i have set to 300. so this
23:41 - one we can keep as it is so self.speed
23:44 - is totally fine
23:46 - the problem we have now is that using
23:48 - self.direct.x and adding numbers to it
23:51 - is not a good way to move anything in
23:53 - pygame
23:54 - because rec.x for the position only ever
23:57 - stores integers
23:59 - and this number here is going to be some
24:01 - kind of float
24:03 - so if we were to use this number by
24:05 - itself as the position for the rectangle
24:08 - we would be losing information
24:10 - and the way around this is to create
24:12 - another attribute that i called
24:15 - self.position
24:16 - and this is going to be another vector
24:18 - so pygame.math.vector2
24:22 - and by default the position of this
24:25 - vector
24:26 - itself.rect.top left
24:28 - so the top left position of this
24:31 - rectangle and let me place the vectors
24:34 - right next to each other
24:36 - and the vector can still floating point
24:37 - information totally fine
24:39 - so essentially what we are going to do
24:42 - is self.pause dot x
24:44 - plus equal
24:46 - all of this
24:48 - and that way we are not going to lose
24:49 - the information after the decimal point
24:52 - and once we have that
24:54 - we are going to set self.direct.x
24:57 - to the rounded version of self.s
25:01 - and this round here is not strictly
25:03 - necessary but it is kind of helpful
25:07 - because when we set rec.x and we pass in
25:10 - a floating point number
25:12 - highgame drops any value after that
25:14 - period
25:15 - so for example if we had 1.9 in
25:18 - self.post.x
25:20 - self.react.x would just turn this into a
25:23 - one
25:24 - and if we are rounding all of this this
25:26 - one becomes a 2
25:28 - which is the much better number here
25:31 - so alright with that we should be having
25:34 - some kind of movement
25:36 - except there's one thing i forgot we
25:38 - have to in our game loop
25:41 - update the game
25:43 - and all this really means is self dot
25:46 - all sprites dot update
25:49 - and in here we have to pass in delta
25:51 - time
25:52 - and let's see if this is working
25:55 - the game does it for an error and if i
25:56 - press right
25:57 - now we get an error the problem starts
26:00 - in the update method
26:02 - and in here
26:05 - high game has the problem that int
26:07 - object has no attribute x so for some
26:10 - reason it thinks this direction dot x is
26:14 - an integer
26:15 - and the reason for that happens down
26:17 - here
26:18 - that if we don't press left or right
26:20 - we are setting self.direction to zero
26:23 - which isn't what i intended instead we
26:26 - have to set self.direction.x
26:28 - to zero so we want to set one part of
26:31 - the vector to zero
26:32 - we do not want to set the entire vector
26:34 - to the integer zero which would be well
26:37 - pointless and i guess while we are here
26:39 - there's another thing i did forget
26:41 - that
26:42 - this is going to throw an error as well
26:45 - because right now
26:46 - this is going to be an integer this is a
26:49 - vector
26:50 - this is an integer and this is a
26:52 - floating point number
26:53 - the problem is
26:55 - we couldn't really add a vector to an
26:58 - integer
26:59 - pygame just wouldn't know what to do
27:01 - with it
27:02 - and this well has to be self.direction.x
27:06 - and now this should be working so now i
27:10 - can move around and this is working
27:12 - totally fine
27:13 - and it feels very smooth so that's a
27:15 - pretty good start
27:17 - now the problem we have is that our
27:19 - player can move outside of the window
27:21 - which doesn't feel good at all
27:26 - so that's the thing we have to work on
27:28 - now
27:29 - and all of that is just going to be
27:32 - another method that i called screen
27:35 - constraint
27:36 - we need self and nothing else
27:40 - and now we have to figure out the basic
27:42 - logic in here
27:44 - and i think this one could also be a
27:47 - pretty good challenge for you so try to
27:50 - figure out the method here that our
27:51 - player cannot leave the window
27:55 - it shouldn't be too hard if you want to
27:58 - tip basically all you want to do if the
28:00 - player is too far to the right you want
28:02 - to set it to the right of the window and
28:04 - then the counter side for the left if
28:06 - the player is too far left you want to
28:07 - set it to zero it's kind of all you need
28:10 - to do so try to figure out how to
28:11 - implement this one yourself
28:16 - basically all i want to do is if
28:18 - self.rect.write
28:21 - is greater than the window with
28:25 - and if that is the case
28:27 - self.rect.write
28:30 - should be equal to the window width
28:34 - so basically all this means if this here
28:38 - again
28:39 - is our entire window
28:41 - variable drawing
28:43 - and our player is
28:45 - here ish
28:47 - if that is the case essentially what i
28:49 - want to do i want to take this side here
28:52 - and place it on the right side of the
28:55 - window
28:56 - and that way whenever the player gets
28:58 - too far to the right the player is put
29:00 - on the right side of the window so it
29:02 - feels like the player can never leave
29:04 - although there's one more thing that we
29:06 - do need
29:07 - we have to update this position.x as
29:09 - well
29:11 - which just means self.pos.x
29:14 - is going to be self.rect.x
29:18 - and if we didn't do that pi game might
29:21 - get confused where these points are in
29:23 - relation to each other so this position
29:25 - on x needs to be in the top left of the
29:27 - rectangle
29:28 - and well once we have that we have to do
29:31 - the same thing for the other side so
29:34 - self.direct.left
29:35 - is smaller than zero
29:38 - and if that is the case
29:41 - self.rect.left
29:42 - is going to be 0
29:44 - and
29:45 - self.post.x
29:46 - is going to be self.rect.x
29:49 - so now i just have to call
29:51 - self.screenconstrained
29:54 - and let's see if this is working
29:56 - so now the game still runs and if i get
29:58 - too far to the right i can't go any
30:00 - further
30:02 - and if i go all the way to the left
30:06 - this is also still working
30:08 - cool
30:10 - so this one is working just fine
30:14 - but now that we have that part we can
30:17 - start working on the ball and this one
30:20 - is going to need a couple of things
30:21 - let's talk about them
30:23 - first of all the ball needs to move
30:25 - around this one is fairly easily
30:27 - implemented it's going to be fairly
30:29 - similar compared to the player
30:31 - the more complicated part is the
30:33 - collision that the ball needs to be able
30:35 - to collide with the player and with the
30:37 - edges and later on also with all the
30:39 - blocks we are going to create
30:42 - which means that we are going to need
30:44 - collisions with both static and moving
30:46 - obstacles
30:47 - which is quite a complicated topic as a
30:50 - matter of fact i have just made a whole
30:52 - video about it
30:54 - so for this video i am going to go over
30:56 - the theory in a bit but if you want more
30:58 - detail check out the other video it's
31:00 - going to go over this in much more
31:02 - detail and finally the ball is also
31:06 - going to get an actual image which is
31:08 - well super easy to implement but i did
31:11 - want to mention it
31:13 - and finally
31:14 - the ball also needs to be active and
31:16 - passive now what that basically means is
31:19 - that if the ball is active it's moving
31:21 - around the window and if it is passive
31:24 - it's always stuck to the player
31:26 - and only once the player presses a
31:28 - button then the ball gets active again
31:30 - and that is going to be quite a large
31:33 - section so let's work on implementing
31:36 - all of this
31:37 - here i'm back at main.pi and i want to
31:39 - look at my sprites
31:41 - and right now we only have player but i
31:44 - want to create a second class called
31:46 - ball
31:47 - and this one is also going to be a
31:49 - sprite so pygame dot sprite dot sprite
31:53 - and now for the
31:55 - init method
31:57 - we need self and then we also need to
32:00 - know what groups the ball should be in
32:03 - but on top of that we also need to know
32:05 - where the player is because the ball is
32:08 - supposed to collide with the player so
32:10 - this one is going to be passed in there
32:12 - as well and later on we are going to add
32:15 - the obstacles as well but for now we
32:17 - don't have them
32:19 - and now in here i want my super done
32:22 - there init method
32:24 - and pass in the groups in here as well
32:29 - and now
32:31 - we can let's call it a graphics setup
32:35 - and all this really means is i'm going
32:37 - to set self.image
32:40 - and self.image is going to be
32:41 - pygame.image.load
32:44 - and i'm just going to load from the
32:46 - string that is one fold up graphics
32:50 - other
32:52 - and in there we have ball dot png
32:55 - and let's fix the typo
32:58 - and add convert underscore alpha and
33:02 - that should be all we need
33:04 - and besides that
33:07 - i also want to have a position set up
33:10 - and this one is going to be fairly
33:12 - similar compared to the player let me
33:14 - open it just for the init method
33:18 - so we're going to need a rectangle a
33:20 - direction a position and a speed
33:23 - as a matter of fact let me copy
33:26 - all of them and let me pass them in here
33:29 - i guess you could be working with
33:30 - inheritance but i do want to overwrite
33:32 - most of them anyway so there's not much
33:35 - point to that let's go for them one by
33:36 - one for the rectangle by default
33:39 - basically what i want if this here is my
33:43 - ball
33:44 - i want this ball
33:46 - to be
33:48 - right on top of the player
33:50 - which essentially means
33:52 - that the mid bottom
33:54 - of the ball
33:56 - should be in the exact same position
33:58 - as the top mid of the player that
34:02 - is
34:03 - really easy to implement but we do need
34:05 - to know where the player is
34:07 - let me add another section and let's
34:08 - call this one collision
34:11 - objects
34:12 - and in here all i really am going to do
34:14 - is self.player is going to be player
34:18 - which is the argument we get from up
34:20 - here
34:22 - and now
34:23 - for my rectangle i want to place the mid
34:26 - bottom
34:27 - and the mid bottom
34:29 - should be in the position of player
34:31 - direct dot mid top
34:34 - and i guess the one part of this codec
34:37 - can stay the same is position this one
34:39 - should always be the top left of the
34:41 - rectangle by default
34:43 - the other two arguments direction and
34:45 - speed we do have to change the ball
34:48 - speed i have set to 400
34:52 - and for the direction i did make some
34:54 - changes and in here we basically need x
34:58 - and y
34:59 - now y is the easy part by default this
35:02 - one should be negative one because the
35:04 - ball once we started should go up if it
35:07 - went down it would be kind of weird
35:10 - but for the x i want to have a random
35:12 - number that is either one or negative
35:15 - one so if the player starts the ball it
35:17 - should go left or right randomly
35:19 - and since we now have random numbers
35:22 - we need from random import
35:26 - in my case i went with choice
35:28 - and all i really want to do in here is
35:31 - choice
35:32 - and into choice we have to pass a tuple
35:34 - with our choices which in my case is one
35:37 - and negative one
35:39 - so our direction when we spawn the ball
35:42 - is going to be negative 1 in the y
35:43 - direction
35:44 - and it is going to be either 1 or
35:46 - negative 1 in the x direction
35:48 - the one final part for the init method
35:51 - is active which really just means
35:54 - self.active
35:56 - and by default this one is going to be
35:57 - false
35:58 - so now we have all we need to get
36:01 - started
36:02 - now to actually move the ball we need
36:04 - again the update method that needs self
36:07 - and delta time just like the player did
36:10 - and in here the first thing i want to do
36:13 - is if self dot active
36:16 - then i want to for now it's going to be
36:18 - pass but this one is going to be quite a
36:21 - bit of stuff later on
36:23 - but if the ball isn't active so else
36:27 - then i just want to set self.rect.mid
36:31 - bottom
36:33 - to self.player.rect.mid
36:36 - top
36:38 - and don't forget self.pause
36:41 - also needs to be updated and this one is
36:43 - just always going to be
36:44 - pygame.math.vector2
36:48 - and
36:49 - self.direct.top left
36:51 - so basically all we are going to do in
36:54 - the update method for now
36:56 - is that
36:57 - the mid bottom of the ball is always
37:00 - going to be moved wherever the mid top
37:02 - of the player is and that way if we are
37:04 - moving the player the ball is going to
37:06 - be moved along with it and again we
37:09 - always have to update position
37:11 - otherwise we are going to get some weird
37:12 - behavior later on
37:14 - and all right this one
37:17 - is a good start let's actually see if
37:20 - this one is going to work so in my
37:22 - main.pi file besides player i also want
37:26 - to import ball
37:27 - and now in our setup
37:30 - i want to create another attribute
37:32 - called self.ball
37:34 - and this one is going to be ball
37:37 - and in here let me copy the parameters
37:39 - we need groups and we need our player
37:42 - groups is going to be self dot all
37:45 - sprites
37:46 - and player is just going to be
37:49 - self.player
37:50 - and now let's see if this is going to
37:52 - work and this one already looks pretty
37:54 - good and if i move left and right
37:56 - the ball is going to move along with it
37:59 - so this is working just fine cool and
38:03 - now that we have that
38:06 - we can look at our ball and work on what
38:10 - happens when this active is going to be
38:12 - true actually we can do this right now
38:15 - in my main.pi
38:16 - i want to check if the player is
38:18 - pressing the space button
38:20 - and if the player has done that i want
38:22 - to set
38:23 - this self.active to true
38:26 - and this could be a good challenge so
38:29 - try to implement this one yourself that
38:31 - if the player presses space self.active
38:33 - should become true
38:38 - alright what i want to do in main.pi i
38:42 - have my event loop and since i don't
38:45 - really check for that much input i can
38:47 - just add
38:48 - another event type in here
38:50 - so event or type
38:52 - is equal to pygame dot e down
38:56 - so now i am checking if any button was
38:59 - pressed inside of that i want to check
39:01 - for one specific key so if event key is
39:05 - equal to pygame dot k underscore space
39:09 - and if that is the case self dot ball
39:13 - dot active
39:15 - should become true
39:17 - let's try the game is still running i
39:20 - can move around but now if i press space
39:24 - the ball is stuck in mid air while my
39:27 - player keeps on moving
39:29 - the reason for that
39:32 - is
39:33 - this line here
39:35 - for now we are only updating the ball
39:37 - position
39:38 - if self.active is false if it is true we
39:42 - don't do any of that so the ball just
39:44 - remains constant
39:47 - and in here for now what we could be
39:50 - doing
39:50 - is self dot pos
39:53 - plus equal self self.direction
39:57 - multiplied with self.speed
40:00 - and multiplied with delta time
40:03 - and this is going to work but you see in
40:06 - a second why this isn't a good start so
40:08 - now i can move around and if i press
40:10 - space
40:13 - nothing is happening because i forgot
40:14 - one line
40:16 - so right now we are just setting the
40:18 - position we're not actually updating
40:20 - this rectangle which actually places
40:22 - this sprite so we have to check
40:26 - self.rect.top left
40:28 - is going to be
40:30 - round self.post.x
40:34 - and round
40:37 - dot self.pos.y
40:38 - and i guess we can put all of this into
40:40 - one tuple to make it look a bit nicer
40:44 - and now this should be working so i can
40:46 - move around if i now press space
40:49 - the ball is just moving into space so
40:52 - not particularly helpful
40:55 - and the problem we have here is that
40:57 - there's no collision whatsoever
41:00 - and this we are going to address in just
41:03 - a second
41:04 - although before i'm going to do that
41:07 - there's another thing i would like to
41:09 - add
41:10 - and that is that i want to normalize my
41:13 - direction
41:14 - so
41:15 - this direction here
41:17 - now what does that actually mean to
41:19 - normalize a vector
41:21 - so right now our direction is always
41:23 - going to be one or negative one
41:25 - and let's say we have a vector that
41:27 - moves in the direction of one purely
41:29 - upwards so this is one
41:32 - and then we have another vector that
41:34 - just moves to the right
41:36 - by a speed of 1 as well
41:38 - in both of those cases we are going to
41:40 - cover the same distance
41:42 - the problem we have now though is if we
41:45 - move both up and to the right at the
41:47 - same time
41:48 - you would assume we are going to move at
41:51 - a distance of 1.
41:54 - but that isn't actually the case
41:57 - if we get both of these speeds we are
41:59 - actually moving
42:00 - by something like 1.4
42:04 - so this ball if it moves diagonally
42:06 - would move 40 faster than if it went
42:08 - just up or left
42:10 - which in our case isn't going to be that
42:13 - much of a problem because the ball is
42:15 - always going to move diagonally but it
42:17 - still doesn't feel good to have
42:19 - something like this in there because it
42:21 - might change the speed of the ball
42:22 - without you intending to do so so we do
42:25 - want to address it all we really have to
42:27 - do is self dot direction is going to be
42:30 - self.direction.normalize
42:34 - although this by itself is not going to
42:36 - work
42:37 - because there is a chance that this
42:39 - direction might be zero in our case
42:42 - again not particularly likely but it
42:44 - might be the case
42:46 - and if the direction is zero you cannot
42:48 - normalize it so essentially what we want
42:51 - to do is if
42:53 - self.direction dot
42:56 - magnitude and if that is different from
42:59 - zero
43:01 - then we want to normalize the direction
43:04 - and the magnitude is basically the
43:06 - length of the vector so if the vector
43:09 - has any kind of length we want to
43:10 - normalize that length
43:12 - meaning we always set the length of the
43:14 - vector to 1.
43:16 - and that way when we are running this
43:18 - code the ball is always going to move at
43:20 - the same speed
43:22 - which makes our game significantly more
43:24 - predictable but right now we have to
43:28 - talk about the bigger part and that is
43:31 - the collisions and in my case the ball
43:34 - is going to have two different kinds of
43:36 - collision so let me add two methods here
43:39 - we first of all have the collision by
43:42 - itself
43:43 - and this one for noun itself and nothing
43:47 - else i am just going to add pass in here
43:49 - we will cover this one in a lot of
43:51 - detail in just a bit
43:53 - but the other collision i want to add
43:56 - is
43:57 - window
43:58 - religion
44:00 - so the collision is to make sure that
44:02 - the ball doesn't leave the screen and
44:04 - this one we are going to do right now
44:07 - and in here what i want to do is add
44:10 - another parameter that is called
44:12 - direction
44:13 - and basically what i want to do
44:15 - i first want to check the direction
44:18 - or
44:19 - let's call it horizontal
44:21 - and if direction
44:24 - is going to be vertical
44:26 - not how you spell that
44:28 - then
44:29 - i want to do something else
44:31 - now
44:33 - for this window collisions it's not
44:35 - strictly necessary by itself to separate
44:37 - the axis but later on for the collisions
44:40 - this separation is going to become
44:42 - really important so for the window
44:44 - collision i already want to do the same
44:46 - thing
44:48 - and basically what we want to do
44:51 - is let me give a bit more space
44:53 - i first want to move the ball in the
44:56 - horizontal direction so i'm either going
44:58 - to move it left or right
45:00 - after i have done that
45:01 - i'm going to check the window collisions
45:03 - and the normal collisions so the
45:05 - collisions with the player and with the
45:06 - other obstacles once we have them and
45:08 - only once all of that is done
45:11 - i want to move the ball in the vertical
45:13 - direction and then do the collision and
45:15 - the window collision checks for this
45:17 - axis as well
45:18 - why that is important you will see when
45:20 - we talk about the collisions because
45:22 - this one is going to become a bit more
45:24 - complex
45:25 - but for now what i want to do is that
45:27 - this position shouldn't be x and y it
45:30 - should just be x and then self.direction
45:34 - is going to be self.direction.x
45:36 - and then
45:38 - self.direct.x
45:40 - is going to be round
45:42 - self.x
45:44 - and then we are going to copy all of
45:45 - this
45:47 - and replace all of the x's with y's
45:51 - and that way for now there's not going
45:54 - to be any difference
45:56 - but what i want to do now essentially is
45:59 - called self dot window collision
46:02 - with horizontal
46:04 - and then copy this and move it here and
46:07 - then check for the vertical collisions
46:09 - and later on we are going to do the same
46:12 - thing for the normal collisions and then
46:14 - you will see why the setup is going to
46:16 - make sense
46:17 - now we basically want to check the
46:19 - window collisions
46:21 - and this one should actually be pretty
46:23 - simple in terms of collisions so if you
46:26 - understand the player collisions so the
46:28 - stuff we have done
46:30 - here
46:32 - you should actually have a pretty good
46:33 - idea how to address the window
46:35 - collisions for the ball
46:36 - the only difference now
46:38 - is that we don't set the position to the
46:41 - right side of the window instead we just
46:43 - want to change the direction of the ball
46:46 - and as a consequence this could be a
46:48 - pretty good challenge for you
46:50 - so try to implement the collisions for
46:53 - the ball that it bounces around the
46:55 - window and see how far you get
47:00 - all right basically let's start with the
47:03 - left side so if
47:05 - self.wrecked.left
47:06 - is smaller than zero
47:08 - so our ball is moving outside of the
47:10 - left side of the window
47:12 - if that is the case
47:14 - i want to set myself.right.left
47:17 - to the position of 0.
47:19 - then self.x
47:23 - should become
47:24 - self.rect.x so so far this is the very
47:27 - same thing we have done here
47:30 - the one thing i want to add now
47:32 - is self.direction.x
47:36 - multiply equal with negative one
47:39 - so essentially what we are going to do
47:44 - if the ball is moving too far to the
47:46 - left and is somewhere here we want to
47:48 - place
47:49 - this side here
47:51 - to the left side of the window
47:53 - and then instead of moving the ball
47:56 - further to the left we want to change
47:58 - this direction
47:59 - to
48:00 - the right
48:03 - and that way it looks like the ball is
48:04 - bouncing off the window
48:06 - and now this we have to do for the other
48:09 - side as well
48:11 - so let me copy this if statement
48:16 - and now self.direct.right
48:20 - is greater
48:21 - than the window width
48:24 - and if that is the case self.rect.write
48:28 - should be the window width
48:31 - and then this one can stay the same and
48:33 - this one can also stay the same
48:35 - and now i have to copy all of those
48:40 - and do the same thing for the vertical
48:42 - direction
48:43 - and now self direct dot top
48:46 - is smaller than zero so the ball is
48:48 - leaving the window on the top side
48:50 - and if that is the case
48:51 - self.top is going to be zero
48:54 - and self.x
48:57 - should be self.y
48:59 - and then direction.y should also become
49:02 - negative one
49:04 - and now
49:05 - we have the bottom side of the
49:06 - collisions and this one we don't need at
49:09 - all because if the ball is touching the
49:11 - bottom side of the window it should be
49:13 - failing
49:15 - so we can remove all of this and this
49:18 - should be self.rect.bottom
49:21 - and if this is the case i want to set
49:23 - self dot active
49:26 - to
49:27 - false
49:28 - and now this should be working let's
49:31 - have a look
49:33 - so i can still move around if i press
49:35 - space
49:36 - the ball is moving around except it
49:39 - doesn't collide with the top part
49:41 - let's see one foot wrong
49:43 - and
49:44 - ah the problem here is i made a typo
49:47 - this should be vertical so now let's try
49:49 - this again
49:51 - let me move to one side this collision
49:53 - works and this one works as well and now
49:55 - if the ball hits the bottom part it just
49:57 - disappears
49:59 - ah and there it comes again
50:01 - and let's try this again
50:03 - ah now we have the problem that the ball
50:07 - once we are restarting it still has the
50:09 - downward facing direction so that is
50:12 - something we do have to work on
50:14 - and well all we have to do is if we get
50:19 - to this point here
50:21 - i want to set self dot direction dot y
50:26 - has to be
50:28 - negative one
50:30 - oh and i realize this should be window
50:32 - height
50:35 - not window width
50:36 - and this should now feel a good bit
50:39 - better so now let's try this
50:41 - we have collisions and the ball goes
50:45 - straight to the player this is feeling
50:47 - better
50:49 - and okay this feels quite nice
50:54 - so with that we already have some basic
50:58 - collisions although there's no collision
51:01 - between our ball and our player and to
51:03 - implement that we are going to need a
51:06 - bit of theory so let's talk about
51:08 - collision theory
51:12 - and there are a couple of steps we have
51:14 - to go through the first one is the
51:16 - easiest one and that is if there's an
51:19 - overlap between objects in the first
51:21 - place so in our case right now if the
51:23 - player and if the ball are touching at
51:25 - all
51:26 - and this is easy because pygame has lots
51:28 - of functions to do that for us so we
51:31 - don't really have to worry about it
51:33 - but now we have a problem and let me
51:35 - visualize this
51:37 - so we might have a situation like this
51:39 - where we have the ball so the right
51:41 - shape in here colliding with some kind
51:43 - of obstacle and right now we just know
51:46 - there's an overlap we don't know from
51:48 - which side the ball has come and
51:50 - basically what we want to do
51:52 - is place this ball somewhere on the
51:54 - outside of the obstacle so for example
51:57 - if the ball came from the left side to
51:59 - the right we want to move the right side
52:02 - of the ball so this side here
52:05 - to the left side of the obstacle so that
52:08 - the ball is somewhere here
52:12 - and that way we are resolving the
52:13 - overlap so the ball is well on the
52:16 - outside and it seems like the ball is
52:18 - colliding
52:19 - but to achieve that we have a problem
52:22 - because if we are just looking at this
52:25 - we don't know where the ball has come
52:26 - from so the ball might have come from
52:29 - this side the ball might have come from
52:31 - this side the ball might have come from
52:33 - this side the ball might have come from
52:35 - well literally any side
52:37 - and
52:38 - well the problem is now unless we know
52:40 - where the ball came from
52:42 - we cannot place the ball on the side of
52:44 - the collision because well we don't know
52:46 - where the ball came from
52:48 - and this is something we have to figure
52:50 - out in code which is possibly the most
52:53 - complicated part of this entire tutorial
52:56 - so let's talk about how we are going to
52:58 - achieve that and the very first thing
53:01 - that we can do
53:03 - is to separate our axes in horizontal
53:05 - and the vertical axis
53:07 - and this basically means that on the
53:09 - horizontal axis we only have to check if
53:11 - the collision happened on the left or on
53:13 - the right and then on the vertical we
53:15 - only check if this is on the top or on
53:17 - the bottom
53:18 - and this is going to simplify our math
53:21 - significantly and basically what we are
53:23 - then going to do in the game
53:26 - is we first do all the horizontal
53:27 - movement
53:28 - then we are checking the horizontal
53:29 - collision
53:31 - then we are checking the vertical
53:32 - movement and then we are doing the
53:34 - vertical collisions and we already have
53:36 - the basic part of this in our code
53:39 - so if i switch back to my code really
53:41 - quick
53:42 - we have our ball class and inside of
53:45 - that in the update method we are first
53:48 - doing all of the horizontal movement and
53:50 - then we are doing the vertical movement
53:52 - and let me actually add comments here to
53:54 - illustrate this a bit better so
53:56 - horizontal movement plus
53:59 - religion
54:00 - and then i can copy all of this and
54:02 - change this to
54:05 - vertical movement plus collision
54:08 - and this setup is really helpful to
54:10 - figure out collisions if you didn't do
54:12 - this you would have to add a whole lot
54:14 - more code to make all of this work
54:16 - which is why i included all of this
54:19 - so basically what we are going to do in
54:21 - just a second when we are writing the
54:23 - collision method
54:25 - we are also going to write self dot
54:28 - collision
54:29 - and then here there should also be
54:31 - horizontal
54:33 - and then we are doing the same thing for
54:36 - vertical and let me give the collision
54:40 - another parameter and let's call it
54:42 - direction
54:44 - so now we have to figure out if the
54:47 - collision happened on the left or on the
54:48 - right or on the top or the bottom
54:51 - and now you do have to be a bit careful
54:54 - so let's talk about this here's the case
54:56 - we had just now
54:58 - and if you were to just look at this
55:00 - you might assume that the collision
55:02 - definitely happened on this side here
55:05 - and we would want to move the ball to
55:08 - this edge
55:10 - which
55:11 - may be right but it's also very easy to
55:14 - get this wrong
55:15 - because it might have happened that the
55:17 - ball is moving at a very high speed in
55:20 - this direction and as a consequence of
55:22 - the high speed the ball might have been
55:24 - here on one frame then just about here
55:27 - on the next frame
55:29 - and then the ball jumped almost over the
55:31 - entire obstacle and as a consequence the
55:34 - ball is nearly over the entire thing
55:37 - so just because the ball is quite far on
55:39 - one side of the obstacle doesn't mean
55:41 - the collision happened on that side it's
55:43 - actually a really big problem for
55:45 - collisions that if the ball is moving
55:47 - too fast it might literally jump over
55:50 - entire obstacles which is really bad and
55:54 - this problem is called tunneling and
55:55 - game development it's actually a big
55:57 - problem but in our case we are not going
56:00 - to worry too much about it so then how
56:03 - can we actually resolve this issue
56:06 - and for the horizontal collisions we
56:07 - have to check a left side and a right
56:10 - side
56:11 - and both of these are going to be if
56:13 - statements i am going to only talk about
56:15 - the left side but the right side works
56:18 - in basically the same way except you
56:20 - check different numbers
56:21 - if you want to check collisions on the
56:23 - left side basically
56:25 - what we want to do we want to first
56:28 - check if the right side of the ball so
56:30 - this side here
56:32 - is greater than the left side of the
56:36 - obstacle so this side here
56:38 - and if the right side of the player is
56:41 - greater than the left side of the
56:42 - obstacle we know there's going to be an
56:44 - overlap so that's a really good start
56:47 - but then again the problem is we don't
56:50 - know where the ball came from so in this
56:52 - situation we don't know for sure that
56:54 - the ball came from the left because the
56:56 - ball might have moved really fast from
56:58 - the right side
56:59 - so we will need a second condition to
57:01 - make this work
57:03 - and that second condition
57:05 - is going to be a check on where the ball
57:08 - was on the previous frame
57:10 - so you can see on the screen right now
57:12 - the ball in the previous frame
57:14 - and what we want to check in here is if
57:17 - the right side of the ball
57:20 - is smaller than the left side of the
57:22 - obstacle
57:24 - and if that is the case we know that on
57:26 - the previous frame so this frame here
57:29 - the ball did not collide with the
57:30 - obstacle but the ball was on the left
57:33 - side of the obstacle and then in the
57:35 - current frame so this one here
57:38 - the ball is colliding on the right side
57:40 - and if these two conditions are true we
57:42 - know that there is a collision between
57:45 - these two obstacles on this side here
57:48 - and this sort of logic we can then apply
57:49 - to the right side to the top and to the
57:52 - bottom they all work in basically the
57:54 - same way except we're looking at
57:56 - different sites
57:57 - and well with all of that we have our
57:59 - collision logic so let's actually
58:02 - implement all of this
58:04 - here we are back in our code and i want
58:07 - to work on the collisions
58:09 - and the very first thing we have to do
58:11 - is to find overlapping
58:14 - objects
58:15 - which in our case right now is just a
58:17 - player but we are going to get proper
58:20 - obstacles later on and i want to store
58:23 - all of this in a separate variable let's
58:25 - call this one overlap sprites
58:29 - and for now this is just going to be a
58:31 - list but later on i want to change this
58:34 - to a method that captures all of the
58:35 - blocks the ball can collide with but we
58:38 - don't have any blocks yet so i'm just
58:40 - going to leave this as an empty list
58:42 - but now we also want to check if the
58:44 - ball is colliding with the player and
58:46 - this we get with if self dot
58:49 - dot
58:51 - rect
58:52 - and in here we need self.player.rect
58:57 - so we are essentially checking if the
58:59 - rectangle of the ball is colliding with
59:01 - the rectangle of the player collide here
59:05 - is not the perfect word overlap would be
59:07 - better because we only check an overlap
59:09 - we don't really check a collision
59:11 - although i guess those two are very
59:12 - similar if that is the case i want to
59:15 - get my overlapped sprites and append
59:18 - self dot
59:19 - layer
59:20 - so essentially later on these overlapped
59:23 - sprites are going to be all the blocks
59:25 - the ball is colliding with and
59:28 - if the ball is also colliding with the
59:29 - player we want to add the player to this
59:32 - list as well once we have this method
59:33 - here properly this is going to make much
59:35 - more sense so right now if the ball is
59:38 - colliding with the player we have a list
59:40 - with one sprite inside
59:42 - and now we want to check if overlap
59:45 - sprites exists in the first place so if
59:48 - there's anything inside of this list
59:50 - then we first of all want to check our
59:52 - direction so if our direction is
59:55 - horizontal
59:56 - then we want to do something
59:59 - and if direction
60:01 - is
60:02 - vertical
60:03 - then we want to do something else
60:06 - and let's work on the horizontal side
60:07 - for now basically what we want to do for
60:10 - sprite in overlap sprites we are looking
60:13 - at every single sprite inside of that
60:15 - list and now we have to implement the
60:18 - logic i just talked about so let's start
60:21 - with a collision on the left side of the
60:23 - obstacle
60:24 - basically what we want to do in here is
60:26 - if self.rect.right
60:30 - is greater or equal than
60:32 - sprite.rect.left
60:35 - and this is now our current frame so let
60:38 - me draw this we have our obstacle
60:41 - something like this
60:43 - and we have a ball that might be on this
60:45 - position here right now
60:47 - and what we are checking in this line
60:50 - right now
60:51 - is if the right side of the ball so this
60:53 - side here
60:54 - is greater
60:57 - than the left side of the obstacle so
61:00 - this side here
61:02 - and that is a really good start but this
61:04 - doesn't help us right now because the
61:06 - ball might have come from this side
61:08 - which again we couldn't really account
61:10 - for right now
61:12 - so we have to add a second condition
61:14 - with and
61:16 - and basically what i would like to get
61:18 - in here is
61:20 - self dot old wrecked dot right
61:23 - is smaller or equal
61:25 - and sprite dot alt
61:28 - rect.left
61:30 - and let me draw what this means
61:33 - i guess i can reopen the previous
61:35 - drawing
61:36 - so right now we already covered the
61:39 - first if statement this one just checks
61:41 - if the right side of the ball is greater
61:43 - than the left side of the obstacle
61:45 - which is a good start let me get rid of
61:47 - lines so it's a bit easier to see
61:49 - so now we know that this condition here
61:52 - works out what we now want to check if
61:54 - on the previous frame the ball was
61:56 - something like here
61:58 - so at the right side of the ball
62:00 - it's smaller than the left side of the
62:03 - obstacle which is this if statement here
62:06 - the issue we are facing right now is
62:08 - that we don't have an old rectangle for
62:11 - either the ball or any of the obstacles
62:14 - so we have to create these attributes
62:17 - and that fortunately isn't as difficult
62:19 - as it sounds
62:20 - so basically what we have to do let's
62:23 - start with the ball by itself
62:26 - when i initiate this class i have my
62:29 - rectangle and what i also want to create
62:32 - is self dot alt underscore rect
62:36 - and this one for now is just going to be
62:39 - self.rect.copy
62:42 - so for now we are literally just copying
62:45 - the rectangle so that isn't going to
62:47 - help us very much but it's a start
62:50 - and
62:51 - now what i essentially want to do
62:54 - in my update method
62:56 - before i do any of the movement
62:59 - i want to create old rectangle
63:03 - and all that really means is self dot
63:06 - all direct
63:08 - is going to be self.rect.copy
63:12 - again
63:13 - now what do we actually do
63:15 - and think of it like this
63:18 - when we come down here so in the
63:20 - execution of our code we have our
63:22 - rectangle and it might be let's say in
63:25 - this position here with some x and y
63:27 - position it doesn't really matter which
63:29 - they are
63:30 - and when we come to
63:33 - this line here
63:34 - we are making a copy
63:37 - of
63:38 - this rectangle so now these two
63:40 - rectangles are in the same position
63:42 - but what we now do in all of these lines
63:46 - on the code we are moving this original
63:49 - rectangle so let me draw an arrow so
63:51 - this rectangle here is being moved in
63:54 - any kind of direction we don't really
63:57 - care in which direction that is being
63:59 - moved it just doesn't matter to us
64:01 - but now this rectangle here isn't being
64:04 - moved and as a consequence this
64:07 - rectangle stays on the previous frame
64:09 - whereas this rectangle here moves to the
64:12 - next frame and with that we have a
64:14 - previous and we have a current frame
64:16 - with the old rect being our previous one
64:19 - and that's really all the logic you are
64:21 - going to need in here
64:23 - and now this line
64:24 - we can copy for the player and implement
64:27 - it in there as well
64:29 - so here i have the player
64:31 - and after i've created the rectangle let
64:34 - me just copy it in here
64:36 - i now have an old rectangle
64:38 - and then in the update method we again
64:42 - before we do anything else have to
64:44 - create self.rect
64:46 - and this is going to be self.rect.copy
64:50 - and this should be not wrecked but old
64:53 - wrecked
64:54 - and now before we move anything we are
64:57 - making a copy of the rectangle then we
64:59 - are moving the rectangle so now we have
65:02 - a previous frame and our current frame
65:04 - at the end of all of this
65:06 - so with that we have our current and our
65:10 - previous frame which is all we need for
65:13 - this line here to work
65:15 - and now that we do have that
65:17 - we can implement some logic so basically
65:20 - what i want to do for the ball is
65:22 - self.rect.right
65:25 - is going to be equal to sprite.rect.left
65:29 - and this basically means
65:31 - if this here is our obstacle and our
65:35 - ball collided with something like this
65:38 - we want to move the ball to this side
65:40 - here so that our ball is now
65:43 - here
65:45 - and that way it looks like the ball
65:47 - didn't overlap but just collide
65:50 - and since we now move the rectangle we
65:53 - also have to move the position so
65:55 - self.post.x
65:56 - is going to be self.rect.x
66:00 - and now finally what we have to do is
66:03 - self dot direction dot x
66:06 - multiply equal with negative one
66:09 - because we want to bounce the ball as
66:10 - well and well with that we have the
66:13 - collision for one side
66:16 - all we have to do now is copy this three
66:18 - more times and get the other collisions
66:20 - as well and this i think could be a
66:22 - really good challenge for you so try to
66:25 - implement the collision for the left
66:26 - side to top and the bottom and see how
66:28 - far you get
66:33 - let me start with the other side by just
66:37 - copying this if statement
66:39 - and essentially what i want to check now
66:41 - is if
66:43 - self.direct.left
66:44 - is smaller or equal than sprite direct
66:47 - dot right
66:49 - and if i draw this one i think that's
66:51 - the best way to think about it
66:53 - we have our obstacle here and now we
66:56 - want to check if the ball collision
66:57 - happened on this side here so what we
67:00 - check right now is the left side of the
67:02 - ball against the right side of the
67:04 - obstacle
67:06 - and if the ball is smaller than that we
67:08 - know there happened the collision and
67:10 - besides that we now want to check
67:13 - if the old rectangle of the ball so left
67:15 - side
67:16 - was greater or equal than the right
67:21 - side
67:22 - of the obstacle
67:23 - and then we have to check
67:25 - self.rect.left is going to be sprite dot
67:28 - direct dot right
67:29 - and the other two lines can stay just
67:31 - the same with that we have the
67:34 - horizontal collisions so now i can copy
67:37 - all of this
67:39 - and paste it into the vertical axis as
67:41 - well and in here
67:43 - let's start with the bottom
67:46 - so if the bottom of the ball is greater
67:49 - or equal than the top of the obstacle
67:52 - and then besides that we also want to
67:55 - check if the bottom of the player in the
67:57 - previous frame was above the obstacle
68:01 - and now if that is the case sprite or
68:03 - direct dot bottom should be equal to
68:06 - sprite or direct dot top
68:08 - and the only thing we now have to change
68:10 - in the other two lines is going to be
68:13 - y instead of x
68:16 - and nearly done
68:17 - now we want to check if
68:20 - self.rect.top
68:22 - is smaller equal than sprite dot red dot
68:25 - bottom
68:26 - and we basically just change
68:28 - left to top and right to bottom
68:32 - so this should be top as well
68:34 - and this should be
68:36 - bottom and now again
68:39 - this x should be a y
68:43 - and with that we should be done
68:47 - let's try
68:51 - so now these collisions still work and
68:54 - this is also working nice
68:56 - and now the important part is if there's
68:59 - collision on the left side of a player
69:00 - this one is important
69:02 - so let's try this again
69:06 - the ball may be a little bit slow but
69:09 - okay it's kind of hard to get but i want
69:11 - to get hits the right side okay well the
69:14 - collisions do work and the really
69:16 - important part here why we need specific
69:19 - collision mechanics
69:21 - is that when there's a collision between
69:23 - the ball and the player
69:26 - on the right or the left side
69:29 - in this case it's totally possible that
69:32 - the player is moving to the right and
69:34 - the ball is moving to the left
69:36 - and if we don't have a collision this
69:38 - collision mechanic is still going to
69:40 - work
69:41 - we don't get some weird arrow that the
69:43 - ball is just moving around randomly
69:44 - which is what i really cared about in
69:46 - here
69:47 - but all right
69:48 - now with all of that
69:51 - we have a working collision mechanic
69:54 - which took quite some time let me
69:56 - minimize this method because it is quite
69:58 - massive
69:59 - all right so with that we can come to
70:02 - the next section
70:04 - and that is going to be creating the
70:06 - obstacles
70:07 - and for now there are two things i would
70:10 - like to work on
70:12 - number one is that i want to have some
70:14 - kind of layout that shows me where the
70:16 - blocks are going to be
70:19 - and besides that when we actually create
70:21 - the blocks in the method
70:23 - these blocks should scale automatically
70:25 - to the size of the window so if we don't
70:27 - create blocks that are either massively
70:28 - too small or massively too large if the
70:31 - size of the window changes
70:33 - so when we are creating the blocks from
70:34 - the layout there should be some
70:36 - flexibility in terms of how large the
70:38 - blocks are going to become and for now
70:40 - all of the blocks are going to be a
70:41 - simple color but later on we are going
70:44 - to add proper graphics i just want to
70:45 - focus on specific things for now but all
70:48 - right let's jump straight into the code
70:50 - and let's work on this
70:53 - here we are back in the code and first
70:55 - of all i want to go to my settings and
70:58 - right now there really isn't very much
71:00 - in here but i want to add something else
71:04 - and that is going to be what i called a
71:07 - blog map
71:09 - and this one is essentially a list it
71:11 - contains a couple of strings and that's
71:14 - just about it
71:15 - and basically what this one means here
71:18 - if we have a 1 for example
71:21 - we are creating a block with this type 1
71:24 - and then this block is going to have a
71:25 - certain amount of health and a certain
71:27 - color
71:28 - as a matter of fact i do have a color
71:30 - legend as well this one looks like this
71:35 - so for example if we have a 1 here
71:39 - we want to look at our color legend pick
71:41 - up the one here and from that we know
71:44 - this color is supposed to be blue and
71:46 - then this number is also going to be the
71:47 - amount of health for this block
71:50 - so this layout basically tells us three
71:51 - bits of information the position of the
71:54 - block the color of the block and the
71:55 - amount of health the block has
71:57 - and you can totally change this kind of
72:00 - layout for example in my case i didn't
72:02 - even add gray blocks so for example i
72:05 - could add 7 and 7 in here and we will
72:08 - get some grey blocks later on you will
72:10 - see in a second how this thing is going
72:12 - to work
72:13 - and now before we can actually place
72:17 - these blocks
72:18 - we need a few more bits of information
72:21 - and i'm going to add these as extra
72:22 - constants the first is the gap size
72:26 - spelled correctly
72:27 - and in my case this is 2 and this gap
72:30 - size refers to the gap between the
72:32 - blocks so if we have a block here and
72:35 - another block here
72:36 - gap size refers to the distance between
72:39 - these two and now that we have that
72:41 - information
72:42 - we can already figure out the block
72:45 - height and we can figure out the block
72:49 - with
72:50 - and there's one thing i did forgot to
72:51 - mention in this block map we have a
72:54 - couple of strings that are just empty or
72:56 - well they're not empty but they have
72:57 - spaces inside
72:59 - and for these i just don't want to have
73:01 - any block in them i think that's fairly
73:03 - obvious
73:05 - okay now for the block height
73:07 - basically what i want to do
73:10 - here i have my entire window
73:13 - and the height for this window we get
73:15 - from the 720 here so i know the height
73:18 - of this window is 720 pixels
73:21 - and i know inside of this window
73:24 - i have a couple of rows because each
73:27 - string inside of this list is supposed
73:30 - to be one row and for simplicity let's
73:33 - say i have 10 strings inside of this
73:35 - block map
73:36 - which means in this window i am going to
73:39 - have 10 rows so 1 2 3 4 and you get the
73:43 - idea and now what we basically want to
73:46 - figure out is how tall
73:49 - does each row need to be
73:51 - and the math here is actually super
73:53 - simple all we really have to do is
73:55 - divide the entire height of the window
73:58 - by the amount of rows that we have
74:00 - so in this case for example we know the
74:02 - height of one of the rows would be 72
74:06 - although this isn't the final number
74:09 - because from the 72
74:11 - we would want to subtract the gap size
74:15 - so this 2 in our case essentially what
74:18 - we want to do is
74:20 - the entire height of the window divided
74:22 - by the number of rows
74:24 - minus the gap
74:26 - size which in our case would be 72-2
74:30 - which would be 70 pixels
74:33 - and this 70 pixels in this case
74:36 - would then be the height of one
74:38 - individual block
74:40 - once we have that we can do the same
74:42 - logic for the width of the window and
74:45 - that way we will get the width of each
74:46 - individual block
74:48 - and well i think this could become a
74:51 - really interesting challenge so with all
74:54 - of this in mind try to figure out the
74:56 - code for the block height and the block
74:58 - width and see how far you get
75:03 - for the block height basically what we
75:05 - want to do is
75:06 - window height
75:08 - divided by the length
75:11 - of block map and the length of the block
75:14 - map basically tells us how many strings
75:17 - we have in here which is exactly what we
75:19 - need
75:20 - and from that we just have to subtract
75:23 - the gap size and we are good to go this
75:27 - is all we really needed
75:29 - and now for the block width we can do
75:31 - the same thing except now it's going to
75:33 - be width
75:34 - and now for the
75:36 - length we don't just want to look at
75:39 - block map
75:40 - but we know that the length of each of
75:43 - these lists tell us how many columns we
75:45 - have
75:46 - so in this case let's say there are 15
75:48 - numbers inside of this
75:50 - and since there are 50 numbers in here
75:52 - we know we are supposed to have 15
75:54 - columns inside of this block map
75:57 - so all we really want to do in here is
75:59 - not look at block map but look at one
76:02 - string inside of block map and let's say
76:05 - the first one so this one here
76:07 - and that is all we needed again so now
76:11 - i can subtract gap size again and we are
76:13 - done
76:14 - so with that we have the gap size the
76:17 - block size for the width and the height
76:19 - now what we have to do next in main.pi
76:23 - we have to create another method
76:26 - and let's call this one stage set up
76:30 - that is not how you spell that
76:33 - and in here we just need self and
76:35 - nothing else
76:37 - and what we now want to do we want to
76:40 - first of all
76:41 - cycle through
76:43 - all rows and columns of log map
76:48 - and once we have that we want to find
76:51 - the x and y position for each individual
76:56 - lock
76:57 - so essentially what that means we want
76:59 - to cycle through
77:01 - this thing we first want to cycle
77:03 - through all of the rows so all of the
77:04 - strings
77:06 - and that will be giving us the y
77:07 - position
77:08 - and then inside of that and then inside
77:11 - of that we want to cycle through every
77:13 - single number inside of the string
77:15 - and that would be giving us the x
77:17 - position
77:18 - and basically what that means
77:21 - i first want to go for row in
77:25 - lock
77:26 - underscore map i think i called it
77:29 - and let's just print
77:32 - row and see what we get
77:34 - obviously don't forget to actually call
77:36 - this method
77:38 - which i have done in the setup method so
77:41 - in here self.stage setup
77:44 - and let's see what we get
77:46 - so now we still get our window but we
77:48 - don't care about it what we instead care
77:50 - about is this here
77:54 - so in here we have all of our strings
77:59 - inside of block map
78:00 - which is a pretty good start
78:04 - but there's one important thing we now
78:06 - need to figure out because right now i
78:08 - don't really care what is inside of the
78:10 - string i instead want to know
78:14 - what the index of this string here is so
78:18 - what i essentially want to know is that
78:20 - this first string here has the index 0
78:24 - and the second one has index 1 then 2 3
78:28 - and so on
78:29 - and then what i'm going to do in a
78:30 - second is multiply this number with the
78:33 - block height of each of the blocks
78:35 - and that way the first block is going to
78:37 - start on position 0 on the y axis
78:40 - the one with the index one
78:42 - is going to start on something like 70
78:45 - pixels
78:46 - the next one multiplied by height is 140
78:50 - and so on
78:52 - so this index here is going to become
78:55 - really important
78:56 - and that index we can get with the
78:59 - enumerate method so in here enumerate
79:02 - and enumerate is going to return the
79:04 - information so the row but before that
79:07 - it's going to return an index
79:09 - which i want to capture in index
79:12 - row
79:12 - actually i think row index is making
79:15 - more sense
79:17 - so now i can copy this line and let's
79:19 - change the first one to row index and
79:22 - now let's see what we get
79:24 - so let me close the window again now we
79:26 - know
79:27 - on index number zero we get this
79:29 - information
79:30 - on row number one we get this
79:32 - information and so on
79:34 - and actually from that we can already
79:37 - get the y position
79:39 - so basically what i want to do is i want
79:41 - to get the row index
79:44 - and multiply this
79:46 - with the block
79:48 - height
79:49 - and the block height is just what we got
79:51 - down here
79:54 - so this would be a good start
79:56 - and let's actually print what we get so
79:58 - print y
80:00 - now if i run this again
80:01 - we are
80:02 - getting 0 78 156 and so on
80:08 - and this is a reasonable y position but
80:11 - we are missing something really
80:12 - important and that is the gap size
80:16 - so what i basically want to do is this
80:18 - block height is going to get the gap
80:21 - size as well
80:23 - and now if we run this
80:25 - we're getting 0 80 160 and we know the
80:28 - block height is going to be
80:31 - so there's one pixel of a gap between
80:33 - the top and the bottom
80:36 - although there is going to be another
80:38 - problem we have to deal with because
80:40 - this 80 right now let me minimize the
80:42 - game
80:43 - so essentially what we have right now is
80:46 - here we have a couple of rows let me add
80:49 - one on top
80:51 - and the first row is zero the second one
80:54 - is 80 and the third one is 160.
80:58 - this i got from the information down
81:00 - here
81:01 - and we also know that inside of this we
81:04 - have our blocks that should be
81:07 - 78 pixels tall
81:10 - and that is the information we
81:11 - calculated inside of block height now
81:14 - the problem is that if we were to just
81:17 - use this information here
81:19 - we would always place the block in the
81:22 - top part of this row
81:25 - which essentially means that we have no
81:28 - offset on the top
81:30 - and we have
81:31 - two pixels right now offset at the
81:33 - bottom which is the entire size of our
81:35 - gap
81:36 - so what we instead want to do
81:38 - is to place this block in the middle
81:42 - of the row so we have one pixel on the
81:45 - top and one pixel at the bottom always
81:47 - half of the gap size
81:49 - and to achieve that let me clean this
81:52 - one up a tiny bit
81:53 - basically all we want to do
81:55 - is towards this y position
81:58 - i want to add gap
82:00 - underscore size
82:02 - and floor divide this by two
82:05 - and that way we are not adding the top
82:07 - part exactly on the top row instead we
82:11 - are giving it half the gap of size and
82:13 - then at the bottom automatically we are
82:15 - already getting half of the gap size
82:17 - again so i hope this makes sense
82:20 - all right so with that we have the y
82:23 - position
82:24 - to get the x position
82:26 - we essentially have to cycle through
82:28 - each of the individual strings and this
82:31 - is going to happen in a very similar way
82:33 - compared to the y position
82:35 - so
82:36 - really all we have to do is for let's
82:39 - add a call index and a column
82:43 - in
82:43 - enumerate and now importantly we want to
82:46 - enumerate over the row so this one here
82:50 - and inside of this we have to indent our
82:53 - y
82:54 - and now we can also get our x position
82:57 - and for the x position we are basically
82:59 - getting the column index we are going to
83:02 - multiply it with the block
83:04 - width plus the gap size
83:09 - and then towards that we are adding gap
83:11 - size again except in half
83:14 - and with that we have our x and our y
83:17 - position
83:18 - so i guess i can move this one up a tiny
83:21 - bit now this looks better
83:23 - and now that we have that i want to use
83:26 - that information to create a block
83:29 - and this block we don't have yet so we
83:32 - have to create it but there are a few
83:35 - bits of information i would like to pass
83:37 - in here
83:38 - first of all i want to get some type of
83:41 - a block
83:43 - which basically means the type is each
83:46 - of these numbers so a type of a block
83:48 - would be six it could be seven three two
83:51 - one doesn't really matter
83:53 - i also just realized there's no five in
83:55 - here let me add
83:57 - five on these sides
84:00 - so that's the first thing i need next up
84:03 - i need a position and that's going to be
84:05 - the x and the y we created here and let
84:07 - me move the x up so it feels a bit
84:09 - better
84:10 - okay so x and y is going to be our
84:12 - position
84:14 - and then we are going to need some
84:16 - groups
84:17 - and that is at least for now all we are
84:20 - going to need so
84:22 - let me copy all of this
84:24 - comment it out and now in my sprites i
84:28 - want to create another class
84:30 - and this one i called
84:33 - lock
84:34 - and this one again has to be pygame dot
84:36 - sprite dot sprite
84:39 - and in here for the dander init method i
84:43 - want to pass in the arguments i just
84:46 - talked about
84:47 - although don't forget we also need self
84:50 - and usually i avoid type because it
84:52 - might interfere with the inbuilt python
84:54 - method type so let's change this to
84:57 - block underscore type
84:59 - all right now that we have that we as
85:01 - always need a super thunder init method
85:05 - that is going to get our groups
85:07 - besides that i am going to need a
85:10 - self.image
85:12 - and
85:13 - self.rect
85:15 - and self.image is really easy at least i
85:18 - hope it is all we need is pygame dot
85:21 - surface
85:22 - and we know how large each of the blocks
85:25 - needs to be that's the information we
85:27 - have here with block height and block
85:29 - width
85:29 - so let me just copy them
85:31 - [Music]
85:32 - lock height and block
85:36 - width
85:37 - and the rectangle is just going to be
85:41 - self dot image dot get underscore rect
85:45 - and top left is going to be the position
85:49 - we are getting from up here and this by
85:51 - itself for now is all we need to get
85:53 - started
85:55 - now let me comment the block
85:57 - the type we are getting from the column
86:00 - so the column
86:02 - is basically going to be each of these
86:04 - numbers so that's what we have to pass
86:06 - in for the type the position
86:09 - is going to be a tuple with x and y
86:14 - and for now for the groups i want this
86:16 - to be in self dot all sprites
86:20 - and now let's try this we're getting an
86:22 - error because i did not import the block
86:26 - so
86:27 - lock and now let's try this again
86:29 - and there we go we are getting something
86:32 - weird
86:33 - and the problem here is that right now
86:36 - we are checking for literally any kind
86:39 - of string so even if the string is empty
86:43 - igame is still going to place a block
86:45 - there which we don't want
86:48 - so i'm going to add all of this inside
86:50 - of an if statement and that is if the
86:53 - column is different from
86:56 - an empty string
86:57 - and only if that's the case
87:00 - i want to place all of these blocks
87:03 - all right and now if we run the code
87:06 - this is looking better although still
87:08 - kind of weird the gap besides each of
87:12 - those blocks is way too large
87:14 - and let's have a look at the sprites i
87:16 - think i know what the issue is ah the
87:18 - issue is here i switched around the
87:20 - height and the width so the first
87:22 - argument for surface is the weft and the
87:25 - second one is the height
87:27 - so now let's try this again and this is
87:29 - looking significantly better so with
87:32 - that we have our blocks
87:35 - and what we are now able to do
87:38 - is to create another sprite group and
87:41 - this one let's call it
87:44 - log underscore sprites
87:46 - and this one again it's just going to be
87:48 - pygame.sprite.group
87:52 - and now when i create this block
87:55 - it's going to be in all sprites and it's
87:57 - also going to be in self dot block
88:01 - sprites
88:02 - and now the ball needs to know where
88:04 - these block sprites are so when we are
88:07 - creating the ball
88:09 - i want to do the stage setup first
88:14 - and then inside of the ball
88:16 - i am going to pass in self dot block
88:18 - sprites
88:20 - and now in my sprites
88:24 - i can get my ball and
88:27 - and add another parameter let's call it
88:29 - the blocks
88:31 - and now self.blocks
88:34 - is going to be blocks so we have an
88:36 - attribute with all of the blocks
88:40 - and now the important bit
88:43 - in these overlap sprites
88:45 - we can use pygame.sprite.sprite
88:49 - collide
88:51 - and in here we need a sprite a group and
88:55 - do kill
88:57 - the sprite is just the sprite we want to
88:59 - look at which in our case is going to be
89:01 - self
89:03 - then we have a group which in our case
89:06 - is going to be all of the blocks so self
89:09 - dot
89:10 - locks i think i called it
89:12 - uh yeah this one here
89:15 - and finally do kill
89:17 - and that's just asking us do we want to
89:19 - destroy the block if it touches the ball
89:21 - which in our case is false and that is
89:25 - all we need for all the collision
89:27 - mechanics so now let's try this
89:30 - and ah now we're getting an error that
89:33 - block does not have an attribute old
89:35 - rectangle
89:37 - so when we run the collisions we are
89:39 - checking for an old rectangle which our
89:42 - blocks don't have right now so we have
89:45 - to give it to them and this one is just
89:48 - self old wrecked
89:50 - is going to be self.rect.copy
89:54 - and now let's try this again
89:57 - and we get
89:58 - some basic collisions
90:02 - although you can see sometimes there's a
90:04 - bit of an issue here where the ball
90:06 - seems to stick around the blocks and
90:09 - this i'm going to work on just a second
90:11 - i just want to show it again i hope it
90:12 - comes up
90:16 - i guess not
90:19 - okay never mind
90:21 - but essentially the problem we have
90:23 - right now
90:25 - is let me open up the collision for the
90:28 - ball
90:31 - the vertical one in particular let me
90:34 - add a bit more space
90:36 - the issue we have right now imagine
90:39 - we have two blocks here
90:43 - and the ball is colliding with both like
90:46 - this
90:48 - so we have a collision here and we have
90:50 - a collision here
90:52 - and the result is that this
90:55 - self.direction
90:57 - is going to be multiplied with negative
90:59 - 1 twice once for this block and once for
91:02 - this block and as a consequence the ball
91:04 - first goes down and then goes up again
91:07 - which means that for a second the ball
91:09 - is hovering around it which really isn't
91:12 - what we want
91:13 - and what i found that solves this issue
91:16 - entirely
91:17 - is instead of spawning the bottom of the
91:20 - player on the top for example or the top
91:22 - of the player at the bottom of the
91:23 - sprite we want to give an offset of one
91:26 - pixel so
91:28 - we want to add plus one here and minus
91:30 - one here
91:33 - and then negative one here
91:35 - and
91:36 - last one here
91:37 - that way after a collision the ball is
91:40 - going to be moved one pixel up or one
91:42 - pixel down so we don't have another
91:44 - collision straight afterwards so now
91:46 - let's try this again there shouldn't be
91:48 - any visible difference except we don't
91:50 - have the bug anymore
91:51 - um okay i am terrible at my own game
91:54 - okay this feels kind of nice okay i am
91:57 - really bad at this game
92:00 - okay i think this is looking pretty good
92:03 - cool
92:06 - now obviously
92:08 - now obviously this game doesn't do
92:09 - anything right now
92:11 - so in our blocks we have to add a bit
92:14 - more code that blocks get destroyed
92:17 - once the ball is touching them or at
92:20 - least they lose some health and for that
92:23 - let me add another section here and that
92:25 - is going to be
92:27 - damage information i guess is the word
92:30 - and first of all i want
92:33 - self.health in here
92:35 - and that is just going to be an integer
92:38 - of the block
92:39 - type because remember the block type is
92:42 - literally just a number so we can
92:44 - totally use it for the health now that
92:47 - we have that
92:48 - i want to give this block a method that
92:51 - i called get underscore damage and in
92:54 - here we need self and we need an amount
92:58 - so how much damage the ball can get
93:00 - and essentially all we want to do in
93:02 - here is self dot health minus equal the
93:05 - amount of damage taken and now obviously
93:09 - we have to update this rectangle so what
93:12 - i basically want to check is if
93:14 - self.health
93:16 - is greater than 0
93:18 - i want to update the image which we
93:20 - can't do yet so i'm just going to add
93:22 - pass in here
93:23 - but if that is not the case and this
93:26 - should be health if our health is equal
93:28 - to or lower than zero i want to destroy
93:31 - this sprite with the kill method
93:34 - and now all we have to do
93:37 - if
93:38 - the ball is colliding with this block
93:40 - we want to call the get damage method
93:42 - and pass in an amount of damage now in
93:44 - my case the damage is always going to be
93:46 - one but you could totally add another
93:48 - number in here so
93:50 - what we have to do in the ball we are
93:53 - checking for the collisions that is
93:55 - going to happen in here
93:57 - and first of all i have to identify that
94:00 - we have a block because if the ball is
94:02 - colliding with the player there should
94:04 - just be a collision and nothing else
94:07 - and how i can identify the blocks is
94:09 - that blocks have a health attribute so i
94:12 - can use if get
94:13 - utter
94:15 - we're just checking a class which in my
94:17 - case is sprite
94:18 - and then we can pass in one attribute we
94:20 - would like to check which in my case is
94:22 - health
94:24 - and if that sprite doesn't have this
94:25 - attribute i want to just return none
94:29 - so this line basically checks if the
94:31 - sprite we have has the health attribute
94:34 - which in our case is only the blocks
94:37 - and if that is the case
94:39 - sprite dot get
94:42 - damage should be called with a damage of
94:45 - one
94:46 - and now i have to copy all of this
94:50 - or the vertical axis as well
94:53 - and now we should be having a working
94:56 - code let's try
94:58 - so now the block disappears i'm still
95:00 - terrible at this game
95:01 - so now we had two this is working
95:03 - [Music]
95:06 - we are definitely making some progress
95:07 - i'm hoping to hit the second row as well
95:10 - eventually there we go now nothing
95:12 - changed but now it did this was actually
95:14 - perfect
95:15 - so the second row has more health than
95:18 - the first one
95:20 - and as a consequence we have to hit them
95:21 - twice instead of once
95:24 - and there we go now you can see it again
95:26 - the logic here is definitely working
95:28 - and so are the collisions this is
95:31 - working very nicely cool
95:34 - so
95:35 - with all of that
95:37 - we have our collision mechanics and our
95:40 - blocks so with that we can start working
95:44 - on the next section
95:46 - and that is going to be about adding
95:48 - proper graphics
95:50 - so in this part we are actually going to
95:52 - make our game look better
95:54 - but we do have a problem here let's talk
95:57 - about what we have to address
96:00 - and let's have a look at one image to
96:02 - understand what's going on
96:04 - so here you can see one individual block
96:08 - and i have brightened up the entire
96:09 - scene so it's a bit easier to see what's
96:11 - going on
96:12 - and right now this block by itself is
96:15 - totally fine
96:17 - now the issue that we have is that this
96:19 - block needs to look good in literally
96:21 - any kind of size so for example it would
96:24 - need to look good like this like this
96:26 - like this like this
96:29 - and in our case right now especially if
96:31 - you squash this a bit more it starts to
96:33 - look really weird
96:36 - it might look okay like this but we
96:38 - can't guarantee it's always looking like
96:39 - this
96:40 - and especially if we have a case like
96:42 - that
96:42 - it starts to look really really bad
96:46 - so the issue that we have
96:48 - is that if we just took an image and
96:51 - scaled it up to whatever we need we
96:53 - might squish it or stretch it in such a
96:56 - way that it might end up looking weird
96:58 - so we need to do something else
97:01 - and what we are going to do instead is
97:05 - this let me return to the darker
97:07 - background
97:08 - this white background is what we want to
97:10 - create and again here the aspect ratio
97:14 - is really important that this thing
97:16 - should be able to scale in any size any
97:18 - proportion that we want within reason i
97:20 - suppose
97:22 - and as a consequence we couldn't just
97:24 - scale a random image so
97:27 - what we are going to do instead is this
97:30 - we are going to just create the edges
97:32 - so each of these corners is going to be
97:35 - a separate background and these cannot
97:38 - stretch they will always have the same
97:40 - size
97:42 - but then
97:43 - we are going to bleed some more surfaces
97:46 - these yellow ones the difference for
97:48 - this one though is that these yellow
97:51 - rectangles
97:52 - can stretch and as a consequence it
97:55 - doesn't really matter how big the
97:56 - surface is going to become because this
97:58 - white surface is going to become wider
98:01 - or shorter depending on how big it needs
98:03 - to be
98:04 - and then in the end we're just going to
98:07 - fill the entire thing with a color and
98:09 - we are basically done with it
98:12 - and all right i think all of that might
98:13 - be slightly difficult to understand so
98:16 - let's try to explain this in a different
98:18 - way
98:20 - here we can see one block that we might
98:22 - actually see in the game
98:24 - and this thing right now might look like
98:27 - one coherent image but in reality it
98:30 - actually isn't i can for example
98:33 - take the top left away i can take the
98:35 - bottom left away i can take the left
98:37 - away it all works just fine
98:40 - and the trick now is let's say
98:43 - i have this block but i want this block
98:45 - to be bigger
98:47 - and now the trick is let's say i want to
98:50 - expand the size of this thing on the
98:53 - horizontal axis so i want let's say the
98:56 - top left to be here and the top right to
98:58 - be here and they do have to be on the
99:00 - same height that is really important
99:02 - basically if i have this now
99:04 - i can take the middle part
99:06 - and this one is supposed to scale in the
99:08 - x axis and if i scale it like this
99:13 - then
99:14 - we have well a properly working setup
99:18 - so the top left and the top right don't
99:21 - scale but the middle part does scale and
99:24 - since the middle part can scale without
99:26 - any loss in quality this system works
99:28 - really well and this is essentially what
99:31 - we are going to implement in our game
99:34 - so i hope that is going to make more
99:36 - sense
99:37 - in our game folder we have blocks and
99:41 - inside of blocks we have a couple of
99:43 - different colors and the player and let
99:45 - me open the blue one
99:47 - so inside of the blue folder we have
99:50 - just a bunch of very small images
99:53 - and this is essentially what we are
99:55 - going to import and then we are going to
99:57 - use these individual images to create
99:59 - the actual surface for the player or for
100:02 - all of the blocks
100:04 - and if we use that system we have blocks
100:07 - that scale in basically any dimension
100:10 - so i think if we implement this all of
100:12 - this is going to make much more sense
100:14 - so let's go straight into the code and
100:16 - let's have a look at this
100:19 - here i am back in my code and what i
100:22 - want to do is to create a new file
100:26 - and this one
100:27 - i am going to save as surface maker dot
100:31 - pi
100:33 - and in here i am going to create a class
100:36 - so class surface
100:38 - maker
100:40 - and
100:41 - this m should be capitalized
100:44 - and what this thing is essentially
100:46 - supposed to do let me add a comment it
100:49 - is supposed to import all the graphics
100:52 - and it is supposed to create
100:56 - one surface with the graphics
101:00 - with any size and finally it is supposed
101:04 - to return that image to the blocks or
101:08 - the
101:09 - layer
101:11 - and that's basically all we want to do
101:13 - in here
101:14 - now for that to work we need a couple of
101:17 - different things first of all we need to
101:19 - import pygame for the obvious reasons
101:22 - and besides that we need from settings
101:26 - import star
101:28 - and just to test that this thing is
101:30 - working i want to for now give it one
101:32 - method that i'm going to call get
101:35 - surface
101:36 - and this one itself
101:38 - we want a block type so we know what
101:41 - color we get and we need a size
101:44 - and now all we are really going to do is
101:47 - image is going to be pygame dot surface
101:51 - and it's going to create a surface with
101:53 - a certain size
101:54 - and for now this image we are going to
101:57 - fill let's say for now with a red color
102:01 - and once we have that we want to return
102:04 - that image
102:06 - now this surface maker i now
102:09 - want to import into my game class so in
102:13 - my main file i need from surface maker
102:17 - import
102:18 - surface
102:20 - maker
102:21 - and now as the first thing in this setup
102:24 - i want to create an instance of this
102:26 - surface maker so self dot surface maker
102:30 - is going to be surface maker
102:33 - and now
102:34 - the player is going to get an instance
102:37 - of this self dot surface maker
102:40 - and when we create a stage
102:43 - so all the way down here
102:45 - each of the blocks is also going to get
102:47 - an instance of self dot surface maker
102:50 - and now you might be asking yourself why
102:54 - don't we just create an instance of the
102:55 - surface maker inside of player and
102:58 - inside of each of the block when we
103:00 - create a class itself why do we import
103:03 - this straight in the game method
103:05 - the reason here is that surface maker in
103:08 - a second is going to import a lot of
103:10 - images
103:11 - so it's going to import each part of
103:13 - each of the blocks
103:15 - and right now we are doing this once but
103:18 - if we were to create a separate instance
103:20 - of this method for each player in each
103:22 - block
103:23 - we would import significantly more
103:25 - images
103:26 - and as a consequence i am going to
103:28 - import it here and make it available to
103:30 - all of my classes that need it alright
103:33 - now
103:33 - in my sprites
103:35 - let's start this with the player now the
103:38 - player first of all is going to need
103:40 - another parameter so surface maker and
103:43 - let's put this straight in the setup
103:45 - part so self dot
103:48 - surface maker
103:50 - is going to be surface maker
103:52 - and now
103:54 - essentially what we can do
103:56 - instead of getting a random surface here
103:59 - i want to do something else i want to do
104:01 - surface maker and then call
104:05 - this get surface method here
104:08 - so
104:09 - surfacemaker.getsurface
104:10 - and in here
104:12 - we are going to need a block type and a
104:14 - size
104:16 - so let me copy the parameters
104:18 - and now for the block type for now we
104:21 - are just going to say player so we know
104:23 - what's going on
104:25 - and for the block type for now we are
104:27 - just going to say a string of player
104:30 - and the size we still have i still have
104:33 - it in my notes for this let me just copy
104:35 - it
104:36 - so the size is just going to be
104:40 - 10 of the window width and 5 of the
104:42 - window height
104:44 - and now our surface maker is going to
104:47 - create a surface for the player and this
104:49 - is what we actually want to do
104:52 - now before we can test this we have to
104:54 - do the same thing for the blocks
104:56 - so now for the blocks they are going to
104:58 - need another parameter called surface
105:00 - maker and before we are creating an
105:03 - image
105:04 - i want to set self dot surface maker
105:08 - is going to be surface maker
105:10 - and then let me copy out block width and
105:12 - block height so i save a bit of
105:14 - writing and in here all i want to do is
105:17 - self dot surface maker dot get
105:20 - underscore surface
105:23 - and in here
105:24 - i want to have my dimensions
105:26 - and for the block type i already have my
105:28 - block type
105:30 - so what we would expect now is that we
105:33 - can see some red rectangles but the size
105:36 - should still work
105:38 - and we are getting an error that i
105:41 - believe i forgot
105:43 - a bracket
105:46 - so now let's try this again and now we
105:48 - can see all of our surfaces are red
105:51 - not exactly helpful right now but
105:53 - something we can work with
105:56 - now we can work inside of this surface
105:58 - maker and actually create the graphics
106:01 - and the first thing we have to do in
106:03 - here is to import all of the surfaces so
106:07 - this is going to happen in the init
106:09 - method and this one itself and nothing
106:11 - else
106:13 - and since we need access to the folder
106:15 - we actually to import another module and
106:18 - this one is from os import walk
106:22 - and all that work really does is it
106:24 - works through a couple of folders in our
106:26 - operating system
106:27 - and i can actually show you what's going
106:29 - to happen so what we can do for example
106:32 - is for
106:33 - info in walk
106:36 - and now we need to path to our graphics
106:38 - folders which in my case
106:42 - is
106:42 - this one here
106:45 - so we go upfront folder to graphics and
106:47 - then to blocks
106:49 - and now if i print this information so
106:53 - print info
106:55 - and now if i run all of this we again
106:59 - can see our game and now in the bottom
107:01 - part we have a ton of data
107:04 - so let's talk through it
107:06 - essentially we get two bits of
107:08 - information so this first list we get
107:11 - here is kind of different from the other
107:13 - lists um let me actually explain
107:16 - essentially what work does
107:18 - it looks inside of a folder and it
107:21 - returns a couple of things
107:23 - the first bit of information we get is
107:25 - the folder path which is what we already
107:28 - have so we don't really care about it
107:30 - then we get all of the subfolders so my
107:33 - case we have blue bronze green gray and
107:35 - so on these are all of the folders
107:38 - inside of that main folder
107:40 - and then we have a third list and this
107:43 - one would contain all of the data
107:44 - besides the folders so any kind of image
107:48 - would be in here
107:50 - now this would be our first list but
107:52 - what work also does is it goes through
107:55 - every single subfolder inside of this
107:57 - folder and then gives us information on
107:59 - that as well
108:00 - for example
108:02 - here is the second list we get
108:05 - and in there we are looking at the blue
108:07 - folder
108:09 - and inside of the blue folder there are
108:11 - no subfolders so this list is empty
108:14 - but we have a ton of images so now we
108:17 - have bottom png bottom left png bottom
108:19 - right png and so on
108:21 - and this is the information i can use to
108:23 - import all of the data that i need
108:26 - although we do have a problem here that
108:29 - the structure of this list is
108:30 - inconsistent meaning that it changes
108:33 - after the first item so the first item
108:36 - here is kind of different from the rest
108:38 - of the list so we have to be very
108:40 - careful when working with this
108:42 - essentially the first thing i want to do
108:44 - is i have to identify the first element
108:47 - inside of the list being returned from
108:49 - walk and the easiest way to do this is
108:51 - to use the enumerate method
108:53 - and with that one we get index and we
108:56 - get info
108:58 - and now what i can do is if index
109:02 - is equal to zero
109:03 - so if we are on the first list
109:07 - what i can do with this information is
109:09 - to create a dictionary and then this
109:11 - dictionary is going to hold all of the
109:13 - data so let me actually implement this i
109:16 - want to call this self.assets
109:19 - and self.assets is going to be a
109:21 - dictionary comprehension so i want to
109:24 - create a color key
109:26 - with another dictionary inside of it and
109:30 - this for color in info
109:33 - and index number one
109:36 - so info 1 is just the name of all of the
109:39 - folders
109:40 - and let me actually print again the
109:42 - information
109:43 - that should make it a bit easier to
109:44 - understand what we are doing
109:46 - here we have all of our data again
109:49 - and right now i am exclusively looking
109:52 - at the first list
109:54 - and in here the graphics part we are
109:56 - just going to ignore but info one is
110:00 - this list here
110:02 - and really all i'm going to do is i'm
110:05 - going to cycle through every single item
110:07 - inside of this list and turn every
110:09 - single color into a key for a dictionary
110:11 - and then this key is going to be
110:13 - associated with another dictionary that
110:15 - for now is going to be empty
110:17 - so if i print self dot assets as well
110:22 - and run all of this again we again get
110:24 - our game that we don't care about
110:27 - we now have after the first item
110:29 - another dictionary that just says
110:32 - blue empty dictionary bronze empty
110:34 - dictionary green empty dictionary and so
110:36 - on and this is now going to be the
110:38 - structure for how we are going to store
110:40 - our data
110:42 - what that means in practice
110:44 - if the index is greater than zero so i
110:47 - can just add an else statement
110:49 - i want to go for image name in info
110:55 - and to
110:57 - so info2 are going to be all of the
111:00 - names of our files and this is what i
111:02 - want to look through
111:03 - and now i want to create a full path so
111:07 - this could for example be the full path
111:09 - to the top left inside of the blue
111:12 - folder or the top part or the right part
111:15 - and for that to work we need a few
111:17 - things first first of all i need to
111:19 - figure out my color type so do we have a
111:22 - blue piece right now do we have a bronze
111:25 - piece or a green piece
111:27 - and this we get with self dot assets dot
111:31 - keys
111:33 - and essentially in here
111:36 - i want to take the index
111:37 - minus one and index minus one is going
111:41 - to because we are essentially skipping
111:43 - index zero and then our first item
111:46 - inside of assets is going to have the
111:47 - index with zero
111:49 - and all of this i want to turn
111:52 - into
111:53 - a list
111:55 - and now that we have that i can just
111:58 - copy
111:59 - my
112:00 - graphics blocks
112:02 - i can add
112:04 - the color
112:05 - type
112:06 - and now we need something else for the
112:08 - color type because this has to be inside
112:11 - of an f string but a simple reason
112:14 - that we do need the slashes if we don't
112:17 - have those the whole thing is not going
112:19 - to work
112:20 - and finally we need image name
112:24 - and now this path here is going to be
112:27 - the full path to every single graphic
112:30 - inside of our graphics folder
112:32 - but let me just print what we actually
112:34 - get if i now run all of this again
112:38 - we are getting an error because
112:41 - the list
112:45 - let me get rid of the error message
112:47 - so
112:49 - we don't want to turn this entire thing
112:51 - into a list we want to turn only the
112:54 - keys
112:55 - into a list so then we can use indexing
112:58 - so now let's try this again there we go
113:02 - essentially what we have created now is
113:05 - let's say inside of this one here we
113:07 - have the player and we get
113:10 - each of the graphics inside of the
113:11 - player folder and this one is just going
113:14 - to be a string and that is what we
113:16 - wanted to import and this is going to
113:18 - happen for all of the folders so we have
113:21 - purple for example
113:22 - we have a red for example
113:25 - and discontinues
113:27 - and let me get rid of the print
113:29 - statements they are getting a bit
113:30 - annoying okay cool
113:32 - so now what we essentially have is a
113:35 - full path to each of the file we care
113:37 - about we can use that information now to
113:41 - just import all of these images and this
113:43 - happens with pygame.image.load
113:46 - we want to get the full path and then
113:49 - don't forget to convert
113:51 - alpha all of this
113:53 - and now we have to attach this surface
113:56 - to the assets dictionary
113:58 - and this is going to happen with self
114:01 - dot assets
114:03 - and in here i want to get the specific
114:05 - color type
114:07 - and this is then going to be another
114:10 - dictionary and inside of this dictionary
114:13 - i want to create another key and this
114:15 - key is going to be image name dot split
114:21 - and what we want to split
114:22 - is add a dot
114:25 - and then we only want to get the first
114:28 - index
114:29 - and then this
114:30 - is going to get the value of our surface
114:34 - now what does this line mean and i think
114:38 - this is best explained if i actually
114:40 - print
114:41 - self.
114:43 - assets and let's see what we get so if i
114:46 - now print all of this
114:48 - we are getting a lot of information but
114:51 - basically let's look at the first one so
114:54 - we have blue here
114:56 - and blue extends all the way to here so
114:59 - let me go to surface maker and we are
115:01 - looking just at the first dictionary
115:05 - and this
115:06 - self.blue
115:07 - we are getting with self.assets and the
115:09 - color type
115:11 - and now inside of this dictionary we get
115:14 - imagename.split
115:15 - add a period and then we get the first
115:18 - part of this index
115:20 - and essentially what that did is that
115:22 - for the first surface here for example
115:25 - the original name was bottom.png
115:28 - and what this imagename.split did is
115:30 - remove the png at the end of this bottom
115:33 - so that we don't have to work with the
115:35 - file extensions we just get the name of
115:37 - the file
115:38 - and once we had that
115:40 - we set the surface to the value of this
115:43 - dictionary and this we have done many
115:46 - many times over
115:47 - so again these lines really not that
115:50 - simple anymore i would recommend to go
115:53 - over them a couple of times if you're
115:54 - confused
115:55 - but this is actually all i needed
115:58 - and with that we have actually already
116:01 - covered the first part that we imported
116:04 - all of the graphics
116:05 - and i guess we also covered the final
116:07 - part that we want to return the final
116:10 - image
116:11 - so the last thing that we do have to do
116:14 - is to create a surface with the graphics
116:17 - that covers basically any size
116:20 - and for that we are going to need a bit
116:23 - of space
116:24 - first of all i do not want to fill the
116:27 - image we already have with a color
116:30 - so let me just remove it for now
116:33 - and now we have to blit essentially nine
116:36 - different things we need the four
116:38 - corners
116:39 - we need the four
116:40 - sides and we need the center
116:43 - color
116:45 - so let's start with one and let's see
116:47 - how far we get
116:49 - and before we can start on the corners
116:51 - we first need to know what color we are
116:53 - working with
116:55 - and this i want to do all the way at the
116:56 - top
116:57 - and for this one i created sites
117:01 - and sites is just going to be self dot
117:05 - assets
117:06 - and then we are going to get the block
117:09 - type
117:10 - so the block type in this case would be
117:12 - blue or green or bronze it really
117:15 - doesn't matter for now what we are going
117:17 - to get
117:18 - and for now
117:20 - we don't really work with this too well
117:23 - so
117:24 - for the image right now we are just
117:26 - getting the block type
117:28 - so let's say for now we're just going to
117:31 - change this to red
117:33 - and for the player i think it already
117:35 - said player yeah so this player already
117:38 - works
117:39 - and now we can actually start using that
117:42 - this section i think is getting really
117:44 - hard i hope it still makes sense
117:47 - but essentially all we want to do now is
117:49 - image.blit
117:51 - and we want to get sides and the side we
117:54 - want to get in here is top left
117:56 - and the position where we want to place
117:58 - it is 0 and 0.
118:01 - and now let's see what's going to happen
118:04 - this is looking much more interesting so
118:07 - now we get the top left for each of the
118:10 - blocks
118:12 - we should also be seeing something for
118:13 - the player let's actually have a look
118:16 - and if i look at my sprites and in the
118:19 - player
118:20 - the problem here is that after i created
118:22 - the image with surface maker i'm filling
118:25 - all of this with a red color so let me
118:27 - get rid of this one
118:29 - and now let's try this again and this
118:30 - one is looking better you can also see
118:32 - the top left of my player
118:34 - and now
118:36 - let's do the top right
118:38 - so image dot blit
118:41 - sides
118:42 - and now i want to get the top right
118:45 - but now i need a position
118:48 - or more specifically
118:50 - i need x and y
118:52 - now y is kind of easy because the top
118:55 - right should be at the top so this one
118:57 - can just be zero
118:58 - the left side is going to be a bit more
119:01 - difficult though so let me draw what i
119:04 - am going to do
119:05 - here is the surface we are going to
119:08 - create
119:10 - and the individual part i want to place
119:12 - right now should be in the top
119:15 - left
119:16 - and now i need an x and a y position
119:21 - now the y position can just be zero
119:23 - because it's supposed to be right on the
119:25 - top part
119:27 - but now for the x essentially what i
119:30 - want to do
119:31 - i want to get the entire width
119:35 - of the main surface let's call this w
119:40 - and from that i want to subtract the
119:43 - width
119:44 - of my smaller part
119:47 - let's call it
119:48 - w 2.
119:51 - so all i really have to do is get my w
119:55 - minus my w 2. and that way i would get
119:59 - to this point here which would be the
120:02 - left side of this part which is exactly
120:05 - what i care about
120:07 - so all i really want is to get size
120:10 - which is what i get up here
120:13 - and in there
120:15 - i want to get the first element which is
120:17 - my entire width
120:19 - and from that i want to subtract this
120:22 - surface here
120:24 - and then dot get underscore with
120:29 - and let me remove all of this so it's a
120:31 - bit easier to read
120:32 - so this is the entire size of our
120:34 - surface of the main surface and this is
120:37 - the width of the corner part so this
120:41 - should be working let's try and there we
120:43 - go now we have the top left and the top
120:45 - right for both the blocks and our player
120:48 - let's now do the top middle part and
120:51 - this one i want to have in the sides and
120:54 - now i don't just want to look at all the
120:56 - four sides let's do this a bit more
120:58 - methodically i just want to look at the
121:01 - top side
121:03 - and then here we need a few bits that
121:04 - are important
121:06 - since we want to scale the top part i
121:08 - need to know how wide this thing has to
121:11 - be so top width
121:13 - once we have that information
121:15 - i want to get something like scaled
121:18 - pop
121:19 - surface
121:20 - and this we get in a second
121:23 - and once we have that i just want to
121:25 - image dot blit
121:27 - then this scaled top surface
121:30 - and now we need an x and a y position
121:33 - now for y
121:34 - we already know this is going to be 0.
121:37 - the x we are going to figure out in just
121:39 - a second but let's start working on the
121:42 - top width
121:43 - and here again i think it's best to draw
121:46 - all of this out
121:48 - so here we have the entire width of our
121:52 - main surface so this is this image here
121:56 - and on that surface i already have a top
121:59 - left and a top right
122:03 - so essentially what i'm trying to find
122:05 - is this distance here
122:08 - and well if you look at it like this
122:10 - this should be fairly simple all we
122:12 - really have to do is get this entire
122:15 - width and from that subtract this size
122:18 - and this size and that way we are left
122:21 - with the part we actually care about
122:24 - and in practice what that means we again
122:26 - want to get size zero so that's the
122:29 - entire width of the window
122:31 - and from that we want to subtract
122:35 - sides
122:36 - and in here we have top left
122:39 - and from that i want to get underscore
122:42 - width
122:43 - and
122:45 - this i want to add two
122:48 - sides
122:49 - and we want to get the top right
122:52 - and this one also needs to get get
122:54 - with
122:55 - and with that we have the width we are
122:57 - going to need
122:58 - so now we have to use that information
123:00 - to scale that surface and this we are
123:03 - going to do
123:04 - with pygame dot
123:06 - transform dot
123:09 - scale
123:10 - and in here we need a surface and then a
123:13 - new width and a new height now the
123:16 - surface is kind of easy because we have
123:19 - sides and top
123:21 - and the width is going to be top width
123:25 - now the height i don't want to change so
123:28 - this one is just going to be sides
123:31 - and top
123:33 - and then get underscore height
123:36 - so with that we have our scaled top
123:40 - surface
123:41 - now all we have to figure out where to
123:43 - place this
123:44 - and if you again look at this graphic
123:47 - it should be fairly simple we
123:48 - essentially want to put this top surface
123:52 - on the right side of the top
123:54 - left so all we really have to do let me
123:58 - copy it from here
124:00 - we need to get the width of the top left
124:03 - and if i paste this in here we should be
124:06 - good to go let's try this
124:09 - and there we go now we have the top part
124:11 - let me remove all the drawings this is
124:14 - not looking bad at all
124:16 - and essentially now
124:18 - we have the basic system to make all of
124:20 - this work
124:21 - the rest of this entire system is just
124:24 - replicating all of this a couple more
124:26 - times so we need two more corners bottom
124:29 - left and bottom right and then we need
124:31 - left right and bottom for the sides
124:34 - and then we also need the center
124:36 - and i think this could be a really
124:38 - interesting challenge so to make sure
124:41 - you understand the system
124:42 - try to implement this yourself and see
124:45 - how far you get i do understand this
124:48 - entire system is quite complex
124:50 - so if you have to go over it a couple of
124:52 - times i would really recommend to do
124:54 - this if you're not sure about what you
124:56 - are doing
124:57 - it is well a bit more advanced so try as
125:00 - far as you can get
125:05 - i guess we can finish the corners first
125:07 - so we already have top left and top
125:09 - right next up we need bottom left and
125:11 - bottom right so image dot blit
125:16 - again i want the sides
125:18 - and now let's go with bot
125:21 - left
125:22 - and here again
125:24 - we are going to need x and y
125:28 - now in this case x is going to be the
125:30 - easier one because the bottom left
125:33 - should be on the left side
125:35 - and now we have to figure out the top
125:37 - part of this side
125:39 - and this we get with size 1
125:43 - and from that
125:44 - i want to subtract sides bottom left and
125:48 - i just realized i forgot a bracket
125:52 - so sides bottom left
125:55 - and from this one we want to get the
125:58 - height
126:00 - and let's try this one
126:02 - we got an error because probably some
126:05 - kind of bracket didn't work out
126:07 - i think it's this one
126:10 - let's try
126:11 - this one looks better all right
126:14 - so now we have the top left for all of
126:16 - our surfaces
126:17 - now finally we are going to need the
126:20 - bottom right and for that i am just
126:23 - going to copy the bottom left and change
126:25 - this one to
126:27 - bottom right
126:28 - now for this one
126:30 - the top part so the y position already
126:33 - works
126:34 - we just have to figure out the x aspect
126:37 - and this one we kind of already have
126:40 - because this one we essentially did when
126:42 - this line here so size 0
126:46 - let me paste it in here
126:48 - so size 0 minus sides this one should be
126:52 - [Music]
126:53 - bottom right
126:55 - and then get with and then the other
126:57 - side and this one should be all we need
127:00 - let's try this one and there we go
127:02 - now we have all of the corners
127:07 - so that is a really good start
127:10 - next up we need the
127:15 - left side
127:18 - we need the right side
127:20 - and we need the bottom side
127:23 - and this is all going to work very
127:25 - similar compared to what we have done
127:27 - here
127:28 - so i'm just going to copy
127:30 - this one
127:32 - and
127:33 - let's work with it
127:36 - so instead of top width
127:38 - it should be let's call it left height
127:42 - and in here we don't want the width of
127:45 - the entire thing we want the height
127:48 - and from that we want to subtract two
127:50 - things
127:51 - the top left is still fine but now we
127:54 - also want the
127:56 - bottom left
127:58 - and now we don't want to get the width
128:01 - we want to get the height
128:03 - and this should be done for both of them
128:07 - so with that we have the entire height
128:09 - that we need
128:10 - next up i want to get the scaled left
128:13 - surface
128:15 - highgame.transform.scale still works
128:17 - then i want sides this one should be
128:20 - left
128:22 - and now for the scaling
128:24 - i need a new w and a new
128:28 - height
128:31 - the height we just got that is going to
128:33 - be the left height now with is the
128:37 - easier part
128:38 - all we are going to need in here is
128:40 - sides
128:42 - left i think i called it
128:44 - and from that we need to get underscore
128:46 - with and we should be good to go
128:48 - now finally
128:50 - we need this scaled
128:53 - left surface
128:54 - this one should just be left
128:57 - as a matter of fact we want to put this
128:59 - on the left side so this one should be
129:01 - zero
129:03 - and now we have to figure out the top
129:06 - part of this surface
129:09 - and this one we get with sides
129:13 - and this one is going to be top left
129:16 - and now get underscore height
129:20 - and let's try this one
129:22 - and this one is also working just fine
129:24 - cool
129:26 - two more sides and then we are basically
129:29 - done with this one
129:30 - so now we have the right side and for
129:32 - this one we can actually copy the left
129:34 - side and this should be a good bit
129:36 - easier
129:38 - so now we want to get the right height
129:42 - slice.1 still works
129:44 - and now we want the top
129:46 - right
129:47 - get height and this one should be bottom
129:51 - right
129:53 - and get height still works just fine
129:56 - okay then next up we want scaled right
129:59 - surface
130:00 - and for this one program.transform.scale
130:04 - and the surface we want to scale
130:06 - is the right one
130:08 - and now we are going to need a new
130:11 - scaling so a new dimension and in here
130:15 - for the width we just want to keep the
130:16 - width of the original right side
130:19 - and we have a new
130:22 - right height and this one we can just
130:24 - reuse that's the one we get up here
130:27 - and then finally
130:29 - we want to place scaled
130:31 - right surface
130:33 - and now
130:35 - we need an x and the y we already have
130:38 - so this one can stay the same because
130:40 - both the right and the left side should
130:43 - have the same top part although i guess
130:45 - for this one we can go with top
130:47 - right
130:48 - so now what we have to figure out is
130:50 - where to place the left side of this
130:53 - surface and with this one again we need
130:55 - the full size of the entire surface so
130:58 - the full width
131:01 - and from that
131:02 - i want to get sides
131:04 - at the right side
131:08 - and from that i want to get the whiff
131:11 - and with that we should be having our
131:13 - right side and this one is working as
131:15 - well cool
131:16 - almost done with this part
131:19 - now for the bottom side i want to copy
131:22 - my top side because this one is the
131:24 - closest to it
131:26 - and now top width is going to become
131:29 - bottom width
131:31 - we still want to get the full size minus
131:34 - the bottom
131:35 - left
131:36 - dot get with
131:38 - last the bottom
131:40 - [Music]
131:41 - right dot get with then we have a scaled
131:45 - bottom surface
131:47 - and then here we want to place the
131:49 - bottom or we want to scale this one
131:53 - and we have the
131:55 - bottom width
131:56 - and sides
131:58 - bottom dot get height
132:01 - and this one should stay the same
132:03 - because we want to keep the same height
132:06 - now we have to scaled
132:08 - bottom surface
132:10 - and now finally we just need to figure
132:13 - out our position
132:15 - and the left side is still totally fine
132:18 - so this one we can just keep now we just
132:20 - have to figure out the top and here
132:22 - again i want to get the full height of
132:25 - the entire surface
132:27 - and from that i want to subtract
132:30 - sides
132:32 - bottom and
132:34 - dot get
132:36 - the height of this one
132:39 - and with that we should be done let's
132:42 - try this one now and this is looking
132:44 - nearly done
132:46 - we have two more issues to work on we
132:48 - have to fill the center
132:50 - and we have to get rid of the black
132:51 - color on the edges
132:53 - i guess the center is the easier part
132:55 - because we have this one right here and
132:58 - for this one we are going to need two
133:01 - attributes
133:02 - we need center
133:04 - height and we are going to need center
133:07 - width
133:08 - and once we have that we can create a
133:11 - scaled
133:12 - center
133:14 - and this one then is just going to be
133:16 - pygame dot transform dot scale
133:20 - and in here we already have besides
133:23 - center
133:24 - and i just want to scale this to center
133:28 - width
133:29 - and center height
133:31 - and once we have that i can just image
133:34 - dot blit
133:35 - scaled
133:38 - center
133:39 - and then i have to figure out an x and a
133:42 - y
133:43 - so let's work through these parameters
133:46 - so let me give a bit more space
133:49 - essentially what we have right now
133:53 - this thing here again
133:55 - is going to be our entire image
133:59 - and what we have so far is a couple of
134:02 - corners so these four corners here
134:07 - and besides that we have the sides so we
134:09 - have the left side we have a top side we
134:13 - have a right side
134:14 - and we have a bottom
134:17 - the only part we don't have yet is this
134:19 - center bit here
134:22 - and the x and the y position we're
134:24 - trying to figure out here is going to be
134:26 - this
134:27 - top left position
134:29 - and the center height and center width
134:31 - is going to be this one for the height
134:34 - and this one for the width so these are
134:37 - the bits of information we are trying to
134:39 - figure out
134:41 - so for the center height i want size
134:44 - 1
134:46 - so my height of the entire image
134:48 - and from that i want to subtract
134:51 - this bit here
134:53 - and this bit here
134:55 - which in practice means
134:57 - sides
134:59 - and we want the top
135:01 - and then get underscore height
135:05 - and plus
135:06 - sides
135:09 - and bottom and this one is also going to
135:12 - get right
135:15 - so with that we have the height
135:17 - next up we need to center with and this
135:19 - one works in pretty much the same way as
135:22 - a matter of fact let me copy the entire
135:24 - thing
135:26 - so now instead of the height we want to
135:28 - get the width
135:29 - and now sides this should be right
135:33 - and this should be left
135:35 - and now we don't care about the height
135:37 - we care about the with
135:40 - or both of these
135:44 - and this one works by itself already so
135:48 - the last one we have to figure out is
135:49 - the x and the y part
135:51 - and in here
135:53 - essentially
135:55 - what we care about is this point here
135:57 - again
135:58 - and this point is literally just the
136:00 - width and the height of the top left so
136:03 - this is what we can pass in here
136:06 - so i can just get rid of the entire
136:07 - thing
136:08 - and sides
136:10 - and i want to get the top left
136:13 - and get
136:16 - size and now let's try this
136:20 - and there we go now we have a filled
136:22 - center this one feels significantly nice
136:27 - the last thing we have to do
136:29 - is to get rid of the black edges and
136:32 - this one we can do all the way at the
136:34 - top and really all we have to do in here
136:36 - is set a color key so set underscore
136:39 - color key
136:41 - and this essentially tells pygame to get
136:43 - rid of one specific color which in our
136:46 - case is 0 0 and 0.
136:49 - so now the game is looking drastically
136:52 - better
136:55 - and well you could add any other color
136:57 - in here if you ever wanted to get rid of
136:59 - something specific in terms of color and
137:01 - pie game this is how you would do it
137:04 - especially when you are using sprite
137:06 - sheets this one is being used all the
137:08 - time
137:10 - okay
137:11 - and with that we have the entire surface
137:15 - maker that was way more complicated than
137:18 - i thought it would be
137:20 - so ah well done if you could keep up
137:22 - this one really wasn't easy
137:25 - okay now what we have to do next
137:28 - is actually
137:31 - make sure we get the colors right
137:33 - so
137:34 - right now they're all red they're still
137:36 - working but well we only have one color
137:40 - and this is going to happen inside of
137:42 - our sprites so let me minimize
137:44 - everything else and blocks i want to
137:46 - keep open
137:48 - so right now the problem that we have is
137:51 - we always pass red into our surface make
137:54 - and obviously that is not ideal so
137:57 - instead what i want to do
137:59 - is to use this color legend
138:01 - and this one basically converts a number
138:03 - to a color
138:05 - so in my sprites
138:06 - basically what i want to do is get my
138:09 - color
138:10 - legend
138:12 - and in here pass in the block type
138:16 - and now let's try this one
138:18 - and now we have some nice looking colors
138:21 - already a massive upgrade and
138:25 - let's see if i can get to the second row
138:27 - without dying too often
138:30 - okay
138:32 - not going terribly well
138:35 - i'm really bad at this game um okay so
138:38 - now
138:39 - we get this one should disappear yep
138:41 - this is looking good cool
138:43 - now the one problem that we do have
138:45 - is that the health of the blocks does
138:47 - update but the color doesn't change with
138:49 - them which makes the game look kind of
138:52 - weird so when the ball hits one of these
138:54 - blocks i want them to change their color
138:58 - and basically what i want to do
139:01 - if the block gets damaged we want to
139:04 - subtract the health by whatever amount
139:06 - we have
139:07 - and then if our health is greater than
139:09 - zero
139:10 - i want to create
139:12 - a new self dot image
139:15 - and the image we want to create is self
139:18 - dot surface maker dot get underscore
139:21 - surface
139:22 - and then here we need to get what kind
139:24 - of block we want to have and for this
139:27 - one i am again going to use the color
139:29 - legend so let me copy it from up here
139:32 - but now we don't want to look at our
139:34 - block type
139:35 - instead
139:37 - we want to look at our self.health
139:41 - the problem now is that this self.health
139:44 - is an integer so i want to turn this
139:47 - into a
139:48 - string
139:50 - so that it's going to work with this
139:51 - dictionary here just fine
139:53 - and the other thing we need are the
139:55 - dimensions of our block so
139:58 - this is just something we can
140:00 - copy from the initial part and this
140:04 - should be all we need
140:06 - so now let's try this one again
140:09 - these blocks still just disappear
140:12 - this is look fine just takes a second to
140:15 - hit the second row and yeah there we go
140:18 - so now the green blocks turn blue once
140:21 - we hit them and if we i hope i can hit
140:24 - them again
140:33 - so they are disappeared
140:35 - and i guess we can try to go to the
140:37 - third row and see if this one still
140:39 - works and yeah there we go
140:42 - this seems to be working really really
140:44 - well
140:45 - nice
140:47 - so with that i think we have a really
140:52 - basic game so that was a really long
140:56 - section um sorry that got a bit
140:57 - complicated
140:58 - i hope you could follow along
141:00 - we definitely got over the worst part
141:02 - now we can work on the easier bits
141:04 - and the next part i want to work on is
141:06 - adding some hearts
141:08 - so the player can see how many hearts
141:09 - are left and if there are zero left then
141:12 - the game is over this part should be
141:14 - really simple in fact let's jump
141:16 - straight back into the code and let's
141:19 - implement all of this here i'm back in
141:21 - main.pi and in my indian method
141:25 - i would like to add another section and
141:27 - let's call this one hearts
141:30 - and all i really want to do in here is
141:32 - self.hard underscore surface
141:35 - is going to be pygame.image.load
141:39 - and the path towards that is going one
141:42 - fold up then graphics
141:45 - then we have other and then hard dot png
141:49 - and don't forget we want to convert
141:52 - alpha all of this
141:53 - and now i want to run
141:56 - another method or create another method
141:59 - that i called display
142:01 - arts
142:03 - we need self and nothing else
142:06 - and in here let me give a bit more space
142:09 - i want to do something like for i in
142:13 - the amount of health the player has
142:15 - let's say for now it's just going to be
142:17 - free we're going to make this a bit more
142:18 - flexible in just a
142:20 - second and well if that is the case i
142:24 - just want to self dot display
142:26 - surface dot blit
142:29 - and now again i need a surface and a
142:31 - position
142:32 - the surface is very easy it's self dot
142:35 - hard surface
142:37 - now for the position we are going to
142:39 - need x and y
142:41 - now why in my case is really easy i just
142:44 - set this to four
142:46 - so that we have four pixels between the
142:48 - top of our heart and the top of the
142:50 - window
142:51 - now x is going to be a bit more
142:53 - difficult
142:54 - and essentially all i want to achieve
142:56 - let's say we have
142:59 - three hearts or well in my case boxes
143:01 - but doesn't really matter
143:03 - and what we have to place is this left
143:06 - side
143:08 - and essentially what i want to do i want
143:10 - to get this i here
143:12 - and multiply it with the width of
143:16 - each of these hearts so if i is zero
143:19 - this is going to be zero but if i is one
143:23 - then this position here
143:25 - is going to be one times the width of
143:27 - each of these surfaces
143:29 - so if the heart is 40 pixels wide this
143:31 - would be 40.
143:33 - and that way these surfaces would be
143:36 - right next to each other
143:37 - that's really the entire idea here
143:40 - and let's put all of this in a separate
143:42 - variable let's actually call it x
143:45 - i want to get i
143:46 - and multiply this with self dot
143:49 - art surface and get underscore with
143:53 - and in my run method
143:56 - i can just let's put it in draw the
143:58 - frame so self dot display
144:02 - arts
144:03 - and if i run this now
144:05 - we are getting an arrow that oh this
144:08 - shouldn't be free this should be
144:11 - a range object so now let's try this
144:13 - again there we go now we can see hearts
144:15 - although we have another problem now
144:17 - that hearts are overlapping with all of
144:21 - the blocks
144:22 - which isn't ideal right now
144:25 - and what i have done to overcome this is
144:29 - in here
144:30 - i have set a top
144:33 - offset and all this one really is is the
144:36 - window height
144:38 - divided by 30.
144:40 - and now when we run the stage setup so
144:44 - this one we created a while back and we
144:47 - are placing y
144:50 - i want to add the top
144:53 - offset
144:54 - to all of that so we basically just move
144:57 - all of these positions down by a few
145:00 - pixels
145:01 - so now if i run this
145:03 - we have some more space at the top
145:05 - that's really all we did which feels
145:07 - much cleaner
145:08 - and to make this thing a bit more clean
145:11 - i want to add a bit of a gap between
145:13 - each of the hearts
145:15 - which also isn't difficult to add let me
145:17 - minimize these other methods again
145:20 - so basically all i want to do
145:22 - is make this width wider than the actual
145:25 - surface so let's put it in brackets and
145:27 - let's say plus four
145:29 - and now if i run this
145:31 - there is a bit more space between them
145:33 - might even be a bit too much let's put
145:35 - this to two if that fits better yeah it
145:38 - definitely feels better
145:40 - and now to give them a bit of an offset
145:41 - to the left
145:43 - i want to add
145:45 - two to all of this so now let's try this
145:48 - again and now the hearts look really
145:50 - nice
145:51 - the one thing we now need to figure out
145:53 - is that this three right now is entirely
145:55 - static so instead i want to change this
145:58 - to
146:00 - self.player.hearts or lives or whatever
146:03 - you want to put in there it doesn't
146:04 - really matter
146:05 - so then in my player class
146:07 - i have to add another attribute in here
146:10 - that is self dot hearts
146:12 - and by default this is going to be free
146:15 - so now if i run this we shouldn't be
146:17 - seeing any change and we don't but now
146:20 - if i change self.hearts to let's say
146:22 - something like 10
146:25 - this is looking perfectly fine
146:27 - but let's keep it at free
146:30 - and now all we have to figure out is
146:31 - that if the player misses the ball this
146:33 - self.hearts should be reduced by 1. so
146:36 - let me minimize the player and here we
146:39 - have the ball
146:40 - and in our window collision
146:42 - we have
146:43 - this part here where we check if the
146:45 - board has failed
146:47 - and if that is the case we just want to
146:50 - set self dot player dot hearts
146:53 - minus equal one
146:55 - and now let's try this
146:59 - so
147:00 - there we go we lost one heart if i do
147:02 - this again we're losing another heart
147:04 - i can do this again and now we have zero
147:07 - hearts so this doesn't help us
147:10 - and essentially
147:12 - all we want to do
147:14 - in my run method
147:16 - so let me minimize the display hearts
147:19 - and now what i want to do
147:22 - in my event loop right now i'm checking
147:24 - if event type is pygame.quit
147:27 - and i want to add or self.player.hearts
147:32 - is smaller or equal to zero
147:35 - and now let's try this again
147:37 - and let me deliberately fail this time
147:40 - and now the game should end there we go
147:44 - now the game ended by itself so this is
147:47 - also working well so with that we have
147:50 - some hearts
147:52 - so let me minimize all of these methods
147:53 - the game is getting quite complex
147:56 - so for the next part i want to work on
147:58 - the upgrades
148:00 - basically whenever a block gets
148:02 - destroyed we want to create an upgrade
148:05 - and this is just going to be a simple
148:07 - sprite that falls downwards and if it
148:09 - collides with the player the player gets
148:11 - some kind of upgrade so the player could
148:14 - become wider it could get lasers it
148:16 - could get faster
148:17 - and it could get an extra life i think
148:19 - those are the four upgrades i have and
148:22 - that's basically it so let's go straight
148:24 - to it and let's implement all of this
148:26 - here i am back in main.pi and the first
148:28 - thing i want to do is in sprites.pi
148:31 - because in here i want to create another
148:34 - class and this one will be called
148:37 - upgrade
148:38 - and again this is going to be pygame dot
148:40 - sprite dot sprite and it's not going to
148:44 - be a complicated class all we really are
148:46 - going to do is give this an init method
148:49 - we need self we need a position
148:51 - we need to upgrade type and we need what
148:55 - groups this thing is supposed to be part
148:56 - of and now in here we again need our
148:59 - super dunder init method and pass the
149:02 - groups in here and now first of all
149:05 - self.upgradetype we want to turn into an
149:08 - attribute so upgrade type
149:11 - next up we have to create a self.image
149:14 - and self.rect and for the image i just
149:17 - need pygame.image.load
149:21 - and for the path here i want to create
149:23 - an f string for the simple reason that
149:25 - my path is one fold up
149:28 - graphics
149:29 - upgrades
149:31 - and inside of upgrades i have my upgrade
149:35 - type and let me illustrate what that
149:37 - means so here's the folder we have
149:40 - graphics we have upgrades and in
149:43 - upgrades we have heart laser size and
149:45 - speed and when i have my upgrade type
149:48 - they are going to be named in the same
149:49 - fashion
149:50 - and that way all of this is working and
149:52 - don't forget we need to convert alpha
149:54 - this as well
149:56 - and now
149:57 - for the rectangle all we need is
149:59 - self.image.getrekt
150:02 - and in here the mid top
150:04 - should be
150:06 - the position we place in there
150:09 - and now since we are going to move this
150:11 - we also need self.pos
150:14 - which is going to be
150:16 - pygame.math
150:19 - with
150:21 - self.wrecked.top left
150:23 - and then we need self.speed
150:26 - which i have set to 300
150:30 - and this thing also is going to need an
150:33 - update method that needs self and delta
150:35 - time
150:36 - and this part is going to be super
150:38 - simple we just want to move it downwards
150:40 - so self dot pos dot y
150:43 - plus equal
150:46 - self.speed multiplied by delta time
150:49 - and for this one we don't need any kind
150:51 - of direction because well we only move
150:54 - in one direction
150:56 - and now we also have to set self.rect.y
150:59 - is going to be round self.y
151:02 - and there's one more important thing
151:04 - that if self.direct.top
151:07 - is greater than
151:10 - window height
151:13 - let's say plus a hundred and if that is
151:16 - the case we want to destroy this sprite
151:19 - just so that we are making sure that we
151:21 - don't end up with too many upgrades that
151:22 - we can't get rid of anymore so this is a
151:26 - totally fine upgrade class
151:28 - now we just have to figure out when to
151:30 - spawn them
151:32 - so we need some kind of information in
151:34 - our block because the block knows when
151:37 - the block is being destroyed
151:39 - the problem is that the player also
151:41 - needs access to these upgrades so i want
151:44 - to keep the upgrades a bit more
151:45 - accessible so what i'm going to do
151:48 - i am going to import
151:50 - the upgrades
151:52 - to my main.pi file
151:54 - and in here
151:56 - i am going to create another method
151:59 - and this one i'm going to call
152:01 - create
152:03 - up great
152:04 - and this one itself and nothing else
152:08 - and in here first of all i want to
152:10 - create an upgrade type
152:13 - which should just be
152:15 - a random item from a list so we need
152:17 - choice again which we don't have right
152:19 - now so from random import choice
152:23 - but now what kind of list do we have in
152:25 - this list i want to keep in my settings
152:27 - so in here i have another entry i want
152:31 - to add
152:32 - and this one just looks like
152:35 - this
152:36 - so i have my upgrades i have speed laser
152:38 - heart and size
152:40 - and those are the same items i have in
152:42 - the folder
152:43 - so now i can just copy upgrades and pass
152:46 - it in here
152:47 - and with that i am going to get a random
152:50 - upgrade
152:51 - now next up i want to actually create
152:54 - the upgrade class or one instance of
152:57 - that and now let me copy all of the
152:59 - parameters we need we need position
153:01 - upgrade type and groups
153:04 - now position
153:05 - i want to get from the parameters how
153:07 - that works you're going to see in just a
153:08 - second
153:09 - upgrade type is going to be upgrade type
153:12 - this one we already have
153:14 - now next up this one always has to be in
153:17 - all sprites
153:20 - besides that i want to create another
153:22 - group that i called upgrade sprites
153:26 - and this we need to create
153:28 - in our sprite group setup so self dot
153:32 - upgrade sprites is going to be
153:34 - pygame.sprite.group
153:37 - so all we have to figure out now is when
153:40 - to call this method here
153:42 - and this i want to call from the blocks
153:46 - so in my stage setup when i am creating
153:49 - a block
153:50 - they should have
153:52 - this create upgrade so i'm going to pass
153:55 - this function in there as an argument so
153:58 - make sure here to not call this method i
154:01 - just want to pass the function itself or
154:03 - the method itself
154:05 - and this should be self.create upgrade
154:08 - so now let me minimize everything else
154:12 - in the block we need another argument
154:15 - and that is create
154:18 - upgrade
154:19 - and
154:20 - let me add another section down here so
154:22 - self. create upgrade
154:25 - is going to be create upgrade
154:28 - and before we are destroying the sprite
154:31 - i want to self dot create and upgrade
154:36 - and the position i want to pass in here
154:38 - is self.rect.center
154:42 - and that should be all we needed so
154:45 - let's try now
154:46 - and we are getting an error and that is
154:48 - that we cannot find the file graphics
154:51 - upgrades and speed
154:53 - and the problem here is quite simple
154:56 - so
154:56 - in my upgrade class
154:59 - igame is unable to find this file here
155:02 - and the reason for that is that this one
155:05 - needs dot png at the end so now let's
155:07 - try this again now we have another error
155:10 - this vector 2 should be capitalized
155:13 - and next attempt
155:14 - there we go
155:16 - now we have a couple of upgrades i hope
155:18 - we get some more different ones yep this
155:20 - is looking good we get a lot of speed
155:23 - once i don't actually know why i think
155:25 - it's just random
155:26 - okay um
155:29 - random module is very strange today yeah
155:30 - okay this one's looking better
155:33 - okay um
155:34 - yeah this one i think is getting better
155:37 - cool so it's definitely working except
155:40 - something is wrong with the random
155:41 - module today that we don't seem to get
155:43 - proper randomness
155:44 - um all right
155:49 - this is working just fine
155:51 - now the problem is that we don't want to
155:54 - spawn an upgrade
155:56 - every single time a block dies
155:59 - so we only want to randomly call this
156:02 - method here in like 20 or 30 of the
156:04 - cases
156:05 - and in my case for that i used randint
156:08 - so we have to import that one as well
156:11 - and all i really have done in here is if
156:13 - randint between 0 and 10
156:16 - is smaller than 3 and only then i am
156:19 - going to create an upgrade
156:21 - so let's try this one now we don't get
156:23 - an upgrade
156:26 - now we should be getting one very soon
156:32 - let's hope it's still working
156:43 - there we go okay
156:45 - uh yeah the numbers might be a bit very
156:47 - low but they are working
156:50 - for the purpose of this tutorial i can
156:53 - change this to smaller than nine
156:56 - so we can see something and there we
156:59 - definitely get more of them
157:01 - okay so it is definitely working now
157:04 - next up what we have to figure out is
157:07 - the collision between the player and the
157:09 - upgrades
157:10 - and that is just going to be another
157:12 - method inside of our main game
157:15 - so in here let's call it upgrade
157:18 - collision
157:19 - this one itself and nothing else and in
157:22 - here again we have to create overlap
157:25 - sprites
157:27 - and this could actually be a good
157:29 - challenge that i want you guys to check
157:31 - the collision or well the overlap
157:33 - between the player and the upgrades
157:36 - and if that is the case i want you guys
157:38 - to write another method inside of the
157:40 - player and call it from this method here
157:44 - by passing in the sprite type of the
157:47 - upgrade and see how far you get
157:52 - now first of all i need pygame dot
157:54 - sprite dot sprite polite
157:58 - and i need self dot
158:01 - layer
158:02 - i need self dot upgrade sprites for the
158:06 - group and then do kill has to be true
158:10 - and now for sprite in overlap sprites
158:16 - i want in my player
158:18 - to run some kind of upgrade method and
158:21 - there is going to be one argument and
158:22 - that's going to be sprite dot upgrade
158:26 - type
158:28 - so in my sprites let's minimize every
158:30 - single thing in here they always have an
158:33 - upgrade type and this is what i want to
158:35 - place inside of that method
158:37 - so now inside of our player
158:41 - we need to create another method let me
158:44 - minimize everything else in here
158:46 - so define
158:48 - up rate
158:50 - we need self and we need an upgrade
158:52 - type
158:54 - and for now let's just say we want to
158:56 - print
158:57 - the upgrade
158:58 - type
158:59 - and let's see if this is working oh
159:01 - actually right now it cannot work
159:04 - because we are not calling this method
159:07 - and this i want to do
159:09 - when i update the game
159:11 - so self dot upgrade collision and there
159:14 - were no arguments
159:16 - so let's try this now and we get size
159:19 - we get new upgrade we get speed
159:23 - and i am surprisingly bad at this we get
159:25 - size again and we get hard in laser
159:28 - oh and the game ended because i ran out
159:30 - of hearts but it's definitely working
159:33 - so now in here
159:35 - we just have to figure out what to do
159:37 - with these upgrades
159:39 - and well let's go through them one by
159:41 - one
159:42 - so the first one is if upgrade
159:46 - type is equal to speed
159:50 - and if that is the case self dot speed
159:54 - i want to set to plus equal 50.
159:57 - and if upgrade type
160:00 - i call this one heart
160:03 - i want to set self dot parts plus equal
160:07 - one
160:08 - and let's see if those two are working
160:10 - let's hope i can get a heart and there
160:12 - we got a heart and we lost the heart but
160:14 - i hope you saw it
160:15 - um okay let's try this one again
160:17 - speech
160:19 - this one
160:21 - uh okay i do have to try to get a heart
160:24 - without losing your heart straight away
160:27 - but uh okay
160:29 - seems more difficult than it looks
160:32 - there we go laser
160:34 - last try
160:40 - okay but i think you get the idea i
160:43 - don't want to stretch this out too much
160:46 - yeah we can get a heart ah there we go
160:48 - now we have four hearts so this is
160:49 - working nice
160:52 - next up we have if upgrade type
160:55 - is equal to
160:56 - size
160:58 - and in this case we want to increase or
161:02 - create a new width
161:04 - and this we get with self.direct.width
161:07 - and multiply this with 1.1
161:10 - so our new width is going to be 10 wider
161:13 - than the old width
161:14 - and this i want to use to create a new
161:16 - self.image
161:18 - and this
161:19 - again i am going to use my surface maker
161:22 - for with get underscore surface
161:25 - we have to pass in
161:27 - layer
161:29 - and now we need our new weft
161:32 - and for the height i just want to get
161:33 - self.rect.height
161:36 - so this way we are going to get a new
161:38 - image and now i also have to update the
161:40 - position so self.wrecked
161:43 - is going to be self dot image dot get
161:46 - underscore rect and the center is going
161:48 - to be
161:49 - self.rect.center so where the old center
161:52 - used to be
161:53 - and now since we updated the rectangle
161:55 - self.pause.x
161:58 - has to be self.direct.x so this one
162:01 - doesn't get confused
162:02 - and now before we are going to try this
162:07 - let me
162:08 - in the create upgrade method
162:10 - comment this one out
162:12 - and let's change the upgrade type to
162:15 - size
162:17 - so now we should only get size upgrades
162:20 - and this should make it easier to
162:21 - visualize what's going on
162:24 - this seems to be working just fine we
162:27 - are definitely
162:29 - rowing
162:30 - quite well yeah this is definitely
162:32 - working
162:35 - and in here again
162:36 - we need the surface maker to keep this
162:39 - surface looking good if we didn't do it
162:42 - this would stretch out more and more and
162:44 - look increasingly weird
162:47 - okay but this one is certainly working
162:54 - all right nice so now i can set this one
162:57 - back to normal
163:00 - and finally
163:01 - we have to work on the lasers
163:04 - so if upgrade type
163:07 - is equal to
163:09 - laser
163:10 - and all i want to do inside of this
163:12 - method is self dot
163:15 - laser
163:17 - amount
163:18 - plus equal one
163:20 - and for that to work
163:21 - we first of all need a laser so let me
163:24 - add another section here
163:26 - laser
163:27 - and self dot laser
163:30 - amount by default is going to be zero
163:33 - and since we want to display an extra
163:36 - graphic if there is a laser we have to
163:39 - import another surface let's call this
163:42 - one laser surface
163:45 - and in here we need
163:47 - pygame.image.load as always
163:49 - and the path is going to be one fold up
163:52 - graphics
163:54 - other
163:55 - laser dot
163:57 - png
163:58 - and as always convert
164:01 - alpha
164:03 - and another thing i do want to do is
164:05 - self dot laser underscore rects
164:09 - and by default it's going to be an empty
164:10 - list you're going to see in a second how
164:12 - that is going to work
164:14 - now the upgrade method we are done with
164:17 - and what i want to do
164:19 - is self dot let's call it display
164:23 - lasers
164:25 - in itself and nothing else
164:28 - and in here i want to check if self
164:32 - dodge laser amount
164:35 - is greater than zero so
164:37 - if that is true we know there is going
164:40 - to be a laser
164:42 - and now what i'm trying to do this is
164:44 - the size of our player
164:47 - and i want to place lasers there
164:50 - dynamically now i know the bottom of the
164:53 - laser it's going to be here
164:56 - and now i just have to figure out
164:58 - where on the x-coordinate i have to
165:00 - place my lasers so here here and here
165:04 - and so on
165:06 - so how can i figure that one out
165:08 - and essentially what i did
165:10 - i am always dividing the entire width of
165:13 - this surface
165:15 - by the amount of lasers plus one
165:19 - so if we have one laser
165:22 - we are going to divide the player by one
165:24 - over two
165:25 - if we have two lasers we are going to
165:28 - divide the player into three bits
165:31 - and then this distance here
165:34 - we are going to use from the left to
165:36 - place the laser so if we only have let
165:39 - me use a different color if we only have
165:41 - a single laser
165:43 - we're going to go from this point on the
165:44 - left
165:46 - half weight of the size of the player
165:48 - and place the center of the laser here
165:52 - and if we have two lasers so this part
165:55 - here we are going to go one third so
165:58 - roughly here
165:59 - and then we are going to go another
166:00 - third so roughly here and place a laser
166:03 - here and here
166:05 - and then the more lasers we get the
166:07 - smaller this distance is going to get
166:11 - and first of all i want to get what i
166:14 - called a divider
166:16 - length
166:18 - and this one is just going to be
166:20 - self.rect.width
166:22 - divided by
166:24 - self dot laser
166:27 - amount
166:28 - plus one
166:30 - and now for i in
166:32 - range
166:34 - self dot
166:35 - laser amount
166:38 - i want to create a new rectangle let's
166:42 - call it
166:43 - laser
166:44 - rect
166:46 - and this laser rectangle is going to be
166:48 - self dot laser
166:50 - underscore surf dot get underscore rect
166:54 - and i want to place the mid bottom of
166:57 - this rectangle
166:58 - and this one is going to be needing an x
167:01 - and a y position
167:02 - now the y position is easy it's just
167:05 - self.rect.top
167:07 - so the top of the player
167:09 - x again is going to be a bit more
167:11 - complex so let me place this one in a
167:13 - separate variable
167:16 - and essentially all i really want to do
167:18 - in here is self.direct.left
167:21 - plus
167:22 - divider length
167:25 - and i want to multiply this with i
167:29 - however the problem now is that this i
167:32 - by default is going to be 0. so i want
167:35 - to take this i
167:36 - and add plus 1 to it
167:39 - and now we are very nearly done
167:43 - once we have this list i can just loop
167:46 - over for laser
167:49 - wrecked
167:50 - in self dodge laser
167:53 - rects
167:55 - and in their self.display
168:00 - surface which i think the player has
168:03 - no the player actually doesn't have so
168:05 - we have to import the display surface in
168:07 - here as well
168:08 - and let's do it straight in the setup so
168:11 - self dot
168:12 - display surface
168:15 - is going to be pygame
168:17 - dodge display dot get
168:19 - underscore surface and this is going to
168:22 - get us the display surface
168:24 - and this i now want to use down here
168:27 - and then
168:28 - blitz
168:30 - our
168:32 - self torch laser
168:35 - surface
168:36 - and then the laser
168:38 - wrecked
168:40 - i want the one thing i forgot is self
168:42 - dot laser rects dot
168:46 - append
168:48 - laser
168:49 - rect
168:51 - so the problem we have right now if we
168:53 - left the code like this we would keep on
168:56 - adding more and more lasers
168:58 - so at the beginning
169:00 - of this method i'm going to set
169:02 - self.laser rects
169:05 - to an empty list
169:07 - that way we are creating all of this
169:09 - from scratch every single time and all
169:13 - right
169:14 - the only thing we have to do now
169:16 - is to actually call all of this
169:20 - so all the way at the bottom of my laser
169:22 - self.display
169:25 - lasers and let's see if this is working
169:28 - so we now get an error so far and if i
169:30 - know if in laser we can't see anything
169:36 - now the reason for that is this
169:39 - we are basically
169:42 - drawing our lasers inside of this method
169:44 - here so when we update the sprite we are
169:48 - calling display lasers
169:50 - the issue is then
169:51 - we are drawing the background after that
169:55 - so if i were to move my background
169:57 - on top of all of this
170:00 - then we should be able to see lasers so
170:02 - now let's try this and there we can see
170:04 - a laser
170:05 - it doesn't do anything right now but it
170:08 - definitely works
170:10 - and even if we have two lasers let me
170:12 - try a few more times
170:14 - maybe i find a few more
170:20 - now the important thing here is that
170:22 - this laser mechanic
170:24 - also works with multiple lasers and even
170:28 - if the player gets wider this system
170:31 - still works
170:33 - so okay we get faster but this seems to
170:36 - be working just fine and somehow pygame
170:40 - really likes the speed upgrade for some
170:43 - reason
170:45 - okay let's try this one again and right
170:48 - now you can see because we have too many
170:49 - upgrades it looks a bit silly but it
170:52 - definitely works
170:53 - so i guess we can just
170:55 - draw
170:56 - the background here
170:58 - and this one still works just fine
171:01 - cool so now
171:03 - we can see the lasers so let me minimize
171:05 - this one and let me minimize this one as
171:08 - well
171:08 - this one
171:10 - as well
171:11 - now we have to figure out the projectors
171:13 - for the laser
171:14 - and
171:15 - i guess let me minimize all of this
171:17 - stuff here so it's a bit easier to see
171:19 - what's going on
171:21 - now for the projectile this is just
171:24 - going to be another sprite that this one
171:27 - just moves upwards
171:28 - so i want to add another part in here
171:32 - and let's call it the projectile
171:35 - and this one is just going to be
171:37 - self.projectile
171:39 - underscore surface
171:42 - and for this one we need pygame dot
171:44 - image load
171:46 - and in here the path is going to be
171:50 - one folder up
171:51 - graphics
171:52 - then other and then project tiles.png
171:58 - and don't forget to convert
172:01 - alpha all of this again
172:03 - so now we have an image of a projectile
172:06 - let me minimize the init method again
172:10 - and now i want to create another method
172:14 - and this is going to be create
172:17 - projectile
172:19 - needs self and nothing else
172:22 - and all i need to do here is for
172:25 - projectile
172:27 - in self.player.laser
172:30 - underscore rects
172:32 - so the rectangle list we just created
172:36 - and if that is the case i want to create
172:38 - a projectile instance of a class that
172:40 - does not exist yet so we have to create
172:43 - this one as well
172:45 - and this happens again in sprites
172:48 - so let's do it all the way at the top
172:50 - and class project tile
172:53 - and again this is just going to be
172:55 - pygame.sprite.sprite
172:58 - and this one is just about to be the
173:00 - easiest class you can have so this one
173:03 - needs an image and a rectangle and then
173:05 - also a position and a speed so we can
173:07 - move it upwards and this could be a good
173:09 - challenge for you so try to create this
173:13 - entire class it should only be about 10
173:16 - lines of code in total
173:18 - and you will need a position you have
173:20 - the surface from main.pi and you will
173:22 - need the groups to place it in all
173:23 - sprites so see how far you get
173:29 - first of all i again need a dunder init
173:33 - method
173:34 - and this one is going to need self a
173:36 - position a surface
173:39 - and groups
173:42 - and now in here i again need a super
173:45 - under init method
173:47 - that is going to get groups as an
173:49 - argument
173:50 - then i need self.image
173:53 - is going to be the surface we get from
173:55 - the parameters
173:56 - and self.rect
174:00 - is going to be self dot image dot get
174:02 - underscore rect and we want to place the
174:05 - mid bottom
174:06 - where we have our position
174:09 - now besides that we again need
174:10 - self.position
174:12 - and this is pygame.math.vector2
174:17 - and here a self.wrecked dot
174:20 - left
174:22 - and finally self.speed
174:24 - in my case it's just 300 it's basically
174:27 - random choose whatever you like
174:29 - now once we have that i need an update
174:31 - method with self and delta time
174:34 - and in here all we are going to do is
174:36 - self.pause dot y
174:39 - minus equals self dot speed multiplied
174:42 - with delta time
174:44 - and then
174:45 - self.rect.y is going to be rounded self
174:48 - dot pos dot y
174:51 - and finally
174:52 - we again want to check if
174:54 - self.rect.bottom
174:57 - is smaller or equal to negative 100.
175:01 - so now since the laser is moving upwards
175:03 - we want to check if the bottom of the
175:05 - laser is on top of the window and if
175:08 - that is the case we want to destroy that
175:10 - sprite
175:11 - again here if we don't need a sprite on
175:14 - the window we shouldn't keep it around
175:17 - it might hamper our performance
175:19 - but alright this is all we need
175:22 - for our projectile
175:25 - so now back in my main.pi actually
175:28 - before i do that let me copy all of the
175:31 - parameters
175:32 - and place them in here
175:35 - and let me fix the typo on player
175:38 - first of all we are going to need a
175:40 - position and in here i want to go with
175:43 - projectile dot mid top
175:46 - and remember projectile in this case
175:49 - refers to
175:50 - a laser rectangle
175:52 - but i don't want this thing to spawn
175:55 - right on top of it i want to give it an
175:57 - offset so
175:59 - i want to subtract pygame.math.vector2
176:04 - 0 in x and let's say
176:07 - 30 in the y direction
176:10 - and you have to use a vector here
176:13 - because mid-top is essentially a tuple
176:15 - okay next up surface this one is the
176:18 - easiest all we need in here is
176:21 - self.projectile surface
176:23 - and let me put all of these arguments on
176:26 - separate lines so all of this is easier
176:29 - to read
176:32 - okay now finally for the groups
176:36 - as with all the other sprites this one
176:39 - has to be in all sprites
176:41 - but i also want another group with self
176:43 - dot projectile
176:46 - sprites
176:48 - and this again has to be in the init
176:51 - method
176:52 - we need
176:53 - self.projectile sprites is going to be
176:56 - pygame.sprite.group
177:00 - and now the last thing we need is to
177:02 - actually run this method whenever the
177:04 - player presses space and this in my case
177:07 - is going to happen in the run method
177:09 - in this event loop
177:12 - so if the player is pressing space i
177:14 - want to run
177:15 - self.create projectile
177:18 - and let's see if this is working and we
177:21 - are getting an error that there is no
177:23 - file called projectiles and i think the
177:26 - reason is i call this one projectile not
177:28 - projectiles
177:30 - so
177:31 - in the init method this should be just
177:34 - projectile now let's try this again it
177:37 - does seem to work oh yeah we have no
177:39 - lasers right now so
177:41 - just to keep the game running
177:43 - when the game is starting i want my
177:46 - player to already have two
177:48 - lasers
177:50 - so now if i press
177:52 - we get some kind of laser the issue we
177:54 - have now is if i press really fast we
177:57 - have more and more lasers which is a bit
178:00 - too easy for all of this so i want that
178:02 - to be some kind of timer
178:05 - that makes sure that the player cannot
178:07 - fire continuously
178:09 - and for that
178:11 - i want to create self dot let's call it
178:14 - can underscore
178:16 - shoot and by default this one is going
178:19 - to be true and besides that we need self
178:22 - dot shoot
178:24 - time
178:26 - by default is just going to be zero it
178:28 - doesn't really matter what it is
178:31 - and now
178:33 - in
178:34 - the event loop
178:36 - we only want to be able
178:38 - to create a projectile if self dot can
178:41 - shoot
178:43 - and once we have done that self dot can
178:45 - shoot
178:46 - is going to be false so now if we run
178:49 - this we should be able to shoot once but
178:50 - not again which seems to be the case
178:53 - so this one works perfectly well right
178:55 - now
178:56 - so what we have to create now is another
178:59 - method that works as a timer to
179:01 - reactivate can shoot and this one
179:04 - just another self dot let's call it
179:08 - laser
179:09 - timer
179:10 - we need self and nothing else in here
179:14 - and basically what i want to do
179:17 - let me create a timeline
179:21 - so this is the timeline of our game and
179:23 - essentially what i want to do if the
179:25 - player shot a laser at this time here
179:27 - let's say this is
179:29 - one second
179:31 - from this point
179:33 - i want to check our time so i check the
179:36 - time here
179:37 - and let's say at some point we get to
179:41 - the second second
179:43 - and as a consequence i know that this
179:45 - difference here
179:47 - is going to be one
179:49 - second
179:50 - and if this distance is greater than one
179:52 - second i want to reactivate the laser
179:55 - now in practice it should be less than
179:57 - one second one second really is quite
179:59 - long
180:00 - i think for mine half a second felt
180:02 - perfectly fine but the idea is
180:06 - quite simple
180:07 - now first of all i need to figure out
180:09 - the time when the player has shot the
180:11 - laser and this also happens down here
180:14 - when we actually shoot the laser
180:16 - all i need is self.shoot time the other
180:19 - attribute i just created
180:21 - and self.edu time it's just going to be
180:23 - pygm.time.get
180:25 - underscore ticks
180:28 - and now in my laser timer
180:32 - i can run
180:34 - if pygame.time.getticks
180:36 - so this is always going to be our
180:38 - current time
180:40 - and from that i want to subtract self
180:43 - shoot time
180:45 - and if that number is greater than let's
180:47 - say 500 milliseconds
180:49 - i want to set dot can shoot
180:52 - back to true and that is all we needed
180:55 - for a timer
180:57 - so now when we are updating our game
181:00 - self.laser
181:03 - timer
181:04 - and let's run this
181:06 - still works i can keep on pressing space
181:09 - but now we only shoot in half a second
181:12 - intervals
181:14 - which i think is looking kind of okay
181:19 - so let me minimize the run method as a
181:22 - matter of fact i want to minimize all
181:23 - methods
181:25 - so it looks a bit cleaner okay now
181:28 - there's one more method that we are
181:30 - going to need
181:31 - so
181:32 - let's create another method and let's
181:34 - call this one projectile
181:37 - block
181:39 - collision
181:40 - we need self and nothing else in here
181:43 - and now
181:45 - we basically have to write one simple
181:47 - method
181:48 - so i want to check for projectile in
181:53 - self.projectile sprites
181:55 - and in here i again want to get my
181:58 - overlap
181:59 - sprites and this is just going to be
182:01 - pygame dot sprite dot
182:04 - sprite
182:05 - for light
182:07 - and i want to check one sprite which is
182:10 - going to be my projectile
182:12 - then i want to check myself dot log
182:14 - sprites
182:16 - and finally should be false because we
182:18 - do not want to destroy the sprite
182:20 - and now in here i want to check if there
182:23 - are overlapping sprites in the first
182:25 - place
182:26 - and if there is an overlapping sprite i
182:29 - want to check for sprite in overlap
182:32 - sprites
182:34 - and if that is the case i just want to
182:36 - call sprite dot get
182:38 - underscore damage
182:40 - do one amount of damage so this get
182:42 - damage we have already created let me
182:46 - have a look so in the block class we
182:48 - have get damage and this one we created
182:51 - for the ball but we can reuse it for the
182:53 - projectiles so get damage one
182:56 - and now what is really important we also
182:59 - have to destroy the projectile
183:02 - so if there's an overlap i want to call
183:05 - projectile.kill
183:09 - and if we didn't do this line of code
183:11 - we would get more and more overlaps here
183:14 - and the lasers would basically destroy
183:16 - all of the blocks in one go
183:19 - and all right now all we have to do is
183:22 - to actually call this method so
183:24 - self.project
183:27 - lock collision
183:29 - and let's try this one
183:32 - and this seems to be working just fine
183:35 - obviously it's really really strong so
183:38 - you do want to be careful in using it
183:40 - but by itself this is working
183:42 - very very well
183:46 - and does make the game significantly
183:47 - more fun and also a lot easier
183:50 - okay but definitely some progress
183:53 - and now we are nearly done there are two
183:56 - more things that i would like to cover
183:58 - and that is crt styling and sounds now
184:02 - sounds is incredibly easy we just have
184:04 - to import a couple of sounds and play
184:06 - them at certain points in our game
184:08 - so that's not a part i'm really
184:09 - concerned about
184:12 - the more important bit is the crt
184:15 - styling and this one well it's not
184:17 - particularly complicated but essentially
184:21 - what we are going to do
184:22 - we are going to create another surface
184:24 - on top of our game and on this new
184:27 - surface we are going to create some
184:29 - black lines and a vignette and this one
184:31 - is going to simulate this old crt style
184:34 - and then we are going to alternate the
184:36 - opacity of this between some random
184:39 - values and that way we are getting the
184:41 - illusion of flickering
184:44 - here we are back in main.pi and inside
184:48 - of this file i would like to create
184:50 - another class and this one i called crt
184:55 - there is no inheritance but we do need
184:58 - an init method
185:01 - and this one itself and nothing else and
185:04 - in here we first of all want to import
185:06 - the vignette and this one is just going
185:09 - to be an image so we can just import it
185:12 - as vignette and to import it we need
185:14 - pygame.image.load
185:16 - and the path that we need is one fold up
185:20 - graphics
185:21 - other and in there i have a file called
185:23 - tv.png
185:26 - and in here make sure to convert alpha
185:30 - all of this the problem we have right
185:33 - now is that this vignette is not scaled
185:35 - up properly
185:37 - but this
185:39 - we can change let's call this one self
185:41 - dot scaled
185:44 - vignette
185:45 - and in this case we want this vignette
185:48 - to have the exact same size as our
185:50 - window
185:52 - otherwise it would look kind of weird
185:54 - that we have one part of the shadow
185:56 - going outside of the window so all i
185:58 - really want to do is
185:59 - pygame.transform.scale
186:01 - [Music]
186:02 - i want to pass in my vignette in here
186:05 - and now i need a width and a height
186:08 - and what i really means is the window
186:10 - width
186:11 - and the window height
186:13 - so now i have a vignette
186:16 - and now there's one more thing that we
186:18 - are going to need and that is self dot
186:21 - display surface
186:22 - and this again we are getting with
186:25 - pygame dot display dot get underscore
186:28 - surface
186:29 - and now that we have all of that we can
186:32 - actually test this method or this class
186:36 - and essentially all i want to do is
186:38 - create a draw method that needs only
186:40 - self
186:41 - and for now i just want to get self dot
186:44 - display surface dot blit
186:46 - and i want to blit myself dot scaled
186:49 - vignette
186:50 - at position zero and zero
186:54 - and this method
186:56 - i would like to run in game.run
186:59 - after we have drawn all of the other
187:01 - elements and this could be a challenge
187:03 - for you so try to call this drum fit to
187:07 - draw this vignette on top of all of the
187:09 - other elements
187:13 - first of all in my game init method
187:17 - i have to create an instance of crt so
187:20 - let's call it crt and self.crt
187:24 - is going to be crt
187:27 - and now let me minimize all of the
187:29 - methods so it's a bit easier to see
187:31 - what's going on
187:32 - in the run method now
187:34 - after we have drawn all of the other
187:37 - elements
187:38 - i want to add let's call it crt styling
187:42 - and all i really have to do in here is
187:44 - self.crt.draw
187:47 - and now let's see what we get
187:50 - this is then already looking a bit
187:52 - better
187:53 - so now we have some vignette that
187:56 - doesn't look half bad
187:57 - the problem is that this vignette is too
188:00 - dark right now
188:01 - so especially in the top left and top
188:03 - right we can hardly see the blocks which
188:06 - isn't ideal
188:08 - so
188:09 - we want to lower the opacity
188:12 - of this surface here
188:15 - and while we are doing that
188:18 - i want to set this to a random opacity
188:20 - on every single frame
188:22 - and essentially what that means i want
188:24 - to get myself dot
188:27 - scaled vignette
188:29 - and set the alpha to one value and you
188:33 - could set for example 60 in here
188:36 - and if we run this now this is looking
188:38 - much less pronounced
188:41 - oh and now we can see the hearts again
188:42 - as well that one was missing before as
188:44 - well
188:45 - and in here
188:47 - 255 would be the maximum and 0 would be
188:51 - well nothing
188:53 - so if we have 60 we are at about a
188:56 - quarter something like that
188:58 - but in my case i don't want to keep this
189:00 - at 60 instead
189:02 - i want to get a random integer which i
189:06 - don't have yet so i have to import it so
189:09 - import rent in from random
189:13 - and now i want to have an alpha value
189:15 - let's say between 70 and 90.
189:19 - and since this updates every single
189:21 - frame we should be getting
189:24 - some very light flickering
189:26 - may even be a little bit too strong but
189:28 - you can play around with this let's say
189:30 - we can set this to 75
189:33 - and
189:35 - yeah i think this feels good
189:40 - so with that we already have our
189:42 - vignette
189:44 - now besides that what we also want to do
189:48 - is create another method and let's call
189:50 - this one create crt
189:53 - lines
189:55 - and this is to simulate the lines that
189:56 - all tvs used to have
189:58 - and then here we need self and nothing
190:00 - else
190:02 - and basically all we are going to do now
190:05 - is we are going to take this scaled
190:07 - vignette and we are going to draw a
190:10 - couple of lines on top of it so if i'm
190:12 - drawing all of this
190:14 - here we have our entire window
190:17 - and right now on another surface we have
190:19 - the vignette that covers something like
190:22 - this area here
190:24 - so all of this yellow bit is our
190:26 - vignette
190:28 - and on the same surface where we have
190:30 - the vignette i want to create a couple
190:32 - of lines quite a few
190:34 - and this one is going to simulate these
190:36 - old tv lines
190:38 - so we are basically going to take the
190:40 - scaled vignette surface and paste
190:42 - something on them
190:44 - and to get this started we first of all
190:46 - need a couple of parameters the first
190:48 - one is the line height which in my case
190:50 - i've set to four so that's the distance
190:53 - between each line
190:55 - and then once we have that we need a
190:57 - line amount
190:59 - and essentially what we are going to do
191:01 - in here is window height
191:05 - lower divided by the line height
191:08 - so if our window height is 720 and we
191:11 - have a line height for four
191:14 - we should be getting about 180 lines i
191:17 - think
191:18 - and once we have that all we have to do
191:20 - is for line in range
191:23 - line
191:24 - amount
191:26 - and now basically all i want to do is
191:28 - pygame dot draw dot line
191:31 - i need a surface so self dot scaled
191:34 - vignette
191:36 - then i'm going to need a color which in
191:38 - my case will be black
191:41 - and then i will need
191:43 - a start position and an end
191:48 - position and i would recommend for you
191:51 - to try to figure out the start and the
191:53 - end position for each individual line
191:55 - here so see if you can figure this out
191:57 - yourself
192:02 - now the first thing that we are going to
192:05 - need
192:06 - is that both the start and the end
192:08 - position is an x and a y position or
192:12 - rather a value
192:15 - and we know for the start position since
192:18 - the line is always starting on the left
192:19 - side x
192:21 - is always going to be zero
192:23 - and we know on the end point of that
192:25 - line it's always on the right side of
192:28 - the window so this one can just be
192:30 - window
192:31 - width
192:32 - the actually interesting part is the y
192:35 - position
192:36 - and this i want to store in a separate
192:38 - variable
192:40 - and in here well all we really have to
192:43 - do is get our line so this number here
192:46 - and this would be a number between 0 and
192:47 - 180 right now
192:49 - and this i want to multiply
192:52 - with my line height
192:54 - meaning the first line would be on
192:56 - position 0 the second on position 4 then
192:59 - position 8 and this would then go all
193:01 - the way up to 720
193:03 - and this is now giving us y
193:06 - and now finally
193:07 - all we need to do is define a line width
193:11 - which in my case i'm going to go with
193:12 - one
193:13 - and now all we have to do in the init
193:16 - method
193:17 - all
193:18 - self.create
193:20 - crt lines and this should be working
193:23 - and there we go now we have some crt
193:26 - lines
193:27 - i guess
193:28 - the effect might be a little bit too
193:30 - strong so we might want to work with the
193:32 - opacity a tiny bit more
193:35 - but other than that i think this is
193:36 - looking pretty good
193:39 - and
193:40 - let's change the opacity to
193:44 - 60
193:45 - to
193:47 - 75
193:51 - yeah i guess this one's working
193:54 - i guess another thing that you could be
193:57 - doing
193:58 - is change this black
194:00 - to
194:00 - a slightly brighter value so let's say
194:03 - 20 20 and 20.
194:07 - and that makes the lines less visible as
194:10 - well but well play around with this and
194:13 - see what you think looks best but i'm
194:16 - quite happy with this
194:18 - and all right with that we have our crt
194:24 - so now all we have to do
194:27 - is to add the sound and we are done with
194:30 - it
194:31 - and we have a couple of different sounds
194:34 - so we have fail impact laser laser hit
194:37 - music and power up
194:39 - which basically play when the ball is
194:41 - failing when the ball hits a block when
194:43 - the laser is being shot when the laser
194:45 - hits the background music and when the
194:47 - player gets the power up so these are
194:49 - all the sounds you want to play under
194:51 - certain circumstances
194:53 - and this should be one of the easiest
194:55 - parts of this tutorial
194:57 - so
194:58 - let's go through them one by one and
195:01 - this really shouldn't be too hard in
195:02 - fact i would recommend you to try to
195:04 - implement all of the sounds yourself if
195:07 - you've gotten this far this really
195:09 - shouldn't be much of a challenge
195:11 - i guess i can start with the ball this
195:13 - one is going to have quite a few
195:14 - different sounds
195:16 - and in here let me minimize all of the
195:19 - methods
195:20 - in the init method
195:24 - i want to add some
195:26 - sounds
195:28 - and the first sound i get is self dot
195:30 - impact sound
195:32 - and to import sound we need pygame dot
195:35 - mixer dot sound
195:37 - and in here
195:38 - we need to go one fold up and sounds and
195:42 - then impact.wav
195:45 - and now what i also want to do is self
195:47 - dot impact sound dot set underscore
195:51 - volume
195:53 - and i've set this to 0.1 so 10 of the
195:56 - original volume
195:58 - it did get quite loud and besides that i
196:02 - want to have self.fail
196:04 - sound
196:05 - and this one is pygame.mixer.sound
196:09 - we need the same folder so one folder up
196:12 - sounds
196:13 - and then we have
196:15 - bail dot wav
196:19 - and now self dot fail sound dot set
196:23 - volume this one should also be 10
196:27 - and now
196:28 - in the window collision
196:30 - down here
196:31 - if the ball is failing we want to play
196:34 - self dot fail sound dot play
196:38 - and that's all we needed besides that in
196:41 - the other collisions
196:43 - if there's any collision in here
196:45 - or in here
196:47 - we want to play that sound
196:49 - i want to call this inside of each
196:51 - individual if statement so in here self
196:54 - dot impact sound dot play and this i can
196:59 - now just copy around for each of the if
197:02 - statements
197:04 - and there we go
197:08 - and all right with that we should be
197:10 - having some sounds
197:13 - and we're getting an error message that
197:14 - sounds.fail doesn't exist
197:17 - that's easy to fix all i have to do
197:20 - is change the dot to a slash
197:23 - and now let's try this again
197:29 - we should be having some impact sounds
197:31 - and
197:32 - some fail sounds this is working quite
197:34 - well
197:37 - cool so with that we have the sounds for
197:40 - the ball
197:41 - it wasn't all that hard actually
197:44 - i guess next up we can work in main
197:48 - and in the game class because in here we
197:51 - are going to have a few more sounds
197:54 - just to save me some writing let me just
197:56 - copy all of this this should speed
197:58 - things up a good bit
198:00 - and what i want to get
198:02 - are these sounds
198:04 - so we have the laser sound we have a
198:05 - power up sound and we have laser hit
198:08 - sound
198:09 - and all of them are set to 10
198:11 - except for the laser hit sound this one
198:13 - is even less loud because um i don't
198:16 - know this felt better there wasn't
198:17 - really a specific reason
198:20 - and now all we have to figure out is
198:22 - when to play these sounds and since we
198:24 - have dedicated functions
198:26 - or well methods for each of them we can
198:29 - just work with that
198:30 - so create upgrade we can ignore create
198:32 - bg we can ignore stage setup we don't
198:35 - need display hearts we don't need
198:37 - upgrade collisions that's the first one
198:40 - we need
198:40 - because in here if there's a collision
198:43 - self power up sound dodge
198:47 - lay
198:49 - and then in create projectile
198:51 - if we are creating a projectile
198:54 - i want to play that sound
198:56 - and this shouldn't be in the projectile
198:58 - because if we play the same sound
199:00 - multiple times it might sound weird so i
199:03 - just want to play this one sound once so
199:05 - self dodge laser
199:07 - sound dot play
199:10 - and now finally
199:12 - we have projectile block collision
199:15 - and in here for every overlap we want to
199:18 - play
199:19 - the sound so
199:21 - self dot
199:23 - laser hit sound i think i called it dot
199:26 - play
199:28 - and let's try all of this
199:35 - and this feels a lot more arcadey
199:40 - and yeah this really changes the feel of
199:42 - the game substantially
199:47 - cool
199:48 - quite happy with that
199:51 - add now back in the init method
199:54 - let me minimize everything again and i
199:56 - just want to look at the init method
199:58 - there's one more thing that we do need
200:00 - and that is self.music
200:03 - and this one we get with
200:04 - pygame.mixer.sound
200:07 - and in here basically the same path we
200:09 - want to get to sounds and in the app we
200:12 - have music.w
200:14 - and for this one we want self.music.set
200:19 - volume
200:20 - to 0.1
200:23 - and this one we want to play straight
200:25 - away so self.music.org
200:29 - and in here we need one argument and
200:32 - that is loops
200:34 - which should be negative one so we play
200:36 - this continuously
200:38 - and now we should be done
200:42 - [Music]
200:57 - [Music]
201:12 - okay cool that was it that tutorial
201:15 - ended up a good bit longer than i
201:17 - expected but i hope you enjoyed it and
201:19 - i'll see you around