00:01 - hello there in this tutorial we are
00:03 - going to be creating a minecraft style
00:05 - menu into
00:05 - cena game engine it's going to look like
00:07 - this and
00:08 - it's a pretty straightforward project
00:10 - takes about an hour and there isn't
00:12 - really anything too difficult to do
00:15 - so if you're beginning on a scene out
00:16 - this should be a pretty useful project
00:17 - to understand the entire engine
00:19 - that being said if you have no idea
00:21 - about it i would recommend to check out
00:23 - this other tutorial i made first it's
00:25 - going to be quite helpful to understand
00:26 - the basics
00:28 - but yeah besides that should be pretty
00:30 - straightforward now
00:31 - another thing to give some credit i
00:33 - didn't start entirely from scratch for
00:35 - this project
00:36 - instead i have taken some of the
00:37 - official examples and modified it quite
00:39 - a bit to make it more understandable
00:42 - so if you want to know where i came from
00:44 - check out this
00:45 - github page it's the official example
00:47 - for this same kind of project
00:49 - although with some slight modification
00:51 - and i think a bit more difficulty built
00:53 - in
00:54 - but uh yeah with that being covered
00:56 - let's jump into it and i hope you enjoy
01:00 - all right so before we get into the
01:02 - actual code let's first talk about the
01:04 - theory here
01:05 - and there are a couple of bits that are
01:06 - a little bit more complicated
01:08 - so let's talk about all the important
01:10 - concepts we need to understand to make
01:12 - all of this work
01:13 - number one we need an item that we can
01:15 - drag around that's like the main point
01:17 - of this whole project
01:19 - and luckily ucena makes doing this
01:21 - really easy
01:22 - because there's an object called the
01:24 - draggable and it's called the draggable
01:25 - because you can drag it around
01:27 - the name makes sense here so this part
01:29 - is incredibly easy and we are going to
01:31 - implement this in just a bit
01:34 - now the second part is slightly more
01:36 - complicated
01:37 - because when we drag around items we
01:39 - don't just want to drag them in random
01:41 - places
01:42 - instead we want to drag and drop them
01:44 - into specific parts so they snap into
01:46 - the cell
01:47 - and this unfortunately is going to be
01:49 - slightly more complicated
01:50 - because there's no inbuilt methodologina
01:52 - that makes all of this work by default
01:55 - now that being said it's not that hard
01:57 - to do because we can still access the
01:59 - position
02:00 - of every draggable item and when we use
02:02 - a little bit of math here
02:04 - we can place them in very specific
02:05 - positions that would correspond to the
02:07 - grid
02:08 - really all we are doing is we are taking
02:10 - a position we are rounding it in a
02:11 - certain way
02:12 - to turn a 0.25 into a 0.2 for example
02:16 - that's
02:16 - really all we are doing here and that's
02:19 - basically it for all the really
02:20 - important concepts we are going
02:22 - to need obviously there are going to be
02:24 - a couple of smaller bits but i guess i
02:26 - can explain them as we go along
02:28 - so with that being said let's actually
02:30 - jump into the project
02:31 - and to get this started i just want to
02:33 - create a basic window that has a
02:35 - background for the menu
02:36 - so right now we are literally going to
02:38 - just create a window with a background
02:40 - image that's all that's going to happen
02:41 - here
02:42 - so here i have an entirely empty sheet
02:44 - of code and this sheet of code is saved
02:46 - in the same folder as a couple of images
02:48 - that we are going to use in just a bit
02:50 - for example there's the background image
02:51 - for the menu there are a couple of
02:53 - textures for the items
02:55 - and also the cell image and whatever you
02:57 - want to call it
02:58 - so make sure these are all saved in the
02:59 - same folder or at least the same project
03:01 - if you use something like pycharm now
03:04 - with that we can actually get started by
03:05 - creating our basic window
03:06 - and a background for the menu so the
03:08 - first thing i want to do is from
03:10 - usina import star
03:13 - so we are importing literally everything
03:15 - from mussina and don't have to write to
03:17 - cena at the beginning
03:18 - now next up we have to create our app
03:20 - for c now
03:21 - and this happens by just calling usina
03:24 - itself
03:25 - and then we have to run this app ideally
03:27 - spell it correctly
03:29 - and if you do that and you run the code
03:32 - you can see a basic window it doesn't
03:34 - redo anything right now
03:35 - but that is going to come in just a
03:37 - second so this is the very basic setup
03:39 - you need for cena
03:40 - now the first thing i want to add is a
03:42 - background image for the menu
03:44 - and this is literally just going to be
03:46 - an image nothing else
03:48 - so a very very simple setup and this is
03:51 - going to happen in a class
03:52 - that i'm going to call it bg and this
03:54 - one has to inherit from
03:55 - entity and in here we have to define our
03:59 - inet method
04:01 - call self on it and then here we have to
04:03 - create our super
04:04 - init method and in here we are going to
04:07 - need four
04:08 - different attributes the first one is we
04:10 - have to define the parent
04:11 - and this basically means that we are
04:13 - going to attach it to the world
04:15 - and there are two different options here
04:17 - number one you can attach something to a
04:19 - scene or to the world
04:20 - and this means you are going to place it
04:22 - into a 3d world
04:23 - but that's not what we want we want to
04:25 - have this 2d image right
04:27 - at the screen and to achieve that we
04:29 - need the other way which is called
04:31 - camera.ui
04:33 - and this basically means that we are
04:34 - gluing something on the screen that the
04:36 - player is looking through so it's right
04:37 - in a 2d space
04:38 - in the center of the view so next up we
04:41 - have to define the shape
04:42 - and this happens with model and for
04:44 - model i want to go with quad
04:46 - so we have a basic square and this would
04:49 - already be a basic start
04:51 - if we are going to create an instance of
04:52 - this class so let me call it
04:55 - bg and create an instance of it and now
04:58 - if i run this
04:58 - we can see a big white square well
05:01 - grayish square
05:03 - so that's a start i suppose but
05:06 - that doesn't really look like a
05:08 - background for menu so i want to
05:10 - add one more thing for now and that's
05:11 - going to be the scale
05:14 - and all we have to do in here is to
05:15 - define an x and a y
05:17 - scale and both of these have to between
05:19 - 0 and
05:20 - 1 with 1 being the full width oh well
05:23 - you could make it larger than one but
05:24 - then you would make it larger than the
05:25 - original size
05:27 - in my case i want to go with 0.56
05:30 - and 0.86
05:33 - and now if i run this you can see
05:36 - something that looks a lot
05:37 - more like the menu we are going to
05:39 - create in the end and now you might be
05:41 - wondering
05:42 - why did i choose those specific numbers
05:44 - and
05:45 - keep the thought in mind it's a really
05:47 - good thought i'll come back to it in
05:48 - just a bit
05:50 - but for now there's one thing missing
05:52 - because if i run
05:53 - this entire code again we don't just
05:55 - want a plain
05:56 - grayish background we want to have a
05:58 - texture on it and for that
06:00 - we have to load a texture which is
06:02 - really just an image
06:04 - and all we need in here is to call load
06:06 - texture
06:08 - and attach a string of the file we want
06:11 - to add
06:12 - in my case this is called bg.png
06:16 - and now if we run this we can see a much
06:19 - more minecrafty looking background color
06:22 - cool so this one is already working
06:24 - quite well now obviously right now this
06:27 - doesn't really look like much
06:28 - because we just have a static image that
06:30 - doesn't do anything
06:32 - so we want to add a draggable item to it
06:34 - and that is actually super easy because
06:36 - usina has a draggable object
06:38 - and this one is literally just an entity
06:41 - that you can drag around
06:42 - and in addition to that it has two
06:44 - methods that are being called
06:45 - automatically
06:46 - and they're called drag and drop and
06:49 - well they're named kind of appropriately
06:51 - whenever you drag the draggable the
06:53 - direct method is called and whenever you
06:54 - drop the draggable the drop method is
06:56 - called
06:57 - that should make sense i think and along
06:59 - with that you can also call the position
07:01 - of all
07:02 - of this there are a couple of ways of
07:03 - doing this actually
07:05 - but yeah let's actually implement this
07:07 - and then i am going to explain how all
07:09 - of this works
07:11 - so here we are back in the code and i
07:13 - want to add another class
07:15 - and i called this one item and this one
07:17 - has to inherit from
07:19 - draggable but besides that we still need
07:22 - to call
07:23 - an indeed method and we also still need
07:27 - our super method to initiate the thing
07:30 - fully that's just a part of usina
07:33 - and now in here we have to specify a
07:35 - couple of things
07:37 - first up again we need a parent and for
07:39 - now this is going to be camera.ui
07:41 - although we are going to change this
07:43 - later on i'll explain it then
07:46 - now same thing for the shape we want a
07:48 - model and this one should be a quad
07:50 - because we want squares next
07:53 - up i want to give this a color just to
07:54 - see what's going to happen and for this
07:56 - we need color
07:57 - and color dot let's go with red for now
07:59 - so we can see what's happening
08:00 - and this is actually already all we need
08:04 - so let me create an instance of this
08:05 - item so item
08:07 - is going to be item don't forget to call
08:10 - it
08:10 - and now let's run this and we have a
08:13 - giant red square in the middle
08:15 - but the really important part here is if
08:17 - i direct this with my mouse
08:19 - i can drag it around so this is already
08:22 - working quite well
08:24 - now obviously this red square is way too
08:26 - big so let's scale it down ever so
08:28 - slightly
08:29 - and for that again i need scale and
08:32 - let's go with 0.1
08:33 - and 0.1 just for now and now with a much
08:37 - more reasonably sized square
08:39 - so this we can already move around quite
08:41 - a bit
08:42 - and this is already starting to shape up
08:44 - to look halfway decent
08:46 - so that's a really good start now along
08:48 - with that
08:49 - we can make this thing quite a bit more
08:51 - powerful
08:52 - and this is by adding the drag and drop
08:54 - method
08:55 - and uh let's start with the drag one so
08:58 - it's just a method of the class
08:59 - it needs a self as well and then here
09:02 - let's for now just print
09:04 - uh let's call it drop drag that would
09:07 - make more sense
09:08 - and then we can also define a drop
09:11 - method
09:12 - in just the same way and here we want to
09:15 - print
09:16 - drop so now let's try the entire thing
09:19 - again
09:20 - and have a look at the bottom left of
09:22 - the screen where you can see the console
09:24 - and now if i drag it you can see drag if
09:26 - i drop it you can see drop
09:28 - so this is super useful
09:32 - and the reason it is super useful is
09:34 - because we can
09:35 - print a ton of attributes of this class
09:37 - in here
09:38 - for example we could print self.x
09:41 - or when we drop it we could print self.y
09:46 - and now let's try this
09:50 - so if i drag it we get an x position
09:53 - if i drop it a y position so we can tell
09:56 - the specific position of wherever we put
09:59 - this object
10:00 - so this is that what we are going to use
10:02 - later to
10:04 - position it in this specific kind of
10:06 - grid
10:07 - and that's going to come back but this
10:09 - is super important
10:11 - and i guess for now we can change this
10:14 - ever so slightly
10:17 - let's turn this into an f string so you
10:19 - can actually tell what's going
10:21 - on
10:25 - and let me just do this for both
10:28 - coordinates
10:30 - so we can have a much clearer
10:33 - understanding of what's going to happen
10:35 - and uh yeah let's just do this for drop
10:38 - so i don't show too many things at once
10:43 - so now let's run this again and now
10:45 - whenever i drop
10:47 - this square we can tell an x in the y
10:49 - position
10:50 - and in here there's something that's
10:52 - kind of particular about ucena
10:54 - that we don't really get an x in the y
10:55 - position like in pi game
10:57 - instead we get like a 0.01 float value
11:01 - um we can still use it perfectly fine
11:03 - although it's
11:04 - i don't find it particularly nice to
11:05 - work with but usina was designed for 3d
11:08 - space and for that this kind of makes
11:10 - sense
11:10 - but yeah it's not a problem it's just
11:13 - annoying
11:14 - so nothing to worry about so with that
11:17 - we have the ability to drag and drop the
11:19 - item and to run some code whenever that
11:21 - happens
11:22 - which is something we are going to use
11:24 - extensively later on
11:26 - but first of all let's create the actual
11:28 - grid so we can see what we are going to
11:30 - do
11:30 - and this is going to be the next step
11:32 - where we are going to create the grids
11:34 - that we are going to place stuff on
11:36 - and for that using has quite a few
11:37 - methods that we can use
11:39 - the most important one is called texture
11:41 - scale
11:43 - and let me explain what happens here
11:44 - usually when you apply a texture to an
11:46 - entity
11:47 - you just stretch the texture across the
11:49 - entire thing so the texture covers the
11:51 - object entirely
11:53 - but sometimes you want to repeat a
11:55 - texture certain times
11:56 - even the x on the y axis so maybe you
11:59 - have some roof tiles and you want to
12:00 - have multiple shingles
12:02 - and in that case you just want to repeat
12:04 - a certain texture multiple times
12:06 - and this is super easily done in c now
12:08 - and this is done with the texture scale
12:10 - because for this you can specify an x
12:12 - and a y value
12:14 - and then a texture is being repeated and
12:16 - that is something we can use for the
12:18 - grid
12:18 - quite well and this is also something we
12:21 - can use later on to place items into the
12:23 - grid
12:24 - um i guess i come back to that later on
12:26 - but
12:27 - um yeah let's actually implement this
12:29 - and let's see how it's going to look
12:31 - so here i'm back in the code and let's
12:33 - create another class
12:35 - and this i think i called grid but the
12:37 - name again really doesn't matter
12:39 - and this one just needs to inherit from
12:41 - entity
12:42 - and then here we need the usual we have
12:44 - to define an init method
12:46 - it needs self then we have to create a
12:49 - super it
12:52 - and in here we need the couple of usual
12:55 - parameters
12:56 - and let me just copy them from the item
12:57 - because i'm lazy
13:00 - so parent is camera ui model squad um
13:03 - the usual
13:05 - now in here now we want to have
13:07 - something else as well
13:08 - we want to have a texture first of all
13:11 - and the texture is just going to be the
13:12 - box of
13:13 - one of the cells in the grid you'll see
13:15 - in a second what i mean
13:17 - and to load a texture we need load
13:19 - texture naming is
13:20 - really a strong suit of usina and how i
13:23 - call this
13:24 - is box.png and now let me actually
13:27 - create an instance of this class
13:29 - let's call it let's call it menu
13:33 - grid and this one needs grid
13:36 - and now let's run all of this and here
13:39 - you can see what i meant
13:40 - now we have a kind of boxy thing around
13:43 - our entire background
13:44 - right now it's way too big so the first
13:48 - thing we need to do to fix this
13:49 - is to apply a texture scale and in here
13:53 - we need a tuple with an x and a y number
13:56 - in my case i went with five and eight
13:59 - and let me just run the code to show
14:01 - what this is going to do
14:03 - and there we go so now instead of having
14:05 - one texture across the entire thing
14:07 - we are replicating a texture multiple
14:09 - times to create a grid
14:11 - so this one is looking much better
14:13 - obviously right now it's
14:14 - way too big so let's scale it down which
14:17 - happens with the scale property
14:20 - and in here i went with 0.5 and 0.8
14:24 - and now let's run this again and there
14:27 - we go now we have a much better looking
14:29 - grid
14:30 - two really important things here that
14:33 - these numbers here
14:34 - and these numbers here look similar for
14:36 - a specific reason
14:38 - that to get squares these numbers have
14:40 - to correspond with each other
14:42 - so that when you divide one by the other
14:45 - you always get 0.1
14:47 - and that way each of the cells is
14:48 - exactly 0.1
14:50 - units high or white so that's quite
14:52 - important
14:53 - and also what i mentioned earlier these
14:56 - numbers here
14:57 - i have chosen or rather i have chosen
15:00 - these numbers here
15:01 - because they are ever so slightly larger
15:03 - than these numbers here
15:05 - and essentially these numbers up here
15:08 - for the background
15:09 - are just a tiny bit larger to create a
15:12 - grid
15:12 - between the cells and the outside of the
15:14 - menu that's literally all it's for
15:17 - so you could have made these numbers a
15:18 - little bit smaller but then you wouldn't
15:20 - really have a padding around the menu
15:22 - cells
15:22 - so this i think looks quite nice so
15:26 - now the important question becomes how
15:28 - can we actually connect
15:29 - these two concepts did we have a
15:31 - draggable and we have a grid but right
15:33 - now
15:34 - they don't work together at all so this
15:37 - is going to be the next step where we
15:39 - are going to create a connection
15:41 - between the grid and the items
15:44 - now to make all of this work we are
15:46 - going to need a couple of concepts
15:48 - and i guess the best way to achieve this
15:50 - is to go through them step by step
15:52 - so let's start with the simplest one
15:54 - that i want to establish
15:55 - a specific connection between the items
15:57 - and the grid so that the grid is
15:59 - essentially the parent class for all the
16:01 - items
16:01 - so we can access all of the items from
16:03 - the grid which is going to be quite
16:05 - important
16:06 - and most of the time in python if you
16:08 - had a task like this
16:09 - you would just create another attribute
16:11 - in the class and then add children to it
16:13 - so we'd have like self.items and then a
16:15 - list of all of the items in the grid
16:17 - class
16:18 - but in usina that's not quite how it
16:21 - works
16:22 - instead what we have to do is to change
16:24 - the attribute of the parent attribute
16:26 - and that way we can create a parent
16:28 - class automatically
16:30 - and it's perfectly fine to use a class
16:31 - that we created ourselves in here as a
16:33 - parent
16:34 - it's actually really powerful and let's
16:37 - actually demonstrate this so here we are
16:40 - back in the code
16:41 - and let me actually minimize bg so we
16:44 - know what's going to happen
16:46 - so whenever this item is going to be
16:48 - created
16:49 - i want this to be a child of this grid
16:51 - class
16:53 - and now just to explain what i just said
16:55 - in the intro
16:56 - if you are doing this in any other
16:57 - python module you probably go something
16:59 - like self.items
17:01 - is going to be a list of item and then
17:04 - you just add multiple items depending on
17:06 - how many you need
17:08 - in usina that doesn't work like that
17:11 - instead what you want to do is
17:14 - change this camera.ui
17:18 - and this one needs to get some kind of
17:20 - let's call it container
17:22 - now what is this container going to be
17:25 - is going to be
17:26 - whatever we pass into the item
17:29 - when we create the instance of it and
17:32 - let me just get rid of this item here
17:34 - because we are not going to need it
17:35 - anymore
17:36 - instead i only want to create items
17:39 - within this grid class
17:41 - so let me actually create a whole new
17:42 - method for that let's call it
17:45 - um at new
17:48 - and this one is just going to need self
17:50 - nothing else and in here literally all
17:52 - we have to do
17:53 - is to create an item and this item is
17:56 - going to need one parameter
17:58 - the parent or the container and the
18:01 - container
18:01 - is just going to be the class itself so
18:04 - literally all we have to do
18:05 - is to pass self in here and well that's
18:08 - literally all you have to do you don't
18:10 - really have to add the item to any kind
18:12 - of list
18:12 - usina does all of that for you so as
18:15 - long as you created a parent for this
18:16 - class
18:17 - and the parent is specified to be this
18:19 - grid you have already attached it
18:21 - so now when we run init on this class
18:23 - let's call self
18:25 - add new item and let's see what happens
18:28 - and here we go now we still have
18:32 - our draggable item but now it has picked
18:34 - up the scale
18:36 - from the parent container which is 0.5
18:39 - and 0.8 so this thing now has a weird
18:41 - scaling
18:42 - something we can fix in just a bit now
18:45 - obviously this still doesn't help us all
18:46 - that much
18:47 - but it is a really important step that
18:49 - we can use later on
18:51 - because now what we could for example do
18:54 - is
18:54 - in the grid
18:57 - we can call print self.children
19:02 - and let's run that and now at the bottom
19:06 - you can see this one here
19:09 - we have a grid item as a child of it
19:12 - if we added more to it we would have
19:13 - more of that and later on we can cycle
19:16 - through them and get their information
19:17 - for example their position
19:19 - which is very very powerful but all
19:22 - right
19:23 - let me get rid of this part for now
19:26 - and now the first thing i want to do is
19:28 - to fix the scaling of this item
19:31 - and for that we first have to get rid of
19:33 - the scale property at
19:35 - all because we don't need it anymore
19:38 - and instead i want to specifically
19:40 - target this scale x and scale y
19:43 - because the code here is going to be
19:44 - slightly longer and
19:46 - fortunately we can do that all right
19:48 - scale x and
19:50 - and also scale y and
19:53 - now in here we want to figure out a
19:55 - specific thing
19:57 - we want to know from this information
20:00 - how we have to scale this item here
20:03 - because this is going to tell us how big
20:04 - it needs to be and fortunately
20:07 - we can access this information from the
20:09 - child
20:10 - all we really need for that is to get
20:12 - the container
20:13 - so the information we passed in here in
20:15 - this case the grid
20:16 - and from this container we can access
20:18 - the texture
20:20 - scale and this is going to be a tuple
20:22 - the tuber we have specified
20:24 - in here so five and eight and for x
20:29 - i want the one with number zero so the x
20:32 - scale
20:32 - so this one right now would be giving us
20:34 - a five so
20:36 - not great yet but what we can do
20:39 - is we can separate this by one and
20:42 - really all this means is that
20:44 - the entire width of this thing is going
20:46 - to be one
20:47 - and it's going to be separated into five
20:49 - different parts
20:51 - so when we have the width of each
20:53 - individual item
20:54 - it needs to be one divided by five
20:56 - exactly what we have done here
20:59 - so now if i copy this and change it to a
21:02 - one
21:04 - and now let's run the code we can see
21:06 - now we have a perfectly sized rectangle
21:09 - because we are literally using the scale
21:10 - from the parent to define its size
21:13 - but there's one thing i don't really
21:15 - like that this thing is
21:17 - exactly on the borders of it so i want
21:19 - to make this
21:20 - draggable item ever so slightly smaller
21:23 - and this we can also achieve quite
21:24 - easily
21:25 - all we need to do is to make this number
21:26 - here ever so slightly larger
21:29 - so you can really just put it into
21:31 - brackets
21:32 - and then multiply it by 1.2 and
21:36 - do the same thing for the number below
21:40 - obviously change it to 1. and now if you
21:43 - run all of this again
21:45 - you have a draggable that fits much more
21:47 - nicely into
21:48 - each of the cells obviously it still
21:50 - doesn't snap but that we are going to
21:52 - come to in just a bit
21:54 - so with that we have a basic setup to
21:57 - connect the two
21:58 - obviously that still doesn't help us to
22:00 - actually place the item
22:02 - and this is going to be the next part
22:04 - that i really want to work on
22:05 - that whenever we drop the item it is
22:08 - going to snap into specific position
22:10 - and for that we really have to think
22:13 - about two coordinate systems that we
22:14 - have for this setup
22:16 - and right now we only have one
22:18 - coordinate system
22:19 - and that's the actual grid itself and
22:21 - its x and y position
22:23 - and just to be clear here this thing
22:25 - right now is a square
22:26 - that has a coordinate system that goes
22:28 - from 0 to 1 and from 0 to -1 and
22:31 - y-axis and these positions we can
22:33 - measure
22:34 - very easily i'm going to demonstrate
22:36 - that in just a second
22:38 - and now all we really have to do to
22:39 - place items in a specific position on
22:42 - top of that
22:43 - is to imagine a grid on top of this
22:45 - thing
22:46 - and we don't actually create any
22:47 - specific method to create this grid
22:50 - instead we are just going to round the
22:51 - numbers in a specific way
22:53 - so for example if a number is 0.25 and
22:56 - 0.1
22:57 - we're going to round these numbers in
22:59 - such a way that they're going to snap
23:01 - in a specific position so the logic here
23:04 - i think once i actually implement it is
23:06 - going to make much more sense
23:08 - um let's go through it but this might be
23:10 - a part you want to watch twice
23:12 - it's slightly more complex but let's go
23:15 - back into the code and let's have a look
23:16 - at this
23:17 - so here i'm back in the code and we
23:19 - still
23:20 - print x and y whenever we drop the
23:22 - draggable so let's run this code and
23:24 - let's see how this looks
23:26 - so whenever i drop this right now we get
23:29 - x being 0.0 something and y being 0.06
23:34 - now if i go to the top left we get
23:38 - x being negative 0.4 and y being 0.4
23:41 - and just to explain these coordinates
23:44 - all the cells we can see right now
23:45 - have a coordinate system that goes from
23:47 - 0 to 1 and from
23:48 - 0 to negative 1. so if i move
23:52 - this draggable to the top left
23:56 - we can see something like negative 0.5
23:58 - and 0.5
24:00 - so we're moving 0.5 to the left and 0.5
24:03 - up
24:04 - and the really important thing here is
24:06 - that the origin of this system is
24:07 - right in the middle of this grid so from
24:10 - this position we move negative 5 to the
24:12 - left
24:12 - and 0.5 up and again in using remember
24:16 - if you go up the y number increases this
24:18 - is the exact inverse from pygame for
24:20 - example
24:21 - so this is already giving us a certain
24:23 - kind of coordinate system that we could
24:25 - be working with
24:26 - although i really want to make one
24:28 - change that right now the origin point
24:30 - is right in the middle of the swing
24:31 - which
24:32 - is kind of a pain to work with instead i
24:34 - want to have my coordinate system start
24:36 - right in the top left this is going to
24:39 - make our math significantly easier
24:41 - so let's start with that then i want to
24:43 - take this grid
24:44 - and change the coordinate system to the
24:46 - top left
24:48 - and for that all we have to do is to get
24:51 - the
24:51 - origin and give it an attribute of
24:55 - negative 0.5 and 0.5 and now if we run
25:00 - this
25:01 - you can see that now we have moved the
25:03 - coordinate system right into the middle
25:05 - of this thing
25:06 - which um well it's a start but not great
25:08 - yet so
25:09 - now to adjust for this change in origin
25:11 - we have to move this entire thing to the
25:13 - left and up
25:14 - which we can do very easily so
25:17 - all we have to get is the position of
25:19 - the thing
25:20 - and then here it's going to be 0.25
25:24 - and 0.4 which is
25:27 - exactly going to be half of the scale
25:31 - so now if i run this again now we're
25:34 - back to our normal grid
25:35 - but the really important thing here is
25:37 - you can already tell actually here
25:39 - that our draggable item if i now
25:42 - leave it roughly at the top left we can
25:44 - see numbers that are basically 0 and 0.
25:47 - and this is really important because now
25:49 - if i go all the way to the right
25:51 - we get x being 1 and y being roughly 0.
25:55 - if i go all the way to the bottom you
25:57 - can see zero
25:58 - and y being minus one so these are some
26:00 - numbers we can use
26:01 - very easily to place the item in a
26:04 - specific spot
26:05 - because all we really want let's say
26:07 - this is grid zero and zero
26:09 - then we can place it at position 0 and 0
26:11 - and just round these numbers a tiny bit
26:13 - same with if we put this in the second
26:15 - spot now we need something like x being
26:17 - 0.2
26:18 - in the top left which is going to make
26:20 - our math significantly easier
26:23 - and well let's do this actually so
26:26 - whenever this item is being dropped i
26:29 - don't just want to print a position
26:31 - i want to put it into a specific
26:33 - position that is defined by the parent
26:37 - and now in here we have to do a little
26:40 - bit of
26:41 - math and i think it's best to illustrate
26:44 - by printing exactly what we are doing
26:46 - and let me comment out
26:47 - the other two bits so they're not going
26:50 - to be annoying
26:51 - so first of all let's start with self.x
26:54 - the number we already have
26:55 - so if i run this and i drop
26:59 - this thing here we get 0.1 if i put into
27:02 - the second cell
27:03 - we got 0.3 and so on
27:06 - 0.5 and all the way to the right
27:09 - we get 0.9 so we can get an x position
27:14 - now really all we have to do is to round
27:16 - this number in such a way that we get
27:17 - very clean
27:18 - predictable numbers so for example at
27:20 - this first one here
27:21 - instead of 0.1 with a ton of numbers
27:24 - just becomes 0.1 and
27:28 - actually just to make the math a little
27:29 - bit easier here as well
27:31 - let's change the origin point of this
27:33 - draggable item as well
27:35 - so let me close this and let's
27:38 - change the origin point here as well
27:40 - that's going to make our life a good bit
27:41 - easier
27:42 - and here i want the origin to be changed
27:45 - and in here you might be tempted to go
27:47 - again with negative 0.5
27:50 - and 0.5 but that
27:53 - wouldn't exactly work let me actually
27:55 - demonstrate why
27:56 - so right now we already start in cell 0
27:59 - and 0.
28:00 - but our cell is glued to the top left
28:02 - but we want to have a little bit of an
28:03 - offset
28:04 - something like this and the problem here
28:07 - is that we multiplied the scale of this
28:09 - cell by 1.2
28:11 - so it's slightly smaller than the actual
28:13 - cell and we have to encounter this for
28:15 - the origin
28:16 - so i want to have the origin slightly
28:17 - outside of the actual item
28:19 - and well all we have to do is to divide
28:21 - this by 2 and then we have the right
28:23 - number
28:23 - and 1.2 divided by 2 is 0.6
28:27 - so now there you can already tell
28:30 - our grid is starting to enclose the item
28:34 - so now if i just drag and drop it we get
28:38 - a specific number i have no idea what is
28:42 - 0.5 came from i'm really sorry
28:45 - that seemed to have been a bug no idea
28:47 - but
28:48 - usually this works really well so we get
28:52 - 0 we get 0.2 we get 0.4
28:56 - we get 0.6 and we get 0.8
28:59 - so all we have to do now is to round
29:01 - these numbers in such a way that they're
29:03 - always identical
29:05 - so we don't get 0.196 and so on instead
29:08 - we get
29:08 - 0.2 that's all we really want and for
29:12 - that
29:12 - unfortunately we have to do a tiny bit
29:14 - of math
29:16 - so let's go through it one by one first
29:18 - of all this number here
29:20 - i want to turn for now into an integer
29:24 - and what do you want to do that well i
29:26 - want to have this number
29:27 - clean and rounded so right now i want to
29:30 - have this integer
29:31 - between 0 and 4 because that way we can
29:34 - just divide it
29:35 - by 5 or the number of x cells that we
29:38 - have
29:38 - and then we would always get a clean
29:39 - number so let me print this
29:42 - this should kind of almost work so we
29:45 - get zero and zero
29:47 - we still get zero and zero but if we get
29:49 - too further to the right we get zero
29:51 - point two
29:52 - and so on eventually we get a larger
29:53 - number so right now this doesn't exactly
29:56 - work but you can kind of see the
29:57 - principle i think
29:59 - but this number obviously is way too
30:01 - small so we have to get this number to
30:03 - be a little bit larger
30:05 - and a simple thing you can start by
30:07 - doing is to multiply this number by five
30:09 - so let's say if this number is here is
30:11 - 0.2 we multiply it by five
30:14 - then this entire thing would become one
30:16 - and we then divide this by five
30:18 - then we will get 0.2 so now let's try
30:20 - this again this should already get us
30:22 - quite a bit closer to it so we get 0 and
30:24 - 0
30:25 - 0 and 0 still now 0.2 0.6
30:29 - and 0.8 so this almost worked we're
30:32 - getting much closer
30:34 - and well here is the slightly dodgy part
30:37 - of this project
30:38 - because the next step on how to make
30:40 - this work safe.x i put never brackets
30:43 - and i have added self dot
30:46 - scale x divided by 2.
30:51 - so we are always adding half of the
30:53 - items with
30:57 - and well now we run this
31:00 - and we get 0.0
31:03 - 0.2 0.4 0.86 and 0.8
31:07 - so this is actually working really well
31:10 - now um
31:11 - well i got to be honest here i have no
31:13 - idea why this works
31:15 - um when you actually run these two
31:17 - numbers you get
31:18 - really unclear numbers and i think if we
31:21 - get to really high numbers
31:22 - this might start to break down but we're
31:25 - talking really high numbers like if you
31:27 - have hundreds of cells
31:28 - but i guess in our case this is still
31:31 - working although
31:32 - not great ideally try to understand what
31:34 - the code is doing
31:35 - but well it is also working so that's a
31:37 - good start
31:38 - so now instead of printing this number
31:41 - here
31:42 - i just want to set self.x to be this
31:45 - number
31:47 - and well now whenever i drop this
31:50 - so even if i print it right in the
31:52 - middle it snaps back to the specific
31:54 - thing
31:55 - because we are rounding it in such a way
31:57 - that whenever we drop it
31:58 - it drops back to it
32:01 - obviously right now just in the x axis
32:03 - but this is working quite well
32:06 - so now we can just do the same thing for
32:08 - the y axis
32:10 - change self.x to self.y
32:14 - and all of these axes to a y and
32:17 - obviously this year
32:18 - from a 5 has to be an 8.
32:21 - ah and one more really important part
32:24 - since
32:24 - the y axis if you go down what is
32:26 - negative this shouldn't be plus
32:28 - it should be minus so now let's try this
32:31 - again
32:32 - and now i can
32:35 - just place stuff and now it always snaps
32:39 - towards
32:39 - the specific grid that we are going to
32:41 - work with
32:42 - um yeah this is actually working super
32:45 - well so um
32:46 - nice and uh yeah so this bit here
32:50 - is a little bit of tricky math and
32:53 - basically when i figured this out
32:54 - it was just trial and error and i still
32:57 - don't fully understand it
32:59 - so later on if you make this your own
33:00 - project and you make this much larger
33:03 - be aware you might want to work on these
33:05 - numbers here
33:06 - but yeah i guess at least for now it at
33:07 - least works
33:09 - so that's a pretty good start now
33:12 - there's one more problem that i really
33:13 - want to address
33:14 - and that is right now we can drag this
33:16 - item anywhere on the screen
33:18 - which not great it's a bit weird
33:23 - so i want to give it some kind of
33:24 - constraint and to fix it
33:26 - i want to add another method and let's
33:28 - call it menu
33:31 - constraint
33:34 - and when we define constraint
33:39 - needs itself and here the logic is
33:42 - actually super easy
33:43 - because we know in our menu grid we have
33:46 - specific coordinates
33:48 - that the thing starts at 0 and goes to 1
33:50 - on the x axis
33:51 - and goes from 0 to -1 on the y-axis
33:54 - so all we have to do is that if we go
33:56 - outside of these numbers
33:58 - so self.x is
34:01 - smaller than 0 or
34:05 - self dot x is greater than one
34:08 - or self dot y is
34:11 - greater than zero or self dot
34:14 - y is smaller than minus one
34:18 - so if any of these are true
34:21 - then let's say for now we want to print
34:23 - outside
34:25 - and let's see if this is going to work
34:27 - so i can still
34:28 - move my item around but now if it places
34:30 - outside
34:31 - we get outside so we know whenever it is
34:34 - outside
34:35 - which is well at least a step in the
34:37 - right direction
34:39 - cool but now i don't just want to print
34:42 - something instead i want to return the
34:43 - item to its original position
34:46 - so whenever we drag it outside of the
34:47 - menu it just goes back to where it
34:49 - started from
34:50 - so the first thing we have to do is to
34:52 - uncomment the direct part
34:54 - because whenever we drag the item we
34:56 - want to get the position where it
34:57 - started from
34:59 - so let me get rid of those two and
35:02 - all i want to have in this method is
35:04 - that whenever i start dragging i want to
35:05 - get the position so for that i'm going
35:07 - to define
35:08 - a new attribute let's call it xy pos and
35:11 - all this one is is self.x and self.y
35:15 - so whenever we start dragging this item
35:17 - we get the position and store it
35:18 - somewhere so we can use it later
35:21 - and well then down here if we are
35:24 - outside of this position
35:26 - we are going to place the item back into
35:28 - the position where it came from
35:30 - so self dot x is going to be self dot
35:33 - x y pause the first one
35:36 - and then for self dot y is going to be
35:39 - self
35:40 - dot x y pos and one
35:44 - and well that's it let's run it now
35:47 - so i can still move it inside but if i
35:49 - go now outside
35:52 - it snaps back but i can still move it
35:54 - inside of the grid
35:55 - so um that's literally it now we have
35:58 - the ability to place this item inside of
36:01 - this grid
36:02 - and that's working really well
36:06 - cool all right and with that
36:09 - we have the really complicated part of
36:11 - this project out of the way
36:13 - i guess the next step is we can make all
36:15 - of this look a little bit nicer
36:17 - and what i mean by that is that when we
36:21 - have our item
36:22 - i don't just want to have a red item i
36:24 - want to have an
36:25 - actual texture so let's work on that
36:28 - and the logic here is going to be quite
36:30 - simple when i create a grid class
36:33 - i'm going to import a couple of textures
36:35 - and each item is going to get a random
36:37 - texture
36:37 - that's basically going to be it so
36:40 - here we are back in the code i have
36:42 - minimized everything to make it a bit
36:44 - more
36:44 - readable and i want to work in the grid
36:47 - and specifically what i want to do here
36:49 - is to create a new method let's call it
36:52 - import textures
36:54 - itself and nothing else and in here i
36:57 - want to do two things
36:58 - number one i want to import a couple of
37:00 - textures and number two i want to import
37:02 - all of these textures
37:03 - to a list so we can actually use them in
37:05 - the grid itself
37:07 - but let's go step by step first of all i
37:09 - want to import a texture let's start
37:10 - with the grass one
37:12 - so the grass one i need load texture
37:14 - again and this one i have called
37:16 - grass dot png and well now we have to do
37:20 - the same thing for
37:21 - all of the different textures we have
37:23 - for example there is a
37:25 - brick one this one needs load texture
37:29 - with brick dot png then we have
37:33 - stone i think i called it i'm terrible
37:35 - at typing
37:37 - load texture this is stone dot png oh
37:40 - actually perfect naming this is called
37:43 - rock
37:44 - let's call it brock and the final one i
37:47 - call
37:48 - dirt and for this one we need load
37:50 - texture
37:51 - and dirt.png so in total we have four
37:55 - different textures
37:56 - but right now we have imported them but
37:58 - we don't really do anything with them
38:00 - so to fix that i want to create in class
38:03 - that
38:04 - i call textures and in there i just want
38:06 - to add
38:07 - all of these different textures
38:11 - so rock and dirt obviously you could
38:14 - have just loaded all of these textures
38:15 - straight into it would have been the
38:16 - same outcome
38:18 - but i guess this one is a little bit
38:19 - more readable now all i want to do
38:22 - is when we initiate this class i want to
38:24 - run this method
38:25 - so import textures
38:29 - and well that's all we really had to do
38:32 - to import all of the textures
38:33 - so now inside of this class we can use
38:35 - this self.textures
38:37 - to get one of the textures so we can
38:39 - close this one
38:40 - and now whenever i instantiate one of
38:43 - these item
38:44 - i want to add random texture to it so i
38:47 - have to open the texture
38:49 - and give it an actual texture so let's
38:52 - put it right below color
38:54 - so texture and let's call this type
38:57 - can't think of a better name and this
38:59 - has to be given to the class when we
39:00 - initiate it
39:01 - so this for now is all we need
39:05 - and now when i create an item let's just
39:07 - start with just the first one
39:09 - so i want self.textures and
39:12 - number zero so now when i run this
39:16 - we can see okay this kind of works you
39:19 - can see
39:19 - some grass-ish looking thing and the
39:22 - problem here
39:23 - is that this red color
39:26 - and this texture they're working
39:27 - together to create the color
39:29 - so we're basically tinting the entire
39:31 - texture in red when we do this
39:33 - to fix that all we have to do is to turn
39:35 - this into white
39:36 - and now let's run this again now we can
39:39 - see it
39:39 - now this is looking much better
39:43 - cool so now we have a grass texture
39:47 - but i don't just want to always have the
39:49 - grass texture
39:50 - or the one with the index 0 instead i
39:52 - want to have a random one
39:54 - so to do that we need random numbers so
39:56 - i have to from
39:58 - random import rent and actually
40:02 - choice so that we can pick a random item
40:05 - from a list
40:06 - and that literally is
40:10 - in here we need choice
40:14 - put this in there and now whenever i run
40:15 - this okay
40:17 - same thing now we get a brick texture
40:21 - we get a grass texture again
40:24 - grass texture i'm being very unlucky
40:26 - with this oh yeah now we get a stone
40:27 - texture
40:28 - so now we get a random texture every
40:30 - single time we run this
40:32 - um cool so this i think already makes
40:34 - the entire thing look quite a bit nicer
40:36 - and yeah you can play around with the
40:38 - looks of this forever i'm going to keep
40:39 - it simple
40:40 - so with this we have made the entire
40:42 - thing look substantially better
40:44 - there's still one big thing missing that
40:47 - we only have one item
40:48 - and we can't add anything else to it so
40:52 - let's work on this bit and in here again
40:54 - we are going to need a couple of
40:56 - different concepts working together
40:58 - number one is we have to look for
41:00 - keyboard input number two
41:02 - is we have to be able to use that
41:03 - keyboard input to add an item and number
41:05 - three
41:06 - the actually important bit is that we
41:08 - have to find a free cell to add the item
41:10 - to
41:11 - and that we are going to take care of in
41:12 - just a second but let's go for this step
41:14 - by step
41:15 - so here i'm back in the code and the
41:18 - first thing i want to do
41:19 - is to check for keyboard input and this
41:21 - can be done very easily in oceana all we
41:23 - need is define
41:25 - an input function and this takes one
41:28 - argument the key
41:29 - and this is being called automatically
41:31 - by oceana so we don't have to call it
41:33 - ourselves we just have to specify what
41:35 - we are looking for
41:36 - and i want to look for a specific key in
41:39 - my case i went with the key a
41:41 - but you can basically add anything in
41:43 - here
41:44 - and whenever this is pressed i want to
41:46 - get my menu grid and
41:48 - call the add new item method so this
41:50 - thing here
41:51 - and once we have that we are
41:54 - well we have a new item so let's run
41:56 - this let me move this thing to the side
41:59 - and now i press a we got another one and
42:01 - now we can just add
42:03 - more and more items to this and the
42:06 - random method really isn't
42:08 - very random okay that gets better cool
42:11 - so now we have
42:12 - random items the problem here now is
42:14 - that when i keep on pressing this
42:17 - it always adds new item on top of this
42:19 - thing
42:20 - so this is something we do have to work
42:22 - on
42:23 - also i can add one thing on top of
42:25 - another and
42:27 - this is also something we are going to
42:28 - address in a bit but for now
42:31 - i want to make sure that whenever i add
42:33 - a new item
42:34 - this grid first finds an empty cell and
42:37 - only then
42:38 - adds a new item and to make that work
42:42 - when we create a new item we have to
42:43 - give it a position so i want to add
42:45 - another argument into this that's going
42:48 - to be the position
42:49 - and that means also when we create this
42:52 - thing
42:53 - this also needs a position and now we
42:56 - have to integrate this position into our
42:58 - grid
42:58 - which well fortunately is very easy
43:01 - because
43:01 - all i have to do is to get so i imagine
43:04 - this to be a tuple of an x and a y
43:05 - portion so right now we take the x value
43:08 - and now all we have to do
43:10 - is to multiply this thing by one over
43:14 - the texture scale and this number here
43:18 - would always going to be 0.2 because the
43:20 - texture scale for the x is going to be
43:22 - 5.
43:23 - so any number we have in here we are
43:25 - going to multiply by 0.2
43:27 - so if this is 0 it's going to be 0
43:29 - anyway if this is 1
43:31 - this entire thing is going to be 0.2 if
43:33 - this is going to be 2
43:35 - this entire thing is going to be 0.4
43:38 - and that way we basically do the same
43:40 - thing as we're doing here
43:41 - we are just going to create specific
43:43 - numbers that don't really change
43:45 - and then we have to do the same thing
43:46 - for the y portion so let me copy
43:49 - the entire thing and just change this to
43:51 - a one
43:52 - and now we get this same thing we have
43:54 - done for the y so i hope that makes
43:56 - sense
43:58 - and now let's test the entire thing so
44:01 - when i call the position
44:05 - i'm going to define pause to be let's
44:08 - start with zero and zero
44:11 - and let's run this and we are in the top
44:13 - left and if i add a larger number
44:16 - let's say two and
44:19 - uh minus four we get
44:23 - 2 from the left and 4 from the top so
44:25 - this one is working pretty well
44:26 - cool now the obvious problem is we are
44:29 - always going to add a cell
44:30 - to this position here which we don't
44:33 - want
44:34 - instead i want to find a cell that isn't
44:36 - occupied yet and this is something we
44:38 - can do
44:38 - but it does rely on a couple of
44:41 - different parts
44:42 - so let's go through them one by one
44:44 - essentially
44:45 - all i'm going to do to make this work
44:47 - i'm going to create a grid of all the
44:49 - cells that are possible
44:50 - in our grid and that's going to be one
44:53 - list i call this all cells
44:55 - now then i have created another list and
44:57 - this is called taking cells and this is
44:59 - literally just a list of all the cells
45:01 - that are already occupied
45:03 - and all i do then is i compare both
45:05 - lists and see
45:06 - which field is empty yet and then i am
45:09 - going to use that cell
45:10 - and i have an empty cell so that's
45:13 - literally the entire logic
45:15 - so let's actually go for this step by
45:17 - step so here we're back in the code
45:19 - and instead of a specific position i
45:22 - want to create a new method let's call
45:23 - itself
45:24 - a find free cell
45:28 - and let's put this right below define
45:31 - find
45:32 - free cell does not need any arguments
45:35 - besides self
45:37 - and we have to start with a list of all
45:39 - the possible cells that we can have
45:42 - so this is literally just all the
45:44 - different cells that are possible
45:46 - and for that i'm going to use list
45:47 - comprehension and for this i have used a
45:50 - vector 2
45:51 - so a 2 dimensional vector with an x and
45:54 - a y
45:55 - which i think makes sense and now i just
45:58 - want to get all the possible y and all
45:59 - the possible x positions
46:01 - so for y in range from
46:05 - 0 all the way to 0.8
46:08 - and we want to go in the negative
46:09 - direction and for all of this
46:12 - also for x in range
46:15 - zero and five
46:18 - that is literally all we needed let me
46:20 - actually illustrate what's happening
46:22 - here
46:22 - so let me comment out add new item and
46:25 - instead i want to return
46:27 - all cells and then print
46:30 - pause so um what we're doing right now
46:34 - is whenever we run this method we're
46:36 - going to create all the possible cells
46:38 - in here
46:39 - and return it so it's being stored
46:41 - inside of position and then we are
46:42 - printing it
46:44 - i hope that makes sense so now if i run
46:46 - this we can't see any item
46:48 - but now i've pressed a and you can see a
46:51 - ton of different vectors let's start
46:53 - from 0 and 0
46:55 - and go all the way to 4 and negative 7.
46:58 - so these would be all the possible sets
47:00 - that we can use
47:01 - but obviously we don't just want to
47:03 - print them we do want to use them
47:06 - so this will be the first step we have
47:08 - all the possible cells so
47:10 - next up i want to find my taken cells
47:14 - and this one is actually also going to
47:15 - be fairly simple
47:17 - essentially i want to first look at all
47:19 - of the children
47:20 - so all the items we have created earlier
47:23 - and i want to
47:24 - cycle through this thing so for child in
47:27 - self.children and now i have to find a
47:29 - method to get the position of this child
47:32 - or the specific grid position so we need
47:34 - a vector
47:35 - like we have done above and for that i'm
47:37 - going to create a specific method inside
47:39 - of the child class
47:41 - so let's call it child get cell
47:45 - pause so really all that's happening
47:47 - here is we're cycling through all of the
47:49 - children
47:50 - and we're calling the get cell position
47:52 - and this one is going to give us a
47:53 - vector
47:54 - with the x and the y position so all we
47:56 - have to do now
47:57 - is to actually create that so i want to
48:00 - get cell position and it doesn't need
48:04 - any arguments and in here
48:06 - i want to figure out what the cell
48:08 - position of this thing is going to be
48:10 - and for that we're going to need an x
48:11 - and a y position
48:13 - and at the end of it we want to return
48:16 - a vector to with x and y
48:20 - so now let's define these two variables
48:23 - and this is going to be actually quite
48:26 - simple
48:27 - all we need is self.x
48:30 - and multiply this by self dot parent
48:34 - dot texture scale
48:37 - in the appropriate axis so 0 for x
48:40 - and this one would then give us the
48:42 - specific point it's on
48:43 - in the grid obviously this then has to
48:46 - be turned into an integer
48:48 - because we want to have clean numbers
48:51 - but that
48:51 - is essentially it now i can just copy
48:54 - this thing for
48:55 - y and change the x to y as well
48:58 - and with that one we just get a
49:02 - specific position so with that
49:05 - we have all the taking cells and all the
49:08 - cells possible
49:09 - and now with that all we have to do is
49:11 - to compare these two different cells
49:13 - and well this just means for cell in
49:16 - all cells if cell not
49:20 - in taking cells then we want to return
49:25 - that cell so the logic here i think
49:28 - makes sense
49:29 - we look at each cell in all the possible
49:31 - cells and we check if this cell
49:32 - does not exist in any of these taking
49:34 - cells and if that is the case
49:37 - we're going to return the cell that is
49:38 - not in any of these
49:40 - cells and then the code is going to end
49:43 - and we are good to go
49:44 - so let me get rid of this and now this
49:48 - should actually work let's try so i run
49:51 - the code
49:52 - we already get one because we're calling
49:54 - it once but now let me try it again
49:56 - and this did not work because we're
49:59 - still adding it on the same position
50:01 - and you might have already spotted the
50:02 - mistake here i do not
50:04 - call the get cell position i just named
50:07 - it so this one obviously would never
50:09 - get a proper position so now let's try
50:11 - this again
50:12 - and here we go whenever i press a i'm
50:15 - going to add a new item to it
50:17 - and here's something slightly weird
50:18 - about you see now if i had more
50:20 - of these grids at some point we get a
50:23 - weird texture error i
50:24 - don't know why this is happening if you
50:27 - start to drag this around
50:28 - you get a slightly different thing you
50:30 - can still drag them you just can't see
50:32 - them
50:33 - honestly i have no idea why this is
50:35 - happening might be a bug
50:38 - so but if you keep on adding it it still
50:40 - works
50:41 - it's just a bit weird um oh yeah and if
50:45 - we have too many of these the entire
50:46 - thing crashes as well
50:47 - so not great don't worry too much about
50:49 - it but the one thing we do have to worry
50:51 - about
50:51 - is some kind of fail safe if we have too
50:53 - many different cells
50:55 - and all i did for this is if the length
51:01 - of the taken cells
51:05 - is greater or equal to the length
51:08 - of all cells then i want to return
51:13 - false and now when we add a new item
51:18 - i just want to check if this thing
51:20 - exists at all and if that's the case
51:22 - only then do i want to create a new item
51:25 - so if we return faults
51:26 - this thing is not going to evaluate and
51:28 - we're not going to add anything new here
51:30 - so um should still work and there we go
51:33 - this is still looking good cool so now
51:36 - we can also add new items and things are
51:39 - still looking quite well
51:41 - cool so let me close all of these again
51:45 - because we only have one more thing to
51:47 - add
51:48 - and that is let me add a few more
51:51 - that whenever these two overlap i want
51:54 - them to switch positions
51:56 - so when i drag this brick on top of the
51:58 - grass
51:59 - and drop it here i want the grass to go
52:01 - to where the brick used to be
52:03 - and let's implement that that's also
52:06 - actually not
52:06 - too much of a difficult thing to add so
52:09 - let's talk about that part
52:10 - all we really have to check in here is
52:13 - that whenever we drop one of these items
52:15 - then we want to check all the children
52:17 - in the grid and if two of them are
52:19 - overlapping
52:20 - we know that we dropped one item on
52:22 - another so then
52:24 - on this other item that we dropped it on
52:26 - we want to move this to where the other
52:28 - item used to be
52:29 - i hope that makes sense and yeah that's
52:32 - actually all for the logic here let's
52:34 - actually go on to the code and let's
52:36 - have a look at this
52:38 - so here i am back in the code and i want
52:41 - to have a look at my items
52:43 - and okay this is also getting quite
52:45 - extensive let me minimize a few things
52:47 - so it's not getting overwhelming so i
52:50 - want to look at the drop
52:52 - so whenever we drop an item i also want
52:55 - to check if it's overlapping with
52:57 - something else
52:58 - because then we know we have dropped the
53:00 - item on another item
53:01 - so let's call this an overlap
53:06 - check and
53:09 - let's put it right below so we can see
53:11 - how they work together
53:14 - so def overlap check
53:18 - it needs self as usual and
53:22 - in here we have to think about a couple
53:24 - of different things
53:26 - number one whenever we drop this we want
53:28 - to check all the children
53:30 - inside of the grid which we can do very
53:32 - easily we want to go for
53:34 - child in self.parent.children
53:40 - so essentially from this item we go to
53:43 - the grid
53:44 - and we look at all of its children and
53:46 - now in here we have to check if one
53:48 - child is overlapping with another child
53:50 - so if child dot x is equal to
53:54 - self self.x and child.y
53:58 - is equal dot is equal to self.y
54:02 - so this logic here might be slightly
54:04 - confusing i think
54:05 - effectively we have a child and we have
54:08 - ourself
54:09 - both are items but when we cycle through
54:12 - all the children
54:13 - we look for all the possible existing
54:15 - items whereas for self
54:17 - we look for this item itself that we
54:19 - currently have selected so the one that
54:20 - we have dropped
54:21 - so that way we can distinguish between
54:23 - the child that already existed
54:25 - and our own item that we just dropped
54:27 - once we have that
54:28 - all we have to check is if child is
54:31 - equal to self
54:33 - then we just want to continue
54:36 - however if that is not the case i want
54:40 - child x to be
54:43 - where the self used to be and this we
54:46 - already have
54:47 - we have x y plus and this is going to be
54:49 - zero
54:51 - and then we have to do the same thing
54:53 - for y
54:56 - except with 1. and let me explain what
55:00 - happens here
55:01 - we first cycle through all the children
55:03 - in the parent so all the possible items
55:05 - and then there we check if any of the
55:07 - children is overlapping with
55:08 - the item we just dropped now if the item
55:12 - we just dropped is ourself
55:13 - we just don't do anything if that is not
55:16 - the case we're going to put the child
55:17 - where our item used to be now
55:20 - this line here is actually really
55:22 - important because
55:23 - if we didn't include it using i would
55:25 - always add both the child
55:27 - and our self to this original position
55:29 - so we have to find some code to ignore
55:32 - the child itself so this one here is
55:33 - quite important and
55:35 - let me put it on the line before
55:38 - i think this looks a bit cleaner but um
55:41 - okay let's try this let me add a few
55:44 - more this still works that's a good sign
55:46 - and let's move this brick to this dirt
55:49 - sign and there we go
55:50 - we can move the two around and um
55:53 - yeah there we go we have a properly
55:56 - working
55:57 - menu system thingy and we can just move
56:00 - stuff around
56:01 - and we are good to go um yeah
56:04 - that was pretty much it i hope you
56:06 - enjoyed this tutorial