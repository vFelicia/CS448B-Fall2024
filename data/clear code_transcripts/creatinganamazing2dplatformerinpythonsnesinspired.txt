00:00 - [Music]
00:28 - a
00:32 - hello there in this tutorial we are
00:34 - going to create a platformer with an
00:35 - Overworld the game is going to be quite
00:38 - Advanced there will be a variety of
00:39 - enemies and traps a complex movement
00:42 - system that includes wall jumps and
00:43 - semic collidable platforms and there
00:45 - will be a ton of animations all of the
00:48 - levels and the Overworld are made in
00:50 - tiled meaning you can extend the game on
00:52 - your own easily I will talk about that
00:54 - throughout the video in fact to make
00:56 - this game I will be going through three
00:58 - major stages
01:00 - we will start with the basic logic of a
01:02 - platformer then we will add the proper
01:04 - Graphics enemies and the UI and finally
01:07 - we will create the Overworld if you only
01:10 - care about the basic platform of logic
01:12 - or the Overworld you can watch these
01:13 - parts in isolation as the code is very
01:16 - modular on top of that I will cover
01:18 - vital math concepts like Collision
01:20 - detection Delta time adjusted movement
01:22 - and trigonometry throughout this
01:24 - tutorial however I would very much
01:26 - recommend you to practice them Beyond
01:28 - this video and a really good way of
01:30 - doing that is via the sponsor of this
01:32 - video brilliant brilliant offers a huge
01:35 - range of courses that cover fundamental
01:37 - concepts for game development like
01:39 - vector math and trigonometry for every
01:42 - subject they cover both the absolute
01:43 - Basics and more advanced concepts
01:46 - meaning you can either start entirely
01:47 - from scratch or jump straight into more
01:49 - advanced topics their lessons are highly
01:51 - interactive and Incredibly wellmade and
01:54 - they also break up larger topics into
01:56 - more digestable chunks that you can
01:58 - focus on and practice learning that way
02:00 - is much more fun and intuitive than
02:02 - reading a book or passively following a
02:04 - lecture they also cover topics like data
02:06 - science artificial intelligence and
02:08 - Science and Engineering more broadly so
02:10 - if you want to learn how llms like jbt
02:13 - work or how robots are built then
02:15 - brilliant is for you you can sign up at
02:18 - brilliant.org Clear code and the first
02:21 - 200 people get a 20% discount on a
02:23 - premium subscription also there's a
02:26 - 30-day trial period to just test it so
02:28 - not much to lose
02:30 - now with all of that out of the way we
02:33 - can get started with the first part of
02:35 - the game which will be the basic outline
02:38 - of a level we have the main player and
02:41 - the collidable parts of the level we are
02:43 - also going to add some very basic
02:44 - movement but it's not going to be
02:46 - terribly
02:47 - sophisticated now before we get started
02:50 - let's talk about the folder setup at the
02:52 - moment the basic setup looks like this
02:54 - we have four folders and two are really
02:57 - important for now we have code and we
02:59 - have data audio contains audio files and
03:02 - Graphics is a very Mighty folder there's
03:05 - a ton of stuff in there but for now it
03:07 - really doesn't matter what we care about
03:09 - is the code folder and in there we have
03:12 - five files although in our case we only
03:15 - care about Main and settings for now I
03:18 - will talk about support and timer later
03:20 - they contain basic Support classes and
03:22 - debug is just a way to show some
03:25 - information inside of pame it's not
03:27 - going to be part of the actual game
03:29 - finally inside of data we have all of
03:31 - the level data for example if you look
03:33 - at levels we have a whole bunch of
03:36 - levels Zer to five are the levels in the
03:39 - game and Omni is a general level that we
03:42 - are going to use as a testing ground if
03:45 - you open Omni TMX you can see inside of
03:48 - til that we have a basic level doesn't
03:52 - look terribly sophisticated but this
03:54 - level contains all of the specific
03:56 - elements that are going to be present in
03:58 - every other level meaning if we can
04:00 - build this level we can create all of
04:02 - the other levels and by the way I have
04:04 - us tile to create all of the levels
04:06 - which is an open source and free tool
04:09 - that you could use as well I have
04:10 - actually made a whole tutorial on this
04:12 - although for the purposes of this video
04:14 - you are not going to need it unless you
04:16 - want to create your own levels then you
04:17 - should probably check it out anyway with
04:20 - that we have this setup which means
04:23 - inside of the code folder I want to open
04:25 - Main and settings once you have done
04:28 - that we have a completely empty file
04:30 - from main.py and if you look at
04:32 - settings.py we have a couple of things
04:35 - nothing too drastic Z layers we don't
04:38 - need at all and the really important
04:40 - part is that we are importing py game
04:42 - and sis at the top and then we are also
04:45 - getting py game. ma. Vector 2 as a
04:47 - vector we are going to use a lot of
04:50 - vectors throughout this video hence
04:52 - having easy access to them is really
04:53 - nice also before we continue I am using
04:58 - py game- CE which you are importing via
05:01 - pame but the actual module is called py
05:03 - game- C over the last year the pame
05:06 - community had a bit of an issue and kind
05:09 - of split although split isn't the exact
05:11 - word basically all of the developers bar
05:14 - one went onto pame C and the original
05:17 - pame is now very much outdated the pame
05:19 - version that you want to use is called
05:21 - py game- CE it is entirely backwards
05:23 - compatible and inside of the code you
05:25 - are simply importing it as py game and
05:28 - all of your old Pro projects will work
05:30 - just as before but you are getting a lot
05:33 - of extra features it also runs faster
05:36 - there really isn't any reason to use the
05:37 - old pame anymore the new one is
05:39 - significantly better you want to import
05:41 - pame and CIS and all of that happens
05:44 - inside of settings finally we have
05:46 - window width and window height two basic
05:48 - numbers then we have a tile size and
05:50 - animation speed so with that we can work
05:52 - inside of main.py and now we can work
05:54 - with some actual logic to get started we
05:58 - have to import everything from set
05:59 - settings so from settings import
06:02 - everything after that I want to create a
06:05 - class called game this one is going to
06:07 - run the basic logic in there we will
06:10 - need a Dunder init method with self and
06:13 - nothing else first of all in there we
06:16 - need pygame do init by the way we have
06:19 - access to pame Via this from settings
06:22 - import everything basically we imp
06:25 - putting py game in there and then we are
06:26 - passing it through via this line after
06:29 - after that we have to create self.
06:33 - displore surface that we create with
06:36 - pygame do display do setor mode and then
06:41 - we need the width and the height of the
06:42 - window which we're getting from settings
06:44 - window WID and window height I can
06:46 - simply copy it in there after that you
06:49 - can also set a window title this you do
06:52 - with py game. display. setor caption and
06:56 - then a string in there gives you a
06:57 - window title let's call this one super
07:00 - pirate world after that I want to create
07:04 - a method that I will call run once again
07:07 - no need for custom parameters but you
07:09 - will need self in there we want to
07:11 - create the game Loop meaning while true
07:15 - and then we want to check for event in
07:19 - tame. event doget and in there for now
07:23 - we only want to check if
07:25 - event. type is equal to P game g. quit P
07:31 - game. quit being the short hand for the
07:33 - x button at the top of the window
07:35 - meaning if this is the case we do want
07:37 - to close the window after that we can
07:39 - run py game. quit and then sis. exit
07:45 - both of these modules we are once again
07:47 - getting from settings.py with that we
07:50 - can check for closing the window the
07:52 - last thing that we have to do is py
07:54 - game. display.
07:57 - update and that should cover everything
07:59 - to get started all we have to do now is
08:02 - to create one instance of the class so
08:04 - game is game and then call game. run and
08:09 - we should be having a basic black window
08:11 - and that is looking really good also
08:14 - since we are going to have lots of files
08:16 - later on I want to wrap this inside of
08:19 - the if statement if Thunder name is
08:22 - equal to the string Thunder main that
08:26 - way we are making sure we don't run
08:27 - anything accidentally let's try this
08:29 - again and that is still working perfect
08:32 - now that we have that we can start
08:34 - working on the level and this should be
08:36 - a separate python file it is going to
08:38 - contain quite a bit of code so I'm going
08:41 - to create a new file and call it level.
08:43 - high and there just as before we want
08:46 - from settings import everything and then
08:51 - create a class called level no need for
08:54 - inheritance but we will need a thunder
08:57 - init method for now it's just going to
09:00 - use self but there's going to be quite a
09:02 - few arguments later on now in there
09:05 - first of all we want to get self.
09:07 - display uncore surface that way this
09:11 - class can also draw on the display since
09:13 - we already created the display surface
09:15 - this one we get with py game. display.
09:18 - getor surface and all that this one is
09:21 - going to do is it gives us this display
09:24 - surface and that we can draw on as a
09:27 - matter of fact this we are going to do
09:29 - right away let's do it via a run method
09:32 - no need for custom parameters for this
09:34 - one and all I want to do is self.
09:37 - display surface and then fill it with a
09:39 - color the color doesn't really matter
09:41 - let's go with
09:43 - gray now that we have that once we are
09:45 - calling the run method we should be able
09:47 - to fill the entire window with a gray
09:50 - color for that to work though we have to
09:52 - create and run the method and that we do
09:54 - inside of main.py all we have to do is
09:57 - from level import level and then create
10:02 - one instance of this inside of an
10:04 - attribute in the game class the name of
10:07 - the attribute that I have chosen is
10:08 - self. current stage because later on the
10:13 - current stage could either be a level or
10:15 - the Overworld because of that I not
10:17 - going to call it self. level although
10:19 - you could but it would be a bit weird
10:21 - anyway all we want to do is create one
10:23 - instance of the level no need for
10:25 - arguments at this stage and after we
10:27 - have that before we are calling py game.
10:29 - display. update I want to get self.
10:32 - current stage and then call the run
10:34 - method if I now run all of this we're
10:37 - getting a gray background and this is
10:39 - because of that line if you change it to
10:42 - Red for example you would get a red
10:44 - background that is leaving us with two
10:47 - major things to work on number one we
10:50 - need a basic outline of the player and
10:52 - number two we need the main parts of the
10:54 - level I.E the parts of the level that
10:57 - the player can collide with
10:59 - the second part is a bit easier so let's
11:02 - get started with that if we are looking
11:04 - back at Tiles the only tiles I really
11:07 - care about are inside of the terrain
11:09 - layer meaning everything else at least
11:11 - for now I want to hide and there is
11:14 - quite a bit more none of this I care
11:16 - about the only tiles I care about are
11:18 - these also for now we are not going to
11:21 - have any graphics all of these are going
11:23 - to have one color later on we are going
11:25 - to work on the proper graphics for that
11:27 - first of all we have to import the TMX
11:30 - file and that happens inside of main.py
11:33 - we are doing all of that via a module
11:36 - that is called P
11:39 - TMX more specifically we want to import
11:42 - a sub module from that which we do via
11:45 - from
11:46 - PMX do
11:48 - _ pygame and then import load P game if
11:54 - you run the code there shouldn't be any
11:56 - error messages and that is looking
11:59 - pretty good now this module you have to
12:01 - install via pip if you have gotten an
12:03 - error message this module doesn't exist
12:05 - you have to do that just to make sure
12:07 - you know how to do it you would open on
12:09 - Windows the Powershell or on Mac OS the
12:12 - terminal and simply type pip install py
12:15 - TMX and if you're on Mac OS this would
12:18 - be pip 3 install py
12:20 - TMX that's all you have to do afterwards
12:22 - your computer is going to take care of
12:23 - the rest now with that we can import PMX
12:28 - files
12:30 - and this I also want to do inside of the
12:32 - game class and then later on pass the
12:34 - information into the level the way I
12:37 - handled that is I created a dictionary
12:39 - with self.
12:41 - TMX Maps because later on we are going
12:44 - to have quite a few for the keys I'm
12:46 - going to use integers so the first level
12:48 - is going to get the integer zero the
12:50 - associated value is going to be the load
12:53 - P game that we are getting from py TMX
12:56 - in there we now want to import one py
12:58 - TMX x file the only argument we have to
13:01 - pass into load pame is a path to the
13:03 - file and you could on your operating
13:06 - system simply type the relative path so
13:08 - in my case this would be Das
13:10 - Dash then slash then data then
13:15 - levels and then Omni do emx after we
13:20 - have that let me simply print self do
13:24 - PMX maps to see what we get and we are
13:28 - getting it dictionary with a tile map
13:30 - inside this one is going to contain all
13:32 - of the data from the
13:34 - level however before we continue with
13:37 - that we don't need the print statement
13:40 - anymore this import statement is not
13:43 - ideal because depending on your
13:44 - operating system you might need a
13:46 - different path string for example some
13:49 - operating systems use a forward slash or
13:51 - a backwards slash and this isn't exactly
13:54 - consistent which can be really really
13:57 - annoying the way around rounded is an
13:59 - inbuilt python module which I want to
14:02 - import via from os. paath import join
14:08 - join is a really powerful method and it
14:10 - gives you relative paths on your
14:12 - specific operating
14:14 - system the way you are using it is via
14:17 - join and then in there you add the
14:19 - specific nodes of your path so in my
14:22 - case I want to go up one folder then to
14:25 - data then to level
14:29 - and finally I want to get Omni TMX and
14:33 - with that I don't need the original
14:35 - string anymore the end result should
14:37 - though still be the same but it's a lot
14:40 - more reliable that being said though if
14:43 - I print all of this then you can see
14:45 - what's going on all we are getting is
14:48 - the same path that we have written
14:50 - before with that we have imported the
14:53 - data for one level and this I want to
14:55 - pass into self. current stage
14:59 - I.E self. TMX maps and I only want to
15:02 - pass in this one bit of data and to make
15:06 - that work I have to give the level class
15:09 - another parameter let's call it TMX
15:11 - uncore map and after we have that we can
15:16 - inside of the level create another
15:18 - method that I want to call setup which
15:21 - will need s and then the TMX
15:24 - map and for now let's simply print the
15:27 - TMX map and call self. setup and pass
15:32 - the TMX map right through if I now run
15:35 - m.p we are getting the tile map printed
15:39 - and all of that happens inside of setup
15:42 - with that we can contain all of the
15:44 - logic inside of this method and this
15:46 - method is going to be very chunky
15:47 - because the level is quite
15:49 - complex but we'll go through it step by
15:52 - step it's not going to be too bad first
15:54 - of all we want to Target one specific
15:56 - layer inside of this tile map map and
16:00 - for that we will need TMX map and then
16:03 - get uncore layer uncore by uncore name
16:07 - the layer we want to get is
16:10 - called ter Rin if I go back to titled
16:13 - really quick the only layer that we have
16:16 - visible right now is terrain so we are
16:18 - importing all of this data and since
16:21 - we're working with a tile set we want to
16:23 - add dot Tiles at the end and don't
16:25 - forget to call it what this allows us to
16:27 - do is to put all of this inside of a
16:29 - four loop with four x y and this surface
16:35 - and don't forget in whatever we are
16:37 - getting returned from all of this the
16:40 - end result is that for each of the tiles
16:42 - you can see inside of the tile map we
16:44 - get the X position so the columns the Y
16:47 - position I.E the rows and then the
16:50 - surface that would be the associated
16:52 - image for each of them if I now run
16:54 - main. pi and expand the print statement
16:59 - you can see that we always have an X
17:02 - position a y position and a surface that
17:05 - we can use for the level Graphics
17:07 - although for that to work we have to
17:09 - create a class that can actually be
17:11 - displayed I.E we are going to need a
17:14 - Sprite and we are going to create quite
17:16 - a few different Sprite classes I'm going
17:19 - to St of them in a separate python file
17:22 - which means I want to create Sprites
17:25 - dopie in there once again I first of all
17:28 - have to import from settings and I want
17:31 - to have everything that way we have
17:33 - access to py game and the only class we
17:36 - want to create for now is called Sprite
17:38 - a very simple class and this one needs
17:41 - inheritance pygame dos sprite. Sprite
17:45 - and do pay attention to the second
17:47 - Sprite having a capital letter for the s
17:51 - for this class we want to have a Dunder
17:54 - init method with self the position where
17:56 - we want to place it the surface that we
17:59 - want to display and finally we want to
18:02 - have the groups and as a reminder we are
18:04 - displaying Sprites by putting them into
18:06 - groups and then the groups are
18:08 - displaying and updating all of them
18:11 - we're going to handle that in just a
18:12 - second first of all though we have to
18:14 - call
18:15 - super. Thunder init to initialize the
18:18 - parent class I.E py. sprite. Sprite and
18:22 - the one argument you can pass in here is
18:24 - the groups that way you are assigning
18:26 - this Sprite to a group when you are
18:28 - creating it which is super handy after
18:31 - that each Sprite wants to have self.
18:33 - image and self. wct the image is what we
18:37 - are going to display and in our case for
18:40 - this part of the video we don't care
18:42 - about specific Graphics we just want to
18:44 - display the basic
18:46 - outline so for this part you could be
18:48 - using the surface and then you would be
18:50 - displaying the graphics from tiles I.E
18:53 - the stuff you can see on here however I
18:56 - don't want to do that I simply want to
18:58 - create a pame do surface with the size
19:01 - of the tile size and that we get from
19:03 - settings I want to copy tile size and
19:06 - insert this twice once for the width and
19:09 - once for the height and just to make
19:10 - sure we can see what's going on I also
19:12 - want to fill this image so self. image.
19:15 - fill and let's say we want to fill it
19:17 - with a white color after that we will
19:19 - need self. rect and this will determine
19:22 - the position for that I want to have
19:24 - self. image and then
19:26 - getorf wrecked
19:28 - if you have used py game in the past you
19:30 - probably know get wrecked but nowadays
19:33 - you are using get F wck and this one
19:35 - creates a floating Point rectangle which
19:38 - is much better in terms of movement
19:40 - inside of py game basically a normal wct
19:43 - can only be placed via integer values so
19:45 - 0 1 2 3 and so on but an frre is placed
19:49 - via floating Point values meaning you
19:51 - can have 1.15 something which is
19:54 - significantly more precise and when it
19:56 - comes to movement much more reliable
19:58 - but in terms of arguments you are still
20:00 - using them like any other rectangle
20:03 - which means when we are creating it we
20:05 - want to decide which point we want to
20:08 - place and in my case I want to place the
20:10 - top left and this one will need the
20:13 - position that position we are getting
20:16 - from the parameters and passing it
20:17 - through cool with that we can go back to
20:20 - level. Pi and first of all we need from
20:23 - Sprites and I want to import this Sprite
20:27 - after that we we will need to create one
20:30 - group and later on we're going to create
20:32 - a couple of groups so let me add a
20:34 - comment here to organize the code the
20:36 - group I want to create for now is going
20:38 - to be stored inside of an attribute and
20:40 - I'm going to call it self. all Sprites
20:43 - every single Sprite that we are going to
20:45 - create will be inside of this group and
20:48 - Via that they will all be drawn now the
20:50 - group we are creating with pame DOs
20:53 - sprite.
20:54 - group and if you spell it correctly that
20:57 - would also help quite substantially all
20:59 - right with that we have a group that
21:02 - means next up we can turn this bit of
21:04 - information into an actual class we want
21:08 - to create a Sprite class and for that we
21:10 - will need a position a surface and a
21:13 - group let me copy the parameters the
21:16 - position is going to be X and Y at least
21:20 - for now the surface we can pass right
21:23 - through so this one doesn't have to
21:24 - change at all the groups for now is
21:27 - going to be do all Sprites with that we
21:31 - have Sprites inside of a Sprite group
21:35 - all we have to do now is inside of the
21:36 - run method called self. or Sprites do
21:40 - draw and then for the argument we have
21:42 - to specify on what surface we want to
21:44 - draw I want to draw on self. displore
21:49 - Surface also the background should be
21:51 - black red is a bit distracting so with
21:55 - that I can run main. pi and we can see
21:59 - some really messy stuff in the top left
22:03 - the reason for that is if you look at
22:05 - level. Pi this X and Y is not pixel
22:08 - position it's position inside of a grid
22:12 - these numbers would be something like 0
22:13 - 1 maybe a 10 maybe a 15 what pame is
22:17 - looking for is an actual pixel position
22:20 - so for example our window would be 1280
22:22 - x 720 pixels if you move by 10 pixels
22:25 - it's going to be very little movement
22:28 - fix that we have to convert the grid
22:30 - position to pixel positions and to meth
22:33 - for that is super simple we just have to
22:36 - multiply both of them with the tile
22:39 - underscore size also I should be adding
22:43 - the multiplication sign now if I run all
22:46 - of this
22:47 - again we have a proper looking level
22:50 - comparing all of this to tied you can
22:52 - see what's going on we are basically
22:55 - creating this part right now
22:59 - cool that covers the first part next up
23:02 - then we can import or rather create the
23:05 - player now for that let's have a look at
23:08 - Tiles the player itself is inside of the
23:11 - object layer if I make this one visible
23:13 - you can see that we have a player this
23:15 - little icon is wherever the player is
23:17 - going to start and this if you look in
23:19 - the top right is an object layer I.E we
23:22 - are working with an object we can move
23:23 - around very easily we're not bound by
23:26 - the grid coordinates but other than that
23:28 - the differences are quite minor which
23:31 - means back inside of level. Pi I need
23:35 - another four loop I want four obj in TMX
23:40 - map and then get layer by name once
23:42 - again the layer I want to work on right
23:45 - now is called objects for this one since
23:49 - we're not working with tiles you don't
23:51 - need the dot Tiles at the end instead
23:54 - we're getting an obj object let's
23:56 - actually print what we're getting
23:57 - getting print. obj if I now run all of
24:00 - this we are getting a whole bunch of obj
24:05 - objects the only one that we care about
24:07 - at the moment is tiled object 15 the
24:10 - player player by the way is the name of
24:13 - this object which is super handy because
24:16 - we can for example obj do name and check
24:20 - if this is player also there should be
24:23 - an if at the beginning if that is the
24:26 - case we can for example get the player
24:29 - position let's say obj X and obj Y if I
24:32 - now run m.p again we get the player
24:36 - start position for X and Y now we can
24:39 - create a player and this part is going
24:41 - to be your exercise for this section of
24:44 - the video I want you guys to create the
24:46 - player inside of a player. pi file it's
24:50 - going to look for now very similar
24:51 - compared to the Sprite we have just
24:53 - created also the color of the player
24:56 - should be red and it it should appear in
24:58 - the position that we have set entitled
25:00 - pause of you now and try to work this
25:02 - one out on your
25:06 - own I want to start by creating a new
25:09 - python file that I'm going to save as
25:12 - player do PI we will need from settings
25:16 - and I want to import everything after
25:19 - that I want to create a class called
25:21 - player which like Sprite is going to
25:24 - inherit from py game. sprite. Sprite
25:28 - after that we will need a thunder init
25:32 - method with self then we will need the
25:35 - position of the player and we will need
25:39 - the groups that the player should be in
25:42 - inside of the init method first of all a
25:45 - really easy thing to forget is to
25:46 - initialize the parent class and there we
25:49 - can also pass into groups after that we
25:51 - will need self. image and self. wct and
25:55 - this is the part we have already seen
25:56 - for the image I want to create pame do
26:00 - surface this one wants to have a two bu
26:02 - with a width and a height the specific
26:05 - numberers here for now really don't
26:08 - matter that being said if we open the
26:11 - player inside of Photoshop we can
26:13 - measure the size of his
26:15 - body and I think this should be roughly
26:18 - the player size so we have a width of 48
26:21 - pixels and height for 56 those are
26:23 - numbers we can use for now but later on
26:25 - we are simply going to use the dimension
26:27 - of the image to determine how large the
26:29 - player will be anyway for now I want to
26:31 - have a width of 48 and a height of 56
26:36 - that way at least we have a basic idea
26:37 - of how big the player is going to be
26:40 - after that we will need the rectangle
26:42 - and for that we need self. image.
26:46 - getorf with the top left being the
26:49 - position that we're getting from the
26:52 - parameters cool with that inside of
26:55 - level. Pi we have to import from
27:00 - player the player class after that
27:04 - inside of the if statement we want to
27:07 - create one instance of the player class
27:09 - and for that we will need a position and
27:11 - a groups the groups is easy we only have
27:14 - a single group self. all Sprites the
27:17 - position is going to
27:19 - be obj dox and obj doy and I should have
27:25 - mentioned earlier but obj or already
27:27 - gives you the pixel position meaning
27:29 - those numbers we don't have to multiply
27:31 - with tile size but anyway if I now run
27:34 - may not P again we cannot see anything
27:38 - and the issue that we have is that the
27:40 - background is black and the player
27:41 - itself is also black and black on black
27:44 - is very difficult to see to fix that we
27:47 - want to get self. image and then fill
27:49 - all of this I think I said with a red
27:51 - color but choose whatever color you want
27:53 - it really doesn't matter if I now run
27:55 - all of this again we can see the player
27:58 - that feels much better cool with that we
28:01 - have covered the exercise and this
28:03 - already let me run it again is a pretty
28:06 - good start to get ready with the
28:09 - level now to go a bit further I also
28:12 - want to add some basic movement but for
28:14 - that we need a few more things first of
28:17 - all though I want to get rid of the
28:19 - print statements because they are going
28:21 - to annoy me most importantly we want to
28:24 - work inside of player. p in there we
28:28 - will need two things an input method
28:32 - that doesn't need any parameters and for
28:34 - now I simply want to add pass in here
28:37 - after that I want a move method and this
28:40 - one also needs only self for now and
28:42 - pass so we don't get an error message
28:45 - also what we have to figure out is how
28:46 - to call all of these methods and for
28:49 - that we will create a third one called
28:52 - update now this update is kind of
28:55 - special because it's going to be called
28:57 - via the group the way it works is you
29:00 - want to call self. orites and then the
29:03 - update method and this update method is
29:05 - going to call all of the update methods
29:08 - inside of the Sprites that are inside of
29:09 - it right now the player has an update
29:12 - method so the group will call this
29:14 - method and to demonstrate let's print
29:17 - player if I now run m not Pi we can see
29:20 - we have player in the bottom left that's
29:22 - really
29:23 - good now in there I want to call Self
29:27 - Dot input and self. move since both
29:31 - method have no real Conta this isn't
29:33 - going to do anything but it's a good
29:35 - start now we can create some input to
29:38 - get input we first of all have to create
29:40 - a local variable called key or rather
29:43 - keys and then we want to get all of the
29:45 - keyboard input that we get with pame do
29:48 - key then getor pressed this is going to
29:52 - give us all of the currently pressed
29:54 - Keys which we can use with for example
29:57 - if if keys and py game.
30:00 - Kore
30:02 - right then we would for example print
30:06 - right if I now run main. pi and I press
30:09 - to the right we're getting right now we
30:11 - have to figure out how to actually use
30:13 - this to move the player and for that we
30:15 - will need a few more things let's all of
30:17 - this under common let's call it movement
30:20 - first of all I will need self. direction
30:23 - which is going to be a vector or more
30:26 - specifically a vector to 2 this Vector
30:28 - we can get because in settings. pi we
30:31 - have renamed the vector so instead of a
30:34 - vector 2 we are simply creating a vector
30:37 - by default the values are going to be
30:38 - zero and zero for X and Y which is
30:41 - exactly what I want besides that I also
30:43 - want to set self. speed for now let's
30:47 - say I want to go with
30:49 - five after that we can work inside of
30:52 - the move method and in there I want to
30:54 - get self. rec. Toop left plus equal
30:59 - self. direction multiplied with self do
31:04 - speed basically we are taking the
31:07 - current position of the player and we
31:08 - are increasing it by the speed in a
31:11 - certain direction that's all that's
31:12 - happening here now right now if I run
31:15 - main. Pi this is not going to do
31:17 - anything simply because we don't have a
31:19 - Direction but if I change this Vector to
31:22 - one and zero and Run the game again the
31:25 - player is moving very fast to the right
31:27 - the five here is very very fast let's
31:30 - say 0.1 might be
31:32 - better there we go this is looking a bit
31:35 - better and in just a second we are going
31:38 - to work on frame rate Independence that
31:40 - way it doesn't matter what the frame
31:42 - rate of the game is our players going to
31:44 - move at a constant rate first of all
31:46 - though I want to change direction back
31:48 - to zero and zero because the player
31:51 - should only move in the direction that
31:53 - is being pressed on the keyboard and for
31:55 - now the player can only move left or
31:58 - right so we want to check the keys for
32:00 - py game. K right and K left and usually
32:05 - how I approach these things is before we
32:07 - getting input we are creating another
32:09 - Vector that I usually call input vector
32:13 - and this is a completely new Vector with
32:15 - no values so the values by default are
32:17 - zero and zero meaning on every frame of
32:21 - the game the input Vector starts with
32:23 - Zer and zero and after we are doing that
32:26 - we can update it depending on what the
32:27 - player is pressing for example if the
32:29 - player is pressing on the right arrow
32:31 - key then I want to get input vector dox
32:35 - and increase it by
32:37 - one however if the player is pressing to
32:40 - the left then I want to subtract it by
32:44 - one with that system if the player is
32:47 - pressing both we end up back on zero so
32:49 - we have no movement whatsoever all we
32:52 - have to do at the end of it is set self.
32:54 - direction to the value of the input
32:57 - Vector if I now run may not Pi again and
33:01 - if I press left or right the player is
33:03 - moving so that's a really good start
33:06 - although I want to make one more update
33:09 - I don't just want to get the input
33:11 - Vector I also want to normalize it that
33:14 - just means that the length of the vector
33:16 - is always going to be one that way we
33:18 - are ensuring that the direction is only
33:20 - giving as the direction the speed is
33:22 - what's actually setting the speed I
33:25 - suppose I should do an example imagine
33:27 - self. Direction has a value of 1 for x
33:32 - and 0 for y and that we are multiplying
33:36 - with the speed which in our case is
33:41 - 0.1 the result is going to be another
33:45 - Vector that is going to be
33:48 - 0.1
33:50 - and0 that would be the actual Movement
33:54 - we would move by a unit of 0.1
33:57 - however now imagine that we get a
33:59 - different kind of vector that wouldn't
34:01 - be ideal where we have an X of two and Y
34:05 - could still be zero it doesn't really
34:06 - matter if we multiplying this by the
34:09 - same speed IE
34:11 - 0.1 the result would be
34:15 - 0.2 and
34:18 - 0 the problem with this second result is
34:21 - that the movement speed would be twice
34:23 - as fast as the original result and that
34:26 - we prevent with
34:29 - normalize it simply keeps the direction
34:31 - of the vector but it ensures that they
34:33 - all have the same length however this we
34:36 - can only do if the vector has any kind
34:39 - of value imagine you want to normalize a
34:42 - vector with zero and zero it doesn't
34:43 - point in any direction you simply
34:45 - couldn't normalize
34:47 - it as a matter of fact if you run the
34:49 - code like this you should be getting an
34:51 - error and we do that we cannot normalize
34:54 - a vector with a length of zero to get
34:56 - wrong that it's quite simple we only
34:59 - want to normalize the vector if there is
35:02 - an input Vector at all a vector with a
35:05 - value of 0 and zero will return false so
35:08 - this one would not run but we do need an
35:10 - out statement and we simply want to
35:12 - return the input Vector on its own now
35:15 - if I run main. Pi we get basically the
35:18 - same kind of
35:20 - movement so not much has changed but the
35:22 - game works a bit more
35:24 - consistently we are nearly done for this
35:26 - part there's just one more thing that we
35:28 - will need and that is frame rate
35:31 - Independence at the moment our game
35:33 - always runs as fast as possible it
35:35 - should be around 1,000 frames per second
35:37 - if not
35:38 - faster but if you have a really slow
35:41 - computer this number might be
35:42 - substantially lower and our game would
35:45 - run either too fast or too slow
35:47 - depending on what setup the player has
35:49 - this we have to account for and for that
35:52 - we will first of all need self. clock
35:56 - which we get with py game. time. clock
35:59 - this is going to give you a clock object
36:01 - and that in return can control and
36:03 - measure the frame rate the way you are
36:06 - usually using it is all the way at the
36:09 - top of your while loop you're calling
36:11 - self. clock and then tick whatever you
36:14 - insert into the tick method is going to
36:16 - be your frame rate if you leave it empty
36:18 - your game is going to try to run as fast
36:20 - as possible if I run the game now
36:22 - there's not going to be any
36:24 - change however if I change this number
36:27 - to f30 and run it again now if I press
36:31 - to the left we're going to move
36:32 - substantially slower because we have a
36:35 - lot fewer frames to account for that we
36:38 - will need a concept called Delta time
36:41 - which is going to be returned by the ti
36:43 - method we can store that inside of a
36:45 - local variable if I print the
36:49 - value we are getting 33 sometimes
36:52 - 34 that means that it takes py game
36:56 - around 33 milliseconds to draw one frame
36:59 - which makes sense we have 30 frames per
37:01 - second and 1,000 so 1,000 milliseconds
37:04 - divided by 30 is about 33 if I get rid
37:08 - of the 30 and run all of this again we
37:11 - get a much lower number because now the
37:13 - game tries to run much faster so the
37:15 - time to draw one frame is drastically
37:17 - lower so at the moment it takes about 1
37:20 - millsc to draw one frame since our game
37:22 - is very simple that number makes sense
37:25 - in our case we want to have these
37:26 - numbers in seconds which you get by
37:28 - dividing the return value by a
37:32 - thousand and this data time has to be
37:34 - accessible to the player we want to have
37:37 - this inside of this function and for
37:40 - that we have to pass Delta time through
37:42 - to the player let me get rid of the
37:45 - print statement and add Delta time to
37:48 - the run method of the level with that
37:51 - inside of level. Pi we have to add one
37:53 - more parameter for Delta time after that
37:57 - we can pass the other time into the
37:59 - update method of all Sprites and next up
38:03 - inside of the
38:04 - player we can add one more parameter on
38:07 - the update and then pass thata time into
38:10 - the move method finally then inside of
38:13 - move we have Delta time available and we
38:16 - can multiply our movement with Delta
38:19 - time since datta time is a really low
38:22 - number our speed needs to be much higher
38:24 - I set this one to 200 if I now run may
38:27 - not P again we have one kind of movement
38:30 - that feels about right for the game the
38:33 - really important thing now is I can set
38:36 - the tick method or the frame rate of the
38:38 - game to something like 30 and we would
38:41 - still have the same kind of movement
38:43 - although now it looks much choppier
38:45 - because we are drawing a lot less frames
38:48 - because of that the game is going to
38:49 - look less nice basically for all games
38:52 - you want to have as many frames as
38:54 - possible because it simply looks better
38:57 - and with that we have the first part of
38:59 - the game where we are importing a couple
39:01 - of things and we're creating a player
39:03 - and a couple of Sprites next up we are
39:05 - going to work on the collisions on top
39:07 - of that we are also going to give the
39:09 - player the ability to fall down no
39:11 - jumping yet but that we can work on
39:13 - later the really important part are the
39:15 - collisions because they make the entire
39:18 - game to make that work we have to cover
39:21 - just a bit of theory let's go through it
39:24 - really quick the most important part is
39:26 - that we are splitting the movement and
39:28 - the collisions into the separate axes
39:31 - meaning first of all we are doing all of
39:34 - the horizontal stuff this includes the
39:36 - movement and then the horizontal
39:38 - Collision check after that we are doing
39:41 - the same thing for the vertical axis so
39:43 - we are moving up and down and then we
39:45 - are doing vertical
39:46 - collisions with that set up the math
39:48 - becomes substantially easier next up
39:51 - them we have to figure out how to
39:52 - actually do collisions and there's
39:54 - already a problem because because pame
39:57 - doesn't really have inbuilt collisions
39:59 - the only thing that we do have are
40:01 - overlap checks and since we are working
40:03 - with Sprites that all have a rectangle
40:05 - we can check overlaps quite easily but
40:08 - the really important thing to understand
40:09 - here is that an overlap is not a
40:12 - collision all we can tell is that two
40:15 - rectangles are overlapping but this does
40:18 - not affect the position at all for that
40:20 - we need step number three where we are
40:23 - updating the position the way you want
40:25 - to think about it imagine you have some
40:27 - kind of static object and then a moving
40:31 - object let's say this one's moving to
40:33 - the right and eventually this object is
40:35 - going to overlap with the static object
40:38 - that would be the overlap check after we
40:41 - have done that we want to get to step
40:43 - number three and update the position
40:45 - where the yellow moving rectangle should
40:47 - be somewhere here ultimately we're
40:51 - moving it a bit further to the left
40:52 - because of the overlap that way it looks
40:55 - like there's an actual Collision not
40:57 - just an overlap we do however have to
41:00 - account for something
41:02 - else when we are updating the position
41:05 - we kind of don't know yet where the
41:07 - Collision happened and let me
41:09 - demonstrate so in the previous example
41:12 - we had a static object and then we had a
41:14 - moving object and now think of this from
41:17 - the point of view of py game all it sees
41:19 - are two rectangles that are overlapping
41:22 - with that information it doesn't really
41:24 - know where the Collision happened and
41:26 - that makes it impossible to resolve this
41:28 - Collision for example this yellow
41:30 - rectangle could have been in the
41:31 - previous position here it could have
41:35 - been here it could have been here it
41:40 - could have been here all of those would
41:43 - be valid positions that could have
41:45 - happened and we simply don't know which
41:47 - one is the case and to keep all of this
41:50 - a bit Keener let's do it only on one
41:52 - axis so once again we have a static
41:55 - object on top of of that we have a
41:57 - moving object that right now is here we
42:00 - have to resolve this Collision meaning
42:02 - we have to update the position of the
42:03 - yellow rectangle to get a proper
42:05 - Collision but we don't know where that
42:07 - Collision happened if the yellow
42:09 - rectangle came from the left and moved
42:11 - to the right then the correct answer
42:13 - would be roughly here however what is
42:16 - also a possibility is that the rectangle
42:19 - came from the right and move to the left
42:21 - really fast in that case the correct
42:23 - answer would be that the correct
42:25 - resolution would be on the right side
42:28 - and we have to figure out if the moving
42:30 - object came from the right side or from
42:32 - the left side and for that we will need
42:35 - extra information and what I think is
42:37 - the best way is to check the position of
42:40 - both objects twice once in the current
42:42 - frame and once in the previous frame and
42:45 - let me draw all of this again we once
42:46 - again have a static object and we have
42:49 - an overlap but now we also have
42:52 - additional information besides the
42:54 - current position of the yellow rectangle
42:56 - we also get the last frame position and
42:58 - let's say it was here and now the answer
43:02 - is much easier to understand we know
43:04 - that the rectangle moved from there to
43:07 - there and as a consequence the correct
43:09 - answer for the Collision would be this
43:11 - side that is the logic we have to
43:13 - implement so let's do all of this
43:15 - straight in code back in the project
43:18 - before we can start working on the
43:20 - actual collisions we need to do just a
43:22 - bit of setup most importantly the player
43:25 - needs to know where the Collision
43:27 - objects are at the moment he can move
43:30 - around but well we don't really know
43:32 - where other objects
43:34 - are for that inside of level. Pi I want
43:37 - to create another Sprite group self.
43:40 - Collision uncore Sprites and this is
43:44 - just going to be another Sprite group I
43:46 - can actually copy the previous one so py
43:49 - game. sprite. group with that we have
43:52 - Collision Sprites and this group should
43:54 - contain all of the collidable Sprites at
43:57 - the moment we only have basic Sprites
43:59 - and those we want to assign to two
44:01 - groups they will always be in all
44:03 - Sprites but they should also be in self.
44:06 - Collision
44:08 - Sprites hence for the group argument you
44:11 - want to have a tle with all Sprites and
44:13 - collision
44:14 - Sprites that way this Sprite is going to
44:17 - be in both on top of that for the player
44:21 - we want to insert these self. Collision
44:25 - Sprites
44:26 - and what is really important to
44:28 - understand now is that a Sprite is
44:31 - inside both all Sprites and collision
44:33 - Sprites however the player is only
44:36 - inside of all Sprites but on top of that
44:39 - has access to Collision Sprites but is
44:42 - not in it itself and that's a really
44:44 - important difference the player only has
44:47 - access to it it is not inside of
44:50 - it otherwise it would collide with
44:52 - itself and that would be kind of weird
44:54 - to make all of this work though inside
44:56 - of the player we have to add another
44:58 - parameter let's call it Collision uncore
45:02 - Sprites later on we are going to have
45:04 - quite a bit of collision stuff so let me
45:06 - add another comment I simply want to
45:08 - store this information inside of an
45:11 - attribute self. Collision Sprites is
45:13 - Collision Sprites and just to make sure
45:16 - we see what's going on let me print
45:18 - self. Collision Sprites if I now run
45:22 - m.p we can see we have a group with 94
45:26 - Sprites that looks about right that
45:28 - means we can now work on the actual
45:31 - collisions and to get started we have to
45:34 - work inside of the move method because
45:36 - remember step number one is that we want
45:38 - to separate the axes meaning we start
45:41 - with the horizontal stuff and then we
45:43 - get the vertical stuff for that let me
45:45 - duplicate this line the points that I
45:47 - want to update are X and Y for the
45:51 - direction I want Direction dox and
45:53 - Direction doy this line does exactly the
45:58 - same thing that we have seen earlier if
45:59 - I run the game now we still get the same
46:02 - kind of movement very hard to see
46:04 - because we only have horizontal movement
46:06 - but trust me this is doing the same
46:07 - thing but now what we can do is create a
46:12 - method called Collision which is going
46:15 - to get self by default but then also the
46:18 - AIS and this axis could be horizontal or
46:21 - vertical and the way we are going to use
46:24 - it is we're going to call it after we
46:26 - are doing the horizontal movement so
46:28 - self. collision and then we're going to
46:30 - add
46:32 - horizontal then I can duplicate the line
46:35 - and after we're doing the vertical
46:36 - movement I want to check the vertical
46:38 - collisions that way we are doing the
46:41 - horizontal movement then the horizontal
46:42 - collisions then the vertical movement
46:44 - and then the vertical
46:46 - collisions so now we have to figure out
46:49 - the collisions itself and first of all
46:51 - we have to look at all of the Sprites
46:53 - inside of collision Sprites that we can
46:55 - do do let's say for sprite in. Collision
46:59 - Sprites after that we want to check if
47:03 - sprite. wct do Collide and the method
47:07 - here is called Collide wct although a
47:09 - better name for this one would be
47:10 - overlap rect because we are only
47:12 - checking if there's an
47:14 - overlap but anyway what we want to check
47:16 - is self.
47:18 - wct this line basically checks a
47:21 - collision between the Sprite rectangle
47:23 - so one of the Sprites and collision
47:24 - Sprites with if self. rect which is the
47:27 - rectangle of the player if that is the
47:30 - case we want to check if the axis is
47:35 - horizontal and then we want to do stuff
47:37 - let's say pass for now and else then we
47:40 - want to do something else else would be
47:43 - the vertical Collision for now I will
47:46 - focus on the horizontal part and there
47:48 - are two cases we can cover left
47:50 - collision and right
47:53 - Collision let's get started with the
47:55 - left left side and we already know that
47:58 - there is an overlap so we now have to
48:01 - figure out where the rectangle has come
48:04 - from as a matter of fact before we start
48:06 - working on that let me simply print a
48:11 - overlap and if I now run m not pi and I
48:14 - overlap with one of the Sprites we're
48:16 - getting overlap so we definitely know
48:19 - that something is happening the issue is
48:21 - now we have to figure out where the
48:24 - overlap occurred and and this could be
48:26 - either on the left side or on the right
48:27 - side for the left side I want to check
48:30 - if self. rec. left is smaller or equal
48:37 - sprite. rec. right and if that is the
48:41 - case I want to set self. rec. left to
48:46 - sprite. re. right the way you want to
48:49 - think about this line is we have a
48:54 - static rectangle for now and this would
48:56 - be the Sprite and then we have a moving
48:58 - one that would be the player what we are
49:01 - checking with this if statement is if we
49:05 - have a player let's say here and we
49:08 - first of all want to check the left side
49:10 - of the player against the right side of
49:13 - the obstacle or the Sprite in this case
49:17 - the left side of the player would be
49:19 - this side and the right side of the
49:21 - obstacle would be this
49:24 - bit and you can see that the left side
49:26 - of the player is smaller than the right
49:29 - side of the obstacle and if that is the
49:31 - case we want to set the left side of the
49:33 - player exactly to that position that way
49:36 - we are resolving this Collision this
49:39 - should actually work already let's try
49:41 - may not pi and now if I go to the right
49:44 - yep we have a collision although this
49:47 - only works on one side if I do it the
49:49 - other way we get some really weird
49:52 - Behavior to get around that we have to
49:54 - also cover the right side and this one
49:57 - works in basically the same way we want
50:00 - to check if self. rec. right is greater
50:03 - or equal then sprite.
50:06 - re. left and if that is the case we want
50:09 - to set self. re. right to sprite. w.
50:15 - left let's write this one now and that
50:19 - is looking not terrible let's try the
50:22 - other
50:23 - side and now we get some weird behavior
50:27 - that was intended because our Collision
50:29 - logic is currently
50:31 - incomplete basically pame became
50:34 - confused with these two lines where to
50:36 - put the player and well we have to add
50:39 - one more condition to actually tell
50:41 - which direction the player came from so
50:44 - for example if we once again have a
50:47 - Sprite and we have a player overlapping
50:50 - with it we now have to figure out if the
50:52 - player came from the right side and we
50:54 - have to put the left side of the player
50:55 - here or if the player came from the left
50:57 - side and moved right and then the player
50:59 - should be here with the right side on
51:02 - the left side of the obstacle to get
51:05 - that information we have to find where
51:07 - the player was on the last frame and the
51:10 - best way to get that information I found
51:13 - is when we are creating the entirety of
51:17 - the
51:18 - player we get two rectangles so let me
51:21 - another a comment with rects we first of
51:24 - all have the main rectangle this is
51:27 - going to show where the player will be
51:28 - drawn but on top of that I want to
51:30 - create self. old rect which by default
51:34 - is simply going to be self. re. copy the
51:37 - trick with this old rectangle is that
51:40 - bobia doing anything else in the update
51:43 - method we are setting self. old W to a
51:48 - copy of self. rect so self. rec. copy
51:52 - once again we are storing the current
51:54 - position of the rectangle inside of the
51:57 - old rectangle and then when we are doing
51:59 - all of the movement we are getting a new
52:01 - position instead of self. self. direct
52:04 - has the current position Old direct has
52:06 - the previous one although this
52:08 - information we need both for the player
52:10 - and for the Sprites now at the moment
52:12 - all of these Sprites do not move but
52:14 - they still need an old wct and that is
52:18 - quite easily added self. _ wct it's
52:22 - going to be self. rec. copy with that we
52:27 - can expand our Collision logic let's
52:30 - start with the left side I want to check
52:32 - if currently the rectangle or the left
52:34 - side of the player rectangle is to the
52:37 - left of the right side of the obstacle
52:40 - on top of that I want to check if self.
52:44 - allir do left is greater or equal than
52:50 - sprite. old. right so what does that
52:54 - mean once again to draw we have the
52:58 - static rectangle and we have the player
53:01 - one as well the first condition we
53:03 - already covered basically we are
53:05 - checking if the left side of the player
53:07 - is further to the left than the right
53:09 - side of the obstacle but on top of that
53:11 - we now have a second condition where we
53:14 - are checking the last position of the
53:15 - player and let's say old wck of the
53:18 - player was here and we are checking if
53:22 - this left side of the player was greater
53:25 - than the right side of the obstacle IE
53:31 - side that's why we know that on the last
53:33 - frame the player was to the right of
53:37 - this obstacle and in the current frame
53:39 - it is overlapping with the obstacle and
53:42 - both of those conditions combined mean
53:44 - that we are landing exactly on this line
53:48 - here and the same thing we have to do
53:51 - for the other sides so let me copy it
53:55 - for the right side Collision we
53:58 - basically want to check the opposite if
54:00 - self. w. right was smaller than or equal
54:04 - than sprite. rec. left and now if I run
54:08 - main.
54:10 - Pi that Collision looks pretty good and
54:13 - let's try the right
54:16 - side and that is also looking very
54:20 - solid that is going to cover the
54:22 - horizontal collisions so now I can
54:25 - minimize this and then we are going to
54:28 - work on the vertical collisions the
54:30 - issue is at the moment we don't really
54:32 - have vertical movement so doing this is
54:34 - going to be a bit of a problem to fix
54:37 - that we can start working on the
54:39 - vertical movement at least a little bit
54:41 - for now we are only going to make the
54:43 - player fall down for that inside of the
54:46 - move method and let me actually minimize
54:49 - everything so we can focus on one
54:51 - particular issue inside of the move
54:54 - method I want to first of all check the
54:56 - horizontal stuff that is what we have
54:59 - just done and then I want to work on the
55:01 - vertical
55:02 - logic to figure out the fall mechanic we
55:05 - have to work on a couple of things
55:07 - number one we shouldn't be using speed
55:10 - anymore because the player shouldn't be
55:12 - falling by the same speed as he is
55:14 - running that would be a bit weird
55:16 - although I guess you could be doing it I
55:18 - would rather want to have some kind of
55:20 - gravity and that we can set inside of
55:22 - the dunder init method and the speed I
55:25 - also want to have self.
55:29 - gravity in my case I went with
55:33 - 1,300 but that number is quite
55:35 - subjective just choose later on what you
55:37 - think looks good well with that we have
55:40 - a gravity next up we have to work on
55:43 - that our fall speed increases the longer
55:45 - we fall remember that gravity is not a
55:48 - constant if you fall longer you should
55:50 - be falling faster and all of that should
55:53 - also work with Delta time and well
55:56 - there's one specific thing that
55:58 - basically solves all of that first of
56:00 - all we want to get self. direction and
56:02 - only work with Y we basically want to
56:05 - increase this value by self. gravity
56:09 - that we want to multiply with Delta time
56:11 - as well that is going to give us a new
56:14 - Direction and this direction we want to
56:16 - use to update self.
56:18 - w.y actually what I've have done below
56:21 - so I don't need this line I can reuse
56:23 - this line we now have self. Direction
56:26 - doy but we don't need self. speeed or
56:29 - time anymore with that we should already
56:32 - have a decent start at the very least
56:34 - the player should now be falling
56:36 - although it might be a bit fast if I go
56:38 - back to the player and I change the
56:41 - gravity to something like let's say
56:44 - 400 then we get some decently looking
56:47 - falling Behavior so that's not
56:50 - bad however this system is not ideal
56:54 - because because it actually isn't frame
56:56 - rate independent it might look like it
56:58 - because we are using Delta time but if
57:01 - the frame rate changes then we would get
57:03 - different Behavior what you are actually
57:06 - supposed to do is divide the Gravity by
57:09 - two and then duplicate this line and
57:11 - then after we are applying the movement
57:13 - do the same thing again that way we
57:16 - getting the average of the downward
57:19 - velocity and then when we applying
57:21 - direction. y we also want to multiply it
57:23 - with Delta time
57:25 - once we have that logic and by the way I
57:27 - found this code snippet on stack
57:29 - Overflow I'm going to link the page it's
57:32 - super useful what we can now do is set
57:34 - the gravity back to
57:36 - 1,300 and then try m. pi and we can see
57:40 - that the gravity very barely works the
57:44 - issue for that is a bit deceiving
57:46 - because the problem is the input method
57:49 - more specifically this line where we are
57:52 - normalizing the vector because of that
57:55 - the length of Direction can never be
57:57 - greater than one regardless of what we
57:59 - are doing down here in the gravity bit
58:02 - the way around that is that direction
58:04 - should only cover the horizontal part
58:06 - meaning only self. direction dox should
58:09 - be
58:10 - updated and then well from the
58:13 - normalized vector we only want to f x
58:15 - same with the input Vector if we are not
58:18 - normalizing it or well we could just
58:20 - return zero here it would be the same
58:22 - thing but anyway let's not try of this
58:25 - and we have gravity that looks good with
58:28 - that we have the two major parts of the
58:31 - movement so I can minimize this method
58:33 - and now we can work on the final part of
58:35 - the Collision the vertical bit that part
58:38 - is going to be your exercise I want you
58:41 - to finish the vertical collisions it
58:43 - should look very similar compared to
58:45 - what we have done for the horizontal
58:46 - ones pause the video now and see how far
58:49 - you
58:53 - get to to get started there are two
58:56 - options we could encounter we have a top
59:00 - collision and we have a bottom Collision
59:03 - for the top Collision I want to check if
59:05 - self. re. toop is smaller or equal
59:10 - compared to sprite.
59:12 - w.
59:14 - bottom on top of that I want to check if
59:18 - self. old. toop is greater or equal
59:23 - compared to Sprite dot old wed do
59:28 - bottom and if that is the case I want to
59:31 - set
59:32 - self. dotop to sprite. rec. bottom once
59:38 - again we have our Sprite and we have the
59:42 - player let's say now the player is
59:44 - roughly here the first condition that we
59:48 - are checking is if the top of the player
59:50 - is smaller than the bottom of the Sprite
59:53 - the top of the player layer is this line
59:56 - and the bottom of the Sprite is this
59:58 - line in the current image this would be
60:00 - correct remember that the origin point
60:02 - in P game is in the top left so this
60:04 - would be zero and our coordinate system
60:06 - extends from there so this condition
60:09 - would be true next up we have to check
60:11 - the old rectangles and for the player
60:14 - let's say the old rectangle was
60:18 - here on there we want to check the top
60:21 - of this rectangle if it was greater than
60:24 - the bottom of the Sprite rectangle that
60:27 - way we know that in the last frame it
60:29 - was below the Sprite which in this case
60:32 - would also be true so this line would be
60:35 - executed which is exactly what we want
60:38 - after that I can duplicate this entire
60:41 - line and then cover the bottom side we
60:43 - want to check if self. re. bottom is
60:47 - greater or equal than sprite. re. toop
60:51 - and on top of that we want to check
60:53 - self. old rect
60:55 - bottom is smaller
60:57 - than sprite. old. toop and if both of
61:03 - those conditions are true then self. re.
61:06 - bottom should be sprite. re. toop if I
61:10 - now run all of this we are landing on a
61:12 - platform and that looks really good
61:15 - there's just one minor issue and that is
61:17 - while we are standing on here Direction
61:19 - not why so the gravity is continuously
61:22 - being applied meaning if we are falling
61:24 - down
61:24 - we are disappearing
61:26 - immediately as a matter of fact let me
61:29 - demonstrate this a bit better after the
61:31 - move method down here I want to print
61:35 - self. Direction
61:37 - doy and now if I run main. Pi you can
61:41 - see that our downwards gravity keeps on
61:43 - increasing and this shouldn't happen the
61:46 - way around that we don't need the print
61:48 - statement anymore is if we have any kind
61:51 - of vertical Collision then we want to to
61:54 - set self. Direction doy to Z and now if
62:01 - we run off this again I can fall down
62:04 - and we have a fairly constant gravity
62:07 - applied that looks good and with that we
62:10 - have the gravity this is basically all
62:12 - we need all righty at this point we
62:15 - already have the basic outlines of a
62:17 - platformer but there's one really
62:19 - important part missing and that is
62:21 - jumping on top of that we are also going
62:24 - to add wall sliding and wall jumping and
62:27 - most of the logic for that actually
62:28 - isn't that difficult so let's jump
62:30 - straight into the project here we are
62:33 - and I want to work inside of player. py
62:36 - first of all we need to get some kind of
62:38 - input to tell the game that the player
62:40 - wants to jump that's going to happen
62:42 - inside of input all the way at the
62:44 - bottom of this method I want to check if
62:47 - keys and then P game.
62:50 - Kore space if that is the case I want
62:54 - want to jump for now let's simply print
62:57 - jump to see if this is
62:59 - working if I now press space we get jump
63:03 - so that part is working just fine that
63:05 - means we can add the actual
63:08 - logic now in the most basic sense all
63:11 - you really have to do to get a jump
63:12 - mechanic is set self. Direction doy to
63:16 - some kind of negative
63:18 - value for example if I set this to -200
63:22 - run m not Pi again and press space then
63:24 - we have a little jump also if I hold on
63:27 - Space we keep on going up so it's not
63:29 - really a jump it's more of a float but
63:32 - you get the
63:35 - idea however I want to have the input
63:38 - function only for input it shouldn't do
63:41 - anything else and this would count as
63:43 - something else so I am not going to add
63:45 - a -200 in here instead I am going to get
63:50 - rid of all of that and instead set self.
63:54 - do jump to through this attribute
63:58 - doesn't exist right now so let's create
63:59 - it inside of the dunder init method
64:02 - self. jump and by default this attribute
64:05 - should be false now we know that we have
64:08 - input that the player should be jumping
64:10 - and that we can use inside of the move
64:12 - method and we can minimize the input
64:15 - method I want to work inside of the
64:18 - vertical
64:19 - Movement we can simply add a bit of code
64:22 - afterwards if self do
64:24 - jump then we want to do something most
64:28 - importantly we want to set self.
64:30 - Direction
64:32 - doy to some kind of value and that value
64:36 - I have called self.
64:39 - jumore he this attribute doesn't exist
64:43 - right now so let's create it inside of
64:45 - the dund NIT method below self. jump and
64:48 - give it a value the one that I went with
64:51 - was
64:52 - 900 however ever you do have to be
64:55 - careful for this one 900 right now is a
64:58 - downwards movement because the origin
65:00 - point of the game is the top left
65:03 - meaning if we want to go up we have to
65:05 - go in the negative direction that being
65:08 - said I don't really like having a jump
65:10 - height or some kind of strength and then
65:12 - set a negative number that feels kind of
65:14 - weird although you could be doing it in
65:17 - my case I am simply going to equal it to
65:20 - negative jump height when we are setting
65:22 - self. Direction doy and now I can run
65:25 - main not Pi again and we get a massive
65:28 - jump eventually we should be coming down
65:30 - again actually no we're not because this
65:35 - self jump is never going to be false as
65:37 - a consequence this negative direction
65:40 - will always happen hence the player
65:42 - never comes down again a fairly easy
65:45 - thing to fix all we have to do is self
65:47 - do jump should be fults right after that
65:51 - line with that I can run m not Pi again
65:54 - again and now we are coming down again
65:56 - and that feels like not a terrible jump
66:00 - although I can jump as many times as I
66:02 - want which also isn't ideal although
66:06 - kind of fun to fix this kind of behavior
66:09 - we need one important check we need to
66:11 - know if the player is on the floor or
66:14 - not and later on we also want to know if
66:16 - the player is on a wall or not that's
66:18 - going to be really important for the
66:19 - wall jump and the wall Slide the way I
66:22 - organized that part in side of the Dand
66:25 - method under the Collision part I have
66:29 - created another attribute called self
66:31 - dot
66:32 - onore surface and there are three
66:35 - surfaces that I care about number one is
66:38 - the floor by default this one gets false
66:42 - then we have left also false and finally
66:47 - we have right which by default is also
66:50 - going to be false and I want these
66:52 - values to become true if the play
66:53 - players colliding with the floor a wall
66:55 - on the left or a wall on the right and
66:58 - that we can use for example inside of
67:01 - this if statement to check if the player
67:04 - is self on
67:06 - Surface and then we want to check
67:09 - against the floor and only if that is
67:10 - the case we want to allow it
67:13 - jump that means we now have to check for
67:17 - contact with the floor and I called the
67:19 - method for that check uncore contact no
67:23 - need for custom parameters and in there
67:26 - we have to talk about some logic it's
67:28 - ultimately a very simple concept imagine
67:31 - we have the player and the player is
67:33 - surrounded by a couple of Sprites we
67:35 - could have one here another one to the
67:38 - side then let's say one here and another
67:42 - one here all that we are going to do is
67:45 - we are going to spawn three rectangles
67:47 - one to the left of the player one to the
67:50 - right of the player and one right below
67:53 - the player
67:54 - and if one of these rectangles collides
67:56 - with any of the collidable walls for
67:58 - example if the left rectangle collides
68:01 - with this one for example then we know
68:04 - we have a contact on the left side of
68:06 - the player for that we have to create a
68:09 - couple of rectangles I want to have a
68:11 - floor rectangle I want to have a right
68:15 - rectangle and I want to have a left
68:19 - rectangle for the first one I want to
68:21 - create pame do rect and now we have to
68:24 - define a left a top a width and a height
68:29 - or more specifically I want to create
68:31 - two t bus one with the left and the top
68:34 - and one with the width and the height
68:36 - both approaches are perfectly fine as
68:37 - far as P game is concerned left and top
68:40 - is actually really simple because all we
68:42 - need to get is self. rec. bottom left
68:47 - and I should probably draw all of this
68:49 - so once again we have the player and at
68:52 - the moment the floor rectangle should be
68:54 - a rectangle that covers the entire
68:57 - bottom of the player and at the moment
68:59 - the point we have placed is the bottom
69:01 - left this would be that point after that
69:05 - I want to get the width and the height
69:07 - now the width is really simple we are
69:10 - just going to get the width of the
69:12 - player and for the height we can set a
69:14 - random number that is sufficiently small
69:16 - I think two is reasonably okay
69:20 - here which means for the height we want
69:23 - to have by two and for the Wii we want
69:25 - to have self.
69:27 - dowi and I suppose the other two
69:29 - rectangles for now we can ignore
69:31 - although we will come back to them more
69:34 - importantly for now I want to get all of
69:36 - the rectangles that we could be
69:38 - colliding with and I want to have all of
69:40 - them inside of a list let's call them
69:42 - Collide rects and that is just going to
69:45 - be a list which I can get via list
69:47 - comprehension I want to get sprite. W
69:50 - for sprite in. Collision
69:53 - [Music]
69:55 - Sprites this step you don't necessarily
69:57 - have to do but I think it makes the code
69:59 - a little bit cleaner because in the next
70:02 - step and let me add a comment for that I
70:04 - want to check the actual
70:06 - collisions and ultimately all that we
70:08 - are going to do in here is self dot on
70:11 - Surface and for now we only really care
70:13 - about the floor and this one should be
70:17 - true but only if a certain condition is
70:19 - true and that is that the floor wrecked
70:22 - is colliding with any of the rectangles
70:25 - inside of the Collide W
70:27 - list for that pame has a really neat
70:31 - function it's called Collide
70:33 - list and that is checking if this
70:36 - rectangle is colliding with any
70:37 - rectangles inside of a list which in our
70:39 - case is the Collide rects list if there
70:42 - is a collision between the rectangle and
70:44 - the list then the return value of
70:46 - collide list will be the index of the
70:48 - rectangle inside of that
70:50 - list unless there is no Collision
70:53 - whatsoever then it returns -1 which
70:57 - means if this value is greater or equal
71:01 - to zero then we know there's some kind
71:03 - of return value or in other words our
71:06 - flow rectangle has hit one of the
71:07 - Collide
71:09 - rectangles if that is not the case
71:11 - however we have no collisions whatsoever
71:13 - so we can set the value to false and
71:16 - that is all we need with that we can
71:19 - look at the update method and simply
71:21 - call self. check
71:24 - contact now if we're trying all of this
71:27 - I should only be able to jump if I'm on
71:28 - the floor and I keep on pressing space
71:31 - and we only jump once we hit the floor
71:34 - however there's a bit of a weird
71:36 - Behavior if I press space then the
71:39 - player is always going to jump twice and
71:42 - I think I know what the issue is if
71:44 - we're looking at the player this jump
71:47 - equals false should not be indented
71:50 - inside of this if
71:52 - statement because of that we are only
71:54 - setting self. jump to faults once we
71:56 - hitting the
71:57 - floor but we should rather set it to
72:00 - faults as soon as we are jumping so now
72:02 - if I run m. Pi I should only be jumping
72:06 - once and that is significantly better
72:09 - cool now we already have a very basic
72:14 - platformer and everything else works
72:16 - pretty well so quite happy
72:20 - cool that means next up we can work on
72:23 - the wall collisions and for that we will
72:26 - first of all need to check if there's
72:28 - contact with the wall at
72:30 - all and that means we now can work on
72:33 - the right rectangle and the left
72:38 - rectangle both of those are going to be
72:40 - fairly similar compared to the floor
72:42 - rectangle I suppose let me draw the
72:45 - entire thing we once again want to have
72:48 - the player and now we want to have a
72:50 - rectangle to the left and to the right
72:55 - and importantly for this one I don't
72:57 - want these rectangles to fill the entire
72:59 - height of the player there should be a
73:01 - bit of space at the top and the bottom I
73:04 - suppose a good number might be that the
73:06 - height of these side rectangles should
73:08 - be 1/2 the height of the player I am
73:11 - telling you all of this because this is
73:13 - going to be your exercise I want you
73:15 - guys to create the left R and the right
73:17 - red and afterwards use them to update on
73:20 - Surface pause the video now and see how
73:22 - far you get
73:28 - let's start with the right rectangle for
73:30 - that we once again need pame dot w where
73:35 - we have to Define left top width and
73:38 - height I think for this one width and
73:41 - height are the easier Parts width is
73:43 - simply going to be two pixels and I
73:45 - should really draw all of this we have
73:48 - the player and we want to create a
73:50 - rectangle that's roughly this big at the
73:54 - moment we have set the width of this
73:55 - thing to two pixels next up we need to
73:58 - get the height which should be 1 half of
74:00 - the player height or to be a bit more
74:02 - specific we want to get half the height
74:04 - of the player rectangle so self. rec.
74:09 - height and then divide this by two after
74:11 - that we need to figure out the left and
74:13 - the top and for that ideally I would
74:16 - like to use something like I have done
74:17 - for the floor rectangle where we start
74:20 - with one of the corner points of the
74:22 - original rectangle angle so for that I
74:24 - want to use two bus for the left and the
74:26 - top and then another two bu for the
74:28 - width and the
74:29 - height so for the left Ed top the way I
74:33 - approach this is I first of I got self.
74:36 - rec. toop
74:39 - right that point would bring us all the
74:42 - way up here meaning now we have to go
74:45 - down by one qu of the height of the
74:48 - rectangle if we're doing that we end up
74:51 - down here to make that work all we have
74:53 - to do is add one more Vector which we
74:55 - can do via a vector I want to go zero
74:59 - pixels left or right and then I want to
75:01 - go self. re. height and divide this one
75:05 - by four and that is pretty much it with
75:09 - that we have the rectangle next up we
75:12 - can work on the left rectangle and this
75:14 - is going to be py game. rect and once
75:17 - again we want to have a tuple with left
75:19 - and top and then another Tuple with
75:21 - width and height once again width and
75:24 - height are going to be the easier Parts
75:26 - in fact I can almost use the same
75:29 - numbers I have used for the right
75:31 - rectangle the only change I have to make
75:33 - is that the width should be -2 and I
75:36 - should have mentioned this but in pi
75:38 - game you can totally use negative
75:39 - numbers for rectangles makes your life
75:42 - quite a bit easier but anyway now we
75:44 - have to Define left and top for that I
75:48 - want to get self. rec. toop left and
75:52 - once again go down by one quar of the
75:55 - height of the
75:56 - rectangle which I have already done
75:58 - before so I can simply copy those
76:00 - numbers also for left W I should fix my
76:04 - typo that is starting to get a bit weird
76:06 - at this point I think it's a good idea
76:08 - to test if this is actually working so I
76:10 - want to draw both of these rectangles
76:13 - actually we can draw all three of them I
76:15 - want to py game. draw do wct and now I
76:19 - want to draw on the display surface
76:22 - which we don't have available right
76:24 - now for that as a quick test self.
76:30 - displore surface is going to be py game.
76:34 - display. getor surface that way the
76:38 - player can draw on the surface but I am
76:41 - going to remove that in just a second
76:43 - it's just for testing
76:44 - purposes this is the surface I want to
76:47 - draw then I need the color let's go with
76:52 - yellow and finally we need to rectangle
76:55 - let's go with the floor rectangle and
76:57 - now if I am running all of this we are
77:00 - getting an error and that error happens
77:03 - on this line because we are not closing
77:06 - a bracket that happens for this Vector
77:10 - very easy fix if I now remain. Pi again
77:13 - there we go and you can see that we
77:16 - cannot see the floor rectangle the
77:18 - reason for that is that we are drawing
77:21 - this line inside of check contact and
77:23 - check contact happens inside of the
77:25 - update method which we are calling
77:28 - before we are filling the entire
77:30 - background as a consequence we are
77:32 - drawing black on top of this drawing but
77:35 - if we are filling the background first
77:36 - and run m.p again now we can see we have
77:40 - a very small yellow rectangle below the
77:43 - player and this is telling us if the
77:45 - player is on the floor or not and that
77:47 - looks perfectly
77:50 - fine the same thing we can now also do
77:53 - do with the right rectangle and with the
77:58 - left rectangle let's try m not Pi again
78:01 - and you can see that this is almost
78:04 - working we do have the right rectangle
78:06 - but something went wrong with the left
78:08 - one and I believe I know what the issue
78:11 - is if I go to the left rectangle and set
78:17 - this WID to a two and then for the
78:19 - vector for the offset I'm going to set
78:21 - the number to
78:23 - -2 that
78:25 - way if we have the player now this
78:30 - offset will get us down by one4 and then
78:34 - two pixels to the left so this would be
78:37 - -2 from that point we are then drawing
78:41 - the rectangle size and the width is now
78:44 - going to be two so this number now works
78:47 - out and I think now this is going to
78:49 - work so if I run main. Pi now you can
78:52 - see it that feels much better so I think
78:54 - in P game if you using negative numbers
78:57 - for a
78:59 - rectangle the rectangle is still going
79:01 - to work but the drawing logic gets a bit
79:04 - weird in the actual project I have used
79:06 - negative numbers for this one so
79:08 - definitely works but I guess I leave it
79:10 - like this so it's a bit more consistent
79:12 - we know that we have the proper
79:14 - rectangles to check if the player is
79:16 - colliding with a
79:18 - ball that we can now use to update self.
79:22 - on surface I want to check self do on
79:26 - Surface and let's go with the right side
79:30 - this one should be true if we have the
79:33 - right rectangle and a Collide list with
79:38 - the Collide rects and this number needs
79:40 - to be greater or equal to zero if that
79:44 - is not the case the value should be
79:47 - false after that I can duplicate the
79:49 - entire line change right to left and
79:53 - then I want to check the left rectangle
79:56 - also let me align those lines that feels
79:58 - a bit cleaner and with that we can print
80:02 - self dot on Surface and let's try the
80:05 - game now you can see we are on the floor
80:09 - if I collide with the right wall we get
80:11 - right being true and if I collide with a
80:13 - left wall we are getting left being true
80:16 - and all of this works pretty well so I
80:19 - am very happy with
80:21 - that we also can get multiple values so
80:24 - all of this is going very
80:26 - well that means we are done inside of
80:29 - check contact and now we can work inside
80:31 - of the move method and let me close
80:33 - everything else so we can focus on this
80:35 - one method at the moment the player is
80:39 - always falling down because of these
80:42 - three lines but if the player is sliding
80:45 - on the wall then we want to have a
80:47 - different kind of gravity or rather we
80:49 - want to have a lot less Gravity the way
80:52 - I approach roach test is simply with an
80:54 - if statement where we are checking if we
80:56 - are on a wall if that is not the case so
81:01 - else then we are going to do all of this
81:04 - stuff oh and self Collision should
81:06 - probably be all the way at the end of
81:09 - the vertical movement now we have to
81:12 - check if the player is on the wall or
81:15 - more specifically we want to check a
81:17 - couple of things first of all the player
81:20 - should only be able to slide on the wall
81:22 - if we are in the air which means we want
81:25 - to check if not self dot on Surface and
81:30 - lore next up then we can check if we are
81:33 - either hitting a left or a right wall
81:36 - and that we can check via the any
81:37 - function any wants to have either a list
81:40 - or Tuple as an argument and if any value
81:43 - inside of this list or tupal is true
81:46 - then any is going to return true in our
81:48 - case we want to check if self dot on
81:51 - Surface and
81:53 - left and the other value will be self.
81:56 - on Surface and right if both of these
81:59 - conditions are true we know that the
82:01 - player is in the air and colliding with
82:03 - a wall which means which means we can
82:07 - set a custom wall slate Behavior first
82:10 - of all I have set self. Direction doy to
82:15 - Zer that why we are stopping any kind of
82:17 - existing fall or jump
82:19 - mechanic next up then we want to move
82:21 - the player down and that we do with
82:24 - self. rect doy plus equal and then some
82:29 - kind of speed I went with self. gravity
82:33 - divided by 10 and don't forget we want
82:36 - to multiply all of this with Delta time
82:39 - and that should already be a basic start
82:41 - if I now collide with a wall this is
82:44 - going to be a bit there you can see we
82:47 - have a basic wall
82:50 - slide and we can try right the other
82:53 - side as well I just have to hit the
82:55 - wall and that is working pretty
83:00 - good next up we have to work out how to
83:03 - jump from a wall slide at the moment if
83:08 - I run main. pi and we are wall sliding I
83:12 - can't really do anything so if I press
83:14 - space nothing's going to happen for that
83:17 - we want to work inside of this if
83:19 - statement at the moment we only allow a
83:22 - jump if the player is on the floor
83:24 - however we can also add a second if
83:26 - statement or rather let's use an L if
83:30 - statement I want to check once again the
83:33 - any function we have just used in fact I
83:35 - can just copy it from up there and then
83:38 - we know if the player is currently
83:39 - sliding along the wall if that is the
83:42 - case I want to set self. Direction doy
83:46 - to the negative self. jump height in the
83:50 - game let's go to the left
83:53 - and I want to jump but I press space
83:56 - nothing is going to happen and I kept on
83:58 - holding down left in this example
84:00 - however if I jump again and press space
84:03 - and go to the right then the player is
84:05 - going to jump in that direction so the
84:07 - issue we have at the moment is that once
84:11 - we hit a wall we set s the direction to
84:14 - zero and this is going to override any
84:17 - kind of jump basically what we want to
84:19 - force is that the player has to jump in
84:22 - the opposite direction from the wall for
84:24 - a very short amount of time for example
84:27 - what we could be doing is set self.
84:30 - direction dox is going to be one if self
84:34 - dot on surface is left and if that is
84:38 - not the case else this should
84:41 - be-1 now the jump should already work a
84:43 - little bit better but not by very
84:47 - much so let me try and well minor
84:51 - improvements
84:53 - as long as the player keeps on holding
84:55 - down left inside of the input so this
85:00 - line then the player is going to get
85:02 - immediately back to the wall regardless
85:05 - of what this line is doing we basically
85:08 - have to block the input for a bit and
85:10 - for that we will need a timer and that
85:13 - timer we actually already have if I open
85:16 - the timer. pi file in the project folder
85:20 - you can see we have something like this
85:23 - and this is a very basic custom timer I
85:26 - am explaining this thing in a lot of
85:27 - detail in another tutorials so check
85:29 - this one out for more
85:31 - information but quickly how it works we
85:33 - are creating a timer class and for this
85:35 - timer class we can customize a duration
85:38 - a function and if the timer repeats and
85:41 - then when we are creating an instance we
85:43 - are setting a couple of attributes for
85:45 - duration the function start time is
85:48 - going to be zero and then we are
85:49 - checking if the time is active and if it
85:52 - repeats repats nothing complicated once
85:55 - the timer activates we are setting
85:57 - active to true and the start time to get
86:01 - ticks get ticks gives you a time since
86:03 - our game has started in
86:06 - milliseconds that way we always know
86:08 - exactly when this timer has started and
86:11 - then inside of the update method we are
86:14 - using get ticks again except now we are
86:17 - checking this constantly this update
86:19 - method will run continuously ultimately
86:22 - the way this timer is going to work is
86:24 - imagine we have a game running for some
86:26 - amount of time and we are starting the
86:28 - timer at some arbitrary Point let's say
86:31 - here this point we are only checking
86:34 - once whenever we are activating the
86:37 - timer but after that we are running this
86:41 - update method continuously meaning we
86:44 - are checking the time right after and a
86:46 - little bit later a little bit later a
86:47 - little bit later again and so on and
86:50 - every time we are getting the current
86:53 - time again since the start of the game
86:56 - and the further we go the greater the
86:58 - distance from the original point will be
87:01 - and at some point we are getting to this
87:04 - line where the current time minus the
87:07 - star time is greater than the
87:09 - duration let's say the duration point
87:12 - would be this line and if that is the
87:14 - case we know that a certain amount of
87:16 - time has passed whatever we specified in
87:19 - the beginning and if that is the case we
87:22 - can run the function we have specified
87:25 - and on top of that we are also going to
87:27 - deactivate the timer and this one sets
87:30 - active to fults and the start time back
87:32 - to zero if repeat is enabled that we are
87:36 - doing inside of the method then we are
87:39 - starting the timer from scratch and with
87:42 - that we have a timer that can call a
87:43 - function although it doesn't have to and
87:46 - it can repeat itself this class is
87:48 - incredibly useful and I'm using it for
87:50 - my purposes all the time
87:53 - so how do you actually use it inside of
87:56 - the player first of all we have to
87:58 - import it
87:59 - from timer import
88:03 - timer after that inside of the NIT
88:05 - method I want to get rid of the display
88:08 - surface that was there just for testing
88:10 - purposes and instead I want to have a
88:12 - timer section in there I'm going to
88:15 - create an attribute called self. timer
88:17 - which will be a
88:19 - dictionary inside of this dictionary the
88:21 - key value pair are going to be the name
88:23 - of the timer and then the timer itself
88:27 - along with the arguments now for these
88:29 - timers you could specify a couple of
88:32 - arguments if you open the timer class
88:35 - you will always need a duration and this
88:37 - we are going to give it you could also
88:39 - give it a function or repeat but I don't
88:42 - care about either of those all I want is
88:44 - to have some amount of time let's say
88:46 - 200 and the name should be let's call it
88:49 - wall jump however we do have to be
88:53 - careful now because this timer by
88:55 - default is not going to work because
88:57 - it's only going to work if we are
88:59 - calling the update
89:00 - method for that the way I approach it
89:04 - and let me minimize all of the code
89:06 - because I want to create another method
89:09 - that I will call update
89:12 - timers no need for custom parameters all
89:15 - we are going to do in there is for timer
89:19 - in.
89:20 - timers and we only care about the values
89:24 - inside of it I.E the timers let me open
89:26 - it actually oh and this should be self.
89:30 - timers we want to look at all of the
89:32 - values or the timer instances inside of
89:34 - this dictionary which we are getting via
89:37 - values inside of the for Loop all we're
89:40 - going to do is call timer. update and
89:44 - that's it if we call this method let's
89:47 - do it before the input self. update
89:51 - timers
89:53 - then we have a working timer and we
89:55 - could add more timers to it they would
89:57 - all work automatically that's going to
89:59 - happen quite soon actually but anyway
90:01 - for now we have to figure out when to
90:04 - activate the wall jump
90:06 - timer although let's first test it let's
90:09 - say inside of the input when I press
90:12 - jump I want to activate the timer this I
90:14 - do with self. timers and then wall jump
90:20 - and we want to activate this
90:23 - timer activate by the way is just a
90:26 - method of the class and that we can then
90:29 - check inside of the update method I
90:31 - simply want to
90:33 - print if this timer is active or not if
90:37 - I now run main. Pi you can see by
90:39 - default this one is false but if I press
90:41 - space we get true for a very short
90:44 - amount of time I think I set this timer
90:46 - to 200 milliseconds so for 1/5 of a
90:50 - second this timer would be
90:52 - active if I increase this number to
90:54 - let's say
90:56 - 2,000 run all of this again press space
90:59 - we should have true for 2 seconds and we
91:01 - do that looks good cool so we know this
91:05 - timer is
91:06 - working which means we have to figure
91:09 - out how to use it and in my
91:12 - case if the player is moving and this if
91:17 - statement is true I.E we are trying to
91:19 - jump away from a wall then I want to
91:22 - activate the wall jump timer we can do
91:25 - that all the way at the top of
91:28 - it that way we have the timer active and
91:31 - that we can then use inside of the input
91:33 - to block these two inputs all we have to
91:37 - do is another if statement if not self.
91:42 - timers we want to look at the wall
91:45 - jump timer and we want to check if this
91:48 - one is active or more specifically if
91:51 - this timer is not active only then do we
91:53 - allow all of this which we can do quite
91:56 - easily I want to do all of
91:59 - that jump should be outside of this if
92:01 - statement that we are still going to
92:03 - need but now if I run main. pi and let
92:08 - try to get a wall jump this feels much
92:11 - better although the timer now is way too
92:14 - long so even if I don't press anything
92:16 - the player keeps on moving to the right
92:19 - let's try the other side and this is
92:22 - also working the last thing we have to
92:24 - do is set this timer to a more
92:26 - reasonable time let's say
92:30 - 250 and then we can try it
92:34 - again and possibly a bit more
92:39 - actually but this is something you can
92:41 - play around with let's try
92:46 - 400
92:48 - and yeah but feels about
92:50 - right and just a quick recap all that we
92:53 - are doing is once the player is on a
92:56 - wall and we are trying to jump then we
92:59 - are activating the wall jump timer and
93:02 - as long as this timer is active we do
93:04 - not allow any kind of left or right
93:07 - input that is important because a bit
93:10 - further down when we are running the
93:12 - original if statement we are trying to
93:15 - make it so that the player goes in the
93:16 - opposite direction of the wall for a
93:18 - short amount of time that way we always
93:20 - move away from the wall and that's
93:23 - basically it the timer class makes this
93:25 - kind of problem really easy to solve but
93:28 - anyway I want to work on one more thing
93:31 - if we run main. pi and if I jump right
93:35 - next to wall then we are jumping away
93:37 - from it immediately and that is kind of
93:40 - weird so I want to use a timer a second
93:44 - time and what I want to do is that once
93:47 - the player is jumping we only want to
93:50 - allow a wall jump after after a short
93:52 - amount of
93:53 - time let's say after 250
93:56 - milliseconds that part is going to be
93:59 - your second exercise for this part I
94:02 - want you to create some kind of logic to
94:04 - only allow a wall jump after 250
94:07 - milliseconds of jumping for that you
94:09 - should be using another timer pause the
94:11 - video now and see if you can figure this
94:13 - one
94:17 - out to get started we first of all have
94:20 - to create a second timer and that I want
94:23 - to do inside of self. timers let's call
94:25 - this one wall slide I guess wall slide
94:30 - block is a decent name this is going to
94:32 - be another
94:34 - timer with the duration for this one 250
94:39 - milliseconds and this timer is going to
94:42 - automatically work because we have our
94:44 - handy update timers function or well
94:47 - method now we have to figure out when to
94:50 - activate the timer and and we know when
94:52 - the player starts to jump either inside
94:55 - of this if self. jump or inside of the
94:58 - input I want to work inside of the move
95:01 - method we know that the player does the
95:03 - original jump inside of this line so in
95:06 - there we also want to activate the timer
95:10 - for that I can actually duplicate this
95:12 - line the only thing I have to change is
95:15 - wall slide block I believe they called
95:17 - it yep with that we should have a time
95:20 - at at start once the player jumps and
95:23 - let's see if this one is working I want
95:25 - to print the wall slide block and check
95:28 - if this one is active if I now run main
95:31 - Pi by default it's false if I jump we
95:33 - have true for a very short amount of
95:35 - time that looks about right which means
95:39 - we now have to use it and that's going
95:40 - to happen inside of the L if statement
95:43 - because in there we are getting the wall
95:44 - jump I want to check if the player is
95:47 - currently touching a wall and I want
95:51 - want to check if this timer is not
95:52 - active so not and then copy the timer
95:57 - itself and DOT active and now if we are
96:01 - trying all of
96:03 - this we get
96:06 - something not
96:08 - ideal the reason for that is at the
96:10 - moment we are blocking the wall jump but
96:15 - we are not blocking the wall slide to
96:18 - fix that we have to use the timer again
96:20 - I can actually just copy
96:22 - it we want to do this as
96:25 - well so just a recap the player should
96:28 - slide from wall if the player's in the
96:30 - air has contact with the wall and has
96:33 - been in the air for some amount of time
96:36 - let's try all of this now and I can
96:38 - still jump and now if I jump right next
96:41 - to a ledge this is working just fine
96:44 - let's see if I can still wall jump and
96:46 - yep I can so with that we have a very
96:49 - nice jumping mechanic or generally a
96:52 - platformer this feels pretty good at
96:54 - this point we have covered all of the
96:56 - basics of the platformer so we can start
96:58 - with some more advanced topics the first
97:01 - one is going to be moving platforms
97:03 - which is going to make the game feel
97:05 - significantly more interactive to make
97:07 - those work we have to update the player
97:09 - just a bit but it's not going to be too
97:12 - difficult first of all though we have to
97:14 - create moving platforms for that we will
97:17 - have to look at til here we are in til
97:20 - and so far we only worked inside of the
97:22 - terrain layer and the objects layer but
97:25 - now we want to add one more layer we
97:27 - want to work with the moving objects if
97:30 - I make this one visible we can see a few
97:33 - more things most of the stuff you can
97:35 - ignore what I want to work with are
97:37 - these two rectangles if you look on the
97:40 - left side there we have a couple of
97:44 - parameters most importantly at the top
97:47 - we have a name helicopter later on
97:49 - that's going to be important for the
97:50 - graphic but for now just don't worry
97:53 - about it what is more important at the
97:55 - bottom we can see a couple of attributes
97:59 - and the one we care about most for now
98:01 - is the speed that's going to be well the
98:03 - speed of the platform and the way this
98:05 - system is going to work and let me zoom
98:07 - in just a bit more we are going to pick
98:11 - the top middle point of this rectangle
98:14 - and then spawn a platform around
98:18 - it this platform is then going to move
98:21 - down in a straight line until it reaches
98:24 - the bottom Point once it does that it
98:27 - starts moving back up again until it
98:29 - reaches the origin point and this keeps
98:31 - on going so we have a platform that
98:33 - moves up and down the horizontal
98:36 - platform so this one is going to work in
98:39 - basically the same way except it moves
98:41 - left and right later on we are also
98:44 - going to get other kinds of platform for
98:46 - example those are going to be a saw it's
98:48 - not really a platform more of a trap and
98:51 - and then we have a spike this thing is
98:53 - going to create a spike that rotates
98:56 - around this point but those are not
98:58 - important for now I only really want to
99:01 - work with those two objects for that
99:04 - let's work inside of level. Pi more
99:08 - specifically I want to work inside of
99:10 - setup later on the setup method is going
99:13 - to become quite Mighty so I want to
99:15 - start adding comments right away I
99:18 - suppose the first part that we already
99:19 - created is the tile
99:21 - and then we have the objects after that
99:26 - I want to have let's call it moving
99:30 - objects all of those I get via 4 obj in
99:34 - TMX map doget layer by name and the
99:37 - layer name is going to be
99:40 - moving objects in case you're wondering
99:43 - where I'm getting those names from if
99:45 - you look at til you can see we have
99:47 - moving objects that's what I'm importing
99:50 - and and there we get a couple of objects
99:53 - so let me print obj and run the code and
99:57 - we don't care about the game but what we
100:00 - do get is a whole bunch of objects the
100:03 - ones that we care about are helicopter
100:05 - so the last two those we can isolate
100:09 - quite easily with an if statement so if
100:11 - objname is equal to
100:15 - helicopter if that is the case we can
100:19 - for example print obj do width obj do
100:23 - height obj dox and obj doy let's try
100:29 - that and we are getting a whole bunch of
100:32 - points that looks pretty good that
100:35 - information is already useful because at
100:37 - the moment we are trying to figure out
100:39 - if the platform is moving left or right
100:41 - or up or down and the easiest way to
100:44 - figure that one out is if the rectangle
100:46 - that we created in tiled is wider than
100:48 - it is tall so basically if obj do width
100:53 - is greater than obj do height if that is
100:57 - the case we want to have horizontal
101:00 - movement if that is the case let's say I
101:02 - want to create a local variable called
101:05 - move Direction and this one would be X
101:09 - on top of that we also have to create a
101:12 - start position and an end position both
101:16 - of those are going to be two builds with
101:18 - X and Y and now we have to figure out if
101:23 - this is the rectangle we have created
101:27 - entitled we currently want to get this
101:30 - point that would be the start point and
101:32 - then the end point would be this bit
101:36 - also I should mention obj dox so the
101:39 - information we already have is this top
101:41 - left point we always specify the top
101:44 - left for any
101:45 - object which means to get the X part of
101:50 - this point we simply need obj
101:54 - dox and for the Y point we need obj doy
101:58 - and then plus half the height of this
102:00 - rectangle so obj dot height / by two and
102:05 - that's it now we get the point next up
102:08 - we need the end position once again I
102:11 - want to have X and Y and this time I
102:14 - want to have obj dox plus obj do wi so
102:20 - basically we're taking the origin point
102:22 - and going all the way to the right
102:26 - side and obj doy for the endpoint is
102:29 - going to be the same y that we have
102:32 - specified already so that part's easy
102:34 - after we have that I want to cover the
102:36 - El statement and that one would be the
102:39 - vertical movement for most of that I can
102:43 - simply duplicate the lines I already
102:45 - created because we don't have to change
102:48 - that much most importantly move there is
102:51 - going to be y we now want to move up and
102:53 - down start position for this one and
102:57 - remember we are now working with a
102:59 - rectangle that is quite tall but not
103:02 - very wide and we want to get this point
103:04 - for the start and this point for the end
103:08 - we pretty much do the opposite compared
103:10 - to what we have done for the horizontal
103:12 - Movement we want to get obj dox and
103:16 - remember this is the left side of the
103:18 - rectangle and we want to add OB J
103:22 - do Wii and divide it by two obj doy for
103:27 - the Y part can just be obj
103:30 - doy and then for the end position we
103:33 - want to get the same point for X this
103:36 - one does not change however for obj doy
103:40 - we want to add the entirety of the
103:42 - height and that is pretty much it with
103:45 - that we're getting a direction and a
103:47 - start position along with an end
103:49 - position there's one more property that
103:52 - we do need and that is the speed and
103:55 - this one is the same for vertical or
103:58 - horizontal so we can keep it outside of
103:59 - this if statement now to get the speed
104:03 - we have to look at tiled and then look
104:05 - at the custom properties so on the left
104:07 - we have the speed to get that inside of
104:11 - the code we need the object and this
104:13 - object has a properties attribute which
104:17 - is just going to be a
104:19 - dictionary as matter fact let me print
104:21 - what we get so print this speed and we
104:24 - don't have to print the other two things
104:25 - anymore if I now run main. Pi we are
104:29 - getting all of the attributes most of
104:31 - which we don't care about but speed is
104:33 - in there as well this is what we
104:35 - actually want to work with since we now
104:37 - have a dictionary we can get the key
104:39 - quite easily we want to get the speed of
104:41 - all of this so now if I run main. Pi
104:44 - we're getting 160 that looks really good
104:47 - with all of that we have the basic
104:50 - attributes we just have to put it inside
104:52 - of a class so we can display it that's
104:55 - going to happen inside of Sprites
104:57 - dopy in there I want to create a new
105:00 - class and I call this one a moving
105:03 - Sprite what is really important is that
105:06 - this is going to inherit from the Sprite
105:08 - we just created this Sprite up here that
105:11 - way we don't have to recreate the image
105:13 - and a rectangle anymore it's going to
105:16 - save us a bit of work and over the
105:18 - course of this tutorial I am going to
105:20 - use quite a bit of inheritance just be
105:22 - ready for that but for now it's not
105:25 - going to be too difficult I think so we
105:27 - want to initiate this class we will need
105:29 - quite a bit of information most
105:31 - importantly as always we will need self
105:34 - on top of that we will need the groups
105:37 - this one is part of then we need a start
105:41 - position an
105:42 - end position we want to have the move
105:46 - Direction and finally our speed after
105:49 - that we have have to call the super
105:51 - Dunder inage method to initialize the
105:54 - parent class and really important now we
105:58 - are initializing this parent class which
106:01 - means this init method wants to have
106:04 - these parameters let me copy them
106:07 - actually first of all the position that
106:10 - can simply be the start
106:13 - position and then let's ignore surface
106:16 - for now that's going to get a bit more
106:18 - complicated instead with we are going to
106:21 - work on the groups and that part is
106:22 - really easy because we already have the
106:24 - groups we are simply passing them
106:25 - through via the parameters so we have to
106:29 - figure out a surface and if you look at
106:32 - the original I have created a surface
106:35 - parameter but I am not using it at all
106:37 - for this entire class instead for the
106:40 - image I am simply creating a new Surface
106:42 - from scratch as a consequence whatever
106:46 - we are specifying for this moving Sprite
106:48 - as a surface will be ignored and over
106:50 - written with a surface that is the tile
106:52 - size in width and height to get around
106:56 - that I want to cut out all of this bit
106:59 - and assign it as the default value for
107:02 - the parameter and then for the groups we
107:04 - have a default value of
107:07 - none once we have that I can assign this
107:10 - image a surface and with that the
107:13 - surface parameter will not be ignored
107:15 - anymore which means inside of the moving
107:18 - Sprite before we are calling super where
107:20 - in knit we can create a surface with a
107:23 - custom size let's say pame do surface
107:27 - and I want this thing to be let's say
107:30 - 200 pixels wide and 50 pixels
107:33 - tall later on once we have proper
107:35 - Graphics we are simply going to use
107:37 - those but for now since we don't have
107:38 - that we have to work a bit more
107:40 - creatively here but I hope the logic
107:43 - makes sense the only real difference now
107:46 - is that we are creating a py game
107:48 - surface as the default value for the
107:50 - surface surface parameter inside of the
107:51 - class and this gets assigned to the
107:53 - image and just to make sure I didn't
107:55 - make a mistake let me run m. pi and no
107:58 - error so this is still working just fine
108:01 - however now inside of level. Pi we can
108:04 - create the moving Sprite although for
108:06 - that first of all we will need to import
108:08 - it so import moving Sprite after the
108:12 - Sprite now I can create a moving Sprite
108:16 - and for that to work we will need a
108:18 - whole bunch of arguments all of those
108:22 - let me paste them in and go through them
108:24 - one by one first of all the groups and
108:27 - to keep it simple I will start with all
108:29 - Sprites then we have the start position
108:32 - this one we already defined here and
108:33 - here the end position we also have we
108:36 - have to move Direction and we have to
108:38 - speed so basically we have everything we
108:41 - need just to get started let's run M pi
108:45 - and we can see we have two platform
108:48 - looking things we count do anything with
108:50 - them but at the very least they are
108:52 - there also while we are here I want to
108:55 - close the timer because we don't need
108:57 - that part anymore instead I have to work
108:59 - a bit more inside of the moving Sprite
109:02 - and there is already one problem that
109:04 - you might have spotted the positioning
109:07 - of the moving Sprites is a bit off
109:09 - imagine we are currently working with a
109:12 - vertical rectangle this is what we
109:14 - imported from tiled and at the moment we
109:18 - are setting the start position as the
109:20 - top left of the
109:22 - rectangle because of that the rectangle
109:25 - is going to have a start position that
109:26 - looks something like this which really
109:29 - is going to be weird instead I want this
109:33 - point to be right in the center of the
109:36 - platform or to be a bit more specific I
109:39 - want to move the center of the platform
109:41 - to that point that makes more sense that
109:43 - part is quite simple all we have to do
109:45 - is update the rectangle so self. rect do
109:49 - Center is going to be the start position
109:53 - if I now go to main. P we get a slightly
109:56 - different position but this one is a bit
109:58 - more accurate cool that's a good start
110:01 - and also a very easy thing to fix on top
110:04 - of that we have to capture this speed
110:06 - and the end position as an attribute
110:09 - also the start position so self. start
110:11 - position is start position then self.
110:14 - end position is end position and finally
110:18 - self. speed is going to be the speed
110:22 - also and this I want to store under a
110:24 - separate command I want to have the
110:26 - movement and I guess the speed should be
110:27 - in there as well besides the speed I
110:30 - want to have self.
110:34 - Direction which is going to be a
110:37 - vector with one and zero I.E we are
110:40 - moving to the right but it should only
110:42 - be if the move direction is going to be
110:46 - X if that is not the case so we're
110:48 - moving up and down then and the
110:50 - direction should be Vector with Zer and
110:52 - one so we are moving down by default
110:55 - also while we are here I want to store
110:58 - the move Direction as a separate
110:59 - attribute so move de is moved
111:03 - deer after we have that we can create an
111:06 - update method with self and Delta time
111:10 - since we now are updating the position
111:14 - we also have to update the old rectangle
111:16 - so old rect is going to be self. re.
111:19 - copy
111:20 - this we didn't need to do in the
111:22 - original Sprite because this one isn't
111:24 - moving the old Rec can simply stay in
111:26 - the same position the entire time and
111:29 - next up all we really have to do is
111:31 - self. rec. toop left plus equal self.
111:35 - direction multiplied with self dop speed
111:38 - multiplied with Delta time and now if I
111:42 - run m. Pi we get moving platforms we
111:45 - still cannot interact with them and they
111:47 - keep on moving in the same direction
111:49 - forever so so that's not ideal but at
111:51 - the very least we get something to make
111:54 - sure that we are constraining them I
111:57 - want to add another method and this one
111:59 - is going to be called check border don't
112:03 - forget to call it and now we can create
112:05 - the check order method in the most basic
112:09 - sense all that we are really going to do
112:11 - is first of all I want to check the move
112:13 - direction if let's say we are moving on
112:17 - we moving left and right if if that is
112:20 - the case I want to check if self. r.
112:24 - write is greater or equal to self. end
112:28 - position and the X part so index zero on
112:33 - top of that I want to check if self.
112:35 - direction dox is equal to
112:38 - 1 if that is the case we are too far to
112:41 - the right and we are moving right then I
112:44 - want to set self.
112:46 - direction to -1 and this should be self
112:49 - self. Direction
112:51 - dox on top of that self. rec. right
112:55 - should be self. end position and
113:00 - zero it's honestly quite a simple logic
113:03 - imagine we have our platform and the
113:06 - platform is currently moving to the
113:08 - right and on top of that our end
113:11 - position is some kind of border that we
113:13 - have just crossed to check that we first
113:16 - of all check this first bit where we are
113:20 - checking the right side of our platform
113:22 - against the X part of the end position
113:25 - and if this part is greater we know we
113:28 - have exceeded this point on top of that
113:30 - we also want to know if the platform is
113:33 - moving to the right that way we are sure
113:36 - that we have crossed this border and we
113:38 - are going in this
113:40 - direction if both these conditions are
113:42 - true then we want to move in the other
113:44 - direction and then also set the right
113:46 - side of the platform to the border so we
113:49 - get something something like this with
113:51 - that I can run main. pi and now this
113:54 - lower platform should eventually bounce
113:56 - back and it does that looks really good
113:59 - although it only works once basically we
114:03 - have to add a few more options here that
114:06 - part is going to be your exercise I want
114:08 - you guys to make the moving platforms
114:09 - bounce pause the video now and see if
114:12 - you can figure it
114:17 - out first of all I want to finish up the
114:20 - left side of the rectangle for that we
114:22 - can actually copy most of the if logic I
114:26 - want to check if self. re. left is
114:31 - smaller or equal than end position zero
114:35 - this shouldn't be end position this
114:37 - should be the start
114:39 - position on top of that we want to check
114:41 - if the direction dox is -1 if that is
114:46 - the case Direction not X should be one
114:49 - and ourself. rec. left should be start
114:54 - POS zero and that should cover the
114:58 - entire left and right movement so we're
115:01 - bouncing there once and we should also
115:03 - bounce there then next up we can work on
115:07 - the other direction so else and now I
115:13 - want to check the up and down part let
115:17 - me actually duplicate all of this stuff
115:20 - because I want to check if self. re.
115:23 - bottom is greater than end position. one
115:27 - and self. Direction doy is going to be
115:29 - one so we are moving down if that is the
115:32 - case self. Direction doy should be
115:34 - negative -1 and self. re. bottom should
115:37 - be n+
115:39 - one after that for the up movement self.
115:43 - re. top if it is smaller
115:46 - than start position one 1 and we are
115:51 - currently moving
115:53 - up so self. direction. Y is -1 if that
115:57 - is the case we want to move down and
116:00 - self. re. toop should be start position
116:03 - one let's try this
116:06 - one
116:08 - and we are going up again and also down
116:11 - again cool so that one is working just
116:14 - fine however I just realized I made a
116:17 - mistake and that is when we are starting
116:21 - to create the
116:23 - rectangle we are setting the center of
116:26 - the rectangle to the start
116:29 - position so if this is the path we are
116:32 - following at the moment before we are
116:35 - moving our platform is roughly
116:38 - here however then when we are doing
116:42 - these parts let's say we have a top
116:45 - Collision then we are checking if the
116:48 - top of the the platform is exceeding
116:51 - this Top Line and if that is the case we
116:54 - are moving down again as a consequence
116:56 - the highest point after the start is
116:59 - that the platform can only really go up
117:01 - to
117:02 - here and that would look a little bit
117:05 - inconsistent and well would make the
117:07 - game feel a bit less good to get around
117:10 - that I want to add one more if statement
117:12 - so if we want to check the move
117:15 - Direction and if move direction is let's
117:19 - say
117:21 - x then we want to send self. rect do mid
117:25 - left to the start position if that is
117:27 - not the case so else then I want to set
117:31 - the self. rec mid top to the start
117:35 - position and then we should have a bit
117:37 - more
117:38 - consistency and now these two platforms
117:42 - should feel a bit
117:43 - better and yeah I hope you get the
117:46 - problem this is a fairly easy thing to
117:48 - fix
117:50 - next up we can actually make these
117:52 - platforms interact with the player
117:54 - because at the moment they're only
117:55 - visible but not collidable to fix that
117:58 - we can place them into self. Collision
118:03 - Sprites let's see what happens in the
118:05 - game and the game doesn't crash that's a
118:07 - good sign and I can also jump on them we
118:09 - still have
118:10 - collisions however you can see the
118:13 - downward movement is a bit choppy not
118:15 - terrible but this doesn't feel amazing
118:18 - also I cannot jump on top of these
118:20 - platforms and if I go on the horizontal
118:23 - platform you can see another problem if
118:25 - I don't move well I don't move so we
118:29 - have to add a bit more logic to all of
118:33 - this oh also sometimes I can jump it's
118:36 - just very
118:38 - inconsistent but nothing that is
118:39 - insurmountable for all of that we want
118:41 - to work inside of the player most
118:44 - importantly we first of all have to know
118:47 - if there is a moving platform or not so
118:49 - under collisions in player. init I want
118:52 - to create self do let's just call it
118:54 - plat form by default this one is
118:58 - none however then inside of check
119:02 - contact we want to check if the player
119:04 - is standing on a moving platform in this
119:07 - we want to check on every single frame
119:10 - so by default I always when we start
119:12 - want to set self. platform to none and
119:15 - after that I am checking again if we are
119:17 - on a platform and that I'm checking with
119:20 - a for Loop for sprite in self. Collision
119:25 - Sprites however I don't want to have all
119:28 - of the Collision Sprites I just want to
119:30 - have the ones that are a moving Sprite
119:33 - meaning we have to isolate this Sprite
119:36 - somehow and we could do it in a couple
119:38 - of ways for example we could check for
119:40 - specific attribute like speed for
119:42 - example wouldn't exist inside of a
119:44 - normal Sprite however I do want to be a
119:47 - bit more explicit
119:49 - so I'm going to give this another
119:51 - attribute self. moving which I am going
119:54 - to set to
119:55 - true and now I can use list
119:58 - comprehension where I will create a
120:02 - Sprite for sprite in self. Collision
120:06 - Sprites and important you now have to
120:08 - add Sprites as well that way you're
120:11 - getting a list of all of the Sprites and
120:13 - then you can use them inside of the list
120:15 - comprehension and really important for
120:17 - this one is you want to this only if
120:21 - this Sprite has an attribute which you
120:22 - can check with has utter we want to
120:26 - check the Sprite and then moving with
120:29 - that we are only getting the moving
120:31 - platforms and on there we can check if
120:35 - Sprite do rect do Collide rect and we
120:40 - want to check against the floor
120:42 - rectangle that we already have if that
120:45 - is the case we know that the player is
120:46 - standing on a platform and and if that
120:49 - is the case I want to set s the platform
120:52 - to this Sprite that way the player will
120:54 - know what we are standing on that is
120:57 - information that we can use very well
120:59 - under the move method or well you could
121:02 - place it wherever you want but I think
121:03 - it makes the most sense there I want to
121:06 - add another method called platform move
121:10 - for this one we will need self and Delta
121:12 - time as well and basically all that we
121:15 - are going to do is first of all we will
121:17 - check if there is is a platform I.E if
121:21 - the player is standing on a platform and
121:23 - if that is the case we're going to get
121:25 - self. rec. toop left and we are going to
121:29 - add self. platform. Direction multiplied
121:34 - with self. platform dosp speed
121:37 - multiplied with Delta time basically if
121:40 - the player is standing on a platform we
121:43 - are going to move the player in the
121:45 - direction of the platform by the speed
121:46 - of the platform at our current framework
121:49 - r that way our player is going to move
121:51 - along with the platform after that we
121:54 - have to make sure that we are calling
121:56 - that so after move self. platform move
122:00 - and don't forget Delta time if I now run
122:03 - main.py and I hope I can get on one of
122:05 - these
122:06 - platforms this looks much better now the
122:10 - player is not choppy
122:12 - anymore although I cannot jump on this
122:16 - platform at all
122:19 - but I can do it if we're going left and
122:21 - right so we are nearly done this is
122:24 - already a major Improvement the last
122:27 - really major thing that we have to work
122:28 - on is that if the platform is going up
122:30 - and down we cannot jump and that is
122:34 - because inside of the move method we are
122:39 - kind of overwriting the direction so for
122:41 - example once the player tries to jump so
122:43 - we are updating the direction then the
122:45 - player might Collide immediately once
122:47 - again with a platform and and then we
122:49 - are canceling out the jump a really easy
122:52 - way to get around that is to get self.
122:55 - Rec do bottom and move the player up by
122:59 - one pixel so minus equal 1 and then this
123:02 - should be working and now for testing
123:05 - purposes I realized that getting on the
123:07 - platform inside of main.py is kind of
123:10 - difficult if you have the same issue
123:13 - simply open tiled and then move these
123:16 - things around just a little bit
123:19 - something like this go back to the code
123:21 - and run this again and now this is
123:23 - getting much easier and I can jump while
123:26 - the platform is going up and down that
123:29 - feels much better and the same thing is
123:32 - also going to work for the other
123:34 - platform so cool this is working pretty
123:38 - well very good we are nearly done with
123:41 - the basics of the platformer there are
123:44 - just three more things that I would like
123:46 - to add number one I want to have semi
123:49 - collidable platforms which are going to
123:51 - make the game feel much more interactive
123:53 - and all that really means is that the
123:55 - player can jump through some platforms
123:57 - While others are completely solid number
124:00 - two I want to add a hitbox so that we
124:02 - have a separation between how the player
124:04 - looks and what the player can collide
124:06 - with especially for the sord of the
124:08 - player this is going to make the game
124:09 - feel much better also for this stage we
124:12 - are going to add a basic player graphic
124:14 - but that's not really necessary it's
124:16 - just better to show what's going on fin
124:18 - finally we're going to add a camera that
124:20 - way you can actually explore the level
124:23 - on top of that there's one minor bug
124:25 - that I really want to work on and let's
124:27 - start with that right
124:28 - away here we are back in main.py and if
124:31 - I run the game we have the same thing
124:34 - that we have already seen a couple of
124:35 - times and all of this works reasonably
124:38 - well however if I jump against the up
124:41 - and down moving platform and it goes
124:44 - down then we get some weird
124:46 - behavior and this only happens if the
124:48 - platform is moving down so what happens
124:51 - here and that's the bug I want to
124:53 - fix basically the way you want to think
124:56 - about it is that if we have a platform
125:00 - that's moving down and then we have a
125:03 - player moving up I.E jumping and we have
125:07 - a collision between the two if that is
125:09 - the case the player should be moving
125:11 - down and move down at an increasing
125:13 - speed because of gravity however that
125:16 - doesn't happen because as soon as the
125:18 - player moves moves down just a bit the
125:21 - platform is also going to move down and
125:23 - as a consequence the player is going to
125:25 - move down just a bit but the platform
125:28 - will move down even more the result of
125:30 - all of that is going to be another
125:32 - collision at the top the end result is
125:35 - that the player is going to be stuck at
125:36 - the bottom of this
125:38 - platform that we can fix quite easily
125:41 - all of that happens inside of the player
125:43 - as a matter of fact we have already done
125:46 - something similar if we look inside of
125:48 - the move move method they on the
125:51 - platform once it's moving up we're
125:54 - giving the player a very small offset
125:56 - once he starts to jump that way we are
125:59 - making sure that the player is not glued
126:00 - to this platform and something similar
126:03 - we are going to do inside of the
126:05 - collisions basically when we have a top
126:09 - Collision then we want to check if has
126:13 - attribute if this bride is
126:17 - moving I.E with these two conditions we
126:20 - know that we have a top collision and
126:22 - the platform we are colliding with is
126:24 - moving then we want to give the player a
126:26 - bit of an offset self. wed. toop and now
126:32 - you have to add a small amount I think I
126:35 - went with six in the final project let's
126:37 - see how that looks so if I now Run the
126:39 - game and the platform goes down you can
126:42 - see we are always
126:45 - getting a bit of a gap between a
126:48 - platform from and the
126:50 - player now if you look closely this is
126:53 - kind of noticeable but in the actual
126:56 - game this will be much less noticeable
126:58 - and the player won't pay attention to it
127:00 - anyway you could add more code to make
127:03 - this effect more convincing for example
127:05 - you could add a timer to disable this
127:07 - kind of collision or you could work with
127:08 - the speed of the moving platform there
127:10 - are lots of things that you could be
127:12 - doing
127:13 - here but I want to keep it simple so I
127:16 - think this approach Works reasonably
127:17 - well all right cool that covers the bu
127:21 - with that we can work on semic
127:23 - collidable platforms that part is going
127:26 - to be your exercise and let me explain
127:28 - what I want to do inside of level. Pi we
127:31 - have a setup method and in there we are
127:35 - creating the helicopter platform all of
127:37 - that we have done in the last part these
127:40 - platforms should be semic collidable
127:43 - meaning that the player should only have
127:44 - a collision at the bottom there's no
127:46 - Collision on the left right or top
127:48 - between the player and the platform
127:50 - figuring that kind of thing out will
127:52 - require you to understand basically
127:54 - everything we have done so far but let
127:57 - me do a summary the exercise is going to
127:59 - be that I want you guys to make the
128:01 - moving platforms semic collidable I.E
128:04 - they should only be a collision at the
128:05 - bottom of the player also once the
128:08 - player presses down this Collision
128:10 - should be disabled for a short amount of
128:12 - time to work out all of this there are a
128:15 - couple of tips number one you should
128:18 - sted Platforms in another Sprite group I
128:20 - have called this one something like
128:22 - semic collidable Sprites the name here
128:23 - doesn't really matter just skip in mind
128:26 - that organizing all of these Sprites in
128:28 - a separate Sprite group is probably a
128:30 - good
128:31 - idea number two you can reuse quite a
128:35 - bit of the Collision logic that we have
128:36 - already covered in the player you will
128:38 - only need a small part of it finally you
128:42 - will also have to update other parts of
128:44 - the player class for example the floor
128:46 - contact and the move player methods are
128:48 - quite important and would need to change
128:51 - hi there I forgot something that is
128:53 - relevant to this exercise after adding
128:55 - the semic Collision platforms you will
128:57 - get some Collision flaws that will
128:59 - probably be confusing you fix those by
129:02 - wrapping the old W into an INF function
129:04 - and that's basically all you have to do
129:06 - I would recommend to do that right away
129:08 - and then go on with the rest of the
129:10 - exercise try to work this one out on
129:12 - your own and create semic collidable
129:14 - platforms should take you a
129:17 - bit
129:21 - all right let's get started inside of
129:24 - the level we already have two groups and
129:28 - I want to create a third one self dot
129:31 - semic
129:34 - cision underscore Sprites this will be
129:38 - just another Sprite group so pame dos
129:41 - sprite. Group after we have that when we
129:45 - are creating the helicopter platforms we
129:47 - do not want want to place them into the
129:49 - Collision Sprites we want to put them
129:51 - into the semi Collision
129:54 - Sprites simply with this setup the
129:56 - player doesn't have access to these
129:58 - Sprites anymore meaning if I run main Pi
130:01 - we can still see them but there's no
130:02 - Collision because they're not in the
130:04 - Collision Sprites anymore to fix that
130:07 - part when we are creating the player
130:09 - that happens here we have to add these
130:12 - platforms or rather this group as
130:15 - another argument so semic Collision
130:17 - Sprites and as a reminder once again the
130:20 - player itself is not in this group just
130:23 - like with the Collision Sprites the
130:24 - player just has access to them
130:26 - fundamental difference but anyway inside
130:29 - of player. Pi we have to add another
130:32 - parameter semi
130:34 - Collision
130:36 - Sprites also we have to turn this
130:38 - argument into an attribute so self do
130:42 - semi Collision Sprites is going to be
130:44 - semic Collision Sprites perfect with
130:48 - that we have access to these Sprites
130:50 - although at the moment they don't really
130:51 - do anything to fix that we will have to
130:55 - change quite a bit inside of the player
130:58 - the most important part is that I want
130:59 - to create a semic
131:02 - cision method no need for custom
131:05 - parameters in this one and the logic is
131:08 - going to be fairly similar compared to
131:10 - what we have done inside of the
131:11 - Collision method although it's going to
131:13 - be quite a bit simpler we still want to
131:15 - look at all of the Sprites meaning for
131:17 - sprite in do semic Collision
131:20 - Sprites on top of that we also want to
131:23 - check e Collision so if sprite. re.
131:27 - Collide rect and then self. rectangle so
131:32 - far we have done the exact same thing
131:35 - however now there's only one Collision
131:37 - that we really care about and that is
131:39 - the bottom Collision which means we can
131:42 - simply copy this line and paste it in
131:45 - there after we have that we can look
131:48 - look at the move method and call it
131:51 - right after self. Collision self.
131:55 - semi
131:57 - collision and let's see what we get if I
132:00 - now run main. Pi I can jump on the
132:03 - platform and we are not falling through
132:06 - anymore although you can see we have a
132:07 - bit of a bug if I stay on this platform
132:09 - and fall down we have a massive amount
132:12 - of gravity but other than that it's
132:14 - basically working and also the other
132:17 - platform that's looking pretty
132:21 - good and yeah that feels much
132:25 - nicer righty next up then inside of this
132:31 - method even though we are standing on a
132:33 - platform we are still increasing gravity
132:36 - constantly which we don't want to do to
132:38 - fix that all we have to do is set self.
132:41 - direction.
132:43 - y20 and now let's try this again I can
132:46 - jump on the platform
132:48 - we are not falling through it and we get
132:51 - the normal falling
132:53 - behavior and let's try this one as well
132:57 - and there we have a bit of an
133:00 - issue but other than that this part
133:02 - works so at the moment we have the issue
133:05 - that if the platform is moving down like
133:07 - that the player is hopping a
133:09 - bit the reason for that is that we are
133:14 - not applying the platform move method
133:20 - simply because at the moment the player
133:22 - doesn't think there is a platform and
133:24 - this happens because of check contact in
133:28 - there we are updating the platform and
133:30 - at the moment we are only looking at
133:32 - self. Collision Sprites we are not
133:34 - looking at the semic Collision Sprites
133:37 - to make that work let me create another
133:39 - local variable we can call it
133:41 - Sprites the value for this one is going
133:44 - to be what we already have so self.
133:47 - Collision Sprites Sprites and to that I
133:50 - want to have self. semicolons Sprites
133:53 - dos Sprites and I should be explicit if
133:56 - you add dot Sprites after the group you
134:00 - essentially get a list that you can add
134:02 - together and only because of these
134:04 - Sprites can we add these two lists
134:06 - together if you simply added two groups
134:09 - you would get an error but anyway now I
134:11 - want to Loop through all of these
134:14 - Sprites and if we have a floor W
134:16 - Collision then we want to assign a new
134:19 - platform that should also reenable this
134:22 - platform move method because
134:24 - fundamentally it simply cares about
134:26 - having a platform so let's
134:29 - try and if I jump on one of those we get
134:32 - the movement back and that looks pretty
134:35 - good and if I jump on the other
134:38 - platform I have to wait for it to go
134:40 - down and we are simply falling through
134:43 - the entire
134:44 - thing and that happens consistently so
134:47 - what what's going wrong now the best way
134:49 - to diagnose that is if I minimize all of
134:53 - the methods we can look at the update
134:55 - method and then print self. on Surface
135:01 - and now let's try this again and you can
135:03 - see by default when I'm just standing on
135:06 - the terrain floor is true however if I
135:10 - jump on the moving platforms floor is
135:13 - false also if I'm on one of those I
135:15 - cannot jump because we are not on a
135:19 - floor and if I'm on the other platform
135:22 - we also get floor as faults and at some
135:24 - point I'm falling through this
135:26 - platform the reason ultimately here is
135:29 - that the game thinks when we are on a
135:32 - moving platform that we are not on the
135:34 - floor and that in turn happens because
135:37 - of check contact we are only on the
135:40 - floor if we are colliding with the floor
135:43 - wrecked or if a part below the player
135:45 - collides with this rectangle the way
135:48 - around that is that we have to create
135:49 - one more list and let's call this the
135:53 - semioli
135:55 - rects and this is going to be another
135:57 - list comprehension I want to get sprite.
136:00 - rect for sprite in self. semic Collision
136:04 - Sprites and then we want to check that
136:07 - we are on a floor if this condition is
136:10 - true but we also want to check so or if
136:14 - our
136:16 - floor rectang angle as a Collide list
136:20 - with the semic Collide rectangles and
136:24 - the return value needs to be greater or
136:26 - equal to zero also there's another
136:31 - condition because this we only want to
136:32 - do if self. Direction
136:35 - doy is greater or equal to zero remember
136:40 - we only want to have a bottom Collision
136:42 - if the player is moving up we shouldn't
136:44 - have any collision with these moving
136:46 - platforms so with that let's try m.p
136:50 - again and we are still printing on
136:52 - Surface and now if I jump on a moving
136:54 - platform we getting floor is true which
136:56 - means we can also jump on it and that
136:59 - feels much nicer let's try the other
137:02 - platform and we are still falling
137:04 - through so something is not exactly
137:06 - right but we are making progress so at
137:09 - the moment we can at least jump on this
137:11 - platform and that was the one part of
137:14 - the tutorial that might have been a bit
137:16 - hard because the reason for it is if you
137:19 - look inside of the
137:21 - player the way to fix it is you have to
137:24 - wrap self. old. bottom inside of an INT
137:27 - function if we now run main.py
137:30 - again everything works just fine and
137:33 - this looks much better and we can also
137:36 - jump the other
137:38 - platform works pretty
137:41 - good let's try this again and yeah this
137:44 - looks
137:45 - fine sometimes P games seems to have
137:48 - problems with the Precision of floating
137:50 - Point values and usually once you add an
137:53 - INT function to it it solves everything
137:55 - as a matter of fact for better accuracy
137:59 - I would recommend to wrap all of the old
138:01 - rects into an in
138:06 - function let's do that in general like
138:09 - so and now if you run main Pi the
138:12 - Collision shouldn't be affected too much
138:14 - or at least it should work just as
138:16 - before and and now this works still just
138:22 - fine and that is looking good
138:26 - cool sorry about the last part that was
138:29 - a bit
138:30 - confusing but anyway with that we now
138:33 - have semic collidable
138:35 - platforms next up I want to be able to
138:39 - if we are on top of one of them if I
138:42 - press down then we should fall through
138:44 - them and to make that work we we will
138:47 - need a
138:49 - timer basically if I minimize everything
138:53 - again and get rid of the print
138:56 - statement we want to add a couple of
138:58 - things number one we have to add another
139:02 - timer I have called this one the
139:04 - platform skip
139:07 - timer once again it's a timer class and
139:10 - now we need a duration I went with 300
139:13 - milliseconds and this time up we now
139:16 - have to activate which Happ s inside of
139:19 - input let's do it right below the input
139:23 - for the left key I want to
139:26 - check if Keys P game. Kore down I.E we
139:32 - are pressing the down key if that is the
139:34 - case I want to get self. timers and then
139:38 - the
139:40 - platform skip timer and activate it that
139:44 - is all we need inside of input next up
139:47 - we want to work inside of semic
139:48 - collisions because all of this should
139:51 - only be available if the timer is not
139:54 - active meaning we want to wrap all of
139:57 - this inside of one additional if
139:59 - statement if not self. timers and I call
140:04 - this one the platform skip timer only if
140:08 - this is not active then we want to do
140:11 - all of this and now if I run
140:14 - main.py and I am on one of those
140:16 - platforms I pr down and we are falling
140:18 - through it and that works consistently
140:21 - let's try the other
140:22 - platform and that also works just
140:25 - fine also I'm realizing there's one
140:28 - issue and you might have seen it before
140:30 - already if I jump on a platform and I
140:33 - just barely land then we're getting rid
140:36 - of the upwards movement pretty
140:39 - abruptly it's if I do it multiple times
140:41 - I think it's quite easy to
140:43 - see the way to fix that is also inside
140:46 - of this
140:47 - method we only want to set self.
140:50 - Direction doy if we are moving down so
140:54 - if self. Direction doy is greater than
140:58 - zero then we want to set it to zero and
141:01 - now if our remain Pi
141:03 - again this feels much
141:10 - better and cool I am quite happy with
141:15 - that that looks about right
141:19 - perfect we are making a ton of progress
141:22 - and that was a pretty tough exercise I
141:25 - hope you got at least quite far into it
141:28 - next up we're going to work on two
141:29 - simpler things and first of all I want
141:32 - to give the player a hit
141:34 - box and to illustrate why that is
141:37 - important let me update the player image
141:41 - at the moment we have a plain surface
141:43 - that we are filling with a red color
141:45 - it's a good start but it's also Fair
141:47 - fairly boring I want to replace that
141:50 - with one of the idle frames of the
141:51 - player which I have to import so py
141:53 - game. image. load to import an image and
141:58 - to get the proper path we will need like
142:00 - we have used in main from OS import join
142:04 - then we can use the join method to go up
142:07 - a folder then I want to go to Graphics
142:11 - in there we have the player in there we
142:15 - have Idol I believe I called it and in
142:19 - there we have a file name called
142:22 - 0.png just to double check here is the
142:25 - project folder at the moment we are
142:27 - inside of player. Pi from there we want
142:30 - to go up a folder then to Graphics in
142:33 - there we have the player and there we
142:35 - have idle and then there we have
142:39 - z.png that looks good also I want to get
142:42 - rid of self. image. fill and now if I on
142:46 - main.py
142:47 - we can see we have the player graphic or
142:50 - at least one frame of the player graphic
142:52 - and there you can see quite well that
142:54 - this looks very weird there's a ton of
142:56 - white space around the player and well
142:59 - we get the collisions even on the right
143:01 - side so what happens here basically what
143:05 - is happening is that this is our player
143:07 - graphic at the moment and the actual
143:10 - size of the graphic is this big and that
143:13 - size is important because later on when
143:15 - the player moves to the left we want to
143:17 - lip this entire graphic and then the
143:19 - shape would be something like
143:22 - this but the actual size of the graphic
143:25 - wouldn't be affected which makes our
143:27 - math a lot
143:28 - easier that being said though the actual
143:31 - thing that we want to show is this large
143:34 - and the actual Collision should only be
143:36 - this large meaning we want to have a
143:38 - hitbox that is excluding The Sword and
143:40 - parts of the head and the arm and to
143:43 - implement all of that we have to work
143:45 - inside of the player most importantly
143:48 - after we are creating the rectangle I
143:50 - want to create one more rectangle that I
143:52 - will call
143:54 - hitbox
143:55 - rectangle which is going to be self.
143:58 - rect and now we need the inflate method
144:01 - inflate is ultimately quite a simple
144:04 - method it simply takes a rectangle and
144:06 - then resizes it around a center point
144:10 - for example if this is our current
144:13 - rectangle with this Center Point if we
144:16 - at negative numbers into inflate is
144:18 - going to give us a smaller rectangle
144:20 - let's say something like this but it has
144:24 - the same origin Point as a matter of
144:26 - fact let me add the proper numbers I
144:29 - want to inflate this rectangle by 76
144:33 - pixels on the horizontal axis and - 36
144:37 - pixels on the vertical
144:40 - one that means that on the left side we
144:44 - are shrinking the rectangle by 38 pixels
144:49 - or 76 divided by two and on the vertical
144:52 - axis we are shrinking it by 18 pixels on
144:56 - each side or 36 in total and that way we
145:00 - are keeping the same origin point which
145:03 - is important because later on we have to
145:05 - make sure the hitbox and the actual
145:08 - rectangle are
145:10 - aligned that is important because
145:12 - basically what we are going to do the
145:14 - entire movement and collision Logic for
145:16 - this rectangle will be done via the
145:19 - hitbox rectangle and then after we have
145:21 - done all of the movement we are going to
145:23 - set the position of the rectangle to the
145:26 - same position as the hitbox rectangle
145:28 - basically we want to work inside of the
145:30 - move method at the moment we are always
145:33 - updating the rectangle but instead I
145:35 - want to update the hitbox rectangle and
145:38 - that we want to do for all of the
145:40 - rectangles when we are moving down we
145:43 - want to update this rectangle and also
145:46 - when we are jumping so basically every
145:49 - time we have self. w we want to replace
145:51 - it with self. hitbox
145:54 - wct also this has to happen inside of
145:56 - collision and semic collision so let's
145:59 - do it right away I want to check for
146:02 - sprite in self. Collision Sprites and
146:04 - then sprite. rec. cidere with self.
146:07 - hitbox
146:08 - rectangle and then we have to update all
146:11 - of these rectangles as well that belong
146:14 - to the
146:15 - player
146:18 - that should be it next up we have to do
146:20 - the same thing for the semic collisions
146:23 - and there we have at least slightly
146:25 - fewer
146:26 - rectangles those three should be
146:30 - it and now basically what we have to do
146:34 - is after we are doing the movement we
146:36 - want to set self. re. Center to
146:40 - self. hitbox rectangle do Center so in
146:45 - the most basic sense all that we are
146:47 - doing when we are creating the player we
146:50 - are creating a hitbox rectangle that is
146:52 - smaller than the original rectangle and
146:55 - this hitbox rectangle is going to be
146:57 - responsible for all of the movement and
146:59 - all of the collisions which is happening
147:02 - in
147:03 - here and after we have done all of that
147:05 - we are setting the center of the
147:07 - rectangle to the center of the hitbox
147:09 - rectangle this is almost going to work
147:11 - there's just one thing I forgot because
147:14 - we also have to update check contact
147:18 - because in there once again we are using
147:20 - the rectangle but this should always be
147:24 - the hitbox
147:27 - rectangle so all of the rects should
147:30 - basically be hitbox rectangle and now
147:33 - let's try all of this again the game
147:35 - doesn't crash that's a good start and
147:37 - now we have no horizontal collisions
147:40 - that's something we have to work on and
147:42 - those collisions also don't work so
147:45 - something is working working but we have
147:48 - to fine-tune things a bit and you might
147:51 - have already spotted the mistake inside
147:53 - of player. Pi what we are not doing is
147:56 - updating the old
147:58 - rectangle and this we are also not doing
148:01 - inside of the init method so this
148:05 - instead of self. rec. copy should be
148:07 - self. hitbox rec. copy and this line I
148:12 - want to do in the init method and inside
148:15 - of the update method
148:17 - and now we're trying all of
148:19 - this we have no collision between The
148:22 - Sword and the level and that feels
148:24 - drastically better on top of that if I
148:27 - try the platforms oh I realized I forgot
148:30 - one thing the hitbox rectangle does not
148:33 - move along with the platforms and that
148:35 - way we're getting the jumpy Behavior
148:37 - again that is easy to fix inside of
148:42 - layer I want to minimize everything
148:44 - again and move and work inside of
148:47 - platform move I want to update self.
148:51 - hitbox rec. toop left and then apply the
148:53 - platform movement and now if we try
148:56 - main.py I can jump on a platform and
148:59 - that looks much better let's try the
149:02 - other platform as
149:03 - well and that looks pretty good cool I
149:06 - can also jump that covers another part
149:10 - and I do realize I have changed lots of
149:12 - stuff inside of this class quite quickly
149:16 - but basic basically I simply replaced
149:17 - all of the rectangles with hitbox
149:19 - rectangle and the only place where we
149:22 - are updating the rectangle is here where
149:26 - we are setting the center of the
149:27 - rectangle to the center of the hitbox
149:30 - rectangle and all the other Collision
149:33 - checks are being done with the hitbox
149:35 - rectangle same for the movement cool and
149:38 - that covers another important part
149:41 - finally we can work on the camera that's
149:44 - going to become quite important because
149:46 - at at the moment we can only see a very
149:49 - small part of the level which obviously
149:51 - isn't
149:52 - ideal the way you want to think about it
149:55 - is at the moment we have a window that
149:57 - looks something like this I think the
149:59 - dimensions are
150:01 - 1280 by
150:03 - 720 although the specific numbers don't
150:06 - matter in there we have a player and we
150:10 - have some levels so there's some bits
150:12 - here we have some bits here and we have
150:14 - some bits here
150:17 - the part that goes further to the right
150:19 - we cannot see so anything that goes
150:21 - further than 1280 to the right is
150:23 - invisible now there's one limitation
150:26 - already and that is we always have the
150:29 - origin point in the top left this point
150:31 - will be zero and zero and this cannot be
150:35 - changed as far as P game is concerned we
150:38 - always have a window that starts up
150:40 - there goes up to 720 on the vertical
150:42 - axis and up to 1280 on the horizontal
150:45 - one and every element is drawn relative
150:48 - to
150:49 - that so what we can do is when we are
150:53 - drawing all of the level elements we
150:55 - don't have to draw them from the origin
150:56 - point of 0 and zero instead we could
150:59 - change this point to something else
151:01 - let's say negative 50 and zero that way
151:05 - we would be shifting everything a bit
151:07 - further to the left and see more of this
151:10 - part I.E we are basically drawing
151:12 - everything with an offset and if you
151:14 - make this offset relative to the player
151:17 - position then we are getting a camera
151:20 - that always follows the player and by
151:22 - the way for all of this I have made a
151:24 - dedicated video if you want to learn
151:26 - more about the details but basically the
151:28 - way you would approach it inside of
151:30 - level. Pi we currently have one Sprite
151:34 - group that contains all of the Sprites
151:37 - and the drawing logic of this group we
151:40 - want to customize and for that I want to
151:42 - create a new python file let me save
151:45 - this one as s groups. py and in there we
151:49 - want from settings import everything
151:53 - after that we want to create a class
151:56 - that I usually call all Sprites this one
151:59 - has to inherit from pygame dos sprite.
152:02 - group most importantly to get started we
152:05 - will need a Dunder init method without
152:08 - any custom parameters that has to
152:10 - initialize the parent class meaning
152:12 - super and thunder in it with that we
152:16 - basically created our own custom group
152:18 - that works exactly like an inbuilt py
152:21 - game Group which means inside of level.
152:24 - Pi we can from groups import all Sprites
152:30 - and then instead of py game. sprite.
152:32 - group use all
152:36 - Sprites the result should be the same if
152:38 - I run m.p that looks pretty good no
152:42 - change that's at least not a problem but
152:45 - we also didn't create a cam camera to
152:47 - work on that we have to first of all
152:49 - understand what is bright group actually
152:52 - does inside of the draw method and it's
152:55 - actually really simple by default when
152:58 - you're calling the draw method of a
152:59 - group you have to pass in a Target
153:01 - surface let's call it surface for now
153:04 - and then inside of this Method All That
153:07 - the group does is it Loops over every
153:09 - single Sprite that is contained inside
153:11 - of this group and this you can do with
153:14 - four Sprite in
153:16 - self if you call Self then the group is
153:19 - going to return all of the Sprites
153:21 - inside of it and once you have that all
153:23 - you really have to do is serve. blit
153:27 - with sprite. image and sprite. wct which
153:31 - means now if I run main.py we still get
153:34 - the very same outcome even though when
153:37 - we are looking at the run method this
153:40 - draw method is now completely customized
153:42 - we have overwritten the default draw
153:45 - method of a group
153:46 - one way to demonstrate that is inside of
153:49 - the init method we can for example
153:51 - create the display surface which is what
153:54 - we want to draw on anyway and that once
153:57 - again we get with py. display. getor
154:01 - surface and then use this display
154:04 - surface to draw on because of that we
154:08 - don't need the argument for the Target
154:10 - surface anymore and we can also get rid
154:13 - of it inside of the draw method we call
154:16 - it inside of level. Pi now I can run all
154:19 - of this again and it still works just
154:22 - fine so with that we have recreated the
154:25 - basic drawing logic now we can customize
154:28 - it and for that I want to create self.
154:31 - offset which is just going to be another
154:34 - vector and to demonstrate what this one
154:36 - is doing let me give it a custom value
154:39 - 500
154:40 - and0 now that we have that inside of the
154:43 - for loop I want to create an off
154:46 - set
154:48 - position which is going to be sprite.
154:51 - rec. toop left plus self. offset and
154:56 - this new position is what we will use
154:58 - for the actual drawing position so in
155:01 - there we get offset
155:03 - position if I now run may not Pi you can
155:06 - see that we have moved the entire level
155:09 - 500 pixels to the right but everything
155:12 - else still works just fine and a really
155:16 - important thing to understand at this
155:18 - point is that we haven't actually
155:20 - changed any position of the actual
155:22 - rectangles in the game for the player
155:25 - and for all of the Sprites the
155:27 - rectangles have stayed exactly the same
155:30 - as far as they are concerned they are
155:32 - still in exactly the same position the
155:35 - only difference is when we are drawing
155:37 - the entirety of the game we are drawing
155:39 - it with an offset and that way we are
155:42 - getting a camera and because of that we
155:45 - can create create a camera without
155:47 - affecting anything else in the game all
155:50 - we have to figure out now is how to
155:52 - align this offset with the player
155:55 - position first of all for that we need
155:58 - the actual player position or more
156:00 - broadly I want to have a Target position
156:04 - and that we get inside of the level I
156:07 - want to pass in self. player. w. Center
156:11 - or I suppose we could be a bit more
156:14 - specific here this should be the hit box
156:17 - rectangle of the player in practice
156:19 - though both would work just fine but
156:22 - anyway I don't think self the player is
156:25 - available yet because when we are
156:27 - running setup we are only creating an
156:30 - instance of the player but we're not
156:31 - storing it that is very easy to fix
156:34 - self. player is going to be the player
156:37 - object and now we should have access to
156:40 - the player let's try M notp and this is
156:43 - still working just fine cool first of
156:46 - all I want to set the starting value of
156:49 - the offset Vector to 0er and zero which
156:52 - are the default values so if I leave it
156:53 - empty that's all we need and after that
156:57 - I want to get self. offset and update
156:59 - the horizontal part the value for that
157:02 - is going to be I want to have the target
157:05 - position but only the X part or index
157:08 - zero and since I want the player to
157:11 - always be in the center of the window I
157:13 - want to subtract window
157:16 - wi ided by two and just to explain what
157:20 - this window wi divided by two means if
157:23 - this is our entirety of the window we
157:26 - always want to have the player exactly
157:28 - in the center of this window which means
157:31 - on the horizontal axis we want to have
157:33 - exactly half of the window width in
157:36 - terms of distance between the center of
157:38 - the player and the origin top left point
157:42 - and this part is almost going to work if
157:44 - I now run made of Pi
157:46 - we get some very trippy Behavior the
157:49 - reason for that is that we have to
157:52 - invert all of this this should
157:54 - be negative if I now run this again
157:59 - there we go we have a camera that is
158:01 - working really really
158:04 - well and now we can see the rest of the
158:07 - level also just
158:09 - fine and the reason we needed negative
158:11 - numbers for this one is because the ferv
158:13 - the player is moving to the right for
158:15 - example
158:16 - the more leftwards we want to draw the
158:19 - level or if I draw all of this once
158:22 - again we have a basic level we have
158:25 - something here something here and then
158:27 - something larger here we have the player
158:31 - on this position and the window itself
158:33 - looks something like this if the player
158:37 - is moving further to the right then we
158:40 - want to draw everything else further to
158:42 - the left I.E in exactly the opposite
158:45 - Direction because of that we have the
158:48 - negative the same thing we want to do
158:50 - for the vertical part so self. offsety
158:53 - is going to be Target position 1 minus
158:56 - window height / it by two and then we
159:00 - should be done if I now run main. Pi we
159:04 - get the player always in the center of
159:07 - the window and that looks pretty
159:10 - solid so with that we have a basic
159:14 - platformer that works really
159:17 - well and there we
159:20 - go he there before we finish there is
159:23 - one thing I realized that didn't work
159:25 - perfectly well and that happens inside
159:28 - of the collisions so if you go to player
159:30 - and collisions earlier on for the
159:32 - collisions we added the integer because
159:35 - otherwise we got some minor bugs and I
159:38 - realized you have to add both the old
159:41 - RCT and the Sprite old RCT in an in
159:43 - function so let's do it right away
159:47 - and that's all you have to do and for
159:49 - now even without the in function all of
159:51 - this would have worked just fine however
159:53 - later on we will get some occasional
159:55 - funky behavior and adding the code like
159:57 - this fixes all of
159:59 - that now truth be told I don't know
160:02 - exactly why this is necessary in the
160:04 - first place but once you have it all of
160:06 - your collisions are going to work
160:08 - perfectly so we don't have to think
160:10 - about it too much but anyway with all of
160:12 - that we have finished the basic
160:14 - platformer
160:16 - welcome to the second part of this
160:18 - tutorial at this point we already have a
160:21 - basic outline of a platformer which
160:24 - works reasonably well but it doesn't
160:26 - look particularly good and that is what
160:28 - we are going to work on by the end of
160:30 - this part we will have a proper looking
160:32 - platformer that feels like an actual
160:35 - game most importantly for that we have
160:38 - to add all of the graphics that is going
160:40 - to be a major chunk and on top of that
160:42 - we are also going to add more
160:44 - interactivity by that I mean we're going
160:46 - to have some enemies we are going to
160:48 - have UI elements we are going to have
160:50 - some items and we're going to have a
160:51 - couple of
160:52 - traps quite a bit to work on and for all
160:55 - of that we will have to go through a few
160:58 - stages the first one is going to be all
161:00 - of the basic Graphics of the level
161:02 - that's going to be a fairly
161:03 - straightforward part however there is
161:06 - going to be one major bit that we have
161:08 - to be aware of for this entire part and
161:11 - that is importing
161:13 - Graphics if you look at the project
161:15 - folder fer and you open the graphics
161:18 - folder you can see that we have a ton of
161:21 - material to work with for example simply
161:23 - looking at objects we have a whole bunch
161:27 - of them and when you come to animations
161:30 - it gets even worse so for example under
161:32 - items we have one animation for every
161:36 - single
161:37 - item and then if you look at the player
161:40 - for example the player has a ton of
161:42 - states and every single state has a
161:44 - bunch of Fram as well I don't know how
161:47 - many Graphics we have in total but there
161:50 - are a lot and importing all of them
161:53 - manually is not going to be a pleasant
161:55 - experience so I am going to emphasize
161:58 - how to import files in bulk in pame
162:01 - during this entire section but for now
162:04 - that's not too important because there
162:06 - are a couple of things we can import
162:08 - quite easily because at the moment we
162:11 - can work inside of level. Pi in the
162:13 - setup method we already already have a
162:16 - for Loop to create all of the
162:19 - Sprites from this for Loop we are
162:21 - getting a surface that we are passing
162:23 - into the Sprite and then in this Sprite
162:27 - we are capturing it via a parameter and
162:30 - then assigning it to an
162:32 - image the only reason we can't see it is
162:35 - because we are filling this image with a
162:36 - white color if we get rid of this white
162:40 - color and run all of this again we
162:43 - already have a basic level and this is
162:45 - looking much better now we still have
162:48 - the Platformers you can see them right
162:50 - now or well you can at least see that
162:52 - the player is moving since they are
162:55 - black and with a black background they
162:57 - are not too visible but that's going to
162:59 - be a problem for
163:00 - later for now I am quite happy with this
163:03 - and just to make sure that we can see
163:05 - the moving
163:06 - platforms after we calling super. init I
163:10 - want to self. image do bill with let's
163:15 - say a white color and now we should be
163:17 - able to see them again and that feels a
163:19 - bit better and there you can see we
163:21 - already have the basic outline of the
163:24 - level on top of that we do have a couple
163:28 - of tiles that are very easily
163:30 - importable if you look at tiled we have
163:33 - a couple of tiled layers at the moment
163:35 - we only imported terrain but we also
163:38 - have FG platforms and BG BG by the way
163:42 - is all of the background stuff platforms
163:45 - are a couple of extra
163:47 - platforms and finally we have FG this
163:49 - one is a bit more difficult to see but
163:51 - if I zoom in FG for example is the grass
163:55 - that should always be on top of
163:57 - everything else importing all of those
164:00 - is actually fairly simple we simply need
164:02 - another for Loop let's call it for layer
164:04 - in and then I want to have a list with
164:07 - BG I want to have the ter Rin then I
164:12 - want to have the foreground and then I
164:15 - also want to have the plat
164:18 - forms after that this for Loop that we
164:21 - already had for the terrain is going to
164:23 - become an inner for Loop and then we can
164:25 - replace the terrain with the layer and
164:29 - now if I run all of this we get a whole
164:32 - bunch of stuff although we have to
164:34 - customize things so for example these
164:37 - platforms are collidable and they should
164:39 - be just like the moving platforms only
164:42 - collidable from one side so we should be
164:44 - falling through through them also the
164:46 - grass should not be collidable same with
164:50 - the background stuff this one should
164:52 - just be in the background behind the
164:54 - player we shouldn't be able to collide
164:56 - with
164:57 - it which means inside of this for Loop
165:00 - we have to customize a couple of
165:03 - things most importantly we want to have
165:06 - a local variable called groups and by
165:09 - default the value in there is going to
165:11 - be a list with self. all Sprites
165:15 - and then if the layer
165:18 - is terrain then we want to groups and
165:24 - append self. Collision
165:29 - Sprites after that we can check again if
165:32 - we have the platforms and if that is the
165:35 - case we want to attach semic Collision
165:38 - Sprites with that we can replace all of
165:41 - the groups we had by default with the
165:44 - local group groups variable and now we
165:48 - have a much better looking system and
165:50 - the platforms should already work and
165:52 - that looks really
165:55 - good now the moving platforms here are
165:57 - getting a bit annoying but well that's
166:00 - something you can fine tune this is just
166:02 - an experimental level so it doesn't have
166:04 - to work
166:05 - perfectly and I suppose one thing you
166:07 - could be working on is the downward fall
166:10 - so if I press down we are falling right
166:13 - through the moving platform
166:16 - if you customize the falling down timer
166:18 - that is this platform skip timer and we
166:22 - could try to set it to 100 and now this
166:26 - should be working better yep that feels
166:28 - better so once again experiment with all
166:31 - of this but that you could do in your
166:33 - own time as far as I'm concerned all of
166:36 - this is working reasonably well however
166:38 - there's going to be a bit of an issue
166:40 - and that is if I jump in there okay it
166:44 - actually works
166:46 - but the grass for example should be in
166:49 - front of the player and more generally I
166:53 - want to have control which elements are
166:54 - in front of other elements so at the
166:57 - moment all of this is only behind the
167:00 - player because we are creating it before
167:02 - we are creating the
167:04 - player if we switch that around the
167:07 - player would be behind everything else
167:09 - we can actually try that and run may not
167:13 - Pi if I know go
167:15 - behind the stuff the player is not
167:17 - visible anymore and obviously that's
167:19 - going to be a
167:22 - problem although I want to create a
167:24 - player afterwards so we want to have
167:27 - control over the drawing logic and for
167:30 - that if you look at settings. Pi we have
167:33 - a variable called Z layers and this is
167:36 - going to determine when things are being
167:38 - drawn for example the background will be
167:40 - drawn first then we have the clouds BG
167:43 - tiles path and so on and the later
167:45 - something is drawn it will always be on
167:47 - top of the element before so FG elements
167:51 - will always be drawn last hence they on
167:53 - top of everything
167:55 - else we just have to figure out how to
167:57 - use this system and for that first of
167:59 - all we have to work inside of groups. Pi
168:03 - because what we want to do in here is
168:06 - sort all of the Sprites and that we do
168:09 - via sorted sorted wants to have some
168:12 - kind of list that we're getting with
168:13 - self and then it wants to have a key
168:16 - which usually is a Lambda function where
168:19 - we have to specify one parameter which I
168:22 - usually call Sprite and then whatever
168:25 - the Lambda function returns is going to
168:27 - be sorted by the sorted
168:29 - function and the sorted function for
168:31 - that is expecting an integer that it is
168:34 - then going to sort from the lowest to
168:35 - the highest
168:37 - value which means we want to get this
168:41 - Sprite and then return a that index now
168:45 - this one doesn't exist right now in a
168:48 - second though we going to get that
168:49 - number from this variable as a matter of
168:52 - fact that's going to happen right now
168:54 - when we are creating all of these
168:57 - Sprites I want to be able to pass in one
169:00 - more argument and that is going to be
169:03 - the Z number which we don't have right
169:06 - now so let's create it and to get that I
169:10 - want to get the Z layers the dictionary
169:13 - we are getting from settings. pi and in
169:17 - there I want to get one entry for
169:19 - example I could get the BG tiles for now
169:24 - let's leave it like that so all of the
169:26 - tiles we are creating will be in the
169:29 - background although for that first of
169:31 - all we have to create inside of the
169:34 - Sprite one more parameter and that is
169:36 - going to be
169:37 - Z now this one should also have a
169:40 - default parameter I want to get Z layers
169:43 - and then Main
169:45 - simply because main is where most of the
169:48 - game is happening so this should be the
169:49 - default
169:50 - value after that I want to create an
169:53 - attribute self. Z is going to be
169:57 - Z next up we have to work inside of the
170:00 - player because this one will also need a
170:04 - z attribute let's put it right below
170:07 - self. image self doz is going to be and
170:11 - the player should always be on the main
170:13 - layer so this one should be main all
170:16 - right and with that let's try to run
170:18 - main. pi and you can see the player is
170:20 - on top of the grass but what should also
170:23 - be the case is that the player is on top
170:25 - of this background and this is going to
170:28 - work regardless of when we are creating
170:31 - things so even if I create the player
170:33 - before all of these tiles and run main P
170:37 - we should still have the player in front
170:39 - of it and that looks really good
170:43 - cool and now I can explain this Logic
170:47 - the way you have to think about it is
170:49 - that the player has a Sprite do Z which
170:52 - I believe is five yeah so player. Z is
170:54 - five and everything else has PG tiles so
170:58 - Z for them is going to be
171:00 - two and sorted is going to sort all of
171:02 - these Sprites by that number and the
171:05 - higher the number is the lat an element
171:07 - will be drawn and as a consequence that
171:09 - element will be on top of the earlier
171:12 - Sprites the system ultimately is n that
171:15 - difficult but I think when you get
171:16 - started it can be a bit confusing so I
171:18 - hope it makes sense but anyway now we
171:21 - can work inside of level. Pi because
171:23 - this Z number isn't correct yet I
171:27 - basically want terrain and platforms to
171:30 - be on the main
171:32 - layer however BG should be inside of BG
171:35 - tiles and FG should be in the
171:38 - foreground one way to approach that
171:40 - could be with a match case statement so
171:43 - I want to match the layer and then one
171:47 - case could be BG if that is the case
171:52 - that should be
171:55 - that
171:57 - layers and for that I do want to keep
172:00 - the BG
172:02 - tiles another case would be the FG and
172:07 - if that is the case I want to assign
172:10 - that to the foreground or F
172:15 - G and for everything else we want to
172:17 - have the main layer which means terrain
172:20 - and platforms are going to be the cases
172:23 - and both of those we can have with case
172:25 - underscore that's going to cover
172:27 - everything else if that is the case that
172:30 - should be main let's try all of this and
172:34 - now you can see that the grass is in
172:38 - front of the player kind of hard to see
172:42 - but there that's kind of more visible
172:44 - visible however more importantly all of
172:47 - this background stuff is behind the
172:49 - player and that still works perfectly
172:51 - fine cool so with
172:54 - that we have made some pretty good
172:56 - progress in terms of how we are drawing
173:00 - things that means we can minimize this
173:03 - for Loop and I also want to have the
173:05 - player after the
173:06 - tiles that isn't strictly a requirement
173:09 - it just feels better as a matter of fact
173:12 - we are now going to add all of the
173:14 - objects for that once again let's have a
173:17 - look at tiled here we are and at the
173:20 - moment we have a whole bunch of layers
173:22 - and the only one that I care about is
173:24 - objects so let me hide literally
173:27 - everything else because at the moment
173:30 - it's not going to be
173:31 - necessary we are already importing one
173:34 - object and that's the player but on top
173:36 - of that we have a couple of palm trees
173:38 - we have crates we have spikes we have
173:41 - the level finish flag and on top of that
173:44 - we have one object that is going to be a
173:46 - saw later
173:49 - on all of these things we want to import
173:52 - and that import is going to be a bit of
173:54 - an issue now you could use tile to get
173:56 - the graphics for example all of these
173:59 - palm trees are simply available via obj
174:02 - do image but that's not what I want to
174:04 - do and that is because if I open the
174:07 - project folder we are right now inside
174:10 - of graphics and there I want to go to
174:12 - levels there we have The Palms and there
174:16 - we have all of the different palm tree
174:18 - animations and that's the issue all of
174:20 - these are animated I don't want to have
174:23 - a single image I want to import a whole
174:26 - sequence of images for every single palm
174:28 - tree and that I do not get from til all
174:32 - of that we have to do
174:35 - semi-manually however what we can do is
174:38 - use another python file and that is
174:40 - support. p that's already in our project
174:43 - if you're open that one you can see four
174:46 - functions that can Mass import basically
174:49 - any kind of folder now for this tutorial
174:52 - I am not going to explain all of this in
174:54 - detail however I have made a whole
174:56 - separate video explaining how all of
174:58 - these functions work in that video I
175:01 - also cover how to import tile Maps but
175:03 - for this project that's not
175:04 - necessary basically the way you want to
175:06 - think about these functions is that they
175:09 - cover two important things number one
175:12 - they are platform independent
175:14 - we are using a join method to create a
175:17 - path dynamically that way for example
175:20 - for different operating systems you
175:21 - might need either a forward slash or
175:23 - backward slash for the path and join
175:26 - gives you the right one
175:28 - automatically on top of that a lot of
175:30 - them do Mass Imports let me actually go
175:33 - through all of them import image is the
175:35 - easiest one and This One Imports a
175:37 - single
175:38 - image all you have to do is specify a
175:41 - path you can also specify if there are
175:43 - alpha Val values and what the file
175:45 - format is going to be that being said
175:48 - though there are defaults where Alpha is
175:50 - true and the file format is PNG so most
175:53 - of the time you simply have to specify a
175:56 - path that's the easiest function and
175:58 - that doesn't do very much the next one
176:00 - is much more interesting import folder
176:03 - This One Imports all of the images
176:05 - inside of a folder and places them
176:07 - inside of a
176:09 - list the end result is going to be a
176:11 - list with surfaces that you could for
176:13 - example add animate through after that
176:16 - we have a somewhat similar function this
176:18 - one is called import folder dictionary
176:20 - it works more or less like import folder
176:22 - but the difference is that now we are
176:24 - getting a dictionary where we have the
176:26 - name of the file as the key and the
176:28 - actual surface as the
176:30 - value for import folder we just get a
176:32 - list with surfaces we don't know what
176:34 - the names are which a lot of the times
176:36 - we don't actually need but import folder
176:39 - dictionary retains that data finally we
176:42 - have import subfolder folders this one
176:45 - is going to be used for something like
176:46 - the player where we have one main folder
176:49 - and then lots of different subfolders
176:51 - for all of the states of the player if
176:53 - you look at Graphics in there we have
176:56 - the player this entire folder we want to
177:00 - import and in there we have lots of
177:02 - subfolders for example we have idle and
177:05 - in there we have more
177:06 - animations what import subfolder is
177:09 - going to do it is going to create a
177:11 - dictionary and the keys of this
177:12 - dictionary are going to be the folder
177:14 - names and then the values are going to
177:16 - be a list of surfaces for each of these
177:19 - folders once again if you want to know
177:22 - more about it check out the dedicated
177:23 - video but for now we can work inside of
177:27 - main.py and import a whole bunch of data
177:30 - first of all for that I want from
177:33 - support import everything and then since
177:37 - we are going to import a whole bunch of
177:39 - stuff create a new method let's call it
177:43 - import
177:44 - assets no need for custom parameters in
177:47 - this one and for now what I want to do
177:50 - is create self. levore
177:54 - frames this is going to be a dictionary
177:56 - in
177:58 - itself and for now what we want to
178:01 - import for
178:02 - example I suppose what we can start with
178:06 - could be the
178:08 - flag for that we want to look at a
178:10 - project folder we have Graphics then we
178:14 - want to go to the level and in there we
178:17 - have a flag a simple animation and this
178:20 - we want to
178:22 - import which we are going to do with the
178:24 - import folder function and then we will
178:28 - need a path we want to go uper folder
178:31 - then we want to go to Graphics after
178:33 - that we want to go to level and finally
178:37 - the folder we want to import is flag and
178:40 - after all of this let me print self.
178:43 - level from frames also make sure that
178:45 - you are calling import assets if I now
178:49 - run all of this we can see that we
178:53 - have a dictionary with a flag key and
178:57 - the associated value is a list with a
178:58 - whole bunch of
179:01 - surfaces and this is the power of these
179:03 - functions if we didn't have them we
179:06 - would have to run py game. image. load
179:08 - for every single file inside of this
179:10 - folder which would be a nightmare all
179:13 - right but now what I want to do is get
179:16 - these level frames into our current
179:19 - stage that part is quite easily done we
179:22 - simply have to add it as an argument
179:23 - self. level frames the one important
179:26 - thing here is make sure you are calling
179:28 - import assets before you are creating
179:31 - the current
179:33 - stage so next up then inside of level.
179:37 - Pi we have to create one more parameter
179:41 - level frames and those levels frames we
179:44 - want to pass into this setup method
179:47 - right away level frames for that inside
179:50 - of setup we will need another parameter
179:53 - level frames and now we can work with
179:57 - all of those at the moment we are only
180:00 - checking for objects if the name is
180:02 - player but there are quite a few more
180:05 - let's simply check the else case so we
180:08 - are covering everything but the player
180:11 - to get started in here we can actually
180:13 - start with an easy part if
180:15 - objname is in a list of barel or
180:23 - rate if that is the case and let me show
180:25 - what we are doing in til we are
180:28 - currently looking at these free objects
180:30 - where we have a barrel and a crate those
180:33 - are not going to be animated meaning we
180:35 - can import them straight away from til
180:37 - for that once again we can simply create
180:40 - a Sprite and then we need all of the
180:42 - Sprite arguments let me copy them
180:44 - actually so we need position surface
180:46 - groups and z now Z we can simply leave
180:52 - out because I like the default argument
180:54 - here all of these Sprites should be on
180:56 - the main
180:57 - layer then for groups I want to have a
181:00 - list with self. all Sprites and since
181:03 - these Sprites are supposed to be
181:04 - collidable also self. Collision
181:07 - Sprites position and surface then are
181:10 - also going to be fairly easy the surface
181:12 - is obj do image and position is going to
181:16 - be a list with obj dox and obj
181:21 - doy that should already be enough if I
181:24 - now run main. Pi we have a whole bunch
181:27 - of crates and that looks pretty
181:30 - good
181:32 - cool that means once more we can add an
181:35 - else
181:36 - statement for now in there I want to
181:39 - create the
181:41 - frames and those we are getting via the
181:44 - level frames and then I want to use the
181:49 - objname the way this is going to work
181:51 - objname we getting from til if you look
181:54 - at that for example if we look at the
181:57 - flag objname is flag the same flag we
182:02 - have used as the key inside of the level
182:05 - frames
182:06 - dictionary and at the moment I want to
182:09 - do all of that only if pal not in
182:16 - objname so for now we are going to
182:18 - ignore all of the palm trees because
182:20 - they're going to work a little bit
182:21 - different I cover them in just a second
182:23 - after we have all of that let's print
182:25 - the frames that we are getting and I'm
182:27 - pretty sure we are going to get an error
182:29 - let's run main. pi and we are getting a
182:32 - key
182:33 - error that pame cannot find the key saw
182:38 - inside of level
182:40 - frames and that should make sense if if
182:43 - we open tiled again we are at the moment
182:46 - ignoring all of the palm trees and if
182:49 - you look at them you can see for the
182:50 - name we have something like Palm small
182:53 - or Palm BG or Palm BG right all of these
182:57 - Palms are different kind of animations
183:00 - and the one thing that connects them all
183:02 - is that for the name we always start
183:03 - with
183:04 - palm however we also have a saw and we
183:08 - have floor spikes those we don't have
183:12 - inside of the dictionary right now
183:13 - meaning we have to import them we first
183:16 - of all have to get the saw that one is
183:19 - going to be an animation as well so I
183:20 - want to import
183:22 - folder and let me copy in the path
183:25 - that's going to make my life a bit
183:27 - easier we want to go up a folder then to
183:29 - Graphics then to enemies then saw and
183:32 - then animation and after that I want to
183:35 - have the floor Spike this one once again
183:38 - is import folder we go to the same
183:40 - enemies folder and then we import floor
183:42 - spikes
183:44 - if I now run main. Pi we're not getting
183:46 - an error anymore and instead we get a
183:49 - whole bunch of frames these frames we
183:52 - want to use for an
183:54 - animation but step by step at the moment
183:57 - we are still working inside of this if
184:00 - statement and the issue we have right
184:02 - now is that we do have a Sprite class
184:04 - but this one isn't animated meaning we
184:07 - need to create inside of Sprites dop
184:11 - something like a animated Sprite
184:15 - class I want to inherit from Sprite the
184:19 - class we have just created that way we
184:21 - can save a bit of code for that I want
184:24 - to create a Dunder init method and then
184:28 - we will need a position we will need
184:30 - some frames we will need the groups we
184:33 - should be able to specify the Z layers
184:36 - although this one should get a default
184:38 - value with it being on the main layer
184:42 - also finally
184:43 - I want to be able to specify an
184:45 - animation speed although this one also
184:48 - gets a default value which will be the
184:51 - animation speed variable inside of
184:53 - settings so this should be the default
184:56 - value and after we have all of
184:59 - that we can work on initializing all of
185:03 - this most importantly I want to call
185:06 - Super and then Dunder init that way we
185:10 - are calling the parent Dunder init
185:12 - method and in there we have to specify a
185:14 - position a surface and the groups also
185:18 - the layer position is going to be fairly
185:21 - easy because this one we're getting from
185:22 - the arguments right away same with the
185:24 - groups those we don't have to worry
185:26 - about and also Z is covered the one
185:29 - thing that's going to be a bit more
185:30 - difficult will be the surface for that
185:34 - first of all I have to create a couple
185:36 - of attributes and those are going to be
185:38 - self. frames and self. frame underscore
185:44 - index the value for both of those are
185:47 - going to be either the frames or zero
185:51 - and as a reminder self. frames is going
185:53 - to be a list with surfaces and from this
185:56 - list we are going to pick one surface
185:58 - via the frame
186:00 - index an easy way to do that to get
186:02 - started is when we are initializing the
186:04 - parent class I want to get self. frames
186:07 - and then use self. frame index for the
186:12 - indexing and that way we have an
186:14 - animated Sprite that isn't animated yet
186:17 - but at the very least it shouldn't crash
186:20 - which means inside of level. Pi besides
186:23 - the Sprite I also want to import the
186:27 - animated Sprite and by the way in just a
186:30 - bit we are also going to update the
186:32 - moving Sprite to be animated which we
186:34 - achieve by making it inherit from the
186:36 - animated Sprite but that's not too
186:38 - important for now when we are working
186:41 - inside of the objects I want to create
186:44 - an animated Sprite and for that we will
186:47 - need a whole bunch of
186:49 - arguments all of those and then the
186:52 - animation speed position is fairly easy
186:56 - we can simply take them from the object
186:59 - the frames we already have this is what
187:01 - we just created groups for now is simply
187:04 - going to be self. all
187:06 - Sprites and then just to keep it simple
187:08 - for now I want to ignore that and the
187:11 - animation speed now let's try all of
187:13 - this and I can see I have the spikes I
187:17 - have the saw and if I go further to the
187:20 - right then we can see the flag that
187:24 - looks pretty good the issue now though
187:27 - is that none of those are animated and
187:29 - for that we will have to work inside of
187:31 - animated Sprite a bit more although
187:34 - before we get to that I want to create
187:36 - another attribute self. animation speed
187:38 - which is the same value as the animation
187:42 - speed from the par
187:43 - parameters after that we want to create
187:46 - an animate method with self and Delta
187:51 - time and basically all that we are going
187:53 - to do is we are going to increase the
187:56 - frame
187:57 - index by self. animation speed and
188:01 - multiply this with Delta time Delta time
188:03 - for this one is fairly important we were
188:06 - to make sure that these animations play
188:08 - at the same speed on every kind of
188:10 - computer after we have that we want to
188:12 - up St self. image and essentially all
188:16 - that we really want to do is pick a new
188:18 - Surface from self.
188:21 - frames which means I want to get self.
188:25 - frames and then use indexing so self do
188:29 - frame index however this is not going to
188:32 - work for two reasons number one after we
188:35 - are running this line self. frame index
188:38 - is going to be a floating point value
188:40 - and we will need an integer
188:43 - for that I want to turn this number into
188:46 - an integer the next problem is that this
188:49 - number will keep on growing forever
188:52 - that's an issue because self. frames has
188:54 - a finite number of surfaces hence we are
188:57 - going to get an index error really
189:00 - quickly because this index is too large
189:02 - for self. frames to overcome that we
189:05 - will need the modulus operator where we
189:08 - want to get length and then self dot RS
189:13 - that way frame index will never exceed
189:16 - the length of self. frames and with that
189:19 - we are animating all we have to do now
189:22 - is to call the update method with self
189:25 - and Delta time all of that is already
189:27 - happening and then call self.
189:31 - animate with Delta time and now if I run
189:34 - m not Pi we can see we have animations
189:38 - that looks pretty good and if I go to
189:41 - the flag this one should also be
189:44 - animated and perfect that looks really
189:46 - good with the basic parts of the level
189:48 - out of the way we can start working on
189:50 - the player this one is going to be quite
189:53 - a chunky
189:55 - class although since we already have
189:57 - some really good Basics this shouldn't
189:58 - be too difficult let's Jump Right In
190:01 - once again we are starting inside of
190:03 - main.py and what we have to start with
190:06 - are the assets for the player this is
190:08 - just going to be another import I want
190:11 - to have a player key
190:13 - and the associated value is going to be
190:16 - import subfolders like what we have done
190:19 - for the palm trees the file path for
190:22 - this one let me copy it in is going to
190:25 - be onefold up graphics and
190:27 - player after we have done all of that I
190:30 - want to print self. level
190:33 - frames and then the layer entry if I now
190:38 - run all of
190:39 - this we are getting all of the player
190:43 - graphics and there are quite a few but
190:45 - ultimately and I already mentioned this
190:47 - we basically go by States for example
190:50 - one state could be the air attack
190:51 - another state could be hit or jump and
190:55 - associated with every state we have a
190:57 - list of surfaces that's the
191:00 - animation all of that we have to get
191:02 - into the player class which happens
191:05 - inside of level. Pi in this setup method
191:08 - because in there at some point we are
191:11 - creating the player
191:14 - now to keep this one a bit more
191:15 - organized I want to use named arguments
191:18 - the first argument is the position the
191:21 - second one was the groups we had the
191:24 - Collision uncore
191:27 - Sprites and finally we had the semic
191:31 - Collision
191:32 - Sprites I want to add one more argument
191:35 - and that is going to be the level frames
191:39 - and then the player
191:40 - Graphics after that we we can work
191:43 - inside of player. piy and first of all
191:47 - we will need let's call it
191:50 - frames at the moment our player image is
191:54 - simply going to be a single idle frame
191:57 - although that we don't want to use
191:59 - anymore instead let's organize all of
192:02 - this a bit better I first of all want to
192:04 - have the general setup part in there we
192:08 - are initializing the parent class then
192:11 - we are declaring that and that's all we
192:13 - need in there after that we are getting
192:16 - the image and for that like we have done
192:19 - in the animated Sprite this one we want
192:23 - to store the frames and create a frame
192:26 - index I can just copy all of this
192:29 - and we have self. frames and the frame
192:32 - index and just to make sure that this is
192:34 - working let me get rid of the graphic we
192:37 - have loaded in so far and instead get
192:40 - self. frames
192:43 - and now we need one of the animation
192:46 - States this could for example be idle
192:49 - and then we get a list of surfaces from
192:52 - which we want to get one surface via
192:54 - indexing which we get via frame index if
192:57 - I now run main. Pi we are getting an
193:00 - error that positional arguments follow
193:03 - keyword arguments that happens because I
193:06 - forgot to add the named argument frames
193:09 - in there now this should be working and
193:11 - there we go we basically have the same
193:14 - result we already got before however
193:17 - what we can do now is pick another state
193:20 - for example I think one was called
193:22 - attack if I run out of this we get the
193:25 - first frame of the attack
193:27 - animation all we could do jump and then
193:30 - we get the first frame of the jump
193:33 - animation let me return this to idle and
193:36 - now all we have to figure out is how to
193:37 - manage the states and how to do the
193:40 - actual animation part also we have to to
193:42 - figure out if the player is facing left
193:44 - or right meaning we have a couple of
193:47 - things to work on first of all I want to
193:50 - create two more attributes first one is
193:52 - called State the second one is going to
193:54 - be self. facing right the values for
193:59 - this one are going to be idle and R the
194:03 - default state of the player is going to
194:05 - be idle and we are facing right by
194:08 - default all of the graphics for the
194:10 - player are facing right and then when
194:13 - the player is turning left we are
194:14 - setting this to false and then when we
194:17 - are drawing the player we are going to
194:18 - invert it on the horizontal
194:21 - axis okay then finally I want to update
194:25 - this line just a bit instead of getting
194:27 - this idle I want to use self. state that
194:32 - isn't going to make a massive difference
194:33 - we are still getting the same result but
194:35 - it feels a bit cleaner after that we can
194:38 - minimize the dunder init method and let
194:41 - me create all the way at the bottom a
194:45 - Define animate method with self and
194:48 - Delta time we want to do something
194:51 - fairly similar compared to what we have
194:52 - done inside of the animated Sprite once
194:55 - again basically all of
194:58 - this although for the player we want to
195:01 - get self. frame index and then increase
195:05 - it by the animation uncore speed this
195:10 - value doesn't need to be randomized
195:11 - because we only have a single player
195:14 - although we do have to multiply it with
195:16 - Delta time after we have that I want to
195:19 - update self. image which is going to be
195:22 - self. frames and then we want to do
195:25 - something different compared to what we
195:26 - have done on this line for animated
195:29 - Sprite the frames were just a list of
195:32 - surfaces but in the player we have a
195:34 - dictionary where we first of all have to
195:36 - get self. State and after that we
195:40 - getting a list of surfaces only in the
195:42 - there can we get the integer of self.
195:45 - frame index with
195:47 - modulus of the length of self. rams and
195:52 - don't forget this also needs self. State
195:55 - let's try for that inside of the update
195:58 - method we have to call animate and since
196:00 - we have quite a few methods in there I
196:02 - think it makes sense to organize this a
196:04 - bit
196:05 - better we start with the general updates
196:08 - then we have the input Ander movement
196:11 - and after that we are going to get self.
196:14 - animate with Delta time let's try that
196:18 - one and we are getting an error that we
196:22 - are trying to add together a dictionary
196:24 - with a float let's see what's going
196:26 - wrong and the issue we have is that we
196:30 - are trying to update self. frames this
196:32 - should be self. frame
196:35 - index and there we go we have a player
196:39 - animation that's a start but we do have
196:41 - to refine a couple of things first of
196:44 - all if the player is going to the left
196:46 - all of this should be flipped for that
196:49 - first of all we have to know if the
196:51 - player is going left or right in the
196:52 - first
196:54 - place the best way I find for that is to
196:57 - Simply look at the input method because
197:00 - if the player is pressing right then we
197:02 - know we are facing right so this one
197:06 - should be true however as soon as the
197:08 - player is pressing left then facing
197:11 - right should be false because now we
197:13 - should be facing left after we have all
197:16 - of that we can work once again inside of
197:19 - animate because now we want to update
197:22 - self. image once again the value for
197:25 - this one is going to be self. image but
197:28 - only if self. facing right is the case
197:32 - if that is not the case then I want to
197:34 - flip the current image on the horizontal
197:37 - axis which I do with py game. transform.
197:41 - flip the same method that we have used
197:44 - for the spikes except now we want to
197:46 - flip it on the horizontal axis not the
197:48 - vertical one once again for that we will
197:51 - need three arguments the surface if you
197:53 - want to flip it on the horizontal axis
197:55 - or on the vertical axis in our case the
197:58 - surface will be self. image we do want
198:02 - to flip this one on the horizontal axis
198:04 - so true for this one but not on the
198:06 - vertical one so false here with that
198:09 - let's try main. pi and now if I go left
198:12 - we have inverted the pirate and
198:15 - everything else still works just fine
198:17 - that looks pretty good and already feels
198:20 - significantly
198:22 - better although we are always playing
198:24 - the idle animation for that I want to
198:27 - create one more method get uncore State
198:31 - no need for custom parameters and in
198:33 - there we're going to update the state
198:35 - that determines what animation we are
198:37 - playing for now I want to check if self
198:40 - dot on Surface and I want to check if
198:43 - the player is on the floor if that is
198:46 - the case I want to set self. state to
198:51 - idle but only if self. direction dox is
198:56 - equal to zero if that is not the case
198:59 - else the player should be
199:01 - running I think the logic here makes
199:03 - sense if the player's on the floor and
199:05 - self. direction is zero then the player
199:08 - is idling however if the player is on
199:10 - the floor and direction is different
199:12 - from zero then the player is running all
199:14 - we have to do is before we are animating
199:17 - the player we want to self. get
199:20 - State let's try may not P now and now
199:24 - the player is moving but only if we have
199:28 - horizontal
199:30 - movement although if we are jumping none
199:32 - of that is going to
199:34 - apply after that we can add an else
199:38 - statement where we want to check if the
199:41 - player is on the way wall or just
199:43 - generally in the air which we can do
199:45 - with if any and then self dot on Surface
199:50 - with
199:51 - left or self dot on Surface with right
199:58 - if either of those conditions are true
200:00 - we know that the player is in the air
200:02 - and colliding with a wall if that is the
200:04 - case self do state should be the
200:08 - wall however if we don't have any of
200:11 - these conditions meaning we are in the
200:13 - air but not colliding with a wall then
200:16 - self. State should be jump however that
200:21 - should only be the case if the player is
200:23 - going up if the player is going down it
200:25 - should be fall which means if self.
200:28 - Direction doy is smaller than zero I.E
200:32 - we are going up and we are jumping but
200:35 - if we are going down else then the state
200:38 - should be full and now I already spotted
200:43 - one mistake inside of any we have to add
200:45 - a tupal or a
200:47 - list let's try all of this now and we
200:50 - can still walk around on the floor but
200:52 - once the player jumps we have a jump and
200:54 - a fall animation and after that let's
200:57 - try a wall and that looks really good we
201:01 - have a proper wall slide let's try the
201:05 - other side as
201:07 - well and that looks pretty
201:09 - good we are making loads of progress now
201:13 - there are two more animations that we
201:15 - need to be able to play the ground
201:17 - attack and the Air
201:19 - Attack we do have the animation frames
201:22 - but we have no way to trigger either of
201:24 - them also at the moment we are only
201:26 - going to play these animations they're
201:28 - not actually doing
201:30 - anything first of all inside of the
201:33 - input we need to check for one key that
201:36 - can trigger an attack and let me add a
201:39 - bit more white space in here that feels
201:40 - a bit crammed
201:42 - I want to add one more if statement if
201:45 - keys and py game.
201:48 - Kore I went with the X key so whenever
201:51 - the player presses X we want to attack
201:54 - if that is the case I want to run a
201:56 - method called self do
201:58 - attack that method doesn't exist right
202:01 - now I'm going to create it right below
202:04 - input attack with self no other
202:07 - parameters needed if we are pressing
202:10 - attack I want to do most importantly get
202:14 - some kind of attribute that is called
202:16 - attacking and set this one to through
202:20 - this self. attacking doesn't exist right
202:22 - now so let's create it and I suppose we
202:25 - can do all of that under
202:27 - Movement by default it should be false
202:30 - after we have that I want to work inside
202:32 - of animate the important thing now is
202:35 - that for the animations whenever the
202:37 - player presses attack I only want to
202:40 - attack once after the the animation is
202:42 - done I want to go back to some kind of
202:44 - idle state which means I want to check
202:47 - if self. state is equal to a tag on top
202:53 - of that I want to check and self. frame
202:57 - index is greater or equal than the
203:01 - length of self.
203:04 - frames of the current state so self.
203:07 - state if that is the case self. State
203:10 - should go back to
203:13 - idle I hope the logic here makes sense
203:16 - if the current state is a tack we are
203:18 - checking if the current frame index is
203:20 - greater than the length of the attack
203:22 - animations and if that is the case we
203:24 - are setting the state back to idle
203:27 - however at the moment we don't actually
203:29 - get to this state being attack because
203:32 - remember the attack method only sets an
203:34 - attribute called attacking to true we do
203:37 - not actually update this state for that
203:39 - we want to work inside of get
203:42 - State first of all let's cover the state
203:45 - if the player is on the floor if that is
203:47 - the case we also want to check if self.
203:51 - attacking if that is the case so we are
203:54 - on the floor and we are attacking then
203:56 - self. State should
203:59 - be a tag and the other state we are only
204:03 - checking if that is not the case meaning
204:05 - it's going to be inside of an else
204:07 - statement something similar we are going
204:10 - to do if we are in the air so in there
204:12 - we are going to check if self. attacking
204:15 - and if that is going to be the case then
204:17 - self.
204:18 - state will be the
204:22 - aircore attack and only if we are not
204:25 - attacking meaning else we are going to
204:27 - cover the other
204:29 - states let's now try all of this and if
204:32 - I press X nothing is going to
204:35 - happen and I think I know why inside of
204:38 - the player when we are starting the tag
204:42 - we also want to set self. frame index to
204:46 - zero to understand that one imagine that
204:50 - we are just playing the game normally
204:52 - and frame index is doing something let's
204:54 - say at the moment frame index is five
204:57 - and then we are switching to the attack
205:00 - animation since frame index already is
205:02 - at five we are basically immediately at
205:05 - this
205:06 - stage and as a consequence we go
205:09 - straight back to an idle animation and
205:11 - we can never see the
205:13 - attack to overcome that we are setting
205:15 - self. frame index to zero so that way we
205:18 - are starting the attack animation from
205:20 - frame
205:21 - zero let's try main. Pi now and if I
205:23 - press X we get an attack animation that
205:26 - looks pretty good also if I jump and
205:28 - press
205:29 - X we get something not perfect yet also
205:34 - if I keep on pressing X we get something
205:37 - really
205:38 - weird you might have already spotted the
205:40 - mistake basically I can attack whenever
205:44 - I want but ideally there should be some
205:47 - kind of cool down that we can only
205:49 - attack let's say twice a second which we
205:52 - can do quite easily inside of self.
205:54 - timers I want to have one more entry I
205:58 - call this one the attack block timer
206:01 - which is going to be a timer with a
206:03 - duration of 500
206:06 - millisecs now as soon as we are calling
206:08 - attack I want to activate this timer so
206:10 - self do timers and attack block dot
206:17 - activate on top of that I only want to
206:19 - allow all of that if the attack block
206:22 - timer is not active meaning if not self.
206:27 - attack timers do active basically the
206:30 - logic is going to be we are only able to
206:33 - attack if the timer for the attack block
206:36 - is not active however once we are
206:39 - attacking we are activating this timer
206:41 - meaning this method should only be able
206:43 - to run twice a second or every half
206:45 - second let's try all of this again and
206:48 - now I can keep on pressing X and we
206:51 - always get the full attack animation
206:54 - that looks really good and if I jump
206:58 - there something is going wrong so as
207:00 - soon as I jump we are attacking and
207:03 - that's not ideal the reason for that is
207:06 - that we are never setting self.
207:08 - attacking back to fults as soon as we
207:10 - are pressing it once it will always be
207:13 - activated the way around that is once
207:16 - again inside of animate we want to check
207:19 - all the way at the end if self.
207:21 - attacking is the case and self. frame
207:25 - index is greater than the length of
207:29 - self.
207:30 - frames with self. state if that happens
207:35 - to be the case I want to set self.
207:38 - attacking back to
207:40 - false and now let's try an air attack
207:44 - and we only get one
207:47 - attack that looks pretty good and also
207:51 - if I'm on the
207:52 - floor we only have a single attack and
207:57 - with that we are basically done these
208:00 - are all the animations we need for the
208:01 - player wasn't actually that hard and a
208:03 - bit shorter than I expected although
208:06 - there's one thing I would like to work
208:08 - on and that is if you look at the attack
208:11 - animation for the sword The Grass Is
208:13 - Always in front of it and that looks
208:16 - kind of weird so I'm going to set the
208:19 - grass to be behind the player that way
208:21 - we are solving all of that if you want
208:24 - to challenge yourself this could be a
208:26 - good exercise for you although it's not
208:27 - going to be a proper one basically we
208:30 - want to work inside of the level and the
208:34 - grass is always on the FG layer which we
208:38 - are checking for inside of this match
208:40 - case statement and all we really have to
208:42 - change is FG should be BG tiles if I now
208:46 - run may not pie again the sword is in
208:48 - front of the grass which looks much
208:50 - better now if you want to spend a lot of
208:53 - time on it you could separate the player
208:55 - graphic and the sword graphic so that
208:57 - the player is behind the grass and the
208:59 - sword is in front of it although that
209:01 - would be quite a bit more
209:03 - work in my case I am happy with this and
209:06 - we have covered another important part
209:08 - of the game for the next part let's work
209:10 - on the mve objects and we already have
209:13 - parts of that the platforms that are
209:15 - going up and down are basically done the
209:18 - only thing that we have to do is to
209:19 - animate them that shouldn't be too
209:22 - difficult but on top of that we are
209:24 - going to have a few more objects an easy
209:26 - one would be a boat that is just moving
209:28 - left and right but on top of that we
209:30 - have a saw and much more importantly we
209:32 - have a spike that is going to go in
209:34 - circles for that I will have to cover a
209:37 - bit of trigonometry but it shouldn't be
209:39 - too difficult let's get get started with
209:41 - the easier
209:42 - bits once again we are in the code
209:45 - editor and I want to work inside of
209:47 - level. Pi more specifically inside of
209:51 - setup and in there we already have a
209:54 - couple of moving
209:57 - objects for now the only thing that we
209:59 - are looking at are the helicopter
210:01 - platforms and that's a good start but I
210:04 - am going to have other objects that will
210:06 - move like the helicopter platforms as a
210:09 - matter of fact let's have a look at
210:10 - tiled the only layer that we really care
210:13 - about at the moment are the moving
210:14 - objects so let me hide everything
210:19 - else there we go the two things we have
210:23 - already seen in here are this object and
210:26 - this object both are called helicopter
210:29 - and they are just rectangles with a name
210:31 - and then a couple of additional
210:33 - attributes nothing too difficult but on
210:35 - top of that if you look at the bottom
210:37 - left we have a couple more rectangles
210:40 - and they have similar attributes but a
210:43 - different name they are called saw they
210:45 - are simply there for damage it shouldn't
210:47 - be possible to land on them after that
210:50 - if you look all the way to the right we
210:52 - have a larger rectangle and this one is
210:54 - called Bat although after that we once
210:57 - again have the same
210:58 - attributes the only thing that is
211:01 - noticeably different in here is this
211:04 - object this is called a spike and if you
211:06 - look at those attributes you can see
211:08 - that they are quite a bit different
211:12 - this is the one that we are going to
211:13 - animate with trigonometry and basically
211:16 - this point is going to be the center and
211:19 - we will move the spike around that
211:21 - point depending on what the radius is so
211:24 - the distance from this point is what we
211:26 - are specifying in the attributes but
211:28 - that's going to come much later for now
211:30 - don't worry about it instead I want to
211:33 - cover all of the other platforms and to
211:35 - get started with that one I first of all
211:37 - want to exclude all of the spikes which
211:40 - means if OB j. name is equal to spike
211:46 - then we want to do spikes that's going
211:47 - to come later so pass in there for now
211:50 - and else is going to cover well
211:52 - everything else and there first of all I
211:55 - want to get the frames which ideally I
211:57 - would get via level frames and then the
212:00 - obj do
212:02 - name for that we need to import some
212:05 - graphics if you look at main. Pi in the
212:09 - import function we have to import a few
212:12 - more things once again let me simply
212:15 - copy them in the first one is a saw and
212:18 - this one import folder Graphics enemies
212:20 - saw and
212:21 - animation after that I want to have the
212:25 - helicopter Sprites once again we are
212:27 - simply using import folder finally I
212:30 - want to have the boat images basically
212:34 - most of the time for this we are simply
212:36 - importing all of the images from inside
212:38 - of one folder and I think that's it
212:41 - let's try it actually and for the time
212:45 - being I'm going to comment out all the
212:47 - stuff in there but don't delete it we
212:49 - are going to need it later on I simply
212:52 - want to print all of the frames to make
212:54 - sure that we are covering all of the
212:56 - objects if I now run main. Pi we are not
212:58 - getting an error and instead we are
213:01 - printing all of the surfaces that looks
213:03 - pretty good that's a good start so next
213:06 - up we can work on the logic and for that
213:09 - I want to uncomment the first part of
213:12 - what we have done earlier although we
213:14 - don't need this if obj name is
213:16 - helicopter anymore but I do want to keep
213:19 - the if else logic part thinking of the
213:22 - speed we will need as well and then we
213:25 - will need the moving Sprite so not that
213:28 - much of a change to be
213:29 - honest however these moving Sprites are
213:32 - not animated also we always have the
213:35 - same group which isn't ideal and let's
213:37 - fix that part right away so right below
213:40 - the frame frames I want to have the
213:42 - groups and for the groups we only really
213:44 - have two options either we are in. all
213:48 - Sprites and self. semic collision
213:51 - Sprites and that is the case if obj do
213:54 - properties have the value platform being
213:58 - set to
213:59 - true for that let's have a look at tiled
214:03 - if you for example click on this
214:05 - platform rectangle there we can see
214:07 - platform is ticked and that in the game
214:09 - should mean that the player can land on
214:12 - it however the other objects like the
214:14 - saw don't have this platform ticked if
214:17 - it is not ticked we want to run
214:19 - something else and that is going to be a
214:21 - tual with self. all Sprites and all of
214:25 - these platforms that are not semic
214:27 - collidable should be inside of self.
214:29 - damage Sprites I.E later on they are
214:32 - causing damage to the player with that
214:35 - we have the groups we just have to pass
214:37 - them into the moving Sprites there we go
214:40 - on top on top of that I also want to
214:42 - pass in the frames into the Sprite
214:44 - although for that we have to update the
214:46 - Sprite class that is going to happen
214:48 - inside of Sprites dop all the way at the
214:51 - bottom we have the moving Sprite and
214:54 - first of all we have to give this thing
214:56 - one more parameter frames and this has
214:59 - to be the first parameter now we have to
215:01 - figure out how to actually use all of
215:03 - these frames and ideally we want to do
215:07 - something very similar compared to what
215:08 - we have done in animated Sprite as a
215:11 - matter of fact all of this is going to
215:12 - be so similar that we want to inherit
215:15 - from this class I.E the moving Sprite
215:18 - should inherit from the animated Sprite
215:21 - that means we also have to update the
215:23 - super Dunder in Hidden method first of
215:25 - all though let's remove the surface we
215:27 - have created earlier this one isn't
215:29 - necessary anymore and now we have to
215:31 - figure out the arguments for the parent
215:33 - class we want to initialize this
215:35 - animated Sprite and call this function
215:39 - with these arguments
215:41 - that being said I don't really care
215:42 - about that or animation speed the
215:44 - arguments I care about are position
215:46 - frames and
215:48 - groups we already have the start
215:50 - position and the groups those two can
215:53 - stay exactly the same the one thing that
215:55 - has to change are the frames at the
215:58 - moment we have a surface but this we
216:01 - want to replace with the frames which we
216:03 - can do very easily all we have to do is
216:05 - pass the frames in
216:07 - there after that we also don't want to
216:10 - fill this surface with a white color
216:14 - anymore and just to test all of this we
216:16 - should already have something and there
216:19 - we go we can now see the platforms and
216:22 - they are working although they're not
216:24 - being
216:25 - animated other than that though they're
216:27 - still working just fine and this makes
216:29 - the game feel much
216:31 - nicer also if you go all the way to the
216:34 - right there should be a boat there
216:36 - somewhere
216:37 - now there we go and this is also semic
216:40 - collidable
216:41 - so I can fall through and all of this is
216:44 - working very good the reason why this
216:47 - moving Sprite Now isn't animating
216:48 - anymore is because it has an update
216:51 - method and because of that we are
216:53 - overwriting this update method which is
216:56 - the reason why self. animate is not
216:58 - being called but that we can fix quite
217:00 - easily all we have to do let's do it all
217:02 - the way at the bottom we want to animate
217:05 - this Sprite as well and now we have
217:08 - animations for these platform
217:10 - and that looks very good The Source on
217:12 - the right also work perfectly fine so I
217:15 - am happy with that now if you go all the
217:17 - way to the right and look at the boat
217:20 - let me go really quickly
217:23 - there this boat doesn't animate oh well
217:27 - it kind of does basically inside of this
217:31 - import folder we only have a single
217:34 - surface and this we are looping over so
217:36 - we never go beyond the first image the
217:39 - reason why I went went with that is
217:41 - because all of the other platforms are
217:42 - animated and having the boat as the sole
217:45 - outlier would have caused a bit of extra
217:47 - work which I wanted to avoid cool so
217:50 - with that we have the moving platforms
217:53 - but I do want to do a little bit
217:57 - more let me actually demonstrate if you
218:00 - look at the source on the
218:03 - left I want to indicate where they are
218:06 - going ideally I want to have a couple of
218:09 - dots that show their path so those are
218:12 - the horizontal ones and then those would
218:14 - be the vertical ones for that one I want
218:18 - to check if obj do name is equal to saw
218:23 - on top of that I want to check if the I
218:26 - think I called it move Direction This is
218:29 - the local variable that we have created
218:31 - earlier to check if this moving object
218:33 - is moving left or right or up or down
218:36 - and at the moment we want to check one
218:38 - of these axes let's say we want to check
218:40 - check if this is going left or right if
218:43 - that is the case essentially what we're
218:45 - going to do is we have the rectangle
218:48 - that we are getting from til somewhere
218:50 - on there we are going to have this saw
218:52 - like this on top of that we want to
218:55 - place a couple of dots at a certain
218:58 - distance all throughout this thing
219:00 - something like this first of all we have
219:04 - to figure out the start position that's
219:06 - going to be the left side in the middle
219:08 - of this rectangle and then simply jump a
219:11 - bit further to the right at a certain
219:13 - distance let's start with why first of
219:16 - all for that we still have a start
219:20 - position that we also got earlier this
219:23 - is a tupo from which we want to get the
219:26 - first index meaning we are getting the Y
219:28 - value that if we look at the rectangle
219:32 - again would give us this center line
219:36 - remember the start position is objx and
219:39 - then obj y plus the height divided by
219:42 - two we start at the top of this
219:44 - rectangle and then jump down by half of
219:46 - the height after that I want to specify
219:49 - the left and the right side of this
219:51 - rectangle which I can also do quite
219:53 - easily I want to have the start position
219:56 - zero and then the end position zero once
220:01 - again numbers I getting from up there
220:04 - and finally all I have to do is for X in
220:08 - range I want to go from the left to the
220:11 - right at a certain increment let's say
220:14 - 20 pixels now at this point you do want
220:16 - to be a bit careful because for range we
220:19 - are going to need integers and we are
220:20 - not entirely sure if these numbers are
220:23 - integers or not to make sure that we
220:25 - have integers let's use the int function
220:28 - after that we want to create a Sprite
220:31 - for these dots to show the path of the
220:33 - saw we don't want to animate anything
220:36 - and for the Sprite we need a couple of
220:39 - arguments let me copy all of this and
220:42 - paste it in there first of all for the
220:45 - position this we have done a couple of
220:47 - times already objx and obj
220:51 - doy then we need a surface and that we
220:54 - are going to do in just a second for now
220:56 - let's simply write surface for the
220:58 - groups we simply want to have self. po
221:01 - Sprites and for
221:03 - Z I want to have Z layers and this one
221:06 - should be BG
221:08 - details okay the one thing we don't have
221:10 - at the moment is the surface this we
221:12 - have to import which we are going to do
221:14 - inside of level
221:16 - frames also I want to import this one
221:20 - right below the saw although the
221:22 - specific position does not matter we
221:24 - want to have a saw chain which is a
221:26 - simple image in the same folder as the
221:29 - main saw let me copy that string and
221:32 - then inside of this for Loop we want to
221:36 - use level
221:38 - frames with that key
221:41 - and that should already be a pretty good
221:43 - start let's try now and we have one dot
221:48 - not amazing but at least a start and I
221:51 - think I already know where the issue is
221:54 - we shouldn't be using objx and obj doy
221:57 - we want to use this X and this Y X and Y
222:04 - and now let's try this again there we go
222:06 - this feels significantly better and the
222:09 - s is moving right along that so I'm
222:13 - quite happy however there is a small
222:17 - issue and that is that we are placing
222:20 - the top left of the Sprite however Y is
222:24 - exactly in the center of the rectangle
222:27 - as a consequence when we have our path
222:30 - so this is the rectangle we have
222:31 - outlined in tiled and at the moment y
222:35 - goes exactly through the center line and
222:38 - we are drawing the Sprites basically
222:41 - like this whereas the correct position
222:44 - would be this so we want to move all of
222:47 - these Sprites up by half of the height
222:50 - which we can do quite easily we want to
222:53 - subtract level frames and then get once
222:56 - again the sord chain from that we want
222:59 - to get the height then divide that by
223:03 - two with that we should have a bit more
223:07 - of a center line which I think we yet
223:10 - that looks good that covers the
223:12 - horizontal part next up we are going to
223:14 - work on the vertical
223:16 - one all of that is inside of an El
223:19 - statement and basically we're going to
223:21 - copy most of that and then change some
223:25 - details most importantly the first value
223:28 - will be X for that we need to start
223:29 - position zero and from that we want to
223:33 - subtract half of the Sprites Whi so get
223:36 - whiff from that surface next up we want
223:40 - to specify a top and a bottom although
223:44 - in practice all we are changing is a
223:46 - zero to a one remember once again we
223:49 - already have a start and an end position
223:52 - finally in the end we want to have a for
223:54 - loop with four Y in range from top to
223:59 - the bottom at an increment of 20 pixels
224:02 - and then we want to use the very same
224:06 - numbers let's try all of that and that
224:09 - looks pretty pretty good let's wait for
224:12 - a second but I think this is going to
224:14 - work just fine cool very happy with that
224:18 - with that we have all of the frames
224:20 - besides the spike however there's one
224:22 - thing I realized I just forgot let's run
224:25 - main dop again and go all the way to the
224:28 - right where we have the boat this one
224:30 - doesn't work perfectly right now and let
224:33 - me try to jump on it so I can
224:36 - demonstrate the boat if it is going to
224:38 - the left should be
224:40 - flipping at the moment it's simply going
224:43 - the wrong way for that inside of til if
224:46 - you look at the boat rectangle you can
224:49 - see we have another attribute called
224:51 - flip and this for the boat is
224:54 - ticked that we have to incorporate into
224:56 - our moving Sprite basically if the ship
225:00 - is going to the left then we want to
225:03 - flip the surface that's all that this
225:05 - parameter is for first of all for that
225:09 - when we are creating the moving Sprite
225:12 - we want to add in one more argument
225:15 - which is going to be the object then the
225:17 - properties with flip that is going to
225:21 - give us a Boolean value that can either
225:23 - be true or false which we can capture
225:26 - inside of our moving
225:29 - Sprite first of all we need a flip
225:32 - parameter and let's say by default this
225:35 - one should be false that we also have to
225:38 - store inside of an attribute
225:40 - self. flip is going to be flip finally
225:44 - then after we are calling animate I want
225:48 - to check if self. lip if that is the
225:52 - case I want to update the
225:54 - image which I do with
225:57 - pame do
225:59 - transform dot flip we have done this a
226:03 - couple of times by now we need a surface
226:05 - then we want to get the axis for X and Y
226:08 - the surface and our case will always be
226:11 - self.
226:13 - image however for the other values I
226:16 - want to have a bit of flexibility at the
226:18 - moment we only really have one platform
226:20 - that can flip which in our case is the
226:22 - boat that can only flip left or right
226:25 - but later on maybe we also get some
226:27 - objects that flip on the vertical axis
226:30 - they are not going to be part of this
226:32 - game but you might want to add your own
226:34 - stuff so I want to have all of this
226:35 - being flexible the way I approach that
226:39 - is below flip we're going to create one
226:41 - more attribute self. reverse which is
226:45 - going to be a dictionary with X which by
226:48 - default gets a value of false and then Y
226:52 - which also gets a default value of false
226:56 - finally we want to dynamically update
226:59 - these values for example if we are
227:02 - moving on the horizontal axis then we
227:06 - want to update self. reverse and the x
227:10 - value and basically we want to set this
227:12 - to true if we are moving to the left so
227:15 - if self. direction. x is smaller than
227:19 - zero if that is not the case so else it
227:22 - should be
227:23 - false the same thing we can then do on
227:26 - the vertical
227:28 - axis I want to update self. reverse doy
227:32 - this one should be true if we are moving
227:34 - down so direction do y should be greater
227:36 - than
227:37 - zero after all of that we can go back to
227:41 - py game. transform. flip and then simply
227:44 - add self. reverse with
227:48 - X and self. reverse with Y let me copy
227:52 - it and there we go this should be enough
227:56 - if I now run m not pipe we not getting
227:58 - an error that's a good sign if I now get
228:02 - to the ship in
228:05 - time it should flip around and there we
228:08 - go this works perfect L well let's try
228:11 - it one more time we have to wait a
228:12 - second but it shouldn't be too
228:16 - long and there we go the ship is
228:19 - flipping again and the player can stand
228:21 - on it just
228:22 - fine that is working pretty
228:25 - well and just to make sure this is
228:27 - working for the other platforms as well
228:30 - let me take Flip or the up and down
228:33 - helicopter
228:34 - platform and now you can see as soon as
228:37 - the platform is going down it is is
228:39 - being flipped that's working pretty well
228:42 - although not actually what I want to do
228:44 - which means inside of tiled I want to
228:46 - untake this
228:48 - parameter cool with that we have all of
228:51 - the moving objects besides the spike and
228:54 - this one is going to be quite a bit
228:56 - different and well for all of that we
228:59 - will need
229:00 - trigonometry so let me outline what is
229:03 - going to
229:04 - happen let's start with the basic
229:07 - problem we have a center point and we
229:10 - want to rotate some kind of spiky ball
229:12 - around that IE this ball should move
229:16 - something like this where we always have
229:19 - the same radius from the center
229:25 - point what we have to figure out for
229:27 - that is essentially a
229:30 - triangle like this via this triangle we
229:34 - getting the X distance and the Y
229:37 - distance if we add those two numbers to
229:39 - the center point we are getting to the
229:42 - actual position of the spiky
229:44 - ball all of that happens at a certain
229:48 - angle once we have that system all we
229:50 - need to do to move the ball around is to
229:53 - update the angle and for that we are
229:56 - going to use
229:58 - trigonometry so let's get started here
230:01 - we have a right angle triangle and
230:04 - trigonometry helps us to measure these
230:06 - kind of triangles what right angle means
230:09 - by the way is that one side of this
230:13 - rectangle is 90° which usually is this
230:16 - side here but the specific side doesn't
230:18 - matter so this side is always 90° that
230:22 - is really important if that isn't the
230:24 - case then this is not going to work but
230:27 - in our case we will always work with
230:28 - right angle triangles and what
230:31 - trigonometry is doing is that if we know
230:34 - one angle besides the 90° so if we know
230:38 - this angle or or this angle and we know
230:41 - one side this could e be this side this
230:43 - side or this side then we can get all of
230:46 - the other angles and all of the other
230:49 - sides and this triangle has specific
230:51 - names the X side is called the adjacent
230:54 - the Y side is called the opponent and
230:57 - the radius is called the
230:59 - hypotenuse and we also have 90° I forgot
231:01 - that one now these names you don't have
231:03 - to use when you do the math but when you
231:06 - want to understand websites that talk
231:07 - about this kind of stuff you want to
231:09 - know these names which is why I am going
231:11 - to use them as well now let's talk about
231:14 - what trigonometry actually does here are
231:18 - two
231:19 - triangles they are basically identical
231:21 - so we have 90° on both of them and we
231:25 - have an angle of 30° on the left side
231:28 - the only thing that is different is the
231:30 - hypotenuse this is either 50 on the left
231:32 - side or 200 on the right side so in
231:36 - effect this second triangle is going to
231:38 - be much larger but that isn't really
231:41 - important for our purposes what is
231:43 - really important is that as long as the
231:46 - angle a is 30° the ratio if we divide
231:51 - the opponent by the adjacent will always
231:54 - be the same regardless of the length of
231:56 - the hypotenuse what that means let's say
231:59 - the opponent right now is 50 and the
232:03 - adjacent is let's say
232:06 - 25 if we divide one by the other so 50 /
232:11 - 25 we simply get 2 now at the same angle
232:16 - if the hypotenuse gets larger to 200 in
232:19 - this case obviously the opponent and the
232:22 - adjacent will also get larger however
232:26 - they get larger by the same ratio for
232:29 - example the opponent right now could be
232:31 - 200 and the adjacent would be 100 the
232:36 - specific number here once again does not
232:38 - matter what matters is the relationship
232:40 - between the two because now we get 200
232:44 - divided by 100 which is still going to
232:47 - be two which means that this two here
232:52 - and this two here are the same which in
232:55 - practice means that the relationship
232:56 - between these two sides stays the same
233:00 - they can grow and Shrink as much as they
233:02 - want but as long as this angle is
233:05 - constant they will always have the same
233:07 - ratio to each other and that is super
233:09 - useful because we know that this number
233:12 - here responds to one certain ratio
233:16 - between these two numbers and this ratio
233:19 - is always constant for any angle
233:22 - basically what that means is all we have
233:24 - to do is if we know the hypotenuse we
233:27 - can get the length of o and a or the
233:29 - opponent and the adjacent all we really
233:32 - have to do is convert the angle to a
233:34 - ratio now to convert them we need a
233:37 - couple of special functions and those
233:39 - you probably know
233:41 - already they are called sinus cosinus
233:44 - and tangent functions and all that they
233:47 - are doing is that they convert an angle
233:49 - to a
233:50 - ratio there are three different kinds we
233:53 - can look at sinus or sin is the ratio
233:56 - between the opponent and the hypotenuse
233:59 - cosinus is the adjacent and the
234:01 - hypotenuse and the tangent is the
234:03 - opponent divided by the
234:05 - adjacent for a legend these are the
234:07 - sides I'm talking about and just as a
234:09 - reminder when we are talking about this
234:12 - angle here let's say for Simplicity this
234:15 - could be
234:16 - 30° this means for example for the sinus
234:20 - we have a relationship between the
234:21 - opponent and the hypotenuse and this
234:24 - relationship will stay constant as long
234:27 - as this angle here is constant and now
234:30 - you might be wondering how can you get
234:32 - sinus cosinus and tangent now you could
234:35 - do the math here but that's kind of
234:37 - Overkill literally usally every single
234:39 - calculator and python as well have these
234:42 - formulas included so you don't have to
234:44 - do the math for example here is the
234:46 - windows calculator and if I want to know
234:49 - what sinus of 30° are I have to type 30°
234:54 - then go to trigonometry and then here I
234:56 - have sin cos and tan or sinus cosinus
234:59 - and tangent if I click on sinus we get
235:03 - 0.5 this is all that we wanted to
235:07 - know with that we have the theory but if
235:11 - you are not very good at math this is
235:13 - probably still confusing so let's do all
235:15 - of this in practice and here's one
235:17 - example all the stuff at the top here is
235:20 - just reminders so we have the triangle
235:22 - with have the names of different sides
235:24 - we have hypotenuse adjacent and opponent
235:27 - and the one angle we always know other
235:30 - than that we have the formulas for sinus
235:32 - cosinus and the tangent on top of that
235:36 - what we know so far are these two bits
235:38 - of information we know the angle this
235:41 - one is 30° let me draw it in right now
235:44 - actually so we know this side here is
235:47 - 30° on top of that we know H is 50 so
235:51 - this H here is 50 I guess finally we
235:55 - also know that this other side here is
235:59 - 90° what we want to figure out is the
236:03 - adjacent and the opponent so how could
236:06 - we do that and well well this is going
236:09 - to be your exercise try to figure out
236:12 - what these sides are using these
236:15 - formulas here you will have to rearrange
236:17 - them a tiny bit but this shouldn't be
236:19 - too difficult at least I hope it won't
236:21 - be but pause the video and see if you
236:23 - can figure this one
236:27 - out all right the first question is
236:31 - which of these three formulas we should
236:33 - work with all three of them are using
236:36 - the angle so this isn't use of us now to
236:40 - choose one we basically want to go with
236:43 - the most information that we have so for
236:46 - example tangent a is really bad because
236:49 - this one doesn't have the hypotenuse
236:51 - which we do have so we don't want to get
236:54 - the tangent instead we want to get
236:57 - either the S curve or the cosine curve
237:00 - we actually are going to need both to
237:03 - understand why let me get started by
237:05 - calculating the opponent meaning we are
237:08 - talking about about this site here right
237:10 - now I want to get the opponent for this
237:14 - one I need the sign function inside of
237:17 - there I have my angle a and this is
237:21 - going to be the opponent divided by the
237:26 - hypotenuse this we can already simplify
237:29 - quite a bit for example we know that H
237:32 - is simply going to be 50 we can also get
237:36 - S A all we need is a calculator
237:40 - here we go I want to know what 30° are
237:45 - inside of a sign function and the result
237:48 - is going to be
237:49 - 0.5 that's all I needed meaning this
237:53 - entire thing here is simply
237:57 - 0.5 with that we know that
238:02 - 0.5 is going to be the opponent divided
238:07 - by 50
238:09 - that is going to look like much easier
238:11 - math we can simply rewrite this and
238:14 - multiply both sides by 50 so multiplied
238:18 - by 50 I hope you know what this one
238:20 - means we basically multiply both sides
238:22 - by 50 let me do it in full actually we
238:25 - have
238:26 - 0.5 * 50 is the same as the opponent
238:32 - divided by 50 multiplied by 50 now with
238:37 - this on the right side we are dividing
238:39 - by 50 and multiplying by 50 those two
238:43 - cancel each other out all that is going
238:45 - to be left is the opponent this is all
238:47 - we care about and the opponent is going
238:50 - to be 50 multiplied by
238:52 - 0.5 which means ultimately that the
238:56 - opponent is going to be
239:00 - 25 this number up here is simply going
239:02 - to be
239:04 - 25 I hope this makes sense honestly once
239:07 - you tried a couple of times it is quite
239:10 - simple so next up we have to get the
239:12 - adjacent and if you couldn't do the
239:15 - exercise maybe try again now I hope it
239:17 - makes more
239:19 - sense but for this one we need the
239:22 - cosine because this one is including the
239:25 - adjacent for this one we want to get the
239:29 - adjacent this one is
239:32 - cosine of a and this one is the adjacent
239:38 - divided by the hypotenuse now the
239:41 - hypotenuse once again we know is going
239:44 - to be 50 so let me remove it right away
239:46 - this is going to be 50 for the cosinus
239:50 - of a let me move in the calculator I
239:52 - already have 30 in here and I want to go
239:54 - to trigonometry and get cosine this
239:57 - number isn't as clean we can just write
240:00 - 0.866 that's close enough meaning I can
240:03 - get rid of this cosine entirely and
240:07 - instead write zero
240:10 - 0.866 with that we have a much easier
240:12 - formula to solve all we have to do is
240:15 - multiply both sides by 50 so let me do
240:18 - it properly again I want to multiply
240:20 - both sides by 50 which is multiplying
240:24 - the left side by 50 and on the right
240:26 - side we're getting rid of this divided
240:29 - by 50 at the end we have a is going to
240:33 - be
240:35 - 0.866 multiplied by 50 that is a very
240:40 - easy thing to solve once you have a
240:42 - calculator let me do it on the side the
240:45 - solution here will be
240:50 - 43.3 not 100% correct but for our
240:53 - purposes this is easily good enough and
240:56 - this is going to be the result we now
240:58 - know that the adjacent is
241:02 - 43.3 and that is all we needed we have
241:06 - the X and we have the Y and with that we
241:10 - can get to the drawing although before
241:12 - we get to that I would always recommend
241:14 - to double check your map whenever you
241:17 - try to solve anything like this there
241:19 - are lots of websites that can do
241:20 - trigonometry for you the website that I
241:23 - really like to use is called
241:25 - trigonometry calculator in here you can
241:27 - simply add a couple of numbers and then
241:29 - get the results in our case we know one
241:33 - angle and one
241:35 - side in the bottom you can see what
241:38 - sides they're talking about in our case
241:41 - we know that angle a is 30° so angle a
241:45 - is
241:46 - 30° on top of that we know C is our
241:49 - radius and this was
241:53 - 50° and with that we get site a being 25
241:57 - and site B
241:58 - 43.3 that's the numbers I came up with
242:01 - as well so the math here checks out with
242:04 - all of that out of the way let's once
242:06 - again look at the setup method and more
242:09 - specifically the only thing that we
242:12 - really care about are the moving objects
242:14 - and then obj name equal Spike if that is
242:18 - the case then we want to create a whole
242:20 - new class let's call it Spike now this
242:22 - Spike doesn't exist right now I'll fix
242:25 - that in just a second but first of all
242:27 - we will need a whole bunch of arguments
242:29 - that we can start with right away first
242:31 - of all we want to have a position and
242:34 - this is going to be what we have covered
242:35 - already a couple of times obj dox and
242:38 - obj doy that being said though this
242:41 - would be the top left of the object and
242:43 - I want to place the center of it to fix
242:46 - that I also want to add obj do width to
242:49 - X and obj do height to Y next up we will
242:55 - need a surface and the spike itself is
242:57 - not being animated so we will only need
242:59 - a single surface for that I want to have
243:02 - the level frames and in there in just a
243:04 - bit I want to have a Spike as a matter
243:07 - of fact this we can do right away inside
243:10 - of main.py in import assets I want to
243:13 - add one more entry that's going to be
243:16 - Spike and we want to import only a
243:18 - single image which we are getting from
243:21 - Graphics enemies spike ball and spiked
243:23 - ball once again I have been a bit
243:26 - inconsistent with underscores and spaces
243:28 - but well the path does work in the end
243:31 - after we have the surface we want to
243:33 - have a few more parameters first of all
243:35 - I want to have the radius which I'm
243:37 - going getting from obj do properties and
243:41 - the radius then I can duplicate all of
243:44 - this three times because I want to have
243:48 - the speed I want to have the start angle
243:53 - and I want to have the end
243:57 - angle all of those I get via the
244:00 - properties there we have speed we have
244:03 - the start angle and we have the end
244:09 - and to demonstrate all of this inside of
244:12 - til if you click on the spike ball you
244:15 - can see we have end angle platform radio
244:18 - speed and start
244:20 - Angle now platform for this one we are
244:23 - going to ignore we only really need the
244:25 - other parameters however if we run the
244:28 - code right now we would get an error
244:30 - because this spy class does not exist
244:32 - that we have to fix inside of Sprites I
244:35 - want to create a new class called Spike
244:38 - the parent class should be a regular
244:40 - Sprite and after that I want to have a
244:43 - thunder init method with self and then
244:46 - all of the arguments I just talked about
244:49 - we want to have a position we want to
244:51 - have a surface we want to have groups
244:54 - that's the one I forgot just now we want
244:56 - to have a radius a speed a start angle
245:00 - and end
245:02 - angle finally I forgot the Z
245:05 - parameter although I suppose for this
245:07 - one we could have a default value for Z
245:09 - layers and Main cool those are all of
245:13 - the parameters the one I forgot is
245:14 - groups let's fix that one right away
245:17 - fortunately that is easy to fix groups
245:19 - should Simply Be self. popres and self
245:23 - do damage spres that's about it next up
245:27 - then inside of the spike class we want
245:31 - to turn all of the parameters into
245:35 - attributes let's start with self. Center
245:38 - this one is going to be the position
245:40 - then we have self. radius that is going
245:42 - to be the radius self. speed will be
245:46 - speed let me paste in the last two
245:48 - attributes start angle and end angle on
245:51 - top of that we want to create a few more
245:54 - actually we want to have an angle and
245:56 - this by default is going to be self.
245:58 - start
246:00 - angle this is the angle we are actually
246:02 - going to update later on so basically
246:05 - what we are going to do when we are
246:07 - running the update method with self and
246:09 - Delta time we are updating self. angle
246:13 - by increasing it with self do speed
246:16 - multiplied by Delta time that way this
246:19 - angle keeps on updating and as a
246:22 - reminder we currently have a center
246:25 - point this would be a point like this
246:28 - from that point we want to create a
246:30 - triangle and then on the top right point
246:33 - we want to place the spike ball this
246:35 - would be the actual visible Sprite the
246:38 - position of the Sprite we are going to
246:40 - get via self. angle if we then add
246:43 - trigonometry we would also get X and Y
246:47 - which would give us the position of this
246:49 - point which means we want to call Super
246:54 - and then thunder in
246:57 - it with a position a surface groups and
247:04 - Z position is the only thing that's
247:06 - actually going to be complicated the
247:08 - surface we already have groups we
247:10 - already have and that we also have so
247:13 - position is what we have to work on and
247:15 - this is going to be X and Y and for that
247:19 - we will have to use
247:21 - trigonometry I want to create an x value
247:24 - and I want to create a y value let's
247:26 - start with Y actually so what we want to
247:29 - do we have a triangle and on this point
247:33 - we know the hypotenuse so H is going to
247:37 - to be our
247:39 - radius we have either the radius or the
247:41 - hypotenuse they are the same thing on
247:44 - top of that we have the start angle
247:46 - let's call it Alpha that's what we
247:48 - specified earlier and from all of that
247:51 - we want to get this y distance or this
247:54 - bit to be a bit more specific let's use
247:57 - the formula sin
248:00 - of
248:02 - alpha is equal to the opponent divided
248:08 - hypotenuse or in our case it is going to
248:11 - be y
248:14 - / r or in other words if we are
248:17 - rewriting all of this because we only
248:19 - really care about why we get the sign
248:24 - value of
248:25 - alpha multiplied with r and that is what
248:31 - we actually need to get this wide
248:34 - distance now to make all of that work
248:36 - inside of python to get the sign
248:38 - functions we need from math import sin
248:45 - Co and also we want to have radians by
248:49 - default sin and cosine work with radians
248:52 - not degrees so when we are working with
248:55 - them we want to convert our degrees into
248:57 - radians and that's what this function is
248:59 - for to get why we want to have the sign
249:03 - value of
249:05 - radians of self dot
249:09 - angle and this we want to multiply with
249:12 - self do radius if I bring up the formula
249:17 - again we are doing this part here that's
249:20 - the same
249:22 - thing however at this point you do want
249:24 - to be careful because at the moment this
249:27 - origin point for us in this formula is 0
249:31 - and zero which isn't correct because we
249:35 - want to circle around this Center Point
249:38 - to get that we want to get self. Center
249:42 - and this is a tuple and we want to get X
249:44 - and to that we want to add the value we
249:47 - have just created and that is pretty
249:50 - much it after that we can do X and you
249:54 - can do this part as an exercise for
249:55 - yourself although the answer is actually
249:57 - quite simple we want to get self.
249:59 - center. Z and then the cosine of the
250:03 - angle also I realized for y this should
250:06 - be one because we care about the Y value
250:09 - but that is pretty much it now we have
250:11 - the X and the Y part with that we can
250:13 - run super Dunder in it and we should be
250:15 - good to go which means inside of level.
250:19 - Pi I also want to import this Spike and
250:22 - now run main. pi and there we have the
250:26 - spike ball in some position now this
250:29 - doesn't do very much at the moment but
250:32 - that we can work on next because at the
250:35 - moment inside of the update method we
250:37 - are simply updating the angle but after
250:39 - that we are not using it anymore to fix
250:42 - that we want to get our trigonometry
250:45 - parts once again and simply copy them in
250:48 - there since we are now updating the
250:50 - angle we are getting new X and Y values
250:54 - which we can use to update self. rect
250:58 - and basically we simply want to update
251:00 - the center to the X and Y value if I now
251:04 - run out of this again we are getting
251:07 - actual movement in a
251:12 - circle and that is looking pretty good
251:16 - if you look at s and cosine for a little
251:19 - bit they honestly aren't that difficult
251:21 - with a bit of practice they become
251:23 - fairly
251:24 - straightforward however we are not
251:26 - entirely done yet because I want to have
251:28 - more control over the movement of the
251:31 - spike once again if we are looking at
251:34 - tiled we have an end angle and a start
251:37 - angle and I want to make sure that this
251:39 - spike is moving between them now at the
251:42 - moment the end angle is -1 and I have
251:45 - used that as a short hand to move in a
251:46 - Full Circle however if this one is let's
251:50 - say
251:51 - 180 then the spike should go from zero
251:54 - 280 and then go backwards back to zero
251:57 - to implement something like this we
251:59 - first of all will need a few more
252:02 - parameters most importantly we want to
252:04 - have a direction which by default is
252:06 - going to be 1 and then when we are
252:09 - updating the angle this should be self.
252:12 - Direction multiplied with the speed and
252:14 - Delta time that way we can move this
252:17 - thing forwards or
252:19 - backwards also I want to have self dot
252:22 - let's call it full circle the value for
252:25 - this one will be true but only if self.
252:28 - end
252:31 - angle is equal to -1 if that is not the
252:35 - case else it should be false
252:39 - and after we have that before we are
252:41 - calculating the positions inside of the
252:43 - update method I want to check if not
252:48 - self. full
252:50 - circle then we want to check if self.
252:54 - angle is greater or equal than self. end
253:00 - angle if that is the case self.
253:02 - direction should be -1 on top of that we
253:06 - want to check if self. angle is smaller
253:10 - than self. start angle then self.
253:14 - direction should be
253:17 - one with all of that let's try the code
253:19 - again and now the spike should move back
253:22 - at some point and that looks pretty
253:25 - good and yeah now we get 180° movement
253:30 - which I like quite a bit
253:32 - more that covers the spike class however
253:35 - we are not done with the spikes entirely
253:38 - because at the moment we have a start
253:40 - point and we have the actual Spike but
253:43 - the player doesn't really know where the
253:45 - spike is going to go and to indicate all
253:48 - of that a bit better I once again want
253:50 - to have some kind of chains that connect
253:53 - the spike to the center point for that
253:56 - we can actually reuse the same class
253:58 - although first of all we have to import
254:01 - one more graphic I want to have a spike
254:04 - chain which is in the same folder and
254:07 - called Spike uncore
254:09 - chain inside of level. Pi then let me
254:13 - clean this up just a bit I want to
254:16 - create a four Loop let's call it 4 I in
254:21 - range I want to start from zero and then
254:25 - go up to obj do
254:28 - properties with the
254:31 - radius the step size should be
254:34 - 20 basically what we are going to do at
254:36 - the the moment we only have a single
254:39 - Spike the big one but what we can do
254:43 - inside of this four Loop is to create a
254:46 - similar object with a smaller radius
254:49 - which we are getting via this four Loop
254:51 - and since we can customize this surface
254:54 - we can simply create a spike class with
254:56 - a different surface and a lower radius
254:59 - and then they should all move along with
255:01 - each other which means inside of this
255:03 - for loop I want to create another Spike
255:05 - and for that let me actually copy
255:08 - all of this the position or the center
255:11 - position to be a bit more specific can
255:13 - stay identical Spike does have to change
255:16 - this one should now be the spike chain
255:19 - the one we have just
255:21 - imported the radios also needs to change
255:24 - because this we are now getting from the
255:26 - for Loop this one would be I or actually
255:29 - to be a bit more specific let's call
255:32 - it radius there we want to have the
255:36 - radius the speed the start angle and the
255:38 - end angle all can stay the same however
255:41 - for the groups I want these spikes to
255:43 - only be in all Sprites they should not
255:46 - hurt the player I think that'd be a bit
255:48 - weird finally for this bike I do want to
255:52 - set a custom Z
255:54 - value those should be in Z layers and
255:57 - then BG
256:00 - details that way we always have them
256:02 - behind everything else and now if I made
256:06 - a pie this feels quite a bit
256:09 - nicer and everything else works just
256:12 - fine righty and with that we have
256:15 - covered a really important part of this
256:18 - game now we have all of the moving
256:20 - objects one second while I was editing
256:23 - this video I realized I have made a
256:25 - mistake if you look at level. pi and
256:28 - when we are creating this Spike the
256:31 - position at the moment is wrong we want
256:33 - to place this spike in the center of the
256:36 - object position
256:38 - if this is the square we are getting
256:40 - from til obj dox and Y would give us the
256:44 - top left but instead we want to get this
256:47 - Center Point to get to that point we
256:50 - want to add half the width and half the
256:53 - height of the object I got halfway there
256:56 - I added the object width and the object
256:58 - height but I never divided either by
257:01 - two that fortunately is very easy to fix
257:05 - we divide both by two and now we should
257:07 - have the center of the object and this
257:09 - we also have to do for the smaller
257:11 - spikes so for both of them I want to
257:14 - divide them by two and now if you run M
257:17 - Pi we still get a workable result so
257:20 - that looks pretty good but now the
257:22 - entire thing is just a little bit more
257:24 - accurate next up we are going to work on
257:26 - the enemies and we will have two in the
257:28 - game number one is called to and this is
257:32 - a simple enemy that walks left and right
257:35 - the other enemy is called shell which is
257:37 - well a shell I suppose the special thing
257:40 - about that one is that there's no
257:41 - movement but instead if the player gets
257:43 - close to it then it shoots a pearl and
257:46 - that's basically it neither of these
257:48 - classes get too complicated so let's
257:50 - Jump Right In and once again we have to
257:53 - import a couple of things to get started
257:56 - first of all inside of import assets I
257:58 - want to import a few more Graphics or to
258:01 - be a bit more specific I want to have a
258:03 - key called tooth and then import a
258:05 - folder
258:07 - where we go to Graphics enemies tooth
258:09 - and run and just to show what we are
258:11 - getting if you go to graphics and then
258:15 - to enemies and in there we have tooth
258:18 - there's only a single animation inside
258:20 - of it where we have a couple of run
258:23 - frames that's literally all that this
258:25 - enemy is going to do it's going to run
258:27 - on a platform and then goes either left
258:29 - or right there's no other state I did
258:32 - want to keep all of this simple so with
258:34 - that we have all that we need next next
258:36 - up we have to work inside of level more
258:39 - specifically the setup method and in
258:41 - there I want to add another section that
258:45 - we can call enemies the setup for this
258:48 - one is actually incredibly simple all we
258:51 - want is for obj in TMX map doget layer
258:56 - by name the layer we want to look at is
258:58 - called
259:00 - n on this layer we only really have two
259:03 - kinds of objects and both have a
259:06 - specific name which means I can check
259:09 - objname is equal to
259:11 - to if that is the case I want to create
259:14 - an instance of a to class which is going
259:17 - to get a whole bunch of arguments we
259:20 - want to have a position we want to have
259:22 - a couple of frames we want to have the
259:25 - groups and we are also going to need the
259:28 - Collision Sprites the reason why we are
259:31 - needing the Collision Sprites is imagine
259:34 - we have all the tiles for our level
259:36 - level and it looks something like this I
259:40 - want to place to on a platform and then
259:43 - to is going to run in One Direction and
259:46 - once he reaches a cliff he should turn
259:48 - around until he reaches another Cliff at
259:51 - which point he should turn around
259:52 - again and keep on doing that forever for
259:56 - that to work we have to make sure that
259:58 - Toth has access to the Collision Sprites
260:00 - on top of that inside of til you have to
260:03 - make sure when you're building a level
260:06 - that you placing tooth on top of
260:08 - collision Sprites if you are not doing
260:10 - that you are going to get an error but
260:12 - for example in this case I want to make
260:14 - sure that Toth is running in this
260:17 - direction until he reaches this point
260:20 - and then he runs in the other direction
260:22 - until he reaches this point and then
260:24 - keeps on doing this forever with that we
260:27 - have the basic setup which means we can
260:30 - now create the tooth class which I want
260:32 - to do in a new python file and while we
260:35 - at it we don't need the supported P file
260:38 - anymore instead I want to create a new
260:40 - python file and then save it as enemies.
260:45 - I and there first of all we want from
260:48 - settings import everything and then we
260:51 - can create a class called
260:53 - to which is to inherit from pygame dos
260:56 - sprite. Sprite after that we will need a
261:00 - thunder init method with parameters for
261:03 - all of the arguments I just talked about
261:05 - let me actually copy them right over and
261:08 - once we have that we can pass actual
261:10 - arguments into them position as always
261:14 - is the easiest bit we simply want to
261:16 - have obj dox and obj doy for the level
261:21 - frames we now have our level frames with
261:25 - to for the groups we want to have a
261:28 - tupal with self. B Sprites self. damage
261:33 - Sprites and then we are going to need
261:35 - one more I called those
261:38 - self.to Sprites that way we can get easy
261:41 - access to all of this kind of
261:43 - enemy finally we need to Collision
261:46 - Sprites which we get with self.
261:48 - Collision
261:50 - Sprites nearly done we now have to
261:52 - create a two Sprites class that is going
261:55 - to happen inside of AIT there I want to
261:58 - have two Sprites is equal to py game.
262:00 - sprite. group also while we are here we
262:04 - can import from
262:07 - enemies I want to import to cool with
262:11 - that we have all of the setup out of the
262:13 - way which means we can call Super Dunder
262:17 - in it and then pass in the groups after
262:21 - that I want to store all of the
262:24 - frames inside of an attribute and while
262:26 - we are here I also want to create self.
262:29 - frame uncore index frames is going to be
262:33 - frames and the frame index is going to
262:35 - be zero
262:37 - Z after that we can create the image
262:41 - which is going to be self.
262:44 - frames with self. frame index after that
262:49 - we have to get self. wct which we're
262:52 - getting with self. image.
262:55 - getorf
262:57 - rectangle we only want to place the top
262:59 - left in whatever position we are getting
263:03 - this should be a good place to get
263:05 - started at the very least we should be
263:07 - able to see something although I am
263:09 - already seeing a mistake we need self
263:12 - first of all also the dot after the
263:14 - rectangle shouldn't be there but now if
263:17 - I run m. Pi we are getting an error that
263:19 - tooth object has no attribute Z that
263:22 - does make sense fairly easy to fix self.
263:26 - Z for this one is going to be
263:28 - zore layers and I always want the
263:31 - enemies to be on the main layer now
263:34 - let's try this again
263:37 - and if I go to the enemy position we can
263:41 - see we have tooth that looks pretty good
263:44 - doesn't do anything right now but that
263:46 - we can work on for that though we're
263:48 - going to need a few more parameters
263:50 - first of all I want to get a
263:53 - direction which by default should be
263:55 - either zero or negative 0 and this is
263:59 - going to move to left or right now to
264:03 - get either one of those I want to use
264:07 - the choice method which means I want to
264:10 - have a tup with one and negative one and
264:12 - pass the tupal into the choice method
264:15 - for that I need from random import
264:19 - choice on top of that I want self.
264:23 - Collision uncore rectangles I want to
264:27 - store all of the rectangles from the
264:29 - Collision Sprites which means I want to
264:32 - have sprite. Rec for sprite in Collision
264:37 - Sprites since the Collision for this
264:39 - enemy is going to be fairly simple we
264:41 - don't really need all of the Sprites all
264:43 - that we care about are the rectangles
264:46 - which means with this line we are making
264:48 - the entire class just a little bit
264:50 - leaner cool with that we have a couple
264:53 - of parameters but we don't do anything
264:56 - right now for that we will need update
264:58 - with self and Delta time and in there
265:01 - first of all I want to animate this
265:04 - class which we have already seen couple
265:06 - of times self. frame index plus equal
265:10 - the
265:11 - animation speed multiplied with Delta
265:16 - time after that self. image should be
265:21 - self.
265:22 - frames I want to get an integer of self.
265:26 - frame index with modulus of the length
265:30 - of self. frames let's try the animation
265:34 - if I now go to main.py and run out of
265:36 - this we have a run animation that looks
265:39 - pretty nice after that we can do the
265:43 - actual movement which we do with self.
265:47 - dox plus equal self.
265:50 - direction and then we need some kind of
265:52 - speed let's say for now 200 also
265:55 - multiply all of this with Delta time
265:58 - let's try of that now and there we can
266:00 - see the enemy is moving quite fast but
266:03 - that's not really the point now this 200
266:06 - should be an attribute let's place it
266:09 - right below Collision rectangles self.
266:11 - speed is going to be 200 and now self.
266:17 - speed oh also you might have noticed
266:20 - that if I get the right game if to is
266:25 - moving to the left he is moonwalking
266:27 - which looks kind of funny but is not the
266:30 - intended
266:31 - experience basically if direction is
266:35 - negative then I want to flip all of the
266:37 - frames kind of like we have done for the
266:39 - moving platforms although for this enemy
266:42 - it's going to be quite a bit simpler all
266:44 - that we want to do is if self. direction
266:47 - is smaller than zero I.E we are moving
266:51 - left then self. image is going to be py
266:54 - game.
266:56 - transform. flip with self. image true
267:00 - and false for the horizontal and the
267:03 - vertical axis and now let's try this
267:05 - again again and I hope I get a game
267:08 - where to is moving
267:11 - left there we go now to is facing in the
267:14 - right direction although I suppose
267:17 - having all of this on a single line is a
267:19 - bit cleaner so basically what I want to
267:21 - do his self. image is all of the stuff
267:24 - we have just done but only if self.
267:28 - direction is smaller than zero if that
267:30 - is not the case else we just want to
267:32 - have self. image and with that we are
267:35 - saving a single line of code the last
267:38 - thing we have to do for to is we want to
267:41 - reverse the direction once we're hitting
267:44 - a cliff for that once again imagine that
267:48 - we have a couple of tiles like this and
267:52 - then a couple of other tiles on the
267:54 - lower level what we are going to do with
267:57 - Toth we are going to create two more
268:00 - rectangles one to the bottom right and
268:03 - another to the bottom left and as as
268:05 - soon as one of these rectangles doesn't
268:08 - collide with the Collision rectangles
268:10 - anymore then we know we have reached a
268:13 - cliff for example if this rectangle in
268:15 - the bottom right of the player is in
268:17 - this position then we know that to must
268:20 - be here facing a cliff and as a
268:23 - consequence tooth should be moving to
268:24 - the left for that I want to create a
268:27 - floor wrecked right which is going to be
268:32 - pame do f wct and now we need a top left
268:37 - position for this rectangle and a size
268:40 - the size is fairly simple I want this
268:42 - one to be one and one pixels for the top
268:45 - left I want to get self. rec.
268:49 - bottom right after that we can duplicate
268:52 - all of this and get the floor wreck left
268:56 - the top left of this rectangle should be
268:58 - the bottom left of the tooth enemy and
269:02 - then the size of the rectangle should be
269:04 - negative -1 and one so basically if this
269:08 - is to we are placing the bottom left
269:12 - this point and then go one pixel to the
269:15 - left and one pixel down this is negative
269:18 - 1 and this is one the outcome is going
269:21 - to be a
269:23 - rectangle after that we want to check if
269:26 - either floor wck right or floor wed left
269:29 - is not colliding with any of the
269:31 - Collision rectangles anymore or in other
269:35 - words we we want to check if floor
269:38 - wrecked let's start with the right side
269:41 - and Collide list we want to check a
269:44 - collision with a list of rectangles
269:47 - which we already have so on there self.
269:50 - Collision
269:52 - rectangles if this number is below zero
269:56 - then we know there's no Collision on top
269:59 - of that we want to check and self.
270:02 - direction is greater than zero if that
270:06 - is the
270:07 - case we know that we have no Collision
270:11 - on the right rectangle and we are moving
270:13 - to the right as a consequence we would
270:16 - want to set self.
270:19 - direction to ne1 however this would only
270:24 - cover one side and we can make all of
270:26 - this a bit more elegant which we can do
270:28 - with an aura statement and then on the
270:30 - next line I want to basically duplicate
270:33 - all of this and then cover the logic for
270:35 - the left
270:36 - side I want to check floor W left
270:40 - Collide list with Collision rectangles
270:44 - but then self. direction is smaller than
270:47 - zero if that is the case we know we are
270:50 - moving to the left and we are on a cliff
270:53 - on the left side if that is the case we
270:56 - want self direction to be a one or in
271:00 - other words we want to flip a negative
271:01 - one to a positive one which we can do
271:04 - with multiply equal minus one and well
271:08 - that's basically it this should cover
271:10 - the entirety of the logic if I now try
271:12 - mayor pi and jump on this platform we
271:16 - cannot touch tooth yet but other than
271:18 - that this is working pretty
271:21 - well let's try it a few more times but
271:24 - I'm pretty confident that this is
271:25 - working perfect with that we have the
271:28 - first enemy wasn't that difficult later
271:31 - on we will have to make some more
271:33 - updates but for now this is a really
271:35 - good good start which means next up we
271:38 - can create the other enemy that one's
271:40 - called shell and once again we want to
271:43 - inherit from pygame dos sprite.
271:46 - Sprite this one is going to be the
271:49 - slightly more complex enemy but let's go
271:51 - through it step by step first of all I
271:54 - want to run the dunder init method with
271:56 - self position frames and
271:59 - groups with those we should have
272:01 - everything we need to at least see this
272:03 - enemy first of all we have to call Super
272:06 - Thunder innit with the groups after that
272:10 - we want to get self. frames and self.
272:14 - frame index which like with to are going
272:17 - to be frames and the index zero on top
272:21 - of that we are now going to need a state
272:25 - which by default should be
272:27 - idle and to understand why we need that
272:30 - let's open the graphics folder again we
272:32 - want to go to enemies and there we have
272:35 - have the shell in the Shell we have two
272:37 - states idle and fire idle is a single
272:41 - image and fire is a short
272:44 - animation all of that we have to import
272:47 - and then control inside of the game and
272:50 - to make all of that work we want to get
272:51 - self. image is going to be the frames or
272:55 - rather self. frames but basically the
272:58 - same then self. State and then self.
273:02 - frame
273:03 - index next up we we will have to create
273:06 - self. rectangle which we get with self.
273:09 - image. getet
273:11 - fere on there we want to place the top
273:13 - left to the position and also before I
273:16 - forget again we have to create a z
273:19 - parameter which once again is going to
273:21 - be Z layers in
273:24 - main this should be enough to at least
273:27 - see the shell but we have to import the
273:29 - graphics first of all that's going to
273:31 - happen inside of import Assets in the
273:32 - game class let me copy that one in we
273:36 - want to go one folder up Graphics
273:38 - enemies and shell and really importantly
273:40 - we want to import sub folders like we
273:43 - have done for the player that way we are
273:46 - getting a dictionary with all of the
273:48 - folders as a key the associated value is
273:50 - going to be a list with surfaces which
273:53 - are going to give us our
273:55 - animation and after we have that inside
273:57 - of level. Pi in the setup method I want
274:00 - to check if obj do name is equal to
274:05 - shell if that is the case I want to
274:08 - create one instance of the shell for
274:10 - that let me copy all of the parameters I
274:12 - want to create shell with those
274:14 - parameters position is going to be this
274:17 - one frames are going to be the level
274:21 - frames with
274:23 - shell and for the groups we want to have
274:25 - self. Sprites and self. collision
274:29 - Sprites shell should be collidable I.E
274:32 - the player should be able to stand on
274:34 - top of it
274:35 - and I suppose I should mention the
274:38 - difference here is that to like the
274:41 - player has access to the Collision
274:42 - Sprites but itself is not in that group
274:45 - whereas shell is inside of that group
274:48 - although if I'm not trying to run this
274:50 - code we would get an error for two
274:52 - reasons actually first of all I am not
274:54 - importing shell from enemies so besides
274:57 - tooth I want to import shell however now
275:01 - if I try to run all of
275:03 - this we are getting an error that shell
275:06 - object has no attribute old W this one
275:09 - is required for collisions to work to
275:12 - fix that one after we are creating the
275:14 - rectangle I also want to create self. _
275:19 - rectangle which is simply going to be
275:21 - self. rec.
275:23 - copy let's try all of that and we have
275:27 - collisions also the player can now jump
275:29 - on top of the shell and that looks
275:31 - pretty good however we have an issue we
275:35 - have two shells and each shell has one
275:38 - property called reverse for the shell
275:41 - I'm looking at right now this is not
275:42 - ticked however for the other one this
275:45 - one is which means I want this one to
275:47 - face to the left to make that work we
275:50 - have to update the dunder init method
275:52 - just a bit first of all I have to get
275:56 - the parameter let's call it reverse into
275:59 - this class which happens inside of
276:01 - level. Pi and I want to add one more
276:04 - argument
276:05 - which I'm getting with obj do properties
276:09 - and this one is called reverse which is
276:11 - going to be a bullan value which means
276:14 - we can use it quite simply inside of an
276:16 - if statement if
276:18 - reverse then we want to let's add a
276:21 - commment for Now flip all frames in
276:26 - self. frames or rather for now just in
276:30 - frames however if that is not the case
276:33 - else I simply want to set self. frames
276:36 - to the frames without making any changes
276:41 - and since we are now creating frames in
276:42 - there we don't need this frames
276:45 - anymore now we have to figure out how to
276:48 - go through this dictionary and then flip
276:50 - all of the
276:51 - surfaces the way I approach that is
276:54 - first of all I'm going to create self.
276:56 - frames although for now it's going to be
276:58 - an empty
276:59 - dictionary after that I get for key and
277:03 - surface in
277:06 - frames.
277:07 - items remember key is the name of the
277:10 - animation and surface I suppose I should
277:13 - call the surfaces is going to be our
277:16 - animation inside of this for loop I want
277:18 - to get self. frames the dictionary I've
277:21 - just created and then create a new entry
277:24 - with the name being the
277:26 - key and then after that I want to use
277:29 - list comprehension to flip all of the
277:32 - frames inside of surfaces this is the
277:34 - list with the surfaces we are working
277:37 - with and basically to get started I want
277:40 - to get surface for surf in surface that
277:44 - way we would simply copy the list but we
277:46 - want to flip all of these surfaces which
277:49 - we are once again doing with py game.
277:52 - transform. flip the other Arguments for
277:55 - that are going to be true and false that
277:59 - should already cover it if I now run may
278:01 - not Pi again that worked pretty well now
278:04 - we have a shell looking e to the right
278:06 - or to the left perfect on top of that I
278:09 - want to create one more attribute and
278:12 - that is going to be self. bullet uncore
278:16 - Direction which should not be inside of
278:18 - the for Loop if the shell is facing to
278:21 - the left then this one should
278:23 - be-1 however if it is not then it should
278:26 - be one and I suppose I don't have to
278:28 - explain in too much detail what this
278:30 - parameter does later on if a shell is
278:32 - facing to the right it should only shoot
278:34 - bullets in in that direction now that we
278:37 - have that we have to figure out if the
278:39 - player is close to any instance of this
278:41 - class for that first of all we will need
278:45 - access to the player which is going to
278:47 - be another parameter that we want to
278:49 - store as an attribute self. player is
278:52 - going to be
278:53 - player and then inside of level. Pi we
278:56 - have to pass the self. player in there
278:59 - as an
279:00 - argument and I hope on your monitor you
279:03 - have a bit more space but it might make
279:05 - sense to use named Arguments for this
279:07 - one I want to create another method
279:10 - called State
279:13 - Management inside of this method we want
279:16 - to control the state of the shell and it
279:18 - can either be in an idle state or in a
279:20 - fire state to trigger the fire State we
279:23 - will need three
279:25 - conditions imagine we have the shell and
279:28 - we have the player the shell should be
279:31 - shooting if number one the player is
279:34 - inside side of a certain radius so we
279:36 - need a radius number two the player
279:40 - should roughly be on the same horizontal
279:44 - axis so let's call this one
279:46 - a and finally the player should be in
279:50 - the forward facing direction of the
279:54 - shell I.E if the shell is facing to the
279:57 - right it should only be shooting if the
279:59 - player is to the right of it to make our
280:02 - life a bit easier for this one I want to
280:04 - create two vectors one for the player
280:06 - position and one for the let's call it
280:09 - the shell
280:11 - position for both of those I want to
280:14 - create a vector for the player this
280:18 - should be self.
280:20 - hitbox
280:22 - rectangle do Center this should actually
280:25 - be self. player. hitbox center for the
280:28 - shell this should be a vector self. rec.
280:34 - Center
280:35 - so at this point we have simply created
280:37 - two vectors with the center of the
280:39 - player and the center of the shell not
280:41 - massively important but this is going to
280:43 - make our life quite a bit easier first
280:46 - of all we want to check if the player is
280:49 - near and with vectors all we have to do
280:52 - is get the shell position and then get
280:56 - distance underscore 2 in our case this
281:00 - is going to be the player
281:03 - position if this number is let's say
281:06 - below 500 then we know the player is
281:09 - near and for now to test this let's
281:13 - print if player near then we want to
281:17 - print ler is
281:21 - near also don't forget to run this
281:24 - method which we're going to do inside of
281:27 - an update method self and Delta time and
281:31 - self. State
281:32 - Management if I now run made of Pi we
281:35 - get player is near but if I run away
281:38 - from it this does not update anymore
281:41 - hence it is
281:43 - working next up then we have to check if
281:47 - the player is in front of the shell and
281:50 - if the player is on the same level
281:53 - player. level is I think the easier one
281:56 - let's say in our case I want to make
281:58 - sure that the shell and the player are
282:02 - within 15 pixels of each other
282:05 - or in other words we should be able to
282:06 - go 15 pixels up or 15 pixels down if the
282:12 - player is inside of this range then we
282:14 - consider this variable to be true I want
282:17 - the shell position although I only care
282:19 - about the Y part from that I want to get
282:23 - the player position and once again I
282:26 - only care about why for example let's
282:29 - say the shell wi position is 200 and the
282:33 - player wi position is
282:36 - 190 if you subtract one from the other
282:40 - the end result would be 10 which should
282:44 - be inside of the range so an easy way to
282:46 - get started with this is we want to
282:48 - check if this number is smaller than 30
282:52 - now this would be a good start and it
282:54 - would also work with
282:56 - 210 because in that case the result
282:59 - would
283:02 - be1 which is also going to be below
283:06 - 30 however now imagine the player white
283:09 - position is 300 which would be somewhere
283:12 - down here which would be very much
283:15 - outside of the range but in terms of
283:17 - math we would get 200 minus 300 which
283:20 - would
283:22 - be100 which is also below 30 hence with
283:27 - this system by itself the player would
283:29 - always be considered level if we are
283:32 - anywhere below the shell which isn't
283:35 - ideal the way around that is to turn the
283:38 - result of this subtraction into an
283:41 - absolute
283:43 - number that way this negative 100 would
283:46 - become a positive 100 and be greater
283:48 - than
283:50 - 30 next up then we have to check if the
283:53 - player is in front of the shell and for
283:55 - Simplicity for now let's imagine that
283:57 - our shell is always facing to the right
284:01 - on top of that we have once again a play
284:04 - and let's give them some values we only
284:06 - really care about X let's say for the
284:08 - shell this could be 100 and for the
284:11 - player X could
284:14 - be
284:15 - 200 essentially to know if the player is
284:19 - in front of the shell we want to check
284:22 - if the x value for the shell is smaller
284:24 - than the x value for the player and
284:25 - that's all we need at least as long as
284:27 - the shell is facing to the right so
284:30 - basically we want to check if shell
284:33 - position do X is smaller than player
284:37 - position. X however this we only want to
284:41 - do if self. bullet direction is greater
284:45 - than zero however if that is not the
284:47 - case we want to check the opposite I.E
284:49 - shell position. X is greater than player
284:55 - position. X and that is pretty much it
284:59 - with that we know if the player is near
285:01 - if the player is in front of the shell
285:03 - and if the player is on the same level
285:06 - that means we can update our if
285:08 - statement we want to check if the player
285:10 - is near and the player is in the front
285:14 - and the player is
285:17 - level only if all three conditions are
285:19 - met then we want to do stuff if I run
285:22 - the game player is near does trigger
285:25 - immediately however once I jump it does
285:27 - not trigger anymore and if I am on the
285:30 - wrong side of the shell it also doesn't
285:32 - trigger let's try the other shell
285:34 - and I can jump behind it that doesn't
285:37 - trigger anything but if I go to the left
285:40 - side of it we are getting player near so
285:43 - that is working perfectly fine which
285:45 - means if that is the case we want to
285:47 - update self. state which should now be
285:51 - fire also we always want to play the
285:54 - fire animation from the first index
285:57 - which means we want to update frame
285:59 - index and set it to zero also while we
286:03 - are here there should be a timer the
286:06 - shell shouldn't be able to shoot
286:08 - immediately we only want to shoot let's
286:10 - say every 2 seconds or maybe every 3
286:12 - seconds for that we will need from timer
286:17 - import a
286:19 - timer and let's call this one the self.
286:23 - shoot timer which is going to be a timer
286:26 - with a duration of 3,000
286:29 - milliseconds and then we will need
286:31 - another condition and not self. shoot
286:36 - timer. active once we are shooting I
286:39 - want to activate this timer meaning
286:41 - self. shoot timer. activate quite a bit
286:45 - but now we are getting the right state
286:49 - if the player is in front of the shell
286:51 - although one thing I forgot is we want
286:54 - to get self. shoot timer and updated
286:57 - that way it's actually going to
286:59 - work and once we have all of that we can
287:02 - work on the animations SL attack logic
287:07 - first of all we want to update self.
287:09 - frame index in the usual way plus equal
287:12 - animation speed multiplied with Delta
287:16 - time however next up we couldn't reuse
287:19 - the animation method we have used for
287:22 - the tooth class because once we have
287:25 - played the fire animation ones we want
287:27 - to go back to the idle
287:29 - State and for that we need to know if
287:32 - the animation is finished or not because
287:35 - of that we couldn't use the modulus
287:37 - operator anymore instead we want to
287:40 - check if self. frame index is smaller
287:44 - than the length of self. frames and then
287:48 - self. state if that is the case I want
287:52 - to get self. image and set it to self.
287:56 - frames with self. State and then integer
288:01 - of self. frame in
288:04 - index with that we should actually get
288:07 - already a basic
288:08 - animation and at some point we are
288:11 - starting again cool that looks pretty
288:13 - good and I think I should explain we are
288:16 - always updating the frame index and then
288:19 - we are checking if the frame index is
288:22 - smaller than the amount of frames we
288:24 - have inside of the
288:26 - list if that is the case we want to cyle
288:29 - through that list however once the shell
288:32 - starts to fire we are setting the frame
288:34 - index back to zero because of that all
288:37 - of this is going to play again I suppose
288:39 - what we can do as well is to cover an
288:42 - else statement if that is the case I
288:45 - want to set self. frame index back to
288:49 - zero and on top of that if self. state
288:53 - is equal to fire then I want to set
288:56 - self.
288:57 - state to the idle state with all of that
289:02 - we want to check an action ual fire
289:05 - animation and basically if you are
289:08 - looking at the graphics let me zoom in a
289:10 - bit at some point we want to shoot a
289:14 - pearl and this needs to happen on a
289:16 - specific frame this one to be
289:19 - precise if we are on this Frame of the
289:22 - animation we want to shoot a pearl and
289:25 - then this is moving to the right to make
289:28 - that work we have to check what frame we
289:30 - are on inside of the
289:32 - animation first of all we want to check
289:35 - if self. state is equal to fire on top
289:40 - of that we want to check if the current
289:42 - integer of self. frame
289:46 - index is equal to three also we have to
289:51 - be careful here because during the
289:54 - animation we could be on this index
289:56 - multiple times as a consequence I want
289:59 - to create one more parameter I'm going
290:02 - to call this one self. has underscore
290:05 - fired and I only want to be able to
290:08 - shoot a bullet if we haven't fired yet
290:11 - once we have done that let's say I want
290:13 - to
290:14 - print shoot a pearl and then set self
290:20 - dot has fired to R also at the end of
290:25 - all of this I want to make sure that
290:26 - self do has fired is back to false so
290:30 - has fired is false the last thing we now
290:33 - have to to do in the Thunder init method
290:36 - is we need to create self. has fired and
290:41 - set it to false let's try all of this
290:45 - and now we should be getting shoot Pearl
290:47 - every couple of seconds but only if the
290:50 - player is in front of a shell if the
290:52 - player is on the same level and if the
290:54 - player's in front of
290:55 - it which means for the last part we have
290:59 - to create the actual Pearl and that's
291:02 - going to be a whole separate class
291:05 - let's create it right below the shell
291:07 - class
291:09 - Pearl once again we are going to create
291:12 - a py game. sprite.
291:15 - Sprite the arguments we are going to use
291:18 - to create it are going to be a position
291:22 - groups a surface we want to have a
291:25 - direction and a speed I want to call
291:29 - Super and then Thunder init with the
291:33 - group groups self. image should be the
291:37 - surface and self. RCT should be self.
291:43 - image. getet fct and we want to place
291:46 - this
291:47 - Center and then use the
291:49 - position self. direction should be an
291:53 - attribute and self. speed should also be
291:56 - an
291:57 - attribute finally we need self. Z and I
292:02 - want the pearls to always be on the main
292:07 - layer this should be giving us a pearl
292:11 - but now we have to be careful because we
292:13 - want to create a pearl inside of the
292:15 - level
292:16 - class but the trigger to create a pearl
292:19 - happens inside of the shell which means
292:22 - we have to get some kind of code from
292:24 - the shell into the level. pi
292:27 - class that we are going to do via
292:30 - another method inside of level. Pi I'm
292:33 - going to call it create
292:35 - Pearl for this one we will need two
292:39 - parameters the starting position and the
292:44 - direction and then in there we are going
292:46 - to create a pearl although for that to
292:48 - work we have to import it so from
292:50 - enemies import
292:52 - Pearl and then we have to get the
292:56 - parameters for the
292:58 - Pearl position and direction we going to
293:01 - get via the parameters the groups are
293:05 - going to be self. all
293:08 - Sprites self. damage Sprites and finally
293:12 - I want to have one more group that is
293:14 - going to be called self. Pearl
293:18 - Sprites this group doesn't exist right
293:21 - now let's create it really quick I want
293:23 - to create let me actually duplicate this
293:27 - line self. Pearl
293:31 - Sprites after that we need two more
293:33 - things a surface and a speed the speed
293:36 - we can set to some value that we think
293:38 - looks good I'm going to go with
293:40 - 150 finally we will need a surface and
293:44 - this we're going to import inside of
293:46 - level
293:47 - frames we want to import a single image
293:51 - from Graphics enemies bullets and pearl
293:54 - all of that we are going to store under
293:56 - the Pearl keyword which means for the
293:59 - surface we want to
294:01 - get level frames and then get the Pearl
294:06 - and with that we have one function that
294:08 - can create a pearl and this function we
294:11 - want to trigger from inside of the shell
294:15 - for that to work we want to pass the
294:17 - function in there as an argument self.
294:19 - create
294:21 - Pearl and I think for the shell we need
294:24 - named arguments otherwise this will
294:26 - become confusing we have the
294:29 - position we have the frames we have all
294:33 - of the groups this one was called
294:37 - reverse then we had the player and
294:41 - finally we are going to get one more
294:44 - that we can call
294:45 - create Pearl that looks much cleaner
294:50 - next up then inside of the shell we will
294:53 - need one more parameter and that's going
294:55 - to be the last one create uncore
294:58 - Pearl which we want to store as a
295:01 - parameter self. create Pearl is going to
295:04 - be create Pearl and now when we are
295:09 - shooting inside of the animation so far
295:13 - we only printed shoot Pearl but now we
295:16 - can call self. create Pearl for which we
295:20 - are going to need a position and a
295:23 - Direction so position and direction
295:26 - direction is the easier part because for
295:29 - this one we have a bullet Direction and
295:32 - for the position let's simply use self.
295:35 - rec. Center however I am getting a
295:39 - parenthesis error that happens inside of
295:44 - level. Pi and that is because I missed a
295:47 - square brackets now let's try this again
295:50 - and after a shell is trying to shoot we
295:53 - get name level frames is not defined and
295:56 - you might have spotted the mistake
295:58 - already we only have level frames
296:01 - available inside of the setup method
296:03 - because we are passing it in there right
296:05 - away but that does not apply to create
296:09 - Pearl so this level frames we cannot use
296:13 - and I think the best way around that is
296:16 - inside of the init method I want to
296:19 - create a couple more let's call it
296:22 - frames I want to have self. Pearl
296:26 - surface which I am getting from Level
296:28 - frames and pearl let me simply paste it
296:31 - in there and after we have that we get
296:34 - access to the Pearl surface and now if
296:38 - for try main. P again we are getting one
296:41 - Pearl every couple of seconds let's try
296:45 - the other
296:47 - shell and we get the same result that
296:50 - looks pretty
296:52 - good however the pearls are not moving
296:55 - and well that's going to be a problem
296:57 - for that we have to work a bit more
296:59 - inside of the Pearl class finishing the
297:02 - class is going to be your exercise and
297:05 - there are four parts to it number one I
297:08 - want you guys to give the Pearl a proper
297:09 - starting position number two make the
297:12 - pearls move in the right direction
297:15 - number three is the Pearl should
297:16 - disappear once it hits an obstacle or
297:19 - the player and finally a pearl should
297:22 - also disappear after 5 Seconds that
297:25 - should be quite a bit to work on pause
297:27 - the video now and see how far you
297:32 - get
297:33 - let's get started with the proper
297:35 - starting position for a pearl because at
297:37 - the moment the Pearl starts right in the
297:40 - center of the shell not
297:42 - ideal to fix that we have to update the
297:45 - W position at the moment we are setting
297:48 - the center to the position which is at
297:50 - the center of the shell to update that I
297:53 - want to use a vector and for example
297:56 - move this thing 50 pixels to the right
297:59 - and 0 pixels on the vertical axis if I
298:02 - now try of this again this shell looks
298:05 - about all right however the other one is
298:07 - not going to be looking good because now
298:09 - we on the wrong
298:11 - side although that we can fix quite
298:14 - easily all we have to do is multiply
298:16 - this 50 with the
298:20 - direction let's try this again and that
298:23 - still looks pretty good let's try the
298:25 - other
298:26 - one and that's also looking pretty good
298:30 - neat next up we want to make the Pearl
298:33 - move that's going to happen inside of an
298:35 - update method with self and Delta time
298:39 - all that we really have to do is self.
298:42 - dox plus equal self.
298:46 - direction multiplied with self do speed
298:49 - and multiply it with Delta
298:52 - time let's righty up
298:54 - on and now the pears are moving and
298:57 - there should be another one soon and
298:59 - that's looking pretty good let's try the
299:01 - other one and that's also working next
299:05 - up and this is going to happen inside of
299:07 - the Pearl class I want to create a timer
299:11 - as a matter of fact later on I am going
299:13 - to create multiple timers so I'm going
299:15 - to create a dictionary called self.
299:18 - timers although with only one key for
299:20 - now which I'm going to call Lifetime
299:23 - this is going to be a timer with a
299:25 - duration of
299:27 - 5,000 and this timer I want to activate
299:30 - right away self.
299:32 - timers
299:33 - lifetime I want to activate it after
299:36 - that to make sure all of the timers are
299:38 - working I want for timer in self. timers
299:42 - do
299:43 - values and then timer.
299:47 - update with that the timers are running
299:50 - and as soon as if not self.
299:55 - timers with LIF time do active I.E we
300:01 - are activating this timer when we are
300:03 - creating the class or one instance of
300:05 - the class and as soon as this timer is
300:08 - not active anymore then we want to
300:10 - destroy the Sprite Which we're getting
300:13 - via the kill method let's try all of
300:17 - that and this Pearl should disappear
300:20 - very
300:21 - soon and there we go it disappeared
300:24 - let's try it again just to be
300:26 - sure we are getting another
300:30 - Pearl and cool that looks good finally
300:34 - then we want to make sure that the Pearl
300:36 - disappears once it collides either with
300:39 - the player or with a collidable Sprite
300:42 - and that we could do in two ways either
300:44 - we could pass the player and all of the
300:46 - Collision Sprites into the Pearl class
300:49 - which would be doable but kind of
300:52 - overkill for a single bullet kind of
300:54 - object so instead what I'm going to do
300:57 - is create another method inside of
300:59 - level. Pi which I'm going to call Pearl
301:03 - Collision in there I want to check for
301:06 - sprite in self. Collision
301:10 - Sprites and then I want to get pame do
301:14 - Sprite do
301:17 - Sprite
301:18 - toite for this one we are going to need
301:21 - the Sprite so a single Sprite that we
301:23 - want to check which at the moment is
301:25 - going to be one Collision Sprite this we
301:28 - want to check against the group of
301:29 - Sprites which in our case are going to
301:31 - be our pearls
301:33 - Sprites and finally we want to set our
301:36 - do Hill argument with that logic we are
301:39 - checking every single Sprite inside of
301:42 - the Collision Sprites if that Sprite has
301:45 - a collision with a pearl then we are
301:48 - destroying the Pearl all we have to do
301:50 - inside of the run method is call this
301:54 - self. Pearl Collision method and I want
301:59 - to make sure that I
302:00 - separate the update l iic and the draw
302:04 - logic let's try main. pi and the easiest
302:09 - way to check if this is working is in
302:11 - here and that looks pretty good the
302:14 - Pearl disappears right away although
302:17 - this is only going to apply to the level
302:19 - if a pearl hits the player then it is
302:22 - not going to disappear now that logic we
302:25 - could keep inside of the Pearl collision
302:28 - and if you have done that for now that
302:29 - is totally fine but later on I I want to
302:33 - have a few more objects that can hurt
302:35 - the player which means for all of that I
302:38 - want to have one more method and let's
302:40 - call this one the hit
302:42 - collision and there I want to check for
302:45 - sprite in self. damage
302:48 - Sprites after that I want to check if
302:51 - sprite. w. collide wct with self.
302:56 - player. hitbox
302:59 - rectangle if that is the case I want to
303:02 - print
303:03 - layer damage and on top of that if a
303:08 - bullet is colliding with the player then
303:10 - I want to destroy a bullet and by Bullet
303:12 - I mean Pearl for that we have to be able
303:15 - to identify this Pearl inside of all of
303:18 - the damage
303:20 - Sprites I think the easiest way of doing
303:22 - that is to give it one more parameter
303:25 - self. Pearl is going to be true and then
303:29 - inside of level. Pi in the hit Collision
303:31 - method I want to use has
303:35 - attribute with Sprite and Pearl and if
303:40 - that is the case I want to destroy this
303:43 - Sprite using the kill method and with
303:46 - that after the Pearl Collision I also
303:48 - want to get the hit
303:51 - collisions and now if I try all of that
303:54 - and we're getting hit we get player
303:56 - damage and the Pearl disappears and this
303:59 - works multiple times now at the moment
304:02 - we don't have proper data to store the
304:04 - player Health but that's going to come
304:06 - in the next part for now I think we have
304:08 - made a ton of progress and this section
304:10 - has gotten quite long all righty once
304:13 - again I have forgotten one part and you
304:16 - might have noticed what it is if we are
304:18 - running the game the trth enemy walks
304:21 - left and right just fine so that part
304:24 - Works however if we go to til and move
304:28 - him further down here we would expect
304:32 - this enemy
304:33 - to go up to this point and then to this
304:36 - point and bounce between the two that
304:39 - however doesn't happen because we only
304:41 - check for a cliff we do not check for a
304:46 - wall which means if I now save til and
304:49 - run all of this again we can see that
304:52 - partly the tooth enemy works but there
304:55 - at the wall he just walks right through
304:57 - the wall because we don't actually have
304:59 - Collision checks with the wall we just
305:01 - reverse the direction once we hit the
305:03 - cliff which works reasonably well but I
305:06 - do want to cover the wall case as well
305:08 - for that we have to work inside of the
305:10 - tooth class more specifically inside of
305:14 - reverse Direction and everything else we
305:16 - can
305:17 - ignore the logic for this part
305:19 - fortunately is going to be fairly simple
305:22 - imagine we have the tooth enemy so far
305:26 - we have a floor wck left and right those
305:29 - are a couple of rectangles to the bottom
305:31 - right and the bottom left on top of that
305:34 - I want to create another rectangle that
305:37 - spans the entire width of the enemy plus
305:40 - a pixel to the left and to the right if
305:43 - this rectangle collides with any of the
305:45 - rectangles inside of the Collision rects
305:47 - list then we also want to reverse the
305:49 - direction and that's about it it's not
305:52 - terribly complicated first of all for
305:54 - that I want to create let's call this
305:56 - one a wall rectangle for that we will
306:01 - need P game do F wct once again we are
306:06 - going to specify the top left and the
306:09 - size the size actually is the easier
306:12 - part for the WID I want to get self.
306:15 - rec. WID and then
306:19 - plus two pixels then for the height the
306:22 - number doesn't really matter so let's
306:24 - add a one in
306:26 - here after that we will need the top
306:28 - left for that I will get self. Rec
306:34 - dot top
306:36 - left however to that we have to add a
306:41 - vector in which we go one pixel to the
306:44 - left and zero pixel on the vertical
306:47 - axis that would give us the wall
306:49 - rectangle next up we have to check like
306:51 - we have done for the flow rectangles if
306:54 - there is a collision or to be a bit more
306:56 - specific for the floor rectangles we
306:59 - checked if there wasn't a collision for
307:01 - the wall re angle we want to do the
307:03 - exact opposite if there is a collision
307:06 - we know we have hit a wall but the
307:08 - difference in terms of code isn't that
307:11 - drastic we want to add the wall
307:14 - rectangle and then Collide list we want
307:17 - to check self dot Collision rectangles
307:20 - and if that number is different from -1
307:24 - then we know there's some kind of
307:26 - collision if that is the case we want to
307:29 - turn around and that is it if I now run
307:33 - may not Pi all of this should work just
307:35 - fine so let's have a
307:38 - look and cool that works pretty well and
307:43 - back in tiled let me copy the enemy and
307:46 - paste him up there to make sure both
307:49 - cases are working then back inside of
307:52 - the Cod we can try all of this and that
307:55 - looks pretty
307:58 - solid cool with that we have slightly
308:01 - better enemy Behavior
308:03 - with the enemies out of the way we can
308:06 - work on interactivity meaning the player
308:08 - should be able to attack the enemies and
308:10 - the enemies should be able to damage the
308:12 - player on top of that all of the traps
308:15 - should damage the player and there
308:17 - should be a couple of items that heal
308:18 - the player or at the very least provide
308:21 - some money also to display the health of
308:23 - the pirate I want to display hearts in
308:25 - the top left and if the pirate collects
308:27 - coins then we should display a couple of
308:29 - coins for a short amount of time that's
308:32 - that is going to be a larger section
308:33 - because we have to cover quite a few
308:35 - elements let's get started with the
308:37 - items this is the easier part for that
308:40 - once again we are inside of main.py and
308:43 - we have to go to import assets because
308:45 - we need another set of Graphics we want
308:48 - to have another key called items and in
308:51 - there we want to import subfolders the
308:53 - way that one is going to work inside of
308:55 - Graphics we have items and in there we
308:58 - essentially have five animations so if I
309:01 - open diamonds we have a diamond
309:02 - animation the same for the gold coin and
309:05 - so on this is what we are importing
309:08 - after that we have to work inside of
309:10 - level. Pi more specifically in the setup
309:13 - method essentially in there I want to
309:16 - add another entry for the items and once
309:21 - again this is going to be for obj in TMX
309:24 - map doget layer by name the layer we
309:28 - want to look at is called items and for
309:31 - that one if you look at tiled we have an
309:33 - object layer called items on there we
309:36 - have all of the items should be
309:38 - straightforward also what we're
309:40 - importing here is if you click on one of
309:43 - these objects you can see that they all
309:45 - have a name we have a silver coin a
309:47 - skull a potion a diamond and a gold coin
309:51 - the name matches up with the folder that
309:53 - we have imported and that's important
309:55 - although that's the kind of system you
309:56 - have already seen a couple of times by
309:58 - now I hope it makes sense inside of this
310:01 - four Loop I want to create an instance
310:04 - of an item class which does not exist
310:07 - right now for that we have to work
310:09 - inside of Sprites and let me minimize
310:11 - everything what we want to create let me
310:13 - do it right below the animated Sprite
310:16 - for the simple reason that the item
310:18 - class should inherit from that animated
310:21 - Sprite after we have that we want to
310:23 - create a Dunder init method with self
310:26 - then we will need the item underscore
310:29 - type meaning do we get a gold coin a Sil
310:32 - silver coin a skull and so on after that
310:34 - we will need a position the frames the
310:39 - groups and that's going to be it for now
310:41 - actually although later on we will have
310:43 - to add a bit more after that we have to
310:46 - call the super Thunder init method to
310:49 - make that one work we have to cover the
310:52 - arguments from the parent class most
310:55 - importantly we need position frames and
310:57 - groups Z layers and animation speed I am
311:00 - going to ignore because all of the items
311:03 - should be on this layer and the
311:05 - animation speed shouldn't change hence
311:08 - the default value is totally fine for
311:09 - those and fortunately all three of these
311:12 - parameters are covered by the parameters
311:15 - of the actual class itself so once we
311:18 - are creating one instance of it we
311:20 - should be good to go let's try that
311:22 - actually inside of level. Pi first of
311:24 - all I want to import the item class for
311:28 - the arguments I want to go to the item
311:31 - class
311:32 - and I want to have these four
311:36 - arguments the item type is the easiest
311:38 - one I want to have
311:41 - objname for the position this we have
311:43 - already seen a couple of times obj dox
311:46 - and obj
311:48 - doy the level frames is also fairly easy
311:51 - although what you have to keep in mind
311:53 - for this one is that inside of level
311:56 - frames we have the key items and this
311:59 - one contains another dictionary and only
312:02 - in there do we have all of the
312:03 - animations the way we are going to
312:05 - access those is with level frames then
312:08 - we want to have the
312:10 - items and then in there we have another
312:12 - dictionary and this we can access via
312:16 - objname finally we want to place all of
312:19 - this at least for now instead of self.
312:21 - all
312:22 - Sprites and there we go we have a whole
312:25 - bunch of items that looks pretty good
312:27 - they don't do anything at the moment but
312:29 - that we can work on although before we
312:32 - get to that I want to cover one more
312:35 - thing inside of til we always have one
312:38 - cell and at least inside of tiled in the
312:41 - middle of the cell we have the item but
312:44 - that's not what we are importing into py
312:46 - game what we get from obj position so
312:49 - objx and Y is the top left and the only
312:53 - reason all of these items are in the
312:56 - center of a cell is because they have a
312:58 - special graphic with a ton of white
313:00 - space to each side
313:03 - the actual animation however doesn't do
313:05 - that which means if we imported all of
313:07 - that into pame the item would be in the
313:09 - top left which is not what we want we
313:12 - want to have a bit of an offset in each
313:15 - direction that way we get exactly to the
313:18 - center of the cell and to demonstrate
313:20 - what that actually
313:22 - means let me select one of these
313:24 - graphics and place the
313:26 - goldcoin right there if I now run May
313:29 - notp again you can see that the gold
313:31 - coin coin is kind of in a weird position
313:34 - which I don't really like to fix that
313:36 - part I want to go to level. Pi and then
313:39 - add to the position the tile size and
313:43 - divide it by two that however isn't
313:46 - enough if i r may not buy again we are
313:49 - still not exactly in the center that is
313:52 - because inside of Sprites when we are
313:54 - placing the item we are placing the top
313:57 - left however what we want to place is
314:00 - the center which we can offset right
314:02 - away self. rec. Center is going to be
314:04 - the position and now may not P the coin
314:09 - is exactly in the right position that
314:10 - feels much better all righty next up
314:14 - then I want to store the item type as an
314:17 - attribute so item type is the item type
314:20 - that is important later on to determine
314:22 - what kind of item the player has picked
314:24 - up although at the moment this isn't
314:26 - going to do very
314:27 - much for that to actually make the items
314:30 - do something we have to work inside of
314:33 - the
314:33 - level it will be somewhat similar
314:36 - compared to the Pearl
314:37 - Collision I want to create another
314:40 - method that I'm going to call Item
314:43 - Collision no need for custom parameters
314:46 - on this one and in there we want to
314:49 - check all of the items which at the
314:50 - moment we cannot do because inside of
314:54 - setup we have all of the
314:56 - items simply inside of all Sprites so
315:00 - there's no way to identify all of them
315:02 - easily but that we can change quite
315:04 - easily self dot let's call it item
315:08 - Sprites this group doesn't exist right
315:10 - now but that we can change inside of the
315:12 - dunder init method I want to create item
315:17 - Sprites with that we have easy access to
315:20 - all of the
315:21 - items first of all we want to check if
315:24 - there's any item in the level at all so
315:26 - if item Sprites only then do we want to
315:29 - check if there's an item Collision after
315:32 - that we want to check item Sprites that
315:35 - the player has collided with which we
315:38 - can get with py game. sprite. Sprite
315:42 - cite for that we want to check one
315:44 - Sprite Which is our self.
315:46 - player next up we want to check the
315:48 - collision between this player Sprite and
315:50 - a group of Sprites which in our case is
315:52 - item Sprites and then we want to tell
315:55 - pame to destroy the Sprite that the
315:57 - player has cided with which means this
315:59 - one should be true
316:02 - after this method has run the Sprite
316:06 - will be removed from any kind of group
316:08 - and then stored inside of item Sprites
316:11 - which means we can check if there are
316:13 - any item
316:14 - Sprites if that is the case for example
316:17 - we could print item
316:20 - Collision after that all we have to do
316:22 - is run this method right below self. hit
316:25 - Collision self. item
316:29 - collision and then this should work
316:31 - let's REM at p and we are getting item
316:34 - Collision that looks pretty
316:37 - good what is even better we could
316:40 - actually
316:41 - print
316:43 - item Sprites and this is a list of
316:47 - values from which we only want to get
316:49 - the first one and on there we have an
316:52 - item
316:54 - pipe now if we run main.py we get silver
316:58 - skull potion diamond and then we we also
317:02 - have a gold coin there we go this works
317:04 - perfectly well now with that we could
317:07 - start the actual interactivity in the
317:10 - game but there's one more thing to
317:12 - do mainly if you collide with an item
317:16 - the item simply disappears and that
317:18 - doesn't feel right also if a pearl hits
317:21 - the player nothing happens which I also
317:23 - don't like ideally there should be some
317:26 - kind of particle
317:28 - effect which we can create fairly easily
317:32 - I want to create a class called particle
317:35 - effect
317:37 - Sprite Which once again is going to
317:39 - inherit from animate Sprite we will need
317:42 - a Dunder init method with self a
317:45 - position rames and a group or rather
317:49 - groups to keep a bit more consistent
317:51 - here next up we will need a
317:54 - super ther inage method with the
317:58 - position the frames and the groups all
318:00 - of which we getting from the init method
318:02 - of the class
318:03 - itself also just as before we want to
318:06 - update this Center so self. re. Center
318:10 - is going to be the position that we are
318:12 - getting on top of that I want to update
318:15 - the Z position the particle effect
318:18 - should always be on that layers and FG
318:21 - it should always be on top of everything
318:24 - else after that we will need to
318:27 - overwrite the animate method although
318:29 - for the parameters we still need sell
318:31 - and Desa
318:32 - time so what we have to do inside of
318:36 - animated Sprite we keep on running an
318:38 - animation forever which works in general
318:42 - however for the particle effect we want
318:44 - a slightly different system we want to
318:46 - play the animation once and then destroy
318:48 - the Sprite Which means this logic it
318:51 - doesn't work anymore because this one
318:53 - never stops however the first line still
318:55 - works just fine this one we can just
318:57 - copy and now we want to check if self.
319:00 - frame
319:02 - index is smaller than the length of
319:04 - self.
319:06 - frames if that is the case we want to
319:08 - update self. image which is going to be
319:11 - self. frames with the integer of self.
319:15 - frame
319:17 - index however if that is not the case
319:20 - else I want to destroy the Sprite and
319:23 - that is pretty much it with that we have
319:26 - a particle effect although next up
319:28 - inside of main. Pi we once again have to
319:31 - to import a couple of
319:33 - Graphics what I want to import is this
319:35 - one a key called particle and then
319:38 - folder Graphics effects and
319:41 - particle if you go to Graphics there we
319:44 - have effects and this one only contains
319:46 - a single folder called particle and
319:49 - there we have a very simple particle
319:51 - animation that's the one that we want to
319:53 - use so now inside of level. Pi when the
319:57 - player collides with an item we want to
320:00 - create the particle Sprite effect or
320:03 - particle effect Sprite whatever I called
320:04 - it we first of all have to import it
320:07 - into the level. P
320:10 - class and after that we want to create
320:13 - one instance of
320:15 - it for which we will need a position
320:18 - frames and
320:20 - groups for the position we want to get
320:23 - the item which we already have then get
320:27 - the rectangle of the item and then place
320:29 - the particle in the same Center
320:32 - for the groups we simply want to go with
320:34 - all Sprites also I can get rid of the
320:38 - print
320:39 - statement finally for the frames we have
320:42 - a bit of an issue because the frames are
320:44 - only available inside of the setup
320:46 - method and the dunder init method they
320:49 - are not available inside of item
320:51 - Collision the same problem we had inside
320:54 - of create Pearl for which we created a
320:57 - separate attribute which we want to do
321:00 - again
321:01 - we have a pearl surface and right below
321:04 - I want to have a particle let's call it
321:08 - frames this is going to be level frames
321:11 - and the key for this one is called
321:14 - particle and that we want to use so
321:17 - inside of frames I want to get self.
321:20 - particle
321:22 - frames and that should be it if I now
321:24 - run m not pi and I collide with an
321:27 - item that looks really good let's try it
321:30 - with the gold coin Point as
321:32 - well and yeah we definitely have this
321:35 - one
321:35 - working the same thing we want to do now
321:38 - inside of hit Collision we already know
321:41 - if the player was hit by a pearl after
321:43 - which we are destroying the Sprite but
321:45 - on top of that we want to
321:48 - create a let me copy it a particle
321:51 - effect
321:52 - Sprite although for this one we have to
321:54 - update the position this should be
321:56 - sprite. rec. Center the other arguments
322:00 - are totally fine though let's try this
322:02 - one and now if the play gets hit we have
322:05 - a little particle effect that feels
322:07 - quite
322:08 - nice finally we want to cover the Pearl
322:12 - hitting a wall Collision for that we
322:15 - have Pearl collisions and once again we
322:18 - are running pygame Sprite Collide and
322:20 - this one is going to return the Sprite
322:23 - that has a collision which we can stall
322:26 - inside of an attribute let's simply call
322:27 - it Sprite that one is going to be a list
322:30 - and if if there's anything inside of the
322:32 - list we want to run some code
322:35 - essentially once again let me copy it
322:37 - from the
322:38 - items we want to get the first item from
322:41 - this list so Sprite Zero rec. Center
322:46 - then we have the particle frames and all
322:48 - Sprites that should actually be it
322:50 - although now this is going to be
322:51 - slightly difficult to
322:55 - test but this one definitely works let
322:58 - me jump again and yeah cool with that we
323:01 - have a couple of particle effects which
323:02 - make the game feel much better so
323:06 - finally we can start working on the
323:08 - interactivity and there are quite a few
323:11 - parts that we have to cover first of all
323:14 - the player should be able to attack the
323:15 - tooth enemy and also the pearls in both
323:19 - cases the direction of them should be
323:21 - reversed I.E if the player hits too then
323:24 - to should start walking in the other
323:26 - direction and if the player hits a pearl
323:28 - then the Pearl should reverse for for
323:31 - all of that I want to create another
323:34 - method that I'm going to call
323:37 - attack
323:39 - Collision in there we're going to check
323:41 - the collision between the sword of the
323:43 - pirate when the pirate attacks against
323:46 - the tooth enemies and against the pearls
323:49 - I first of all want to get all of the
323:52 - attackable objects let's call them
323:54 - Target and basically I want to get self.
323:59 - Pearl Sprites
324:01 - and then I want to specify I want to get
324:03 - the Sprites because with that I will get
324:05 - a list that I can add to another list
324:08 - the list I want to add is two Sprites
324:10 - and on there I want to get the Sprites
324:13 - again that is going to give me all of
324:16 - the hitable Sprites after we have that
324:19 - we want to run an if statement with
324:21 - three
324:22 - conditions the first one is if this
324:25 - target is colliding so target. rec.
324:29 - collide rect with self. player. rect and
324:34 - for this one I do want to highlight that
324:36 - we want to use the rectangle remember
324:39 - the hitbox rectangle does not contain
324:41 - the sword this one is only contained in
324:43 - the main rectangle of the player and
324:46 - this is the one that we want to collide
324:47 - with at the
324:49 - moment on top of that we want to check
324:52 - self. player.
324:56 - attacking that is an attribute that we
324:59 - already have I created that one ages ago
325:02 - so far we have only used this one for
325:04 - the animations but we can also use it
325:06 - for the actual attack
325:08 - logic so with that at the moment we are
325:11 - checking if an enemy is colliding with
325:14 - the player sword and if the player is
325:16 - attacking however that is not enough
325:19 - there's one more condition and that
325:21 - would be facing the
325:25 - target the reason why we need this one
325:28 - is imagine we have the player once again
325:30 - again and by default the player is
325:32 - facing to the
325:34 - right if we now have a condition where a
325:37 - Target collides with the rectangle let's
325:39 - say this one could be on the side and
325:42 - the player is
325:44 - attacking which would be fine but the
325:46 - player is attacking to the right
325:49 - direction but without the final
325:52 - condition even this enemy would be
325:55 - affected by the attack which would be
325:57 - very weird now this facing Target we
326:01 - have to create facing Target and for
326:05 - that once again we need to figure out if
326:08 - self. player. rect and we want to look
326:12 - at the horizontal Center if this one is
326:15 - let's say smaller then the target do wct
326:19 - do Center
326:21 - X if that is the case the player is to
326:25 - the left of the enemy we have the player
326:28 - here with some kind of X and we have the
326:30 - the enemy with a center and the
326:33 - important part is that the enemy Center
326:35 - is greater than the player Center so the
326:38 - enemy is to the right but this we only
326:41 - want to check if the player is facing to
326:44 - the right which we can check with an end
326:47 - statement because inside of the player
326:49 - we have self. player. facing uncore
326:53 - right once again we have used that
326:55 - attribute earlier for the animations but
326:57 - we can use it multiple times this would
327:00 - one condition but we want to cover
327:03 - another one with an or
327:05 - statement I want to cover self. player.
327:09 - rec.
327:11 - centerx is greater than
327:15 - target. rec. Center X and not self.
327:20 - player do facing right that should cover
327:25 - both sides with that we know if the
327:28 - player is facing the enemy or not
327:31 - with that we can finish the if statement
327:33 - and at this point we know that the enemy
327:36 - was hit by the player
327:37 - attack which means we can call target.
327:41 - reverse which is what we want to do for
327:43 - both the tooth and the Pearl but this
327:45 - method doesn't exist right now for that
327:48 - inside of enemies we want to create it
327:52 - and I want to create reverse with self
327:57 - and for now let's simply Print Pro for
328:00 - the two and for the
328:01 - Pearl we want to create uh the same
328:05 - method
328:07 - reverse that for now
328:09 - Prince Pearl next up before we forget we
328:14 - also have to call attack Collision which
328:16 - we're going to do right below the item
328:20 - collision and
328:24 - now we can see if I attack we are
328:27 - getting Pearl and if I attack the tooth
328:29 - we are getting
328:30 - too so we definitely detect the
328:34 - attack next up then we have to reverse
328:37 - the direction for either of them that is
328:40 - something we have already kind of done
328:42 - down here we simply want to multiply the
328:45 - Direction with negative
328:47 - one this would work but it wouldn't work
328:50 - consistently let me try actually if I
328:53 - now attack the tooth
328:55 - enemy it works this time but if I try it
328:59 - a couple of times
329:03 - okay this actually works reasonably well
329:04 - but it doesn't work perfectly the reason
329:07 - is when we are running this method we
329:10 - might hit the enemy multiple
329:12 - times I.E this condition might be true
329:15 - multiple times in a very short amount of
329:18 - time because of that the game might
329:20 - register two attacks within 10
329:22 - milliseconds of each other which I want
329:24 - to avoid for that inside of the Toth
329:27 - enemy I want to create a timer let's go
329:30 - call this one the hit timer which once
329:33 - again is going to be a timer with a
329:36 - duration of let's say 250 milliseconds
329:40 - this timer we first of all have to
329:41 - update self. hit timer.
329:45 - update and after we are doing that I
329:48 - only want to reverse the direction if
329:50 - not self. hit timer
329:54 - do if and then once we have reversed the
329:57 - direction I want to activate the timer s
330:00 - do hit timer.
330:02 - activate that way the game shouldn't
330:05 - change fundamentally I can still attack
330:07 - the enemy this one works just fine but
330:10 - now it works just a bit more
330:13 - reliably next up
330:15 - then I want to work on the
330:20 - Pearl this one is going to work in
330:22 - basically the same way which means first
330:24 - of all I want to create
330:27 - a let's call it a reverse timer with a
330:31 - timer that has a duration of 250
330:35 - milliseconds if that timer is not active
330:38 - meaning
330:39 - self.
330:41 - timers and
330:43 - reverse if that is the case self.
330:47 - direction should be multiplied with -1
330:51 - and we want to activate the timer for
330:53 - that let me copy it and then activate it
330:58 - also I'm realizing this should be
331:01 - do active and it should be not active at
331:05 - the
331:07 - moment but other than that this should
331:09 - be it and now I
331:14 - can attack the pearls and they go in the
331:17 - opposite direction that works really
331:21 - well that means next up we can work on
331:24 - highlighting if the player was hit and
331:27 - that we already do to an extent inside
331:29 - of level Pi in hit Collision we are
331:33 - checking if the player was hit and if
331:35 - that is the case we are printing player
331:37 - damage but that obviously isn't enough
331:39 - for an actual
331:41 - game instead I want to get
331:44 - self. layer and then run a method let's
331:47 - call it get damage this one doesn't
331:50 - exist right now so inside of the player
331:53 - I want to collapse all of the methods
331:56 - and then create another one all the way
331:59 - at the bottom yet underscore damage no
332:02 - need for custom parameters and then in
332:04 - there we need a couple of things I
332:07 - suppose for now we can still print
332:11 - player was damaged let's try that and if
332:15 - the player gets hit this still works
332:17 - however if we have a collision with too
332:20 - we are getting multiple collisions and
332:22 - if that happened in the game the player
332:25 - would get basically infinite damage in a
332:27 - very short amount of time simply because
332:29 - we have we have a huge amount of frames
332:32 - to overcome that I want to create a
332:34 - timer inside of thunder in knit we
332:37 - already have a few timers let's call
332:40 - this one the hit timer which has a
332:42 - duration of 400
332:44 - milliseconds and then I only want to run
332:47 - this print statement if not self.
332:51 - timers with hit is active on top of that
332:56 - if the player was hit I want to activate
332:59 - the timer so
333:01 - [Music]
333:04 - activate with that this one should still
333:07 - work just as before that's good and now
333:10 - if I get hit by tooth we only get one
333:13 - actual damage
333:15 - Point perfect that's a good start also
333:19 - while the player is damaged I want to
333:21 - indicate that the player currently gets
333:23 - damaged and for that I want to flicker
333:26 - the pirate the way we are going to
333:28 - approach that is first of all if self.
333:32 - timers and the player currently is hit
333:35 - if that is the case I want to fill the
333:38 - entire surface of the player with a
333:41 - white color and for that we are going to
333:43 - need a mask now I don't have time to
333:45 - explain masks in detail but once again I
333:48 - have made a complete video on it check
333:51 - that one out for more
333:53 - information but essentially we're going
333:56 - to create a white mask which we're
333:59 - getting with Pip game do mask and then
334:01 - from uncore surface this surface we want
334:05 - to look at is self.
334:07 - image this is going to give us a mask of
334:10 - the player or of the player image to be
334:12 - a bit more specific that means that
334:15 - every pixel on this image that is
334:17 - transparent will be black and every
334:19 - pixel that is not transparent will be
334:20 - white as a matter of fact I can
334:23 - demonstrate from this white mask I want
334:25 - to create a white surface which we get
334:29 - with white mask.
334:31 - 2core
334:33 - surface with that we have the silhouette
334:36 - of the
334:38 - player which we want to set as the image
334:40 - so self. image is going to be the White
334:45 - surface after that all we have to do
334:48 - after the animate method we need to call
334:50 - self. licker also I realize I want to
334:54 - check if self. Tim is hit is active and
334:59 - now if I remain not pie and the pirate
335:01 - gets hit we can see for a short amount
335:03 - of time we have the white outlines of
335:07 - the player along with the black pixels
335:10 - wherever we have a transparent pixel
335:12 - inside of the image this is what a mask
335:15 - does although in our case we only really
335:18 - care about the white pixels to get rid
335:21 - of the black ones we want to get the
335:23 - White surface and then set a color key
335:27 - with the black color and now if I of Pi
335:32 - the player is only white for a short
335:35 - amount of time after we get hit and this
335:37 - works both with the pearls and with
335:39 - tooth so that looks pretty good that's a
335:43 - good start although we can refine this I
335:47 - don't want to have a pure white color
335:48 - that is solid I want to flicker this a
335:50 - bit more for that we can once again use
335:53 - the signed function which I want to
335:55 - import from math import sign the reason
335:59 - why that is useful imagine once again we
336:02 - have the triangles we talked about
336:05 - inside of the spike class and we are
336:09 - getting the Y part via this sin function
336:13 - depending on the angle this one gets
336:15 - larger or smaller this is useful because
336:18 - if we have the entire circle with
336:22 - 360° we get a lot of triangles on this
336:26 - for example we could have a triangle
336:28 - right here and then Des sign value would
336:30 - be reasonably small however we could
336:32 - have another triangle that is much more
336:36 - up there and then we would get a much
336:38 - greater y value on top of that we could
336:41 - go negative meaning if we have a
336:43 - triangle down here we would get a
336:46 - negative y
336:48 - value and this always depends on the
336:51 - angle but if you added all of these
336:54 - values together you would get what is
336:56 - called a sign curve that bounces between
337:00 - the values of one and -1 and keeps on
337:04 - doing this
337:05 - forever that we can use basically inside
337:09 - of the flicker method I only want to
337:12 - flicker if the player is hit and if our
337:15 - sine wave value is greater or equal to
337:18 - zero which means and
337:22 - sin of py game. time.get uncore x
337:30 - if that value is greater or equal to
337:33 - zero only then do we want to flicker a
337:35 - player and now if we run this we are
337:38 - getting a whole bunch of flickers and
337:40 - this works multiple times let's try the
337:43 - tooth
337:45 - again cool that works well you can also
337:48 - customize how fast this flickering
337:51 - happens all you have to do is multiply
337:53 - the amount of time let's say If I
337:55 - multiply this with
337:57 - 100 then we get a faster flicker or if
338:01 - you divided it by 100 you can I think
338:04 - see a bit better what's going on now we
338:06 - have a much slower
338:08 - one but in my case I want to keep it at
338:12 - multiplied with 200 is what I think I Ed
338:15 - in the actual game I suppose we can stay
338:18 - with 100 that feels like a good neutral
338:20 - value but once again choose what you
338:23 - like the most here whatever looks best
338:25 - is what's going to work for
338:27 - you perfect with that we you can
338:29 - indicate that the player was hit and
338:32 - with that covered we can come to the
338:34 - actual part where we are storing and
338:36 - updating the health and the coins of the
338:38 - player for that part we already have a
338:42 - problem it might make sense to store the
338:44 - health of the player inside of the level
338:46 - or inside of the player and that might
338:49 - be a good start but it would cause a ton
338:51 - of problems really really fast because
338:55 - later on once we have an Overworld we
338:57 - are going to create new instance
339:00 - of this level class fairly often hence
339:04 - whatever value we are storing in there
339:06 - will not survive once we creating a new
339:08 - instance of a level instead we have to
339:11 - store all of that outside of the level
339:13 - or in some kind of class that we can
339:15 - access quite easily in my case I have
339:18 - created a whole game data class for that
339:22 - I want to create a new python file and
339:24 - let's call it data.
339:26 - piy all we want to do in here is create
339:29 - a class called
339:31 - data and by the way for this python file
339:34 - we don't need py game we simply use
339:37 - basic python to store all of the data
339:38 - there's no py game needed inside of this
339:41 - class I want to have a Dunder init
339:43 - method and then in there we have self.
339:47 - coins which by default is going to be
339:49 - zero and then self. Health which let's
339:53 - say it's going to be five at the start
339:55 - of the game this is going to be where we
339:58 - will store all of our data
340:00 - and then inside of
340:03 - main.py I want from data import the data
340:07 - class and then before we are importing
340:11 - the TMX maps and creating the level I
340:14 - want to create one instance of this
340:16 - class self. data is going to be the data
340:20 - we have just created after that when I'm
340:23 - creating the level I want to pass in
340:26 - self. data
340:29 - that way later on we keep the data
340:32 - inside of the game class and because of
340:35 - that the data does not change when we
340:37 - are changing the level first of all
340:39 - though inside of level. Pi we need one
340:42 - more parameter data which we want to
340:45 - store inside of an attribute self. data
340:49 - is going to be data that however still
340:52 - isn't enough because at the moment we
340:55 - are checking inside of the player if the
340:58 - player has been damaged so in there we
341:01 - want to update the data class for that
341:04 - to work we have to pass data into the
341:06 - player as well that happens inside of
341:10 - setup and more specifically inside of
341:14 - the objects we already have the player
341:16 - in
341:17 - there I want to assign it data to data
341:23 - or self. data to be a bit more specific
341:27 - next up then inside of the play ler we
341:30 - need one more parameter for
341:33 - data that once again we are going to
341:36 - store inside of an attribute self. data
341:38 - is
341:39 - data let's run main.py to make sure
341:42 - nothing went wrong cool the game still
341:45 - works just fine but now we have the data
341:48 - inside of the player and that we can
341:50 - update I want to get self. data and then
341:54 - if the player gets hit update the health
341:57 - part of it and reduce it by one
342:00 - to make sure that this one is working
342:02 - inside of the game class in the run
342:04 - method to be a bit more specific I want
342:06 - to get self. dat and he and print all of
342:11 - that let's run this and we're getting
342:14 - five four if it shoots again three and
342:18 - that looks good and if the player gets
342:20 - hit by two we're getting to two so this
342:23 - also works just fine and by the way if
342:27 - you don't like printing game information
342:30 - there's one more class you might want to
342:32 - check out and that is the debug class if
342:36 - you open this one it's not a terribly
342:38 - powerful class all that we are doing in
342:41 - here is we are getting the display
342:43 - surface then we are creating a surface
342:46 - and a rectangle with some kind of text
342:49 - information and that we are drawing the
342:52 - reason why this one is powerful if
342:55 - inside of main.py you import it from
342:57 - debug you want to support debug you can
343:00 - simply call debug although this has to
343:03 - happen before you call py game. display.
343:05 - update but if you now run it in the top
343:08 - left you can see the amount of Health
343:09 - that we have and this one still updates
343:12 - just fine and that makes it a bit easier
343:14 - to see what's going on in the game which
343:16 - I tend to
343:18 - prefer now this class isn't a necessity
343:21 - but it can be a nice utility feature
343:24 - anyway with that we get our health
343:27 - information on top of that I want to
343:29 - work with the items for that inside of
343:32 - the level I want to have a look at the
343:37 - items that we created all of those since
343:40 - the items are also supposed to update
343:42 - the player data we want to pass data in
343:45 - there as well so self. data as an
343:48 - argument after that inside of the
343:51 - Sprites in the item class we need one
343:54 - more parameter data which we want to
343:57 - store as an attribute self. data data is
343:59 - going to be data after we have that we
344:02 - want to create another method let's call
344:05 - it
344:06 - act fit and then we can check if for
344:10 - example self. item type is equal to
344:14 - let's start with gold if that is the
344:16 - case I want to get self. data and coins
344:21 - and increase this one by
344:23 - five after that I can duplicate this if
344:27 - statement change it to to Silver that
344:30 - one would update the amount of coins by
344:33 - one I can duplicate all of this again
344:36 - next up we want to check for a diamond
344:39 - this one would update the coins by 20
344:42 - and finally we have the
344:47 - skull for which the player would get 50
344:50 - coins finally there's one more item
344:53 - which is the
344:56 - poan this one targets the the health of
345:00 - the player and increases it by one
345:04 - that's all we need inside of this class
345:06 - afterwards inside of level. Pi once we
345:09 - have an item
345:11 - Collision inside of the item
345:16 - collisions we already get the item that
345:18 - we have collided with that's simply the
345:20 - first item inside of item Sprites which
345:23 - means I want to get item
345:25 - Sprites the first item and then active
345:28 - activate that one with that inside of
345:32 - the game right now we have four Health
345:36 - points but if I collide with a potion it
345:38 - goes back to five so that works
345:41 - perfectly well also we can now look at
345:44 - self. dat. coins Run This Again by
345:47 - default the player has zero coins but if
345:49 - I collide with a silver coin and a scalp
345:51 - we get 51 and if I get a diamond we get
345:56 - 71 and if I get the gold coin we should
345:59 - be at 76 and we
346:01 - are all right so with that we have all
346:04 - of the data from the level but we are
346:07 - not really displaying it we are simply
346:09 - using debug to show what number we have
346:11 - but for an actual game once again this
346:13 - doesn't feel right instead I want to
346:17 - create a UI which I'm going to store in
346:19 - a new python
346:21 - file
346:22 - ui. High also we have quite a lot of
346:25 - tabs open we don't need the enemies
346:28 - anymore and at the moment we don't need
346:30 - the groups either first of all inside of
346:33 - the UI I need from settings and import
346:39 - everything after that I want to create a
346:41 - class called
346:44 - UI inside of which as always we will
346:47 - need a Dunder init method inside of this
346:50 - one for now we will need self and we
346:53 - will need a font on top of that we will
346:55 - need a couple of frames those are going
346:58 - to be the hard frames later on that will
347:01 - show the health of the player although
347:04 - first of all we want to get self.
347:07 - displore surface which is going to be py
347:10 - game. display. getor surface with that
347:15 - we can draw on the display surface next
347:18 - up we want to get self. Sprites which is
347:22 - going to be a simple pygame dos sprite.
347:25 - group and after that we want to start a
347:28 - font inside of an attribute f after that
347:32 - there are two things that we
347:34 - fundamentally want to create number one
347:37 - their health or their hearts however you
347:40 - want to call it and number two the coins
347:43 - the hearts are going to be a bit more
347:44 - extensive so let's start with that one
347:47 - first of all for that we want to get all
347:49 - of the hard frames which I want to store
347:51 - in a hard frames
347:54 - list all we need for that are the frames
347:58 - and then I call this one hard now this
348:01 - one we don't have at the
348:03 - moment to overcome that inside of main.
348:06 - Pi in the import assets I don't want to
348:09 - do all of this instead of level frames
348:12 - because these frames should not be
348:14 - inside of the level they should be in
348:16 - the UI hence I want to create self. UI
348:22 - frames which once again are going to be
348:25 - a
348:26 - dictionary the only thing that we really
348:28 - have there is the heart which we are
348:30 - getting with import
348:34 - folder and then we importing Graphics UI
348:37 - and heart a very simple heart
348:39 - animation and that is all we need for
348:41 - now although when we are creating one
348:45 - instance of this class we want to pass
348:48 - in self. UI frames with that we getting
348:53 - the frames and from that we are getting
348:55 - the hard frames later on we are also
348:58 - going to get coin frames but that's
349:00 - going to be an issue for later for now
349:03 - to get started I want to call a method
349:06 - create hearts and by default I want to
349:10 - create five Hearts now this method
349:12 - doesn't exist right now so let's create
349:15 - it create hearts with self and the
349:18 - amount of hearts that we want to create
349:21 - fundamentally all we want to do is for
349:25 - heart in range of the amount of hearts
349:30 - and then we want to create a heart this
349:33 - is going to be a whole separate Sprite
349:36 - class which we can create inside of the
349:38 - UI python file class heart right below
349:43 - although technically this is going to be
349:45 - a Sprite so you could also place it
349:47 - inside of Sprites it doesn't really make
349:49 - a difference that being said though
349:52 - since the heart is going to be animated
349:54 - I want to inherit from the animated
349:56 - Sprite Which means in inside of UI I
349:59 - want from Sprites import the animated
350:03 - Sprite that is going to be the parent
350:05 - class of the heart after that I want to
350:08 - create a Dunder init method with self a
350:11 - position frames and groups all of these
350:15 - parameters we can use right away inside
350:18 - of super Dunder init to initialize the
350:20 - parent class and there as always we are
350:23 - passing in the position the frames and
350:24 - the groups that being said though the
350:27 - animation for this heart is is going to
350:28 - work just a little bit different but
350:30 - that's going to be an issue for later
350:32 - but now I simply want to create a heart
350:35 - for which we will need the free
350:36 - parameters position is going to be X and
350:40 - Y which we are going to cover in just a
350:42 - second after that for the frames we want
350:45 - to have self. hard frames and the group
350:49 - is going to be self. Sprites before we
350:52 - can continue we will need x and y y is
350:57 - going to be simply 10 pixels I should
351:00 - explain by the way if this is our window
351:04 - I want the hearts to be in the top left
351:06 - let's say one here one here one here and
351:09 - so on at the moment I have specified the
351:12 - Y part and we are always specifying the
351:14 - top left at the moment we have an offset
351:17 - of 10 pixels from the top for X we will
351:20 - need a bit more Logic the first heart
351:23 - should be 10 pixels from the left the
351:26 - second heart should be a bit further to
351:28 - the side and have a bit of padding to
351:30 - the next heart although to get started
351:33 - we could use the number 10 plus the hard
351:37 - multiplied by 50 hard in this case is
351:41 - going to be an integer that goes from 0
351:43 - to four or in other words we're going up
351:46 - to five but we don't include
351:49 - five and this is going to give us a new
351:51 - x
351:52 - value after we have all of that we will
351:56 - still need for the UI class something
351:58 - like an update method or display method
352:01 - and there for now we simply want to call
352:04 - self. Sprites do draw and we want to
352:07 - draw on self. display surface also we
352:11 - want to update all of the Sprites so
352:13 - self. Sprites do update with Delta time
352:17 - after we have all of that inside of
352:19 - main.py we have to import this UI class
352:23 - so from UI import
352:26 - UI and then right before the data I want
352:30 - to create an attribute called UI for
352:34 - this one we will now need a font and a
352:37 - couple of frames the frames we already
352:40 - have but the font we
352:42 - don't we can fix that in just a second
352:45 - for now let's simply say self. font and
352:47 - after that self. UI frames now the font
352:51 - doesn't exist but that we can fix fairly
352:53 - easily before we are getting the UI
352:56 - frames self. f
352:58 - to create a font we need py game. font.
353:02 - font with a font type and a font size
353:06 - the font size in my case is going to be
353:08 - 40
353:09 - pixels and the path to the font we're
353:13 - getting via the join method we want to
353:16 - go up a folder we want to go to Graphics
353:20 - we want to go to UI and in there we have
353:23 - a file called
353:25 - RuneScape uncore f.
353:30 - ttf and with that we should have a UI
353:33 - class and I realized for the data class
353:37 - the self. UI frames shouldn't go in
353:39 - there let's try all of this and this is
353:42 - working pretty well or at the very least
353:45 - the game isn't
353:46 - crashing after that inside of the run
353:50 - method after we are displaying all of
353:53 - the current stage I want to get self. UI
353:57 - and then up
353:59 - the entire class with Delta time if I
354:02 - now run this we getting a whole bunch of
354:04 - Hearts they're not updating with the
354:06 - health of the player yet but at the very
354:09 - least we have something but on top of
354:12 - that they also update continuously which
354:14 - I don't really like it feels too generic
354:17 - I know it's hard to describe it just
354:18 - doesn't look good now you could be a bit
354:21 - lazy and simply use a lower number let's
354:24 - say something like 20 now if we run this
354:26 - that feels quite a bit better and also
354:30 - if I don't run the debug method you can
354:32 - actually see what's going on now on the
354:34 - top left we have all of the hearts and
354:36 - that's a good start but I want this
354:39 - system to be a bit more
354:42 - flexible essentially before we are
354:45 - creating the hearts I want to get self.
354:49 - heart
354:51 - surface
354:53 - Wii which we get with self. hard frames
354:57 - we want to get the first index which is
355:00 - going to give us one surface and from
355:02 - this we want to get the Wii on top of
355:05 - that I want to get self. hard heading
355:10 - which I've have set to five this is
355:12 - going to give us the amount of space
355:14 - between the hearts and the five I have
355:17 - chosen because it looks good if you like
355:19 - another number just go with that and
355:22 - after that we do want to keep the 10 as
355:25 - the starting value but instead set of
355:29 - hard * 20 I want to get the heart and
355:32 - multiply it with self do
355:34 - hard surface
355:37 - Wii plus self. hard heading just for
355:42 - some numbers the first four Loop is
355:46 - going to give us a heart of zero which
355:49 - means all of this is going to be zero
355:52 - the second heart however is going to
355:54 - give us a value of one then let's say
355:58 - the heart surface has a width of 18
356:01 - pixels and the hard padding is five so
356:04 - the result is going to be 1 *
356:07 - 23 that number means we are placing this
356:11 - hard 23 pixels further to the right than
356:14 - the previous heart and since the
356:16 - previous heart has a width of 18 pixels
356:18 - there's a gap of five pixels that should
356:21 - be all we need if I now run of this
356:23 - again that looks pretty all right if we
356:26 - increase the padding to something ridic
356:27 - ridiculous let's say 20
356:29 - pixels We Get Much More spacing between
356:33 - them let's try maybe six to see how that
356:37 - looks yeah I feel that looks about right
356:40 - but once again play around with the
356:41 - numbers to see what you like next up
356:44 - though I want to work a bit more inside
356:47 - of the heart I want them to only
356:49 - occasionally animate we get that system
356:52 - to work I want to create another
356:54 - attribute self. active which by defa
356:57 - default is going to be false after we
357:00 - have that I want to create an update
357:02 - method with self and Delta time if the
357:06 - class is
357:08 - active then I want to call some kind of
357:10 - self. animate method with data time this
357:13 - animate method we're going to create in
357:15 - just a second we already have one inside
357:19 - of the animated Sprite class but in just
357:21 - a second we are going to create our
357:24 - own however if that is not the case so
357:28 - else then I don't want the heart to
357:30 - animate however while the heart isn't
357:33 - animated there should be some kind of
357:35 - timer and if the timer runs out the
357:37 - heart should start to animate again now
357:40 - for all of that we could use an actual
357:42 - timer but that's a bit of an Overkill an
357:45 - easiest system would
357:46 - be from random import Rand in and then
357:53 - inside of the El statement if Rand in
357:56 - let's say from zero to
357:59 - 2,000 I.E we are generating random
358:02 - numbers between these two values if that
358:05 - value is equal to one then we want to
358:08 - set self. active to
358:11 - R since that case is fairly unlikely it
358:14 - will take some time hence we get a timer
358:18 - now this timer is not perfect because it
358:20 - is not frame rate independent that being
358:23 - said in our case the difference between
358:25 - the frame rates shouldn't be that great
358:27 - so this system is basically all right
358:30 - after that we want to create a custom
358:33 - animate method with self and Delta
358:37 - time once again we want to update a
358:40 - frame index which we're getting from the
358:43 - animated Sprite parent class this one we
358:46 - want to update with animation uncore
358:50 - speed multiplied with Delta time and
358:54 - after that if self. frame index is
358:58 - smaller than the length of self.
359:02 - frames then we want to update the image
359:05 - so self. image is going to be self.
359:09 - frames with the integer of self. frame
359:14 - index however if that is not the case so
359:17 - we have finished the animation then we
359:19 - want to set self. active to
359:23 - BS and we want to set
359:25 - self. frame in index back to
359:30 - zero that should be all we need for now
359:33 - if I now run m.p again the hearts should
359:36 - only animate once in a while and there
359:38 - you can see we have the occasional
359:40 - animation but it doesn't happen
359:42 - constantly anymore which I think looks
359:44 - quite a bit better that covers the heart
359:48 - class and next up we can actually make
359:51 - this system interactive I.E make the UI
359:55 - work along with the data class all that
359:57 - we really want to do for now if the
360:00 - amount of Health inside of the data
360:01 - class changes then we want to change the
360:04 - amount of hearts that we have inside of
360:06 - the UI for that the data class needs to
360:09 - have access to the UI which we can do
360:12 - fairly easily when we are creating the
360:14 - data class I want to pass in self. UI
360:18 - for that to work we will need one more
360:20 - parameter UI which we want to store as
360:23 - an attribute right away UI is going to
360:26 - be UI
360:28 - so now we have another issue we want to
360:32 - call a method on this UI class if the
360:34 - value of Health changes and the way to
360:37 - approach that is by creating a Setter
360:41 - and a getter method which is quite a
360:43 - powerful system that you can use in
360:45 - Python although for that to work you
360:47 - have to understand decorators at least
360:49 - in a very basic sense once again I have
360:52 - made a whole separate video on the topic
360:54 - which can get a bit more complicated so
360:57 - I am not going to go into too much
360:59 - detail but basically what we are going
361:01 - to do the health we have so far worked
361:03 - with is going to become a private
361:06 - attribute it should only be available
361:08 - inside of this class which we indicating
361:11 - via an underscore although this
361:13 - underscore here is just a convention to
361:15 - tell other programmers that this
361:18 - attribute is only available inside of
361:20 - the class and shouldn't be available
361:22 - from the
361:23 - outside however now if I run may. pi and
361:26 - we're trying to use this one we get data
361:28 - has no attribute Health did you mean
361:30 - underscore health and well not really
361:34 - instead what we want to do is we want to
361:37 - replace this Heth with a Setter and a
361:39 - getter
361:40 - method those are essentially going to
361:43 - replace the health attribute first of
361:45 - all whenever we want to read the health
361:48 - attribute we want to create a property
361:52 - and then create a method that has the
361:55 - same name Health this this one is just
361:58 - another method so we will need a
362:00 - parameter with self inside of the method
362:02 - we want to return self. uncore Health
362:07 - whenever we are trying to read the
362:09 - health attribute we are returning the
362:12 - value of the underscore Health
362:15 - attribute as far as anything from
362:17 - outside of the class is concerned health
362:19 - and underscore Health are the same but
362:21 - internally in the class they are
362:23 - different and this would for example
362:25 - allow us to do literally anything else
362:28 - before we are returning the value for
362:30 - example we could print Health was red
362:34 - but that we don't want to do instead we
362:37 - want to create a Setter class which we
362:40 - do with at and then health.
362:44 - setter this once again is going to be
362:46 - another method that we're going to call
362:48 - Health this one will need one parameter
362:51 - for S and then another for the value
362:55 - inside of this method we are are
362:57 - actually updating the health attribute
363:00 - and we are setting it to the value now
363:03 - once we have all of that we have
363:05 - replaced the health attribute with a
363:08 - getter so we can read it and a Setter so
363:11 - we can update it and with both of those
363:14 - before or after we are updating the
363:16 - value we could run any other code but
363:19 - first of all let's see if this one is
363:21 - working in the first place and we still
363:24 - get no errors let me try to collide with
363:28 - it too that works pretty well and also
363:32 - we can read the
363:33 - value I.E we could print self. dat.
363:39 - health and run all of this and we get
363:42 - the very same outcome so that works
363:44 - pretty well however what we can now do
363:47 - is whenever we are printing the health I
363:49 - want to print Health was red and now if
363:53 - I run main. Pi we get health was red
363:57 - whenever we are printing the health but
364:00 - that once again is not the part that we
364:01 - care about instead what we care about is
364:05 - whenever we updating the health we want
364:07 - to call something on the UI self. UI and
364:11 - what we want to call is create
364:13 - underscore Hearts the method that we
364:16 - actually already have basically what we
364:19 - are going to
364:20 - do when we are calling the method we
364:22 - will create a new amount of hearts and
364:25 - before we are doing that we we going to
364:27 - get rid of all of the previous Hearts
364:30 - meaning before we are creating all of
364:31 - the hearts I want for sprite in self.
364:36 - Sprites and then destroy all of the
364:40 - Sprites that way when we have an update
364:44 - to the data class we want to create
364:47 - hearts with our VI
364:52 - value inside of UI then we are going to
364:55 - call this create heart method get rid of
364:58 - all of the previous hearts and then
365:00 - create new hearts with the right amount
365:03 - with that if I run main of p and we get
365:06 - hit one heart disappears and a second
365:09 - heart disappears and if I hit to another
365:12 - heart disappears cool so this one is
365:15 - working also when we are starting the
365:19 - game this create Hearts shouldn't be
365:22 - there let me remove it instead inside of
365:25 - the data class when we are initializing
365:28 - all of this I want to get self. UI and
365:32 - create hearts with self. uncore
365:36 - health with that inside of may. Pi we
365:39 - get the same starting amount although
365:42 - now we are keeping all of the actual
365:45 - health information inside of the data
365:48 - class cool next up we have to work on
365:51 - the coins which is going to be a fairly
365:54 - similar system as a con consquence this
365:57 - part is going to be your exercise when
366:01 - the player collides with a coin then
366:03 - display the amount of coins the player
366:04 - has in total for a short amount of time
366:07 - let's say one second pause the video now
366:09 - and see how far you
366:14 - get for all of this you could approach
366:16 - this in a few different ways and I hope
366:18 - you experimented but in my case I
366:22 - created first of all self. coin mount
366:27 - which by default is going to be zero
366:29 - also then we have self. coin timer which
366:33 - is going to be a timer with a duration
366:35 - of 1
366:36 - second this timer doesn't exist right
366:39 - now so we have to import it from timer
366:41 - import timer after that we don't need
366:45 - the hearts anymore I want to create
366:47 - another method that I will call display
366:51 - uncore text for now I simply want to
366:54 - create a text uncore surface
366:57 - with self. font. render where we are
367:01 - going to display self. coin amount
367:04 - although this has to be a string so Str
367:07 - Str after that I don't want to analias
367:11 - the text and then we are going to need a
367:13 - color let's say for now I want to use
367:16 - white next up we will need a text uncore
367:20 - rectangle which we get via the text
367:23 - surface and then
367:25 - getorf rectangle
367:27 - I want to place the top
367:30 - left the position I went for is going to
367:33 - be 16 and 34 finally after we have all
367:38 - of that self. display surface. blit with
367:41 - the text surface and the text
367:45 - rectangle if we now call self. display
367:50 - text we should see at least some text
367:53 - and there we can see a zero and this one
367:55 - doesn't update at the moment so it's a
367:58 - start but not a
368:00 - deal to make that work better we have to
368:03 - update this coin amount whenever inside
368:07 - of data we are updating the coins for
368:10 - that I want to create another method
368:13 - let's call it show points this one is
368:17 - going to get one amount parameter in
368:20 - there I want to update self. coin amount
368:23 - to the amount that we get and after that
368:26 - inside of that Pi I want to turn the
368:30 - coins into an underscore coins and then
368:33 - do basically the same thing I have done
368:35 - for the health so let me copy all of
368:37 - this and this should be coins when we
368:41 - are reading the coins attribute I simply
368:43 - want to return underscore coins however
368:46 - when we are trying to update that value
368:49 - I first of all want to update the amount
368:51 - of coins to the value that we
368:53 - get but after that inside of UI I want
368:56 - to show the coins I think I called it
369:00 - yeah show coins and then pass in the
369:02 - value with that we are updating the
369:05 - value of self. coin amount and that in
369:08 - turn should update whatever we are
369:10 - displaying let's try this one now and I
369:13 - getting an error that I need to update
369:16 - all of this to coins. Setter so now
369:18 - let's try this again and if I pick up a
369:20 - silver coin we get one if I pick up the
369:23 - gold coin we should get to six and I die
369:26 - died let's try this
369:28 - again we should get 251 and we should
369:32 - get yep that looks good
369:34 - 271 meaning now all of the coins are
369:38 - being displayed properly that looks good
369:41 - but I don't want to display them
369:42 - constantly so inside of the game I don't
369:45 - think there's much of a point to always
369:46 - display the amount of coins that the
369:48 - player has you could do it but it
369:50 - doesn't feel
369:52 - right the way I get around that is as
369:55 - soon as we are showing the coins I want
369:57 - to start the coin
369:59 - timer so self. coin timer.
370:03 - activate and for that to work we have to
370:07 - update the timer self. coin timer.
370:10 - update in the update
370:13 - method after that inside of display text
370:17 - I want to do all of that but only if
370:21 - self. coin timer is
370:24 - active and with that by default we do
370:28 - not show the coins however if I collect
370:30 - one for one second we can see the amount
370:32 - of coins that we have and that feels
370:35 - pretty good on top of that I want to
370:39 - display a simple Graphics so we know
370:41 - that we are talking about the
370:44 - coins for that inside of main.py I want
370:47 - to import one more graphic that's going
370:49 - to happen inside of UI frames I want to
370:52 - import a coin graphic which is going to
370:55 - be as simple image and this we then have
370:59 - inside of UI frames so after that inside
371:03 - of ui. Pi we can still use those frames
371:06 - although we have to store them inside of
371:09 - a separate attribute let's call it self.
371:12 - coin uncore surface which is going to be
371:15 - frames and
371:17 - coin after we have
371:20 - that inside of display text we are first
371:23 - displaying the text and then I want to
371:26 - display the a coin graphic for that I
371:28 - will need a coin rectangle first of all
371:32 - which we get with self. coin surface and
371:35 - then get F wck we want to place the
371:38 - center in the bottom left position of
371:41 - the text rectangle which means we want
371:44 - to get the text rectangle and the bottom
371:47 - left of that after that self. display
371:50 - surface once again with the blit method
371:53 - self. coin surface and coin rectangle
371:58 - the difference isn't going to be major
372:01 - if I now pick up a coin we get a coin
372:04 - next to the number and I feel like the
372:06 - coin should be just a little bit
372:08 - higher for that we can use the move
372:11 - method to move this rectangle up by -6
372:16 - pixels and now if I pick one up that
372:18 - feels a little bit nicer once again the
372:21 - more you play around with this the
372:23 - better it's going to
372:24 - look that being said I don't like the
372:27 - default white color and I have a
372:30 - separate value called 33 32 and 3D if
372:35 - you now R main.py we are getting a
372:37 - darker color that is going to work much
372:40 - better once we have a proper background
372:42 - we are nearly done the last thing that I
372:45 - want to do is if the player collects
372:48 - more than 100 coins we want to set the
372:50 - coins back to zero and increase the
372:53 - health by one for that inside of the
372:56 - coin Setter
372:58 - method after we are updating the coins I
373:01 - want to check if self. coins is greater
373:05 - or equal to 100 if that is the case I
373:09 - want to reduce the amount of coins by
373:11 - 100 so minus equal 100 and on top of
373:14 - that self.
373:16 - Health should be increased by one and
373:21 - then finally when we are showing the
373:23 - coins I don't want to get the value
373:25 - instead that I want to use self.
373:28 - coins now at the moment inside of our
373:31 - level we don't have more than 100 coins
373:35 - but that we can fix quite easily inside
373:37 - of tiles I want to duplicate the skull
373:40 - let's say a couple of
373:43 - times with that we can try all of this
373:46 - and now if I pick up two scals we get to
373:49 - six health and if I pick two more we
373:52 - getting to seven that looks pretty good
373:54 - and the rest of the logic works just
373:57 - fine and all of that was a longer part
373:59 - but by now we have an actually
374:01 - interactive game next up we can work on
374:04 - the sky and then we have an actual level
374:07 - we are nearly done with the level
374:09 - there's just one more major thing that
374:11 - we have to cover and that is the
374:13 - background for that we are either going
374:15 - to have a sky or we are going to have
374:17 - some kind of tile setup on top of that
374:21 - what we are also going to cover are some
374:22 - more additional elements like the water
374:25 - in the level or constraint for the
374:27 - camera so we cannot see outside of the
374:29 - level let's start with those two parts
374:31 - actually because they are fairly
374:33 - straightforward once again we are back
374:36 - inside of main.py and for this part I
374:40 - want to close the UI and the data python
374:42 - file because we are not going to need
374:45 - them instead I want to work inside of
374:48 - level. Pi and I suppose to get started
374:51 - we can work on the water because at the
374:53 - moment if I run main.py we don't really
374:56 - have any water which looks
374:58 - weird we want to look inside of setup
375:01 - and then minimize everything because we
375:03 - want to create another for
375:06 - Loop all the way at the bottom I want to
375:09 - create a water
375:12 - section all we need for that is for obj
375:15 - in TMX map and then get layer by name
375:20 - the layer we want to look at is called
375:22 - water what that is going to mean inside
375:24 - of til we we have the water layer and
375:27 - the water layer only contains a single
375:29 - object a larger rectangle on this
375:32 - rectangle we want to look at every
375:35 - single individual
375:37 - cell which means we want to start with
375:40 - the first row and then look at this cell
375:43 - this cell this cell until we reach the
375:46 - end of the
375:47 - rectangle after that we go to the second
375:49 - row third row until we finish the entire
375:52 - thing and basically on the first row we
375:56 - are going to have a wave animation
375:58 - something like this but on every other
376:01 - row we are simply going to have a semi
376:03 - transparent surface that way we are
376:06 - going to get a block of water that will
376:08 - be animated which means inside of the
376:11 - for Loop we first of all want to know
376:13 - the rows and the columns to get either
376:17 - of those we want to get for the rows obj
376:21 - do height and then divided by the tile
376:24 - size and this needs to be an
376:27 - integer the same thing we want to do for
376:29 - the columns it's going to be a fairly
376:31 - similar operation except now we want to
376:33 - do obj do wift with that we know how
376:37 - many rows and columns we have inside of
376:39 - the
376:40 - object after that we want to get four
376:43 - row in range rows and then four call in
376:49 - range columns that way we are getting
376:53 - every single cell inside of this
376:55 - rectangle
376:56 - after that we have to convert our
376:58 - columns into X and our rows into y
377:02 - positions the way that is going to work
377:04 - for X we're going to get obj dox and
377:08 - that is going to be the top left of the
377:10 - rectangle and to that we want to add the
377:14 - column multiplied with the tile size
377:18 - imagine that this is the entire
377:21 - rectangle that we are
377:22 - importing objx and obj doy would be the
377:26 - top left point to that position we want
377:29 - to add the column multiplied by the tile
377:32 - size the column is going to be an
377:34 - integer that starts at zero and goes
377:36 - let's say up to 10 for the first four
377:40 - Loop the value is going to be 0o and 0 *
377:43 - 64 is still going to be zero so we are
377:46 - going to have a tile all the way on the
377:47 - left side however on the next for Loop
377:50 - this value is going to be one so we are
377:52 - jumping 64 pixels to the right and then
377:55 - create create one tile here that kind of
377:58 - logic we also want to do for the
378:00 - vertical part let me copy it the only
378:03 - real difference is that this is going to
378:05 - be obj doy plus row multiplied by the
378:09 - tile size with that we have the position
378:11 - of all of the tiles next up we have to
378:14 - figure out if we are on the first row or
378:17 - on any other row which is fairly easily
378:19 - done all we want to check is if row is
378:23 - equal to
378:24 - zero if that is the case we want to
378:27 - create an animated Sprite for that
378:30 - inside of Sprites I want to get the
378:32 - position frames and groups along with Z
378:36 - the actual arguments we're going to add
378:38 - in just a second first of all though I
378:40 - want to create a regular Sprite for
378:42 - which I will need a position a surface
378:45 - groups and
378:46 - Z I.E I want to have a Sprite with these
378:49 - arguments although let me get rid of the
378:51 - default
378:53 - values now before we can start working
378:55 - on windows we have to once again import
378:58 - a whole bunch of Graphics that's going
379:00 - to happen in Main and it's going to be
379:02 - fairly similar compared to what we have
379:04 - already done inside of level frames I
379:07 - want to import two more things water top
379:10 - and water body water top is a whole
379:13 - folder with an animation whereas the
379:16 - water body is simply an image that is
379:19 - semi-transparent basically it's a
379:20 - semi-transparent blue image here is the
379:23 - graphics folder and we want to to look
379:26 - at the level in there we should have
379:29 - water and then in there we have the body
379:32 - that's what we're importing for the
379:33 - water body and the top part is going to
379:36 - be a basic wave animation that's all
379:38 - that's happening in here now we have the
379:41 - surfaces with that we can actually
379:43 - create the animated Sprite and the
379:45 - Sprite for the position for both of
379:49 - those actually we want to have a tupal
379:52 - with X and Y also for the group groups I
379:56 - want those to be in self dot all
379:59 - Sprites same for the Z parameter I want
380:02 - to be in Z layers and we want to get the
380:05 - water
380:07 - key if you look at settings we have
380:10 - water finally then we are going to need
380:12 - the frames and the surface for both of
380:15 - those I want to get the level
380:18 - frames for the water animation I want to
380:22 - get the water top frames let me paste
380:25 - them in and for the water body I want to
380:28 - have the water body part and that should
380:31 - be it if I now run main not Pi we can
380:34 - see that we have water and that works
380:38 - pretty well although it's not perfect
380:40 - because if you jump outside of the level
380:43 - we can see that this system breaks down
380:45 - quite fast that we're going to fix next
380:48 - but first of all this system is working
380:51 - reasonably well so I'm pretty happy with
380:53 - that and with that we can close the
380:55 - setup method we are basically done with
380:58 - it next up I want to constrain the
381:00 - camera to the level and that is going to
381:02 - mean a couple of
381:04 - things first of all it means that we
381:07 - have to constrain the player to the
381:08 - level itself I.E if the player leaves
381:12 - the constraints of the level we either
381:14 - want to constrain the player itself to
381:16 - the level or we want to end the level if
381:19 - this is our entire level with all of the
381:23 - tiles and the random enemies and the
381:25 - player being in there
381:27 - somewhere if the player Falls too far
381:29 - down then we want to kill the player if
381:33 - the player walks too far to the left
381:35 - then we want to constrain the player to
381:37 - the left side of the level and finally
381:40 - if the player reaches the flag somewhere
381:43 - here then we should finish the level
381:46 - also I suppose what we can do if the
381:48 - player goes too far to the right then we
381:50 - should also constrain the player in that
381:52 - direction we don't have to constrain the
381:54 - player at the top because the player
381:56 - cannot fly so that part should be okay
382:00 - for all of that I want to create a new
382:02 - method let's call it
382:04 - check
382:06 - constraint in there we want to first of
382:09 - all Left Right constrain the player and
382:13 - that is terrible spelling essentially
382:16 - what we are going to do if self. player.
382:19 - hitbox rectangle. left is smaller or
382:24 - equal to zero
382:26 - and if that is the case self. player.
382:28 - hitbox rectangle. left should be
382:33 - zero once we have that all we need to do
382:36 - is call this method self. check
382:40 - constraint and now if I run main. Pi
382:43 - once more I try to go all the way to the
382:46 - left at some point we cannot do that
382:49 - anymore and that feels all right cool so
382:53 - that's the first part
382:56 - next up I want to do the same thing for
382:58 - the right side so if self. player.
383:01 - hitbox rectangle. right is greater or
383:05 - equal than some number and this number
383:09 - we don't know right
383:10 - now although we can get it but that has
383:13 - to happen inside of the dunder init
383:16 - method all the way at the top I want to
383:19 - create some level
383:22 - data first of all in there I want to
383:25 - have self.
383:27 - levore wift and this we can get with TMX
383:30 - map. wift let me actually print what
383:34 - we're getting from that and while we are
383:36 - testing that I want to comment out this
383:39 - part if I now run my. Pi we are getting
383:43 - 40 that 40 means that our map has 40
383:48 - columns so if you click on resize map we
383:50 - have a whiff of 40 tiles that part Works
383:54 - inside of tiled but for our level we
383:56 - want to have pixel width so we want to
383:58 - multiply all of that with the tile size
384:03 - and that is going to give us the width
384:05 - of the
384:05 - level which means I can now copy all of
384:08 - that and then uncomment this bit and
384:12 - check if the right side of the player is
384:15 - greater than the level width if that is
384:17 - the case self. player. hitbox rectangle.
384:20 - right should be equal to that point
384:24 - let's try that part and now I have to
384:27 - walk a bit further to the
384:30 - right and the boat is right there so now
384:34 - I should not be able to go further than
384:36 - this point and I'm not a bit hard to see
384:38 - but it's definitely working next up
384:41 - then I want to check the
384:45 - bottom border for that all I really need
384:50 - is self. player. hitbox rectangle.
384:54 - bottom if that one is greater then let's
384:58 - call it self. level bottom that point
385:03 - also doesn't exist right now if that is
385:05 - the case for now we want to print
385:08 - def later on if that is the case we are
385:11 - going to go back to the Overworld but
385:13 - since we don't have an Overworld right
385:15 - now that's not really an option but step
385:18 - by step first of all we have to create a
385:20 - level bottom that once again is going to
385:23 - happen inside of level data
385:26 - in fact it's going to be quite similar
385:28 - to the level Wii all we need is TMX map
385:32 - except this one is going to be the
385:34 - height which we want to multiply with
385:36 - the tile size let's try all of that and
385:40 - now if the player falls down we can see
385:43 - death so this part is also working just
385:47 - fine next up then I want to
385:51 - check the success State for the level
385:54 - which basically means that the player is
385:56 - reaching the flag that we can check with
385:59 - if self. player. hitbox
386:03 - rectangle and collide wct with let's
386:07 - call it self. level finish rectangle
386:13 - this one once again does not exist right
386:15 - now which we are going to fix in a
386:18 - second first of all though I want to
386:20 - print success so let's create the level
386:23 - finish rectangle
386:26 - and that we are actually not going to do
386:28 - inside of the dander init method instead
386:32 - we are going to do that in the setup
386:35 - method because when we are looking at
386:37 - the
386:38 - objects all of this somewhere in there
386:42 - we have the
386:43 - flag at the moment we are only checking
386:46 - if we have an object named player or
386:49 - anything else but on top of that I want
386:52 - to add another if statement that if
386:55 - statement is going to be if obj name is
386:58 - equal to flag if that is the case then I
387:02 - want to create the level finish
387:04 - rectangle which is just going to be a
387:06 - rectangle with a top left and a
387:10 - size the top left is fairly easy we want
387:13 - to have obj dox and obj doy for the size
387:18 - this doesn't get much more complicated
387:20 - we want to have obj do WID and obj do
387:24 - height
387:25 - and that is pretty much
387:28 - it now we can run main.py and once the
387:32 - player touches the flag we should be
387:34 - seeing success that looks really good
387:38 - cool so with that we can check the
387:41 - various constraints on the level that's
387:43 - a really important start and later on
387:46 - really important to connect the level to
387:47 - the
387:49 - Overworld although it doesn't make the
387:52 - game look that much better for that we
387:54 - have to re open the Sprite
387:56 - group or in other words we want to work
387:59 - inside of all
388:00 - Sprites that one we have stored inside
388:04 - of groups so that's what I want to open
388:08 - inside of this all Sprites class we are
388:10 - going to display all of the
388:11 - backgrounds simply because it's quite
388:14 - easy anything we are drawing before this
388:16 - for Loop will always be in the
388:18 - background which makes our life
388:20 - significantly easier for that though the
388:24 - all spreads class needs to know quite a
388:26 - bit more first of all we want to know
388:28 - the level width and the level height
388:31 - both of those we are already getting
388:33 - inside of the level so when we are
388:35 - creating all Sprites I want to pass in
388:37 - self. level wi and self. level
388:41 - underscore bottom level bottom and level
388:45 - height are the same thing the naming
388:46 - here isn't ideal admittedly just to make
388:49 - sure you understand if this is our level
388:53 - the level bottom is going to be this
388:56 - side which is always going to be the
388:59 - height of the level so those two numbers
389:01 - mean the same thing although in practice
389:03 - I suppose it can be a bit
389:05 - confusing anyway though with that inside
389:08 - of the level we know how wide and how
389:11 - tall the level is all of that we want to
389:14 - store as an attribute right away self.
389:17 - width and self. height are going to be
389:21 - width and height that is already
389:24 - important information information and
389:26 - next up we want to get from til some
389:28 - kind of info if we want to have a sky or
389:32 - if we want to have some kind of tiled
389:34 - background if you look at tiled we have
389:37 - one layer called Data this one also only
389:40 - contains a single object which is called
389:43 - Data itself and in there we have a whole
389:47 - bunch of
389:49 - parameters the only one we care about
389:51 - for now is going to be BG this one could
389:54 - be blue could be green and there are a
389:56 - few more options it could also be empty
389:59 - if that is the case the background
390:01 - should be a
390:02 - sky how that system is going to work in
390:04 - detail I will explain in just a bit for
390:07 - now just keep in mind that we are
390:09 - importing one value from this object
390:13 - which we also want to pass into all
390:15 - Sprites let's call it BG
390:19 - P which by default is going to be
390:22 - none next up then is inside of the level
390:26 - I want to create let's call it TMX
390:29 - level
390:31 - properties that is what we are getting
390:33 - from the object which I want to extract
390:35 - via TMX map get layer by name the layer
390:39 - we want to look at is called data and
390:42 - since this one only contains a single
390:44 - object we can use indexing with
390:47 - zero on that object we want to get the
390:51 - properties just to make sure that this
390:53 - is working I want to print TMX level
390:57 - properties let me run main. pi and there
391:01 - we are getting a
391:04 - dictionary the only value that we care
391:06 - about for now is BG which at the moment
391:08 - is
391:09 - blue that is important because if you
391:13 - open graphics and go to level there is a
391:18 - PG folder with tiles and in there we
391:21 - have a whole bunch of images these are
391:23 - the tiles that we want want to import
391:25 - for the
391:26 - background for example if tile specifies
391:29 - blue then we want to import this file
391:31 - for that dope first of all we once again
391:34 - have to import this
391:36 - folder in my case the key is going to be
391:39 - BG tiles and then we want to import a
391:42 - folder as a dictionary meaning we are
391:45 - going to get surfaces with the names of
391:47 - the files as a key all of that inside of
391:49 - a dictionary inside of level. Pi I want
391:53 - to check if TMX level
391:57 - properties. BG has a value if that is
392:02 - the case I want to create a BG tile and
392:06 - the value for that is going to be the
392:08 - level frames in there we want to go to
392:11 - the BG uncore tiles the one we have just
392:15 - created and remember this is going to be
392:17 - a dictionary so in there we can use
392:21 - indexing one more time with a
392:23 - keyword the keyword that we are looking
392:26 - for is going to be the background which
392:29 - means at the end of all of this our BG
392:32 - tile should contain a
392:34 - surface let's try and there we go we
392:38 - have a
392:40 - surface almost specifically the blue
392:42 - surface I just talked
392:44 - about this blue surface we want to pass
392:48 - into all Sprites and later on we are
392:51 - going to have a whole bunch of arguments
392:54 - for this class so I want to use named
392:57 - arguments right
392:58 - away we have width and height and after
393:03 - that I want to have the next argument
393:07 - would be BG
393:09 - tile which is going to be BG tile which
393:12 - will be the BG tile we have just
393:15 - created that being said if there's
393:18 - nothing inside of this background I
393:20 - still have to assign a value which we
393:22 - are doing with an ALT statement B tile
393:24 - can simply be done which means next up I
393:28 - can try all of this it's still working
393:30 - just fine
393:32 - cool after that I have a surface with a
393:36 - BG tile and this we want to use to draw
393:40 - the entire background meaning if this is
393:44 - our level we have a whole bunch of
393:47 - columns and rows this specific number
393:50 - does not matter what does matter is that
393:53 - for every single cell
393:55 - we want to display one of these PG tiles
393:57 - as a Sprite and the Sprite that we are
394:00 - going to use for that we're getting from
394:02 - the Sprite class this one which means I
394:05 - want to check if B tile exists in the
394:08 - first place and after that I want to
394:11 - look at every single cell inside of the
394:13 - level which we're getting with four
394:16 - column in range self
394:19 - Dot wift and then in there for row in
394:25 - range self. height this is fairly
394:29 - similar compared to what we have done
394:30 - with the water however I realized that
394:34 - my code setup isn't ideal because this
394:37 - width and height are pixel information
394:39 - inside of level Pi we are multiplying
394:42 - both with the tile size that way we
394:45 - don't get a number between 0 and 40 for
394:47 - the width instead we would get a number
394:49 - between 0 and 40 *
394:53 - 64 which is going to be way too large
394:56 - now to overcome that I'm going to paste
394:58 - in TMX map. wift straight into all
395:02 - Sprites and the same thing for TMX map.
395:06 - height then inside of the groups for the
395:09 - width and the height I am going to
395:11 - multiply both values with the tile
395:15 - underscore size that way we are
395:18 - retaining the proper size of the level
395:20 - but then inside of these lines I simply
395:23 - want to get the width and the height of
395:26 - the level via the grid so these numbers
395:29 - stay more manageable and after that I
395:32 - want to create an X and Y value for the
395:34 - position X is going to be column times
395:37 - the tile size and Y is going to be the
395:41 - row multiplied with the tile size after
395:44 - we have that we can create a Sprite
395:48 - simply a Sprite that we have already
395:49 - seen a couple of times and for that let
395:52 - me copy all of the parameters and also
395:55 - from Sprite import
395:59 - Sprite next up we have to get all of the
396:03 - arguments and those are going to be
396:04 - mostly familiar I think the position is
396:08 - the easiest part this one is just going
396:10 - to be X and Y the surface we also have
396:14 - this one will be the BG
396:16 - tile after that we have the groups and
396:18 - remember we are already working inside
396:21 - of a group the argument for this one is
396:24 - is going to be
396:25 - self finally we have the Z parameter and
396:29 - I want these PG tiles to always be first
396:32 - in line in this four Loop and since
396:35 - inside of settings all of the Z layers
396:38 - start at zero any negative number for Z
396:41 - in here is going to be at the beginning
396:44 - soga1 is going to always Place us behind
396:46 - everything else and that is pretty much
396:49 - it the only thing I have to do is fix my
396:51 - typo at the top this should be from
396:53 - Sprites inputs Sprite now let's try
396:56 - main. pi and there we go we have a
396:59 - background it doesn't yet work perfectly
397:02 - but if we are here
397:05 - is this looks much
397:08 - better on top of that if we are entitled
397:12 - we can change the background to green
397:15 - and then start main notp again now we
397:18 - have a completely different background
397:20 - and that starts to feel like a real
397:23 - level so if we are here not too bad
397:26 - although for this level we do want to
397:28 - have a proper
397:29 - sky so next up we want to constrain the
397:33 - camera so that the player cannot see the
397:36 - black background anymore all of that we
397:38 - are going to do in a separate method
397:41 - let's call it
397:42 - camera
397:44 - constraint essentially all that we have
397:46 - to do in here is at the moment we are
397:49 - always updating the offset to wherever
397:51 - the player is however if the player goes
397:54 - too far to the left then at some point
397:57 - we want to stop updating the X part of
397:59 - the offset or in other words self.
398:03 - offset dox is going to be self. offset
398:08 - dox but only if self. offset dox is
398:13 - smaller than zero if that is not the
398:16 - case else it should be zero so what does
398:20 - that mean to illustrate let me actually
398:23 - run self. camera
398:25 - constraint if I now run may. pi and go
398:28 - to the left at some point the camera
398:31 - simply stops going any further and the
398:34 - player also cannot go further so this
398:36 - looks pretty good and if you now simply
398:39 - look here or let's say down
398:43 - here it looks like the background is
398:45 - covering the entire background the basic
398:49 - logic is and remember the offset always
398:52 - runs in the opposite direction compared
398:53 - to the player so the further to the
398:56 - right the player gets the smaller the
398:58 - offsetx becomes because of that self.
399:01 - offset should be the offset itself if
399:04 - the number is below zero meaning the
399:06 - player is to the right of the origin
399:07 - point however if the player is to the
399:09 - left of the origin point then we want to
399:12 - set the number simply to zero and that
399:14 - way the camera sticks to the left side
399:16 - of the window once again the offset
399:18 - logic can be a bit confusing you
399:20 - basically always want to invert the
399:22 - camera to whatever the player position
399:24 - is this would be the left side but we
399:27 - have three more
399:29 - sides and to organize all of that I
399:32 - think the best way is to have a
399:34 - dictionary for easy access let's call it
399:36 - self. borders and there we have a left
399:41 - side that is simply going to be zero and
399:45 - then in camera constraint I want to
399:47 - replace the zero with self.
399:51 - borders and the left key
399:54 - that feels a bit cleaner because besides
399:57 - that I also want to have a right
400:00 - side I want to have a top side and I
400:04 - want to have a bottom side the right
400:07 - side is going to be self do whift and
400:11 - just to make sure that we are testing
400:13 - things step by step let me comment out
400:15 - the top and the bottom and instead we
400:18 - have to work a bit more with the camera
400:21 - offset once again I want to update self.
400:24 - offset dox this one is going to be
400:27 - itself self. offset dox but only if
400:31 - self. offset dox is greater than self do
400:38 - borders and we are looking at the right
400:41 - side if that is not the case else once
400:44 - again we want to have the same value in
400:48 - there and now if we are trying this we
400:52 - are getting some really weird stuff so
400:54 - what is going wrong and basically this
400:57 - number needs to be negative because once
401:00 - again remember the further the player is
401:03 - going to the right the further left the
401:05 - camera offset is going to be so whenever
401:07 - you're thinking of the right border you
401:09 - want to mirror the entire thing
401:12 - essentially or in other words we want to
401:15 - have the negative self. width now if we
401:19 - are trying all of this I can go all the
401:21 - way to the right and uh some
401:27 - point I shouldn't have the camera
401:29 - updating anymore and here I see a
401:32 - problem with the testing because the
401:33 - player cannot go further to the right
401:36 - than the level Whi that happens because
401:38 - of this check constrain but that's okay
401:42 - because in our case we want to stop the
401:44 - camera before
401:45 - anyway imagine that once again we have
401:49 - the level and the level ends on this
401:52 - side any that comes after is going to be
401:55 - a black background that we want to
401:57 - ignore which means if the player's on
402:00 - this position the player would be able
402:02 - to see all of this which we don't want
402:06 - this part should never be visible as a
402:09 - consequence the actual end part of the
402:11 - level should be much further it should
402:14 - rather be somewhere here so that the
402:16 - player can only ever see this part up to
402:20 - the end of the level to get that we want
402:24 - to add the window whift to the right
402:27 - border now if we're trying
402:29 - main.py and I can go further to the
402:32 - right at some point the camera should
402:35 - stop updating and there we go now I
402:38 - cannot go any further than this point or
402:40 - rather the camera cannot go any further
402:43 - and that looks much cleaner next up the
402:46 - same logic we are going to apply to the
402:48 - bottom because it's fairly similar we
402:51 - want to have negative self do height
402:54 - plus the window height and then inside
402:58 - of camera constraint we want to update
403:01 - self. offset
403:03 - doy which is going to be itself self.
403:06 - offset doy but only if self. offset doy
403:12 - is greater than self. borders with the
403:20 - bottom else it is going to be that value
403:23 - you let's try the level and if I fall
403:26 - down the camera stops updating and
403:30 - especially if we go back to the
403:31 - Overworld this is going to work really
403:33 - well finally then we will need a top
403:38 - argument and for that you could specify
403:41 - a zero that would technically work let
403:44 - me demonstrate if I duplicate this line
403:48 - we want to keep offset doy but only if
403:51 - it is smaller than the bord top and if
403:54 - that is not the case it should be the
403:55 - Top If I now run may. Pi we can never go
403:59 - further than this point so this part is
404:01 - also working just
404:04 - fine however sometimes you want to be
404:06 - able to jump further than that so you
404:09 - might want to disable the top border for
404:12 - that inside of til we have another
404:15 - attribute called top limit this by
404:18 - default is going to be zero but you
404:20 - could set it to another number if you
404:22 - want to have more vertical space face at
404:23 - the top to import that inside of level.
404:27 - Pi in the dunder init
404:29 - method we can specify one more argument
404:33 - that would be the top limit which we can
404:36 - get via TMX level properties the value
404:40 - we are looking for is called top
404:42 - underscore limit for that to work we
404:45 - will need a top underscore limit with a
404:48 - default value of zero and this value we
404:52 - want to pass into the top number so top
404:54 - limit in
404:56 - there since inside of til this value at
404:59 - the moment is
405:01 - zero this is not going to make any kind
405:03 - of change however we could set this
405:06 - value to something like a
405:08 - 100 run all of this again and now we
405:12 - have a bit more space at the
405:15 - top which if we had a background could
405:19 - work quite well however once again we
405:22 - are getting a black background ground
405:23 - which we do not want to see to fix that
405:26 - part we have to work inside of this
405:29 - logic specifically inside of the rows we
405:33 - basically want to now go from the top
405:35 - limit up to the height fortunately that
405:39 - we can do quite easily inside of the
405:41 - range function because in there we can
405:44 - set a start size and an end
405:46 - size the end size is still going to be
405:49 - the height of the level however the
405:52 - start size at the moment needs to be 100
405:56 - simply because inside of tile the top
405:58 - limit is 100 once again remember for the
406:01 - offset we are going in exactly the
406:04 - opposite way which means in our case I
406:06 - want to have negative top underscore
406:10 - limit although this is going to be 100
406:14 - right now whereas the height is only
406:16 - something like 20 I.E this one is going
406:19 - to work in pixels and this one is going
406:21 - to work in a grid to overcome that I
406:24 - want to divide the top limit by the
406:27 - tille size and then turn all of this
406:29 - into an
406:32 - integer that should already help a bit
406:35 - if I now run may. Pi we have a slightly
406:39 - smaller
406:40 - Gap the reason why there's still a gap
406:43 - is that the integer function is always
406:45 - going to round
406:47 - down so at the moment we have 100 pixels
406:50 - but we only drawing one extra tile
406:54 - whereas we are actually going to need
406:55 - two to fill the space and well the
406:58 - easiest way to fix that is simply
407:00 - subtract one from there and now we are
407:03 - filling the entirety of the space and
407:06 - that feels quite a bit nicer cool so now
407:09 - with that we have the
407:10 - background also we have the camera
407:12 - constraint this one we can minimize we
407:14 - are not going to need it anymore and let
407:16 - me clean this one up just a bit this
407:19 - feels nicer now I want to have a sky if
407:23 - we don't have a BG tile which means
407:26 - there should be an else statement and
407:29 - then we can create the
407:32 - sky first of all in there I will have to
407:35 - have a couple of Graphics I will need
407:37 - self do what is called a large cloud and
407:41 - I want to have self.
407:43 - small clouds which is going to be a list
407:47 - of surfaces and for all of that we
407:50 - already know how to import Graphics that
407:52 - always happens inside of the level
407:55 - frames I want to have two more entries
407:58 - for the cloud small and Cloud large once
408:01 - again Cloud large is going to be a
408:03 - simple image whereas the small clouds
408:06 - are going to be Graphics inside of a
408:08 - folder once again if you look at the
408:10 - graphics folder we have Graphics then we
408:13 - have level and in there we have the
408:15 - clouds we have a large cloud and we have
408:18 - small clouds and they are three
408:20 - different kinds that we could be using
408:23 - those we want to get into this all
408:26 - Sprites class for that inside of the
408:28 - level we have to pass into more
408:32 - arguments or I suppose to keep this one
408:34 - a bit more condensed I want to have
408:37 - clouds which is going to be a dictionary
408:41 - where we have the large Cloud which is
408:43 - going to be level frames and large
408:47 - uncore Cloud I believe I called
408:51 - it actually the opposite Cloud uncore
408:56 - large and after that we have the small
408:59 - clouds which is going to be level
409:03 - frames and let me copy it Cloud
409:07 - small after that inside of
409:10 - groups we will need let me do it before
409:13 - the parameters with default values I
409:15 - want to have the
409:18 - clouds and then the large cloud is going
409:20 - to be clouds
409:23 - large and the cloud small are going to
409:26 - be clouds and small let's run main. pi
409:29 - to make sure we get the Imports and we
409:32 - didn't get an error so that looks pretty
409:34 - good although we don't actually get to
409:36 - this part the way we are getting to the
409:38 - sky is inside of tiled you want BG to be
409:44 - empty that way we are getting none for
409:47 - BG
409:48 - tiles I.E if you look at level tiles you
409:51 - would get this BG tile n
409:53 - which we are then passing into this BG
409:55 - tile which is then in turn not going to
409:59 - run this if statement and instead we're
410:01 - getting to this part which means if I
410:04 - run main. Pi we are back to the black
410:07 - background not ideal but that we can
410:10 - work on we at the very least have a
410:12 - couple of Graphics but first of all I
410:15 - suppose we should go step by step and
410:18 - start by drawing the actual sky and for
410:21 - that first of all I I want to know if we
410:24 - should be drawing a sky or not for which
410:27 - I have another attribute called self.
410:29 - Sky the value for this one is going to
410:32 - be the opposite of BG tile if BG tile
410:36 - has no value then none is going to turn
410:39 - this value to true however if we have
410:42 - some value for B tile then it would
410:45 - evaluate to true so all of this would
410:47 - become false or in other words if we
410:50 - have a BG tile then self. Sky would be
410:52 - false but if we do have a BG tile then
410:54 - self. Sky would be true and if that is
410:58 - the case before we are drawing all of
411:01 - the Sprites I want to check if self. Sky
411:05 - then I want to run a method let's call
411:07 - it self. draw sky that method doesn't
411:11 - exist right now so let's create it draw
411:15 - Sky most importantly we want to get
411:17 - self. display surface and fill the
411:20 - entire thing with a color and for that I
411:23 - have a pretty fine color that simply
411:25 - looks good let's place it in there we
411:27 - have DD C6 and
411:30 - A1 if I now run m. Pi we're getting a
411:34 - very plain background color that's at
411:36 - the very least better than a black color
411:39 - after that we want to draw a horizon
411:42 - line or rather I want to have a horizon
411:47 - position for now let's place this one at
411:50 - a position of
411:51 - 500 and let me explain what we are going
411:54 - to do once again we have all of the
411:57 - level at the moment we're filling all of
412:00 - this with the background color which is
412:03 - a decent start but not actually what I
412:05 - want Instead This background color
412:07 - should only cover the top
412:10 - halfish while the bottom part should be
412:13 - water with some kind of horizon line
412:16 - between the
412:17 - two The Horizon position we are
412:20 - specifying is going to be the position
412:23 - of this Center Line that separates the
412:25 - sky from the water or in other words it
412:29 - is going to be the distance from the top
412:31 - to when we are starting with the water
412:34 - and I think 500 might be a little bit
412:36 - much let's go with 400 so we can see it
412:39 - a bit better what we can do with that
412:42 - number is for example we can create a c
412:45 - rectangle which is going to be simply a
412:48 - pame do F
412:51 - rectangle I want to speci ify the left
412:53 - the top the width and the height for
412:55 - this thing the left is really easy this
412:58 - one should always be at position
413:00 - zero and the top should be the Horizon
413:03 - position the width should be the window
413:06 - width and the height should be the
413:08 - window height minus the Horizon position
413:12 - I suppose what is important to explain
413:14 - for this one is that this C rectangle is
413:17 - always going to cover the same bottom
413:18 - part of the window and it is not going
413:21 - to move along with the level
413:23 - we basically put a blue rectangle in the
413:25 - background and that covers the water
413:27 - that's really all we need once we have
413:30 - that I simply want to py game. draw.
413:34 - rectangle on self. display surface with
413:38 - a specific
413:40 - color which I want to paste in we want
413:44 - to have the hex code 92 A9
413:48 - CE after we have that I want to have the
413:51 - C rectangle
413:53 - rectangle and now if I run main. Pi in
413:56 - the background we have the blue color
413:59 - however if I jump this one moves along
414:02 - with the player which is going to look
414:04 - really really
414:05 - strange the reason for that is that this
414:10 - rectangle completely ignores the camera
414:12 - none of this affects the rectangle so
414:15 - we're moving the entirety of the level
414:17 - but this background is always constant
414:20 - but we can fix that fairly easily
414:24 - because the Horizon position can be
414:26 - affected by the offset all that we
414:28 - really want to do is add self. offset
414:31 - doy to it and then we are good to go if
414:34 - I now run may. Pi this thing doesn't
414:36 - change anymore or in other words it
414:38 - moves along with the rest of the level
414:41 - which feels significantly better also at
414:44 - this point this number shouldn't be set
414:45 - in the code it should be set inside of
414:48 - tiled fortunately it is because in there
414:51 - we have the horizon line this is also
414:54 - what I want to import that is fairly
414:56 - easily done I want to add one more named
415:00 - argument the horizon
415:03 - line the value for that one is going to
415:06 - be our TMX level properties and in there
415:12 - we have the horizon uncore line after
415:16 - that inside of the groups I want to have
415:18 - another argument the
415:21 - horizon line
415:23 - which we want to turn into an attribute
415:25 - right away self. horizon line is going
415:28 - to be the horizon
415:29 - line and finally we can replace the 400
415:33 - with self. horizon line and now I can
415:37 - run m.p and we get the position we have
415:40 - specified inside of tiled that's a good
415:43 - start and the game does look
415:45 - significantly better but it's still not
415:47 - perfect we are missing
415:50 - clouds although first of all I want to
415:53 - accentuate the Horizon a bit more
415:56 - meaning I want to create a couple of
415:59 - Horizon Lines or rather we actually only
416:02 - need a single
416:04 - one which I can get with pame DOT draw
416:09 - doline I want to draw on self. display
416:12 - surface for the color once again I have
416:16 - a default value which is going to be
416:18 - this one F5 F1 de finally we need a
416:22 - start value an end value and a line
416:28 - thickness the start value is going to be
416:31 - zero for x and the Horizon position for
416:36 - the Y value for the end we want to have
416:40 - the window whiffed and then once again
416:43 - the Horizon position for y finally for
416:46 - the thickness let's go with four and now
416:50 - if I run main. Pi you can see we have a
416:53 - white line separating the Sea and the
416:55 - sky which is the Horizon that looks
416:58 - pretty good meaning now I can minimize
417:01 - draw Sky we are not going to need it
417:04 - anymore now for the clouds we are going
417:07 - to have two separate systems one for the
417:09 - small cloud and one for the large one if
417:13 - this is going to be our level for the
417:15 - small clouds we are simply going to
417:17 - create a bunch of Sprites that start all
417:19 - the way on the right side something like
417:22 - this and these are always going to be
417:24 - clouds which are going to move to the
417:26 - left and once they hit the left border
417:29 - of the level we are going to destroy
417:31 - them however for the large Cloud we have
417:34 - one large image and this one is tilable
417:38 - which means we can have one large Cloud
417:40 - that looks something like this and then
417:43 - another large Cloud that looks something
417:45 - like this and all of those large clouds
417:48 - we want to move by the same speed in the
417:51 - same direction
417:52 - in fact here's the graphics folder and
417:54 - the small clouds are very simple images
417:57 - they don't really do very much however
417:59 - if we are going to the big cloud you can
418:02 - see that this is a large Cloud that has
418:04 - a left Edge and the right Edge and we
418:07 - can put large clouds right next to each
418:09 - other that way we are basically going to
418:11 - create an infinitely long Cloud to get
418:14 - started let's create some attributes for
418:17 - the large Cloud that's the system I want
418:20 - to start with we are going to have have
418:22 - self. large Cloud speed which I want to
418:27 - set to 50 and then I also want to create
418:30 - self. large Cloud X which by default is
418:36 - going to be zero finally we will need
418:38 - one more parameter and that are called
418:40 - self. large
418:43 - Cloud tiles the way you want to think
418:46 - about this one is once more we have the
418:50 - entirety of the level but the large
418:52 - Cloud can only occupy a small part of
418:54 - that let's say something like this will
418:57 - be occupied by the cloud but we want to
419:00 - cover the entire width of the level with
419:02 - a cloud we have to know how many large
419:04 - clouds we need in this example we are
419:07 - going to need three large clouds and
419:10 - then once we have these three large
419:12 - clouds we want to move all of them in
419:14 - the same direction by the same speed
419:16 - that way they always stick together and
419:18 - it looks like one coherent
419:20 - Cloud the value for this one has to be
419:23 - an integer and we basically want to get
419:25 - self. wift so the level Whi we have
419:28 - specified earlier this we want to divide
419:31 - by self. large Cloud the one we imported
419:35 - earlier although from that we want to
419:38 - get the WID if I print that number self.
419:42 - large Cloud piles and run main. Pi we
419:47 - get at the moment we only need a single
419:50 - Cloud to fill the entire level
419:52 - background and that should make sense
419:55 - because if I open the file and look at
419:57 - the dimensions this thing is
420:00 - 1,792 pixels wide it is quite a large
420:03 - image whereas our entire level is 40 *
420:08 - 64 pixels so 2560 pixels the large
420:13 - clouds at the moment would mostly cover
420:15 - the entire window but once again since
420:19 - the in function is going to round down
420:22 - we are always getting the number that is
420:23 - slightly too small to fill the entire
420:25 - window but that we can fix quite easily
420:28 - by adding plus
420:29 - one and in my case I have added plus two
420:33 - just to have a bit of extra space at the
420:35 - end to make sure that we are not cutting
420:37 - off the main Cloud because that would
420:38 - look quite weird but anyway with that we
420:41 - have all we need to display the large
420:43 - Cloud we want to create another method
420:48 - Define draw large cloud
420:52 - for the parameters we will need self and
420:54 - Delta time the reason why we need Delta
420:57 - time is we want to move self. large
421:00 - Cloud
421:01 - X and increase it by self.
421:06 - Cloud large Cloud speed multiplied with
421:10 - Delta time now at the moment this would
421:12 - make the number larger I.E we would be
421:15 - moving to the right but the direction we
421:17 - do want to control I suppose for all of
421:19 - that we can create a self do Cloud
421:23 - uncore Direction which should be Nega -1
421:26 - by default and this one we want to have
421:28 - both for the large and for the small
421:30 - Cloud so I'm going to place it all the
421:31 - way at the top now for that I want to
421:35 - have self. Cloud diction multiplied with
421:40 - the cloud speed and Delta
421:42 - time that way we are moving the large
421:46 - Cloud X number and then I want to run a
421:49 - for Loop for cloud in range
421:53 - self. large cloud
421:56 - files we want to draw as many large
422:00 - clouds as we have tiles meaning we want
422:03 - to run self. display surface and then
422:06 - blit the value we always want to place
422:08 - self. large
422:11 - Cloud now the position is going to get a
422:14 - bit more complicated so let's store it
422:16 - inside of a separate XY variable we need
422:19 - X and Y or rather I think what is going
422:24 - to make a bit more sense we want to
422:25 - place the left side and the top side of
422:28 - the cloud and the top part is going to
422:31 - be easier so let's define that and the
422:34 - left side for now is going to be zero as
422:37 - a matter of fact let's add zero for both
422:39 - of them and then call self. draw large
422:43 - cloud with Delta time if I now run main.
422:47 - Pi I have realized that we don't have
422:49 - Delta time inside of this draw method
422:54 - that fortunately is quite easily fixable
422:56 - we need Delta time when we are calling
422:58 - the draw method and then inside of the
423:01 - level we want to pass in Delta time as
423:04 - well if I now run main. Pi we can see we
423:08 - have the large clouds in the background
423:11 - and once again they are moving along
423:13 - with the camera or rather they don't
423:15 - move along with the camera so they're
423:16 - just static in the background and don't
423:18 - do anything but at the very least we
423:21 - have something
423:22 - so next up we can refine these
423:26 - numbers because for that I want to get
423:28 - self. horizon line the number we have
423:31 - specified earlier but this by itself is
423:35 - not going to be enough if they run may
423:37 - not P now now the clouds you can see
423:39 - them all the way at the bottom so if you
423:41 - look at the bottom right there you can
423:43 - see one part of the
423:45 - cloud remember once again we are
423:47 - specifying the top part of the clouds
423:50 - and the horizon line is the top of the
423:52 - water meaning we want to place the
423:55 - bottom of the clouds on this top
423:57 - position to get that we want to specify
423:59 - one more attribute and that is going to
424:01 - be large
424:04 - Cloud he and while we are here we can
424:08 - also specify large
424:11 - Cloud width both of those numbers we're
424:14 - getting from self. large cloud and then
424:18 - get underscore
424:20 - size we want to placed the top of the
424:22 - cloud on the horizon line minus self.
424:27 - large Cloud height and also these
424:31 - numbers should be inverted we are
424:33 - getting the width first and then we
424:35 - getting the height that's a silly
424:37 - mistake to make if I now run main. Pi we
424:41 - are getting the clouds kind of in the
424:44 - right position the one issue we have now
424:47 - is that they do not update with the
424:49 - camera but that we can fix fairly easy
424:51 - easily all we need is self. offset
424:55 - doy and now we have the clouds exactly
425:00 - in the right position that feels much
425:03 - nicer although this only covers one AIS
425:07 - we also need the left side for that one
425:10 - we will need self. large Cloud X and
425:15 - then plus self. large
425:18 - Cloud WID m multiplied by the number of
425:23 - clouds that we have that's the number we
425:25 - are getting from the four
425:27 - Loop to all of that we want to add self.
425:30 - offset dox and now if made. Pi the
425:35 - background clouds are moving that looks
425:38 - pretty good and also if I go further to
425:40 - the right you can see all of them
425:44 - and now we have to wait a little bit
425:47 - because the system isn't perfect at some
425:50 - point the clouds are simply going to to
425:56 - stop there we go since we only created
425:59 - free clouds at some point the clouds
426:02 - simply stop and we can see how this
426:05 - entire system is going to fall
426:07 - apart for that we want to add one more
426:12 - condition we basically want to check if
426:16 - self. large Cloud X is smaller or equal
426:22 - to the
426:24 - negative large Cloud width then we want
426:28 - to set self. large Cloud X back to
426:33 - zero essentially if this is the level
426:36 - again we are setting one point a bit
426:39 - further to the left this is going to be
426:41 - the width of one
426:44 - cloud and as soon as we have one Cloud
426:47 - reaching this point all the way to the
426:49 - left then we are restarting all of the
426:51 - clouds
426:52 - in the origin position and since this
426:54 - cut of point is the width of one of the
426:56 - clouds this should be seamless although
426:59 - that's kind of hard to demonstrate I
427:01 - suppose what I could be doing is I can
427:03 - set the large Cloud speed to 500 and now
427:07 - if I go to a point all the way to the
427:11 - right we can see the clouds pretty well
427:14 - and you should not be able to see any
427:16 - kind of transition
427:20 - marks
427:22 - and I think that is looking pretty solid
427:26 - cool although the cloud speed should
427:28 - just be
427:30 - 50 with that we are drawing the large
427:33 - clouds next up we can work on the small
427:36 - clouds so small
427:39 - clouds I want to work inside of Sprites
427:42 - again because there's one more class
427:44 - that we have to
427:45 - create all the way at the bottom I want
427:48 - to create a cloud which is just going to
427:51 - be a Sprite
427:52 - This Cloud I then want to import groups.
427:55 - Pi so after Sprite I want to have a
427:57 - cloud and then for the small clouds I
428:00 - want to do two things number one I want
428:03 - to create a timer that creates a cloud
428:07 - every
428:09 - 2.5
428:10 - seconds this should have a random speed
428:13 - and always go to the left on top of that
428:17 - there should be lots of clouds by the
428:21 - default so when you start up the level
428:23 - there should already be a certain number
428:25 - of
428:26 - clouds this part is going to be your
428:29 - exercise meaning for the exercise I want
428:31 - you guys to create the cloud class and
428:33 - the timer by default when the level is
428:36 - starting there should already be a whole
428:38 - bunch of clouds on the screen simply
428:40 - choose a number that you think looks
428:42 - good on top of that the timer should
428:44 - create a new Cloud every 2.5 seconds
428:48 - pause the video now and see if we can
428:49 - figure this one out
428:55 - I suppose we can get started with the
428:58 - cloud class first of all we will need a
429:00 - Dunder init
429:02 - method for that we will need self a
429:05 - position a surface the groups is z
429:09 - argument although the default value for
429:11 - this one could be Z layers and we have a
429:16 - clouds layer if you look at settings
429:19 - there's clouds after that we have to
429:21 - call Super Dunder init where we have to
429:25 - pass in the position the surface the
429:28 - groups and the Z argument after that I
429:31 - want to specify self. speed which is
429:34 - going to be a random integer and this
429:37 - Rand int function we don't have right
429:39 - now so from random import Rand int I
429:44 - went with a number between 50 and
429:46 - 120 on top of that I want to have a
429:49 - self. Direction
429:51 - which is going to be -1 after that I
429:55 - want to have an update method with self
429:58 - and Delta time all we want to do in here
430:00 - is self. Rec dox plus equal self.
430:05 - direction multiplied with self. speed
430:08 - and multiply it with Delta time on top
430:11 - of that while we are here we want to
430:13 - check if self.
430:16 - re. right is smaller or equal to zero
430:22 - if that is the case we want to destroy
430:24 - the Sprite the logic for this one is if
430:27 - the cloud reaches too far to the left
430:29 - then we want to get rid of it if we
430:31 - didn't do that at some point we would
430:33 - keep on spawning clouds and that
430:35 - eventually might cause a performance
430:37 - problem it's not strictly necessary but
430:40 - it's generally good practice anyway with
430:43 - that we have the cloud so next up inside
430:46 - of groups we are already importing the
430:49 - cloud which means once we are starting
430:51 - all of this we want to create a couple
430:53 - of clouds and let's say for cloud in
430:58 - range 20 all we want in there is to
431:01 - create one instance of a cloud for that
431:04 - we will need position surface and groups
431:08 - groups is the easier part this one is
431:10 - simply going to be self besides that
431:12 - though we will need a position and we
431:14 - will need a surface let's start with the
431:17 - surface for that we want to use the
431:19 - choice method because we have a list of
431:23 - small clouds those we want to pick from
431:26 - self. small clouds although I think at
431:30 - the moment we don't have the choice
431:32 - method meaning from random I want to
431:34 - import
431:37 - choice that is going to give us the
431:39 - surface finally we will need a position
431:42 - and for that once again I want to get a
431:45 - random number so we want to import Rand
431:48 - in now in the position we want to
431:50 - specify Y X and Y and let me draw the
431:55 - issue we have
431:57 - here this is going to be our level and
432:00 - on the bottom we have all of the water I
432:03 - want the clouds to only be inside of
432:06 - this area on top of that when we are
432:10 - creating the clouds at the start of the
432:11 - game the clouds should be somewhere
432:13 - between this left side and this right
432:16 - side meaning we have two
432:18 - constraints let's start with x I want to
432:21 - have a random integer between zero and
432:24 - self. WID for y I want to have a number
432:29 - between self do borders and the top of
432:33 - the level up to self. horizon line that
432:38 - should be all we need although we want
432:40 - to get rent in there now let's try all
432:43 - of this and there we go we have a whole
432:46 - bunch of clouds 20 might be a bit much
432:49 - also we're not generating any new clouds
432:51 - so anything that comes afterwards looks
432:53 - a bit weird but at least we have a
432:57 - start however let me run this again and
432:59 - you can see we have this huge gap all
433:02 - the way at the top here the reason why
433:04 - we are getting that is when we are
433:07 - creating a cloud we are always placing
433:10 - the top left inside of the position we
433:14 - are going from the top all the way to
433:16 - the horizon line placing the top left
433:18 - isn't ideal because we might cross this
433:20 - this horizon line which we really
433:22 - shouldn't do to fix that when we are
433:26 - creating the cloud I want to update
433:29 - self. wct I want to set the mid bottom
433:33 - to the position that's going to make
433:35 - quite a difference and now we are using
433:37 - the space much
433:40 - better and I think that looks quite
433:44 - nice cool this is going to cover the
433:47 - default case next up we want to have a
433:50 - timer that creates a new Cloud every 2.5
433:54 - seconds for that we will need the timer
433:56 - class from timer import timer and after
434:01 - that for the clouds we want to have a
434:04 - self.
434:06 - cloud timer the duration for this one
434:09 - should be
434:10 - 2,500 however I want to add more
434:13 - arguments in there because remember the
434:15 - timer can run a function once it runs
434:17 - out and it can be repeated for getet
434:20 - that we want to first of all specify a
434:22 - function we want to run self.
434:25 - create Cloud make sure to not call it
434:29 - after that we want to set a third value
434:30 - to
434:31 - true and just to demonstrate if we are
434:34 - opening the timer class we can set a
434:37 - duration a function and repeat we didn't
434:41 - need that earlier because we have
434:43 - default values for these parameters also
434:45 - for all of this to work I want to
434:47 - activate the cloud timer right away so
434:52 - activate also inside of the draw method
434:55 - before we are doing anything else I want
434:57 - to get the cloud timer and update
435:02 - it all we need now is another function
435:06 - that's going to be called create out no
435:10 - need for arguments in this one all we
435:12 - really want to do is create one instance
435:14 - of a cloud this surface we can also copy
435:18 - because this one is going to stay the
435:20 - same
435:21 - as a matter of fact let me copy the
435:23 - position as well because we can keep
435:25 - parts of that the Y part to be more
435:28 - specific this one doesn't need to change
435:31 - however the X part does need to change
435:33 - because we want to now create a cloud
435:36 - all the way on the right side of the
435:38 - window meaning we want to get a random
435:40 - number from the width of the level up to
435:44 - let's say self. wift do 200 pixels just
435:48 - to get some random numbers in there and
435:50 - with that I should be good to go
435:52 - although I am seeing that I messed this
435:54 - one up this should be equal to timer
435:57 - with these
435:58 - numbers now let's try may. pi and we do
436:02 - have some clouds if I go all the way to
436:05 - the
436:06 - right we should be getting more clouds
436:12 - continuously right now the clouds might
436:14 - be behind the large Cloud so we do have
436:17 - to wait a bit there are some more clouds
436:19 - and there you can see we are creating
436:20 - more clouds and this happens a bit too
436:23 - far to the
436:26 - left let's move the value a bit further
436:28 - to the right but other than that this
436:30 - works pretty well so basically when we
436:34 - are creating this random value we want
436:36 - to get self. with let's say plus
436:41 - 500 and then up to
436:45 - 600 and now the second
436:49 - attempt
436:51 - now this should look much
436:54 - better now we keep on getting clouds
436:56 - that come in from the
437:04 - right I think this looks about right I
437:07 - think the timer is a bit too slow but
437:10 - that's something you can fine tune it's
437:11 - not too important and something fairly
437:13 - subjective either way this function or
437:16 - Rob by this method is working just
437:18 - fine and with that we have finished the
437:22 - level if I now run all of this we have
437:25 - all of the important parts and we can
437:27 - jump around we have a background we have
437:29 - enemies we have platforms this is
437:31 - actually looking really
437:33 - good and everything else still works
437:35 - just fine on top of that what you can do
437:39 - at this point is when we are creating
437:41 - the TMX Maps so on this line where we
437:44 - import om.
437:46 - TMX you can import other files for
437:49 - example if we import 1. TMX run all of
437:52 - this again then we get a completely
437:55 - different
437:56 - level but everything else still works
437:59 - just fine so let me try to attack an
438:01 - enemy and we have Pearl all of that
438:05 - looks really good besides that we have
438:08 - two TMX and when we are running this one
438:11 - I realized there is an error that all
438:13 - Sprites object has no attribute Cloud
438:15 - timer let's have a look at that really
438:17 - quick if we're looking at groups and the
438:21 - issue right now is we are only creating
438:24 - a cloud timer if we have a sky however
438:27 - if we don't have a cloud timer attribute
438:30 - further down there we are trying to
438:32 - update a cloud timer that doesn't exist
438:35 - fortunately that's easy to fix we want
438:37 - to place this Cloud timer and only
438:39 - update it if there's a sky if I now run
438:42 - main. Pi we can see the whole level and
438:45 - that feels quite a bit better and there
438:48 - we have a whole another level
438:51 - that once again works perfectly
438:54 - fine later on we are going to combine
438:57 - all of the different levels although for
438:59 - now I will stick with Omni TMX but play
439:03 - around and if you look at til you could
439:05 - design your own levels as well the way I
439:08 - would recommend you to approach that so
439:10 - here we are in om. TMX and if you want
439:13 - to create your own level you basically
439:15 - save this file under save
439:18 - as and then you save it as whatever
439:20 - level you want for example if you want
439:22 - to have a new level then you could add
439:24 - level six save it and now you can
439:27 - customize this thing to your heart's
439:28 - content whatever you want to put in
439:30 - there you can also resize the map under
439:33 - map and resize map and then just put in
439:36 - whatever you
439:37 - like with that set up you can reuse all
439:39 - of the layers and simply rearrange stuff
439:42 - which I think is the easiest way to
439:44 - create your own levels but anyway this
439:47 - covers the entirety of the level the
439:49 - last thing that we have to work on is
439:50 - going to be the Overworld that's going
439:52 - to come for the next part to finish up
439:55 - this tutorial we have to create the
439:57 - Overworld and this is going to connect
439:59 - all of the various
440:00 - levels on top of that we want this thing
440:03 - to be somewhat Dynamic meaning we only
440:05 - want to display some of the paths the
440:07 - ones that have already been unlocked
440:10 - other than that we have to create a
440:12 - movement system and an input system but
440:14 - none of that is going to get too
440:15 - complicated first of all though let's
440:18 - get started by creating the basic
440:19 - outline of of the
440:21 - Overworld we are back inside of the code
440:25 - and I want to create a new python
440:29 - file that I'm going to save as Overworld
440:33 - dopy there we're going to store all of
440:35 - the Overworld logic first of all we need
440:37 - from settings and import everything
440:41 - after that I want to create a class
440:43 - called over
440:45 - world no need for inheritance on this
440:48 - one but we will as always need a Dunder
440:51 - init method for that we will need self
440:54 - we will need a
440:56 - TMX map we will need access to our data
441:00 - class and finally we will need to have
441:03 - some let's call them
441:04 - Overworld uncore frames once again for
441:08 - the Overworld we're going to import all
441:11 - of the graphics inside of the game and
441:13 - then pass them into the Overworld class
441:16 - first of all I want to create self.
441:18 - display uncore surface which we get with
441:21 - py game. display.
441:24 - getor
441:26 - surface also data should become an
441:28 - attribute so self. data is data after
441:32 - that I want to create a couple of groups
441:34 - later on although for now I simply want
441:36 - to have self.
441:38 - allore
441:39 - Sprites which at the moment is going to
441:42 - be a py
441:43 - game. sprite.
441:47 - group via this all Sprites we are going
441:49 - to draw the entire level and later on
441:52 - we're going to customize this even more
441:53 - to create a camera once again first of
441:56 - all I want to create a self. setup
441:59 - method into which we are going to pass
442:03 - the TMX map and the Overworld frames now
442:07 - this method doesn't exist right now so
442:09 - set up with self TMX map and the
442:12 - Overworld frames for now just to make
442:15 - sure this is working let's add a pass in
442:18 - here and then inside of main. P
442:20 - create the basic Overworld first of all
442:23 - for that we want from Overworld import
442:27 - the Overworld
442:29 - class and then inside of the Thunder
442:31 - init method we want to create one
442:34 - instance of this Overworld and at the
442:36 - moment our current stage is going to be
442:39 - the level but that is not what we want
442:42 - anymore I suppose for now I could simply
442:44 - comment it out and then get self.
442:47 - current stage and our current stage
442:49 - should be one instance of the Overworld
442:52 - class for that we're going to need a
442:55 - couple of arguments and let me copy all
442:57 - of the
442:58 - parameters first of all we will need a
443:01 - TMX map and that we don't have at the
443:04 - moment we only have the TMX maps for the
443:08 - levels but that we can fix quite easily
443:10 - I want to have self. TMX over World
443:14 - which we can import via the method we
443:17 - have already used for the level let me
443:19 - copy it
443:21 - and basically now if I once again open
443:23 - the project folder I can go to data and
443:25 - in there we have an Overworld folder
443:28 - which only contains a single file that
443:31 - is what we want to import meaning we
443:33 - want to go to data we want to go to over
443:36 - world and then we want to
443:38 - import over world.
443:42 - TMX and in case you are wondering this
443:44 - is what this TMX map looks like most
443:48 - importantly for now what we're going to
443:49 - work about are the two tile layers where
443:53 - we are going to import all of the
443:55 - background and then we have a couple of
443:57 - objects like the grass the rocks and the
443:59 - palm trees for now that's all we are
444:02 - going to need later on though we are
444:05 - going to have paths and nodes nodes are
444:08 - going to be the pathways to a level for
444:10 - example if I select this one you can see
444:13 - in the attributes we have two we are
444:16 - going to stage one on this note and we
444:19 - can only go down down and if we do that
444:21 - we are going to stage one which is going
444:24 - to be this one and from this point we
444:27 - can go left right and up and if we enter
444:31 - the level we are getting to stage
444:33 - one I will explain the system in much
444:35 - more detail later on for now you don't
444:37 - really have to worry about it the only
444:39 - thing that we are going to need is main
444:41 - top and objects first of all though we
444:44 - want to pass TMX Overworld into the
444:47 - Overworld class after that we need data
444:51 - and that is quite easy self. data
444:54 - finally we will need some Overworld
444:56 - frames which we are getting from import
444:58 - assets and now I can
445:01 - minimize everything else and then create
445:05 - self. over World frames which once again
445:10 - is going to be a dictionary for now I
445:13 - want to import two things in there the
445:15 - palms and the water background both of
445:18 - which are just a folder which are going
445:20 - to give us an animation nothing fancy
445:23 - here this is what we want to import so I
445:25 - want to import self. Overworld frames
445:29 - with that we have everything we need so
445:32 - next up I can minimize import assets and
445:35 - then we have to look at the run method
445:37 - because at the moment we are trying to
445:39 - run the well run method on the current
445:42 - stage but the Overworld doesn't have
445:45 - such a thing although we can fix that
445:48 - fairly easily we want to Define a run
445:50 - method with self and Delta time although
445:54 - for now pass and there is going to be
445:55 - enough if I now run all of this we can
445:58 - see that well we can't really see
446:00 - anything but that is the intended
446:03 - experience because inside of Overworld
446:05 - we are not drawing anything yet for that
446:09 - inside of the setup method I first of
446:11 - all want to get all of the
446:14 - tiles which means I want for layer in
446:18 - and this is going to be the the main
446:20 - layer and I want to have the top layer I
446:24 - should actually demonstrate at the
446:26 - moment the only thing that we care about
446:28 - is Main and top and if I zoom out main
446:32 - is basically the main part of the
446:34 - islands and top is stuff we always want
446:36 - to have on top of the main layer because
446:39 - of that it's quite important that we
446:41 - first call Main and then top because of
446:43 - that the top layers will be created
446:45 - after the main layer hence they're going
446:47 - to be on
446:48 - top if we didn't do that the entire
446:51 - thing would look a bit weird but anyway
446:53 - after that we can do for x y and the
446:57 - surface in TMX map and then once again
447:01 - get layer by name the layer we want to
447:05 - look at is the layer we are getting from
447:07 - the parent for
447:09 - Loop also don't forget we are now
447:11 - working with tiles so you want to add Do
447:14 - tiles at the end after that we simply
447:16 - want to create a Sprite this Sprite that
447:20 - we already created inside of Sprites
447:23 - this one to make that work I want from
447:27 - Sprites and import the Sprite
447:30 - class after that once again we will need
447:33 - a whole bunch of
447:36 - arguments the position we have already
447:38 - covered a couple of times we want X and
447:40 - Y however be careful this X and Y is a
447:43 - grid position whereas for the Sprite we
447:46 - want to have a pixel position meaning we
447:48 - want to multiply of those with the tile
447:51 - underscore
447:53 - size the surface we already have that
447:56 - we're getting from the for Loop groups
447:58 - is also easy we only have a single one
448:00 - self do all
448:02 - Sprites finally for the Z layers I want
448:05 - to have
448:07 - zore
448:08 - layers and then inside of
448:11 - settings I want to place all of those
448:14 - tiles on BG tiles let's paste it in
448:17 - there and then we should be good to go
448:20 - next up we have to call self. all
448:24 - Sprites do update with Delta time and
448:28 - self. all Sprites do draw on
448:31 - self. display
448:34 - surface now if we are running this we
448:37 - can somewhat see what's going on at the
448:40 - very least something is going to work
448:41 - since we don't have a camera at the
448:43 - moment this isn't going to work
448:45 - perfectly
448:46 - yet next up we can work on the watch
448:50 - for that one we want to fill the entire
448:52 - map with an animated Sprite that is
448:54 - going to display the water the one we
448:56 - have just imported if I find it really
448:59 - quick inside of import assets this water
449:03 - is a sprite
449:05 - animation which we want to play and for
449:08 - that I want for call in range TMX map.
449:14 - width after that for Row in range PMX
449:18 - map do height finally we can create an
449:22 - animated Sprite once again that we have
449:25 - already created inside of the Sprites
449:28 - class so I want to have this one with
449:30 - all of those arguments although I don't
449:33 - need the animation speed which means
449:36 - inside of the Overworld I want to import
449:38 - the animated Sprite and then pass in
449:42 - these
449:43 - arguments X and Y we can simply copy
449:48 - from the Sprite we have already created
449:50 - this one isn't going to change except X
449:53 - is going to be the column and Y is going
449:55 - to be the row RS we are going to get
449:58 - from Overworld frames and in there we
450:00 - want to get the water once again the one
450:03 - we have just
450:05 - imported groups is easy self do all
450:08 - Sprites and finally Z I can copy the Z
450:12 - layers from the Sprite although we do
450:14 - have to change the key I want the water
450:17 - to be in the background so BG layer if
450:20 - I'm running all of
450:22 - this we are getting something so we
450:26 - definitely have water but we cannot see
450:29 - the level
450:30 - anymore and you might have spotted
450:32 - already why at the moment we simply have
450:36 - a Sprite group we don't sort all of
450:39 - these Sprites by the Z layer as a
450:42 - consequence since we are creating the
450:43 - water after we are creating the other
450:45 - layers the water is going to be on top
450:48 - hence in of groups we want to create
450:51 - another Sprite group I want to minimize
450:53 - the all Sprites and then create a class
450:56 - called I called them World Sprites which
451:00 - once again has to be pame dos sprite.
451:02 - group for the inheritance we want to
451:05 - create a thunder in it method with self
451:09 - and we also want to pass the data in
451:10 - there I guess we can do it right away
451:13 - also we have to make sure that we are
451:15 - calling super thunder in nit although
451:17 - without any arguments also Al while we
451:19 - are here self. display surface is going
451:22 - to be pame do display. getor surface
451:26 - self. data should be the data none of
451:29 - that is too important what we rather
451:31 - want to do is update the draw method
451:35 - with self and I suppose for now we can
451:37 - also set a Target position very similar
451:40 - compared to what we have done inside of
451:42 - all Sprites all the way down here in
451:45 - fact while we are here I can copy the
451:48 - offset part s because those are going to
451:51 - stay the same and then in the dunder
451:53 - init method self. offset is going to be
451:57 - a basic Vector later on for the camera
452:00 - this part is going to become really
452:02 - important although for now we are only
452:04 - going to use the camera to show a bit
452:06 - more of the level what is much more
452:09 - important I want for sprite in sorted
452:14 - and then look at self then use a key to
452:16 - sort all of the Sprite via the Z
452:18 - position
452:19 - for that I will need a Lambda function
452:22 - with one parameter the
452:24 - Sprite all I want to return is Sprite do
452:27 - Z after that I want
452:31 - self. display surface. blit sprite.
452:35 - image and sprite.
452:38 - wct that should be a good start if I now
452:41 - go back to the Overworld and import from
452:45 - groups I call this one the world Sprites
452:49 - and then use these word Sprites as the
452:51 - group and while we are doing that we
452:53 - also have to pass in the data also we
452:56 - now cannot use the display surface
452:59 - inside of the draw method anymore
453:01 - instead we will need a
453:02 - position let's for now go with zero and
453:05 - zero now I can finally run M pi and now
453:08 - we can see the level on top of the water
453:11 - on top of that what I can do now inside
453:14 - of the groups I can use the offset to
453:17 - draw all of this with a well offset this
453:20 - is going to work exactly like it worked
453:22 - inside of all Sprites I want to create
453:24 - an offset position which is going to be
453:28 - sprite. rec. toop left plus self. offset
453:35 - although truth be told we could combine
453:37 - these two lines fairly easily all I
453:39 - really want to do is get the top left of
453:41 - the current Sprite rectangle and then
453:44 - add the offset we don't really need a
453:46 - whole line of code just for that but now
453:48 - if on m.p we are offsetting the entire
453:52 - thing although not in the right way
453:54 - let's say inside of all Sprites do draw
453:58 - I don't want to have zero and zero I
454:00 - want
454:01 - 1,000 and
454:05 - 800 now let's try. pi and that feels
454:08 - significantly better later on when we
454:11 - have a player this system can become
454:12 - more flexible but for now I'm quite
454:14 - happy with this next up then we can
454:17 - start working on the objects there have
454:21 - three objects that we have to import so
454:23 - if I look at the objects we have a whole
454:26 - bunch of pal trees we have some grass
454:29 - objects and finally we have a couple of
454:31 - rocks in the background all of those I
454:34 - want to import and if you look at their
454:36 - names we have an object called grass for
454:39 - the grass then we have a palm tree and
454:43 - finally we have somewhere in there is
454:46 - Stone as well importing all of that is
454:49 - going to be your exercise like we have
454:51 - done before I want you guys to import
454:53 - The Palms the rocks and the grass
454:56 - Sprites however you have to be aware
454:59 - that the Palms are animated meaning you
455:02 - have to get the frames for this
455:03 - animation instead of the surface that
455:05 - you're getting from til but try to
455:07 - figure this one out on your own and
455:09 - display everything pause the video now
455:11 - and see how far you
455:16 - get first of all we will need four obj
455:19 - in TMX map get layer by name the layer
455:24 - that we want to look at is called
455:26 - objects in there we basically have two
455:29 - options we have a palm tree which is
455:32 - going to be animated that one we can
455:34 - isolate with obj do name is equal to
455:38 - home if that is the case we want to
455:41 - create an animated Sprite but that we
455:43 - can do later the other case so else is
455:46 - going to be grass or stone
455:50 - neither of those are going to be
455:51 - animated meaning for them we can create
455:54 - a simple Sprite where we will need a
455:56 - position a surface groups and a z layer
456:00 - which is going to be the same for both
456:02 - of them the position will be obj dox and
456:06 - obj doy the surface is going to be obj
456:09 - do image groups is going to be self do
456:13 - Sprites although I just realized the Z
456:16 - layer has to be different for the two of
456:18 - them
456:19 - but that we can fix quite easily I want
456:22 - Z to be there Z layers in any case but
456:26 - then for the string I want to create an
456:28 - F string where we are adding a single
456:31 - value that value is going to
456:34 - be
456:36 - BG
456:38 - details but only if obj do name is equal
456:43 - to Grass if that is not the case else we
456:47 - want to be on the BG tiles layer that
456:50 - should be all we need if I now run may
456:52 - not Pi we have the grass and all of the
456:56 - Rocks now when it comes to the layers
456:58 - you will have to play around with what
457:00 - looks good it took me quite a bit of
457:02 - experimenting to see what worked best
457:05 - next up we want to work on the palms for
457:07 - that we will need an animated Sprite
457:10 - with a position frames the grops and a z
457:16 - layer the position is the easiest part
457:18 - that's the thing we have already seen a
457:20 - couple of times groups is also easy
457:23 - because we only have one self. all
457:25 - Sprites what is that layers I want that
457:28 - layers and the palm trees should be on
457:30 - the main layer finally we will need the
457:33 - frames and those we already have because
457:36 - inside of main. Pi in Overworld frames
457:38 - we have a palm key meaning for that I
457:42 - can basically copy what I've done for
457:44 - the water we want to get Overworld
457:46 - frames but not the water we want to have
457:48 - the
457:49 - Palm after that I can run main pi and we
457:53 - have a whole bunch of palm trees that
457:55 - looks pretty good
457:57 - although I want their animation speed to
458:00 - be a bit more
458:02 - randomized which we can do quite easily
458:04 - because there is an animation speed
458:06 - attribute inside of animated
458:08 - Sprite for that one I want to have a
458:11 - random integer let's say between four
458:14 - and six for that though we will need to
458:18 - from random import Rand in after that if
458:22 - I run main. P all of the palm trees are
458:26 - animating a bit more randomly which I
458:28 - think looks much better and with that we
458:31 - have set up the entirety of the
458:33 - Overworld wasn't actually so bad and the
458:36 - main thing that you basically have to
458:38 - learn about pame is that you always want
458:41 - to create a basic setup with Sprites and
458:43 - animated Sprites and whatever basic
458:46 - objects you need once you have all of
458:48 - those in place though it becomes really
458:50 - easy to set up even more complex
458:53 - levels next up then I want to minimize
458:57 - all the stuff we don't need anymore I
458:59 - want to create I call those the nodes
459:02 - and the layer basically a node is going
459:07 - to be one of these circles that are
459:09 - going to lead the player to a level all
459:12 - of these nodes are then connected by a
459:14 - path that we are going to create later
459:16 - for now it's not too important
459:19 - what I want to start with is create all
459:21 - of the notes and then place a player on
459:24 - one of them I will need for obj in TMX
459:30 - map. getet layer by name the layer we
459:33 - now want to look at is called
459:37 - notes and basically we are importing all
459:39 - of this where we have an object in a
459:43 - certain position and this one has a
459:44 - couple of attributes first of all in
459:47 - there I want to create create all of the
459:49 - nodes which I'm getting via an if
459:51 - statement
459:52 - objname is equal to node if that is the
459:56 - case I want to create what I called a
459:59 - node
460:00 - class which is going to be a Sprite
460:03 - meaning we want to work once again
460:04 - inside of the Sprites and let me
460:07 - collapse everything because we want to
460:10 - create a new class called
460:13 - note which needs to inherit from pame
460:16 - dos sprite. Sprite after that we will
460:19 - need a Dunder in nich method with self
460:23 - we want to specify a couple of things
460:25 - now first of all a position and a
460:27 - surface along with the
460:30 - groups after that we have to call Super
460:33 - Thunder init with the
460:36 - groups next up we want to set self.
460:39 - image to the surface we are getting and
460:42 - we want to get a self. rectangle now for
460:46 - this rectangle I want to get self. image
460:48 - . getet F rectangle but now we want to
460:52 - place the center and for the position
460:55 - let me zoom in when we are getting the
460:57 - position from tiled we always get the
461:00 - top left but we want to place a circle
461:03 - that's going to look something like this
461:06 - which should be around the center point
461:08 - of the tile we are importing meaning
461:10 - from this top left we have to go to the
461:12 - right and down by half the width and
461:15 - height of this cell which means I want
461:19 - to have a tupal and for X we want to
461:21 - have position with zero plus the tile
461:25 - size divid by two the same thing we want
461:28 - to do for y with the one difference that
461:31 - this should be position
461:33 - one after that we will need one more
461:36 - thing and that is self. z which we can
461:39 - get from Z layers and I want all of this
461:42 - to be on the path layer which I don't
461:45 - think we have used yet but it's this one
461:49 - righty with that we are getting a node
461:52 - and that we want to use inside of the
461:54 - Overworld for that we have to import the
461:58 - node and then add in all of the
462:00 - arguments let me copy them position
462:03 - surface and
462:05 - groups position is going to be obj dox
462:10 - and obj doy inside of a
462:13 - tubal surface we don't have yet that's
462:16 - going to come in a second but groups I
462:18 - want to have self. all Sprites so next
462:22 - up we will need surfaces for that I want
462:25 - to look inside of main.py because all of
462:28 - the Imports happen inside of Overworld
462:30 - frames what I want to import in there is
462:33 - going to be a larger file we want to
462:36 - import a folder as a dictionary from
462:38 - Graphics Overworld and path let's have a
462:41 - look at that one here we have the
462:42 - project folder and we want to go to
462:45 - Graphics in there we have an Overworld
462:48 - and then we have a path now all of this
462:52 - might look a bit weird but those are
462:54 - later on going to become the path the
462:57 - only thing that we care about for now is
462:59 - going to be the node to reach that one
463:02 - we want to get the Overworld frames in
463:05 - there we have a path and then inside of
463:08 - that dictionary we are getting a Noe
463:10 - file that should be it if I now run may
463:14 - not Pi we can see all of the noes that
463:17 - looks Prett pretty
463:19 - good however I want to pass a bit more
463:22 - information into them and for that let
463:25 - me use named arguments we want to have a
463:28 - position we want to have I believe I
463:30 - called this one the surface yep surface
463:33 - and finally we will need the
463:36 - groups after that I want to import let's
463:41 - call this one the level which we can get
463:44 - from obj do properties on that thing we
463:48 - have a stage attribute once again
463:50 - instead of tiled we are currently
463:52 - importing this
463:54 - attribute for example for the first
463:56 - level the one we are starting on this
463:58 - one this is going to be zero for the
464:00 - next one it is going to be one after
464:03 - that we have two and so on on top of
464:06 - that we want to pass in the data which
464:10 - we get with self. data after that inside
464:14 - of the Sprites and also by the way we
464:17 - don't need to play anymore at least for
464:19 - now so let me close it that way we have
464:21 - a bit more
464:22 - space I want to get the level and the
464:26 - data both of which will need to be an
464:29 - attribute self. level is going to be the
464:31 - level and self. data is going to be the
464:34 - data now this by itself isn't too useful
464:37 - however what we can do now if I open the
464:40 - data class we can add one more parameter
464:45 - let's call it
464:46 - unlocked level
464:49 - which we can set to zero at least for
464:51 - now after that inside of the groups when
464:55 - we are drawing all of the Sprites I want
464:58 - to check if we are on the path layer
465:01 - which I can check with if sprite.
465:04 - Z is equal to
465:09 - zcore layers and we want to check if we
465:13 - are on the path
465:15 - layer if that is the case we want to to
465:18 - do something else however else we simply
465:20 - want to draw all of the Sprites however
465:23 - if we are on the path layer which means
465:26 - for now we are looking at all of the
465:30 - nodes but we don't want to draw all of
465:32 - them we only want to draw the ones with
465:35 - the level that is below our currently
465:38 - unlocked level below or equal to I
465:41 - should say which means I want to check
465:44 - if
465:45 - sprite. level is smaller or equal to
465:51 - self. data Dot and now we can use the
465:55 - parameter we have just created unlocked
465:59 - level only if that is the case do we
466:02 - want to blit this particular node but
466:04 - then the blit method is the one we have
466:06 - already used we can simply copy it and
466:09 - now if I run m. Pi we can only see the
466:13 - first node the one with level zero
466:16 - however if we increase the un loock
466:18 - level to let's say three then we can see
466:21 - more of the notes later on we are going
466:25 - to change this number depending on what
466:27 - we are doing inside of the level for now
466:29 - though it's a good way to test if the
466:31 - entire Overworld system is going to work
466:34 - after we have that I want to create the
466:36 - player icon which is going to be another
466:39 - Sprite let's create it here class I call
466:41 - this one an icon which has to inherit
466:44 - from pame dos sprite. Sprite for that
466:48 - one we will need a thunder init method
466:51 - with self a position groups and Frames I
466:56 - want to call Super Dunder init with the
467:00 - groups after that I want to create an
467:03 - image and I want to create a rectangle
467:06 - for the image we want to get self.
467:09 - frames and self. frame index the value
467:14 - for those is going to be frames and zero
467:17 - we have seen this a couple of times by
467:18 - now also we will need self. state which
467:23 - by default is going to be idle after we
467:26 - have follow of that the image we are
467:28 - going to get with self. image is going
467:30 - to be self.
467:32 - frames with self. State and then we
467:36 - getting a list of surfaces from which we
467:38 - want to pick via self. frame index and I
467:42 - suppose I'm jumping ahead a little bit
467:44 - first of all what we want to do if we go
467:47 - to the Overworld folder there we have a
467:49 - folder called icon and there we have a
467:52 - bunch of States if we look at the idle
467:55 - one we can see this is the player
467:57 - standing Idol if we look at down we have
468:00 - a down walking animation and if you look
468:03 - at left or right we have a left or right
468:06 - walking animation all of this we first
468:08 - of all want to import and then animate
468:11 - through inside of the icon class should
468:13 - have gone step by step here so let's
468:15 - start with step number one we want to
468:18 - import all of these surfaces which we
468:21 - can do with a another key called icon
468:24 - and then import subfolders we want to go
468:27 - a folder up Graphics Overworld and icon
468:30 - that's all we need after that we are
468:32 - going to create a player inside of the
468:34 - for Loop where we are going to create
468:36 - the nodes simply because when the
468:39 - Overworld is being created we want to
468:41 - have the player on one of those nodes
468:44 - depending on what level is currently
468:46 - unlocked so we want to have another
468:48 - entry for the player I want to check if
468:51 - obj do name is equal
468:55 - to node and on top of that I want to
468:59 - check what the current level is that we
469:03 - don't know at the moment actually
469:04 - because inside of data we only store
469:07 - what the currently unlocked level is but
469:10 - on top of that we will need a self.
469:13 - current uncore level for now let's set
469:17 - this one to Z after that once we have a
469:20 - note I can check what the stage of this
469:23 - note is that I am once again getting
469:25 - from obj do properties and Stage I can
469:28 - actually just copy this one I want to
469:30 - check if the current stage of the node
469:33 - is equal to self. dat. current uncore
469:38 - level if that is the case we know we are
469:41 - on a node and the level of this node is
469:44 - equal to our current level which means
469:47 - the player should be on this Noe hence
469:49 - we want to create an icon if that is the
469:51 - case which we also want to store inside
469:53 - of an attribute self. icon is going to
469:56 - be icon then next up inside of the
470:00 - Sprites we have to get the parameters
470:04 - for the position I want to get obj dox
470:06 - and obj
470:08 - doy however this would once again be the
470:11 - top left but I want to place the player
470:14 - right in the center of this and for that
470:17 - I want to add tile size divided by two
470:22 - groups is going to be easy self dot all
470:24 - Sprites and the frames are going to be
470:26 - the Overworld frames for the icon after
470:31 - we have all of that at the top we also
470:34 - shouldn't forget to import the icon and
470:37 - now I can run m.p and we're getting an
470:40 - error that icon has no attribute Z that
470:43 - makes sense because inside of the icon
470:45 - we will need a z parameter and we will
470:48 - need a rectangle self. Z is easy it's
470:51 - simply going to be Z layers and we want
470:54 - to be on the main
470:56 - layer after that we will need the
470:59 - rectangle that we can get with self.
471:01 - rect being self. image. getet F
471:06 - rectangle where we want to place the
471:08 - center to wherever the position is after
471:12 - that let's try main. pi and there we can
471:14 - see we have the player in roughly the
471:17 - right position
471:19 - on top of that inside of data if I set
471:21 - the current level to a one then we start
471:24 - on the first level or first level node
471:27 - and if I set it to a two then we are
471:30 - adding up there also now that we have an
471:34 - icon we can update the camera we don't
471:37 - want to have a static position we want
471:40 - this to be self. icon. rec. center now
471:45 - if I run all of this again we can see
471:47 - that the player is right in the center
471:49 - on the correct note however we have two
471:52 - problems number one is that the player
471:55 - is quite far down I would rather have
471:57 - the player a bit further roughly up here
472:01 - on top of that you can see that this
472:03 - palm tree is behind the player and that
472:07 - I really don't like it looks super weird
472:10 - to fix all of that we have to work
472:12 - inside of groups. Pi because in there we
472:16 - have to sort all of the Sprites again in
472:18 - another way I want to split the drawing
472:21 - logic into two parts where first of all
472:24 - we are drawing all of the background and
472:27 - wow that is spelled
472:29 - background and after we have done all of
472:32 - that we want to draw the main layer now
472:35 - the background we have mostly covered
472:38 - for that we can reuse the stuff we have
472:40 - already written although with one
472:43 - modification I want to check if Sprite
472:46 - doz is smaller than Z layers and Main
472:52 - only if that is the case do we want to
472:54 - do all of that if I now run may not Pi
472:58 - again we can only see all of the layers
473:01 - up to the main layer not including the
473:03 - main layer for that we will need another
473:07 - for Loop and the main for Loop we
473:10 - basically want to copy although the
473:13 - sorted method needs to be
473:15 - updated the way you want to think about
473:18 - it and to explain that let me comment it
473:20 - out and then set this to smaller or
473:24 - equal to the main layer because of that
473:27 - we can now see the main layer again but
473:30 - we still have the issue with the palm
473:32 - tree that we have to work on and the way
473:35 - to fix that kind of issue is to sort all
473:38 - of the Sprites via the Y position which
473:42 - means imagine that this palm tree at the
473:44 - moment has a wi position of
473:48 - 300 the Y position of the player on the
473:51 - center is going to be
473:54 - 350 and the Y position of this palm tree
473:58 - is going to be I don't know
474:01 - 400 these numbers we can get quite
474:03 - easily simply when we are creating the
474:05 - Sprite we can get the number from the
474:07 - center however then we want to use that
474:09 - number to order the Sprites meaning we
474:13 - want to Simply sort the Sprite via the
474:15 - white position and then this Sprite will
474:17 - be drawn first then we have this Sprite
474:20 - and then we have that Sprite which means
474:22 - that this Sprite since it was drawn last
474:24 - will be on top and implementing all of
474:27 - that logic is honestly not that
474:29 - difficult basically what we want to do
474:32 - for sprite in sort itself that is going
474:34 - to give us all of the Sprites but then
474:37 - when we have the Lambda function to sort
474:39 - it we do not want to get sprite. Z
474:42 - instead we want to get sprite. rec.
474:45 - Center y and that's all we need now we
474:48 - are sorting all of the Sprites via the Y
474:51 - position after that I want to check if
474:54 - Sprite dot Z is on top of the main layer
474:59 - also this needs to
475:01 - be that layers and Main if that is the
475:05 - case once again we can use the blit
475:07 - method like so if I now run all of this
475:11 - we can see that the player is behind the
475:13 - palm trees which is really all we needed
475:17 - in in my camera video I explain the
475:19 - logic for all of this in a bit more
475:20 - detail so check this one out if you are
475:22 - interested next one then we can work on
475:26 - the offset for the player so once again
475:28 - and let me place the player in an easier
475:31 - to see position current level zero that
475:34 - should bring the player in a bit more of
475:36 - an open field so that looks good but I
475:39 - want the player to be a bit further up
475:41 - so that for example the player would be
475:43 - something like this at the moment it
475:45 - just looks like the player is too far
475:47 - down to work on that we could work
475:50 - inside of the Sprites but in there this
475:53 - would be kind of awkward because we have
475:56 - the image and we have the rectangle
475:58 - which is going to give us the entire
476:00 - Sprite and we don't really want to mess
476:02 - with those what is going to be much
476:04 - easier is to give this icon some kind of
476:07 - attribute to identify it self. icon and
476:10 - set this one to True with that inside of
476:13 - the groups we can identify the Sprite if
476:16 - has
476:18 - attribute I want to check if the Sprite
476:21 - has an attribute called icon which only
476:24 - the icon is going to
476:26 - have if that is the case I want to do
476:28 - something however if that is not the
476:30 - case I want to draw all of the other
476:33 - Sprites however if that is the case I
476:36 - still want to use the blit
476:38 - method but then I also want to add an
476:41 - extra offset to it which we do by adding
476:44 - another Vector with zero the number in
476:47 - my case is -28 if I now run main. Pi the
476:51 - player is really nicely in the middle of
476:53 - the
476:54 - node although inside of the icon class
476:58 - we haven't made any change simply inside
477:00 - of the camera draw logic whenever we
477:02 - have this icon we always drawing it a
477:05 - little bit higher which just looks a
477:07 - whole lot nicer cool and with that we
477:10 - have the whole setup for the level next
477:12 - up we can work on the paths in this part
477:15 - we are going to add the movement to the
477:17 - Overworld on top of that we're going to
477:19 - create a connection between the levels
477:21 - and the Overworld which means by the end
477:24 - of this part we basically have a
477:26 - finished game there are some minor bits
477:29 - we still have to add but those really
477:31 - aren't going to be any kind of problem
477:33 - let's get started with the movement
477:35 - first of all I want to start inside of
477:38 - til because in there we have a layer
477:41 - called paths and this is the only thing
477:43 - I want to look at for now so if you look
477:46 - at this you can see we have a whole
477:48 - bunch of triangles those are going to be
477:51 - our path the way you want to think about
477:53 - it and let me show the notes as well the
477:57 - notes we have already seen for example
477:59 - this note would get us to the first
478:01 - level or level zero inside of the game
478:05 - from this note I want to have a path
478:07 - that goes this way and this way and then
478:09 - finally ends on note for level one that
478:13 - is what the triangle is for effectively
478:16 - we're going to import the corner points
478:18 - of it those are then going to give us
478:21 - the path that the player will follow for
478:23 - all of that inside of the Overworld we
478:26 - want to work in the setup method and
478:29 - that has to happen before we are
478:30 - creating the nodes and the player you
478:33 - will see just in a second why but
478:35 - basically I want to have another section
478:37 - that I'm going to call paths and there
478:39 - first of all I want to create a for loop
478:42 - as we have done multiple times already
478:44 - for obj in TMX map get layer by name the
478:48 - layer we now want to get is called paths
478:52 - now these objects are going to work a
478:54 - little bit different compared to what we
478:56 - have already seen so for example we
478:58 - already have seen obj dox obj doy and
479:02 - things like that but something that I
479:04 - haven't used yet is obj do points if I
479:08 - print that one to show what we
479:12 - get I can run the
479:14 - code and then after second we are
479:18 - getting a whole bunch of points or
479:20 - rather we are always getting a tupal
479:23 - that contains points that we can look at
479:26 - those are the points that Define the
479:27 - shape that I have created and
479:29 - tiled I.E the points I have just talked
479:32 - about so for each of these objects we
479:35 - have these points here although these
479:38 - points I do want to store which I'm
479:40 - going to do inside of a PA list for that
479:44 - I am going to use list comprehension
479:47 - for now let's say I want to have P for p
479:50 - in obj do
479:53 - points with that we are essentially
479:56 - making a copy of the list but that's not
479:59 - exactly what I want to do instead I want
480:01 - to have a tupo with P do X and P
480:07 - doy what I should mention obj points is
480:10 - going to give us a list with Point
480:12 - objects and inside of each point object
480:15 - we have a couple of attributes like p.x
480:18 - or p.y if I am extracting all of that I
480:22 - can print the position and now we are
480:25 - getting a list with a couple of position
480:29 - two builds that's a good start but I
480:31 - want to have a little bit more if you
480:33 - look at tiled once again we have the
480:36 - node in the usual position and ideally I
480:39 - want the path to start in the center of
480:41 - that node but that is not what we have
480:44 - at the moment we always start in the top
480:47 - left of this note and this happens for
480:49 - all of these nodes if I zoom
480:54 - around you can see that the paths always
480:57 - start and end on the top left of all of
481:00 - these
481:01 - nodes that is for a reason because with
481:05 - that system I can always snap to the
481:07 - grid which makes my life much easier to
481:09 - arrange these points in pame however we
481:12 - do have to adjust for that which
481:14 - fortunately isn't too difficult all that
481:17 - we really want to do is to add the tile
481:20 - size and divide it by
481:22 - two that way we end up in the center of
481:24 - the cell also I really want to have
481:27 - integers for all of this after all of
481:30 - that I am getting a list with position T
481:33 - bus that start in the center of the node
481:35 - and then go to the center of the target
481:37 - position or Target node rather on top of
481:40 - that I want to capture a couple of
481:42 - properties two in particular one for the
481:45 - start of the path and and another for
481:47 - the end of the path both of which I can
481:50 - get via obj do properties because each
481:53 - path has two properties one for start
481:57 - and then another one for the end and as
481:59 - always if you look at tiled and select
482:02 - the path we have an end attribute and a
482:05 - start attribute this is what we are
482:07 - currently importing and after I have all
482:09 - of that I need to store these points
482:12 - more generally which I'm going to do via
482:15 - a dictionary that I'm going to call
482:17 - self.
482:18 - paths at the beginning it's simply going
482:21 - to be an empty dictionary but then
482:23 - inside of this for loop I want to get
482:26 - self. paths create a new key with the
482:30 - end of the
482:31 - path the value is going to be a another
482:34 - dictionary where we have the
482:37 - position which will be the current
482:39 - position for this path or the position
482:41 - points besides that I also want to have
482:44 - a start entry with this start level
482:48 - after we have all of that I can print
482:51 - self. paths and then run all of this
482:54 - again and now we are getting a
482:57 - dictionary with all of our paths to
483:00 - illustrate what is going on here let's
483:02 - have a look at this one
483:05 - entry we have a starting point on level
483:08 - zero and the end point is going to be
483:11 - level one the positions are going to be
483:14 - 672 and 800
483:17 - then on the next point we are going to
483:19 - 672 and 980 meaning we are only going
483:23 - down after that we are going to 992 and
483:26 - to
483:27 - 928 the only value that changes is X
483:31 - meaning we are going to the
483:34 - right this is exactly the path to go
483:36 - from here to
483:38 - here after we have that we want to work
483:42 - inside of the nodes because in there we
483:45 - need to know what kind of paths are
483:47 - available from each node intitled I can
483:50 - explain all of this a bit better imagine
483:53 - we are on this starting node for stage
483:56 - Zero from this point we have to know in
483:59 - what direction we can go in and for that
484:01 - we have the other custom properties for
484:03 - example for this node there's only one
484:05 - direction down and if we do go down we
484:09 - go on path number one which is going to
484:12 - lead us to this end
484:15 - level if if we end up on this level we
484:17 - have quite a few more options we are
484:20 - still on stage one but then we can go up
484:23 - right or left if we go right we go to
484:26 - stage number three and if we go up we go
484:28 - to stage number two however if we go
484:30 - left we go on stage number one but in
484:34 - Reverse which means we end up back up
484:36 - here so these directions we now have to
484:40 - import and then get them into the node
484:43 - now for that I first of all want to
484:45 - clean up the data
484:47 - let's say I want to create let's call
484:49 - this one
484:51 - available
484:53 - paths for that I want to create a
484:56 - dictionary where we will need a key and
484:59 - a value so let's say 4K and value in obj
485:06 - dot properties and we want to look at
485:10 - all of the items let's print what we're
485:12 - getting from that so print available
485:15 - paths if I now run all of this we're
485:17 - getting a dictionary where we have down
485:20 - left down right at some point we also
485:22 - have up and that's a good start but we
485:26 - do not want to have something like this
485:27 - stage in there to get rid of that we
485:30 - only want to get the value if K is in
485:35 - the list with all of the directions so
485:39 - left
485:41 - right up or
485:45 - down if that is working then we only get
485:49 - the available directions that
485:51 - information we now have to pass into the
485:54 - node I suppose inside of the node we can
485:57 - simply call it paths and we want to
485:59 - assign it the available paths after that
486:03 - inside of the Sprites let me minimize
486:06 - everything because we at the moment only
486:09 - care about the nodes and there we want
486:11 - to have another parameter for the
486:13 - paths which we also want to store at as
486:16 - an attribute self. paths is going to be
486:19 - paths with that inside of each note we
486:22 - know which direction we are going to go
486:25 - which is then in turn going to become
486:28 - important for the icon because this is
486:30 - the object that will actually start
486:32 - moving the way that is going to work
486:35 - back inside of the Overworld we first of
486:38 - all want to get some kind of input that
486:41 - can be another method
486:45 - input inside of that method we want to
486:48 - check all of the Pressed keys so py
486:51 - game. Keys
486:53 - doget pressed for now the only thing
486:56 - that I want to check is one key input if
487:00 - keys and py game. Kore down if that is
487:05 - the case I want to move the player from
487:08 - stage zero to stage one or rather from
487:11 - the note for stage zero to the note of
487:13 - stage one to be a bit more precise to be
487:16 - able to check if this is the case we
487:19 - first of all have to know what node the
487:21 - player is on to achieve that I want to
487:25 - create another attribute if self and I
487:28 - call this one the current
487:31 - node we first of all want to check if
487:34 - the player even is on a node I.E the
487:37 - player could either be on a node or
487:39 - walking if the player is walking we
487:41 - shouldn't accept keyboard input at all
487:43 - anyway but then if we are on a current
487:46 - node we only want to accept keyboard
487:49 - input if we are pressing down and self.
487:52 - current node. cancore move with down so
487:59 - I hope the logic makes sense here we
488:01 - only want to move the player or allow
488:03 - keyboard input in the first place if the
488:05 - player is on a node and if the node
488:08 - allows the player to move down now for
488:10 - that first of all we are going to need a
488:13 - current node and then the current node
488:15 - needs to have have a mve down
488:18 - method let's start with the current node
488:22 - after we are running the setup method I
488:24 - want to get self. Curren node now to get
488:28 - the current node I simply want to get
488:31 - the node that the player is standing on
488:34 - but that is a bit of an issue right now
488:36 - because we don't have easy access to all
488:38 - of the nodes but that we can fix by
488:40 - adding another group besides self. all
488:43 - Sprites I want the notes also to be in
488:45 - self do node
488:48 - Sprites this group does not exist right
488:51 - now so all the way at the top I want to
488:53 - create self. no Sprites which is going
488:56 - to be py game. sprite.
488:59 - group after that I want to at the moment
489:03 - simply get the note with the level zero
489:06 - that I'm going to get with note for a
489:08 - note in self. node
489:12 - Sprites but only if node do
489:16 - level is equal to zero that is going to
489:20 - return me a list with one item from
489:23 - which I want to get the first index that
489:26 - way we get one Noe that has the right
489:30 - level and after that we don't need to
489:32 - setup method anymore we have to give the
489:35 - note a can move method and we are simply
489:39 - talking about these notes here so these
489:42 - notes need to have a cancore move method
489:47 - with self and a Direction all we really
489:50 - have to check is if the direction is
489:54 - in a list with self. paths and then we
489:59 - only really care about the keys on this
490:01 - one essentially paths is what we have
490:04 - created earlier when we have run the
490:07 - setup method with all of this where we
490:10 - have gotten the available
490:13 - paths those are stored inside of self.
490:15 - paths inside of the node and now when we
490:18 - are running can move we are passing in a
490:21 - direction to check if we for example can
490:23 - go up or left or right or in our case if
490:26 - we can go down if this down is inside of
490:32 - the keys of self. paths then we want
490:36 - to return through and now I have added a
490:40 - ton of code so let's actually check if
490:43 - all of this is working I want to print
490:45 - can and move down also we have to call
490:49 - the input method which I want to do all
490:51 - the way at the beginning of the run
490:53 - method self.
490:56 - input let's try main. pi and we're
491:00 - getting an error
491:03 - that this should be py game. key. getet
491:06 - pressed next attempt the game doesn't
491:09 - crash and now if I press down we get the
491:12 - message can move down however if I'm
491:14 - pressing any other a key we don't get
491:17 - anything else so that looks pretty solid
491:21 - and I do realize at this point the logic
491:23 - does get a bit more advanced but
491:26 - ultimately all that you really have to
491:28 - understand is that when we are running
491:30 - the dunder init method we are inside of
491:33 - the setup method create a whole bunch of
491:36 - nodes that happens down here each of
491:40 - these nodes is going to get available
491:42 - paths and then the value is going to be
491:44 - the relevant path that we can walk
491:47 - on all of that we are then passing into
491:49 - the node and then inside of the node we
491:53 - are checking via the can move method
491:55 - once the player gets input if this
491:57 - direction is indeed inside of this
492:01 - dictionary if that is the case
492:03 - [Music]
492:05 - then we at the moment simply print can
492:08 - move
492:09 - down but obviously we don't just want to
492:12 - print something we want to make the
492:14 - player move which we can do via self.
492:17 - move with the direction in this case
492:20 - down that method doesn't exist right now
492:23 - so defined move with self and a
492:26 - Direction first of all in there I want
492:29 - to get a path
492:31 - key which is going to be our self.
492:35 - current node and on there I want to get
492:37 - all of the
492:39 - paths we once again want to get the
492:41 - direction we have just used and since we
492:45 - have checked if we can move in this
492:47 - direction we know that this direction
492:50 - does exist inside of the
492:51 - paths let me print what we are getting
492:54 - print path key and now I run main. pi
492:58 - and I press down we're getting
493:00 - one however at this point you really
493:03 - want to be careful because if I show the
493:08 - type so what kind of data type we have
493:11 - for this variable we are going to get
493:13 - class string we are not getting an
493:16 - integer what we are getting is a string
493:20 - that happens to look like an integer but
493:23 - it's ultimately still a string so if you
493:26 - look at tiled once again and one of the
493:28 - nodes and we could look at any of these
493:30 - left right or up custom
493:33 - properties all of these are strings and
493:36 - you can see this in particular for this
493:37 - one for left we have one r that means we
493:41 - want to go on path one in Reverse for
493:44 - that system to work
493:46 - I have set all of these custom
493:48 - properties to be strings and to make
493:50 - sure this doesn't cause a problem down
493:52 - the line I want to get the index zero
493:55 - and turn all of this into an integer
494:00 - that way we are still getting the same
494:01 - result so if I press we are now getting
494:04 - an integer although if we don't show the
494:07 - type we should now still see just a one
494:11 - and there we go now we get the right
494:14 - path however we also want to know if
494:17 - we're going to reverse the path or not
494:19 - for that I have another local variable
494:23 - pathore
494:24 - reverse this by default is going to be
494:27 - true but only if self. current node.
494:31 - paths with the current direction and
494:34 - then we always want to look at the last
494:36 - entry inside of the string meaning -1 if
494:41 - that value is equal to the string R then
494:44 - we want to reverse the direction I.E
494:46 - this one should be true however if that
494:49 - is not the case the value should be
494:51 - false with that we know the key of the
494:54 - path we want to get and if that path
494:56 - should be
494:58 - reversed after that we can finally get
495:01 - the actual path I want to finally get
495:04 - self. paths the one we have created
495:07 - earlier all of
495:09 - this we can identify all of the paths
495:12 - simply by their end
495:14 - key which means self. paths is going to
495:18 - get an indexing with path
495:21 - P although from all of that we are going
495:24 - to get a dictionary from which we only
495:27 - really want to get the
495:29 - position on top of that I want to get
495:32 - all of the points but only if not have
495:38 - reverse if however we do want to reverse
495:42 - the path then there should be an El
495:43 - statement where we we are getting all of
495:47 - that except we are reversing all of that
495:52 - which we can do with semicolon semicolon
495:54 - and
495:55 - ne1 that's the easiest way to reverse a
495:57 - list in Python and with that we are
496:00 - getting a path let me print the path and
496:03 - run main. Pi if I now press down we are
496:07 - getting a list of values I want a player
496:10 - to go to this point once we are reaching
496:12 - that point the player should go to this
496:14 - point and once we're reaching that point
496:16 - the player should go to that point and
496:18 - once we are reaching that point we
496:20 - should be on the next node for all of
496:23 - that I want to work inside of the icon
496:26 - which means I want to get self. icon and
496:28 - then call a start move method with the
496:31 - path next up then inside of the Sprites
496:35 - I want to work inside of the icon at the
496:39 - moment we if we are going to run the
496:41 - code are going to get an error message
496:43 - because we do not have a can move method
496:46 - with self and a path but now if we are
496:50 - going to start moving I want to first of
496:53 - all update the
496:54 - rectangle center of the player to the
496:58 - first position of the path meaning path
497:01 - and
497:02 - zero after that I want to store the path
497:05 - itself although for that I want to
497:08 - create an attribute let's call it self.
497:13 - path and we can put that all the way at
497:15 - the top that feels a bit better
497:16 - organized by default this value is going
497:19 - to be
497:22 - none however once the player starts
497:25 - moving then I want to set self. path to
497:30 - the path we are getting via the
497:31 - parameters but we don't want all of the
497:34 - path because remember if we are getting
497:37 - three points for example with this being
497:39 - our starting point this being the corner
497:42 - point and this being the Final
497:44 - Destination
497:46 - the starting point we don't really need
497:48 - anymore because this is where the player
497:50 - starts so from that point we simply want
497:52 - to move
497:53 - down and we don't really need this point
497:56 - in the first place at least after we
497:59 - have set the center of the player to
498:00 - that point as a consequence when we are
498:04 - setting the path we only want to get
498:07 - from index one all the way to the end
498:10 - after we have that I want to run a
498:12 - method called self. find under score
498:15 - path and that might sound a bit weird
498:19 - but let me explain once again imagine we
498:22 - have three points that we want to move
498:25 - along with the player starting on this
498:27 - point by default the player has no idea
498:30 - in what direction to move
498:33 - in that is what fine path is for it is
498:37 - going to tell the player icon in which
498:38 - direction to move so in this case we
498:40 - want to move down we figure that part
498:44 - out let's create the method I want
498:47 - Define find
498:49 - path no need for custom parameters in
498:52 - that one and first of all I only want to
498:54 - run logic in there if we have a path
498:57 - inside of the icon after that I want to
499:00 - check if self. re. Center X is equal to
499:06 - self. path and then I want to get the
499:08 - path with zero and zero to visualize
499:13 - what that means let me print self do
499:16 - path once we're doing all of that also
499:18 - let me add pass in there just so we
499:20 - don't get an error if I now run m.p and
499:23 - I press down we are getting an
499:26 - error that the icon object has no
499:29 - attributes St to
499:31 - move ah that is because I call this
499:33 - method can move instead of start move
499:37 - let's try this again I can press down
499:39 - and now we are getting a list with
499:42 - points in the path and what we are doing
499:45 - at the moment is we are checking the
499:47 - current horizontal center of the player
499:51 - against self. path with zero so we
499:54 - getting the first entry and then in
499:58 - there we are checking the x value the
500:00 - one with the index zero I.E the
500:04 - 672 that would be the exposition of the
500:07 - next node and to understand that once
500:10 - again imagine we have our three points
500:13 - at the moment we want to check which
500:14 - which direction the player can go in and
500:18 - one way to figure that out is if the
500:19 - current position of the player and the
500:22 - next node have the same Exposition then
500:25 - we know they are on the same
500:28 - line which means that the player can
500:30 - either go up or
500:32 - down that part we don't know yet but at
500:36 - least we know that we can move on the
500:37 - vertical axis in there we can set self.
500:43 - Direction which is going to be a vector
500:47 - that needs X and Y X is always going to
500:50 - be zero because remember we can now only
500:53 - move up or down hence the direction for
500:56 - X should not do anything and Y should be
500:59 - one but only if self.
501:03 - path with zero and now one so we are
501:08 - checking the Y position of the first
501:10 - point in the
501:12 - path if that point is great greater than
501:15 - self. rect do Center y then we know that
501:19 - the first point in the path is below the
501:21 - player so the player should move down
501:24 - however if that is not the case so else
501:26 - then we should be moving up and after we
501:29 - have that I can run the else statement
501:32 - and in there we are going to move on the
501:35 - horizontal axis the logic in there is
501:38 - going to be reasonably similar so let me
501:40 - copy all of this but now we only want to
501:43 - move on the horizontal
501:45 - so y should be zero but X should be one
501:49 - but only if self. path Z and zero is
501:54 - greater than self. re. Center X I.E the
501:59 - next point in the path is to the right
502:00 - of the player then we should go to the
502:03 - right if that is not the case else we
502:06 - should be going to the left that is
502:08 - going to give us the direction the
502:10 - player should be moving
502:12 - in also just as a safeguard if we do not
502:17 - have a path then I want to run an El
502:19 - statement where self. direction is going
502:23 - to be a vector without any movement so
502:26 - the values for this one should be zero
502:27 - and zero which we're getting by
502:30 - default also at this point we should
502:33 - specify a self. direction Vector in the
502:36 - init
502:37 - method we should always have a direction
502:39 - even when we are just creating the class
502:42 - cool but with that we can find the
502:46 - direction which by the way might have
502:48 - been a better name for this function but
502:50 - doesn't really matter after we have it
502:53 - though I can minimize it because now we
502:56 - can run the update method with self and
502:59 - Delta time essentially all that we want
503:02 - to do is if self. path so if the icon
503:07 - currently has a path then we want to set
503:09 - self. re.
503:12 - Center by self. Direct Direction
503:15 - multiplied with some kind of speed let's
503:17 - say self. speed multiplied with Delta
503:20 - time now speed we don't have yet for
503:24 - that self. speed is going to be I went
503:27 - with
503:29 - 400 and now inside of main. Pi if I
503:33 - press down the player moves down
503:35 - although the player never stops moving
503:37 - down and eventually this gets kind of
503:39 - silly but at the very least we do have a
503:42 - start the issue at the moment is is that
503:44 - the player doesn't respect the corner we
503:47 - are simply running fine path once and
503:49 - the player will always move in that
503:51 - direction so at the moment we have the
503:53 - starting position of the player the next
503:55 - point in the path and the final point in
503:57 - the path since the first point in the
503:59 - path was right below the player because
504:02 - of that the player kept on moving in
504:04 - that direction but we only want the
504:06 - player to move up to this point and then
504:09 - move to the right for that we will need
504:13 - another method it I call this one the
504:17 - point
504:19 - Collision without any custom parameters
504:23 - the logic for this one is going to be if
504:25 - self. direction is going to be one I.E
504:30 - at the moment we are moving down and on
504:32 - top of that we want to check and self
504:36 - dot rect do Center Y is greater or equal
504:43 - to self. path and then we want to get
504:46 - the next point in the path which is
504:48 - always going to be path zero on this
504:51 - point at the moment we only care about
504:53 - why so if the player is moving down and
504:56 - then exceeding the next y point in the
504:59 - path if that is the
505:01 - case we want to set self. re. Center y
505:06 - exactly to this point so self do path
505:09 - with zero and one and after that we want
505:13 - to delete
505:16 - self. path with zero and after that we
505:20 - want to run self. find path once again
505:23 - the way you want to think about that and
505:25 - I hope you're not entirely lost yet we
505:28 - once again have the three points and at
505:30 - the moment the player is moving down
505:34 - however at some point the player is
505:36 - going to exceed this point which is
505:39 - going to trigger this
505:41 - function because of that we are going to
505:44 - to set the player back to the center of
505:47 - this point that is this line after that
505:50 - we are deleting the point we are
505:52 - currently on so this point from our path
505:55 - list finally we are running find path
505:59 - again so we are checking the direction
506:00 - from this point to this point I.E the
506:04 - player should start moving to the right
506:07 - although to make sure that this is
506:08 - working we also have to call it I want
506:11 - to run self. Point Collision
506:15 - and now inside of main. Pi I can press
506:17 - down and nothing
506:19 - happens and I also realize why this
506:22 - should be self. Direction
506:25 - doy now let's try this again and now
506:29 - we're getting an error but at the very
506:31 - least we know that this function is
506:34 - doing
506:35 - something we are setting the center of
506:37 - the player so a point with X and Y to
506:41 - only a single point we want to instead
506:44 - assign Center y to that point next
506:47 - attempt if I now go down and now the
506:50 - player is moving in the right direction
506:52 - although the player never stops once we
506:54 - reach the Final Destination that is
506:56 - going to be fixed once we get all of the
506:59 - points inside of the point Collision I
507:02 - suppose first of all we can start with
507:04 - the up movement I.E we want to check
507:09 - or and let's put all of that on another
507:11 - line I want to copy all all of that and
507:16 - then check if self. Direction doy is -1
507:21 - and then if self. rec. Center Y is
507:23 - smaller or equal to self. path 0 and one
507:28 - if that is the case once again I want to
507:30 - set the vertical center of the player to
507:32 - this point delete the next PATH point
507:34 - and then find A New Path direction that
507:37 - would cover the vertical part next up we
507:40 - can cover the horizontal bit which is
507:42 - going to be if self direction dox is
507:47 - going to be one and self. rec.
507:51 - centerx is greater or equal than self.
507:55 - path with zero and
507:58 - zero or we want to do the very same
508:02 - thing except now we are going to the
508:05 - left and we want to check if the player
508:07 - is below that point if either of those
508:10 - conditions are true then we want to set
508:12 - self. re. Center X to self. path with
508:17 - zero and zero we also want to delete the
508:21 - next point in the path so delete self.
508:24 - path with zero and finally we want to
508:28 - find a new path with that let's try May
508:31 - notp again and now the player stops when
508:35 - we are going to the right so this
508:37 - condition is true then we are at some
508:40 - point exceeding this point and we are
508:42 - deleting the final point in the
508:44 - path after that find. path since the
508:48 - path is going to be empty this if
508:51 - statement is not going to trigger
508:52 - anymore and the consequence will be that
508:55 - self. direction will be an empty Vector
508:57 - hence the player is not going to move
509:00 - anymore so we are definitely making
509:02 - progress however if I now run main.py
509:05 - again this is still working but if I now
509:07 - press down again we are once again
509:10 - starting on stage zero that is because
509:14 - because inside of the Overworld we are
509:16 - never updating the current
509:19 - node although that we can fix fairly
509:21 - easily I want to get the current
509:25 - Noe no need for custom parameters in
509:28 - this one and basically all I really want
509:30 - to check is I want to get all of the
509:33 - notes since those are Sprites I can run
509:35 - pygame dos sprite. Sprite to
509:39 - light with self. icon self. node Sprites
509:45 - and Bs I simply want to get all of the
509:48 - notes that the player icon is colliding
509:50 - with if we do have nodes then I want to
509:54 - update self. current
509:57 - node to the first item that the player
510:00 - has collided with now for this system
510:04 - you have to make sure that the notes are
510:05 - always far apart so the player can never
510:07 - collide with two noes at the same time
510:10 - although I think in practice that's not
510:12 - really going to be a constraint
510:15 - if you have two notes right next to each
510:16 - other something weird has happened in
510:18 - your Overworld but anyway after we are
510:21 - running the input method I also want to
510:23 - check self. getet current
510:27 - node if I now run may. pi and then I
510:31 - press down I should now not be able to
510:33 - move anymore and I indeed can't that is
510:37 - because the down node only has left
510:41 - right and up
510:42 - directions none of which we are checking
510:44 - for at the moment and for that inside of
510:47 - input we have to add the other
510:51 - directions I can actually just copy all
510:53 - of this and then I want to check if the
510:55 - player can go left if that is the case
510:58 - we want to self. move left next up we
511:02 - want to check right and the player can
511:06 - only move to the
511:07 - right and then move the player to the
511:10 - right finally I want to check the up
511:14 - Direction and then move up if this is
511:17 - the case also I realized we have to
511:19 - update this direction there should be K
511:22 - left K right and K up now let's try all
511:28 - of this and if I press down and up and
511:31 - left and right the player can move to
511:35 - all of the nodes and that works
511:37 - reasonably okay however there are still
511:39 - a couple of problems for example if I
511:41 - move and press again we can jump around
511:46 - quite a bit and that shouldn't be the
511:49 - case the issue we have right now is that
511:51 - we never disable the current node once
511:53 - the player starts moving hence even if
511:56 - the player goes down from the first node
511:58 - both of these conditions can still be
512:01 - true we need something to disable that
512:03 - kind of input once the player is moving
512:07 - all of that we can get with and not
512:10 - self. ion. path we only want to allow
512:14 - input if the player is on a current Noe
512:17 - if the player currently is not moving if
512:20 - we have the down key pressed and if the
512:22 - current node allows it let's now try all
512:25 - of this and now we get much better
512:28 - movement and I can press whatever I want
512:32 - while the pirate is moving we only move
512:35 - if the player is on a node and other
512:37 - than that this is working really
512:41 - well so I am quite happy with that part
512:46 - and I do realize all of this gets quite
512:49 - complicated you probably have to go over
512:51 - it a couple of times we are moving
512:53 - around a ton of data but anyway next up
512:57 - I want to animate the player icon for
513:00 - that I can minimize everything else and
513:03 - we already have all of the frames for
513:05 - the player we also storing them meaning
513:08 - we have to update the state and then
513:10 - animate through all of the frames to get
513:12 - a new image that part is going to be
513:15 - your exercise I want you to animate the
513:17 - player icon pause the video now and see
513:20 - how far you
513:25 - get I want to create another
513:29 - method that we can call animate with
513:32 - self and Delta time there we want to get
513:36 - the frame index and increase it by the
513:39 - animation speed multipli it with Delta
513:42 - time after that we want to update self.
513:45 - image with self.
513:49 - frames the frames of the current self.
513:52 - state and then we want to get an integer
513:55 - of self. frame
513:58 - index with modulus of the length of
514:02 - self.
514:04 - frames and the current self. state that
514:08 - way we are animating Forever This
514:11 - animate method we now want to call with
514:13 - self Dot animate and Delta
514:15 - time make sure here that animate is not
514:18 - inside of this if statement although I
514:20 - guess in practice it wouldn't make much
514:22 - of a difference but anyway let's try all
514:25 - of this now and once the player is
514:27 - moving nothing's going to happen and
514:30 - that is
514:32 - because we are never updating this state
514:35 - we are always on the idle State and idle
514:38 - is a plain image it's not really an
514:42 - animation to fix that we want to get the
514:47 - state and basically what I have done in
514:50 - here I always want to set a default
514:52 - state of idle but after that I want to
514:56 - check with a couple of if statements if
514:58 - we want to update the state for example
515:01 - if self. direction is equal to Vector
515:05 - with one and zero if that is the case
515:08 - self. State should be right that we can
515:13 - cop copy because next up I want to check
515:15 - if this value is -1 which case the state
515:19 - should be left we can copy all of this
515:22 - one more time and set this to
515:25 - zero and one in which case we should be
515:29 - going down and finally the last
515:32 - one is going to
515:34 - be negative one or zero and Nega 1 in
515:38 - which case we are going
515:40 - up and to clean all of this a bit up I
515:43 - want to keep the if statements on a
515:44 - single line that I think is a bit more
515:47 - readable and now before we are animating
515:50 - the icon I want to run self. getet
515:54 - state that should animate it and now we
515:58 - are getting a walk
516:00 - animation that is looking really cute so
516:04 - I am quite happy with that that covers
516:08 - the
516:09 - animation and that covers most of the
516:12 - path logic although there's one really
516:14 - important part that I haven't covered
516:16 - yet and that is at the moment inside of
516:20 - the data class we have unlocked the
516:23 - level up to three but in main.py if
516:27 - we're running the game we can go to all
516:29 - of the levels and that shouldn't be the
516:32 - case to get around that when we are
516:36 - figuring out inside of Sprites in the
516:39 - note class if the player can move in a
516:42 - certain direction we should do two
516:44 - checks number one if the direction is
516:46 - inside of this node in the first place
516:49 - but on top of that I want to check
516:51 - another condition and that is self.
516:55 - paths so the paths we already have and
516:58 - on there we want to
517:00 - get the direction we are moving in and
517:04 - from that we want to get the first value
517:07 - and just to make sure you know what's
517:09 - going on let me print self. paths and
517:12 - Direction and and comment out the other
517:15 - stuff if I now print what we are getting
517:19 - and run main. Pi I can press down we
517:22 - getting one for this one then we getting
517:24 - a two if I go back we get two R and
517:26 - three and so on we are essentially
517:29 - getting the path keys and we want to
517:32 - check if that value is smaller or equal
517:35 - to self. dat do unlocked
517:40 - level however once again remember that
517:43 - that what we're getting from here is
517:45 - going to be a string that way we can
517:48 - sometimes add an R to reverse the path
517:50 - which means we only ever want to get the
517:52 - first value which will always be a
517:54 - number and then convert all of this to
517:57 - an
517:58 - integer and now if I run main. Pi I
518:02 - should still be able to move up to these
518:04 - nodes but I should not be able to go to
518:07 - the right anymore after this point and I
518:11 - can't I cannot go down or right but I
518:13 - can still go left and up these notes are
518:17 - all fine on top of that if I go to data
518:21 - and set the unlocked level to
518:24 - one I can run main. Pi I can go to the
518:27 - first level but now I cannot go right
518:29 - and I cannot go up but I can still go
518:31 - left and with that we can unlock certain
518:36 - levels so with that we have all of the
518:38 - notes and we can make the player move
518:41 - however the entire thing is still
518:42 - looking a bit weird because we do not
518:44 - have a
518:45 - path for that inside of the overworlds I
518:49 - want to add one more method that is
518:52 - going to be let's do right below
518:55 - setup I want to create the path
519:00 - Sprites no need for custom parameters
519:03 - and in there we are going to need a
519:05 - couple of steps first of all we have to
519:08 - get the tiles from the PA and once again
519:13 - let me explain the logic we have a
519:15 - starting point with the player then we
519:17 - have another point and finally a
519:20 - starting destination and along those
519:22 - points we are going to have a whole
519:24 - bunch of Sprites there could be one
519:26 - Sprite here another Sprite here then
519:29 - another Sprite here and after that we
519:31 - are going to the
519:33 - right which means at the moment we have
519:36 - to convert this path into actual tiles
519:41 - that we can work with and that's what
519:43 - we're going to do in this part after we
519:46 - have all of that we can place the actual
519:48 - path tiles so that we have a path that
519:50 - looks something
519:52 - like this but that's going to come later
519:56 - ultimately what I want to create is a
519:59 - local variable that I called path tiles
520:03 - this will be a dictionary that at the
520:06 - moment is going to be empty but what
520:08 - we're going to create in here is for
520:10 - each level for example for level one I I
520:13 - want to have a list with all of the tile
520:15 - positions which are all going to be
520:17 - vectors so we can have a vector with the
520:20 - grid of 20 and 21 then another Vector
520:25 - with 21 and 21 we are going one column
520:28 - to the right although for now that thing
520:31 - is going to be empty what we now have to
520:34 - do is look at all of our paths which we
520:37 - can do with for let's call it path ID
520:41 - and data in do paths. items just to make
520:47 - sure you know what's going on let me
520:48 - print the path ID and the
520:53 - data also we have to make sure that we
520:55 - are calling self. create path Sprites
520:58 - inside of the dunder init method if I
521:01 - now run may not
521:02 - P we are getting the path ID along with
521:07 - some data points where we have the
521:08 - position so all of the points of the
521:10 - path and then the starting point Point
521:14 - that's all that we are getting from this
521:15 - for
521:16 - Loop now in there first of all I want to
521:20 - get the actual path which we are getting
521:22 - from data and the position after that I
521:26 - want to get the start node and the end
521:31 - note that is important because once
521:33 - again we have our path points and we
521:37 - want to get all of the tiles along this
521:42 - path
521:43 - however we also have to include the
521:46 - actual nodes for the start and for the
521:50 - end those are important to get all of
521:52 - the path unfortunately those aren too
521:56 - easy to get and to make that a bit
521:59 - easier I want to create another
522:02 - dictionary let's call it
522:05 - notes this is going to be a dictionary
522:08 - where we get note. level and then the
522:12 - associated Val value is going to be a
522:15 - vector with I suppose this could be the
522:18 - note and we want to get a grd position
522:23 - this one we don't have yet but we can
522:25 - create it fairly easily and then for
522:27 - note in self. node
522:31 - Sprites also this should be node level
522:35 - we want to create a dictionary with all
522:37 - of the nodes and then get the grid
522:40 - position for that inside of the note we
522:44 - have to create another attribute which
522:46 - is going to be self do GD position this
522:51 - is going to be a tupal with X and Y or
522:55 - actually this should be column and
522:58 - row to get either we want to get an
523:01 - integer with the position
523:05 - zero and divide it by the tile size and
523:09 - for the row we need the same thing
523:11 - except position one
523:13 - with that we can get all of the nodes
523:16 - inside of the level and from that I want
523:19 - to get for each path the start node and
523:21 - the end node which I can get via nodes
523:26 - and then the start node I can get from
523:28 - data and in there we have the start
523:32 - path the end node is simply going to be
523:34 - noes and then the path ID remember
523:39 - inside of self. paaths the key or the
523:42 - path ID for each of the paths is going
523:44 - to be the end position for that
523:47 - path which we're going to use to assign
523:51 - the end node while the start node we
523:54 - have inside of data and start so this we
523:56 - can use as well finally with that we can
523:59 - get our path tiles and then create a key
524:02 - with the path
524:04 - ID the value for all of those is going
524:07 - to be a list and the first value will be
524:10 - the start node while the last value so
524:13 - path
524:15 - tiles and the path
524:18 - ID is going to be the end node and then
524:25 - between the start node and the end node
524:28 - we want to append all of the other notes
524:30 - which we're doing via a four loop I want
524:33 - to get four index and points in
524:37 - enumerate PA so at this point I can
524:40 - finally look at the three points points
524:43 - and convert them into tiles on a grid
524:47 - something like this so far we already
524:50 - have the start point and the end point
524:53 - this is what we specified here on top of
524:56 - that we have the path tiles so we have
525:00 - an entry inside of a dictionary in which
525:03 - we are storing all of this all we have
525:05 - to do now is get all of the middle
525:08 - points we are always going to look at a
525:11 - whole bunch of points inside of the
525:14 - path from those points I want to get a
525:17 - start value and an end value both of
525:21 - those are going to be vectors meaning
525:23 - Vector for the points for the start
525:25 - point and for the end point I want to
525:28 - create another Vector although now for
525:32 - the end point we want to get the next
525:34 - Point inside of the path which we can't
525:37 - get via the four Loop but what we can do
525:40 - is get the path and then in that IND + 1
525:44 - although this is not going to work by
525:47 - itself because of this index + one we
525:50 - are going to get an index error meaning
525:52 - we only want to do all of that if index
525:55 - is smaller than the length of the path
525:58 - minus one so with that we have a start
526:01 - point and an end point next up I want to
526:05 - get the path
526:06 - Direction which is going to be the end
526:09 - point minus the start Point divided by
526:12 - the tile
526:14 - size so what does that mean once again
526:19 - imagine we only have two
526:21 - points which are sharing the same
526:24 - Exposition but then for the first one we
526:27 - have a y value of 100 and for the second
526:31 - one we have a y value of let's say
526:35 - 250 that means our start Vector so this
526:38 - one would have a value of zero and 100
526:44 - while our end Vector would have a value
526:46 - of 0 and
526:49 - 250 is going to give us a new Vector
526:52 - with zero and a
526:54 - 150 finally if we divide all of this by
526:58 - the tile size we're going to get the
527:00 - value of zero and then in this case 150
527:04 - by 64 would be 2 something let's say 2.5
527:09 - roughly now this Vector is incredibly
527:12 - use useful because it's telling us that
527:15 - from this point we want to create one
527:17 - tile here and one tile here and then we
527:20 - reach another point that for now we can
527:23 - simply ignore basically this point is
527:25 - telling us that from the current point
527:28 - we have to go two tiles down to get to
527:30 - the next Corner first of all though I
527:32 - want to create a start
527:35 - tile which is going to be another Vector
527:39 - where I'm getting the integer of start
527:42 - and Z divided by the tile size for x and
527:48 - for y this would be another integer with
527:51 - start one divided by the tile size so
527:56 - this is going to be our start point and
527:58 - after that we want to check what happens
528:00 - in our path
528:02 - direction if we have a path Direction
528:06 - with some y values then we can get
528:09 - another let's call it Direction score y
528:13 - this value is going to be one if path
528:16 - deer do y is greater than zero and if
528:22 - that's not the case else it's going to
528:24 - be -1 so at the moment we know from this
528:28 - point that we have to go down by two
528:31 - tiles from a certain start
528:34 - position this we have to communicate to
528:37 - python so if the Y value inside of this
528:39 - Vector is positive we want to go
528:41 - downwards
528:42 - and if that's not the case we want to go
528:44 - upwards and those two should be
528:47 - together and after that we can create a
528:49 - for Loop for y in
528:53 - range we want to go from here y to the
529:00 - integer of path Direction dot
529:04 - y plus Direction
529:08 - doy all in the direction that we have
529:11 - specified and once we have that I want
529:14 - to get the path tiles with the path
529:18 - ID and a pend the start tile plus the
529:25 - vector with zero and the y
529:28 - direction okay and I'm pretty sure at
529:30 - this point you are quite lost and sorry
529:33 - about that this part gets a bit
529:35 - complicated to explain we start all the
529:38 - way at the top where we are going
529:40 - through all of the points inside of the
529:42 - path and we also getting the index and
529:45 - there we only want to run a code if a
529:47 - certain condition is true I.E if the
529:50 - index is smaller than the length of the
529:52 - path minus one that is important because
529:55 - we want to get the start point and the
529:57 - current end point of this path which we
530:00 - want to store as a vector so points and
530:03 - then Vector path index plus one that way
530:06 - we're getting the current and the next
530:08 - point we have a point here and a point
530:11 - here and we want to get their
530:15 - relationship which we are going to get
530:17 - via the next variable path direction we
530:20 - are subtracting the end point from the
530:22 - start point so we know we are going down
530:26 - and this we want to convert into tiles
530:29 - that we know we have one and two tiles
530:32 - to go or to be a bit more specific these
530:36 - tiles should be here and here while the
530:41 - start tile is the tile we are currently
530:43 - on this would be this one this would
530:46 - cover all of that part and I hope that
530:49 - makes a bit more sense after we have
530:52 - done that at the
530:54 - moment we only really have one start
530:58 - tile this bit which we're getting from
531:00 - this start
531:02 - tile but then after that point we want
531:05 - to use the path Direction the one we
531:07 - have
531:09 - specified and then create actual tile
531:12 - from
531:13 - that I.E we first of all want to know if
531:17 - we are going up or down in our case we
531:20 - want to go down and then we going to run
531:24 - a for Loop where we are going to go in
531:27 - our case from the number one and then we
531:30 - are going to go to the integer of path
531:33 - deer y plus path deer pa. Y in our case
531:37 - was y + 1 so we would go up to three but
531:41 - not included
531:42 - since we are starting from one we would
531:44 - only get the numbers one and two which
531:48 - is exactly what we want we want to
531:50 - create this tile and this tile finally
531:54 - we want to specify the direction so do
531:56 - we want to go down or up in our case we
531:58 - want to go down and once we have all of
532:02 - that we can create the actual path tiles
532:06 - basically we are using the start tile
532:09 - then adding more points to it next up we
532:13 - want to do the same thing for the
532:15 - horizontal axis which means if our path
532:18 - Direction has X values then we want to
532:22 - get direction. X and this is going to be
532:24 - one if path direction is greater than
532:28 - zero else it's going to be NE - 1 and
532:32 - then we want to have 4 x in range
532:34 - direction. X in path deer do X Plus deer
532:38 - X and deer
532:40 - X we also want to add path tiles path ID
532:44 - then append the start tile although now
532:46 - this should be X and zero we essentially
532:49 - going to do the very same thing that we
532:51 - have done for y except now it's going to
532:53 - be on the horizontal axis and after we
532:56 - have done all of that we want to attach
532:59 - the end node and with that we have a
533:02 - whole bunch of vectors and that covers
533:05 - this part or at least I hope it does
533:09 - next up we can create Sprites from all
533:12 - of that I want to go through all of the
533:15 - path tiles we have just
533:17 - created with for key and path in path
533:23 - tiles do
533:26 - items and ultimately I want to create a
533:30 - path
533:31 - Sprite where we will need a position a
533:36 - surface a group and then the level that
533:40 - we want to unlock let's start by
533:42 - creating this path Sprite in the first
533:45 - place inside of Sprites I want to create
533:47 - another class let's call it path Sprite
533:51 - this is going to be a really simple
533:52 - Sprite we can simply inherit from the
533:55 - Sprite parent class and then Define
533:58 - thunder in it we will need self position
534:02 - surface groups a level and finally a z
534:07 - parameter although actually we don't
534:09 - need that because the path Sprites are
534:12 - always going to be on the same
534:15 - layer after that we have to call Super
534:18 - Thunder init with the position the
534:21 - surface the groups and finally for the Z
534:25 - argument I want to get Z layers with the
534:29 - path the only other thing that we are
534:31 - going to need is self. level and this
534:34 - one should be the level we getting from
534:36 - the parameters we're getting a path
534:38 - Sprite that we have to import p Sprite
534:42 - and now we can use this
534:44 - one first of all though this path is
534:48 - still going to be a list of
534:51 - points all of which we can get with four
534:54 - tile in
534:57 - path after that we can get the tile and
535:00 - that is going to be a
535:03 - vector which means for the position we
535:06 - can get tile dox and tile
535:09 - doy but keep in mind for these tiles we
535:13 - are working inside of a grid to convert
535:16 - all of that into pixel positions we want
535:18 - to multiply it with the tile
535:20 - size also let me use named arguments so
535:24 - all of this is a bit more
535:26 - readable for the surface for now I
535:29 - simply want to get pame do
535:32 - surface with a size of tile size and
535:36 - tile
535:38 - size the group is simply going to be
535:41 - self
535:42 - all Sprites and the level is going to be
535:46 - the key the key we are getting from the
535:49 - path
535:50 - tiles that should cover everything
535:53 - although there's a typo this should be
535:55 - groups and now let's try all of this
535:59 - there we can see a path and if we set
536:02 - data with unlocked level to
536:06 - four then we can see a whole bunch more
536:08 - levels and they still work really well
536:13 - now at the moment the path is entirely
536:15 - black but that we can fix reasonably
536:19 - easily for now though I'm quite happy
536:21 - with this I should also mention for the
536:24 - path Sprite this level parameter is
536:27 - really important because inside of the
536:30 - groups when we are
536:33 - drawing all of the stuff on the path we
536:36 - are checking if the level of the Sprite
536:39 - is below the unlocked level this applies
536:42 - both to the nodes and to the path
536:44 - Sprites if the level is below the
536:47 - unlocked level then we are not going to
536:50 - show it cool so with that we can get the
536:53 - path Sprite next up we want to figure
536:56 - out what kind of tile we want to show to
536:59 - make that a bit easier I want to wrap
537:02 - the path into the enumerate function
537:05 - that way we're getting an index and a
537:07 - tile basically what we are now going to
537:10 - do we are always going to check three
537:12 - tiles a starting tile a mid tile and an
537:16 - end tile and we want to know what the
537:19 - relationship between these tiles is for
537:22 - example are they all vertical are they
537:26 - all horizontal are they in a corner and
537:29 - so on for that first of all I want to
537:32 - ignore the first and the last tile
537:35 - meaning if index is greater than zero
537:39 - and index is smaller than the length of
537:42 - the path minus one that way we are
537:46 - ignoring the very first and the very
537:48 - last item inside of this path we are not
537:51 - going to need those anyway first of all
537:54 - then I want to get a previous pile which
537:58 - is going to be the path that we are
538:00 - working with and then index minus one
538:04 - and from that I want to subtract the
538:07 - current
538:08 - tile after that I want to get the next
538:12 - tile and this is going to be the path
538:15 - with index + one also minus the
538:19 - tile minus the tile here is important
538:22 - because I want to get the relationship
538:24 - between these tiles if the middle tile
538:28 - has a vector position of let's say four
538:31 - and five and the tile that came before
538:34 - it has a position of four and four if we
538:39 - subtract one from the other
538:42 - what we have done here for example then
538:44 - we are going to get a vector with a
538:46 - value of 0 and -1 which is going to tell
538:50 - us that the previous tile was above the
538:53 - current
538:54 - tile after we have all of that we can
538:57 - come to the actual comparisons for
538:59 - example I could check if the previous
539:02 - tile dox is equal to the next tile
539:06 - dox if that is the case I know the tiles
539:09 - are all on the vertical a
539:11 - AIS which means from inside of main.py
539:16 - when we imported all of the path
539:20 - Graphics we can choose one of
539:23 - those although once again the Overworld
539:26 - frames are only available inside of the
539:29 - setup
539:30 - method that's not too much of an issue
539:33 - before we are calling self. create path
539:35 - Sprites we can create self. pathore
539:39 - frames which are going to be the
539:41 - Overworld frames with the half next up
539:45 - then for the surface I want to have
539:48 - self. have
539:52 - frames and I want to pick the vertical
539:55 - key from
539:57 - that and I suppose just for testing
540:00 - purposes at the beginning I want to
540:03 - create a local variable with a black
540:06 - surface this surface we are then going
540:08 - to overwrite with these conditions
540:12 - meaning when we are creating a path
540:13 - Sprite the surface should get a Surface
540:17 - also this path Sprite should be inside
540:20 - of this if statement and now if I'm
540:23 - trying m. Pi we can see all of the
540:27 - vertical paths work just fine down there
540:31 - this one also works well cool so that's
540:33 - a good
540:34 - start next up we can check an L if
540:39 - statement that if we have all of the
540:43 - horizontal tiles meaning the Y for next
540:46 - tile and previous tile is identical I
540:49 - want to get the surface except now the
540:52 - surface should be
540:54 - horizontal let's try that and that's
540:57 - already looking significantly
541:01 - better which means all we have to do now
541:04 - is get all of the corners that part is
541:07 - going to be a bit more labor intensive
541:09 - but I think it's not too bad
541:12 - the only thing we have to be careful
541:13 - about here is that the corner could
541:15 - either go this way or it could go this
541:18 - way for example if we have a corner that
541:21 - goes like this we could have a previous
541:24 - tile that is on the left so X would be
541:29 - -1 and then also we have a next tile
541:33 - where Y is going to be negative one that
541:36 - would be one condition but we could also
541:39 - flip those two around
541:42 - where the previous tile was on top and
541:44 - the next tile is on the left we have to
541:47 - cover both of these conditions which
541:50 - means I want to check if previous tile
541:53 - dox is equal to -1 and next tile doy is
541:59 - equal to -1 as well or and now I want to
542:04 - copy all of this I want to check if
542:07 - previous tiley is -1 and next Tilex X
542:12 - is1 if that is the case I want to assign
542:15 - a new Surface which once again we are
542:19 - getting via the path frames and the key
542:21 - for this one is top left let's try this
542:25 - and let's find one of those
542:29 - Corners okay it's right behind the palm
542:32 - tree but I hope you can see we are
542:34 - getting the right kind of
542:38 - tile that is actually the only time we
542:41 - are using that kind of corner okay bad
542:44 - example let's do another
542:46 - condition where we want to place the
542:50 - bottom right
542:53 - corner which is going to be the exact
542:55 - opposite compared to top left which
542:58 - means all we have to do is change all of
543:00 - the minuses to a
543:04 - plus and if I run this one
543:06 - now we can see up there we have a much
543:10 - nicer looking
543:13 - corner and if we go
543:16 - around okay I need more corners in this
543:19 - game that would make my life
543:21 - easier but this one is definitely
543:24 - working so we know the logic is
543:26 - sound next
543:28 - up I want to check if we are placing
543:32 - let's say the bottom left
543:35 - corner for that X is going to be -1 for
543:40 - the pre previous tile and for the next
543:42 - tile Y is going to be one then we have
543:45 - to invert all of this as well and for
543:48 - that the next tile is going to be
543:49 - negative one let's try this one now and
543:54 - there should be one more Corner that
543:56 - looks pretty
543:57 - good finally we have the last condition
544:01 - and that is going to
544:03 - be this one where we are inverting the X
544:07 - and the
544:09 - Y in both cases
544:11 - also this one should be top right now if
544:16 - I run main. Pi we have all of the
544:19 - corners and that looks pretty
544:24 - good so yeah I'm quite happy with that
544:29 - and finally if none of these conditions
544:32 - apply and they should all be an L if
544:35 - case I do like to add one kind of safety
544:38 - condition where we have some kind of
544:40 - tile in the end that makes sure that if
544:43 - something goes wrong with the math we
544:46 - have some kind of tile that is probably
544:48 - going to look okay for that I want to
544:51 - get self. path frames with the
544:54 - horizontal tile the one we have placed
544:57 - all the way at the beginning now if the
544:59 - MTH is going wrong this still wouldn't
545:00 - look ideal but it beats having a black
545:04 - surface but anyway after that we don't
545:07 - need the black surface anymore and now
545:11 - if I run main. Pi all of this is still
545:14 - going to work just
545:16 - fine so that looks pretty
545:21 - good also what we can do inside of data
545:24 - I can unlock all the levels I think up
545:27 - to six I've made and
545:29 - now we can explore all of the levels I
545:34 - think we only have five in total
545:36 - actually but it doesn't really matter
545:37 - for the
545:38 - logic anyway at this point we
545:43 - have all of the Overworld that looks
545:46 - pretty
545:48 - good that covers the entirety of the
545:51 - Overworld which means we can close the
545:54 - import assets method and now what we
545:57 - have to figure out is how to connect all
546:00 - of the levels with the Overworld for
546:03 - that first of all I want to import all
546:06 - of the TMX maps at the moment we only
546:09 - have level zero which is also the om.
546:13 - TMX file but that I don't want anymore
546:16 - this should be z.
546:18 - TMX after that I want to copy all of
546:21 - this a couple of times because I want to
546:24 - have level one two three four and the
546:28 - associated level is going to be 1 2 3
546:32 - and four once again let's have a look at
546:35 - the project folder inside of data we
546:38 - have all of the levels and this one goes
546:40 - go up to six all of this is what I want
546:43 - to import although level six is the one
546:45 - I just created all the other ones I made
546:49 - earlier and the one that I forgot is
546:51 - going to be level five with 5.
546:56 - TMX so with that we have all of the TMX
547:00 - Maps that's a good start but that still
547:02 - doesn't help us to switch between a
547:05 - level and the Overworld to fix that part
547:08 - I want to create another method that I
547:11 - am calling switch uncore stage where we
547:16 - are going to need self we will need a
547:19 - Target and then the level we want to
547:21 - unlock so an unlock parameter which by
547:24 - default is going to be zero essentially
547:27 - in there we are going to check if the
547:30 - target is going to be a
547:33 - level if that is the case I want to
547:36 - update self. current stage to whatever
547:40 - the level is going to be although for
547:42 - now let's ignore that part and simply
547:44 - add pass in here but essentially to
547:48 - explain this a bit better we're going to
547:50 - pass switch stage into the Overworld and
547:53 - into all of the levels and then from I
547:56 - ofos we could call
547:58 - it which is then going to bring us back
548:01 - to this game class and finally via
548:05 - switch stage we are going to either
548:08 - assign a level class to the current St
548:10 - stage or the Overworld to the current
548:13 - stage and if we are not going to Target
548:16 - a level then we know that we want to
548:19 - create the
548:21 - Overworld hence self. current stage
548:24 - should be the Overworld or rather one
548:28 - instance of the Overworld class although
548:31 - once again this we are not going to do
548:34 - just
548:34 - yet let me keep pass in
548:37 - there what I actually want to start with
548:40 - and for that I want to disable the
548:43 - current
548:45 - stage and uncomment the current stage we
548:49 - created earlier if I now Run the game
548:52 - again we have a completely new
548:56 - level and that still works perfectly
548:58 - fine so that's a good
549:00 - start however now once the player
549:03 - reaches the end of the level then we
549:05 - want to call switch stage for which we
549:08 - have to pass this method it into the
549:11 - level class also make sure to not call
549:14 - this function we want to pass the
549:16 - function itself not the return value
549:18 - into this
549:20 - class after that inside of the level and
549:24 - let me minimize everything we are going
549:27 - to need another parameter switch uncore
549:31 - stage and then we want to store the
549:33 - function in an attribute so switch stage
549:36 - is going to be switch stage finally we
549:39 - want to work inside of check constraint
549:43 - because there we're checking the bottom
549:45 - border and the success state for now
549:48 - let's work in the bottom border so if
549:50 - the player Falls too far down then we
549:53 - want to go back to the Overworld we want
549:55 - to run self. switch stage we want to
549:58 - Target the Overworld and for the Target
550:02 - level the one we are going to unlock I'm
550:04 - going to set this one
550:06 - to1 we do not want to unlock any new
550:09 - level
550:11 - which we're going to indicate via a
550:12 - negative
550:13 - one after that inside of main do PI we
550:19 - are running this self. switch stage or
550:21 - more specifically this L
550:23 - statement and for now let me simply test
550:26 - if this is working I want to print the
550:28 - Target and I want to print the unlock
550:32 - parameter let's try this and if I fall
550:36 - down we can see we have Overworld and
550:40 - and ne1 so this is running
550:43 - indeed which means we can update the
550:47 - current stage to create the Overworld
550:50 - and for that I am kind of regretting
550:52 - deleting the Overworld from earlier but
550:55 - anyway when we are creating the
550:56 - Overworld we don't need that much data
550:59 - let me copy the parameters we want to
551:01 - create all of that TMX map is easy this
551:05 - is self. TMX Overworld data is self.
551:10 - data
551:11 - and the Overworld frames are going to be
551:12 - self. Overworld frames the ones that we
551:16 - are getting from import assets
551:19 - those let's try all of this again and
551:22 - now if the player falls down we have the
551:25 - Overworld and we can still move around
551:28 - so that is looking pretty
551:31 - good however at this stage inside of
551:34 - data I want to set the unlock level to
551:38 - zero that makes it so that if we die we
551:42 - are stuck on the first level note that
551:44 - looks good however inside of the level
551:48 - if the player reaches the flag or the
551:50 - level finish rectangle then we also want
551:53 - to switch the stage however we want to
551:56 - unlock the level that we have assigned
551:59 - as the level
552:00 - unlock if you look at tiled we have our
552:04 - data object and in there we have a level
552:07 - unlock at the moment we are inside of z.
552:10 - TMX and this one unlocks level one
552:14 - although to get that inside of the
552:16 - dunder init method I first of all want
552:18 - to store it inside of an attribute all
552:21 - of that we are storing inside of TMX
552:24 - level properties after we are getting
552:27 - that dictionary I want to create self.
552:30 - level
552:31 - unlock which is TMX properties with the
552:35 - key level uncore unlock and after we
552:39 - have that
552:41 - we can pass this as an argument into the
552:45 - Overworld next up then we can once again
552:49 - work inside of switch
552:51 - stage all I really want to do in there
552:54 - is if the unlock value is greater than
552:59 - zero which means we can get self. data
553:02 - and then update the unlocked
553:06 - level and set it to the unlock value
553:09 - that we we are
553:11 - getting however if that is not the case
553:14 - else we know that the player has failed
553:17 - and as a consequence we want to update
553:18 - self. data. health and reduce it by one
553:24 - that should actually work already if I
553:25 - now run all of this look at the health
553:28 - we have currently five hearts and if I
553:30 - fall down this is being reduced to four
553:33 - so that's working pretty well on top of
553:35 - that entitled I'm going to move the
553:37 - pirate all the way to the right so it's
553:39 - going to be really easy to finish the
553:41 - level if I now run all of this I can
553:44 - finish the level and we have unlocked
553:47 - the next
553:50 - Noe we can also go back however there's
553:53 - no way to start a level from this
553:56 - point but that's okay we have covered at
553:59 - least one direction next up we want to
554:02 - go from the Overworld back to a level to
554:05 - make that work we have to pass switch
554:08 - stage into the Overworld
554:11 - fairly easily done we have to pass self.
554:14 - switch stage in there and then work
554:17 - inside of overw world. Pi first of all
554:20 - we have to create another parameter
554:22 - switch uncore stage which we also want
554:25 - to store as a parameter switch stage is
554:29 - going to be switch
554:31 - stage after that I want to work inside
554:35 - of the input
554:37 - method the key I now want to check is if
554:40 - keys and py game.
554:44 - Kore return if the player is pressing
554:48 - enter Then I want to self. switch
554:53 - stage to the level which once again is
554:58 - going to bring us back to this method in
555:01 - which we want to create an instance of
555:04 - the level
555:05 - class for that we will need all of those
555:09 - parameters
555:10 - although we do have to be a bit careful
555:12 - here because at the moment we are always
555:14 - creating the first level the other
555:17 - arguments are totally fine though and by
555:20 - the way this mistake also happens inside
555:22 - of the init method which I guess it's
555:25 - fine but it should be more flexible we
555:26 - shouldn't always start with index zero
555:28 - we want to start with the first item
555:30 - inside of this list which we have to
555:32 - find inside of data we want to start
555:35 - with self. current level or unlocked
555:37 - level by default they are the same to
555:40 - get that value I want self. data and
555:43 - then the current
555:46 - level which by the way I also want to do
555:49 - when we are creating the level in the
555:51 - first
555:52 - place also before we are
555:55 - continuing when the player is pressing
555:57 - enter I have to assign a new value to
556:00 - the current level which means self.
556:04 - data. current level is going to be self.
556:08 - Curren node. level that way we know what
556:12 - level we are and we are storing it so
556:15 - once we are going back from a level to
556:16 - the Overworld we can place the player in
556:19 - this current level
556:20 - position let's try all of that and once
556:23 - again the player starts in the level if
556:25 - I now hit this part we are getting an
556:28 - error that there's no K return that's a
556:31 - simple typo we just need an uppercase K
556:34 - next attempt once again I want to jump
556:37 - to the flag and now this is working
556:40 - I can press enter and now we are in
556:43 - another
556:44 - level I can try to fall down once again
556:48 - and now we are back to the Overworld
556:52 - also while we're here let's try the old
556:53 - level this one is still working and yeah
556:57 - this is working quite
556:59 - well and at this point we have finished
557:03 - most of the game there are still a
557:06 - couple of things that I would like to
557:07 - add later on but for now none of of them
557:09 - are too important and I think this part
557:11 - got really long so if you got to the end
557:14 - of it well done that was a tough
557:21 - [Music]
557:23 - section all righty at this point we are
557:25 - basically done with the game the last
557:27 - thing in terms of code that we have to
557:28 - do is if the player runs out of Health
557:30 - we want to close the game that should be
557:32 - very easily done on top of that we also
557:35 - have to add some audio files which isn't
557:38 - going to be a problem either
557:40 - so before we start what I do want to
557:42 - cover is here we have the project folder
557:45 - and so far we basically ignored the
557:47 - audio folder but if you open that one we
557:50 - basically have a whole bunch of files
557:52 - not that many all of that we want to
557:55 - import and then play at a certain time
557:57 - Starlight City by the way is the
557:59 - background music but that's not too
558:01 - important for now I simply want to work
558:04 - inside of the main file and by the way I
558:07 - closed everything I didn't need the only
558:09 - file FES that we really need at this
558:11 - point is main.py level. pi and player.
558:14 - pi and first of all inside of the game
558:17 - class I want to add one more
558:20 - method that one is going to be check
558:23 - game over no need for custom parameters
558:27 - there's nothing complicated we are going
558:28 - to do in here we simply want to check if
558:31 - self. dat. health is smaller or equal to
558:36 - zero then we want to quit the game which
558:39 - we do with pame do quit along with sis.
558:43 - exit the same thing we have done in the
558:45 - run method down here on top of that
558:49 - before we are running anything I want to
558:52 - self. check game
558:55 - over oh and while I'm testing all of
558:57 - this inside of the init method the first
559:00 - level should be the Omni level just to
559:03 - make sure we have all of the elements at
559:04 - one time let's not try all of this and I
559:07 - think the fastest way to dive would to
559:09 - jump on the
559:12 - spikes and there we go the game ends
559:14 - once the player runs out of Health not
559:17 - the most elegant mechanic but for a
559:19 - simple game this is still totally fine
559:21 - cool with that we have the game logic
559:23 - itself done the last thing we have to
559:25 - add are the sound files and that is
559:27 - going to happen first of all inside of
559:28 - import assets because we have to import
559:31 - just a few more things all of the audio
559:34 - files I want to store inside of an
559:35 - attribute self.
559:38 - aore file
559:40 - like with all of the graphical assets
559:42 - this is going to be a dictionary for
559:44 - example one entry in there could be the
559:46 - coin sound this coin sound we are
559:48 - getting with py game. mixer. sound and
559:53 - then we will need the join method for
559:54 - the path I want to go up a folder then I
559:59 - want to go to the audio folder and in
560:01 - there we have coin.
560:03 - wav that would be a good start next up I
560:06 - have to get this audio file somewhere
560:09 - into the the level and then play it at
560:11 - the right moment first of all these
560:13 - audio files we want to pass into the
560:16 - level when we created which happens on
560:18 - this level so after the level frames I
560:21 - also want to pass in self. audio files
560:25 - and really important now we are creating
560:28 - the level twice once inside of the dund
560:31 - NIT method and once inside of switch
560:33 - stage most specifically here in both
560:36 - cases we will have to add self. audio
560:39 - file
560:40 - after we have that I can minimize both
560:43 - of these methods and then in the level
560:45 - after the level frames we will need
560:47 - audio uncore
560:49 - files after we have that inside of the D
560:52 - init method of the level class I want to
560:55 - add another section let's call this one
560:57 - sound or I suppose audio but basically
561:00 - the same thing first of all I want to
561:02 - create a coin sound which we're getting
561:06 - from the audio files and then the coin
561:08 - entry so next up we have to figure out
561:11 - when to play it and that fortunately is
561:15 - really easy we basically always want to
561:17 - play the sound when there's an item
561:19 - Collision which is going to happen if
561:21 - this if statement triggers meaning after
561:24 - that I want to get self. coin sound and
561:28 - play it if I now run all of
561:36 - this that sounds good cool so with that
561:40 - we have the coin sound although this
561:42 - coin sound might be just a little bit
561:44 - too loud to fix that self. coin sound.
561:49 - setor volume and in there we need to
561:52 - value between zero and one with one
561:55 - being 100% of the volume which is the
561:57 - default and I want to set this to let's
561:59 - say
562:00 - 0.4 let's try this one again and the
562:04 - item sound is a bit less
562:07 - loud as always this is is a very
562:09 - subjective thing so choose whatever you
562:12 - think is best in fact finishing up all
562:15 - of the sounds is going to be your
562:16 - exercise I want you guys to finish up
562:19 - the sounds and then you are done with
562:20 - the project see how far you
562:26 - get first of all we have to import more
562:29 - audio files in my case I am going to
562:33 - copy all of them in so you don't have to
562:35 - watch me type basically what we need is
562:37 - all of this it sound for the attack jump
562:40 - damage and pearl they all in the same
562:42 - folder and you always deal with wav
562:45 - files next up then inside of the level
562:48 - we now have all of the files inside of
562:50 - audio files and we have to figure out
562:53 - when to play them and there's one that
562:55 - we can play in the level right away that
562:57 - is the damage uncore sound which we're
563:01 - getting from audio files and damage also
563:05 - while we're here I want to reduce the
563:07 - volume of this thing just a bit with set
563:10 - volume and set this one to
563:13 - 0.5 this is going to be a sound that we
563:15 - want to play whenever the player gets
563:17 - damaged and that we know from inside of
563:20 - the hit Collision because in there we
563:23 - are already running player damage on top
563:25 - of that I want to get self. damage sound
563:28 - and play that
563:30 - one if I now run main. Pi again we are
563:34 - getting a sound let's try it
563:36 - again cool that works now this sound if
563:41 - you hit something else is kind of
563:43 - working but you might want to add more
563:45 - audio files also with the
563:47 - spikes not amazing but well it kind of
563:51 - works righty next up I want to work on
563:54 - the Pearl sound so the sound that will
563:56 - be played whenever a pearl is being
563:58 - created that first of all needs to be an
564:00 - attribute inside of the level class
564:04 - Pearl sound is going to be audio files
564:07 - the entry for this one is Pearl and that
564:09 - part is super easy because we have an
564:11 - entire method to create a pearl whenever
564:14 - that happens we also want to play the
564:16 - sound which means self. Pearl sound and
564:21 - play that one let's try out of
564:25 - that
564:27 - and we are getting a
564:30 - sound so with that we have all of the
564:32 - Easy Sounds or well the super easy ones
564:36 - the other two sounds for the attack and
564:38 - the jump need to be inside of the player
564:42 - for that we have to work with the setup
564:44 - method because in there I want to pass
564:47 - in the audio files and let me minimize
564:50 - the Thunder nit method and then work
564:52 - inside of setup first of all in there we
564:55 - also need the audio files after that
564:59 - when we are coming to the player that is
565:01 - happening here I want to create two more
565:05 - attributes I want to have an attack
565:08 - sound which we're getting from audio
565:10 - files and a tack after that I want to
565:14 - have a jump sound which we're also
565:17 - getting from audio files except the key
565:19 - for this one is jump and then inside of
565:22 - the player we will need two more
565:24 - parameters for attack sound and jump
565:30 - sound both of those we want to store as
565:32 - an attribute meaning all the way at the
565:34 - bottom I want to have the audio section
565:38 - self do attack sound is going to be the
565:43 - attack sound and self. jump sound will
565:48 - be the jump
565:49 - sound perfect and after that I want to
565:51 - minimize all of the methods so things
565:53 - are a bit easier to see and let's start
565:56 - with the attack that is going to happen
565:58 - inside of the attack method inside of
566:01 - this method we can play the attack sound
566:04 - all we really have to do is self. attack
566:06 - sound
566:08 - dolay
566:09 - let's right up
566:12 - on and if I press X we are getting an
566:15 - attack sound this is working if I'm on
566:18 - the floor and if I am
566:23 - jumping
566:24 - cool besides that we have the jump sound
566:27 - that I want to work on inside of the
566:29 - move method and there we are checking if
566:32 - the player is currently jumping although
566:35 - we have two different kinds of jump a
566:37 - jump from the floor and a jump from the
566:39 - wall for both of those we want to play
566:41 - the jump sound meaning we have to call
566:44 - self. jump sound and play it in both of
566:49 - those cases let's
566:53 - try that sounds good let's try a wall
566:57 - jump and that's also
567:00 - working and I suppose the one thing you
567:02 - want to be careful about here is that
567:04 - this jump sound shouldn't be inside of
567:07 - this if statement if it was the player
567:10 - could for example play the jump sound if
567:11 - he was in the air already which I really
567:13 - don't want to do but anyway with that we
567:17 - have most of the sounds now you could be
567:19 - adding a few more but I think this video
567:21 - has gone on long enough so I don't want
567:23 - to stretch it too far that being said
567:25 - there's one more file that I do want to
567:27 - add this would be self. BG music the
567:31 - file for that one let me simply copy it
567:33 - in it's going to be py game. mixer sound
567:36 - and we are importing Starlight city. MP3
567:39 - this is the only background music that
567:41 - we are going to play and to start it I
567:43 - want to work inside of the dunder init
567:45 - method all the way at to bottom I want
567:47 - to play self. BG
567:51 - music with one argument negative one if
567:55 - you insert a single argument into the
567:57 - play method then you're defining the
567:59 - amount of loops and if you add a
568:01 - negative one in there then you are
568:02 - looping this file
568:05 - indefinitely and with
568:07 - that
568:11 - [Music]
568:22 - [Music]
568:27 - cool I think that is working I suppose
568:30 - there's one last thing that we could be
568:31 - doing and that is to set the volume of
568:34 - the background music and that we have
568:36 - already seen self. BG music and then set
568:38 - underscore volume I suppose this one we
568:42 - could set to 50% try this
568:44 - [Music]
568:48 - again and that also sounds about right
568:51 - and once again choose whatever numbers
568:52 - you like and well with that we have
568:56 - finished the entire tutorial so I hope
568:58 - all of that was useful and well I'll see
569:00 - you around