00:00 - hello there in this tutorial we are
00:03 - going to create a really basic minecraft
00:04 - clone in python
00:06 - and well it works like any other
00:08 - minecraft game you can create blocks you
00:10 - can destroy blocks
00:11 - and i also have different blocks that
00:13 - you can just switch to
00:14 - just to make it a bit easier and there
00:17 - are quite a few different ones and you
00:18 - can just work with them
00:20 - and play around pretty straightforward
00:22 - when it comes down to it
00:23 - and of course with that you can make
00:25 - well in my case a really simple house
00:28 - but if you want the tube you could just
00:29 - add more stuff to it or get rid of stuff
00:32 - well it's basically how minecraft works
00:37 - and all of this is made with the usina
00:40 - game engine
00:40 - so let's talk about that one the ostina
00:43 - game engine
00:44 - was released sometime last year and it's
00:47 - a really neat engine it can do really
00:48 - powerful stuff with very few lines of
00:50 - code
00:51 - for example the entire game you just saw
00:53 - took about 90 lines of code to write
00:56 - and you can make it in about an hour
00:58 - it's really easy
00:59 - so it's quite a good engine for
01:01 - beginners i feel
01:03 - and especially for 3d games osena is
01:06 - quite a bit more powerful than pygame
01:08 - for example
01:09 - but that doesn't mean it doesn't have
01:10 - problems and there's one big warning i
01:13 - do have to give that your cena game
01:14 - engine is only available for windows and
01:16 - linux
01:17 - so if you have mac os i'm really sorry
01:20 - this tutorial is not going to be for you
01:22 - but with all of that out of the way
01:24 - let's first do a brief introduction to
01:26 - the
01:26 - cena game engine and once we have the
01:28 - basics covered we can actually come to
01:30 - making the game
01:31 - so for this part we're talking about how
01:33 - cena works and how we can make some
01:35 - basic stuff with it
01:36 - and obviously the very first thing you
01:38 - have to do is to install it
01:39 - so in the powershell type pip install
01:42 - cena
01:42 - and then you should see a fairly lengthy
01:44 - dialog to install it
01:45 - and once that's done you should be good
01:47 - to go this works like literally any
01:49 - other module for python
01:51 - and once you have installed it go to the
01:53 - code editor of your choice in my case
01:55 - sublime
01:56 - and type import or cena and now if you
01:59 - run it
02:00 - you should be getting a message that is
02:02 - something like this
02:04 - the really important part you're looking
02:05 - for here is that you're not getting an
02:07 - error message
02:08 - if you don't you have installed it
02:09 - properly and now that we have that
02:11 - let me close it we can actually start
02:13 - working in oceana
02:14 - and the first thing we need to do is
02:16 - that i don't want to import usina by
02:18 - itself
02:19 - instead i want to go from from yocena
02:22 - import everything so star and the reason
02:26 - for that is that there are lots of
02:27 - objects that rely on oceana
02:29 - and having to type ocena every time is
02:31 - going to be quite cumbersome
02:33 - and now we need two lines to create the
02:35 - entire game the first line is to create
02:37 - the basic instance of the game
02:39 - and this has to be stored in a variable
02:40 - that i'm going to call app
02:42 - and to create this one all we have to
02:44 - type is orcina
02:46 - and make sure the first letter is
02:48 - capitalized that one is important
02:50 - and once we have that what i want to do
02:52 - is app.run
02:54 - so i create an instance and i run the
02:56 - instance and with that if i run my code
02:58 - now
02:59 - we get a really basic window we can see
03:02 - our frame rate
03:02 - and we can close the window that's about
03:05 - it nothing much happens
03:06 - yet but it's already a really good start
03:10 - that we have a window with just two
03:11 - lines of code
03:12 - so for example this would be much easier
03:14 - than pygame for example
03:17 - now we have to figure out how can we
03:18 - actually put stuff on the screen
03:20 - and for that we have to understand the
03:22 - most important concept for oceana
03:24 - and that is called entities and an
03:27 - entity
03:27 - in oceana can basically be anything it
03:30 - can be square it can be a cube it can be
03:32 - a circle
03:33 - it could also be a button basically
03:35 - anything you see on the screen
03:37 - is going to be an entity and then when
03:39 - you create this entity you can customize
03:41 - it quite a bit
03:42 - and once it's created it's automatically
03:44 - added to the game
03:46 - so all you have to take care of is
03:48 - creating it and then you're good to go
03:49 - so let's create one i want to create
03:53 - let's say let's call it test square
03:57 - where i just want to create a basic
03:58 - square on the screen and for that we
04:00 - have to create an entity
04:02 - and now we have to give it a couple of
04:04 - arguments
04:05 - the first one is what's called the model
04:07 - and this one determines what kind of
04:09 - shape it's going to take
04:10 - so is it going to be a cube is it going
04:12 - to be square is it going to be a circle
04:15 - and for now let's just go with circle
04:18 - that tends to be a really easy shape
04:20 - and with that we would get a circle and
04:22 - now let's give it a color argument
04:24 - and for that i need the color keyword
04:27 - and to assign it any color
04:29 - i need the keyword color and then the
04:31 - color i want to go with let's say for
04:33 - now let's go with red
04:34 - and with that we should have a red
04:36 - circle so let me run the code
04:38 - and we can see a red circle right in the
04:41 - middle of our screen
04:42 - so this one's working really well and
04:44 - what you can do now
04:45 - is change this circle to something else
04:48 - so for example if you want to square
04:50 - you would need the quad keyword and if i
04:52 - want to go now
04:53 - we get a square now you could
04:56 - if you wanted a cube so a
04:58 - three-dimensional object
04:59 - you could type cube in here although if
05:01 - i run this because we're looking at only
05:03 - one side of this cube we can't really
05:05 - see it
05:06 - but we're going to come to that in just
05:08 - a bit for now
05:10 - don't worry about it and let's leave it
05:12 - at the quad for now that one's the
05:14 - easiest to see
05:15 - and what you can also do in the
05:17 - parameters here is you can for example
05:19 - set a scale
05:20 - and then they can pass in a tuple with
05:23 - the x and the y scale
05:25 - so if i passed in let's say one and four
05:29 - we would stretch it four on the y and
05:32 - one on the x axis
05:33 - and of course you could also change the
05:36 - position
05:37 - and this could for example be let's say
05:39 - five and one and let's see what happens
05:42 - so now we have moved the entire thing
05:44 - one unit upwards and five units to the
05:46 - right
05:48 - and a really important thing here is
05:49 - that the origin point is in the center
05:51 - of the screen
05:54 - so y has to be positive if you want to
05:56 - go up has to be negative if you want to
05:57 - go down
05:58 - kind of like it would make sense and
06:00 - just to demonstrate it let's make this a
06:02 - higher value
06:02 - to 4 and now we get even higher
06:06 - so this would be quite different
06:07 - compared to pie game for example
06:10 - so now we have a basic thing on the
06:11 - screen how could we
06:13 - move it and that is also really easy in
06:16 - oceana because all we need
06:18 - is to create a function so def and this
06:21 - function has to be called
06:22 - update it doesn't need any arguments and
06:25 - this update function
06:26 - is going to be called biocena on every
06:28 - frame automatically
06:30 - so as long as you have this name and
06:31 - function you are good to go
06:34 - so for example what i could be doing in
06:36 - here is just to print
06:38 - test and then run the entire thing and
06:41 - now in the console you can see we get
06:42 - test
06:43 - quite a bit and now if i wanted to move
06:47 - this test square all i would have to do
06:50 - is to get the object itself and then
06:53 - influence one parameter for now let's go
06:56 - with x
06:58 - and i could just change the values so i
07:00 - could go with minus equal 1
07:01 - which would move it to the left although
07:04 - if i were to run this right now we go
07:06 - really fast
07:07 - so this is way too fast and this would
07:10 - also
07:11 - not adjust to different frame rates so
07:13 - this would be quite inconsistent
07:15 - but all we have to do to fix that is to
07:17 - add times time
07:18 - dot delta so this is the time between
07:21 - different frames
07:23 - so if we multiply this with the movement
07:24 - speed our object is going to move in
07:26 - accordance with the frame rate
07:28 - which is going to make our game quite
07:29 - smooth so now let's try it again
07:33 - and there we go this feels much better
07:36 - cool
07:37 - and we could even make it a bit faster
07:38 - let's go with minus equal
07:40 - four and yeah that feels better
07:44 - cool now you could make this even more
07:46 - sophisticated
07:47 - by adding keyboard input and for that
07:50 - all you need
07:51 - is held keys and from that
07:55 - we just have to pass in one specific key
07:59 - let's say my case a and now i have to
08:02 - indent this
08:03 - and i can just run the game again and
08:06 - now
08:06 - this thing is only going to move to the
08:08 - right if i press a and that's all we
08:10 - need
08:12 - and this could be any letter on your
08:14 - keyboard any number or even your mouse
08:16 - keys it's really flexible
08:18 - and all right with that we have our
08:20 - basic object and we have a way to move
08:22 - it
08:23 - now what we can also do let me add
08:26 - another square
08:27 - and let's call this sun's you've seen a
08:29 - second why
08:30 - and for this one i want to add a custom
08:32 - texture but i can add any kind of
08:34 - picture i want into this
08:36 - and for this i am still going to need an
08:37 - entity and the entity is supposed to be
08:40 - a quart again so we're getting a square
08:44 - and now i want to add a custom picture
08:47 - to this and for that i will need the
08:49 - texture
08:50 - keyword and now for the texture i
08:54 - have to create a texture and there are a
08:55 - couple of ways of doing it
08:57 - the one i would recommend is to create
09:02 - a texture in its own variable and then
09:04 - we need the keyword
09:05 - load texture and then you can select
09:08 - from your folder
09:09 - in my case i have a folder called assets
09:12 - and in that folder i have a file called
09:17 - sans.png and now that
09:20 - i can just pass in here and let's try
09:23 - now let's see what happens
09:25 - and now we get suns from undertale
09:27 - pretty nice and easy
09:29 - and we can actually make this easier we
09:32 - don't actually have to do
09:33 - this entire line we could just pass this
09:36 - straight into here and it would load
09:39 - automatically
09:40 - so if i run this now this would also
09:42 - work perfectly fine
09:44 - so this would be fine but i generally
09:46 - feel like importing all your textures at
09:48 - the beginning is a
09:49 - more readable way to approach this but
09:51 - it's ultimately up to you
09:53 - so with that we have a couple of really
09:55 - simple objects in our game
09:57 - but in an actual game you really want to
10:00 - have more control
10:00 - over all of these things so this kind of
10:04 - thing
10:04 - is generally just to create really
10:06 - simple ones if we wanted to create more
10:08 - complex ones
10:09 - we could also do that and for that we
10:12 - have to create an entirely class
10:14 - that inherits from an entity for example
10:16 - so
10:17 - let's create a more complex cube and
10:20 - with that we can also go into 3d
10:22 - so i want to create a new class and
10:25 - let's call this one
10:26 - test cube and this one has to inherit
10:29 - from entity and now and there
10:32 - i want to create an init method it needs
10:34 - self and nothing else
10:36 - or you could pass something in there
10:37 - would be fine and then there i want my
10:39 - super method
10:41 - and then the init and now when i
10:44 - initiate the parent
10:45 - i can specify a ton of different
10:48 - arguments
10:49 - so in here for example i could create a
10:51 - model
10:52 - for now i want a cube i could give it a
10:56 - color
10:57 - let's give it let's say the color white
11:00 - just for now and then of course i can
11:02 - also give it a texture
11:03 - and osena has a couple of textures in
11:06 - build that you can use
11:07 - one of those is called white underscore
11:09 - cube
11:11 - so this one you don't have to load it's
11:12 - inbuilt into a c now
11:15 - and with this we have our own class that
11:17 - we can add lots of stuff to that
11:19 - is something we are going to do in just
11:21 - a bit and now all we have to do
11:23 - to create an actual block from this
11:25 - class
11:26 - is well to call it so let me call my
11:29 - test cube
11:30 - and this is supposed to be my test cube
11:32 - class
11:34 - and now if we run this we can see a
11:37 - white cube
11:38 - right in the middle of our screen and
11:40 - you can't really see that it's a cube
11:41 - yet
11:42 - so let's give it some rotation and for
11:45 - that
11:45 - all i have to do is to give it a
11:47 - rotation argument
11:48 - and this one needs to be a vector 3 with
11:51 - the x
11:52 - y and z rotation and let's just go with
11:54 - 45
11:55 - 45 and 45. so now if we run this
11:59 - we can see our cube so this one is
12:01 - working pretty well
12:03 - and you could still move this thing
12:04 - around with position and this would work
12:06 - perfectly well
12:08 - now with that we have already quite a
12:09 - few things covered
12:11 - but there's one more concept we need
12:12 - before we can get to the actual game
12:14 - and that is to create a button and
12:17 - buttons work
12:18 - slightly differently or well not that
12:20 - much let's actually create one that's
12:21 - going to be the fastest way
12:23 - so to create a button i still have to
12:26 - create a class
12:27 - and i'm going to call it test button
12:31 - and this one has to inherit from a class
12:33 - called button itself
12:35 - and now here i have to create again
12:38 - a done there init method that needs self
12:41 - and inside of that
12:42 - i want to get my super method and init
12:45 - that one and in here i can create lots
12:48 - of different stuff for the button
12:50 - so for example my button could be a cube
12:54 - just like my test cube i could give it a
12:57 - texture
12:58 - and let's say another inbuilt one is
13:00 - called brick
13:02 - i could give it a color and this one
13:04 - would be let's go with
13:07 - color blue just to use one we haven't
13:10 - seen yet
13:11 - and with that we have a really basic
13:13 - button let's actually create it
13:15 - and let me get rid of the test cube just
13:18 - so we don't have it in the way
13:20 - so now instead of test cube i want a
13:22 - test button
13:24 - and now if i run this we can see a
13:27 - giant button and you can see if i hover
13:30 - over it it gets slightly brighter
13:33 - but now it is kind of weird how buttons
13:36 - work
13:37 - because this button is significantly
13:39 - larger than this test cube
13:41 - and the reason for that is that a test
13:43 - button needs one more argument
13:45 - and is called the parent argument and
13:48 - the parent we need
13:48 - is the scene so the actual game scene
13:50 - again
13:52 - and now if i run this again now we can
13:54 - see the normal size button
13:56 - i am not actually sure why the parent
13:59 - argument is needed for the test button
14:01 - but not for the test cube it's a little
14:03 - bit weird
14:04 - but if you want to create a button this
14:06 - has to be parented to the scene
14:08 - and that's the actual game what we can
14:10 - also do
14:11 - for a button is to give it different
14:13 - colors depending on what you do with it
14:15 - so for example there is a highlight
14:18 - underscore
14:18 - color argument that changes the color if
14:21 - we hover over the button
14:23 - so this could for example be color let's
14:26 - go with red
14:27 - and then we also have a pressed
14:30 - underscore color
14:31 - and this is the color we get when the
14:33 - button is pressed and for this one let's
14:35 - go with color
14:36 - dot lime and now if we run this again
14:41 - we get our button if i have over it it
14:44 - becomes red
14:44 - and if i click it it becomes green so
14:47 - this one is working quite well
14:49 - and now how could we use a button
14:53 - and well this one is also incredibly
14:55 - easy all we have to do is to create a
14:57 - new method
14:58 - that is called input it needs self as
15:01 - usual
15:02 - and then it needs one more argument that
15:04 - is called key and that's the key we are
15:06 - pressing to activate it
15:08 - and now inside of that method we have to
15:10 - create an if statement that if self
15:12 - dot overt so if our mouse is over the
15:14 - button
15:16 - and inside of that what we want to check
15:17 - is if key
15:19 - so the key we pass into it is equal to
15:22 - the left mouse button argument which is
15:25 - called
15:26 - left mouse down
15:29 - and if that is the case let's just print
15:33 - button pressed and now
15:37 - if i run out of this it's still working
15:39 - and if i press on the button
15:40 - we get button pressed so this one is
15:43 - working pretty well
15:46 - and with that we can actually come to
15:49 - the game
15:49 - so let's talk about minecraft and really
15:52 - the one important thing you have to know
15:54 - about minecraft
15:55 - is that minecraft is a voxel-based game
15:58 - and really all that means
15:59 - is that every single block that you see
16:01 - in minecraft is a voxel
16:03 - so these are the things that we have to
16:05 - create ourselves but besides that
16:07 - there really isn't other much else that
16:09 - we do need
16:10 - so let's actually jump straight into our
16:13 - code again
16:13 - and let's have a look at this all right
16:17 - welcome back i have gotten rid of all
16:19 - the code i have used to explain with
16:21 - cena itself
16:22 - so all we have now if we run the code is
16:24 - an empty window
16:25 - that we can use to create an actual game
16:28 - and the first thing i have to do
16:30 - is to create a new class for all the
16:33 - voxels we want to create
16:35 - so the class is going to be called voxel
16:37 - and this one has to inherit
16:38 - from the button class for the simple
16:41 - reason that whenever i click on a voxel
16:43 - i want to create another voxel right
16:45 - next to it
16:46 - so i need to know where each voxel is
16:48 - that's why it's a button
16:49 - and in here we need our init method
16:52 - again
16:54 - itself and nothing else for now at least
16:58 - and let me just type it properly and in
17:01 - here we again need the super method with
17:04 - the underscore init
17:07 - and now we have to specify a couple of
17:09 - arguments the first one is parent the
17:11 - one that we have seen earlier this would
17:12 - be scene
17:14 - so the actual scene of the game next up
17:17 - we would need a position
17:20 - and the position for now let me just
17:22 - place it at
17:23 - 0 0 and 0. although this we are going to
17:27 - change later when we set up the game
17:29 - next up i want to create a model so what
17:31 - the thing is going to look like
17:33 - and this one for now is going to be a
17:35 - cube although this also is going to
17:37 - change at least somewhat then i need the
17:40 - origin
17:42 - y so effectively the height and 3d space
17:45 - of this cube
17:46 - and this one is going to be 0.5
17:50 - and once we have that we need a texture
17:53 - so we can actually see the cube
17:56 - and for the texture for now i'm just
17:58 - going to go with white
17:59 - underscore cube the one that we have
18:01 - seen earlier
18:03 - and this also we are going to change in
18:05 - just a bit for now i just want to have a
18:06 - basic setup
18:08 - and next up we are going to need a color
18:11 - and
18:11 - one important thing you need both a
18:13 - texture and a color
18:15 - and both of these colors are going to be
18:17 - multiplied together so if you only have
18:19 - the texture and no color it is going to
18:21 - look weird
18:22 - and for now let's just stick with white
18:24 - i think that's going to be fine
18:26 - and besides that i also want to create a
18:29 - high
18:30 - light underscore color and this one
18:33 - let's go with color
18:35 - dot lime so
18:38 - really all that's happening here is we
18:40 - create a button that is going to be a
18:42 - cube with a white texture
18:44 - and if we hover over it then it's going
18:47 - to be lime colored
18:48 - then we have a position 0 0 and 0 so
18:50 - it's right in the middle
18:51 - except it's slightly lifted up by 0.5
18:55 - that's really that's all that's
18:56 - happening here so
18:58 - now that we have all of that we have to
19:01 - create our button
19:03 - and for that let me put it right between
19:05 - those two lines of code
19:08 - i could just create voxel is equal to
19:11 - voxel and let's actually run this and
19:14 - let's see what happens
19:15 - so now we can see one button and it
19:18 - becomes greenish when we hover over it
19:20 - so this one well it's a start but
19:23 - i don't just want to create a single
19:25 - button i want to create
19:27 - multiple and to create multiple buttons
19:30 - really all i need is for z
19:34 - in let's go with range of 8 so i want to
19:37 - create eight blocks in the z
19:39 - space and inside of that
19:42 - i'm going to go for x in range
19:46 - eight so effectively what i have done
19:49 - is i have gone forwards and backwards by
19:51 - eight units and then i've also gone left
19:53 - and right
19:53 - for each of these units and now what i
19:57 - can do in there
19:58 - is to create a voxel and then this voxel
20:02 - is always going to get the voxel class
20:04 - itself
20:05 - so this way we are creating 64 voxels
20:08 - and now if we run this we still
20:12 - can't really see it and the reason for
20:14 - that
20:15 - right now is because they are all in the
20:17 - same position so this one doesn't
20:19 - really help us so i have to place in
20:22 - some kind of information in here to
20:24 - customize the position
20:25 - so when i call this class on the init
20:28 - method
20:29 - i want to give it a position that by
20:32 - default is supposed to be
20:34 - zero zero and zero so that we always end
20:37 - up with this position if nothing is
20:38 - passed in here
20:39 - and this one is getting position so if i
20:42 - run this again now
20:43 - nothing is going to change but what i
20:46 - can do now when i create all of these
20:47 - voxels
20:48 - i can pass an x 0 and
20:51 - z so that we actually use this
20:54 - information
20:55 - and this information to place each
20:57 - individual voxel
20:58 - so now if i run this again we are
21:01 - getting an error because
21:03 - all of this has to be a tuple and i
21:06 - could even give it the
21:07 - position keyboard and now let's try this
21:10 - again
21:11 - there we go now we can see all of them
21:13 - right next to each other
21:14 - the problem now is how can we actually
21:16 - create a first person character in all
21:18 - of this
21:19 - and in here usina makes this incredibly
21:22 - easy
21:23 - because it has a couple of predefined
21:25 - classes that we can use to just create a
21:27 - first person character
21:28 - we don't really have to do anything
21:30 - ourselves for that
21:32 - and really all we have to do is to
21:34 - import something else first
21:36 - and what we have to import is from usina
21:40 - dot prefabs dot first
21:44 - underscore person underscore controller
21:47 - and then import first
21:51 - person controller i hope i spelled that
21:54 - right
21:56 - so this by default is not being imported
21:58 - into oceana so we have to do it ourself
22:00 - but once we do have it all we have to do
22:03 - to create a first person character
22:05 - is to create a new variable where we
22:07 - store it and then call
22:08 - first person controller and this is also
22:12 - class
22:12 - so we have to call it and now
22:15 - i can run the game and we get a first
22:19 - person player
22:20 - so well with that we already have
22:24 - really the basics of what we need for a
22:26 - game
22:28 - and the buttons also work and the
22:30 - collision between them also works
22:32 - automatically so you don't have to worry
22:33 - about this
22:34 - at all which is really powerful
22:41 - and now if you do want to close the game
22:43 - because you can't use the mouse anymore
22:45 - i just switch between my windows and
22:48 - then close it from there this tends to
22:49 - be the easiest
22:51 - and cool now we have our first person
22:54 - controller
22:55 - and if you want to make all of this
22:56 - larger we could go with something like
22:59 - 20 times 20.
23:02 - and now we have a much larger field
23:07 - although one of the problems with the
23:09 - game right now is that if you added too
23:11 - many of these fields the game would slow
23:13 - down
23:14 - so there would be quite a bit of
23:15 - optimization work to do
23:19 - but all right what we have to figure out
23:21 - now is how to make all of this
23:22 - more interactive so how can you create
23:25 - and destroy blocks
23:26 - and again this is going to be super easy
23:29 - because
23:30 - effectively what we want to do is that
23:32 - if you press on the voxel button
23:34 - then we want to create a new block on
23:36 - that position
23:38 - so the first thing we have to do is to
23:41 - create a new button press functionality
23:43 - and this is something we have seen
23:44 - earlier because this voxel
23:47 - is just a button that we can press so we
23:49 - can give it an input method
23:51 - and this one itself and key separated by
23:54 - a comma
23:55 - and in here again i need if self dot
23:59 - avert and now i want to check is if
24:03 - e is equal to left
24:07 - mouse down and if that is the case
24:11 - i want to create a new voxel and this
24:13 - one again
24:14 - is going to need the voxel class so
24:17 - really what's happening in here is if we
24:19 - are pressing this button
24:21 - we are creating a new button in a
24:23 - certain position that we can specify
24:26 - and now we actually have to specify the
24:28 - position
24:29 - of this button and there are two parts
24:32 - we have to combine
24:33 - the first one is self dot position
24:36 - so that we get the position of the
24:38 - button we are pressing right now
24:40 - but then we have to add mouse
24:44 - dot normal and once we have that i can
24:48 - actually try all of this
24:49 - and see if it works so now if i press on
24:51 - any button
24:52 - we get a new well voxel button cube
24:56 - thing so this one is actually pretty
24:58 - good start
24:59 - so what's happening here and let me
25:01 - explain in the game that's going to be
25:03 - the easiest
25:04 - so here we have some more space
25:08 - so right now i'm looking at this button
25:11 - here or this voxel
25:13 - so i get the position of the voxel
25:14 - itself and the normal
25:16 - is the surface we are looking at so
25:19 - right now the normal is pointing upwards
25:21 - and this is what we are using when we
25:23 - create a new voxel button
25:25 - that we want to get the position itself
25:27 - plus the upward direction
25:29 - so when we press it that's where we are
25:31 - going to create the new voxel button
25:33 - and this we can do for any kind of
25:35 - surface that we just get the position
25:37 - itself
25:38 - plus the surface we are pointing at and
25:41 - in what way it's
25:42 - facing and once we have that we can
25:45 - really create
25:46 - all the different cubes that we wanted
25:49 - and this
25:49 - is pretty much a perfect minecraft
25:52 - functionality
25:53 - so really nice
25:56 - what we can do now is to add another if
25:59 - statement
26:00 - if we wanted to destroy all of these
26:02 - boxes
26:03 - so if key is equal to right
26:06 - mouse down and all i need to destroy
26:10 - a button is the destroy self
26:13 - and this is literally all we needed so
26:15 - now i can run the thing again
26:17 - and if i left click i create a voxel if
26:20 - i right click i destroy it
26:24 - and with that we can even create our
26:27 - bottom itself
26:29 - and fall into a bottomless pit of
26:30 - nothingness
26:33 - hey it's working and one more thing that
26:35 - we could be doing
26:36 - is to change the color and give it a bit
26:38 - more variety so right now every single
26:41 - block is perfectly white
26:42 - which well tends to get a little bit
26:44 - boring even if we added textures
26:46 - so instead what we can do is to give it
26:49 - color.color
26:50 - and in here we can specify rgb values
26:55 - and in my case i want this to be 0 and 0
26:57 - and then i want
26:59 - random dot uniform
27:02 - and this is supposed to between 0.9 and
27:05 - 1
27:06 - so that the color of every block is
27:07 - going to be slightly random
27:10 - and now if we run this it still works
27:13 - and now each of these blocks gets a
27:15 - slightly different shade of gray
27:18 - although there's one more thing that i
27:20 - am slightly confused about
27:22 - is that what these specific arguments in
27:24 - here mean
27:25 - is a bit confusing because if you change
27:28 - this one from zero to one
27:31 - nothing really seems to change however
27:35 - if you change the second one
27:38 - to a one now the entire thing is going
27:40 - to be red
27:42 - so i assume these values are going to be
27:45 - rgba but i'm really not entirely sure
27:50 - but let's leave it for now as it is and
27:51 - it's perfectly fine
27:53 - and all right with that we have a really
27:56 - basic setup
27:57 - for a very simple and nice
28:00 - game setup that works kind of like
28:02 - minecraft
28:04 - and all of this is exactly the same
28:06 - setup for one of the demos for usina and
28:09 - this is exactly what i have copied
28:11 - so if you've gotten this far you have
28:12 - basically replicated one demo from the
28:14 - cena game so definitely check out the
28:17 - github page
28:18 - and there are lots more examples i would
28:20 - really recommend to check them out
28:21 - they're really fun to play around with
28:23 - but alright now that we have our basic
28:25 - setup we can make all of this
28:27 - look much better and there are a
28:30 - couple of things that we need to make
28:32 - all of this work and let's start by
28:34 - creating proper cubes that we can use
28:36 - this is going to be the biggest change
28:38 - that we can
28:40 - and to create proper blocks with the
28:41 - proper textures we do have to cover
28:44 - one specific topic that right now we
28:47 - have used an inbuilt
28:48 - cube which worked decently fine but it's
28:51 - very limited in terms of how you can add
28:53 - a texture to it
28:55 - and the reason for that is that there's
28:56 - no uv map for
28:58 - it and a uv map is basically how you
29:01 - wrap a texture
29:02 - around a cube or really any 3d object
29:05 - and the default cube in oceana doesn't
29:07 - really have a uv map
29:09 - so when we apply the proper texture to
29:10 - it it wouldn't really
29:12 - work so what we have to do is to create
29:15 - our own block
29:16 - and apply texture to it and then import
29:18 - all of that into oceana
29:20 - which fortunately is really easy and i
29:22 - have used blender to create a basic
29:24 - block
29:25 - and in the project folder for this game
29:27 - i'm going to link the blender file in
29:28 - case you want to have a look at this
29:30 - but i'm going to import the finished
29:31 - file itself which is going to be the
29:33 - most straightforward way
29:35 - but let's go through it step by step
29:37 - that's going to be the easiest one
29:39 - so here i'm back in my code and the
29:41 - first thing i want to do
29:42 - is to get rid of this cube and instead
29:45 - what i want to do
29:46 - is to import from my assets folder and
29:48 - there i have a file called block
29:51 - and this is assets block
29:54 - and this block is a block i have created
29:56 - in blender that has a uv map
29:58 - so if we applied a more proper texture
30:00 - to it it would show up properly
30:03 - as a matter of fact i have created a
30:05 - couple of textures
30:07 - and just to save me some typing let me
30:09 - paste them all in
30:10 - so i have a grass texture i have a stone
30:12 - texture i have a brick texture and i
30:14 - have a dirt texture
30:16 - and all of these get a texture loaded
30:17 - right into the game
30:19 - and now i don't want to use the white
30:21 - cube texture anymore
30:23 - instead for now let's just go with the
30:25 - grass texture
30:27 - and let's actually look how this looks
30:30 - ah and if i run this now we get an error
30:32 - but a simple reason that we first have
30:35 - to create
30:35 - oceana and only then we can load
30:37 - textures so i need app
30:39 - is equal to cena first and then i can
30:41 - run all of this
30:44 - and now let's try it again this should
30:46 - be working now and there
30:47 - we go now
30:51 - you can kind of see the problem that the
30:53 - positioning
30:54 - is kind of messed up and the reasoning
30:58 - here
30:58 - is that the default buttons are a
31:00 - different size from the buttons we have
31:02 - imported
31:04 - but that we can change very easily all
31:06 - we need is scale
31:08 - is equal to 0.5 so now if i try this
31:11 - again
31:13 - now this looks much better and i can
31:15 - still create all of the blocks
31:16 - and i get my basic blocks so this one
31:20 - is still working exactly the same way
31:21 - except now we have a nicer looking
31:23 - texture edit
31:24 - and also what i want to do now i want to
31:27 - get rid of this highlight color
31:28 - because it makes the entire thing look
31:30 - kind of weird
31:32 - so now let's try it again and yeah i
31:35 - feel this is looking a bit better
31:37 - but you could leave it if you wanted to
31:39 - alright
31:40 - so now we're making some progress but i
31:43 - don't want this grass texture every time
31:45 - instead i want to be able to pick from
31:47 - any of these textures
31:49 - so what i want to do is when i create
31:51 - this voxel class
31:52 - i want to assign it a texture
31:56 - and by default this should be the grass
31:58 - texture
31:59 - but if i specify the keyword this could
32:01 - be
32:02 - any texture in here so now if i run all
32:05 - of this again we should still see the
32:07 - same outcome
32:08 - cool but now what we could be doing
32:12 - is when we are specifying the voxel
32:15 - itself let's do it down here actually
32:17 - let's do it up here so you can see the
32:18 - difference a bit better
32:20 - so whenever i click on a voxel i want to
32:23 - give it
32:24 - a more specific texture and let's go
32:26 - with the stone
32:28 - texture so now the default voxels are
32:32 - going to be the grass texture
32:33 - but when i click on one i'm creating a
32:35 - stone texture or a stone
32:38 - so now if i click on something we are
32:40 - getting a stone cool this is working
32:42 - pretty well
32:45 - and really all we have to do now is to
32:48 - figure out
32:48 - some kind of input that we can select
32:51 - specific kind of textures
32:53 - and what i have done is i have
32:57 - created an
33:00 - update function so the same thing we
33:02 - have seen earlier and this one is going
33:03 - to be run on every single frame
33:05 - and effectively what i have done in here
33:08 - i have created
33:09 - a new variable actually outside of it
33:11 - that i've called
33:12 - block underscore pick
33:15 - and by default this is one and then all
33:18 - i'm doing in here
33:19 - is if held underscore keys
33:23 - one then i want to set block
33:26 - pick to one
33:30 - and now i can copy this thing a couple
33:31 - of times and change this to two
33:35 - three and four and then 2
33:38 - 3 and 4. and i have to set this
33:42 - to global block
33:46 - pick so really all that's happening in
33:49 - here
33:50 - is that if i press any of this button
33:52 - this block pick gets a different number
33:54 - and this we can then use further down
33:57 - here
33:58 - to influence how this entire thing is
34:00 - going to look
34:01 - so instead of just creating a texture
34:04 - itself
34:05 - i also want to check if log pic
34:08 - is equal to 1 and if that is the case
34:12 - only then do i want to create a voxel
34:14 - with the
34:15 - let's put this one for the grass texture
34:18 - and i think can put all of them on the
34:20 - same line that makes it a bit more
34:21 - readable
34:22 - and with that i am only going to create
34:25 - a grass texture
34:26 - if block pick is equal to one
34:30 - but let's say if i pressed two
34:33 - then i want to create a stone texture
34:37 - if i picked 3 i want this to be
34:41 - a thing i call this a brick texture
34:45 - it was indeed a brick texture and then
34:48 - for number four
34:50 - i want this to be a dirt texture
34:53 - and all right let's try this now let's
34:56 - see what happens
34:57 - so i'm still in my basic game if i
35:00 - clicked
35:01 - just by itself we get this but now if i
35:03 - press two on my keyboard
35:05 - and try this again we're getting a stone
35:07 - block
35:08 - if i press three we're getting a brick
35:10 - and if i press four we're getting some
35:12 - dirt
35:13 - or however you call this one and alright
35:16 - this is
35:16 - really starting to come together so this
35:18 - is already helping to make the game look
35:20 - nicer
35:21 - but there are three more elements that
35:22 - can really help to bring the game across
35:25 - number one is the skybox number two is a
35:27 - hand and number three is sounds
35:30 - and let's go for them step by step the
35:32 - first one is a sky box
35:33 - and a skybox basically is what we can
35:36 - see as sky
35:37 - but to emulate this in our game all we
35:39 - basically do
35:40 - is we create a giant sphere that has a
35:44 - sky texture on it that's really all it
35:45 - is and
35:47 - well we can go straight to creating it
35:49 - it's super easy to do
35:50 - so here i'm back in my code and what i
35:53 - want to do is to create a new class that
35:54 - i'm going to call
35:55 - sky and this one is just going to
35:57 - inherit from entity
36:00 - and in there i need def init and it
36:03 - needs self nothing else
36:05 - and in there i need my super and then
36:08 - init and in here we have to specify
36:12 - a couple of things the first one just to
36:14 - be sure is the parent
36:15 - which needs to be the scene so we're
36:17 - part of the actual game
36:19 - but now for the model we need something
36:21 - new and that is
36:23 - a sphere so well a round object
36:27 - and now for the texture i want to create
36:31 - a sky texture and this one
36:35 - doesn't exist yet but all we have to do
36:37 - is to import it
36:38 - so in my textures i want a sky
36:41 - texture and let me line it up properly
36:45 - i want to lower texture again and in my
36:48 - assets folder there is one file
36:52 - that is called sky box
36:56 - dot png and this is the one i want to
37:00 - use
37:01 - let me add a bit more space below the
37:02 - class itself and this
37:04 - would actually already give us something
37:07 - so
37:08 - let me actually create it so below the
37:10 - player i'm also going to create
37:12 - a new variable called sky and this one
37:14 - gets
37:15 - my sky class
37:18 - and let's run the entire thing and see
37:20 - what happens i'm getting an error
37:22 - because this is supposed to be a comma
37:25 - now we go okay right now i can't see
37:27 - anything but if i turn around
37:29 - there we can see a very tiny world so
37:32 - this thing we want to scale up massively
37:36 - and really all we have to do is to give
37:39 - it a scale argument
37:40 - and in there i passed in 150
37:44 - so now if i run this again we can't well
37:47 - we can't see
37:48 - anything and well the reason for that is
37:52 - that this texture right now is only on
37:54 - the outside
37:55 - so if we are inside of this object we
37:58 - can't see it
37:59 - but we can change this very easily all
38:01 - we need is
38:02 - double underscore cited
38:06 - and this needs to be true and now if i
38:08 - run this again this should be working
38:10 - and there we go now this is looking much
38:13 - nicer
38:14 - although this isn't the perfect sky
38:16 - texture especially you can see
38:17 - there there's one seam this is where the
38:19 - texture start and end
38:21 - connect so well this isn't great but i
38:23 - think it's good enough for now
38:25 - so with that we have our sky now i can
38:28 - close this class and never think about
38:30 - it again
38:32 - now the next thing i'm going to need is
38:34 - a hand and this one is purely decorative
38:36 - it doesn't really do anything besides
38:38 - simulating having a hand it's
38:39 - a really simple thing and for that we
38:42 - are going to learn one new thing
38:44 - but i think this is best explained by
38:45 - actually implementing it and i want to
38:47 - create a new class
38:48 - that i call hand and this one is also
38:51 - going to be an
38:51 - entity and in there as always i need
38:55 - my done there init method that needs
38:58 - self and nothing else and inside of that
39:00 - i need my super
39:02 - and then init for that one
39:06 - and in here we have to specify the
39:08 - parent
39:09 - but the parent is not going to be the
39:11 - scene instead it is going to be camera
39:14 - dot ui and let me explain what that is
39:17 - so far we have only used the scene and
39:19 - this is the actual 3d space
39:21 - of our game the camera ui is the actual
39:24 - 2d space of our camera so if you want to
39:27 - create
39:28 - a ui it would be on this space and this
39:30 - one is not going to move along with the
39:32 - game itself
39:33 - it's just a static space that is kind of
39:35 - on top of the game itself
39:37 - it's essentially a glass sheet that the
39:39 - player is looking through
39:41 - or in most other game engines this would
39:43 - be a viewport this would also be a good
39:44 - way to think about it
39:46 - now what i also want is to give this a
39:48 - model
39:50 - and again i have a custom model that is
39:52 - in my assets folder
39:54 - and it's just called arm and this also
39:57 - has a texture
39:59 - and the texture let's load it straight
40:02 - in there
40:04 - and i call this one arm
40:07 - texture that needs an equal and
40:11 - load texture and this one is also an
40:14 - assets and i've called this one
40:18 - arm texture dot png
40:22 - and now i can assign this texture it's
40:24 - arm texture
40:26 - and with that we have our basic hand
40:29 - let's
40:29 - actually create this object using the
40:31 - class so i call this hand
40:34 - and let's see what happens
40:37 - so well um it's a touch
40:40 - large i feel so what we have to do for
40:43 - now
40:44 - is to make this entire thing a little
40:45 - bit smaller so
40:47 - i want to go scale 0.2
40:51 - an equal sign and let's try this now
40:56 - and now we get a much better
40:57 - proportioned hand
40:59 - although it's pointing right at us so
41:01 - that's
41:02 - not great and for that
41:05 - all i have to do is to give it a
41:07 - rotation and a position
41:09 - and the rotation is going to be a
41:12 - vector3
41:13 - and the rotation i went with is 150
41:16 - negative 10
41:17 - and 0. and let's try this now
41:22 - and there we go now we can see our hand
41:25 - a little bit better
41:26 - although it's still in the completely
41:27 - wrong position but well
41:29 - we are making progress and the rest
41:30 - still works perfectly fine
41:33 - so now let's give it a position so
41:36 - position
41:37 - is equal to and this needs to be a
41:39 - vector 2 because we're moving in a 2d
41:41 - space
41:42 - and i have moved this 0.4 to the right
41:46 - and then downwards by negative 0.6
41:51 - and now let's try this again and now
41:54 - this is looking much nicer
41:55 - cool so with that we have a basic hand
41:59 - but right now it doesn't animate and
42:02 - well that looks a bit weird
42:04 - so let's add a really basic animation
42:07 - although calling it an animation
42:08 - is well kind of overkill of course all
42:11 - i've effectively done is that if the
42:13 - player presses the mouse button
42:15 - their hand is in one position if the
42:16 - mouse button is not pressed
42:18 - the hand is in the default position
42:19 - that's really all that's happening here
42:20 - it's not really an animation
42:22 - but you could very easily make it one
42:25 - all i really have to do
42:26 - is to create a method for this hand that
42:29 - i called
42:30 - active and in itself and in there i
42:33 - changed
42:34 - the hand position and rotation to be
42:36 - more in the middle of the screen
42:39 - so i need self position
42:42 - and self dot rotation
42:46 - and no comma or bracket afterward
42:49 - and for the position i went with 0.3
42:52 - and negative 0.5 and the rotation i
42:56 - actually didn't touch
42:57 - so we can just leave it as it is and
43:01 - then for the other state
43:04 - passive ozone itself
43:07 - and for this one i just took this
43:10 - position
43:11 - and assigned it to it so self dot
43:14 - position so now we have two methods that
43:17 - can influence the position
43:19 - of the hand and if i click the mouse i
43:22 - want the active method to run
43:23 - if i don't click the mouse i want the
43:25 - passive method to run
43:27 - so with that i have to go to my update
43:29 - function and
43:30 - add another if statement in here and
43:32 - let's do it right at the top although it
43:33 - doesn't really matter
43:35 - and really all i want to do is if held
43:38 - keys
43:41 - as left mouse
43:46 - or held keys
43:49 - is equal to right mouse so for pressing
43:53 - the left mouse button
43:54 - or the right mouse button we want to
43:55 - trigger one of these
43:57 - and here's something slightly weird that
43:59 - if you use
44:00 - the update function you have to use the
44:02 - left mouse however when you use a button
44:05 - you have to use the left mouse down so
44:07 - it's a slight difference be careful with
44:08 - that
44:10 - but right now we have our if statement
44:13 - and all i have to do in there is either
44:17 - hand dot active
44:20 - and if that's not the case i want hand
44:23 - dot
44:23 - passive and
44:27 - that's literally all we have to do for
44:28 - the hand and if i run the code now
44:31 - and if i click my hand moves a tiny bit
44:34 - or at least we get the illusion of a
44:36 - movement but everything else still works
44:38 - really well
44:39 - and well this is quite nice so we are
44:42 - really making some good progress
44:44 - cool and really all that's left to do
44:46 - now is to add a sound to it
44:48 - and this is also really easily done i
44:51 - first have to import a sound
44:53 - and i have called mind punch sound
44:56 - and this now happens with the keyword
44:59 - audio
45:00 - and this is also new class and when we
45:02 - initiate this sound we need again a file
45:05 - and i have one in assets and i called
45:07 - this punch
45:08 - underscore sound and i didn't need the
45:11 - file ending
45:12 - and now we have to specify a couple more
45:14 - things the first one is loop
45:16 - and this one is supposed to be false
45:17 - because we only want one punch sound
45:20 - and i need autoplay and this is also
45:23 - supposed to be
45:23 - false and with that we have imported our
45:27 - audio file
45:28 - so now we have to figure out when to
45:30 - play it and the one i went with let me
45:32 - minimize
45:33 - all the other parts is that whenever you
45:36 - click
45:36 - or delete one of these cubes then we are
45:39 - going to play the sound
45:41 - and all i have to do to play a sound is
45:43 - to get the sound itself
45:44 - and then play and i want to do this for
45:48 - both creating
45:49 - and deleting a block so let me put this
45:53 - above destroy it feels better
45:56 - and now if we try all of this
46:01 - we ah i
46:04 - think i made one mistake let me get out
46:06 - of it
46:07 - so right now the sound is kind of double
46:09 - playing and the reason is
46:11 - well quite simple that whenever i call
46:13 - the input method
46:15 - and we're hovering over any of the
46:17 - buttons
46:18 - then we are playing the sound but i only
46:21 - want to play the sound
46:22 - if we're actually pressing it so that
46:24 - way
46:25 - it's going to work properly and now
46:28 - let's try this again
46:32 - and this is feeling so much better
46:36 - and cool this is basically the finished
46:39 - game
46:41 - there are a couple of tiny things that
46:42 - you can do
46:44 - and well they're really tiny basic
46:47 - things
46:48 - so let me do an all the way to top what
46:50 - we could do for example
46:52 - is window dot fps underscore counter
46:56 - dot enabled a build
47:00 - is true right now but i want this to be
47:03 - false
47:04 - so we can see a tiny number in the top
47:06 - right i hope this
47:08 - i feel makes the game look a bit nicer
47:11 - and since we're not using
47:12 - the escape button we can also hide that
47:14 - one
47:15 - so window dot exit underscore button
47:19 - dot visible is equal to
47:23 - false
47:26 - and now we get the whole window and this
47:29 - is literally what i have showed you
47:31 - earlier at the beginning of this video
47:33 - really what you can do now is just keep
47:35 - on building different blocks and just
47:38 - add more and more stuff towards it and
47:41 - get rid of stuff if you don't like it
47:43 - it works pretty well so well
47:46 - that's pretty much it there are a couple
47:48 - of things you do want to be aware of
47:51 - number one is that well lots of things
47:54 - are missing
47:55 - that we don't have an inventory we only
47:57 - create a very basic square
47:59 - and not much is happening yet so if you
48:02 - wanted to expand this entire thing
48:04 - you would have to add quite a bit more
48:06 - code because in the current setup if you
48:08 - had too many blocks the game slows down
48:10 - very noticeably so this would be one
48:13 - thing to work on
48:14 - number two is that if you look very
48:17 - closely at the textures you can see it
48:18 - very well here
48:20 - is that there are lots of little seams
48:21 - between them which happens because
48:24 - i well i didn't spend too much time
48:26 - making them because this is just a demo
48:28 - but if you spend a bit more time on them
48:30 - you can make them look much nicer
48:33 - and well you can also add an inventory
48:35 - and lots more tiny things
48:37 - but well what you have so far is
48:39 - essentially a basic start for the game
48:41 - so if you play rhombus more you can
48:43 - probably make quite a bit more of this
48:46 - so i hope you enjoyed and i will see you
48:49 - around
48:51 - bye