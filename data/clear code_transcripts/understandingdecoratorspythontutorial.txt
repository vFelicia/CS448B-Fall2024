00:01 - hello there in this tutorial we are
00:03 - going to cover decorators which are a
00:06 - somewhat more advanced topic in python
00:08 - so let's go over some theory first
00:12 - in the most basic sense decorators are
00:14 - functions that decorate other functions
00:17 - which does sound a bit cryptic but
00:19 - essentially what we do is we are
00:21 - wrapping one function around another
00:23 - function
00:24 - and let's do this a bit more visually to
00:27 - illustrate what's happening
00:29 - this is a normal function and usually
00:31 - what you do is you just call it
00:33 - somewhere and then you have something
00:35 - happening
00:36 - what decorators do is we still have the
00:39 - normal function
00:40 - but now we are putting another function
00:43 - around it
00:45 - and then when we are calling all of this
00:47 - we are calling the decorator function
00:49 - and inside of that decorator function we
00:52 - are calling the original function
00:54 - and this is allowing us to execute code
00:56 - before and after the function
00:59 - so when i'm calling this function here i
01:01 - could run code here and i could run code
01:04 - here without making any changes to the
01:07 - original function
01:08 - this function here
01:10 - would stay exactly the same all the
01:13 - actual logic happens inside of the
01:15 - decorator
01:17 - we are literally putting one function
01:19 - inside of another function and this
01:21 - other function executes extra code
01:23 - that's the entire idea of a decorator
01:26 - now why would you want to do this
01:29 - basically this way we can give extra
01:32 - functionality to a function without
01:34 - changing it
01:35 - a simple example here is we could write
01:38 - a decorator for a function and it makes
01:40 - the function execute twice when called
01:43 - not the most useful function but we are
01:46 - going to talk some more useful examples
01:48 - later on i just want to illustrate what
01:50 - is happening now in practice you are
01:52 - seeing decorators in three different
01:55 - circumstances let's go over them
01:57 - the most common one is you want to test
02:00 - your code without changing it let's say
02:02 - you work in a team you have some really
02:04 - complicated code and you want to test
02:06 - your code without making too many
02:08 - changes a decorator would be excellent
02:10 - for that
02:12 - the other example would be you are
02:14 - working in a team and you want to avoid
02:16 - making unnecessary changes
02:18 - now those two points are pretty similar
02:21 - you basically want to do something with
02:23 - your code without making too many
02:24 - changes
02:26 - and both of these are also fairly
02:28 - advanced if you are just learning python
02:30 - you are quite far away from either of
02:32 - these
02:33 - which is why you may be struggling with
02:35 - decorators because you don't really need
02:38 - them
02:39 - however there is a third case that you
02:41 - probably are going to use
02:43 - and that is using a decorator inside of
02:46 - a class because this allows you to run
02:49 - code when an attribute is accessed or
02:51 - changed
02:52 - so for example let's say you have a
02:55 - monster with health and every time that
02:57 - health is changed you want to run some
02:59 - other function inside of the monster
03:01 - with a decorator doing this is fairly
03:03 - easy
03:04 - although that being said decorators can
03:07 - be quite hard especially for beginners
03:10 - because we are going to use some more
03:12 - advanced functionalities in python that
03:15 - may be slightly
03:16 - confusing although i would really
03:19 - recommend you to try to follow along
03:21 - because this is going to be really good
03:23 - practice to understand functions and how
03:24 - to pass them around
03:26 - in fact before we start with decorators
03:29 - we need to recap functions itself so
03:32 - let's have a look at that
03:34 - here we have a completely empty sheet of
03:37 - code and let's just get started with a
03:39 - really basic function
03:41 - i want to define let's call it func
03:44 - there are no arguments and inside of
03:46 - this function i just want to print
03:49 - function
03:51 - just about the easiest function you can
03:52 - write if i call this function
03:55 - i get function
03:57 - so this really doesn't do all that much
04:01 - now there's a really important concept
04:03 - you have to understand that right now we
04:06 - are calling the function here
04:08 - and if we didn't do that so if i remove
04:11 - those brackets i could run this and
04:14 - nothing would happen
04:16 - but what i could do is print the
04:19 - function itself
04:21 - and now i get a function object
04:24 - meaning this
04:26 - function here as the whole function not
04:29 - what's being returned just the function
04:31 - itself and this is just going to be an
04:34 - object
04:36 - if that doesn't tell you anything check
04:37 - out my videos on object oriented
04:39 - programming they should be quite helpful
04:42 - but basically
04:43 - what this funk is giving us is a simple
04:46 - object that we can call and if we don't
04:48 - call it we are just getting a function
04:50 - object
04:51 - still not particularly useful
04:53 - but what we can do with this function
04:56 - object is pass it around like any other
04:59 - object like an integer like a string
05:02 - like basically any other object
05:04 - we can pass it around for example what
05:06 - we can do
05:07 - i can create another function and this
05:10 - let's call it a wrapper
05:12 - because this one is supposed to take the
05:15 - argument of the function
05:17 - and then i want to execute the function
05:20 - itself meaning what i can do now i can
05:22 - call my wrapper function and run this
05:26 - and i get function again
05:28 - and what is happening in here i am
05:31 - calling this wrapper and i'm passing in
05:34 - this function
05:36 - here what happens as a consequence
05:40 - is this function is being passed as a
05:43 - parameter
05:44 - into the wrapper function and inside of
05:47 - that function
05:48 - we are calling this function
05:51 - and when we are calling it we are
05:53 - printing the word function
05:56 - and now that we have that we could also
05:58 - do something like print
06:01 - hello
06:02 - and
06:03 - print
06:05 - goodbye and if i run this now
06:08 - we are running the function inside of
06:10 - another function and before and after we
06:12 - are calling it we are running some other
06:14 - code
06:15 - and this is basically the main idea of a
06:18 - decorator although it does get a bit
06:20 - more complicated
06:22 - but we'll come to that in just a bit
06:25 - now there's one more thing that you can
06:27 - do inside of a function
06:30 - and that is you can create a whole new
06:32 - function
06:34 - so for example let me create another
06:37 - function
06:38 - and let's call this one a function
06:42 - generator
06:43 - and then here we have no arguments to
06:45 - keep it simple
06:46 - and now inside of this function
06:49 - generator i want to create a new
06:51 - function
06:52 - and let's call this one new function i
06:54 - guess it's a good word
06:56 - and in here i just want to print
06:59 - new
07:00 - function
07:01 - and since this new function is just
07:04 - going to be an object we can return
07:07 - the new function and what i can do with
07:10 - that
07:11 - i can create a variable let's call it
07:14 - new
07:14 - function and i want to get my function
07:18 - generator
07:19 - and if i run this
07:21 - we can't see anything but now this new
07:23 - function is going to have this new
07:26 - function in here
07:28 - meaning what i can do i can call my new
07:31 - function execute it and we get new
07:34 - function
07:35 - so just to go over this because it may
07:38 - be a bit confusing
07:40 - this new function
07:41 - executes this one here and what we are
07:45 - getting from this function generator is
07:48 - we are defining a new function this one
07:51 - here
07:52 - and at the end of the function we are
07:54 - returning this new function
07:57 - and this we are capturing inside of this
07:59 - new function variable and this new
08:01 - function variable now is just a function
08:04 - meaning we can call it here
08:07 - and when we are calling it we are
08:09 - getting this print statement that's
08:12 - really all that's happening here
08:13 - the main thing you have to understand is
08:15 - we are basically passing around
08:16 - functions with the return statement
08:19 - with that we have some function basics
08:21 - so now we can actually start working on
08:23 - the decorator
08:24 - and for that let me open up a new file
08:28 - and in here
08:29 - i want to create an actual decorator
08:32 - now first of all for decorator we are
08:36 - going to need a basic function we want
08:38 - to decorate
08:39 - so from my function basics i want to
08:42 - copy this basic function here
08:45 - which is just printing function by
08:48 - itself so if i run this we get function
08:50 - literally the easiest function you can
08:52 - write more or less
08:54 - and now for this function
08:56 - i want to create a decorator and this is
08:59 - going to be another function that you
09:01 - can give whatever name you want let's
09:03 - say i want to call this one decorator to
09:05 - keep things simple
09:06 - and this decorator is going to accept
09:09 - one parameter which is going to be a
09:11 - function so in just a bit we're going to
09:14 - pass this function
09:16 - inside of this decorator
09:18 - what we are going to do with that inside
09:21 - of this function
09:22 - we're going to create another function
09:25 - and let's call this one the wrapper
09:27 - and this one right now doesn't have any
09:30 - arguments
09:31 - but now inside of this function i want
09:34 - to run
09:34 - the original function
09:37 - and besides that i can do quite a few
09:40 - other things
09:41 - for example i could just print
09:45 - the decoration
09:47 - begins and let me write this properly
09:51 - and i can also write the decoration
09:54 - ends
09:55 - and now after i have done that i can
09:57 - return this wrapper
10:00 - and now what i can do
10:02 - i can create my
10:05 - new function
10:07 - and this is going to be my decorator
10:10 - and instead of this decorator i want to
10:12 - pass in my function
10:15 - and once i have that i can just call my
10:17 - new function
10:19 - and i get the decorator begins the
10:21 - function
10:22 - and the decorator ends
10:24 - what is happening here let me go over
10:26 - this this is probably a bit confusing
10:28 - we are starting with our basic function
10:31 - and this function
10:32 - we are passing
10:34 - in here into the
10:36 - decorator function and this is the one
10:39 - we have up here
10:40 - and inside of this decorator function we
10:43 - are creating a whole new function this
10:46 - bit here
10:47 - and inside of this function
10:49 - we are calling the original function
10:54 - meaning this one here
10:57 - and then around this function we are
10:59 - doing some other stuff like we are
11:01 - printing these two statements here
11:05 - and then at the end of all of this we
11:07 - are returning
11:09 - this new function and this new function
11:11 - we are storing
11:13 - in the new function variable
11:15 - and then we can just call it like any
11:18 - other function and now we have extra
11:21 - functionality around our original
11:23 - function
11:25 - now where this becomes really
11:26 - interesting
11:27 - is let's say
11:29 - somewhere later in the course i am
11:31 - running function by itself
11:33 - which would just give me the word
11:35 - function
11:37 - let me comment out these two lines here
11:40 - if i just run fung i get function and
11:42 - nothing else
11:45 - and what i can do with decorators if i
11:47 - uncomment those two lines and get rid of
11:50 - this new func
11:52 - when i create the variable name for this
11:55 - i can just call it the same way like i
11:57 - have called the original function so i
11:59 - can call both func
12:01 - if i do that and run the code again
12:04 - i now have a new functionality for this
12:08 - function
12:09 - because we are essentially overwriting
12:11 - the original function name and that way
12:14 - our function even with the same name has
12:17 - new functionality
12:19 - and this is the basic idea of a
12:20 - decorator if we have this kind of system
12:23 - we can have really complex code and
12:26 - still check our function without making
12:29 - any changes to the code
12:31 - and since this is a reasonably common
12:34 - operation python has a shorthand for it
12:38 - and let me comment out
12:40 - this statement here
12:42 - and the shorthand looks like this i
12:44 - first write an add and then the
12:46 - decorator function so in this case
12:48 - decorator and now if i run all of this
12:50 - again we are seeing the same outcome
12:54 - for the simple reason let me uncomment
12:56 - it
12:58 - that this statement here
13:00 - and this line here they are doing
13:03 - essentially the same thing
13:05 - we are wrapping this function here
13:08 - inside of a decorator this one here
13:11 - and let's go over this a bit more slowly
13:14 - i think that's going to be useful
13:16 - here we have the function you have just
13:18 - seen and you can wrap this in a
13:22 - traditional way by writing the function
13:24 - and then we are putting the function
13:26 - inside of the decorator and then we are
13:28 - calling the function
13:30 - i hope this is making sense if you're
13:33 - confused about this i would recommend to
13:34 - pause the video now and just go over all
13:37 - of these different statements and see
13:38 - how they connect
13:40 - i guess i can go over it as well again
13:43 - we have this decorator here and inside
13:45 - of this decorator we are passing in the
13:48 - function
13:50 - and then we get this function here as a
13:52 - parameter
13:54 - now inside of this function we are
13:56 - creating a whole new function and this
13:59 - one is called wrapper
14:01 - and only inside of this function we are
14:04 - calling the original function this one
14:06 - here
14:07 - and then around this function we can do
14:09 - whatever we want like calling these two
14:12 - print statements here we could also do
14:13 - lots of other things i'm going to cover
14:15 - that in just a second
14:17 - and finally at the end what we are doing
14:20 - is we are returning this wrapper
14:22 - function
14:23 - and this wrapper function we are storing
14:26 - right now in func
14:28 - and then we can call it like any other
14:30 - function
14:32 - and that way we're using the name of the
14:34 - function and overwrite it with this new
14:37 - function that is being wrapped inside of
14:39 - the function
14:41 - which means if i took out this line here
14:44 - the function would come back to its
14:45 - original functionality and just print
14:48 - function
14:50 - now the problem with that approach is
14:51 - that we are writing func three times one
14:54 - two and three and if you want to call it
14:57 - a fourth time which is kind of annoying
15:00 - so what python developers have done is
15:02 - to create a shorthand for this and this
15:04 - is called a decorator and this one is
15:07 - looking like this
15:09 - and
15:10 - basically this line here where we have
15:14 - the name of the function a decorator and
15:16 - then the function as an argument is the
15:19 - same as this add decorator those two
15:22 - lines are doing the exact same thing
15:24 - meaning when you are calling this
15:26 - function you have the same result
15:30 - now obviously just printing two more
15:32 - statements isn't particularly useful so
15:35 - let's actually do something more
15:37 - relevant to see why decorators can be
15:39 - useful
15:40 - here we are back in the code and i want
15:43 - to create another decorator
15:45 - and this one i want to call the duration
15:49 - decorator
15:51 - and then here again as a parameter we
15:54 - need the function
15:55 - and inside of that i want to create a
15:58 - wrapper
15:59 - it doesn't need any arguments and in
16:01 - here first of all i want to execute my
16:04 - function and then return the wrapper and
16:08 - this is essentially a decorator that
16:11 - doesn't do anything right now and what i
16:13 - want to do with it is to measure how
16:15 - long it takes to execute this function
16:18 - here
16:19 - and for that to work we need a time
16:21 - module
16:22 - meaning i want to import time
16:26 - and now what i want to do inside of this
16:28 - decorator
16:30 - i want to get my start time
16:32 - and this i would get with time dot time
16:36 - and this has to run before i call the
16:38 - function
16:39 - and after i have called the function
16:42 - i want to get my duration
16:44 - and my duration is my time.time which is
16:47 - my current time
16:48 - and from that i want to subtract my
16:51 - start time
16:53 - and once i have that i can print
16:56 - let's call it duration and this should
16:59 - be an f string
17:00 - with the duration
17:03 - and now just to get some reasonable
17:06 - numbers in here
17:07 - when i am calling the original function
17:10 - i want to call time dot sleep and make
17:13 - it sleep for one second
17:16 - and now with this duration decorator let
17:19 - me actually call it so duration
17:22 - decorator
17:24 - i can now comment out this line here
17:27 - and now if i run the code we get
17:28 - function and we get the actual duration
17:32 - and from this line we know it took one
17:34 - point a tiny amount of time to execute
17:38 - all of this
17:39 - and this now we could get without making
17:43 - any changes anywhere else in the code
17:45 - we're just calling the function here we
17:47 - have the wrapper up here and then we're
17:49 - adding this one line of code to add some
17:52 - debugging functionality so this is
17:54 - something you could be doing if your
17:56 - code is running very slow and you want
17:58 - to identify what is slowing it down
18:01 - now another thing that i haven't covered
18:03 - yet is that you can combine different
18:05 - decorators and this happens by just
18:08 - adding them with the different add
18:09 - statements on top of each other
18:12 - and we already have another decorator so
18:15 - let me call this original decorator
18:18 - and let's run all of this again
18:20 - and now let me go through them i have
18:24 - decorator begins and decorator ends that
18:27 - is what we are getting up here from this
18:29 - original decorator
18:32 - besides that we have the duration of the
18:35 - decorator and this is what we are
18:37 - getting from this print statement here
18:40 - and the actual function so this print
18:44 - here
18:45 - is this line
18:47 - meaning now even though we have a very
18:49 - simple function by using decorators we
18:52 - can give it a ton more extra
18:54 - functionality without making any changes
18:56 - to it
18:57 - which is well the entire idea of a
19:00 - decorator if you understand this it can
19:03 - be really useful in very specific
19:05 - circumstances although if you are a
19:07 - beginner you probably just are going to
19:09 - add more stuff to this function although
19:12 - well if you know decorators you don't
19:14 - have to
19:16 - and this makes it much cleaner to work
19:18 - with your functions
19:19 - but alright let's do another exercise on
19:21 - this
19:22 - i want you guys to create another
19:25 - decorator that calls the function twice
19:27 - and this decorator should be called with
19:30 - this decorator and this decorator as
19:32 - well so that this function has three
19:34 - decorators in total
19:36 - and let's see how far you get
19:42 - again i have to create another function
19:45 - and let's call it the double
19:47 - decorator
19:49 - and in here once more we need a function
19:52 - and inside of this function i want to
19:54 - create a wrapper
19:56 - it doesn't need any arguments again
19:59 - and now in here i want to call my
20:01 - function twice
20:03 - which i just do by calling my function
20:05 - twice it's very simple once it comes
20:07 - down to it
20:09 - and once i have that i want to return
20:11 - the wrapper once more
20:14 - oh and by the way i'm just calling this
20:16 - wrapper because i think it makes sense
20:18 - you could call this whatever you want
20:19 - there's no naming restriction
20:22 - and all right now what i can do
20:24 - i can add another decorator with the
20:27 - double decorator
20:29 - and now if i run out of this we have to
20:31 - wait a second
20:33 - and if i expand this
20:35 - we have the code being executed
20:38 - once
20:39 - and then twice
20:41 - and well this is working really nicely
20:45 - and here again our actual function is
20:47 - really simple and we are just adding
20:50 - more and more stuff to it and that way
20:52 - it gets more and more complex
20:55 - with that we have some very basic
20:57 - decorators
20:58 - now there are some more things we can do
21:01 - with them
21:03 - and what i want to cover for this part
21:05 - is that you can have functions with
21:07 - parameters being decorated that part is
21:09 - actually really simple
21:10 - and besides that decorators themselves
21:13 - can also have parameters although
21:15 - implementing this gets even more
21:17 - complicated because we are wrapping a
21:19 - function inside of a function inside of
21:21 - another function
21:23 - so this we will have to explore in quite
21:25 - some more detail
21:27 - but let's have a look at all of this
21:30 - here i am back in a completely empty
21:32 - sheet of code and i want to create a new
21:35 - function so define function
21:37 - and now i want to have a function
21:40 - parameter
21:41 - it doesn't really matter what it is and
21:43 - in my case i am just going to print that
21:46 - function parameter
21:48 - and now once we have that i can call
21:50 - this function with whatever i want let's
21:53 - say hello
21:54 - and if i run this i get hello a super
21:57 - simple function
21:59 - and to decorate this
22:01 - we kind of need the same thing we have
22:04 - done here it's not really that much more
22:06 - complicated as a matter of fact let me
22:09 - actually copy this decorator here
22:13 - and paste it in here
22:16 - and now i want to decorate this function
22:20 - with the decorator
22:24 - and just as a reminder
22:26 - this would be the same thing as calling
22:29 - function
22:30 - is the deck curator
22:33 - with the function
22:35 - however now if i call this
22:38 - i am getting the decorator takes zero
22:40 - position arguments but one was given
22:44 - and this happens in this one as well as
22:48 - in this one
22:49 - so we're getting the same error message
22:51 - that's usually a good sign at the very
22:53 - least
22:55 - the problem python has is that this
22:56 - function needs this parameter so when we
23:00 - are calling the function up here
23:02 - we again need the
23:05 - parameter but on top of that when we
23:07 - call this function here
23:10 - we are calling this wrapper
23:13 - and right now when we are calling hello
23:16 - we are passing it essentially into this
23:18 - parameter here which doesn't exist yet
23:21 - which is why python is so unhappy
23:25 - and to get around this we just have to
23:27 - create the parameters
23:28 - meaning this wrapper here and this
23:31 - function need the same parameters oh
23:33 - well for this wrapper it's a parameter
23:36 - for this function it's an argument
23:38 - and let me name them properly here i
23:40 - want to have a wrapper parameter
23:44 - and now if i run out of this again we
23:46 - should see a different error message
23:48 - and that is that funk is missing one
23:50 - required position argument func
23:52 - parameter
23:54 - meaning this one here
23:58 - and well i get this
24:01 - argument from the wrapper parameter
24:03 - so now if i run this
24:05 - we get hello and if i change this
24:07 - argument to
24:09 - something
24:11 - this is still working
24:13 - and we could also do this the other way
24:16 - the more traditional way
24:18 - and we will get the same outcome
24:21 - and let me just go over what is
24:23 - happening here by using the traditional
24:25 - style to make it a bit easier to explain
24:29 - we are again calling this decorator
24:31 - function here and passing in the
24:33 - function itself
24:35 - now inside of this decorator we are
24:38 - creating all of this here
24:42 - and right now the wrapper has one
24:46 - parameter the wrapper parameter
24:48 - and then inside of this wrapper function
24:50 - we are calling whatever code we want
24:53 - and we also have the original function
24:56 - here and then we are passing the wrapper
24:59 - parameter as an argument inside of this
25:01 - function
25:02 - and once we have all of that at the end
25:05 - of the code we can just call the
25:06 - function with something and then this
25:08 - something would be passed into the
25:11 - parameter for the wrapper
25:13 - and then this would be passed into the
25:15 - original function
25:17 - now what you see very often for a
25:20 - wrapper you don't have one specific
25:23 - argument instead people very often just
25:26 - add arcs with a star and then double
25:28 - quarks
25:30 - and then this you pass into whatever
25:32 - original function you have so if i run
25:35 - this we get the same outcome and these
25:39 - are very simple unpacking operators this
25:41 - one is for a list and this one is for
25:43 - dictionary or keywords
25:46 - and the reason why these are used is
25:48 - because they allow
25:50 - for this decorator to accept basically
25:54 - any kind of function with any kind of
25:56 - parameter right now we only have one
25:58 - parameter but we could also have more
26:01 - name parameters an unlimited amount of
26:03 - arguments it doesn't really matter if
26:06 - you have this setup you can accept any
26:08 - number of arguments or named arguments
26:12 - which means that this decorator
26:14 - works with literally any function
26:16 - without limitation
26:18 - and all right with that we have basic
26:19 - parameters
26:21 - what we can also do let me uncomment the
26:23 - decorator let's try if this is working
26:25 - it does
26:26 - what we can also do
26:28 - is create a decorator that is accepting
26:31 - other arguments like a 10 for example
26:34 - but for that to work we need something
26:37 - even more complex
26:38 - so let's do this in a separate file
26:42 - all right and here once more we have an
26:45 - incredibly simple function if i call
26:48 - this function we can see function
26:52 - and now what i want to do i want to
26:56 - create another decorator
26:58 - and let's call this one a repetition
27:02 - decorator
27:04 - and this one should accept one argument
27:06 - by how many times i want to repeat this
27:09 - function here for example if i add a
27:12 - five in here i want to repeat this code
27:14 - five times when it's being called or
27:17 - rather i want to call it five times when
27:19 - it is being called
27:21 - now for that to work we need some pretty
27:25 - extensive setup
27:27 - and let me go through what this would
27:28 - look like i am first going to create the
27:31 - actual decorator so repetition decorator
27:34 - but this one is not going to accept a
27:37 - function instead it is going to accept
27:40 - this argument here so in my case i want
27:43 - to call this the repetitions
27:47 - and now inside of this i am creating
27:50 - another function and this is the actual
27:52 - decorator
27:54 - and this decorator is going to accept a
27:57 - function
27:58 - and now inside of this decorator
28:00 - i want to create the actual wrapper
28:03 - and this one in my case has no arguments
28:06 - and what i want to do is for
28:09 - let's call it r in
28:11 - range
28:13 - repetitions
28:14 - i want to run my function
28:18 - and now what i have to do
28:21 - i have to inside of the decorator i want
28:23 - to return the wrapper
28:26 - and then inside of the scope of this
28:28 - repetition decorator
28:31 - i want to return
28:33 - the actual deck curator
28:36 - and now if i run this it is going to
28:39 - work five times and i can change this to
28:42 - a 20
28:43 - and we will call this function 20 times
28:46 - now the question is
28:48 - why does this work so
28:50 - let's go over it and let's do this in a
28:54 - traditional way
28:56 - which i guess i haven't done yet but
28:58 - if we didn't use decorators and still
29:01 - wanted to use this
29:02 - it would look like this
29:04 - i'm still using my func variable name
29:06 - and now i want to call the repetition
29:09 - decorator
29:10 - and now for this repetition decorator i
29:12 - have to specify how many repetitions i
29:15 - want let's say 4 in this case
29:18 - and after i have that
29:20 - i am calling whatever i get from this
29:22 - and passing in my
29:24 - function and if i run this we get
29:27 - function four times
29:29 - now if you look at this this is probably
29:31 - really confusing
29:33 - but to understand this you basically
29:36 - have to understand the return statement
29:38 - and let's go through it one by one
29:41 - first of all we are calling the
29:43 - repetition decorator and passing in four
29:46 - that is this line of code here
29:50 - and this one by itself doesn't actually
29:52 - do all that much all we are doing is
29:54 - creating a new function and returning it
29:59 - so all we are getting from this
30:01 - repetition decorator with a 4 is this
30:04 - decorator here a new function
30:08 - meaning this decorator here is going to
30:10 - replace the entire decorator we have
30:13 - seen so far
30:15 - and on this new decorator we are calling
30:18 - the new function
30:20 - this one here meaning now
30:22 - we are passing this function
30:24 - inside of here and this function is
30:27 - being captured inside of
30:30 - this
30:31 - parameter
30:33 - and once we have that we are basically
30:37 - back to a normal decorator
30:41 - so inside of this decorator we have a
30:43 - wrapper and this one just loops over the
30:46 - range of repetitions that we get from up
30:49 - here
30:50 - and then inside of that we are calling
30:52 - the function and then we are returning
30:54 - the wrapper
30:56 - and then this wrapper is being stored
30:59 - inside of the function
31:00 - and we can call this function
31:03 - and then we are repeating it by whatever
31:05 - we specified in here
31:07 - and well if i comment this out again and
31:10 - return to my decorator let's add four in
31:13 - here and we still get four
31:16 - repetitions and i would really recommend
31:19 - you to practice this in your own time
31:21 - although if you're just starting don't
31:24 - worry too much about it just get used to
31:26 - functions and classes by themselves and
31:28 - once you are a bit more comfortable
31:30 - start working on decorators they are
31:32 - definitely one of the more advanced
31:34 - topics in python
31:36 - although there is going to be another
31:38 - section and this is where you are
31:40 - probably going to use decorators the
31:42 - most as a beginner and that is to use
31:45 - decorators inside of classes
31:48 - so let's talk about decorators inside of
31:51 - classes and there's one really important
31:54 - one it is called property
31:57 - and what this allows us to do
32:00 - is it allows us to turn methods into
32:02 - attributes and this is something we get
32:06 - from the property function that we can
32:08 - use inside of python it actually comes
32:10 - with python
32:12 - and i'm pretty sure all of this is going
32:14 - to sound really cryptic if i just
32:16 - explain it theoretically
32:17 - so let's do all of this in code that
32:20 - should be better alright here i have a
32:22 - completely empty python file and what i
32:25 - want to do is to create a new class
32:28 - let's call it generic
32:31 - and in here i want to create a dunder
32:34 - init method
32:36 - and this one itself and nothing else
32:39 - and what i want to do in here is create
32:41 - one attribute let's call it x and let's
32:43 - set a value for 10 it really doesn't
32:46 - matter what it is
32:47 - and now i want to create an object from
32:51 - this class let's call it generic and i
32:54 - just want my generic class
32:56 - and now i can print generic
33:00 - dot x and i should get 10 and indeed i
33:03 - do
33:05 - and now what i want to do is i want to
33:07 - observe this x here
33:10 - meaning whenever i look at it so i
33:12 - retrieve the value or when i change the
33:14 - value i want to run some other code and
33:18 - this by itself in python isn't really
33:20 - that easy to do
33:22 - i guess what you could be doing is run
33:25 - some kind of function that let's call it
33:27 - get x in here self
33:30 - and in here i could return self.x
33:34 - and then besides that i could print some
33:37 - other code
33:38 - let's say get x
33:41 - and now inside of this print statement
33:43 - instead of x i want to get x
33:46 - and don't forget to call it if i run
33:48 - this i get get x and the value so when i
33:52 - get x i can run some other code
33:55 - and this is fine by itself but it's not
33:58 - very elegant
34:00 - and again like we have seen with the
34:02 - other decorators
34:04 - what happens if i already have a lot of
34:07 - code let's say i have this generic x 10
34:11 - times in my code and i don't want to
34:14 - change all of these instances here
34:17 - i just want to change my class itself to
34:20 - account for that that whenever we get x
34:23 - i want to run some other code and this
34:26 - we can do
34:27 - but we need some special function in
34:29 - python
34:31 - and this function is called property
34:35 - and into this property function
34:37 - we can pass in a getter a setter and a
34:42 - deleter
34:44 - and then we can assign all of this to
34:47 - one attribute inside of our class let's
34:50 - say x right now
34:53 - and then this x is what we are actually
34:55 - going to work with so now when we are
34:58 - calling generic x this line here this x
35:02 - refers to this x here and then when we
35:06 - are just looking at this x we are
35:07 - calling the getter method
35:09 - when we are changing this x we are
35:12 - calling setter
35:13 - and when we are deleting this x we are
35:15 - calling deleter
35:17 - meaning now what you usually see with
35:20 - this
35:20 - the original attribute we have this x
35:23 - here we are turning into a private
35:25 - method with an underscore before it
35:28 - and now to python this x here and this x
35:32 - are two separate variables
35:35 - but i as a programmer still know that
35:37 - they're the same because of the naming
35:39 - convention here
35:40 - and now basically what i'm going to do
35:43 - for this getter i am going to return
35:45 - underscore x
35:47 - and with that we have a getter so this
35:52 - method here is going to be this getter
35:56 - meaning whenever we are calling
35:59 - this generic x
36:00 - we are calling this get a method
36:04 - which is then returning this underscore
36:06 - x
36:07 - and essentially what we are doing here
36:10 - outside of the class we are working with
36:13 - x and this is what we are accessing but
36:16 - inside of the class we are using
36:18 - underscore x and this is what actually
36:20 - keeps track of the value
36:23 - and now basically what we have to do
36:25 - besides a getter we also need a
36:29 - setter so let me change it and for the
36:32 - setter we need self and a new value
36:36 - and when we are calling this
36:38 - let me run set x
36:40 - and then self underscore x should be the
36:43 - value
36:44 - and this we do not want to return
36:48 - and finally besides that let me copy it
36:51 - one more time
36:53 - i want to have it deleter
36:56 - this one doesn't need a value
36:58 - and what i want to do in here is delete
37:01 - x
37:02 - and all we have to do for this one is to
37:04 - run del and self dot underscore x
37:10 - and now i can run this
37:13 - and let me make this a bit smaller
37:16 - now when i print generic x we get get x
37:20 - and the value of x meaning we have run
37:23 - this method here
37:26 - what i can also do before i'm printing x
37:29 - i can run
37:31 - generic x
37:32 - is equal to 4
37:35 - and now if i run this
37:37 - i am setting x and i'm getting x and
37:40 - then i get the actual value of x
37:43 - and finally what i can do
37:46 - i can also run delete and generic dot x
37:50 - and now if i run this i have set x get x
37:54 - the value of x and delete x
37:57 - meaning now
37:59 - whenever i for example get the value of
38:02 - x i can run
38:03 - whatever other code i want
38:06 - and for example what i could do with
38:08 - that
38:09 - i could import from date time that's not
38:13 - how you spell that from date time import
38:16 - date time and i want to know whenever i
38:20 - get x
38:21 - which i get by just printing
38:24 - the date time dot now
38:27 - and now if i run this
38:29 - i am getting the current time when i'm
38:32 - accessing x
38:34 - and since we're just returning this
38:36 - underscore x you could even make changes
38:38 - to whatever x you get depending on the
38:40 - time of day some other variables some
38:43 - basically anything you want to look at
38:45 - which is why all of this is really
38:47 - powerful
38:48 - and i would recommend to go over this in
38:51 - your own time it's really useful
38:54 - but just to go over it really quickly
38:55 - again i think that's going to be useful
38:58 - when we are initiating this class
39:01 - we have underscore x this one here
39:04 - and this is the variable we actually
39:07 - storing values in
39:09 - right now that is 10 but it really
39:11 - doesn't matter what it is
39:13 - once we have that we are running this
39:16 - line here and this one turns x into a
39:20 - property
39:21 - and this property has a getter
39:24 - a setter and a deleter
39:27 - and those are referring to this getter
39:30 - here this setter here
39:32 - and this deleter
39:34 - and now from outside of the class
39:36 - whenever we are accessing this x here we
39:40 - are running either of these methods
39:43 - and these methods then influence self.x
39:47 - which is where we actually store the
39:48 - value
39:50 - so this one here
39:52 - and that way when we are accessing
39:54 - changing or deleting a value
39:56 - we can run whatever code we want in
39:58 - there
39:59 - and i hope this is making sense this is
40:02 - again something slightly more advanced
40:04 - that you probably want to practice on
40:05 - your own time
40:07 - but what python developers also realized
40:10 - is that this isn't exactly an elegant
40:12 - way of writing all of this
40:15 - which is why this property works really
40:18 - well as a decorator
40:20 - and let me copy the entire class to
40:24 - implement this as a decorator
40:27 - and let me comment out all of this
40:32 - and basically how you would implement
40:34 - all of this as a decorator
40:37 - for the getter
40:38 - you would simply add the add
40:41 - property
40:42 - decorator
40:43 - although then the getter you would
40:46 - rename to the name of the property which
40:48 - in my case is this one here so i just
40:51 - want this to be x
40:53 - now for the setter
40:55 - i want to get another decorator and this
40:58 - one you would call with the name of the
41:00 - property in my case again x and now you
41:03 - would add dot setter and then the actual
41:07 - method would also be called x or the
41:09 - name of the property
41:11 - and finally
41:13 - the same works for deleter so we need x
41:16 - dot
41:17 - deleter
41:18 - and now the name of the method should
41:20 - also be the name of the property
41:22 - so x in my case
41:25 - and now once we have that
41:26 - i can get rid of this property here
41:29 - and now this code
41:31 - does the same as this code up here
41:34 - meaning if i run out of this
41:36 - we get the exact same result
41:39 - except now it's a bit easier to read i
41:41 - suppose
41:43 - and this is something you are going to
41:46 - see reasonably often even as a beginner
41:49 - because running some code when you're
41:51 - just changing a value or even when
41:53 - you're just looking at the value can be
41:55 - really powerful
41:57 - so understanding this here or at least
41:59 - being able to replicate it by yourself
42:02 - is going to be something you do want to
42:03 - practice
42:05 - but again this is all very advanced so
42:07 - if you're just learning python and all
42:09 - of this is too much don't worry about it
42:12 - you are not going to use it for quite
42:14 - some time
42:15 - and it would be much more valuable for
42:17 - you to understand classes and functions
42:20 - by themselves so don't stress yourself
42:22 - if this is too much
42:24 - but anyway this is all you need to know
42:26 - to get started with decorators and i
42:29 - hope that was helpful