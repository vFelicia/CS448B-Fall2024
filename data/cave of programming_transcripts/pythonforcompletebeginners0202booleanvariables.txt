00:00 - in this video we're going to take a look
00:01 - at Boolean values in Python let's create
00:05 - a variable here I'll call it just value
00:08 - which normally would be a terrible name
00:10 - for a variable because it doesn't
00:12 - describe what the variable actually is
00:14 - at all but in this case I want something
00:18 - completely non-descriptive so it's a
00:20 - perfectly fine name now we've seen that
00:23 - you can set variables equal to for
00:25 - example
00:27 - integers and let's do a print on this
00:31 - and let's also print the type of it and
00:34 - you can probably
00:36 - remember what this is going to display
00:39 - now so if we run
00:41 - this we see it prints 10 and it tells us
00:46 - that the type of the thing that value
00:48 - refers to is int integer a whole number
00:53 - we can also set variables equal to
00:56 - floats like
00:58 - 10.5 now we find that this is a
01:02 - float which is the type of thing in
01:04 - Python that represents floating Point
01:07 - values we've also seen strings so we
01:11 - could set this
01:12 - to some string like this some some text
01:16 - in
01:18 - quotes and then the type is STP now
01:21 - sometimes people call these primitive
01:24 - types just because in some programming
01:27 - languages there are certain typ types
01:30 - that are implemented in a simpler way
01:32 - than more complex types so some
01:36 - programming languages you have variables
01:39 - that can simply represent a little area
01:41 - of computer memory and you have other
01:44 - variables that represent something more
01:45 - complex but python doesn't have that
01:48 - division in Python everything is an
01:51 - object which is a more complex type of
01:53 - entity than just a little bit of
01:55 - computer
01:56 - memory but I just mentioned this
01:59 - primitive types thing just in case you
02:01 - come across it sometimes int float and
02:04 - perhaps even string are referred to as
02:08 - primitive types even though it doesn't
02:10 - really apply to python now there's
02:12 - something else that we could set a
02:13 - variable equal to we could set it equal
02:15 - to True notice true has a capital letter
02:21 - here it's actually a built-in keyword in
02:25 - Python
02:26 - 3 and if we run this we find the type of
02:30 - the variable now or the type of the
02:32 - thing it refers to I should probably say
02:35 - strictly speaking is Bo bull stands for
02:40 - Boolean this comes from Boolean algebra
02:43 - which was devised by George bull a
02:45 - Boolean variable has the value true or
02:49 - false one of those two
02:52 - things so we can also set this to fals
02:55 - and again you need a capital f for fals
02:58 - what can we do with this well let's take
03:01 - a look at something called the equality
03:04 - test operator I'm going to print the
03:06 - result of taking a string let's write
03:11 - hello and comparing it to another string
03:15 - with a double equal
03:18 - sign now a double equal sign is known as
03:23 - the equality test operator it tests if
03:27 - two things can be considered equal or
03:30 - not a single equal sign is the
03:33 - assignment
03:34 - operator it takes whatever's on the left
03:37 - of it and sets it equal to or makes it
03:41 - refer to whatever's on the right of it
03:45 - two equal signs performs a different
03:48 - function which we tend to associate with
03:51 - an just one equals sign in mathematics
03:54 - for example but two equal signs the
03:57 - equality test operator Compares if two
04:01 - things are equal or not so let's just
04:04 - take a look at what this does so this
04:07 - returns true the operator is what we
04:10 - call a binary operator meaning it
04:13 - requires two things to work so it's got
04:16 - this and this now if I change one of
04:19 - these strings so it's not equal to the
04:21 - other string anymore the equality test
04:24 - operator returns false now so the
04:27 - operator is looking at these two things
04:29 - and we can say it's returning a value
04:32 - it's returning
04:33 - fults but don't worry about the
04:36 - lingo only worry about whether you can
04:39 - use this code or not now we could set
04:42 - the return value of this operator equal
04:44 - to a variable let's call it is equal and
04:47 - set that
04:50 - equal to the return value of this equals
04:53 - equals operator so this bit here is
04:56 - going to evaluate to true or return true
05:00 - if the strings are equal and then store
05:02 - that in this variable if they are not
05:04 - equal it will evaluate to fals and again
05:07 - that will get stored in this variable so
05:10 - we can print this
05:13 - out and let's just print the type of it
05:15 - as well but you know what the type of it
05:17 - is going to be it's going to be
05:19 - bull let's run it and there we go false
05:23 - and
05:26 - bull we can use equals equals
05:30 - the equality test operator to compare
05:32 - lots of different things in Python
05:34 - including inss with floats it's not so
05:38 - reliable and is best avoided because
05:41 - floating Point values are not stored in
05:44 - a precise way they can't be because you
05:47 - can only use a certain limited amount of
05:49 - computer memory to store them and floats
05:52 - by their nature are not inherently
05:55 - Limited in that way try this code out
05:58 - for yourself verify that it works and
06:01 - we're going to be moving on to using
06:03 - this to create if statements to create
06:07 - conditionals that can run code only
06:09 - under certain
06:12 - circumstances hello you've been watching
06:14 - a free sample from my Python and machine
06:17 - learning for complete beginners course
06:19 - I'm uploading enough videos from the
06:21 - start of the course to get you started
06:24 - with python and machine learning the
06:26 - full course is absolutely massive if
06:28 - you're interested in it please click the
06:30 - link in the description the complete
06:33 - course covers not only basic python but
06:35 - also some fairly Advanced python even
06:38 - some desktop programming stuff and then
06:40 - goes on to machine learning and
06:42 - artificial intelligence until next time
06:46 - happy coding