hey guys and welcome back to part 2 of coding Tetris in Python with PI game so let's get right into it in this video we're gonna be finishing a few other functions we're gonna be doing valid space convert shape format we're gonna be coding a bit in the main and we're also gonna be fixing a small mistake I made in the last video so this code right here in draw a grid yes this does draw our grid but this is not what I intended this function to do and I kind of just realize this when I was looking over the video and looking over the code so we're just gonna copy this code from draw grid okay delete it out of there and we're gonna paste it down here at the bottom of a draw window okay so now we just have this after we're bleeding the label we have whatever code we had within draw a grid okay because draw a grid would this actually was supposed to do is draw deed lines for the grid so I kind of got this mixed up while I was going through the tutorial so we're gonna finish draw a grid now and what this is gonna do it's gonna draw those gray lines over top of all of our different colors so we can kind of see where each block is so we can see the actual grid structure so let's get started with this say SX which stands for start X is equal to when you call it top left X okay and then s Y is equal to top left Y like that alright and this is just so I don't have to keep typing top left X top left Y just makes it a little bit shorter for us okay now I'm just gonna say I'm going to set it before Luke when I say for I in range and this is gonna be the length of the grid so how many rows we have let's say for J in range and this one is now going to be a deal n of grid I so how many columns in each row and then here we're gonna be drawing lines okay so for every row we're gonna draw a line so pygame draw dot line we need a surface give it a surface we need to cover this case is gonna be gray so gray color code standard is 128 128 128 and then we need two positions okay so the start position is going to be equal to s X all right and then s y plus what do you call it I I believe x blocksize and I think that is actually correct okay now for the end position well it's gonna be the same xvalue because we're destroying or actually it's gonna be let me just check here yeah it's gonna be a xvalue that is just equal to the width so SX plus whatever the play with this and then the y value is going to be the same here because if you think about it we're gonna be at the same yvalue each time we're doing like we're drawing a horizontal line every horizontal line is gonna have the same two Y values and the x value is just gonna be changed okay so I'm just gonna copy this and paste it in here now okay uhoh all right I don't know why that did that but we'll just go back like that okay so now what we're gonna do is we're just gonna do this case with x sx plus j x blocksize okay sy can't actually just stay like this okay and then for sx same thing sx plus j x blocksize and J's again as our current column and then this one s y plus play underscore oops we need a plus sign here plus play underscore height like that okay and that should be drawing us what do you call it 20 vertical lines and then 10 horizontal lines down the screen giving us a grid and kind of the way that works is every time we loop through a new row we're simply changing the y value of what line we're drawing and then these X values are going to stay static just at the left side and the right side of the screen and then the way that we do it here is we have the X values that constantly are changing every column and the y values are staying static being the top of the screen and the bottom of the screen to draw the vertical lines and that's what I wanted to do within this drug grid function so now that's all kind of sorted out and we fixed like a small mistake don't get me wrong you can still have that other code up here it still works fine but just in terms of what I actually wanted to do with these functions that's the way we needed to fix it okay so now that we've done that what I want to start doing is getting into this convert shape format okay now this is probably the most complicated function I want to say within our program and what this is going to take as an argument or a parameter is just the shape now this is what I was talking about before so when we have a shape look something like this right so we have zeros that we have periods now this looks nice to us like we can tell what kind of shape this is but the computer has no idea so how can we get this into a form that the computer can read and ideally we want to give it we want it to give us positions within the grid of where blocks exist and then we're not going to give position if the block doesn't exist so if there's a period like this okay and you'll see what I mean as we start coding this function and that's what the goal of this function is to do to take that information and put it into something that's actually useful to us so we want a bunch of positions that's the goal because from these like lists we want to generate a list of positions and then based on those positions we can do things we can check them we can draw them and so on so I'm just gonna create a list called format don't worry if it's a keyword it'll just override it we're gonna say when we're giving a shape we're actually given a piece object so I don't know why I'm calling shape but whatever it's fine so shape dot shape and then we can just do is equal to and I'll talk about this in a second shape dot rotation modulus the length of shape dot shape okay so what this does is actually gives us the sub list that we need so this needs to be spelled correctly I don't know how I butcher that so bad okay shape touch shape so if we look again here whenever we're past a shape we're actually passed something like this right so we passed the shape object and its shape property so right here is look something like this looks like the variable T which would have a list full of lists so we want to get the actual sub list so which one this list right that's one we want so the way we do that is by getting the shape rotation modulus the length of the shape so for example if our current rotation is zero like we haven't rotated yet then what's gonna happen is we're gonna have zero modulus the length of shape in this case the length would be four so we get zero so we're given this first shape now if we have one we're given this if we have two or giving this if we have three were given this and if we have four then we go back and we get this one okay and it just keeps going and keeps going because modulus simply just gives us the remainder so that's how we can tell what the axe current shape is within that main list okay hope that make sense so now we've done that what we're going to do is we want to set up a loop and because we want to look through every row and every column and then based on if there's a zero or a period we're gonna do something so we're gonna say 4i comma and because we want the line as well in enumerate alright and then format okay because format is the list that contains like the actual zeros in once okay we're just gonna say Rho is equal to list of line this just gives us a nice list format that we can deal with making it easier for us I'm gonna say for J in or J comma column sorry in enumerate and now row so now every row we're getting the current line and then we're going to loop through the line and look for either a 0 or a period I'm going to say if column which is going to be for example if we have some like this it's gonna look like 0 0 ok so this is what our row is gonna look like so when we start looping J will be 0 and column will be a period okay just just in case you're kind of confused there okay so before if column equals equals and it's gonna be string 0 then we know that we've hit like a position like this cube exists here so what we want to do is we want to add the position to our positions list now it's not so simple as just to add the current I and J value we actually have to add something else I'll show you right now I'm just gonna type it out and kind of talk about okay so shape dot X plus J and then shape dot y plus I okay so this is our x value it's the current value of the shape because if the shape is already moving down the screen is moving left and right well we need to add that to whatever the J value is whatever column were in within this list okay and then same thing for with the Y value so whatever the current Y value is of our shape we're gonna add whatever column or whatever row sorry we're now in as for the Y value okay and that is the positions that we need in these positions list okay so now that we've done that we just have to modify these positions slightly we'd shut to give them an offcenter and I'll talk about why this why if to do this so for I pause in enumerate positions okay then we're going to say positions I is equal to and then it's going to be the current position okay so we just need to put this in a tupple cuz that's the way we're gonna give it pause 0 minus 2 and pause 1 minus 4 okay so now let's break this down and kind of talk about exactly what's going on so we started off blank list positions we're just getting the actual shape within this list so for example we get something like this okay and then we're looping through it and where am i sorry and we're pretty much just checking if a zero exists in each position of that shape okay if that exists then we're gonna add that position into our list and the way we do that is simply by getting the X plus whatever the current column is that we're looping through and whatever the current row is plus y okay now that we've got that the issue is that if we look here we're gonna get something like for a position list here we'll get something like three one and then we'll get three two we've got three three and we'll get three four okay now the issue with that is we're adding the current X value plus these two periods and the O so we need to remove these kind of trailing periods right because that's gonna result in our positions being offset it to the right by too much same thing with these Y values okay because when we're counting this row we're saying well this is one lower than this row so our current Y value say it was zero and we're adding to it now instead of just adding one we're gonna be adding two so what's gonna everything's gonna be offset down so the way that we can kind of fix this is just by offsetting by constant by offsetting I'm just gonna take every x value that we've added and subtract two from it and every Y value that we've added and subtract four from it now what this is gonna do is simply just move everything to the left and up so that when we are displaying it it's just more accurate to the screen okay you guys can see what's gonna happen if you don't offset this and you'll notice that you kind of run into a few errors so run with me on this Aryan and just kind of you should see how this works later on okay okay so now that we've converted the shape format I want to go and code valid space now okay so valid space is gonna take two parameters shape and grid all right and we're gonna check the grid to see if we're moving into a valid space so what I'm gonna do here is I'm going to create two Liske I'm gonna say accepted how do you spell accepted accepted underscore pause so these are just gonna be the positions that are actually valid okay is equal to and just flow with me on this we'll talk about in a second for ji and then within this list for J in range 10 this is similar what we did in the last tutorial and then for I in range 20 okay this is really similar to the way that we created the grid we're just getting every single possible position for a 10 by 20 grid okay and we're just adding it in a tupple in accepted position it's okay that's great but the thing is I want to convert this into a one dimensional list so this is the way we can do this and make all the positions but now how do we flatten this list so this is actually how you do this okay so accept it cause it's gonna be equal to and this is one way there's many J for sub in accepted positions and then one more for J in sub okay so what this is actually doing now is it's pretty much taking all the positions in our list and just adding it into a one dimensional list and we're just overriding this list with that so see if you guys can understand that if not don't worry about it just know that all this does is simply flatten this list so we go from looking something like this we wouldn't call it like 0 1 and then having another list embedded just trying to show an example here to 3 so we go from that to something that kind of looks like this and we just have two positions in it now so we don't have those sub lists and it just makes it a lot easier to loop through okay so now we just have 0 1 2 3 rather than having these embedded lists full of other tuples okay that's all we're doing with this line okay so after we do that what we want to do is we want to get all these positions and we're gonna get the shape and we're gonna convert it into our positions right because remember whenever we get a shape it looks something like this it means nothing to us we need to first convert it into positions before we can compare it against other positions in our grid so we're gonna use this convert shape format grid our convert shape format we're gonna pass it to the shape and we're just gonna store this in a variable and I guess we're gonna call it what should we call it formatted okay because I guess that makes sense we formatted our shape so now we can use this and kind of compare it against accepted positions so here we're gonna have a list that looks like something with a bunch of positions in it and then this one we're gonna have a list that has a bunch of positions in it so you might see where we're going here in terms of how to compare these things okay okay so now that we've done that we've kind of got all our data ready to check this is the really easy part where I'm just going to say for position in format it and all we're gonna do now is just check if this position exists within excepted positions because accepted position is every position that were allowed to have right so we're say if pause not in accepted position and this is an important part pause one is greater than a negative one return false and then otherwise so if we make it through that loop that means we had all our positions accepted we can return true okay so let's talk about this really quickly the reason I have this if pause once the Y value is greater than negative one is because when we give this offset of four what ends up happening is we get some when we spawn in our shapes they're gonna spawn above the screen and then we actually want this because we don't want our shape to show up on the screen we want to start falling before it's actually seen so typically this means a Y position is going to start out like negative 1 or negative 2 so the thing is while it's falling we're checking if it's in a valid position right but the thing is it's not going to be a in a valid position if it's negative so we just want to make sure that we're only asking if it's in a valid position if the Y value is greater than negative 1 so greater than or equal to 0 okay and this is a really easy way to tell us well are we on the grid or not so let's give an example say we're trying to move left and we're already at the edge of the screen so that means we're gonna have an x value of negative one well that position of negative one whatever Y value is not gonna be in this accepted position great what do you call it list so when we try this we're gonna return false and it's not gonna allow us to move left and that is the whole point of that and now okay what am I doing here okay so I also just want to modify this part up here so I have for J I and range for J and range if I in range 20 I want to just change something here okay so what I'm gonna do actually let me say if grid I J equals equals and then the color zero zero zero okay so this is an important part I was kind of waiting I was kind of thinking about this so pretty much we're only gonna add this position into our accepted position if it's empty which actually makes a lot of sense because think about if we already have a color in that position then that's not a valid position we can't move into where piece already exists so what this condition does it says okay well we're only adding this position now if this is true so if I J is true then we're good we can add the position if it's not zero zero zero that means something exists in there so that's why we're not gonna add it into our excepted positions okay so I know this looks kind of confusing cuz I'm doing like a bunch of embed in for loops this just saves us a few lines it's kind of a cool way to create a list in one liner it's like the Python anyway so I figured I'd do that for most of the stuff in here okay so now that we've done that what else can we code well you know what while we're here we can code check lost alright this one's a really easy function this is just simply in a check if any of the positions are what do you call it above the screen so if we hit y value 0 then we know that we're above the screen and we've actually lost so the way to do this for your site for pause be in positions because what this is gonna do is we're gonna pass a list of positions so we're gonna get every pause now in the position we're going to say X Y is equal to pause which simply you're splitting up the tupple because we know we're gonna get something looks in the form of like three four okay and we're say if Y is less than 1 so equal to 0 or greater then we return true else where we don't even need no say return false down here so if every position is less than or greater than Y or whatever 1 then we will return false because we haven't lost yet otherwise we return true ok so we're almost getting there now I want to go down to the mean and I want to finish coding up some stuff in here so last time we kind of just left it at this like moving pieces around whatever but we have these variables ok so change piece next piece o'clock fall time that we're not using so what I'm gonna do now is I'm going to show you guys how we can actually move our shape down our screen at like a regular time interval so I'm gonna create a variable here actually called fall speed and this is how long it's gonna take before each shape starts falling ok so we'll talk about how to do this actually we're gonna start coding it now so pretty much we're gonna say up here and I didn't do this before which fall along grid equals create grid based on locked positions the reason we're doing this I know we already created great up here is because every time that we move we have a chance to be adding something to locked positions we're gonna do that later because for example if we hit the bottom of the screen will now lock to position it's gonna be equal to something else because it's gonna have a new shape in it shouldn't we need to constantly update the grid so that when we're drawing it to the screen we get like an updated version so that's why I'm doing that up here ok I also need to actually I don't think I need to do that here we need to add to fall time ok so the way we're gonna add to fall time because this is gonna track would he call it how long since like the last loop ran is by using this clock object that I set up here ok so before I add to that after here I'm gonna do clock tick and then I'm going to add this and I'll talk about this after I do it so Clark get underscore raw time like that ok so the way that this works is this wrong time actually gets the amount of time since this last clock tick so when I first add it's going to be zero because we haven't yet take to the clock and the next iteration it's gonna see how long it took this while loop to run and then it's going to simply add that amount okay so it's actually gonna give us real time this means this should technically run at the exact same speed on everyone's computer and every one machine because I know when I use fps FPS is dependent on kind of the speed of what do you call it your actual computer sometimes like the way I did it in other games so this is a better way to do it so now what I'm gonna do is since I've now incremented the fall time and this is gonna be given to us in milliseconds so like one second would be a thousand that's that number and our fall speed is in well zero point two seven so what I need to do is I have to say if fall time divided by a thousand is greater than false speed then we're going to do is we in a reset fall time equal to zero and if we're going to add one to the current Y value which means we're scripted we're moving down the piece one so this is gonna automatically now move our piece down another thing is what if our piece will hit the bottom the screen or what if it's moving into position we can't move into so this is the same thing we've kind of done in here what we're gonna do is going to say again if not valid position or valid space whatever given the current piece and our grid I believe at least grid okay then and actually we're gonna check one other condition and our current piece dot Y is greater than zero this means that we're not at like the top of the screen because the same thing with negative values all right is greater than zero then what we're gonna do is were gonna subtract one from the current piece so y minus equal one because that means we'll we moved into an envelope position so let's move back up one and pretend like that never happened and we're just gonna say change piece is equal to true now the reason I'm setting change piece equal to true because think of it right if we're moving down and we move into position that's not valid well we know we didn't move left or right off the screen because we were moving down that means we must have either hit the bottom of the screen or hit another piece so in that instance we need to stop moving this piece and we need to change it and what changing piece is gonna do we're gonna do that later is simply gonna lock all the positions what they're currently in and then it's gonna make this next piece generate down the screen and I'll show you that in a second but this is kind of the way to check it and it's the easier way then you don't have to check like the yvalues and and all that stuff okay all right so now that we've done that let's move down here to the bottom of main and let's start adding a few things okay so what I want to do down here now I want to say shape positions so shape underscore pause is equal to convert shape format current piece because what we're gonna do now is we're going to check all the positions of the piece moving down to see if what we've hit the ground or see if we need to lock it okay so and we're gonna add all that color to the grid so that when we're drawing it we actually see the piece because right now we have the piece but we don't add its color into the grid so we're not actually gonna see it show up so we first need to add it to the grid so we can draw it and we can see it moving so to do that we're gonna say for I in range the blend of shape positions okay we're going to here going to say XY equals shape positions of X that's the current iteration the current one we're looking through and say if Y is greater than negative one so this means that we're not above the screen then we say grid Y x equals current piece dot color okay because remember the grid stores a bunch of different colors so all we're doing in the greatest giving different colors and based on that position in the grid so Y X which is going to be this shape the all the shape positions we're gonna draw that color now the reason I'm gonna have this negative one is because imagine that we're at the top of the screen and we try to draw it or we're above the screen we have a position with a negative Y value so if we throw negative we're not actually gonna get an error in grid here but it's gonna end up looking like it's at the bottom of the screen and that moving to the top and is just gonna look weird if you guys want to see what it looks like without this just removed this condition you'll see that Y I haven't added in okay so now what we're gonna do is we're going to check this change piece variable so I put it up here change piece this means that we've hit the bottom or we've hit something what we're gonna do now is we're gonna update locked positions and this one I'm gonna start talking about a lot okay so four paws actually in shape positions all right we're going to say P is equal to zero pause one all right I don't know why I do this but I think there's a reason for it so let's just run with it and we're gonna say locked positions P is equal to current piece don't cut okay so what is this well locked positions is gonna be a dictionary I'm gonna form like this alright it's gonna have a top one here that's gonna have a positions like 1 2 and then we're gonna have a color and the color is gonna be another tupple but RGB values okay so for example to 5500 the reason we have this is so that when we passed locked positions into our grid like this alright we can get each of those positions in the grid and then update the color of gray so every time that we have like a locked position in a locked position as simply means our piece is no longer moving it's hit the bottom of the screen and we're on to a new piece we can get the position and we can get the color and then we can update the grid based on that and we can keep that in there okay and that's the way that locked position works so it's a dictionary with the key of a position and the value of a color all right that's kind of like the data structure for that now what we're gonna do after this after we update our locked positions and we add positions to it whereas a current piece equals next piece okay so we're just gonna change that and now since we've said current pieces now we kill the next piece will we need to update next piece so let's get a new shape because we're just moving forward with the game and now of course we got to say change piece equals false because we're on to a new piece that's gonna spawn at the top of the screen okay and I think that is about it what we also want to do actually is we're gonna check if we lost the game and I think I do this after trial window I don't think it really matters but we're gonna say if check lost based on what do you call it locked positions okay so these are all the positions of the shapes then we're gonna say run is equal to false and that's gonna break us out of this wall open you know what while we're here let's indent out nonstop I game but what is it I think it's not displayed up quit or something yeah don't display dot quit so we're actually just exiting out of our game okay so I've done a lot here I think I'm gonna stop it here and in the next video we're gonna get into kind of doing clearing the rows which is also very complicated and I think we're gonna test this a few times go through probably fix a few bugs and yeah so that's been it for this video if you guys enjoy please make sure you leave a like and subscribe and I will see you again in the next one