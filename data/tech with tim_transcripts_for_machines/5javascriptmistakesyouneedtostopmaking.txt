if you've ever written any code in JavaScript you might have noticed that it's a little bit of a strange language and there's a lot of unexpected behavior and weird things that go on now this leads many beginner and Junior developers to making a lot of mistakes in JavaScript simply because they don't know about these weird features so in this video I'm going to share with you the top beginner JavaScript mistakes and how you can fix them with that said let's dive in so first thing to mention is that if you want to get better at programming and become a software engineer I do have a course it's called programmingexpert.ao I'll leave a link to it in the description and if you're interested in blockchain or web3 technology I have a course for that as well it's called blockchain expert again that will be in the description now let's dive into mistake number one so the first mistake that many JavaScript developers make is misunderstanding the use of the double or the loose and the triple or the strict equality operator so in many programming languages you only have access to the double equal sign which tells you if two objects are equivalent however in JavaScript we have the triple equal sign which tells you if they are strictly equivalent now that means that a lot of people mix this up and they use both of these operators kind of willynilly without understanding what the difference is you should always use the triple equal sign here the strict equality operator unless you have a reason to specifically use the double equal sign and that's what I'm going to talk about now so notice here that I have my number one equal to the number 42 and number two equal to the string 42. now these are different objects they're different types and really they are not equivalent however when I use the double equal sign or the loose equality operator and I run my code notice that it says that they are equivalent now that's because the elusive quality operator is going to convert the first number here into a string and then compare the two strings against each other to tell me that this is actually true or equivalent now this works with other types as well and can give you some strange Behavior if you're not careful for example if I compare null and undefined using the loose equality operator notice we get true if I compare something like false and then the string false here notice that we get false so it's not necessarily intuitive right in this case you would have thought oh yeah that's going to tell me it's true because it'll just convert the Boolean to a string or vice versa but it doesn't now let's look what happens if we do it in the other order just for a sanity check here if we go false double equal to the string false then we get false as well so just showing you there's a very strange Behavior now continuing I can say false is double equal to undefined okay so that's equal to false what about false equal to null okay so that's false so not necessarily intuitive gives you a lot of weird results and that's why I wanted to show you here that when you're using this double equal sign is checking for loose equality where it's going to attempt to convert the different types into one another so instead of using that you should use the triple equal sign like this now when you use the triple equal sign this is a strict equality which means that you're only going to say that something is equal if it is the same type so in this instance when I use the triple equal sign if I go and say node and then solution.js you can see that it says using triple equals num1 and num2 are not equal and then we could repeat all of those examples that I showed you with the triple equal sign and you see that they would not be equivalent if they were not the same type alright so the next mistake that many JavaScript developers make is misusing the VAR let and const keywords or using them synonymously when they actually do have different use cases now when we're declaring variables in JavaScript as I just said there's three different ways to do this we can use the bar keyword the let keyword or the const keyword now a const is going to be used when we're declaring a constant value that cannot change let is going to be used when we're declaring something that can change and then VAR will do the same it will declare a variable that could change however VAR and let are not the exact same they're not synonymous they work differently and the way that they differ is in the scope in which they Define a variable a lot of people don't know this but you cannot just treat VAR the exact same as using let so have a look at this example pause the video if you want to and kind of read through if you can understand but I'll walk you through it so you see that we have a function here and inside of the function I start by declaring a variable using the VAR keyword now when I do this we're actually going to declare a variable within this scope okay the scope is essentially going to be the nearest function that we're inside of now there's some other weird edge cases there but in this case it's kind of the nearest function that we're enclosed in so in this case it is example okay then we say if true so we're just executing this if statement here to create a new block we declare a another variable with the same name as this using the VAR keyword now obviously here when I go to print this out we're going to print out the value of 2 which is this new variable that was declared however when I come outside of the block here notice that I will be printing 2 as well when you might have thought that I would have printed the value of 1. now the reason we're getting 2 here is that when I use this VAR keyword it doesn't declare this variable inside of the block it declares it inside of the current scope so the block is the if statement the scope is the function so it actually overrides the value of the variable that existed before it in the current scope to be equal to 2 which is different than what the let keyword does so now if I come and have a look at using let you can see that we Define let equal to one we say if true then we Define it equal to 2 and then we print out what the value is inside of this if statement Block in this case it's 2. however when we exit the Block it's equal to one now it's equal to one because let only defines the variable within the current block not within the current scope so this variable only accessible and usable inside of this if statement block and then outside we revert back to using this one because this statement did not modify or override this variable hopefully that makes a little bit of sense VAR is the current scope which is the function let is the current block which would be something like an if statement for Loop Etc then we have const now when we use cons it's going to do the current block as well so exact same as let so you can see here we say it's equal to one we come in and we Define the constant equal to 2. inside the Block it's equal to 2 outside of the block it is equal to one make sure you understand those important differences and you use VAR let and const accordingly based on that so the next mistake that many JavaScript developers make is misusing mutable and immutable types or not understanding the difference now in JavaScript we have this concept of mutability this means that some objects are mutable meaning they can change and some are immutable meaning they cannot change now this is a very important concept to understand especially when you're working with objects or nested structures so before I actually dive into this example I'm just going to illustrate a immutable objects you can see the standard and typically expected Behavior so let's have a constant x equal to one and a constant Y is equal to X and then I say something actually let's make these let's so they can change their values like X plus equals one and Y plus equals two now in this case what happens here in this example is we Define x equal to one now one is an immutable object that means once we Define it it cannot change and then we say Y is equal to X now that means that we are going to essentially copy whatever the value inside of X was into y so now Y is equal to 1 as well however it's a different one than the one here so now if I say X plus equals 1 x becomes equal to 2 and then if I say y plus equals 2 y becomes equal to 3. me changing X or Y does not affect the other variable even though I had something like let Y equals X I know this seems completely trivial but in some cases you might actually think that because I said Y equals X now if I change y it affects X and if I change X it affects y but that's not the case because this is an immutable object so in JavaScript types like booleans numbers strings these are immutable meaning once we Define them they're not going to change and if I assign them to to another variable so something like Y equals X now Y is a copy of that object now this is different when we look at immutable objects like arrays or objects so if I have something like an array here and then I say let Y equals X and then I do something like y dot push one what actually happens is both X and Y now are the array that contains one inside of them now the reason for that is when I'm storing an array or any mutable object I'm actually storing what's known as a reference to that object so when I act on the variable I'm acting on the reference which then modifies the underlying array which can be pointed to by multiple different variables so here x is essentially this x goes to a reference which goes to this array and then when I say Y is equal to x what I do is I copy the reference to that same array so now if I change X that affects y because I'm changing what the reference points to Y was not storing a copy of X it was storing a reference to X meaning any change to X affects Y and any change to Y affects X because they are pointing to the same underlying object so this can be better Illustrated with the example I have on my screen you can see I have a person object with a name age and address now I create a new object using the original person object so I say updated person is equal to person then what I do is I change the name of my updated person to be Jane Doe and I change the address dot City to be equal to Los Angeles so now if I open up my terminal and run my code notice again I'm printing the person and the updated person that I actually get the exact same object in the exact same data so again keep in mind I said updated person is equal to this person an object you might assume that makes a copy of the person object but it doesn't it makes a reference to the original object so now when I do things like update the name or update the city of the address what that does is that actually affects the original object which is both of these variables so updated person and person are both pointing to the same object hence why when I make a change to one it affects the other so how you can avoid this well you can make a deep copy of the actual object now first of all I just want to show you that if I do something like dot dot dot person using the spread operator what this will do is copy all of the properties of my original person so now if I run this we're going to get a slightly different result where you can see that I get a different name so I have John Doe which was the original name and then I have Jane Doe however notice that the city in my person is still changed to Los Angeles so again just have a look here we update the name and we update the city of the address so in this case I retained my original name in the person object but the city still changed in the address now the reason for that is when I do this copy operation this is what's known as a shallow copy it's copying all of the properties however since one of the properties is an object it's essentially copying the reference to the object associated with that property now that means when I change something on that object that wasn't deeply copied it was just shallow copied it's going to affect the underlying object which is nested inside of the person object I know that seems a little bit confusing feel free to pause the video and kind of read through this but you need to understand what happens when you're working with these mutable types so to fix this we'll have a look at our solution here and you can see that what we're actually doing now is we're using a form of a deep copy now there's better ways to do a deep copy in JavaScript won't get into that right now essentially the way we deep copy everything that exists inside of this person including the nested object sorry is we say json.parse and then json.stringify the person so we convert the person object into a string which is an immutable type and then we parse that string as an object and that gives us a brand new object which is a deep copy an actual copy not just an alias or a reference to this object so now if I come here and I run my solution so let's do that you can see that our address does not change in the original object all right the next mistake that many JavaScript developers make is not understanding the difference between the context of the this keyword inside of Arrow functions and regular functions let's have a look at this example so you can see what I mean so first of all when we Define a function this is different than defining an error function a lot of people just use them synonymously and they think that an arrow function works the exact same as a regular function now in a lot of scenarios it does but if you start using this keyword so the one that's in Orange here it works differently so if we have a look at this example we have a function this is kind of a factory for a car object here and what we do is we return a make model and year for the car and then we have two functions one that's regular function and one that's an arrow function associated with these properties now they do the exact same thing just one is a regular function one's an arrow function now if you look at all of the comments here you can see that when we use the regular function we get the output we expected right we get the make of the car the model of the car and the year of the car and that's because when we use a regular function this is bound to whatever called the function so when I call the function using my car this references the car that I called it on which has the make modeling year on it however when we use an arrow function this is actually going to inherit whatever the current this context is where it was defined I'm going to show you an example of that in one second but what that means is that since this was defined inside of this function it's going to inherit this context from this function now this context of this function is currently the global scope which means it's going to reference Global I know this seems a little bit strange but essentially we're inheriting this context whereas here the context is different based on what invoked or called the function so just to prove to you that I'm not making this up let's change into directory 4 and let's go node and then mistake.js and you can see that we get what we expected and then when we use the arrow function we get undefined values so now let's have a look at the solution and you'll see what I mean with the arrow functions so when we have a look at our Arrow function now you can see that what this is actually going to do is inherit this context from where it was defined so go ahead pause the video if you want to understand this more but we have an object inside of the object we have a name property and then we have a property that is a regular function then inside of that function we Define another function so now the arrow function inside of this function inherits this from the function it's defined inside of so now when I call say hello from my object this Arrow functions this is going to be whatever this is from the function it was defined inside of very hard to explain because this is a word that I used to explain and it's also the actual word that I'm talking about but hopefully this makes a bit of sense so if I run this now and I say node and then solution.js it says hello from John and then the arrow function says hello from John as well again that's because the context of this keyword in the arrow function inherits from wherever it's defined in this case it's defined inside of a function that is going to have this context be equal to whatever object called it so when I reference this Dot name here it's referencing the object that called it which has the name John so moving on to our last mistake and this is mishandling asynchronous code so let's have a look at this example here we have a fetch data function now this function is essentially mimicking the result of an API call so let's say use the fetch function and you're attempting to get some data from an API that's what this is attempting to mimic okay so what we're doing is we're returning a new promise the promise has a resolve and a reject function and the promise is just to set timeout that waits for one second before it calls this resolve callback function don't worry too much about this if you don't understand how it works essentially what we're doing is we are triggering the dot then if you're familiar with that in JavaScript after one second so what I'm doing here now incorrectly is I'm saying okay I want to get the data from this function I want to retrieve this from my API so I say data it's equal to fetch data and then I print out data and then whatever the result of data is now the mistake here is that I didn't wait for this data to be returned so what happened is I get the result promise pending let me show this to you if we go into directory five and then we say node mistake.js you can see that I get promise pending the reason I'm getting that is I essentially immediately print whatever the result of data is before I wait for this promise to resolve so at that point it's just a promise that is pending data so how am I going to fix this well if I go to my solution here you can see that now we have two ways to actually handle this correctly the first way is to use the dot then and the dot catch and the second way is to use async and await so let's start with DOT then and Dot catch now what we can do is on a promise we can use this dot then function What DOT then we'll do is trigger as soon as the promise resolves so as soon as this resolve function is called internally from the promise a lot of times you don't actually see that as happening behind the scenes then this will be triggered and then you can actually go ahead and print the data this is essentially saying hey wait for the problems to resolve once it resolves run this function and then execute this code perfectly fine then we have our catch and the catch is going to run when the promise resolves to an error so when the promise rejects really and that's pretty much when it runs right so if an error occurs then you go into dot catch if an error doesn't occur and the promise resolves correctly you're going into dot then now one thing to note here is that when you do this you're not going to have blocking code what that means is that if I go down here and I say something like const num is equal to one this line is going to execute immediately it's not going to wait for this promise to resolve so that's kind of nice because what you can do is say Okay I want to do this kind of stuff once this promise resolves but I don't want to block my code I want to continue going down from there so that's what happens we continue executing the rest of the code in the function and then as soon as the promise resolves we'll actually print out whatever the result is here okay so that's way one using dot then and Dot catch way two is to use async and wait so inside of here I have a try catch block now I'm using a try catch block because there could be an error that occurs that I actually want to handle with my promise anyways what I do is I say const data is equal to a weight now when I say a weight this is a blocking keyword and what this means is I'm going to wait for the promise to resolve that's exactly what happens here now the reason why I needed to put an async here before my function is because to be able to use the await keyword I need to be inside of an asynchronous function so if I put async then I have the ability to use the await keyword now here when I say constant.log data with async await I'm only going to print this line once the promise resolves because I'm essentially waiting just kind of stalling right here on this line line 26 until I get that data then I print it out now that's different than if we go back here where I said const data is equal to fetch data at this point I'm not waiting I'm just saying okay trigger the promise and then we go immediately to the next line whereas if we go back here we're waiting for it to resolve then we're printing out the now it's important here that we have this try catch because again there could be a error that happens inside of our promise if that's the case then we want to handle that and since we're not using the dot catch like we are over here we need to kind of do that manually with our try catch block okay so with that said that's going to wrap up this video These are the common mistakes that JavaScript developers make hopefully you found this helpful and I showed you how you can avoid making these mistakes in the future if you did make sure to leave a like subscribe the channel and I will see you in the next one foreign