hey guys and welcome back to another YouTube video so in today's video I'm gonna be showing you a path finding algorithm and this algorithm is called breaths first search algorithm now I don't know if I said that correctly or not so feel free to correct me in the comments if I'm butchering the name but essentially what this is is it's a cue based algorithm it's very simple that allows us to find the shortest possible path from one point to another point in a maze that looks something like this now you can use this to do tons of different things path finding is just one of the nice applications and visual applications that we can show you with it but essentially what it does and what this algorithm can do for us is generate a list of every single possible move or subset of a problem that we can do and we can try all of those different things until eventually we reach result that's favorable or that we want so in this case we're gonna generate for example in a maze like this we're gonna generate every single possible valid move that you could make in this move so every single possible path you could have we're gonna try that path and we're gonna see that if it goes from the start point to the end point and the way we're gonna determine if it's the shortest path is how I'm gonna top what I'm going to talk about throughout this video so let's start with a demonstration and then I want to move into talking about a queue so we're gonna explain that and then we'll talk about the breaths first search algorithm how that works and then we'll get into implementing it so I already have this obviously coded and I'll show you that when I run this program you can see that it generates the shortest path for this maze so this is the start point and this is the end point and you can see these plus signs represent actually the only path that leads us to this end node ok now if I have another may so I've maced two so let's run this and just do a comparison here so amazed to change that and you can see that again we get the shortest path from there to the end point here and obviously I can mess around at this endpoint if I want to show you and prove to you that I did not just actually hard code this what I can do is put X here put a pound sign where's this like that and there we go you get did I make mistake here let's run this one more time oh I'm messing up the wrong maze my bad okay I thought I really made a horrible mistake there okay so I was changing the wrong maze anyways change the end coordinate to be here now we'll run that and you can see now that again it's finding us the shortest path which will be this to get to the end node and I'm gonna talk about exactly how this works and how we can kind of implement this okay so let's go to the drawing board now and talk about our first problem where our first kind of thing which is a queue so what is a queue you might have heard of queue before maybe in pool maybe and just like a list kind of data structure but essentially just a data structure that has a few different properties associated with it so the queue that we're going to talk about is called FIFO now you might have seen this before and you might have been like whoa what the heck does this mean it's actually super straightforward it stands for first in first out and that obviously means to the first element to go into the queue has priority of coming out of the queue first it's a very basic and standard data structure if you guys are in computer science or are taking a course you'll probably learn about it at some point hopefully at least in firstyear University so first in first out okay that's the queue that we're gonna be using so to give you a quick demonstration of what I mean by that let's create a queue and let's add some elements so this is going to be my queue it's hard to like keep redrawing the queues but anyways you get what I mean so this is gonna be my queue data structure and what I want to do is I want to add the elements one four and five to my queue so the first element I'm gonna add is gonna be one okay so one comes into my queue and it's actually gonna start let's start it here at the end okay so we can get rid of this line so put one here so this is the first element in our queue and we could put a little one above it just to represent that it is the first one okay now the next element I want to add into my queue is four so what we're gonna do is we're gonna push for to the end of the queue so four will go here and what that means is I go to my eraser tool here our one gets pushed over here to the beginning of the queue now so one is here your 4 is here this is the first element added and this is the second element added so now at this point in time if I wanted to remove an element from the queue which one would be removed well we don't really have a choice it would be one and that is because it has the highest priority and it was the first element added to the queue so if I wanted to remove an element what I would do is I would remove one so we can simply erase one like this okay that would mean a four would shift in like the first position in the queue okay so it moves over and then if we wanted to remove another element from the queue well the only element left in the queue is for so we'd take four and we'd move it over to the queue and we'd remove that okay so let's say now we have four in the queue one has been removed we've already added and removed it we want to add five well we can add five in here like that now this is the first element of the queue this is the second element the queue so if we want to remove an element we remove four it comes out like that and then five would be shipped over and be the first element in the queue I hope that makes sense it's pretty straightforward you as I understand as we go through some examples so how can we use this queue to generate like a subset of every single possible solution so let's do a really basic example with binary numbers so by neri my horrible writing skills okay so binary numbers you can either have a 0 or a 1 right so say we want to generate all the binary numbers up to let's say 15 okay how can we do that using a queue well what we want to do I'll just put this in here in brackets 15 is we're gonna start by let's say set up a queue so we're gonna say Q equals 2 and this will just be like a blank queue for right now okay what we're gonna do is we're gonna add two things into the queue we're gonna start actually with nothing and we're gonna go through a while loop or a for loop in this case we're gonna say for blank because it doesn't actually matter what this value is in range okay and we'll do 15 because we want to generate 15 numbers what we're gonna do is we're gonna start so this actually in the start would just blank in it okay just nothing we're gonna start by D queuing and what D queuing means is it means removing something from the queue so you might hear this says DQ means remove from the queue then there's something called on queue which means add to the queue and on queue adds to the end of the Q DQ removes from the front of the queue first in first at right okay so if we're doing for D queuing we're gonna say like X alright equals Q dot get now get is just getting be like the first element in the queue from us okay so x equals Q dot get so X in this case is going to be equal to a blank string and now what we're going to do is we're going to add two elements into the queue so we're going to start by adding will say y equals and we're gonna do X plus and then in this case 0 okay because we're doing the binary number 0 and then we're gonna do Z equals x plus one so now what we've done is we what we've removed this blank string from the queue so our queue now looks like this okay and then what we've done is we've added two elements into the queue so the first element we added was 0 because blank plus 0 is 0 and then we added 1 so now we have 0 and we have 1 ok so imagine this both of these I don't have enough room just say add to queue ok we're just gonna say that we added those alright ok so we do that and this is our for loop and this is what we're gonna do to generate the subset so now let's look at the next loop of our for loop okay so our queue is 01 I'm just gonna leave this undid so I can are undone or whatever so I can add things so now what happens when we get something from the queue what do we get we get 0 right because well we 0 is the first element so we're gonna grab that and now we're gonna add another thing to the queue so does yours remove 0 is gone so let's erase this erase 0 okay and now what do we have X is 0 so that means Y is gonna be equal to 0 0 right and what is Zed well Z is 0 1 ok so there we go now we have 1 0 0 0 1 ok so let's do the next thing let's try the next one okay so now we're gonna queue again we're going to start and what is our first element the queue that's 1 so we're gonna remove one from the queue so let's do one ok we'll move these brackets over just to save us a bit of room here ok so we have 1 so X is equal to 1 and then we do what y equals x plus 0 so that means now we're gonna get 1 0 in our queue and then what's the next thing we're gonna get we're going to get X plus 1 which stands for 1 1 so now you can see we have 0 0 0 1 1 0 1 1 in our queue and obviously we can keep repeating this process and if I do it one more time essentially what's going to happen is we're gonna remove 0 0 so that gets will get rid of 0 0 ok and then the next thing that we're gonna add into her Q is 0 0 0 so 0 0 0 and then we're gonna add 0 0 1 ok we're gonna add those to the end and we're gonna grab 0 1 and then we're gonna go 0 1 0 and we're gonna go 0 1 1 I'm going to keep on keep on keep on generating these until eventually we hit the binary number 15 or until this loop has ran 15 times okay and I hope that makes sense in terms of how to generate that so see how much time we're at nine minutes yeah that's not bad so that is how we can generate a subset of every single binary number so how do we now apply this into pathfinding well it's a very similar approach so in binary numbers we had two things we had 0 & 1 with our path we have 4 things we have up right down left and right so what do we do now if we want to add these 4 things to our queue well it's the exact same process we're gonna start with a queue and all the queue is gonna happen it is a blank string ok nothing now all we're gonna do is we're just gonna loop so let's just say loop we'll write some pseudocode here and all we're gonna do is we're gonna DQ the first element so we're gonna say X is equal to Q dot get so we're getting that first element which is going to be a blank string and then what we're gonna do is instead of just adding two things we're gonna add four things so we're gonna say X plus equals or no what am I saying X plus equals will say like add one so the first thing to add to the queue will be equal to X plus and in this case U and then the next one so add two will be equal to X plus and we'll do D like that and we'll go and we'll do L and we'll do our as well and we'll add those and we'll continue through the process and it will generate every single possible like solution to UDL are on that we could have and we'll I'll show you how like we'll print it out and we'll be able to look at all of them in a second okay but that's how we do it for path finding now the only thing with path finding is we could have invalid paths so let's actually clear this so for example if we draw a 3 by 3 grid so if we do something like this okay so 3 by 3 quick little grid here and we say like this is an obstacle our start point is here in our end point is here we want to get from the start to the end well the way we do this is again we're gonna generate all the possible moves so the first move we would have well the only valid moves we can do is we can go this way when go left or we can go down right because if we try to go backwards sorry right and we try to go up those are not valid moves so we're not gonna add them to the queue and I'll show you how we implement that in Python but essentially just only add valid moves to the queue so that when we're checking if we've reached this destination and we're only checking valid moves there's no point in checking moves outside of the range right okay so we have two possible moves so our moves right now in our queue are gonna be equal to what left and down okay so now we repeat the process we'll dql so let's dql and we'll look at now we're looking at this move okay so now I was removed from the queue so if we go where's my eraser and we removed el and let's open up this queue again okay so we removed el now we're at el what's the only valid boost we can do well we can go right or we can go left okay so the two moves will add from that our now we're gonna have left left we're gonna have left right and those are the two moves now down let's look at what down is okay so now we're down so we'll DQ that so we'll say down what are the moves we can possibly do well we can't go right okay we could can we can go up we cannot go left and we can go down so the two moves we can do our here and here so let's just undo all those arrows quickly so what we're gonna do then obviously is we'll add will say one of the moves is down down another move is down up okay now D is removed and let's just pretend this keeps going quickly on to over here I chose the wrong pat object and that we can just continue repeating this process and eventually what's gonna happen is we're gonna get a move that's either equal to what do you call it left left down down down or we're gonna get a move that's equal to down down left left left now each of these are only five moves so either path is perfectly valid to go and that's how we're gonna generate the path to find our point now I hope that makes sense that's probably like the longest but easiest way I can explain this to you and how that works but essentially we're gonna generate every single possible path we're gonna check before we add something into the queue if it's a valid path for example going here so going down and going left is not valid so we won't bother adding it to the you and then what we're gonna do is every time we generate a new path we're gonna check if that path reaches the end and if it does we can simply stop because we know we found the shortest path now how do we know we found the shortest path well every time we DQ and we add things to the queue we're adding one step to the path so if we just found a path we would have generated every single possible path that takes five steps and we found one that reached the end we know that we're at the shortest path because we would have found a path earlier if there was a shorter one and I hope that makes sense in terms of how that works okay so that's enough for the drawing so let's do a quick talk about this implementation here all the source code is gonna be up on my website tech with Tim done that if you guys want to use this sorry I'm just putting away my drawing table here so I can get my keyboard ready to go but essentially uh most of this code is just the cosmetic stuff like creating the maze printing the maze outright valid checking if it's a valid position finding the ED so let's just go to the algorithm and this is the part that I was explaining to you I'm not gonna talk about all these but essentially we create a queue now Python already has an implementation for a queue if you simply import queue then you can use that and we can put things into the queue by doing dot put alright so I start by putting a blank string like I was talking about before okay and then I'm just setting this variable add equal to blank and I just is gonna represent like the first path that we have okay I'm gonna create a maze because the maze is gonna be what I want to traverse through and see if I've reached the end or not and well Wow I have not found the end of the maze so while find end is not true what I mean I give it maze and I give it add and add as represents the path that we just recently used okay I could probably call that path it would make more sense but that's what ad represents essentially while we have not found the end we're gonna continue doing the process that I'm going to talk about here so we're gonna DQ we're gonna get the first element from the queue in this case we're gonna numbs dog get and nums just represents all of the different things in our queue okay because I did nums equals QQ all right we're going to say 4j left/right up/down now all this is doing essentially is we're first gonna start by creating a new thing to put into the queue the first thing we're gonna do is we're gonna get the last element that we DQ'd we're gonna add first of all left to it then we're add right to it then we're gonna up to it then we're gonna add down to it that's how the forloop works and before we actually add it to the queue we're gonna make sure it's a valid path so we say if this path so what we've just generated is valid in the given maze then we'll add it to the queue otherwise just go to the next one don't bother adding it because why would I add a path that's not valid we can't take that path so there's no point using it and we're going to loop through this until eventually we find the end in which case this loop will break and then our path will be equal to what do you call it whatever path like whatever the last path and the queue is so for example like if you you had a list a length of 67 the 67th path would be the one that would lead you to the end position and that's because we stopped at that point so the last element is obviously gonna be the path so I'll demonstrate again for you one more time and you can kind of see right maybe this makes more sense on how its works now so we started by generating this position because it was the only valid position right and then this position generated either right or left and then this one generated left or down and right and it just keeps going and generating every single possible position until eventually we hit here so like every single possible movement almost was generated here but once we eventually hit here we just stopped and we said this is the path down left down down right down down and you can see how that works on the maze okay so anyways that is Brett's first search algorithm explained extremely indepth if you guys have any questions about that please don't hesitate to ask me if you guys want to mess around with this example make your own mazes please head to my website go ahead and download it use it on it's completely for free I want you guys to learn and experiment with this and I think it's pretty cool how this actually works and as always if you guys are new here please make sure you leave a like and subscribe to the channel I will see you again in another video