hello everybody and welcome to part two of this video series in this part i'm going to be explaining to you the theory behind blockchain technology so specifically going through some key terms like private keys public keys cryptographic hash functions what those are how those work i will talk about transactions how a transaction is created and signed and secured i will talk to you about blocks how blocks are connected together i will then start talking about proof of work which involves minors and securing the blockchain and while all of this is very very interesting and i try my best to break it down as simply as possible for you in this video so in a second we're going to hop over to the drawing tablet i'm just going to start doing some diagramming and explaining and i encourage you to sit back relax and enjoy the explanation however before we do that i quickly need to thank the sponsor of this video and this series which is cartesi now cartesia is a company that is dedicated to making the blockchain more accessible and affordable and when i say affordable the reason that's important is because as you're going to see as we go through the rest of these videos here deploying smart contracts is very very expensive now cartesi offers a bunch of solutions that can actually cut this cost by a factor of almost 100 and really just make it much easier to work on the blockchain anyways we'll hear more from them later on and we'll actually start using some cartesi technology hopefully in a future series but regardless they're an awesome company they've been helping me come up with the content for this video and i'm just super grateful and happy to be working with them regardless let's dive into the video all right so i'm now on the blackboard ignore the black screen there will be some drawing in one second but for now i'm gonna start by explaining to you some key terminology related to cryptocurrency specifically private key public key and address so let's actually start by looking at what's known as a cryptographic hash function because it's very important to understand this concept so we have a function let's say f x and this is equal to y this means you take some input x you get some output y pretty standard now with most regular functions you can compute what's known as the inverse now the inverse of f is known as f inverse and then you would take y and this will give you x so the idea here is that given some output and given the function that computed that output tell me what the input to that function would need to be to get that output so the inverse is like this you take the output you pass that to the inverse function and it gives you the input required to pass to the original function to get that output so let's just look at one concrete example let's say we have something like y is equal to x plus 2. well if 2 is my input then y is 4. now compute the inverse of this function the inverse of this function you simply compute by isolating x so you would just say y minus 2 is equal to x that's the inverse and so if i give you the value 4 you can tell me 2 was used to compute that great so now that we understand what the inverse is the first property of a cryptographic hash function is that it has no inverse so we're going to call this now the hash function so let's do hash func this is going to be our input and this is going to be our hash otherwise known as a digest okay you don't really need to know that but hash is what i'm probably going to be referring to this as as we go through this video so the first factor or the first property of a cryptographic hash function is that it has no inverse now what that really means is that given y you cannot find x so if you're given the function and the output of the function there's no way to figure out what the input is that's very very important so to clarify here when i say we can't find the inverse of a cryptographic hash that's not necessarily true now it's important to note that here i'm not talking about the cryptographic hash function i'm talking about the actual hash itself that was the output of this function so currently there is no efficient way or formula that we know that we can use to take an individual hash and determine its inverse however it may be possible to invert a hash using a brute force approach where you would blindly guess and try several different values until you determine what the original input value was that generated this hash now this brute force approach would take billions of years to perform and that's why we say a cryptographic hash has no inverse because it would take an extremely long and unfeasible amount of time to compute it so yes theoretically it may be possible to compute the inverse of an individual hash but it would take such a long time that we just simplify things by saying it has no inverse so moving on the next property of a cryptographic hash function is that it is deterministic that means that any input x1 always leads to one output y1 so second property deterministic again meaning that one input always points to the exact same output next property is that every output is unique so if i pass x1 i get y1 nothing else points to y1 so if i have x2 it's not possible for me to get the same y1 as soon as i have something like x2 and they both point to the same output this is no longer a cryptographic hash function so again i need to add a small clarification here theoretically it is possible to have two inputs mapped to the same output using a hash function now when that happens this is known as a collision now the thing with cryptographic hash functions is that for that to happen for you to find a collision just like finding the inverse that would take you say billions of years a very very long time to do so we can kind of operate on the assumption that there will be no collisions but theoretically if we're talking about the exact definition there could be so i'm going to kind of be speaking in this video in definitives just understand there is some nuance behind those but it's just much easier to operate under these assumptions and well hopefully that makes sense okay so those are the first three properties of this function the next is that the hash that you get is uncorrelated to the input so what this means is that if i have something like f of 1 1 maybe this gives me a hash of a b c 2 3. now you might be trying to guess here that if i had a hash of 1 2 then it would give me something similar to this maybe you would think we get a b c 2 4 or something along those lines because you would imagine that the output here is correlated to the input but with a cryptographic hash function this is not the case if i were to pass 1 2 so just one number is different i get a completely different hash so i might get something like d f a two nine four or seven or whatever you know what i mean we just get a completely different hash there's no way to reasonably guess what the hash is going to be by looking at the input all right so that is great the very last property is that this is quick to compute so computing the hash of some input is very very fast those are the five properties of a cryptographic hash function okay so moving forward we're now going to talk about private keys public keys and addresses so let's start with our private key now the private key i like to think of as the master password for our ethereum account so the private key is actually what allows us to access our account and to send money so if you have access to a private key you have access to an ethereum account and while you can send money on that account that means you need to keep this private you do not want to share this with anyone and in fact we don't even look at what our private key is when we use metamask it's generated for us and stored in an encrypted fashion in kind of the back end of metamask so that no one can actually see it now when i say encrypted this is actually one of the reasons why we need to pass a password when we created our meta mask account so what happens in metamask is it will generate a private key for us but it won't store it in plain text so if the private key was one two three it will never store one two three instead it will store what's known as an encryption or an encrypted version of this private key and it will encrypt it using our password so we have some special function that's going to take in our private key and our password and then it will give us some output okay and then the only way to go from this output back to what this private key is is to know what the password is okay so we need to use the password every time we sign in so that we can decrypt our private key so that we can then use the private key to actually send transactions okay that is the private key and what the private key actually is is just a string of characters that's really all it is it's extremely long and again you usually are not going to be looking at this yourself it's going to be stored in some secure way so next from our private key we generate what's known as a public key now the public key is generated from the private key so you need the private key to get to the public key and we use a cryptographic hash function to generate this which means if you know the public key there is no way to go back to the private key you cannot do that because the way we generated it was using a cryptographic hash function that's very important because someone could theoretically figure out your public key if they do figure out what that is that doesn't matter there's no way for them to go to the private key hence why this is private and this is public the public one can be shared anywhere okay moving forward the next thing we have is our address now the address is generated from the public key so a private key and a public key actually make up an ethereum account and then the address is what you're going to actually send money to now what the address is is actually a few characters when i say a few it's something like 20 characters of the hash of this public key that's pretty much all i will say it's kind of just a simplified version of the public key and the way you get the address is you generate it from the public key so you go private key public key address and from the public key again you can knock it back to the private key from the address you cannot get back to the private key and that's very important because as soon as you have the private key you have access to the ethereum account so you give the address to whoever you want to send money to you and that is how you will reference your account on the ethereum network by this address great so the whole point of the address as i was saying is it's just a simplified version of the public key so it's a little bit easier to be using on the blockchain rather than writing the public key everywhere so now that we understand private key public key and address we need to talk about transactions and then how the blockchain actually handles transactions so let's say we have the example where we have maybe account one in account two and account one wants to send some ethereum maybe 0.1 f to a count two how do we do this well to do this we need a transaction now anyone can create transactions on the blockchain anyone can do it and what's involved in a transaction is an amount so this is going to be 0.1 f we're going to have a 2 wallet so what address we're going to so we're going to be going to account two and then from this is going to be account one now the only problem right now with this transaction is that we kind of have to trust that who's making this transaction is the person who's sending the money right the from address but theoretically account two could make this transaction and say oh yeah account one is sending me all of its ethereum anyone could just make a transaction you could add as many as you want and you could just throw them on the blockchain and while if there was no security then you would just have random people adding transactions all of the time that is why we have something known as a digital signature so a digital signature is a very special hash that involves the actual private key of the account trying to send the money so of the from account as well as all the information associated with the transaction now i won't talk too much about the signature because it's pretty mathematically complicated but to be able to actually create a transaction that is valid what you need is the private key of the account you're trying to send ethereum from so this signature here again as i was saying is going to require the private key as well as the transaction itself so the transaction i'm just going to represent by tx and then there's actually another part of this as well and anyways you hash all of this it gives you some you know random string of characters and this string of characters you can verify is a correct signature for this transaction now the way that you actually verify this signature is simply by using the public key of the account that's sending this ethereum so if we see a transaction that's coming from account number one we don't need to know account number one's private key to determine that the signature is valid we can just use their public key and a special kind of mathematical computation to determine that this signature is valid and that it was actually signed by the account that's sending the ethereum because again you can only send this ethereum if you have access to the private key of the account that's supposed to be sending the ethereum so just know for now that you can verify a signature very easily without knowing the private key of the account you just use a certain aspect of the public key i'm not going to go into too much more detail but that is how you verify a signature so anyways that is how you actually secure a transaction you digitally sign it using your private key and a few other things we don't have to manually do that ourself it's done by metamask when we actually send a transaction okay so let's remove all this and now let's see how we actually associate a transaction with a block and how we actually you know use the blockchain and put a transaction on the blockchain because right now we made this transaction that's fine but we need to send it on the blockchain we need to attach it to a block before it's actually going to go through before our money gets sent to the other person so let's look at what a blockchain is let's say we have one block like this another block like this and a third block like this now all of these blocks are connected together in a chain now they would be of equal size i've obviously drawn mine a little wonky here but all of these blocks contain some information on them as well as all of the transactions and smart contracts that were added to them at the current point in time so what this blockchain actually does is it represents a digital ledger of the entire history of the ethereum network when we're talking about ethereum here right so every single transaction is a transaction that has taken place and we know the order in which they took place because they're ordered on the block and then all of these blocks are ordered and this is very similar to something like a ledger that you would have at a bank so a bank would keep track of every single transaction you had sent and everyone else had sent it would know all of that information well same thing here with the blockchain we just do it in a different way and one of the key properties of the blockchain is that it is decentralized this means it is not controlled by a bank is not controlled by a single person it is controlled by a network of computers that are owned privately by random people around the internet and the reason why this is important is because as soon as something is owned centrally so by one person or one organization or one entity they have the ability and the power to do something with it that is corrupt or that is malicious or that anyone else just doesn't have the ability to do or that they shouldn't maybe have the ability to for example if you own a bank account the likelihood this is going to happen is very slim but theoretically the government could just force the bank to hand over all of your funds maybe you need to pay your taxes or something whatever the idea is there's a central organization that controls this and so at any point in time this central authority could go in and actually modify what's on the ledger they could change the account balance they could take money from you but here when we're talking about a blockchain that is actually not possible because this is not owned by one person or one entity it is used and controlled by all of the computers around the world that contribute to the network and we'll talk about what those are in a second but to be able to do anything malicious on the blockchain you would have to control almost all of the computers around the world that are storing a copy of the blockchain and that are on the blockchain network okay hopefully this makes a tiny bit of sense but let's have a look at one individual block kind of see how that works in the context of transactions and then we'll talk about proof of work and a bunch of other very important aspects of the security of the blockchain so let's say we have a single block okay we can just call this something like block number two okay now the reason why i'm naming it number two and not number one is because the first block in a blockchain is a special block contains some configuration and initialization related stuff because well it's the very first block so that's kind of a special one we're going to ignore block one for now and just move straight to block two now block two is going to contain some transactions on it the transactions i'm going to represent by these squiggly lines now these transactions are exactly what i showed you before they have a to address a from address and a mount a signature and they have a few other things as well in fact every time you send a transaction you usually have to pay a very small fee and this fee will be given to the miners that are trying to secure and validate a block anyways this block has some transactions on it now this is where we get into the concept of miners so miners are computers that are sitting around the world that are supporting the ethereum network they're actually what allow it to run and they're what secure the blocks and make sure that you can't just hack the network okay so we'll dive into miners in a second i just want to take a quick step back here so whenever you're sending a transaction you need this transaction to be associated with a block and this block has to be mined which we'll discuss in a minute before your transaction actually goes through and is completely successful up until that point your transaction will be pending but once it's been added to a block and that block has been mined then it is successful now a new block is added to the ethereum network approximately every 15 seconds so very very quickly anyways now let's talk about mining so what are miners well as i discussed miners are just computers that are sitting around the world this is going to be my computer just a bunch of kind of deformed squares here right so there's a bunch of these guys sitting all around the world connected to the ethereum blockchain now every single time a new block is created and all the transactions are added it gets sent to every single miner so all these miners are kind of nodes on the network they're all sitting there waiting for transactions to get added to the current block when this happens what these miners do is try to mine the block now mining the block consists of performing some computations particularly some very difficult computations that are very time consuming and trying to guess a number that makes the hash of a block which we're going to get to in a minute have some specific properties now the point of doing this for these miners is that if they're able to guess a specific number they successfully mine the block and they will be given a reward so let's say minor one actually guesses what the number is i'll discuss what that number is in a second and they will be given some reward now this reward will be made up of two things the first thing it will be made up of is a block reward now a block reward is a reward that is hard coded into the ethereum network and actually decreases over time and this is new ethereum that will be created and given to the miner as a reward for mining this block i'm not sure what the current block reward is right now it's probably something like one ethereum but the point is that this is new ethereum that then gets added to the ecosystem and is circulating around so yes some cryptocurrencies and here specifically ethereum do have an inflationary aspect to them because new currency is being created but it's not something you really need to be worried about and while there's a whole field of cryptocurrency called tokenomics that kind of discusses this and why this is maybe actually a good thing i'm not really going to get into this in this video point being don't be too worried about the fact that new ethereum is being created so the second thing that you're going to have is going to be your fees now every time you send a transaction you're going to pay a very small fee this fee goes to the miners that are mining the block and so the successful miner the miner that actually guesses the number that mines the block is going to get the block reward and any fees associated with all the transactions on the block okay hopefully that makes sense i'm just trying to explain the incentive structure here for people to actually mine so continuing now we need to talk about what the miners are actually doing what the miners are doing are trying to guess a number that gets added at the end of the block so i'm going to say num equals question mark that makes the hash of this block equal to a certain number so what they're trying to do here is they are trying to find some number that they can add as kind of a dummy transaction at the very end of the block so that when i take a hash of this entire block so i run this to a cryptographic hash function the hash that i get starts with a certain number of zeros i believe right now what they're trying to find is a number that starts with 30 zeros but it could be actually higher or lower i'm not sure what the exact number is the point is that what these miners are going to be doing is trying to guess some number right this is a random number that you add at the end of the block and then when you hash the entire block so all of the transactions associated with the block and the number together it gives you some hash some digest right that has 30 numbers at the beginning or 30 zeros at the beginning sorry and then the rest of it doesn't really matter what that is but you're just trying to find something that has a certain number of leading zeros so the point of this is that the more zeros that you have in that number you're trying to guess the harder it is to guess that number because the probability just decreases that you're going to guess the correct number right here and again i'm just really trying to reiterate here that what's going to happen is you're going to take a hash of all of this everything inside of the block including this number and then you want it to give you some number that starts with 30 zeros but the thing is there's no way to figure out what this number is other than just guessing and checking because the cryptographic hash function has that property that there's no known inverse so since we can't compute the inverse we have no better way of finding out what this number is other than guessing and checking and so these miners are just guessing and checking as quickly as they possibly can and the one that gets the correct number then adds that to the block that mines the block and then we create a new block and continue moving forward now this is an oversimplification but that's the general idea of what these miners are doing okay so hopefully that kind of makes sense but that is what these miners are attempting to do and you might be wondering well there's so many miners so is it only actually one miner that's guessing this number and the answer is yes at every single block you're only having one minor that is going to guess what the correct number is and get the reward that's why you'll have pool mining which means you'll have like hundreds of thousands of computers that will split their processing power they'll say okay we're all going to try to guess a number together and if any of us get the number we're going to split the rewards between everyone because the probability that one of us can guess the number consistently is very very low in fact if you only had one computer mining and it was not mining very quickly your probability of ever getting a block reward would be almost zero because there's just so many other computers doing it and you would have to get extremely extremely lucky so that's why you would mine with a bunch of other people so that your probability of getting a reward is much higher and then you would split that based on how much work all of you have done okay so let's continue here now what i want to do is draw a few blocks and we'll see how these are connected and kind of the security aspect of this so let's just paste this block over here and for now we can just go with two blocks okay so we have block two and then this guy is going to have to be block three let's fix your corner right there okay so we have block two and we have block three now this will be coming from block one we don't need to worry about that right now now the thing is these blocks are connected together right so we have block three we have block two block three is connected to block two and obviously it comes after block two now how do we know that well obviously these arrows aren't actually there we don't really have arrows connecting these things but what we do have is a field in every single block that represents the hash of the last block so we have something like last is equal to and then whatever the hash of this block is including the number that we guessed that is what we put right here to represent this is the last block in the chain so let's say when we hash all of this we get a number that is 0 0 0 0 4 9 a b now this will usually be a hexadecimal number that is 64 characters long but for simplicity we'll just go with this for now so to get this hash we would also have guessed this number let's just say it's seven and what we were trying to do was to get a hash that started with four zeros which we've done so next what we'll do is we'll write this hash here so zero zero zero zero four nine a b so now in block three we know the previous block was block two and block two would also have this field it would say last is equal to the hash of whatever block one is so now block three we get a bunch of transactions on here we add them all on and we say okay we want to mine block three so what we need to do now when we mine block three is we have to find some number such that when we hash all of this including this last field right that's gonna be included in the block where we're hashing we get a number that starts with four zeros so what this really means here is that if the hash of block two ever changes for some reason then this is no longer going to be correct because this is going to be referencing block two which now no longer exists and so this will be disconnected from the blockchain you can kind of imagine that this arrow would get erased now i'll continue explaining this but again what we're doing is we're trying to mine block three so we'll guess some number let's say we guess some number nine and then we end up getting some hash here i guess i can just do it in maybe a purple color 0 0 0 and then maybe this is 7 9 ba okay this is the hash that we end up getting so now where the real security feature of the block chain comes in is that let's say i am a malicious entity here and i want to change one of the transactions on the blockchain so let's say i take my copy of the blockchain and i go to block 2 and i change the transaction instead i add this fraudulent transaction right here well as soon as i change this transaction this hash here changes right and the reason this is going to change is because when i take the hash of this block now since this transaction has changed i get something completely different and so what i'm probably going to end up getting here is something that doesn't start with four zeros so say maybe i get one zero two a b b c one that's my hash so now since this hash doesn't start with four zeros i need to recompute this number and remind this entire block because now the number seven is no longer correct to give me a hash that starts with four zeros so let's say i'm successful in doing that and i guess uh you know the number let's go 275 or something and now i get a hash like 0 0 0 0 1 2 3 4. okay that's my new hash well now the problem is this hash does not match this hash right here and so this block is disconnected from this block and so if i want to actually keep this fraudulent transaction in block 2 what i need to do now is modify block 3 because i have to change this last to match what my new last on block 2 is so what i do now is i come here and i would need to change this now to whatever this is so 0 0 0 0 1 2 3 4. but now that i've changed this the hash here is going to be completely different right because we're going to get a different value when we have something different inside of the block so now i get a hash maybe that doesn't start with zeros right 1 0 0 2 3 a b c whatever some random hash so now i need to recompute this block recompute this random number and remind it so that i now find a hash that starts with four zeros and you get the point i have to do that for every single block in the blockchain right because these blocks are connected together and as soon as these blocks are no longer connected i don't have a valid blockchain and if i try to send this on the ethereum network all of the other computers on the network are going to be like uh no that is not correct your blocks are not connected your hashes are all messed up and i have a different version than you have so no i'm not going to accept that as a transaction i'm not going to accept that as a block because that is fraudulent so hopefully this makes a bit of sense but this is a concept known of hashes of hashes or hashing of hashes and so what we're doing is we're taking a hash of this block putting it inside of here and then taking a hash of this block that contains the hash of the previous block and so any change to the previous block means that this will no longer be valid and so we have to change pretty well every single block in the blockchain to be able to modify everything and that is why this is so secure and that is what leads me to the concept of proof of work so what we're doing when we're mining is we are proving that we have spent a certain amount of time before adding this block to the blockchain and the reason that's important is because the more time we spend the harder it is to modify the blockchain if you had an absolute supercomputer and you could just remind these blocks instantly then you would be able to go and change the blockchain that would be fine you could do that because you could just regenerate every single block with all of your fraudulent transactions added however since that's pretty well impossible and we have so many computers working on the blockchain at the exact same time for you to be able to do that you would need more computing power than all of the other computers on the blockchain combined and you would need to be able to not only rewrite the entire blockchain previously to what it's currently at you would also need to be able to catch up to all of the other computers that are working on the new blocks being added to the chain and kind of beat them and you'd be like racing against them in a sense i'm sure this is very abstract but this is what makes the blockchain so secure that these blocks are actually linked together you need to perform this mining process which is proving you've done a certain amount of work this work takes some amount of time this amount of time you can calculate using probability the probability you're going to guess a random number and how quickly you can guess random numbers and all of that and as the blockchain continues to grow being able to potentially modify it becomes harder and harder and harder so anything that is added to the blockchain is pretty well permanent and you cannot remove it without having to rewrite the entire blockchain so this is all great but one other thing i will mention here is that another security feature that's built in is that every single computer that is mining the blockchain or mining the current block has a copy of the existing blockchain and so what that means is if you try to change something on say the current block every single other computer knows what the current block looks like and so if you're submitting a block that looks different from that it's going to be able to tell that very very quickly it can just take the hash of the block if it doesn't match the hash that it has it's going to be like no this is the incorrect block i'm not going to accept this block or accept this transaction because well it doesn't match what i currently have so hopefully this is all starting to come full circle just a little bit you don't have to understand this stuff super super well but you just have to have a general idea of why the blockchain is so secure this concept of decentralization and kind of how transactions get added to the blockchain and what mining actually means right and that's the reason why there's been a huge gpu crisis in the past and recently as well a bunch of people are mining cryptocurrency for the incentive of trying to earn these different rewards all right so that is all great and really what i just spent the last 10 or 15 minutes explaining is proof of work so pretty much everything starting from when i started talking about blocks was trying to explain to you how proof of work works and while that uses raw computing power typically gpus to perform hashing which then secures the blockchain in the ways that i mentioned however and i understand some of you may be a little frustrated here ethereum is actually switching over now to proof of stake i'm not sure exactly when that's going to happen but it's supposed to have happened for a long time and i know it's going to happen very very soon and the difference is that with proof of stake which is going to be kind of the new method and algorithm this is a type of consensus mechanism which is going to be used to validate the transactions versus using raw computing power now proof of stake pretty much means that if you own cryptocurrency you can stake your coins by staking them you're kind of putting them in a locked container that's the way you can think of it and what this does is give you the right as the staker of these coins to check new blocks of transactions and to add those to the blockchain now i'm not going to explain proof of stake in this video maybe we'll explain that in another video point being ethereum is slowly switching over or actually probably pretty quickly switching over to proof of stake and that's going to be the new method now i will just say that even though ethereum is switching over to proof of stake that does not mean that what i just explained to you was a waste of your time it is still very very valuable to understand how proof of work works and that is currently what is being used and is being used for a lot of other cryptocurrencies as well proof of stake is just another method of doing this and while i'm not going to explain that further in this video but maybe we'll talk about that in the future regardless with that said that pretty much wraps up everything that i needed to cover if you guys made it to the end of the video give yourself a pat on the back i hope that this maybe cleared up how the blockchain works and gave you at least a little bit of the insight into the theory behind it if i were to go through and explain all of the mathematics of this not only would i probably make a ton of mistakes but this video would probably be four or five hours long so really if you can grasp the core concepts here you have a good enough understanding to kind of proceed and to move forward and start writing smart contracts and to be quite honest with you you don't necessarily need to have all of this mastered to actually write a smart contract it's just very helpful and something that i think is fundamental before moving forward anyways with that said i will finally end the video here thank you guys again for watching if you enjoyed leave a like subscribe to the channel and i will see you in another one you