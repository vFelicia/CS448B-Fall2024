in this video I'll show you how to create the famous simulation known as Conway's Game of Life now this is a very interesting cellular simulation in which each cell you see on the screen has a few rules applied to it I'll go through those rules in one second but cells can either be recreated they can die or they can remain on the screen this is a very interesting project that I'll show you how to build in Python using pi game not overly complicated and you can finish this in under an hour or whatever the length of the video is all of the code for this will be available in the description in case you want to check it out without actually going through the tutorial anyways let's go through the rules of the game rule number one is that in a live cell so the yellow cells you see right here that have fewer than two live neighbors will die now that's due to underpopulation rule number two is a live cell with two or three live neighbors will remain alive this is known as survival rule 3 a live cell with more than three live neighbors dies and that's due to overpopulation or overcrowding rule 4 this is the last rule a dead cell with exactly three live neighbors becomes alive that's reproduction now with these rules you can see that we get these really interesting shapes and patterns and there's been all kinds of research and studies related to this game where you can create some really interesting objects the way I've set it up here is that you can actually add cells onto the screen you can delete them by clicking on them we have a few keystrokes that I've added here that will automatically generate some cells for us really interesting project I hope you stick around to build it with me with that said let's go ahead and get started after a quick word from our sponsor thanks to taipai for sponsoring this video If you're looking for an allinone solution for building and deploying web applications in Python typi has you covered taipi is an open source python library for building web applications you can make the front end back end and deploy web applications with ease forget learning Advanced CSS and JavaScript instead use Simple syntax to create multiple page dashboards and and front ends with only Python and augmented markdown at the same time Taipei is designed to build powerful and customizable datadriven backend applications it provides components to organize and manage data through pipelines and dataflow orchestration each pipeline execution is referred to as a scenario scenarios are stored recorded and actionable enabling whatif analysis or kpi comparison type is designed to rapidly reduce your development time and provide all the functionalities you need to build and deploy entire applications get started with taipi and their open source package from the link in the description alright so as we get into the video here I want to quickly go over the rules one more time in a graphical setting just so everyone understands exactly what we need to do to implement this so I just pulled up a website that has kind of a great explanation here that you can read through so pause the video if you want to have a look at it but you can see that each cell with one or a one or no neighbor sorry dies as by Solitude and then each cell with four more neighbors dies as as if by overpopulation each cell with two or three neighbors Will Survive and for a space that is empty or unpopulated if it has exactly three neighbors it will become populated so it shows you a few examples here with the visuals just wanted to kind of pop that up in case you guys want some more explanation anyways what we'll be doing is implementing this the first thing we'll need to do is Implement a grid system we'll then need to add a way to actually add in these different cells and kind of generate them randomly then we'll start adjusting the grid by applying these different rules we're really cool what ends up happening here let's go ahead and start building this alright so I've just cleared my python file and we're going to begin writing this code now the first thing we need to do is install pygame pygame is a 2d Graphics library that we'll be using for this simulation very straightforward you don't need to know anything about it I'll explain to you everything you need in this video so to install Pi game we're going to Simply type pip install and then Pi game here in our terminal if you're on Mac or Linux you're going to do pip 3 install Pi game if that doesn't work I will leave two videos on the screen that will show you how to install pie game that's really all the setup we need now we can start setting up our PI game window which will be responsible for the simulation so we're going to begin sorry at the top of our program by importing Pi game we are then going to say pygame dot init we're going to initialize the modules so we can use it we're going to start now by actually adding a few different colors so we're going to say black is equal to zero zero zero these are RGB color codes that we're going to use throughout the rest of the program so I'm going to Define all of the constants that we need at the top of the screen and then as we go through we'll kind of write the rest of the code next we are going to have gray now gray can be a bunch of different colors but I'm going to go with 128 128 128 again the amount of red green and blue that's what we're doing for the colors lastly we're going to have yellow now yellow is going to be 255 255 0 whenever you're writing RGB the maximum value is 255 the minimum value is zero okay so now we have the three colors that we can use next we're going to set up some dimensions for our grid and for our screen so I'm going to say with comma height is equal to and we're going to go with 800 800. now you can adjust this if you want but I recommend you make it even numbers that are divisible by the next variable here which is going to be our tile size now the tile size is the size of one individual tile in this case it will be 20 that means it's going to be 20 pixels by 20 pixels if you want to make it larger go ahead and do that again I just recommend you make it evenly divisible by the width and the height so it's a little bit easier or kind of looks better on the screen next we're going to Define our grid underscore width here now the grid width is going to be equal to the width integer divided by the tile size this is just the number of tiles that we'll have in our grid remember we're creating a grid but we have pixels on the screen so we need to kind of make the grid based on the pixels next we're going to have grid height grid height is going to be the height divided by the tile size lastly we're gonna have an FPS this FPS is going to be 60 meaning we have 60 frames per second if you wanted to increase this you can but another variable again that we need okay now that we have our constants we're going to define a screen now the screen is where we're going to do all of our python drawing or our PI game drawing so I'm going to say screen is equal to Pi game dot display dot set underscore mode and inside a tuple here I'm going to pass the width and the height that I want this screen to be so this is how you initialize a new Pi game window again you just pass the width and the height that you want inside of a tuple to this set mode that's going to actually pop up a screen for us and now what we need to do is create a clock and then implement the main Loop I'll explain this more in depth in a second but for now we're going to say clock is equal to Pi game dot time dot clock and now we're going to set up what's known as the main Loop now whenever we're working in pi game we have an event Loop or a main Loop this is something that's running constantly that's checking for things like button presses key key presses adjusting the grid for us for example so this is where a lot of the core logic will be called from will separate it out into different functions but we always have this main Loops that's what we need to write first so we can actually see something appearing on the screen right so what we'll do here is we'll Define a main function where we'll place the main Loop for now we're going to say running is equal to true and then we're going to say while running this is going to be our main Loop inside of here we're going to say clock dot tick and we're going to tick the FPS now what this will do is regulate the speed of this while loop so that it only runs a maximum of the FPS times per second so since we have 60 FPS this means that this Loop will run a maximum of 60 times per second if you're on a very slow computer it could run less than that but this will make it so at maximum it runs at this speed so that if you have a really fast computer like I do here the simulation doesn't run insanely fast okay now what we need to do is simply handle an event when a user attempts to quit the screen or quit the game so we're going to say it for event in pygame.event dot get now this is where you can actually Loop through all of the events that have occurred since the last frame so this will run 60 times per second and handle all of our different events the one event that we want to handle right now is if the user exits out of the window so we're going to say if event.type is equal to pygame.quit in all capitals then we're going to say running is equal to false that will then stop this while loop from running and then we will go down here and we'll write Pi game dot quit which will close the window for us so as soon as the while loop is finished we simply quit okay that's great now we're simply going to call this main function so we're going to say if underscore underscore name is equal to underscore underscore main then we will call Main now what this does is ensure that we are only going to call this main function if we are directly running this python file that's because you could be importing say a function a module a class whatever it may be from this file into another file and if we were to do that without having this line then it would actually start running the simulation we don't want that we only want to run the simulation when we directly execute this python file not if this python file is imported by another file okay so now what we're going to do is go to our terminal or however you want to run your python code I'm going to say Python main.pi and notice a pi game window pops up it's 800 by 800 pixels that's the width and the height that we set if we hit on the x button it closes the window that's what we implemented with this event right here perfect the next thing we need to do is draw our grid so what we'll do is create a function called Draw grid now inside of draw grid we're going to take actually a set of positions now this will be a good time for me to kind of explain how we're going to go about actually implementing this so what we're going to do is we're going to have a set and this set is going to contain all of the positions of cells that are alive now we'll do this so that we can very easily access all of those positions without having to Loop through every grid position when we're trying to update it as we go through and kind of perform the simulation you'll see what I mean in a second but this is very efficient because this means we only actually look where cells are alive and then check the neighbors around those cells rather than looking at every single position in the grid where most of those positions will be unfilled so when we draw our grid we're going to draw our grid lines then we're going to draw the cells that are alive kind of inside of those lines right so essentially a bunch of squares will be drawn inside of the grid lines hopefully that makes a bit of sense but that's kind of how we'll go about it so with that said we're going to go down here we're going to say positions is equal to a set in Python just so we have that defined and now we'll go inside a draw grid and we'll start by just simply drawing the grid lines and then we'll draw the different positions so to draw the grid lines is fairly straightforward we're going to need however many rows and however many column lines we have going both horizontally and vertically so we can start in any order that we want but I'm going to start with my rows so I'm going to say four row in range and then the range of this is going to be our grid height now what we'll do is we'll draw lines for every single row that we have in our grid right which is the height of our grid so to do that we're going to say hi game dot draw dot line now the first argument to this function right here is going to be the screen that we want to draw the line on so in this case we want to draw it on our screen right we could actually have a subsurface or a nested surface which is why this argument exists but I'm not going to get into that in this video next we need to define the color that we want to draw now we Define the color in RGB you can actually pass a string here as well but I like to use RGB because it's more flexible so I'm going to pass black which is my RGB color code here for well black right zero zero zero next you pass the starting position and the ending position where you want to draw this line so the first position we want to draw this line is the following well it's going to be 0 and then the row so whatever row we're currently on in our iteration multiplied by and then this is going to be the tile size so the way this is kind of going to work is when we're on row 0 will we draw a line at the very top of the screen when we're on Row one then we're drawing a line 20 pixels down right because we take one and we multiply that by the tile size which is 20 and then on this side for for the other position we draw the line going to the entire width of the screen which we have defined and then same thing row multiplied by the tile size so the x coordinates are always staying the same for our line because we want to go from one side of the screen to the other but the x coordinate or the y coordinate sorry is going downwards as we draw right so we're drawing every single row now this would be a good time to mention that in pi game we use a zero zero coordinate system in the top left hand corner of the screen a little bit different than some other programs that means that 0 0 is top left so as you go down your y increases and as you go to the right your X increases so keep that in mind y increases as you go down that's the opposite of a lot of other grid systems where Y is going to increase as you go up okay so it's the opposite here in pi game all right that's our row and actually before we go any further let's just look at what that's doing so we're going to kind of write a function here that says draw a grid we'll just pass it this empty position set for now and if we run on this uh the script here so let's go and run this uh well we don't have a background that's different than black so we're not seeing any lines but it should actually be rendering those lines so what we'll do now is we'll change the background color to Jane to change the background color sorry we're going to say screen dot fill and we're going to pass the color we want to fill this in now I want the background color to be gray so I'm going to say screen dot fill gray what this will do is fill in the entire screen with gray and then draw the grid okay now actually that reminds me that one thing we need to do is we need to put this inside of the while loop because I just realized it's not inside of here hence why nothing is happening and we need to update the display after we draw okay so silly mistake there we're going to say pygame.display.update inside of the while loop which I messed up there so now we fill the screen with gray we then draw the grid line and then we update the display whenever you want to actually take any of the changes or drawing events that you've done and put them onto the screen you run this update command and any of the draws that you've done will automatically be applied to the screen okay now these draws are also in an order that means that if I fill the screen gray and then I draw the grid lines the grid lines go on top of the gray screen if I did this in the other order that means that I would actually go over top of my grid lines here and I would not be able to see them because I'd be filling the screen after I drew the grid lines hopefully that makes sense but that's kind of how that works so if we run this now you can see that we get our horizontal grid lines the next thing we need to do is do the vertical ones so the vertical ones are going to be the exact same thing except just in the other direction so let's copy this and let's change this to B4 call in Grid width and now what we want to do is be drawing lines where we're changing the x coordinate but we're not not changing the y coordinate so for the y coordinate we're going to have 0 and we're going to have the height of the screen because we're always drawing from the top to the bottom and what changes now is the x coordinate we'll reset call multiplied by the tile size and then we do the exact same thing over here okay so now we've changed this just to be adjusted for columns so if we go here and run this you see that we get our beautiful grid okay now that we have the grid what we'd like to do is actually start drawing positions within the grid and to be able to do that we need to kind of be able to create these positions so let's make it so that we can actually click down on the screen create the positions and then draw them onto the screen now we can go in any order we want but I actually will start by drawing them just so that once we actually get that code down for creating them we can see them so we have these positions now our positions are going to be in the following format row column or actually we're going to do column row okay so kind of like X Y now this is not going to tell us actually the pixel positions it's going to tell us what kind of uh what do you call it position in the grid right so it's going to give us a column Row in the grid not the pixel location so what we'll do is translate the column in row to the pixel location and then draw the position so we're going to say four position in positions okay so we're going to Loop through this set we're going to say call row is equal to position so we're just kind of decomposing this into its two components and now we need to figure out the top left hand corner where we want to draw a rectangle um kind of in this grid box so whenever you draw something in python or in pi game Sorry you draw it from the top left hand corner so I want to figure out the top left hand corner of the grid box little Cube where I want to be drawing a square so to do that I'm going to say my top left is equal to and very simply we're just going to take the column and we're going to multiply it by the tile size and we're going to take the row and again we're going to multiply that by the tile size as well now we're going to draw a rectangle so we're going to say Pi game dot draw dot rectangle and to draw a rectangle again we pass the screen we pass the color we want to draw it in this case it's going to be yellow we're then going to pass an asterisk and top left and then we're going to say comma tile size tile size now what we're passing here is a rectangle object now this asterisk will actually take the two different kind of objects we have here the two different what you call these elements column times tile size and row times tile size and it will just kind of write them out as if they were individual values inside of this Tuple I know this seems a bit weird but this is called unpacking so I'm unpacking the values so that they would kind of be written like this right tile size tile size I know seems a little bit weird but just bear with me here I wanted to show you a bit more advanced python syntax in case you haven't seen that it just treats them as their individual arguments inside of the Tuple not a tuple being passed here then I'm passing the tile size and the tile size which is going to be the width and the height so it goes the X Y width height and what you're doing there is specifying the top left hand corner and then the width and the height of the rectangle you want to draw okay so that's it that will now draw the positions if we want to test that we can just add a position into the set here so we can do something like 10 10 and now if we go ahead and run our code we should see a position appearing on the screen uh we got an issue here says cannot unpack noniterable int object uh okay not sure why I'm getting that error there it says row call position ah so this is a bit of an issue the way that I just put this inside of the set it's actually treating each 10 as an individual 10 not as a tuple kind of annoying that if that's the case but we can actually fix this by just writing Tuple like that and actually no I don't think that's going to fix it uh to fix it we can do this sorry positions.add and then we can add a position like 10 10 and now it will actually add the Tuple it won't just add two tens which is why we're getting that issue so let's rerun here and now you can see we have that position appearing on the screen okay that's great so now that we have that the next thing that we want to do is we want to make it so we can click down on the screen and have a position appearing so we're going to go inside of this event Loop here and we're now going to check for the event which is the mouse button down so we're going to save event.type is equal to pygame dot mouse button down all capitals no spaces and this means you pressed any Mouse so like Left Right middle button doesn't matter what we're going to do is we're going to capture the position of the mouse and then we're going to figure out what row column you pressed on and then we're going to add a position for that so we're going to say X Y is equal to Pi game dot mouse dot get underscore position and now we need to translate a pixel position to the column and the row that you clicked on to do that is kind of the opposite of going from row call to pixel right we're going to say column is equal to X integer divided by the tile size and we're going to say row is equal to Y integer divided by the tile size okay so if we know every single tile is 20 pixels if I'm at say 40 40 then I would be at position 2 2 right because I'm in that second kind of grid uh hopefully that makes sense but that's how you figure out what row column you're in we're then going to say the position is equal to column row like that and now what we just need to do is first check if the position already exists in the set if it does that means that we're actually going to remove it because if we're clicking on a tile that exists in the set we'll just remove it from the set if it doesn't exist there then we'll add it so we're going to say if the pause is in the positions another benefit of using this set is that you can look this up in Big O of one or constant time complexity and we're going to say positions dot remove and then pause another constant time complexity operation otherwise we're going to say positions dot add and then pause if you're unfamiliar with time complexity don't worry about it my point is just this is my much much faster than working with an array so we can support a much larger grid by writing code in this way okay so there we go we now will actually be able to press these down onto the screen at least if I didn't make any mistakes so let's bring this up and let's start clicking and you can see that we have some positions now we can't click and drag that would be a different implementation but for now this is fine although it looks like when I press on them it doesn't actually remove them so we might have an issue there let's look at why we're getting that problem ah so this is a silly issue but I had is instead of in here so that was never actually uh triggering true so just change that from is to in I was thinking like is in but it's just in my apologies there guys if we run now you can see now we can actually remove our positions okay great so that is most of the user input handled next thing we'll do is just make it so we can clear the screen and so we can randomly generate some positions just so we don't have to constantly write them out write them out ourselves sorry so what we'll do now is We'll add another event down here and we'll say if event.type is equal to pygame dot key down then we're going to check for a few different Keys now the first key will be the clear key the second key will be the generate key and then we'll have the space bar which will allow us to pause and play the simulation so actually we can go in a slightly different order uh excuse me here we're going to say if event.key is equal to pygame.k underscore space obviously this is checking if you pressed the spacebar key down then what we're going to do is we're actually going to set a variable here called playing we're going to make that equal to false and we're going to go here and we're going to say playing is equal to not playing now all this will do is toggle this playing variable so that we are either pausing or playing the simulation that's it that's all that the space key will do next we're going to say if event dot key is equal to Pi game dot k underscore C notice this is a lowercase C this time what we're going to do is clear the screen to clear the screen we're going to say positions is equal to a set so we're just going to create a new set that'll just remove everything that was in the existing set and then we're going to say uh sorry that's coming a little bit later uh playing is equal to false so we just pause the simulation after you clear lastly we want to randomly generate a bunch of positions if you press the G key now you can pick whatever key you want for this but I'm going to go with G so I'm going to say if event.key is equal to pygame.k underscore G then I'm going to say that positions is equal to I'm going to call function gen inside of gen I'm going to specify how many positions it is that I actually want to generate now I want this to be random so I'm going to say random dot Rand range and this is going to be 2 to 5 multiplied by the grid width now I know we haven't actually defined all of this yet just bear with me for one second first of all go to the top of the screen here import random so we have access to that random module there and then we're going to make this gen function now the idea is again I'm passing the number of unique positions that I want to generate okay so now we're going to go to gen and we're going to write this function so we're going to say Define gen we're going to take in a number and all we're going to do is generate that number of random positions to do that we're going to return a set inside of the set we're going to have a list the list is going to have a tuple and the Tuple is going to say random Dot randrange and we're going to pass 0 as the start index and as the stop Index this is going to be the grid underscore width and then for actually sorry it says to be grid height and then we're going to do the same thing again random dot randridge this is going to be zero and grid width okay and then we're going to say four underscore in range and then number let me zoom out so we can actually read this so how does this work well what we're doing is we are creating a list here this list is going to contain a bunch of random positions in a tuple so what we're doing is using something known as a list comprehension we're first generating a random position in the y direction okay so for the row so we're picking a random one between zero and the grid height because that's all that's valid same thing here we're picking a random one for the X position now between zero and grid width and then we're doing this for underscore this is just a placeholder variable you could put I here if you want but since we're not actually going to use the variable I'm just putting underscore in range and then number okay so we're just creating this number of random positions for whatever the num is that we pass to this function now why I'm converting this to a set is that what's going to end up happening here is all of these um values here they could potentially overlap now a lot of times they won't but it is possible that I generate the exact same random position well I don't want to have duplicated positions so we just convert it to a set and that's going to remove any of the duplicates for us plus we need to set anyways so now positions will work and if we press this key we should actually generate those random positions so let's give this a shot here and see if I press G you can see that it randomly generates a bunch of positions for us if we want more of them we can go down here and we can just kind of change these numbers around a little bit so maybe four to ten right because it's going to be random multiply by the grid width and now you see we get a lot more positions appearing on the screen now while we're at it let's try the c key notice C works it just clears the screen and there we go okay so now that we've done that we want to start updating the grid now updating the grid is not overly complicated but it is kind of the most logic intense part of this application so we're going to write a few functions here first this is going to be adjust grid and what this is going to take in is positions okay and we're going to write another function here and this is going to be Define get underscore neighbors like that and this is going to take in a position and this is going to return an array or a set containing all of the neighbors of that position now remember that what we're doing here is we're looking at every single um kind of cell and we're saying okay does this cell exist does it get deleted and then if there's a cell that is not alive we have to see okay should this become alive based on the neighbors of those positions we'll go over the rules again don't worry and obviously we'll be coding them out but it's important that for every single position we look at we need to know all of the neighbors of that position we need to know if they are in a live cell or not and if it is a live cell then we need to check okay how many live cells are you neighbors with based on that value we either delete you we keep you or we potentially create a new cell in one of those neighboring positions all right so let's go to adjust grid now again the way we're doing this is we're only looking at positions that could potentially have any update to them that means that I don't actually Loop through the entire grid I just Loop through the positions which are live cells so what I'm going to do is say all underscore neighbors is equal to a set and I'm going to say my new underscore positions is equal to a set now the reason I need this is whenever I make any updates I'm making it based on the current frame or the current set of live cells that means that I need a new set that I put all of my new cells into which will exist at the next step because if I try to update the existing set while I'm kind of doing this update step I could potentially kind of mess up how things are working because I'm going to be deleting and adding cells which will then change how the other cells react I'm not sure if that makes sense to you or not but I can't kind of make the update in the same position set I need to use a new set for all of my updates so that those updates don't affect the other cells that I've yet to have a look at now that's why we have new positions why do we have all neighbors well the reason I have all neighbors is that I need to potentially check for the Neighbors of any live cells if they should become a live cell right I don't need to check ones that are really far away that don't have any live cell neighbors but any cell that has at least one live neighbor I'm gonna put inside of here because then I'm going to check if it needs to become a live cell okay so first what we're going to do is simply see if we need to delete or keep existing cells so we're going to say four position in positions okay and what we're going to do is get all of the neighbors of this position so we're going to say Neighbors is equal to get neighbors and we're going to pass this position we're going to write Neighbors in one second or that function for now though imagine this gives us all of the neighbors now what I'm going to do is say all neighbors dot update neighbors what this will do is take this list of neighbors and it will pass them all into this set if any of those neighbors already exist which is very possible if they will not be duplicated because they're inside of a set so now that we have all of the neighboring positions the next thing that we need to do is check if these neighbors are alive or not because what get neighbors will do for us is just return the coordinates or the row column of all of the neighbors of Any Given cell so now we're going to do some pythonic syntax here and we're going to say neighbors is equal to a list that is filtered using the filter function now this filter is going to be quite easy we're going to say Lambda X we're going to say X in positions like that and then we're going to pass here the neighbors okay what did we just do well I wrote what's known as an anonymous function all this is doing is acting as a filter function that essentially means that we're going to take this list of neighboring positions and we're going to Loop through them and we're going to pass every single one of those positions to this function so that they're going to be passed as the parameter X we're then going to ask is x in positions so is this position a live cell if it is then we're going to keep that position inside of this filtered list if not we're going to remove it so what happens is filter actually gives us something known as an iterator we don't want that we want a list so we're going to convert filter to a list and now we're good to go that might be a little bit more information that you need but essentially this just filters the neighbor positions and gives us only the ones that are alive which is what we care about so now we can say if the Len of our filtered neighbors here is in 2 or 3 meaning it's equal to two or three just just a shortcut to do that then what I'm going to do is say new positions dot add and I'm going to add this position so all I'm saying is here is okay well if this position based on the current positions has enough live neighbors so it has two or three then we'll keep it for the next round so we'll add that into our new positions that's it that's all we have to do here now if we don't add it we are kind of implicitly deleting it because well if we don't add it it's not going to exist in new positions after this right perfect so that is it for kind of handling the positions or the cell story that we're going to be keeping or not keeping now what we need to do is see if there's any cells that we need to create right or that need to become alive so to do that we're going to say for position in all neighbors so now we're looping through all of the neighbors of the live cells that's why we collected them so we could Loop through them now we're going to say neighbors is equal to get neighbors of and this is going to be the position right so now I want the neighbors of what were the neighbors of all of the live cells I know a little bit overwhelming but that's what we want now similar to this we're going to filter this I probably could make this a separate function but it's fine we're just going to copy this in here so again we're now going to look and say okay well which one of these neighbor positions are alive we're going to get all those and then we're going to check the following we're going to say if the length of neighbors is equal to 3 then we're going to say new underscore positions dot add and we're going to add the current position which will create a new live cell lastly we're going to return the new neighbors or the new position sorry okay so that's it for adjust grid we need to write the get neighbors function and then we're actually pretty much done with this code other than just calling these functions and stepping through a few things quick let's recap what I did just because this is the most complex logic that we've had given it's not that complicated but you get the idea we have all neighbors right storing all of the neighbors of all of the live cells from the current set of positions new positions this will be what is updated after we kind of run this whole update Cycles this is what we'll see at the next step here we go through all the positions these are live right these are the live cells and we say okay let's get the neighbors of that live cell this gives us all of those neighboring coordinates right so all eight potential neighbors of that position we're then going to say all neighbors.updates we're going to put that in there so we can use them later we're going to filter the neighbors so we only get the live cells and we're going to say if the length of the live cells that our neighbors is two or three then that's good we're going to keep this position that's it down here what we're doing is looping through all of the neighbors now of the live cells we're checking their live neighbors and we're saying if they have exactly three live neighbors well we need to make this cell become alive so we do that and then finally we return new positions once we write get neighbors this will put it all into perspective how do we get the neighbors well we have eight neighbors right we have top left hand corner uh kind of top middle top right the middle to the right middle right or bottom right I guess uh bottom middle bottom left and then like the left middle side uh you know what I mean right if you're looking at a grid one position you have eight potential neighbors diagonally and um what do you call it horizontally and vertically so what we're going to do is say X Y is equal to position okay so we're going to break this down because again remember we're passing a tuple here that contains the column and the row so we'll just denote that with X Y we're going to say neighbors is equal to a list and we're going to say 4 DX in negative one comma 0 comma one this is one uh kind of more creative approach to get the neighbors we'll explain this in one second four d y in negative 1 0 1 and this stands for displacement in X and displacement in y okay so continuing here we are going to say if DX is equal to zero and the Y is equal to zero then just continue now the reason for that is that if we have no no displacement in X and no displacement in y then we're looking at the current position which we don't want to look at but the way that I'm writing this we just need this little check here okay so we just press continue there or say continue next I'm going to say neighbors dot append and I'm going to append X plus the displacement in X and then y plus the displacement in y now again notice we have negative 1 0 1 meaning that as we Loop through this we have nine iterations one of those iterations won't count which is the center position so all of those other eight iterations will give us every single combination of neighbors right so we have like negative 1 in The X which is moving left and then that would be combined with negative 1 and the Y 0 and the Y and one in the Y which would give us all those positions uh to the kind of furthest left side then zero okay that's in the middle same thing negative one zero one one that's to the right negative one zero one okay only thing we need to do here is just make sure we don't handle a position that's off the screen to do that we just say if DX Plus or actually if X plus the x is less than zero or X plus the x is greater than the grid width then we will continue and we'll copy this exact same thing and we'll put this here but we'll just check it with Y okay so we'll say if y plus d y or Y plus Dy is greater than the grid height all right just making sure that we don't have any positions that are going off of the screen uh so we don't get any index out of bounds exceptions or any kind of issues related to that but we don't end up generating the simulation that we can't actually see which would be kind of silly okay so now we have get neighbors and we're going to return the neighbors list and that is going to do pretty much most of the code that we need okay so now that we have that what we want to do is actually start calling these functions now remember we kind of have this pause state right I have playing so either we're playing or we're not playing now we also need to kind of keep track of what step we are on or at least how often we want to update the screen so we could update the screen every one second every two seconds every three seconds you can kind of pick but what I'm going to do here is say step is equal to zero or actually this would be a better variable we'll say count is equal to zero and we're going to say the count underscore frequency or really we could call this update frequency is equal to 120. now what I'll do is at the very top of my code here I'm going to say if we are playing then my count plus equals 1. so this is saying okay if we're in the play mode if we actually are activating the simulation we're going to add one to our count now that will happen to maximum almost 60 times per second right so that means that every second account is going to go up by 60. so now what we'll do is we're going to say if the count is greater than or equal to the update frequency which is 120 which means two seconds then we're going to reset the count to be equal to zero and we're going to say our new positions are equal to the adjustment of the grid passing the original positions because again remember this is returning new positions which will be the new ones that we want to see so we simply set our position set equal to those new positions that are returned from our adjusted grid function there you go that's pretty much all we need a few other Smite slight tweaks we can make for example if we decide to clear the screen we can just reset our count so we can say count is equal to zero here uh so it's not kind of stuck at something and lastly we can just add a caption onto the screen here that tells us if we are paused or playing so that we know so we're going to say hi game dot display dot set underscore caption and we're just going to say playing if playing else paused okay so this is an inline if statement and this will just allow us to again either show playing if we're playing or show paused if it is paused so we get some feedback now it's possible I made an error or two here but let's zoom out for a second I'll kind of slowly scroll through in case you guys need access to this obviously the code will be available in the description as well okay kind of there you go now let's run this and make sure it works okay so let's generate and let's press the play button notice it says playing and we should see that we start to get the kind of game running and there you go the simulation is running okay so as we run the simulation uh while it's playing I can do things right like I can remove them I can add stuff in I can kind of do whatever I want I can press G and just have it like continue to go right and I can also press C and I can clear it just keep in mind that you know playing and pausing up here it's kind of a little weird like if you're generating while you're playing through it but that works you can do that I set up that way okay so I think with that said that's gonna wrap up this video there's actually a lot shorter than I thought it was going to be uh and yeah that kind of covers everything that we needed so if you guys enjoyed make sure you leave a like subscribe to the channel let me know if you enjoyed the simulation and you want more and I look forward to seeing you in another YouTube video foreign