hello everybody and welcome to the sixth video in this opencv python tutorial series in this video what we'll be doing is learning how we can detect corners in an image now the point of this video is not just to show you the corner detection although that is interesting it's to give you kind of an introduction to some of the interesting algorithms that opencv has built in and how easy they are to actually use for example in this video we're literally going to need to write about three or four lines related to corner detection and that's all we need to do to find all of the corners in an image so there's a ton of really interesting stuff you can do with opencv obviously i cannot and will not cover all of it in this tutorial series so if you want to check for yourself some of the things i'm kind of skipping over or not talking about as in depth then go to the opencv documentation i will link it down below i will mention that the version of the documentation i'm showing here is not the official documentation this is kind of i guess like a reworked version of the documentation that in my opinion is a lot easier to understand and has some better images and visuals and just it just makes it easier to access the information at least in my opinion so anyways this will be at the link in the description for example the corner detection algorithm we're going to use here is called the shi tomasi um i believe that's how you pronounce that i'm probably wrong corner detector and good features to track so if you want to hear the theory and math behind this i'm not going to explain in this video i'm not qualified to do so and i also just think it's kind of unnecessary and boring but you're welcome to read through that yourself again link in the description all right so with that said let's dive in the first thing i need to do here is import my module so i'm going to say import numpy as and then mp and i'm going to import cb2 now that we do that we need to load in an image or we can use a video capture device if we want now for this tutorial i'm just going to use an image so i have this image here it's of a chess board we're going to load this in and then we'll do the corner detection on this now you of course can load in any image that you want doesn't need to be a chess board but if you do want this image it will be in the github repository again that will be linked in the description so let's load this in i'm going to say img is equal to then cb2 dot and then uh what is this i am read sorry yep and then here we are going to do assets slash and then chess board dot png so i have that inside of my assets folder if you get this from github you as well will have it in the assets folder all right now that i have this let's actually just quickly display this so i'm going to say cv2 dot and then i am show i'm going to i am show i guess frame and then we will show img call this whatever you want doesn't matter we'll say cv2 dot wait key we'll wait infinitely for us to press anything and then cb2 don't destroy all windows all right so let's load this up we can see that our chessboard appears but now notice that our chessboard is quite large i don't want my chessboard to be this large so let's resize it and make it a bit smaller so i'm going to say img is equal to and then cb2 dot resize we're going to resize the image we're going to pass 0 0 here and then we're going to pass our fx equals and let's go 0.75 and fy equals and 0.75 as well all right so let me try this now we should see our chessboard is a bit smaller that's awesome okay so it just about fits on the screen great so now that our chessboard is resized what i actually need to do is convert this to a grayscale image so a lot of the times when you're dealing with these types of algorithms where you're detecting edges or features or corners you're going to be converting your image to grayscale before you pass it to these algorithms that's just because these algorithms work on grayscale images and it's easier for them to detect these features in a grayscale image than a bgr or rgb colored image so what i'm going to do here is say image is equal to and then cv2 and we've already seen this before this is going to be dot cbt color we're going to pass our image and then we're going to pass the color that we want to convert this to so cb2 dot color underscore and then we're going to say bgr 2 and then gray like that so now that should convert our image to grayscale let's run this in c and there we go we do indeed get this grayscaled image now notice it doesn't look any different because well it was already grayscale before it was just black and white but this is grayscale and it is working all right so now we have that what we can actually do is we can now run our corner detection algorithm so once we've converted this to grayscale what we can say is that our corners is equal to and then cv2 and the name of this method here is good features to track i i don't know why they named it this a lot of the naming and kind of conventions i have here i don't find too intuitive but this is going to run that algorithm i discussed which is the she what is this shitomashi corner detector and good features to track so all this is saying is that it's just going to return to you all of the corners from an image i don't know why they have to make it confusing with good features to track anyways again link in the description for that so now that we have all of the corners or sorry now that we've written this function we need to pass some arguments to it so the arguments for this function are the following you need to pass your source image the image you want to detect the corners from then you need to pass the number of corners that you want to return or more specifically the number of best corners that you want to return so you pass some integer here let's call this integer n and this will return to you the 100 best or the n best what do you call it corners from the image so if your image has like 500 corners that this algorithm detects it will return to you the n best of those corners so let's just go with a hundred here you can make this whatever you want i'm just gonna pick a hundred next we have to pick the minimum quality for our corners so the quality of a corner is between zero and one so one would be a perfect corner zero would be a corner where there's like no confidence that that is a corner and it's hard for me to really explain what the quality really means because that's kind of due to the implementation of the algorithm so again read the documentation if you want to see exactly how that works but pretty much if you make this number really small you're going to get corners that are probably corners but that the program's not 100 sure they are whereas if you make this number larger say like 0.5 then you're going to get only corners that the program's pretty certain are corners so it's kind of a degree of confidence when it's looking and finding these corners and well that's what you're picking right here what's the minimum quality you want i can say from experience putting it at 0.01 is probably fine but if you notice that you're getting a bunch of things that aren't corners then slowly increase this value upwards then after we have that the last thing that we need to return is actually the minimum euclidean distance between corners that are returned so a lot of times what will happen is if you have a corner that's like slightly rounded it will return to you like 500 points that are all right on that corner um so it will detect you know a bunch of different corners that is really just one corner so what you put here is some value which is telling you the minimum distance between two corners so if you had two corners that were really close then what you would do is make a value here like 10 and this means hey i'm not going to return both of those corners i'm only going to return one and specifically the best of that one because these corners are too close together and well i don't want to return ones that are too close so euclidean distance is simply the absolute distance between two points on a graph or in this case in an image so if you were at say 1010 and 2020 then you would have some euclidean distance between those two points so the way you calculate euclidean distance is actually using pythagoras theorem now i know i've butchered the way you say that i can never say that correctly but the basic equation for euclidean distance if you're working in two dimensional space so xy dimensions here then you would have some points say like x1 and y1 and then you would have another point say like x2 and y2 and the way you calculate this is you take the square root so sqrt of and then that's going to be x 2 minus x 1 to the exponent so let's go hat 2. i know this isn't proper syntax but you get the idea and then i'm pretty sure that is plus that's now going to be y2 minus y1 to the exponent 2. so that is euclidean distance and the reason this works is because you're literally just performing pythagoras theorem you're looking at a right angle triangle you're figuring out the distance of i guess it's the uh oh i've been out of math for a long time now the distance between the adjacent and the opposite uh sides i guess and then you're calculating the length of the hypotenuse which is going to be the distance between those two points so i think i've probably butchered that explanation a little bit i don't claim to be a you know god at math or anything but this is the formula for euclidean distance it's pretty much just the straight line distance between two points so anyways that's what this is telling you is that the euclidean distance between two corners must be greater than this for you to include that corner alright so now that we have that what we want to do is display these corners on the screen so we will continue in one second but i need to quickly thank the sponsor of this video and the series which is algo expert algol expert is the best platform to use for preparing for your software engineering coding interviews they have over 125 coding interview questions they have behavioral interview tips a data structures crash course mock interviews and a ton of other helpful features get started with algo expert today by clicking the link in the description and using the code tech with tim for a discount on the platform so the first thing that we need to do here is we need to convert these corners into integers so by default when it returns to these corners in fact let me just show you let's let's print out corners here you're going to notice that the data type of these corners is actually float so let's have a look so let me just quit this and we'll look right here and what you can see here that all these values are floating point values now this is no good we don't want floating point values and the reason we don't want floating point values is because we want to use these values here to actually draw our corners now what we're going to do is kind of extract these values and we're just going to draw circles where all of these points are so we can see where all of our corners are notice how many it's giving me here so i need to convert these into integers to do that is actually pretty straightforward we're going to say that corners is equal to and then np dot and then i believe this is actually called int 0 so we're going to say int 0 just had to reference my notes there and then we're going to pass in corners now this will just take our numpy array that has those floating point corners and turn them into integers all right so now that i have that what i want to do is draw these corners so obviously i have multiple corners and notice that if you look at these corners here they're actually returned to us in a similar shape to our image so we have like all of these corners inside of two numpy arrays so that's going to be something that we have to deal with but just notice that we have our one array and then inside of two arrays here two lists we have our points so we are going to have to kind of decompose that and deal with that here but i will show you how we do that so anyways i'm going to loop through all my corners so i'm going to say four corner in corners like that and then what i want to do is i want to decompose these corners so first of all let me just show you what i mean by this so if i print out my corner now in this for loop you're going to see that after we close this and we look here this is what's printing out right we're getting an array inside of an array so i obviously need to take this interior array and then use that as a point for drawing my circle so we could do something like this we could say that corner is equal to corner 0 and then that would give us one array that has the x y values but there's actually a method in numpy that can help us do this so if i say x y is equal to and then corner dot and then i have to look at this i believe this is called ravel what this actually does is flatten an array so if you're given something that looks like this and you have you know some elements in it what ravel does is it just takes this array and completely flattens it now when you say flatten all that means is remove all the interior rings so we'll get rid of these two brackets and these two brackets and it will just give you all of the remaining elements so even if you had something that was like this and you have like one comma two and then like two comma one then what would happen is it would just give you a new array here that would look like this one two two one it would just flatten it for you so anyways what's going to happen is when we have our point that looks like this so x y it will flatten it so the array now becomes x y and then in python there's something called tuple or list decomposition so we'll take these two elements and then just place them into the two variables so x will be equal to x and y will be equal to y so that's what corner dot ravel is going to do now that we have the corner we can actually draw the corner so to draw the corner we're going to say cv2 dot and then circle this is why i showed it to you in the last video or in i guess video four i'm going to say image i'm going to put the center of my circle which is going to be x y make sure this is a tuple and that you don't just pass this corner.ravel here because that won't work then after you have that you want to pass the radius so let's make the radius of this say 5. we now need a color so this is going to be in bgr so let's make these blue so 255 0 0 and then we need a thickness of the line or a fill now i want to fill in my circle so i'm going to make a negative 1. so now we'll draw that on the image and then display the image so we should see all of our corners so let's run this and notice that we do see these corners here but for some reason they're showing up white and actually i'm realizing that the reason these are showing up white is because our image is still in grayscale so if i want to convert my image back into a colored image then i'll have to do something to do that so these are actually being drawn as blue but since our image is in gray scale it's just showing them as white so we need to not show the image that is grayscale in fact we should show the image that is colored so what i'm going to do and this is constructive i probably should done this at the beginning is rather than doing all of my i guess image manipulations on the grayscale image all i'm going to do is have my gray here so i'll say gray is equal to then cv2.cvt color and i will use that to detect the corners but then i will draw the corners on my colored image so now rather than converting the original image into grayscale what i will do is make a new image that is grayscale i will find the corners in that new image and then i will just draw the corners on the colored image so this should work now that's what i did here by changing this to gray and changing this here to gray so let's save this and run and let's see and there we go so now we're getting all of the corners it's missed a few just because you can't really detect a corner here because there's just a ton of black and it's bordering there but you can see that it's giving us you know pretty much all the corners except for these two black ones which is to be expected so now that we have all these corners what i'm going to do is i'm going to draw lines between these corners now i can't really zoom in here to see if it's showing multiple circles here uh for these corners like if it's detecting multiple corners i don't think it is but there is a possibility that multiple circles are being drawn on top of each other that shouldn't happen because of the euclidean distance thing that we have but it just to me i don't know i'm looking at it looks like there might be multiple ones drawn there uh anyways we'll see when we start drawing these lines but what i'm going to do now just to kind of add some nice spin to this is we are going to draw randomly colored lines between every single one of these corners so every combination of corners will have a line drawn between them so i just want to show you this because i think it's interesting so i'm going to go and say 4i in range and then this is going to be the len of our corners i am then going to say 4j in range and then the len of our corners like that i'm going to say that oops uh corner 1 is equal to and then corners at index i and then i will say corner 2 is equal to and then corners at index j and i also will sorry just do a quick fix here i'm going to say i plus 1 to line of corners so what this is going to do is loop through all of the corners then it's going to loop through all of the other corners that we haven't already looped through that's why i have i plus 1 here we're going to get two pairs of or we're going to get a pair of corners i guess so two corners corner one and corner two and then we're going to draw a line between these two corners so now that we have these two corners here all we have to do is convert these to tuples because these are going to be list by default so we have to say tuple and tuple this will take this list and convert this to a corner and then i will say cv2 dot line and i will draw a line on my image between corner 1 corner 2 it's going to have a color this color is going to be a random color so i'll show you how we do that one second and then the thickness of the line will just make one so i think that's all we need for the line but now what i want to do is figure out what this color value is going to be so i'm going to say color and then is equal to and then n pi or np sorry.random.randint and what i can do here is i can pass a high value or sorry a low value a high value and then the shape or the number of random elements that i want to generate so in this case if i say 0 and 255 because i want to generate here 3 random values between 0 and 255 so that i can generate a random color right a random value for blue random for green random for red and then the amount of these that i want so the size is equal to three so this will kind of be a shortcut to what we did in one of the previous videos to generate a random number where now we will just have uh this one function that can do it all for us now the only issue with this is that this returns to us a list and these random ins are not necessarily integers now i know this is weird but it's actually going to return to us a 32 or 64bit integer and we only want an 8bit integer now this is just kind of one of the things with numpy numpy has a bunch of different types for all of their integer values in python it works a little bit different like your standard python integer data types versus your numpy integer data types so because of this small nuance here we need to convert these integers that are generated into regular python integers so that they are not numpy 64 32bit integers which we don't want so to do this we're going to map this this will actually be instructive as well i can say map and then what i will do is i will put a function that i want to apply to every single one of these values so the way that map works is you put a function so i'm going to write a function i'll explain this in one second and what this will do is it will apply this function to every single element in your array here and then it will return a new array that has all of the results from this function so in this case i wrote what's known as an anonymous function it's a lambda function so if you want to write a oneline function and you don't want to define one yourself you can write lambda then you can write x so this is going to be like the parameter for the function and then your return value comes after this colon so in this case x will be every single element from this randomly generated list of integers and then we'll just take that and convert it into a regular python integer because we have int here so return to us that int we will add all of those ins into a new list and then that's what map will give us and then finally after this we need to convert this into a tuple because we can't have a list for our color it needs to be a tuple and then we can put here color so i understand this is probably a little bit confusing especially if you're not more experienced python programmer but map again all it does is map all of the values from an array to a function or uses a function to map all of the values returns you a new array that has all of those values then you convert this into a tuple and then we can use that as the color for our line so now that we have that all i have to do is run this and you're going to see we're going to get kind of a bunch of just random lines showing up on the screen here so let's run this and i got an error so let me look into this and i will be right back all right so i'm just looking into this issue here and i realized that we ran into a pretty silly mistake so when i'm referencing corners i and corners j i have to remember that we haven't done this corner dot ravel thing right we haven't flattened it which means that corners i is really this kind of two sided array like this right it has two array inside of an array so the way that we have to combat this is we need to just take the zeroth index of this so what this will do is give us the interior array because since we have something that looks like this x y we just want x y and so if we index this exterior array at 0 that will give us the interior array which is the first element so this should hopefully fix our problem for us so let me run my program now on let's see if this works and there we go this does indeed work and notice that we have all kinds of lines going around the screen a line thickness of one between every single corner so i just want to show you that and i think this is interesting and it just shows you what you can kind of do with opencv so in the next video i think we're going to get into potentially object detection or facial recognition we're going to be doing some interesting stuff i hope you guys are looking forward to it and with that said if you enjoyed make sure you leave a like subscribe to the channel and i will see you in another youtube video