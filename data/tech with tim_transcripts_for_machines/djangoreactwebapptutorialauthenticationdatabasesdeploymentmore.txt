in this video you'll learn how to use Python and JavaScript to create a full stack web application we'll be using Django for the backend and react for the front end and we'll Implement authentication using JWT tokens now as a bonus I'm even going to show you how to deploy this application completely for free so by the time you finish this video you'll have an entire project completed it will be a great starting point that you can extend and build upon and you'll even learn about how to get a free deployment so you can share this with other people and you can see it working online not just on your local machine I'm going to go over a ton of stuff in this video you're going to learn a ton and with that said let's get into a quick demo so you can see what you're going to build so I have a quick demo in front of me that I'm going to run you through but I do want to mention that this video is more designed for intermediates this is not a beginner tutorial and I'm going to assume that you already understand both Python and JavaScript and have some familiarity in D Jango and react that said I will of course explain everything that I'm doing and I will make it as clear as possible but I'm not going to be going over basic syntax like for Loops what a variable is or anything that is more in the beginner section if you are looking for more beginner tutorials I have tons of them on my channel but this is for those of you that really want to level up understand how to use multiple languages and create a more advanced application that can actually be deployed and have some real world use with that said though let's go through a quick Demo First let's have a look at how this works so you can see that we have a login page we also have a register page if I go here so I can start by registering a new account so I can do something like tim1 123 let's set a password we're going to wait a second for it to load and then we can log into this account and you'll see the main functionality that we've implemented so now that we're registered let's log in okay wait for that to load and then it will bring us to a page where we'll be able to create some different notes now I know this seems really basic but I promise you this is what you need to understand to create some more advanced applications how you associate data with specific users and how you create create read update and delete data that's what I'm going to be showing you here so let's do new note test content here okay and then we'll submit this and the note should be created in just a second you'll notice there's a little bit of lag just because of how the deployment set up and if we wait we should see that the note appears here so let's refresh the page here and you can see that the note pops up now it's obviously not the prettiest thing in the world but that's not the point of this tutorial and if we want we can click on delete again we just have to wait a few seconds and the note will be deleted so that's it that's what I'm going to be showing you how to build but this involves building the front end building the back end having authenticated requests registering users creating new users signing in logging out there's a lot of stuff in this video and I promise you're going to learn a bunch however there is something I need you to know about right now which is your chance to win a cyber Tru or $100,000 cash now the way to do that is really just to complete this video and develop and deploy this application that we're going to build step by step on Coro now I've partnered with them for this video but they're running this wso2 code challenge which is giving you the chance to win a cybertruck which is pretty incredible now in order to actually enter this challenge all you have to do is develop and deploy an application it has to have a front end and a back end and you have to deploy it to production using the Coro platform again I'm going to walk you through doing that in this video if you want to maximize your chances of winning there's some bonuses that you can get here by adding additional functionality like connecting with databases and the key data you'll want to know about here are the following obviously I'll link this in the description so you can check it out but the main date you're going to want to know is April 30th you want to finish your project before then so that you'll be entered into the draw it gives you some information on how to submit I'll let you guys read that from the link in the description and there's also going to be 10 other winners that will receive a 14in MacBook Pro with an apple M3 chip so even if you don't win the cybertruck you have 10 other chances to win a MacBook Pro pretty incredible competition and the great thing is you literally just have to follow along with this video and you'll already have a project that you can use to submit obviously you can make it better if you want to but this as a bare minimum is all you need to be able to enter the competition so with that said I hope you're excited let's get into the code here and start by writing our backend so let's begin here by walking through a quick overview of what it is that we actually need to do now we need to start by building the back end the back end is going to be our API it's going to store our data and it's what's going to handle our different users or any other information we're storing related to them once we build the back end we need to build the front end the front end is the user facing component of the application which will allow people to interact with the API in our case to make new nodes to sign in to sign out Etc once we do that we're then going to deploy a database and we're going to connect the database to our backend so we have something that's a little bit more robust and that's stored in the cloud that means we could access our database from other sources and that's typic best practice after that we're actually going to deploy the back end then we're going to deploy the front end and we're going to connect both of them together but first we're going to begin with our backend so what we want to do here is open up a directory in Visual Studio code or any other code editor you want to use in this case I've just opened one called D Jango react tutorial it's on my desktop you can store it anywhere you want so open up that directory and then change into that directory in your terminal and the first thing we're going to do here is create a virtual environment to install our various python packages so to do that the command is going to be Python 3m venv and then EnV and if you are on Windows the command is going to be python so you're just going to exclude the three so we're going to run that it's going to create a new virtual environment directory for us what we're going to do now is activate that virtual environment so to do that we're going to type Source then this is going to be EnV SL bin slash active AC at and if the activation is correct you should see a prefix before your terminal line now if you're on Windows the command to activate is a little bit different it should be EnV SL scripts SL activate dobat if that doesn't work you'll need to look up the specific command for whatever shell you're using powers shell command prompt Etc because it is a little bit different okay now that the virtual environment is activated what we're going to do is install all of the dependencies for this project in inside of here now to do that we're actually going to create a new file here called requirements.txt and we're going to paste all of the different requirements we need so all of the Python packages directly inside of here so what we're going to do is go to a link in the description I'll leave this link down below it's going to bring you to a GitHub repository that looks something like this now this GitHub repo has all of the code you need for the entire project so if you're getting stuck come here you can look at it it has all of the different files all of the completed code and if I tell you to copy something you can find it from here now in our case we're just going to go into the backend directory and we're going to find requirements.txt and you'll see this has a list of all of the requirements that we need so what I'm going to do is just copy these and I'm going to go back and I'm going to paste it inside of my requirements.txt because we're going to use this file to have all of the requirements we need and to install all of them in our environment now notice we need D Jango D Jango cores headers this allows us to fix that cross origin request issue that you've probably seen in your terminal before if you haven't seen that don't worry about it but we do need this we then need Jango rest framework D Jango rest framework simple JWT for handling our JWT authentication then a few other dependencies we need in here as well you don't need to worry about all of them this one here is for working with a postris SQL database which we'll be doing later and then python. EnV for loading in some environment variables again don't stress too much about what these are but we do need to install them to do that we're going to type pip install dasr and then requirements.txt make sure that's in the virtual environment that you activated so you see this prefix here when you hit enter it should install all of those different dependencies for you and then we'll be good to go okay so now that we've done that what we're going to do is create a new D Jango project to make a new Django project we're going to type djangoadmin and then start project and then we're going to give it a name in this case we'll call it backend now I recommend you go with the same names as me and this should make a new directory for you we're now going to change into the backend directory and we're going to make a new D Jango app now apps are where we can actually write our own custom views and custom code you'll notice here if you look in the backend directory we have another directory named the same thing this is kind of the main directory where we have some settings we link different applications but this isn't where we write a lot of custom Django code where we write our custom Django code is in an app and we can have multiple different apps for different types of things we're doing to organize logic out maybe we have an app for authentication for a certain component of our application in this case we just need a single app so what we're going to do is type Python manage.py and then this is going to be start app and we're going to call this API okay so that will make a new directory for us called API now that we've done that what we're going to do is we're going to go into back end and we're going to go into settings.py now inside of here I'm going to put a bunch of settings that we need to write it's very important that you watch this very carefully and do exactly what I do if you miss even the smallest thing it will mess up your project so just be very careful here going through and following with what I show you and if for some reason you're getting some errors you can just copy the settings.py file from the GitHub repository okay so we're going to start right from the very top and we're going to import something that we need we're going to say from date time import the time Delta we're then going to say from. EnV import load. EnV and we're going to import OS then we're going to call the function load. EnV now you'll see why we need these Imports in a second but what this one will do here is load an environment variable uh file for our story so we can use that for having credentials for our database and other things that we need we're then going to scroll down and we're going to go to where it says alloud host now for alloud host we're going to put an asterisk inside of a string and this will allow any different host to host our Django application now the reason we do this is just so we don't get an error later on when we deploy this application and it's running on some host that it's not aware of okay so we're going to put alloud host here and what I'm going to do now is copy in some configuration that we need now this is related to our JWT tokens which we're going to talk about in a second so I'm going to paste these in and you'll see that we have rest framework and simple JWT now if you don't want to write this yourself you can just again go copy it from the settings.py file in the GitHub repository but what we're specifying here is the default authentication classes and the default permission classes now we need these when we're working with our JWT tokens I don't need to get into it too much but you just need to specify this configuration for the JWT tokens to work properly next we're going to specify the lifetime for our JWT tokens so the access token which is what we'll use to actually access different Roots will expire in 30 minutes you can change that if you want and the refresh token will expire in one day the refresh token is something we can use to get a new access token so your refresh token should always have a larger expiration date than the access token okay now that we have that we're going to move down into installed apps now in installed apps we're going to add API which is the name of the application that we added here so the one that we created that's what you need to add then we're going to add restore framework again make sure you spell this exactly as I have here and then we are going to add the cores headers now what we're going to do for the rest of the settings or at least a lot of the other ones you see is enable cores or add some configuration so that cores is not an issue for us cores is a problem when you have a different origin trying to hit this back end so you've probably seen this before if you've worked with any kind of front end and back end it says there's some ches issue and you can't make a request that's what I'm just kind of enabling here or I'm fixing for us preemptively so we don't get that issue later on okay so we're going to add cores headers we're then going to go into middleware and we're going to add a middleware for Cores now I'm just going to copy in the middleware so I don't mess it up so it's going to look like this it's going to be cores headers do middleware do cores middleware with the Correct capitalization okay and then Simply Save the file and we'll keep moving down now as we move down what we are going to go down to is all the way at the bottom and all the way at the bottom we're going to paste in two variables here we're going to write them out I'm going to say corescore allow underscore allcore Origins is going to be equal to true I'm then going to say corescore allow uncore credentials is equal to true now typically if I could uh disable my cap blocks here sorry typically you would actually just allow a specific origin not all of them but in our case all of our Origins will be slightly different based on how we do the deployment so I'm just enabling all of the different Origins to work here so that you don't get any issue and you can proceed with the tutorial later if you wanted to make this more secure there's some changes you could make inside of the settings but for now this will just make sure you don't hit any roadblocks which is my main goal right now so that should be all we need to do for the settings what I'm going to do is I'm going to take my requirements.txt file now and I'm going to place that inside of the backend directory and just leave the environment variable or the environment uh python virtual environment sorry outside of this directory okay so we have our backend directory we've messed with the settings what I want to do now is quickly explain to you how JWT tokens work and then we'll start implementing them here in the rest framework which is the first thing we need to do okay so what is a JWT token we'll actually have an entire video on this so I'll link it here in case you want to watch it but this stands for Json web tokens now the Json web token will act as our permissions or our authentication every time we access a website the idea is we have a front end and the front end is separate from our backend so every time we make a request to the back end the backend needs to know who we are and what we have permiss misss to do so what we'll do is we'll include a token along with our request to the back end and that token can be decoded and understood to represent a certain set of permissions so for example I may sign in as my user Tim that user will be granted a token and then that token will be used with all future requests to tell the backend who's actually interacting with it and what permissions they have now fortunately for us a lot of this difficult logic we don't need to write our s it will already be handled by D Jango but what I want you to understand is that the basic flow goes like this we have some front end and the front end is communicating with the back end it's doing that through a request it will send a request to the back end and then we will receive a response from the back end so let's say we first visit our front end the first thing that we'll need to do is we'll need to get access to a JWT token so we're able to actually interact with the back end and perform some operations now in order order to do that what we will do is we will pass some credentials to our front end so maybe a username or a password or something along those lines the front end will then take those credentials and send it to the back end and it will ask the back end it'll say hey look at these credentials and grant me a token based on these credentials so assuming the username and the password is correct then we will be granted two tokens an access token and a refresh token the access token is what we'll use with all of our requests and the refresh token is what we'll use to refresh the access token now what our front end will do at that time is it will store both the access token and the refresh token now it will store them so it can continue to use them with future requests and we don't have to constantly sign into the application now let's say that we are using this access token and all of a sudden it expires maybe it's been 30 minutes and the token is no longer valid well what the front end will do is it will simply submit the refresh token to a specific route on the back back end and if that refresh token is valid a new access token will be sent back to us we'll store that token and we'll continue using that now the reason we do that is because if an access token were to be leaked we want that access token to expire in a certain amount of time so it can't be used permanently and give someone else access to our account so the concept is we're going to expire the token relatively quickly and we can keep refreshing it and then after our refresh token expires we need to actually sign back into the website alt together to get a new set of refresh and access tokens there's obviously more to this but that's the basic idea behind JWT token authentication and that's what we're going to implement here you'll learn more about it as we go through this example so what we need to do in order to actually Grant an access token is we need to have a set of credentials so the first thing we need to do is figure out a way to create a new user once we can create a new user we can then store their username and their password and we can use their credentials so their username and their their password to log in and access the access token for that user so we're going to go into our API view here and we're going to create a file called serializers if we spell this correctly dop now inside serializers we're going to import a few things we're going to say from Jango do contrib doo do and this is going to be models import the user model so let's Spell import correctly we're then going to say from restore framework import serializers let me zoom in a little bit so we can read this better and what we're going to do now is create something known as a serializer now what Jango does is it uses something known as an OM an omm is an object relational mapping what this does is it Maps python objects to the corresponding code that needs to be executed to make a change in the database so the idea is from the developer perspective we can just write normal python code and D Jango in the back end will automatically handle all of the database operations that need to be performed now where a serializer comes in is that with our API we're going to use something known as Json now Json is Javascript object notation and this is the standard format for communicating with web applications so from our API we're going to be accepting Json data that contains things like the username and the password for a new user we want to make we'll also be returning Json data with information about the response that this API is giving to whoever made a request so what we need to do is create a serializer which is something that can take this python object and convert it into Json data that can be used in the communication with other applications right so it'll allow us to take in some Json data and convert that into the python equivalent code and then vice versa have some python code and convert that into the Json equivalent format so what we're going to do is say class user serializer and this is going to inherit from the serializers do the model serializer now inside of here we're going to say class meta and we're going to specify the model that we want to serialize as the user model the user model is built into D Jango and it well represents a user right within Jango then we're going to say fields are equal to ID username and password now these are all the fields that we want to serialize when we are accepting a new user and when we are returning a new user remember the serializer is used in two different places next we're going to specify extraor quars and this is going to be equal to password colon and then we're going to specify write only equal to true now what this does here if we spell true correctly is it tells D Jango that we want to accept a password when we're creating a new user but we don't want to return the password when we are giving information about a user so that when we specify this as right only it means no one can read what the password is which is intentional okay so now we're going to have another class or sorry not another class we're going to make a function here called create and we're going to take in self and validated uncore data and inside of here we're going to say user is equal to user. objects. creatore user and we're going to pass to this Asis Asis validated data we're then going to return the user now all this is doing is implementing a method that will be called when we want to create a new version of this user in this case to create a new version of the user what we're going to do is we're going to accept the validated data this is data that we have already passed all of the checks that the serializer does for us where it looks for a valid username and looks for a valid password really what will happen is the serializer will look at this model it will look at all of the fields on that model and the ones that we've specified here it will make sure that they are valid and if they're valid it will pass the data here once the data has been passed here it's up to us to actually create the new user to do that we can say the user is equal to user. object.create user and then we pass all of the data what we're doing here is just splitting up the keyword arguments and passing them in as such from a dictionary now you don't need to really understand how that works but that's what's happening and then we return the user okay now that we've done that what we're going to do is go to views.py now inside of views.py we're going to write a simple view that allows us to create a new user so we have the serializer but we still need the view or the path to make this user so we're going to say from Django do contrib do off. models import the user again okay we're then going to say from the rest framework import and this is going to be generics we're then going to say from do serializers the file we just made import the user serializer and then we're going to say from rest framework undor simple J or sorry that's actually incorrect from rest framework. permissions apologies import and this is going to be is authenticated and allow now what we're going to do is make the classbased view that will allow us to implement creating a new user or kind of like a registration form so we're going to say class and this is going to be create userv View and then what we're going to do is inherit from the generics do create API view now this is a generic view that's built into D Jango that will automatically handle creating a new user or creating a new object for us now in order for this to work we need to specify a few values so we're going to say the query reset is equal to user doobs doall we're then going to pass the serializer class which is equal to our user and we're going to say the permission classes are equal to allow any what we're doing here is we're specifying okay here's a list of all of the different objects that we're going to be looking at when we're creating a new one to make sure we don't create a user that already exists this is the serializer class which tells this view what kind of data we need to accept to make a new user so in this case a username and a password and then the permission class specifies who can actually call this in this case we're going to allow anyone even if they're not authenticated to use this view to create a new user okay so that's it for the view now that we've done that we're going to go to urls.py within this backend directory so notice we moved outside of the app directory and we're in that main backend directory inside of here I'm just going to remove all of the comments so it's a little bit cleaner and what we're going to do is configure all of our different URLs so that we kind of link them up and we can go to the correct routs now we need to import a few things here so we're going to say from api. views import and this is going to be the create sorry this needs to be views we're going to say create user view so this is the view we just wrote inside of here we're just importing it over here we're then going to say from the rest framework this time it's going to be simple JWT do views we're going to import the token obtained pair viiew and the token refresh view now let me just save this and format it and let's make this bit smaller so we can read it now what these views are are prebuilt views that allow us to obtain our access and refresh tokens and to refresh the token okay I know it seems a little bit strange but they're already built for us and now that we've implemented what we need to do which is creating a new user once the user is created we can use these prebuilt views to obtain the token for that user and to effectively sign them in now we're going to write a few paths here these paths are URLs that we can go to uh that will call a specific function or do some type of operation so the first one we're going to have is API SL userregister and make sure you always include the trailing slash here now this is going to call the create userview do asore View and we're going to give this a name and we'll say this is register so that means when we go to this route right here it's going to call that view that we just created and it's going to allow us to make a new user we then are going to implement the view for actually getting our token now that's already built for us but we just need to link it up so we're going to say API SL token slash and then this is going to be the token obtain pairview do ascore view sorry and then name name is equal to and we'll say getor token you can name these whatever you want it doesn't really matter what you have here next we're going to have the view for refreshing the token so we're going to say API SL token SL refresh and this is going to be the token refresh view. as View and then the name will just be equal to refresh okay we're almost done we're now going to do another path and this path is going to be the API Das off view okay make sure you have your trailing SL and this is going to Simply include all of the URLs from the restore framework. URLs and we need to just import the include function from here where it says Django dols okay so those are all the URLs we currently need what we've done is we've linked our register view we've linked our token obtain pair viw and our token refresh view we've also linked all of the prebuilt uh URLs that we need from the rest framework you don't have to worry too much about those okay so at this point we have mostly everything done to actually start working with this uh and seeing how it works so what we're going to do is we're going to bring up our terminal let's clear all of this and we're going to start by making some migrations on our database now whenever you start a new jangle project or you make any significant changes that involve the data model what you need to do is run some migrations so the first thing you'll do is type python manage.py and then this is going to be make migrations now what make migrations will do is it will create the file that specifies the M migrations that need to be performed so that's what we're going to do to start and it probably will say that we don't have any migrations but let's see what it says here if it runs so yeah it says no changes detected so that's fine but I just want to show you that this is the process now once you've made the migrations you need to actually migrate so it's kind of two steps you're making the migrations and then you're actually apply Ling the migrations and the way you apply them is by using the migrate command so we're going to go ahead and hit enter and you'll notice that it will migrate and make all of these changes and really what this will do is provision the database so that it has the correct tables and everything set up so whenever you connect to a new database you want to do those same steps again so you're provisioning the new database so now that that's set up we can run our application now to run our application we'll type Python manage.py and then run server Okay so let's do that and you should see that the server starts running and it tells you the URL it's running on so what we can do is open that up I'm just going to bring it over to my other screen here and you'll notice that right away we get this kind of 404 not found it's just because we haven't gone to any of the roots that we've defined so what we can do now is Define or go to those roots so we're going to go to the off or sorry the API SL userregister root and when we do that what is the issue here did I spell something correctly uh user got unexpected keyword arguments context all right so I've found the error here kind of a silly one under my serializer class here for my create user view this should say user serializer not user so let's save that now and go back to where we were before and refresh and notice now it brings us to the correct page okay so let's look at this going to go into HTML form and what I can do is pass a username and password and create a new user so let's begin doing that and then we can see how we sign in as that user and get the access token all right so I just created a new user here and what we'll do once the user is created is we'll go to the rout that is API token now it's going to bring us to this page where will ask us to pass our credentials and once we pass our credentials it will give us our access token so let me type in my credentials and then let's get the token okay so I'm going to to go ahead and hit on post here and you'll notice now that what it gives me is a refresh token and an access token now this is what our front end would store and then it would use this access token with every request that it sends in order to actually access the different protected Roots so that's the idea here but I'll show you that if I copy this access token and I now go to the refresh route you'll see that what I can do is pass my refresh token and post and when I do this uh oh it says token is wrong type maybe it's because it started with the space or something I'm not sure exactly why we're getting that issue with the refresh token maybe it's just based on how I'm calling it here but idea is that this should have given us a new access token uh not this issue all right so I just went back and I realized I had copied the wrong token so now when I paste in the refresh token it gives me a new access token and all is working okay so those are the main routes right we wanted to have the ability to get the tokens to refresh the token to create a new user now that we have these written what we want to do is start writing some roots for our authenticated users so now that we have the ability to authenticate them using these tokens we want to give them the ability to for example create a new note delete note something along those lines I know it seems simple but trust me this is what we need to understand so we know how to connect data to authenticated users so let's go back to vs code and let's start writing what we need for creating different notes so I'm going to clear this here and shut down the server and what we're going to do now is we're going to make a new model inside of API models.py now this model will be for our note so let's write that out so inside here what I'm going to do is I'm going to say from Django do contrib doo. models I'm going to import the user model I'm now going to make a new class called notes we can zoom in on this a little bit and this is going to be a model so we're going to say that this is models. model now as I said before Jango uses an OM an object relational mapping so what I'll do is I'll write out the model definition in Python and then jeno can automatically handle converting this into the correct database code so what we do here inside of models is we Define the python version of our models which specify the type of fields we want to store on this model or in this data or table whatever you want to refer to it as and then Jango automatically map it for us and add the corresponding table rows Etc in our database so we're going to have a note and for our note we want the following we want to have a title and the title is going to be models. character field and we're going to specify the max length of the title which is equal to 100 next we're going to have some content and the content will be equal to a models. text field and we're not going to specify any minimum or maximum length we'll just let them put as much text as they want next we're going to have a created at field and created at is going to be models. time field and inside here we're going to have Auto uncore nowor add equal to True next we're going to have our author and the author is going to be the models. foreign key we'll talk about this in a second and this is going to reference our user and we're going to have undelete equal to models. Cascade in the related name equal to notes okay lastly let's zoom out so we can read all of this we're going to Define anore uncore string uncore uncore method and we're simply going to return the self. tile okay let's quickly talk about what we just did here specifically with the forign key well first we added the title maximum length of 100 content is just a text field that makes sense created at models. dat Time Field when we add this argument right here it tells it that we don't want to be passing this we want it to just automatically populate whenever we make a new version or a new instance of this note then we have our author now the author is specifying who made this note whenever we have that well we can use something known as a foreign key now a foreign key can link something like a user because that's what it is in this case with some data that belongs to that user now we can use foreign keys in a lot of different sit situations but we want to link different pieces of data together in this case I want each user to have a collection of notes and I want there to be one user that can potentially have many different notes now this is known as a on to many relationship so what I do is for my author I say that this is going to be a model Stop forign Key when we specify forign key that's indicating that we're going to be linking with some other data source in this case it's the user then we specify the on delete now what on delete means is if I were to delete this user so the thing that's being referenced what should we do well models. Cascade simply says that we should also delete all of the notes that this user has that's all it's doing then as the related name this tells us what field name we want to put on the user that references all of its notes so from my user object I'll now be able to actually access the notes and notes will give me all of these note objects that the user has created okay so that's how we link data with a user we use a foreign key there's a lot more about foreign keys that you can learn I actually have all kinds of other Jango videos on my channel that go through foreign keys and more advanced relationships but for now we're just going to stick with this okay so now that we have our model created we're going to make a serializer for this model because remember this is an API and we need to be able to convert this into Json data so that we can receive it and we can return it so we're going to go up to the top here and we're going to say from models import the note then we're going to make our serializer this is going to be the note serializer okay if we could spell this correctly and this is going to be serializers doth model serializer we're then going to specify our meta class here and inside here we're going to say the model is equal to the note and then we're going to say our fields are equal to ID title content and then created at and author and for our extraor quarks we're going to pass author okay so let's specify this and this is going to say read only true now what that tells us is actually the opposite of what we did here for our user serializer which says hey we should be able to read who the author is but we shouldn't be able to write who the author is the reason we're doing that is because we'll manually set who the author is based on who creates this note we don't want someone to be able to tell us who the author is so if I'm signed in and I'm authenticated and I make the note well then I become the author so we're specifying it as read only which means we can't write it we can just read what it is okay so I know it's a bit weird but we want to make sure that for certain fields we do that so that we can see them but we can't set them or we can set them but we can't see them and in this case author is one of those where we want that to be set by the back end not by someone just deciding who the author should be okay so now that we have our serializer and our model we're going to go into views and we're going to make some views for creating a note and for deleting a note now first let's import the note so to do that we're going to say from Models import note now we're also going to import the note serializer in the same line here as our user serializer now let's go above and let's make a view for creating a new note now to do that we'll say class note list create okay and this is going to be generic. listc create API view what we're going to do in here is the following we're going to specify our serializer class which is going to be equal to the note serializer and our permission classes which will be equal to and this is going to be is authenticated now what this says is that you cannot call this rout unless you're authenticated and you pass a valid JWT token perfect now notice that we're using list create view not just create the reason for that is that this view will actually do two things it will list all of the notes that the user has created or it will create a new note so there's two functions here so first thing we're going to do is specify a method called get query set now that's not what I wanted but I want to return learn from here and we're going to write up here that our user is equal to self. request. user now this is really nice but in Jango if we want to get the user that is actually authenticated and that is interacting with this route all we have to do inside of our class based views is we write self. request. user and that's going to give us the user object so it says abstract base user or Anonymous user don't worry about that but it's going to give us the correct user because we are actually authenticated we can then use that user to filter our notes and just get any of the notes that were ridden by this user so if we wanted to get all of the notes we would just do note doobs doall but if we want to get all of the notes that are written by a specific user we instead pass filter and then we pass the author equal to the user now this needs to be the lowercase user story and what that does is filter by this field now we could filter by all kinds of other fields as well right like I could filter by the title equal to something specific if I wanted to do that but in this case we do the author filter and that effectively is just going to get us all of the notes written by this user okay so that's why I've written get query set rather than having query set specified here because I need access to the request object with specifies the user so that I can then filter all of the notes by that user this also means that your only able to view the notes that were written by you you can't view notes that were written by someone else okay next we're going to have a perform create and this is going to take in self and the serializer now this is just because we want to do some custom uh kind of configuration here when we create a new user so we're overriding the create method okay so all these generic views you can just leave them as is and as long as you specify a serial izer Class A permission class and a query set it's automatically going to work and it will let you create list Etc whatever it specifies here but if you want some custom functionality which we need you need to override specific methods and in this case we need to override the get query set and the perform create now how do you know that well you do have to reference the Django documentation because there's no way you can memorize all of this stuff and even myself I don't have this memorized like I'm looking off of some premade notes because there's no way I would memorize this when I was originally writing it out I had to go look at the python or sorry the Django documentation to know what it is I had to do here okay so what we're going to do is we're going to say if the serializer do isore valid then we're going to say serializer dove and we're going to pass the author equal to the self. request. user otherwise we're simply going to print the serializer . errors okay so what is this what are we doing here how does this work well serializer itself so this class when we pass to it different data it will tell us if it's valid or not now what happens automatically in these generic list views is any data that's required to create the note will be accepted it will be passed into the serializer that we've written here and the serializer will check against all of the different fields on the model and make sure that the data is accurate so we'll check that the title is not above the maximum length for example we'll check that we have some content that we have a date whatever right it'll check all the things that we need so what we're doing here is we're getting access to that serializer object and we need to manually check if it's valid so we say okay if this is valid if the serializer passed all of the checks with the data that was passed to create a new version of the note what we'll do is we'll save the serializer and when we save the serializer it will make a new version of the note and anything we pass here will be an additional field that will add onto that note so in this case we're adding the author because remember in the serializer we specified that the author was read only so it won't be passed into us we have to manually add that ourself which is what we're doing okay so that is how we create a note now let's do a view for deleting a note which is a little bit easier so we're going to say class note delete and this will be generics do destroy API view now inside here we're going to specify the query set and this will be equal to note doobs doall we're then going to say the serializer class is equal to the note serializer we're going to say the permission classes are equal to is authenticated and actually I realized that we don't need to specify the query set we're just going to go down here and we're going to say Define get query set and it's actually going to be the exact same as this one so we're just going to copy this and paste it here because similar to up here we want to make sure that you can only delete notes that you own so the query set of notes that we allowed to delete are simply ones that are within this filtered list so sorry we don't need to specify the query set manually we just specify the method here okay so works the exact same as the note list create but this time there's nothing special we need to do we just specify okay here are the valid notes that you could delete and then we'll what we'll actually do sorry is we'll specify a note we want to delete and it will automatically delete it for us if we're authenticated which is what we need to be so now that we have these views what we need to do is we need to set up some URLs for them but this time I'm going to set up the URLs in this API folder so I'm going to make a new file called urls.py and inside urls.py I'm going to say URL patterns is equal to an empty list now here we need to write the different URL patterns and we'll actually forward URLs from the main application to here so at the top of my code I'm going to say from Django do URLs import path I'm then going to say from dot import views now inside URL patterns I'm going to specify two paths the first path will be for viewing or creating our notes so we're just going to say notes slash and this is going to go to the Views Dot and this is going to be the note list create. as view we are then going to have the name equal to the note list we're then going to have another path and inside this path we're going to say notes slash delete slash and then this is going to be int colon PK which stands for primary key and then this is going to be views. note delete. as View and the name can be delete note okay so now we have our uh URL story here for the notes okay so for creating and listing and for deleting now what we need to do is link the URLs from our main URLs file into this file so we're going to go to urls.py within our backend which is where we wrote the URLs before and we're going to make a link so that we forward specific URLs over to this file where they're then handled from this app so the way we do that is we specify a path and inside the path we're going to say API slash and then we're going to include and this is going to be the api. URLs now when we do that what we're saying is okay whenever we go to something that has API slash and it wasn't one of the ones above we're going to take the remainder of the path so what comes after the slash and we're going to forward that to this file api. URLs which is right here now inside of here we'll parse the rest of the path and if it matches anything here we'll handle it and we'll go to the views that we wrote within this app now you may be asking yourself why didn't we write the create user view in this same manner right like inside of URL patterns well we could have done that here inside of the app but I wanted to keep all of the different Roots related to our authentication and registration in the same place so that's why I did it the way that I did it here there's all different types of ways to link URLs but I wanted to kind of show you both of them so that's why we're doing there okay so that's really going to wrap up most the backend code but obviously want to check if this is working so let's go ahead and run our code but before we do that we need to make a migration to our database because we've made a major change the data model so we're going to say python manage.py make migrations okay so you can see that it says we've now made a new migration which is creating the model note we now need to actually migrate so let's go ahead and migrate and you'll see that this works okay now we're going to run our code so python manage.py run server and we're going to test this out so let's open up this view okay so I need to actually go over here and I guess we already have it open so let's just refresh okay continue that's fine and let's go and get our token so we're going to go to slash token here let me pass in some credentials so I get a token okay so I have a token I'm going to copy the access token I'm now going to go to slash API SL notes so you'll notice here that we're getting this error saying authentication credentials were not provided now this is actually good it means this is working properly and the reason it's working is because we didn't actually pass the token when we sent the request to this route in order to uh view the different notes now we're not going to be able to pass that token without doing some things that are a little bit more advanced so what we're actually going to do is just write the front end and you'll see in the front end how we pass that token and actually are able to create the notes for now just trust me this does work if you wanted to test it out you could remove the authentication so if we go here you could go to what is it views.py and you could just remove this and make it to allow any instead then you would be able to access that route the issue is though that you wouldn't have a user because you wouldn't be passing the correct access token so just bear with me here guys that's going to wrap up the back end now what we're going to do is go over and write the front end all right so now we are moving on and we are working on the front end now this is going to be in react so what I've done is a just opened up that same directory that we were in before but I've got into the base directory so I'm no longer in that backend uh directory now what we're going to do is use vit to create a new react project to do that I'm going to do npm create this is going to be vit at latest and then front end d template react and this is going to create a frontend directory which is going to have react installed so let's go ahead and hit enter and that should make it for us let's go yes let's install that and now we need to install a few different packages so let's go to CD front end and we're going to install the various packages that we need so we're going to type npm install and we're going to install axios for using our Network requests we're going to install react router Dom and then we're going to install JWT dcode these are the three packages that we need here so let's install all three of those let's give those a second and once they're finished I'll be right back all right so I realized that I typed in the wrong thing for react router Dom so let's fix that I'm not sure how I made that mistake there uh but it says it can't find what is it react react Dom yeah it's cuz that's not a package we need react rotor domom so let's fix that and install and hopefully it we'll be good now okay looks like we are good to go so now we can go inside of our front end directory and we can start creating some different files now I'm not going to lie to you there is a fair amount of code here but as always I'm going to walk through it step by by step and if you want to copy anything you can just do that from the GitHub repository which is linked in the description okay so what we're going to do is go inside of SRC here and we're just going to start organizing this directory a little bit first of all we're going to delete these CSS files so let's get rid of those because we don't need them we're going to go into assets uh that's actually fine there we'll go into app.jsx and we'll just remove everything inside of the body here of this component and we'll get rid of this okay and we'll get rid of all three of those Imports and the import to app.css we're just going to import react from react here okay just so we don't get any errors all right now we'll go into main. jsx we're going to remove the import to index.css because we don't need that and we're going to create a few directories in here where we'll organize our code now the first directory is going to be Pages the next directory is going to be Styles and the last one is going to be components okay so this is where we're going to organize all of our different code now we're going to create a few other files here we're going to make a constants if we can spell this correctly do JS and we're going to make an api.js we're also going to make an environment variable file inside of the front end directory so we're going to type EnV like that okay so we have our EnV we then have our new directories components pages and styles we have our constants file and we have our api.js file now let's go into constants to start I just need to define a few constants that we'll use inside of API so let's write these constants out we're going to say export const and this is going to be accessor token and this is just simply going to be equal to access and then we're going to say export const and this is going to be refresh unor token and this is going to be equal to refresh now the reason why I'm putting these here is that we're going to use local storage to store the access token and the refresh token in our browser and I want to have a key that I can use to access in my local storage and that's what this key is going to be so I'm going to use these constants here to access the access token and the refresh token okay so now that we have that we're going to go inside of api.js I just want to hook up the more complex stuff to start and then we can start writing all of the components now the idea in this api.js file is that what I'm going to do is I'm going to write something known as an Interceptor now an Interceptor will essentially intercept any request that we're going to send and it will automatically add the correct headers so that we don't need to manually write it a bunch of different times repetitively in our code now we're going to be using something known as axios axios is a really clean way to send Network requests that's pretty easy to use uh so we're going to set up something called an axios Interceptor where anytime we send a request it's going to check if we have an access token and if we do it will auto automatically added to that request so we don't need to think about it once we write this code once so we're going to say import aios from axios okay we're then going to say import the access token from our constants now what we're going to do is we're going to get the API so we're going to say const API is equal to axios do create and inside of create we're going to pass an object and the object is going to specify spey the base URL which is going to be equal to import. meta env. Vore apiurl okay now this might seem confusing but what this allows us to do is import anything that's specified inside an environment variable file now if we want to have an environment variable loaded inside of our uh what do you call it JavaScript code here our react code it needs to start with V so the IDE a here is that we're going to have this in an environment variable so that it's really easy for us to load and change what the URL should be so what I'm going to do is I'm going to go to myv file and inside of here I'm going to specify that same thing so Vore API URL and we're just going to make this equal to http colon Local Host colon 8000 okay now we can change that later if we need to but this should be the URL of our backend server obviously it's running right now but when we start running it then this will be the correct one okay so since that's in there this is how you import that environment variable importa env. vapi URL and we're specifying that as the base URL so when I start using this API here all I need to do is specify the path I want to access I don't need to specify the base URL now what I'm going to do is I'm going to say api. interceptors and this is going to be request. use now inside of here it's going to take a function so we're going to write an arrow function like so now inside of this function we're going to accept the config and what we're going to do is look in our local storage and see if we have an access token if we do we're going to add that as an authorization header to our request otherwise there's nothing that we need to do because we don't have a header so I'm going to say const token is equal to local storage. getet item and I'm going to try to get the item with the key access token we'll set this later but for now we're just going to try to get it we're going to say if we have a token then what we'll do is say config do headers do authorization is equal to and then we're going to use back ticks here and we're going to say Bearer and then we're going to embed the token like so now this is how you pass a JWT access token you simply create an authorization header which can automatically be handled for us by axios which is why we're using it and it needs to start with Bearer then you have a space and then you have what the actual token is now this is how you embed a string inside of another string or yeah I guess that's what we're doing right we use backticks and then we can embed a variable here inside of the string okay so that is if this is successful and then we need to return config now we're just going to have another function here which is called error and if there's an error all we're going to do is say return promise. reject and we're going to reject with the error okay now don't worry about this too much this error function the main thing that we want to be looking at here is adding this authorization header that's automatically going to happen in all our requests so now what we're going to do is say export default API so we're going to export this object that we've just added this Interceptor on and from now on we're actually going to use this API object rather than using axios by default uh to send all of our different requests so the authorization token will automatically be added for us okay so now that we've done that we actually need a way to get our token right and also to protect our different roots on the front end as well as on the back end now the order I'm going to do this might seem a little bit weird but you just need to bear with me because there's a lot of code that needs to be written before any of this will actually be testable because of the security that we have on our back end so I'm going to go inside of my components here I'm going to make a new component called protected root. jsx okay now this is going to represent a wrapper for or a protected route and the idea is if we wrap something in protected rout then we need to have an authorization token before we'll be able to actually access this route so what I'm going to do is the following I'm going to say import navigate from react router Dom I'm then going to import the JWT dcode from and this is going to be JWT D decode I'm then going to import API from and this is going to be dot slash or actually dot do slash API okay and I'm going to import the refresh token and the access token from my constants now what I'm going to do is I'm going to take my function and I'm going to say function protected root and inside of here we're going to take in children now this is what will be wrapped and then for our protected route we're going to do a few different things here now the basic idea is we need to check if we are authorized before we allow someone to access this route otherwise we just need to redirect them and tell them they need to log in before they can view this now theoretically someone could uh bypass this because it's all frontend code but the concept is I don't want to allow someone to go to a route on the front end they shouldn't be able to access until they've logged in so I'm writing my own kind of custom front end protection here just to make this a little bit cleaner so what I'm going to do is I'm going to write a const here and I'm going to say this is is authorized and then set is authorized uh if we could spell this correctly and this is going to be equal to use state which we're going to import from react and by default this is going to be null okay then what we're going to do is we're going to write two functions the first function is is going to be refresh token okay which is going to be an async function all right and what this is going to do is refresh the access token for us automatically we're then going to have an O function which is also going to be async which is going to check if we need to refresh the token or if we are good to go okay so down here before I Implement these functions I'm just going to say something where I say if is authorized is equal to null then what I'm going to do is return a div and this div is just going to say loading dot dot dot the reason for this is that until this has some State that's not null I'm loading and I'm just checking the tokens or I'm potentially refreshing them okay otherwise I'm going to return is authorized question mark So if we are authorized so if that's true then we're going to return whatever the children were that we wrapped otherwise we're going to return a component called navig and this is going to go two equals and it's going to go to the login rout so 2/ login now this is a root or this is a component are that we can use from react router Dom as soon as this is rendered it's just going to automatically navigate us to the login page I know we haven't implemented all of the routing yet uh but this is what it will do once we implement the routing then down here I'm going to say export default and this is going to be the protected route okay so we're going to go inside of our off function now and the IDE aidea inside of oth is to first look at our access token see if we have one and if we have one check if it's expired or not now if it's expired we want to just automatically refresh the token so that the user doesn't have to worry about anything and it just happens by itself in the background that's what this function will do now if we cannot refresh the token or it's expired then what we'll do is just say hey no you're not you're not authorized and you need to log in again by going to that login route so the first thing we're going to check is if you have the token so we're going to say const token is equal to local storage. getet item and we're going to access the item with the access token we're then going to say if not token then what we'll do is we'll say set is authorized to false and we will return okay now if we do have the token then what we can do is decode the token and we can get what the expiration date is so to do that we can say const decoded is equal to JW dcode and then take in the token now this is automatically going to decode it for us and give us access to the value and the expiration date so I'm going to say const token expiration is equal to decoded. okay which stands for expiration I'm now going to get today's date I'm going to say con now is equal to date. now and I'm going to divide this by a th so I get the date in seconds not in milliseconds now what I'm going to do is I'm going to say if the token expiration is less than now which would mean it's already expired I'm going to say await refresh token otherwise I'm going to say set is authorized and this is going to be true now the reason I can set it equal to True is because if the token is not yet expired that means that it's valid and we're good to just simply say that yes it's authorized we're good to go okay now what we'll do is we go write the refresh token and then we actually need to call these functions so inside of refresh token we're going to say const refresh token is equal to local storage. getet item and we're going to get the refresh token I'm then going to do a try catch block here so let's write the catch to start so we're going to catch some error and we'll just say set is authorized and then false and we can just console.log the error here okay now inside of the try what I'm going to do is I'm going to send a request to my backend with my refresh token to get a new access token so I'm going to say const res standing for response is equal to await api. poost and I'm going to post to/ API SL token SL refresh don't forget the trailing slash otherwise this won't work and then as the payload I'm going to pass refresh equal to my refresh token now let's just format this so it's a little bit easier to read okay so here what we're doing right is we're saying let's get the refresh token and then we're going to try to send a response to this route with the refresh token which will should give us a new access token so what we'll do here now is we'll say if res. status is equal to 200 meaning it was successful we're going to say local storage. set item we're going to set the new access token to be equal to the res. dat. access okay because that's what's going to contain the access token we're then going to say set is authorized to True otherwise we're going to say set is authorized to false okay so that's how the refresh token function works we get the refresh token we send it to the back end notice we're using api. poost when I do that it's automatically going to handle the base URL for me so I just need to pass if we go back here the route that I want to access which is this I passed my refresh token if the response status code is 200 that means it's successful and I did get back an access token so I will change or I will set sorry the new access token as the access token in local storage so I can use it when I now send requests then I set is authorized to True otherwise I set it to false because for some reason there was an error here and we didn't get a new access token okay last thing we need to do here is we're going to write a use effect so we're going to say const actually we're going to say use effect up here to import that and we're going to say use effect like this we're going to implement our function and all we're going to do is we're going to say off so we're going to call this function and we're just going to catch in case there's any errors so we're going to say off. catch and if there is an error we're going to say set is author ized to false okay so the idea is as soon as we load a protected route we're going to try to do this right where we call the off function we see if we have a token if we do have a token and it's not expired we can simply set authorized to true if it is expired we need to refresh the token so we'll wait for that to happen and then as soon as the token is refreshed and we're authorized we'll be able to access that route if we are not able to access the rout or we're unauthorized then we're going to return the navigate component back to login okay let's zoom out a bit so you can kind of read some of it I'll just slowly scroll through it of course you can also copy this directly from the GitHub okay so that is our protected root component now what we're going to do is we're going to stub some pages that we're going to need and we're going to set up the navigation for our application so I'm going to make a few different components I'm going to say login. jsx I'm going to say register. jsx I'm going to I'm going to say home so let's do this. jsx what else do we need and I'm going to do not found. jsx okay now inside of each of these I'm just going to stub a component so I'm going to say const home let's zoom in a bit okay or actually let's just make it function let say function home like that and then we will export default home and from home we can just return some div that says home let's copy that and let's go into login and let's just change home here to be login okay obviously we're going to fill in these components later but I just need to have some of them right now for my navigation for this one it'll be not found so this is like a 404 page okay so we're going to do not found and then not found and then lastly register this is going to say register register and register okay so now that we have our four pages let me make this bigger so we can see it and close all of these what we're going to do is we're going to go to our app.jsx and we're going to write the navigation essentially so how we go between the different pages using react router Dom so let's start importing a few things we need again the idea is that this is the root of our application and we want to be able to navigate between different pages by going to a different address in the URL bar so that's what I'm going to show you how to implement so I'm going to say import the browser router import Roots import roots and import navigation from react router Dom I am then going to import the login component from this is going to be dot slash and this is going to be Pages /login we are then going to import the register component from do SL Pages SL register I'm then going to import the home component from the same thing pages slome and we're going to import the not found component from do/ Pages SL not found okay we also need to import the protected rout so we're going to say import protected root from SL components SL protected root okay now we're going to write two very simple functions one for logging us out so I'm going to say function log out and all log out is going to do is as soon as we call it it's going to say local storage. CLE so as as soon as we log out we're going to clear our refresh token and our access token and we're just going to return a navigate so let's do this and this is going to be two so let's write two equals slash login okay and navigate we need to import that so do we have that imported sorry this needs to be navigate not navigation okay so that is our log out function and then we're going to import one more function or write one more function and this is going to be register and log out okay and what this is going to do is it is going to say local storage. CLE then this is going to return simply the register component now the reason why I'm writing this is that if someone is registering I first want to clear the local storage so that I don't end up submitting access tokens to the register route where I could potentially get an error so we just need to make sure that when we are registering we first clear the local storage so we don't have any old access tokens lingering around I know it seems a bit strange but it's just something that we need to do in order for this to work properly okay now what we want to do is we want to set up this app component so we can navigate between our different pages so to do that we're going to return the browser router okay this is a component from react router. now inside of here we need to specify Roots so we're going to say roots and inside of here we can put all of our different roots that we want to navigate between so let's begin by specifying the home root so we're going to say root this is going to be a selfcontained component and inside of here we're going to say the path is equal to this so just the standard path if you go to just the normal path this is where it'll bring it to and the element that we want to render here is going to be the following now this is going to be the protected roote and then inside of the protected roote we are going to render home so the point is that you cannot access the home component unless unless you have the access token and it's valid because you shouldn't be able to access that because home is for people that are logged in and authenticated so that's how this works right we're wrapping the component that we want to be protected with protected root and you can use protected root for any component that you want so now we're going to do another rout and let's end it like this the path for this one this time will be slash login and this element that we're going to render is going to be the login page okay okay now that's not protected you can go to that no matter what now let's copy this and do the same thing for register okay but the element we're going to go to this time is going to be the component we wrote so register and log out right the one that's going to log us out first by removing the tokens and then we're going to have another rout this is going to be path equal to and we're just going to put in asteris and if you go to any other path we're going to render the element which is equal to the not found Route which is going to be like a 404 page okay so what we're doing is we're looking first starting at the very first route so we're saying okay is it the normal path if it is go to home if it's login go to login if it's register go to register if it is anything else go to the 404 not found page okay that's going to handle all of our routing now we can actually test if this routing is working so to do that we're going to bring up our code here notice we're inside of the front end directory and we're going to type npm and actually I believe we are going to need to install uh okay no actually that seem to work that's fine and then we're going to type npm run Dev now when we type npm run Dev that's going to run the development server for us what we can do now is we can open it up let me just bring it over to the other page and you'll see that we go to login by default if I try to go to home notice it's redirecting me to login because it is a protected route and we don't have our access token now let's see what happens if we go to register brings us to register and if we go to something like some random string it brings us to not found okay so that's working so let's go ahead and shut this down and start writing some more of our components okay so first component that I think is pretty easy to get out of the way is the 404 or the not found component so let's write that one so for this all we can do in here is just remove that and we can go with an H1 tag and we could say 404 not found and then we can go with ap and we can say the page you're looking for does not exist okay like that that's fine and maybe we'll do doesn't exist okay so that's good for the not found page next what I actually want to write is I want to write a generic form that can be used by our register and by our login page and I also realized here that we didn't implement the logout route so let's quickly do that so we're just going to write another one here and just change this to say log out and we'll go to log out okay so sorry just add that one I just forgot that right there okay so as I was saying what I want to do is I want to make a form this form will just collect a username or password and then submit it to either the register route or to the login route now we can just write one form and we can just kind of make it a bit dynamic so it works for both registering and logging in because for our registration it's the exact same process as logging in right just a username and password it'll be the same for both so what I'm going to do is go to components and I'm going to make a form. jsx so inside here let's import a few things that we need we're going to say import use state from react we're going to say import API from do/ API I'm going to say import and this is going to be use navigate from react router Dom okay this a hook that we can use to actually access the navigation from code I then am going to import the access token okay come on give it to me and the refresh token from our constants and I am going to actually for now that's it okay we're now going to write a function this is a form and we're going to take in two props the props that we're going to take in our root and our method okay now the root is the rout that we want to go to when we submit the form so it could be the token route or it could be the register route and the method is just telling us okay are we registering or are we logging in the idea is this form will work again for both logging in and registering and this is the dynamic props that we'll pass to specify what it should be used for so in terms of the state we're going to need to store the username and the password that the user is typing in so we're going to say con username uh what is it comma set username is equal to use State and this will be an empty string we're then going to say const password and then set password is equal to use State and this will be an empty string and then we'll do one more piece of state to just keep track of if we're loading or not so we're going to say con loading set loading is equal to use State and this will be false to start we're then going to say const navigate is equal to use navigate and we'll call that hook okay now what we want to do is just write a basic form so we're going to say return and we're going to return a form now the form is going to have on submit okay and this is going to call a function and the function it's going to call is handle submit so we can stub that function right now we can say cost handle submit is equal to a function and instead of here we're going to take in E and we're going to say e. prevent default now what this will do is prevent us from actually submitting the form and it will kind of remove the default Behavior so we won't reload the page because we don't want to reload the page here when we're doing that okay so now that we've made the form I'm just going to add a class to this because we're going to style it in a second so I'm going to say class name is the form container and then inside the form we'll write our different elements so first things first we're going to write an H1 tag and we're actually going to look at what the method is that's passed as the prop now we're going to say if the method is equal to login then we're just going to uh render login as the text inside of here otherwise we're going to Lo uh render register sorry okay so this is just giving us the name and in fact what we can do just to make this a little bit cleaner is we can say const name is equal to and we can copy this and paste this here and then we can just render the name inside of here so the idea is we're just getting the name that we should put for the title of the form okay so if it's login then do login otherwise do register so method will be either equal to login or register okay now we're going to have some input fields for the username and the password so we're going to say input okay and for the first input we'll specify the class name equal to and this can be the form D input then we can do type is equal to text we can do the value is equal to username and on change is equal to and then we're going to take in a function here and this is going to be e and then set username so let's spell that correctly and this is going to be e. Target doval okay lastly we'll have a placeholder and this will be equal to username okay so this is one of our input Fields again form input type text value username so this means that anytime we make a change here we take in the variable e we're then saying set us us name and then whatever we typed we're just going to adjust and set that in the state so that we'll be able to access that when we actually submit the form now we're going to copy this and we'll just do similar thing here for the password so we're going to change this from type text to type password we're going to change the value to be password we're going to change set username to be set password and we're going to change the placeholder to be password okay almost done last thing we want to do now is add the button cuz we need a button to submit so for the class name of this button it will just be the formb button and the type of this will be submit and then inside of the button we're just going to put the name that we have from up here so it'll either say login or register depending on the method that we pass to this form okay we can zoom out a little bit so it's a bit easier to read and that's it for the actual uh jsx or uh what do you call it word rendering on the screen let me just format this and now let's write our handle submit method so when we submit the form the first thing we'll do is we'll set loading equal to True okay let's zoom in so we can see this a bit and then after that we're going to attempt to send a request to whatever root it is that this form is representing so we're either going to try to log in or we're going to try to register so what we'll do is we'll set up a TR catch because this could fail okay and we're going to make this an Asing function as well okay so we're going to catch error if we have an error we're just going to alert what the error is so it'll just show it on screen and then we're going to add a finally block and we're going to say set loading false so no matter what happens we're going to try to send the request if there's an error we'll catch it and whether it worked or it didn't work we're just going to set loading equal to false because eventually we'll have a loading indicator here and we want to obviously like turn that off right and let me just fix this a little bit okay so inside of our try we're going to send a request so to send the request we're going to say const res is equal to await api. poost and we're going to post to the root that was passed into the form we then are going to pass a username and a password so this is it it's going to use the API that we wrote it's going to send a post request to whatever the route is pass the username and password we're going to wait until we get that back and we're going to check the following we're going to say if method is equal to login then what we're going to do is say local storage. set item and we're going to set the access token to the res. dat. access and we're going to say local storage do set item and we're going to set the refresh token to be res. dat. refresh okay so the idea is we're going to send this request if an error occurs it'll be handled here in the catch if there's no error that occurs then we're going to check if the method was log in if it was that means that we need to get the access token and the refresh token and we need to set them okay then we are going to navigate to the slash login or sorry not to the SL login to the SL page so we're going to use the navigate function that we have here and just navigate to home so we'll be able to view our notes which you'll see in a second otherwise we are going to navigate to/ login the reason for this is that if it wasn't login it must have been register if it was register there's no tokens that we need to set in order to get the tokens we actually need to log in with our new registered account okay so that's our form again we can kind of zoom out a little bit so you can read it a little bit better now there's some more things that we'll do here later on but for now I just want to apply The Styling and then I want to actually go to these elements and test out and see if they're working so for the styling I'm going to make a new style sheet here in Styles and I'm going to call this form. CSS now what I'm going to do is just copy in the Styles I'm not going to write them out because I think that's kind of a waste of time so I'm going to paste in all of the Styles here if you want these Styles you can simply have them from the GitHub repository that is linked in the description okay so you can just go find them from the for. CSS file and just paste them in your own file or you can just cop the entire file right whatever you want to do anyways I've read them in here in order for these styles to be applied though we do need to import that file so we're going to say import do do Styles form. CSS okay just so that we'll have some nice styling last thing we need to do is we need to export this component so we're going to say export default form and now that we have exported the form we can start using it so now that we have the form component we're going to use that from the login and from the register component component and it's going to be pretty straightforward but all we'll do from login here is we'll start by importing the form so we're going to say import form from dot slash or dot dot slash if we can do two dots components SL form and then rather than returning this div we're just going to return the form component but we're going to pass two props to it now when we're logging in or sorry when we're registering the route that we want to go to is API slash userregister again make sure you have that trailing slash then the method is going to be equal to register okay so that's it that's all we need to do we're just setting the rout that we want to send the request to and we're specifying the name or the method which is register now we can copy this same thing and we can go to login and for login we need to import the form again so we're going to say import let's zoom in uh form from do do/ components SL form this time for login the root is going to be API SL token slash and the method is going to be to log in okay so now we should be using this for both the login and the register route and we can check if we are by clearing and going to npm runev so now if we open this up let me just bring this over so we can see it because it keeps opening on my other screen you see that we have a login field and if I go to slash register we have the register form now the main thing to check here is if the token is actually going to be working however before we can do that we need to make sure that the back end is running so what I want to do now is I want to split my terminal here I want to CD into the backend directory and I want to run my app so I'm going to say python manage.py run server all you need to do here is get in the backend directory and just run the server like you normally would okay so we're going to run this now and let's just check where it's running right so HTP 1.7.0 point0 point1 Co in 8000 I'm going to copy that and I'm going to go to my environment variable and I'm just going to paste it inside of here just so it's exactly what we had before and actually I think I got to remove that trailing slash otherwise we might get an error okay I'm just going to shut down my V server and I'm just going to rerun it to make sure it reloads the environment variable and now I have my back end running and my front end and technically we should be sending requests now to the back end so let's test that out so what I'm going to do from register is I'm going to say newcore user and let's go with a password like 1 2 3 4 5 and I'm just going to open up the inspect window here in my console so I can see what's happening so let's click on register and notice that it redirected me to log in now if we want to see if that's working we can go to our back end and we'll see that a post request was actually sent here and even shows us what the options were username new user password here I don't know if maybe I printed that out or something I'm not sure if that's supposed to show us regardless you can see the post was successful with 2011 it immediately redirected us to login so now I can try to log in so I'm going to go new user then 1 2 3 45 log in and notice it brings me to home so I can access home even though it's a protected route because now I have my access token and if we go back here and we look uh where is it we have a post to token and you can see we have a status code of 200 working successfully okay so we're able to communicate no cores errors everything is good and let's see what happens uh actually I guess there's not much more that I can check I mean I can go to login okay it brings me there and I can go back to home because I still have the access token but you'll notice now if I go to SL logout it's going to redirect me to login and if I try to go back to home it doesn't let me go there because I'm no longer authorized because I've logged out so I would need to log in again newcore user okay and then it will bring me to home and I'm good to go all right so there you go we're making really really good progress now now that we've done that we want to start writing the homepage so we can actually start making some notes and our application can actually do something so we're able to log in we're able to register the form is built I would say the hard part is done and now we need to start actually interacting with our notes so that's going to involve writing some code inside of the homepage here so let's start doing that so from our homepage what we want to be able to do here is view all of the notes that we have and then create new notes and delete notes so let's go through those operations one at a time we're going to start by importing a few things so I'm going to say import and we're going to import use State and use effect from react okay and we're going to import our API from dot do/ API okay now inside of home let's start with the state that we need so we're going to need to keep track of all of the notes that we have that we've already grabbed from the server because the first thing we'll do when we load this page is we'll send an authorized request to get all of the notes that we've created so let's do that first we're going to say con notes set notes is equal to use State and this will be an empty array we then need some State for the form that will be on this page that allows us to create a new note now I'm going to do it all in this component we could put it in a separate component if we wanted it to be cleaner but in this case I'm just going to have some State for the content and for the title of my note so I'm going to say con content set content is equal to use State this will be an empty string I'm then going to say const and this is going to be title set title is equal to use State and this is going to be an empty string and now what we're going to do is write a few different functions that will send some requests so I am going to write all of the HTML obviously in a second but I want to show you how we send the request to for example get all of the notes that this user has written so we're going to write a function called get notes now this can be written like this and what this is going to do is say API doget and we're just going to call the/ Api SL notes root notice I have my trailing slash okay now if you weren't sure how you would figure out what this route is in the back end remember if we go to API and URLs we have these different roots that we've written right we have the notes rout and we have notes / delete now the reason I'm prefixing this with API is because the way that we forwarded the URLs if we go back into back end here is anything that had API and wasn't one of these roots up here got forwarded to the other API roots that we have here so that's why I know that that's the correct route hopefully that's helpful but the idea is we've ridden all of these paths in our back end and now we're going to access them from our front end okay so I have api. getet SL API notes slash that's going to give me all the notes this user has written so I'm going to have a then and I'm going to say res and I'm going to return my res. data I'm then going to have another dot then and inside of here I'm going to have my data and I'm going to say set notes equal to whatever the data is now let me just format this so it looks a little bit nicer okay then we're going to have a catch in case there's an error and if there is an error we're just going to alert the error on screen okay and let me format this so that we get it looking nicer okay so there we go that's our get note function that will get all of the notes for us and really this should be get notes so what we can do is we can write a use effect and this use effect can simply call the get note function sorry as soon as we visit this page and then what we can do is inside of the then we can just console.log what the notes are so console.log and this will be the data just so that we can see what it is uh when we load this component okay so before we go much further let's actually just see if this request works so let's open up our terminal here let's go back to our front end and let's refresh and notice that you see we get an empty list here okay so we're getting the empty list the reason why we're getting the empty list is because well there's no notes that we've created and if we go back here you can see that it's sending the request to SL API sln notes perfect okay so let's bring that down and then let's continue writing our code so now that we have get notes let's have a way to delete notes notes and to create notes now to delete a note we're going to say const delete note and we need to take in the ID of the note that we want to delete then what we'll do is we'll say api. delete because the request is delete this time we're going to use some back Texs and we're going to say SL API sln notes SL delete slash and we're going to pass inside of here the ID of the note that we want to remove we're then going to say do then and we're going to get the response and we're going to check the status code of the response so we're going to say if res. status is equal to 204 which means we successfully deleted it then we're going to have an alert and we'll say note was deleted okay otherwise we're going to say alert and then failed if we do this failed to delete note like that okay then we're going to have a catch and for the catch we're going to catch an error and we're going to alert whatever that error is on screen and then I'm just going to call the get notes function this is not the most optimal way to do this but the idea is if we just deleted a note then it means that our notes have changed so I want to show that update on the screen so we'll just call get notes again and then that will actually update the screen by removing the notes when we receive the new notes from our backend really what we should be doing is on the front end just removing it from this list but I don't want to write that JavaScript to do the removal so we're just going to do it like this okay so I'm just going to format this again so it's a little bit easier to read and now we need to write our last function before we get into the HTML which is creating our notes so to create our notes we're going to say const create note and we're going to take in some value e because this is going to come from a form and we're going to say e do prevent and then default okay we're then going to say api. poost and we're going to post to SL API SL notes okay so the same one that we use to get our results but this time we're not using get we're using post and what we'll do is we'll pass the content and the title of the note we want to create then similarly to before we're going to take in the response here in the do then and we're going to say if the response. status is equal to 200 or sorry to 20 one which means we created the note we're going to say alert and then note if we can do this created okay otherwise there was an error so we're going to say alert and then failed to make note okay then we need a do catch same thing if we have an error so we'll say error like this then we are going to alert the error and then lastly we're going to do the same thing we're going to say get notes like that okay and let's Zoom back in and format and now we have our create note function okay so we have create note delete note and get notes now we need to write the HTML okay so for our HTML we kind of have two main components here the first part is just displaying all of our notes and the second part is going to be a bit of a form to create a note so for displaying our not notes we'll just make a div here and we're going to say H2 and then notes then inside of here we're actually going to render all of our notes however I'm going to write a separate component that will display the notes so for right now we're just going to leave that empty we're now going to come down here though and we're going to make a form and this form is create a note okay so we're going to write a form and this needs to be in lowercase the form is going to have an onsubmit and the onsubmit is going to be equal to the create note function now inside of the form we're going to write our different elements so we're going to have a label this is going to be HTML 4 equal to the title and this is going to say title colon where then going to have a Brak line and we're going to have an input field for the input we're going to say type is equal to text we're going to say the ID is equal to the title we're going to say the the name is equal to the title and we're going to say required and then onchange is going to be equal to and this is going to be e and then set like this set title and then e. target. Val don't worry I'm going to save it so we can actually see what it looks like okay so this is the input type equals text ID title name title on change we'll also set the value equal to the title perfect okay so that's the first part now we need the same thing but for the content so I'm just going to copy this and paste this down here and change this to say content and then this will say content and then we're going to use a text area this time so it's a little bit larger so we're going to say text area and inside of text area we're going to say ID is equal to content we're going to say name is equal to content we're going to say required we're going to say value is equal to content and we're going to say onchange is equal to and then this is going to be a function where we take in E let's save this or actually it's it's just going to work right now okay let's go there so it's going to be function e and then this is going to be set content e. target. value okay I no this a lot we're almost done we're now going to have another brake line and then beneath this we're going to have an input and this is going to be type equal to submit and we'll say the value is equal to submit okay and let's format it nice okay zoom out a bit so we can read it a bit easier you can see that what we're returning here is a big div inside the div we have a first part which will display all of our notes in and then we have a second part here where we are going to create a note when we submit the form it's going to call the create note function which is going to pass the title as well as the content okay uh oh last thing yeah value content okay so that's good all right so I think that's going to complete the homepage other than displaying all of the notes so let's test this out let's make sure our servers are currently running looks like they are we'll come back here and you can see that we have kind of a sketchy little uh form here we'll fix that in a second but for now let's see if we can make a new note so we're going to say test note and then test content and submit and it says the note was created and if I refresh here you can see now that we have a new note okay so it says author is id2 content test content created at ID title perfect that is working okay now we did have an issue though where when I created the note it didn't update right away so I just want to see why that was the case I think it's because we need to put the get note notes inside of the then yes that's going to make sense so we'll put that inside of then and we're going to do that for all of the places where we created it so we're going to take this and put it here okay perfect so that should fix that for us and now we want to start displaying the different notes and we also want to style this page a bit we'll do the styling after first we're going to make a new component inside of the components directory called note. jsx okay this is going to represent one single note and we'll just use this to render all of our notes really easily so we're going to say import react from react we're then going to make a function called note now the note is just going to take in the note itself and a function which is on delete and we're going to return um some jsx here or some HTML so we're going to have a div the class name of this is going to be the note container okay we're then going to have a P tag this is going to have a class name equal to the note title this is going to be note. tile we're going to have another P tag this is going to say class name is equal to and this is going to be the note and content and then you guessed it this is going to be the note do content we're then going to have another P tag and this is going to be class name equal to the note date and then what we're going to do is pass in a value here which I'll put in in a second and then we're going to have a button and this button is going to have a class name equal to delete button and it's going to have an onclick equal to and we're going to call the on delete function so we're going to have a function that calls on delete delete and passes the note. ID and then here this will say delete okay let's format this so we can read it nice so what we're doing right is we're rendering the container inside of here we're going to have the title the content we're going to put the date here which I'm going to do in a second and then we have the delete button which will call the on delete function that we pass as a prop with the ID of the note which is what we'll need to actually delete the note so that's why we wrap this with another function so we can pass this uh argument here into the function so now I'm just going to make a variable I'm going to say const formatted date is equal to new date and I'm going to take in the note. created at and I'm just going to convert this to a local date string in enus now what this is going to do is just strip off all the parts that we don't need to see like the time zone and it's just going to tell us what the date was when we actually created this string so it's just going to give us a nicely formatted date essentially I know I said that kind of backwards it's just going to make the date look nicer that's all it's doing now you can do all kinds of formatting for it but that's fine for now so we're going to pass the formatted date here where we were kind of missing that value now that we have this note component we can use it inside of the home page so to do that where we have notes here we're going to start rendering all of our note components so to render our note components we're going to render some code here and we're going to say notes map and we're going to map each one of our notes and we're going to show the note component so we're going to say note the note is going to be equal to the note on delete is going to be equal to and then this is going to be the delete note function so it will call that with the ID we're then going to say the key is equal to the note. ID just so we don't get that error that we so commonly see where it says hey we need a key on all of our dynamically rendered elements so let's format this again and there we go okay so we're rendering notes however we need to import note so let's do that from the top of our program we can say import notes from dot do/ component slote okay we're almost done here so let's bring this up and let's test this now so we're going to come here and refresh and it gives an an error here sorry it says Source comp components note. jsx does not provide exported named default okay let's fix that error so we're going to go back to note and we need to export this so we're going to say export default notes all right so let's go back to our front end and we can see now that the note is appearing if I refresh it works and I can delete it and notice it goes away now let's add a little bit of styling here and then that's going to pretty much wrap up the front end and then we can move on to the deployment okay so let's begin by styling the note to do that we'll just go to Styles we'll make a new one called note. CSS and while while while we are here excuse me I will do home. CSS and we're going to add a component called loading indicator so I'm just going to add that while we're here okay I'm going to go to note. CSS I'm just going to copy in all of the code again you can find this from the GitHub repository I don't like just writing a bunch of CSS in a video I find it's not very useful okay so that's for note for home let's copy in this okay again all this available from the GitHub and then loading indicator let me copy in this code paste it and format it okay so that is that for the Styles now we need to import it so from home. jsx we're going to import our Styles so we're going to import do/ stylehome docss now let's go to the same thing for our what is this note okay and we'll import note. CSS okay let's go back here now and you can see that looks quite a bit nicer and now we can do hey what is up submit that note created and you see the note pops up we have our date delete button Etc okay last thing to do is add a loading indicator so for example if we go to slash log out in the logi when I press login I want to see a login kind of loading indicator when we are loading so to do that we're going to make a new component so inside of components we're going to say loading indicator like that do jsx we've already got the CSS written for it but now we're just going to write the component which is very straightforward so we're going to say import do do/ Styles SL loading indicator if we can type this indic indicator. CSS okay we're then going to say const loading indicator and this is going to be actually we make this as an arrow function okay then we're just going to return here a div for the div we're going to say class name is equal to loading container and then we're going to have a div and this is going to be class name is equal to loader and then we're just going to export default the loading indicator okay now we can use this anywhere that we want so we're going to go to our form and let me just make this a bit smaller inside of our form in between the last input and the button we're just going to write some conditional rendering here so we're going to say loading and and and then the loading indicator like that and we just need to make sure we import the loading indicator from the loading indic indicator component sorry so pretty straightforward we're just going to show the loading indicator when we're loading and then the CSS that I wrote um inside of the loading indicator file here will automatically do like the nice animation for us so if we go back here now you should see it kind of pops up here right while we're waiting for this Okay click okay and there you go the loading indicator component has now been written so with that said guys that is going to wrap up the front end at this point now we have the front and finished we have the backend finished everything is working on Local Host The Next Step here is going to be to deploy a database connect to the database and then we're going to deploy both the back end and the front end using coreo so let's go ahead and do that starting with our database all right so now that the front end and the back end are finished we're going to be deploying our database now as a reminder we're going to be using Coro to do that this is completely free they're also the ones that are running that challenge for the Cyber truck or the $100,000 so really follow along with these steps here if you want to make sure that you're eligible to enter that so what we're going to have to do here is go to the Coro website I'm leave a link to it in the description once you're here you got to create a new account or log into an existing one I'm going to do that please do that and then we'll be brought to a portal and I'll kind of show you how we create the database all right so once you sign into your Coro account you will be brought to the dashboard now from here you can do a lot of stuff and you can actually create a project but the first thing we want to do is just create the database integration after that we're going to make a project within that project we're going to create some components we're going to have our back end and our front end and we're going to use Coro to actually link these two together this is a really cool platform it's actually really fast to be able to spin up and deploy different applications best part is it's free when you're in the developer tier and obviously you can upgrade if you wanted to do more production ready deployments okay so what we're going to do is go to the dependencies tab on the left hand side of the screen and we're going to click on databases now it's going to bring us to this page right here and what we can do is we can create a new database now I'm just going to delete the one that I already have because I can only have one going at a time and this is going to act as a trial database uh it's not really meant to be production ready but it's just allowing you to mess with the features and try it out so it's a good thing to get some practice on how we actually deploy regular databases and how we connect to them from D Jango so what I'm going to do is create a new database I'm going to select post Christ SQL and for the name I'm just going to call this database you can call it whatever you want but make sure you select postris okay now you're only going to have one option here for the hosting the reason for that is because this is kind of like a free trial demo database under the developer tier so you can see you can try it out for free for seven days and then you'd have to recreate it if you wanted to keep using it so I'm going to go United States digital ocean and hobbyist plan here it says 3 cents per hour but don't worry you don't have to pay for it it is free and then it's going to create this service now it'll take a few minutes to spin up the database and one thing to know is that this is a trial database so it's going to be powered off every every hour so what that would mean is if it if it is powered off sory you got to come back here and just power it on manually but for development purposes this is totally fine so while this spins up what we're going to do is copy all of the values that we have here into an environment variable file in our uh what do you call this backend kind of python script or backend python project so let's set that up while this is creating so I'm going to go back here and I'm just going to close all of this and we're going to open up our backend directory and we're going to go to just the main kind of root directory here and we're going to create an EnV file so we're going to say dot EnV for the EnV file we're going to specify a few variables and then we're going to use the values from this page here as those values so the first variable we need is going to be our dbor host we're then going to have our dbor Port okay we're then going to have our dbor user and our dbor name and our password dbor PWD okay so now we're just going to take all the values from here and we're going to copy them into the corresponding variables so let's copy the host to start we're going to put a set of quotes and paste that in here for the port this is going to be 21510 so let's paste that over here for the user it's going to be this let's make sure we put that inside of quotes here and for the name it's going to be default DB and then we'll need to wait for the service to be created before we have access to the password and actually I'm just going to surround this in quotes because that's what I have in my demo project so I don't want to mess anything up okay so let's wait for this to finish it's going to give us the password we can click to view it and then we'll put it in the environment variable file and we'll be good to move on to the next steps all right so the service has been created here and I just copied the password and put it in my environment variable file now that we've created the database what we want to do is connect to it from D Jango and then we can provision it using pythons manage.py or what exists here inside of D Jango and then we can just use our application like we normally would except this time will'll be connected to a remote database so in order to do that we need to go into backend settings.py and we're going to go to the databases so where it says databases here what we're going to do is change a bunch of these things so where it says engine we're going to change the engine to be Jango in low lower case. DB doback ends. postgis SQL like that then for the name this is going to be the environment variable which is os. getet EnV and we're going to get the DB name now the reason why this works is because at the very top of our code we load in our environment variable file and we have all those variables in the EnV file so make sure they're there for this to work okay so now that we have the name the next thing that we need is the user so we're going to say the user is equal to os. getv and this is going to be the dbor user we then need the password the password is going to be os. getet EnV and this is going to be the dbor PWD for password we then are going to have the host and the host is going to be os. get EnV and this is going to be the host or the dbor host I should say and then lastly we need the port and the port is going to be os. getet en EnV and then dvore Port okay and let's make sure we have our commas so that's it that will configure our database so now that we have all of our environment variables loaded in we can actually connect to the database what we need to do now is let's bring up our terminal I'm going to stop running the back end here so let's stop that and for some reason I think we were getting an error where it was saying that this was typed wrong it was okay so I just spelled that incorrectly so let me fix that quickly and now what we're going to do is type Python manage.py and then migrate what this is going to do is connect to that remote database you're going to notice this will take quite a bit longer because we actually need to connect over the Internet we're not connecting locally so once this is finished I'll be right back okay so this code just finished running so now what we can do is type python manage.py and then run server and now our server will be running just like before and what we can do is we can go back here and we can start using our app as we normally would so now we're going to be in a new database so we'll need to make any accounts again so I'll make an account set the password okay you're going to notice it will take longer now because again we're connecting to that remote database not the local one so let's try to sign into our account okay log in let's wait and it should bring us to the homepage there you go we have the homepage and we could go and we could make our notes so now we're just connected to the remote database if we want to see the logs we can go and view it we can see metrics advanced settings all kinds of stuff here uh very useful and also super super easy to use if we want we can also gate access based on IPS all kinds of settings you can mess with here so now that we've deployed the database it's time to deploy the back end now to deploy the back end we first need to actually set up a git repository because Coro will be able to view the git repository read it and actually automatically respond to new commits and do automatic deployments and all kinds of cool stuff so we're going to go over to our code here and we're going to start setting this up to work for a git repository now to do that we're going to create a new file so we're going to make a new file called G ignore okay inside of the G ignore we're going to ignore the environment variable directory because or the environment uh what do you call it python virtual environment directory because we don't need that we're then going to go to front end and we're going to go to our get ignore and we're just going to add the EnV file because we don't want to include that in the git repo and we're going to go to backend and we're going to make a git ignore and inside backend we're going to ignore the EnV and the db. sqlite3 uh which we want to ignore as well okay now that we've done that we're just going to make a few deployment related files inside of our backend directory and and then we'll upload this to GitHub so we're going to start by doing a Coro folder now inside of Coro we're going to make a new file and this is going to be endpoints do yaml now this is where we're going to specify the endpoints that we want to deploy and then we want to expose from this specific component which is the back end now Coro obviously will look inside of this do Coro folder to find this configuration so we're going to write here the version which is 0. .1 we're then going to specify our end points now for the end points we're going to specify a name the name can just be rest API doesn't really matter what you call it and now we're going to specify a few other things so we're going to do the port the port is going to be 8,000 the context is going to be a single forward slash the type is going to be rest and the network visibility is going to be public now this is a basic configuration that Coro is going to look for when we're deploying a rest API the port obviously needs to match the port of our D Jango API which is 8,000 type of course is going to be rest because this is a rest API when we set the network visibility to public that means anyone will be able to view this we also could specify it as project or organization and then for the context this is the base path of the API that we want to expose in this case I just want to expose the entire one so I'm going with Slash okay and that's what you guys will use as well obviously there's a lot of details for this in the documentation on the Coro website you guys can check that out if you want to learn more about how to set up these configurations especially for something a bit more advanced now we also need to make one more file this will be the last one that we need to do and this is called the proc file and the proc file is going to specify the command to start executing our application and that command is going to be web colon and then python manage. pi and then run server and then it's going to be 0.0.0.0 Port 8,000 okay so exactly what we would normally do to execute our server except this time we're doing 0.0.0.0 which means run on any origin or on the public IP address of the server that we're executing on so this way it'll be public and anyone will be able to access it perfect so that's it for uh the kind of configuration now what we need to do is add this to GitHub so we're going to make a new git repository with the command get anit we're going to type G add Dot and then get commit hyphen M and then first commit okay so we just make a commit we are then going to change the branch so we're going to type git Branch hyphen M and then main this is going to change the branch from Master to main which we need to do when we push to get we're going to clear this and we're going to go over to get make a new remote repo and then add here and push this code to GitHub so I'm on GitHub here and I've just made a new repo called Django react full stack app it's important that we make this public because in the developer tier for Coro we can only have public repositories we're not going to add a read me we already have the repository set up we just need to add the origin and then push our code so we're just going to take this Command right here which is get remote add origin and we're going to move over here and paste this in our terminal okay we're then going to push this so get push origin and then Main and this will push all of the code to the remote repo so we can then start setting up our deployment okay so let's go back here and let's refresh we'll see here when we refresh we get all of our code popping up now what we can do is go back here to Coro and we can go to the overview tab so now that all of this is set up on GitHub we're going to create a new project in Coro now to do that you can go to the overview Tab and then click on create project or you can go up here here and make a new project so I'm going to click on create project I'm going to call this D Jango react tutorial and I'm going to use the mono repo because we just have one repo that contains all of our project code so we're going to go next and we're going to authorize this with GitHub now you're going to have to go through a few steps here to authorize it it's very straightforward just give it access to your repos then what you're going to need to do is go to the GitHub repository and select the one you want so in my case it's Jango react full stack app now here you can select the branch I've selected main cuz that's the only branch that I have but you could set up a separate deployment branch and that would probably be a good idea so let's go next and notice that it's actually automatically going to detect our different components now I want to show you how we manually create them so I'm just going to click on create for now it's going to go ahead and make the new project and then we can add the components ourself so let's go ahead and do that the first thing we're going to do is add a new service the service is going to be for our rest API so I'm going to click on service here and for the component name I am going to go with the back end and for the description we'll just leave it empty and I'm going to select python as my build pack now for the python directory I'm going to select backend okay and for the language version I'm going to go with 3.10 so let's go ahead and click create and notice there's a bunch of other services you could make here okay so Coro is going to automatically go ahead and make this backend service for us and while it does that I'm going to create the frontend service now for the front end service we're going to go with a web application for the name this is going to be the front end and for the build pack this is going to be react now for the project directory this is going to be the front end okay and for the build command this is going to be npm install and npm run built we're then going to have the build path as/ D this is where the output file will go when we actually build this application then for the node version we're going to go with 20.0 you can go with any version you want really I think as long as it's high enough but 20.0 should be fine okay so that should be good that's going to create the front end component for us and now what we'll need to do is build each of these components and then deploy them now there's a few other steps as well obviously but this is pretty straightforward and it's actually pretty impressive how fast we can get this deployed out okay so let's go back to our back end we can do that by just selecting the service up here and from our back end we're going to go to the build tab now you'll notice that there's a bunch of other tabs here right like usage insights observability devops testing the API deploying managing right it's got everything you can imagine now what we can do is build latest or we can view the different commits and we can build a specific commit in our case we just want to build latest so we're going to click on build latest we're going to wait for a little bit it should build the latest version of this and then we can go ahead and deploy it and we can test the API all right so the build has just completed and now what we'll do is go over to deployment now from deployment we can deploy the build you also will have noticed from the build tab we have the option to Auto deploy if we enable that as soon as a build is finished or actually as soon as a new commit is made on our Branch it will automatically build it and then deploy it now you can see that what we can do here is configure and deploy so if I click on this it gives me the option to actually Mount some environment variables now that's what I'll do now because remember we need to pass the environment variables for our database configuration so what we can do is add a bunch of environment variables in this case it's just allowing us to do one so I'm actually going to do it another way I'm just going to click on next we have the option to file Mount uh endpoint details here this is fine we can go ahead and deploy that and once this first version is deployed it's going to give us the option to configure some secrets so I'm going to click on manage config in secrets and here I'm going to click on Create and then I'm going to going to go secret and environment variable now the reason this is secret is because I don't want anyone to be able to view this once it's been created this is going to be the data to connect to my database now what we'll do here is just add the different environment variables that we need that match what we had in our local repo I'm going to call this EnV and then what I'm going to do is go back to my code here I'm going to go find my environment variable file which is this and I'm going to copy all of these values over so let me do that and I'll be right back all right so I've added all of these values and notice that I'm not used quotation marks for any of them I'm just adding them as plain text inside of here I have my host Port user name and password the exact same as I had from the environment variable file in my local repository what I'm going to do now is press on create this is going to add the environment variables as Secrets now if you want to edit them you'll have to actually read all of the values because you can't view the contents anymore we'll go back to deploy and within deploy now it should automatically redeploy with those environment variables so now what will happen is our API will be deployed if we want to view the end points we can view them right here we can see the project URL and the public URL however the public URL is automatically going to be protected from coreo now the way that this works is that Coro is automatically going to add an API key that we need to pass in order to access this URL so if I just try to go to the URL in fact I can do that just to show you you'll notice that it's not going to work so if I go to the public URL and I paste it in here it's just going to tell me hey like you don't have the correct security credentials to be able to view this now that's intentional because Coro will automatically protect your apis for you and if you want to disable the protection which is what we're going to do you need to do that manually so what we're going to go to now is the settings page within manage sorry for the quick cut here but I do need to quickly jump in because the website has changed a little bit since I filmed this video so I just want to show you quickly how to get to the correct page page so that none of you are lost so in the video what you're going to see me do is go to this manage Tab and then for manage go to settings now that's no longer available and instead what you're going to need to do is go to the deploy Tab and then simply click on endpoint configurations from this point forward all of the settings and all of the instructions I give you are the same simply do them from this page rather than the page you're seeing in this video now from here what we're going to do is change the API visibility to be public now we want this to be public so that anyone can access this API and use it to interact with our application now as well as that we're going to go and press on edit now from edit we're going to change some of the settings here by disabling the application Level security Now this tells you exactly what it does this option determines the type of security that will be used to secure the API an API can be secured with either ooth or any other available security type or it can be secured with both of them if oo 2 option is selected relevant API will require a valid oo 2 token for successful in if so we want to disable that because we already have our JWT tokens and for this example it's going to be a little bit complex to have this enabled so what we'll do is disable this and press on Save when we do that what's going to happen now is that when we try to access the API we will actually be able to send a request to it whereas before we would need to pass an API token and that would add kind of some more code changes which I don't want to make at this point because we've already done quite a few changes so now that we've changed our settings what we're going to do is go back to the deploy Tab and if you haven't already just redeploy the API to make sure the new settings are applied now we can go view the endpoints and if we take the public URL and we paste it in here we can see if this is working or not or if we get any issues now in this case it just says bad request which is fine because it means we were actually able to access the API but what happened was we didn't have a security um what do you call it issue like we had before right so here we just access a route that didn't exist but if I go to something like / API SL token we can see if that one's going to load and in this case it gave us some connection error which tells me there's probably some issue with the database connection so let's actually go check that quickly the way we can do that is we can go to observability and we can go to metrics and we can actually see all of the logs for what's happening with our application so let's go here give it a second to load and see what we're getting we can also see the throughput the latency and some other issues or not other issues other stats I guess which are meaningful okay so when we go here it just says that we're not able to connect to the database so what most likely happened is the database just turned off because it's been an hour so let me return the database back on and in fact I'll show you how we do that so what I can do is get out of this project go to dependencies databases and we'll see if that was the culprit and it was you can see the database is powered off so what I'm going to do is just power on this service it's going to take a second to power back on and we'll go back into our application so Jango re act tutorial we'll just give it a minute to power back on we'll go into our components we'll go into our backend and we'll just redeploy this as soon as the database is powered back on and we should be good to go and uh actually able to well interact with the application and the API all right so the database is powered back on so let's just redeploy our app here to make sure that everything is all good we'll wait for that to finish and then what we can do is go to the endpoint and we can test this again just to see if everything is functioning now assuming the back end is working then the next step is to deploy the front end once we have the front end deployed we just need to connect it to the back end and once the two are connected we'll have a fully deployed application and you'll actually have a project that you can submit to the Coro wso2 challenge to potentially win the cybertruck don't forget about that so now our back end has been successfully deployed and it's time to move on to the front end so what we're going to do is make a new component we're going to go to the front end component I should say and from the front front end now we're going to go to build we're going to build the latest version of our front end and once this is built we're going to check out the front end then we're going to connect it to the back end so the front end has been built we could enable auto deploy if we want but I'm just going to go over to deploy and now we will deploy this now there's a few settings that we need to change first of all so we're going to go to authentication settings and we're going to disable the managed authentication with Coro as I talked about before we're not using the authentication for this specific app however if you were building this from the ground up and you wanted to use the authentication from Coro obviously you would enable this and they have some really good documentation that shows you how to handle off using the Coro platform they can do user authentication they can do application Level authentication it's very interesting so I definitely recommend checking it out but just for this app since the whole point was to look at JWT tokens in Django we don't need this feature so I'm going to click on deploy and now that we've disabled that it's going to deploy this it's going to take a second and once this has been deployed we should see the front end working so let's click on this web app URL uh and we're getting a not found error okay so let's give it a second here because it probably just needs a minute to spin up let's go to it again and not found okay let me look at the issue here and I will be right back all right so I just had to deploy the app and wait a second and there we go we now see that we have our front end and this is deployed we can go to register if we try to go to something that doesn't exist we'll get that not found page we can go back to register here but you'll notice that if I try to actually use this to make a new account it's not going to work now and the reason it doesn't work is because we're not connected to the back end so let's now go with the connection and then that we'll wrap up this video so in order to make the connection here what we need to do is go to dependencies and then connections now what Coro can do which is really interesting is actually deploy our backend on the same origin as our front end or at least allow us to make the request on the same origin so that we don't need to be interacting with something that's outside of this origin which is actually quite useful for a lot of applications so you're going to see that I clicked on create there and what I'm going to do is use my backend rest API so I'm going to go backend rest API here going to select that we'll just call this backend as the connection name and click on create now that we've done this you're going to see a bunch of instructions on the right hand side for how to do this action now this is if you were using the authentication handled by coreo in our case we are not so we don't need to follow the steps on the right hand side but if you are again check out these steps the authentication is a very useful feature especially if you don't build it in yourself like we have with Jango so what we're going to do here is copy this service URL now this service URL is hosted on the same domain as our front end which means we can send requests to this and then whatever we add afterwards is the API route that will be be redirected to so the way that we're going to do this is we're going to go back to our repository here I'm just going to close all of this and I'm going to go to my front end directory and to api.js now all I'm going to do is I'm going to say const API URL is equal to and I'm going to paste this root in here now notice I'm not putting a different domain I'm just putting the path that will Bey on the same domain now what I'm going to do is I'm going to look for the presence of this environment variable file if it exists I'm going to use what's inside of there otherwise I'm going to use the API URL now let me just format this so it's a bit easier to read so what this will do now is it will use this when we're in the deployed environment which is the connection that we need to our backend so what we can do now is we can make a new commit so we can say get add Dot and then get commit hyphen M add backend URL and then we can type get push origin Main and we can make a push now what we'll need to do is just redeploy the front end with this new commit and what will happen is now the front end will make a request to its same origin with this slash URL as the base URL and then it will add the API path afterwards so we'll go to like API SL token or register or whatever the URLs are so that's it that's really all we have to do for the connection it's quite easy I'm pretty impressed with how Coro has been able to handle this and what we can do is go back to build now and we can go to build latest so let's view the commits first of all okay we have the backend URL so let's go with build latest and build that out okay so our front end is now built so let's go back to deploy and let's deploy the new version here okay so that's going to take a second to deploy and once that's finished everything should be good to go fingers crossed obviously things can go wrong but if that's the case we could go and we could check out the logs we can use all of the tools that Coro has built into the platform now let's go to the web URL okay there we go we have V plus react let's go to SL register and make a new account okay so we got to spell register correctly though okay so let's go with new user and then we'll go with a password here okay good sign that's taking a second to load that means it's probably connected to the remote database okay so that account was created so now let's try to log into this okay and then we should be able to view our notes okay so stop telling me to change my password I know it's very weak that's fine so let's make a new note say new note test content let's submit that should take a second here the note should be added then we'll be able to view them delete them Etc now I know there's a little bit of latency it's just because of the database that we're using so it takes a second to make all all of those operations uh but if you're using one that was actually deployed that wasn't kind of the trial or like the temporary test database obviously this would be a lot faster all right so the new note has been added here and we can see that all of the functionality is working properly I guess the last thing we can do is log out and when we do that brings us back to the login page and then we can log in with another account so there you go we now have a fully deployed application completely for free by the way that you could now use to enter this cyber truck giveaway so with that said guys I'm going to wrap up the video here all of this code will be available on GitHub so you can simply download it from the link in the description you can modify it tweak it whatever you need to do a big thank you to Coro for sponsoring this video and for hosting that giveaway make sure you check out the platform more and you enter that giveaway again you have a chance to win a cyber truck or $100,000 and then there's going to be 10 other people that are picked to win a MacBook Pro 14in with a M3 chip wrap it up here guys I hope you enjoyed enjy if you did leave a like subscribe to the channel and I will see you in the next one