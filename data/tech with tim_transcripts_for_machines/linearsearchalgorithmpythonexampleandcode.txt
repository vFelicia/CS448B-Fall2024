hey guys and welcome back to another YouTube video so today I'm going to be starting a new series on my channel and this is gonna be an algorithm series so pretty much in this series I'm gonna go through a series of different algorithms that could be searching algorithms sorting algorithms path finding algorithms you name it and I'm gonna be telling you the complexity of the algorithm and then showing you a an example of it in Python so today I already have this example typed up and we're just gonna be doing the most simple one that I could think of at least today which is the linear search algorithm now what this algorithm does is exactly how its named it pretty much looks through a list Lenard linearly and tries to find an element in it and that if it finds that element it will return the index of that element so I'll show you it working here before I go into how exactly it works and you can see so we've looked for the element 43 in a random list of integers I've created here and we can see we get the index 22 I go to about 22 we should be able to find 43 let's see here three right here and that is at the 22nd index that looks about right so we know that the program is indeed working now the complexity of this algorithm which pretty much means the efficiency of it is simply n so we have the Big O notation of N and that means that in the worst case scenario of this algorithm it will take n meaning the amount of elements in the list time to find that element or that many comparisons for example so I'll give you an example here if I make a list like this and I go 1 4 3 5 6 doesn't really matter what numbers I'm putting here I'm just putting some rounded numbers and say for example we are looking for the element 2 5 we want to know what index element 5 is that obviously it's right here now the way that this algorithm works is it has to look through each element in list so it starts at the beginning and moves to the end without skipping any algorithm so chain any item sorry without swapping any items without removing any items it just looks at every single item so we look at one it's not one it's not four it's not three here we go and we're at five now we return the third indices like that thing with this algorithm is though and the reason has the conflicts D of n is say for example we are looking for the element two well the element two obviously is at the very end of the list we can see that here but the program doesn't know that he has to look through every single element in the list until eventually we find the element two now this is the worst case scenario for this algorithm and in that the last element is the one that we're looking for as it has to look through every single element first now this actually works in the reverse order though what if the element we're looking for is one well we only have to look through one element before we find that element because it's right there so that's obviously gonna be extremely fast and if we get that we're extremely lucky now in most cases for this algorithm the item you're looking for will be near the middle of the list where in that case it's gonna take well half the time so n divided by two I hope that makes sense for how this how this works so let's look in our function here you can ignore this it's just creates a random list and this is it this is the whole algorithm yes I know there's other ways to write this algorithm but this is just the way that I chose just using a simple for loop so pretty much we have a list and we have an element we're gonna look through every element in the list like this and if the elements in the list is equal to the element that we're looking for we're just going to return that into C like that now say we get through the entire list and that element is not in the list then we've just returned negative one now the advantages of this algorithm the first one obviously is it's extremely simple very easy to use only takes up well four or five lines like this the second advantage of it it's good for small data sets so say if you only have like ten elements 20 elements you're trying to find something it's perfectly fine to use this just keep it simple and it also you don't have to have a sorted list so in the next algorithm that I'm going to be showing which is gonna be the binary sort algorithm which is a lot faster than this one for large data sets you already have to have the list sorted before you can do that so that's going to take up some time obviously as you have to have to sort the list so this one is gonna be good to use if you have small lists and yeah so I'll show it show you it working again here click enter we get negative one and that's because 43 wasn't in this list again run it again yeah 1343 should be at that 13 embassy which is right here so obviously we know that this works it's extremely simple so if you guys enjoyed this video and it helped you out please leave me a like and subscribe and if you have any ideas for future videos doesn't even have to be different algorithms just leave a comment down below I'll be sure to respond to you and hopefully make a video on that