if you're watching this video and you write code in python then chances are you're familiar with what a unique language it is and you utilize some of the awesome features that python provides now this is great and python is an awesome language but because it is pretty unique and it's not like a lot of the traditional programming languages there's a lot of ways that you can make mistakes in python without really realizing it python is as i said a unique and kind of quirky language it allows you to do a ton of stuff and it's very flexible but with that flexibility it allows you to make a bunch of mistakes that are really hard to catch if you haven't watched a video like this so with that said let's get into this video and i'm gonna walk you through some mistakes that you're probably making in python and that you can easily fix by going through these tips so the first mistake that i'm sure many of you are making is that you haven't checked out my programming course yet called programming expert i'll leave it in the description this is a unique course that teaches python specifically some more advanced features of python and we recently added go to it as a second language so don't make that mistake check that out from the link in the description but in all seriousness here the first mistake that you're probably making is something called name shadowing now name shadowing occurs when you name your variable parameter function really anything you're defining a name for a builtin function some builtin name or something in the current scope that's already defined so for example here if we have this function called get database record we have a parameter here called id now this is a shadowed name and the reason this is shadowed is because you're naming this a builtin function so in python we actually have a builtin function here called id many people don't know about this function and so they'll do something like this where they write a function and then they name this parameter they give a parameter name of id now you'll notice here when i write id i'm getting the syntax highlighting as if it was a function because that's what python knows to do but this is not going to be treated as a function it's going to be treated as the parameter so that is the intended behavior when we're looking at a function like this but it can be really confusing if you're familiar with the builtin functions and you have kind of a long function or a long class or something like that when you're reading shadowed names so really you want to avoid name shadowing as much as you can and one of the only ways to do that in python is just to ensure that you're not naming your parameters functions etc a builtin name so something like id uh maybe something like max that's a really common one something like min you want to avoid those names because again they are built in functions and if you do name something that in the current scope so in this function you can no longer use this as the function so if i try to do something like id here let's just call this function so get database record let's pass in one notice it says the int object is not callable because i've overridden the id function by shadowing its name now this can occur when you have nested functions as well and all and in all kinds of other scenarios another really common thing here is when you shadow a name from the global scope so for example if i make my parameter here named database or i accept maybe like id and database like that again if you have a longer function it can be confusing when i'm reading this code if i'm referring to the database parameter if i spelled that correctly or the database variable in the global scope so obviously this isn't always avoidable the main thing here is just don't name your parameters or variables a builtin name like max min id not only because it's confusing but because you also now make it so you can no longer use those functions inside of wherever you've given that name so another mistake that you are likely unintentionally making in python is using a mutable object as the default value for an optional parameter now i know that's a mouthful but if you look here at this function it's called mutable parameter and we have an optional parameter we know it's optional because we have it assigned to a default value if you don't pass it it gets the default value and the default value is a mutable object which is a list now let me show you why this is bad by running the code so when i run the code we actually get an unexpected output if you're from another programming language where we get one two one two one two and then one two one two one two now the reason this occurs is because this is mutable that means we can actually mutate it we can change it in place so when i do something like lst.pen1 and lst.pen2 i'm actually mutating this list right here which is the same list that's going to be the default value for the next call to this function so you can see on every consecutive call we're actually adding elements to this same list this list does not get recreated every single time the function is called it gets created one time when we define the function that's the way that the the default value works here so if you want to avoid this and you do want to actually have a mutable value or immutable object as your default parameter you should do something like this instead and then manually check inside of the function if this is none so i'm going to say if lst is none then i will say lst is equal to and make that a list so now if i run this notice we don't get that error anymore because i'm recreating a new list object every function call as a post using the same one that's only created one time when my program is actually kind of initialized in the function is read by the interpreter hopefully that makes a bit of sense try not to make this issue or try not to make this mistake this also happens if you use dictionaries if you use sets and any other mutable object so the next mistake i have here is a more general one this could apply to any programming language and this is modifying an iterable object while you're iterating through it so in this case i have something that's iterable which is a list just means i can loop through it right using a for loop in this case and i have 4i comma value in a numerator list so it's going to give me the value as well as the index of each element and i'm saying if the index is divisible by 2 then i'm going to pop this index from my list now if you're looking at this here and you just kind of take all the indices and apply this to it we should be popping one we should be popping three because that's index two we should be popping five that's index four popping seven and then popping nine however when i run this notice that i get kind of a weird result i get two 235689 kind of strange why i'm getting that but the reason is because i'm modifying this iterable object while i'm looping through it so if i have a look here and i print out i value and actually let's not print out value let's print out i and lst and let's have a look at it at every iteration we see i zero and then one two three four five all the way up until six and what happens is we don't actually end up iterating through every unique element in the list because we're popping it as we go and the enumerate function works a little bit differently than the range function in python and to show you this let's do another example so let's change this now to say 4i and this is going to be in range and then this will be the len of lst so you would imagine we just get the exact same result here but when i run this notice now we get pop index out of range well the issue here is that we're reducing the length of the list while we're iterating through it and the range function has kind of a constant range that we're going to be iterating through so as soon as i define that i'm going to iterate through the range of 0 to 9 that doesn't change the whole time i'm going through this for loop so even if i modify the length of the list this hasn't changed because i put a constant value here whereas when we have the enumerate this will actually change based on the length of the list and again that's why you get that weird result so that's what i wanted to share with you don't do this it causes a lot of headaches only do this if you really understand what you're doing if you want to make a modification to a list while you're iterating through it usually what i like to do is store the modifications i want to make somewhere else iterate through the list entirely one time and then run a for loop and just make those specific iterations that i want to hopefully that makes a bit of sense but that is mistake number three so the next mistake i have to share with you is one that is super tricky to figure out if you've never seen this before and this is called name clashing now this happens when you name your python file which we're going to refer to as a module here the name of a builtin module in python or a thirdparty module that you've installed using something like pip so looking at this example here i have a little script where i import pi game pi game is a third party python module i installed this on my system and this lets me build 2d games you guys have probably seen this on my channel before anyways i have pi game now when i run this i get an error and it says this is most likely due to a circular import but this is only happening in this file if i throw this in another file this code will work completely fine so what's going on here well the issue is i've named my python module pygame so i've named it the thing that i'm trying to import so what happens is when i try to import pygame i'm trying to import the module that i'm currently working in myself and then i get this error and it's saying it doesn't have the attribute so to show you how you would fix this you would rename the file so let's call this pi game one now and when i run this code notice we no longer get that error and actually pops up a little pi game screen obviously goes away because i haven't coded anything else out so be careful about that do not name your python modules your python files a builtin module or a module that you're going to be importing or using in your program so moving on the next mistake i have for you is using a naked accept now here i have a try accept block and this exception or this except block is going to accept any exception so if anything happens in here that's an error that crashes the program we're going to go in here and print i crashed now that's great it's useful that we have this feature the issue is this accepts anything which means i don't know why i crashed when i'm reading this code and i see this message being printed out now this is really bad practice because it makes it really hard to debug your code and you just really shouldn't do this you should handle each individual exception as opposed to just any general exception kind of for obvious reasons but in this case i have two things inside of here that could fail right this could fail trying to open a file in read mode because if the file doesn't exist we'll get an exception and then dividing one by zero well zero division that's an error no matter what so two things that could fail and when i run the code here all i get is i crashed so i don't know if it was because i was unable to open the file or because i divided by zero and now if i delete the file that currently exists so tim.txt i have that there and i run this again i get i crashed so of course the solution here is to accept a specific exception and multiple of them if you want to so you kind of just need to know what the names of these are you can look them up you also can just crash your program and see what the exception is but for now let's accept the zero division error so the zero division error is simply called zero division error you should also get some syntax highlighting for it and now i can say i tried to divide by zero dot dot okay now let's just comment this line out let's run this and then we get i tried to divide by zero if i uncomment that and make my new file so let's save this as tim.txt yes put test inside of there save and run notice that i get i tried to divide by zero because i'm accepting the zero division error this obviously did not have an exception all right now though if we want to handle both of these exceptions we can write multiple except blocks so i can do accept and then i can accept i think this is the file not found error and i can print out i could not find the file dot dot so now if i delete the file again let's delete that let's run this then i get i could not find the file one last thing i will throw in here before i leave you also can have as e or as something now when i do that it will actually give me access to the error in this scope so i can do something like print e let's just comment this out now and then you can actually view what the exception string message is so keep that in mind that sometimes can be useful but please when you're writing your except blocks accept a specific exception it will help you later on so moving on to my next mistake and this one is using the wrong data structure now this is common and you could do this in any programming language but this is very important in python because there's a lot of operations that you can perform on a data structure that are very inefficient and that if you were to use a different data structure you'd have a much more efficient algorithm now if you're unfamiliar with time complexity don't worry that's kind of what i'm referring to here really what we're talking about is how fast can you perform an operation and which data structure or builtin type is going to be the best for what it is that you're doing so in python we have really three core data structures you should understand and that's going to be list set in dictionary we have string as well but i won't put that in here anyways the point is if we're looking at something like a list a list is used when you care about a ordered collection of elements so if the order and the frequency of elements that you have is important then you use a list there's not really another way to get around that if you want to store something ordered and you care about the frequency you use a list moving on we have a set now a set is used when you do not care about the frequency or the order of elements you only care about the presence of elements so you care if something is in the set or if it's not in the set now these two structures have drastically different time complexities in a list if i wanted to determine if something's inside of it that's what's known as a big o of n time operation and that essentially means that i have to look through at most every element in the list and there could be millions of elements to determine if something is there whereas with a set it's actually pretty much an instant or constant time operation for me to determine if an element is in there so if there's 10 million elements or 100 elements it's going to take relatively the same amount of time for me to determine if an element's in the set so it's very fast for doing lookups right and then you have a dictionary this is kind of a hybrid what this allows you to do is store key value pairs but similarly to a set this allows you to have constant time lookup and access to an element so i can access an element add a key pretty much instantly and i can check if an element is in the dictionary those are the three different data structures and you want to use them appropriately because of what i'm about to show you so i have a list here for example and i'll get to these in one second by the way and with this list i can perform all kinds of operations on it some are going to be much more efficient than others though for example if i want to remove the very last element i can do dot pop and that just removes last element and this is a constant time operation happens very quickly time doesn't change depending on the size of the list however if i want to remove the first element this is a big o of end time operation and this could take a very long amount of time depending on how long the list is so in this situation if you know you need to have an order collection of elements and you want to be say popping something from the middle of the list or the beginning of the list or something along those lines you should use one of the two data structures i have up here and sorry that's from collections so python has a builtin module it's called collections and inside of it it has something called a deck and a queue i believe it also has a heap it has a ton of other data structures that you can use now a deck or a dq however you say this is a double ended queue and a queue is essentially a first in first out data structure it acts uh kind of like a cue that you'd have when you're on the phone like waiting on hold or something like that but a double ending queue essentially all you need to know about the double ended queue is it allows you to remove something from the beginning and the end of it in constant time so if you know you want to pop something from say the beginning of a list instead of using a list just use a q it has very similar properties to the list but it allows you to actually remove elements from the front and from the back of it in constant time i'm not going to do a whole tutorial on these i actually think i have some on my channel way way back just wanted to mention though that there is these builtin data structures they are much more efficient for specific operations and just be careful which one you're using based on what it is that you actually want to do so moving on here to my final mistake and this one is using the global keyword and global variables now if you watch this channel you should be familiar with why you should not do that i have an entire video that i posted talking about why not to do this but i will quickly summarize it here so this program very simple i have a global variable called global var i have two functions bar and foo in the first function i say global global var that means that i'm going to access or whenever i access this name i'm going to treat it as the global variable so when i print global var i'm going to print this when i say global var is equal to x i'm going to print this in fact let me just say print and let's go with global var down here anyways you get the point that's what's happening then i have foo and inside of here i print global var i define global var equal to x and then i print global var now first of all just say guess what you think the output of this program is going to be pause the video if you need to i'm about to run the code and then i'll talk about kind of the weird stuff that we're getting so when i run this you see that we get 10 20 and then we get an exception now let's talk about this so what's happening is i'm calling bar the bar function actually executes fine and what it does is it prints out 10 and 20. so i'm printing the value of the global variable and then changing global var to be equal to x which i pass in here as 20 and then i'm printing it again and of course i'm getting 20 because i've changed this in the global scope however when i then go and call foo what happens here is i get this exception it says unbounded local error or local variable global var reference before assignment now that is on this line right here so line 10 and the reason i'm getting this is because i have actually defined a local variable global var inside of this function and it's kind of weird how python does this but essentially since this is defined down here when i try to print global var even though i have a global variable with that name it's not going to reference that it's going to reference the one in the local scope and since it's not yet defined i get an exception i know kind of weird one of the reasons again you don't really want to be using global variables is because if you try to write a local version of that inside of the function you're going to get these weird errors when you try to access that value above in the function now if i were to do this this would work fine i wouldn't get any issues with that however again since i'm doing this before i am defining this variable i get that error so hopefully it makes a bit of sense as to why that is occurring again really it's because i have a local version of my global variable whenever i have that in a function that's what i'm going to be accessing when i use that name so when i try to access it here it's not yet to find it well that causes an exception anyways that was my final mistake for you guys i wanted to keep this video nice and short and just quickly give you a few things to help you improve your python coding if you enjoyed make sure leave a like subscribe the channel and i hope to see you in another youtube video you