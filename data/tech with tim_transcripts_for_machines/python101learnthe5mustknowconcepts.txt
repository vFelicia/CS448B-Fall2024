if you're interested in becoming a developer that writes any type of code in Python then you need to understand these five very important python Concepts these are what I see most beginner and intermediate python programmers making a ton of mistakes with and misunderstanding when they're reading through production code the goal of this video is to make sure that when you're reading through production python code you understand what's happening you know the concept and then you can reproduce that code and write your own pull requests and own features using python code that other developers will understand and expect so with that said let's get into the video after I share with you the first very important concept you need to understand which is the sponsor of this video nordpass nordpass is the ultimate password and credential management solution that I've actually been looking for for a long time now I don't know about you guys but I have a lot of passwords credit cards Bank details private Keys Etc and oftentimes I need to share these with my coworkers making it a constant struggle to not only keep this data secure and safe but to allow them to access it quickly without having to message me all the time now nordpass fixes this problem because it allows me to store both my personal or my business data in a single secure location and then give different access to members of my team now if you don't believe me you can check it out from the link in the description and use the code Tech with Tim which means you'll no longer have to be sending messages or receiving messages asking for passwords not to mention the nordpass has features like autofill data breach detection and activity log a password generator and much more check out Nord from the link in the description and use the code tequitim for a three month free trial so you can take control over your data and your accounts thanks again to nordpass for sponsoring this video so the first concept to go over here is mutable versus immutable types now this is the concept that most beginner and intermediate programmers make mistakes with don't worry if you already understand it there's a lot more complicated Concepts so stick around for the rest of the video regardless an immutable type is something that cannot change a mutable type is something that can change an example of these in Python is the following so immutable types are going to be our string our ins our floats our Boolean our bytes type and our topple type all of these are immutable meaning once you define this you cannot change it however we have mutable types in Python which are the list the set and the dictionary and pretty much any other type used from some thirdparty library or module these can change which means once you find them you can actually modify them let me give you a super quick example here of immutable versus mutable then we'll go into a more complex one using a function which is where I see most beginners make a mistake okay so let's say we have some number like x equals one and we say Y is equal to X and in fact let's change this to a tuple which remember is e mutable meaning we cannot change it actually to quickly show this to you let's try to do something like x0 is equal to one where we're trying to change this Tuple without reassigning something to this variable so if I go here and run my code notice I get an error and it says the Tuple object does not support item assignment now the reason it doesn't support that is because this is immutable that means that once I Define this Tuple I cannot change it now if we go here and do something like Y equals X and let's come and say X is equal to one two three I just want to show you if I print out both X and Y here that my change to X here after assigning X to Y did not affect y the reason for that is whenever you're using immutable types when you do an assignment to another variable so I do something like Y equals X it makes a copy so an actual real copy of this immutable object meaning that if I now go something like X is equal to one two three that's not going to affect y because I'm not modifying what Y is storing I'm just reassigning a new value to X I know that seems trivial but the reason I'm illustrating this to you is because this works differently when we change this to a list so if I change this to a list now and then I come and do something like x 0 is equal to 100 you might think that Y is not going to change but when I run this you see that both X and Y have the same value now the reason for that is when you're using mutable types and you do something like Y equals X here so you're signing a variable to another variable and this variable is storing a mutable type what happens is you actually store a reference or an alias to this same object meaning that if I make a change to the object like I'm doing right here it changes for both of these variables because they're actually storing the same object in fact they're storing a reference to the same object so again if you change the underlying object then it changes for both X and Y that's the difference between immutable and mutable types now let me just paste in a quick example here that will illustrate this even a little bit further so you can see in this example we have a function that Returns the largest numbers it Returns the N largest numbers actually what it does is it sorts the list of numbers that it accepts so what I've done down here is I've created a list of numbers I printed out what the value of the list was before I called the function and then I printed out with the value was afterwards now take a guess if you want it what you think the output is going to be but I'll go ahead and run the code and you can see here that we actually get the list before that's unsorted and then the list becomes sorted afterwards now the reason this occurs is because what happens is when we call this function we pass this nums list as the parameter numbers now since we're passing a mutable object a list is mutable when we do a numbers.sort what this does is actually sort the list in place now numbers here is going to be storing a reference to this same list so when I sort the numbers parameter here since I had passed in my numbers array it ends up sorting that numbers array that's down here seems a little bit strange but the reason this is occurring is again because we're using a mutable object so the point here is that you need to understand when you're using mutable versus immutable objects because you could have functions like this that can perform side effects on your mutable objects this is referred to as a side effect because what happens is one of the parameters is being mutated or modified inside of the function sometimes you want that to be the case sometimes you don't want that to be the case you need to be intentional when you're writing your code so the next concept to understand here is list comprehensions now the reason you need to understand this is because it's used quite a bit in Python and oftentimes you'll see people writing fairly complicated comprehensions to simplify a line of code now this can kind of do the reverse sometimes it can actually make it more complicated regardless you need to understand what they are so that you can actually understand them if you see them in some production code so let's have a look at a list comprehension so the most basic comprehension you can do here is something like X or we'll go with i for I in range and then maybe something like 10 and in case you can't guess it here what this is going to do is give me an array that contains the numbers 0 through 9. so let me open up my terminal and run this and there you go we get zero through nine so this is a list comprehension where essentially you write a for Loop inside of a list what you do on the left hand side is you put but the value that you want to populate the list with and then you have some kind of iterator in this case we have a for Loop that's going to Loop through and generate these different values now this is a very simple list comprehension you can make much more complicated ones for example we can have a list here instead so now if I do a list we have a bunch of empty lists inside of this list but just like we have a list comprehension here we can have one inside of this list so I can do something like four so actually let's go with J 4J in range 5 like that and now we have a nested list comprehension and if I run this code you can see that now we get a bunch of lists that contain five different values inside of them 10 times okay so that's one thing you can do another thing that we can do here is the following so let's go here and say I for I in range 10 and then we can put in if statement and we can say if I mod 2 is equal to zero now this means we're going to only put this value here if this condition evaluate true so in this case we're only going to put even values or 0 inside of this list so when I run this you see that we get all of the even values up to but not including 10. all right so the next concept here is the different python argument and parameter types now there's quite a few that's why I'm going through this concept and a lot of times people have no idea what they are beyond the basic ones so if we Define a function here like complicated function we can have what's known as our necessary parameters or our positional parameters that are defined in order so I can have something like X Y now these are required and they are positional meaning that if I want to pass values here I have to do something like 1 2 right I pass them in the order in which I want them to be um kind of assigned so X is 1 and Y is 2. however I can actually switch things up a little bit here and as I pass these arguments I can do something like Y is equal to 2 and X is equal to 1. and now if I go here and print this so X and Y you see that we get one and two so this is valid when you are calling a function you can actually write out the name of the parameter whether or not it's positional optional Etc and then you can just assign it directly inside of here this allows you to no longer pass this positionally however if I pass some positional arguments so let's say I do something like one now I can do something like Z2 Y is equal to 3. so I can pass some of the arguments positionally and then some of them I can pass uh using the kind of keyword argument here or you know the named argument whatever you want to refer to it as by the way inside of your function call you refer to these as arguments and up here in your function you refer to these as parameters so I just wanted to show you that I can pass some of these positionally however things get a little bit weird if I try to pass some positionally and some using the keyword so in this case I have like Z equals 2 1 and then y equals three if I try to run this notice I get an error and it says a positional argument follows a keyword argument which you're not allowed to do so if I want to use some positional arguments and the rest keyword arguments that means that I need to start by defining my positional arguments then I can do the keyword arguments after hopefully that's clear but that was the first thing to go over okay next thing is optional parameters so inside of your function you can mark one of your parameters as optional by putting in equal signs by do Z equals two in this case none now this is optional meaning I'm not required to pass it when I call this function so if I call with 1 and 3 here you can see this is perfectly fine however if I got rid of the equal sign here so I made this no longer optional then I get an error and it says it's missing one required positional argument okay that's worth noting now if I try to access Zed here you'll see that actually let's make it equal something like 10. if I run this it actually gets its default value so when you make something optional really what you're doing is providing a default value for it which means if you don't pass that value when you call the function by default it will be equal to that value okay so that was actually the easy stuff now we move on to the more complicated ones now we have something referred to as asterisk arcs now what this allows us to do is actually accept any number of positional arguments so I can pass a bunch of arguments like this okay I can pass no additional arguments I can pass one two whatever it's any number after my positional arguments so if I print out x y z and then args here and I run the code you see that this is perfectly valid so when I do this asterisk args again this means okay I'm going to accept any number of positional arguments at this point so after my two positional arguments that I have here and it's going to store all of them in a tuple which is an emutable type okay if we just have star args here then you see it works the exact same way we accept any number of positional arguments even zero right so if I have none here this works perfectly fine okay that is star args now we also have star star quarks so when you have star star quarks this means we're going to accept any number of keyword arguments so let me just print out quarks here and go and pass some keyword arguments so the keyword arguments are like this something like x equals one s is equal to I don't know hello B is equal to True whatever let's do a capital true here so now if I run this you see that we have no positional arguments but we have these three keyword arguments and they are stored inside of a dictionary so if I want to access any of these individual keyword arguments I go quarks and then I reference whatever the key is so I want to reference X here and notice I get one okay this is useful when you want to make your functions Dynamic and you don't know how many regular arguments or keyword arguments are going to be accepting now you can obviously pass both so if I do something like one two three and then some keyword arguments here you'll now see that we'll get both args and quarks having some values and then we can process those values however we see fit okay great last thing to show you is how to use these uh with inside of your function so let's swap this around out and let's say we have like a b and then C is equal to True d is equal to false okay now if we go here we can actually use the asterisks to kind of break apart a list and pass different positional arguments so let's have a list here and I have one two three inside of it and these are actually the corresponding values for both a b and not C Just A and B if that's the case I can't just pass this list because if I do that it's going to be the positional argument for a so what I can do is put an asterisk before it and this is actually going to kind of decompose or break this apart into two individual positional arguments so if I go here and I print my a and my B and I run this notice I get 1 2 works perfectly fine okay now we have the same thing we can do with our keyword arguments so let's say I have a dictionary that contains my keyword arguments something like C is I don't know hello and D is cool I can actually place a dictionary here and then put two asterisks before it and what this will do is break this dictionary into its keyword arguments and pass that to the file function so now I can print C and D and when I have a look uh what does it say here C is not defined sorry we need to just add a string here always forget that you need to do that in Python let's clear and rerun and notice now that we get the values for our keyword arguments so the next concept here is if underscore underscore name equals underscore underscore main now this is simply telling you if you ran the current python file the reason why it's important to understand that is because a lot of times you can have a bunch of different python modules and sometimes you run the module directly other times it might be imported by a different module so let's have a look at this example in this case we have start.pi we have some function and then we have this if underscore under square name equals equals underscore underscore main we're printing run then we have another file here inside of this file we import the add function from this start module now if I didn't have this line here what would happen is when I import this module by default python would read the entire kind of block of code here the entire file and if I didn't have something inside of the if statement so I just had to say print run here then it would actually execute that line of code which I might not want to happen unless I'm actually inside of that module or sorry not inside of that module but if I ran that module it's better if I just show it to you so if I go here and I run pythonstart.pi you see that we get run printing out to the screen however if I run my other file so python other file.pi notice it doesn't print out run however if I remove this line here and we remove the indentation now it will print run so the purpose again of having this line is to determine if you ran this file drag directly a lot of times you have a file where it has a ton of utility functions that are going to be imported by other files and then you have something you might want to do when you're running it directly like maybe initializing a game or starting some program or sending an API request whatever it may be but you don't want this event to occur you don't want this code to run if it's being imported only if it's being ran directly so that's how you use this that's pretty much all you need to know hopefully now you know so the next concept to go over here does not involve my computer and this is the Gil or the global interpreter lock now this is exclusive to Python and essentially what this says is that any thread that wants to be executing needs to acquire The Interpreter lock now what that kind of technically means for you is that you can only execute one thread at the same time even if you have multiple CPU cores on your computer now to better illustrate this because I'm sure it's a bit confusing on your computer you have a CPU or in your computer you have a CPU that CPU will typically have multiple cores two cores four core eight cores whatever it may be now each one of these cores can execute one operation at a time with hyper threading and virtualization you might be able to do a few more I'm not going to talk about all the details there for Simplicity let's say each CPU core can execute one operation well this is great because that means your CPU can be working on multiple things at the same time and if you have a complex application it's possible that you want to be doing something like processing an image while allowing a user to type something in while maybe sending a request to the network there's a ton of different things you could be doing at the same time and this is where multithreading comes in a thread is essentially a component of your application that's being executed by the CPU when you start getting into larger programs you start designing multithreaded applications where you have different pieces of your code separated into different threads such that they can execute at the same point in time now with python you can do this you can have multiple threads the issue becomes though that you have this Global interpreter lock now what that means is even if you have a bunch of CPU cores on your computer only one of these threads can be executing at a time that's because this thread needs to acquire something known as a lock on The Interpreter now I'm not going to discuss why this was implemented in Python but what you need to know about this is that if you do actually have multiple threads this is not going to give you a performance bonus in Python it's not going to increase the speed at which you execute your code so to give you a simple example here let's say I wanted to sum the numbers from 1 to 100. well if I was doing this in a single thread I'd have to sum all of the numbers from 1 to 100 in a row however what could be more efficient is if I split this into four threads or six threads or eight threads and I summed sections of the numbers for example if there was four of me then I could sum the first 0 to 25 25 to 50 50 to 75 75 to 100 and then I could add all of those values together and this would allow me to sum the numbers four times faster and in a traditional programming language you can do this you can create four threads they're going to be executed on four different CPU cores and this will allow you to very quickly speed up your programs using these multiple threats in Python you can't do that even though you have these multiple threads only one of them can execute at a time which means it doesn't matter how you split these things up it's going to take the exact same amount of time or approximately the exact same amount of time to execute this code now I'm going to stop here hopefully you get the point that you can only have one thread in execution at a time if you know that you pretty much know the global interpreter lock if you want to learn more then I'll encourage you to read about it or let me know in the comments if you want to see me make an entire video on it regardless I'm going to wrap it up here I hope that you found this helpful and I look forward to seeing you in another YouTube video foreign