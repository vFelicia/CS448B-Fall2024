hello everybody and welcome to video 4 in this ros programming tutorial series in this video i'll be going over data types specifically the primitive data types in rust there's a lot more data types that i need to cover but i'm going to get to those in later videos for now we're going to look at the most basic ones which are known as primitive now before we dive in i will mention again i do have a programming course programming expert dot io check it out from the link in the description if you want to learn software engineering tools software design you want to learn how to programming go and python and have a ton of interactive practice questions assessments and projects to work on thank you guys very much if you do decide to purchase that course again link in the description with that said though let's get into this content so data types as i was saying we have primitive data types now these are the most basic data types we can kind of use them without having to do anything special and that's really what the primitive data types are just the most basic ones in a language so that's what we're going to look at here now rust has two categories of primitive data types we have a scalar type and then we have a compound or the types kind of fall into the categories of scalar and compound now scalar simply means a single value so something like an integer something like a boolean if you're familiar with data types whereas compound means multiple values so here we actually have an array and we have a tuple which we're going to look at in a minute for now though let's look at the scalar data types and how we use those in rus so as we know russ is a statically typed language that means it's very important for us to understand what type our variables are and we can implicitly have the type decided or we can explicitly define it when we declare a variable so if i do something like let x equals 2 implicitly the compiler is going to say this is an integer however i can explicitly define the type by doing something like colon and then i32 and what this means is that i am assigning the type of integer 32 to the variable x then i'm storing the value 2 as this type i 32. so this is the first type right integer this stands for a signed integer that's using 32 bits to represent and store the number now the number of bits essentially tells you how large of a number you can store and the range of numbers that can be stored in a variable i'm not really going to get too much into binary here because that's beyond the scope of what i'm uh meaning to teach but 32 is actually the default value for an integer in rust so what i mean by that is if i do something like let x equals two by default the type of this variable is going to be i32 because this is an integer value and we could assign it to many different types but we default it to i32 okay so let's keep looking at integers so as you saw we had i32 this is the default but we also have multiple other types of integers we have i8 we have i 16 like this i believe we have i 64 and i think we even have all the way up to i 128 now again these are the number of bits that's going to be used for all of these integers and in case you're unfamiliar with an integer this is any number that does not contain a decimal part so any whole number essentially something like eight something like negative nine something like 9727 negative ah that's totally fine and since we have a signed integer that's just what the default integer is that means we can use a negative sign for our value okay so those are the different types for our integers we then have the data type of uint now uint is unsigned integer and it's exactly the same as integer except you can't use negatives so if i do something like let x and then this is u32 i'm saying that i'm going to assign this variable the type of unsigned integer 32 and then give it the value of 972. now i can't assign anything to this variable that has a sign to it like i can't have a negative number here because this is an unsigned integer using 32 bits to store the number now i don't want to get too much into binary here in the different ranges and all of that but i'll just quickly mention that when we're looking at something like a u32 versus an i32 or we could even go even simpler with something like u8 and i8 these are able to represent the exact same number of unique values so using eight bits you're always able to represent two to the exponent eight unique values however the range of values that you can represent is different when you're using a u8 versus an i8 for example with an unsigned integer you don't have to represent any negative numbers so the range of numbers you can represent is 0 to 2 to the exponent eight minus one because you have eight bits you put eight here for the exponent and this is the range you can represent i believe from zero to uh this is going to be i think 128 or it's going to be oh sorry 255 my apology 0 to 255 that's the range of numbers you can represent with a u8 however with an i8 this is going to change now you're going to be a negative to the exponent and then this is going to be 7 you have to reduce the exponent by 1 2 two to the exponent seven minus one so with i eight you're gonna have a range of negative 128 to 127 in terms of the numbers you can actually represent whereas this is going to be zero to 255 hopefully that makes sense uh if it doesn't then i'd say refresh yourself on binary a little bit but i just wanted to quickly mention that okay so we've looked at signed integers and unsigned integers and the different quantities of course with u32 we have u64 uh with a lowercase and we'd have u 128 as well if i spell that correctly okay so that is it for integers next we're going to look at floating point values so in rust we have two floating data types we have f32 and f64 and this means we're going to have a floating point value using 32 bits and we're going to have a floating point value using 64 bits this is also known as single precision and double precision so let's have a look at one of those values we could do something like let let's go floating point and then we'll say the type of this is going to be f32 and this could be equal to something like 10.9 so as soon as we have this decimal component here now we know we're having a floating point value and we need to use the f32 or 64 type now the default type if you don't actually explicitly define it is going to be f32 using single precision okay all right so i think that's really it for floats um those are the types f32 f64 if you're not sure just use f32 now we can move on to booleans now a boolean is simply a true or false value or a zero or one value so for a boolean we could do something like let true or false equal and then this can be false notice we have it with lower cases there's no capital on the first letter like in python and this type here is simply the bool type now we also could make this a true but these are the two values this could store true or false now false is also represented by zero and true is represented by one sometimes you may see that so you can also use zero and one here again zero for false one for true okay so that is the bull type not much more to talk about there and lastly we have the char type or the character type for our scalar uh primitive data types so a character is gonna be something like this let's say let letter the type is going to be char not character just char and then we're going to use single quotation marks here and we can put any character on our keyboard so char just stores a single character we have eight uh we could do sorry not eight we have a we could do eight we could do nine we could do a bracket uh really any character you can represent as long as you're using single quotation marks okay so those are our four primitive data types again we have int and uh i'm kind of counting those as one unsigned integer and signed integer we have our floating point values with f32 or f64 we have our boolean values using bool and that's going to be true or false and then we have our characters using the char keyword and again you don't need to manually define any of these if you don't want to they will implicitly uh be set when the compiler is running through this cut okay so that's it for our scalar types now let's look at our compound types and then we can just i guess print a few things out and do some examples here with the types to make it a bit more clear okay so for our compound types we have a tuple i believe it's called tuple not tuple some people i think say like tuple or some weird pronunciation for it but it's called tuple spelt like this and we also have an array okay so a tuple is going to be a fixed length sequence of elements that is immutable so to create a tuple i'm going to do the following i'm going to say lattup standing for tuple and then i can make this equal to my parentheses here and inside of the parentheses i can put whatever values i want so i can do something like one true and then maybe put a character in here like s now the type of this tuple implicitly is actually gonna be what i'm gonna write out here which is an i 32 a boolean and then a chart so that's actually what the type of this tuple would be now the tuple really is defined by what values it's storing so this is actually the type right this is not a tuple it is a tuple that has an i32 a boolean and a char as the three values that's the specific type of this tuple if i make another tuple here so i do something like let top two and then i change this to something like i8 these are different types these tuples are not the same type i could not assign this to this tuple here that would not work because these are different types right this is an i8 as opposed to an i32 so just keep that in mind i know a lot of people get confused with this but the actual type is reliant on what elements are being stored inside of the tuple it's very specific okay so that is the basics on a tuple now tuples are immutable just like all our other variables by default you can of course use the mutt keyword if you want to make them mutable but let me show you how we access specific elements from our tuple so what i can do here is something like println exclamation point and if i try to just print out my tuple here you'll see that i get an error so let me go here and let's go back here and run this uh and notice that i get some problem let me make this a bit larger it's saying that uh print ln okay expected semicolon sorry let me add the semicolon first just so that we're not distracted by that error we'll rerun and we still get an error here and it is saying that uh we cannot format this with the default formatter so it's not possible to take this type here and format that using this so instead we'll just print out individual elements so to do that i can do something like tup dot and then i'm actually going to use the index of the element that i want to reference so if i wanted to reference the first element here i would use zero i know this looks a bit weird but top dot zero that's going to get me one if i wanted the second element i would do one if i wanted the last element i would do two the indices are just numbers representing each of our elements right so the first one is going to be zero second one one and then the last one two okay but if i do tup two here we should see that we get s printing out so let's clear and run and notice that we get s printed out to the screen if i do top of one we should get true so let's have a look at this here and notice that i get okay so there you go that is how you access the individual elements now continuing with tuples here let's have a look at how we can maybe mutate the tuple so let's change this to be mutable and now let's do something like this and actually just test if this works so top 0 is equal to and let's make this equal to 10 and let's print out top 0. okay so take a guess at what you think we're going to get here let's run the program and okay it keeps getting mad at me for the semicolons i keep forgetting those let's run this again and let's see and notice that i get 10 so i actually am able to modify using the indices when i add this mutable keyword however if i remove the mutt keyword and i go here and rerun notice that i get a problem it's saying cannot assign because this is not mutable so using the individual indexes we can assign to the value in the tuple and then if i make this mutable we should actually be able to change the tuple entirely as well so i can do something like top and i can change this to maybe 10 false and then let's just go with a okay and let's run this and let's see what we get and notice that we get 10 and that is fine although it's giving us some warning here saying uh on by default what is it variable assigned to top is never read okay so it's saying there's no point in us writing this kind of like the warnings we were getting in the previous video okay so that's pretty much it for tuples there's some more i could show you but i think that's fine for right now uh one thing to note is that i can't add elements to the tuple right so if i try to do something like add a 10 here this isn't going to work i'm going to get an error because i'm trying to change the type of the tuple and i can't do that because the type only contains three elements so i can't add four okay that's it for that though let's quickly move on to arrays and then i'll wrap up the video by mentioning strings to you and then we'll move on to user input in the next one so to create an array i'll do something like let arr and then this can be equal to something like one two three four five now arrays have to have the same element inside of them so in this case they're all going to be into 32 by default and if i want to get index access here i can do this similarly to the tuples but this time we're going to use square brackets and i could do something like ar 0. that would reference 1. if i do a r4 that would reference 5 so on and so forth now just like our tuples an arrays type is defined by the type of elements as well as the number of elements in the array so unlike other languages i can't actually add elements into this array i would need to make a new array with a new type uh that has more kind of allocation or more space for different elements here i'm only able to have five elements in this array and they all have to be of the type int 32. now let's see if i can change this doing something ar4 is equal to three and then we might as well print this out so print line and we'll do our formatter here and then arr at four let's give this a test so clear and run and notice we get a problem here it says we cannot assign because this is not mutable so just like the top line we need to change this to be mutable now if i go back here and run this everything is fine and we're printing out three because we assign that to the last element now let's have a look at how we explicitly define the type to do that here with our array we would go colon and then the type is going to be square brackets the type in your array so in this case i32 and then a semicolon followed by the number of elements exactly that you have in your array so in this case we have five so if i run this now let's go here and run and notice that it works fine uh we get what we need now let's just have a look at what happens here if we do something like this so we define an array without actually initializing the values so we're saying the type is i32 we're going to have exactly five elements let's see what happens if we try to access the last element here by running this and notice we get a problem here it says use of possibly uninitialized arr so unlike in other languages where you just get values automatically initialized in your array that does not occur here you do need to manually initialize it and if i try to do something like make this equal to an empty array we should get another compile time error here saying that we can't assign an empty array to an array of type i32 with five elements okay i know i went through a lot here this video was actually a lot longer than i was expecting it to be but i wanted to thoroughly walk you through all of the different data types here the primitive data types and show you how they work in rust hopefully this gave you a general idea of what these data types are how to use them what values correspond with which data types i did spend a lot of time again because this is very important you need to understand the types before we move any further now i will quickly show you that you have to be careful here with your types so if i do something like let x and i make this u8 and this is equal to a four let's see what happens if i try to say let y uh equal x okay so let's just see what happens if i go print ln exclamation point uh and we print out and we'll just print out y i'll also note you can print out multiple values so i could actually do something like x comma y uh and of course x will line up with that y will line up with that okay so let's go here let's clear and let's run and notice this is all fine now i'm going to ask you what is the type of y well some of you may say the type is u32 or i32 but actually the type of y is u8 and to prove that to you if i change this to be something like i32 which is the default you'll see that we get an error here when i run the code and the reason we get an error is because we cannot convert this u n data type here to an i32 or the uint8 type just isn't i32 so i'm saying this variable is of type i32 and i'm assigning a u8 type to this variable however if i actually put a 4 here explicitly you'll see that i don't get any problem because 4 can be treated as an i32 but i can't use x which is of type u8 so you have to be careful with how that works you'll learn more as we go through and see kind of the features of a statically typed language but i wanted to quickly show that to you so with that said i will wrap up the video here i hope you enjoyed if you did make sure you like subscribe to the channel and i will see you in another one you