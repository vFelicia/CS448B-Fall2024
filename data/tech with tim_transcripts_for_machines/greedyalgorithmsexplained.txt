hello everybody and welcome to another youtube video so in today's video i'm going to be explaining greedy algorithms now this is really meant to just be an introduction to this topic so in this video i will explain to you what a greedy algorithm is how you can go about creating a greedy algorithm and then show you a few examples of it but with that said if you want to learn more and practice with greedy algorithms what you can do is check out the sponsor of this video before we get started i need to thank the sponsor of this video which is alcoexpert algo expert is the best platform to use from preparing for your software engineering coding interviews and has the highest quality coding interview practice questions with 160 practice questions detailed solutions in nine of the most popular programming languages a featurepacked browserbased coding environment extensive test suites and conceptual overviews and code walkthroughs for each and every problem algo expert is the best resource to use to ace your coding interviews algo expert also has a data structures crash course coding interview assessments and a mock interviews feature i can highly recommend algo expert as a former customer myself and now an official instructor on the platform get started using algo expert today by clicking the link in the description and using the code tech with tim for a discount on the platform so i'm here on my drawing tablet and i'm going to start explaining to you what greedy algorithms are now before i do that i will note that i do have very messy handwriting so please excuse me i'll try my best to make everything as neat as possible in this video with that said what is a greedy algorithm well a greedy algorithm is really an algorithm that makes a greedy choice you can think of this as kind of an optimal choice at every single step in the solution or in the problem now the greedy choice is defined by some rule that rule could be select the largest number select the smallest number select the element that has a certain property whatever you're making some definitive choice some greedy choice at every step in the algorithm now greedy algorithms can be very complicated they can also be quite simple to give you an explanation or kind of an example of a greedy algorithm let me kind of introduce a problem to you right here so let's say for this problem we're given some array and this array is filled with integers so i have 3 4 negative 1 2 negative 3 and 0 and then maybe we're given some integer n we can say here that n is equal to 4. now what this problem is asking us to do is to find the n numbers in this array that equal the largest sum now if that's the case the greedy algorithm approach to solving this problem is to simply select the largest number at every single step until we've selected n numbers and this should hopefully solve the problem for us so if we apply the greedy algorithm approach we're selecting the largest number at every step until we've hit four numbers so what we do is we start by selecting four because this is the current largest number so we select four then we select 3 because 4 was already selected so now we have 3 and 4. then we select 2 and then finally we select 0 and what we get is 4 3 2 and 1 which means that we have an answer of 10. so that's the largest sum that we can create by selecting four numbers and this would actually be our answer here we would return 4 3 2 and 1. so that's an example of a very very simple greedy algorithm where all we did was select the largest number at each step and well that led us to the solution so i know the example i just showed you is relatively trivial but it's the best way that i can show you what a greedy algorithm is without getting into any super formal explanations so as you saw there a greedy algorithm is really just an algorithm that makes an optimal or greedy choice at every single step and eventually all of those choices lead to an optimal solution at the end of the program now before we get into some more advanced examples here i'm going to give you two kind of formal definitions or formal properties of when you can actually use a greedy algorithm to solve a problem so if the following two properties that i'm going to state are true you can use a greedy algorithm and you'll be able to solve the problem so the first property is called the greedy choice property and what this says is that a global optimal solution can be reached by choosing the optimal choice at each step and then the second property that needs to be true as well is the optimal substructure property which says a problem has an optimal substructure if an optimal solution to the entire problem contains the optimal solutions to the subproblems so to kind of break that down a little bit what that means is every time you make a choice you can kind of treat that as a sub problem now an optimal substructure exists if all of those sub problems allow you to solve the larger problem as a whole so really it's saying if all of the solutions to these sub problems combined allow you to have a full optimal solution to the entire problem then you're good you can go ahead and use a greedy algorithm so i'll leave those definitions on the screen so that you can read them i'll give you one more kind of formal definition here before we get into another example this says greedy algorithms work on problems for which it is true that at every step there is a choice that is optimal for the problem up to that step and after the last step the algorithm produces the optimal solution of the complete problem so that makes it seem a little bit more confusing than it really is what i'm going to do now is move on to another example and show you how we apply a greedy algorithm to it so in front of me i have a very famous problem which is known as the knapsack problem now what i'm going to do is introduce a variation of this problem to you and then explain how a greedy algorithm can be used to solve this then i'm going to go back to kind of the original problem and show you how the greedy algorithm fails so let me introduce what this problem is so in this problem you have a backpack that has a specific capacity in this case the capacity is 25. now that denotes kind of the size in total of items that you can hold in the backpack some people call it weight you can call whatever you want but that means that we can only store at most 25 kind of you know units of items in our backpack and what our goal is is to fill the backpack with as much value as possible without going over its capacity so we can see that each item has a size here and has a value so if we're looking at item 0 it has a size of 22 and it has a value of 19. we look at item 1 we have a size of 10 and a value of 9. and so if we were to select say item 1 that means that we would then be left with 15 units of capacity in our backpack we would have a total value of 9. so again the goal is to maximize the value without going over the capacity but you can be at the capacity so you could use 25 units of space in the backpack so the question here is how do we use a greedy algorithm to solve this problem and actually i need to introduce the variation of this problem which is you can select a fractional amount of any of these items so what that means is that let's say we want to select item one but we don't have enough room for the entirety of item one we can select half of item one so if we were going to select half of item one then what we would do is you know say 0.5 times 10 that's how much weight we're going to have for half of item 1 and then 0.5 times nine that's how much value we're gonna get if we select a fractional amount of item one now you don't have to just select half you could select 99 of it you could select one percent of it you could select ten percent of it whatever you want you can select a fractional amount of an item so my question is how do we use a greedy algorithm to solve this fractional backpack problem well the first thing that we should consider is can we solve this problem by just looking at one of these columns here so just the value or just the size can i select items that just have the largest value can i select items that have the smallest size what is kind of the grady approach so let's just see what happens if we try to select items that have the smallest size first and see if that actually gives us an optimal solution so at each step in our algorithm we're going to select the remaining item that has the smallest size that's kind of our greedy step and so the first item that we're going to select here is going to be item 3 because it has a size of 7. so when we do that we see that our current size is going to be 7 and our current value is going to be 6 and then we can cross this off because we've used it okay the next greedy step is we are going to select the size of nine so we select nine that gives us a total size of 16 and then our value is now 15 because well 9 plus 6 is 15 okay and then we're going to select our next item the next item has a size of 10. and when we select this item we see that this is going to lead us to go over capacity to 26 so what we need to do is select a fractional amount of this item which means instead of selecting all 10 we're going to select 90 of this right so we'll select 9 of 10 which means we are going to get now a capacity of 25 and then what's 90 of 9 well let me just use the calculator to get that i probably should have been able to solve that in my head but that's going to give us 8.1 value which means we're going to have a total value of 23.1 perfect so there you go we now have a total capacity of 25 a value of 23.1 and that's kind of the answer we got when we selected items that had the smallest size that was the greedy choice that we made so let me just kind of move this over to the side here so we remember this value and now let's try it in the other way all right so now we're going to perform the greedy algorithm but this time choosing the largest value instead of the smallest size so if i'm selecting the largest value that means i'm going to select item 0. so we have a size of 22 and a value of 19. then i'm going to be choosing between item one and item two because they have the same largest value since this has a smaller size item two i'm going to select this one and so that means that if i were to select the entire item i would have a weight of 31. obviously i can't do that because that goes over my capacity and so instead i need to select 33 of this item so that means that my capacity is going to go to 25. 33 of 9 is clearly 3. same thing here that means that i am going to get an additional 2 value here and that is going to lead me to 22. so let's take this and store this down here as well so the two answers we got were 23.1 and 22. now what we can say right now is okay well clearly the other approach selecting the smallest size worked better for this example but is this actually the optimal answer are either of these the optimal answer to this problem and well the answer to that is no there's actually a better way to solve this still using a greedy approach but it requires a little bit of thinking so the purpose of me showing you those two methods there was to illustrate that in a lot of examples you can use a greedy algorithm but you have to make sure you're really thinking about what your greedy criteria is how you're selecting the optimal choice at every single step now for this problem here you have to remember that we can select a fractional amount of all of these items and so really what we should do is find the items that have the best value to size ratio select the largest fractions of those items that we can and then continue on throughout the yellow group so i'll show you what i mean by that but let's just have a look here so what i'm going to do is make another column and i'm going to call this value over size now the point of this is that the items that have the largest value over size ratio are the best items for me to select so quite simply if we're looking at this right here nine size gives me nine value that means my value to size ratio is one so for every extra capacity i add or remove i guess from my backpack i get one value whereas if we're looking at say 22 and 19 i need to pull out my calculator for this but 19 divided by 22 is 0.8636 if we're looking at 9 and 10 we're going to get 0.9 and if we're looking at 6 and 7 then we're going to get 0.857 so here we can see that the best item to select in terms of the value to size ratio is going to be item 2 and then we're going to have item 1 and then it's going to be item 0 followed by item 3. so now what our new greedy algorithm should do here the correct greedy algorithm is at each step in our algorithm we should select the item that has the highest value over size ratio and take as much of that item as we possibly can so in this case we see that this is our best item so we're going to take all of item two so i can just i guess write what our weight and our size is going to be over here so that's item 2 we're going to select all of that then this guy is done so what's the next one well we want to select item one so we're going to select all of item 1 which means we're going to get now a capacity of 19 and we're going to have a value of 18 so this guy's done now and then this is slightly better than this so we're going to select as much of item zero as we possibly can so we need to select kind of six size of item zero so let me do some math here so we're gonna select approximately 27 of item zero so 27 times 19 gives us a value of 5.18 which means that we're going to have here 23. if i can do this correctly 23.18 like that and then we're going to have a capacity of 25. so we did actually end up with marginally more value by using this different greedy approach that i just showed you right here now a lot of you might think that this is a calculation error this is not there is actually slightly more value in doing the method that i just showed you here so selecting a fraction of this specifically 27 of it now in a lot of other examples you'll see that this difference would be much larger the whole point of this was just to illustrate to you that you need to be very careful in what you actually use as your greedy criteria it's not as simple as just looking at one category in this case we combined the categories and intuitively this does make a lot of sense right to select the highest fraction of items that we can that have the largest value over size right or value to size ratio so that's the example that i wanted to show you on how you can actually use a greedy algorithm to solve a problem i'm not going to write the code for this you can figure that out on your own but now what i want to do is change the variation of this problem and show you how a greedy algorithm might actually fail all right so i've cleared the screen and now what i want to do is change the variation of this problem and show you how the greedy algorithm will fail when we change the problem just slightly so now the problem is the exact same you want to maximize the value without going over the capacity however you cannot select a fractional amount of an item so if we try to perform the greedy algorithm we did in the last step where we select the item that has the largest value to size ratio you're going to see that we quickly fail and we do not get the correct amount we do not get the largest value we possibly can so let me prove it to you this was the item that had the best us value to size ratio second best third best and fourth best so if we select this item first we get nine and nine and then we select this item we get a total capacity of 19 and then we get a value of 18 and now we try to select the next item and we see we cannot select another item because there is no item that has a size small enough that we can fit in the bag with a capacity of 19 already being used and so our value from the greedy algorithm approach is 18. so obviously this means that the greedy algorithm fails in this example and cannot deliver an optimal solution and one of the reasons it can't do that is because the choice it makes in the current step actually affects what choices it's going to have to make in the future because we have this capacity constraint and so we really would be better off using something like dynamic programming here to solve this problem rather than a greedy algorithm in fact a greedy algorithm just will not give us the correct result unless we're lucky and the greedy algorithm choices end up lining up with what the actual optimal value should be so with that i think i'm going to end the video here hopefully this gave you a quick introduction to what greedy algorithms are again they're pretty straightforward but they're used in all kinds of different algorithms for example if you're talking about dijkstra's algorithm or the minimum spanning tree algorithm where a lot of other graph algorithms actually may use a version of a greedy algorithm they have other types of kind of algorithms in them but they make a greedy choice at every single step to help solve the problem if you're talking about dijkstra's algorithm at every single step it's choosing the node that currently has the shortest distance to get to it and then it's examining from that note now might be butchering that a little bit it's been a while since i looked at dijkstra's but that is an example of an algorithm that implements a greedy choice and kind of is a greedy algorithm based on the definition of greedy algorithms anyways i hope you guys enjoyed i hope you learned something if you did make sure to leave a like subscribe to the channel i will see you in another youtube video you