foreign with you how to build a platformer game in Python this game will have Pixel Perfect Collision it will have an animated character as you can see here it will have single and double jumping it will have all kinds of different animations for falling jumping colliding with obstacles for example you can see here when I hit the fire I kind of go into this hit State I will show you how to generate different objects how to scroll the background and really at the end of this video you will have a solid fundamental understanding of how to build a platformer game in Python and you can go and extend this and build really anything that you can think of I will even include a ton of free assets for you that allow you to change your character change the terrain change the background and do all of that extremely easily in fact in this tutorial alone I will show you how to use four different characters let me show you those characters before we continue so this is the second character here this is being referred to as mask dude this is the third character I'm calling this guy the ninja Frog as you can see and Final finally we have this character here which is called pink man now in this tutorial you will learn how to use all of these characters and you can swap them out with a single line of code with that said I hope you're excited this video has taken a very long time to prepare so please click the like button subscribe to the channel and we'll dive in after a quick word from our sponsor thanks to dice for sponsoring this video dice is the platform for gogetters like yourself to find your next job in Tech that aligns with your values and skill set on dice.com you can easily search and filter for jobs and set personalized alerts so you never miss a job opportunity start by creating your free profile setting up your job alerts and then going visible and connecting with employers immediately now Beyond Just Landing a job dice helps you gain insights into the tech industry and learn what skills and Technologies you need to master to get to the next level with dice.com you get access to countless articles free ebooks and a variety of other resources that help you understand things like what tech salaries you can expect effect job postings by volumes the number of jobs by occupation and a lot of other valuable information that helps you craft your career in Tech we all know that searching for a tech job can be difficult but with dice it doesn't have to be click the link in the description to start leveling up with dice today and don't forget to download their mobile app so you never miss a great job opportunity thanks again to dice for sponsoring this video alright so let's go ahead and get into it now since this is a long video I do want to spend a minute here just talking about who this video is designed for exactly what you're going to learn and what you can expect just so you don't waste your time if you don't want to go through it so this video is really designed for people that have a bit of experience with python ideally you are an intermediate python programmer you understand the syntax you know for Loops you know functions you know all of that if you don't feel free to follow along but I'm not going to be explaining those basic concepts now this video will teach you how to build exactly what you see here so by the end of the video you will have exactly this and if you're not interested in waiting until the end of the video then you can download the code from the GitHub repository that I will leave in the description that's also where all the assets are going to be so regardless you're going to have to download the code from GitHub again I will leave that in the description download that open up the folder and kind of we can start working from there now really what I'm going to be showing you here mostly is Sprite sheet animation uh Pixel Perfect Collision using what's called masks and then how you can do the scrolling background generating objects all of that kind of stuff that is really the hard part when it comes to generating a platform or game once you have all of that down it's very easy to extend this to add levels to add like you know a finishing flag to add coins to add you know lives you can turn this game into anything you want and that's how I've designed this so that you have the base and then you can go and make it kind of a fullfledged game and work off of that so with that said I will stop talking now I think this game looks really good I'm excited to share this with you guys so let's get into actually building it so right now I have Visual Studio code open obviously we're doing this in Python and I already have Pi game installed now the first thing we're going to have to do is install pygame which is the module we're going to be using so to do that go to your terminal and type pip install Pi game if that doesn't work for you you're going to try pip 3 install Pi game if that doesn't work try python hyphen M pip install Pi game if that doesn't work try Python 3 hyphadam pip install Pi game if none of those work I will leave two videos on the screen that show you how to install that module now once you have Pi game installed I'm going to assume that you've downloaded the GitHub repository go to GitHub there's a little button that says click to download download the folder extract it to your desktop and then open it in vs code or whatever editor you want so you have something that looks like this you should have an assets directory inside of assets you should have a bunch of different folders then you should have a main python file that contains all of the finished code now obviously we're going to write the code from scratch but you can either work off that existing code or you can kind of clear the file and type along with me whatever you want to do I quickly want to run you through the assets folder and then we'll get into the code so in assets we have a ton of stuff we're not going to use most of this but I wanted to include all of it so that you could kind of continue the game later if you want so we have for example backgrounds these are a bunch of background tiles so you can change kind of the theme or color background very easily I'll show you how to do that we have items like boxes checkpoints fruits Etc we're not going to use any of those then we have main characters for main characters we have a bunch of sprite sheets inside of here and I'll show you how we can split these Sprite sheets apart and use all of the different kind of animations inside of here right so we have that for Mass dude ninja frog Pinkman and virtual guy all of the file names are the exact same okay then we have menu we're not going to be using anything from there we have other we have terrain we are actually going to be using terrain specifically we're going to pull out this kind of block here but you could change the block again if you want to do that and then we have traps and we are going to be using the fire trap wherever that is right here that has kind of an animation right where the fire is going but again you can add all of this stuff later on I'll show you kind of the base on how to do it and then you'll be able to extend from there okay now that we understand the assets I apologize for such a long introduction let's get into writing the code I also need to plug the idea of a course programmingexpert.io if you guys want to get better at python check that out from the link in the description okay so let's start at the top of our program here by importing everything we need we're going to import OS we're going to import random we're going to import math we're going to import pygame we're going to say from OS import list directory and we're going to say from OS dot path import is file and join now the reason I'm doing all this OS stuff is because we are going to be dynamically loading all of the Sprite sheets and the images so we don't have to manually like type out the file names that we want I'll show you how we write a function that just loads these folders here kind of splits the Sprite sheets automatically and gives us all the images that we're interested in okay after we do that we're going to say pygame.net we need to initialize the pi gate module then we're going to go down here we're going to set a caption for our display I'm going to say Pi game dot display dot set underscore caption if you're unfamiliar with what this is doing this is setting the caption at the top of the window I'll try to explain most the pi game stuff as we go through the video I also have a ton of videos on Pi game on my channel if you want to check out something a little bit more basic okay now what I'm going to do is Define a few Global variables that we're going to be using here the first one is going to be the background color now we'll use this for now until we Implement our own background and for the background color I'm going to make this white which is going to be 255 255 255 all of our colors in pi game are going to be in RGB okay so red green blue that's what we have for our background color we're then going to define the width and the height of our screen for some of you you're going to have to make this smaller if you're on a smaller display for me I'm on a 2K monitor so I'm going to go with a thousand by 800 but if you're on again a smaller screen you might want to make this just a bit smaller so that it works for you although it doesn't really matter um make it whatever size you want next I'm going to say my FPS which is my frames per second is going to be equal to 60 and I'm going to Define my player velocity equal to 5 and this is going to be the speed at which my player moves around the screen okay now that we've done that we need to set up a pi game window so I'm going to say pygame.display.set underscore mode and then I'm going to pass the width and the height to this window argument here this mode argument and this is going to kind of create the pi game window for us I'm going to store that in the window variable and there we go we have kind of our Global variables created now I'm going to make a main function I'm going to say Define Main this main function is going to be what we run to kind of start the game so inside of here I'm going to take a window and at the bottom of my program I'm going to say if underscore underscore name underscore underscore is equal to underscore underscore Main underscore underscore then call the main function and pass the window argument okay so hopefully you can see kind of the structure of our program already the reason I have this line right here is so that we only call the main function if we run this file directly if we don't run this file directly say we imported something from it then we won't run the game code okay so that's why I have this inside of main is where we're going to write kind of our event Loop the event Loop will be what's handling say the Collision moving our character redrawing the window all of that kind of stuff this kind of good practice to have your event Loop in one place so inside of the main function we need to set up a few things the first thing we need is a clock so we're going to say clock is equal to Pi game dot time dot clock we also need to Define uh what is it a while loop that's going to continually Loop and act as our event Loop so I'm going to say run is equal to true I'm going to say while true or while run sorry and then the first thing I'm going to do is say clock.tick FPS now FPS members our variable right here what this line does is ensures that our while loop is going to run 60 frames per second okay so no more than 60 times per second that's what this ensures if you're on a really slow computer chances are you could be running less than 60 frames per second but in my case I'm on quite a fast computer and if I didn't put this here then you'd see that my game would be like way faster than yours so we need to do this to regulate the frame rate across different devices okay now that we have that we're going to say four event in pygame dot event dot get and the first event that we're going to check for is if the user quits the game if they quit by quitting I mean they hit the red X in the top right hand corner then we need to stop the event Loop and exit our program so I'm going to say if event DOT type is equal to pygame dot quit then we're going to say run is equal to false and we can break out of this Loop then we can go down here and we can say hi game dot quit notice this is outside of the while loop and then we can put quit which will actually quit the Python program okay so now we have our basic event Loop and what should happen if I run the code now is a pi game window should pop up nothing should be on the screen and if I hit the red arrow it should close so let's try this and see what we get okay notice it says platformer and then I hit X and it closes perfect uh we're well on our way to creating the platformer game all right so now that we've done that I actually think that the first thing we can do is generate our background then once we have the background we can create a basic player that we can move around the screen and once we have that we'll start doing all of the animations and then later in the video once we've got uh kind of the bulk of the stuff done we'll handle the collision and all of the movements right okay so I need to make a function here and I'm going to call this get underscore background now before I dive into this let's have a look at our assets folder again now what I want to do is use these tiles right they're just tiles I believe their size is 64 by 64 or 32 by 32 something along those lines anyways we'll want to use these tiles and tile the whole background so what I need to do is essentially create a whole grid of these tiles based on the size of my screen so the way I'm going to do that is by using a folder here this folder is going to return to me sorry not this folder my bad this function this function is going to return to me a list that contains all of the background tiles that we need to draw so that's what we're going to do here with get background now what we want to take is the name sorry as I was saying the name is going to be the color of our background and that's going to allow us to change what background that we're using so the first thing we need to do here is load this background image now it's very important that when you run this file you run it from the directory that the file exists in now the reason I'm saying that right now is because the way I'm going to load this image relies on the fact that you're running this code from the directory that it exists in so see here that I'm in desktop python platformer and then notice tutorials inside of that directory that's why this is going to work if you try to run this code from a different directory say a CD to desktop and then I tried to run this then I'm going to get an issue so just make sure you're in the correct directory I just want to say that before we even get into this okay so I'm going to load my image I'm going to say image is equal to pygame dot image dot load and then what I'm going to do is join the assets path which is directly in the directory this file is in with the background uh path here if I spell background correctly and then with the name which is going to be the file name that I want to load which is really just the color of the background okay now that I have that I want to get the width and the height of this image so I'm not guessing what it is so I'm going to say underscore underscore with height is equal to image.get underscore rect now when you do this it will give you the X Y width height I don't care about the XY so I've just put two underscores here denoting that I don't care about these values and then I'm able to grab the width and the height so now that I have the width and the height I'm going to say tiles is equal to an empty list and then I'm going to Loop through um essentially how many tiles I need to create in the X and the Y Direction so I'm going to say 4i in range and then I'm going to take my width I'm going to integer divide this by the width of my tile and I'm going to add one and I'm going to do the same thing for my height here so I'm going to say 4J in range height over the height of my image Plus 1. okay so notice width here is the width of the screen height is the height of the screen I'm integer dividing this by the width of my tile and that tells me approximately how many tiles I need kind of in The X direction to fill the whole screen then just to make sure that I don't have any gaps I add one and I do the exact same thing for height in the y direction then what I'm going to do is say actually yeah I'm going to say rect uh is this wrecked no we're gonna say pause is equal to I multiply by the width and J multiplied by the height and this is going to denote the position of the top left hand corner of the current tile that I'm adding to this tiles list in pi game when you draw something on the screen you draw it from the top left hand corner so what I'll be doing is continually moving the positions based on how this for Loop is going right so for every eye for every J I'm multiplying it by the width and multiplying it by the height and that gives me the accurate positions I need to place every single tile in on the screen hopefully that makes a bit of sense but that's how this is working uh and then I'm going to say towels.append my position and then I'm going to return my tiles I'm also going to return the image so that I can know what image I need to use when I'm drawing all of these tiles okay now that I have my background I'm going to go into Main and I'm going to say my background is equal to get background and for the name I'm going to reference here in the background folder any of these images so we can use anyone we want it doesn't really matter I kind of like the blue one so I'll go with blue feel free to change this though on your end and there we go if I can type this correctly okay so I'm going to say background comma BG image like that and now I want to set up something that's going to draw my background so I'm going to make a function here and I'm going to say draw this is going to take in a window and for now it's going to take in a background and later it'll take in everything else we want to draw inside of here I'm going to say Pi game dot display dot update and before I do that I'm going to draw my background so I'm going to say 4 and this is going to be tile in background like that and then I'm going to say window dot blit and actually I need to take my BG image as well so let's take that and I'm going to draw the background image and then what I need to pass here is the position I want to draw it at which is going to be tile so what I can actually do is just convert this to a tuple notice the tile is going to be a list right tile is going to contain kind of my X Y position you can see that here right we're appending pause which is a list of x y and now that I think of it to make it easier let's just make this a tuple directly and now we don't need to convert it okay so in case anyone's confused what we're doing here is looping through every single tile that we have and then we're going to draw our background image at that position which will fill the entire screen with background images then what we're going to do is update the display the reason we update it so that every single frame we kind of clear the screen right and we don't have old drawings still on the screen you'll see what I mean in a second but this draw function is what we're going to do all of our drawing for now the only thing we need to draw is the background later it will be the player the blocks the obstacles Etc okay so now I'm gonna go inside of my wallet I'm going to call this draw function that we just created I'm going to pass window and then of course I'm going to pass my background and my BG image okay now this reminds me that I no longer need this background color we're not going to use that so I can get rid of that there okay so at this point assuming I've loaded the image correctly we're now going to see this tiling the entire screen so let's save and run and notice that we get it right it's tiling the entire screen looks pretty good to me and we can quite easily change this if we want by just going here and saying okay rather than blue I want yellow and then we say yellow and now we get a yellow background great so that's kind of the advantage of how I've done this here you can change the background to any color you want well given that it's in the background directory now that we have our background what should we do next well we probably want to put a player on the screen and start seeing some images for that player now the player itself is the most complicated aspect of this program there's a lot of movement going on with it so we'll start by just creating like a block for our player kind of move the block around have it jumping around then once we do that we'll do all of the Sprites and animations just so that we can get some more progress before we dive into that because it is a bit of work okay so let's go here and let's say class player we're going to use a class for our player kind of makes sense here and this class is going to inherit from pie game dot Sprite dot Sprite now I don't typically use Sprites when I'm working in pi game but I'm going to use them in this tutorial and the reason for that is that it makes it very easy to do Pixel Perfect Collision when we have two Sprite objects which we're going to have because we're inheriting from the pi game Sprite class we can use a method that tells us if these Sprites are colliding with each other so just understand that's why I'm doing this inheritance you don't have to understand exactly what the Sprite is but it kind of denotes that we have some properties on our class and then it allows these special Pi game methods to use those properties to handle the Collision for us so we don't have to write anything too complicated when it comes to the Collision although we still do need to handle it a bit okay so what we're going to do here is Define our initialization and we're going to take in a self an X Y width and height now the width and height will really be determined by the image that we're using for our player but for now since we're going to have like a block for our player until we add that image we're going to have a width and height now that reminds me that I just need to set a color for my player so I'm going to say color is 255.00 I'm making this a class variable just so it's the same for all of my players and I have access to it just right on the class okay now what I'm going to do is say self direct is equal to pygame.rect I'm going to pass my X Y width and height so rather than representing all of these values individually uh we're just going to put them on the rectangle and this is going to make it a little bit easier for us to kind of move the play around and do collision and all of that so erect really is just a tuple that's storing four individual values when I make it Pi game.rect it means we can use it in some kind of special equations and whatnot okay now for our player we're gonna have to have a few values uh the first thing we're going to have I'm getting a bit ahead of myself here but is going to be the x velocity and the next is going to be the Y velocity now the X and Y velocity is going to denote um what do you call it here how fast we are moving our player every single frame in both directions right so the way that we'll actually move our player is we'll just apply a velocity in a direction and then it'll just keep moving in that direction until we remove that velocity now this will be great for example for something like gravity or jumping um and you'll you'll see what I mean in a minute okay now that we have that we need to add something known as a mask for now I'm going to say the mask is equal to none and then I think that's all we need for right now so now that we have that let's add our first function here which is going to be the move function so move is going to take in a displacement in the X Direction and a displacement in the y direction and it's going to say the self.rec dot X plus equals the Direction X or displacement X sorry and self.rect.y plus equals the displacement y now if we want to move upward down or left or right we just change the sign of this DX or d y right okay so now we have a move next what we want to do is create two functions one for moving to the left and this is going to take in the velocity we want to move in the left Direction and the next is going to be moving in the right direction again this is going to take in self and Vel now to move left what we're going to do is say ourself.x velocity is equal to and then this is going to be negative velocity and then to move to the right we're going to say self.xfel is equal to Vel now the reason we use negative velocity here is because if we want to go left we have to subtract from our X position in pi game remember our coordinate system is that 0 0 is the top left hand corner of the screen so if I want to move down I add to my ycoordinate and if I want to move to the right I add to my x coordinate so if I want to go up I subtract y if I want to go left I subtract X so that's why I'm putting a negative Val here I know it seems a bit weird how I've just done move and now I'm saying move left we're going to have negative don't worry you'll see how this works in a second next I'm going to say if self dot Direct action does not equal left then self Dot Direction is equal to left and I'm going to say self.animation count is equal to zero now we're not going to use these right now but I just want to add them in um for now at least and you'll see why in a second now I'm also going to say appear yourself dot direction is equal to left and the reason I'm adding this direction is because I need to keep track of what direction my player is facing so later once I have my Sprites I know if I'm showing the animation to the left or I'm showing the animation to the right now the animation count uh we're resetting that when we change directions and the reason we're doing that is so that the animation doesn't look all wonky when we go from going left to right so we need to kind of reset the count that we're using to change the animation frames again you're going to see that later as we go through the tutorial now I've just added up here um self.animation count equals zero just to make sure we don't get any weird errors later so now I have my direction and my animation cap perfect okay now I'm going to copy this I'm going to put the same thing in move right and I'm going to change the direction here to say right and then right so now we know what direction we're facing at all points in time okay perfect next what we need to do is we need to have some kind of draw function and we also need to have what I'm going to call the loop function and in fact let's do the loop function first so I'm going to say Define Loop and inside of here I'm going to take in self and FPS now what Loop is going to do is be called once every frame when I say frame that's really one iteration of the while loop and this is going to move our character in the correct direction and handle things like updating the animation and all of the stuff that we constantly need to do for our character so for right now I only care about moving in the X Direction we'll handle the jumping later so what I'm going to do is just say self.move and I'm going to say that we're going to move based on our x velocity and our y velocity now notice we're updating our x velocity here when we move left or we move to the right so now if we call Loop and we have some velocity in the X Direction it's going to move our character to the left or to the right okay again all this will start to make sense as we get through the tutorial there is a lot of stuff I need to do kind of up front before I can just show you instantly so hopefully you guys are following along but I just want to note we eventually of course will see how all this works I'll walk through the code so no worries if it's a bit confusing right now now what else do we need to do inside of the loop well we need to update something known as The Mask which I'm going to get to in a second but before we can do that we need to Define uh what's known as our image so I'm going to say Define and this is going to be draw and this is going to be the function that handles drawing on the screen and for draw we are going to take in our window which I'll just represent with win now what we'll do for now is we'll just say Pi game dot draw dot rectangle we'll draw the rectangle on the window which is the first argument here it's where we're drawing it the second argument is the color which is going to be self.color then the last is the rectangle so I'm going to say that is self dot rect now notice the react here right has our XY width height and when we move we're updating the X and Y of the rectangle which will then change where we're drawing it if I can find it here on the screen okay so that's what we need for drum now actually for now I think that's okay uh we will add to this obviously in a second but I think we can generate a player draw the player see it moving and then go from there so let's do that so let's go to main here I'm going to create a player I'm going to say player is equal to player I need to pass an x a y and a width and a height so I'm going to pass let's say a hundred and let's make him 50 by 50. and then what we can do now is pass our player to the draw function we can then take player inside of here and we can say player don't draw and we can pass the window okay so I will move the player in one second but for now let's just see if this is working if it's going to show up on the screen so let's run the code and notice that now we have a red rectangle in the top left hand corner obviously nothing's happening right now because we're not moving it around the screen but you could see it's showing so we have our player we're drawing the player on the screen now we want to start using some of these methods Right Moving left moving right Etc so I want to separate my movement into a function so I'm going to say Define handle move like this and for this right now we'll just take in the player now inside of handle move what we're going to do is essentially check the keys that are being pressed on the keyboard if you're pressing left or you're pressing right then we'll move the character to the left or to the right eventually we will check for collision and we will do all of it so I'm going to say key is equal to pygame dot keys actually not keys.key DOT get underscore pressed this tells you all of the keys on the keyboard that are currently being pressed and I'm going to say if and actually this is going to be key really we should call this Keys though because this makes a bit more sense so we're going to say if keys and then this is pygame dot k underscore left this is the left Arrow key if you wanted to use the a key then you would use a like that uh yeah actually I'll go with left Arrow key because that's what I usually do but you can use a or swap it however you want and then I'm going to say if this is the case then player dot move underscore left and how much do I want to move the player bikes we have to pass the velocity well this is going to be my player velocity right okay next I'm going to say if keys and this is pygame dot k underscore right then I'm going to say player dot move underscore right again same thing I'm going to move this by my player velocity now it's important that before I do this I set my player velocity to be zero now the reason this is the case is because if I don't do this what will happen is as soon as I move left this is going to set my player velocity right which you can see here my X Val it's going to set the x velocity now once I set that I'm going to continue moving in that direction until it gets set back to zero so if you wanted to make it so when you press a key you just continually move in that direction until you press a different key then you could omit this but in our case we only want to move while you're holding down the key so I'm going to say player.xval equals zero there's a lot of other ways to go about doing this but I just wanted to stay consistent with our movement because of how we're going to do the gravity so for now just bear with me we essentially set the velocity to zero and then if we are moving left or right so if we're pressing these Keys then we change the velocity to be you know the negative player velocity or the positive player velocity based on the direction we're moving in okay that's actually all we need for handling the movement so let's put the handle movement function uh where are we going to put this we're going to put this before we draw so I'm going to say handle move I want to pass my player all right now I need to make sure before I do this that I call my Loop function okay and I pass my FPS and the reason I need to call Loop is because Loop is what actually moves my player right if you look at loop it's moving my player in the x velocity and Y velocity direction every single frame so if I set the x velocity well then I continue moving again if I set the Y velocity I move in that direction but that only works if we're continually calling this Loop function okay good so we've made great progress so far let's see now if we can move our player or if I've made any mistakes which are very likely so let's run the code and let's see okay so I'm going to hit my right arrow key you can see I can move to the right and I can move to the left obviously if I wanted to go up and down I could Implement that but we want to have it jumping which I will show you uh in a second but we kind of need Collision before we can do jumping very good all is looking great so far now let's Implement gravity so we kind of fall down then we can do uh kind of the Sprite sheets then we can do the Collision because the Collision makes more sense I guess once we have the uh the Sprite sheets done so let's Implement gravity now gravity is a little bit complicated because we want to have um like kind of a realistic gravity right that actually implements some basic physics what I mean by that is rather than just having a constant velocity we want to actually have an acceleration for our gravity so as many of you know if you're in physics gravity um the acceleration is negative 9.8 meters per second squared I believe that's what the acceleration is anyway in our game we want to emulate something similar to that where it feels like the longer you're falling the faster you fall you're not falling at a constant speed that makes the game just feel like really really unrealistic so the first thing we need to do is pick some value that we want our gravity to be and this is the acceleration of gravity so keep that in mind so for this I'm going to make a variable in my player class because it's the only place we need it right now I'm going to say this equal to 1. so gravity is equal to one if you want gravity to be faster obviously you increment this value right make it large okay now inside of loop this is where we need to handle our gravity so every single frame in our loop we're going to increase the Y velocity by our gravity however how we know how much to increase the velocity by varies on how long we've been falling for again I know this seems really weird but we essentially need to keep track of how long we've been falling so that we know how quickly we should be increasing our velocity or how quick we should be accelerating downwards so that means that I need to create a variable here called self dot count and given we should really call this something better I'll call it fall count and this will um essentially tell us okay how long have we been in the air for how long have we been falling and we'll use this value to determine how much we um increment our velocity by so I'm now I'm going to say myself.w underscore velocity and I'm going to add to this the minimum of 1 or and I'm going to take my self.count and this is my fall count divided by the frames per second multiplied by the self.gravity now this isn't truly what the acceleration would be but this will give us like a kind of somewhat realistic looking gravity in the game so just bear with me here so what we're doing we're taking our fall count we're dividing it by FPS the point of this is that if I want this value to be in seconds then I need to take whatever my count is which I'm going to increment every single Loop in fact we'll do this right now plus equals 1 and I divide it by FPS so if my FPS is 60 as soon as this is 60 then I've been falling for one second I take that amount of time I multiply it by my gravity and then that tells me how much I'm going to increment my y velocity by however this is going to start out being really really small just like fractional decimal decimal amounts so just to make this a bit easier for us when we do our Collision I'm going to increment this by the minimum of 1 or this value so every frame we're moving at least one pixel down and it doesn't take us like a full second before we really start feeling any effect of gravity hopefully uh that makes a bit of sense you guys are understanding me here but just bear with me I've uh experimented with these numbers quite a bit so I think this should be fine okay so now that we have this what should happen when I just click run here is I should just start falling immediately on the screen and obviously until we have some platforms or Collision we can't really stop falling if we have gravity uh but let's have a look and let's see how it works right now okay so you can see that I've fall and notice I'll do this again that I start falling slowly and then it picks up the pace right so this is somewhat realistic to how gravity would actually work and that's what I was trying to implement when I did this now that we have done that it's time to move on and have some kind of Sprites or images I was going to do this later but I realized that we can't really do the Collision which is going to be Pixel Perfect Collision until we have some kind of images that's that's really what we need we need our Sprites so what we need to do here first is examine what our Sprites look like for our characters now remember all these characters pretty much the exact same they just look different but in terms of their movements their animations number of images they're identical so whatever I show you for one of these is the same for all of them hence why we can just kind of swap them out so when I go to mask dude here let's zoom in you can see that we have for example double jumper I just picked a random Sprite sheet now this sheet has six different animations or six different frames which represent what this guy's going to look like while he's kind of jumping or double jumping in the air so what we need to do is we need to split this one image into the six individual images and then Loop through those images at some frequency or some time so that we can show them on the screen and show in an animation right we need to kind of manually do this now some of these are single frames like falling is just single frame that's easy hit okay this is um like you know the guy disappears for a second kind of expands goes back you get the point where you want to Loop through these animations idle single frame actually no idle is not a single frame it's a bunch of frames this guy's arms are kind of wagging up and down we have jump a single frame run a bunch of frames and then wall jump now notice here with these images that they're in different directions or let's say they're all kind of facing right so another thing we're going to have to do is rotate this image to face left when our character is facing left so that's another thing we have to handle that not only do we just have to split these images up we also have to get a rotated version of them so that we can show you moving in a different direction same with jumping same with being idle like whatever Direction you're going we need to show the image flipped in that direction uh so not rotate sorry flip that's what we're gonna do okay so let's do this first thing I will do actually is I'll write the function that will flip our image so I'm going to say flip Sprites this is going to take in a list of Sprites and I'm going to return High game dot transform dot flip and this is going to be Sprite true false notice as it says here this is indicating what directions you want to flip in when I pass true this means flip in the X Direction when I pass false this means don't flip in the y direction if you want to flip both you'd pass true twice but we don't want to do that so I have Pi game.transform.flip Sprite and then this is going to be four Sprite in Sprites really I could call this image but you get the point okay so we have flip now we're going to write a function which is load Sprite sheets and should we call it sheet or sheets I think sheets is fine and what this is going to do is load all of the different Sprite sheets for our character so it's going to give us the spreadsheet for double jumping for hitting for falling and then within our character we can pick what sheet we want to be using and what animations we want to Loop through so I'm going to take in directory 1 and directory 2 and the reason I'm doing this is so that I can load other images that aren't just my characters and this will be very dynamic I also want to take in the desired width and height of my image and if we need to load multiple directions so I'm going to say Direction equals false as a default parameter so that we only load like the left and the right side images like we flipped the images if you pass this equal to true okay now the first thing we need to do is determine the path to the images we're going to be loading so I'm going to say join assets der one dir 2. notice I can use join because I imported this from os.path okay now I'm gonna get all of the images in this directory now the way I do that is a phone I'm going to say images is equal to and this is going to be f for f in list directory again notice I can use that because I import it here we're going to list all of these things that are inside of this path directory and then we're going to say if is file and then this is going to be join path and F so what this for Loop is going to do here this uh I forget what you actually call this when you write a for Loop in a list anyways what this line is going to do here is load every single file only file that is inside of this directory so again we're just going to get every single one of these file names and then once we have those file names we can load that image and we can then split that image up into the individual images that we want okay so we have images now I'm going to say all Sprites is equal to a dictionary and what I'm going to do with this dictionary is have key value pairs where the key is the let's say animation style and the values all of the images in that animation okay so I have all Sprites and I'm going to say for image in images and I'm going to say that my Sprite sheet so the individual Sprite sheet I want to load here is going to be equal to pygame dot image dot load and then this is going to be join path and image and then dot convert Alpha which is essentially going to allow me to load a transparent background image okay so we are loading the image which is just one of the files that we found right from this path and we just need to append the path to it right so whatever the path to the directory is plus the image name okay we're going to load that in we're going to get the transparent background now that we have this we need to get all of the Sprites in this image so I'm going to say Sprites is equal to and now this is going to be a list okay so again the processes load all of the different files okay we have all the files these are sprite sheets now we need to get all the individual images from the Sprite sheet and load those okay so I'm going to say 4i in range and then this is going to be Sprite sheet dot get underscore with integer divided by the width of the image that we're loading now width is going to be the width of an individual image inside of our animation or inside of our Sprite sheet so if I know this is say 32 pixels I pass 32 and then it gives me a bunch of images that are 32 pixels wide that's how I'm doing the loading so that's why I took width and height here okay now that we have that we're going to say surface is equal to High game dot surface and then this is going to be with height we're going to pass Pi game dot s r c Alpha which allows us to load again transparent images and then I'm going to pass 32 here which is the depth don't worry about that but this is what we need to load these images and now we need to create a rectangle which is going to tell us where in this image again image being the Sprite sheet that we want to take an individual image from and BLT it onto this surface I know this seems really weird what we're doing is we're going to create a surface that's the size of our desired individual animation frame we're then going to grab that animation frame from our main main image we're going to draw it onto the surface and then we're going to kind of export that surface that's the way that we have to do this so I'm going to say rectangle is equal to Pi game Dot rect and for the rect this is the location on our original image that we want to grab this new frame from so I'm going to say this is I multiplied by my width and then 0 and then the width and the height of my image okay now that I have that I'm going to say surface.blit blit really means draw and I'm going to draw my Sprite sheet but I'm going to draw this at 0 0 and I'm only going to draw the portion of it which is my rectangle so notice this is my source this is the destination and this is the area of my source that I'm drawing so in position 0 0 which is the top left hand corner of my new Surface I am drawing my Sprite sheet but I'm only drawing the frame from my Sprite sheet that I want okay then I'm going to say Sprite start append and I'm going to append my Surface but I'm going to make my Surface Two Times larger because that's what I want to do I want this to be bigger than the default size so I'm going to say Pi game Dot transform dot scale to X and then I'm going to scale to X my Surface okay again I know this seems a bit complicated but now we have essentially stripped out all the individual frames we've just scaled them up to be double their size so if they're 32 by 32 we've made them 64 by 64 that's what scale 2x does and now we need to handle the directions okay so now we need to say if Direction then all underscore Sprites and this is going to be image dot replace it's going to be dot PNG this is going to be an empty string plus underscore right is equal to our Sprites and then we're going to copy the same thing let's copy this and put it here and now this is going to be underscore left is equal to and this is going to be flip Sprites so what we're saying here is if you want a multidirectional animation then we need to add two keys to our dictionary here for every single one of our animations so for falling for hit for idle we need a left and a right side so the right side is the one that we already have so we're going to say okay all Sprite at and then we're just going to strip off the dot PNG from whatever the name of our base image was so that's going to give us run jump idle hit whatever the name of our files and then we're going to append underscore write or underscore left now for underscore right that's our basic Sprites for underscore left we need to flip all of those Sprites and we already wrote the function that did that now otherwise then what we'll do is say all underscore Sprites at image dot replace dot PNG with an empty string this just removes the dot PNG and then it's going to be equal two Sprites okay then we can return all of our Sprites all right probably one of the most complicated aspects of the code that we need to write so don't worry we are done now with loading images at least we'll have to load our block but that's going to be a lot easier than loading our Sprite sheets so this now will load a Sprite shoot for us now that we've loaded our Sprite sheet we actually want to start using this so inside of player we are going to grab our images so I'm going to say my Sprites is equal to and it's going to be load Sprite sheets and now I need to pass what I want to load so now I need to pass the main character directory and actually this is the main characters okay so have a look here so inside of assets right uh yes so we're joining assets with dur1 and dirt 2. so the first directory I pass is main characters and then I pass the second directory which is the name of the character I want to load so mask dude ninja frog pink men or virtual guy you can pick whatever one you want I'm gonna go with mask dude for now now for width and height uh the width and the height of this is going to be 32. so make sure you do this 3232 and then you pass true because we want a multidirectional Sprite so both the left and right side animations that's what we want okay now that we have that we are going to change our draw here so that we're drawing our Sprite now for for now we're just going to draw like one simple Sprite just so you see how it looks on the screen then I'll go through animating the Sprite and showing you how that works okay so rather than pygame.draw.rect I'm going to say self.sprite is equal to and then this is going to be self dot Sprites at idle now idle is one of the name of our animations right so if we go here you can see we have idle jump Etc so I'm accessing the key from my dictionary and then I'm going to access the first frame of this key which is zero because every single key is a whole like Sprite sheet right so now that I have my Sprite I'm going to say window blit and then this is going to be self.sprite and I'm going to blip this at self.rec dot X and self.rec.y which is the position on the screen and then if we want we can just turn off the gravity for right now so we can kind of see it on the screen it doesn't just disappear okay let's try this out let's just make sure it actually loaded correctly so let me run this and we got an error okay so let me see what error we got here um run this again it said key key error idle okay so the issue here is that since we load a directional Sprite we need to reference either idle right or idle left so we can actually do this by saying idle underscore Plus self dot Direction and then so long as we set the direction which we did here to left uh this should work so now it'll change based on if we're going left or right so actually you'll see that it should swap as we change directions okay let's try this now all right so now we have this guy facing left if I go right he turns right left right perfect now we want to see him animated so as I was saying let's get into the animation now this is actually going to be pretty easy because we've already loaded in all of the frames that we need so I know that we don't have a ton to show right now but a lot of the hard stuff is done for this video so just making you aware that all this time has not gone to waste what we need to do is we need to come up with something that has a way to kind of update our Sprite or update what we're showing on the screen so I'm going to write a function here called update Sprite and I'm going to take in self and I'm going to say Sprite sheet is equal to idle now this is the default spreadsheet if we're not moving if we're not jumping if we're not falling if we're not being attacked we use idle however if we are running or we're doing something else then we use the other spreadsheet so now I'm going to say if myself dot x velocity does not equal zero then my Sprite sheet is going to be equal to run so if I have some velocity in the X Direction then I'm running right so then I want to change this to the Run spreadsheet so now I'm going to say my Sprite sheet name is equal to and this is going to be my Sprite sheet plus and then underscore and then plus the self dot Direction perfect so now we just change the main Sprite sheet name so idle run jump whatever we add the direction to it and this tells us you know what exact Sprite shoot we want okay now that we have that what we're going to do is say these Sprites that we could be using for this animation is equal to self.sprites and this is in all capitals at the Sprite sheet name all right now that we've done that we need to essentially iterate through these Sprites and every few seconds change the Sprite that we're showing so it looks like we're animating so we need to add a variable here that is going to account for the amount of delay between changing Sprites so I'm going to call this the animation delay I'm going to make this equal to five okay now I'm going to come here and I'm going to say that my Sprite index which essentially a Sprite that I want to be using here is equal to my self.animation count which we're going to increment in a second integer divided by my self.animation delay modulus by the length of these Sprites that I'm using now let's just put some parentheses here for order of operations and let me explain what we're doing so we have an animation delay that's every five frames so every five frames we want to show a different Sprite in whatever animation we're using so if we're running left if we're idle whatever it doesn't matter we want to show a different one so we take the animation count we divide it by five and then we mod whatever the line of our Sprites is so if we have five Sprites then when we're on say animation count 10 we're showing the second Sprite right you get the idea so this is dynamic this will now work for any single Sprite so hopefully you guys understand how this animation count is kind of working but we're just trying to pick a new index every animation frames from our uh Sprites but we want this to be dynamic so we're using the length of the Sprites and again it's just it's dynamical work for any single Sprite sheet we have now we need to select our Sprites we say self.sprite is equal to the Sprites that we have access to at the Sprite index then we update our animation count by one now what we can do is remove this here from draw and we just need to Now call the self Dot update sprite from our Loop okay so now that we've done that we'll call this we'll update our Sprite every single frame and then we'll draw that updated Sprite on the screen okay let's run it and let's see what we get notice we have idle notice I can run to the right and I can run to the left now if you think this is too slow and some of you may argue that it is then you just make this number smaller so make this three okay and now it looks like we're running a little bit faster so it's completely up to you how you want to animate this um I'll do two for now and let's see if this looks better so actually I think three was a pretty kind of happy medium here so let's go back to three again you guys can change this is up to you how you want it to look okay now that we have that we're almost ready to start doing Collision however we need to introduce something known as a mask so I'm going to make another method here I'm going to say Define update now what we need to do here is essentially update the rectangle that bounds our character based on the Sprite that we're showing so there's different um like kind of sizes to the Sprites right some are a little bit taller some are a little push to the left or pushed to the right and the rectangle that we have we want to be essentially the same as the Sprite that we have again I know this seems a bit weird but we're going to do this we're going to say self.rect is equal to self Dot and then it's going to be Sprite dot get underscore rect and we're going to say that the top left of this rectangle is equal to the self.rect dot X and the self.rec dot y now pretty much what's going to happen here is depending on what Sprite image we have if it's slightly smaller slightly bigger whatever we're going to constantly adjust the rectangle specifically we're going to adjust the width and the height of it but we're going to use the same X and Y position that we've had for this rectangle if you don't understand that um it's fine it's not a massive deal this line is not crazy important but it's just trying to make sure that the rectangle we're using to kind of bound our character is constantly adjusted based on the Sprite that we're using now what's more important is this line which is updating the mask we're going to say self.mask is equal to pygame dot mask Dot from surface and this is going to be self dot Sprite now let me quickly explain this a mask is essentially a mapping of all of the pixels that exist in the Sprite so whenever we draw something on the screen we're really drawing a rectangle right but the rectangle may not have um nontransparent pixels right so only part of the rectangle is actually filled in hence why we get kind of a circular image a dynamic image whatever so what this mask tells us is where there's actually images or where's this actually pixels sorry and this mask allows us to perform Pixel Perfect Collision because we can overlap it with another mask and make sure that we only say two objects Collide if pixels are colliding not if the rectangular box is colliding if we did rectangular Collision then it constantly looks like we're hitting something even when we're not because the rectangle for our character is larger than where all of the pixels for our character are you've probably seen this in a lot of games before but what the mask does is solve that problem for us and allow us to do this kind of Pixel Perfect Collision it's very important though that you you call this mask if you don't do that this Collision is not going to work properly it needs to be masked because the Sprite that we inherited from here uses this rectangle and uses this mask property when it does the Collision all right so now that we've done this I just need to call this function so I'm going to go here and say self dot update and now we're done with most of what we need for the player so what we want to do now is we want to start adding blocks onto the screen and then letting a player fall collide with those blocks and then be able to jump because obviously we can't really jump until we have something to jump off of otherwise jumping in thin air doesn't make a ton of sense alright so let's create another class here and this class I'm going to call object and this will be a base class that we use for essentially all of our objects just so that the Collision will be uniform across all of them so again we're going to inherit from the Sprite class from PI game and we're going to Define our initialization so to find a knit we're going to take in self X Y width and height and name which for now is going to be equal to none but could be equal to something we're then going to say super dot underscore underscore knit which will initialize the superclass which is this one right here now that reminds me we need this as well in our Constructor for player so let's put that in player okay now we need to define a rectangle so we're going to say selfdirectangle is equal to Pi game Dot rect and then this is going to be x y width and height we're going to say self.image is equal to Pi game dot surface and then this is going to be width height and then we're going to say Pi game dot source Alpha like that if we spell Pi game correctly again this just supports transport transparent images for us my apologies and then we're going to say self dot width equals width self.height is equal to height and self dot name is equal to name where are they going to say Define draw I'm going to say self and window like this and then we're going to say win dot blit and this is going to be self.image and then we're going to blip this at the self Direct dot X and the self.rect.y okay I know I went fast essentially this is just a base class we're not actually going to instantiate this but this just defines all the properties that we need for a valid Sprite so we have a rectangle we have our image we are drawing the image and then in a class that we're about to use we're going to inherit from this and it will just save us from rewriting a bunch of functionality that we don't need so the idea here is that all we do is modify this image when we change the image now the draw function will automatically draw it accurately on the screen for us and all these other properties we're just saving in case we need them from our child class so I'm going to make a class now called block this is going to inherit from object now we're going to say Define a net and we're going to take in self x y and the size of our block now since the block is a square we just need one dimension not two right okay we're going to say super dot underscore underscore knit and we're going to pass x y size size so notice this Constructor requires four arguments so we have to pass four here we just duplicate size because it's the same for the width and the height then we're going to say block is equal to load block which is going to be a function that we write in a second that will take a size we're then going to say self dot image dot blit imagine that this is going to give us an image okay which it will in a second when we write it we're going to blit the block at position zero zero and then we're going to say the self.mask is equal to High game dot mask Dot from surface we're going to take our self.image and there you go we have our mask which we need for Collision again I know this is a little confusing it'll make more sense in a second but we're using this object which now has this draw function built in for us it also defines the rack that defines the width and the height and all of that stuff here what we do is we get the image that we need which we're going to write this in one second then we BLT this image to our image which is a pi game surface and then we say self.maski we'll do pygame.mask Dot from surface self.image we also could just say self.image is equal to the block but let's do it this way for now okay so let's now write our get Block function which I'm going to do beneath our get Sprite sheet or load Sprite sheet so I'm going to say get Block and I'm going to take in a size now what I need to do here is essentially find the block that I want in my train folder so I'm going to say path is equal to join assets and then this is going to be terrain like so and then we're going to use the terrain.png file so if I go here you can see that we have train terrain and then what we want to do is load this block which I'll be showing you how to load in one second okay now that we have done that now that we have our path we're going to say the image is equal to Pi game dot image dot load and we're going to say path again dot convert Alpha so that we get a transparent background we don't really need it for this one but just in case later we load something does have transparency we will and then we're going to say surface is equal to Pi game dot surface and for the surface we're going to pass size size which is the width and the height of our surface we're gonna pass pygame DOT Source Alpha with a depth sorry of 32. we're going to say rectangle is equal to pygame Dot rect and then this is going to be 96 0 size size now let me slow down for one second if we go to Terrain we can see that we want to load this guy right here now I've already done the math this image starts 96 pixels from the top of the screen so that's the reason I'm putting 96 there because I want to start at 96 so 960 is my position and then I want to load the size of this which I think is going to be either 96 or 64 or something along those lines anyways if I wanted to load say this terrain image then I would still have 96 but my y position would be different in fact the Y position would probably be a little bit less than 96 it might be 80 it might be 85 I'd have to like experiment with it to see exactly where this image starts but I just want you to understand that what I'm passing here when I say something like 960 I'm passing the position that I want to load the image from from the image right so I'm picking out a part of this image and this is like 96 0. that's where I'm picking it right here hopefully uh you guys understand that but if you want to load a different train image then you have to adjust these to be the starting position the top left hand corner of whatever image it is you want to load here and if yeah I was going to say we could load a different one but I don't want to waste time guessing which one it is so you guys can mess with that if you want but let's just load this top one which I already know works okay now that we have that we're gonna say surface dot Blitz and we're going to Blitz the image and again we're going to BLT it at 0 0. but we're only going to blit the area of it which is represented by the rectangle then we're going to return pygame Dot transform dot scale 2X surface Okay so we've passed what size we want our block to be then we create an image that is of that size okay we then say rectangle is equal to 96 0 size size right and then we BLT this image onto our surface which will be the image that we return and we return this scaled up by two times so it just doubles the size that we pass here you don't have to scale it if you don't want but I want it to be larger so I am scaling it now I understand again it's a bit confusing this size is going to be the dimension of this block so you want to pass whatever the size from this Sprite sheet is that you want to get in our case I think it's going to be 64 or something along those lines so that's what size will be you guys can mess around with this but really what you're going to be changing is these two values and the size that's what you're going to change when you want to load a different image for your block okay so now for Block we have get block or load block uh did I call it load block or get Block I called it get Block okay so let's change this to be get Block all right so we now have our block let's create a block let's draw a block on the screen and let's do some collision with our blocks okay so let's go here to Main and let's say blocks is equal to and let's just start by creating a single block so for our block uh let's just put it kind of randomly on the screen for now uh where do I want to put this let's go with something like actually I'm going to create a variable first I'm going to say block size let's put this at zero height minus the block underscore size block size is going to be equal to 96 okay and then 4 B size we're going to pass block size okay so the size of our block is actually 96 I lied it is not 64. it's going to be 96. so we're going to create a block it's going to be positioned at zero height minus block size which is going to put it at the bottom of the screen and then the size is this now we need to draw our blocks so I'm going to pass blocks to my draw function okay and I'm going to go here and actually let's call this objects and we're going to say form objects or for obj in objects if we could type this correctly obj dot draw I'm struggling here with the typing and we will draw this on the window okay so we have our block now let's quickly look at this again right we load our image okay we get our block we have our size now we create the block down here and then we put it on the screen let's run it and let's see if we got a block and of course we've got an error what does it say here I need to run this again I take zero positional arguments but one was given okay so let's go to our player class here and we can see update I forgot to add the self parameter so let's add that in and that should fix it okay so now you can see that we have a block so now what we can do is create a whole floor of blocks if we want to do that and then we'll Implement gravity and then collision with the block so that you can see that you like can land on the Block and we can jump off of the block all right so let's make a whole floor so to make a floor we can do this we can say floor is equal to we're going to say block it's going to be I times block size it's gonna be height minus block size block size 4 I in range and I'm going to say negative width width times two um and we're going to divide this by the block size and by the block size okay then for my blocks uh let's actually just replace this and instead we'll just pass floor okay what I've done here with this for Loop is I've said I want to create blocks that go kind of to the left and to the right of the screen so I don't want to just fill the current screen because we're going to have a scrolling background in a second which we'll Implement in a minute anyways I want to have some kind of going to the left and so I'm going to the right so I'm taking my negative width uh over the block size which is how many blocks I want to the left side of the screen and then I'm taking my width times 2 and I'm interested dividing that by the block size again that's how many blocks I want to the right of the screen then I'm taking I I'm multiplying it by my block size which is telling me the x coordinate position that I want my block to be at and then this is always going to be the same because I want it to be at kind of the bottom of the screen and then for my block size well I want that to always be the same okay so let's run this now and see what we get and now we get a bunch of blocks so now that we have these blocks let's make it so we can collide with the blocks and so we have gravity and we actually fall onto those blocks so the Collision all right Collision is a little complicated but let's write it and let's see how we can how we can get it going here so inside of handle move is where we're going to handle our Collision which means we need to have a list of objects that we can potentially be colliding with now we are going to write a function here called handle vertical Collision because we need to handle the vertical and horizontal Collision differently for now we'll just start with uh vertical and we're going to take in player objects and the displacement in y that we just moved now we're going to have collided underscore objects is equal to a list we're going to say for object in objects these are all the objects we could be colliding with and we're going to say if High game Dot Sprites dot Collide mask and then we're going to pass our player and our object now remember I told you Collision was going to be simple well there you go this is all you need to do to determine if two objects are colliding the reason we can do this is because our objects we've inherited from the Sprite class and on them we have a mask so we're going to use this mask property as well as the rectangle property when we collide with the mask so I pass my player I pass my object and this will tell me if I am colliding with my object perfect now if I am I'm going to do some stuff differently depending on what direction I'm colliding in so if I'm hitting the top of the object it's going to be different than if I'm hitting the bottom so we need to handle that here so I'm going to say if my displacement Y is greater than zero really this should be velocity but that's fine then what I'm going to do is place my character on top of the object it collided with so I'm no longer colliding with it now what this is saying is if I'm moving down on the screen so if I'm moving down then that would mean I was colliding with the top of this object so if I am I'm going to take the bottom of my player rectangle which is my bottom my player's feet essentially and I'm going to make it equal to the top of the object I'm colliding with this is another advantage of using rectangles you can use this kind of bottom and top property and avoid having to do you know add the height and all that kind of stuff so that's what I'm going to do now otherwise I'm going to say if my displacement Y is less than 0 and I suppose this can be an L if then what I will do is say myplayer.rec dot top is equal to the obj.rec dot bottom because if I'm moving up which means I have a negative velocity then I am hitting the bottom of an object so I need to make my top be equal to the bottom okay this just makes it so you don't like say stay inside of the object excuse me you go outside of it and it looks like you collided but you didn't go through the object now one thing we also need to do here is we need to call the method player.landin and player.hit head which I've not yet created and we're going to write these to handle what happens when we land on a block and when we hit our head on a block okay then we're going to say collided objects dot append and we're going to append our object and we're going to return our collided objects just so that we know what objects we collide with so that we can check if we collided with like fire or a certain special object or something like that okay so let's handle vertical Collision now we need to write the uh landed and hit head method so let's go to player and let's do this so I'm going to say let's do it here landed self now what do we do if we lend it well if we just landed then we need to reset our gravity or our fall counter so we're going to say self dot fall count is equal to zero so that way we stop um like adding gravity right okay what else do we need to do if we land it we need to say that our y velocity is equal to zero if we let it on a block stop moving us down and I'll add this in now we're going to say our self.jump count is equal to zero we're going to do something with jumping that involves double jumping so we'll have a jump counter I'll just put this here now and then we'll we'll use it later okay so that's if we landed otherwise I'm going to say Define hit head for self I'm going to say self.count equals zero but if we hit our head I want to reverse our velocity so that now we move down because we're moving up right so I'm going to multiply my velocity by negative one so when I hit my head I kind of bounce off the block and go downwards that's what's going to look most natural okay so that's all we need for right now for hitting the head now we can add our gravity back and when we add our gravity back what's going to happen is we'll fall we'll hit the block I'll move us to the top of the block and then we should just be able to move on top of the block let's see if that's going to work though uh although it's not gonna work if we don't add the function call so let's add the function call here in handle move we're going to say handle vertical Collision we'll pass the player the objects and the player.y velocity and the Y velocity is essentially how much we just moved right okay very good now let's make sure handle move we need to pass our floor so let's do that all right let's run the code let's see what we get and boom look we land on a block and we can now run on top of the block and everything is looking very good to me okay so that's pretty good now that we're on top of a block we can jump and then we can deal with uh hitting blocks um what do you call this uh horizontally right so that we can't like run into a block and we'll also make the background scroll and then we'll be pretty good we'll have a lot of this tutorial finished I wanted to make us jump yes let's make it jump okay so let's go to our player and let's create a variable here self.jump underscore count is equal to zero now based on the way we've coded this jumping is actually quite easy I can say Define jump self and when we jump all we're going to do is say self.y underscore velocity is equal to the negative of selfdog gravity multiplied by whatever Factor you want in terms of the speed of your jump so I'm going to multiply Gravity by eight the reason I'm doing this negative is that I jump up in the air right so now that I've done this what will happen is as soon as I hit the jump key I'll jump up into the error it's pretty straightforward and the reason that's going to happen is because my y velocity will change and what will bring me down is the fact that inside of my Loop if I go to where Loop is I'm constantly applying downward gravity so what I'm doing is changing my velocity to go upwards and then I'm letting gravity take me down so that's kind of the benefit of how we've coded this jumping is very easy now I'm also going to reset my animation count to zero I'm going to say my jump count plus equals one I'm going to say if the self dot jump underscore count is equal to one this means that I'm double jumping so if the jump counts equal to one when I hit jump that means it's just going to be equal to 2 now actually let me take this sorry and put this down here then I will say self.count is equal to zero yeah I think does that make sense no I want to do it this way sorry okay so what I'm trying to do here is make it so that as soon as I jump I essentially get rid of any gravity I've already obtained so let's say I was like falling and then I landed and then I jumped there would be some gravity on me keeping me on the ground so I want to remove that gravity so that when I jump up it's not in uh the factor it's like it's not taken into account and then I'll start applying the gravity after I've jumped hopefully that makes a bit of sense but this should say fall count so as soon as I jump I'm resetting the fall count to be equal to zero so that any gravity I've accumulated I'm removing but I'm only doing that if this is the first jump I'm making because for the second jump I want you to have to time it based on like when you're jumping right so if you jump a second time close to when you jump the first time you will jump higher than if you jumped at like the peak of your jump when your gravity would be the highest okay I don't know if that makes sense but just just follow along here this I messed with this before this works trust me all right so we have jumping now I think that's all we really need for jumping um yeah that seems good to me so now if we want to jump let's make it so when we hit space we jump so we can do that inside of handle move actually I'm not going to do a handle move I'm going to do it here in the event Loop and the reason for this is that if I do it in handle move what's going to happen is if I press the jump key and I hold the jump key down I'm going to keep jumping a bunch of times I don't want to do that I just want to jump once when I hit the key and then I have to release the key and press it again to jump this tells me if I'm holding down the key what I'm going to do in here tells me if I released the key yeah you'll see um but yeah this is this is how I do it so I'm going to say if event DOT type is equal to pygame Dot key down I'm going to say if event dot key is equal to Pi game dot k underscore space and my player dot jump count is less than two so I'm going to allow double jumping right so I'll have two jumps then I'm going to say player dot jump okay that should be all we need for jumping so let's try it out and let's see if this works and I can jump and notice I can kind of Run and Jump at the same time now what I'll do now is add uh like falling and jumping animations because obviously it looks kind of weird right now when I'm jumping but there you go we can jump nice okay so let's add the uh the animations now so if we go to update Sprite all we need to do here is we can say if self Dot and actually I need to refer to my cheat sheet here because this is a bit more complicated than I thought okay I'm going to say if not self if self.y underscore velocity does not equal zero then what I will do is say if self dot jump count equals equals one then I'm going to say my Sprite sheet is equal to jump I'm going to say l if self dot jump count equals equals two then my spreadsheet is equal to double jump now this is actually going to be if my velocity is less than zero which means I'm moving up now the next one that I want to add is I want to say if and actually these are all going to be L IFS well not that one but this one I'm going to say elif myself.y underscore Val is greater than zero this means I'm moving down then my Sprite sheet should be equal to fall okay so this is handling regular jump and double jump and this is telling me if I'm falling let's try it now and let's see what happens when I jump okay so it's kind of glitching a little bit uh the reason this is happening I believe is because we are applying gravity even while we're on the ground so my y velocity is always greater than zero and then stops being greater than zero that's greater than zero again so I will show you how to fix this all right so actually the way that I'm going to fix this is a bit of a hack but it's it's gonna be good it'll work here so I'm actually going to say if myself the Y velocity is greater than self Dot gravity times two now the reason I'm going to do this for fall is so that I don't immediately start glitching into this false State when I have a really low amount of gravity being applied to me when I've gone off the block and then I've fallen down to the block so let me show you what I mean by just kind of kind of writing the code here so you can see that what happens is when I hit the block when I collide with it it's going to reset my gravity count and then I'm going to kind of Spawn to the top of the block so when I'm on the top of the block I'm going to be slowly falling down to the block then I'm going to hit the block when I hit the Block it's gonna do the same thing it's going to bring me to the top reset my gravity account so what was happening before is that we would go to the top of the block and then our gravity would increase a tiny bit right it would increase to be one pixel per second or something along those lines which would mean we were falling so then we were falling we hit the block and then it reset it so it kept glitching between the two states so what I've done is just made it so we have to have a significant amount of gravity before it starts showing that fall state so now it doesn't look glitchy on the screen as I'm jumping around and you can see that what actually happens is when I jump and I get to the peak of my jump you can see that it starts the falling State because now my velocity has changed directions right now I'm going down okay so now we have jumping now we have running around and colliding with blocks done quite a bit actually the next thing I want to do is make it so that objects move on the screen then we will do a horizontal collision and then we will pretty much be done after I add kind of that like fire uh state right or that let's call it trap something like that okay so we want to do scrolling background scrolling background is actually fairly easy the way that we do a scrolling background is we simply offset every single thing that we're drawing on the screen by a certain amount so any object that we have we don't change its position at all we just change how we're drawing it on the screen so it doesn't affect any of our Collision all it affects is what's seen right so what's happening in the background is we may be colliding at a really far position to the right we're showing the position currently on the screen you see what I mean but what this involves is having some offset X which I'm going to say is equal to zero now the way that I want to have it and I'll just illustrate here is that when I'm on the screen I only start scrolling the background when I get close to the edge so like here right it would start scrolling whereas if I'm in the middle and I'm kind of moving like this I don't want it to scroll the background until I get to the edge oh also notice you can double jump here I kind of forgot to to mention that part um so I'm going to implement that where essentially once we reach a certain boundary then the screen will start scrolling all right so how do we do this well we can do it just directly inside of our Loop here and we're going to do it here we're going to say if the player.rect dot X minus the offset X plus the player.rect dot width and actually now that I think of this we're just going to do this we're going to say if the player.rect dot right which will account for the width minus the offset X is greater than or equal to the width minus a variable that I'm going to write in a second which is scroll area width and the blair.x underscore velocity is greater than zero then we're going to say offset underscore X and this is going to be plus equals the player dot x velocity all right let me just write this variable then I'll explain how this works because we also have to do the other side so I'm going to say scroll area width is equal to 200 what that means is that when I get to 200 pixels on the left or 200 pixels on the right of the screen I start scrolling okay so here what I'm doing is I'm checking if I'm moving to the right that's what this checks if my x velocity is greater than zero that means I'm moving to the right and this is checking if my character is right on the screen like if it's crossed a specific boundary so I take whatever the right position of my player is which could be very far off the screen I subtract whatever offset we currently have so if we're offsetting everything by 100 pixels for example I subtract that so I know where I'm actually showing the character on the screen and I say if that's greater than the width minus the scroll area width which means I'm at say 700 pixels something like that on the right side of the screen then I'm going to offset the screen by whatever the velocity was that my player just moved to the right so that will make it look like I'm scrolling now we can say or and do the exact same thing for the left side so I'm going to say if player Dot rect dot left and this is actually going to be is going to be plus the offset I gotta check if it's Plus or if it's minus no it's going to be minus again minus the offset X is less than or equal to the scroll area width and my player dot X underscore Val is less than zero then I want to do this now let's move this down on the screen a bit I'm just going to add some parentheses so that my condition is correct here okay so I think that should be good again I'm checking to the left and to the right side if I'm moving to the left I want to check if I'm at that boundary if I'm checking to the right or if I'm moving to the right story I want to check if I'm at that boundary and then I increment my offset X now all I have to do to account for this is add an offset X to my draw function and draw every single object offset by this x so I'm going to go here and say offset underscore X and now just to all of my draw functions I'm going to pass offset X offset underscore X I'm going to go to all my draw functions and I'm going to add this offset X and what I'm going to do is just subtract the offset X from the X position I'm drawing everything out so we say minus offset X and we'll take in the offset underscore X okay now the reason this works if I move to the left my offset X is going to be negative which means everything is going to push to the right side because we're adding to the position for it if I move to the left side or sorry if I move to the right side the offset X is going to be positive which means everything is going to move to the left so it has a scrolling background effect let's just run it though and see if it works then I can fix it if it doesn't okay so as I start running here you can see that now the floor is going to start going with me once I reach this boundary however on this side right like when I'm in the middle is not doing anything I have to get to a certain boundary which is kind of invisible on the screen and then it starts scrolling with me which is what I wanted to do and then notice if I jump here boom I fall off the platform let's do collision with blocks in the horizontal Direction so to do that I'm just going to add a block here so I'm actually going to make a list I'm going to say objects is equal to Asterix floor now if you've ever seen uh like kind of dot dot dot in JavaScript that's what this does in Python it just essentially breaks this floor into all its individual elements and passes them inside of this list so imagine it if me just writing this here that's what it's doing and then I'm going to pass another block and for this block I'm going to place this at let's do zero and then for the Y this is going to be the height of the screen minus the block size times two now the reason I'm multiplying this by two is so that I get it a bit higher on the screen so that we can kind of run into it horizontally and I'm going to pass my block size so I'll just see now I want to go and rather than drawing my floor want to pass objects and same here with handle move on to pass objects so let me run this so now you can see that I have that block there right now notice that when I hit the block I kind of go to the top of it and the reason I go to the top of the block is because right now I'm only handling my vertical Collision so when I hit the block I have a little bit of gravity because remember there's always some gravity on me when I'm on the floor and so it thinks that I've hit the top of the block so it spawns me on the top of the block so we need to make it now so that when you hit the Block in the horizontal Direction it kind of Pops you off of it so that it doesn't think you're hitting the top of the block or the bottom of the block alternatively which you'll see in a second and in fact let me add one more block to show you uh hitting our head on the Block so let's add another block let's make this at say block size multiplied by three and then for the height let's do times four okay now we have another block let's see where this guy is now I can show you that I can hit my head on the Block right and I can't kind of go above it okay anyways we have that let's do our horizontal Collision so the horizontal Collision is a bit weird to implement the idea behind this is that since we're using our Sprite Collide mask we want to make sure that if we collide with a block horizontally we move ourselves off of that block so that it doesn't think that we're colliding with it in the vertical Direction now you just saw that happen we hit the block it thought that we were hitting it like the top of the block so it put us on the top of the block because that's what this line does right here so in our horizontal Collision we essentially need to check okay by moving in this direction are you going to hit the block if you are going to hit the block we want to prevent you from moving in that direction so that you don't hit it collide with it and then we like spawn to the top of it so let me write it and I'll explain to you how it works but it's just very important that we check the horizontal Collision first then once we check that we check the vertical Collision because we only want to check vertical Collision if we are not colliding with a block horizontally or if we haven't already handled or if we have already handled the horizontal Collision again the idea is we don't want to be thinking that we're hitting the block on the top when really we hit it on the left or the right side so we got to check that first so I'm going to make a function I'm going to say define collide I'm going to take player objects a displacement X like that now I'm going to say player.move and I'm going to move my player in the displacement X Direction and 0 in the y direction the reason I'm doing this is I want to check if with the current velocity that my player has if now the reason I'm doing this is I want to check if my player were to move to the right or if they were to move to the left would they hit a block that's that's what I'm checking essentially by moving the player preemptively so now what I need to do is say player.update now the reason I need to call that update and let's go here to dot update is because I need to update the rectangle in The Mask before I check for Collision so again what I'm doing is I'm preemptively moving my player to where they would be moving if they're going left or right I'm updating their mask and their rectangle and then I'm going to say four object in objects if pygame dot Sprite dot Collide mask and then I'm passing my player and my object so this is why I needed to update my mask and my rectangle so I move my player I update it and then using that updated mask I check would I be colliding with an object now I'm going to say collided object is equal to none I've got to spell collided correctly if I am then I'm going to say collided and this is just going to be object is equal to obj then I'm going to break okay then I'm going to say player.move and I'm going to move them back and then I'm going to say player.update okay and then I'm going to return the collided object okay so what I'm doing right I'm moving my player I'm updating the mask I'm checking if they would collide with something if they were to move in that direction then if they did okay I get that Clyde object it doesn't matter if they do or they don't after I check this Collision I have to move them back to where they originally were so I have to reverse the movement and then update the mask again then a return collided object okay again moving checking if we hit anything either way moving back to where we were before this is preemptively tracking before we allow them to move into a block all right now what we need to do is use this function uh to allow us to move left or right or to disallow us from moving left or right so I'm going to say Collide underscore left is equal to collide player objects and then negative player Vel then I'm going to say Collide underscore right is equal to collide player objects and then player and then I'm going to say and not Collide left and not Collide right again what we're doing here is we're checking if we should be able to move left or if we should be able to move right uh based on our current position that's why I make that preemptive movement and then here I only let you make the movement if that movement does not cause you moving into a block or colliding with one now that we have that that should actually handle our horizontal Collision that's actually all we need all right so let me run this code and let's see so I'm here okay obviously that's still working and you can see that I can't go through the block now let's go here and actually I'm getting a bit of a bug on the right side okay so that time it worked but it's a little bit glitchy and I have a feeling it has to do with the animation count of me running because it's only sometimes when I'm running and I hit the block that it spawns me up here so I'm just going to do another little hack here and I'm just going to multiply this by two both of them here the reason for this being that I'll just make it so there's a little bit of space between the block and that way me changing the Sprite isn't going to affect if I collide with the object or not because remember the Sprites kind of shift to the left or to the right a little bit so just by adding this multiplied by two it should make it so that I'm never going to be colliding left or right it will make it so as a bit of space see how there's a bit of space between the block now but that's okay because now I'm never going to have that Collision bug um where it's going to spawn me to the top and really you could probably just add one or two pixels but you can see that that kind of fixed it right there okay so now we have collision with blocks we have a scrolling background we have double jumping I think that the last thing that we need to add here is the fire thing right kind of that trap where you hit it and you kind of Flash and then once we've done that will pretty much be done the tutorial all right so let's write our class for representing our fire so I'm going to say class fire this is going to inherit from object as well and this is going to be animated right we're going to have animated fire so this will take a bit more work but I think it'll be worth it it looks pretty cool on the screen so I'm going to take X Y width and height and then I'm going to call my super initializer so super dot underscore squared knit self x y with and height okay and then for the name of this I'm actually going to call it fire remember that we can pass a name the reason I'm adding a name to the object is so that I can determine when I collide with the object if it's fire and if it's fire then I want to do something right okay so for self.fire I'm going to use our load Sprite sheets function for directory one this is going to be traps and for directory two this is going to be fire now if we go here to trops you can see that fire is one of our traps so we have hit off on okay now there's also a bunch of other traps right so you can you can pick a different trap if you want like you could pass this blink one or whatever the thing with these ones is that they have uh some more animations so there's a bit more logic you need to handle for them so that's why I'm going with fire because it's a pretty simple one to do now up here for fire I'm again gonna have my animation delay so let's make that equal three and now let's specify our image so let's say ourself.image is going to be self.fire off we're going to start with it off and then zero okay then I'm going to say self.mask is equal to pygame dot mask Dot from surface self Dot image like that okay then I need to set an animation count so I'm going to say my animation underscore count is equal to zero just like we did for our player and I need to set myself dot animation underscore name which for now is going to be equal to off okay now I'm going to make a few functions my first function is going to be on or my first method and I'm going to say self dot animation name is equal to on if we look at fire we see we have hit off on we're not going to use hit we're just going to use off and on okay now we're going to have off self.animation name is equal to off okay and then we'll have our Loop we'll say Define Loop self and inside of our loop we're going to do a very similar thing to what we did inside of our player Loop in fact so similar that I can copy pretty much all of this right here so let's copy all that and let's paste that here now for update rather than actually just calling an update method we'll just copy the stuff from the update method here and just paste it down okay and rather than self.sprite we're going to change this to image and I actually think that once we remove the direction here this is all that we need for our um all right so now we just need to make a few changes we're going to get rid of this Sprite sheet name and rather than Sprite sheet name we're going to say self dot animation name and now we should actually be good to just use this so let me space this out a bit we get our Sprites okay this isn't going to be self that Sprites no it's not gonna be selfdestrates it's gonna be self.fire which is this okay really I probably should call this something else but fire is going to represent all of our fire images okay so I'm using this to get my different animations I'm getting the animation name that I'm currently playing so either on or off and then I'm saying my Sprite index is equal to self.animation count divided by the self.animation delay mod the line of Sprites same as what we had before my image is equal to Sprites at Sprite index and then I increment the animation count update my rectangle and update my mask which is important for the collision and I'm good now last thing I want to do here is I want to just check if my self dot animation count is greater than actually if this divided by myself dot animation delay is greater than the line of Sprites now the reason I want to do this is so that my animation count doesn't get too large now you'll notice in my player class I actually didn't do this now that was intentional because if you do this then it kind of messes up how the double jump works you can do it if you want but you'll see that it kind of messes with things and with our player we're constantly resetting the animation account when we jump or when we go left or when we go right so that value doesn't really get too large but here for our fire since it's just static like it's just sitting forever what will happen is the animation count if we never change it back to zero we'll get to an extremely large number which can kind of lag our program so what I want to do is just make it smaller right so if it goes beyond what the actual animation um what do you call this is the line of the Sprites are then I want to set this to zero it's important I divide it by the animation delay though because if I'm dividing it here I need to divide it here before I set it back to zero okay so now we have fire I think that's actually all we need for fire so now we just need to add it to our objects so let's create it let's say fire it's equal to Fire and what do we need to pass for fire we need X Y width and height so we can pick where we want to put this um where do I want to put my X and Y okay for now let's go 100 and let's go height minus the block size and then I don't know how tall my fire is going to be I've got to see how big I want to make this let's make it say 64. and then we'll go 32 64 here okay so if we look at fire let's quickly have a look here and go to off for example or on the size of this is 32 by 64. okay that's what the size is and you need to pass that uh correctly to the fire class otherwise it won't load the image properly so we take our height minus our block size minus 64 which will put us on top of a block now I will put this at yeah 100 is fine for now for the X and yeah 32 with 64 height there we go we have our fire now I'm just going to say fire.on I'm just going to turn it on we'll just leave it on forever uh you can turn off programmatically if you want and then inside of objects I'll just place my fire now that I've done that it should just show up on the screen when I run my code so I got an issue let's see what the bug is here of course the output is not showing up correctly it says and it takes from five to six positional arguments where seven were given uh okay I see the issue here let's go back to our fire and we don't want to pass self let's remove self okay let's run this uh list index out of range self.fire off zero hmm okay I'm wondering why that's giving us an issue we have off here so that should have been okay so let's go here and let's print self.fire and let's see why it's giving us this uh this bug here all right so I've determined the issue and the issue is that I passed the incorrect size here it's actually 16 by 32. so I was passing too large of a size and that's why it wasn't giving us the correct number of images so let's change this now and run and now we should be okay and there we go now we have fire uh but however it is off now the reason it's off is because we didn't call the loop method on fire so let's fix that I can also get rid of the print statement that I put here that I don't need anymore okay so let's go down to Main and where we have player.loop let's call fire.loop and is asking for the FPS I don't know if I took that in my Loop here no I don't need the FPS for that so let's get rid of that okay now let's call it and it should start being on uh fire object has not shoot Sprite okay let's go fix that error my apologies fire we have Sprite somewhere here that we don't want self.sprite there's gonna be self Dot image and self Dot image all right start with that let's run it now and there we go we now have a moving fire and notice that I can kind of be on top of the fire right so I can collide with it and it's like Pixel Perfect Collision pretty much when I'm hitting it so now the last thing we need is to just make it so we go into that kind of hit State when we do hit the fire that's actually pretty easy to do we just need to add a kind of state to our player to know if we're hit or not so we're going to say self.hit is equal to false we also want to hit count because we're going to only be flashing for a certain amount of time then we're going to have a method here to find hit self .hit equals true and self.hit count is equal to zero then we're going to go in Loop and before our update Sprite we're going to say if self dot hit then self dot hit count plus equals one and then we're going to say if self dot hit count is greater than and we can just pick some value but let's say FPS multiplied by two which is going to be two seconds then the self dot hit is equal to false then we go here into our update Sprite and we say actually at the top here if self.hit it's important you put this at the top by the way so make sure you put it here then we are going to say the Sprite sheet is equal to hit great then we want to now determine if we actually got hit so we do that from our Collision functions which are going to be here all right so we have Collide left we have Collide right and we're going to have vertical collide now what we're going to do is we're essentially going to Loop through all of these objects and we're going to see if we hit fire now the way we'll know if we hit fire is by looking at all the objects that were returned here and it will tell us well if if we hit fire or not right it's because we can look at the name of the object and if the name of the object is fire then we know we hit fire so I'm going to say to check is equal to collide left Collide right and asterisk vertical Collide now I realize that inside of here I only returned one object whereas inside of here I returned all the objects I was colliding with vertically really we should probably be returning all of them from here as well but I think this is still going to work so we'll just leave it how it is for right now so I'm going to say 4 obj into underscore check these are all the objects we collided with remember I'm going to say if to underscore check and to underscore check Dot name is equal to fire then player.hit is able to trip okay that is all we need actually I'm going to say player.hit I want to call the method I don't want to set it equal to true so what we're doing here is looking through all the objects we collided with if any of them are fire then we will put hit on the player the reason I'm doing this first if to check is because these could be none right we could have no objects we collided with so I need to make sure I handle that case before I try to access name on an object that isn't defined all right let's run the code and let's see and player has no object no attribute hit count okay so let's go to player and let's go to hit count and let's make that equal to zero I guess I forgot to assign that all right let's try this now uh list object has no attribute name okay interesting uh let's see here okay all right so I'm using two check when I need to be checking obj so let's fix that and run the code Bool object is not callable okay player.hits aha so let's call this make hit it's because I have an attribute with the same name as my method so it's accessing the attribute when it should be accessing the method so I'm just going to say make underscore hit and now that should fix the problem for us run the code and there we go now it looks like I'm always being hit right now that of course is a bug so hit is equal to false let's check our hit count it's because if self.it so if the hit count plus equals one if selfdoh hit count is greater than self.he equals false maybe we need to reset our hit count as well okay and there's probably a bug here let's scroll down keep scrolling with our fire so we have to check if obj and obj and a name equals equals fire player.make hit okay I'm not sure what the bug is let me run this again and yeah it seems like we start out in the hit state so maybe it's an issue in here let's have a look here if self dot hit spreadsheet equals hit but we are we hit right away for some reason it's making us hit immediately okay let me have a look here guys and I'll be right back alright so I've realized I made a silly mistake here I actually had this collided objects append outside of this if statement that was causing all kinds of bugs and issues for me I think I was doing some print debugging so let me get rid of that here uh anyways I just moved it back now so that it's in the correct location so now if I rerun this now we should see that when I hit the fire it puts me into kind of this hit State last two seconds and then it ends all right so with that said guys I think that's pretty much gonna wrap up this video this showed you how to create a platformer how to do animations how to do Sprites how to do a scrolling background obviously there's a ton of stuff that can be added to this game but I really want to leave that to you obviously I could spend hours days months working on a game like this but I think this is a solid enough base to really give you guys a good foundation to go out there and create something pretty cool obviously there's all kinds of assets that I will leave in the GitHub that you can use I have all kinds of other Pi game tutorials that you may want to reference if you want to learn about menus sound effects um points scoring all of that kind of stuff you guys just go on my channel search Pi game tutorial you will see a bunch of them those will show you how to do a ton of other things that you know you may want to add to this game so I hope you guys enjoyed this this was a ton of work as always the code will be in the description if you did enjoy make sure to leave a like subscribe to the channel consider supporting me by purchasing something like programming expert I hope to see you in another YouTube video