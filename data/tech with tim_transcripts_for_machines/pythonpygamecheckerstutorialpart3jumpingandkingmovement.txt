okay so now that we have this what we need to do is actually allow us to select the piece have it selected and move to a valid square that also involves having to figure out where can we move to like what is a valid square right and if we move and we say jump over a piece how do we remove that piece how do we get rid of it you know can we jump and double jump like those are the stuff things we have to figure out now which are kind of difficult but obviously we're going to do them they won't be that hard okay so i'm going to make a another file inside of checkers and i'm going to call this game.pi now what this is going to be responsible for is handling actually the game so figuring out like whose turn is it did we select a piece is this piece good like can we move here can we move there that's what game is going to do and it's going to use board and a bunch of other stuff to do that for us it's also going to handle like drawing everything and a bunch of other stuff all right so now we're going to code out the game class now the whole point of the game class is going to be to let us actually interface with the board and the pieces and everything else with a few really simple methods so essentially i don't want this main kind of loop that's actually running and checking for us pressing buttons and stuff to be associated at all with how this game operates i want this game to be able to be operated by in theory to computers right i don't want it to be linked in directly to us pressing buttons and all of that because later on what we'll do is implement an ai so we can play against it right so we need to make sure that it's very clear that game just exposes some methods that we can use but it's not like it's not dependent on the fact that we're pressing certain things or that two human players are playing that's kind of what i'm trying to get at here with the point uh with with this so let's define the class let's import pie game like that and say divine underscore underscore net self and doing anything else for game we're actually going to take the window that we want to draw this game on so we could put the window in here if we want like we could define it in this game class i'm not going to just for the purpose that say we actually want to draw or play maybe like four or five chess games at the same time well we could in theory pass a window that is big enough that we could draw four chess games and then we could just pass subsets of that window to different games and play multiple games at the same time so i'm just trying to keep things flexible um we could define win here i'm not going to but just figured i'd tell you why so first i'm going to say self.selected equals none this actually reminds me that i want to go back to board and remove the selected piece because we're not going to use that inside of board we're going to use this inside of game to figure out what piece is selected by someone that's playing if they are and then next i'm going to say self.board equals board so that means from main here we're actually not going to make a board we're actually just going to make a game and the game will control the board for us so rather than having to get the piece move the piece all of that all we'll do is use the game to say okay we selected this row and column move it to this row and column and that will figure all of that out for us so self.board equals board next we're going to say self.turn equals red which means we need to import constants so from dot constants import red white uh what else would we need uh probably a few other things but we'll just leave red and white for now so self.turn equals red and after that we need self dot valid underscore moves equals a dictionary we'll talk about this after but this is going to pretty much tell us what the current valid moves are for whatever player is playing so that we can draw those or we can move those or whatever it may be next we're going to say self.win equals win so just store that window in here so we don't need to pass it every time and then what we're going to do is define an update method so update will just be like say we're updating the pi game display instead we'll just simply call this update method so we'll say inside of update self.board.draw and then anything else that we want to do to actually kind of update the game and then next we'll say pie game dot display dot update so now right if we go back to main all we have to do actually is instead of saying board.drawingpygame.display.update we'll say game dot update like that instead of making a board we'll say game equals game so now in theory we've just kind of wrapped some of this functionality and so i'm going to get rid of those two lines we're not going to use this right now and we need to import game but once we import game all we'll have to do is just use the update method the move method it's a lot simpler on this end when we do that so let's say from trackers dot game import game and let's run this and see if this works okay so i'm getting an issue missing up is a positional argument win so i forgot i have to pass the window to my game so let's do that and what is this now board is not defined as so we need to actually import board into game so let's do that and now let's try it and what's the error this time missing one required positional argument uh win okay so let's go back to uh game sorry guys and let's say self.win inside of the call to selftopword.draw okay and there we go now it's working so we can see that it all works the same we've just kind of wrapped it up and are using it a little bit differently all right so now let's go back to game and let's start defining a few other methods that we want so first i'm going to define a reset method this is pretty straightforward just say we want to reset the game and what we'll need to do is say self.selected equals none self.board equals board self.turn equals red and self.valid moves equals blank and in fact that looks really similar to what all this stuff is right so let's wrap this in a new method and let's just say define and let's actually just call this a knit so inside of the reset method we can just call a knit like that and i'm going to make this private just putting an underscore beside it so that no one else can call this they have to call the reset method and then here what we'll do is we'll just call underscore a net so the logic behind this is that since we're doing the same thing twice but there's a little bit difference in the init method here let's just put in a method that does it and rather than having the user um just call a knit right what i will do is have them called reset the reason for that is that init technically is initializing the game but we don't want the user to have to call in a nit method when they want to reset the game right so just for it so it's more clear for them we make this private so they don't see it they only see the reset and really all it's doing is just calling a net which is also used by the initialization of the game so it's just about what we're exposing and showing to whoever's using this class yes we ourselves are using this class but you have to imagine that maybe someone else is using it or maybe we're going to use it in a different capacity so it makes more sense to have methods that are named the right thing and then inside of a knit we're going to have self like that okay and this will be self.init and self.init my bad okay so now that we've done that i'm going to add a method for select so this will say select a row and column so self row call and we will have move so define move self row call all right great so this is pretty much saying all right when you select something you will call this select method you will tell us the row and column that you selected and then based on that whatever information we're currently storing in the state of this game will do something right so if you already selected a piece then maybe we'll move it or if you selected a different piece we'll change that selection right that's what we're going to do so i'm going to save self dot selected so if we have something selected because note right now select is equal to none then what we'll do is we'll say result equals self dot move of row call now this won't make too much sense right now because we haven't defined this move method but what i'm saying is okay if we already selected something then let's try to move what we've selected to the row and column that you put in here the point of this being that i'm actually going to make move private we only ever select something from the game so when we are like moving stuff around or when we're giving any input to the game we just call this select method we say okay i selected this i selected this i selected this blah blah blah and this will handle what happens based on that selection so we don't need to call move and select we just call select and select will determine whether or not we should move something based on what you've already selected that's what i'm doing at least might not make perfect sense but anyways i'm going to say if not result then self.selected equals none and self.select row call so essentially what's going to happen from this move method is if we were able to successfully move something so if the row column that we selected was valid because we already had something selected so we selected say you know a diagonal square that we could move to then we will actually move it but otherwise what we will do is select a different piece or at least try to select a different piece so we'll say um sorry let me reclarify this so what this is doing essentially is saying okay if we have something selected already that means we already pressed on some piece so we're trying to move the piece that was selected to whatever row and column we just passed here now let's say that doesn't make sense like maybe we pressed a red square and then we pressed a white square well that's going to mean that result is going to be false it's going to tell us hey no that wasn't valid like you couldn't move there so we do is we reset the selection and then we reselect a row and column so this is going to call this method again except now we're going to get into the else statement that i'll put here or not the else statement but we'll get into the rest of the code that i'm going to put here which will essentially say okay let's select this piece let's do that let's whatever right that's what it's going to do so we're going to say piece equals and in this case we'll say self dot board dot get piece row column so we've used this before but we're going to use it in here we'll say if piece does not equal zero so if we're not selecting an empty piece we're actually selecting something that's red or or black and and not black sorry red or white and self.piece.color and actually it's not self it's just piece.color if p stock color equals equals self.turn so whatever turn it currently is then what we can do is actually select that piece so let's say self.selected equals that piece and we'll say self.valid moves are equal to self.board.getvalidmoves which is a method we're going to define in a second and we'll simply pass in that piece and then we will return true to tell us hey this was right we selected something that's good otherwise we'll return false so this is just to tell the user hey this selection was valid so we're returning true to you if it's not valid we're returning false and that's the basis of how this works so again we'll go through it if we selected something then try to move it to whatever else we just pressed here if that doesn't work so we get a false back then say okay get rid of our current selection reselect something else which means call this method again and that means we'll do whatever happens here now we could put an else statement just to make sure in this case return false is fine just to make sure that we're not going to accidentally run this code after the self.select happens and we return back here if that's making sense because this is technically recursive but anyways that's what i'm getting at so we can go over this again later but i think that's enough of an explanation okay so now we're going to do move so move is called here and now we need to actually move something if this is called so we're going to say piece equals self.board.getpeace row oops comma call next if self dot selected so if we have actually selected something and the piece is equal to zero and the row call is in valid moves which is going to be self dot valid underscore moves so hopefully this is reading clean enough that it makes sense but essentially if we selected something and the piece that we selected is zero this is important because we can't move into a position that has another piece so only if we selected something and what we selected is actually not another piece because at this point we've okay so we've already selected something and then what the row and column that we pass here that we're trying to move to is not another piece if that's the case so actually i can't i don't think i can say yeah if piece is equal to zero from row and column that we just pressed on and the row and column that we want to move to right is in the valid moves then we can actually move it so we can say self.board dot move and we can move the piece which we would have had as selected so self dot selected we can move the selected piece to the row and to the column okay so i double checked that i'm pretty sure and this is right i've been confusing myself there's a lot of rows and columns and the same words everywhere we'll move the currently selected piece to the row and column that was passed to us here and this will work we've already set up how the board moves the pieces and then what i'm going to say is this will be weird because we haven't seen this yet but skipped is going to be equal to self dot valid moves uh you know what actually let's skip this because i don't want to confuse anyone if they if they don't we haven't yet wrote the code that we're about to try to like work with if that makes any sense but otherwise if this is not true we're going to return false and then return true if this actually works now the other thing we need to do is actually change the turn so i'm going to say define change turn self and we're going to say if self.turn equals equals red self dot turn oops self.turn equals white and otherwise self.turn equals red so change turn just to make this a bit cleaner to see and then we'll call self dot change turn all right so valid moves we haven't looked at this yet but this is going to be a dictionary of the valid moves that we can take from any uh possible position and then we have change turn which is going to say okay if it's red we'll go to white if it's white we'll go to red so pretty straightforward i want to see now if i can get select to work or if this is working the only problem is we're not drawing anything right so i won't really be able to see if what piece i've selected is working or not so we're actually going to have to keep writing code until we can really test this and make sure that we haven't messed anything up okay so now it's actually time for in my opinion what the fun part is which is trying to figure out an algorithm that can essentially be given any piece and determine all of the valid moves for that piece now unfortunately my um like drawing software isn't working i'm going to try to get it working if it doesn't then you'll be seeing me hand drawing something in just a second all right so now i got the drawing stuff to work fortunately so i don't have to actually go and get a piece of paper and film myself doing that but what i'm going to show you is essentially how we figure out what pieces are where what piece where what moves pieces can go to based on where they are that's a mouthful and i still didn't say it correctly but let's say we're considering this red piece right here that i'm filling in so this red checker essentially what are the valid moves for this piece i'm going to draw them in green so one of the valid moves would be this another one would be this right to hop over this piece but if i move this piece so i remove this blue one then no longer is that a valid move the valid move is if i can go back to green this one right here so this is actually kind of tricky because it looks simple it looks like just expand on the diagonals and figure out um where you need to move to just say okay is there you know empty space on the diagonals if there is you can move there right but then again what happens if i add a checker right here so i add a blue one right here i can no longer move here i can only jump over top and if i add another blue one right here at the end now i can't even move on this diagonal at all so hopefully you can understand kind of the complexity in this and why the algorithm we're about to write is actually kind of complicated to figure out where a chess piece is or a checkers piece is able to move essentially we need to look at all of the checker pieces on the diagonals of where that checker piece is and now imagine the situation in which this is a king so if we give him like a little crown or something that's sure this will be our king it's not really a crown but if it's a king it can move backwards right and it has the same rules applying to it except it can move backwards as well and then what happens when we can double jump right so if we have a situation i can't even i don't think i can even set one up where we can double jump uh let me see if i can uh okay let's see if we can get a double jump set up somewhere just to show you an example if i have a piece here and i have a piece here and then imagine that this expanded on technically a valid move is right here in this square for this piece it can jump here and then it can jump over there and capture both of these pieces and we need to keep track of what pieces we jumped over so that we know if we remove them so it seems pretty simplistic but actually moving these pieces is pretty complicated so let's consider the algorithm that i'm actually going to run through i have it up beside me i'm going to bring it up beside me at least and i'll show you what i'm going to do so the first thing that we're going to do is check the color of the piece so is it red or in this case is it blue but this would be white obviously i'm just doing it in blue because you cannot see white on this background okay so the color is it red or is it blue that determines the direction that we're going to move it in fact i think we already have the direction set on the piece as either negative one or positive one so let's say that we're considering something that's red we can only move down in that direction so what we're going to do is look on this left diagonal in this right diagonal for any valid moves for this piece we can only move diagonally again right so what are we going to do the first thing we're going to do is we're going to move down one row so whatever row this is on we're going to start from this row right here and we're going to if we're checking the left diagonal on the right diagonal we're going to check one at a time so i'll start by checking the left diagonal here i'm going to look to the square that is one left and one down so on the diagonal right here and say okay is does this have a piece in it or does it not have a piece in it so the two things here are okay if it has a piece in it is the piece blue or is the piece red so is the piece the same color as our piece if it is we can't move on that diagonal so if this piece right here is actually red then we can't move here right because we cannot have a red move into a piece where another red is now if the piece is empty so if there's nothing there we can move there that's a valid square so if it's empty then we say check okay boom we can go there that's fine if it has the opposite color piece in it then we have to keep moving on the diagonal and see if we can jump over this piece so if there is a piece on this diagonal we need to check the next piece here and see if we can move into that square so if there is not another piece in this next square over doesn't matter what color it is then this becomes a valid move and we can move into this square now this applies the exact same way on the right side of the diagonal as well we'll move over one and to the right and we'll say okay is there anything here in this case there's not so we can move there but if there was we need to check the color of it if it's the opposite color we need to check continuing on the diagonal and see if we can move over top of that color to jump it right and if we do jump that we need to keep track that this move would jump a piece so that we can remove that piece if we decide to take that move now where it gets a little bit more complicated is if you're double jumping or doing something else so actually let me just erase all of this just and draw a fresh grid because it's getting kind of messy here and i'll talk about how we handle the situation in which we're double jumping so let's just say this is our grid uh it's it doesn't have to be even or neat it's just for the purpose of showing you here and let's say we have you know maybe we can change the colors again we have our red checker here then we have a blue one and a blue one and we'll expand this out like that okay so technically we should be able to move here to this square to double jump so what i what i'm doing at least in my algorithm to check this is saying okay if we jump over a piece and we land in a square that doesn't have another piece in it from this square check if we can jump any other piece on the diagonals so we already know to check if we can jump a piece but imagine that there's a piece here and here technically this is a valid move because if we move here we can actually jump over to the other side and jump the other piece so that's something to be aware of as well so as soon as we go here i'm actually going to run the exact same algorithm i ran before right except this time i'm only going to consider a move valid if it jumps over another piece for the double jump or triple jump or so on and so forth so as soon as we jump a piece we immediately consider if from the current position that we jump to we can jump any other piece and if we can we add those moves to the valid move set so that is how we're going to do this i'll write the code for it which is more complicated than this and then that will be probably the hardest part of this video is writing this little bit of algorithm here all right so let's get into it now bring the keyboard back get rid of all the wires for my drawing tablet and there we go okay so what i'm going to do is i'm going to say define inside of board dot pi get underscore valid underscore moves and this is going to take self and do we want to take a piece or do we want to take yeah or we'll take a piece instead of row and call all right so first i'm going to say moves equals an empty dictionary what i'm going to do in this dictionary is store the move as the key so what place we could potentially move to as a row call so like 4 5 might be a available space that we can move to and i'm going to have this as the key being equal to any pieces that we jump to that move so say that we jump over the piece in three four to get to four five then that would be stored in a list that is associated with this key in the dictionary so you know more accurately be it like that so that we know if we move to this move we have to remove that piece because we jumped it all right so moves equals empty dictionary i'm going to say left equals piece dot call minus one oops because we're moving left one and then right oops equals piece dot call plus one so essentially just getting the you know what's left and what's right because that's the diagonals we're going to start considering and then row equals piece dot row like that all right so now what i'm going to say is actually i need to check something here yeah the direction that we have on this piece is actually if i can find it uh to have direction not going to be relevant so we can actually just get rid of it because we're not going to use that we have to do it another way that i forgot so inside of here what i'm going to say is if p stock color equals equals red or piece dot king we'll do something if peace.color equals equals white or piece dot king do something the reason i'm doing this is because we need to check whether we can move up or whether we can move down based on the color and based on if this piece is a king that's what we need to do now what i'm going to do is i'm going to define two more methods i'm going to say define underscore traverse underscore left which is going to look on the left diagonal for us because we're going to have to do this multiple times i'm going to say self pass and i'll fill in the rest of the parameters after and then next we're going to say define underscore traverse underscore right which is going to move to the right so we have two methods here that we're going to call from inside of here to kind of split up this algorithm and just make it a little bit more digestible and easier to see but for our traverse left i'm going to say where do we start where do we stop how much should we step by and what is the color left and i think one more thing skip only equals that or skipped equals that i'm going to copy these and i'm going to put them inside of traverse right now let me just explain why i've added all these so start stop step is going to be for the for loops we're going to put inside of here the step is the most important because essentially it's telling us okay do i go up or do i go down when i'm traversing through the rows for the diagonals am i going on the top left diagonal or the top or the bottom left diagonal right am i going on the top right diagonal or the bottom right diagonal skipped will tell us okay because we're going to call this method recursively which you'll see in a second have we skipped any pieces yet if we have we can only move to squares when we skip another piece right that's what this is telling us and left sorry this should say right in traverse right is telling us okay where are we starting in terms of the column uh when we're traversing to the left okay so that's what this is telling us so inside we're going to fill in traverse left and first right and then we'll use them inside of get valid moves so traverse left i have to look at my other screen here because there's no way i'm gonna be able to do this just off the fly i have to say moves equals a empty dictionary last equals an empty list we're going to say 4r in range r is going to stand for row start stop step so again the point of this is that i'm giving the parameters for my for loop in the uh or i guess i'm giving the arguments for my for loop in the parameters so that i can simply just put them here and this will tell me okay what row am i starting at what row am i stopping at and what am i stepping by awesome okay so start stop step next we're going to say if left is less than 0 break so if we get to a situation where we're now looking outside of the board so our left is no longer in the range of columns that we have because we're going to subtract from left every time in this loop in fact we can just do that like this at the end then we need to break all right so we're looping through all the rows and we're going to have a variable that keeps track of left for us that we just increment as we move through the rows this again will move us kind of on a diagonal pattern which is what we're trying to look for we're going to say current equals self.board dot get underscore piece and we're going to put r left like that so row and then left which is the variable keeping track of again the column that we're on i'm going to say if current equals equals 0 and now we need a more advanced thing inside of here and by the way we're going to copy and list all this for traverse right so once we do this there's just a few minor changes so if current equals zero meaning the current thing we're looking at if it is zero then we need to check if skip underscore only and not last then we'll say is break okay so to explain this is kind of complicated but what we're going to do and maybe it actually be easier if we call traverse left first just so that i can kind of illustrate this better in fact that's what i'm going to do i'm simply going to say here moves dot update self dot underscore traverse left and then what i'm going to pass is row minus 1 i'm going to pass the max of row minus three a uh and negative one and i'll talk about this in a second negative one piece dot call up wait is this correct sorry piece dot color we need the color and left okay so what i'm saying is i want to update the moves with whatever is returned from here which is going to be another dictionary i'm traversing left i'm passing row minus 1 which means okay if we're red we are moving up right so we need to move we need to check upwards to see if there's anything valid there so we're going to start remember this is the first parameter here start at the row above the current row that we're at we're going to say okay how far up are we going to look how many rows up am i looking well i'm going to look at row minus 3 or negative 1. so the maximum of that now negative 1 pretty much says stop at negative 1 which means look up to row 0 right which is a valid row and the reason i put row minus 3 is because i don't want to look further than 2 pieces away from where i currently am and if i start at row minus 1 and i move to maximum of row minus 3 right then what that means is i'm only looking to above the current row that i'm at at most so that's why i'm putting real minus 3. negative 1 is saying move up when we increment this for loop or decrement this for loop in this case the color obviously is the piece color and left is where we're going to start for our column and what we're going to subtract as we move upwards that's what this moves.update is doing now i'm going to do the same thing for moves.update with right except it's going to be changed a little bit so move.update traverse right the start stop step is going to be the same peace stock color will be the same except instead of left we're obviously going to pass right now let's do the same for white just to show you what i mean hopefully this will make it more clear and this order of explaining and instead of uh yeah traverse left is right except now instead of row minus one is going to be row plus one because we're moving down this time right and now instead of the max it's going to be the min of row plus three or rows right hopefully this is making sense and then instead of negative one it's going to be one and left and right is the same so i think that's right let me make sure i did that correctly yes it is and then outside of here we'll return moves so this method right here traverse left interest right will return as a dictionary essentially what moves.update is doing is merging this dictionary with the one we currently have so that we can have as many things as we want in that dictionary we don't have to say moves equals this and then go through and add them automatically this this method doesn't okay so hopefully that's making sense on how we're going up and how we're going down but what i'm saying is if current is equal to zero and we skipped a piece and we have not um seen a piece yet so it like we'll define last in a second but if we've skipped a piece and last which is a piece that we would skip to move to where we're going to go is not defined then break the reason for that is if the next square we look at when we jump over a piece is a blank square we can't move there because we need to jump to another piece jump over another piece to be able to actually make that a valid move now this will make more sense as i complete the algorithm i like to explain things as i go but sometimes you just have to walk through all of it and then kind of go through parts after so elif skip only we'll do something in a second and else we're going to say moves and this will be our left is equal to last all right and then finally what i'm going to do not finally there's actually more to this i'm going to say if and last why is that an error we'll see in a second so if last then we're going to say is if step equals equals negative 1 rho equals the max of r minus 3 comma 0 else rho equals the min of r plus 3 rows so this is now doing the same thing that we did before because what i'm preparing to do essentially is saying okay if we found an empty square and last had a um a value in it so there was like we found something uh when we were looping which you know what i'm just gonna keep going and then i'll explain this so if current does not equal zero what i'm gonna say is l if current dot color equals equals color break else last equals current we're going to put this inside of a list okay now we're i'm actually almost done with this but i just need to code out a good amount to be able to start explaining this so if current is equal to zero that means we found an empty square otherwise if it's not so if it has a color it wasn't equal to zero and it's equal to our current color so the piece we're trying to move is equal to our piece then we can't move there obviously we're blocked we can't jump over it so we break and we won't be adding any moves if that's the case otherwise we say okay if it wasn't our color it means it was the other color which means we could potentially move over top of it assuming that it's an empty square next so we say last equals current so then what happens in this instance we're seeing if we can jump right which is the complex aspect last gets equal to current we loop again and we look at the next row and we move left and we look at the other diagonal piece say okay if current now so this next piece is zero and if we skipped and not last break i'll talk about that after if skip only let's do that but in the situation where it's zero and none of this was true we add this as a possible move so we say okay if it's zero and last existed right then that means we can jump over it so we say moves r comma left equals last now in the situation where we find this first and we don't just find um a like a a piece that is the other color in between we will add uh the move but we just won't skip anything because last will be equal to an empty list all right now we're saying if last so essentially if current was equal to zero and last which means that we had something that we skipped over now we can actually skip it we're preparing to see if we can double jump or triple jump right so that's what we're trying to do so what we do now is we say okay what direction were we going were we going up or were we going down because we need to recalculate and this shouldn't say r plus r let's say r plus 3. we need to recalculate where we're going to stop because now we're at a new position when we recall these two functions so what we're going to say now is moves.update and we're going to say self.underscore traverse left which is the same one that we're doing here we're going to r plus uh step so either we're going up or down based on what the step is if step is negative one r will subtract one if it's one we'll add one say r plus step we'll say row and actually is it row sorry this should be r plus step yeah row and then in this case step because we already passed the step so we know what direction we're going in then what do we need to pass after that we need the color okay we're gonna pass left minus one and finally we're gonna pass skipped equals last okay so that's what we passed for that and then we'll copy the exact same thing move down a line and do this now except traverse right and instead of left minus one it's going to be left plus one all right so let me make sure i did this correctly i think i did but the whole point of this is like once we get to a point where we've skipped over something so in this case we we found a valid square we skipped over something we figured out okay now where are we going to go to figure out if we can double jump or triple jump what row do we stop at we call this again recursively which means just do it again and see if we can double jump or triple jump from this position and then we actually can just break here it won't matter if we put a break or not because based on the way that this for loop is set up it won't run anymore but i'm just going to break just so we're clear that after we do this there's no more valid moves in this current iteration and now i need to fill in this pass here for skip only but it should actually just say skipped okay so let's go to skip now if skipped we're going to say moves r comma left and yeah r yeah r comma left equals last plus skipped so essentially if we're in the situation where we found a valid move uh we skipped over something right now what we can do is we can actually sorry this isn't this is the situation where we're double jumping something we will combine the last uh checker that we jumped with the checker we jumped on this move into this moves skip so that we know whether we can jump one or whether we can jump two and which ones we need to remove this is all going to make more sense as we continue doing it but just it's hard to explain this because it is a really kind of abstract complicated algorithm without really a visualization now the reason we have this break here again is essentially we're saying if we've skipped over something we found a blank square and we don't have anything that we can skip again we can't move there that's what this is saying so that means all we have to do here is check if we've skipped because if we skipped and we did find another thing that we can skip over then we can update the move or add another move that has the last plus this one if none of this is true if we didn't skip anything so we're on the first one as soon as we find an empty square this is valid moves our left equals last right and there we go and then we check and do this recursive call to see if we can skip any more from that blank space that is kind of how this works again hard to explain but that's what we have to do to get this work and now i'm going to go traverse right i'm going to copy all of this and we're just going to update a few of the variables so instead of left we're going to say right and instead of write being less than zero it's going to be right greater than or equal to rows and actually not rows is going to say calls now current that's fine instead of left again this says right so pretty much anywhere says left just substitute it with right and some of the minuses and pluses will have to substitute as well uh yep and this would say right so right minus equals one that's gonna be right plus equals one and so left so it's gonna be right that can stay the same with plus one and minus one and let's see if there's anywhere else i think that should be good and finally let's return moves from this and from this okay so this is the algorithm to determine the valid moves based on a piece right so given a piece tell us all the valid moves this will do it i don't think i messed it up at all and now what i want to do is just add something that can draw these valid moves so we can actually make sure that this is working so next what i'm going to say is define draw underscore valid underscore moves and why is this break giving me an error let's see what it says instance of list has no get piece method current equals self.board oh oops sorry so this should say self.board my apology guys we're gonna have to make quick fix here line 78 self dot board are left because we're inside board not game i forgot so the internal representation is different and then here same thing self.board are right okay so that should be good now let's go to draw valid moves let's say self we can say do i should i say moves i'm just going to look at where i've done this before so actually what i'm going to do is i'm going to take this method sorry and i'm going to put this inside of game just because game handles most of the drawing so inside of here we'll say define draw valid moves self moves and then what we will do is we'll say okay uh we need to just draw squares for all of these valid moves so we'll figure out their row and their column and then just draw a circle there for each move so we'll say 4 move in moves and then we will get the row and columns we'll say row call equals move remember all the moves are going to be a dictionary okay so we say row call equals move this loops through all the keys of the dictionary which coincidentally is the rows and columns that are a tuple for us there so row call equals move and then pygame.draw.circle we'll draw it on the surface which is self.win and then what we will do is we'll draw it what color do we want we want blue which i'm going to import from here so blue like that we'll say self.x oops not self.x we have to actually calculate self.x so i'm going to say row multiplied by square size rho multiplied by square size minus square size over over 2 that should give us the middle and then same thing with call so call times square size minus square size over over two we've already talked about how that works so i'm not going to go over it again and then we need the radius which in this case let's just hard code at 15. okay so square size we also need to import so let's import that like that and i think that's all i need to do for draw valid moves now inside of draw or inside update sorry where is that i've got to find where the update method is we'll say oops self dot draw valid moves and we'll pass the self dot valid underscore moves or self dot board dot valid moves okay so i think that is or no we have it stored inside of here what am i saying sorry guys after an hour and almost two hours of recording the brain starts to go when i'm talking and doing all this but anyways self.valid moves which is stored in here which should be updated when we select a piece and now i apologize it's been like 40 minutes since we've tested this but i'm going to run this and see what is happening oops what is this going on here let's go back here okay so now when i select something nothing is showing up which is great and let's just check check this okay so i realize why nothing is showing up because i just looked at this here we have not called the select method of our game at all so we need to actually call the select method so what we're going to do to do that is we're simply going to say game dot select row call whenever we press on something and that should be good let's check that out and actually what i'll do here is say if game.turn equals equals red so pretty much just make it just let us select the red ones is what i'm saying here because later we'll make the we need to import red later we'll make the white ones the ai but let's run this and see now if we get anything okay so select and okay so it's giving us some moves but clearly these are not valid so i'm just gonna have a quick look at the bug that i made and then i will be back and we can discuss what is going wrong so i've made a stupid mistake here by mixing up inside of the draw move the draw valid moves uh the row and the column so i was like looking through all my code like what the heck did i do wrong like where did i break something when in reality this just needs to be changed from call and row because i'm drawing the row uh on the i'm drawing like the x and y reversed so i was like this looks like it's like getting it right just drawing it opposite that's exactly what it was doing so i did some debugging and figured that out i'm trying to figure out where else i think i printed some stuff out that i want to remove uh maybe not anyways okay but that was the major issue also there was a small mistake i had a break statement i think i went over this but on line 91 uh 92 the break stand was indented just needs to uh in and i guess in indent is that what you want to call it out here so it's in line with the if statement same thing here in traverse right so let's look at this now all right so one more error here in this draw method i just looked at i'm like what the heck what have i done wrong these negative signs need to be positive signs so what i was doing is saying okay we're going to go to the edge of the square so the top left edge and then subtract from the top left edge which meant we were going up into the other square which is why it was going off so that was the issue but now change those negative signs to positive signs inside of here between the square sides and square sides over two and hopefully fingers crossed let's click something everything looks to be working okay great so that's awesome so that is pretty much how this works to get the valid move so i apologize to everyone for butchering that horribly and i'm trying to make sure that the white and red i think the checkerboard pattern is good now we need to worry about actually jumping over pieces updating the valve moves you can see that work to actually move where i moved it but there's a few glitches so let's fix that now all right so let's go back into game let's go into the select method that i don't think i actually ended up finishing and let's just check and make sure this is all good so first of all i need to get rid of this else statement which i realize is a mistake and put it like that um i'm not gonna explain exactly why but just don't add that else statement that messes it all up you can read through this and and go back i think i explained kind of how this works okay so after that what we'll do is go back into move and now i'll make it so if we skip over a piece we actually capture that piece so we're going to move the position this is what we've done we'll change turns but what i want to do is check if the position we moved to had a piece skipped so i'm going to say skipped equals self dot valid moves and not peace we're going to say valid moves and inside of here i'm going to say row column now we say if skipped and then what we need to do is say self.board dot remove skipped like that and then actually we can just put change turn at the end because i think it makes more sense to go afterwards rather than before and looking at that i think that's all we need inside of here just double checking looks good now we need to add this remove method inside of the board class here so what i'm going to do is say define remove self pieces and what we'll do is loop through all the pieces and just remove the ones we need to so we'll say four piece in pieces and then simply say self.board and we'll say peace.row peace.call equals 0. so that should be as easy as it is to remove all of these loop through all the keys that are in this because it's going to be a dictionary or not dictionary it'll just be actually a bunch of pieces and we will simply just remove those pieces so we'll just set them equal to zero which you know at the same time we'll remove them okay so now that should work uh let's see how this works now if we run okay so let me go here now let's see if i can move white oh i can great and what's something that's happening here so i notice that when i'm moving it doesn't at the end of the move remove these valid moves so we have to do that so let's actually do that now let's go to move and yes at the end of valid move here where it says self.change turn let's go inside of change turn and let's say self.valid moves equals a blank list okay so that should hopefully fix that let me close this and restart it and now let's test some stuff out so first of all i can't move to any places that aren't valid moves right so click on a piece and try to move it somewhere else you can't you can only move it to a place that is valid so i can move it there now i can't move these pieces or even select them because it's not my turn but i can select the white so if i select this one here now let's go with the red and let's see if we can jump over and looks like it's working when we jump it actually captures it so really with that this is the finished checkers game what we have to add as well now would be checking if someone has one so i'll show you how we do that quickly and actually let's just make sure that the king pieces work properly before i say that that we finished the tutorial all right so we capture there capture there i'd like to set up some kind of double jump and make sure that that's going to work at some point too so let's do that as well actually um it's not doing a great job at setting it up though okay let's move this here um which turn is it now my turn okay let's go here we can go there i'm trying to move this i guess i can't move it down i wanted to move this one so we could double jump but anyways let's see if we can just get a king piece first as well okay so let's move that there this can go here that can go there all right move you here here go there and king okay that looks like it's working and now it's white and when i press the king i can jump backwards over the other pieces okay so that's great to see that looks like that is somewhat working now let's move this guy here and it's hard to play the same game against yourself i'm just trying to get a double jump setup so let's move that here and let's see okay so it looks like i can double jump and that this is indeed valid now it'd be cool if i could have done a triple jump in fact maybe let's let's see if we can get a triple jump and just really test ourselves out here and see if that's working so yeah triple jump i'm gonna make this guy a king and it looks like something went wrong so good job we were testing that list index out of range board are right so actually when i moved to the last square we had an issue so let me just look at the code and see what's going on there so first the mistake is here i had row equals equals rows obviously that's never going to be true because we can't move into rows which is 8 we can only move into potentially row 7 but based on the way it's indexing so i'm saying if rho now equals equals row minus one then in that case we can make this a king so that should fix the fact that that guy didn't go to a king but now i'm trying to figure out what the issue was with that index out of range and let's have a look at that aha so i found the culprit here again this max on line 69 should say min so what happened was we were maxing row plus three or rows which meant we were going to use whatever the larger one was so we'd use row plus three when we were traversing which meant we would try to go down from when we moved into that position and obviously that wouldn't work because there was no more rows to look at so let's just kind of run through and test one more time i'll add one thing to check if someone's a winner and then we'll pretty much be done okay so let's do that let's do that let's see you go there you can jump i just want to move a white to the other end to make sure that all of that is working okay let's just keep going and white okay so now he's king and now it's the red's turn and there we go he can move here okay so that seems to generally be working i'm going to test just one more time and see if this double jump works so this is crazy look he can go boom boom and if i go there it actually captures both of those pieces so this is working properly great so i am satisfied that this is functioning that the game is working we can move around of course you can add some music sound effects make it look better i'm not focused on that i always focus on the function first and now let's add one thing to check if someone has one and let's go actually back to board let's go to remove and let's update that method because i remember that i forgot to do something so now when we remove a piece i want to actually check if that piece does not equal zero first of all and so if piece does not equal zero if piece dot color equals equals red then remember we have this count up here uh for the red and white left that we need to update so now what we'll say is okay if p stock color equals equals red then self dot i believe it's red left minus equals one else self dot white left minus equals one now we can even add a winner onto here so we say define winner and this will return to us the color that won if they won so we'll say if self.red left is less than or equal to zero return red l if self.white left is less than or equal to zero return oops sorry this should be other way around return white and return red and then finally return none in the situation where no one won so return none like that now i'm not gonna actually like program anything related to that but what i'll do is simply just say if game.winner does not equal none then print game.winner could simplify that but this is fine for now and this is pretty much i'm just trying to show you if you want to check if they win just do this and then inside of here you can do something specific in my case i'm literally just going to print out the color of the winner because i can't be bothered to add any more to this now so with that being said this has been checkers all right so i am back and this is the next day and i just read through this code and tested it and i realized that i made a kind of small mistake at the end so i just wanted to hop in here quickly and fix it for you guys in case any of you were running into problems so essentially some of you probably noticed this but when i said if game.winner i didn't actually add this winner method to the game class i added it to the board class so that's fine we can just add another one to the game class that simply uses the one from the board class really easy fix but i just wanted to hop in here and show you how to do that so we're just gonna have to define winner inside of our game class we'll take self here and we'll simply just return self dot board dot winner so that's it let me just run this and make sure that everything's working now and we can see that it is and we're good to go so let's get back to the original video uh if you guys made it to the end of this video give yourself a pat on the back because i hardly did it is much more difficult than you would imagine to go through and explain about 400 500 lines of code especially because i'm doing this pretty much in one take only cutting out like any major mistakes i make so if you guys appreciate this please do leave a like subscribe to the channel all the code will be available in the description in case your game isn't working or something is messed up and yeah let me know you thought of this series and hopefully you're looking forward to adding to the ai to this which we'll be doing shortly