in this video i'll be giving you an introduction to kubernetes specifically i'll discuss what kubernetes is some kubernetes terminology and the basic kubernetes architecture after that i'll transition to the computer and show you how to create and connect to a kubernetes cluster then once we've created a cluster i'll walk you through a simple demo of deploying a basic flask website using kubernetes now if you want to follow along with this video and create your own cluster you can do this locally on your own computer or you can use a cloud provider like lenode which happens to be the sponsor of this video so what is kubernetes kubernetes also known as k8s is an open source container orchestration system used for automating software deployment scaling and management it was originally designed at google but now is maintained by the cloud native computing foundation kubernetes typically works with docker containers and microservices and automatically creates destroys and manages containers based on scaling and performance needs kubernetes allows you to easily scale your applications by running multiple containers and having requests load balance between them automatically kubernetes also prevents significant downtime by automatically recreating containers when they die and or crash and ensuring a predetermined number of containers is always running so to better understand kubernetes let me quickly describe some key terminology starting with a pod so in kubernetes a pod is an abstraction of a container usually a docker container but it can be other types of containers as well now pods are where your applications and microservices will be running and they have the potential to crash or to die now every single pod is assigned a dynamic internal ip address that allows it to communicate with other pods that are running every time a pod dies a new one is created and it will be assigned a new ip address next we'll talk about a node a node is simply some server that is running pots it's also commonly referred to as a worker and it usually runs multiple pods at the same time so pods are an abstraction of containers and then your nodes are running multiple pods or multiple containers at the same time continuing we have a cluster a cluster is simply the set of nodes that are running the pod slash containerized applications one cluster may contain many different nodes next we have what is known as a service now a service is assigned a static slash permanent ip address and allows you to communicate with different pods all of the requests being sent to a pod will first go through the service and this service will act like a load balancer and send requests to the appropriate pod typically the one that is less busy you can have both internal and external services now an internal service is one that's only accessible from the nodes within the cluster and an external service is accessible from outside of the cluster for example you may have an internal service for your database pods and an external service for pods that are running your publicfacing website endpoints lastly here we have a deployment now a deployment is the specification for what pods kubernetes should run and how many of them should be running a deployment is an abstraction over pods meaning you don't have to create pods yourself you simply define the images you want each set of pods to run and then the number of replica of those pods you want to always be running for example you may want to run three replicas of a pod that contains an api if that's the case you specify this in the deployment and kubernetes will ensure three replicas are always running if one replica dies it will automatically create another one for you so now that we have some of the key terminology down let's talk about the basic kubernetes architecture now i'm going to give you a very high level overview of how kubernetes works there's a lot of details i'm skimming over this will give you the basics just keep in mind there's a lot of other awesome features in kubernetes that i'm not discussing in this video this is meant to be a very basic introduction if you want to learn more then leave a comment down below and maybe i'll make a followup followup video sorry in the future so let's start here with how nodes function well each node must run three applications a container runtime so something like docker cubelet and cube proxy now cubelet is the application that interacts with pods and the node and cubeproxy is what proxies and load balances request to the correct pod based on the defined service so cube proxy runs on every single node and that implements part of the kubernetes service component so it's a lot more complicated than this but cube proxy essentially ensures that requests go to the right place so all three of those programs cubelet cube proxy and then some type of container runtime are required on every single individual node okay so now we need to introduce a new concept known as masternodes so in a kubernetes cluster you have master and slave nodes now the master nodes are what you as the system administrator or devops engineer would interact with and those manage all of the slave nodes and handle things like authentication so the slave nodes are those that are running the actual applications and pawns now in a large system you have multiple masternodes and these masternodes typically require less system resources than the slave nodes because they're not actually running any system applications they're just handling all of the slave notes so to clarify here let's go through a simple example let's say you have a cluster containing one masternode and three slave nodes to create a deployment and start running pods you send a request to the master node containing the deployment that you want to run the masternode then talks to all of the slave nodes and handles the creation of all of the necessary pods services etc so you don't have to manually touch any of the slave nodes or create any pods yourself the master node does all of this for you all you have to do is send it a deployment so essentially you're going to be interacting with the masternode using an api and then the masternode is going to do all of the heavy lifting for you handle all of your slave nodes and other servers handle creating pods and really everything that's going on behind the scenes so that is the basics on kubernetes as i said there's a lot of details i've left out here but this is really all you need to understand to start working with kubernetes and deploying some simple systems with that said let's hop over to the computer and create our first kubernetes cluster all right so i'm on the computer and the first thing we need to do here is create a kubernetes cluster now there's two methods to do this the first way is to use a cloud provider like lenode which is what i'm going to do in this video the second way is to set this up locally on your computer using something called mini cube now i recommend the cloud provider approach because lenode has sponsored this video and they're going to be giving all of you a hundred dollars in free credit for 60 days so it's completely free to follow along with this i actually think this setup is way easier on the node than it is doing it locally and this will allow you to get a feel for what it's like to actually work with a remote server and have multiple nodes running as opposed to doing it locally on your own machine where you're kind of simulating or faking it in a sense and you have only a single node which is your own computer that's going to be running the master node as well as all of the parts so again recommend the cloud approach but if you want to do it on your own computer that's totally fine i'll explain how to do that in a minute for now though you can go to the link in the description it is lenove.com tech with tim sign up for a new account and again you get a hundred dollars in free credit for this tutorial we're going to use like 15 cents uh worth of stuff just because we're only going to be running this for you know an hour or however long once you're done with the services of course you can delete them and you won't be charged for them okay so sign up for a new account i already have one so i'm going to sign in then i will walk you through how to create the cluster on low note all right so i'm on my leno dashboard and i just wanted to quickly mention that i've worked with lenode for over two years now i actually have a bunch of servers and development projects that are ran with lenode in fact we have a kubernetes cluster that runs a website and some apis and stuff that i have going on for my discord server anyways just wanted to mention that this is a great company work with them for a long time and there's a reason why they're sponsoring this video and some others on the channel regardless what we want to do is create a kubernetes cluster here so we're going to go to kubernetes and we're going to click create cluster now lenode has their own kubernetes engine which makes it really easy to set up a cluster and have everything initialized for you so you don't have to go in and do any manual setup yourself you just kind of look at this user interface here select what you want in the cluster and it will set it up for you so for the cluster label i'm just going to go with tutorial for now for the region i'm going to go with toronto they have a bunch of other regions you can select whatever one is closest to you and then for the kubernetes version we can go with 1.22 it doesn't really matter what version you select okay now we need to add a node pool so the node pools are going to be all of the individual servers that are running as a part of our kubernetes cluster so you can select which ones you would like and the quantity that you want to have now lenode recommends you have a at minimum three so up to you but you can do two you could do one you are going to run into some availability issues and just performance issues if you have less service right the more servers you have the more available your application is going to be and if i go here and notice that we have stuff like shared cpu dedicated cpu high memory a bunch of different options i'm sure you guys can read through the specs on your own for now though let's just go with three lenode two gigabyte servers which are ten uh ten dollars a month so i'm gonna click add here the quantity was three so i've added those in and if i wanted more well i could add those okay so now that i've done that i'm just gonna click on create cluster and this is gonna take a second and once it's created i will be right back all right so all of my nodes here have been created and if i go to the kubernetes tab you can see that i can click on tutorial and i can see my node pool which are just connected nodes right in the kubernetes cluster now it's automatically given them a name for me i have three of them and they are all running now that's as easy as it is to create a cluster i'm going to show you how to connect to this in a second but for now i will quickly go through how you can do this locally in case you didn't want to use the cloud provider so here is the mini cube documentation for getting started this is not overly complicated but it is a few more steps than the cloud provider so i'll leave this link in the description and what you can do is install this program called minicube and then you can run the command mini cube start and that will actually allow you to treat your own local device as a kubernetes cluster now again go through the installation i'm not going to walk through it because it differs based on your operating system you're going to start your cluster and then if you want you can look at the interact with your cluster and deploy applications although i'm going to explain how to do that in the next steps in this video so i'll leave that link in the description again walk through this if you want to do this locally so now that we've done that let me close this here what we need to do is install program here called cubectl so as i said what we're doing is we have our kubernetes cluster in our case we're having this hosted in the cloud if you're using minicube it's going to be on your local machine and we need a way to interact with the cluster specifically with the master node of the cluster so there's this command line tool called cubectl and you download this or install it on whatever computer you want not one that's running the cluster but one that's going to be interacting with the cluster so in the case of minicube yes it will be on the same computer but in our case we have a lenode cluster out in the cloud we install this on our local machine and then it allows us sorry to send requests to the cluster after we connect to it so just keep that in mind this is kind of our way to interface with the cluster this does not need to be on the same machine that is running the cluster or on the master node or anything along those lines we're just communicating with the masternode using this so i'll leave this link in the description as well you want to install this for linux mac or for windows right so whatever operating system you're on click on the appropriate link on this case i'm on windows and what i would do is use this curl command so i'd say curl hyphen lo i would paste this and in fact i'll run through the installation if you're on mac or if you are on linux it'll be slightly different so just click on the appropriate link anyways what i'm going to do is use this command so i'm going to open up my command prompt here i'm on windows i'm going to cd onto my desktop and i want to make a directory uh mkdir okay so let's say mkdir and let's go with k8 and i'm going to cd into k8 and i'm just going to run this curl command in the directory so that my program here cubectl gets saved inside of this directory okay so i'm going to run this curl command this is going to take a second to download and now if i have a look in this directory we can see that i have the cubectl.exe alright so now that that is installed or at least downloaded in our directory here i need to add this to the system path now this is going to be different if you are on mac or linux so you'll have to look up how to add a program to the system path it's not overly complicated from what i can remember but obviously i'm not on a mac right now and so i can't show you how to do that so you need to add this to the path the way you do this on windows is you type in env and you access the edit environment variables for your account you then go to the path variable and you either double click on it or click edit now inside of here we want to add the location of where we downloaded the cubectl.exe so i'm going to go down here notice i already have this because i installed it somewhere else but i'm now going to change the location so it's actually where i installed this uh this exe file where i downloaded it so in this case it's on my desktop it's in the k8 folder and then the name of it is cube ctl dot exe okay so there we go i'm gonna click ok ok and now it should be saved and now that i've added this the path again on mac and linux it's going to be different but you need to add it to the system path what you can do is open up a new command prompt here or terminal window if you're on mac or linux and type in cube ctl now when you do that you should get some output here if it says it is not a recognized command then that means you did not successfully add it to the path okay so now that we have cube ctl installed what we need to do is link this with our cluster now if you followed along with the lenode instructions you need to follow the following steps i'm about to go through if you installed minicube it should be automatically linked for you but if it's not you'll have to reference the minicube documentation anyways we're going to go back to lenode here and i'm going to download this cubeconfig file so the way i find this is i go to the kubernetes tab i click on my kubernetes cluster and you should see something that says cube config and then there's a yaml file here so what we're going to do is click on that and download it so i'm going to download it into this k8 folder and it's named tutorial and then cube config okay so i'm going to hit save now that i've done this what i need to do is create an environment variable that references this file and the environment variable needs to be named something specific i'll show you that in a second and once we create that environment variable then cubectl will know to look for that and to use this configuration file to access our cluster so this config file here i can click on view and i can have a look what's inside of it you can see we have a certificate we have our token essentially it has the authentication to our master node into our cluster so we're able to send requests to the cluster that are authenticated and we don't need to kind of do anything manually we just link this file essentially and again if you did this locally with minicube it should already be set up and connected for you so what i'm going to do here is go back to my environment variables okay and notice here that we have this environment variable called cube config now again on mac and linux to create this is going to be different you're probably going to have to use the export command from your terminal but on windows what i can do is simply create this variable if i don't already have it or edit so let me just delete it and let's recreate it to go through the steps so this is called cube config in all capitals and then the value of this needs to be the path to where you downloaded this file so the path of this file is c colon slash users slash tim slash desktop and then this is slash k8 and then the name of the file i believe is tutorial and then the path for this actually what i can do i should have done this before is just click on browse file or browse directory and now i can just go and actually find where this file is so it's in tim it should be in desktop and then k8 and okay so k8 and then the name of this is going to be tutorialcubeconfig.yaml so you just need to find where you downloaded this and put the path to the downloaded file again that's in the cubeconfig environment variable all right i'm going to click ok now we can see that we've created this environment variable cube config i'm going to click ok again now i'm going to restart my terminal window i'm going to type on cmd and now cube ctl should be connected to my kubernetes cluster and i will show you how we can test that all right so the command that we're going to run to test to see if we are connected successfully is simply cube ctl and then this is going to be get and pod now this is going to give us a list of all of the pods that are running now in this case no pods are running in our cluster but notice we didn't get an error from this command meaning we are connected and yeah we get this result no resource found in default namespace now as i go through this you will see a bunch of terminology that we have not yet covered for now you can simply ignore it for example namespace you don't need to know what that is just understand what a pod is a services and a node and then a few other things as we go through anyways that was getting the pod the next thing that i will do here is look at these services so let's say cube ctl get and then let's go with service now when i do this notice we have one service now this is the cluster ip and it is 10.12.0.1 this is a default service that's going to be on all of our kubernetes clusters okay so we've now looked at how to get the pods how to get these services we could also get a deployment so we could say kubernetes or not kubernetes cube ctl gets and then deployment like that and of course we don't have any deployments because we have not created any so now let's create our first deployment now remember the pod is the smallest unit that we have and we don't interact with the pod or we don't at least stack manually create the pods what we do instead is we create a deployment and the deployment specifies the pods that we should be running right now i will create the most basic deployment that i possibly can then i will show you how we write deployment configuration files and how we actually i guess deploy or execute those configuration files and send them to the masternode for now though let's create a simple deployment just so we can look at a few things i'm going to say cubectl this is going to be create and then i'm going to create a deployment but i could create a few other things as well like a service for example and i'm going to put the name of the deployment now here we can do something like mongodb because what i need to do is pass an image and the image is going to be what the pods should be running where the containers in the pod should be running so i'm going to say cube cto create deployment mongodb and then hyphen hyphen image is equal to and then i can put any docker image here from docker hub so docker hub is a place where a bunch of docker images are hosted if you're unfamiliar with docker then check out my docker tutorial i will leave it on the screen as well as a link in the description because i'm not going to be explaining all the docker concepts in this video regardless we place the docker image that we want this deployment to run for the pawns so now i'm going to hit enter and we can see that we have created this deployment so now if i run cubectl getdeployment you can see that we have the mongodb deployment and it's a zero out of one up to date one availability zero age five seconds now this is because it's booting up the container right now so if i do something like cubectl getpod you can see that we have one pod we have a mongodb pod that was created for us it has some id here and then it's not ready because we are creating the container so if i give this a few seconds then i run this command again we now see that this is ready the container is running and there you go we've just created a deployment the deployment then ran the pods for us and now if this pod were to die or to crash it would automatically be recreated by kubernetes for us there you go so that's as easy as it is to start working and actually deploying something out now the image that i picked here is just a random image i just picked the image just so we had something to kind of mess around with later i'm going to show you how we deploy our own image so we can actually deploy sample flask application for now though let's have a look at how we can do something like view what's actually going on inside of the pod so this is my pod id or my pod name so i'm going to copy that with ctrl c and now i'm going to use a command that gets the logs of this pod so i'm going to say cube ctl logs and then i'm going to paste the pod name now when i do this we're going to see everything that's happening inside of this pod now it may be pretty meaningless to us but sometimes this is useful for debugging and allows us to view you know what the output is in the pod okay so let's clear this let's run another command now another command that i have found very useful here is called exec now what this command allows you to do is actually get inside of the interactive shell for a pod so i can say cube ctl exec and then hyphen i t for interactive shell then i'm going to put my pod name which is this and then i am going to put hyphen hyphen bin slash and then bash now this is actually going to put me in a bash environment for this shell although i need to do sorry a space here after the dash dash so i just cleared the screen so it was fresh here but now you can see i'm inside of the interactive shell and inside of here i can type a command like ls i can cd into the home directory i can ls inside of here and i can essentially debug the container that's actually running or the pod that's running by getting into it in that way now if i want to exit i'll type exit and that will bring me back to my main commands line okay so those are a few basic commands to deal with pods and to deal with deployments now let's have a look at how we can delete pods and delete deployments so i can do something here like cubectl get and then pod all right this gives me the pod names let's copy this and now if i want to delete the pod i can do something like cubectl delete pod and then paste the pod and notice it's going to say that it was deleted however if i now go to get the pods notice that one is running with an age of four seconds the reason it's running is because as soon as this pod is deleted our deployment now has said okay well one was deleted we need to run another pod because this pod died or this pod crashed so just trying to show you here the power of kubernetes a pod crashed it died and knew a new one was automatically created so how would we prevent this from happening what happens if we actually want to remove say the entire deployment well i can do that i can remove the deployment so i can do something like cubectl and then i can say delete deployment so let's do this and the name of the deployment which i believe i called mongodb so now i've deleted the deployment and if i go to get my pods notice we have no pods because we would have removed all of the ones that were associated with that specific deployment all right i think that is really all i need to show you for the basic kubernetes commands there of course is a lot more stuff that you can do but this show you how to get the pod get the service get the deployment create a very basic deployment as well as how to delete a deployment and delete pods next what i would like to do is actually go through an example where i demonstrate how we deploy our own application because that's going to be a lot more useful than just going through some basic commands all right so now we're going to start going through this flask deployment now all of the code that you will see here will be available from the description you can click on the link that says github repository or something along those lines and you'll see the docker file the config.yml file main.pi as well as requirements.txt and i'll explain all these files in a minute however i want to start with this file right here so for this application we need to have a deployment and this deployment needs to specify what docker image we want to run that docker image is going to be a custom image that's going to contain our application and in this case we're going to make three replicas of it now what you're looking at is the configuration file for this deployment so often times when we are deploying applications it's not enough to simply run a single pod and all of the options for our deployment we don't want to specify in the command line so instead we put them in a configuration file and then we can use the configuration file as our deployment which i'll show you how to do later on for now that we have a very basic config.yml file i will not walk through every single line in this but i'll go through some of the important ones now so this is yaml yaml okay file extension mostly for configuration and inside of here i have an api version i have the kind of this file which is a deployment because we can create other things as well we can create a service right we can create a namespace we can create all these other things that i haven't necessarily talked about the only ones we're really familiar with are deployments and services so i do my kind i have some metadata the name of this the labels associated with this and then i have my specification for what i actually want for my different pots so i say replicas is equal to three now that means we're going to run three replicas of all of the pods that i specify here then i have selector i have my template and i have my spec here for the different containers that i want to run you can read about all of this uh all of these different what do you call it symbols or fields from the kubernetes documentation for now you can just kind of copy this file again from the link in the description and work with it and just change some of the important aspects so here i have my containers now the container name is going to be flask web and then the image is going to be a custom docker image i'm going to show you how we create this in a minute and then for the ports i'm saying i want to expose expose sorry port 5000 because that's the port that my flask application is going to run so this will now create when i send this deployment over to my masternode three pods that are running this image there are all explorers exposing port 5000 now the issue is we need a service that's going to allow us to actually interact with our pods and so what i'm going to do is paste down here a service now i put three dashes the three dashes means we're gonna have a new file here a new config and so you can place kind of as much as you want in a single file if you separate it with three dashes and now here i'm saying my api version is v1 my kind is service my metadata name is flask service and then for the specification what i need to do is essentially link different ports and i need to specify that this is going to be an external service the reason it needs to be external is because i want to be able to access the website from outside of the nodes right outside of the kubernetes cluster if this was something like a database or an internal api then i would not make this an external service i would make it internal because then only the applications in the cluster would be able to access it i understand this is a lot but just bear with me for now okay so we have our kind service metadata then we have our spec and inside of here we specify the ports that we want to have exposed and kind of linking with so in this case i'm saying okay port 5000 now what that means is that i want the port for this service to be 5000 so i'm going to go to the static ip address of this service which i will show you how to get and then port 5000 and that is going to proxy the request to the target port and the target port is the port on my pod that i want to actually access so in this case i want to access port 5000 because that's the port on my pod and i access it through port 5000 on my uh what do you call it on my service okay now i can make this port something different i can change the target port they do not have to be the same in this case i'm just making them the same and then the protocol of course is going to be tcp okay for the selector i'm saying this service is going to be for the flask web container or the flask web pod so that's why i have flask web flask web here right and then the type is going to be load balancer now this is kind of a misleading name but what this essentially means is that this is an external service all right so that is really all we need for this file here again i understand not all this is completely clear i don't want to explain every single line you can find that from the kubernetes documentation for now though this is the file we'll use to actually deploy our flask application okay so this is our config file however we now need to actually get the code for our app and see how we're going to deploy that so i have this main.pi file and this is what's going to be running my flask application again available from the link in the description but i just import flask create my app i create a very basic route it's going to render some html hello this is the main page and then an h1 tag that says hello and then i have if underscore name is equal to main i'm going to run the app and when i put the host of 0.000 that means that this is going to run on the ip address of the machine so rather than running locally on localhost it's going to run on the public ip address and then i'm running this on port 5000. okay so that is the main code of my app i then have requirements.txt which is for python just saying what requirements we need to run this python code in this case it's just flask and then i have a docker file now again i'm not going to explain all the docker stuff because i have an entire video on that but the docker file is essentially the image is going to be used sorry to create an image for my application so i have from python colon 3.6 slim this is the base image that i'm going to use i'm then going to run this command i'm going to run this command which is going to install python engines and build essential which i need to run my website and then i'm saying i'm going to copy the requirements txt file to the container and then i'm going to run the command pip install hyphen requirements.txt so inside of my container it's going to install flask then i'm going to copy the main.pi file i'm going to expose port 5000 on this container and then i'm going to run the command python3 main.pi which will start running my flask server now this will happen three times right inside of the three replicas of my pods so each one of them will be running an instance of the main.pi file and then the requests that are sent to this will be load balanced between the different nodes or between the different pods sorry okay so that is the code that i have so now that we've kind of walked through all of this we need to first create our docker file or sorry our docker image let's go here we need to create this image and we need to upload it to docker hub so we're actually able to access it from inside of this config.yml file so what i need to do here is go to my command line so now what we need to do here is build a docker image and upload that docker image to docker hub so actually i'm not going to go to my command line quite yet what i'm going to do instead is tell you to download docker desktop if you don't already have it or just download docker so you need to have docker on your system again if you're unfamiliar with docker i will leave a link to a video on it in the description but download docker once you've done that you need to create an account on docker hub docker hub is where you're going to host your image so it's accessible from your kubernetes cluster and then you are good now keep in mind your username because you're going to need that username so again download docker install that on your system and then go to docker hub create an account and once you know the username of that account you can follow along with the next steps so from your computer open up docker desktop if you have it and you're going to need to authenticate with docker hub by signing into your docker hub account so you can then push an image to docker hub so up here you should see something that says account or sign in or whatever so click on it and then you're going to be prompted to sign into your account sign in to the docker hub account you just created and then you should be automatically like linked with the docker hub account so you can push images to docker hub in this case i'm already signed in so of course i don't need to do anything okay now that i'm signed in though i'm going to go to my command line and now we can actually start writing some code so the first thing i need to do is build a docker image and push it to docker hub so i need to locate my docker file to build the image from so i'm going to go cd it's actually in my downloads and then a folder called not that called test okay so inside of here you see i have my config.yaml dockerfile main.pi requirements.txt now i'm going to build my docker image so i'm going to say docker build i'm going to put a dot this is the current directory where my docker file is that's why i'm putting dot then i'm going to do hyphen t for the name and it is very important here for the name of your docker image that you prefix it with the username of your docker hub account so i'm going to say tech with tim zero which is the name of my docker hub account slash and then you can put whatever name you want here for the image so since i already have one called flask web i'm going to go flask web tutorial okay so you put your username you put the name of the image or actually what may be called the repository that this image is going to be a part of and then colon and then the name of the actual image which in this case i'm going to put as latest now you can name this whatever you want i miss explain this a little bit again we have username slash and then this is your repository because theoretically you can have multiple images in the repository and then you put the name of the image after the colon here which in this case is latest you don't have to know what all of these mean so long as you have this kind of string right here and you can use it okay so now that we've done that i'm going to hit enter and it should start building my docker image for me from the docker file so once this is done i will be right back okay so we have now created this docker image so if i want to view the images i can say docker and i think just images and it will show me all the ones i have notice i was messing around with this previously and hence i have a bunch of different images but i also have tech with tim zero slash flask and then web tutorial so i'm going to copy this okay and now i'm going to push this to docker hub and this will only work if you signed into docker hub so let's clear here and let's push so i'm going to say docker push and then i'm going to push the name of the image that i just made so i need to add the latest here as well okay so docker push user name slash repository name colon name of image which is latest let's hit enter and then it should push it to docker hub alright so it looks as though this has finished and i've pushed it to docker hub so let's have a look and verify here so if i go to docker hub and i refresh we should see now that we have a new repository and we do it as flask web tutorial and if i click in here i can see that i have an image called latest and if i click into the latest image then i can see kind of all the stuff related to this image anyways i'm not super concerned about looking at that uh but we can see that we have tech with tim zero flask web tutorial latest that is our image so now that this is on docker hub this is a public image meaning anyone can view it so keep that in mind you only want to put open source code here don't put anything private unless you're going to make a private docker hub one but that kind of involves a few different things and now that we have this image we want to go to our config.yaml file so let's open up sublime text which is what i was using here okay y is select folder i don't want select folder okay subline text though and now all i need to do is inside of my spec here for the deployment i need to change the image that i want to run to be the name of the image that i just created now again for you guys it will be different i mean theoretically you can actually use this because it's public so you can just put in what i have here or put in your own docker image that you would have already created now i will mention that if you wanted to make multiple containers you would just copy this here and you put this here and then you just put whatever the other images that you want to run give it a different name maybe the container port would be different if you're exposing a port but that's kind of how you run multiple containers then all of those would be replicated three times anyways i don't want to run multiple pods or multiple containers i just want to run one and have it replicated three times so that is what i am doing here okay so i'm now going to save this file again make sure it looks like this you can download it from the link in the description and now that we have this file all that's left to do is actually put this on our kubernetes cluster and then we'll actually be able to view our flask website from the ip address of our cluster or from our servicer so i'm going to clear the screen here and i'm inside again the directory where i have this config.yaml file and what i can do now is type cubectl and then apply hyphen f which stands for file and the name of the file that i want to apply now in this case the file that i want to apply is called config.yaml so i'm going to hit enter here and apply this and it's going to create a deployment and create a service for me on my kubernetes cluster so now what i can do is type cube ctl get pod and you should see that we get three pods because we replicated the pod three times right and if i go cube ctl and get service this is actually what we want to look at here we can see that we have a flask service it is type load balancer meaning it is external again kind of a weird name here but that's what it means we have a cluster ip and then we have an external ip now the external ip is what i was talking about with the services that are external and this allows us to actually access the service from this ip address outside of the cluster so i'm going to copy this ip address and then i want to look at the ports here so when it shows me these two ports what this means is i can access both port 5000 and port 3002 are 32 000 sorry 194. both of these are tcp ports which are going to allow me uh to be rooted essentially inside of whatever pod the load balancer sends me to and then i will be able to hit the end point for my website okay so let's see if the pods are running now okay so they're all running so that's good to go let's check our deployments okay so let's say cube ctl get deployment it would be helpful if we spelt deployment properly and we have our flask deployment three out of three up to date available awesome okay so now let's go here and let's go to our browser let's paste in the ip address let's go to port 5000 and notice that i get my website there you go we just hosted a website this is publicly available assuming i'm still running this cluster which i probably won't be when you're watching a video you could go to this url as well and you would be able to visit the website now one thing to note here because i realized i misexplained something so for the ports for your external services they're actually supposed to be within a specified range i believe the range is something like 31 000 to 34 000 i don't know the exact range up what this means here is not that it is running on both of these ports that is incorrect it means that when i go to port 5000 it's kind of an alias for the port 3002 or 32194 and so that means i use port 5000 but really it's going to come in as this port when i put 5000 in my browser at least i believe that's what's happening here if someone knows precisely and they think i'm incorrect then please do leave a comment about from what i can tell that's what's happening here we're kind of aliasing this port which is actually the port it's going to come in through as poor 5000 but that still means that we can use port 5000 here to access the uh the website okay all right so that is going to wrap up this video now i know that i did not show you everything associated with kubernetes i'd not go through all of the different features but i thought this was a really good introduction video that even if you didn't follow along with at least gave you a decent idea of how these things work and how easy it is to actually deploy in this case a distributed system where we have multiple pods running the same website we're going to have a load balancer automatically set up for us and if we had a website that was getting a ton of traffic then we would just have more pods right and we could easily modify the deployment to replicate maybe 20 times 30 times 40 times whatever and kubernetes would handle all of that for us so that said i will wrap up the video here i hope that you guys found this helpful if you did make sure leave a like subscribe the channel thanks again to lenode for sponsoring this video and i will see you in another one