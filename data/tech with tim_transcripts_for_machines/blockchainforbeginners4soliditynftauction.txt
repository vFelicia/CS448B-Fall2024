hello everybody and welcome to another video in this blockchain for beginners tutorial series in this video we're going to be continuing from the last video and learning more about solidity once we learn a few new topics then we're actually going to work on an auction where we're going to be auctioning an nft now this will work with any type of nfts this is really really cool and if you're interested in nfts you're going to learn a little bit about how they work so with that said we'll get into the content in a second but i do need to thank cartesi again for sponsoring this video and this series they are an awesome company they've been helping me come up with the content for this series and they have a bunch of scaling solutions for ethereum and for developing smart contracts that we're gonna look at in a future video regardless let's go ahead and get into the content alright so i'm back in remix and in front of me i have the example that we finished in the last video which is kind of a mock bank account now what i'm going to do is just give you a quick recap of everything that's in this contract so we understand the syntax and get a quick refresher then we'll look at some new solidity features and we'll actually move into working on that auction which is going to be the bulk of the video okay so right now we can see we're inside of a dot sol file now the dot sol stands for solidity and that's the extension you need for your solidity smart contracts now at the top of our contracts we need a pragma line now the pragma line is going to tell solidity what compiler version we should use so in this case we're using 0.8.10 to see the compiler versions you can go to the solidity compiler extension click here and then it will show you the versions in this case 0.8.10 is one of the latest so that's the one that we're going to use great we then define our contract we say contract my contract open the curly brace and close the curly brace and inside of here is the content of our contract now it's worth noting that you can define multiple contracts in one solidity file and you can have stuff like contract inheritance that's a little bit complicated we don't need to look at that here but just wanted to mention that okay so inside of our contract here we start by defining what most of you would consider a class attribute this is just going to be actually a private member of this class because we've defined it as private anyways this is a mapping type now the mapping type is like a hash table or a dictionary where we have some key that can be associated with some value now in this case we're having an address this is going to be an ethereum address being associated with a uint so an unsigned integer we then denote this as private meaning we can't directly access this from outside of the contract and then we have balances that's just the name of this mapping okay now we have a function the function is called deposit it's denoted external and payable now external says that we can only call this function from outside of the contract so i couldn't go here and do something like deposit that would be invalid because this is an external function then we have payable payable is saying that this is either going to be sending money to someone or receiving money or specifically ether and in this case since we're going to be getting money we have to make it payable then what we do inside of deposit is we say balances at message.sender now message.sender is going to be the address of the sender of the transaction who's sending money to this contract so essentially whoever invoked the call to this contract or made the transaction to this contract it's going to be their address we're adding that as a key to balances and then we're going to increment the value here by message.value now message.value is going to store the amount of ether that they sent to this contract and the reason why we can do this is because the default value of all of our uins inside of our mappings is going to be zero so even if this sender does not already exist in the mapping we'll simply make the value equal to whatever the message.value is because the default value is 0. hopefully that makes sense that's explained in the previous video in case you are confused regardless we now have withdraw so withdraw is going to take in an address payable this is going to be our addr that's going to take a new int amount now this means that we need to pass an address to this withdraw function this is the address that we want to withdraw funds to then we have uint amount this is the amount of funds that we want to withdraw from the contract now this is a public payable function when we say this is public that pretty much means it can be called from anywhere and then we have payable and again what payable means is we're either going to be sending money out or receiving money so of course we need to denote this function as payable okay we then have a require statement now what the require statement is going to do is it's going to check if this condition is true and if it is not true then it's actually going to raise an exception and the exception is going to be insufficient funds that means we're actually going to cancel the entire contract call everything that would have happened is going to be reverted i'm going to talk about this more in a second and essentially this transaction is going to fail because this condition was not satisfied okay so you use require when you want to ensure that something is true before proceeding in the contract okay so we're requiring that the balance of the address is greater than or equal to the amount that we want to withdraw makes sense if we don't have that then the error or the exception is insufficient funds so next we're actually going to send money from the smart contract to this address if they had sufficient funds to withdraw so we're going to say bool sent bytes memory data is equal to adr dot call and then we're putting the amount that we want to withdraw and we're actually calling this transaction now if you're confused on how this line works i spent about three or four minutes explaining it in the last video so you can go back and watch that essentially all this is doing is sending money to this address this is the amount of money that it's going to be sending or the amount of ether great then we have this bool sent now this bool sent is going to be equal to true if we successfully sent this otherwise it's going to be equal to false so if we were not able to successfully send the money some error occurred there then we're just going to raise the exception could not withdraw otherwise what we're going to do is we're going to update the balances so we're going to say balances at message.sender minus equals the amount to make sure they can't just keep withdrawing the same amount of money it's actually going to subtract from their current balance when they withdraw great then we go to this function so this is get balance now let's say public view function now again public means we can call this from anywhere and view actually means that this is only going to be returning or accessing state from this contract it's not going to be modifying it so this means we can call this get balance function without actually having to make a transaction which pretty much means this is free to call so this is a good point in time to remind you that whenever we're just accessing the state of a contract this is free we can just query the state of the contract we don't need to pay for this however if we're going to be actually modifying the state then that requires a transaction that transaction needs to be mined and while that means it's going to cost us some money at least in gas and potentially ethereum if what we're doing requires that we send ethereum okay so let's continue explaining this we then have returns and then you end now returns is just stating what this function is going to return we're saying u in standing for unsigned integer and then here all we're doing is we're returning the address of this now this is just going to be the contract we're just going to cast this to its actual address and then we're going to get the balance whenever you have an address you can access the balance by just using dot bounce there you go that is everything that we did inside of this contract so now that we've talked about all of this i just want to spend a second talking about exceptions because we've seen them in this contract but i haven't actually talked about exactly what they do and how they work so in solidity we have a few different ways to actually throw an exception or to cause an exception to occur now an exception is pretty much an error that's going to occur in our program and all exceptions in solidity are state reverting now what that means is if there's ever an exception at any point in time during the transaction call then this is going to revert the state back to what it was previously any changes you've made up until that point will be completely removed so just to give you an example here let's say that i did something like balances at 1 is equal to 2. now i know this makes no sense but let's say i did this right here and then i come to this required line and this actually ends up raising an exception because sent is equal to false well if that's the case this line will be completely reverted we won't actually have done that operation it will be undone and reverted back to what it was before so just worth noting whenever an exception occurs any of the state in the contract that's been changed is going to be reverted now require as i'm kind of alluding to here does cause an exception right so if the condition here is not true then it raises an exception and the message for that exception is going to be whatever we put here now there's a few other ways that we can raise exceptions in solidity i'll quickly show them to you although we're not really going to look at an example of them so one way to raise an exception is to use revert now revert actually allows us to just directly uh reverse the entire contract state again this is just going to raise an exception exactly like require will except inside of here we can just put our error message we don't actually need to put any condition so if we ever encounter a revert in the program we're just immediately going to raise an exception the exception message will be this and again that's going to revert the state because that's what all exceptions do in solidity okay so that's revert now another thing that we have is a cert now a search is similar to require in fact it works in the exact same way except it's designed to be used when you want to check in variants rather than checking input validation so i'll show you here i could do something like assert true is equal to true now of course that's always going to be true but you get the idea now if this condition was false what would happen is we would raise an exception with this as the error message now assert and require are pretty much identical but the reason you use assert is because you're checking an invariant if you don't know what that means don't worry about it and if we're using require we're using that when we want to check input validation okay so that's why we're using require here because we want to ensure that the amount that they passed in is valid now in this case we could probably actually replace this require with an assert it's not a huge deal and there's actually not really any formal recommendation on which one you should use but it's kind of the standard to just use assert when you're checking an invariant and require when you're checking input validation so in this case based on what i'm saying we would use assert here because this is an invariant but we also can just use require like i had before that's completely fine anyways this isn't super important but i just want to show you those methods in case you see them in other contracts alright so that's almost everything for exceptions one more thing to note here is that the only thing that will not be reverted if an exception occurs is low level calls like this adr.com now i can't really show you what the other calls are because we haven't seen them but essentially if you were to send money to someone successfully and then later on in the contract there's an exception that occurs that's not going to be reverted you just can't revert that because once the funds are transferred well you can't really just transfer them back and so if i did something like this and let's say that this was successful then that means this is not going to be reverted now everything else will be reverted this balances will be changed back but this isn't going to be reverted the ethereum that was sent to that account is not going to be sent back to the smart contract okay there's some good reasons for that but that's worth noting now a few other things to mention here with exceptions exceptions are cascading now that means if i have an exception that occurs in another smart contract that i'm calling from this smart contract that's going to mean that the state of this contract as well as the state of the other one are going to be reverted so it's kind of hard to show this but let's say i make a contract and i call this my contract 2 like this and let's just make some functions so we can do something like function test and then just make this public view returns you ins okay and then maybe what i do here is i just say revert okay so that's what i do now if i call this function okay from inside of here then even though it's happening inside of this contract the exceptions occurring here it's going to cascade into this contract meaning that if any of the state was changed inside of here that's going to be reverted and same with any of the state inside of my contract too hopefully that makes sense but just keep in mind that exceptions cascade so even if you have like 10 contracts all calling each other and then in the 10th contract an exception occurs every single one of the contracts that we're dealing with that contract are going to get the cascading exception and all of them are going to have their state reverted and the transaction will fail now just to note here the reason why we're getting this error is because i didn't have the semicolon of course revert is fine i can put this here although this doesn't really make much sense because why would you just revert inside of a function all right so now that we've talked about exceptions what i can do is start showing you some new features in solidity and the first thing i want to do is show you a constructor so i'm just going to clear everything that's inside of this contract and i'm going to write a public variable here so i'm going to say let's go with address and this is going to be public and then i'm going to say that this is the owner of the contract so what i'm going to show you is a constructor now a constructor is simply a special function that's a part of a class or in this case a contract that's going to be called when the contract is initialized now in solidity your constructor will be called exactly one time and just like any other language constructor you can accept parameters in here you can do some setup steps and well you'll see how this works so the way you implement a constructor in this version of solidity is constructor open and close parentheses open and close curly brace and then inside of here you can do whatever you want so in this case i'm just going to say my owner is equal to the message.sender now the reason i'm doing this is so that i can keep track of who actually created this contract so when i create a contract i have a message.sender whoever sent the transaction to actually create the contract so this is perfectly valid i can say my owner is equal to the message.sender and now whoever deployed the contract will be the owner and i'll be keeping track of that inside of this public variable on the contract okay pretty straightforward that's how that works now again this is how you do the constructor you can only have one of them and this will be called exactly one time and only one time when the contract is deployed this isn't going to be called every single time a transaction is sent to the contract it's only called when it's deployed the very first time so let me show you how this works let's go and actually deploy this to the javascript vm let's click on deploy okay we have our contract when i click on owner it's going to give me the address of this account right here which is the one that i'm using now let's try deploying from this account okay so deploy my contract's down here owner now it's giving me the other own pretty straightforward that is how the constructor works and this is a pretty common thing that you'll want to do is keep track of who actually deployed the contract now another thing you can do in here is accept parameters so maybe i just want to accept a uint and let's just go with something like test for now again this can really be anything okay so i want this to be test and then what i will do is say u int public and let's just go with i don't know v i'm just picking random names for now and i can do something like v is equal to test that's completely fine i can access the value of this parameter so now let's get rid of these contracts all right so now we can deploy our contract and notice where the deploy button is it's actually giving me a parameter that i need to pass here it's saying tasks this is the uint256 so i'm going to do something like 2 hit transact now i go to my contract i have owner and i have v and i can see v is equal to 2. there you go that is the basics of the constructor now of course you can have multiple arguments if you would like or multiple parameters sorry and do whatever you please with them great so what i'm going to do now is just get rid of everything inside of here and i'm going to start talking to you about a new thing which is called a pure function now we've looked at view functions we've looked at payable functions internal functions external functions public functions now we want to look at pure now a pure function is pretty straightforward but it is simply a function that is not going to do anything with the state of the contract you can kind of think of it like a static method because it has no access to the internal state of the contract it just does some type of computations then returns some value so i'm just going to write a function here i'm going to say function and this will be something like add two now we will make this a public and then this will be pure function and this is going to return a u int like that now i'm going to take as a parameter here the u int x and all i'm going to do is just return like this x plus 2. okay very straightforward but this is a pure function now as i said a pure function is not going to modify or access the state of this contract it's just going to be performing some type of computation that doesn't rely on the actual contract internal state so just like accessing the data from a contract this is going to be free as well we don't need to pay to do this and let me prove this to you so if i go to my injected web 3 now i'm connected to the goreli test network and i do deploy this okay it's going to ask me for a i guess transaction because when i deploy i need to pay for that and then let's give this a second okay we can see that our contract is deployed now let's do something like add two five notice it gives me the value seven back i didn't need to add a transaction to be able to do this okay so whenever you have a view or a pure function these are free you don't need to have a transaction to call these so if you ever just want some type of utility functions associated with your contract then you make them pure okay hopefully that makes sense that's all i need to cover with pure okay so now that we've gone through that we can start getting into the important stuff which is events so i'm actually going to hop over to the drawing tablet to explain to you what events are and then we'll start implementing them when we work on the auction all right so i'm now on my drawing tablet i'm going to start explaining events to you but before i can do that i need to talk to you about why we need them so in front of me i have a smart contract now this is going to be our auction contract and on the auction we're going to have some function called start now of course we're going to have some other functions as well but for now just imagine we have start and what start is going to do is it's going to attempt to start the auction so it's going to modify some of the state and then it's going to return a value indicating to us whether or not this was successful so we're expecting this to be a bull let me just write this right here indicating that it's going to return a bool okay that's great so now we want to start the auction so let's say we have some account so account one like this we know since this is going to modify state we need to make a transaction to the auction to be able to start this so i'm going to make a transaction we're going to call start on here and then what we're expecting is that we're going to get some return value here indicating to us whether or not this started successfully well if we're just working on our javascript vm then we know that it's actually going to work successfully we're going to be able to get a return value we'll see something like true or we'll see something like false however if we're working on a real blockchain we're actually not able to return something from a function that's modifying the state back to our account so essentially whenever we're making a transaction we can't return data back to that transaction now this actually makes sense if you look at how transactions work but for now you really need to understand that if you ever make a transaction to a smart contract that contract cannot return you any data now it can try it can have a return statement but you're not going to be able to view that return data from the transaction so really we have to imagine that this is going to be a oneway operation where we're just going to call start now if an exception occurs we're going to be notified of that however if an exception doesn't occur we're not going to get any return value so trying to do something like this is not going to work on a real blockchain now that's a pretty big problem right because in a lot of situations when i make a call or i make a transaction sorry to my smart contract i probably want to get a return value i need some information i want to know if this started successfully however we can't have a returned value so how do we get around this problem well the way we get around this problem is with events so what a smart contract can do is it can actually emit events now that means that what we can do from auction is when we start this we can create or omit something known as an event and this event can have a return value that we might want this account to be able to see so we can emit an event that says something like started and then maybe we can put the time that this started out and we can put if it happened successfully or not so we could but true or alternatively we could put false now these events will be stored on the blockchain however they're going to be stored in a different way than the data associated with your contract so any of the variables you would have defined or kind of the state of the contract is said to be in storage these events are not going to be in storage they're going to be stored as a part of the transaction history on the blockchain so that makes them a little bit less accessible however they are much cheaper to use because of the way that they're stored so i'm not going to get into this too much but essentially just understand that your events are stored in a different way that makes them much cheaper to actually store although they are a little bit harder to access so that means that you usually use a thirdparty tool maybe something like etherscan to actually read and query these events because it's not as simple to go directly look at them like it is for the data on the contract and so we omit this event and then this account here or some external client that's off the blockchain is able to view these events and subscribe to them so they'll be notified if an event occurs now i'm going to get into a detailed example in a second but for now just understand that whenever we have a transaction our smart contract cannot return a value to that transaction instead what it can do is emit an event this event will be stored off the blockchain you can kind of think of these events as a log right we'll be able to then view those logs off of the blockchain and we can search for specific data inside of those logs and subscribe to events which means we'll be notified when an event occurs now just an important note here this is not the case so the no return value thing is not a case if we're making a call not a transaction now i understand this is a bit confusing but if i'm making a call to a function that does not modify the state so that doesn't require that i spend money on it doesn't need a transaction essentially i'm just querying the state then of course i can get a return value right if all i want to do is just get some data that's stored in the state of the auction that's fine i can do that i can get a return value but if i make a transaction that modifies the state that's the situation where i can't get a return value okay hopefully that makes sense but that is why we need events so now let me clear the screen and let's get into a more advanced example all right so for this example what i want to do is imagine that we're trying to build an application that's going to be partly on the blockchain that's going to allow us to auction our nft so again we still have this auction this is our contract but now what we probably want to do is we probably want to make a nice beautiful user interface that allows users to interact with this auction so to interact with the auction the owner of the auction is going to need to start it and then once it's started we're going to be able to accept bids right now the bid will be a certain amount of ethereum and we'll need to keep track of what the current bid is who's currently winning the auction we need to know when the auction ends and all of that logic again will be handled by auction however we want a very easy way for users to be able to interact with the auction contract i don't want them to have to write some really low level code and send their own transactions instead i want them to just be able to connect their blockchain account or their ethereum account with my user interface and click this nice big button that says bid okay so they're going to be using my user interface all of my clients are going to have a different instance of the user interface maybe this is something like a react app or something like a javascript client whatever right so let's say we have kind of two user interfaces here and we have two people that are bidding against each other just for simplicity so i'm going to say that this is number one and this is number two now the concept here is that this person's going to press the bid button it's going to send a transaction to the auction it's going to send maybe one ethereum and well that's going to be their bid and then this person maybe they want to send a bid maybe they send a bid of to ethereum now this is all great but again we run into this problem where i want these user interfaces to be able to be updated whenever another bit occurs so essentially if i'm sitting right here i want to know that number two just made a bid so that i can then bid again and i can bid three ethereum right now how do i do that well since i can't get a return value here and since my auction can't send something to my user interface it's not able to do that what i need to do is use my events so what's going to happen is every single time i make a bid an event is going to be emitted so i'm going to say emit and then i'll omit an event that's going to be something like let's write this properly something like bid one f and then it will be from number one and then we'll probably give the time that this bit occurred and a bunch of other information but the idea is we're going to omit all of these events and then what we can do is we can have these user interfaces subscribe to the events so when they subscribe to the events what's going to happen is they're going to be notified when an event occurs and then they can use the data from the event to update their user interface and tell the user hey you just got outbid do you want to bid again or hey the current bit is this or the auction ended or whatever you get the idea but the concept here is we have an external client right so our javascript clients kind of sitting on some type of user interface they are subscribed to the events that this contract is going to be emitting and whenever the contract omits an event they'll be able to update their user interface and they could say query the state of the auction if they wanted to they could do that for free because that doesn't require a transaction hopefully this makes sense but that is the point of events and this is kind of how you would start building out a very simple blockchain application you would deploy your smart contract this would be kind of your source of truth right this would handle all of the complex logic then you would have your nice user interfaces that allow the user to interact with the smart contract and be updated of things that's happening with the smart contract because the smart contract can only do some type of operation when a transaction is performed so you need some type of external client sitting listening for events and updating the user then the user can trigger those transactions to the smart contract when they actually want to do something that is state changing perfect there we go we now understand the importance of events let's go ahead and go back to the computer we're going to start writing out this auction contract and looking at events all right so i'm back on my computer in remix we're actually just going to start working on the auction contract and then as we work on that i'll show you events so i'm going to change the name of my contract here to auction because that's going to be a bit more fitting and i'm going to implement a bunch of public things that we need here for our auction so if we're thinking of an auction we're going to have a time span for this auction so we need to know if the auction has been started if it's ended how much time is left so when the auction is actually going to end we want to know all of the bids we want to know who's selling the nft we want to know what the current highest bid is and who the current highest bidder is and we also need to know what nft we're selling but we'll deal with the nfts later because that's a little bit complicated so for now what i'm going to do is say address payable it's important we do payable here because we're going to want to pay this person who you'll see is the seller so we're going to say address payable public seller now it needs to be payable because well the seller of the nft we're going to have to pay the profits of the auction so whoever you know the highest bidder was we're going to take money from them and send it to the seller okay now other than that we are going to need to know when the auction started so actually we don't need to know when it started we just need to know when it's going to end if it started and then if it's ended so i'm going to say bool and then this will be public and this will be started we'll then say bool public ended and we'll say bool our sorry not bool this is going to be you int and then this will be public if we could spell this correctly and then end at and this will be the time that we actually are going to end the auction at now other than that we need the highest bidder so we're going to say you int or sorry we want the highest bid so i'm going to say uint public and then this will be highest bid like that and then we will have address and do i want this to be payable let me look at my cheat sheet here no i don't think we need that to be payable we'll just say address public and then highest bidder like that uh and that should be good now other than that we're gonna need some mapping to keep track of all of the bids that users have made to this contract so the idea here for the auction is that when you make a bid you have to send money to the contract so if you don't actually end up winning the nft then you need the ability to withdraw your money right so we're going to have a withdrawal function that allows you if you didn't win to actually take all your money back from the contract so i'm going to say mapping and then this is going to be address and this will go to a uint and this will be a public and then this will be bits now the reason all of these are public is because i don't need to hide any of this information it's fine if everybody sees it and i want people to be able to see when it started when it ended what the end that is what the highest bid is because you want people to trust this contract that's the whole point of writing smart contracts right okay so now that we have that i'm going to make a constructor i'm going to say constructor like this and all i'm going to do is simply assign the seller so i'm going to say the seller is equal to message dot and then this will be sender so whoever deployed the smart contract will be the seller of the contract now notice i'm getting an error here it's going to tell me that the type address is not implicitly convertible to expected type address payable now i didn't show this to you previously but the way that you can convert a regular address to a payable address is you can just say payable like this and then surround what you want to convert so now this address that is not addressed payable will be payable and i'll put that inside of seller okay now what i'm going to do is implement a start function this function will allow only the seller of the nft to start and they'll need to pass all the nft details to be able to start the auction now we won't implement the nft stuff right now as i mentioned we'll do that at the end so i'm going to say function we'll just call this start then this will be public external okay so we're going to call this from outside of the smart contract and inside of here what i want to do is i want to require that the message dot sender is equal to the seller otherwise i will say you did not start the auction exclamation point okay and then we'll go with semicolon now what's the error here it says visibility already specified as public okay so that's my bad story i'm just going to make this external because you can't have public external those are going to be you know messing with each other so external is fine now what's the warning function state mutability can be restricted to view okay that's fine we're going to change that layer okay so now what i'm going to do is i'm going to say started is equal to true and then what i need to do is pick the end at date now this is going to be a little bit weird because we haven't seen this yet but i'm going to say end at is equal to and this is going to be block dot and then time stamp plus and then seven days now we can actually change this so that it's not days and in fact let me check if that's correct okay actually i think seven days is correct so first of all let's just explain what this line is because i haven't covered this so block is actually referring to the block that this transaction is a part of once it's been mined right so once it's been mined it will be a part of a block and the block is going to have a time stamp that's when the block was created so this is going to give us the relative timestamp of the transaction it's not going to be precisely when we sent it but it will be very close to that because blocks are created very very quickly in ethereum and we're going to add seven days to that and days is a keyword just like ether in remix so i can or sorry not in remix but in solidity so this way we're just going to add seven days to this time stamp which means we will end seven days after this so of course feel free to modify the number of days i mean you can make this one day if you want two days whatever it doesn't really matter in fact let's just go with two days for now but whatever you set this that's going to be the amount of time the contract or sorry the what do you call it the auction will last for okay so now we have start however what i want to do is add one more require here that just makes it so we cannot start this contract if it's already started so i'm going to say not started like that and then i'll say already started exclamation point and what i want to do is i want to omit an event saying that i started the contract so now we're going to talk about how we actually implement events now creating an event is actually pretty straightforward you first need to declare an event in the body of your contract so i'm going to do it up here i'm going to say event and then start and i've just created an event now we need to omit these events but this is an event that is emittable so what you do is you put the keyword event you then put the name of the event in this case i'm going to go with start now notice i'm starting it with a capital because the convention here is pascal case just like our contracts and then inside of the parentheses you put any arguments you want the event to accept so you could put for example the address of the person who started the event now that wouldn't really be very useful because the only person who can start the event or sorry start the contract or start the auction is going to be the seller but you could put any other data you want here you don't need to put the time because that will automatically be associated with events whenever they're omitted but i can put any data inside of the parentheses and then i pass that data as arguments when i omit the event and that'll be like the data of the event we'll see this in a second right now for start i don't need any arguments we won't look at that right now but when i do events for a bid i'm going to have the address of the person who bid the amount they bid et cetera right okay so anyways we have an event defined which is start and now if i want to emit an event this is really straightforward i just do omit and then i put the name of the event like that okay there you go i'm now emitting the start event now if start was accepting arguments i would pass them right in here so whatever the arguments are right okay there we go pretty straightforward so now that we have that let's deploy this contract let's deploy it to a legitimate network right so i'm going to deploy it to the goreli test network and then i'm actually going to go look at the events of my smart contract and show you how you can view them off the blockchain on etherscan so let's do this i'm going to click deploy and then once it's finished i will let you know okay so the contract has now been deployed so i'm going to click on the contract deployment here i'm going to view this on ether scan notice it says that it was successful so what i'm going to do now is click right on the contract so notice it says contract here it was created so i'm going to click on that and when i go here we can see we have the hash of the transaction that created the contract then i can click on events now when i go to event notice we don't see any events now that's because we haven't triggered any yet but i'm now going to trigger an event and show you that it will show up right here okay so let's go back to remix let's now go to our contract and let's start by just clicking on some of these so we can see the seller is it started no it's not started so let's start it by clicking on start now when we do this of course we need a transaction because this is going to modify the state so i'm going to click on confirm okay this is going to take a second to complete and let's just go here and it should tell us when this is done then we can go check the corresponding event that would have been omitted okay so this is finished now so let's go back here and let's refresh the page and notice that we have an event now the event is start okay and i can click on this right here and kind of view some of the details now the method will actually be the method that we called in the transaction now this is going to be a special hash of this method i'm not really going to describe exactly how you kind of read this stuff because there is a special way to do that however whenever you're going to be subscribing to events or trying to get the data associated with an event you're not just going to be reading it from this page you're going to have a client this client is going to be using a special library a library could be something like web3js this is a javascript library that kind of handles a lot of this complex lower level stuff for you and it will kind of decode this data and tell you the stuff in the event now i'm not going to show you how we subscribe to events in this tutorial because it's fairly complicated but if you were writing say a javascript client or something what you could do is use something like web3.js so let's do this this is the ethereum javascript api and inside of here you can subscribe to events so if you go to f.subscribe this is the thing right here i'll leave a link to this in the description and you can kind of view how you would do this and how you actually get the data associated with events from a smart contract okay let's go back to remix though and let's continue all right so now that we've written the start method let's write the end method or the end function so i'm going to say function end external and inside of here i need to require a bunch of things the first thing i'm going to require is that they started the contract so i'm going to say require started because well if they haven't started it they can't end it so i'll say you need to start first exclamation point doesn't really matter the error message that i give then i will also require that the block dot timestamp is greater than or equal to end at because i don't want to allow someone to end the auction if uh the end at time is not yet reached right because that would be unfair that means you could have someone like bid on it and then you could end it for them so that they would win it before anyone else was able to bid anyways we're gonna do this we're going to say block.timestamp greater than or equal to end at i'll say auction is still ongoing is ongoing one word or two word i think it's one word someone can correct me in the comments clearly programming is greater than spelling anyways and then we also want to make sure that it's not already ended right so i'm going to say not ended we'll say auction already ended and let's spell already correctly okay exclamation point perfect so now that we have all of our requires what we can do is say ended is equal to true and then we want to emit an event that says we ended it now of course when we end we're going to actually have to transfer the nft to the highest bidder and then we're gonna transfer the funds from the contract to the uh what do you call it the seller of the nft but for now we'll just do the events so let's go up here and let's say event and let's say end now for this event i actually want to know what the highest bid was and who the highest bidder was so i know who won the auction right so i'm going to say let's go with address and this will be i guess highest bidder okay and then we will go with uint and then this will be highest bid okay so that's for event and in fact i guess i can do this yeah that's fine we can do that inside here okay so now for end i'm going to say omit and then end and then inside of here i'm going to pass the highest bidder so let's go highest bidder like that and then let's pass the highest bid perfect okay there we go now one thing i want to add to start is i just want to add a parameter here that's going to be the starting price or the starting bid or whatever for the auction so i'm going to say uint we'll say starting bid and what i'm going to do is after i start this or it actually it doesn't really matter where i do this but i'm going to say that the highest bid is equal to and then this is going to be the starting bit so this way you're going to have to bid at least a little bit higher than this to be able to actually win the item if you were say the only bidder that way someone doesn't list this and kind of gets screwed by only having someone bid like one way or twoway or something and no one else actually bids on the nft regardless we'll have that for now and we can now test if end is going to work and then we can implement bid and we can implement withdraw which are the other two functions that we're going to need so let me save this now let's close this i'm going to deploy the contract again this will take a second once it's done i will be back all right so the auction is now deployed now i can start this by passing say a thousand way as the starting bid we will wait for this to go through and then we can try to end it now i will show you that when we end it this isn't gonna work and the reason it's not gonna work is pretty obvious but we don't have this condition being equal to true right the block.timestamp is not going to be greater than or equal to end at so it's not going to let us end this and i'll just show you that that works in a second once this starts okay so that's started let's now go to this contract the way i'm going to get to this is i'm going to open up metamask i'm going to go to contract creation okay let's go here let's view the contract okay it's still indexing let me refresh this once it's done i'll be right back okay so now it is fully successful let me click on the contract let's go to events and we can see that the event start has been triggered or been omitted right because we started the contract so now let's see what happens if we try to end it so notice is going to tell us that we're probably going to get a problem here it's saying that gas estimation errored with the following message see below the transaction execution will likely fail do you want to force sending and it's saying that the area's auction is still ongoing so it's actually able to look at our smart contract and realize that we're not going to be able to do this because the block dot time stamp is not greater than or equal to the end at time so we can still send the transaction if we want now if we do this what's going to happen is it's just going to fail now when it fails and we hit a require statement the required statement will return whatever remaining gas we had as a part of this transaction back to us however some gas is going to be lost now that's one thing to note here with require it does actually return your gas if this fails again not all of it because it still had to use some gas but it will return whatever wasn't used so you can see here we're getting this error right it's telling us this didn't work and we weren't able to do that because this require statement would have been well not true right it would have you know caused an exception okay so hopefully that makes sense that is how that works now that we've done that let's start implementing the bid and the with draw functions that we need okay so let's code out the bid function let's go with function bid external now this needs to be payable because this is actually going to accept ethereum right so inside of here we need to require a few things we're going to require that we have started the auction if we haven't started then obviously we can't do this so i'm going to say not started we're going to require that the block dot timestamp again this is a global keyword that we have access to is going to be less than the end at time so this means that the contract is not ended or sorry i keep saying contract i mean auction so we'll say ended exclamation point and then we will also require that the message dot value so this is going to be the value of the bid because they're going to be sending the amount of the bid right is greater than and then this will be the current highest bit okay so now we have all of our required statements now let's see why it's getting mounted mountainous here it's saying expected semicolon but got identifier okay i need a semicolon right there so now if this is the case what we're going to do is we're going to update the amount of money that people have sent to this contract kind of similar to the bank account by using this bids mapping and we're going to update the highest bid in the highest bidder because at this point we know this person would have bid an amount higher than the highest bid so we need to update those values right so we're going to say that the highest bid is equal to message dot value and we're going to say that the highest bidder is equal to the message.sender okay so now after updating this since the highest bidder has now changed what i need to do is make it so the person who just got outbid is able to withdraw their money from the contract so i'm going to say if and then this is going to be the highest bidder so not bid but bidder does not equal the address zero now address zero is the default address i'll talk about this in a second then what i'm going to do is say that bid at and this is going to be highest bidder plus equals and then the highest bid so the logic here why is this yelling at me let's see what the problem is operator not compatible with types uint256 and address sorry this needs to be highest bid not highest bidder okay that's better but the logic here is that as soon as someone gets outbid i want to allow them to withdraw their money from the contract so that they could withdraw and then bid again right because otherwise they would need to have a ton of ethereum to be able to actually continually outbidding someone if all of their money is stored in the contract so hopefully this makes sense but since we're updating the highest bidder now if the highest bidder was not equal to address zero so essentially if this was not the first person to make a bid then what we do is we take whatever the highest bidder was store that in our bids mapping and then we add whatever their highest bid to that so that now they're able to withdraw and let's say they don't withdraw and they just continue making bids that's fine this will continue to increment however many bids they've made so then they will be able to withdraw all of that if they're not currently the highest bidder okay and actually they'll be able to withdraw whatever amount inside of there is not their current bid that's being stored in highest bid you can look through this logic and probably see why that makes sense but address zero just to clarify here is the default address so when i write something like address public for right now sorry not just public but address public highest bidder it's going to be storing just a zero filled address so i'm just making sure that it's not equal to the zero filled address and you can do that by just writing address and then putting zero inside of here okay so that is bid that's pretty much all we need for bid now we want to write the withdraw function so i'm going to say function withdraw like that and then this is going to be an external payable as well and inside of here what we need to do is withdraw a certain amount or i guess we'll just withdraw the entire amount of whatever the person's bidded that's not the current bid so we're just going to start by getting the amount of money they've sent to this contract that's not currently the highest bid so i'm going to say a uint and i guess i'll just go with something like balance is going to be equal to and then this will be bidsat message.sender and then what i'm going to do is say bidsmessage dot sender is equal to 0 just to reset that and then i'm going to send whatever their balance is to them so the way i'm going to do this is i'm going to write this complex line in fact i'm just going to copy this in because we saw this in the last video i'm going to say bool sent bytes memory data is equal to payable message.sender so just converting that address to a payable address dot call value and then this is going to be balance balance is right here right and then what i need to do is require that this was successful so i'm going to say require sent and i'm going to say could not withdraw so let's do this could not withdraw let's add our semicolon and there we go we have just implemented the withdraw function now what i'm going to do is actually add some events here as well for bid and for withdraw then we can test this out and then we'll start actually working within nft because right now we're not really auctioning anything so let's make some events let's make an event for bid now what i want to do is have an address now this is going to be indexed now we haven't seen this keyword before but what you're allowed to do whenever you're defining the arguments for your events is you can put an indexed parameter and you can actually put up to three of these and this is what you will be able to search for an event for so if i say indexed here then this means i can search by whatever this parameter is for this event in my logs right or in my event so i'm going to say address indexed let me just look at my cheat sheet to make sure i don't mess this up it's going to be sender and then we're going to say uint amount to specify how much they actually bid and then we'll do an event and this is going to be withdraw and this again will be an address that's going to be indexed this will be the bidder and then this will be you ins and the amount that they withdrew okay i think that is fine now what's it telling me what's what's it saying i did wrong here oh i spelt index incorrectly okay so let's go and let's now omit these events so i'm going to say omit and then this is going to be bid and then we're going to pass to this just the highest bidder and the highest bid okay perfect let's add our semicolon and then for withdraw we will say omit and then withdraw and then we're going to omit the message.sender and the balance great there we go okay so now let's actually just deploy this we can do some experiments with it i'll set up another ethereum account make sure it works and then we'll talk about the nfts so i'm going to deploy once it's done i will be right back okay so i am back this finished deploying my contract this year i actually started the contract with a minimum bid of a thousand way and now what i'm going to do is change my ethereum account in fact i've actually already done this so i deployed this contract from my tutorial account but now i'm on account one so now i'm going to make a bid from account one and show you how this works so i'm on account 1. you can see i've reconnected this here to what do you call it remix and now i'm going to make a bid of a thousand way i'm going to click on bid then when i do this notice it's going to tell me that i'm probably going to get an error the reason i'm going to get an error is because this is not greater than the starting bid and so i'm just going to cancel the transaction so i'm going to change this now to be a thousand one let's click on bid and let's see okay so confirm let's give this a second and again notice i'm not going to get any return value here it's not going to tell me if this was successful or whatever i'm just going to see that the transaction didn't fail whenever this is done and then i should see an event be emitted here okay so let's now refresh this and we now see uh hmm okay maybe we need to wait a second okay so the event has showed up i just had to wait a second i was being impatient but after i refreshed a few times it appeared here anyways this has happened successfully i know this looks like gibberish but if you were actually subscribing to this event then you would have some library that would be translating this for you so you'd be able to read the real data regardless the bid happened and i can look now at for example the highest bid which i can see is 1001 the highest bidder which is this address i can look at the seller which is different if the contract is started and all of this type of stuff now that's pretty much all i wanted to show you for that since we don't really have two days to wait here for this to finish i can't show you it actually ending what i will do though is i will now start implementing the nft stuff which is a little bit complicated but it's pretty cool so i'll try my best to explain it to you alright so i've just switched tabs and i'm going to try to explain to you the difference between fungible and nonfungible tokens and how these kind of live on the ethereum network so i'm sure all of you are familiar with cryptocurrencies right we have currencies like ethereum we have currencies like bitcoin we have a ton of other currencies that are built on top of these main blockchain networks so if we're talking about coins that are built on ethereum these are tokens now really all a token is is a smart contract that defines that your address owns a certain amount of tokens now this is specific to ethereum but if you're working with a token that's on the ethereum network really what gives you the ability to own that token is that there's a smart contract with the name of that token it's named say timcoin for example right if i had my own token on ethereum and in that contract it says that your address has 20 tim coins or 100 tim coins or whatever it is now the way this all gets standardized is that what happens is you need to implement specific methods or specific functions on your smart contracts then make it act like an erc20 or an erc 721 token now erc20 is simply a protocol for a specific token in this case it's a fungible token now erc20 states that you need to define some special methods on the smart contract now if you do that ethereum is able to look at your smart contract and treat that smart contract like a token rather than just any other smart contract now that means in your ethereum wallet you're going to see your tokens showing up or you'll be able to link them you'll be able to then say buy these tokens or exchange these tokens because you've defined certain functions on the token and it meets the erc20 protocol hopefully that makes sense now erc 20 is simply a fungible token protocol what that means is every single one of these tokens is exactly the same so there's no difference in you owning one of the tokens or the other tokens like any token is just identical each of them has the same value and as it says here this makes erc20 tokens useful for things like medium of exchange voting rights staking whatever okay that's what you can use these tokens for however now we go over to erc 721 now erc 721 is fungible tokens now fungible tokens mean that these tokens are different so there could be a different value associated with each token maybe there's some assets like an image associated with a token hence nfts right maybe you get some special rights with a specific token tokens are unique they are different and they have a unique id now this is very similar to erc20 except you're just having these unique tokens and you have some special functions now that you need to define on smart contracts that are defining an erc 721 token so it's a little bit too complicated for me to show you exactly how to create your own nfts or your own erc20 tokens but the concept is again that we have this smart contract this is an example of an nft contract this smart contract defines who owns what nfts it's capable of creating new nfts and then if i wanted to say send my nft from me to you what i would do is call a function on the smart contract that transfers the nft i have to be the owner of the nft to be able to do that and then it changes the internal state of the nft contract to now define that you own my nft because i sent it to you so hopefully this makes a tiny bit of sense but that's the general idea behind tokens and behind nfts and all of this type of stuff now as you can see here there's some other types of tokens that you can create but erc 721 is the one we're going to work with right now and what we're actually going to accept in our smart contract that's going to be the auction is the address of a smart contract that represents an nft as well as the unique id associated with the nft that the user wants to auction so whenever you get an nft it has a unique id associated with it because every single erc721 token is unique when i say erc721 that really just means nonfungible token okay and so it has a unique id if i pass that unique id along with the contract representing that nft then what i'm able to do is verify that the user owns that nft and then actually list it in the auction and transfer it between different people okay so now let's get into some even more complicated stuff because i need to show you how we can make our own nft and when i say make our own nft i'm not talking about make your own nft contract i'm saying kind of acquire an nft in your ethereum account so that you can follow along and actually auction off your own nft in this tutorial all right so to do this i'm going to go up to this other tab here where i have token.sol now i'm not going to explain any of this code but essentially this is my own timcoin nft okay and i'm going to give you guys all the privilege of owning some timcoin completely for free it has zero value and it's going to be on an ethereum test network but you can own it for free you are welcome and the way i'm going to do that is i'm going to deploy this smart contract i'm going to leave a link to the contract address in the description and you actually are able to create your own nft by calling this award item function which is going to give you your ethereum address a nft okay it's going to give you a special id essentially of timcoin i'll explain this more in depth and i'll show you exactly how to do this but right now when you're watching this video this will be deployed on the goreli test network so you need to make sure you're using that test network and then what you'll be able to do is interact with this contract from remix again i'm going to show you exactly how to do that it will then award you an nft and then once you have that nft you'll be able to auction that nft inside of our test contract now before i show you how to do that we're going to implement kind of the nft logic in our contract then i'll show you how you get your own timcoin nft again you're welcome you guys can thank me in the comments okay so what we're going to do is we're going to now specify what's known as an interface that we are going to accept for a specific contract which is going to be the contract address of the nft that we want to list so i'm going to say interface so actually there's not a ton of value of me typing this in so i'm just going to paste in the interface and i'll explain what this is so first of all an interface is an abstract data type the reason we're going to use an interface is because we need to verify that the contract passed to this auction does actually represent an nft and so we're going to treat the contract as an irc 721 type contract which means we're going to make sure it has a transfer and a transfer from function on it now if you're unfamiliar with interfaces i can't explain them too much in depth essentially they just enforce that anything that is of type of this interface has these methods that are specified in this way so for us to have a valid nft contract really all we care about is that it has a transfer and a transfer from function that we can use now the transfer from allows us to transfer from one address to another address a specific what do you call it nft id okay so as i was saying before all we're doing is we're going to be calling a function on the nft contract that takes in the address of the owner of the nft the address of the receiver of the nft the nft id it verifies we own this nft and then it would transfer it to here and then transfer is simply going to take an nft id and transfer it to a specific address once it's been approved to do that you'll see what i mean in a second but anyways that's our interface so what we're going to do now is we're going to go inside of our auction and we're going to define the nft that we're actually going to be auctioning so i'm going to say i erc 721 public like this nft and then what i'm going to do is i'm going to say uint public nft id okay so what i'm saying is i want to store the contract of the nft address here it's going to be of type ierc721 meaning it has to have these functions on it and then i'm going to have uint public not nd t nftid which is going to be the unique id of the nft that we want to auction so now inside of my start function what i'm going to do is take in a starting bid i'm going to take in the nft contract and the unique id of that nft so i'm going to say irc 7 21 this is going to be nft and we'll make this underscore nft and then we're going to say uint nft id we'll just make this underscore again so it doesn't mirror our global name and then comma now let me make sure i typed that correctly i think i did okay so now inside of here what we're going to do is we're going to set the nft so we're going to say nft is equal to and then this is going to be underscore nft again this is the contract representing the nft then we're going to say nft id is equal to underscore nft id like that now what i'm going to do is just take these two lines here and put them after i do this just in case these return some error although it doesn't really matter because if an error was returned then the state would have been reverted but that's fine okay so we're going to do that now what we also need to do is we need to transfer this nft from the owner of the nft to this contract so now the contract owns the nft and then is able to actually transfer this to whoever wins the nft in the auction right so what i'm going to do is say nft dot transfer from and we're going to transfer from and this is going to be the message.sender who we're assuming owns the nft to this or sorry it's going to be address this like that and then this is going to be nft id okay so this here is going to fail if we don't own the nft so if whoever called this start here doesn't own the nft then we're not going to allow them transfer because the nft contract will raise an exception and so that whole thing will cascade meaning all of this is going to fail as well and so we won't actually start the auction so we're only able to start the auction if we own the nft and if we have the ability to send the nft from the sender to this address okay hopefully that makes sense i'll explain again how we kind of set the nft up and how we actually make an nft and get access to it in a second so now that we have that what we need to do is deal with what happens when the auction ends because once the auction ends we need to send the nft to whoever won it then we need to take the balance of the contract and specifically whatever the highest bid was and send that actually to ourselves right to the seller of the nft so all we're going to do here is we're going to check if the and this is going to be highest bidder does not equal the address zero because if it's equal to the address zero that means no one actually bid on this item and so we can just return the funds or return the nft to ourself so anyways we're going to say if this is the case then that means that we're going to take whatever the highest bidder amount was or the highest bid story we're going to transfer that to ourselves and then we are going to transfer the nft to whoever won the nft so i'm going to say nft dot transfer and then we're going to transfer it to the highest bidder i think that's all i need to put in here let me confirm that's correct oh one more thing the nft id okay so we're using the nft contract we're using dot transfer we're going to transfer it to the highest bidder and then this will be the nft id now what's it saying is the issue it says transfer is not found well that's because i spelt transfer incorrectly okay that's fine then after that we're going to figure out whatever the highest bid was and we are going to then pay that to ourselves the seller of the nft so the way we do that is we just copy in this line because i really don't feel like writing it again so we're going to say bool sent and then bytes memory equals data seller.call value and then this is going to be highest bid and then we'll call that like that and then we're going to require sent and we're going to say could not pay the seller okay there we go now in the other situation so if the highest bid actually is equal to address zero then what we're going to do is just return the nft to ourselves so we're going to say nft dot transfer and then this is going to be 2. i guess we will just say the seller and then this will be nft id and i think that's it again i spelt transfer incorrectly let me just make sure that's right looks good to me awesome okay so that is actually all we need for this contract now this contract should work however i need to show you how we can now actually get access to an nft and what that looks like in our account so i'm going to start by deploying this contract now be careful what account you deploy this from i'm going to deploy it from this one so i'm going to deploy test.soul which is really just my kind of auction contract let's confirm this okay this will take a second once that's done i'll be right back okay so that has now been deployed now remember to be able to start this auction we actually need the address of our nft so i am now going to deploy this nft contract here i'll leave the link to it in the description or you could just painfully write out all whatever the number of characters are but again it'll be linked in the description and i'll show you how you can use this to get your own nft so let me now deploy this i need to pass a string name and a symbol actually do i need to do that uh oh sorry i'm doing the wrong thing okay let's deploy timcoin so i'm going to deploy timcoin to the goreli test network this is going to take a second and then i will show you again how we can actually access this and get our own nft okay so tim coin has now been deployed now for me i can see timcoin right here right and we see all these different methods you don't have to worry about a bunch of them but anyways you're not going to see this inside of your remix because you didn't deploy this contract but you need to interact with the contract again on the gorilla test network you need to be on the gorilla test network otherwise this isn't going to work for you so what you're going to do is you're going to take the contract address which will be linked in the description and you're going to paste it right here where it says or at address okay so it should say that right at the bottom you're going to do that and then it will load this contract now notice it just loaded the same contract for me twice because i already had it here but that's how you can load again just copy it paste it in here and then it will load it right here now what you're going to want to do is you're going to want to start by setting the approval for all now i'm going to discuss what this is in a second but essentially what you need to do here is you need to allow this smart contract being the auction to actually transfer your nft now if you don't allow it to do that you're not going to be able to actually auction the nft the reason you can't auction the nft is because the contract will not have the ability to take the nft and transfer it to itself so you have to explicitly give the contract permission to do that before you create your nft so what you're going to do is go to your auction contract this is going to be different than mine you're going to copy the address of your auction contract okay i've done that i'm going to go to timcoin i'm going to go to set approved for all i'm going to paste in my contract like this then i'm going to go comma and i'm going to go true now look here it says operator which is this so the operator is the auction contract it's going to be operating on this nft and then true now what this is going to do is it's going to allow this contract to pretty much list any of your nfts now you still have to call the contract for it to do that but you're giving it explicit permission for it to access any of the timcoin nfts that you have access to so don't worry this doesn't mess with any other nfts you might have on your ethereum account and we're on a test network anyway so it shouldn't matter but i'm going to press transact this should go or this should be successful once i click confirm here okay so let's wait for that to finish and then we have set the approval for all of the nfts that you own to be able to be operated by the auction contract again what you're passing here is the auction contract now it's very important that you do this first before you actually give yourself an nft otherwise the nft you give yourself will not have the approval set for it for the auction contract okay so now that we've done that let's close all these and we're going to go to the award item function now this is what you want to press when you want to give yourself an nft so you're going to copy your address so my address is right here i'm going to copy it in to a word item and then what it says here is that there is a uri now the token uri is actually a url to json metadata related to this nft so as you may have seen nfts have like fancy images and music and gifs and all of this very valuable stuff anyways the point is all of that stuff is stored off of the blockchain on a specific url in json data and so what you actually have to do is associate data with your nft off the blockchain so when i create the nft i pass the url of the data sitting off the blockchain that represents my nft and then it links those two together and that's why when you go and you view nfts you see like a nice little fancy image it's because it's referencing the uri of this nft and then it's grabbing the image for it and displaying it pretty straightforward but that's really how nfts work again i'm not it's not meant to be an entire lesson on nfts but the token uri is just that it's a url now you actually don't need to pass anything here i'm just going to pass like one two you have to give some data but you don't have to give a url so i can pass one two three zero whatever doesn't matter so just go like that and when i hit transact then what's going to happen is it's actually going to give your ethereum account or whatever account you put the address for in nft so let's wait a second and then i'll show you that we actually will have tim coin showing up in our ethereum wallet okay so that finished so now if i go to metamask so let's get out of this here let's go to metamask and let's look at my account let's go to assets and notice how it says don't see your tokens import tokens so i'm going to click on import tokens and i'm going to copy in the token contract address of timcoin now again that's what will be linked in the description i can just copy it from right here so i'm going to go here i'm going to go to assets import tokens i'm going to paste this in notice the symbol is tim very fitting for the token decimal just put 0 and then add custom token and now it's showing that i have one tim token so i'm going to go import tokens like that and now if i look at my assets i see one tim coin okay it's just looking at the contract and since it follows the erc 721 protocol it's able to specify that i have one of these now if you want to own multiple just do this again just call the contract you can even pass the same uri it really doesn't matter and hit transact and now when you do this you're just gonna have to wait a second and then your wallet should update and once this is done you'll now have two tim coins and in fact just because this is interesting i will show you that if i go to metamask i go to my wallet here and let's go view account on etherscan you can actually view the tim coins that you have on here so notice i can go to token and i can specify timcoin and when i go here you can see that i have the token id of one i have one tim coin that was just added here in one minute now if i refresh this i should have a second tim coin in a second because i just requested that uh okay it might take a second so let's go back to where we were before okay uh award item let's refresh okay so now we should have two tim coins if we go here yes there we go now we have tim coins and the token id is one and two so if you want to see what your token id is because all of you're going to have a different token id you need to do what i just did go to metamask you're going to view your account on metamask so i went to where is that here view account on sorry not metamask on etherscan it's going to bring you to etherscan and then what you can do is go to your tim coins i showed you how to do that but let's go back so you're just going to click here click on timcoin and then it will show you your token id so you own tokenid one and two well in this case ion one and two you'll own something that's not one and two because it's going to be a unique id so this means i can auction token id 1 and 2 because i own that so now how do we auction it well this is kind of the moment of truth here to see if this is all going to work so i'm going to copy the address of my timcoin nft contract okay then i'm going to go to start i'm going to paste that in as the first argument so let's go here for the nft id you have to post an id that you own so either one or two for me and then put a starting bid so i'm going to put a thousand and i'm going to hit transact like this okay fingers crossed once i hit this let's see if this works and if everything we did was successful okay so very good we see the green check mark here meaning that this was good so now let's go to nft and notice the address is this nft id is one seller is me started is true highest bid is the zero address because no one's made a bid yet and then we have highest bid now of course this will work as it would would work before as we tested it previously and this will now take how many days did we set if we go here i think we set two days yeah so after two days then you'll actually be able to win your nft when someone hits the end button or sends the end request to this contract okay so that is going to wrap up the video i hope this was helpful in terms of giving you a deeper understanding of solidity and smart contracts and showing you a real practical application hosted on the blockchain now in the next videos we're going to be talking about some of the scaling limitations of ethereum and of solidity and some of the problems you can run into when you need to perform large computations then i'm going to be showing you some scaling solutions so ways that you can mitigate those concerns and we'll be talking about cartesi which again is the sponsor of this video and this series and showing you some of the solutions that they provide again i really hope that you guys have learned a lot from these videos i've been having a great time filming them well i look forward to posting more on the channel with that said if you enjoyed make sure to leave a like subscribe to the channel and i will see you in the next one