hello everybody and welcome to another youtube video so in today's video i will be sharing with you 15 complicated programming terms now this is a sequel to one of the last videos i did which was 25 terms all programmers need to know you guys said you wanted some more advanced terms so here i am with this video and you can check that video out from the link in the description also put it on the screen right here anyways in this video i'll spend about a minute on each term i'll put the definition up on the screen i've actually grouped all of the terms by their category so the four categories i have here is object oriented programming networking and web technologies cpu and task scheduling and then numbering systems if you guys want a third video with more categories then let me know in the comments anyways with that said the first term that i need to break down for you is actually not a term but is the sponsor of this video before we get started i need to thank the sponsor of this video which is visme visme is an allinone visual content platform that allows everyone including nondesigners to create beautiful presentations infographics reports and social media images in minutes even if you're like me and have no sense of design or aesthetics you can still use visme it provides an extremely easy to use platform without compromising on features and capabilities with visme you can make anything from boardroom ready presentations to short videos and animations with their builtin tools one of the best parts of bismi is how quickly you can create professional designs and how much time you save over using traditional tools bismi is designed for all types of use cases and clients and if you're an individual small team large business or educator you can get a ton of value from it and even use it completely for free thanks again to bismi for sponsoring this video and don't forget to check them out from the link in the description all right so let's go ahead and get started i have four sections to share with you the first section is object oriented program now the first term in this section i have for you is abstraction now abstraction is really the process of hiding implementation details and separating functionality from implementation so whenever we talk about abstraction we're usually saying to make something more abstract now something that is more abstract is more general so to give you an idea here let's say we have a bunch of different dog breeds we have chihuahua we have golden retriever whatever we have a bunch of different dog beats those would be concrete or specific whereas if i say dog that would be a more abstract concept right that is something that is more general dog is more general than a specific dog breed so when we are writing code in an object oriented style a lot of times what we're trying to do is abstract things out and the point of that is that if i were to create say an abstract dog class rather than concrete dog breed classes now it's very easy for me to understand how every single dog in my program works or operates the behavior that it has i don't need to go and dig into 10 individual dog breed classes i know that it doesn't even matter what the breed of my dogs are they all behave in the same way because they all use the same very general class there's a ton of other benefits from this i'm not going to really go much further here but the idea with abstraction and object oriented programming is to make something more general and to kind of try to hide some of the details and make it easier for your users to actually understand and use this class alright so the next term i have is inheritance now inheritance is simply the ability of one class to inherit or reuse the functionality of another class so let's say we have an example where we're working in some type of store we're modeling a store and we have our employee we have our manager and we have our supervisor well we could create three individual classes for each of these people and in fact we probably are going to do that but the thing is all of these three roles have a lot of stuff in common they probably all have a name right each manager supervisor employee they probably all have a name they probably all have a id they probably all have a salary or an hourly wage they definitely share some behavior in common so rather than me creating three individual classes that all are going to kind of rewrite the same behavior multiple times i would create what's known as a base class or a super class which would be my employee now in the employee i would put all of the functionality that's going to be common to say my manager and my supervisor then what i would do is in my manager class in my supervisor class i would inherit from the employee class and i would immediately be able to reuse all of that functionality without rewriting it inside of those classes and then let's say something was a little bit different in my manager or in my supervisor class well i would just write in the new functionality or if i wanted to override something from the employee class i could easily do that because these would be our child classes now i'm not going to go much further than that i have a bunch of videos on object oriented programming but that is the basic idea behind inheritance all right so moving on we are now talking about abstract classes specifically abstract based classes now an abstract class is simply a class that is designed to act as the base or the parent class in an inheritance hierarchy but is not intended and should not be instantiated now what that actually means is you're never going to create a concrete instance of this abstract class so i will never make an object that is of the type of this abstract class so for example let's go back to the manager employee supervisor right when we had our employee we said that was our parent class and the supervisor and manager we're going to inherit from it well this is not an abstract class because we could actually create an instance of employee it's not invalid for me to make someone who's an employee but who is not a manager and who is not a supervisor however if that employee class was actually turned to an abstract class then we would no longer be able to make an instance of it because its only role is to act as the super class for concrete classes below it so when you have an abstract class a lot of times what you do is you actually write something known as an abstract method and this is a method that is not yet implemented but that you want every single subclass every single class that's inheriting from it to implement on its own so really the point of the abstract based class is to provide base behavior for concrete implementations of this class i understand that sounds a little bit confusing that's the best definition i can give you in about one minute so moving on we have interface now an interface is an abstract type that is used to define the behavior that any class that implements it must define seems a little bit weird but let's say we have a list interface okay now this is not something that we can make an object from i can't instantiate the list interface and in fact in the list interface all i'm actually able to do is define the properties or methods the classes that implement me are going to use so if i make a list interface maybe i define a method and we'll call this method say length and we define another method called index i don't write the implementations of these methods i don't give the functions any bodies all i do is just write the name of them and i say hey if you implement me if you implement the list interface you must implement this behavior in this functionality so now we write a linked list class notice i said class not interface and we implement the list interface if i do that i have a class that implements the interface i must inside of this class implement all of the methods and functionality defined by the interface so now on my linked list class i write a concrete implementation of the length and the index method because i'm implementing the interface now the point of doing this is that i can now view an object of type linked list as simply the list interface this means that i can view this object only knowing that it has the length and index method and i don't have to care about any of its other functionality or even what general type it is and this allows me to accept any object that implements the list interface as say an argument type or a parameter typed to a function and treat it the exact same in this function because i know that it has a set amount of functionality so the next term i have is polymorphism now let's say buzzword people throw this around all the time without actually knowing what it means but i'm just going to break down the actual compound word here so we have poly and then we have morphism now if we look at poly and morph poly means many and morph is just a form right so if we have polymorphism this is really saying that we can have something existing in multiple forms now if i read you the actual definition this is the concept that objects of different data types can be accessed through the same interface and what this really means is a single object can be treated as a different type based on the context it's used in so this is actually the reason why we have something like interfaces we have something like uh inheritance and we have kind of this idea of abstraction polymorphism is just kind of this underlying concept that defines objectoriented programming and allows for all these functionalities to exist we're saying that if something is say of type manager but manager inherits from employee we can treat this object that is of type manager like it is of type employee because it implements the functionality of the employee class same thing with our interface right it doesn't really matter what type our object is if the class it's from implements the interface we can treat it exactly like that interface so one object can be treated in different ways and have kind of slightly different behavior or access to behavior based on the context it's used in our program that's really all polymorphism means anyways that's going to conclude the object oriented programming section so moving on we are getting into the networking and web technologies section so the first term i have for you here is the server side slash the back end now people do use these interchangeably they can have slightly different meanings point being they're very similar so i group them together anyways this really refers to the programs or operations that are running on the server or the remote machine now the reason this is important is because something that's running remotely so not on your own computer or on the user's computer is not accessible from the user and cannot easily be manipulated so if i have say the back end of my website right that's running on a remote server and this is responsible for handling http requests which is the web request you send when you want to get the html of the page and so i hit the server it sends me the html and then my browser actually renders the html so the rendering of the html is happening on the front end or the client side but actually retrieving the html from the page while i'm getting that from the server that's running my website so anything that's happening in the back end not a program that's running on your actual computer something that's running somewhere else and then giving you some data or giving you some information is the back end or the server typically you have your apis running on a server your databases are running on a server any sensitive information you put in the back end or the server side because the user of your program cannot manipulate that data they can only send different requests to the server and the server should be able to handle any say malicious requests so as you probably guessed the next term i have is the front end or the client side now this is really the application or the operations that are facing your user that they actually see and that they can manipulate in whatever way that they would like so as i was saying before if the server sends you the source of the page then you render that on your computer well you are rendering the front end or the client side your browser is responsible for doing that now since your computer is actually doing this you can go and you can look at that code you can look at the source of the html you can look at the javascript and you can manipulate that if you like now of course that's not going to change it on the server but it will change it on your front end which means you can try to do something maliciously with it so that is why there's an important difference and any sensitive information or data you need to keep on the back end you need to make sure that a user could not change something on your front end that's going to actually affect the back end and the security of your system all right so next we are moving on to the term packet now a packet is simply a block of data that's being transmitted across the network so whenever you want to send some information from one computer to another you're going to use the internet to do this right you can use some type of network to do this whether it's your local network or it's actually the internet point being is that you can't usually send all the information you want in just one piece of data for example say i want to send you an entire video game okay i can't just send you that whole video game as like one little package i need to split it into packets those packets all get sent to you and then once you receive all the packets you can reconstruct them into what the original data was it's very complicated i'm not an expert at this so i'm not going to explain it a ton but the idea is whenever you're transmitting information you split it into packets you send those packets very quickly through the network and then you reconstruct those packets with the data that they contain they contain a bunch of different types of data and there's packets that contain more data less data different protocols of packets all kinds of advanced stuff that i'm really not qualified to talk anymore about all right so that's going to wrap up the networking and web technology section now we're getting into cpu and task scheduling cpu being central processing unit now the first thing i'm going to do is explain kind of two terms to you at once because they go hand in hand this is process and thread so a process is really an application or program that is running on your operating system and has its own memory and has at least one thread now a process is something like obs which is the screen recording software i'm using right now something like a video game although you could have multiple processes technically really any application you can kind of think of as a process now when you create a process what happens is your operating system is going to allocate space in ram for that process to store its data okay now anything that's not a part of that process we'll just say for simplicity cannot access that data so if you have two processes they cannot share data with each other at least not very easily and for simplicity again we'll just say they can't share data okay so that moves us to a thread now as i said a process contains at least one thread a thread is actually the executing aspect of a process so it is code that is being read now sometimes you have multiple threads in a process the point of having that is so that every single thread can execute independently of one another so for example let's say you have a website and you need to wait for something to download on that website well you would have one thread that is responsible for running the user interface of that website another one that is responsible for actually downloading the content the reason why this is important is because if you only had a single thread as soon as you started downloading you would no longer be able to use the website you would need to wait for that thread to finish but if you split it into two individual threads you can use the website while you download that file the way that works is you will have those threads both being processed by individual cpu cores or they'll be splitting the processing time so you can kind of transfer between the two different threads a little bit more complicated than that point being a thread is a part of a process if you have threads in a process they can share the same data and memory so if i make x equals one in one thread and another thread that's a part of that process i can access that variable x okay but if they were in two different processes two separate processes with two separate threads then they would not be able to exchange data with each other again at least not very easily okay so moving on we're going to talk about concurrency and parallelism now something that is concurrent or really concurrency refers to the ability of a processor to work on multiple threads simultaneously and when i say simultaneously this doesn't necessarily mean the two threads are going to have work done on them at the exact same second in time okay or the exact same nanosecond in time what this means is that the processor is able to switch between different threads and work on different threads at the same time so rather than me having to say finish thread one before i move over to thread two i can do a little bit of work on thread one a little bit of work on thread two go back to thread one go back to thread two and the way this is handled is pretty complicated point being that's kind of what concurrency refers to so if you have a concurrent program that doesn't necessarily mean that two threads are being ran at the exact same time it simply means that you're able to work on them kind of side by side you can switch the processing power or the processing resource whatever you want to call it between the multiple threads now this would be between threads within one process or between threads in different processes as well so this leads us nicely into parallelism now a parallel program is a program that is actually having multiple threads being executed at the exact same time and the way this is possible is by multiple cpu cores working on threads at the exact same time so the number of cpu cores that you have in your computer actually defines the number of operations that you can do at the same time in parallel okay we have one cpu that means we can do one operation per whatever the speed of the processor is if i have two cpu cores that means i can do two operations per whatever the speed of the processor is and so if i have two cpu cores each core can at the same time be working on a thread so i can have two threads not having to be switched between just both constantly being worked on now this is very complicated the way that you manage concurrency and parallelism point being if something is parallel stuff is actually happening at the exact same time you don't need to wait for one thread to kind of stall or hang before you switch to the other one you just do both of them at the same time because you have separate cpu cores to work on them all right so now we're talking about asynchronous programming now asynchronous programming is much easier than creating your own threads or own processes as a programmer but that is because it's actually very complicated how it works and while it's difficult to explain in asynchronous programming you have something known as an event loop now the event loop is constantly running and it's capable of actually knowing when something has finished when something is started what the progress of something is and scheduling and handling tasks according to that now i'll just read the actual definition and i'll try to kind of clarify it a little bit more but this is a means of parallel programming in which a unit of work runs separately from the main application thread and notifies the calling thread of its completion failure or progress so the point of this is that i can do something like try to download something from the internet and while that download is happening i am able to actually go do something else without necessarily creating multiple threats again very very complicated but as the programmer i'm not responsible for distributing my program into the unique threads the async event loop will actually do that for me and it will be able to tell me if something is finished if something is finished i can go and do some other type of operation and i can await the execution of some program it's very complicated i have an entire video on asynchronous programming that much better articulates this point i can't really explain it in one minute but hopefully that gives you maybe some kind of idea of what that means all right so that's going to wrap up that section now we're going to move into the next section which is numbering systems so the first numbering system i have for you is take a guess binary now i understand this isn't super complicated but i'm going to explain it more in depth so binary really means kind of the choice or the option between two things right the actual word binary you know yes or no that's a binary decision if you were answering yes or no now in computers this refers to a base two numbering system that is used at the hardware level of computers and in some software to perform computations now the reason why this is used at the hardware level of computers is because with binary you have a zero or a one and if you have a zero or a one this is known as a bit okay now at the hardware level of computers you have a bunch of transistors i like to think of these as very very tiny wires that are carrying electrical signal now they can either be carrying an electrical signal or they cannot be carrying an electrical signal which means they are on or off zero or one right that's where we get binary from that's why we use it so at the actual computation level down on the cpu level of a computer you have a bunch of logic gates now these logic gates at a super fundamental level take in two electrical signals and based on the value of those electrical signals so on or off they output another electrical signal for example in an and gate if you have both the electrical signals on going in then you get on coming off if anyone is off you get off right now this is actually how you perform the basic math that leads us to perform more advanced computations it's hard to explain this more than that point being is binary is very fundamental to computing in general and at the hardware level of computers everything is happening in binary and binary is represented in the physical world with transistors and logic gates okay so continuing with binary i want to explain quickly a bit and a byte i kind of explained a bit already but this is really the smallest unit of data measurement in a computer it is either zero or one on or off okay that is what a bit is now a byte on the other hand is simply eight bits so if you have a byte of data this is capable of representing 256 unique numbers so either the number zero through 255 if you're not using a signed bit at the front of your binary or at the yeah i guess at the front of your binary number or negative 128 to 127 if you're using the first bit of your binary number as a sign bit now if you're not sure what a sign bit is this is simply one bit at the beginning of the byte that represents if the number is positive or negative so if you're using the first bit as a signed bit then this means that your range is going to change from negative 128 to 127 because you need to represent well negative or positive you can still represent 256 unique numbers you're just getting a different range because you're starting with negative numbers and then going to positive okay so finally the last term i have for you here is known as hexadecimal now this is a base 16 numbering system that is commonly used to simplify binary and to actually represent colors specifically in html and css now hexadecimal i believe goes from 0 to f so f would be 15 in hexadecimal and so when you have a base 16 numbering system the highest number you have if is 15 the lowest you have is 0. now i could do a whole video on base numbering systems in fact if you want that video let me know i just find that not the most interesting thing in the world but i would definitely make it for you guys alright so with that said i am going to end the video here i apologize if i didn't necessarily clear up every single one of these terms the point of this was to give you the high level overview so now hopefully you have some base level understanding you can at least go look up some of these terms and you kind of have some starting place you know kind of what it means and so that should hopefully help you if you're trying to learn you know maybe how to implement say a synchronous program regardless i hope you guys enjoyed the video if you want to see a part three to this where i do maybe acronyms or some other type of terms then let me know in the comments with that said please do like the video subscribe to the channel i will see you in another one