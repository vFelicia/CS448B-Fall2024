hello everybody and welcome to video 6 in this rust programming tutorial series in this video i'm going to be going over arithmetic so really math here in ross with different data types as well as how we perform type conversions and how we cast one type to another this is an important video you may think you know how to do basic arithmetic but if you've not done it in a statically typed language then please watch through because there's a lot of nuances and stuff you need to understand especially related to stuff like overflows which we're going to talk about a fair amount now of course i will mention i do have my course programming expert dot io if you made it to video six check it out it's in the link in the description genuinely a great resource we've had some great feedback on it so far and i spent an incredible amount of time working on that course i promise you it's some of the best work that i've ever delivered so if you like this teaching content then definitely check that out anyways with that said let's dive in here so let's just have a look at some basic variables here and start to kind of get into arithmetic so i'm going to say let x is equal to 9 and don't forget my semicolon this this time and then let y equal 10. now we know by default these are going to be i32 but i'm going to change these to be u8 and 2b now first thing i'll show you is we do have a comment in rust i should have mentioned this earlier but a comment is with two forward slashes now anything after these two forward slashes on the same line will not be read by the compiler it will just be ignored as a comment and what i'm going to do here is just put the range of my uh what do you call it my u8 which is 0 to 255 and then the range here for my i8 we know is going to be negative 128 to 127. now the reason i'm doing this is i want to show you what happens if i put a value here that's outside of the range of this type so for example if i do something like 256. now it may seem obvious but if i go here and i run my code you're going to see that i get an error and it says that the value 256 does not fit into the type u8 whose range is 0 to 255 so just keep that in mind when we are compiling here if we have an overflow occurring which is what this is you can see here we have this overflowing literals thing and while it says overflow a few times we're going to get a problem because well this literal is out of the range for u8 and by the way a literal is when we're actually typing out a primitive value here uh it may not only be primitive values that may be slightly inaccurate but a literal is literally like typing 256 or typing 1 or typing 1.23 these are known as literal values uh anyways okay so that's what happens when we do that now the same thing would happen with i8 and if of course if i try to do something like negative 9 we're going to get that same problem it doesn't fit in u8 okay so that's fine next though let's move on to adding these values so clearly you know you may want to add these together so let's say let z equal x plus y we'll add a semicolon and we'll just print the result here so take a guess at what you think the results going to be here if you think this is work is going to work if it's not going to work why it may not work but let's go and let's run the code and notice that we get another error right it says expected u8 but found i8 there's no implementation for u8 plus i8 so even though as humans this looks easy we can add 12 plus 10 we know it's going to be 22. the computer cannot do this because they are different data types we have an unsigned integer and we have a signed integer and there's no implementation for how we add these two values together even though they have the same number of bits so keep that in mind you just can't do this right i can't add types that are not the exact same i would need to change one of these types to be able to add them so if i change this to i8 then of course i'm going to be able to add them this works fine it's 22 but if i do something like i 64 plus i8 you'll see we get the same error there's no implementation for i64 plus i8 so this can be frustrating because sometimes you'll have values that are the same base type like the same integer or same unsigned integer but they have a different number of bits and you need to convert one of the types to another type to be able to add them together which i'm going to show you in a minute now this is the same with floating types of course so if i have my f32 and i have my f64 you'll see that we get the same problem here uh notice i can't add them together whereas now if i change this to be f32 and i add them um actually what's this saying f3210 expected f32 but found integer use a float literal okay so it's actually telling me that i can't assign i should have saw that before a uh integer value which is this 2af32 type so if i want to make this an f32 compatible type i need to add my dot zero actually wasn't aware of that um again guys i'm just learning rest two so there's going to be some times like that where i make a small mistake regardless though you get the point you can see now that we're able to add we get our value of 22 because we made these the correct float types awesome okay continuing here let's look at what happens when we do some division subtraction etc so let's go something like u8 u8 let's make this something like 255 and let's make this one so now take a guess of what you think we're gonna get when we add 255 plus one and we print this out and notice that we actually get an error here it says attempt to compute u8 max plus one underscore u8 the max is just the maximum possible value from u8 which is 255. now this is saying this would overflow and an overflow occurs when we don't have enough bits to represent the number that would be generated by adding these two values so adding 255 and one together would generate an overflow which means we actually can't run this code we can't compile it because we know an overflow would occur and well we can't allow that in rust now there is ways to make it so that you are able to overflow but typically you do not want to be overflowing and that's what's going to occur here if we try to do this addition so to fix this problem we would then have to cast both of these types uh to something larger so something like u16 so we have enough bits to add them and then we would be able to add them together again we'll get into the type casting in a minute but i just wanted to show you some of that okay continuing here let's try to do something like y minus x okay now again we're going to get an overflow error here because we're going to have a negative value that we're trying to represent and we can't do that right 1 minus u8 minus the maximum value of u8 is going to give us an overflow doesn't allow us to do that okay now let's do some stuff that makes a bit more sense so let's try to do 255 divided by 10. so let's try to do x divided by y now these are the same types so this division should work when i do my x divided by y and i run this code notice that i get 25. now this is not going to be a whole number division right i don't know exactly what 255 divided by 10 is but it's not going to be 25 it's 25 point something because we have five more here however we're just getting 25 because the result of any arithmetic operation we perform is always going to be the same type as the two operands in our arithmetic operation so we have the operands which we're using the operator and that means our result is always going to be the same type of the operands which is u8 so this will be of type u8 meaning we can't store a floating point value so this does not implicitly get like an f32 type or something like that and if i tried to say make this an f32 you'd see that we get an error because this operation returns a uint type so let's see how we now actually get a floating point value well let's change this to an f64 and this will be an f64 as well and as we saw previously we need to add the dot zero here so this is a valid float type now let's do x over y and let's see what we get uh and previous error what is this saying here oh i need my semicolon i keep forgetting it okay let's go back let's run and notice i now get my 25.5 which is the correct answer for this division and now this type here will be an f64 because it's the same type as their operands awesome okay so that is division now we have multiplication using an asterisk same thing applies here we're going to get an f64 type if our operands are f64 so let's run this and notice that i get my 2 50. all right so those are the core operators addition subtraction division and multiplication now i want to quickly show you the mod operator so the mod operator is a percent sign i'm sure many of you are familiar with it it's going to give us the modulus or the remainder after division of these values so x mod y should give us 5 because 255 goes into 10 25 times then we have a 5 left over that's our remainder and so that's what we'll get cargo run and notice we get five all right so now that we've looked at that i want to show you how we do type conversions in casting and how we add values of different types so first let's look at how we can actually write literals as a specific type so often times in rust you're not going to explicitly define the type you're just going to let the compiler do it implicitly for you however like if i'm looking at 255 here the default of this is going to be an f64 right the default type is f64 for floating point values but what if i want this to be an f32 without explicitly defining the types without having to do something like f32 there's a few ways to do this but the first way is to simply write f32 directly after the number so when i do this i'm pretty much saying i want to treat 255.0 as an f32 data type and we i mean we can do the same thing with 10 here and now when we run the code notice that this is all good and we get our value of five okay so that's one way you can just write it like this of course i could write something like you know i ate as well if this was a valid type for it since we had the decimal i wasn't getting the syntax highlighting before and that's one way to do it now another way to do it is just use an underscore so if i do something like 255 underscore i8 this will be the same thing i mean let's prove it so let's go 10 underscore i8 here let's do our modulus let's run this and of course i get an error because i accidentally put 255 here which is out of the range so let's just go 127 and let's rerun and notice all is good okay so we can use an underscore to separate and one thing to note too is that we can use multiple underscores to make our numbers more readable so for example let's just make this i64 so we have some more bits here and i64 if i wanted to have 127 000 then i could do this and that is equivalent to 127 000. so if i do that uh actually let's just go divided by y and i run the code here then notice this is good and i get my twelve thousand seven hundred okay so that is one way to do it the next way to do it is to write the as keyword and then the type we wanna write this as so i can write this as an i64 and this will accomplish the same thing when i run this i get this as an i64 data type now this is also how you do explicit type conversion so here i have my x right we know this is an i64 let's now change this type here to be an i32 though we know that we're going to get an error when we try to perform our arithmetic because they're not the same types so what i can do here is i could say parenthesize my x and i could convert this to an i 32 or what would be better is if i convert my y to b a i 32 or to be an i64 sorry so what i'm doing here is i'm essentially taking the type that has the least number of bits in this case it's i32 and i am casting it to a type that has more bits than it so i'm going from a 32 to a 64 and now this should allow me to perform this arithmetic so let's go here and clear and run and notice this works completely fine i actually don't need the parentheses but personally i like adding them just because it makes it kind of more clear right so if i don't add the parentheses same thing works okay so there you go that is how you perform a what is it uh explicit type conversion so as we saw rust will not automatically convert the types for us we have to manually convert them and here what i'm doing again is i'm going from the smaller type to the larger type because if i were to go the other way then an overflow could potentially occur for example if i do x as i 32 i believe this will be fine now because 64 to 32 i think 32 will be enough bits for this uh but if it wasn't then we would get an overflow so that worked fine but if this was a really large number i don't know what the range is for 32 so actually let me try something here just because i don't know what the maximum value is so i'm going to go i 32 colon cool and max to get the maximum value i'm going to say that's as an i64 and then i'm going to add one to it and i think this should just work by default because one will be an i64 okay so let's do that for x uh and then let's try to convert x to b and i32 and we should get an overflow because we're having uh two me the values too large to convert to an i32 right okay so let's run this here let's go cargo run and okay so this is what i was talking about so here we're getting an overflow without it actually telling us that there's an overflow so we had i32 max as i64 we added one to it and now we have one value larger than the maximum value that can be stored in i32 then what we do here is we say okay we're going to take x as an i32 value and we're going to divide that by y which is already an i32 value now when we do that we should be getting a positive number right if we're getting the correct result but we're not we're getting this really large negative number because what happens is we have an overflow so when we try to convert x to the i32 we get a massively negative number because of kind of the way that this is structured now when an overflow occurs we actually use something called two's complement wrapping uh to kind of wrap the value and convert it to a smaller value i'm not going to get into that in this video but that's what's occurring and why we're getting this weird behavior hence why you need to be careful here and notice the compiler didn't actually catch this error because it wasn't written as obvious as when we had literals written in and we were kind of converting them and you know causing an overflow more obviously so here overflow occurred compiler did not catch it and well that's no good we don't want that to happen so that's why i was saying you want to convert the smaller value to the larger as opposed to the other way around okay now that we have looked at that let's look at how we convert a string from user input into a number and then we can end the video here because i think i've gone through most of the type conversion also i will note that we could convert this to a float as well right so i don't want to do it in that format but if i do something like 10 underscore f32 or i write 10 as f32 that's fine so long as i can convert this number to a float okay so let's have a look at uh grabbing user input again and then converting that string to a number maybe adding it and putting it out on the screen so let's say use standard output our center library sorry io now let's create our string variable so we're going to say let mutable input equal string new and then we're going to say std not a c i o colon colon and this is read line i believe dot expect okay and for read line we're going to pass our mutable reference to the input okay and then we're going to expect and say expected to read line whatever that's fine for now and then we could say print ln exclamation point and for now we'll keep it simple and just print the input let me add my semicolons and let's see if i mess this up quite possible so let's clear and run and i got a problem not found in io ah read line is it read lines ah my apologies guys this is std in sorry and then dot read line just forgot that one part okay let's try this now though just confirm and if i go here hello we get hello okay great all right so now that we have our user input let's convert this to an integer to do that i'm going to say let int input and then i need to specify the type here for this conversion to work properly so i'm going to make this an i 64. okay and this is going to be equal to input dot trim now what dot trim does is it's a method we can use on our strings and it's going to return what's known as the escape character or the new line character that we're going to get at the end of the line when we hit enter to kind of submit what we typed so if i go back here to my console every time i hit the enter key here there's a special character that's kind of fed into the terminal telling me to go to the next line and to execute in this case the current command now we're going to get that as a part of our input but it's an invisible character that doesn't show up in the terminal so when we print our input back we don't see it but it is actually there so if we don't remove it using dot trim which is what dot trim does it removes that kind of invisible character uh then we're gonna get an error when we try to do our conversion so make sure you do that trim first we're then going to say dot parse now dot parse is what's going to return a result which is going to parse this string and give us an integer if it's capable of being converted to the type in 64. then we're going to say dot unwrap and this is kind of similar to the dot expect except what this is going to do is it's going to take any valid kind of integer result here and unwrap it into the actual integer type and return that to us that's what's going on so that's what we need there trim parse and unwrap and then we can just print out here the int input and for now let's just go with something like plus two uh just so we can see if this is actually working properly so let's go back to our terminal here uh let's go cargo run okay and now it's allowing me to type so let me type a valid integer like one two three and then we get one two five nice so the addition is working properly now let's see what happens if i type something that's not a valid integer like hello notice i get a problem and it says we called unwrap on an error value so the result returned an error we can't unwrap it until we get our runtime exception that's what this is let's run this again let's go with something like one two three four five okay we got one two three four seven now let's just try with a negative value something like negative nine we get negative seven okay so that is working as we expected uh one more time let's go with something like 9.8 we get an exception because this is a floating value not an integer all right so let's clear that so that is really all i wanted to show you in this video kind of the different arithmetic operators how you work with different types how you perform a type cast or conversion you saw we can do that using the as keyword uh and then what happens when we have integer overflows as well as how we convert a string to an it will look at all of this throughout the rest of the videos of course we're just slowly building and building and building and we'll do some more advanced examples once we learn about some more advanced features with that said if you guys enjoyed make sure to leave a like subscribe to the channel and i will see you in the next one