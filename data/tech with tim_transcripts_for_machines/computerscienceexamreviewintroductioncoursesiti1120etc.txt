this video is gonna be dedicated to helping you guys ace your final exam in your computer science course whether that be university high school outside of school or whether you just want to learn what I'm gonna be doing in this video is going over some really common mistakes that I see all the time personally when I'm teaching people Python how you can fix those mistakes and remember how to fix those mistakes because a lot of people will be able to do it once and then forget it and then I'm also going to be going through Big O notation quickly I mean we talking about recursion on you're talking about the time complex that you have standard algorithm so searching and sorting algorithms and all of that the more difficult things that you learn in a firstyear computer science course now I'm going to be doing this all in Python if for some reason your course is not in Python and you're watching this that's fine you're still gonna understand the time complexity you're still gonna understand most of the stuff although some of the syntax will be a little bit different and some of the stuff is specific to Python now this is really important that you guys watch through most of the video especially if you're struggling with this I want to explain everything in depth and I'm going to attempt to do it fairly quickly I try to keep this video under like mmm 20 30 minutes and explain all the topics as well as I can if you have any questions please leave a comment down below or join my discord server and ask me I am more than happy to help with you guys now personally I am a computer science student so I do have experience writing these exams and writing tests like this and I personally have created some of my own so I can tell you exactly the kinds of questions you're gonna see and this will definitely help you a lot without further ado let's get started okay so I guess the first thing we're gonna talk about really quickly is mute ability now in Python this is a really important really really very important topic that a lot of people do not understand so we have different data types in Python some of which are mutable some of which are not standard data types we have like our int string bool topple float and so on we have list we have sets we have dictionaries and there is obviously more data types as well now can you tell me off the top of your head which of these are mutable in which these are immutable if not that's okay I'm about to tell you so int string bool topple float conveniently the first five that I typed are all immutable data types now what does that mean we'll talk about that a second list sets dictionaries which are the only ones I'm going to cover in this video are evening or sorry mutable data types immutable simply stands for not changeable mutable stands for changeable what do I mean by that let's create a few variables to show an example so I'm gonna have x equals five and have y equals string like this and we're going to create a list Li which is equal to one two three four five six and alone because why not okay so we have XY and L now X is immutable and why is he mutable li is not so the way that we can check this for example is if we add something to X okay and it might seem confusing now but just watch and you'll see how this works I'm gonna say X plus nine it just in a line there's nothing wrong with this line I'm just gonna say X plus nine I'm going to print X okay and I'm going to print X like this alright so what you'd say is okay so five plus nine well that's equal to 14 so what is X gotta print here what is X gonna print here take a guess okay we have five and we get five why did this happen why did we not add nine to X well when we add nine to X what we actually get is a returned value of 14 okay we don't change X to equal 14 because we're not reassigning X by saying x equals x plus nine we're just simply saying X plus nine so this returns to us value 14 but since we don't assign 14 to anything nothing has changed now obviously if I do something like x equals x plus nine we're going to get 14 okay now this seems trivial you guys probably already knew this but let's let's do it again now with Y okay so we're just going to say and this is we're gonna see so remember how if we want to slice strings or grab indexes of strings like I can say y 0 okay if I say y 0 that gives me the string s okay now I'm just gonna try to change Y 0 right so I will print Y and then we'll print why after I don't say why zero equals instead of asked we're gonna say T so now we're gonna say to toe ring okay that's what we're gonna say watch what happens when I run this string object does not support item assignment now why can't we do that that is because string that strings are immutable data types meaning that we can't change them I like it's implicitly like this okay if we wanted to change Y zero to B that we would have to say Y is equal to Y and then we can say t plus y12 the rest okay and that would give us the changed value because now we're reassigning Y to be equal to this because we can't just change it in one line now again this seems trivial but watch what happens would want to do this with lists where I print Li we did the exact same thing we did with with y I say Li zero is equal to in this case changed okay and now watch what happens it says changed to three four five hello no issues were totally allowed to do that that is because lists are mutable meaning that we can change them implicitly like this and we can just change values we can also say like Li and we can take a slice well I would say like 0 4 equals changed okay and that gives us changed 4 or 5 6 float now I know this is like a weird thing that just happened but it just shows you the power of what we're able to do with that versus what we can't do with this okay so another thing with immutability is copying and aliases okay and this is really important a lot of people get really confused by this if we're gonna have a list we said li is equal to 1 2 3 4 5 6 hello and so Li 2 is equal to and I'm just gonna change this I'm gonna say it is equal to Li okay I'm just gonna print Li and Li 2 and you should see we get the same value we didn't same about you okay now if I change Li so I'm gonna say like Li 2 dot append let's just do like this we were able to see it really quickly well what we did things were getting at Li equals 1 2 3 4 5 6 low and we're going Li 2 is just equal to well this added at the end of this and they're different entities right let's check well what happened by us changing Li we actually changed Li one now how does that work well add something called immutability alright and when we change Li since it's equal to Li one what actually ends up happening is we say Li okay so what's Li we're gonna append whatever this is a hundred thousand to it alright so let's go to Li we see Li and we say well that's equal to Li 1 or Li so then we go to Li and we say okay Li is this we want to append to Li 2 which is Li 1 so let's just add one hundred thousand three here because the way that this is stored in memory is simply one object and when we set Li two equals Li well all we're doing is giving Li another name now this is the way it works with lists if you don't want to understand the whole memory addresses and all that stuff that's fine just understand that if you say Li equals Li and you created a new list then whenever you change something on Li it's going to change Li 1 and whenever you change Li 1 it's gonna change Li 2 again like if I do L I thought depend and we'll just add like three hundred like that both of these are gonna be changed so you can see that we get three hundred and both of these lists because these are exactly the same object okay now if we want to avoid this problem and we want to create two independent lists one which is a copy of the other the way that we can do this is simply type square brackets put a colon what this means is return a value from us from the beginning of the list to the end of the list and it's going to create a copy which means now that Li 2 is its own unique object which is the exact same as this except it no longer points to this it points to its own representation of this so we do this we now get 1 2 3 4 5 6 hello 300 because we add that to the first list and we get the hundred thousand in the second list and you can see that they're no longer connected so understand that to create a copy you have to use square bracket colon square bracket and if you just want to create an alias which means another name for then you just simply assign it like this okay and that's the way it works notice you can have unlimited aliases you could do like li 3 equals pretty cool goes to L I wow I really can't type okay x equals L ID 2 and then if you do any operational Li 3 it's gonna change Li 2 which is gonna change Li 1 right because these all Li three Li 2 and Li 1 are this one list and whenever you change this it's gonna change all the rest of them okay if you want to understand more about mutability are you confused I'll leave a link where I go through a really indepth explanation and this will help you understand it if you're still confused okay top right corner or in the description okay now let me go in for you debility let's go into hmm what should we talk about sets and dictionaries and time complexity okay so lists in Python again right our square brackets sets so like s are in curly brackets like one four five six six seven okay dictionaries are in square square brackets as well except they're a little bit different because they have a key value pair all right so okay five or so like test eight okay now sets and dictionaries are different than lists in that they are an unordered collection of unique elements remember this definition well you can type it out for you okay on an ordered collection of unique if I could even type today unique elements okay and that can be changed to unordered okay unordered collection of unique elements remember remember this definition you will need to know this okay this simply means that each element in our set or a dictionary can only appear once and the order of it is completely ambiguous it doesn't matter so I'll prove this to you so in our first set which is just in these curly braces which is s okay if I print s you're gonna see that we get one four five six seven we don't get all of these sixes that is because it is a set of unique elements which means that if an element appears more than once in it it simply removes that element and says note we don't care about that it's already in here we're just gonna have one six in the reason this is important is because we use sets when we care if something exists not how many times it exists or where it exists if you care about the order of Donna or the occurrence or frequency of data use a list if you only care if data exists if it's there if one occurrence is there you use a set now why would I bother using a set when I can just use a list and get the order and get the data well a set is a lot faster than a list and the reason it's faster is because we don't care about the order of elements so whenever we look for something in a set it only costs us one operation Big O of one and this should be a Big O okay Big O of one four sets is to add anything to set to remove anything from the set and to find anything in a set that is how many operations it costs us for the set and I hope you know a little bit of Big O if you don't talk about in just a second all right now if you're trying to do this on a list to add any element into a list to add to the end of the list cost one to add to the beginning of the list actually costs and operations because when I add element zero into the beginning this list like what actually happens in my computer is we have to reshuffle every position in this list we have to say okay so now element one is moved into position one element two has moved into position two three three four four okay and zero gets index zero so that costs us the length of the list operations and the length of the list is always denoted by n okay the length of a list length was set length of any data always is represented by n so when we do that it costs us n now that takes a lot longer and times longer than it does to add in to set now the reason a set is so fast is cuz we don't care about the order of data and I'll show you that even though our set looks ordered like this it looks like it's going in a sending order I can prove to you it doesn't do that so I add an element undred and add an element negative 400 okay you'd think negative 400 go here 700 would stay there let's print ask to our screen and see what we get we get 1 4 5 600 negative 400 now it looks like it's just in the same order that we set it but if I do what do you call it negative 4 and 10 like this let's see what happens we actually get negative 4 shuffle to the end it's because the order does not matter although it looks like it's an order it's not okay this is not in order and that's why we can add things so fast because when we add them in we just add it into like a bubble okay and the bubble has no order it's just a bunch of things floating around in space that exists okay dictionaries are the exact same as sets except they have a key okay they run in the exact same runtime so to find something in the dictionary cost of one to add something is over one to remove something at so of one to access an element in dictionary you need the key of that element this is known as the key this is known as the value it's why it's called a key well I'll keep doing that key value pair there's two things once a key wants a value the key corresponds to the value okay so if I say dict hey this is going to return to me a value of five now just like lists and everything I can change this very easily I can say dict a equals 100 and this is no issue when if I print my dictionary to the screen then I will simply get a change value of hey corresponding to five or 200 and test eight and you can see that that gives it to me just like that notice that keys can be anything you want like I need like six corresponds to eight I could have a couple as my key do anything you want as those keys okay so it works the exact same speed as sets and yeah to delete a dictionary key you can see you can just do a del dictionary and then whatever the key name is to change it like I showed you to add a new key simply type the key once and do like key string seven equals five if I do that it's just gonna add that key in and you can see we get hey test and seven five same thing here there's no order okay so don't think there's an order same runtime very important that's why I keep talking about it these are a lot faster a lot a lot a lot faster than this okay in most cases again last thing I'm gonna say if you care about the order of the data use a list if you don't care about the order with a frequency of the data use a set or use a dictionary okay let's talk about tuples really quickly because these are kind of a weird data type and python tuples are represented like this so they're like t and i have curly braces like this and i got like five six or nine okay now although this looks similar to a list it's not so it is ordered meaning I can do something like T zero and I can find like the element in here okay because I don't know if I showed you but if I try to do s 0 this actually gives a crash because there's no zero index index don't exist so I tried to do dictionary and I put like a and I'm trying to index like hey by doing zero since the key 0 doesn't except exist in my dictionary it gives us an error okay just for warning I can do this there's an order and it's completely mutable which means I can't just do like T 1 equals or sorry immutable I can't do like T 1 equals 5 like I try to do that and I run did it mean to run in debug mode you can see a temple object does not support item assignment which means that it is immutable and if I did like does that equals T and then I'd changed Zed it would not it wouldn't change T okay it's G understanda okay let's get rid of this and now let's go into the fun stuff which is algorithms and recursion which should i do first you know what i think i'm going to talk about recursion first and then go into actually we're already on the topic of run time let's go into algorithms okay i'm gonna create a function you can say this is sort all right in here I'm gonna put a list let's stand for Li all right inside of here I am going to sort a list using Python sort method okay I'm going to return Wow okay return Li dot sort all right and down here I'm gonna create list was it L R equals like one two three six I should probably add some stuff to sort in here and let's just add like a hundred in here okay and then if I print to the screen sort alright let's see what we get okay none return oh sorry let's do this one second I'll talk about this is a second because I sell so another mistake people yet Li does sort print sort Li just say sort Li print Li Wow I even made the mistake that shows you how common it is okay sort Li there we go okay so the way that this sort method works in Python is it takes a list and rather than returning a new list that is sorted it simply sorts the existing list and you can see here that I say Li equals like this list I call my sort function which simply does Li dot sort so this is the exact same as just doing a lie dot sort after here okay and then I print Li and we get the sorted version of it how does this work well this works because of mutability so the way that this can actually operate is since lists are mutable and we can change them without like reassigning them without saying like Li equals Li dot sort we can call this method on it now you guys saw what happened when I tried to for example return Li dot sort well what this does is since this is a method okay and I'm calling Li dot sort well Li dot sort doesn't return a value it just sorts the list so when I return the value of Li dot sort it's equal to none because again it doesn't return anything to us so let like the Python builtin function that sorts all it does is sort the list it doesn't return it so if we try to return what is being returned from there nothing's being returned from there so we're essentially returning none I hope that makes sense on how that works cuz a lot of people what they do is say Li equals Li dot sort like literally exactly what I did and then it prints none and they're like what like what the heck why isn't it working it's because when you call this sort method on a list it just sorts the list in place like it doesn't create a new list it just sorts the original list that's really important it seems trivial but like a lot of people make that mistake I even made a mistake and I've been coding a Python for way too long to uh to have made that right now I'm going to show you what the sorted function does and then I'm going to talk about the time complexity of all of these okay so sordid is a little bit different so I say a sorted and then I do Li this is the opposite of dot sort what still sorts it but it just returns to us a sorted list so what should I say sorted Allah and I print Li watch what happens Li does not change because this function what it does is it returns to us a new list which is a version of Li that is sorted so if I wanted to have this change I would have to say li equals sorted Li and now we get the sorted list so whenever you call sorted on something it returns to you the sorted list creates a copy of that list whereas when you call dot sort it simply just sorts the actual list and changes it now you can run into a lot of issues when you want to sort something but you want to have the original list as well and you decide to call dot sort because now what you're doing is instead of creating a new list you're just changing this original list and you care about what is in the original list right so now you've just lost all your data and it's a huge problem that people run into all the time okay now let's talk about how fast all these are speed speed speed common exam questions how fast do certain sorting methods work now in computer science there's main sorting methods gamma I'm gonna write a few down here there's bubble sort the most famous and the simplest there is in search and sort there is shell sort there is merge sort we have what you call it heapsort and we also have the famous quick sort now how fast are all of these and how can we determine the speed I'm just going to write down the speed in case any of you need a quick review and then we will talk about why in a second so that's o N squared which means whatever the length of the list is and always represents our length of our list it's gonna take n to the power of two so the length of list to the power of two time to sort that okay insertion sort is the same and to the power of two shellsort ranges okay so it can actually have multiple different times based on the sequence this is typically not when you're gonna have to know but I'm just going to tell you in case you do it ranges from o of n log to the power of two n to what do you call it and log or not am I saying sorry N squared okay so based on the sequence in which you're sorting it on it can range in the complexity so just know that it's it's not faster than merge sort heap sort of quicksort but it is faster than searching sort and bubble sir okay that's probably all you're gonna have to know if you even have to know if she'll sort merge sort in what do you call it log N and log n so the length of the list time longer than n okay next one heapsort also runs in O n log n okay and quicksort is the one that most programming languages use typically runs in n log n pythons sort method that we were using there runs the quicksort sorting algorithm okay so what are these and what the heck does all this stuff that you just typed even mean okay so pretty much these are different methods to sort I think that's all it is there's tons of different ways these are just some of the most famous and basic ones you will need to know on your exam most likely the runtime analysis of these it's pretty straightforward okay it's either N squared or n log n shell sort is a little bit different you probably don't have to know that one bubble sort and insertion sort the reason they take N squared is because they run through the data two times okay so ever like n n times for every element and I'll show you in just a second merge sort runs in and log n heap sort n log n quicksort and long and these are your fastest sorting algorithms these are the ones you always want to use if possible okay let's just write an example quickly of maybe a sorting algorithm algorithm and talk about the time complexity of it because we're talking about that now so how can you determine the time complexity of a program just given like a function or something okay I'm going to show you how to do this and it's like to fly and run and say a list which is well obviously just gonna be a list it's gonna be of length n all right just so we understand that and in here let's do something okay for every element I'm going to say for L stands for element in Li we're gonna check if the element equals equals one okay and if the element equals 1 we're gonna loop through the list again or si for L 2 and L I print el2 okay now this function makes no sense like there's no reason why we'd want to do this but we're just gonna go through and analyze the time complexity okay so we're going to call this function when I say run on one two three four one six seven eight okay and let's see what we print out and then we'll talk about it so we get a bunch of numbers together yeah like 1 2 3 K now the way that we can determine how fast this is going to run is by looking at loops okay so n is the length of our list in operation is like one operation represents one okay so for example in whenever I check this sorry this is hard to explain I'm trying to think of better way and I just lost my mouse okay there you go sir this if statement down here costs us and we're just gonna think about this as cost o of one operation because we've now looked at the data one time and we've done something with the gate costs us o of one this print statement we can think of as costing us o of one okay because we printed one thing if I add another thing I said like x equals five like randomly x equals five we can think of this as costing us o of one operation which means constant okay this is constant time like no matter how many times we do this it always costs us o of one okay it doesn't matter what the length of the list is the length of list could be ten million every time we execute x equals five it costs us o of one which is constant time okay these loops however cost us a lot more and how many times these loops gonna run well for Li it's gonna run and times right don't say o of n because if we have I don't know 10 elements in our list then this loop needs to run ten times so and representing the length of our list how many times this loop is gonna run what about this loop inside of here well how many times could it possibly run whenever we're looking at time complexity we want to look at the worst possible case so you're saying if Li equals 1 we're going to run this loop now in this instance this loop is only gonna run twice because we only have one two times right but what if every element our list was one and that's completely possible there's nothing saying that can't happen then that would mean that this list are this loop would run at times okay so we have over 1 here and got over 1 or 1 and then we're running this loop n times and running this loop end times so what's the time complexity of this algorithm how like how long does it take to run so we can look at here we're gonna say for every row of n right then we're gonna do all of this which means we're gonna have one operation for every n so that's one times n so we'll do we're just gonna say x one okay and then we're gonna also run over N times Co so we'll run o n times every event I'm certain times K and then we're gonna do two operation we're gonna print and we're gonna say X ago swap so that's of one plus o of one right so what does this give us well if we give equals n we do a little bit of math here we can see that that's actually gonna give us a value of oh of and right because we're multiplying by one and then oh of n times over well what's that that's oh of N squared so and to the power of two okay and after this we'll we have old 101 which means we're gonna get again another what do you call it wow I don't know what I just rented there again we're gonna get another event another two times okay so we're gonna have Oh N all right so let's add these up now and see what we get well we do a little bit of simplification here we can say that equals three O of n plus o of n to the power 2 so this is our run time of this algorithm however we want to reduce this and simplify this and the way that we can do this is by removing constants okay so o 1 times o of n we get it's like all these these ones here are known as constants okay they run in constant time it doesn't matter how long our list is these are always going to take one operation to run so we can actually remove them which means that now our operation becomes what we get rid of this okay and we get rid of this and we get event x o of n which means that now our final product is just oh of N squared another way to do this is you can multiply it out like I did so like let's say we just we get to the point here we're at Oban plus 1 squared plus o of n Levin now we have 300 event plus o of n to the power two now this 300 event is much much much much smaller than L of n squared let's think about this for example because we only really care about Big O analysis for like extremely large piece of data because that's gonna determine literally how long it takes if you're just running this on 10 elements it doesn't matter if you run three thousand operations on those tenets is so going to run like instantly right so let's plug in ten million here okay ten million to the power of two how much larger than that is three times ten million well that is a lot larger so we can simply omit this three O of n because this o of N squared is going to overpower that so much that we just care about that okay and that's how you can look that Big O analysis the way that I typically do it is just look at the loops and look at how many times each loop could possibly run so we say we have okay we have this if statement but we don't care about that we have this print we don't care about that we have this X we don't care about that you could have infinitely many more operations in here we don't care about them unless they're a loop so if we can run another for loop and we say like for you O for in Li now what we've gotten is well we have a chance to possibly be hitting this third for loop every single time we run the program which means now we have well o of N squared times what another event so that's gonna give us well o of n cubed and this is a very slow algorithm because we have to do oh of n cubed operations to get our result okay I hope that makes sense for like a really basic comparison now let's let me show you log N and O of n just simple because that was like a pretty complex example okay and I'm gonna do this by showing searching algorithms so I talked about sorting algorithms now we're going to talk about searching algorithms now sorting algorithms obviously are gonna take a lot longer than searching algorithms because we have to change that around we have to move them we have two operations on them whereas searching algorithms we're just looking for something right so I have a list and I set this equal to like 1 2 3 4 5 6 7 8 9 and ten okay here we go list ascending order one to ten I want to find the element eight for example how can I go about doing this well the most simple way to do this is you say okay for I in range and we'll say the length of Li okay what we can do now is we can say well if statement here if Li I Wow okay equals equals looking for and I'm going to create like what I'm looking for up here okay looking for equals eight okay then what we're going to do is simply say I need another variable found equals negative one so found equals eight or eight found equals I because that's the index at which it occurred okay so we're doing here is we're looking through every element in the list okay we're gonna see if that element is equal to what we're looking for and if it is when I say found equals I and you're going to break B list because if we found the element well we don't need to continue looking through okay so then we can print found all right and let's see what we get we get seven okay that's the index at which we found it now what is the runtime analysis of this algorithm well first of all this is known as a linear search so that might give you a hint linear search okay see if you can understand what that means the runtime analysis of this and I hope you're able to guess it is n now the reason this is n is because the length of our list is known as n in this case it is a length 10 okay and we could run this for loop at most ten times now how could we run it ten times well what if I do this and say one two three four five six seven eight hour six seven zero nine ten well where's our element it does exist that means we're gonna look through the entire list just to find out that our element does not exist unless I have this found negative one so that if you get to the end it says negative one you know you didn't find it right and that is a linear search looking through every single element a list always happens n times right and again we don't care about these operations we don't care about a sound found equals AI or Li equals AI whatever it like we don't care about that because these run in constant time whereas this is dependent on the length of the list okay now I'm going to talk about binary search so this is linear search the most basic search like you usually come up with this without even knowing anything about computer science right binary search is a little bit different now binary search only works on a sorted list I'm going to show you why so I have a sorted list one through ten okay and I want to find the element three now if you're clever and you know a little bit about computer science you know that there's a much faster way to find that element rather than looking through every element of the list because we know that the list is sorted so if we know that the list is sorted there's something sneaky that we can do and I'm just gonna illustrate to you and then I'm gonna code it so pretty much what we're actually able to do is and the way this algorithm works is we're gonna start and we're gonna look in the middle of the list rather than going from beginning it to the end and look at the middle of the list we're gonna grab this element which this case is five okay look at that middle list we're looking at five we know the element we're looking for is one or two or three or whatever case let's say we're looking for two what we're gonna do now is going to split this list into two we're gonna say elements that are greater than five and elements that are less than five so we're gonna check ran say was two less than or equal to five it's less than five that means that any element above five since we know the list is sorted can't be two so let's just remove that from our search query and no longer look there okay next now we're gonna look at the middle of this list so we've now essentially cut this list in two right we were had ten elements now we only have five so now we're in the middle of this new list we're looking for two we're at three so we look at three and we say okay is two less than this or is 2 greater than this well twos less than this so that means we're gonna remove all of these elements and we actually remove the middle at element as well because we know that if it's less than or greater than it it's not age right okay now we have a list one or two we're gonna look at the middle of the list in this case we'll just grab 0 just you could either grab one or two if it Steven list it doesn't matter and I say okay so is less than 1 no it's not ok is to greater than 1 yes it is so we remove and now we have one element left in our list which is the element we're looking for and we've been tracking the indexes the whole time so we know that it occurs at index 2 right or index 1 or whatever ok no safe say that we haven't exactly doing 1 2 3 4 5 and the first time we look at is 3 another operation mundi which I didn't really say is we're first gonna check if the element is the one we're looking for and if it is that we're just gonna break out we already found it ok otherwise then we continue doing that process now how does how fast does this work well give you a second to think about it but think that every time that you look through the list you cut the list in half right so if you have a list of 10 well you can just run some basic math you say ok so 10 we look through and we get now we're at 5 we look through it so 5 divided by 2 okay let's say our list now is what do you call it 2 3 okay we divide that by 2 and now we're at one element all right and we just keep dividing so the way that we actually do this in math is log base 2 of n because however long our list is well every time we cut it into so it's actually log base 2 of N and if you run like math logs on stuff saw as an import math you can see that how much faster and how many more or how many less operations were actually gonna have to run if I just do math dot log there we hope you've been telling me here and we'll do of a massive number base to watch what we get oh I just freakin printed to the screen turns a lie okay let's try this we get 26.5 so instead of doing whatever this is like a million or ten million operations we do 26.5 operations to find our element that is freaking amazing that we're able to do that so now let's code it and see how it actually works so define binary underscore Wow okay I'm really not type of enough all right behind Harry underscore search don't know what happened there anyways and then we will put our list which me a lie and say X and X is gonna be what we're looking for okay we're gonna do here's gonna have to bears a top equals the length of our list and bottom is equal to zero and what we're gonna do is we are going to change bottom and top to slice our list in half and the reason we can't just slice the list right we have to do the bottom and top variables because we slice it then we're gonna lose the indexes at which our number is we can't just say like to divide the list in two and then take like a new list and look at it we look at the same list just from different indexes right and say well top is greater than bottom because if we get to the point where bottom is greater than top then that means now we're like flipped around and list and our element doesn't exist in there like we haven't found it yet so we need to stop running at that point what we're gonna do is we're going to say middle which is we need the middle index is gonna be equal to top plus bottom in brackets I've made this mistake earlier integer divided by two it's gonna give us the middle index or list right now we're just gonna check the first thing that we always check is like if the middle is actually our element that's what we're looking for so we'll say if Li at index middle is equal to X then let's simply return middle because we're done we found it okay otherwise so L if Li middle is greater than X then what we have to do is change the bottom so now we're gonna shoot the bottom upwards because we don't need to look at anything below that middle index right because we know it's gonna be greater so we can simply say that middle is going to be equal to or may not want to miss it bottom is equal to middle plus one now the reason we can do this is only if we know that the element exists in the list okay if you don't know the element exists analyst you gotta leave this as middle because if you try to add one to the middle like this right and there's only one element in the list and that's not the list then you're gonna run into like an index error so I'm gonna leave it plus one but just just so you understand that okay otherwise and so if it's not greater then it's not equal to it must be less than if it's less than we're gonna change our top and our top must be equal to middle index plus one I think um let's see here one of them is minus and one of them's plus okay let's just see if this works and then we'll play around at it because I honestly forgets and for some reason I'm not thinking too great right now okay so binary search and then let's go in here let's create a list that's bordered okay nine ten and let's look for element four see if we run into an issue here oh we didn't okay I am D equals the second time I've done nine now probably actually more than that sure someone's counting print IND none we didn't return anything so we didn't find it that means we had an issue with our middles let's just do this this is gonna work and it's gonna be slower oh and now we're running into an issue Li middle equals equals x bottom equals Middle top equals middle okay give me one sec I'm gonna have a look and I'll come back okay so apparently uh I wasn't thinking very very well when I made this so you can see I changed the sign now pretty much it's cuz usually I say like if X is less than Li but for some reason I decided to do it the other way anyways you just need to flip this sign around so that it's actually gonna work because what we were saying before is if if the index in the list is greater than X they were saying bottom it would be like incrementing bottom to move up so we'd never find the element but now it's the other way around so it's proper so you see we round this now I just changes to seventeen to make sure I was working but uh we get with the correct index and you can chain just whatever index you want and you oh now we're running into another issue great let's see okay so there you go so just make sure you get rid of this minus one now as well and there you go sorry about butchering that algorithm for you guys but I just work and do it as well anyway so that's how this binary search algorithm works if you want to see an example of how this works really quickly I'm gonna fast forward once I've created like a massive list and then test it on it and show you it versus the linear search so you can see how how much faster it is so just yeah bear with me okay so I'm just gonna run the program now it's already tested it once but pretty much all I did is just create like a random list and then we do a binary search and then we do a linear search and you can just kind of see by when it prints how much longer one of them takes any other it's hard to show you like a really relevant example because the memory limit on my computer doesn't let me do any more digits in this random list so I can only search like so many but you'll you'll see like there's quite a bit of a time difference I guess relatively so when I run this it's gonna take a second to actually create this list this is the longest part that's why I print start searching binary so you don't think that it's doing that anyway so we started and ended binary instantly and linear did take a few seconds to run now if I have another zero to this you would see the linear would take a lot longer to run where binary would still run pretty well instantly and you can actually prove how many operations this runs in but just saying like our equals math dot log of whatever this number is and then what do you call it base to and then if I print that to the screen so instead of printing all this jazz what was print are get rid of this and run this you can see that it only runs 26 operations right and if I remove a zero you'll see that it runs in 23 like if I just keep adding adding adding adding zeros and it hardly runs in 43 like that's how many operations this many pieces of data in a list takes to find so that's incredibly fast and it's that's why binary search is so important so a recap binary search runs in log n linear search runs in n ok log n is exponentially faster than n alright if you guys are still here I commend you because this has been a very long video but right now I'm gonna go over recursion now recursion is it's a fun topic I guess you could say and there's three standard rules to recursion so for something to be recursive first of all it must be a function so in this case I'm going to call function say X okay and we're going to return func of X plus one okay and for someone to be recursive there's three rules we've satisfied the first rule the first rule is it must call itself a recursive call means that the function within its function body so the indentation makes a call to itself it can make multiple calls can make one call can make ten calls it can make unlimited calls actually can't do unlimited because on the programmer crash but anyways okay that is the first criteria the second criteria is it must have a base case so right now if I were to run this my program would crash and it would give me a stock error because what I constantly do is just keep calling this function and I never terminate and that is an infinite loop of recursion so we must have a base case so for example if x equals equals zero return zero okay that could be base case and every time I run X every time I run this function we would eventually get closer to X and this leads me to my third criteria this is not a proper recursive function by the way I'm going to talk about a proper one in a second the function must get closer and closer to that base case with every function call so for example if I call a value of x and I know that my function is going to return a or is going to be given a positive value of x every time I run this function and it runs through it subtracts one from X which is essentially moving closer to our base case of where x equals zero and we can just return zero okay so that is how these are the three basic criteria for recursion for something to your cursor it must do those three things I'm going to show you the most trivial example of recursion that I possibly can and it is factorial if you don't know what factorial is I think it's like exclamation point five stands for factorial and that is equal to all of the numbers underneath five multiplied by each other so that is fought four times three times two times one and I actually think five is included as well five times four times three times two times one that is the factorial of 5 so you can see that as we keep multiplying this it gets much and much larger if I were to do the factorial of 10 like that's a massive number okay so you can say define fact which could be factorial of n and it's going to be the number that we're given not to be confused with the length of a list what we're going to do here is we are going to set up our three criteria so the first criteria is a must call itself we're gonna do some different order we're going to set a base case R and say if and equals equals 1 return 1 because the factorial of 1 is 1 this is the case that we know so we can return we could also do factorial of 2 which is 2 if we wanted to make this simpler we'll say return 1 I think we'll sequels to return too because you know what that's fine or what say n is yeah okay that's fine all right otherwise so if n is not equal to 2 well we must call herself and we must get closer to 2 so what we're gonna do is we're going to return the current number times the factorial of the last number and that will give us the numbers we're gonna return n multiplied by the factorial of n minus 1 because if you think about it 5 factorial is equal to 5 x 4 factorial right and 4 factorial well 4 factorial is equal to 3 factorial x 4 so other way around 4 x 3 factorial and you can keep going on and on until eventually you hit 2 and we know the answer to 2 so we can traverse backwards and find the answer to 5 factorial so might seem confusing but lets me run it for you factorial 5 let us print this out to the screen I believe it's actually I don't know let's do it again 120 is the factorial 5 so 5 times 4 times 3 times 2 times 1 the factorial 4 let's see is 24 factorial 3 test this out is 6 3 times 2 times 1 okay it makes sense factorial 1 we just get an issue for one because we said if it equal to two okay you know what we can do another base case if and equals equals 1 return one and then just assume that we're going to return a number greater than one okay we're gonna be given a number greater than or equal to one okay so now we're gonna talk about something which is height of recursion which I almost can guarantee if you've learned recursion will be a question on your exam I'm gonna show you a very basic standard way to solve this problem and it does involve like a pencil and paper so I just took a break quickly I just pulled out my tablet now I'm just gonna draw on the screen here excuse is black okay to use let's use red excuse my messy handwriting but anyways we're just gonna run through the factorial of 5 okay so we're just literally gonna run through this function and see how many times we call the function because the hyde recursion simply means how many times we actually make this function call right so to do this we start at five we go and and we're just gonna look when you say is five you want no it's fabulous to so we're gonna return so art wow I really do have messy handwriting written with this tablet in a while so excuse me it's gonna be five times the factorial of 4 okay so that's our first function call or our first one can call is actually this so we'll just say factorial of 5 okay and then 5 times factorial 4 ok now we're looking at factorial 4 factorial 4 is it's not one it's not two so that is n times factorial 3 and n in this case is 4 because we've passed four so that's multiplied by the factorial of 3 ok next one let's see here so we have three now right so three multiplied by the factorial of 2 and now we'll look at factorial of 2 what's factorial 2 well factorial of 2 is just 2 so now we have 3 times 2 and now we're just gonna have to and we're not gonna return this right so we have 5 times 4 times 3 times 2 and it's okay that we don't do this one because anything multiplied by 1 is simply itself right so 5 times 5 the factorial 4 is five times four times factorial three now what's factorial three well that's five times four times factorial of 3 times factorial 2 okay so our height of recursion in this case is 4 because we have one two three four function calls now this is a really basic example but it kind of walks you through how it works right so we go five times factory for factorial 4 is 4 times factorial 3 factorial 3 is 3 so if you sub all these in right like say a sub in this right here 4 factorial 4 and then I sub in this 4 factorial 3 and then you just keep moving up then you can find like your answer for that actual thing if you didn't know what the factorial of 5 was you could just run through that to find it ok I'm gonna close that I'm gonna type out another example now that's a little bit more complicated and this is gonna be like a what do you call like in a rhythmic series I think that's what you call it like given a number it adds the last two numbers you guys will you guys will see what it is I'm just gonna call this a R of N and what I'm simply gonna do NSA if n equals equals 1 return 1 and let's see Inc 2 is equal to 0 we're gonna work through this together because I forget the exact case otherwise we're going to return a R of n minus 1 plus the a r of n minus or it should be other way around n minus 1 plus the a R of n minus 2 so we're gonna end up getting a sequence that looks something like this and you guys will see in a second so it starts at 1 1 2 3 5 8 8 plus 5 is 13 13 plus 8 is 21 and this is the sequence I'm going for so we want to generate a sequence based on however many numbers so in this case the secret 1 2 3 4 5 6 7 8 so I gave n is 8 we should get 21 I believe that's that's what I'm gonna so you say if n is actually less than or equal to 2 we're gonna return 1 because the first two sequences are 1 in 1 okay and we're just gonna add them together and keep returning so what is the height of recursion on this well first of all it's just make sure it works because you know we always should test those things okay we get 21 so that's working fine let me now pull up the tablet again and let us try this one more time okay so we need to go to this all right hide a recursion on this now this we have two recursive calls so this is going to be a little bit different eight I'm gonna change this to four to make our life a little bit easier okay so let's start the first recursive call or first call is here okay so we have and go over here we have a are of four okay now what's that equal to well that's equal to the AR of three plus the AR of to scan excuse my handwriting okay so what is this one equal to now well the AR of three so we branch out here I'm going to branch out here because we're gonna have to do this twice right the AR of three is actually equal to the AR of n minus 1 which is 2 plus the AR of and life's 2 which is 1 now we know the values of this that's one and that's one okay now the AR of two is equal to one okay so from our four if you count on the recursive calls with one two three four recursive calls and five calls in total okay now the way that we can calculate the value is just by adding all these up right so they are four should give us a value of three and like I have in the list here so we say 1 1 1 there you go that's our value of 3 now if we change this to 5 we let's see if I can do this to find without erasing everything okay so we'll get rid of that and we'll say the AR of 5 is equal to the air for right so that's a are for the AR f4 is equal to the AOR of 3 and the AR of 2 right whereas the AR of 3 is equal to this so we have like a bunch of arrows now going right but then you can calculate it like this so the AR of 4 is equal to the AR of 3 plus the air to so then you go here we get 3 but then the AR of five which is plus AR four is equal to this which is three or is equal to two right so I know I just completely mess up that explanation but hopefully you can see how you would go about like branching out and doing all those you can figure out not only the value but how many calls you're gonna have okay so yeah anyways I think I'm going to end the video there I know this went a lot longer than expected but there was some things that I want to make sure we're clear for you guys and that I explained well if you watched this entire video you should be fairly prepared or at least now refreshed on a lot of the material that you learned in class obviously I can't explain it as well as a professor because I don't have an hour and a half lectures every other day to explain one topic instead I did everything in like what is this gonna be like 40 minutes 45 minutes whatever that is so yeah hopefully you guys enjoyed the video and it helped you out it definitely helped me to study for my exam by making this and if you guys enjoyed the video please make sure you leave a like on it as did take quite a while to make and subscribe to the channel for more content like this you