hello everyone and welcome to another expert Python tutorial so in today's video we're gonna be talking about context managers now contact managers are definitely one of the more useful topics that we're gonna be talking about it that we have talked about so far and you'll find yourself using them a lot especially as you get into more advanced programming and dealing with things like shared memory and shared resources and unlocking and locking and yeah it's just all those kind of things contact managers come in very handy essentially now I'm actually almost certain that all of you have seen context managers before in fact I'll show you a few examples here of times when you've used them and just not knowing that you've used them and that's kind of a common trend here that I'm hoping you realize there's a lot of the stuff that we're using it's not completely new to you it's not something you've never used before you just never really understood how or why it worked and that's what the point of this series has been is to give you that appreciation and understanding of how these lowerlevel things work so that you have more control over your code and if you need to change them or write your own versions you now know how or at least have the intuition to do so now again this video is sponsored by kite a big thank you again to them you can see whenever we start typing we get these little kite keywords popping up it's just a really good autocomplete and again it's free if you want to download it it's from the link in the description you can find that ok so let's go ahead and get started with context managers now the first thing that I want to do is show you what problem context managers solve to us so I'm gonna start or salt for us so I'm gonna start by showing us the problem and then the solution with the context manager so essentially let's say we have some file and we want to want to open a file right so I want to open save file dot txt we'll open it in write mode which just means create a new file if it doesn't exist yet and then what we'll do say file dot right let's say hello and then we'll say file dot close ok pretty straightforward pretty basic this will work run this code nothing wrong with it but what actually is wrong with what I just wrote well looking at this at a surface level it seems like everything's totally fine I mean we've opened the file we've written one line to it in this case hello and then we've closed it now the issue occurs in this code if this line here so this file dot write line doesn't work it doesn't happen for example like if I just air this line by putting line X here then we run this we can see that we don't make it down to this file that close line because we have some air on this right line so say we open the file we start trying to write something happened something else had the file open we couldn't access it well now we've opened the file and we haven't closed it and that's an issue and we need to make sure whenever we open a file or have some shared resource that we work with that we close it afterwards now a better example would probably be if I open this in read mode as opposed to write mode because that would mean that this file already exists on a system but hopefully you get the point that the issue occurs when we open the file we do a bunch of stuff and we don't reach that file dot closed so the point is how can we make sure that we reach this file dot close no matter what happens in between the open and in between the closed well the way that we could do that is we could use a try and a finally statement right so we could leave what we have right here and we can just add a try like that and then we could add a finally down here if we indent that properly for the file dot close so what this means is regardless of if this works or not we will eventually or finally close this file so that's good and we've just kind of fixed our error there and that's totally fine but there's an easier and better way to do this that allows they're a little bit more functionality and what that is is a context manager now this a code right here is completely equivalent to what I'm about to write so with open file dot txt we'll open it in our mode again we'll call this as file to be consistent and we'll just simply say file dot writes and in this case hello so these two kind of blocks of this block up here and this block actually do the exact same thing and the way that this works is this open method here actually defines what we should do when we use it as a context manager when we exit and when we enter so when we enter what that means is OK when we open this file when we write this code what's the first thing that needs to happen well the first thing needs to happen is we need to open the file and we need to return that so we can store that as the file object that's the thing that's happening when we enter this context manager and we can tell we're using a context manager because we're using the width keyword and that's the most common way and kind of the only examples I'm going to show you here is using the wif keyword in taipa then what we do is we do something whatever we have inside here we could print something we could you know filed outright we can do a for loop doesn't matter and then when this is done so all of the code in here regardless of their if there was an exception or not we will call the exit method and what the exit method does is some kind of code that allows us to close our file properly and make sure that everything works so essentially the contacts manager is kind of like a hidden way to make sure that whenever we do one operation we do another one regardless of what happens in between and again that's really useful for things like opening and closing files and for locking and unlocking shared remember so now I'm going to show you how we can actually write our own context manager that does the same thing that we've just shown here so we have this open function and we say with open file dot txt our as file file dot write hello we understand that after this runs regardless if there's an exception or not we close the file but how does that actually work well let's try to do that so what I'm gonna do now is I'm just gonna make it class and we're gonna write this context manager so when I say class file I'm gonna say define I'm just writing square knit and since we just want to do the same thing we did before we're gonna take a file name and a method in our knits and we're gonna say self dot file equals open file name method now it's important to note then when we make a context manager we don't necessarily need to use it as a context manager all the time in fact I'm gonna start writing a context manager here and show you the methods we need to implement to do that but right now you know the function that we have here we can use this fine even though you know it's gonna be a context manager we can instantiate it and we can use it as we usually would we just aren't going to call these special methods that I'm about to write so we have the first method which is called engine now remember ENTER I told you is the first thing that happens and what this function needs to do is return to us some value that we're gonna use in the context manager right when we wrote for example with something as you know F then this something is gonna call this enter method so we're gonna store whatever is returned from Enter in F so that's what we should get there so here what we're gonna do on the enter is simply return self dot file and again that should be the Open File object then what we're gonna do is define an exit method so underscore R square exit underscore underscore and notice these are special dunder methods because they're gonna be called in a special way automatically from Python because we're going to use the context manager syntax so here actually takes three arguments and the three arguments are parameter I guess we have our type I believe we have I'm going to look to make sure I haven't messed this up we have value and then we have trace back so essentially what this does is regardless of whether or not we get an exception between when we open or so between when we enter and between when we exit if we get an exception it's actually going to call this exit method with that exception so that we can handle the exception and here the way that we would like and I'll talk about how that works a little bit more in a second but let's just do what we wanted to do which is self dot file dot close so for now we're actually going to omit the fact that we're gonna deal with these parameters although we'll talk about them later so in here I'm actually just gonna write some code some print statements so that we can see what happens when we enter and when we exit these methods so print enter current exit so now what I'm gonna do is I'm gonna set up the same thing I did before except this time instead of saying with open I'm gonna say with file and the reason I'm allowed to do this is because I have this enter and exit method defining that this is a context manager let me just say with file we have let's say file dot txt let's put that in say read mode actually we'll put in write mode and then we'll put that as F we can say F dot write hello as the classic example that we've been using and now let's actually run this code and let's look at these print statements and make sure this works okay so we get enter and exit and inside here I'm actually just gonna put a print statement that says middle just so we can see how this works so even though I haven't explicitly called this exit or this entry method we can see that they do get called so enter middle exit and they get called any appropriate timing right so this stuff happens in between the enter and the eggs and now what I'm gonna do is simply put an exception in here so I'll say you know put some letters here just to make sure this crashes let's run this and actually sorry that's it gonna be a syntax error see there's any way that I can get this just to crash oh let's just say raise exception like that and now let's see if we still get art yes we do so we can see we get enter middle exit and then we get the exception raised afterwards even though we raise the exception before we got to this exit method so what this essentially says is regardless of if there's an exception or not we're gonna call this exit method and the point of this is so that we can actually handle an exception inside of our exit method if we need to so I know this is kind of confusing to see in my trace down here because there's all this text but look what's happening right we can see that on line 17 an exception was raised but the thing is we still called this exit print and we still closed the file even though that exception was raised which again is the advantage of a context manager okay so what I want to do now is show you what this type value and trace back actually is so we noticed that what happens is essentially any exception that's raised inside of here actually gets sent to this exit function where it can be handled and that's why we see this exit popping up here because we enter we do this middle stop some exception was raised in the middle that's fine so we immediately go to this exit function where we pass that exception and we wait to see if it gets handled and that's why all of this code in the exit' function runs before we decide that we're going to crash the program or that something's gonna happen so what I'm gonna do now is show you how we can actually handle an exception inside of this exit function and again what type value in trace back are so now we'll keep printing exit' but we're also gonna print all of the different values that are here so we'll just use an app string and we're just gonna do a bunch of commas so that we can see what all these are so type value and in this case trace back so let's run this now we're still gonna get a crash in our code now we can see that we have a class exception none and then a trace back at some location so if we wanted to we can look at this trace back we can look at the type of the exception and we can actually handle it and in fact the way that we handle an exception from our exits is if we determine that this exception is fine that we shouldn't crash the program that all is good what we're actually allowed to do is return the key value true so if we return true from this exit method here that's gonna tell Python that week erase fully handed is handled this exception which means we don't need to crash the code we don't need to run or you know see all this trace back in the output here we're fine and we're good to go and in fact if I run this you can see that by simply adding this return true here we no longer get a crash in our program and everything is fine now be careful with this because you don't want to just add return true if there is actually exceptions and they need to be handled properly in fact a better practice would probably be to do something like if type equals equals and then whatever type of exception you were looking for maybe I raised like a file not found exception or something and we were looking for that specific one then what you could do is handle that exception inside of here and then return true in that instance and in fact this still works because the type was exception but I'm trying to see if I can raise like yeah so let's say file exists air like let's do something like that and run this and you can see now because that wasn't just a regular exception this crashed because we didn't handle that properly so that's how we can handle errors inside of this exit function you just return true if when you check through this air that's passed in here you get you know some valid stuff and you can handle it right and if you don't return true and there's no error like we've seen that's totally fine so if we don't raise some exception regardless of if we did return true or not everything works fine and we're good to go and that is one of the massive advantages of context managers okay so now I'm gonna show you how we can actually create this same context manager because this seems a little bit complicated using a generator so we've talked about generators and we talked about decorators what we can actually do is import something called context Lib so we can import context Lib like that and from context Lib there's actually a decorator in here that allows us to decorate a generator that becomes a context manager and I'm gonna show you how that works okay so let's do the same example we did before with opening a file but now using a different kind well not really different kind but just a different way of creating this context manager so what I'm actually gonna do is I'm gonna write this decorator and the decorator is context live dot context manager like that there's no brackets at the end and in fact what we could have done is set from context live like this import context manager and this is a builtin library in Python and that will just allow us to do this rather than having that dog beforehand so let's do that I'm gonna say define file like this and what I'm actually gonna do is take again the file name and the method and inside here I'm going to say okay file equals open and in this case we'll say file name method then I'm gonna yield because again this is a generator the file object and then I'm going to file dog flows so what this means essentially is that the first thing we're gonna do is say file we're gonna create this file object we're gonna yield this to wherever we're being called from and then when this function resumes again you can think of this as the enter right and this as the exit we're going to close the file and in fact in here again we can handle some exceptions we can do things like that and this is a quicker easier way to actually make a context manager so now I can say with file and in this case let's just say you know well what have we been doing I don't know let's just say tax txt let's switch it up here let's go W mode and will say as F let me get say F dog right let's say hello like that and if we run this code that's perfectly fine that works and now when we add our print statements it'll say print enter like that and print exit like that and then we can print middle and we can see how this is actually working okay so enter middle exit so this decorator allows us to turn this generator object into a context manager it works pretty much exactly the same as I talked about before there is more to go in and kind of dive in with this this syntax right here I typically recommend to people just to use the class syntax just because it allows you to do some more things into something more people are familiar with but if you want to use this context manager decorator and do some things with this generator kind of sin tax to use a context manager you're more than welcome to and that's why I showed you so I think with that I'm gonna wrap the video up here an interesting idea though if you guys want to mess around with context managers is to think about locks in threading so actually from the threading module in Python a camera in the syntax right now at the top of my head you can have shared memory and you can have locks and yeah like memory locks which essentially allow you to wait for another resource to give up this lock so that you can access the resource so the point is like say we have one variable X here that's gonna be accessed by two different threads well we can't access and change X at the same time so we create a memory lock and what one thread will have to do is wait for that lock to be available before it's able to access the object and you can actually implement this functionality with a context manager so that your threads you make sure they unlock the resource before they finish changing it so that's something that's interesting if you want to mess with that I don't really have that much time in this video so I'm not gonna do that but yeah so with that being said this has been context managers I hope you guys enjoyed if you did make sure you leave a like subscribe to the channel and as always let me know if there's any other expertlevel features you would like to see