hello everybody and welcome to the third video in this series where we will start actually working on our project and building out part of the back end now as a reminder the project we're going to be building is a rock paper scissors challenge application what I want to do right now is just hop over to the Blackboard whiteboard drawing tablet whatever you want to call it and give you a little bit of a highle overview of the project architecture just so that as we start going through the code you have a better sense of exactly what it is that we want to do now let's just start with the kind of a objective of the project we're going to have two players or potentially multiple players but for now we can just stay with two and these players want to play Rock Paper Scissors against each other now one player needs to initiate something called a challenge well that's what we'll call it so I'll just represent that with C the other player then needs to accept the challenge and then these two players need to reveal what it is that their answer is right so whether rock paper or scissors now the challenging part comes in making sure that one player does not have an advantage over the other player when they reveal these answers so just quickly recap player one which could be this guy creates some kind of Challenge and then player two who we can call this guy will accept the challenge so we have challenge created challenge accepted now once the challenge has been created and it's been accepted by another player at this point both players should have already submitted what it is that they want their answer to be so in this case maybe this guy does rock and this guy does scissors now if that's the case we know that player one is going to win the issue is though if player one were to create the challenge and submit Rock immediately and we were to just store that normally on the blockchain player 2 would always be able to win by looking at what is stored on the blockchain for this particular challenge remember that any data we put on the blockchain is completely visible and transparent to anyone so we need to do this in a little bit of a different way so I'm just going to walk through how that process is going to work and this is going to really inform how we go about writing this backend which I won't lie to you is a little bit complex but it's all kind of part of the tutorial to show you how this works so the basic idea is that we need both player one and player two to make a commitment to a specific decision so whether rock paper or scissors however we don't want that commitment to be revealed to the other player so what we're going to do is use a little bit of a hashing technique which is very popular in cryptography let's say player one decides that they want to choose Rock now they're the ones that are actually creating this challenge so I say okay I'm going to create a challenge I want my decision to be Rock so what they're going to do is with this rock decision here they're actually going to append to this a secret code or something that we refer to as a Nots now a not is just some kind of random number we could say that this number is something like 173 now this secret number right here the the player is going to store they're going to keep track of and it's kind of like their password now what they're going to do is they're going to take this whole value so whatever their decision is in this case it's rock plus some random number and they're going to pass it through something known as a hash function now what the hash function is going to do is it's going to spit out some random value that we don't know how it was generated so we're essentially going to get this kind of random string and this random string is essentially the encoding of the their choice and their random number now just to simplify this quickly the only way that we'll be able to get this same random number is if we were to pass in this exact input that we have in the hash function so what that means is that this kind of value right here so their choice plus their random number is the only possible input that's going to lead to this output we'll talk more about this in depth in one second now the idea is we're going to store this value on the blockchain which is the hash of their choice and their random number otherwise known as their password so we take this value and we store this on the blockchain now that that's stored on the blockchain they've effectively committed that this is their choice Rock however they have not revealed that choice to player two because all player two is going to see is this hash so now what will happen is player two will do the exact same thing they'll have some decision maybe they go ahead and say okay I want this to be Rock and then they choose some random number something like 373 now same thing here they store their random number over here obviously these numbers would be much larger we're just using small ones for now they generate a completely different hash so maybe something like a b C1 2 three just a random example and then they submit this hash to the blockchain at this point in time both players have stored their secret password and they've made what we're going to call a commitment which is associated with this challenge now that these commitments are on the blockchain they've effectively locked in their answer but neither player knows what the other player's answer was because they don't have access to this secret code so now what we're going to do is once both players have submitted their values so let's just imagine we have kind of a check mark here and a check mark here indicating that we've made the decision from player one and we've made the decision from player two each player in turn or in whatever order they want is going to reveal their answer now the way they'll reveal their answer is actually by doing the opposite of what they did when they committed to it what that means is they're going to take their secret code so value like 173 and they're going to take their decision so I think this player I forget what we did but let's say it was scissors doesn't really matter okay they're going to take these two values and they're actually going to submit these to the blockchain now what's going to happen is on the back end we're going to take the hash of these two values and we're going to check to make sure it matches what they sent us before so we're going to say okay we've got some string that we've stored which is your commitment which is the hash of your decision now that both players have made their decision we're going to take the hash of whatever you tell us your decision actually was and your secret number and we're going to see if that matches the hash that we stored if it did that means that you have now revealed your answer because you've actually submitted this data to the blockchain which is your answer and we verified that this answer is the same as what you originally shows again I'm going to elaborate more on this but that's the basic idea now both players are going to do that and when both players do that that will effectively reveal their answer again I forget what we did but let's say this guy was scissors and this guy was Rock then we know rock wins so it's a twostep process they start by committing what their answer will be and kind of hiding this secret code which would allow us to reveal their answer once both players have made this commitment now it is safe to reveal the answer because these players can't change their commitment they can only essentially reveal what it was so now we go through the reveal process and what we do is we actually submit both of these values to the blockchain where it's then verified and we say okay this was the same as what you originally told us so now we're going to Mark the player one chose scissors same thing here with player two we take the values so rock and 373 we submit those to the blockchain we make sure this matches what they originally submitted by checking the hashes of these values and since it does match we say we have scissors versus Rock and well we know rock wins I'm hoping this makes a little bit of sense but this is how we do a little bit of kind of security on the blockchain and how we can reveal answers and store data without actually revealing what the answer is on the blockchain before we want to reveal it again the reason we need to do this is we can't have one player submit their answer before the other player because if they do that then we're going to know what their answer is and we can always win so what we do instead is we submit a kind of a secret string that has our answer encoded inside of it but that we can only reveal once both players have submitted that secret string so we have kind of secret string one right so here and secret string 2 and then once these are both submitted now the players will tell us what their secret string was and we'll be able to verify that what they're telling us is actually what it was so both players have decided without seeing the other players answer and now they will reveal their answers and we can end the game okay that's the architecture here now what that means is that we're going to have a little bit of logic that obviously can do this hashing from both the front end and the back end and each player just needs to store their secret token for each challenge that they're participating in we'll go through all of this and it will make a lot more sense but that is the security implementation for this project which I actually think is quite cool and shows you quite a lot about how we can make some more advanced systems so let's hop over to the computer now start coding some stuff out we'll work mostly on the back end then in future videos we'll handle the front end and do all of the interactivity all right so we're back on the computer now and what we're going to do is just set up a new folder where we're going to do all of our work from so I just have opened the same directory that we set up in the previous video which is the rollups example now we're going to work inside of here just to make our life a bit easier so I'm going to open up my WSL terminal notice that inside of this terminal I am inside of the rollups example directory what I'm going to do is I'm simply going to copy the ERC or sorry the echo python directory and I'm just going to make a new directory with a different name and we'll start working inside of there for our project so what we can do here is CP hyphen R which stands for recursive and then Echo dpth and then the directory we want to call this so I'm going to say rock paper scissors like that and then I'm going to put a slash and go ahead and hit enter now if I type l plus we should see that we have a rock paper scissors directory so now we can CD into rock paper scissors and we can go ahead and build this application now to do that let me just pop open my guide again I always keep this open whenever I'm working just so I have all of the commands so notice I'm inside of the rups example and I'm inside of the new directory we just copied which is rock paper scissors and what I'll do now is I'll just take this command and I will paste it in here and I will build all of the docker containers and images okay that is built now if I want I can go ahead and start my local node I'm not going to do that this second because we don't need this started right away but that's the basic idea okay so let's close that up and now if we go here we should see that we have a rock paper scissors directory and we've got a few files okay so we have echo. py uh we have pretty much everything that was inside of the other directory what I'm going to do is go to echo. and I'm just going to rename this file to main.py just cuz I'd prefer it to be called main I think that makes a bit more sense I'm then going to go into the docker file and actually says copy dot dot okay that's good so we'll just leave that as it is I thought we were going to need to change that so fortunately we don't need to change that okay we have main.py we can kind of leave this as is I'm just going to get rid of this huge header comment so it doesn't block up our code and we're actually going to make a new python file now this new python file is going to be called challenge. piy and I want to begin by coding out a few different class classes that are going to help us with the implementation of our back end now these are just normal python classes there nothing crazy going on here and once we have this we'll then go back and kind of code the caresi components which will make this a bit more clear so I'm going to go to the top of my program and I'm going to import hash lip now we're going to use this just for the hashing operation that I talked about previously don't worry when we get to that point I'll slow down a lot and explain it to you we're also going to import time like this actually don't remember if we need time or not uh actually I don't think we do for what I'm going to do here so I'll leave that and I'm going to create a few classes now the first class is going to be called move now this is going to represent uh all of our different rock paper scissors moves now we want to just use integers to represent them rather than strings so I'm going to type none is equal to zero I'm going to type rock is equal to 1 paper is equal to two and scissors is equal to 3 just so we have an encoding for our different moves so we're saying if we don't have a move we'll just encode that with zero if we chose rock paper or scissors that'll be 1 two or three respectively next I'm going to create an initialization here so I'm going to say Define a nit I'm going to take in self I'm going to take in a commitment and I'm going to say move is equal to Zer now what I'm going to do is just say self. Commitment if we can get the autocomplete going here is equal to comp commitment sorry and self. move is equal to move now the idea here is that we're just going to have a class that will store the commitment and the finalized move for each of our players uh participating in a challenge so the commitment is going to be the secret string right and the move itself will actually be what the move is from this commitment but remember when we first create the challenge and accept it we're just going to have the secret string and it's not until the players reveal their move that we're going to actually know what their move is okay and we're just going to create a class method here so we're going to say class method and this is going to be Define move uncore 2core string and we're going to take in our class and we're going to take in a move and what this is going to do is simply return the string version of the numeric move okay so we're going to say cs. none is associated with none we're going to say cs. Ro is associated with rock we're going to say cs. paper is associated with paper notice I'm creating a python dictionary here by the way you'll see why we want to do this in a second and then CLS do scissors is scissors I'm then going to put my index or in this case key operator and I'm going to put move now what this will do is it'll take in a numeric move that's between zero and three it will then look for the corresponding value associated with the key in the dictionary so I have none which is zero Rock which is one paper which is two scissors which is three associated with a string when I access the index this means we will return a string and sorry not index but key okay so that is our move class pretty straightforward now we're going to write the challenge class now this is where things get a bit more complicated but this is where it's nice to be working in a language like python because we don't need to know the corresponding solidity code to actually write the complex logic we need we can write it in Python which I imagine most of you are better at than solidity at least I know I am so inside of here we're going to create a knit as well and this challenge is what's going to store a lot of the information we need for an individual Rock paper scissors Challenge and keep in mind we can have multiple challenges which is why we're creating a class so that we can have different instances of challenges now the first thing we need when we create a challenge is the creator of this challenge we want to know their address so we know what player is playing against what other player we also going to want to have an ID for this challenge so we know what the identifier is and how we can access it we're then going to want to have the commitment of the Creator okay so whoever first creates the um challenge will submit a commit so that's kind of the Creator's commitment okay so instead of here we're going to say self. Creator address is equal to the Creator address of the challenge we're going to say self. opponent address is equal to none now just like we have the Creator we're going to have the opponent so we have like player one and player two I'm saying Creator would be player one opponent is player two when we first create a challenge it's openended we don't know who the opponent is going to be so we mark this as none we're then going to say self do commitments now this is going to be a dictionary that's going to store the commitments and really the moves for each of our players so right away we're going to say self. Creator address is going to be associated with a move which is the commitment from that player so what we're doing is saying okay we want to make a new challenge to make a new challenge we need the Creator address the ID of the challenge which we'll look at in a second and the commitment from the player who made that challenge we want to store all of these commitments so we can access them later so we make a dictionary we have the key which is equal to the address of the Creator or the address of whatever player it is in this Challenge and we associate that with an instance of this move class which will store for us not only the commitment but eventually what that player's finalized the move is so there we go we make self. commitments we're going to say self. ID is equal to underscore ID if you wonder why I did underscore id id is a reserved keyword in Python so it's better to use underscore before just to kind of get rid of that reserved keyword this of this variable okay lastly we're going to say self. winner address is equal to none and I remembered why we wanted time so I'm going to go back and import time here we're going to go here and say self. created at is equal to time.time just so we can store when this challenge was actually created okay so this is how we initialize a challenge we get the Creator we get an ID and we get some commitment now there's a few more steps we need to go through so once we have a challenge we need someone to be able to accept the challenge right so to accept the challenge we're going to add an opponent to the challenge so I'm going to make a method called add opponent and when we have that opponent we want the address of the that opponent and we want the commitment of that oppon opponent sorry when they accept the challenge so we take in the address and the commitment and we say self. opponent address is equal to the address address of our new opponent and we say self. commitments at the address is equal to a move and then we store what the player's commitment kind of secret string actually is so very similar to what we did up here but now we're just adding it into the commitments dictionary okay so here is where it gets a bit more complicated we are now going to write the function that will reveal a player's commitment okay let's go ahead and write this we're going to say define reveal and we're going to take in self address move and non now remember non is that secret number that the player is going to store on their client so they're going to store it themselves and they're only going to submit it once both players have um made their commitments right so once the challenge has been accepted essentially either player in any order can now reveal their move so what I'm going to do here is I'm just going to start by saying if not and this is going to be self. commitments doget and then self. opponent address then I want to raise an exception here so I'm going to say raise exception and I'm going to say a opponent has not committed now the reason I'm doing this is I just want to make sure that the player who created the challenge is not able to reveal their move until they have someone accept their Challenge and make that corresponding commitment so that's what I'm doing here just to make sure I'm checking that all right so now that we have that what we're going to do is we are actually going to generate a hash of the secret key and the move that the player has submitted and we're going to verify that that matches with their commitment string so to do this we're first going to have to write a function here so we're going to say Define generatore hash now this is going to be a static method because it doesn't belong to the instance it belongs to the class and and we are going to say for Generate hash that we are going to take some input and we are going to return the hashlib do sha256 and this is going to be the input. dcode sorry not decode Dot incode and thenex digest don't worry too much about exactly what this is doing but we're using the hashing algorithm known as Shaw 2 56 which is a very popular and common algorithm we are taking the input which is going to be some kind of string we are encoding that to a hexadecimal value and then we are getting the digest otherwise known as the hash from this function okay so that is what generate hash does now what we're going to do is we're going to say the reveal uncore hash is equal to challenge which is the name of our class. generate hash and we're going to take the Nots and we're going to add the move to it both these values Will Be Strings sory this I know I said it was a number you'll see why this will be a string in a second but either way they're going to be strings and if we wanted to really be sure we could convert this to a string or we could convert the move to a string it doesn't really matter anyways we're going to take the reveal hash here and we're going to say if the and we need to actually write this first we're going to say committed uncore move is equal to self. commitments doget and we going to get the commitment from this address and we are going to say if the committed move do commitment does not equal the reveal hash then that means they tried to reveal an answer that was not their original commitment so we're going to raise an exception and we're going to say that the move does not match the commitment okay so this is the main security thing right when they first create or accept the challenge we take in that secret string that secret string should be able to be generated by taking their secret number and their move and hashing it so now what we ask them to do is okay submit your secret number and sub submit your move when they submit both those values we take them and we hash them and if they equal what they originally submitted to us that means they submitted the correct answer if not that means they submitted something that was not their original commitment okay so now once they've revealed their answer we can say self. commitments address is equal to a move we're just going to say the committed move do commitment and actually now that I think about it we don't need to do it like this we can say self do commitments add address. move is equal to and this will be the int of the move that they submitted so again we verifi that this move is correct it's going to be 1 through three so either 1 two or three but remember when we first create this move we don't actually instantiate this so it's equal to zero so now that they've revealed their move we store the move inside of the move class which essentially means everyone now will be able to see what that is okay then we can print something like reveal complete just so we have some logging so we'll be able to actually see that um in our output actually I don't think that's even going to log so for now I'm going to get rid of that I don't think we need that okay now that we have the reveal that's kind of the hard part but there's a few more methods that we want to run just to wrap this up so first of all I just want to have a method called both revealed now what this is going to do is simply just return if both players have revealed their move because we need uh both of them to reveal their move before we generate a winner for this game so we're going to say the opponent move is equal to self. commitments at the self. opponent address okay move and we're going to say the Creator move is equal to self. commitment at the self. Creator address. move and we are simply going to return the opponent move does not equal move. none and the Creator move does not equal move. none so all this is saying is okay both players have revealed their answer and we know that's the case if they don't have a move equal to none so that means they have a move right okay now we are going to write another one here which is Define has opponent committed and what we can actually do to check if the opponent has committed is exactly what we did up here so I'm just going to grab this and I am simply going to return that this does not equal none and then I'm going to use this function here so I'm going to say where is this if self. has opponent committed and we'll actually put the not here so if the opponent has not committed then we'll raise this exception I'm just making sure we don't have duplicated code by kind of fixing up some of these methods okay now lastly we're going to say Define evaluate uncore winner and this is going to take in self and what this is going to do is figure out who the winner of the game is okay so first of all let me copy this code here to get the opponent move and the Creator move because we're going to need that so what we need to check here is every possible winning case for rock paper scissors there's a few ways to do this but we can essentially write it in about six if statements bear with me here the first one is going to check if Rock beat scissors okay so we're going to say if the Creator move is equal to move. rock and the opponent move is equal to move. scissors then we can say the self. winner address is equal to the self. Creator address right because they won otherwise so L if the Creator move is equal to move. scissors and the opponent move is equal to you guessed it move. Ro then the self. winner address is equal to the self. opponent address because they chose Rock player chose scissors next we're going to check if scissors beat Paper so we're going to say else if the Creator move is equal to move. scissors and the opponent move if we can type this correctly is equal to move. paper then we're going to say the self. winner address is equal to the self. Creator address okay let's scroll up otherwise if the Creator move is equal to move. paper and the opponent move is equal to move. scissors then the self. winner address is equal to the self. opponent address okay last one this is paper beats Rock okay apparently I can't type that very well we're going to say l if the Creator move is equal to move. paper and the opponent move is equal to move. ro then the self. winner address is equal to the self. Creator address otherwise if the Creator move is equal to move. paper and the opponent move is equal to move. ro I did this in the wrong way so let's fix these around make this rock rock this is very manous to type out okay get rid of this then that means the opponent one so self. winner address is equal to self. opponent address okay chances are I messed this up but that's fine and then we're going to return the self. winner address okay now notice that I didn't handle any draws the reason I didn't handle any draws is because if the winner address is equal to none that means no one won and hence we can infer that that is a draw so I don't need to explicitly say oh the game was a draw I just don't declare a winner and if I don't declare a winner it means it was a draw okay so that is it for all of the code we needed here so we have evaluate winner has the opponent committed have both players revealed we have our generate hash we have our reveal we have our add opponent and we have our initialization and then of course we have our move class now we're going to use all of this from the back end so that's why I wanted to write this first so that we have this file kind of handled and now we can just use all of these methods that we've written now keep in mind all of this code will be available from the link in the description in case you get lost or in case for some reason something's going wrong you can just go ahead and copy it now we're going to go into main.py okay so in main.py what I want to begin by doing is essentially defining all of the different types of operations that this code is going to handle now this is how you should begin when you're writing any kind any kind of decentralized application whether it's with solidity or Cartesian you want to essentially figure out what's known as the protocol and the protocol is what different operations can be performed now remember that we have advance and we have inspect now let's just start with a comment and we want to start by figuring out okay what is going to advance the state all right what type of operations are going to require a transaction so that they'll be finalized and secured on the blockchain that allow us to modify the state well the first thing is going to going to be create challenge right first thing we need to do next thing is going to be to accept the challenge and then the last one is going to be to reveal our answer these are the three things that we need to do create a challenge accept the challenge and reveal that's really the core logic those are the three operations someone can submit to advance the state now we also have inspect now inspect allows us to get some specific data and inspect the state there's a bunch of things we could write here but what we can actually do just to simplify things quite a bit is just to get all of the challenges that are currently active right or just get all of the challenges in general we can make this more advanced if we want but really what we want to do is create challenges accept challenges reveal and then we want to get them we want to view all of those challenges we can again write some more specific inspect States if we wanted to get one challenge or get what uh challenge one players in ETC but for now we're going to keep it nice and simple and we're just going to use these four types of operations so what what we want to do is we want to essentially stub these out or write the functions that are going to handle these four operations now notice we have handle inspect and handle Advance we'll get into those in a second but for now we're just going to stub our functions so we're going to say create Challenge and we're going to put pass we're then going to say Define except challenge okay and pass and then define reveal and pass and Define get challenges and oops this needs to go here pass okay so we now have the four main functions that we're going to want to call now notice I've got this thing called handlers might look a little bit complicated but I promise you it's not too complex what this actually does if we view down here is it gives us access to the function associated with either advancing or inspecting the state so We Begin Again by defining okay what type of operation are we performing is an advanced or is an inspect so we actually get that by viewing the request type and this gives us access to a function object we then call that function object with the data associated with this specific rollup that's what's happening here with these handlers now we're going to do the exact same thing Within These functions for the different handlers we'll have for our specific methods so what I'm going to do is write some more handlers I'm going to say Advan method handlers okay and inspect method handlers and we're going to use the exact same kind of type of architecture or um design pattern here so for our Advanced method we have three different operations we could perform we could do a create challenge right which will be associated with creating a challenge because that's the function that will handle that type of request we then have reveal that will be associated with our reveal function and we then have accept challenge which will be associated with our accept challenge function function now let's go to inspect for inspect it's nice and easy we just have get challenges which will be associated with get challenges so we've just kind of mapped a string which is really the type of request we're going to handle to the function that's going to handle that request so actually sorry before we do that I realize we've got some code here that I don't want to just delete because we are going to use it uh but I want to utilize it to write some helper function so my apologies but we're going to do things a little bit different I'm going to make a new file here and I'm going to call this utility. piy or U.P now inside of U.P I'm just going to paste in two functions that are very simple that allow us to do some encoding and decoding so we can actually read what's going on so I'm just going to paste these in here very straightforward string to hex and hex to string feel free to pause the video and type them out or you can type them out as I explain what they do so anytime we receive data inside of our kind of main.py file here so like data payload and all this stuff that we're going to look at later it's going to come in as hexad decimal encoded now that's not very useful to us because I mean I don't know about you but at least me I can't read heximal data so what I want to do is I want to convert that to a string so the second function that we have here simply takes in some heximal data and it just converts it into a string for us so it says byes stop from hex this actually just gives us a string hex to string we then have string to hex which does the complete opposite takes a string and converts that into hex heximal data that's because anytime we do data exchange here so sending receiving it needs to be in hexadecimal but it's just within our own code we want to be working with strings and kind of printing out strings and logging strings because that's what we're used to using so we just have these two helper methods string to hex and hex to string that help us do those conversions so what we'll do now is we'll just import those from our main code that we can use them so we're going to say from util import string to hex and import hex to string and while we're at it we can say from challenge import challenge and import move cuz we'll use those classes in a minute now the reason I wanted to do those now is because you can see here that we have some code that adds notice and that adds a report now eventually we're going to need that so we might as well write some utility functions that will allow us to do these quite easily so we're going to say Define addore report now remember the report is just some diagnostic information kind of a log of what happened so we'll just take some output that we want the report to be and by default it could just be an empty string now for the report we're going to take all of this stuff here okay and we're going to paste it inside now we don't need all of this and we're going to modify it a bit but the first thing we're going to do is we're going to say loger doino adding notice and we're just going to add to this whatever the output is so we can see what that is now for our actual notice okay we're going to have payload and then what we're going to do is we're going to take string to hex and this is going to be our output because the output is going to be of type string but we need to convert it to a hexadecimal before we put it in the notice so we say Okay payload is associated with the string to hex like that okay then we're going to have our response the response is going to the roll up server plus SL notice that's just the endpoint and then the Json is simply going to be the payload that we have right here and then we can print out receive notice status blah blah blah with body content this okay great so that is adding a report now we want to add a notice and actually I just realized this is adding a notice it is not adding a report so I messed this up a little bit fortunately we can change this quite easily so rather than add report just make this add notice and rather than output I'm just going to call this data and I am going to make it mandatory here and I need to change this now a bit so rather than that we're going to put data in an F string just because the the type of our data here may not necessarily be a um what do you call this a string type okay um anyways I think this is fine for now adding notice data payload string to hex I'm getting a little bit confused but I think that is okay all right next we're going to do our ad report so Define add report and this time we'll take output equal to an empty string now we're going to copy this code right here okay we're going to put this inside of add report so now we can say add report plus the output we can create our report this time for the report we'll say string to hex and then our output and then I think that all of this is actually fine so I think these functions are actually exactly the same except one's notice one's report and I think I was just getting a bit ahead of myself on how this worked but anyways you have ad report and we have ADD notice that's fine so what we will do do now is going to handle advance and handle inspect and start calling the correct function based on the type of data we're receiving now I understand this is a little bit confusing so I just want to go all the way down here and kind of explain how we're going to handle this so we're writing our own decentralized application and as you've noticed here we're pretty much designing the protocol which is the way in which we want to interact with this application now we can interact with this any way we want and we can send any type of data and receive any data that we want now I want to use Json data because this is data that we're probably most familiar with it's just like a python dictionary so what I'm going to expect is that I will receive a Json object inside of my rollup data now this Json object I expect to have a key method and the key method should specify one of the appropriate methods so create challenge like this okay this is what I'm expecting uh to accept as my data now this method will tell me what the user wants to do creating a challenge revealing a challenge accepting a challenge or getting challenges so I want you to keep that in mind as I write the next bit of code here the data that this back end will accept will be a Json object that will contain the key method it may contain some other Keys as well but for now method is what we're focused on okay so if we go inside of handle Advance now which is the one we can write first the first thing we need to do is we need to parse the data we received as a Json object so to do that we're going to say payload is equal to Json which we need to import okay so let's import Json like this load s this stands for load string then we're going to take the hexadecimal data and we're going to convert this to a string now again I know a little bit confusing with me here in in fact I'm going to delete this cuz this is not going to be helpful to us right now I'm saying payload is equal to json. loads now the data that's inside of the payload which is what we're actually sending to the back end is going to be heximal so I start by converting that heximal value into a string value now what we get is essentially a string which is Json data what we want to do though is we want to take that string and we want to convert that to a Json object or in this case a python dictionary so we can utilize it just like a python dictionary so that's what we're doing but the thing is this could fail because we might not actually be receiving Json data if someone sends us something invalid so I'm just going to do a try accept and I'm just going to return reject here when you return reject you're essentially indicating that an error occurred that's all we're doing okay so we're saying okay try this generate a payload if the payload doesn't work we're just going to return reject um and kind of indicate hey whatever you tried to do here did not work work okay now if we did actually load the payload what we want to do is get the method that's stored inside of that python dictionary so we're going to say method is equal to payload doget and then method okay now what we'll also get at the same time is the sender now the way we get the sender is we say data metadata and then message sender now again what we're passing here data which we'll look at down here right so roll up request data is it's going to contain a bunch of different Keys there's some more documentation that shares with you everything but it's going to have a payload which is what we want and it's also going to contain who sent this so what address actually sent this request so that's what we're looking for message. sender so we have the sender now what we can do is we're going say logger dotinfo and we can just put an F string here and we could say received Advance request data and then we can log the payload which now will be in an object format that we'll be able to actually read There we go okay now that we've done that we just want to check this method and make sure this method is inside of the request Handler so what we can do is say Handler is equal to advance method handlers doget and then we can attempt to get the method now if we say if not Handler so essentially that means if we did not have this method inside of the ADV handlers what we can do is add a report okay and we can say invalid method indicating to the user hey this was invalid and we can return the string reject because well this didn't work otherwise what we will do is we will return the Handler and we will call this with the payload and the sender okay so this is handle Advance we are loading in our Json data data we are getting the method that the user wants to call as well as the sender of this message we then are making sure the method is valid if it is we're going to call that method by looking at the associated Handler right so we're going to call that function and we're going to pass that function a payload and the sender okay so now what we can do is we can just kind of fill in these three functions here and we can just generate something like a report inside of here just so that we can actually test if this is working using our frontend console so what we're going to do for all of these is we're going to say payload sender payload sender because that's what we want to receive and payload sender we're going to return accept Okay so we're going to return that from all of them okay and for now we are going to say what is this generate report or what is this make reports what did I call this add reports okay only one I didn't try add report and we're just going to say create challenge like that for this one this will be accept challenge this is just for testing purposes so we can actually run this code and this is going to be reveal challenge okay so now we have everything handled and kind of hooked up for advancing obviously there's some more stuff that we need to write but the core logic is kind of there in terms of taking the request and rooting it to the correct location which is what we just set up so now that we've done that we'll pretty much repeat that process and do the same thing for the inspect so for inspect we can really just copy all of this and we'll just modify it a little bit so go to handle inspect okay we're going to load in our payload we don't actually care about the sender and we're going to change this to say received and this is going to be inspect request now rather than Advance this is going to be inspect method handlers and then here for the Handler we will we'll just call this with our payload okay so that's pretty much it that's the exact same thing for inspect we get the payload we get the method we make sure the method is valid for the inspect request type if it's not we have a report otherwise we do the Handler now for get challenge that means that we're going to have to take in some parameter mean we don't have to we actually could not pass the payload if we don't care about it so we can just do this Candler and now we don't actually need to take anything inside of our get chck es okay so that's all hooked up let's do the same thing here and return accept and let's add a report that says get challenges okay everything is hooked up we have all of the routing done let me just zoom out a bit so you guys can read more of it at once kind of slowly scroll through and you can pause it if you need to have a look at it again remember all of this code will be available from the link in the description and we haven't changed any of this we've just been kind of handling routing our different requests so now that we've got that we want to actually run our code and we want to try this out to see what happens and if our requests are being routed successfully sorry about the sudden cut there guys anyways now that we have all of this code ridden what we want to do is start setting up the environment so we can actually execute and just do a bit of testing now that'll wrap up this video but let's get everything running just so we know it's working so first things first make sure you have Docker desktop running okay if you don't have a running none of this stuff is going to work so make sure you have that running in the background then what we're going to do is open up our WSL window but first we're going to make a modification uh to a few files here so if we look at entrypoint dopy orsh sorry you can see that we have echo. py now that was the name of the file we changed to main.py so we're just going to change this to say main.py now we're going to go into our dap. Json and we're just going to list all of the Python files that we have now so rather than just Echo it's going to be main.py U.P and challenge. piy these are the files that we need to copy in for our code to work so we're going to put those three here so those should be the only modifications that we need to make again in dap. Json and entrypoint.sh now we're going to go over here and start setting some stuff up now I'm just going to open up my developer guide here because this is always quite helpful so first thing we got to do is work on our node now for our node we need to build the project so that we have all of the correct doer containers so I'm going to copy this command Docker build X bake load I'm going to paste that here in rock paper scissors okay so going to go ahead and hit enter give that a second and this should build all of the necessary containers we need and you should see this run without error if you are getting any errors here make sure that you change those files I just showed you so we copied in all the correct files to the image now if you're still having issues with this what I would recommend you do is ensure that you tore down your containers correctly and that you cleared any of the cache that you have in Docker a lot of times what will happen is Docker will actually cach some previous containers volumes Etc and when you try to run this command it will use some of those containers and there'll be some mistakes because they weren't spun up or torn down correctly so what you can do is simply go to your Docker desktop you can view all of the different containers and then you can delete any of the ones that currently exist as well as deleting any of the volumes then you can rerun the command and you should be good to go before you do that you can also just run the command that takes down all of the containers so the docker composed down command the one that is in the cartei guides that are linked in the description okay now that we've built that we're just going to spin up uh the test node right so we're going to copy that command we used in the previous video just make sure the uh what do you call it here the line breaks are correct so we'll fix that one should spin everything up and we just want to make sure this runs and give it a second um so it doesn't have any errors right so it's deploying all the contracts okay okay looks to me like that is fine now in our other terminal window so let's bring one up here we're going to start uh initializing our virtual environment now you may have copied the virtual environment already if you didn't copy the virtual environment from the previous video you're going to need to make a new one so let me just open up the guide here on the left hand side of my screen and you can see that to make a new virtual environments this command if you already have it though so if you LS and again it's not going to show it cuz that's a dott but there is a uh venv folder right so if you see that in your vs code you don't need to remake it and what you can do is just activate it so I'll copy the command here to activate the virtual environment if that doesn't work then make the virtual environment first with this command then install the requirements we should already have them installed because we have the same virtual environment and now we can create or spin up our backend so what we're going to do is copy everything but not the echo. piy and then for the file it's going to be main.py right we don't want to run Echo up high we want to run main upy because that's what's going to actually execute our code so let's go ahead and hit enter there that should spin up our server and yeah we can see that it's running here okay so now that we have that what we can do is go into vs code and we can start using the frontend console to just send some requests to the server so that we can make sure that our code is working and we're just testing the routing at this point in the next video we'll get into some more of the deep logic so from the rollups example directory we're going to go to the frontend console okay let me just clear that remember that we want to type yarn just to install everything so I already did this in the previous video but type yarn we're going to get everything installed and then once it's installed I will show you how we can send some inputs and some inspect requests and just make sure that we're getting the correct reports and outputs okay so what we can do is just open up the guide here and for the guide it shows us how to do this so yarn start input send and then we can send something like a payload so I'm going to copy this into here okay let's make this a little bit larger and for the payload we actually want to put a string which is the Json data now we need to be a little bit careful here because the quotation marks can mess this up but I'm going to put double quotation marks actually I'm going to put single quotation marks sorry I'm going to put an object because we're going to send Json and I'm going to specify My Method now make sure you're putting this inside of Double quotation marks because we're essentially writing what the string is that we're going to send over uh to this back end now we'll know quite quickly if it's not working but we're going to put method and for the method we will go with create unor challenge like that okay now notice we have double quotes inside of the single quotes go ahead and hit enter give this a second we should see it popping up here on the right hand side uh once it actually gets sent through all right so we got an error here from the front end console now I think that just has to do with my quotation marks so I'm I'm just going to put double quotation marks and I'm going to start putting some Escape characters here just bear with me for a second because sending Json is not really supported in the front end console but we're trying to do it for testing we'll write our own kind of tool later but I just want to see if this is going to work now and actually send the Json over and I'll kind of do a few attempts okay so it looks like that did work it says sending method and transaction input zero added however we did not see anything appear over here okay there we go we just got it received Advanced request dat method create challenge adding report create challenge receive report status sending finish okay so that means that worked I just wanted to test the communication here and to kind of explain how this worked we had our double quotation marks which is the string we then put inside of here our Json data and I just escaped the double quotation marks with an escape character which is the backslash okay so by using that sorry is it back slash forward slash I forget which one you call this but whatever this direction slash is we escaped the these double quotation marks so we able to embed double quotes inside of these double quotes for our Json data okay so that was one now other than create challenge we want to test All Our Roots so we're going to test accept challenge okay so this is going to be an input send that over give this a second and we should see it respond to this in a minute okay and there you go accept challenge came in now we want to test reveal so let's go here and test the reveal and then next we will do an inspect request and we will test the um what do you call it the get challenges okay so input to added give this a second to respond and there you go we got reveal okay incredible now that we have that we can have a look at some of the notices or the reports that have been created so again we can go back to our guide here we have yarn start notice list but I believe we can also replace this with report so we'll say yarn start report list see if that gives us a list of reports if I type that in correctly all right I was getting some weird error there cuz my typescripts all messed up on my computer anyways for you guys that should have worked but I'm going to type yarn start inspect Das Dash payload and then we'll do kind of a similar situation here where we have method get uncore challenges don't worry too much about this tool guys I'm just using this for testing purposes we're not going to use this in the production application obviously it's just kind of a debugging tool but if I send this I think this should work if we send the payload correctly and it returns to us get challenges and would give us any reports or whatever that we're generated you can see here it says received inspect request data get challenges there you go and there's one report that has get challenges inside of it okay anyways that is it for this video I just wanted to get the core of the back end done a lot of the communication finished so this way in the next video we can handle the logic in those functions and then start working a bit on the front end and kind of getting that set up and stubbed so we can then wrap that up in the video after that anyways I hope you guys enjoyed so far if there are any questions or if you're having trouble or if for some reason you need to reference the code please you can look at the links in the description we have the cartei Discord server and you can obviously reference all of the complete code anyways I will see you guys in the next video w