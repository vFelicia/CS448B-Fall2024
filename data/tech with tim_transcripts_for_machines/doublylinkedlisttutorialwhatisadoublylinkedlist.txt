all right so we now covered singlylinked list as well as circular lists now this is gonna be an important prerequisite for this videos we're gonna talk about doubly linked lists which build on all of the concepts we previously learned so I recommend if you haven't yet learned that or you haven't seen the videos that I posted on my channel you check those out first before continuing with this video so with that being said let's get started with doubly linked lists now doubly linked lists are very similar to singly linked lists except they just have one more added kind of property to them and that property is known as a previous attribute so before we had our node object which is what's gonna be represented here and it had a value and it had a next attribute and this next attribute was a pointer and it pointed to the next note now that's great but we ran into some issues and some things that we couldn't quite do as fast as we want and that's what a doubly linked list is gonna help us do by adding a new attribute called previous I'm just gonna call it preb previous is the actual name now this means that we're actually gonna have each node pointing not just to the next node in the list so that way but also pointing to the last node in the list and this is why it's called doubly linked because it's linked to a node in two ways so anyways let's erase that for now and now what we're gonna do is we're gonna change our dll class or our SSL class to be DLL which stands for doubly linked list and this is still gonna hold either a head or tail attribute whatever one we want so maybe we'll just say tail in this case and will implement a circular doubly linked list and then it will have all those other methods that we want you know like add remove find you know whatever it is right that's what it'll have so anyways let's now draw a doubly linked list and look at how this actually works so we're obviously gonna start with a head node this will be my head node let's give it a value of seven and then we're gonna have another node let's give this one a value of three and another node and this one can have a value of negative two now let's do the pointers so each node is gonna point to the next node as well as the previous node so I'm just going to do that kind of in line here so that it makes a little bit so this one is gonna point there and this one is actually going to point back as well so this is gonna be our next and this is gonna be our previous and then the same here so next and previous and I'll just do like an N and a P here just to represent that and now what happens for the previous on seven and the next on two well this is where we implement the circular structure that we talked about before so remember this is our head and this is our tail so these will be the only ones that don't have a link to something else as of now but what we'll do is we'll change this and we're gonna implement a circular structure which means that this tail is actually gonna have its next attribute pointing back to the head and this head is gonna have its previous attribute pointing back to the tail like this now this way we're able to access the list in two ways so we can actually go forward through the doubly linked list as well as backwards and having referenced either the tail or the head will give us access to both the head or the tail so whether I put tail here or I put head and that's what we store as our main kind of pointer object for the list it doesn't matter because head points to tail and tail points to head so conversely we have them both either way that we decide to do it and that is another massive advantage of a doubly linked list so just look at this structure that we've made right here and think about why we might want to do this why did this why would this give us a speed advantage over a singly linked list and maybe what some disadvantages of it just think about that for one second and hopefully you guys can come up with some kind of answers I'm gonna explain right now so the main advantage of a doubly linked list is the ability to go through the list forwards as well as backwards and let me explain kind of where this issue comes from so in our singly linked list which I'll just draw count like a tiny little one down here looks like one two three all we had was one link between each one and then we had that certainly circular structure the one like that now this meant that say we want to remove this tail node here so let's do tail well we have to actually traverse through the entire list until we reached the second last element to be able to remove this tail node now with this doublylinked structure we no longer run into that issue now the reason we had to do that is because if we want to remove this node here that means we need to change the pointer on this node to go back and circle to the head right now because of the way we did that we had to reverse the entire list and that's the issue with a singly linked list that also means you know if we have a pointer to any node in this list and we want to know the node that comes before it we need to traverse the entire list to be able to check that which again is gonna happen in om time complexity whereas with this doubly linked list having a pointer to any node so let's say we have a pointer here will allow us to access the node before and after it which means that we can actually traverse the list much faster in certain applications and if we know the location of an element we can quickly go backwards from it or forwards from it however we like which we can't do with a singly linked list so anyways let's try to remove all this and clean some stuff up as we now talk more about the doubly linked list so anyways that is kind of the main advantage of it now this also allows us to do things like add and remove the first and last element in constant time so insertions and deletions are faster and because we can go forward and backward in the list that's how we do that so let's kind of do a simulation of removing this tail element now compared to how we would have had to do it before so if we want to remove this tail element what we need to do is simply find the tail so right now we have the tail and we have a pointer that comes to it so what we do is we're gonna go back to the node before it and we're going to start by setting this pointer to the node that the tail points do so what we'll do is instead of having this end come here we'll change this and we'll point here and actually you know what let me change the color to be green so that you can see kind of the modifications that are made here so anyways this now is gonna point here right that's the first change that we need to make now what we need to do is we need to change the previous pointer of this node here to be our next node so what we do is we say tail dot next so which is this one dot previous actually equals tail dot previous so that means that this previous which is right here rather than pointing to the tail is going to point here to three now that we've successfully eliminated both pointers to this tail element what we can do is we can change the tail now to be equal to this so we say the tail is now this and then this tail element is actually removed and that's kind of just taken out of memory because we have no pointers to it so anyways that is kind of how that works now I know it's messy because there's so many lines and stuff going on but I'll write some pseudocode that hopefully should explain to you guys how to do this now before I get into this too much I just want to explain one disadvantage of this structure the first is that it's very complex as you can see with this next in this previous adding and removing things becomes more difficult as well as takes up more memory because now rather than having each node point to simply one item we're pointing to two which obviously is gonna take up well double the memory so that could be kind of inefficient if you're worrying about memory space now these pointers don't take up very much memory at all and you probably won't notice them in a program that has less than like millions of elements in kind of a list but you know if you're worried about memory then that is something to consider so anyways let's read some pseudocode and I'll write it down here on how we traverse this doubly linked list which is actually the same as singly and how we can remove a certain element so let's say we want to remove this tail element well how do I do that so I actually don't need to traverse it because we have the tail element already set so if I want to remove that well what I can do is simply just do the process I talked about before so we'll start by setting the tail or the node before the tails next property so this one here to be equal to the head so we'll say tail dot and I guess this would be previous and then we'll say tail dot previous dot next is actually equal to tail dot next so again what that's changing here is this attribute and this is making this now go up here to the head all right sweet that's how that works okay now what we need to do is change the pointer on the head to go to our new element so we'll do that so to do that we simply say tail dot previous because that is going to be what am I saying tell the previous tale dot next to previous which now is pointing to this head node here is gonna be equal to in this case tail dot previous you can kind of see how this works they look a little bit reverse here you just kind of reverse the next in the previous swap those around and that's kind of how that works and now we just say is tail equals and in this case I guess it would be equal to tail dot previous so I'll say tail dot previous and I think that's actually all we need to do so we've changed the pointer on this we've changed the pointer on this and now we just set this as our new tail and because this will successfully eliminate that element now let's show one more example just how we add something I don't want to go through every method but I want to give you guys enough kind of examples to where you can play with it and you know make mistakes but have an idea on what you're doing so let's think about how we can add an element now to the beginning of our list so again we have our tail attribute so what we need to do now if we want to add a new element is we need to change a few pointers so we need to add a pointer that goes to head we need to change this previous pointer from head to go back to our new node and then we need to add the tails pointer so that it goes to now our new head node and we need to change this new head node to go to the tail node so there's actually four things that we need to do so it's a little bit more complicated but it shouldn't be that crazy so I'm just going to erase this pointer here just because it kind of takes up a lot of room as well as this pointer text and now let's start writing so what we're going to do if we want to add that new node is we'll say N equals node all right sweet now we can start by setting the value previous and next I'm just gonna do a little semicolon to save some space here and just say and don't value equals I don't know let's make it equal to nine and I will start by saying n dot next is actually gonna be equal to tail dot previous and remember we could be keeping track of the head here but I've just decided to keep track of the tail since we're not circular structure it doesn't matter so we have n dot next equals tail dot previous ok great so that means now our new one is pointing to head alright so what do we need to do now set the previous value to be equal to tail so now we'll say n dot previous equals okay great so now our new head node which we're putting right here is pointing here as well as its previous value is pointing here to our tail sweet so let's remove that and now we need to change the pointers on our head and our tail so we're gonna say head previous which would be tail dot next previous okay so tail dot next dot previous is equal to n so again that's gonna point to this because the next node goes here and then we get that previous pointer which will go back to whatever no do you want so there we go is equal to N and then we'll say tail dot previous dot next is that right oops sorry no that's not correct we have to do tail dot next is equal to head yeah sweet that's how we do it so then tail dot next is equal to n because this next node was originally pointing to the head but now we need to set it equal to N and now that we've done that everything should be good so let's do a quick simulation here on what we've done and just make sure that this actually makes sense since erase that erase that just get rid of some of this junk and run through it one last time okay so let's be just pretend these don't currently have a pointer and let's add that new node so let's add it here says value of nine okay so we started by setting its next value here and its previous value to the tail so we know that that's correct and then what we did is we changed the first thing which was this new node so that his previous value goes to here okay awesome good to go and then what we did is we set the next value of our tail which is this so that it goes to our new head node so the next attribute I guess we'll just put here and it points back to here and that is good to go it's awesome so now when we do tail dot previous or starting tail the previous tail dot next that points to our new head node our new head node now points to the next node in our list and this previous pointer is going here as well as the previous pointer from our head now goes back to our tail node very good we are good to go and that is how you implement a doubly linked list all right so just watching back this video and I want to add something really quickly and just to explain to anyone that might be confused for all these examples I've been using an already existed list which means you know we've already had elements in the list now what happens if you're starting with a blank list which inevitably you will be starting with in some cases well if you are what's gonna happen is you're gonna start by having your tail attribute which will be here pointing to null so you're gonna have no nodes in a blank list so the way that you know this is blank is one tail points to know if it points to null or points to non or points to nothing whatever it is then you know you don't have any elements so when you initially you know say you have this add method here when you initially call this add method the first thing you're checking is if tail equals equals null now if it does you need to create a new note in point tail to that note but how does this work well what's gonna happen is you're gonna create a new node and this is gonna be your tail but how does the previous and next attribute of this first node work well we've talked about this circular structure so let's implement it the exact same except with one node so let's say the value seven here now what is the next in previous well next actually points to itself and previous actually points to itself now I know I just butchered those line so I can redraw them but anyways like previous here goes there and next goes back to itself so what actually happens here is we still have a circular structure just with one node now I know this is weird to think about but when you're adding a new node at the end what you'll do is you'll just say tail dot next equals whatever this is and you'll say tail dot previous equals whatever this is and it just works the same so as if you had one or two different nodes when you add a new node in here it doesn't make a difference because all you're doing is just changing the pointers and regardless of if you had ten nodes or one node since you can keep this consistent circular structure let's see like when I add a new node all I need to do is say if I add one here is I'll change the next pointer of this node to go here and I'll change the previous pointer to go here and then I change this pointer which is previous to go to our new tail node right and I change the next one to go to our new node and that's all I need to do to add something in so anyways that's what I just want to quickly cover here to make sure that no one's super confused and obviously when you're adding nodes the first condition you check is if you haven't like if your list is empty to start because then you need to create that first initial node and set those pointers to be itself and that's just what I wanted to make sure everyone was clear so anyways continue with video now again just quick recap here this is faster at inserting and deleting things in most cases because we don't have to loop through the entire list especially if we already have a pointer to our head node and our tail node but the disadvantage of this is it takes up more room in memory so that's something to be aware of but being able to go forward and backward through the list is actually a massive advantage and with the singly linked list you run into a lot of issues where sometimes you know you have a node and you just want to get the node before it so you can remove that node or do something and you have to end up traversing the entire list which takes again o n time which is a lot of time especially when you're trying to do things very quickly so anyways that has been it for doubly linked lists I hope you guys enjoyed if you did learn something make sure you hit that like button and subscribe to the channel for more data structures and more Python videos