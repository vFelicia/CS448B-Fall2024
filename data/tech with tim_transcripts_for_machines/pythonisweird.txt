hello everybody and welcome to another youtube video so in today's video i'm gonna be showing you some weird python code i've got a bunch of code snippets to show you all of this code is just strange weird stuff in python you can kind of treat this video like a quiz or test for yourself where you try to guess what the output of this code is or figure out what it is before i actually run it now before we dive in i do need to mention the sponsor of this video which is fast host is running a competition for any of my uk based viewers so if you are based in the uk and you can answer my techie test question then you'll be entered to win your dream work from home setup which is worth up to 5 000 pounds so stay tuned for that and let's dive into the video all right so let's go ahead and dive in now the first weird things i have to show you in python are kind of easter eggs and they involve importing modules so these are super simple but the first thing you can do that is quite weird in python is import the this module if you import this and you run your script what this actually does is outputs a poem this poem is the zen of python by tim peters now i'm not going to read it you guys can read it yourself but this is kind of an interesting poem and well if you're into python and you write a lot in python you'll probably appreciate some of the stuff that's in here so the next weird thing i have to show you in python is also a very simple easter egg this one involves importing the antigravity module and when you do this you import this module it actually opens up a new chrome tab or new i guess web browser tab that has a comic which is about python so i mean you guys can look at the comic yourself i'm not going to go through all of it but another interesting easter egg and well a weird thing you can do in python so the next piece of weird python code i need to show you involves the wall risk operator now the walrus operator is the colon and the equal sign formerly known as the assignment expression operator it's used in a few other programming languages but it was actually new in python in version 3.8 now i'm just going to quickly show you how this operator works then i'll show you kind of a weird nuance with this operator that you might not know about okay so that is the walrus operator what's the point of the walrus operator well we have some function here this function takes in x does some long computation and then returns x plus one so imagine this function maybe takes a few seconds to run it's not very efficient and well we shouldn't call it unnecessarily if we don't have to so the problem that i present to you is we need to check the value of this function call so let's say i have some variable or let's have some if statement and i say if the func of maybe 4 is equal to let's just go with 5 then what i want to do is i want to actually print what the value of func of 4 is or maybe just to make this easier we'll go if this is greater than or equal to 5. so the whole point is we're calling this function with the value 4 and we actually want to use whatever the result of that function call was inside of this block but this is pretty inefficient i don't want to call this function two times if i don't have to and well both of these function calls are going to give me the exact same thing i shouldn't do this instead i should store this value somewhere and then use it right so what i could do if i didn't know about the walrus operator is i could do something like x equals func of 4 i could then say if x is greater than 5 and then i could just print x like that well that would solve my problems however there is a cleaner way to do this and this involves the wall risk operator so what i can actually do is inside of parentheses i can say if x colon equals using the walrus operator the func of and then 4 is greater than or equal to 5 print x and what this will do is actually evaluate this so we'll say x is equal to the func of 4 and then it will take whatever the value of x is and kind of plug it in here for the parentheses and check if that is greater than or equal to 5. so if i run this we see that we print out 5 which is the value of x so that is how the assignment expression operator works now one small detail here if you use the walrus operator like this you would imagine that what's going to happen is that x is still going to be equal to func 4 right and then you're going to check if whatever the return value of this in this case is going to be 5 is greater than or equal to 5 and then you're going to print out x that's what you would imagine you would imagine that x is going to be equal to whatever the function call is however if i do this notice we actually print out true now that's kind of strange why is that the case well the reason that's the case is because what we actually did here is we assigned x equal to this expression and that is because the precedence of this operator comes after this operator right here so that is why we're getting the value true we're first checking if the funk of 4 is greater than or equal to 5 that gives us true and then we're assigning that value to x so kind of a weird thing with the walrus operator now another thing that's weird about the walrus operator is you can't do something like this x colon equals and then the func of 2. if you try to do this you get an error and the reason you get an error is because this is not inside of parentheses and because it's not used inside of like an if statement a for loop whatever it's not used in kind of the intended way you can't just blankly assign something like this now of course x equals func of 2 works but what's even weirder is that if you surround this with parentheses all of a sudden you're good i can just print out x i'm going to get rid of this right here and everything is fine it all works so the fact that you didn't have parentheses around this made it no longer work so kind of just a weird thing with the walrus operator that's pretty much all i needed to show you so the next piece of weird python code i have for you is in front of me right here and before i discuss anything pause the video if you'd like and guess what the output of this program is going to be now if you're still listening and you're a little bit confused but you want to try to guess it my hint is going to be this has to do with the mutability of objects so let's take a look and guess what you think this is now first let me explain what the is keyword does in case anyone's a little bit confused so is is not the same as equals equals what equals equals does is compare the equivalence of objects so a really good example of this is if i have d and e and i make this equal to an empty list and an empty list let me just remove this here if i print d is equal to e we see that these are the same these are equivalent right an empty list is equal to an empty list however d is not e because these are not the exact same empty list hopefully that kind of makes sense but this empty list is stored in a different memory location than this empty list and what d is e actually does is it checks the equivalence of the ids of these objects so every object in python has an id that is the address of the memory location this object stored in and while we can see d and e are in two different memory address locations so when we say is something the same are these two objects the same we're not checking equivalents we're checking if they actually are the exact same object stored in the same location in memory okay so let's go back uh to the example that we had so print a is b a is c and b is c now the first thing i'll show you is that all of these strings are the exact same right a b and c are the same and if i print them we get okay okay okay perfect so when i do this we have to kind of guess what we think these should be but all of them should be the exact same right because they're the same string so these should all give us the same result if a is b then a should be c and b should be c if a is not b then a should not be c and b should not be c right that's what we would assume but the thing is when i print this that's not the case we get false false and true now what we actually would expect with kind of some basic knowledge of python and memory addresses and how objects are created is that a should not be b and b should not be c and a should not be c these should all be different objects and the reason for that is strings in python are immutable and when you create an immutable object what it does is create a new object in memory right and that's all it does so we technically should have a being a different id than b being a different id than c but in this case a is different than b a is different than c but b is the same as c how is this the case so b and c are the exact same object but a is a different object somehow well the reason for this is something called internal now interning is an optimization that's performed by the seethon compiler interpreter whatever it exactly is i don't know all of the details behind this but what it does is it reads your code before it's ran so while it's being kind of compiled into bytecode for the computer to understand and it performs optimizations and one of the optimizations it does is it sees if there's any objects that are the exact same if they're the exact same and they're immutable objects it creates one of those objects and points the variables to that singular object so in this case ok and ok were interned and said okay no pun intended there we see that we've created ok two times so rather than duplicating it and creating it twice in memory let's make it once and let's have these variables point to that one object that's what it does that's what the interning is doing however why is it not doing it for variable a the reason it's not doing it for variable a is because when the optimizations are performed the compiler does not know that this object is going to be equivalent to ok it doesn't know that's what the string is going to be equal to and the reason for that is we're using the dot join method and the dot join method is actually interpreted and ran at runtime not at compile time whereas a basic string concatenation and just the definition of a variable like this we know what these are going to be before the program actually runs and that's why the optimization can be performed hopefully that makes sense but that is why you get this strange output and that's just one of the weird things that can go on in python you're going to see many more as we continue in this video so we'll get into the rest of the weird code in just a minute but i need to remind you that the sponsor of this video which is fast host is hosting a competition that you can enter now fast host is a uk based web hosting company that offers a wide range of products and services they aim to help businesses and entrepreneurs of all levels succeed with effective fast and affordable web hosting that fits really any use case fast host affordable virtual private servers give you complete control over your server with flexible dedicated resources you can adjust your service ram cpu and storage whenever you need other features include 100 ssd storage uk data centers and your choice of operating systems for both linux or windows fast host also offers outstanding dedicated servers that are exclusively yours you can choose between the latest amd and intel hardware that guarantees high performance which is perfect for demanding projects with secure uk data centers unlimited bandwidth top of the line specs and 24 7 support you can be confident that your projects can handle anything they need to so now i need to discuss the competition if you're located in the uk and you can answer the following question then you'll be entered to win your dream work from home setup that's worth up to five thousand pounds now that question is who invented the python programming language leave your answers at the link in the description and best of luck in the competition so the next piece of weird python code i have for you is in front of me here take a second pause the video and take a guess at what you think this is going to output now this weird python code here has to do with chained operations and the reason i'm showing it to you is because sometimes it's a little bit tricky to actually realize what the result of these expressions are going to be so let's just have a look at this first print statement right here and actually i'll just run all of these and you can kind of see what our result is so true true false false so let's look at this first expression so 1 equals equals 1. we need to evaluate this first because it's in parentheses and we see when we evaluate this it's going to give us true so we have true in one now many of you may have thought this is actually going to give us false because well there's no true inside of this list but the thing is one and true in python are actually pretty much the same thing they are equivalent and to show this to you if i print true equals equals 1 you see that we get to true and i mean up here is what we got true and another cool thing you can do is you can actually print true plus 1 and that's going to give you 2 because true is really just 1. and so that's why that first expression does actually evaluate to true okay so now that you know that the rest of these is going to be a little bit easier but let's keep going we have 1 equals equals and then 1 in 1. again pretty straightforward we know 1 and 1 is going to be true 1 is equal to 1 and so that prints true okay what about this expression right here we have 1 is less than and then 0 less than 1. so is 0 less than 1 no it's not or sorry yes it is 0 is less than 1 and so that gives us true so now we're checking if one is less than true we know true is one and so in this case we're going to get false that's why it's printing out false there okay that's what that's that one sorry now let's have a look at this one one less than zero less than one all right so again this one is pretty straightforward because we now know that one is equal to true but we start when we don't have any parenthesis here by evaluating from left to right since these are the same operator so 1 is less than 0 that is false so now we get false less than 1 and you would imagine that false less than 1 is going to give us true right this is kind of a tricky one because 1 less than 0 that's false so you would imagine we're going to have false less than 1 so false less than 1 well that should be true because false would be equal to 0. and just to show you if i print false plus 1 you're going to see that we get 1 there right because false is equal to 0. but again we're seeing here that when i go back to this expression we're getting false why is that the case well when you write this expression in python it's not evaluated in the way that you think it should be what you actually get here when you write this is 1 less than 0 and like this 0 less than 1. this is what the actual expression is and so that is why we end up getting false because 1 is not less than 0 so that's a false and that causes this whole expression to be false so that's kind of the trick and the weird thing here is that when you write an expression like this that's chained with these operators you have to imagine that you're going to have this expression and this expression it doesn't evaluate this first and then use this to evaluate against this but in this situation it does because you have the parentheses so that's kind of the weird code in this example so the next weird piece of python code is in front of me here take a second pause the video and have a guess at what you think the output is going to be now this code here has to do with dictionaries so i've created a dictionary and then i'm adding three keys into the dictionary and three values so looking at this on a very surface level you would imagine we're going to have three keys in the dictionary and there's going to be three values for these keys right high hello and yo however when i print this notice that we only get one key and this is equal to yo now if you're just looking at d1 and d2 minus one you notice immediately that these are the exact same right we have one and then we have one two minus one is one and so it kind of makes sense that we're overriding the high key with yo however what about the 1.0 why is it that i don't get a 1.0 key inside of my dictionary and just to show you how weird this actually is if i comment these two out and i run this we do get the 1.0 key so why is this the case well the reason this is the case is because what actually happens when you're using a dictionary is the key value here gets hashed and by hashing this key value you can actually achieve constant lookup and constant deletion and insertion of keys i won't really get into that too much but pretty much any equivalent keys in python will hash to the exact same value it's a little bit strange but what actually happens when you use the dictionary as i was saying is the key value gets sent to a hash function and that hash function is kind of the actual key that's associated with a value so if i do something like we can say x is equal to the hash of 1 and y is equal to the hash of 2 minus 1 and then i print out x equals equals y you're going to see that these are the same thing and then same if i do this hash of 1.0 these are the same thing so equivalent values in python hash to the exact same thing and even more strange if i do the hash of true that also hashes to the same thing so you have to be careful in dictionaries because if you have keys that are equivalent but do not look the exact same like true and like one their hash is gonna go to the same thing which means if you're trying to have two distinct keys but they're equivalent that's not possible you're gonna end up overriding one of those keys hopefully that kind of makes sense but that explains why when we have 1 and 1.0 we end up overriding the key right so if i just do this and i just have 1 and 1.0 you see that we get the key one with hello and notice it's not 1.0 strange again right so we initially added one as the key so we hashed one and then added that as the key and then we said d at 1.0 is equal to hello and when we hashed 1.0 we realized this key already existed in the dictionary so rather than creating a new key we overrode it with hello and that's why 1 still exists even though the value is associated with the key at 1.0 so really weird how this works and if we do this in reverse you'll get the same thing right so if i have d at 1.0 1.0 is the key that persists because it was the first one that was added in so that's all i needed to show you just some weird things related to hashing of keys with dictionaries in python the next weird python code i have for you has to do with the all function so there's this function in python called all and what this does is take some iterable object and tell you if all of the values in it are equal to true so if i go 1 2 3 false and then let's print out all and let's see what we get we get false the reason we get false is because there was one false in this list now if i remove the false we get true because all three of these values are true values okay now clearly if you go true true this is going to give you true and well all works right no pun intended again but it works as we would expect now the weird thing occurs though when you start having nested lists so let's say i have a nested list so just an empty list inside of this list right here when i run this notice that we get false but what happens if i add something inside of this empty list well when i do this we get true so it's kind of weird how this works for add another nested list now we get false so the nested list an empty list is equal to false so if you have an empty list inside of the list then that's false however this is where it gets really weird if you have an empty list inside of an empty list inside of an empty list this gives you true and the reason for that is that the way that the all function is implemented is as follows i'm just going to copy it in here we have define all interval for element interval if not element return false otherwise return trip and so when you have three nested lists like this and we check the element that's inside of the main list which is this element right here we see that it's not empty this list here the one that's kind of like the second embedded is not empty because it has an empty list inside of it and so that means that this actually tells us that oh yeah this is true even though we know there's no true values in here it's completely empty it's just a bunch of nested lists so a very weird thing obviously i could add a bunch more nested lists like this we still get true i could add even more nested lists inside of the nested list and well we're all good so just kind of a weird thing figured i would show that to you when you have two nested lists you get false when you have three you get true and that's because of the implementation here of the all function alright so the next weird python code i have is right here pause the video take a guess at what you think the output is going to be all right so let's run through this here we have our first print statement we have x equal true y equals false we say not x equals equals y now you have to ask yourself here when you're evaluating these is the not going to be applied on the x or is it not going to be applied on the x equals equals y good question to ask you have to ask yourself that i imagine most of you would assume that the knot is going to be applied on the x right so if you're taking that logic you're saying okay not x so not true not true is false false does equal false and so this first parenthesis image should give us the value true so if i output this we do get true nice okay so now let's move to the next print statement so we'll follow the exact same logic as before we'll say all right we're going to apply the not to the y first so that means not y is going to be true x is equal to true so that should give us true right our second prince image should output trip so let's run it and notice we get an error it says invalid syntax x equals equals not y so why is this the case why are we getting an error here well the reason we're getting an error here is that not actually has a lower precedent than equals equals so we actually apply the equals equals before we apply the not and so in this situation what this expression actually looks like is not x equals equals y so in this case we thought that we were doing it correctly just because those expressions are the same when you do them in the opposite order but not is evaluated after the equals equals so even though the not doesn't work the way we thought it does we still get the right answer here because well the not of false is equal to true but when we go down here the reason we get the syntax error is because we try to evaluate the equals equals before we evaluate the not and so what happens is we say x equals equals not that's what we look at the expression right here is what's being looked at first and that's what's throwing that syntax error because not is obviously not valid i can't compare not to x and so that's why we're getting an error so if i wanted this to work properly i would need to actually do this so now if i do this we're going to evaluate the parentheses first which is good that turns that false into a true and then x equals equals true well of course that is true so it's kind of a weird thing you would think you could do something like this but you do need to parenthesize it because if you do this on the right hand side of a double equals sign then you're actually going to get a syntax error which is not something that most people expect alright so the last one i have for you here is definitely the trickiest don't feel bad if you don't get it correct in fact i'll be surprised if any of you get this correct but pause the video take a guess if you want and now i will explain it okay so we have a comma b equals a and then the set at index b equal to dictionary comma 5. at first glance this is very confusing and you're probably thinking this is going to result in an error i'll tell you right now it's not an error now the reason you might think it's an error is because we have two values here two values here but only one value here and you would kind of imagine that what's going to happen is if i put like a c here so maybe i did like dc is that a is going to be equal to dictionary d is going to be able to equal the dictionary b will be equal to 5 and c will be equal to 5. that would be a good guess to have if we had 2 2 and 2. but we don't we have 2 1 and 2. so how does that change things well let me just run this and show you what we get we get a dictionary for a with a key 5 that has the value which is equal to a tuple that has the same dictionary this is what's known as a circular reference and then the value 5. now let me explain the circular reference so whenever you see three dots inside of a data structure that means that this data structure here is the exact same as the data structure it's inside of and so what really is happening here is five is holding a tuple and inside of that tuple it's holding this entire dictionary and so rather than printing the entire dictionary again it prints three dots because if it were to print the entire dictionary again it would do that into infinity because if it prints the dictionary and the dictionary is itself then that dictionary is going to need to print itself again and again and again and again and you would just recursively keep printing the same dictionary and hence why you get the three dots because this is a circular reference this dictionary is actually the exact same dictionary here kind of a weird thing but that's what it is so let's kind of diagnose this and see how we actually come up with this so what actually happens here when you have an expression or you have kind of like multiple equal signs on the same line is you start by assigning the values on the furthest left first and what you do is you say a is equal to or a comma b is equal to and then whatever is on the furthest right hand side and so in this case a becomes equal to a dictionary and b becomes equal to 5. that's the first assignment so let's write this down a is dictionary b is 5 so this kind of first left assignment is done now we read this we say a b is equal to dictionary and 5. the thing is this dictionary has already been assigned to a and so this dictionary here is the same as the dictionary stored in a it's not a new dictionary because we only wrote it once so now what happens is we say a at key b is equal to dictionary comma 5. now b exists because we just assigned b and so what this does is it adds the key 5 to the dictionary and the key 5 now stores the tuple which holds the dictionary and 5. but this dictionary is the same dictionary that a is holding and so what this ends up holding is five colon and then dictionary which has five colon and so on and so forth so what you end up getting is that circular reference right and so i'll just kind of write it in as the dot dot dot to save us from the confusion but this is what you get and that's why you get it because that's the way that you read it and so kind of a strange weird thing i've never seen anything like this in python before but i figured i would show it to you as the last thing because well it's very very weird all right so with that said i think i'm going to end the video here now all of the examples that i showed you here are actually from a github repository it's called wtf python i'll leave the link in the description full credit to them they have a ton of other examples on there i just kind of went through and picked ones that i think would be good to show in a video but if you want to see way more advanced ones check out that repository in the link in the description all right i hope you guys enjoyed if you did make sure that a like subscribe to the channel i will see you in another one you