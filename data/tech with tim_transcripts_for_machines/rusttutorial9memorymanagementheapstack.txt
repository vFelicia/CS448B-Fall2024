hello everybody and welcome to video 9 in this rust programming tutorial series in this video i'm going to be talking to you about memory management in rust specifically discussing the stack and the heap now this is going to be a general introduction to memory management in the next video i'm going to talk about ownership and then we'll move on and talk about references pointers arrays slices and all of those other things but before we can do that of course we need to understand the stack and the heap i'll also say that if you are getting confused here i will recommend that you read the official rust documentation it is a little bit difficult if you don't understand some of these concepts already but it may clear some things up if this video is giving you you know a good understanding but you just want some more detail so i'll link that in the description and with that said we can dive in here now i do of course need to remind you to check out programming programmingexpert.io from the link in the description we teach all kinds of advanced programming concepts stuff similar to this as well just for other programming languages like go and python with that said though we can get in here so on my screen you can see that i have a stack i have a heap and i'm kind of indicating that these are all part of ram which is random access memory i also am going to have a few photos on the left hand side of my screen which will be examples that we'll walk through as we go through this video now the first thing to talk about here is what i mean by memory management and some of the considerations or concerns you may have when it comes to writing information to ram and reading information from ram as well so whenever we run a program or executing that on our machine we need some space in ram where we're going to store the data associated with our program so we have a very basic program over here but in this case we would need some location in ram where we can store the value of the variable x right now in most programming languages we don't really consider what happens when we write a statement like this we just know that okay this data is going to get stored somewhere i can then retrieve it later on by using the variable name x and you don't really care beyond that now in rust this will be handled for us automatically as well but we do kind of want to understand what's going on a bit more just because this is a systems programming language and we have some more lower level control here in rust than we would in a language like python or javascript or something along those lines so we just want to know kind of what's going on when we actually do something like let x equals two how that's getting allocated in ram and how we're retrieving that information and all of that kind of stuff so when it comes to doing this right storing information and ram there's a few concerns the first concern is that wherever we store this information we want it to be easily accessible we want to be able to find it very quickly we don't want to be searching in ram and spending a lot of time trying to find this data the second thing is we don't want to be duplicating this data or taking up any more space in ram than we have to so for example here i wouldn't want to have multiple you know x equals 2 in my ram because we're using up more space than we have to be we also want to make sure that we only have this data in ram when we need to be using this data if i'm never going to be using this variable let x equals 2 or i've already used this data and i'm no longer going to be using it in the program i probably want to remove it from ram and we need to have a way to do that now that concern specifically is something that is dealt with in a different way in many different programming languages for example in java we have something called a garbage collector which will automatically delete data from ram when it's no longer referenced in the program other languages implement different styles or different types of doing this and in rust we have kind of a unique way as well which i'll talk about a bit in a second okay so hopefully that gave a general introduction here but as you can see in rust we have two different sections of ram now that's going to be our stack and our heap now the stack works similarly to a stack you would have learned about in your data structures and algorithms course where the last piece of information in is the first piece of information out so you can think of like a stack of plates where if i have three plates like this the plate that i put on the top that was the most recent plate to be added will be the first plate to come off of the stack because it's at the top now this also has an official name that is lifo or philo now lifo stands for last in first out and philo is first in last out so you can apply whichever one you'd like there to try to remember this concept but keep that in mind the last piece of information in is the first piece of information out when we use a stack now we have the heap now the heap is not really at all similar to the heap data structure that you'd be familiar with from a data structures and algorithms class so for now just understand we have kind of a separate section here called the heap but don't try to visualize it like you would kind of a traditional heap that you would have seen in in data structures and algorithms okay so we have these two pieces of information or sorry two kind of sections of ram and they're used for different purposes now the fastest piece of ram or thing that we have in rust here is the stack so ideally we want to put everything that we possibly can onto the stack and then we use the heap when we need to use the heap for kind of a dynamically sized object which i'll talk about in a minute for now they'll understand that the stack is the fastest and we want to prioritize using the stack when possible however sometimes we need to defer the heap and use that and again i'll go through all those details just trying to give you a general introduction here so now that we have that understood let's kind of ignore the heap for right now let's just look at the stack and let's see what happens when we run a basic program like this in terms of storing information on the stack and again remember the stack is a part of our random access memory so what we can see in the stack here is that we have kind of these little boxes right now this is just my visualization this is not exactly what a stack is going to look like but we will have some address associated with every kind of box or space in our ram or in our stack now this address is how we'll access different information and each piece of information will have its unique address right so just kind of keep that in mind the addresses will be much longer than this i'm just going with very basic ones again for the video and the explanation so we have this program here we say function main and we say let x equals two now when we have let x equals 2 we need to store this in ram so what we do is we go to the stack we place a name x here and then we place a value 2 and we put this on the top of the stack now the top of the stack will just represent the most recent piece of information that we've added to the stack right and then when we add more we'd add like this and when we removed from the stack we'd remove whatever the most recent piece was and keep going kind of down the stack if that makes sense for now though we have x equals two that's been added onto the stack so now that we've placed this here if we use x later on in our program like we print it out we can just access it directly from ram and use it however what happens when this function is finished executing what do we do with x equals 2 on our stack well we need to remove it and the way that this works is that x here is within a scope now the scope is the function that is defined inside of or the block that is defined inside of so in this case we have function main and that means that x since it's defined inside of these curly braces here is a part of this main scope so that means that once this scope is finished executing or we're outside of the scope outside of the main function we need to remove x from ram and russ will do that automatically for us so let's say you know we execute x here we do whatever we want with it then we get to this line right here kind of where i put this double slash although i could have i guess just put an arrow then what we're going to do is remove x from ram so we remove it like that and there you go we've kind of garbage collected or got rid of information and ram that we're no longer using now i know this seems extremely basic right now we're going to go into some more advanced examples but this is the basic concept right we go through a function we see a statement like this let x equals 2 we then add x into ram and then as soon as we're outside of the scope where this information is being used we automatically remove it from ram or from our stack so i've just placed another example on the screen here and we're going to go through this in a second but i do want to mention that the stack is only capable of holding information that has a known and fixed size now that essentially means that we can't store anything on the stack that could change size later on and then we can add stuff to delete stuff too we can't store for example a dynamically sized array on the stack or a dynamically sized string you can only store anything that has a fixed size and for now a fixed size would be something like 2 or 3 or the value true right like a boolean or a float all of those are fixed size they're not going to change throughout the program whereas we could have some data structures that we haven't yet looked at that can change size and that's where the heap comes in and where we need to store those hopefully that gives a bit of clarity uh but that is kind of why we can't just use the stack for everything although for now with the examples we have we will just be using the stack okay anyways we have two lines of code now in this main function and i just want to show you again what happens here when we run through the code so we're first gonna create a space here on the stack where we have x equals two then we're gonna create another space on the stack where we have y and we're gonna copy the value from x here directly into this box and we're going to have 2 as well now we do this because this is an immutable value which means i just make a copy of it so i have the copy right there so now i have x and y on my stack notice i placed x first and then i placed y because that's the order in which i saw them here as i was reading through these lines of code so now let's imagine that we get to the end of this main function here we are no longer in the scope in which these two things are defined and so we need to remove them from ram so how do we do this well we need to essentially pop off the stack so we're going to start by popping this element off which is the top of the stack the most recent element that was added and then we're going to pop this one off so i can just delete these i'm gonna delete that we pop the first element off and then i'll delete this we pop the second element off and there you go that's all that's involved in adding kind of these integer values onto our stack now let's do a more advanced example where we have multiple functions and see what happens there with those stacks all right so i've just placed another example on my screen here where now we have a function call and let's look at what happens with the stack i can go relatively fast because we've already looked at kind of this main example so we start by defining x and y they're both going to have the value 2 here on our stack then we call this example function and when we call this example function we're going to go inside of here and start executing the code and just like we added information onto the stack from the main function we're going to do the exam the same for example so we're going to have a here and that's going to be equal to true excuse my messy handwriting and then we're going to have b here and that's going to be equal to false and again notice that i'm adding them kind of in order in which i'm viewing them on the stack so now this element here b is the top of the stack and if i start removing things from the stack or popping them off this will be the first thing to be removed so now i'm in example right i've executed this code let's go back to white here and i reach the end of this scope so now i'm outside of this scope so that means i need to pop all the elements off of the stack that were a part of this scope so a and b i'm no longer using them i need to pop them off so i do that right we pop one at a time we pop b this comes off the stack then we pop a that comes off the stack and now we return back to where this function was called and we see that we still have x and y and we still have them here because this function is not yet done x and y are still within the current scope hopefully that's making a bit of sense we have not yet popped x and y because this function is not yet finished execute so now let's say example is done we now reach this line right here now we're going to pop y and x off the stack again in this order because we're now out of the scope so there you go that's the basics on adding item to the stack now if i go back to where we had all of our items on the stack let's just note here that the reason why a stack is very quick is because all of the information associated with the current scope that we're in is simply at the top of the stack we don't really need to search for this information we just know that it's at whatever the top of the current stack is so i'm inside of the example function right now at this point in time and if i need to access a or b i know they're going to be at the top of the stack i may need to look a few elements down to find it but i know that they're here because the information with the current scope is at the top of the stack that's what makes this extremely efficient is this kind of stack data structure and then of course when we finish this function call right here we remove this information from the stack now we're back into this scope and now if i want to access the information in the main function well again i just look at the top of the stack i look at x and y so hopefully that gives you a bit of an illustration of why a stack is a very fast data structure and why we're using that here for managing the memory of kind of our basic variables or basic data types now that we understand the stack though let's have a look at an example where we actually need to use the heap or before we do that we can look at a more advanced function example where we have say parameters all right so i've just pasted another example here on the screen excuse the kind of modification that i've made but you can see that i have this add function it has two parameters x and y and conveniently those shadow the names x and y from the main scope and then i'm calling this add function x y again sorry that it's a little bit janky here but i think you get the idea so on the stack i've already placed x and y and i'm imagining here that we're at this add line so when we come to add here now i want to ask you what happens what's happening with the parameters in this function and how do those get added to the stack or not added to the stack how do we deal with that well whenever we're passing immutable values to a function they're just going to be copied into the parameters so what's actually going to happen here is we're going to add to the stack x and y again and they're going to have the same values of 2 and 2. now the function knows to use this x and y as opposed to using this x and y even though it doesn't matter because they're the same value because it's looking at the top of the stack for variables named x and y when i'm referencing them inside of this function hopefully that makes a bit of sense but that's kind of how the stack works and deals with this name shadowing it's looking for essentially the most recent value on the stack that matches the name that it's looking for so in this case when i try to do something like x plus y nothing has to happen on the stack but we retrieve x and we retrieve y from the top of the stack as opposed to later down and then we see that these are equal to two we use them and then we're going to return a value back here to this add function now i'm not really going to describe exactly how that works in relation to the stack but once this scope is finished then again we're going to pop off x and y now we're back to this main scope where now we have x and y equal to these two values even though again they were the same then once we finished the scope we would pop those off and we would continue okay i just want to show you a quick example there with parameters and kind of the name shadowing now that we've done that i'll drag in one more example that has to do with the heap and we'll see when we would use the heap and why the heap can be slower than using the stack so i've just placed another example on the screen here i apologize that it's a bit small but in this example we're using something called a string now i know we've looked at strings already but there is an important distinction to make here between what this is a string literal that has double quotation marks and the string from now the double quotation mark string is immutable it cannot change in size it's a fixed size and we can store that on the stack however when we use this special kind of string syntax here so string colon colon from this actually creates a dynamically sized string which we can add characters to remove characters from we can change the size of it it becomes a dynamic size so since we're using this string from something we haven't yet seen before we need to store this on the heap we can't store this on the stack because we can only store something that's a fixed size on the stack so again if it was just this double quotation mark string we could put it on the stack but since it's not it's this special string object here a special string type we need to instead store it on the heap so you can see i've already kind of skipped step one here where we have x is equal to two and i put that on the stack but now we have this string and we need to store this string on the heap so what actually happens when we want to store something on the heap is we need to refer to or use something called the memory allocator which is going to find space on the heap for us where we can store this string so just keep in mind this is an important distinction on the stack when we add something we just add it at the top of the stack right if this was another immutable value or something that was a dynamic size i just put one y2 for example like we've seen before and we're good we just add it at the top of the stack however with the heap we actually need to search through the heap and look for a location that's large enough to hold what it is that we want to store so we're allocating space we're looking for space on the heap now this is much more time consuming than the stack because we actually have to look through the heap right there's something we have to do to be able to place something on it whereas on the stack we just immediately place it on the top so we go to the memory allocator it then kind of gives us a location on the heap where we're able to store this and then we place that string onto the heap now in terms of the name here this is kind of irrelevant when it comes to the heap i'm just going to put the value here as hello if i can get that in okay so that fits in nicely and now what happens is we actually get what's known as a pointer to the value on the heap so let me just write this out and then i'll explain this we're now going to have string that's the name of our variable that's going to go on the stack and instead of storing hello inside of here we're instead going to have a pointer that's going to point to the location of this string in the heap again we're just pointing to where it is in the heat so now if i actually want to access the value of the string i need to find the address or the location in the heap where the string is stored i then need to go to the heap i need to retrieve the value and then i can use it or i can modify it or do whatever i want with it whereas if i'm just getting something directly from the stack all i have to do is grab the value whereas here there's kind of a little road map or it's giving us an address or a pointer to where this information is actually stored we're going to look at this more in detail later on but that's what happens with the heat the heap is not as organized as the stack and it's just essentially mapping values to an address and then we use that address to access the value from the stack so we store the name of the variable here it has the pointer this actually stores the value and again the reason we need it on the heap is because we need to have kind of a dynamic sizing or a space that's large enough to fit the value which we had to search through in the heap to find so in summary here storing something on the heap is slower than storing something on the stack because we need to search for space to be able to store it it's also slower to access something on the heap than on the stack because we need to follow a pointer to find that information and contemporary processors like the standard processors we use today are much faster at accessing data that's close together in kind of an organized block than to potentially be randomly kind of jumping around a heap looking for data so that's why i've been putting a ton of emphasis here on the stack and the speed of the stack as opposed to the heap now you cannot always use the stack of course in this situation we needed the heap but the point of knowing this is that you want to optimize your programs to use the stack as much as possible and avoid using the heap where you can or understand the performance kind of hits you're going to have by using the heap now with all of that said russ is a very fast programming language there's not really a problem with using the heap you can do that and we're going to be doing that many times you just want to understand where your information is is it on the stack is it on the heap how do i retrieve that what is a pointer and kind of the basics of how information gets cleaned up or data gets cleaned up from random access memory either being on the heap or being on the stack now with all of that said i think i'm going to start wrapping up the video here in the next video i'm going to discuss something with you called ownership which is going to bring all of this full circle and talk to you about why it was important to actually understand the difference between the stack and the heat for now all you need to know is you store fixed size data on the stack you store dynamically sized data on the heap and then when you need to access data on the heap what you do is you have essentially a reference to it on the stack so i have my string variable and this is a pointer that is pointing towards the heap and that's how i actually access that data again making it much slower to access and use data on the heap than when it is directly on the stack with that said i will wrap it up here i hope you found this helpful if you did make sure to leave a like subscribe to the channel and i will see you in another one