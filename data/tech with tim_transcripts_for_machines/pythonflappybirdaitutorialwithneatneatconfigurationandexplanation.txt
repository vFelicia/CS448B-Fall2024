all right so now time to actually start coding and program the AI for this project now we're gonna be using the NEET module to do this which means that a lot of the hard work is actually already done for us we kind of just have to understand underlying concepts to make some good decisions on what to feed this neat algorithm and kind of the configurations to set this up now I've already discussed how this NEETs algorithm works in terms of the flappy bird project so please if you haven't watched that video already go watch it now this video it's not actually part of this series it was kind of the project outlined for this I'll leave a card in the top right hand corner of the screen which actually I guess it's gonna be over there as well as a link in the description to that video now it's only a 10minute video but it explains exactly how this works and I highly recommend you watch that because I'm not going to be reading any of this stuff I said in there now here in front of me is the neat documentation this will be in the link in the description every video and essentially if you're lost on anything or you feel I didn't explain something well enough please you know feel free to come here read through the documentation there's everything that you need this is how I learned to use this by just reading this myself so I'm sure that you guys can figure it out if you need to as well on here now last thing if you're still lost with needs and you want some more stuff to try to understand this I highly recommend that you read this paper this is the original neat paper it's actually referenced in this documentation here and explains exactly how this algorithm works so please go ahead and read this it's only six pages long it's fairly technical but I think you guys can get through it I read it two or three times and after that I feel like I understand the NEET module much much better so again that link will be in the description down below okay so now that we've done that let's talk about what we actually need to do here so the way that NEET works on a very basic level is it involves a neural network so maybe we start with a really basic neural network so we have three input neurons and we have one output neuron and maybe these are all connected well what NEET actually does is it will change the values of these connections so the weights and then it will randomly add other nodes so maybe we add a node up here that's connected like this and remove and add connections now the reason it does this is to try to find a top all you're kind of an architecture for the neural network that works best for the problem we're solving so it starts very simple and then it gets more and more complex only as it needs to now if it doesn't need to get more complex it won't do that and that's actually a very good thing in our case because that means that if we could have a very basic neural network solve the problem that's favorable and neat will allow us to do that by favoring kind of smaller architectures if they're performing better than a more complex one now I don't wanna go in to depth about how we kind of add two nodes and all of that and the mutation and all that jazz but just understand that we start with a very basic neural network and as we need to we'll add complexity of that network in terms of other nodes other connections more neurons different layers and that's something that we don't actually do but then the algorithm will do by itself okay so now that we kind of have a basic understanding of how that works let's now talk about the things that we actually need to give the neat module or they need to algorithm so that it can figure this stuff out for us now the first thing and the most important thing that we need to do is discuss what the inputs are going to be to our neural network now again this is just neural networks being evolved using a genetic algorithm and I've talked about how this worked in the other video but essentially if we don't have these inputs right we can never be sure that we're gonna get a good neural network or a good kind of AI it's working if it doesn't have the correct information how can it possibly figure out you know whether how to jump through those pipes correctly so let's talk about what information we should actually be giving to the neural network now in my case the information that we're gonna be using here is just enough um that's not too much information but that should hopefully let the network kind of figure out some patterns now I'm gonna start by giving the network the position of the bird now since the bird doesn't move along the xaxis all we need to do is give it the Y position because that's the only direction it's gonna be able to move in so we'll give it bird Y and then what I'm gonna do is simply give it the distance between the bird and the next upcoming top pipe as well as the distance between the bird and the next coming bottom pipe so I'm just gonna put top pipe here and bottom pipe so that we kind of have an idea of what this is now some of you may argue that we don't need both the top pipe and the bottom pipe and you may be correct I would encourage you when we actually set this up to only use maybe two of these inputs and see if you can get it to work like that now the reason I'm using both of these is because I think this speeds up the process of the network figuring figuring this stuff out because it doesn't need to determine the gap distance in between the pipes if we only gave it one input of the top pipe or just the bottom pipe all right the next thing we need to talk about is the output of our neural network now the output here is pretty simple it's either we jump or we don't jump that's the only control we actually have for our game and whenever a programming AI for a game we kind of think of the output as what button we should press or what the program should actually do what the character should do so maybe you know if we're playing like snake and we're like moving all around then what we might have is you know move up move right move down and move left which means we need four output neurons to represent all these decisions now since all we're gonna be doing here is saying you know click space or don't click space to jump then all we need is one neuron and this is just gonna say I guess I'll write it in reg that is consistent here jump or do not jump so these are the first things you always need to think about when you're programming in AI what are the inputs going to be and what are the outputs gonna be alright so now that we have that we can talked with the next important part which is the activation function now this isn't crazy important but it does make a difference on how you're going to evaluate this output neuron so in this case we're just gonna pick the activation function for the output neuron and we're actually gonna let neat pick the activation function for any hidden layers or hidden neurons that we have but in this case I'm gonna use an activation function called tan H now this is actually the hyperbolic tangent function and it looks something like this I'll draw it out really briefly here so I'm gonna say that this line here is 1 and this line here is negative 1 and what this looks like there's gonna be a crude drawing so please excuse me is something like this we're set the larger positive a number the closer to one it's gonna be and the larger negative a number the closer to negative one it's gonna be now that just allows us to squish whatever value we get from this output neuron to be in between negative 1 or 1 and this way we can evaluate what you know the value of this is and then we're gonna be able to tell whether we jump or not jump now there's other popular activation functions like sigmoid and all of that and we could have used a sigmoid function for this but I liked NH and what we're gonna do with this 10h function is since it squishes our values between negative 1 and 1 we're gonna check if the value is greater than 0.5 and if it is we're gonna jump otherwise we're not gonna jump now we could have done the same thing where we check if it's greater than zero but 0.5 just works better for this and we can talk about that a little bit later all right the next thing that we need to give our neat algorithm and this is specific now to this neat module and genetic algorithms is the population size now this is a pretty arbitrary value and it doesn't matter a ton in fact you can actually play with this value and you'll probably still get the same result but in this case we're gonna start with a population of a hundred Birds now essentially the population is how many birds we're gonna have running each generation so essentially the way things work is we start with generation 0 so we have Gen 0 we have a hundred Birds in this case which are just gonna be random neural networks so random neural networks controlling a hundred Birds and then what we're gonna do is we're gonna test all these birds we're gonna take the best of these birds breed them mutate them and create another hundred birds in the next generation which is generation 1 and then hopefully these birds since they came from the best of the previous generation will be a little bit better and we keep going and going and going going until eventually we get some perfect Birds now this number essentially just means you know how many birds are we running each generation how many are actually trying for really complex problems you might need to do you know like thousands of birds running at once but for this flappy bird game you know we could probably even bring this down to a number like 10 and still be able to have a high degree of success in coming up with a solution essentially the more birds you have the more the larger the population size the more variants you're gonna get in the more and stuff that's gonna happen so we have a higher chance of you know generating a bird with a new connection or a new node or something like that and kind of the structure will just get a little bit more complex for some of our networks since this is flappy bird we don't need to do anything too crazy so we'll just set this as a hundred and again you guys can mess with this I've done it with fifty and it worked fine but a hundred just what we're gonna go with all right so the next part and the most important part to talk about now is the fitness function now the fitness function is by far the most important part of the NEET algorithm now obviously these inputs and these outputs matter a lot because these are what the information is and what we're actually gonna do but this fitness function is how we're actually gonna grow and how these birds are gonna get better now we'll talk about the fitness function in the next video specifically and how we use that but it's something to keep in mind that we need a way to evaluate how good our birds are because the way this neat module works and this algorithm works is we take the best birds from one population we breed them and we mutate them and we keep doing that now if we're not actually getting the real best Birds or we're scoring on some kind of metric that doesn't make sense for the best bird then obviously we're just gonna have a trash a I so we need to make sure that however we score these birds and get you know figure out which ones are better makes sense so how do we do that well for flappy bird it's actually pretty straightforward there's a few different ways you might think about doing this but what I do is literally just say you know I'll draw a bird here this will be my bird the circle whatever bird makes it farthest in the level did the best so every kind of frame that the bird moves forward like every X position it goes forward we're gonna give it another point and the birds that get the farthest in the level so you know bird over here is gonna be you know a lot better than bird over here in terms of fitness because he made it further or they made it further in level so that's the way I'm scoring Fitness however far you get is what we'll do but we also talked about some tweaks that we can do on Fitness and how we can influence birds to make it further in the level by adding some things later alright so we'll say fitness function we'll just say like distance so like how far it goes and I guess I'm writing in black now that's alright the last thing to talk about here now is the generations we want to run for so at some point you know after we ran for thousands of generations if we still don't have an AI that works really well we're probably just gonna give up and try again because maybe we got unlucky maybe when we added connections when we did things just didn't work out in our favor so what we're gonna do here is set a match generation in this case I set a max generation of 30 which means that if I make it past 30 generations and we still don't have a perfect bird then we're kind of gonna cut this program we're gonna try again because 30 is just too far for me so anyways that is kind of the information we need we've talked about that now so let's just start programming and the more stuff that we program the more stuff I'm gonna have to explain anyways so let's get on with it all right so the configuration file now this is a very important thing that we need whenever we're creating a neat project or using the neat module and this essentially is kind of setting up all the variables and just parameters for this algorithm to run and a lot of the things that I discussed previously like in the last few minutes we're gonna set in this configuration file so if you don't want to type this out from scratch which I don't recommend you do you just click the link of the description to download this I'll just download a text file and then make sure you drag that text file into the same directory as your main Python script because we're gonna use it probably in the next video when we actually set things up so let's start talking about some of the stuff in this configuration file and just setting some values I actually already have it set to all the stuff that we need we'll talk about what it does and why I've set it to that so the first thing here that to talk about is in this neat section and this is Fitness criterion now this is simply a function we can either choose from min Max or mean and this determines how we get rid of the worst birds or actually like what function we use to determine the best birds so obviously we calculate a fitness for all of our birds and we do that from actually this main script which we'll do later but now when we need to remove birds or add birds we need to know whether we're taking birds with the highest fitness or the lowest fitness now I know it's weird like why would you get rid of birds with the lowest fitness but sometimes you might want to do that so in that case you would change this to min but in this case we'll do we'll just put max okay which means we'll take the birds that are the best will breed those and we'll keep those ones and we'll get rid of the ones with the lowest Fitness all right now fitness special pretty straightforward this simply means what number do we actually need to reach so what a fitness level do we want to get before we terminate the program so in this case I'm saying you know if we have a bird that reaches a fitness score of a hundred then I'm gonna say we're good enough this bird is likely gonna go on forever he's gonna be very good we don't need to do any more generations after that and that's exactly what this does so whenever we reach a population and there's a member in that population that has a fitness higher than or equal to this value we will stop running the program that's what this does all right next population size pretty straightforward this is 50 that's what I'm setting did I say a hundred before you know what let's do it as a hundred but again you can change the value to 50 or whatever you want reset on extinction essentially means that what neat actually does is it separates the different kind of architectures of all of our population into what we call species so birds that have you know two or three hidden layers or some weird nodes and there will be one species and birds that just have that standard you know three nodes one out Panero be its own species so it's saying as if we have a species go extinct do we reset a value in this case is just false we don't really have to talk about that too much but you can look that up in the documentation here I'll actually show you if you don't understand how something works if you go to reset on extinction if this evaluates are true when all species simultaneously become extinct due to stagnation a new random population will be created so that's what that does I guess I can't miss explain that but anyways all the stuffs in the documentation anyways the next thing so default genome alright so this is very important so in meat we call all of our you know population members so in this case Birds genomes and genomes have a few different properties to them they have what are called nodes and what are called genes now nodes are be like input nodes and the output nodes and genes are actually the connections between those nodes so this is setting up the default starting genome so the like each member in our population will start with these specific values so this is very important that we tweak this correctly so this is where we're setting the activation function so act in default is 10 H activation mutate rate means if you wanted to change the activation function to be something else randomly you could change this value to be like 0.1 would be there's a 10% chance that whenever we create a new population member they will get a different random activation function I don't want to do that so I'm gonna leave this as zero activation options are just the options that we can choose from as the activation functions so what this activation mutate rate will actually pick from now aggregation default I'm not gonna talk about what this stuff does you can look at that if you want now this is kind of the initial connections that we have and how likely they are to change now when we say bias max value and bias min value this means that for that bias that we have what is the maximum value that we can pick and what is the minimum value that we can pick because we're randomly gonna set up our first neural networks so they have random biases and random weights so let's just kind of define that you know we don't want a bias that's like 10 million so we're gonna squish it in between 30 and negative 30 now mutate power and mutate rate and replace rate is how likely these things are to change when we mutate and breed and create a new population of birds again just leave these like this you can mess with them if you want but these are the numbers that work best all right so genome compatibility options compatibility disjoint coefficient okay I'm not gonna talk about those because I don't honestly don't even really know what those are kind of just left them the default values from another example I stole this configuration file from alright so these ones are pretty straightforward connection add probability and connection delete probability is how likely we are to add a new connection or remove a new connection and again this is good at 50 percent right now so if you wanted to not have it add as likely or remove as likely you could decrease this number maybe put at 0.2 or something but these are the values we're gonna use all right an able default and enabled mutate rate so enable default essentially means that we can have connections that sometimes are enabled were not enabled now this is kind of a weird thing with a neural network where these connections have another parameter on them where they're either you know active or not active that's what this means by default we're gonna have all connections be active and to actually deactivate a connection there's about a 1% chance that's gonna happen that's what this means all right feedforward equals true that's straightforward we're using a feedforward neural network initial connection equals full means we're gonna have fully connected layers to start node add probability and node deletes probability 0.2 so same thing 20% chance of adding a new node or removing a new node again these will be neurons if we're talking in other terms number of hidden okay so this one is probably the most important this is actually setting the default input neurons our amount of input neurons and amount of output neurons so in this case we're gonna have three input neurons like we've talked about one output neuron and no hidden neurons to start we could you know change this to one and then we would start with a more complex network but in this case we're gonna start as simple as possible which is three input and one output all right I'm not gonna talk about what all this does you guys can look that in the documentation if you want same thing here again this is just kind of you know a few tweaks here on how the weights work this is kind of similar to the biases in terms of changing them and all of that I've just left these default from another example I took this file from compatibility threshold we don't need to know that species fitness function that's kind of similar thing to above where we're gonna take the max fitness from those species so max stagnation I believe is how many generations we go without increasing fitness so if we reach a point where we have you know 20 generations go by and our fitness doesn't increase at all like the max fitness for our group of birds doesn't increase then we're gonna eliminate that species and species again are just they're kind of like grouped based on their architecture so anyways that's what that does and then this here is we don't really need to discuss this survival threshold and alit they're not super important but again you guys can go in here and and read through them if you want to know what they actually do alright so with that being said this has been a bit of a longer video I haven't we haven't done any coding but I need to explain kind of how all this stuff works and what it is so when we go into the next video we're not super lost again this is difficult to explain there's a lot of stuff and I kinda need to be selective on what I'm teaching what I'm not teaching and some stuff you're just gonna have to learn on your own that's the way that it works but as we experiment and go through this in the next videos and actually writing the code which we'll do in the next two videos I guess you guys will should start to understand this and it should start to make sense but always feel free to you know mess with stuff if you don't understand something ask questions join the discord server and all of that that being said I'll see you guys in the next video