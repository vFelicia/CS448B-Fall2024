in this video i aim to give you a solid introduction to the key considerations and topics that you need to think about as you design or write a large software system now this will be a really good video for kind of intermediate programmers or people that are starting to work on larger projects and are considering what else they need to do other than just straight writing code as it turns out as you get into large code bases you get into large projects there's a lot of considerations and concerns that pop up and it's a lot easier to be thinking about them from the beginning than to have to worry about them after you've already ridden half of the code or you've designed something that maybe is suboptimal i'm not going to teach you how to design netflix i'm not going to teach you how to design google we're not going to get into anything technical it's just going to be these key considerations and concerns and kind of a good way to get your brain in the correct place as you start working on something a bit larger so with that said sit back relax and let me explain to you some of these key considerations and concerns related to largescale software systems now moving immediately to a small tangent here when i design a youtube video i need to think about the actual content itself how i want the youtube video to flow the different sections or chapters and also the monetization strategy now in this video the strategy is a sponsor which you're about to watch before we get started i need to thank filestack for sponsoring this video filestack lets you simplify your file handling by providing a simple file uploader and powerful apis to upload transform and deliver any file into your app with file stack you can accelerate innovation through reusable components and automate content workflow tasks into a single api call filestack can handle borders and effects document conversions object detection explicit content detection and much much more using file stacks easy to use ui allows you to create reusable workflows that require no coding knowledge and can be modified rapidly over a hundred thousand people are currently using file stack and you can join them today for free by clicking the link in the description thanks again to filestack for sponsoring this video now let's get into it so as i was saying when i design a youtube video i kind of break it into sections or chapters to keep it organized and the sections i'm going to share with you here are the following the first is actually breaking a system into subsystems which is kind of what i'm doing right now with this video the second is testing the third is deployment then i have documentation scaling and security now before you can even really consider any of these things i do feel like you need to have a fundamental understanding of programming and of kind of organizing code in general so this is at a larger level but you need to actually understand how you break code into modules into packages into functions how you keep your code clean and organized because if you can't do that none of this is really going to matter when it comes to writing a large scale system if you want to learn that i have a ton of free videos here on youtube i also have a course it's called programmingexpert.io you can use discount code tim from the link in the description but i wanted to mention that you should have a fundamental understanding here before starting to design any really large scale systems you should be confident in your programming abilities so moving in here to point number one i have breaking a system into sub systems now this is one of the more important points on this list and this is really going to dictate how much of a pain in the asset is to develop your project or your application or whatever it is that you're making it's very important that from the beginning of your software project life cycle that you actually determine what subsystems are going to make up the system as a whole now what i mean by this is rather than having say one massive code base that does everything right you want to break it into individual and kind of logical components which work together to solve a problem now this is very important because if you can break one system into say 20 30 maybe 40 subsystems now you can be confident that each individual system is working as it should be because it's much easier to test smaller pieces of code rather smaller systems so maybe you have an authentication system you have a messaging system you have an achievement system you have all of these different subsystems they're a lot easier to write because you're only writing one at a time a lot easier to maintain a lot easier to debug to test and to scale up or scale down depending on kind of what is required in your application essentially you're reducing complexity in a code base by splitting your system up into multiple subsystems and like i said that provides a lot of different advantages especially based on the different considerations i'm going to have coming up next so if we were to consider say a mobile game maybe you have your authentication system maybe you do have live messaging between players that would be its own separate system maybe you have the user interface as a whole that you could consider a system that interacts with all of the back end systems that you have maybe you have the achievement system maybe you have some system related to actually playing the different games if it's a mobile game or mobile app or something like that right you may have a system related to keeping score uh you may have you know all kinds of different subsystems it really depends on what you're doing but what i like to do when i start a project is determine kind of in a vague sense what these systems are that i'm going to have now i may add more i may remove some or combine them together but at least i'm considering how i'm going to break this apart to make it much easier for me to manage later on and if i needed to i could say outsource the development of one of these systems to someone else so hopefully that kind of puts your mind in the right place at the beginning of development how do i break this down how do i make this nice and simple and then from there when you have a subsystem you would then break that down into individual classes individual modules individual packages and go to the finest level of detail essentially you can to make it as easy as okay i need to do this function this function this class and this class once i build all of that i now have this subsystem then i build all of my subsystems and i have the entire application so moving on here to topic or consideration number two i have testing now testing is extremely important especially as you start to write a lot of code and move into a complex code base that has a lot of different systems and a lot of different stuff going on but it's also very important to consider how you're writing code based on the fact that you're going to have to test that code so i'll elaborate on that more later on when i say testing i'm talking about any type of testing manual testing integration testing unit testing uh testing a database testing backend functions there's a million different tests that you can write frontend test ui component tests you can test practically anything in your application so you need to consider right from the beginning okay what do i want to test how much of a focus or emphasis do i want to have on testing is it absolutely necessary that i test every single component or every single function in my application uh and am i going to be say mocking different components or mocking different modules in my testing do i want to have a live test that actually uses say a real database do i want to mock the database these are all things you want to think about and consider and the thing with testing is that yes it is very important but you also don't want to be slowed down a time by writing tests it does take a long time to write automated tests especially ones that are high quality and actually give you confidence that this test is meaningful but again they take a long time so do you want to do that for the entire application is it absolutely necessary those are things that you need to consider now moving into kind of the second stage of testing here it's important to be thinking about this stuff because as you're writing code you need to write code that is testable if you want to be testing a certain amount of code or certain features you have to write it in a very specific way because if you make it too complicated or too difficult to test in isolation you're not going to be able to test it or you're going to have to rewrite the code to be able to test it properly so that's really what this section is about and i'll just lastly say here that at the beginning of development it will seem like testing is slowing you down like it's taking a lot of time and that it's not really meaningful because you can easily manually test everything that you're doing however as you get into more and more features more and more subsystems being integrated into your software you realize the importance of testing because now rather than having to manually test everything you press a single button or you run a single command and all of a sudden you have confidence that you haven't broken something else in your application by writing new code and in the same light here if you were to add new people to your code base that maybe weren't as familiar with it as you they could have confidence that they're not breaking something or messing something up by running automated tests so moving on here to topic number three i have deployment now this is concerned with how you're actually going to be serving your application or software so you've ridden it in a development environment maybe you have it on localhost or you're testing it on an emulator or something along those lines now how are you going to take this code and deploy it so that users can actually access it is this going to be on mobile is it going to be on web are you going to have it automatically be deployed say every hour or every day or every time you make a change to the code base are you going to deploy it maybe in set intervals every week are you going to be pushing updates to users where they would have to download something to get new features in the application how are you communicating with your users are you going to do that through a deployment where you're actually modifying the code base or maybe you have some backend system that you can kind of play with or mess with that then serve something new to the front end of the application and gives a message to your users i'm just rattling off kind of random ideas here there's not a lot of content i have for this specific section but of course it's important to consider okay i've ridden this stuff in development how am i going to actually give this to my users how am i going to test that it's working properly how am i going to emulate my development environment in a deployment environment how am i going to scale this do i have multiple systems being deployed all at the same time maybe i'm only deploying my front end when i make a change in my back end stuff will stay the same i don't know i'm just trying to give you examples to think about here because deployment is very important and it's something a lot of people leave until the very last step and then they realize i need to change the way i'm doing this because it doesn't work with how i'm gonna deploy this code anyways that's what i have for that on to the next one so now moving on to consideration number four which is all of your favorites and this is documentation now clearly that's a joke everybody hates documentation they hate writing it they hate reading it they hate using it whatever they just don't like documentation and i don't blame them i am like you guys as well i really dislike writing documentation i'd much rather write code but it is something important that you have to do now a lot of code bases and i'll say this from personal experience they'll start off very simple very easy to understand maybe it's just you or two or three people working on this code and it seems like a waste of time to write documentation especially when you're just explaining something that you already know or that your teammates already know but it becomes more and more important as the code base gets larger because you may go a few months without viewing a certain portion of this code base or without viewing a feature that you worked a very long time on and now it's completely finished or alternatively maybe you're working for a startup like i'm doing right now and then the company grows and you bring on new developers and now you're tasked with writing documentation for two weeks to help onboard them into the code base so again something you want to consider do i need documentation for this section is this something i'm going to remember forever probably not should i write documentation on how to set the code base up in case maybe nontechnical people need to do that should i write it on specific features or systems you don't have to go overboard here so what i'm really talking about here is just being cognizant of the fact that this code is likely going to live for a long time assuming whatever you're doing is successful you're probably going to bring new people onto it and you yourself will likely forget some of the stuff that you knew really well as the code base matures and you're working on other features with that in mind you probably want to be writing documentation you don't need to kill yourself and go overboard with it but maybe dedicate you know half an hour a day or a few hours a week to documenting different features and making sure that anyone that comes to this code base will have a decent idea of what is going on and what they need to do to maybe get things set up and to add code for example to the code base so moving on to topic number five we have scaling now scaling is something that again a lot of people don't consider because many projects start off with only a few users or they're only being used for a hobby and a lot of people never really envision their software being used by hundreds of thousands of people or millions of people or people around the world in different time zones and geographic regions and languages and all of this type of stuff and it is something that even though you may not necessarily implement immediately you want to be thinking about when you're writing code because it can save you a lot of time and money down the line for example right now i am writing a lot of code using firebase now firebase is notoriously expensive and the way in which you do database reads and writes and say serverless function calls can drastically impact the cost of your hosting and project for example if i write an algorithm that's n squared time relative to maybe database reads and writes but i could have optimized that to be o n time where it's just linear time that's saving me drastic amounts of money right especially if i have tens of thousands of users that are all interacting with this algorithm or whatever's reading and writing from the database so you want to be very cognizant of that because it would suck to get to a point where okay now you have a bunch of users your apps taking off oh but it's costing you a hundred thousand dollars a month to host it because you didn't consider how expensive it was going to be for example to scale your application now that's one scenario you can also have other scenarios where you just are unable to scale the way you've written code you can't deploy it on multiple servers you can't actually scale it up or you're just having a lot of lag and a lot of delay based on how you've done things because you didn't consider the fact you were going to have a million entries in your database again all things you want to think about earlier rather than later i'm just trying to put those in your head alright so moving on here to topic number six which admittedly i probably should have put earlier but this is security now this becomes very important especially when you have a lot of separate systems in your application you need to find a way to almost synchronize your authorization or authentication between these different systems and ensure that users only have access to what is intended for them to have access to you need to be very careful with the way that you protect say your database for example with rate limiting with the authorization to read or view different documents or tables or rows or whatever it is that you're using and you need a way to easily authenticate your users as well are you going to be storing passwords on your server are you going to use something like oauth or google signin or facebook signin what is your authentication system and how are you going to verify that the users that are signed in are who they say they are very important to do another thing to consider related to security is stuff like rate limiting ddos what's going to happen if someone were to say mess with your software or your front end and hit an api a million times per second i know that's an exaggeration but you get what i mean are you going to stop them from doing that how are you handling those types of scenarios fortunately there's a lot of stuff that's built that does this for you but you need to just consider the security of your application as you're building it out and imagine that there may be and probably will be bad actors in your system that are trying to break the application that are trying to hack into someone's profile that are trying to manipulate say their score or their leaderboard ranking or something along those lines again you need to really think about that and consider that when you're building yeah all right so with that said guys i think i'm gonna start wrapping it up here if you did stick around until the end of the video thank you very much i'm gonna leave you with the image of my cat sleeping on my desk her name is sophie i actually have two cats and if you can remember guess the name of my other cat in the comment section down below if one of you gets it correct then i will pin your comment anyways i hope you guys enjoyed if you did make sure leave a like subscribe to the channel i will see you in another one