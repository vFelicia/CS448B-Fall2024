hello everybody and welcome to the third video in this blockchain for beginners tutorial series in this video i'm going to be giving you an introduction to solidity and showing you how to write and deploy your first smart contract this is really really cool i had a lot of fun messing with this before the video and i think you guys are going to be amazed at how simple it is to actually write a smart contract anyways i should mention that solidity is the programming language typically used for deploying smart contracts and writing ethereum smart contracts and so that's why we're going to be using it now in terms of kind of some prerequisites for this video i'm going to assume that you have some understanding of programming some experience writing and maybe a different programming language just because in this video i'm not going to explain the very basics like things like variables functions and all that stuff that's kind of common knowledge when it comes to programming of course i'll go through the solidity syntax and we're really going to learn by actually just doing a bunch of examples and not focusing a ton on theory last thing i will say is that you do need to have your meta mask set up if you want to deploy this to a test network so an ethereum test network if you don't have metamask setup that's fine you just won't be able to follow along with that step in the video alright so with that said we're just about ready to get started i just want to quickly thank cartesi again for sponsoring this video and this series they're an awesome company again dedicated to making the blockchain more accessible and easy to use they've really helped me a ton in terms of coming up with the content for these videos well i hope you guys appreciate that in the future videos in this series we're going to be talking about how we can actually use cartesi to fix some of the scalability issues with smart contracts because you're going to start to see some of the problems that can actually occur when we write a smart contract because they're a lot different than your traditional code anyways let's go ahead and get into the code all right so i'm here on my computer and the first thing i'm going to discuss is just setting up our environment for writing code and solidity and deploying smart contracts now of course you can write contracts in vs code or any local code editor but instead for this series i'm going to use an online ide called remix now this is a browserbased ide it's completely free and it's super beginner friendly and allows you to actually deploy and test your smart contracts directly from the browser so i'd recommend that you use this you can check it out from the link in the description or just google remix ide again completely free and once you click on that link it should bring you to a page that looks like this so for now what i'm going to do is just give a quick tour of remix then we'll talk about smart contracts what they actually are how they work then we'll start writing some code and going through some examples of smart contracts so the first thing we want to do here when we open up remix is we just want to install a few extensions specifically for solidity so you can write other stuff in remix not just solidity code so that's why we want these extensions so what we're going to do is just on the left hand side here go to this plugin manager it looks like a plug and what we're going to do is search for solidity now for me i already have these extensions installed but what you're going to want to install is the solidity compiler the solidity static analysis and then the solidity unit testing now you don't really need the unit testing but you might as well just install it while we're here so install those three plugins and once you have them installed we're pretty much ready to start writing solidity code now you're going to see in the lefthand side here let me zoom in a little bit that we have a bunch of you know i guess folders directories and inside of here we have some different smart contracts we have some scripts we have all this kind of stuff you don't need to worry about any of that this is all just kind of test code that's provided to you we're not going to use any of this we don't even need to look at it so you can kind of just ignore it for now what i'm actually going to do to get started is i'm just going to make a new file so i'm going to click on this little file icon right here and then i'm just going to call this test.soul so dot sol is the extension for solidity file so that's why we're going to use that when i do that it will open up a brand new file notice we have the little solidity icon now we can start actually writing a smart contract now one thing to notice here is there's stuff like github integrations you can create new directories you can upload files uh you can also have different workspaces so right now i'm in a workspace i created called tutorial but you also could make a new one by clicking this right here i guess this is renaming a workspace and then of course you can delete it i'll let you look at that yourself pretty straightforward anyways all we need to do is get to kind of a file that looks like this just an empty solidity file so i'm just going to zoom in by clicking this plus icon here so you guys can actually read the code all right so now that we're here we might as well write a very basic smart contract i'll briefly show you how it works and how we can run it then i'll actually discuss smart contracts in detail so how they work how you call them and how they're different from traditional code because they are much much different than anything you would have seen before okay so what i'm going to do is zoom in a bit and let's start by writing what's known as our pragma line now the pragma line is required at the beginning of all of your silly files and what this does is actually tell solidity what compiler version this file needs to use so there's a ton of different compilers that are accessible for solidity you just need to define the minimum compiler version so i'm going to say pragma solidity and i'm going to say 0 0.8.10 and then put a semicolon like that so for all of your lines you're going to have semicolons at the end very similar to something like java okay so we have our pragma line again just pragma solidity and then the minimum compiler version if you want to see the compiler versions you can go to i believe it's this tab right here and it will show you all the compiler versions so notice we're on 0.8.10 so i'm just using one of the latest versions that we have okay and then for language of course that'd be solidity and you're just going to have compiler default now here you can actually manually compile your solidity code i'll talk about that in a few minutes for now though let's continue writing the rest of our contract so after we do our pragma line the next thing we need to do is define a contract so i'm going to say contract and then i'm going to give this a name now i can give this whatever name i want i'm just going to call it my contract so what i've just done is created a smart contract okay that's all you need to do you write the word contract give some name the casing you're supposed to use for this name is pascal case which means you're supposed to have capital letters for every single word and then inside of here we can start defining some variables some functions and methods sorry not not functions methods what i mean anyways for now i'm just going to define a very basic variable then i'm going to show you how we actually deploy and test this smart contract and then we'll continue with some theory and looking at this more in depth so for now what i'm going to say is uint this stands for unsigned integer and i'm just going to say that this is public like this i'm going to call this x and i'm just going to make this equal to 21. okay super straightforward this is just me defining a variable the type of the variable is an unsigned integer it is public meaning anyone can view it into name is x and its value is 21. so now that we have this contract what we need to do is compile the contract and then deploy so all of our contracts in solidity need to be compiled into bytecode this bytecode is then sent to the ethereum network where the contract is deployed and then we can call the contract so let's just look at a quick example of doing this so we can manually compile by pressing compile we actually don't need to manually do this when we deploy it will automatically compile for us anyways i've compiled the contract right here notice i have my compiler version solidity compiler default then what i'm going to do is go to this tab right here so just below it let's see what this one's called deploy and run transactions and here what we can do is choose a few different options for actually deploying our contract so if you go here notice we have a bunch of options we have web3 provider injected web 3 javascript vm and then we have the berlin version of the javascript vm now the javascript vm is what i'm going to use for right now but what this is is a virtual machine that simulates the ethereum network in your browser so this means you don't actually have to make any real transactions you're not actually adding this to a legitimate blockchain you're just simulating it so you can test this directly in your browser now if you refresh your browser what's going to happen is anything that you've been simulating in the javascript vm is going to disappear because what was being stored and i guess the cache or whatever inside of your browser point is javascript vm is kind of a testing environment and when you're actually going to deploy this smart contract for other people to use you need to deploy it to what's known as a web3 provider or an injected web 3. now injected web 3 is actually going to use whatever network your meta mask is on so if i do this what's going to happen is when i try to deploy this contract it's going to open up metamask and it's going to require that i actually do a transaction to deploy this contract again we're going to look at that in a second for now i just want to quickly show you deploying it and running it and then we'll get into the theory so i'm going to go to javascript vm and notice here that when i do this it's going to give me a bunch of different accounts that have 100 ethereum again this is just testing and the point of these different accounts is that i can actually use all of them with my smart contract because every time i deploy the smart contract i want to call a function on the smart contract i need to make a transaction to do that and that requires an account to make the transaction with so for now i'll just select this first account i could copy the address here if i wanted to do that the gas limit just leave this the same for now and then you could pick an amount of ethereum that you actually want to send with this transaction now i don't want to do that for now i don't want to send any ethereum all i want to do is deploy my smart contract so i'm just going to click on deploy and then you're going to see down here it's going to show you my deployed contracts so i now have a contract notice it's showing this little button x and if i click on this it gives me the value of x okay very very simple that's all you need to do to deploy a smart contract we'll talk about this more in a second what i want to do now is hop over to my drawing tablet and start talking about some of the theory behind smart contracts and how they actually work and why we kind of needed to go through this alright so i'm here on the drawing tablet and i want to start by discussing how we deploy a smart contract then i want to talk about their use cases and go through a few properties of them so as we saw we had a smart contract and we stored this inside of a dot sol file now this is our solidity file and this is what we refer to as our source code now the source code is simply the code that we write as a programmer it's the closest to english it's the easiest for us to understand it is the source code okay this is where we actually write solidity code however this code cannot be executed on the ethereum network so what we need to do is compile this by running it through a compiler into something called bytecode so the first step when we're deploying this contract is we run this through a compiler this compiler is capable of taking one language and translating it into another and what we get here is now what i'm going to refer to as the bytecode now the bytecode is just a special type of code that the computer can actually understand and execute in almost every programming language what's occurring is you're taking source code you're compiling it into bytecode and then that bytecode is being interpreted by an interpreter the interpreter you can kind of think of as a mini computer in a sense that's actually going to be able to take all of this code read it understand it and then tell the cpu of your computer how to execute it the interpreter is typically known as a virtual machine anyways you don't need to know too much about that point being you take source code compile it into something like bytecode bytecode is then something that the computer can actually understand and execute and so that's how your code actually ends up running anyways at this point we now have our bytecodes we've taken our solidity code we've ran it through the compiler by the way remix will do this for us automatically so you don't need to manually compile the code and now we have our bytecode so let me just move my bytecode over here so now that we have this bytecode this is the code the ethereum network can understand and the computers can execute but how do i actually get this now to the blockchain well what i need to do is i need to create a transaction now i just want to quickly mention here that what a smart contract is is just code that's sitting on the blockchain so all we're doing is we're taking this bytecode we're putting this in a transaction and then this transaction is kind of special in the sense that it requests to create this code this smart contract on the ethereum network so what happens is we make a transaction we throw the byte code on this transaction we pay some fees and then we kind of upload this or send this in a way to the ethereum network okay so just like sending money between different accounts except in this case we're making a transaction that is adding this byte code as a smart contract to the ethereum network now like all other transactions the first thing that needs to happen here is this transaction needs to be associated with a block then it needs to be mined once it's mined then it's on the ethereum network now what that means is just like any other transaction anyone can go and see this they can see the transaction they can see who created the smart contract they can see all of the code of the smart contract they're able to view when you created it the balance of the smart contract all of these other things and this also means that once we add this smart contract to the network we can never change we cannot mutate it we cannot modify it we cannot change it or delete it and the reason for that is the same reason that we can't delete transactions on the ethereum network right because that's the way the blockchain works it is forever there it is a ledger of everything that has happened is completely transparent and trustworthy and that's actually the main point of our smart contracts so hopefully that makes a bit of sense we're going to continue to clarify this in this section point being is that the reason we create smart contracts is because we're taking advantage of the security features of the blockchain to make people trust the code that we are uploading so let's take an example where we want to write some type of poker application or a casino or something that involves money right something that's going to have money being transacted from either us to the client or from the client to us well if someone comes to our website or we go to some casino website for example most times we can't see the code right we have no idea what's actually happening in the back end we could easily be getting ripped off maybe our money's being stolen maybe the odds are not in our favor or less in our favor than they should be whatever if we can't see the code we don't really have any way to trust what this website is doing or how these transactions are occurring however if you had your code as a smart contract and you knew that the website was using the smart contract maybe you're able to verify that in some way then you could just go and read the smart contracts that were being used and decide if you want to interact with them or not this means you can fully and transparently see all of the code that's actually being ran and executed you know if you want to trust it or not and then you can decide if you want to interact with it right so hopefully that makes sense one important point there as well is that that code that you're looking at can never be changed which means if you're interacting with the same smart contract you know it's always going to look like that and it's always going to be trustworthy so that's kind of the main point of smart contracts is to allow people to trust the code to make it fully visible to everyone and also just to allow everyone to be able to use it right although i will say it is pretty expensive to be interacting with smart contracts and uploading them to ethereum okay that is the main point of smart contracts now one thing i'll mention as well is that smart contracts can have a balance so that means you can send money to a smart contract it can receive money it can send money back to you it can call other smart contracts and in fact we're going to start talking about that now so let me clear the screen and now we're going to talk about how you actually call a smart contract so in front of me i have a beautiful illustration i have a contract and two ethereum accounts now as i said briefly a contract can have a balance so just like an account a contract is going to have an address it's going to have some type of balance so we can actually store ethereum and it can send and receive ethereum as well so that means that the account too can send money directly to the contract the contract could send money back to it and again account one in account two i'm just treating as regular ethereum accounts so ones we already would have talked about anyways the contract has a balance and that means we can go and view the balance we can see every single call and transaction that's happened with the contract everything is completely transparent just like our other regular ethereum accounts great okay so now that we understand that i want to talk about the fact that a contract should really be treated like a state machine so what i mean by that is that most contracts are going to store some type of data so in this case we have x equals one now we need to think of this like the state of the contract and the reason for that is that these contracts are not constantly running they're not just always executing in the background they need to manually be triggered from a transaction to actually do something and so when they're not being called by a transaction they're simply some state that's sitting on the ethereum blockchain okay that's all they are we just have the code we have the values of the different variables so the state of the contract and we can access the state or request to change the state by making some type of transaction okay so let's see now how we actually call a smart contract because i keep saying this for it to do anything we need to call it so calling a smart contract is really just making a transaction that requests some operation be performed on the contract okay so from account two maybe we make a transaction so in fact let's just write tx here representing transaction and this transaction is going to the smart contract now usually what we do is we pick some type of method or some operation we're going to be performing on the contract so maybe we call some method here like set x and we pass value 2. now the smart contract can do whatever it wants in this method but maybe all it does is just change the state to 2 then what we would do is we would simply change this so now x is equal to 2. perfect now when we make this transaction just like any other transactions we need to sign it we need to secure it we're going to have a two address and a from address we're also going to have to pay a transaction fee which is going to be made up of gas now you can think of gas kind of like a literal gas in the real world in the sense that this contract requires gas to actually be able to execute code so every single operation this is going to perform is going to use a tiny bit of gas or it's going to use a little bit of gas and so we send what's known as a gas limit so the maximum amount of gas that we potentially want to use in executing this contract and then if that's enough gas the contract will actually be able to execute it will run through all of the code whatever it will have enough gas to do that it costs us ethereum essentially to execute code on the ethereum blockchain okay now the amount of gas you send and is required is going to depend on what the contract is doing some operations require a lot more gas than others anyways that's pretty complicated we don't need to talk about that for now but just understand that what happens is we're passing along gas and the gas allows the contract to actually execute if it runs out of gas just like a car it's not able to do anything else okay so that's it for calling contracts but now let's quickly talk about contracts calling other contracts because that is possible so let's say i have another contract right here and maybe this contract needs to interact with this one maybe it's going to call something on it's going to send ethereum whatever it's going to do so first of all that's fine these contracts can interact with each other they can only do that if this interaction starts from stems from is at the root of some account sending a transaction so these contracts if they have no transaction so imagine this guy's gone right here they can't do anything they cannot execute they cannot call each other they can't do anything at all they're just sitting there idle they are state machines however as soon as i have some transaction from any regular ethereum account that goes to a contract now this contract is capable of performing some operations executing some code whatever and calling other contracts it needs to start though from one of these main transactions there's no way for this contract to call the other contract unless we start from a transaction that i've showed you right here so all of this needs to kind of root from some transaction outside of the blockchain so what i mean by that is from some kind of regular ethereum account so hopefully that makes sense but again you can really think about this in the sense that these contracts are idle not doing anything unless they're called from outside of the main blockchain network right so from kind of a regular account and so if no account is calling any of these contracts they're not able to do anything and we also need gas which is going to be passed along with the transaction to the first contract call that we make all right so with that said i think that ends the theory section of this video i apologize if this was long but this really did need to be covered now we're going to get back to the code and i'm going to start showing you how to write more advanced smart contracts all right so i am back on the computer and now what i'm going to show you how to do is how to deploy the smart contract to a real ethereum network so we'll go with the test network right rather than the javascript vm which is going to emulate the blockchain in your browser so what i'm going to do here is change this to injectedweb3 now when you do that it's going to connect with metamask which i assume you already have set up and it's going to show you the test network that you have i guess enabled in metamask and the account that you're using for metamask so in this case i have my tutorial account that has a little bit less than one ether anyways in the same way that we deployed this when we were using the javascript vm we could just click deploy it will automatically compile this for us we don't need to manually compile and it's going to actually bring up metamask because we need to make a transaction to do this right we need to create the contract that requires a transaction so we can look at data this is going to have the contract data we're going to have our details that's going to tell us how much it costs now the bigger the contract is the more this would cost anyways this is relatively cheap i will click confirm okay now this is going to take a second and if i bring up this kind of you know terminal here console you're going to see it tells me that it successfully deployed the contract okay so you can view kind of i guess the output of all the transactions and contract calls by just bringing this terminal up right here anyways what we're going to see now is it shows my deployed contracts so this is my deployed contract now what i want to do is actually look at this contract so let's see how we can do that so what i'm going to do is go to metamask here i am going to go to the contract deployment which is right here okay and then you'll see that i can actually click on this button and it will allow me to view the transaction on etherscan now i had some other transactions there i was of course messing with this before the video so you can ignore those ones this is the one that we just crit anyways now we are in ether scan the goreli test network etherscan right and we can see we had our transaction it was successful and we have the from and the two now what i want to look at is the actual contract address so i'm going to click on that right there now it's going to bring me to the contract address on etherscan so i can see the balance i can see the content creator so this was me right i created this contract at this transaction and then it tells you that the content or the contract story was crit now we can look at the contract itself so we can actually view the byte code we can decompile that into the source code if we want and then we have events i'm not going to talk about that right now that will be in the next video anyways we can close that i just wanted to oops uh let's go back i just wanted to show you what that looks like uh okay so let's go back to remix all right so now that we have this deployed we can use the contract right so i can access the variable x that's fine it's going to give me the value 21. so one thing to note here is that when you're viewing the state of a contract so we're just looking at the value of x here right viewing the state this is free we don't need to do a transaction it's fine we can query the state that's a free operation and the reason for that is the state is available right like we can go look at the state of the contract because it's stored in there publicly available it's already on the blockchain so we don't need to do any computation we're just querying and viewing a state so that's completely free to do so that's why when i click x here i get this instantly and it gives me 21 because i don't need to actually have a transaction mined to view the state the only transactions i need are when i'm modifying the state of this contract okay or performing some type of computation anyways what i want to do now is change the contract so we can actually update the value of x so this is where we'll talk about functions methods so what i can do is inside of this contract i can create a function this will be a kind of a method associated with the contract obviously i need to give this a name so i'll give it something like set x now for the parameters of this function i need to define first their type and then the name of the parameter so i'm going to say uint underscore x like that this will kind of be my new x value that i want to set x to then i need to give my access modifier for this function now the access modifiers essentially tell people trying to use the contract if this function is private if it is public if it's internal external i'll talk about what all of those mean but you need one of these here so i'm going to say public to define the fact that anyone can use this method so a contract any anyone calling this from a transaction is able to use this method because it's public same with this variable x now if we made x private for example you wouldn't be able to access the state of it at least not very easily because it would be private to the contract again we'll talk about access modifiers in a second for now though we'll just say function set x uint underscore x will make this public then i'm just going to say x is equal to underscore x okay so now when i call this function we will change x change the value and then when we access it again it will be different pretty straightforward okay so now that we've changed the contract we need to redeploy this i'll do this again to the goreli test network so i'll just click on deploy okay we're going to have to confirm the transaction and notice this time it's a bit more expensive we have more content in our contract and so it makes sense this is going to be more expensive right so i'm going to click confirm okay it's going to take a second and then once it's created we should be able to use it and i'll show you what happens when we actually modify x okay so the contract has been created i'm going to click right here and now we'll have a new contract so we'll look at that one in a second but for now what i can do is set x so if i look at x right now it's 21 that was free right i didn't have to pay for that i'm just viewing the state but now if i change the state to say 25 so let's set x notice i need a transaction okay so it's giving me a transaction and this is going to cost me a certain amount of gas right so i will click confirm now this is going to take a minute i need to wait for the transaction to be mined okay it was done pretty quickly now if i click x again its new value is 25. so i've modified the state of this contract okay hopefully that makes sense that kind of wraps up all the explanation in terms of how you call a contract what the state of the contract is all of that stuff now we're going to continue looking at some more solidity syntax all right so i've just cleared my code and changed the environment back to javascript vm now i'm going to talk to you about a few data types in solidity so the first one is uiint now we've already looked at this it stands for unsigned integer meaning we can store any positive whole number okay so i can do something like uint public x is equal to one of course we know that is valid now with the u int this actually allows us to specify the number of bytes we want to use to store the integer so i could do something like you went eight you went 16. you win 32 you and 64. unit 128 and then 256 and i believe 256 is actually the default so if you just write you int i think by default uses 256. i'll put something on the screen that confirms that or not now let's actually just see what happens if we try to store a negative number inside of a uint okay so let me just deploy this contract here we have our smart contract and notice that it's actually not even deploying this right because we would have seen the variable y because we have an error so it's deploying the last contract so the last one that we actually had compiled not this one because we have the error and it's showing that right here okay we cannot implicitly convert negative 1 to an unsigned integer now of course though we have regular integer right so a regular int allows us to store a signed number again just like the uint we can specify the number of bytes so 16 32 64 whatever now let's run to this one so deploy and let's see what we get here and now we have y so it actually deployed this contract and we can look at its value perfect okay so that is it now other than int we have a boolean okay so we can say something like boolean public y is equal to true let's deploy this now oops i want to close that let's look at this contract here click on y and notice we get true now of course other than true we have false i assume most of you know what the boolean data type is just note here there is a lowercase on the first letter rather than a capital if you're coming from python like me okay so we had int uint bool now we also have address address payable and mapping and a ton of other data types as well now i'm only going through these ones because these are kind of the core most important ones we're going to use right now there is strings there is arrays but those work really strangely in solidity compared to other languages so just be careful there if you're looking at say a string or an array there's a lot of nuances and kind of details with those okay for now though let's actually not to a string so let's actually just look at the mapping type so the mapping type allows us to take some key and associate it with some value so i'm going to say public and then we'll just call this map okay now what this means is that i can have some data type for the key and some data type for the value it's very similar to a dictionary or a hash table so when i define a mapping i need to pick the value for the key or the type sorry for the key and the type for the value so for right now i'm just going to say uiint like that is associated with it now just to show you how this works what i can do if i want to set a new mapping is i can say map and then i can put my key like this is equal to my value so if this was a real example i could do something like maybe the map of 1 is associated with the key of negative 2. now that means if i accessed map at 1 it would give me negative 2 okay so this allows you to associate some key with some value very useful you're going to use this all the time anyways that is a mapping again you put the type of the key and then you do it this little equal and i guess greater than sign or less than sign associated with whatever the value data type is so right now what i'm going to do is just make a function that lets us actually add a new key value pair to this mapping so i'm going to say function we'll say set key like that we're going to take in a uint key and we'll take in an int value okay and then we're going to say that this is public and inside of here we'll just say the map at key is equal to value okay now since this function is actually going to be changing the state of this contract that means we will require a transaction to use this excuse me but since we're in the javascript vm we don't need to do that because we're not actually on the blockchain anyways let me quickly go through the syntax so function keyword this lets us make a method or a function inside of the contract or inside of the class whatever you want to call it we then have set key this is the name of that function we have our parameters key and value and we're defining the type that is required for those we then say this is public meaning anyone can call it and we say map key equals value adding a new key value pair to our mapping okay let's deploy this okay so here's our contract let me open this up so we have set key and map now one thing to note is that automatically when you define a variable like this outside of a function so just in the body of the contract it's going to have a getter added for it automatically which means i can access any value in the map so i could do something like map 1 and we're going to see its default value is 0. so in solidity all of our data types have a default value so even though we didn't assign this to something we just declared that it exists if i try to access any key since the value type is int it's always going to give me 0 unless we have a different value for that okay so let's just set a key let's set like five with actually let me do this let's set five with like negative 23 i'll click on transact and now to test this i'll see if the key 5 is associated with negative 23 and it is so we're all good to go now let's do another one let's do like 4 with negative 10 okay transact let's go four and then notice we have negative 10. perfect there we go okay so now that we have done that what i want to do is talk about addresses and how we actually accept money in the contract as well as pay money out so let's get rid of all this for right now and let's start making some functions that can receive money and send money so what i'm going to do is write function we're going to call this receive and this is going to be an external like this payable function now let's talk about external because we haven't yet seen this so just like the public keyword that we had what external does is it makes it so that this can only be used from outside of the contract so i cannot call this function from within the contract if i did that that would give me an error and the reason for that is because we're going to be accepting some ethereum and when you define this as payable which is what i've done right here this means that we can actually pay money to this function when we call it okay hopefully that makes a little bit of sense we're saying function receive external payable meaning okay we can accept money and we can only accept money from outside of the contract so we can't call this from within the contract whenever you're accepting money you need to put payable when i say money i'm really talking about ethereum anyways inside of here we actually don't need to do anything we can just write the body of this function in fact that's completely fine and now what i'm going to show you is that what we can do is send money to this contract by calling this receive method because it's external pip so what i'm going to do is deploy this okay when i deploy it i'm going to have my contract down here and we have this receive function so when we click this red button here what's actually going to happen is we're going to send this amount of whatever this unit is so in this case it's way from this account to our contract okay so this function doesn't need any body if it's external payable that just means we can pay money to it and so what i'm going to do here is set this to like i don't know we'll go with 10 000 way now whey is the smallest amount of ethereum that you can send i believe 10 to the 18 way makes one ether so this is a very small amount anyways it's going to take it from this account in fact let's just send it from another account so that we can see if it actually worked let me make it a bit larger and when i click the button again it's going to send that amount from this account to the contract so let's do that and now notice this amount has gone down i have sent some way right there you go makes sense now there was also some gas associated with that that's why it's not perfectly even and the gas limit was right here okay awesome so we said function receive external payable now this contract technically has a certain balance it would be 10 000 way all right so now that we've looked at that i'm going to show you how we can actually view the balance of this contract from a function so i'm going to say function and then this is going to be get balance okay let's spell balance correctly and then we don't actually need anything inside of parentheses and what i can do is make this a public view that returns like this a uint and sorry not unit it's going to be a uiint and then we can actually write the body of our function now let me just talk about this view keyword because we haven't seen this yet view is saying that this is a readonly method or a readonly function which means it cannot modify the state of our contract so you need to add that when you're writing a function that's going to return a value that's not modifying the state okay that's what we're doing so public view returns you it now inside of here what i'm going to do is i'm going to simply return the address of this dot balance now let me talk about this for a second so return i mean pretty straightforward we're returning a value from the function now what address is doing is actually casting this which is referring to the contract itself to an address so this is the address type right we can use this to actually cast this the contract to the address and then on the address type we have balance balance is how much ether is in this account or in this case in this contract now previously you could just write this stop balance however in the new version of solidity what you need to do is manually cast this to an address so again this is giving us the address of the smart contract we're then getting the balance and then returning it awesome so let's deploy the contract and see if this works now so i'm going to go here i'm going to send some money to this contract first actually i'll go get balance when i run get balance notice that we have zero right there's a zero balance and let's now send some money so let's go from this account here and let's just send one ether okay so if i send one like that let's click receive click on get balance and then notice it's going to give me the balance in way okay if i wanted to convert that to ether i would need to divide it by 10 to the 18 what do you call it whey or i guess i could just divide it by one ether anyways not super important point is that there you go that is how you get the balance okay so now that we've looked at that i want to talk to you about a few global keywords that we have access to in solidity from our smart contract so remember whenever the smart contract is running it's been initiated whatever it would have had to been called from a transaction so someone had to send the transaction they had to call a specific function or method and then maybe they sent some ether along with that so we actually have a way to access that information like who sent the transaction so what i'm going to do here is write a smart contract that keeps track of the last person to send it ether so i'm going to make a variable up here i'm going to say this is an address now again the address is just storing an ethereum account address right or the address for an ethereum account so that's the data type there we have access to things like dot balance on an address so i'm going to say address this is going to be public i'm going to say this is last sender so let's go last sender like that and for now we'll just make this equal to nothing okay so it'll have a default value i believe the default address is just a bunch of zeros okay then inside of receive i actually want to set this to be equal to wherever the last sender was so i'm going to say last sender is equal to and then this is where we talk about the global keyword message.sender so message is something that you can use to access all of the information about the transaction that was used to call this contract now other than message.sender we also have access to message.value now this is going to be the amount of ethereum that was sent with the transaction and we have access to message.gas as well so the amount of gas i believe that's remaining with this transaction okay so let's go and change this back to message.sender and now we can actually use this smart contract and see if it keeps track of who sent the ethereum so i'm going to deploy this okay so we should be deployed let's change to one of these fresh accounts and let's actually send one ether in the receiver okay so i'm going to send that one ethereum let's check the balance okay now the balance oh sorry this is wrong contract i want to use this contract okay let's send one ether okay so go receive now let's check the balance okay so we have one ether in here and now if i go last sender it gives me the address of the account that actually send this ethereum so now let's change this to be let's go with this account let's set in two ether okay get the balance we now have three ethereum inside of here and the last sender has now changed okay there you go that is how you keep track of the actual last sender of a theorem now what i would like to do is i want to show you how to send ethereum from the contract back to a different ethereum account okay because right now what's happening is we're sending ethereum to the contract but the contract's not sending anything back obviously that's not ideal we need a way to you know pay people back from the contract so let's do that so what i'm going to do is write a function i'm going to say function this is going to be pay this is going to be address payable adr and then this is going to be public like this and then payable now let's just quickly go through this so the reason i have the payable here is because whenever i want an address or whenever i want to be able to send ethereum to an address i need to specify it as payable so address payable is different than just regular address this actually allows me now to send the money to this account if i don't have payable then i won't have access to the methods i need for this address to send the money to so just make sure you put payable then we're going to have public payable now since this function is going to be paying money out it's payable if you're going to be sending money or receiving money you need payable and then of course this is public which we've already talked about so inside of here there's a few different ways that i can actually send ethereum now some are simpler than others unfortunately though there's a bunch that have kind of some issues with them and that are not recommended to use so the ones you should not use are the following adr dot transfer okay now i know i spelt that incorrectly but you should not be using transfer okay there's some problems with that i'm not really going to get into them and then we have dot send again there's some problems with this don't use this instead what you need to use is the most complicated one funny enough which is going to be something like this so let me just type it out then i'll explain it this is going to be bytes memory and then this is going to be data and this is going to equal to adr dot call and then we're going to say here that the value is equal to and whatever the amount of ethereum is we want to send and then we're going to call this with one argument okay i believe this is correct let me move this over a bit so we have some more room okay so function pay address payable adr public payable and then we have this kind of crazy line right here so first of all what this is going to do is it's going to decompose the return value of this into two variables first sent and then second bytes memory data now this first one right here is going to be a boolean variable telling us if this was successful so if it was successful this is going to be true otherwise it's going to be false there's a variety of reasons it could be unsuccessful one of them being you don't have enough money in the contract to send okay then we have bytes memory data now this is going to give us the data of this transaction now you don't really need to worry about this too much in fact i'm not really going to explain it but memory is specifying that we want to store this data which is a reference type in memory again i'm not really going to talk about this much more just write this for now we'll worry about this in a later video then what is this doing so what we're doing is we're saying address dot call okay and then inside of curly braces here we're passing the value which is the amount of ethereum we want to send now optionally we can actually choose the amount of gas that we want to send as well so forward with this transaction you don't need to do that you can just leave it to the default value which is what i'm going to do and then we call this whole thing with a string now this is going to be the message that's going to be sent to our uh what do you call it to our transaction or with our transaction so you don't really need to put anything here for right now it just requires one mandatory argument so that's why i put an empty string okay hopefully this makes a bit of sense again address dot call curly braces with the amount of ethereum that you want to send and then this is setting up the transaction and this is actually going to execute it when you do the kind of parentheses call right here with the string argument anyways what we can do after this is we can check if this was successful or not and the way we do that is we could use an if statement so if do exist in solidity or i could do something like if sent or i can use this fancy thing that we haven't seen yet called require now what require does is similar to an assert statement because it's going to check the value of a condition or a variable and if that's true we're going to continue everything will be fine if that's false it's going to throw an exception and actually tell whoever called this smart contract that there was an issue with that call so i'm going to say require sent and then here i can put an error message so i'll just say error sending money okay like that or error sending let's just go with f okay so again if this is true all is good we will continue if this is false then it's going to tell us that there was an error because we were unsuccessful in sending this ethereum all right now let's add our semicolon and what i can do is deploy this and test it out okay so let's go back here and let's deploy this let me close this contract okay so we have our deployed contract we have pay receive get balance and last sender so let us receive some money first so let's send one ether from this account so let's go receive okay last sender is this get balance is one now let's copy this guy's address right here by clicking on copy let's paste it in here let's click on pay and i think everything should be good we can go back here now and we can see uh if we were paid the ethereum or not all right so i thought something was going wrong until i realized that we actually are only sending a hundred way here rather than an entire ethereum which is what i thought we were going to be sending so what i'm going to do is change this to one ether now ether is actually a builtin word or builtin keyword in solidity and we'll just multiply this by 10 to the 18 so that will give me i guess 10 to the 18 way right so one ether anyways i'm gonna change that to one ether so now this will pay one ether from this function okay so let me redeploy here and let's close this okay and now we have our contract so let's receive some money so let's go from this account let's just send like five ether okay so let's go receive what's the balance five ether now let's copy one of these okay and we'll pay it and let's see if this is all good i'll move up the console and looks like it's sent fine okay so now let's go here and we should see that in one of these accounts we have okay almost 101 ether right so i have 100.99999 because there was gas associated with the transaction so we didn't get a full one ether we got a little bit less perfect there you go that is how you send money using i guess this right here using this line okay great so now that we have that what i want to do is i want to end by quickly writing kind of an example of a bank that allows people to send ethereum to the smart contract and then withdraw up to the amount of money that they had sent to the contract so if i send one ether i can withdraw up to one ether from the contract as soon as i try to withdraw more it's gonna tell me hey you don't have a sufficient balance so kind of just like a very simple bank account so let's go ahead and do that all right so let's get into this example of implementing kind of the basic bank accounts so i'm actually just going to get rid of all this we can just rewrite it this will be good practice so i'm going to start by making a mapping and this mapping is going to allow me to associate an amount of ethereum with an address so that way i'll know how much a specific account has sent so far and so i can regulate how much they can withdraw so what i'm going to do here is say mapping and this is going to go address like that and then this will go to an unsigned integer which will be the amount of way that they have sent so amount of ethereum okay then i will call this balances and i can actually manually make this private if i want now when i make this private what that means is there won't be a default getter for this so i can't easily just access the balance of a specific account instead i'll have to use one of the methods or functions that we define okay now we need some way to receive money so let's write that we're going to say function and we'll say deposit okay and then this is going to be a actually external and then payable okay now what i'm going to do is i'm going to say balances at and then this will be message.sender which is going to be the address of the sender of the transaction is equal to or sorry plus equal to message.value okay so remember all of the keys here are going to have a default value of 0. so even if this address doesn't kind of exist yet in the balances it's going to have a value of 0 when i access it so i'm going to add message.value which is the amount of ethereum they deposit okay then of course if this already existed i would just be adding to it whatever the amount of ethereum is they deposited in this transaction that's all i need for here i'm just adding this to the balances then what i'm going to do is say function withdraw and this is going to need to take in an address to withdraw to and in fact i don't necessarily need to do that because what i could do is just use the message.sender address so whoever was withdrawn whoever sent the transaction i just automatically give the money to them but instead what i'll do here is just put in an actual parameter so that you could technically withdraw your money to someone else's account hopefully that makes sense but you'll see what i mean so i'm going to say address payable and then this will be adr and then we'll say this is going to be a public and then this will be a payable function like that okay so what i need to do here is i need to check that they have a sufficient balance in the uh the balances before they can withdraw something i also need to take in the amount that they're going to withdraw so i'm going to say uint amount like that and this will be the amount in way that they want to take okay so we'll say withdraw payable amount okay great that's fine now inside of here what i'm going to do is i'm going to confirm that they have a sufficient balance before i let them withdraw so i'm going to say require and i'm going to say balances at addr is greater than or equal to the amount that they want to take out okay perfect so we'll do that then i'm actually going to send the ethereum to them that they want to withdraw so we're going to say i guess this is going to be bool sent and then this will be byte memory and then what was this data is equal to and then addr dot call and then this is going to be value colon amount okay and then i think i can just call this like that okay so that's good now that i have that i'm going to confirm that they sent it successfully so i'm going to say require sent and we'll say could not withdraw okay we got to spell this properly this is just okay there we go could not withdraw and then what i'm going to do here after i successfully check if they withdrew or not or after i check that they successfully withdrew i'm going to subtract their balance so i'm going to say balances and then this is going to be at message.sender minus equals the amount okay i think that should be good now let's just run through this and make sure we understand so first we're requiring that their balance is greater than the amount so if the balance that they currently have in our kind of bank here is not greater than the amount then we actually need to give them an error message and we'll say in sufficient funds like that okay i think that's how you spell insufficient that should be fine all right and then what we're doing is we're trying to actually send this amount to them so if they have a sufficient balance we'll try to send it to them if this for some reason does not work then we'll tell them they could not withdraw and we'll keep the balance here right because if we didn't send it then the balance is not gone we still have the money in the contract otherwise we will subtract their balance and then we're good to go okay so now we have deposit and withdraw and if we want to we can write one more function here let's go function get balance and this will just give us the balance of a contract okay so let's just go public view returns uint okay and then let's return the address of this dot balance and that should be good okay now we could also write something that allows us to get the the balance of a specific address or we could just make this public but for now i'm going to leave it private okay hopefully that is all good now what i'm going to do is just deploy this contract so let's deploy it let me get rid of this one now what we can do is deposit some money so let's go to this account let's deposit 10 ether okay so we're going to deposit that should have happened successfully let's check the balance looks like we have 10 ether now let's see if we can withdraw so let me copy this address okay so i'm going to paste that in there in fact let's make this larger and for the amount i wish i could copy this uh let's just go with a bunch of zeros here i don't think i can write f directly in here otherwise that would be useful okay so let's click on transact and let's look at our console here and see if this was good okay it looks like we successfully sent the way so now if we go we see we have 85 ether rather than 84 which is what we had before so let me see if i can make this something like 5 now and click transact okay looks like that was successful i guess we're not passing enough zeros okay now we have 85.59 okay now let me try to send an entire five ethereum which we know we don't have for this person actually maybe we do because i think we transacted 10 of theorem sorry but let's try this okay transact and that was successful now let's try this again and notice that when i try to do it again i don't have enough ethereum for this balance so i get insufficient funds as my error message okay if i look at the balance of here we have 4.4 ethereum left in the contract so now let's try to do this from another account so let me copy this address and let's see what happens if i try to withdraw say one ethereum from this address okay if i do that notice we get an error it says insufficient funds because this address has not yet deposited any ethereum so let's now deposit some so let's make this one ether let's click deposit okay now let's try to withdraw and notice we were able to withdraw that successfully all right so that is all i have to show you for this example here hopefully that was a decent introduction to solidity i understand there was a lot of stuff covered in this video i don't expect you to know all of it i just wanted to kind of show you how to create a basic smart contract how to send ethereum receive ethereum and then hopefully give you a bit of an idea behind the theory of how smart contracts actually work in the next video we're going to continue learning more about solidity i'm going to show you some more advanced things that we can do and then in future videos we'll talk about some of the limitations of solidity and how to make things more affordable using cartesi which is the sponsor of this video and this series hope you guys enjoyed if you did make sure leave a like subscribe to the channel and i will see you in another one