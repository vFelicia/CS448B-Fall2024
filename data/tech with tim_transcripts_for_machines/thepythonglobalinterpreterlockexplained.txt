let's talk about one of the most controversial features in Python the Gil or Global interpreter lock in essence this feature disallows parallel processing and restricts your program such that it can only run one thread at a time to better understand this let's have a look at how traditional programs are executed by your CPU in 2023 a typical CPU has four cores and between four to eight threats to keep our example simple we'll imagine that each core only has one Hardware thread each CPU core is a physical processing unit that is capable of handling one task at a time the more cores we have the more tasks we can process at the same exact time the types of tasks that CPU cores handle are called software threads it can get confusing but software threads are created by applications while Hardware threads exist on the physical CPU from now on we'll only be referring to software threats now software threads are portions of applications or programs that can be run independently by a CPU core the more cores we have the more threads we can execute at the same time this means that we can speed up our programs by splitting them into multiple threads so let's take an example where we want to sum the numbers from 1 to 20. well if we do this with a single thread we're only utilizing one of our four CPU cores to speed up this operation we can split our program into four threads where each thread is responsible for summing a portion of the numbers thread one can sum the numbers one to five thread two sum six to ten thread 3 sums 11 to 15 and thread 4 some 16 to 20. now that we're using four threads we can use four CPU cores and we sped up our program by four times now this adds a bit of complexity but overall it's worth the tradeoff now here comes the bad news in Python it doesn't quite work this way whenever we execute code we use something called an interpreter to keep it simple this is what's capable of understanding the code and processing the instructions that we wrote that means that in the previous example each one of our threads will need to access a code interpreter whenever it's executing instructions in most languages this is fine multiple threads can use the same interpreter at the exact same time but in Python we have something called a lock now a lock is essentially a gate that only lets one thread through at a time since we have a lock on our python interpreter that means that even though we have four threads only one can use The Interpreter at a time if a thread is using The Interpreter it can release the lock allowing another thread to access it but only one thread can be using The Interpreter at the same time that in essence is the python Global interpreter lock now at this point you might be asking yourself why would I ever use multiple threads in Python well the answer is when you're working with network or input output type operations now imagine a simple example where a user visits your app the app may need to load the user's friends and chat history from a file or from some API now while this loading is happening you still want your user to be able to interact with the app if you were to place all of this logic in one single thread the app would freeze waiting on the data to be loaded before the user can do anything else on the app or before you can load load additional data now if you split this operation into three threads even though only one thread can execute at a time you can execute a different thread while one thread is waiting on a result from the file system or the server or Network so what we'll do here is we'll make a thread to load the chat history a thread to load the friends and a thread that runs the user interface we start by running the chat history thread which quickly sends a request to a server for some results This Thread then hangs waiting on a result now as soon as it starts waiting we can switch to execute a different thread in this case the friends thread same here as soon as it starts waiting we execute the user interface thread allowing the app to run while the data is loading now once we receive the data we can quickly switch back to the other threads process that data and move on this allows us to execute data concurrently so the CPU can always be working and never waiting on a result that we don't have control over creating multiple threads allows us to switch between those different threads so we're always utilizing the CPU so now that we have a good understanding of threading let's briefly discuss multiprocessing python has a multiprocessing module which allows us to create separate processes now as a simplification you can imagine that each process spawns its own instance of the Python interpreter this means that we can sidestep the global interpreter lock and run a truly parallel application now multiprocessing is not as easy to handle as multithreading but this is a solid solution to avoid the global interpreter lock so now at this point you know about one of the most controversial features in Python the global interpreter lock if you want to learn more about python make sure to subscribe to this channel I look forward to seeing you in another one foreign