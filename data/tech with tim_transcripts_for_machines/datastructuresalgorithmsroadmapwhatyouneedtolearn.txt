we all know that data structures and algorithms is a must topic for anyone wanting to become a software engineer so in this video I'll break down for you exactly what you need to learn the order in which you should learn it and give you some details on what you should focus on for each individual topic I'll even share with you some resources and tips to learn this as effectively as possible now if you want a text based version of this road map or something to follow along with then join my school Community I have it in there completely for free we have over 8,000 members in the school community you can join for free from the link in the description I look forward to seeing you there so let's get right into it with the first thing you absolutely need to master which is big on notation and time complex the analysis you need to understand how to look at a piece of code and understand how efficient that code is does it run in linear time does it run in exponential time does it run in logarithmic time you should understand how to evaluate that and you should know which code is more efficient than others now it's really important that you spend a lot of time in this section and you really get this down this is not something you can skip you need to really understand this to the point where I can put any piece of code in front of you and you can tell me what the time complexity of that is now usually we're going to do this in bigo notation it's not going to be harmful to learn about big Theta notation and the other types of notation but often times we're just going to use bigo notation so as long as you understand that that's completely fine now the reason we need to know this so deeply is because this is going to really translate to every area of data structures and algorithms the whole reason we use different data structures is because of the efficiency of them for different types of operations so if you don't really understand time complexity and efficiency it's going to be impossible to master anything else on this list so please spend a lot of time here absolutely Master this and while you're looking at time complexity you can also look at space complexity now in my eyes this is pretty much the same thing just applied to memory and space it's pretty easy to learn space complexity once you know time complexity so get those down time complexity space complexity and then move into the next topic so now that we're masters of Big O notation and time complexity it's time to get into our basic data structures I've got a long list here just bear with you I'm going to go through them one by one so the first one you're going to want to look at is arrays now you've probably seen an array before but you may not have really gone into the details and understood the time complexity of various operations so here our goal is to understand what an array is how it works and what the different operations are and their efficiency so adding an element removing an element locating an element adding an element at the front adding an element at the back resizing an array and then Dynamic arrays versus fixed size arrays so a dynamic array is one that can grow in size whereas a fixed size array is one that only has a certain number of elements here our goal should be to understand how arrays work behind the scenes and how we grow or Shrink them depending on the operations we're performing now once we look at arrays we want to start looking at linked lists now these are probably the most basic type of data structure and we want to understand how we create references between different nodes how we Traverse a linked list how we add an element how we remove an element and all of the different time complexity of those operations one thing you're going to see here is that for all of these different data structures what we're focused on is four main operations creating deleting inserting and locating in some cases there's a few more but generally speaking those are the four things we do with the data structure and we want to know which data structures are best at what different type of operation so that's why we're really focusing on the efficiency of those operations so we know later on which data structure we should pick for a specific problem that we're encountering okay so once we learned singly linked list we're now going to learn double linked list now this is a linked list that goes in both directions pretty much you can look it up you'll see exactly how it works and same thing with a single link list we're going to want to understand how to add remove find and when we would use double versus single what the advantages are once we look at that we're going to start getting into cu's and stacks now A Q is a data structure that will maintain the order in which elements are inserted this is just like a q where you would line up right you're in a line that is a q so again we want to understand how we add how we delete how we find an element how we create a queue and here we'll also want to look at how we Implement a queue because the implementation is going to dictate the time complex the various different operations now after we learn about Q of course we're going to be learning about a stack a stack is just like a stack of plates whatever goes on the top is the first thing to come off so the first element on is actually the last element off and the last element on is the first element out we have lifo last in first out that's kind of a common term here when we're talking about something like a stack there's a way to say it in reverse as well but a stack is another data structure we're going to want to learn again adding elements removing elements how we implement it and when we would use a stack versus using something like a q so now we've learned about those we're going to start getting into trees now here's where it gets a little bit more complex and we start to see some data structures that aren't quite as familiar because they're not linear they're in a tree likee structure now so this is where you'll start to see kind of some new Concepts but it gets pretty interesting so the first thing we're going to look at is just basic trees and we're going to specifically look at a binary tree a binary tree is a tree in which one node can have at most two different children and with the binary tree we have a lot of different properties and ways to Traverse the tree to add an element to the tree to remove an element to the tree to locate if if an element exists sorry to create the tree when we're starting out so we're going to want to look at all of those different things and when we start looking at trees there's going to be three traversals that we're going to want to focus on the postorder the preorder and the inorder traversal these are very important to understand so make sure you spend some time once you've learned about the basics of trees to know how those traversals work now we're also going to want to learn about some different tree properties like the height of of a tree the depth of a node within the tree we're going to want to understand what a complete binary tree is what a full binary tree is what a perfect binary trees there's all these different properties of trees and even though you don't need to memorize all of them you should have at least seen them once so make sure you go through all of those different Core Concepts there's probably some I'm forgetting here but those are the main ones I can think of off the top of my head now once we've learned about binary trees we're going to start learning about binary search trees now a binary search tree is very similar to what we learned before but in this case we use the tree to more efficiently locate elements and we sort them or sore them sorry in more of a sorted order now it's not a linear sorted order like we would have seen before with the binary search tree all of the children to the right of a parent are going to have a greater than value and all of the children to the left of a parents are going to have a value less than that now this allows us to create an efficient data structure for locating different elements but there's some other properties of this that we're going to want to understand like how do we insert an element in a binary search tra how do we remove an element how do we locate an element Etc so look at both regular binary trees and then binary search trees once we look at binary search trees we're going to start looking at heaps now heaps are similar to binary search trees but they work a little bit different and again we're focusing on those main operations like creating a heap inserting deleting locating Etc now with the Heap we're going to want to look at a Min Heap and a Max Heap and we'll try to see how a heap can actually work as something known as a priority Q which is another data structure that we should kind of learn about in Tangent with the Heap now once we learn about heaps we're going to move on to graphs now when we talk about graphs we're going to be talking about nodes or vertices that are connected with different edges we have so many different properties of graphs like directed graphs undirected graphs weighted graphs unweighted graphs and we need to understand how to represent graphs and how to Traverse them so we could have adjacency list adjacency matrices Edge list there's all different types of properties of graphs and here's where you can get into graph Theory and get real really really complicated start talking about Cycles within graphs and all kinds of fancy algorithms you don't need to get too crazy here but you want to understand what a graph is how you represent a graph the different types of representations and which is advantageous in which scenario now once we understand graphs and we get that terminology out of the way we're going to start looking at hashing now hashing is not overly complex this isn't something I would spend a ton of time on but we want to understand what a hash is how we hash and how we use this for something like a hash map that way we understand how some data structures that we use every single day actually operate and the efficiency of those data structures so that wraps up our basic data structures I know this is overwhelming and it's a lot of content but this really is what you need to know just as the basics in data structures and algorithms and now we're going to get into the algorithms all right so now we're going to start diving into algorithms but I do want to let you know that if you do want to learn all of this and you actually want some practice and ways to evaluate if you actually know what you're learning then you can check out my course with course careers this is a full software development course it doesn't just teach data structures and algorithms but it has an entire section dedicated to this where I break down all of the topics that I'm listing to you right now I explain everything that you need to know and not only that we give you a bunch of practice exercises quizzes Etc so you actually know if you're ingesting this content and understanding what the heck we're talking about you can check it out from the link in the description with that said though let's get into our algorithms okay so now now we've learned our data structures we're going to start talking about algorithms now these algorithms will use the various data structures that we've talked about and a lot of them are just famous computer science algorithms that you should be aware of and you should implement or write once in your life so let's start going through them now there's kind of different categories of algorithms so bear with me as I walk through them the first type of algorithm we're going to want to learn about is recursion now recursion is Simply Now recursion is Simply Now recursion is simply if you got that horrible computer science leave a comment down below but recursion is simply calling the same function from the same function so it's pretty much doing the same thing over and over when we create a recursive algorithm we have something known as a base case and a recursive case you can learn more about it this is not going to be an entire video on recursion next we have searching algorithms now these you may have already seen at this point but a searching algorithm is something we use to locate something within a data structure so we have a linear search which means simply scanning something from left to right and trying to find an element and then we have something like binary search which is a way that we can sort or sorry search very quickly within a sorted list you want to learn both of those and you should know how to implement them and write them out next we have sorting algorithms now sorting is a very famous thing in computer science obviously we need to do this all the time so it's important to understand these different algorithms and the efficiency of each of them within sorting algorithms we have so many different options I'm going to list a few here and if you follow any reputable curric ulum then these will probably all be taught so we have insertion sort selection sort bubble sort merge sort Heap Sort quick sort uh there's probably a few others that I'm forgetting but those are the main famous ones that you want to be aware of you don't necessarily need to write all of these out but you should understand how they work and what sorting algorithm is used as the default implementation for a programming language you write it so next we're moving on to graph algorithms now at this point we really want to focus on depth first search and breadth first search and make sure we can implement those and really understand how they work so with depth first search we're using a stack with breath for search we're using a q we want to really make sure we're good at these because these are very famous algorithms and they're used in a ton of different problems now as well as that I'd recommend looking at Cru skull's algorithm and Prim algorithm for finding a minimum spanning tree these aren't as important but they are pretty famous algorithms and they can show up in some more complicated data structures and algorithms type questions moving on from our graph algorithms we have our path finding algorithms now these are quite a bit different they are a more efficient way to find the shortest path within a graph in this case we have the AAR path finding algorithm and Dyas algorithm start with Dyas then you can look at AAR AAR is just a slight variation of Dyas so it's not that much more difficult to learn and it can always be fun to write programs that actually model these uh pathf finding algorithms in fact I found those really fun when I first learned them so maybe here you want to take a break and actually write out a data structure as an algorithms visualizer where you kind do a pathf finding algorithm just an idea anyways let's move on to the next algorithms I'm going to go a little bit faster here these are important to understand but you can really only learn them when you apply them to a specific problem so as much as you can look at the theory these are going to be more ones you focus on when you see a problem that requires this type of solution now here we have greedy algorithms we have divide and conquer algorithms this is kind of a general classification but something to be aware of we have dynamic programming and then we have backtracking algorithms now again kind of four categories of algorithms that are hard to learn theoretically and that are easier when you actually apply them into a problem okay so that wraps up the algorithm section now it's worth noting that there are tons of different algorithms you can learn but these are the most famous and if I was going to name the few that you should really focus on uh they would be the following so linear search binary search depth for search breath first search and then you want to understand sorting algorithms like the merge sort and the quick sort algorithm if you only had to learn a few algorithms on this list those would be the few I would really really dive into and make sure you fully understand the reason for that is these are the most commonly used and I would say they're the most fundamental in terms of computer science knowledge the other ones are important don't get me wrong but if you're only going to learn a few of them really focus on those specific few so at this point for 95% of you you have all the knowledge you need to really start practicing this and if you do have something like a coding interview start preparing for That interview by doing data structures and algorithm style questions however if you really want to get to the next level there are some more advanced data structures and some math you may want to learn which I'm going to share with you now now I just want to emphasize that for most of you you do not need to know this even myself I'm not master these different data structures so I'm just going to quickly run through a list of the advanced ones again that are completely optional that you may want to look at if you really want to get to the next level but keep in mind most of you do not need to know this and you'll be completely fine with what I said before okay so let's get into it here we have tries B trees AVL trees red black trees skipless segment trees Fenwick tree and the disjoint set now there's about a billion other data structures I could share here as well but these are the more popular Advanced ones now if you've learned all that and you really feel like punishing yourself still I'll give you a few math topics you can learn that'll give you a much deeper understanding but again this is fully optional I've actually learned all of this math I can't remember any of it to this day today but I do remember when I was learning I was like okay that's kind of cool and now I feel like I understand this a bit better anyways we have combinat Tronics we have probability discrete math and discrete structures now discrete math and discret structures are two courses that I took in University I could not tell you what I learned I don't remember most of it but it was based on like mathematical proofs and actually going through some pretty deep math that kind of allows us to understand why certain data structures have different uh time complexities how we actually prove the time complexity of algorithms Etc not something I feel like you really need to know I don't think I've ever used this in real life but if you do really want to get into the nittygritty you can learn those type of mathematical topics okay so that's going to wrap up this complete road map I just want to go through everything you need to learn that you have one video that has everything and you can kind of reference this if you're looking for a road map or a guide now keep in mind I do have the text based version in the school Community completely free you can join from the link in the description and if you want a great resource that really has all of this packaged into one place you can check out my course with course careers I'll wrap of the video here if you guys enjoy make sure to leave a like subscribe to the channel and I will see you in the next one