all right so let's create a class let's call this pipe and now we need to implement some more things so let's start with the class variables that we need so similar to our bird class we're gonna need for this is just the gap which is gonna be equal to 200 and this is just how much space is in between our pipe as well as the velocity or how fast our pipes are gonna be moving because since we have the way the floppy bird works essentially is our bird doesn't move but all of them objects on the screen move we need to move the pipes backwards or towards the bird to make it look like it's moving so I'm gonna save velocity equals 5 here and that will create a emit so under spider square knit underscore underscore will do self and X now the reason I'm doing X and not Y or just I guess not both of them is because the height of these tubes and where they show up on the screen is gonna be completely random every time and we're actually gonna calculate that in here when we first initialize the pipe we're gonna give it a random height so what I'm going to just do here is say self dot x equals x and then I'm gonna say self thought height equals zero self dot gap equals 100 I don't know wait why I did this twice actually we might not need this but anyways we'll see this I'm just looking at my other screen right now we're gonna say self dot top equals zero self dot bottom equals zero we're gonna say self dot pipe underscored top equals PI game dot transform duct flip pipe image and I'll talk about this in a second and then we're gonna do false true and now we're gonna do say self dot pipe underscore bottom in all capitals equals pipe underscore image all right so what I just did here really quickly was I'm creating some variables to keep track of where the top of our pipe is gonna be drawn and where the bottom of our pipe is gonna be drawn I'm also just getting the images for the top pipe and the bottom pipe now the reason I'm doing this here is because I need to keep track of the the specific image so it's kind of hard to explain but I'm gonna go to my desktop to show you essentially the images the pipe starts facing vertically but also need a pipe that faces upside down so I just need to flip this pipe over and store that image inside the class so that's what I do here we flipping the pipe and saying that's the pipe top and this is the pipe bottom now the next thing we need is self dot cast which is gonna be equal to false now this is gonna stand for if the bird is already passed by this pipe and this is gonna be for collision purposes and for the AI later which we'll talk about in a bit and then I'm gonna call a method that we haven't yet created called self dot set underscore height now with this method is gonna do and we're just about to code it is gonna define where the top of our pipe is where the bottom of our pipe is and how tall it is or you know how tall is the top one versus the bottom one where is that gap all of that and that's gonna be randomly defined so what I'm gonna do here say set underscore height give this the self and what we'll do in here is just get a random number for where the top of our pipe should be so I'm gonna say score actually yeah I guess the top four pipe will say self dot height equals random dot R and range will do a range between 40 and 454 where we want the top of our pipe to actually be on the screen and then we're gonna say self the top equals self dot height self thought pipe top dot get under score height now I know it seems kind of confusing but essentially if we want to figure out where the top of our pipe should be let me go back to my image here we need to figure out the top left position of the image for our pipe because let's say this is where we want the like top pipe to be located well we have this number to figure out where we need to draw it on the screen we need to figure out the height of that image and subtract so we'll actually probably be drawing the pipe at a negative location but since it's so long then what will happen is it will like go down the screen and where we actually want you know that bottom of the top pipe to be will be in the correct position so that's what we're doing here now for this pipe it's easy because the top left hand corner is exactly the WHI where this pipe is gonna be located but for the top pipe it's you know a little bit more difficult so anyways let's erase that hopefully that makes sense all right so that's easy or I guess that's the hard part done now we're gonna say self dot bottom equals in this case self dot height Plus self thought gap now I'm gonna use self thought gap from up here which is 200 which means I can get rid of this gap alright so now for the most difficult method of them all the move method I'm being completely sarcastic because all we need to do to actually move our pipes is just change the x position based on the velocity that the pipe should move each frame so in this case all we have to do is say self thought why are not y sorry X minus equals self thought fell because every time we call this move method which is gonna be the same of how we're calling our bird move inside the while loop all we're gonna do is just move the pipe to the left a little bit right based on where that velocity is okay easy enough now the next one is defined draw this is gonna draw our pipe and we're considering a pipe to be both the top and bottom so this will draw up the top and the bottom now we need to give it a window and what we'll do here is simply say win dog blitz and in this case we're in your selftaught pipe top which will be that top pipe will do that at selfthought X self dot top because again we've already calculated these numbers and then we'll let the bottom pipe so self thought I guess it's gonna be pipe under square bottom and then this will be self dot X and self dot bottom if I could type that correctly alright so now we have that that draws it and the last method and the most complicated one probably out of all these is collide now this is where we talk about pixel perfect collision so like I said before and again give me some slack here cuz I'm drawing with my mouse what we typically do is we draw boxes around all of our objects so let's say we have a box like that and around our pipe it's pretty easy to draw a box because it's already pretty boxy we draw another box now what we do is we check if these two boxes collide with each other now this is problematic sometimes because this means that even if you know let's say these like this part of the box collides with another box or maybe we have one like this we would say that these two objects collided when the user doesn't actually see that this urn collides with well this box because you know the pixels aren't in that location now this is the any way to do collision but I didn't want to do that for this project so I'm using something called masks now a mask essentially is and actually I'll bring out my drawing tablet just to you know make this look a little bit neater is kind of an array or a list of where all of the pixels are inside of a box now this is somewhat complicated I'll try to simplify it but essentially if we have two boxes like this and we have two circles what a mask does is it tells us where these circles are so what we can do is we can see you know if these two boxes collide like this and maybe there's a circle here and there's a circle here and we can check if any of the pixels inside these boxes are actually touching and in this case these pixels are not touching so we would say that it doesn't collide but if we have a collision where we have you know a circle and let's say we have that box and this other circle since these pixels right here in this area are actually touching we're gonna say that this collides now this is where we used masks in PI game and a mask is just it looks at an image essentially and it figures out where all the pixels actually are because these images have transparent backgrounds what it's able to do is see if the pixel is transparent or if it's not and then what it does is it creates a list that's gonna be it's actually gonna create a 2d list and it's gonna have as many rows as there are pixels going down and as many columns as there is pixels going across so let's say we have an image that's 10 by 10 well what we're gonna get is we're gonna get 10 entries in here so 1 to 10 and then we're gonna get 10 rows of pixels so let's say you know this is number 10 like this and what we'll do is we'll have these two lists and we'll have one for each image and we'll compare these two lists together and we'll see if there's any pixels in each list that collide with each other or that sit in kind of the same area and then that way we can determine whether or not we had pixel perfect collision now it's kind of as far as I'm gonna explain this if you don't understand it again my apologies but it's kind of with its own video on its own to explain that I want to go into depth with too much depth with it but pygame has some functions that kind of help us do this which are just mask collisions so that is why we needed to call get masks on this or we need to create this method get masks so based on the image it can get us mask which is just a twodimensional list and then we can compare that mask against our other masks so anyways let's create this method called collide let's put self inside of here and then what we're gonna do is actually have bird and window be passed to us now I don't actually remember why I pass window I think I might use it for something or maybe we don't I'm just gonna get rid of it actually because I don't think we need it but what I'm gonna do is say first of all bird underscore mask equals bird which were passing in here which is gonna be that bird object don't get under sport mask so we're going to get that mask to start and now what we're going to do is create a mask for the top pipe and the bottom pipe so the way we do that is the same way we did it here so we're going to take this we're gonna put it here twice and we're gonna say top underscore mask equals this and bottom underscore mask equals this now what we're gonna take is inside yourself dot image we're gonna say self dot pipe top and then we're gonna say self dot pipe body wonderful now we need to calculate something called an offset and an offset is how far away these masks are from each other so we actually know how like I guess the function that we're passing this to and pygame knows how we can check these pixels up against each other again it's kind of complicated but just go with the flow here so we're gonna say top underscore offset which is gonna be offset from the bird to the top mask is gonna be equal to and this is kind of complicated but we're gonna say self dot X bird dot X and then we're gonna say self dot top round of bird dot y now it's just because we can't actually have any negative or sorry decimal numbers here so I just need to round off the Y of the bird anyways now what we're gonna do is make the bottom offset which is gonna look like this so let me similarly and say self dot X bird dot X I'm gonna say self dot bottom the round of bird ly if you're interested in looking more about masks then just look up PI game documentation and look up masks and it kind of shows you how this work how this works but obviously we need the offset which is how far away the two top lefthand corners are from each other and then if we have the mask which is those lists of pixels we can kind of just do some math and calculate and see if two pixels are overlapping or not and that's basically how that works so now what we're gonna do is we're going to figure out if these masks collide now the way we do that is by finding their point of collision so what I'm gonna do is say the underscore point equals Bird underscore mask dot overlap and then I'm gonna say bottom mask bottom offset now what this does is tells us the point of collision or the point of overlap I guess the first one it finds between the bird mask and the bottom pipe using the bottom offset so how far away that bird is from the bottom pipe now if these things don't collide then this returns this function returns to us none all right so that's just important to know so let's copy this and we're gonna do the same thing now for the top so instead of be point we're gonna say T point which stands for top point we're gonna say top mask and top underscore offset like that now what I'm gonna do is check if either of these points exists so essentially if we aren't colliding then both be point and T point will be none so all I have to do here is say if t underscore point or b underscore point which essentially means if they're not none then what we'll do is we'll return true which says that we are colliding with the other object otherwise we're gonna return false so the reason I have these on each of these pipes is so that essentially every time we move the bird will check if the bird collides with whatever pipes are on the screen now if it does it's got this is gonna return true to us and then we can do something in our main loop way you know like make the bird die pause the game whatever we need to do otherwise we'll return false and we'll just keep going so this is gonna tell us if we collide with this pipe and we just pass it a bird object now later when we have a lot of birds we'll be calling this method a bunch of times on all of our different birds alright awesome so now that we've done that I guess we could start drawing some pipes onto the screen but you know what I actually want to program the last class we have to do which is called base so base is gonna be actually let me pull up the image here this now we actually need a class for this because it needs to be moving and the way that this moves is kind of complicated because this image is not super long it's not infinitely long which means as soon as it moves to a certain point we need to move it back so that it can start moving again and you'll see how this works as I start going and I'll kind of explain it with a photo so anyways let's go to class base let's define a few things in here like a velocity this velocity obviously needs to be the same as the pipe otherwise it's gonna look like these two things are moving at different speeds and then we're gonna have a width which is just how wide this actually is and that's gonna be our base image don't get underscore width so how wide one of these images are and then we're gonna say image equals base image alright next let's program the init so define underscores for an it underscore underscore itself and we will start at a y position because the X is going to be moving to the left so we actually don't need to define that now next we're gonna say self dot y equals y we're going to say self dot x1 equals zero and when I say self dot x2 equals to self dog we will get into the x1 and x2 in a second but let's program this remove method now so we're say define move self again just like the bird in the pipes we're gonna be calling this on every single frame and now we're gonna do is say self dot x1 minus equals self done now and self dot x2 minus equals self dot bail and maybe some of you clever people out there starting to figure out how this is actually gonna work but I'm just gonna keep programming this maybe you guys will figure it out otherwise I'm gonna explain in a second so I'm gonna say if self dot X 1plus selfthought width is less than zero then I'm gonna say self dot x1 equals self dot X 2 plus self dot width and then we're gonna do the same thing here for X cubes I'm gonna say if self thought x2 plus self dot wit is less than zero then I say self dot x2 equals self dot X 1 plus self dot wig all right so all of you people that are confused don't worry I'm gonna explain this now so essentially let's go to our drawing and let's figure out how this base is gonna move so let me get rid of all this stuff that we don't need anymore and let me pull up the drawing tablet once again so that I can actually get some proper writing here so if you haven't figured this out by now what we're doing is we're actually gonna be drawing two images for our base so let's actually just clear this flappy bird screen which I'm probably gonna regret but that's fine so what we're gonna be doing is drawing two images for our base let's say this is the first image for our base and we'll do these lines to represent that then this is going to be the second image for our base like this now let's say our window width look our window looks like this alright so what we're gonna do is we're gonna start by moving this image to the left and we're gonna move this second image to the left at the same speed that this first image moves so what's gonna end up happening is after a few frames we're gonna have moved our images and they're gonna look something like this where our base now is we see half of one image and half of the other so remove this so that it looks like you know we're moving one continuous image now as soon as this first image here reaches the end so this point here gets off of the screen what we do is we move this image behind this other image so let me show you kind of how this works so as soon as we get to a point where our images look like this where one image is completely on the screen and the other image is completely off we take this one image and we cycle it to the back which is what that if statements doing so we take that guy and we draw them now over here we change his position here and now what's going to happen is we continue to move these images so now what we do is we do the same thing that we're doing before this guy moves this way and this guy moves this way at the same speed then as soon as this guy completely gets off the screen he comes and he cycles to the back and we keep moving so essentially we kind of have like a circle of images moving and moving and moving and that allows us to continually keep moving this background image to the left and to the left and to the left without ever running out of images now we could also just like keep drawing more and more images behind the other ones and have an infinite amount of images but I kind of like this circular pattern as kind of I don't know creative and cool to come up with so that's what I've done but hopefully that makes sense and that's what those if statements are doing for us all right so let's now debug these if statements make sure I did everything correct here so yeah you can see here we have two expositions we start with one of them at exposition zero and one of them directly behind that image we move them with the velocity and then so that's what these are doing here with these velocities then we check if one of them is ever off of the screen completely if it is we cycle it back and then we do the same thing for the other image awesome all right so the last thing we need to do here is simply draw those so we're gonna say define draw self win and just like we've done so many times before we're gonna say windup lit and in this case I guess it's gonna be self dot IMG and I'm gonna do at self dot x1 self ly and we can pretty much copy this and just change X 1 to be x2 now all right so that's gonna draw that base for us all right so now we have successfully created all of the classes that we need to do and is time to move on to bringing this all together and actually forming the game encoding more of the game the main game