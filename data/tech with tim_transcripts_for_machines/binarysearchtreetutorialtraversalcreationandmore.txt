before we get started to get massive thank you to the node for sponsoring this video they make it easy and affordable to host your site or service in the cloud offering nononsense hosting with plans starting at just five dollars this means no surprise fees or overages like you might have gotten from some more entrylevel hosting companies now the note else was a full API that works with tools like terraform and kubernetes making an awesome environment for development projects maybe you've used an entrylevel hosting service before well a notice your step up to powerful fast and fully configurable cloud computing anyways go ahead and sign up with the link below and take advantage of a free $20 credit using the code twt 19 all right so let's talk about binary search trees now before we get into the search tree part of this let's discuss what a binary tree is now most people will know a tree is usually comprised of what we call nodes connected with branches so if I'm drawing one on the left side of my screen here we have nodes maybe this node has a value of 1 and it has some branches coming off of it now usually these can just be arbitrary there can be like a random amount of branches maybe these ones have a few branches coming off them maybe this one has one and it keeps going right and that's what it trees now a binary tree is really basically just a tree that only has at most two branches for every node now what that means is each parent node has at most two children so if you say this is the parent which will say is P then I guess I'll actually this will brighten right on here these are the children right and that it has at most two it can have none it can have one but it can have at most two and that's all a binary or I guess a binary tree is it just has two children for each parent so now if we call this one the parents it can have at most two children and you can keep going and each node has at most two children that's all I binary tree is so you can see this big tree that I've written in the middle of my screen is a binary tree and that's because at most we have two children to each parent nodes so if you say this is the parent you can see we have child one and we have child two and then the rest of them only have one child now a child is just the node that kind of proceeds or comes after or bias is connected to one of these parent nodes and that's kind of some terminology I'm going to be using here now now this is called the root node now the reason it's called the root is because it is the start of our tree it has nothing that comes before it and it's actually the only node in our tree that has no parent so we call it the root that's important because I'm probably gonna use that terminology a few times so a that is the root node other surveys that for now okay so now that we know what a binary tree is what is a binary search tree also known as BST well a binary search tree now satisfies another property not only is it a binary tree but it also is a search tree which means that we can find elements in it very quickly now the way we do this is because every child that's connected to this tree is connected in a specific way so looking at our root node here we can see that the left child which would be this one here so five is always less than the root node so you can see five is obviously less than seven and eight which is our right node is always greater than the root node so the way this works is when we add in new elements based on where we're adding them in the tree they're always gonna put themself in some kind of order so that it's very quick and easy to find certain elements in the tree so if you look at five here you can see that two since it's less than five goes to the left of it and three over here since it's greater than two it goes to the right of it and that is kind of the way that we add elements in and the order that we maintain in this tree so having that property satisfied where every left child is less than the parents and every right child is greater than the parent is what makes this a search tree so those two properties combined gives us the binary search tree all right so let's start discussing how we can actually create one of these trees so I'm just gonna erase a few nodes here so that can add in some more ones let's say we have a tree that starts off looking like this so we have that root node of seven Nomi a five that we have eight then we have two well how do we add elements into this tree well what we do is let's say we have the element nine and we want to add it into this binary search tree well when we add it we need to make sure that the same binary search tree properties are satisfied to keep this a binary search tree that's what we do is we compare it first of all to the root node and we say okay is this value greater than or less than the root node in this case it's greater than so we move to the right now if there was no root here or sorry not root if there's no node here we would just add nine in so we could replace like we're eight is with nine if eight wasn't there but since there is one here we need to figure out where we're putting this based on this node so we look at eight and we say is nine greater than or less than eight now since it's greater than what we do is we move to the right again we see that there's no note here so there's room for us to place nine and we put nine right here as the right child eight and that's how we add elements into our binary search tree now let's do another example with the element 3 now you already know where 3 goes because you saw me show it but let's do kind of the process of how we add it so let's say we want to add 3 into this tree well we did the same thing we compared it to 7 we say is it less than or greater than it's less than so we go to the left is the room for 3 yet no there's not so we compare it to 5 we say is it less than or greater than 5 well it's greater than 5 so we go to the right it turns out there's no other node there so we can go ahead and add 3 and now our sorry what am I saying what do we put going to the right sorry we go down to 2 we go to the left because it's less than 5 yes I'm thinking correctly and then we say ok is it less than 2 or greater than 2 it's greater than 2 so we add it as the right child 2 my apologies on that one there guys so that is how that works that's how we add elements into the binary search tree now this is pretty straightforward so let's just start by constructing one from scratch to make sure that everyone understands how this works so our nodes just going to do a quick note here have a value they have a left node so a node that's attached on the left and they have a right node now when we start off our tree we don't have any nodes so what we do is let's say we want to add the numbers 7 5 9 3 these are the numbers that we want to add into our binary search tree how do we do this well we start with 7 and since there's currently no nodes in our tree 7 immediately just becomes our root node so we write 7 here and we throw that one like that now 7 is gone we've added that one to the tree now we move on to 5 and now we repeat the process I've just talked about so we say ok let's compare it to 7 is it less than or greater than 7 it's less than so we're gonna add it right here to the left of 7 and this is what's gonna be now the left node of the value 7 on the node 7 this is the left shot all right so that's how we do that's now let's add 9 ok so we compare it to 7 we say is greater than or less than well it's greater than so we go ahead and add it to the right side here and now we have nine okay nine is gone now it's time for three all right so let's add this in now so we look at seven we go to the left because it's less than we look at five go to the left because it's less than and we add three like that and now let's keep going and let's add two so when we do to we do the same process here we go left left oh it needs to go to the left again and then we add two right there now let's add in one more number just to show kind of how this works so let's say we want to add six now well let's I'm just gonna erase some of these lines let's do the same process again compared to seven is it greater than or less than it's less than so we go to the left compared to five is it less than or greater than it's greater than so we go to the right and we add six and that is how we construct this binary search tree from scratch the first element just immediately becomes that root and then from there we just compare it to each node we do I say do we go to the left or do we go to the right and we keep going through there until eventually we have room to add in our node now this is just basically how it works so let's talk about kind of more of an implementation of this now in code because this has all been kind of abstract so let's just erase some of this stuff down here so the reason I wrote this no thing here on the left side of my screen is so that we know what each of our nodes have so what we're gonna do is in our program we're gonna set up an object it's gonna be called node what we're gonna do is each node in our binary search tree is gonna have a value which could be you know seven five nine whatever it is it's gonna have a pointer to a left node and a right node so essentially what happens here is we actually store this node in you know the left property of seven and we actually stored this node which is nine in the right property of seven so when we actually want to loop through and look through our binary search tree we can do this recursively alright so what I'm actually gonna do now is program an implementation for a binary search tree I'm just gonna do this in Python before I used to write these out but I was finding that it's kind of messy in my handwriting obviously it's not need enough to do like long bits of code which is kind of what we need to do here so I'm just gonna do some kind of pseudocode Python II like programming of a binary search tree so the first thing we need to do is create a node class so I'm gonna say there's a class node it's gonna have a few properties we're gonna say define underscore underscore an it underscore underscore and what we're gonna do in here is simply define a value for this node so say self will say value and then what we're gonna do is add some attribute so we'll say self dot value equals value self thought left equals none and CELTA right equals none like that let me just save this as a Python file so it's called test up pi because we're probably not actually gonna run this save it like that so anyways that's what we have we have this node class and this is really all we need for our node class we have a value and we have a left and a right now the next class we're gonna write is going to be called BST or binary search tree now what binary search tree is gonna have is just simply one property so we're going to emit under storage core and then I'm here what we're gonna do is simply just define a root so I'm gonna say self dot root equals none now what this is gonna mean is essentially when we first create our new binary search tree there's nothing in it and this root node is the only thing that we actually want to keep track of in our binary search tree it's gonna start off at none but what the root node is is that first node in this the tree so when we actually start adding elements into the tree what we're gonna do is the first element we add will become that root node and then from there that root node will have a left and a right and then all this other nodes will have left's and rights and we can access those nodes by going to the left of the root node and the right of the root node and so on so that's why we only need to hold a root node here in BST now the first method that I wanted program here is going to be an ADD method and the add method is going to well add a new value into our binary tree now what we're going to take in here is current and we're also going to take value for what value we're adding to our search tree so what I'm doing here it's just kind of start programming this and then hopefully I'll walk us through this as we get go through it the first thing we need to check when we add a new node into our tree is if we have a root node or not so what I'm gonna do is I'm gonna say if root actually I'll say if not root which means you know like if root is equal to none so I guess I can simplify that and just say if root equals equals none then what we're gonna do is just simply make whatever this value is a new node that is going to be the root so we're gonna say self got root which I guess this needs to be self is going to be equal to a new node and in here we're just going to put the value so what this is going to do is construct a new node as we can see here and we're going to store that as the root node because we don't have one yet that's what we need to do now otherwise what we're gonna do is actually write kind of recursive method of finding out where this node needs to go because it needs to be in the correct sorted order it needs to be there to the left of the root node or to the right of the root node and then after all those children everything needs to be in the correct order so we're gonna start by checking if value is less than in this case current dot value now I should say here that what current is is gonna keep track of the current node that we're looking at because I'm actually gonna make this method recursive you're gonna see how that works in a second but current is going to start off as the root node for our binary search tree so we're gonna start as that root so maybe we say that value seven we're gonna compare the value that we're trying to add to that root node to start and then do something with it based on if it's less than or greater than so if the value is less than what I'm gonna check is if current dot Left equals equals none now if it does equal none that means and I'll do a quick illustration here so that we can see kind of how this works so we have this root node let's say maybe this is seven I'm just drawing with my mouse to give me a break here we compare it to seven you know and we go now we want to add our node we check if the left of seven if it's no or not or if it's none if it is what we're going to do is to add the node in there so let's say we wanted to add three well we'll just put it there now if it's not none and there is a node here then we need to do something else so anyways let's get out of this uh I did not mean to do that okay so if current dot left equals equals none ever going to say current dot left equals node value and that's as easy as that is to add the node on the left side of the tree now if it's not none what we're gonna do is we're gonna say else self dot add current left value I mean discuss what this does in a second but let's move on to the next one here alright so if we've compared our value and it's not less than the current value then it must be greater than or the same so in this case I'm just gonna do an else statement and I'm gonna say else I'm literally just gonna copy this but change this to the right side of my tree so in this case I'm gonna say if current right equals none then current right equals node value otherwise self thought add current uh right value now let's walk through exactly how this add method works to make sure that everyone's on the same track here I'll get my drawing tablet back out so that this is a little bit neater when I'm drawing alright so let's go back into this okay so let's say we have a search tree and it looks something like this we have one and we have three or I guess that can't really be three let's make this a seven that's a seven that's a three and let's say this is a nine like right here and I want to add the value two into my search tree well let's go through kind of this method that we just wrote here and figure out what we would do so we're gonna pass current is gonna be the root node to start so whatever the root is which in this case is actually just gonna be seven right and then we're gonna pass the value to so we're gonna do is we're gonna say if self dot root equals equals none does it no it doesn't so we'll move on to the next else statement here I'm going to say if value is less than current value so if this value two is less than this value seven which it is we're gonna say if current dot Left equals none does it no it doesn't then what we're gonna do is call this method again with now the new current node being current left and the value being again so we're gonna come up here and call this again but now if I can get my eraser out and just erase some of this stuff this is no longer gonna be route this is actually gonna be the left node of route which is gonna be three so now the current node we're looking at is three the value is still two and we run this method the exact same one more time we check you know is the route equal to none obviously no it's not then we come here to the else statement we say if the value is less than current value well as to less than current value yes it is so we go into here we say if current dot left equals none is it yep the left of three is none so what we do is we now add in our new node which is two and that goes in the correct place and we can do this for any example any number and this will work properly um just because of the way that I've written that so I hope that makes sense in terms of that implementation to you guys fairly straightforward all right so I want to quickly discuss here how long this method will always take to run so essentially like what is the time complexity of adding a new node into our binary search tree well I'm hoping you guys can probably come up with this on your own but it actually runs in what we call log base 2 of n time now that means that this runs very very quickly and kind of the bigger that are I guess binary search tree is the faster this actually ends up running in in terms of like how much better the speed is getting so if I just draw I'm just gonna make this a bit thicker here but draw a little graph down here I'll just draw with the log function looks like so you guys can actually see at least the positive side it looks something like this so essentially if this is time so this axis here and this is n which means how many things we have in our binary search tree as n increases time very slowly increases which means that this works really well for massive amounts of information because as n gets larger and larger and larger time actually stays fairly consistent and stays pretty similar and that's why we end up using these types of data structures because it's so fast to add elements in as well as to look for elements which is what we're gonna do next but the reason this runs in log base 2 append time and I'm just going to erase some of this so that I can show you is because of the way that we store things in the binary search tree so let's just write a Barrett law show a very basic search tree here let's say this is 7 this could be I don't know 3 this will be 4 we'll have a 1 here I just need to have a few branches that we can actually do a decent example say this is 11 and this is 8 ok sweet so this is our binary search tree now let's say I want to add in the element 5 well what's the process of doing this well we first start by comparing 5 to 7 and when we compare 5 to 7 we immediately know whether we need to go to the left of 7 or to the right of 7 and in this case we need to go to the left so what we actually end up doing is eliminating all of these nodes here from possible what we possibly have to search through on the binary search tree so we've essentially cut the tree in half and we've also eliminated 7 actually because we no longer need to look at that now what we're doing is we just have this smaller tree that we need to look at so we now compare 5 to 3 and we see is 5 less than 3 or greater than 3 well it's greater so what we actually end up doing is cutting off this entire left branch here of 1 and even cutting off 3 as well and now again we've cut this binary search tree in half so this smaller one that we were just looking at we've cut it in half and now we're left with just this box here I know this is messy of 4 and what we do is we either go to the right or the left and there we go and then we cut off 4 and we're done we've done that in pretty much 3 different operations now as the tree gets larger and larger and larger we still don't have to do that many operations because we keep cutting the tree in half and in half and in half and in half until we get to where we need to go and that's why that runs so quickly and that's why it's log base 2 event I hope you guys kind of understand that I'm not gonna go into much more detail about that alright so traversing a binary tree now there's 3 main ways to do this and the first way we're going to talk about is what's called pre or travursel now the Yosa post order and in order but preorder is kind of the most intuitive I usually think and these are pretty straightforward now the first thing to talk about here is we have some kind of idea of visiting a note so typically when we traverse we look through a binary search tree we're trying to do something we're either trying to find a specific node or we're trying to you know print out all the nodes a collect all the nodes we're doing something with them now when we actually do whatever operation we want maybe we're checking something or adding something to a list we call that visiting so when we actually visit the node is very important because that is kind of how this traversal works now the first order which is called preorder simply means and all ice already here what am i doing visit go left and then go right this is what this stands for now it's pretty straightforward essentially what we do is when we're looping through the tree we start by visiting the root node which is this one so we visited now when I visit a node I'm just gonna write it on the bottom of my screen so you can see the order in which I'm doing things so seven is the first node we visit maybe we're looking for a node we check if that's a node we're looking for whatever it's doing we we visit it now what do we do we go left all right so let's go left so we do now is we go left and we go to five and we repeat this process of this preorder traversal on this node five now so even though it says go right as the next step four seven we need to first do five because we've just gone to the left so what we do now is we visit five which means I write it down here and then what do we do we go left so we move left again and we visit three which means I write three down here as if we've been to three already now what do we do we go left well when I go left here there's nothing here so what I do is I move on to the next step which is go right so now I go right and I go to four okay so now we visited four all right so now that we've done that what do we need to do we need to kind of go back the ladder and go right because we've just finished going left so essentially from seven we went left to five we visited five we went left from five to three we couldn't go left from three so we went right and now we've completely gone as far left as we can go so we start coming back up and we go okay we go to five well we went as far left from five as we can go so now we go right and we visit six and now well we've go back up to seven because we've gone as far left as we can go and what do we do we now go right so when we go to 12 so now we visit 12 and from 12 we follow this process we visit we go left and then we go right so we visit it and now we go left to eight which is here and we've followed this process so we visit it we go left we go right and we can't do anything there so we come back up to 12 and now we say okay we've gone as far left as we can go we couldn't go right so now we go right over here to 13 and we follow this process we go left and we go right and once we've reached a point where we've pretty much completed this process we are done and we have traversed the entire tree and that is what we call the preorder traversal so visit go left and go right so once you end up going left then you know you follow the same process on that left node and continue and continue until you until you can't go left anymore and then you start slowly going bright and moving your way back up the tree if you simply follow this process visit go left go right you know how to do preorder and that is how that works now give me a second to clear the screen and I'll be back with in order all right so what is inorder traversal now it's a similar to preorder just a little bit different what we do is we go left visit and then we go right that is the inorder traversal and you guys are gonna see why we might do something like this as I start to write down the nodes that we're visiting so we always start at the root node now we're starting at 7 but notice that I'm not gonna write 7 here yet because I haven't visited 7 yet so when I visit it that's when I write down I haven't visited it so the first thing I do when I get to 7 is I go left so I go left here two five now when I go to five what's the first thing I do will I do the first step here in the inorder traversal which means I go left when I get to three what's the first thing I do I go left now I can't go left from three so what's the next thing I do I visit it so I write three down here now what's the next process after visiting well it's going to the right so what do I do I go to the right now from here I follow the process left visit right left can't do it visit right can't do it come back up okay so let me just get rid of these arrows here just because I don't want to have them all right so there we go so we go to four then we come back up now we've already visited three so we go to 5 and what's the process visit five because we had already gone left from five right so now we visit five and now what do we do we go right so we go to six now which is here and what do we do we left visit right well we can't go left we can't go right and we visited in between there so now we have six and now we come back up to five we've gone right from it five is done we're at seven now what do we do we visit seven because you know we already went left now we're back here so we visit and now what do we do we go right and what do we do from 12 well we start we go left so we go left here this guy goes left visit right so we visit him 8 then we come back up to 12 we visit because we've reached 12 again and now we come over to 13 we go right we visit 13 and there we go that is the in order traversal and notice this gives our numbers in order so left visit right now if you wanted to go from greatest like the largest number to the smallest number you could do right visit left and that would give you the opposite order because you would go as far right as you could and then you work your way back going left and you would get this kind of flipped so you'd have 13 at the start and 3 at the end anyway so that is how the inorder traversal works gonna clear my screen and I will be back with postorder alright the post order traversal is kind of the opposite of preorder so I'm preorder we had left right visit or sorry we had visit and left right and postorder we have left right visit so what we do here is follow the same process that we've done before except we go left right visit so we go left alright we're here at five now what do we do and go to left we go left now what do we do when we get to three well we can't go left so what do we do we go right now from here we go left right visit so we write four because we can't do anything from there so we visit four is the last step what do we do we come back up to three here and now what do we do we visit three because we had gone right so we write three here now we come back up to five we go right because that's how we we had just gone left to go to three so now we go right to go to six we go left right visit so we write six here now we come back up to five we can finally visit five because we had just gone left right now what do we do we come back up to seven and we go to the right so now we go 12 what's the process here at left right visit so we go left here to eight obviously from eight we can't go left right so we need to visit which we do then we come back up to 12 what do we do we don't visit yet we go right because we just gone left so now we're going right so we go thirteen obviously we can't go anywhere from here so we just visit it now we come back up we can finally write 12 because we just want to left right and now finally back up to seven and because we had gone left right from seven we can write seven at the end and that is our post order traversal notice that you're always gonna get your root node at the very end of your post order traversal and that is just the way that it works because left right visit and since this was the first node to repeat that process not until everything else has visited are we going to visit that root node there's different uses for all of these I'm not gonna talk about kind of what those are you can figure them out as you go but now I'm just gonna quickly show you an implementation in actual code for this and then we're gonna wrap up the video and hopefully you've learned a bit about binary search trees alright so what I'm gonna do here is just quickly program the post order in order and pre order traversal they're really straightforward you're gonna see how easy they actually are just notice I've created a visit function here which is gonna stand for what happen is when we visit the node and in this case I'm just gonna print whatever the value of that node is all right so what I'm gonna do here is start by doing preorder so we're gonna say preorder as the name of our method here it's gonna take self and it's going to take I guess current as the node that we need there alright so what we're going to do inside of preorder is simply follow the process of visit left right so we're gonna do is we're gonna say visit and in this case current so I'll say self though visits this is proper and then we're gonna go to the left and we're gonna go to the right so to do that we're gonna say self dot free order like that and then we're going to go current dog left like that and self dot preorder and in this case current dot right now this is all we need to do for preorder and why does this work well exactly what we've shown before so current is gonna always start off as the root node so we're gonna do is we're gonna say self dot visit we're gonna visit this root node so print that out because that's what visit does here then we're gonna go to the left of the root node and call this preorder function on the left of the root node which is now gonna pass whatever that left note is we're gonna visit it and then we're gonna go to the left and we're gonna go to the right and this is recursively gonna call itself and do the preorder now I'm just gonna copy this and really quickly show you post order and in order but it's just a matter of moving around some of the statements in here so they follow the correct order so I guess we'll do in order here so in order is just gonna mean we're gonna go left visit right so let's move the left up here and that's all that we need to do and postorder will simply put the visit at the bottom and change this name to post order like that what am i doing here like that and then obviously I mean we need to change these to be post order and in order but you guys get the point here that is kind of how that works and that is all that we need to do for the implementation I'll just change these because it's going to bug me I don't and that is kind of how we can traverse through a binary search tree now there's tons of things you could do with the binary search tree I literally could have made this video like ten hours long of the amount of different problems you can solve and how it works but I wanted to give you guys a good fundamental understanding I know this that this was long but I really need to explain how all of these things actually work and I mean now you guys should hopefully have an idea how you can well add an element into your binary search tree and how to kind of loop through it in preorder inorder and postorder now there's tons other things you might want to do like delete find search all of that but I'm gonna leave that to you guys with this knowledge you should be able to do that and as always if you guys have any questions don't hesitate to leave them down below that has been it for this video I hope you guys enjoyed please leave a like and subscribe if you did