hello everybody and welcome to part two of the checkers ai tutorial so in this video we're actually going to be implementing the mini max algorithm now the first thing i want to do though is make sure you guys are set up with the code so please go to the description and download all of the code so this is what it's going to look like here i'm going to walk through it quickly just to make sure everyone's clear on how all this stuff works but if you want to see how you actually build all of this code again i already made a series on just walking through and building this checkers game of course if you're interested in the ai then just download the code and we'll go from there but anyways when you download the code you'll see that there is a main.pi file there's a checkers folder an assets folder and some init.pies main.pi is actually how the game is played in terms of the ui side so this allows us to select certain pieces move so on so forth now we're going to be modifying a few bits of this code so the first thing i want to do is just kind of explain to you how this works so in main.pi it's pretty simple this is really just what is actually getting the user's input so you can see we kind of have a main game loop here it's checking if someone has won if it does you know it's printing the winner and actually what we should do in here is say run equals false which means we're going to quit the game so this is the first edition we can make on line 27 if someone has won the game now what else we see is we have game dot select game dot update game is a class and that represents the state of the game so game is actually kind of like i don't want to call it an api but it kind of is just an api that we can use to play a game of checkers if you go ahead and look in this class you can see we have an update method this simply updates the display and draws it we have winner we have reset we have select which will allow us to actually select a piece or potentially move a piece we have the move method we have draw valid moves and then we have change turn so we can use all of these things um within this class like any ones that don't have an underscore before then we can use them and essentially that is just kind of how we actually play checkers so within this class we actually create a board from this init method a board is another class that we've set up the board handles the state of the board so holding all of the pieces allowing us to check what the valid moves are it's the actual checkers board whereas the game is more handling like okay can you move there uh can we allow the board to move over here whose turn is it that's kind of what the game is handling whereas the board is handling more of the state of the actual game and it's less concerned with what the user is actually doing so if we have a look here inside of board we can see we have some stats related to how many kings are left how many pieces are left as well so red left and white left we have some methods to draw the squares so the actual checkerboard squares we have this move method which will actually move a piece to a certain row and column we have get piece which given a row and column will give us the piece that is at that row and column we have create board obviously this is setting up the board we have draw which is drawing everything and then remove uh that's obviously going to remove a piece or pieces we have get valid moves which given a piece will tell us all of the valid moves that this piece could move to we have traverse left and we have traverse right which is handling how we actually determine where we can move to and that's it for board finally we have peace this represents one singular piece it stores simple things like the cover if this piece is a king it's xy position it allows us to draw it and to move it and that is kind of the basic setup now we're going to concern ourselves mostly with this game and board class we'll just need to use them because as the ai right we're not trying to build this ai we need to know first of all well where can the ai actually move from this position okay we need to have a board that we can use to score right so we're going to need some way to evaluate the positions we need to figure out all of the pieces that could potentially move so we need to actually add a few things to this code to allow that to work i will do that actually maybe we'll do that now maybe we'll do that after in fact let's do it now so the first thing that i want to do is i'm going to go inside of this board class again go inside of here if you just downloaded the code and what we're going to do is simply add an evaluate method now the evaluate will tell us given the state of this board what is its score now we'll use a really simple evaluation method which is going to take in ca take into account how many kings we have and how many pieces we have so define evaluate self now this means if we have a board object we can just call dot evaluate on it it will return to us some number positive or negative telling us the score of this board now in the last video i told us that to score a board we would simply subtract the amount of white versus the amount of red now we can do that if we want so we can return self dot white left minus self dot red oops uh red left like that and that will give us a positive negative score white's going to be our a i so if white has more pieces left obviously this is going to be positive now that's fine but i would like to incentivize our ai to actually try to become a king if it can if i don't do this it means that it's not going to prioritize moving to the end of the board it's just going to kind of slowly move its pieces upwards so if we actually prioritize it becoming a king then it's more likely that we'll see a forward progression and that it actually will try to become a king which obviously is an advantage advantageous piece to be so what i'm going to do is simply subtract this and then i'm going to multiply the red kings and the white kings by a negative and positive number and add them together so what i'm going to do is i'm going to say plus in this case the self dot white king's left multiplied by 0.5 so that means if we have or sorry not white we'll say white kings my bad so self.white kings multiplied by 0.5 and then we'll subtract here the self dot red kings multiplied by 0.5 so what this will do is essentially just give us another value right so if there's more red kings and there's white kings then obviously this will be zero minus this means we'll actually be subtracting whatever the amount of red kings times 0.5 is from this evaluate or from this score sorry so hopefully that makes sense but this is what we're going to use feel free to tweak this mess around with it make it more complex if you want the better we make this function not evaluating the board the better our ai is going to be all right now that we have that the next thing that i need to do is actually make a method that can return to us all of the pieces of a certain color the reason i need this is that we can simply use the board if we have a look here it says get valid moves to get all of the valve moves for a specific piece but if we want to check all the moves that a possible color could make what we need to do is determine okay what are all of the pieces on the board that are this color and then check all of the valid moves for all of those pieces right if we have 10 pieces all of those 10 pieces could potentially move so we need to actually get all of those pieces so again don't be too concerned about this because this is code that you guys haven't written yet i would not expect you to understand it but just a few things that we need to add so define get underscore all underscore pieces like that we'll put self in here and we'll say cover now what's going to happen is we're going to pass a color in here an rgb color so either red green blue whatever the piece color is and we will loop through all of the pieces that we're storing in this board and return the ones that are that color so i'm going to say pieces equals a blank list and just try to follow along here although this code will be in the description as well so not only the old code but the final new code i'm going to say 4 in this case row in self.board so if we have a look here this board has an internal representation of all of its pieces it's actually a twodimensional array it looks something say like this where you know let's just imagine it was like a three by three checkerboard it would have like a piece object it would have a zero if there wasn't anything there would have a piece object it might have zero piece zero so essentially if there is a piece in that square it stores a piece object otherwise it stores a zero we can figure out where a piece is by looking at its position in the list in this case this piece would be at zero zero because it's in the zeroth row and the zeroth column this would be at zero one because it is in the zeroth row or sorry this would be one zero if we're going to go row columns this would be in the first row and the zeroth column all right so that is kind of how that works hopefully that makes sense but we're safe for row in self.board and we'll save for peace in not self in row and we'll say if peace does not equal zero and peace.cover equals equals color then pieces dot append piece return pieces all right so make sure i spell piece correctly our pieces correctly hopefully this is pretty straightforward again just looping through all of the rows for each row we're going to loop through all the pieces if the piece is not zero we will check and see what color it is if it is the color that we requested we will add it to the list and we will return it okay so that is i believe all we need for the board we now need to go to game and i'm just going to add one method here because we'll need to do this i'm going to say define get underscore board and all we're going to do here say self and then return self dot board now actually i'll add one more thing as well so get bored is just saying okay we have this board object right that's stored here we were going to want to get that when we actually start using the algorithm so we'll just add a method to return that next what i'm going to do is say define ai underscore move now this is a bit preemptive you're not really going to understand why we're doing this right now but essentially when our ai makes a move what it's going to do is just return to us the new board after its move so rather than saying like oh i'm going to move this piece here which we could do but that will be kind of complicated what i'm going to do is just make it so that we can just pass a new board object to the game and it will simply update the game with that new board object so all we're going to say is self.board equals board and i'm going to say self dot change turn so we'll simply change turns right here after we get this border after we update the board because obviously if it's white's turn well we need to change it to red and you can see that that is what this does okay so now that we've done that we're looking good what i'm going to do is add a new folder inside of this directory not inside of the checkers directory story but inside of the like upper level directory that i'm in and i'm going to call this mini max now inside of minimax i'm going to add a file this is underscore underscore init dot pi what this is going to do is make minimax a package which means i can import stuff directly from this minimax folder inside of here now what i'm going to do is make a new file i'm going to call this algorithm.pi and you can assume what's going to go in here obviously the algorithm that we're about to write now i will be referencing my other screen just because this is a complicated algorithm somewhat and i just don't want to mess it up for you guys so i will be looking over there if you see me kind of peering to the left anyways what i'm going to do is start by importing a few things i'm going to say from copy import deep copy we're going to use this in a second but what we're essentially going to do is copy the board a bunch of times what deep copy does is will make a actual it's kind of hard to say this but you can make what's known as a i don't think it's i think it's called a shallow copy or a deep copy a shallow copy will simply copy the reference to a object whereas a deep copy will copy not only the reference but the object itself so essentially said i do did something like this right x equals list y equals x if i modify x or y it will modify both of the variables if i say x0 equals 1 then that means y 0 will equal 1 as well obviously we don't want that when we're going to be doing this algorithm so if we said something like y equals deep copy of x then what would actually happen is if i modified x or y now they won't modify each other that's the basis behind deep copy but we'll talk about that after i'm going to import pi game and i think that's all i need for right now i'm also going to define the two colors we're going to be using so i'm going to say red equals 255 0 0. by the way if you don't have pi game installed on your system you will need to install that to get this to work i'll quickly show you how to do that what you can do is open up your command prompt or your terminal if you're on mac or windows and what you need to do is simply type pip install high game if you're on windows this will be the command you need to run press enter obviously you need to have python on your system for this to work and if you're on mac or linux type pip3 install pygame for some reason this doesn't work for you i will leave videos in the description that say how to install pygame on mac and how to install pygame on windows and i will also leave cards to them in the corner it should be the top left or right hand corner where you guys can have a look at those and follow along with that then come back install pi game and be good to go alright so we have red now i'm gonna say white now in pi game when we define colors we define them with rgb obviously all red zero green zero blue is going to be red and all of the colors is white so 255 255 255 now what i'm going to do is i'm going to say define mini max and inside of here i'm going to say position depth max underscore player and game now position is going to stand for the current position that we are in so what position will actually be is a board object so we have boards like this right and what we will do is we'll pass different boards to the minimax algorithm and say okay based on this board give me the best possible board after this that i should move into as the white player or as the red player so we have position which stands for really the board it's telling us okay this is where we are what current position we're in depth is telling us okay how far am i making this tree how far am i extending this tree we're going to decrement this and this is going to be a recursive call which means every time we call this the depth will decrease by 1. next we're going to have max player this is going to be a boolean value that tells us okay are we minimizing the value or are we maximizing the value so if max player is true then that means we're trying to maximize if min players are is max player's fault we're trying to minimize again that means we technically could use this ai to have the ai play against each other white and red which maybe we'll show later next we have game game is the actual game object that we're going to get right from here in this main.pi file we're going to pass that to the algorithm and what that will do is then strip out anything it needs from that and potentially draw some stuff on the screen if we want to do some visualization all right so the first thing to do inside of the mini max algorithm is to determine what our depth is now remember that we only evaluate a position when we reach the end of the tree so in our previous example we had the root node and then we had two side nodes right and then or two or three nodes after that and then after all those nodes we had other nodes right so it went like the red move or it went the white move and then the red move and we evaluated at the red move and bubbled up those evaluations upwards so we're only going to actually make an evaluation if the depth of our tree is at zero so if we're looking at the last node essentially in the branch that we're on so i'm going to say if depth equals equal 0 or position dot winner now remember that if we look at board we have this winner method that i put somewhere maybe at the top i think i had winner yeah winner is right here so we can check if someone has won the game so essentially if uh position.winner we can just say does not equal none then what we're going to do is return position dot evaluate and position now i'll talk about why we're also going to return position afterwards but the point of this is essentially to say okay if the depth is zero so we're at the last node in the tree meaning it doesn't we're not going any further than this let's get the actual evaluation of that position and then let's return this current position alongside of its evaluation so we know what evaluation goes with what position now when i say or position.winner does not equal none what i'm trying to say is well if we've won the game then the game is over there's no need to continue evaluating right so that's what this is saying all right so now i'm going to say if max underscore player and else so the reason for this you can kind of guess is because well if it is the max player then we're going to do something different maximize the score whereas if it's the min player we're going to minimize so these two blocks here the if and else will be similar we can actually copy and paste them and change some things but it's just because max and min so the first thing i'm going to say is the max evaluation that i've seen so far is negative infinity reason for this is because whenever we check a new position we're going to determine which one is the best and well if we don't haven't checked anything yet then currently the best that we've seen is negative infinity right meaning if we see anything else then as a score higher than negative infinity which they all will we'll consider that the current best until something else comes along and beats it next i'm going to say best underscore path equals none you can guess what or actually instead of best path let's say best move equals none you can guess what that means that's going to store the best move that we could make and then we're going to say 4 move in get all moves which i'm going to write in a second this is going to be a function what this function will do is get all of the possible moves for our current position so we'll pass it the position we'll pass it actually the color that we want to consider which in this case is going to be white because the maximizing player is going to be the white player we're just going to hard code that in there and we will pass it the game in case again we want to draw anything for visualization purposes so actually rather than waiting before we write this i'm going to write this now just so that the get all moves function just that it's clear and that we don't get too confused and then go back to it so i'm going to say define get underscore all underscore moves what this is going to take is a position it's going to take a color and it's going to take the game now the point of this function is to get all of the possible moves that we could make from the current position so that is why again within this board class we just wrote that method that got all moves i forget where i put it but i think it was like yeah uh sorry get all pieces so that in inside of here we can get all of the pieces and then we can check all of the moves for those pieces and add those into a moves list so i'm going to say moves equals a blank list moves what this list is going to store is it's going to store the new board so it's going to look like this board and piece essentially it's going to say okay if we move this piece this is what the new board will look like if we move it to a certain position so this is the piece and this is the new board and then we'll have a bunch of these that'll say okay this is you know another new board so new board and this is a piece that we move to get that new board so moves equals a blank list i'm going to say for piece in board dot get all moves or not get all moves sorry get all pieces and we just need to pass it the color so we'll simply pass it color like that and what this will do is get all of the pieces of that certain color now i'm going to say valid underscore moves equals board dot get all valid moves or get valid underscore moves and we'll just pass it the piece so hopefully this is making sense loop through all the pieces in the board there the certain color get all of the valid moves for that piece on the board and then say for move comma skip which i'll explain in a second invalid moves dot items like that now we're going to do something so validmoves.items is saying okay i want to loop through since this is a dictionary all of the items now the items is a key value pair right and the key value pair is going to say row column colon and then it's going to have a list of all of the row call or sorry of all of the pieces that we would skip if we move to this row column so the way that i've kind of done this is that the keys are going to say okay if we move this piece to this position to this row column position we will skip over and need to remove these pieces that say if i jumped over another piece then there would be pieces or a piece in this list to tell me which one i need to remove if i take this move most of these won't have anything because most of the moves we make won't be jumping over someone else but they potentially could be right so that's what we need to consider alright so four moves skip invalid move.items move again is that row column tuple skip is a list of the pieces we would skip what i'm going to say is temporary board equals deep copy board so i need to do this and sorry um instead of we're going to call instead of position i'm going to call this board it's really the same thing but board i think is just more clear here so we'll say board but i'm going to deep copy the board because i'm going to be modifying this board in order to determine when i move to this position what the new board will look like so i don't want to modify the same board i want to make a copy of it every single time so that the next piece that i consider has a fresh board that it could potentially move to um like hopefully that makes sense but we just can't have it be the same board otherwise every time we move a piece it will move on the same board which means when we're running this algorithm but board will permanently move to all of the things that we're just trying out right which obviously we don't want so now i'm going to say new board equals and this is going to be a new method which we'll write in a second simulate underscore move of peace move and then one second here we need to pass the temp board game and skip now i'll write this method in just a second but imagine that what this is going to do is or we haven't written this yet but this function sorry imagine what this is going to do is take the piece take the move that we want to make take the temporary board and then make that move on it and return to us the new board that's what it's doing it's telling us okay if you make this move the new board will look like this and then we're going to store that and we're going to put that in our moves list so we're going to say all right moves dot append the new board like that and then comma the piece so we're gonna say all right if this piece moves to whatever move it is then the new board will look like this and then we'll score that board from inside of here and we'll see which board is the is the best and we'll return that and that will be the board that we then set and like technically the move that we make so i hope that makes sense but here i'm going to say return moves and now i'm going to write the function for simulate move so to find define simulate underscore move like that this is going to take a piece it's going to take a move it's going to take a board it's going to take game and it's going to take skip all right so what we're going to do in here is simply just say if i can look at here board dot move so what i'm going to do in here is now move the piece now if i go to the board method here and i have a look at move it takes a piece and a row and column we want to move it to so what i'm going to say is board dot move piece and we're going to move that to the move 0 move 1. now the reason i have to do this is just because this is a tuple so i just need to split it up and make it 0 and 1. so this means we'll get the row and then we'll get the column so we'll move this piece to that row and column and then i'll say if skip which means okay if we skipped over a piece or we jumped over a piece then board dot remove skip like that and then return this board so return board like that now technically we don't really need to return the board i'm just going to do it because it makes sense we could just actually not have new board equal to this and just use the temp board inside of here but it doesn't make a big difference so we'll leave it like this okay but that is the basics for simulate move and get all moves so now we can move back into our mini max algorithm we're actually almost done but i have to write this core algorithm part now so inside of here what i'm going to do is i'm going to say move or sorry not move child comma underscore and in fact now that i'm thinking about it let me just say let me just leave move where it is actually and let me go here and just not add piece and actually just add new board because i'm thinking about it now and i don't really care about the piece that move because at least for right now i'm not drawing it anywhere if we do decide to draw the piece that's moving and draw a circle around it and all that which we might do then i will add this back but anyways what i'm going to do is just say new board like that so i'm going to get rid of the list that i had and just go back to new board all right so new board is there now we're back here i'm going to say for move in get all moves now what i'm going to say is evaluation so i would write eval but evaluation is what i have to write is equal to mini max of the move the depth minus one i'm actually going to write false here and then for the game i'm just going to pass game again all right so before anyone gets confused with this essentially what i'm saying is okay for every single move that i could potentially make i want to evaluate that move now how i evaluate that is i call minimax minimax will if this is the last branch in the tree so if depth is equal to zero it will give me that positions evaluation if it's not it will go through and it will do what's about to be hap be programmed here again so it's a recursive call we start at the root node and then we say okay well i want to consider the two moves i could do from here all right so i can go left or and go right imagine those are the two possible moves so from there we branch down to those and now it says okay well we want to evaluate these so what can i do from these well i can go here and then says okay well i want to evaluate these what can i do from here and then it keeps going and keeps going until we reach the depth that's desired where it starts evaluating those positions and then they bubble up so it says okay well this is negative 5. this is negative 4 so we're going to pick negative 4 and then that goes back and back and back and that's kind of how it works i hope that makes sense this is just kind of recursion it's hard to explain this with this example because it's kind of complicated but this is essentially getting an evaluation for each of the nodes that we're considering alright so max evaluation is going to be equal to the max of max eval and evaluation so this is saying all right well now we got our evaluation maybe it had to go all the way down to the left and had to check a bunch of different things but we know how good this move is so we're going to see is it better than what we already have in here if it is we'll change that otherwise it will stay the same then what we say is if max eval equals equals evaluation we'll say the best path or the best move is equal to the current move and what this is going to do is keep track of okay so if the move that we just looked at is the best one that we've seen so far then let's set that in this variable so that we know that this is you know the best board that we possibly have the best move that we can make and then what i'm going to say is return the max evaluation and the best underscore path so what this will do imagine if i call this one time right i call this minimax algorithm the first time if it's the max player it will go through all of this it will determine the maximum possible move we could make and the best path and return that to me now of course that's not going to happen until we do all of these recursive calls but after all of this stuff has finished it's been evaluated we will know what the best path is and we'll be able to return that from here now we don't care about what the best path is when we actually are inside of here so what i need to do is where it says minimax is i'm just going to take minimax of 0. the reason for this is that minimax returns to us a position or some board as well as the value for that position or board right it tells us the best or the worst one depending on how we're calling it so i'm just going to strip off the fact that it's giving me the path and just take the number only when i'm returning back to the caller excuse me do i care about actually keeping the best path so i know this is confusing this is an advanced thing but let's just keep going and hopefully it's somewhat making sense so actually i'm going to copy all this now and i'm going to put it in here and we're just going to change some of these things to say instead of max eval this is going to say minival this is going to be positive infinity because the worst that we've seen so far is positive infinity we're gonna say four move and get all moves instead of white we're gonna say red and then we're gonna say evaluation equals minimax of move depth minus one instead of false we're going to say true again the reason for this is that after we look inside of here right we're evaluating for the best player here so if we're going down another depth then we need to consider what it's going to be for the worst player so it's like flipflopping so what will happen is it will start by going into this if statement then this will be called with false which means we'll then go into this statement then say we branch even more then this one will be called with true which will go into this statement so it's going back and forth between red white red white red white to figure out the mini max right of whatever nodes we're considering okay so and sorry not best path that should say best move and instead of best path again this will say best move and now let's just change a few things so instead of max eval it's going to say mini vowel it was the mini vowel of min eval and evaluation and we'll say if the min eval equals evaluation then the best move equals move and we can return it the best move so and instead of max eval sorry return minival best move so believe it or not this algorithm is actually finished now i'll show you it functioning in a second we do actually have to still call this but let me just run through one more high level time how all of this works so mini max it takes some board which is telling us the details about all the pieces on there some depth which is telling us okay how many positions do i want to consider tells us are we looking to maximize this score or minimize this score and then the game game is relevant right now we might use that later which is why i kept it in but you can remove it if you want and then i'm going to say if depth equals zero so if we're at the furthest down that we can go when we're considering then uh what we'll do is say position.evaluate and return the position or of course in the situation where someone has won there's no much there's no more further to go down we've won the game so we just returned this position and the evaluation now the reason i'm returning both is again because just the way this works we need to return two things so that we can get not only the best possible uh number right so we get you know the highest number the lowest number but we also get what position corresponds with that so we know where to move to anyways it gives us that and then in the situation where the depth is not zero or someone is not one we say okay are we maximizing or minimizing for maximizing we run this this says all right the maxi valve starts at negative infinity the best move yet we don't know and we say 4 move and get all moves first we get all of the moves related to the current position for the color white which is the maximizing player then what we do is we loop through all these moves and we evaluate these moves with the minimax algorithm we so we say okay well if we're only at depth say 2 and we need to go to depth 0 then let's check what the minimax of this move is right it's recursive so then we call this minimax and we would go and we would repeat this process and we would then in this case go to the minimizing player if the depth was not zero then the minimizing player would do its thing it would return to us what the min evaluation is it might potentially have to call minimax again and then all of a sudden we have an evaluation for whatever move we could potentially make now we check okay is this evaluation better than what we currently have if it is we set it and we set the best move if it's not we keep going until we've considered all of the possible moves works the exact same thing for min evaluation and hopefully that makes sense i think simulate move and get all moves are good enough and let's just make sure valid moves is spelt correctly okay a lot of talking sorry i know this is complex i'm trying my best to explain now let's go into the main loop and i'm going to show you how we can do this so right now the game currently works like we can select a piece we can move a piece blah blah blah now if we just run this right now none of our algorithm oh it's telling me invalid syntax one second our algorithm obviously isn't going to run because we haven't called it and right now you just play two players so what i'm going to do is simply add a thing inside of here that says if game dot i think do i have get turn no i don't i can just say game dot turn equals equals white which means the computer then let's call the minimax algorithm on the current board so let me start by importing it i'm going to say from and remember minimax is in its own folder so i say from minimax dot algorithm do i call it algorithms no it should just be algorithm import mini max all right so now we have that so inside of here i'm going to say mini max and i'll actually say the new underscore board i'll say value comma new underscore board equals the minimax of the game dot get bored because we want to get the board from this game the color which is white and then we'll just pass the game object all right so value new board what is it saying here undefined variable white okay let me just import white from constants you guys can just add this right here comma white and then that should fix it for you all right so value comma new board equals minimax of game.getboard white game now what we're going to do is say okay game.ai move new board what that's going to do right is it's going to say okay well the ai has moved so let's update the new board to be whatever board this is and then that will actually change the turn for us and then it will allow the red player to move again okay i know this is a lot but let me just test this and see if i messed anything up and what do we get minimax missing one required positional argument game uh interesting so let me go back to minimax and see what we've done ah i forgot to add the depth sorry guys so what we need to do is say game.getboard and we need to pass a depth i'm going to pass a depth of 3. you're going to notice if you're on a slow machine this will take a while go up as high as you want with the depth but that means the higher the depth you go technically the better the ai will be but the longer it will take to run so you know you can kind of pick your poison on what you want there but let me go and move and whoa okay we got some crazy thing happening here so let me just quickly check what's going wrong notice that a bunch of stuff just moved when really only one thing should move all right so i've realized the error it's kind of a weird one it's also just based on how i programmed this game so my apologies to you guys that we're gonna have to make this strange fix but essentially the problem that was happening is that these pieces are not copied but the board is copied so what's happening is when i pass piece in here to simulate move and we move this piece it's changing the actual piece on the board so the board itself isn't changing but it's changing the piece that's associated with the board so what i need to do is get the new piece that's copied inside of this board and use that instead to pass here so i'm going to say temp underscore piece equals i'm not going to i'm not going to deep copy that piece but what i'm actually going to do is say temp underscore board dot get piece because this will copy all of the pieces that are stored within the board automatically and what i'll do is i'll say piece dot row p stock call and then i'll pass a new piece here and now it'll work but uh or sorry not a new piece 10 piece but what this is saying essentially is okay from this new board get the piece that is is the same is in the same position as where this piece would be and that should work i don't think we'll have any errors with that but let me run this and just make sure okay so i've just been playing against this for a minute to make sure everything's working i think it's all working properly the white pieces actually managed to get a king piece i'm not really playing uh you know the most properly ever but now we're running into an issue where he just keeps going in between king not king king not king maybe it just doesn't want to actually move so let me see what happens if i open myself up to be jumped i mean he's still moving like that oh and now it decides to move there so maybe the ai is just way smarter than i think and he actually is moving in some somewhat of an accurate place all right so i've been messing around with it it seems to work fine i mean you guys can play with it yourself and see if there's any bugs but what i'm going to do now is just show you how we can draw what's being considered by the ai and i'll actually make the depth 4 and just show you the difference in speed so now if i run this and i move we can see that it takes significantly longer to actually make the move before it was happening pretty much instantly at least i'm not sure what you guys saw in the video but it was going pretty quickly now it's actually taking more time before it's moving and if i change this to five i almost guarantee it's going to take a really long time to move so let's see i move it there and look at this it's just thinking thinking thinking i can't even move it just frozen right because adding that one extra layer makes it take so much longer so it eventually moved and that was the move it decided on but i had to consider so much more so it will be a better ai but you'll have to tell your players hey you know you're going to have to wait for it because well it's going to have to take some time to think now we could add that optimization technique as i mentioned i'm not going to do that but just wanted to be clear all right so now let's go to algorithm and since we have game inside of here what we can do is actually start drawing some stuff related to the moves that the ai is considering and i'll add some like time dot sleeps in this so that we can see kind of what it's actually looking at so i'm just going to make a function here i'm going to say define draw underscore moves i'm going to take a game a board oops board and a piece now what i'm going to do is i'm going to say valid underscore moves equals board dot get underscore valid moves for the piece this is kind of redundant we've done this before but anyways it's fine it's just for the drawing purposes i'm going to say board dot draw and i'm going to simply pass the game dot window to it i'm just going to go through all this and then i'll talk about what it's doing i'm going to say pie game dot draw dot circle and i'm going to say game.win i'm going to say 0 comma 255 0 i'm going to say piece.x piece dot y and then i'm going to say 50 comma 5. now what i just did is draw a green circle around the piece so we're going to pass to this draw moves a piece a board in the game and it's going to draw all the valid moves for that piece just so that we can see it and make sure we're not running into any like critical errors and you can kind of visualize how this is working next i'm going to say game.draw underscore valid underscore moves i think that's what i called it and i'm going to say valid underscore moves dot keys and then finally i'm going to say pygame dot display dot update and then oops pygame dot time dot sleep and i think i passed milliseconds into this so i'm going to pass 100 which means we'll sleep for 100 milliseconds now i know i just like rushed through that valid moves gets all the valid moves for a piece board dot draw redraws the board on the game window so game.win is just the window that we can draw on pygame.draw.circle draw it on the game window color green that's what zero two fifty five zero is ps dot x p start y this is the middle of the circle fifty this is the radius 5 this is the thickness of the outline of the circle then game dot draw valid moves this will draw all of the valid moves the reason i got keys is again because our valid moves look something like this we have like four or five comma some piece object in here so we need to make sure that we just passed the actual row call we're not passing that piece object to confuse this method next pygame.display.update that will update the display pygame.time.sleep this will sleep it for one millis sorry for 0.1 seconds so that we can actually see it being drawn let's run this and see what's happening all right so when i do that nothing happens because i didn't call that method or that function so we need to call that i need to remember where i actually end up calling this from because i can't remember but i think i do it inside of the get all moves that would seem to make sense simulate move ghetto move yes let's do it inside of here alright so i'm going to say draw underscore moves and i'm going to draw that with the game the board and the piece not important that i pass that temporary board or that other piece we're not going to see them actually moving we're just going to see them considering these specific moves all right so let's now do this all right main dot pi run and let's go ahead and move and what is happening pie game has no attribute sleep i maybe i messed something up pie game dot time dot sleep is that not an attribute okay you know what guys i don't know why that one's not working usually that's something ah sorry it's not sleep it's delay pi game dot time dot delay all right that's what it should be okay let's look at this now and we can see that it's going quite quickly but it's showing us pretty much what it's considering and you can kind of see the pieces moving as it's simulating everything as we go through so this is really what's happening kind of in the back end is it's moving all these pieces it's checking okay if i move in this position what's the score is this the best position should i move here should i move there and notice that it's not only considering the white it's considering the red because it has to consider all of our moves based on all of its potential moves so this is obviously going to take a long time to run through and draw everything what i'm going to do is just quit out of this game so close the program it's not responding just because it's not threaded so i can't do that uh and what i'm gonna do is remove this delay and you're just gonna watch it literally like zip through which i think is kind of funny to see so now what i'll do is go like that and it just literally spams the screen showing us okay we're thinking about where we're going and there you go the decided move was to go from here to here now of course you guys can add stuff to this play around with it but that is all i'm going to do for this tutorial if you guys have any questions as always please leave them down below but that is how you make a checkers ai using the mini max algorithm i apologize if any of this went over your head it is difficult to explain this stuff because it is um you know somewhat complicated stuff right that's not the easiest thing in the world anyways if you guys enjoyed make sure to leave a like subscribe to the channel and of course i will see you again in another python tutorial you