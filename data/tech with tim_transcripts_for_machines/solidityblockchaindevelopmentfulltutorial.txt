foreign hello everybody and welcome to this introductory course on blockchain development and solidity throughout this course not only will you learn about theoretical concepts related to blockchain networks like ethereum but you will understand how to write smart contracts in solidity how to deploy those onto the ethereum network and how to do things like create erc20 and ERC 721 tokens which are nfts this course is designed for complete beginners whether you have experience with blockchain or programming or not you will be able to follow along with this content now this content is meant to just be a good introduction to this topic and to this space this is not going to teach you everything you need to know to become a web 3 developer but it's going to be a really good starting place and kind of show you if you're interested in this or not so after going through this course if you are interested in web3 technology you really want to get to the next level you want to potentially land a job I have an entire higher premium course it's called blockchain expert I'll leave a link to it in the description this covers some of the same content as this introductory course but obviously it goes much more in depth we have over 20 hours of video content we have full projects using things like oracles we show you how to actually write frontend code that can interact with your smart contracts we teach you Advanced solidity features there's hundreds of practice questions assessment questions projects so much more it's a great value you guys can check that out from the link in the description now this course is an aggregation of a bunch of videos I made about a year ago I know many of you don't actually know that I have these videos so every once in a while I like to combine them all together so you're going to see that after this intro there's kind of another intro and then it goes through all of the videos that I posted on the channel a really long time ago so just keep that in mind this is kind of an aggregation and I wanted to give you this introduction just so you understand the purpose of this course and I also wanted to mention that it's possible that when you try to use what's known as the gorelli test Network this is a network we used in this course about a year ago it will fail now if that fails I've left a link in the description to another test Network that you can use it's called Avalanche so use that test network instead the setup steps are essentially the same except instead of connecting to go rally you connect to Avalanche so you may have to do a quick Google search how to connect the Avalanche test Network it's fine I've left the link to the faucet a faucet is a place where you can get kind of free ethereum so you can actually test out your Smart contracts so hopefully you guys can keep that in mind I apologize if the network doesn't work I don't have any control over that but I've left an alternative so hopefully you can kind of continue in this course without any issues with that said I hope you guys are looking forward to this all of the resources for all of the videos will be linked in the description as well as the link to blockchain expert let's get into the first video and dive into blockchain development hello everybody and welcome to a brand new and very exciting series on this channel on an introduction to blockchain development so in this series I'm going to be showing you how to write smart contracts and deploy them on the ethereum network and I just want to State before I go any further this is designed for complete beginners so if you have never written code before if you don't know anything about blockchain do not worry this is the place for you I'm going to be explaining absolutely everything and in this series we're not going to write any massively complicated smart contracts this is really meant to give you kind of a high speed introduction and just get your hands dirty and actually deploying and writing contracts anyways with that said in this first video here what I'm going to be doing is showing you how to set up ethereum so how to set up a wallet how to get some different accounts and then how you can get free ethereum from an ethereum test Network this is important because when we're kind of practicing we don't want to be spending real money and you do need to actually spend ethereum to put your smart contracts on on the ethereum network so I'll show you how we can do that for free in this video so I'm super excited for this series I hope you guys are as well and there will likely be more on blockchain related topics on this channel coming in the future so look forward to that now I do need to mention and I apologize for the long intro here that the reason why I'm able to actually create this series is because of a company known as cartesi now cartesi is the sponsor of this video and this series and they've actually been working with me behind the scenes to come up with the curriculum here and make sure that I'm getting everything correct as I'm relaying this information to you I am not a blockchain expert I am kind of a beginner just like you guys but I am good at making YouTube videos and tutorials and so they've been kind of helping me come up with the content in the structure and then reviewing all of the work just to make sure everything is a hundred percent accurate now cartesi is an amazing company they are dedicated to making the blockchain more accessible for everyone and they have a ton of Technology Solutions that allow you to develop on the blockchain for much cheaper now we will hear more about them throughout the rest of this series but for now I just wanted to give them a general introduction and a massive thank you for working with me and well with you guys I guess to make this accessible to everyone and allow people to get into this world of blockchain development with that said let's get into this first video all right so let's go ahead and get started in this first video I'm going to show you how to set up a metamask wallet this is actually an extension for Chrome although it's available for IOS and Android as well and please even if you have an existing ethereum wallet because this will be storing ethereum follow along with these steps because you want a metamask wallet so you can get access to free ethereum and use it with the different applications we're going to be using later in this series so go to this website click on download I'll leave a link to it in the description and click on Chrome and then install metamask for Chrome now when you do this it will install a Chrome extension it should pin this for you but if for some reason you don't see this in the top right hand corner so a little fox icon that's the metamask icon then click on this puzzle icon for extensions and just pin this it's just going to be helpful so click on the little pin and then it will make it so it's persistently up and I guess your I don't know you want to call this a taskbar bookmark bar whatever uh otherwise if you don't want to pin this you can just click directly on metamask and it will open up this page now for you I'm sure this is going to look a little bit different because you have not yet set up an account with metamask so I'm not going to walk through those steps because they're pretty intuitive but just walk through the basic setup steps on metamask you need a password make sure that's secure you're also going to need some secret words you want to make sure you save those somewhere you want to have access to them and then once you've done that it should prompt you to create an account so if you don't get prompted to create an account for some reason just click on this circular icon in the top right hand corner and click create account now you can have as many accounts as you would like within metamask you can see here I have two I have account one and I have tutorial and this will be very useful for us later on if we want to actually try testing out sending ethereum between different accounts great so that's kind of the basic setup so I have account one notice I have six ethereum this is actually fake ethereum I'm going to show you how to get that in a second and then the tutorial account where I have zero right there all right so at this point in time I'm going to imagine that you've gone through those setup steps you've figured out how to get to a page that looks similar to this and now I can show you how to get some free ethereum so the first thing I want to mention is that ethereum has a few different networks so if you click up here where it says for you it'll say ethereum mainnet but for me it says this gorelli test Network what you're going to do is select one of the test networks that you want to try out your application on now these test networks are kind of a mirror or a clone of the ethereum mainnet the mainnet is the main ethereum Network this is where real ethereum exists real smart contracts exist and anything on here is real money so you'll see this is 0.00 USD whereas if I switch to a test Network there's no price because this is all fake ethereum it's not worth any money it's just for testing for development so you can use any test Network that you would like and you can kind of mess around with different ones if you want but the one that's been working really well for me recently is this go rally one now I'm probably uh mispronouncing this but this is the test that we're going to be using for right now and I just want to note that the public address of this wallet if that means anything to you is available right here so if you go copy a clipboard let's take this and paste this you'll see that we have this address this is the address for my ethereum well okay let me go back to metamask here and now we are back on the go rally test Network in my tutorial account great now that we've done this I'm going to show you how we can use a faucet to access free ethereum and have it sent to this wallet so what we can do is click on buy when we do this we have directly deposit ether or test faucet get ether from a faucet for the go rally now this is the one that we want so we're going to click on get ether you can do this on any of the test networks and it will bring you to a different website now this is bringing us to some faucet I actually haven't used this faucet I'm going to show you how we do a different one or use a different one but what you can do is just stick in your address right here and then request The Ether I would need to do the I'm not a robot thing and notice it's giving me an internal server error because sometimes these things just don't work they are test networks okay so they're going to be down sometimes there's going to be some maintenance they're not 100 reliable but that's fine because we're just using them to test so you kind of just have to experiment and mess around with them and find one that's worth working on a specific day kind of annoying but considering we get free ethereum and we can test it out without without having to pay I am not complaining okay so what I'm going to do is go back to metamask here and actually uh let's just copy this public address although I already have that copied and now we're going to go to this website right here I'll leave a link to this in the description now this website is what's known as a social faucet now a social faucet means that you need to post something on social media that contains your wallet address and then put the link to that post and it will then send you a theory now you don't need to post on some large account or something you can just make a brand new account on Twitter or Facebook I think those are the two available ones right here and in fact that's exactly what I did so what I did is I went to Twitter I have this actually really old Twitter account from when I was like 12 or something oh yeah July uh 2013. anyways I don't use this account so I just signed in and then I posted this tweet requesting faucet funds into and then this address now you actually don't need to write anything other than the address of your wallet so what you'll do is go tweet or if you're on Facebook you would post something and then I'm just going to make a tweet that contains my wallet address I'm going to click tweet then I'm going to go here and I'm going to go share so I'm going to copy the link to the tweet I'm going to go here paste that link in and then click give me ether now we have a few options select whatever one you want I'm just going to go with six ethers every day I gotta select the chimney so let's see if I can pass this okay that looks good and it said oh I have a certain amount of time left until my next allowance uh okay looks like it's because I got ether recently from the same account and so that means that I have to wait but for you guys this should work you shouldn't have a timeout problem uh I already have six ethereum so I'll deal with using that as I need to as we go through the tutorial regardless this should work it should just give you ethereum and then if you go to metamask you should see in your account so let me swap my account here to account one that you have some amount of ethereum all right so at this point in time I'm going to assume you've successfully got some ethereum if the test Network I use didn't work just try another one go through all of them eventually one should probably work for you now it doesn't really matter which test Network you used but just keep track of which one it was because you will need to change some very minor steps as we go through the rest of the tutorial if you did use a different test network but everything will still work the general concepts are the same you just need to alter like one or two things very very small anyways what I want to do now is show you how to send ethereum which is really easy to do with metamask and how you can explore the blockchain and look at the addresses of wallets look at different transactions that have occurred and just show you this website here known as etherscan now etherscan is what I like to call a blockchain Explorer you'll notice here I'm on gorelli.etherscan.io so this is specific to the test Network that I'm using if you did use a different test snap work then you're going to want to search up etherscan plus the name of that test Network and just go to that etherskin obviously this one is for the test Network that I used so what I want to do is show you that we can actually view everything on the blockchain completely transparently it's one of the great things about the blockchain you can just go and look at any wall address you don't necessarily know who owns that walled address but you can see every single transaction that's occurred you can see who sent the money how much money is in every single account that's one of the great features of the blockchain everything is completely transparent so I want to show you how we look up our own account on etherskin so I'm going to go here to metamask and I'm just going to click on my account address right here and copy it to the clipboard now that I have that I'm just going to paste it in this search bar right here and just click search okay so here we go we can now see my wall address showing up on etherscan now if you guys go and paste this address in I don't assume you're going to type all of it out but let's say you did that into etherscan you would see the exact same page that I'm seeing and you could view all the transactions in my wallet so anyways here we are this is my wallet you can see I have six ethereum inside of here and I had one transaction that occurred eight days and three hours ago this is correct that's actually when I had the ethereum sent in when I was kind of preparing for this video and you can see it was on this block I had this transaction hash and then I have the from address and the to address so the two address is my wallet address right here but if I want to see where this ethereum came from which was the faucet I can click on this so when I click here notice this has an absurd amount of ethereum 515 000 ethereum right that's quite a bit and you can go and look at all of the different transactions that it sent and how frequently it's sending them so you can see how many people are requesting ethereum from this faucet anyways let's go back and let's actually click on this transaction hash that's what txn hash is so let's do that and let's just look at some details that we have here now notice it's telling us this is only from this test Network okay it gives us the hash of the transaction which we'll discuss later on we have the status this was successful you could have a status of pending meaning it's not yet been sent through then we have the block that this was attached to we can actually click directly into the block and view everything that was associated with this block as well we can see the miner that mined it too which is interesting then we can go and look at the from address the to address the value of the ethereum the transaction fee the gas price and a bunch of other stuff now this is really not going to mean anything to you right now but I just wanted to show you that you can do this you can look at all of the details of the blockchain completely for free transparently and anyone can do this there's not one person who has access You Can't Hide Your transactions from one person everything is completely publicly available all right so now that we've looked at that I'm just going to quickly show you how you could send ethereum now you only can send ethereum between the same test networks so I can't send this ethereum to a different test Network or to the main ethereum Network obviously that's not going to work but what I'm going to do here is just look at my other account so you'll notice that if I go here I have my tutorial account and then I have my account one so let's say I want to send I don't know one ethereum to this tutorial account well I'm just going to copy the address here notice I'm on this test Network going to go back to account one I'm just going to click on send in metamask I'm going to paste in this public address I'll go with one ethereum I will click next and I can confirm this it's going to tell me how much this will cost I have to pay a very small gas fee I will click confirm and now it is sending the transaction you can see it says pending if I click on it here it gives me the details and this is very similar to what I had on etherscan now let's see if we can find the hash of this transaction uh copy address copy address no let's go copy transaction ID okay so I'm going to copy that let's go to etherscan here and paste this in and let's see if we can view the transaction and there we go we can view it and notice if we go to the from address this is my address that now has less ethereum in it than it did before because I am attempting to send money now it is not showing me the pending transaction because the transaction is currently pending it is not finished but you get the point this is all working and well we can view all of the transaction details all right so I just took a quick cut and you can see that the transaction has now actually gone through so I have a status success the page actually updated live when I was on it so that's how I knew this and if I go back to the from address you can see this transaction is now here uh and sorry it's right here actually because it's more recent and it's saying we sent one ethereum out from this address to the other dress and if we go here we can see we have one ether and then of course if we go back to metamask and let's go to this other account so let's go to account number one or tutorial we have one ethereum so anyways with this transaction now being completed I'm actually going to end the video here I just wanted to give you a brief introduction to how we actually set up ethereum accounts how we can send money between different accounts the test networks and the faucets and then of course ether scan so how you can actually view different transactions view wallets and see what's going on on the blockchain a lot of this will start to make more sense in the next video where I actually go through a deep explanation of how blockchain technology Works how the network is secure how transactions are sent etc etc anyways I am going to wrap up the video here I hope you guys enjoyed one last massive thank you to cartesi for sponsoring this video and helping with the content we'll hear more from them in future videos I hope you guys are sticking around make sure you subscribe to the channel and I will see you in the next one hello everybody and welcome to part two of this video series in this part I'm going to be explaining to you the theory behind blockchain technology so specifically going through some key terms like private Keys public Keys cryptographic hash functions what those are how those work I will talk about transactions how a transaction is created and signed and secured I will talk to you about blocks how blocks are connected together I will then start talking about proof of work which involves minors and securing the blockchain and while all of this is very very interesting and I try my best to break it down as simply as possible for you in this video so in a second we're going to hop over to the drawing tablet I'm just going to start doing some diagramming and explaining and I encourage you to sit back relax and enjoy the explanation however before we do that I quickly need to thank the sponsor of this video and this series which is cartesi now cartesi is a company that is dedicated to making the blockchain more accessible and affordable and when I say affordable the reason that's important is because as you're going to see as we go through the rest of these videos here deploying smart contracts is very very expensive now cartesia offers a bunch of solutions that can actually cut this cost by a factor of almost a hundred and really just make it much easier to work on the blockchain anyways we'll hear more from them later on and we'll actually start using some cartesi technology hopefully in a future series but regardless they are an awesome company they've been helping me come up with the content for this video and I'm just super grateful and happy to be working with them regardless let's dive into the video foreign ignore the black screen there will be some drawing in one second but for now I'm gonna start by explaining to you some key terminology related to cryptocurrency specifically private key public key and address so let's actually start by looking at what's knows a cryptographic hash function because it's very important to understand this concept so we have a function let's say f of x and this is equal to Y this means you take some input X you get some output y pretty standard now with most regular functions you can compute what's known as the inverse now the inverse of f is known as F inverse and then you would take Y and this will give you X so the idea here is that given some output and given the function that computed that output tell me what the input to that function would need to be to get that output so the inverse is like this you take the output you pass that to the inverse function and it gives you the input required to pass to the original function to get that output so let's just look at one concrete example let's say we have something like Y is equal to X Plus 2. well if 2 is my input then Y is 4. now compute the inverse of this function the inverse of this function you simply compute by isolating X so you just say y minus 2 is equal to X that's the inverse and so if I give you the value 4 You Can Tell Me 2 was used to compute that great so now that we understand what the inverse is the first property of a cryptographic hash function is that it has no inverse so we're going to call this now the hash function so let's do hash func this is going to be our input and this is going to be our hash otherwise known as a digest okay you don't really need to know that but hash is what I'm probably going to be referring to this as as we go through this video so the first factor or the first property of a cryptographic hash function is that it has no inverse now what that really means is that given y you cannot find X so if you're given the function and the output of the function there's no way to figure out what the input is that's very very important so to clarify here when I say we can't find the inverse of a cryptographic hash that's not necessarily true now it's important to note that here I'm not talking about the cryptographic hash function I'm talking about the actual hash itself that was the output of this function So currently there's no efficient way or formula that we know that we can use to take an individual hash and determine its inverse however it may be possible to invert a hash using a Brute Force approach where you would blindly guess and try several different values until you determine what the original input value was that generated this hash now this Brute Force approach would take billions of years to perform and that's why we say a cryptographic hash has no inverse because it would take an extremely long and unfeasible amount of time to compute it so yes theoretically it may be possible to compute the inverse of an individual hash but it would take such a long time that we just simplify things by saying it has no inverse so moving on the next property of a cryptographic hash function is that it is deterministic that means that any input X1 always leads to one output y1 so second property deterministic again meaning that one input always points to the exact same output next property is that every output is unique so if I pass X1 I get y1 nothing else points to y1 so if I have X2 it's not possible for me to get the same y1 as soon as I have something like X2 and they both point to the same output this is no longer a cryptographic hash function so again I need to add a small clarification here theoretically it is possible to have two inputs mapped to the same output using a hash function now when that happens this is known as a collision now the thing with cryptographic hash functions is that for that to happen for you to find a collision just like finding the inverse that would take you say billions of years a very very long time to do so we can kind of operate on the assumption that there will be no collisions but theoretically if we're talking about the exact definition there could be so I'm going to kind of be speaking in this video in definitives just understand there is some Nuance behind those but it's just much easier to operate under these assumptions and well hopefully that makes sense okay so those are the first three properties of this function the next is that the hash that you get is uncorrelated to the input so what this means is that if I have something like f of 1 1 maybe this gives me a hash of a b c 2 3. now you might be trying to guess here that if I had a hash of 1 2 that it would give me something similar to this maybe you would think we get a b c 2 4 or something along those lines because you would imagine that the output here is correlated to the input but with a cryptographic hash function this is not the case if I were to pass one two so just one number is different I get a completely different hash so I might get something like d f a two nine four or seven or whatever you know what I mean we just get a completely different hash there's no way to reasonably guess what the hash is going to be by looking at the input all right so that is great the very last property is that this is quick to compute so Computing the hash of some input is very very fast those are the five properties of a cryptographic hash function okay so moving forward we're now going to talk about private Keys public keys and addresses so let's start with our private key now the private key I like to think of as the master password for our ethereum account so the private key is actually what allows us to access our account and to send money so if you have access to a private key you have access to an ethereum account and while you can send money on that account that means you need to keep this private you do not want to share this with anyone and in fact we don't even look at what our private key is when we use metamask it's generated for us and stored in an encrypted fashion in kind of the back end of metamask so that no one can actually see it now when I say encrypted this is actually one of the reasons why we need to pass a password when we created our metamask account so what happens in metamask is it will generate a private key for us but it won't store it in plain text so if the private key was one two three it will never store one two three instead it will store what's known as an encryption or an encrypted version of this private key and it will encrypt it using our password so we have some special function that's going to you take in our private key and our password and then it will give us some output okay and then the only way to go from this output back to what this private key is is to know what the password is okay so we need to use the password every time we sign in so that we can decrypt our private key so that we can then use the private key to actually send transactions okay that is the private key and what the private key actually is is just a string of characters that's really all it is it's extremely long and again you usually are not going to be looking at this yourself it's going to be stored in some secure way so next from our private key we generate what's known as a public key now the public key is generated from the private key so you need the private key to get to the public key and we use a cryptographic hash function to generate this which means if you know the public key there is no way to go back to the private key you cannot do that because the way we generate it was using a cryptographic hash function that's very important because someone could theoretically figure out your public key if they do figure out what that is that doesn't matter there's no way for them to go to the private key hence why this is private and this is public the public one can be shared anywhere okay moving forward the next thing we have is our address now the address is generated from the public key so a private key in a public key actually make up an ethereum account and then the address is what you're going to actually send money to now what the address is is actually a few characters when I say a few it's something like 20 characters of the hash of this public key that's pretty much all I will say it's kind of just a simplified version of the public key and the way you get the address is you generate it from the public key so you go private key public Key address and from the public key again you cannot get back to the private key from the address you cannot get back to the private key and that's very important because as soon as you have the private key you have access to the ethereum account so you give the address to whoever you want to send money to you and that is how you will reference your account on the ethereum network by this address great so the whole point of the address as I was saying is it just a simplified version of the public key so it's a little bit easier to be using on the blockchain rather than writing the public key everywhere so now that we have understand private key public key and address we need to talk about transactions and then how the blockchain actually handles transactions so let's say we have the example where we have maybe a count one and a count two and account one wants to send some ethereum maybe 0.1 F to account two how do we do this well to do this we need a transaction now anyone can create transactions on the blockchain anyone can do it and what's involved in a transaction is an amount so it's going to be 0.1 F we're going to have a 2 wallet so what address we're going to so we're going to be going to account to and then from is going to be account one now the only problem right now with this transaction is that we kind of have to trust that who's making this transaction is the person who's sending the money right the from address but theoretically account 2 could make this transaction and say oh yeah account one is sending me all of its ethereum anyone could just make a transaction and you could add as many as you want and you could just throw them on the blockchain and well if there was no security then you would just have random people adding transactions all of the time that is why we have something known as a digital signature so a digital signature is a very special hash that involves the actual private key of the account trying to send the money so of the from account as well as all the information associated with the transaction now I won't talk too much about the signature because it's pretty mathematically complicated but to be able to actually create a transaction that is valid what you need is the private key of the account you're trying to send ethereum from so this signature here again as I was saying is going to require the private key as well as the transaction itself so the transaction I'm just going to represent by TX and then there's actually another part of this as well and anyways you hash all of this it gives you some you know random uh string of characters and this string of characters you can verify is a correct um signature for this transaction now the way that you actually verify the signature is simply by using the public key of the account that's sending this ethereum so if we see a transaction that's coming from account number one we don't need to know what count number one's private key to determine that the signature is about we can just use their public key and a special kind of mathematical computation to determine that this signature is valid and that it was actually signed by the account that's sending the ethereum because again you can only send this ethereum if you have access to the private key of the account that's supposed to be sending the ethereum so just know for now that you can verify a signature very easily without knowing the private key of the account you just use a certain aspect of the public key I'm not going to go into too much more detail but that is how you verify a signature so anyways that is how you actually secure a transaction you digitally sign it using your private key and a few other things we don't have to manually do that ourselves it's done by metamask when we actually send a transaction okay so let's remove all this and now let's see how we actually associate a transaction with a block and how we actually you know use the blockchain and put a transaction on the blockchain because right now we made this transaction that's fine but we need to send it on the blockchain we need to attach it to a block before it's actually going to go through before our money gets sent to the other person so let's look at what a blockchain is let's say we have one block like this another block like this and a third block like this now all of these blocks are connected together in a chain now they would be of equal size I've obviously drawn mine a little wonky here but all of these blocks contain some information on them as well as all of the transactions and smart contracts that were added to them at the current point in time so what this blockchain actually does is it represents a digital Ledger of the entire history of the ethereum network when we're talking about ethereum here right so every single transaction is a transaction that has taken place and we know the order in which they took place because they're ordered on the Block and then all of these blocks are ordered and this is very similar to something like a ledger that you would have at a bank so a bank would keep track of every single transaction you had sent and everyone else had sent it would know all of that information well same thing here with the blockchain we just do it in a different way now one of the Key properties of the blockchain is that it is decentralized this means it is not controlled by a bank is not controlled by a single person it is controlled by a network of computers that are owned privately by random people around the internet and the reason why this is important is because as soon as something is owned centrally so by one person or one organization or one entity they have the ability and the power to do something with it that is corrupt or that is malicious or that anyone else just doesn't have the ability to do or that they shouldn't maybe have the ability to for example if you own a bank account the likelihood this is going to happen is very slim but theoretically the government could just force the bank to hand over all of your funds maybe you need to pay your taxes or something whatever the idea is there's a central organization that controls this and so at any point in time this Central Authority could go in and actually modify what's on The Ledger they could change the account balance they could take money from you but here when we're talking about a blockchain that is actually not possible because this is not owned by one person or one entity it is used and controlled by all of the computers around the world that contribute to the network and we'll talk about what those are in a second but to be able to do anything malicious on the blockchain you would have to control almost all of the computers around the world that are storing a copy of the blockchain and that are on the blockchain network okay hopefully this makes a tiny bit of sense but let's have a look at one individual block kind of see how that works in the context of transactions and then we'll talk about proof of work and a bunch of other very important aspects of the security of the blockchain so let's say we have a single block okay we can just call this something like block number two okay now the reason why I'm naming it number two and not number one is because the first block in a blockchain is a special block contains some configuration and initialization related stuff because well it's the very first block so that's kind of a special one we're going to ignore block one for now and just move straight to block two now block two is going to contain some transactions on it the transactions I'm going to represent by these squiggly lines now these transactions are exactly what I showed you before they have a to address a from address an amount a signature and they have a few other things as well in fact every time you send a transaction you usually have to pay a very small fee and this fee will be given to the miners that are trying to secure and validate a block anyways this block has some transactions on now this is where we get into the concept of miners so miners are computers that are sitting around the world that are supporting the ethereum network they're actually what allow it to run and they're what secure the blocks and make sure that you can't just hack the network okay so we'll dive into miners in a second I just want to take a quick step back here so whenever you're sending a transaction you need this transaction to be associated with a block and this block has to be mined which we'll discuss in a minute before your transaction actually goes through and is completely successful up until that point your transaction will be pending but once it's been added to a block and that block has been mined then it is successful now a new block is added to the ethereum network approximately every 15 seconds so very very quickly anyways now let's talk about mining so what are monitors well as I discussed miners are just computers that are sitting around the world this is going to be my computer just a bunch of kind of deformed squares here right so there's a bunch of these guys sitting all around the world connected to the ethereum blockchain now every single time a new block is created and all the transactions are added it gets sent to every single Miner so all these miners are kind of nodes on the network they're all sitting there waiting for transactions to get added to the current block when this happens what these miners do is try to mine the block now mining the block consists of Performing some computations particularly some very difficult computations that are very time consuming and trying to guess a number that makes the hash of a block which we're going to get to in a minute have some specific properties now the point of doing this for these miners is that if they are able to guess a specific number they successfully mine the block and they will be given a reward so let's say minor one actually guesses what the number is I'll discuss what that number is in a second and they will be given some reward now this reward will be made up of two things the first thing it will be made up of is a block reward now a block reward is a reward that is hard coded into the ethereum network and actually decreases over time and this is new ethereum that will be created and given to the miner as a reward for mining this block I'm not sure what the current block reward is right now it's probably something like one ethereum but the point is that this is new ethereum that then gets added to the ecosystem and is circulating around so yes some cryptocurrency season here specifically ethereum do have an inflationary aspect to them because new currency is being created but it's not something you really need to be worried about and while there's a whole field of cryptocurrency called tokenomics that kind of discusses this and why this is maybe actually a good thing I'm not really going to get into this in this video point being don't be too worried about the fact that new ethereum is being created so the second thing that you're going to have is going to be your fees now every time you send a transaction you're going to pay a very small fee this fee goes to the miners that are mining the block and so the successful Miner the minor actually guesses the number that mines the block is going to get the block reward and any fees associated with all the transactions on the Block okay hopefully that makes sense I'm just trying to explain the incentive structure here for people to actually mine so continuing now we need to talk about what the miners are actually doing what the miners are doing are trying to guess a number that gets added at the end of the block so I'm going to say num equals question mark that makes the hash of this block equal to a certain number so what they're trying to do here is they are trying to find some number that they can add as kind of a dummy transaction at the very end of the block so that when I take a hash of this entire block so I run this to a cryptographic hash function the hash that I get starts with a certain number of zeros I believe right now what they're trying to find is a number that starts with 30 zeros but it could be actually higher lower I'm not sure what the exact number is the point is that what these miners are going to be doing is trying to guess some number right this is a random number that you add at the end of the block and then when you hash the entire block so all of the transactions associated with the block and the number together it gives you some hash some digest right that has 30 numbers at the beginning or 30 zeros at the beginning sorry and then the rest of it doesn't really matter what that is but you're just trying to find something that has a certain number of leading zeros so the point of this is that the more zeros that you have in that number you're trying to guess the harder it is to Guess that number because the probability just decreases that you're going to guess the correct number right here and again I'm just really trying to reiterate here that what's going to happen is you're going to take a hash of all of this everything inside of the block including this number and then you want it to give you some number that starts with 30 zeros but the thing is there's no way to figure out what this number is other than just guessing and checking because the cryptographic hash function has that property that there's no known inverse so since we can't compute the inverse we have no better way of finding out what this number is other than guessing and checking and so these miners are just guessing and checking as quickly as they possibly can and the one that gets the correct number then adds that to the block that mines the block and then we create a new block and continue moving forward now this is an oversimplification but that's the general idea of what these miners are doing okay so hopefully that kind of makes sense uh but that is what these miners are attempting to do and you might be wondering well there's so many minors so is it only actually one minor that's guessing this number and the answer is yes at every single block you're only having one Miner that is going to guess what the correct number is and get the reward that's why you'll have pool mining which means you'll have like hundreds of thousands of computers that will split their processing power they'll say okay we're all going to try to guess a number together and if any of us get the number we're going to split the rewards between everyone because the probability that one of us can guess the number consistently is very very low in fact if you only had one computer Mining and it was not mining very quickly your probability of ever getting a blocked reward would be almost zero because there's just so many other computers doing it and you'd have to get extremely extremely lucky so that's why you would mine with a bunch of other people so that your probability of getting a reward is much higher and then you would split that based on how much work all of you have done okay so let's continue here now what I want to do is draw a few blocks and we'll see how these are connected and kind of the security aspect of this so let's just paste this block over here and for now we can just go with two blocks okay so we have block two and then this guy is going to have to be block three let's fix your corner right there okay so we have block two and we have block three now this will be coming from block one we don't need to worry about that right now now the thing is these blocks are connected together right so we have block three we have block two block three is connected to block two and obviously it comes after block two now how do we know that well obviously these arrows aren't actually there we don't really have arrows connecting these things but what we do have is a field in every single block that represents the hash of the last block so we have something like last is equal to and then whatever the hash of this block is including the number that we guessed that is what we put right here to represent this is the last block in the chain so let's say when we hash all of this we get a number that is zero zero zero zero four nine a b now this will usually be a hexadecimal number that is 64 characters long but for Simplicity we'll just go with this for now so to get this hash we would also have guessed this number let's just say it's 7 and what we were trying to do was to get a hash that started with four zeros which we've done so next what we'll do is we'll write this hash here so zero zero zero zero four nine a b so now in block three we know the previous block was block two and block 2 would also have this field it would say last equal to the hash of whatever block 1 is so now block three we get a bunch of transactions on here we add them all on and we say okay we want to mine block three so what we need to do now when we mind block three is we have to find some number such that when we hash all of this including this last field right that's going to be included in the block where we're hashing we get a number this starts with four zeros so what this really means here is that if the hash of block 2 ever changes for some reason then this is no longer going to be correct because this is going to be referencing block 2 which now no longer exists and so this will be disconnected from the blockchain you can kind of imagine that this Arrow would get erased now I'll continue explaining this but again what we're doing is we're trying to mine block three so we'll guess some number let's say we guess some number nine and then we end up getting some hash here I guess I can just do it in maybe a purple color zero zero zero and then maybe this is 7 9ba okay this is the hash that we end up get so now where the real security feature of the blockchain comes in is that let's say I am a malicious entity here and I want to change one of the transactions on the blockchain so let's say I take my copy of the blockchain and I go to block 2 and I change the transaction instead I add this fraudulent transaction right here well as soon as I change this transaction this hash here changes right and the reason this is going to change is because when I take the hash of this block now since this transaction has changed I get something completely different and so what I'm probably going to end up getting here is something that doesn't start with four zeros so say maybe I get one zero two a b b c 1 that's my hash so now since this hash doesn't start with four zeros I need to recompute this number and remind this entire block because now the number seven is no longer correct to give me a hash that starts with four zeros so let's say I'm successful in doing that and I guess uh you know the number let's go 275 or something and now I get a hash like zero zero zero zero one two three four okay that's my new hash well now the problem is this hash does not match this hash right here and so this block is disconnected from this block and so if I want to actually keep this fraudulent transaction in Block 2 what I need to do now is modify block 3 because I have to change this last to match what my new last on block 2 is so what I do now is I come here and I would need to change this now to whatever this is so zero zero zero zero one two three four but now that I've changed this the hash here is going to be completely different right because we're going to get a different value when we have something different inside of the block so now I get a hash maybe that doesn't start with zeros right one zero zero two three a b c whatever some random hash so now I need to recompute this block recompute this random number and remind it so that I now find a hash that starts with four zeros and you get the point I have to do that for every single block in the blockchain right because these blocks are connected together and as soon as these blocks are no longer connected I don't have a valid blockchain and if I try to send this on the ethereum network all of the other computers on the network are going to be like uh no that is not correct your blocks are not connected your hashes are all messed up and I have a different version than you have so no I'm not going to accept that as a transaction I'm not going to accept that as a block because that is fraudulent so hopefully this makes a bit of sense but this is a concept known of hashes of hashes or hashing of hashes and so what we're doing is we're taking a hash of this block putting it inside of here and then taking a hash of this block that contains the hash of the previous block and so any change to the previous block means that this will no longer be valid and so we have to change pretty well every single block in the blockchain to be able to modify everything and that is why this is so secure and that is what leads me to the concept of proof of work so what we're doing when we're mining is we are proving that we have spent a certain amount of time before adding this block to the blockchain and the reason that's important is because the more time we spend the harder it is to modify the blockchain if you had an absolute supercomputer and you could just remind these blocks instantly then you would be able to go and change the blockchain that would be fine you could do that because you could just regenerate every single block with all of your fraudulent transactions added however since that's pretty well impossible and we have so many computers working on the blockchain at the exact same time for you to be able to do that you would need more computing power than all of the other computers on the blockchain combined and you would need to be able to not only rewrite the entire blockchain previously to what it's currently at you would also need to be able to catch up to all of the other computers that are working on the new blocks being added to the chain and kind of beat them and you'd be like racing against them in a sense I'm sure this is very abstract but this is what makes the blockchain so secure that these blocks are actually linked together you need to perform this mining process which is proving you've done a certain amount of work this work takes some amount of time this amount of time you can calculate using probability the probability you're going to guess a random number and how quickly you can guess random numbers and all of that and as the blockchain continues to grow being able to potentially modify it becomes harder and harder and harder so anything that is added to the blockchain is pretty well permanent and you cannot remove of it without having to rewrite the entire blockchain so this is all great but one other thing I will mention here is that another security feature that's built in is that every single computer that is mining the blockchain or mining the current block has a copy of the existing blockchain and so what that means is that if you try to change something on say the current block every single other computer knows what the current block looks like and so if you're submitting a block that looks different from that it's going to be able to tell that very very quickly it can just take the hash of the block if it doesn't match the hash that it has it's going to be like no this is the incorrect block I'm not going to accept this block or accept this transaction because well it doesn't match what I currently have so hopefully this is all starting to come full circle just a little bit you don't have to understand this stuff super super well but you just have to have a general idea of why the blockchain is so secure this concept of decentralization and kind of how transactions get added to the blockchain and what mining actually means right and that's the reason why there's been a huge GPU crisis in the past and recently as well a bunch of people are mining cryptocurrency for the incentive of trying to earn these different rewards alright so that is all great and really what I just spent the last 10 or 15 minutes explaining is proof of work so pretty much everything starting from when I started talking about blocks was trying to explain to you how proof of work works and while that uses raw computing power typically gpus to perform hashing which then secures the blockchain in the ways that I mentioned however and I understand some of you may be a little frustrated here ethereum is actually switching over now to proof of stake I'm not sure exactly when that's going to happen but it's supposed to have happened for a long time and I know it's going to happen very very soon and the difference is that with proof of stake which is going to be kind of the new method and algorithm this is a type of consensus mechanism which is going to be used to validate the transactions versus using raw computing power now proof of stake pretty much means that if you own cryptocurrency you can stake your coins by staking them you're kind of putting them in a locked container that's the way you can think of it and what this does is give you the right as the Staker of these coins to check new blocks of transactions and to add those to the blockchain now I'm not going to explain proof of stake in this video maybe we'll explain that in another video point being ethereum is slowly switching over or actually probably pretty quickly switching over to proof of stake and that's going to be the new method now I will just say that even though ethereum is switching over to proof of stake that does not mean that what I just explained to you was a waste of your time it is still very very valuable to understand how proof of work works and that is currently what is being used and is being used for a lot of other cryptocurrencies as well proof of stake is just another method of doing this and while I'm not going to explain that further in this video but maybe we'll talk about that in the future regardless with that said that pretty much wraps up everything that I needed to cover if you guys made it to the end of the video give yourself a pat on the back I hope that this maybe cleared up how the blockchain works and gave you at least a little bit of the insight into the theory behind it if I were to go through and explain all of the mathematics of This Not only would I probably make a ton of mistakes but this video would probably be four or five hours long so really if you can grasp The Core Concepts here you have a good enough understanding to kind of proceed and to move forward and start writing smart contracts and to be quite honest with you you don't necessarily need to have all this master to actually write a smart contract it's just very helpful in something that I think is fundamental before moving forward anyways with that said I will finally end the video here thank you guys again for watching if you enjoyed leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to the third video in this blockchain for beginners tutorial Series in this video I'm going to be giving you an introduction to solidity and showing you how to write and deploy your first smart contract this is really really cool I had a lot of fun messing with this before the video and I think you guys are going to be amazed at how simple it is to actually write a smart contract anyways I should mention that solidity is the programming language typically used for deploying smart contracts and writing ethereum smart contracts and so that's why we're going to be using it now in terms of kind of some prerequisites for this video I'm going to assume that you have some understanding of programming some experience writing and maybe a different programming language just because in this video I'm not going to explain the very Basics like things like variables functions and all that stuff that's kind of common knowledge when it comes to program of course I'll go through the solidity syntax and we're really going to learn by actually just doing a bunch of examples and not focusing a ton on Theory last thing I will say is that you do need to have your metamask set up if you want to deploy this to a test Network so an ethereum test network if you don't have metamask setup that's fine you just won't be able to follow along with that step in the video alright so with that said we're just about ready to get started I just want to quickly thank cartesi again for sponsoring this video in this series they're an awesome company again dedicated to making the blockchain more accessible and easy to use they've really helped me a ton in terms of coming up with the content for these videos well I hope you guys appreciate that in the future videos in this series we're going to be talking about how we can actually use cartesi to fix some of the scalability issues with smart contracts because you're going to start to see some of the problems that can actually occur when we write a smart contract because they're a lot different than your traditional code anyways let's go ahead and get into the code foreign so I'm here on my computer and the first thing I'm going to discuss is just setting up our environment for writing code in solidity and deploying smart contracts now of course you can write contracts in vs code or any local code editor but instead for this series I'm going to use an online IDE called remix now this is a browserbased IDE it's completely free and it's super beginner friendly and allows you to actually deploy and test your smart contracts directly from the browser so I'd recommend that you use this you can check it out from the link in the description or just Google remix IDE again completely free and once you click on that link it should bring you to a page that looks like this so for now what I'm going to do is just give a quick tour of remix then we'll talk about smart contracts what they actually are how they work then we'll start writing some code and going through some examples of smart contracts so the first thing we want to do here when we open up remix is we just want to install a few extensions specifically for solidity so you can write other stuff in remix not just solidity code so that's why we want these extensions so what we're going to do is just on the left hand side here go to this plugin manager it looks like a plug and what we're going to do is search for solidity now for me I already have these extensions installed but what you're going to want to install is the solidity compiler the solidity static analysis and then the solidity unit testing now you don't really need the unit testing but you might as well just install it while we're here so install those three plugins and once you have them installed we're pretty much ready to start writing solidity code now you're going to see in the left hand side here let me zoom in a little bit that we have a bunch of you know I guess folders directories and inside of here we have some different smart contracts we have some scripts we have all this kind of stuff you don't need to worry about any of that this is all just kind of test code that's provided to you we're not going to use any of this we don't even need to look at it so you can kind of just ignore it for now what I'm actually going to do to get started is I'm just going to make a new file so I'm going to click on this little file icon right here and then I'm just going to call this test.soul so dot Sol is the extension for sale D file so that's why we're going to use that when I do that it will open up a brand new file notice we have the little solidity icon now we can start actually writing a smart contract now one thing to notice here is there's stuff like GitHub Integrations you can create new directories you can upload files you can also have different workspaces so right now I'm in a workspace I created called tutorial but you also could make a new one by clicking this right here I guess this is renaming a workspace and then of course you can delete it I'll let you look at that yourself pretty straightforward anyways all we need to do is get to kind of a file that looks like this just an empty solidity file so I'm just going to zoom in by clicking this plus icon here so you guys can actually read the code alright so now that we're here we might as well write a very basic smart contract I'll briefly show you how it works and how we can run it then I'll actually discuss smart contracts in detail so how they work how you call them and how they're different from traditional code because they are much much different than anything you would have seen before okay so what I'm going to do is zoom in a bit and let's start by writing what's known as our pragma line now the pragma line is required at the beginning of all of your solidity files and what this does is actually tell solidity what company Tyler version this file needs to use so there's a ton of different compilers that are accessible for solidity you just need to define the minimum compiler version so I'm going to say pragma solidity and I'm going to say 0.8.10 and then put a semicolon like that so for all of your lines you're going to have semicolons at the end very similar to something like Java okay so we have our pragma line again just pragma solidity and then the minimum compiler version if you want to see the compiler versions you can go to I believe it's this tab right here and it will show you all the compiler versions so notice we're on 0.8.10 so I'm just using one of the latest versions that we have okay and then for language of course that'd be solidity and you're just going to have compiler default now here you can actually manually compile your solidity code I'll talk about that in a few minutes for now though let's continue writing the rest of our contract so after we do our pragma line the next thing we need to do is Define a contract so I'm going to say contract and then I'm going to give this a name now I can give this whatever name I want I'm just going to call it my contract so what I've just done is created a smart contract okay that's all you need to do you write the word contract give some name the casing you're supposed to use for this name is Pascal case which means you're supposed to have capital letters for every single word and then inside of here we can start defining some variables some functions and methods sorry not not functions methods that's what I mean anyways for now I'm just going to define a very basic variable then I'm going to show you how we actually deploy and test this smart contract and then we'll continue with some theory in looking at this more in depth so for now what I'm going to say is uint this stands for unsigned integer and I'm just going to say that this is public like this I'm going to call this X and I'm just going to make this equal to 21. okay super straightforward this is just me defining a variable the type of the variable is an unsigned integer it is public meaning anyone can view it its name is X and its value is 21. so now that we have this contract what we need to do is compile the contract and then deploy so all of our contracts in solidity need to be compiled into bytecode this bytecode is then sent to the ethereum network where the contract is deployed and then we can call the contract so let's just look at a quick example of doing this so we can manually compile by pressing compile we actually don't need to manually do this when we deploy it will automatically compile for us anyways I've compiled the contract right here notice I have my compiler version solidity compiler default then what I'm going to do is go to this tab right here so just below it let's see what this one's called deploy and run transactions and here what we can do is choose a few different options for actually deploying our contract so if you go here notice we have a bunch of options we have web3 provider injected web3 JavaScript VM and then we have the Berlin version of the JavaScript VM now the JavaScript VM is what I'm going to use for right now but what this is is a virtual machine that simulates the ethereum network in your browser so this means you don't actually have to make any real transactions you're not actually adding this to a legitimate blockchain you're just simulating it so that you can test this directly in your browser now if you refresh your browser what's going to happen is anything that you've been simulating in the JavaScript VM is going to disappear because while it was being stored and I guess the cache or whatever inside of your browser point is Javascript VM is kind of a testing environment and when you're actually going to deploy this smart contract for other people to use you need to deploy it to what's known as a web 3 provider or an injected web3 now injected web 3 is actually going to use whatever Network your metamask is on so if I do this what's going to happen is when I try to deploy this contract it's going to open up metamask and it's going to require that I actually do a transaction to deploy this contract again we're going to look at that in a second for now I just want to quickly show you deploying it and running it and then we'll get into the theory so I'm going to go to JavaScript VM and notice here that when I do this it's going to give me a bunch of different accounts that have a hundred ethereum again this is just testing and the point of these different accounts is that I can actually use all of them with my smart contract because every time I deploy the smart contract I want to call a function on a smart contract I need to make a transaction to do that and that requires an account to make the transaction with so for now I'll just select this first account I could copy the address here if I wanted to do that the gas limit just leave this the same for now and then you could pick an amount of ethereum that you actually want to send with this transaction now I don't want to do that for now I don't want to send any ethereum all I want to do is deploy my smart contract so I'm just going to click on deploy and then you're going to see down here it's going to show you my deployed contracts so I now have a contract notice that showing this little button X and if I click on this it gives me the value of x okay very very simple that's all you need to do to deploy a smart contract we'll talk about this more in a second what I want to do now is hop over to my drawing tablet and start talking about some of the theory behind smart contracts and how they actually work and why we kind of need to go through this alright so I'm here on the drawing tab and I want to start by discussing how we deploy a smart contract then I want to talk about their use cases and go through a few properties of them so as we saw we had a smart contract and we stored this inside of a DOT Sol file now this is our solidity file and this is what we refer to as our source code now the source code is simply the code that we write as a programmer it's the closest to English it's the easiest for us to understand it is the source code okay this is where we actually write solidity code however this code cannot be executed on the ethereum network so what we need to do is compile this by running it through a compiler into something called by code so the first step when we're deploying this contract is we run this through a compiler this compiler is capable of taking one language and translating it into another and what we get here is now what I'm going to refer to as the bytecode now the byte code is just a special type of code that the computer can actually understand and execute in almost every programming language what's occurring is you're taking source code you're compiling it into bytecode and then that bytecode is being interpreted by an interpreter The Interpreter you can kind of think of as a mini computer in a sense that's actually going to be able to take all of this code read it understand it and then tell the CPU of your computer how to execute it The Interpreter is typically known as a virtual machine anyways you don't need to know too much about that point being you take source code compile it into something like bytecode byte code is then something that the computer can actually understand and execute and so that's how your code actually ends up running anyways at this point we now have our byte codes we've taken our solidity code We've ran it through the compiler by The Way remix will do this for us automatically so you don't need to manually compile the code and now we have our byte code so let me just move my byte code over here so now that we have this bytecode this is the code the ethereum network and understanding that computers can execute but how do I actually get this now to the block well what I need to do is I need to create a transaction now I just want to quickly mention here that what a smart contract is is just code that's sitting on the blockchain so all we're doing is we're taking this bytecode we're putting this in a transaction and then this transaction is kind of special in the sense that it requests to create this code this smart contract on the ethereum network so what happens is we make a transaction we throw the bytecode on this transaction we pay some fees and then we kind of upload this or send this in a way to the ethereum network okay so just like sending money between different accounts except in this case we're making a transaction that is adding this bytecode as a smart contract to the ethereum network now like all other transactions the first thing that needs to happen here is this transaction needs to be associated with a block then it needs to be mined once it's mined then is on the ethereum network now what that means is just like any other transaction anyone can go and see this they can see the transaction they can see who created the smart contract they can see all of the code of the smart contract they're able to view when you created it the balance of the smart contract all of these other things and this also means that once we add this smart contract to the network we can never change it we cannot mutate it we cannot modify it we cannot change it or delete it and the reason for that is the same reason that we can't delete transactions on the ethereum network right because that's the way the blockchain chain works it is forever there it is a ledger of everything that has happened is completely transparent and trustworthy and that's actually the main point of our smart contracts so hopefully that makes a bit of sense we're going to continue to clarify this in this section point being is that the reason we create smart contracts is because we're taking advantage of the security features of the blockchain to make people trust the code that we are uploading so let's take an example where we want to write some type of Poker application or a casino or something that involves money right something that's going to have money being transacted from either us to the client or from the client to us well if someone comes to our website or we go to some Casino website for example most times we can't see the code right we have no idea what's actually happening in the back end we could easily be getting ripped off maybe our money's being stolen maybe the odds are not in our favor or less in our favor than they should be whatever if we can't see the code we don't really have any way to trust what this website is doing or how these transactions are occurring however if you had your code as a smart contract and you knew that the website was using the smart contract maybe you're able to verify that in some way then you could just go and read the smart contracts that were being used and decide if you want to interact with them or not this means you can fully and transparently see all of the code that's actually being ran and executed you know if you want to trust it or not and then you can decide if you want to interact with it right so hopefully that makes sense one important point there as well is that that code that you're looking at can never be changed which means if you're interacting with the same smart contract you know it's always going to look like that and it's always going to be trustworthy so that's kind of the main point of smart contracts is to allow people to trust the code to make it fully visible to everyone and also just to allow everyone to be able to use it right although I will say it is pretty expensive to be interacting with smart contracts and uploading them to a theory okay that is the main point of smart contracts now one thing I will mention as well is that smart contracts can have a balance so that means you can send money money to a Smart contract it can receive money it can send money back to you it can call other smart contracts and in fact we're going to start talking about that now so let me clear the screen and now we're going to talk about how you actually call a smart contract so in front of me I have a beautiful illustration I have a contract and two ethereum accounts now as I said briefly a contract can have a balance so just like an account a contract is going to have an address it's going to have some type of balance so we can actually store ethereum and it can send and receive ethereum as well so that means that the account 2 can send money directly to the contract the contract could send money back to it and again account one and account two I'm just treating as regular ethereum accounts so ones we already would have talked about anyways the contract has a balance and that means we can go and view the balance we can see every single call and transaction that's happened with the contract everything is completely transparent just like our other regular ethereum accounts great okay so now that we understand that I want to talk about the fact that a contract should really be treated like a state machine so what I mean by that is that most contracts are going to store some type of data so in this case we have x equals one now we need to think of this like the state of the contract and the reason for that is that these contracts are not constantly run they're not just always executing in the background they need to manually be triggered from a transaction to actually do something and so when they're not being called by a transaction they're simply some State that's sitting on the ethereum blockchain okay that's all they are we just have the code we have the values of the different variables so the state of the contract and we can access the state or request to change the state by making some type of transaction okay so let's see now how we actually call a smart contract because I keep saying this for it to do anything we need to call it so calling a smart contract is really just making a transaction that requests some operation be performed on the contract okay so from account two maybe we make a transaction so in fact let's just write TX here representing transaction and this transaction is going to the smart contract now usually what we do is we pick some type of method or some operation we're going to be performing on the contract so maybe we call this a method here like set X and we pass value two now the smart contract can do whatever it wants in this method but maybe all it does is just change the state to two then what we would do is we would simply change this so now X is equal to 2. perfect now when we make this transaction just like any other transactions we need to sign it we need to secure it we're going to have a to address and a from address and we're also going to have to pay a transaction fee which is going to be made up of gas now you can think of gas kind of like a literal gas in the real world in the sense that this contract requires gas to actually be able to execute code so every single operation this is going to perform is going to use a tiny bit of gas it's going to use a little bit of gas and so we send what's known as a gas limit so the maximum amount of gas that we potentially want to use in executing this contract and then if that's enough gas the contract will actually be able to execute it will run through all of the code whatever it will have enough gas to do that it costs us ethereum essentially to execute code on the ethereum blockchain okay now the amount of gas you send in is required is going to depend on what the contract is doing some operations require a lot more gas than others anyways that's pretty complicated we don't need to talk about that for now but just understand stand that what happens is we're passing along gas and the gas allows the contract to actually execute if it runs out of gas just like a car it's not able to do anything else okay so that's it for calling contracts but now let's quickly talk about contracts calling other contracts because that is possible so let's say I have another contract right here and maybe this contract needs to interact with this one maybe it's going to call something on it's going to send ethereum whatever it's going to do so first of all that that's fine these contracts can interact with each other but they can only do that if this interaction starts from stems from is at the root of some account sending a transaction so these contracts if they have no transaction so imagine this guy's gone right here they can't do anything they cannot execute they cannot call each other they can't do anything at all they're just sitting there idle they are State machines however as soon as I have some transaction from any regular ethereum account that goes to a contract now this contract is capable of Performing some operations executing some code whatever and calling other contracts it needs to start though from one of these main transactions there's no way for this contract to call the other contract unless we start from a transaction that I've showed you right here so all of this needs to kind of root from some transaction outside of the blockchain so what I mean by that is from some kind of regular ethereum account so hopefully that makes sense but again you can really think about this in the sense that these contracts are idle not doing anything unless they're called from outside of the main blockchain Network right so from kind of a regular account and so if no account is calling any of these contracts they're not able to do anything and we also need gas which is going to be passed along with the transaction to the first contract call that we make all right so with that said I think that ends the theory section of this video I apologize if this was long but this really did need to be covered now we're going to get back to the code and I'm going to start showing you how to write more advanced smart contracts alright so I am back on the computer and now what I'm going to show you how to do is how to deploy the smart contract to a real ethereum Network so we'll go with the test Network right rather than the JavaScript VM which is going to emulate the blockchain in your browser so what I'm going to do here is change this to injected web3 now when you do that it's going to connect with metamask which I assume you already have set up and it's going to show you the test Network that you have I guess enabled in metamask and the account that you're using for metamask so in this case I have my tutorial account that has a little bit less than one ether anyways in the same way that we deployed this uh when we were using the JavaScript VM we could just click deploy it will automatically compile this for us we don't need to manually compile and it's going to actually bring up metamask because we need to make a transaction to do this right we need to create the contract that requires a transaction so we can look at data this is going to have the contract data we're going to have our details that's going to tell us how much it costs now the bigger the contract is the more this would cost anyways this is relatively cheap I will click confirm okay now this is going to take a second and if I bring up this uh kind of you know terminal here console you're going to see it tells me that it successfully deployed the contract okay so you can view kind of I guess the output of all the transactions and contract calls by just bringing this terminal up right here anyways what we're going to see now is it shows my deployed contracts so this is my deployed contract now what I want to do is actually look at this contract so let's see how we can do that so what I'm going to do is go to metamask here I am going to go to the contract deployment which is right here okay and then you'll see that I can actually click on this button and it will allow me to view the transaction on etherscan now I had some other transactions there I was of course messing with this before the video so you can ignore those ones this is the one that we just crit anyways now we are in etherscan the go rally test Network etherscan right and we can see we had our transaction it was successful and we have the from and the two now what I want to look at is the actual contract address so I'm going to click on that right there now it's going to bring me to the contract address on etherscan so I can see the balance I can see the content creator so this was me right I created this contract at this transaction and then it tells you that the content or the contract sorry was created now we can look at the contract itself so we can actually view the byte code we can decompile that into the source code if we want and then we have events I'm not going to talk about that right now that will be in the next video anyways we can close that I just wanted to oops uh let's go back I just wanted to show you what that looks like uh okay so let's go back to remix all right so now that we have this deployed we can use the contract right so I can access the variable X that's fine it's going to give me the value 21. so one thing to note here is that when you're viewing the state of a contract so we're just looking at the value of x here right viewing the state this is free we don't need to do a transaction it's fine we can query the state that's a free operation and the reason for that is the state is available right like we can go look at the state of the contract because it's stored in there publicly available it's already on the blockchain so we don't need to do any computation we're just querying and viewing a state so that's completely free to do so that's why when I click X here I get this instantly and it gives me 21 because I don't need to actually have a transaction mined to view the state the only transactions I need are when I'm modifying the state of this contract okay or performing some type of computation anyways what I want to do now is change the contract so we can actually update the value of x so this is where we'll talk about functions slash methods so what I can do is inside of this contract I can create a function this will be a kind of a method associated with the contract obviously I need to give this a name so I'll give it something like set X now for the parameters of this function I need to Define first there type and then the name of the parameter so I'm going to say uint underscore X like that this will kind of be my new x value that I want to set X to then I need to give my access modifier for this function now the access modifiers essentially tell people trying to use the contract if this function is private if it is public if it's internal external I'll talk about what all of those mean but you need one of these here so I'm going to say public to define the fact that anyone can use this method so a contract any uh anyone calling this from a transaction is able to use this method because it's public same with this variable X now if we made X private for example you wouldn't be able to access the state of it at least not very easily because it would be private to the contract again we'll talk about access modifiers in a sec for now though we'll just say function set X uint underscore X will make this public then I'm just going to say X is equal to underscore X okay so now when I call this function we will change X Change the value and then when we access it again it will be different pretty straightforward okay so now that we've changed the contract we need to redeploy this I'll do this again to the gorelli test Network so I'll just click on deploy okay we're going to have to confirm the transaction and notice this time it's a bit more expensive we have more content in our contract and so it makes sense this is going to be more expensive right so I'm going to click confirm okay it's going to take a second and then once it's created we should be able to use it and I'll show you what happens when we actually modify X okay so the contract has been created I'm going to click right here and now uh we'll have a new contract so we'll look at that one in a second but for now what I can do is set X so if I look at X right now it's 21 that was free right I didn't have to pay for that I'm just viewing the state but now if I change the state to say 25 so let's set X notice I need a transaction okay so it's giving me a transaction and this is going to cost me a certain amount of gas right so I will click confirm now this is going to take a minute I need to wait for the transaction to be mined okay it was done pretty quickly now if I click X again its new value is 25. so I've modified the state of this contract okay hopefully that makes sense that kind of wraps up all the explanation in terms of how you call a contract with the state of the contract is all of that stuff now we're going to continue looking at some more solidity syntax all right so I've just cleared my code and changed the environment back to JavaScript VM now I'm going to talk to you about a few data types in the solidity so the first one is uint now we've already looked at this it stands for unsigned integer meaning we can store any positive whole number okay so I can do something like uint public X is equal to one of course we know that is found now with the uint this actually allows us to specify the number of bytes we want to use to store the integer so I could do something like uint 8 un 16. you win 32 un 64 unit 128 and then 256 and I believe 256 is actually the default so if you just write uint I think by default it uses 256. I'll put something on the screen that confirms that or not now let's actually just see what happens if we try to store a negative number inside of a uint okay so let me just deploy this contract here we have our smart contract and notice that it's actually not even deploying this right because we would have seen the variable y because we have an error so it's deploying the last contract so the last one that we actually had compiled not this one because we have the error and it's showing that right here okay we cannot implicitly convert negative one to an unsigned integer now of course though we have regular integer right so regular int allows us to store a signed number again just like the UNS we can specify the number of bytes so 16 32 64 whatever now let's run to this one so deploy and let's see what we get here and now we have y so it actually deployed this contract and we can look at its value perfect okay so that is it now other than int we have a Boolean okay so we can say something like Boolean public Y is equal to True let's deploy this now oops I want to close that let's look at this contract here click on Y and notice we get true now of course other than true we have false I assume most of you know what the Boolean data type is just note here there is a lowercase on the first letter rather than a capital if you're coming from python like me okay so we had int uint bull now we also have a dress address payable and mapping and a ton of other data types as well now I'm only going through these ones because these are kind of the core most important ones we're going to use right now there is strings there is arrays but those work really strangely in solidity compared to other languages so just be careful there if you're looking at say a string or an array there's a lot of nuances and kind of details with those okay for now though let's actually not to a string so let's actually just look at the mapping type so the mapping type allows us to take some key and Associate it with some value so I'm going to say public and then we'll just call this map okay now what this means is that I can have some data type for the key and some data type for the value it's very similar to a dictionary or a hash table so when I Define a mapping I need to pick the value for the key or the type sorry for the key and the type for the value so for right now I'm just going to say uint like that is associated with it now just to show you how this works what I can do if I want to set a new mapping is I can say map and then I can put my key like this is equal to my value so if this was a real example I could do something like maybe the map of one is associated with the key of negative two now that means if I accessed map at 1 it would give me negative two okay so this allows you to associate some key with some value very useful you're going to use this all the time anyways that is a mapping again you put the type of the key and then you do this little equal and I guess greater than sign or less than sign associated with whatever the value data type is so right now what I'm going to do is just make a function that lets us actually add a new key value pair to this map so I'm going to say function we'll say set key like that we're going to take in a uint key and we'll take an INT value okay and then we're going to say that this is public and inside of here we'll just say the map at key is equal to Value okay now since this function is actually going to be changing the state of this contract that means we will require a transaction to use this excuse me but since we're in the JavaScript VM we don't need to do that because we're not actually on the blockchain anyways let me quickly go through the syntax so function keyword this lets us make a method or a function inside of the contract or inside of the class whatever you want to call it we then have set key this is the name of that function we have our parameters key and value and we're defining the type that is required for those we then say this is public meaning anyone can call it and we say map key equals value adding a new key value pair to our mapping okay let's deploy this okay so here's our contract let me open this up so we have set key and map now one thing to note is that automatically when you define a variable like this outside of a function so just in the body of the contract it's going to have a getter added for it automatically which means I can access any value in the map so I can do something like map one and we're going to see its default value is zero so in solidity all of our data types have a default value so even though we didn't assign this to something we just declare that it exists if I try to access any key since the value type is int it's always going to give me zero unless we have a different value for that okay so let's just set a key let's set like five with actually let me do this let's set five with like negative 23. I'll click on transact and now to test this I'll see if the key five is associated with negative 23 and it is so we're all good to go now let's do another one let's do like four with negative 10. okay transact let's go four and then notice we have negative 10. perfect there we go okay so now that we have done that what I want to do is talk about addresses and how we actually accept money in the contract as well as pay money out so let's get rid of all this for right now and let's start making some functions that can receive money and send money so what I'm going to do is write function we're going to call this receive and this is going to be an external like this payable function now let's talk about external because we haven't yet seen this so just like the public keyword that we had what external does is it makes it so that this can only be used from outside of the contract so I cannot call this function from within the contract if I did that that would give me an error and the reason for that is because we're going to be accepting some ethereum and when you define this as payable which is what I've done right here this means that we can actually pay money to this function when we call it okay hopefully that makes a little bit of sense we're saying function receive external payable meaning okay we can accept money and we can only accept money from outside of the contract so we can't call this from within the contract whenever you're accepting money you need to put payable when I say money I'm really talking about ethereum anyways inside of here we actually don't need to do anything we can just write the body of this function in fact that's completely fine and now what I'm going to show you is that what we can do is send money to this contract by calling this receive method because it's external pal so what I'm I'm going to do is deploy this okay when I deploy it I'm going to have my contract down here we have this receive function so when we click this red button here what's actually going to happen is we're going to send this amount of whatever this unit is so in this case it's way from this account to our contract okay so this function doesn't need anybody if it's external payable that just means we can pay money to it and so what I'm going to do here is set this to like I don't know we'll go with 10 000 way now way is the smallest amount of ethereum that you can send I believe 10 to the 18 way makes one ether so this is a very small amount anyways it's going to take it from this account in fact let's just send it from another account so we can see if it actually worked let me make it a bit larger and when I click the button again it's going to send that amount from this account to the contract so let's do that and now notice this amount has gone down I have sent some way right there you go makes sense now there was also some gas associated with that that's why it's not perfectly even and the gas limit was right here okay awesome so we said function receive external payable now this contract technically has a certain balance it would be ten thousand way all right so now that we've looked at that I'm going to show you how we can actually view the balance of this contract from a function so I'm going to say function and then this is going to be get balance okay let's spell balance correctly and then we don't actually need anything inside of parentheses and what I can do is make this a public view that returns like this a unit and sorry not units it's going to be a uint and then we can actually write the body of our function now let me just talk about this view keyword because we haven't seen this yet view is saying that this is a readonly method or a readonly function which means it cannot modify the state of our contract so you need to add that when you're writing a function that's going to return a value that's not modifying the state okay that's what we're doing so public view returns unit now inside of here what I'm going to do is I'm going to Simply return the address of this dot bounce now let me talk about this for a second so return I mean pretty straightforward we're turning a value from the function now what address is doing is actually casting this which is referring to the contract itself to an address so this is the address type right we can use this to actually cast this the contract to the address and then on the address type we have balance balance is how much ether is in this account or in this case in this contract now previously you could just write this dot balance however uh in the new version of solidity what you need to do is manually cast this to an address so again this was giving us the address of the smart contract we're then getting the balance and then returning it awesome so let's deploy the contract and see if this works now so I'm going to go here I'm going to send some money to this contract first actually I'll go get balance when I run get balanced notice that we have zero right there's a zero balance and let's now send some money so let's go from this account here and let's just send one ether okay so if I send one like that let's click receive click on get balance and then notice it's going to give me the balance in way okay if I wanted to convert that to Ether I would need to divide it by 10 to the 18 uh what do you call it way or I guess I could just divide it by one ether anyways not super important point is that uh there you go that is how you get the balance okay so now that we've looked at that I want to talk to you about a few Global keywords that we have access to in solidity from our smart contract so remember whenever the smart contract is running it's been initiated whatever it would have had to have been called from a transaction so someone had to send the transaction they had to call a specific function or method and then maybe they sent some ether along with that so we actually have a way to access that information like who sent the transaction so what I'm going to do here is write a smart contract that keeps track of the last person to send it ether so I'm going to make a variable up here I'm going to say this is an address now again the address is just storing an ethereum account address right or the address for an ethereum account so that's the data type there we have access to things like dot balance on an address so I'm going to say address this is going to be public I'm going to say this is last sender so let's go last sender like that and for now we'll just make this equal to nothing okay so it'll have a default value I believe the default address is just a bunch of zeros okay then inside of receive I actually want to set this to be equal to wherever the last sender was so I'm going to say last sender is equal to and then this is where we talk about the global keyword message dot sender so message is something that you can use to access all of the information about the transaction that was used to call this contract now other than message.sender we also have access to message.value now this is going to be the amount of ethereum that was sent with the transaction and we have access to message.gas as well so the amount of gas I believe that's remaining with this transaction okay so let's go and change this back to message.sender and now we can actually use this smart contract and see if it keeps track of who sent the ethereum so I'm going to deploy this okay so we should be deployed let's change to one of these fresh accounts and let's uh actually send one ether in the receiver okay so I'm going to send that one ethereum let's check the balance okay now the balance or sorry this is wrong contract I want to use this contract okay let's send one ether okay so go receive now let's check the balance okay so we have one ether in here and now if I go last sender it gives me the address of the account that actually send this ethereum so now let's change this to be let's go with this account let's send two ether okay get the balance we now have three ethereum inside of here and the last sender has now changed okay there you go that is how you keep track of the actual last sender of ethereum now what I would like to do is I want to show you how to send ethereum from the contract back to a different ethereum account okay because right now what's happening is we're sending ethereum to the contract but the contract's not sending anything back obviously that's not ideal we need a way to you know pay people back from the contract so let's do that so what I'm going to do is write a function I'm going to say function this is going to be pay this is going to be address payable addr and then this is going to be public like this and then payable now let's just quickly go through this so the reason I have the payable here is because whenever I want an address or whenever I want to be able to send ethereum to an address I need to specify it as payable so address payable is different than just regular address this actually allows me now to send the money to this account if I don't have payable then I won't have access to the methods I need for this address to send the money to so just make sure you put payable then we're going to have public payable now since this function is going to be paying money out it's payable if you're going to be sending money or receiving money you need payable then of course this is public which we've already talked about so inside of here there's a few different ways that I can actually send a theorem now some are simpler than others unfortunately though there's a bunch that have kind of some issues with them and that are not recommended to use so the ones you should not use are the following addr dot transfer okay now I know I spelled that incorrectly but you should not be using transfer okay there's some problems with that I'm not really going to get into them and then we have dot send again and there's some problems with this don't use this instead what you need to use is the most complicated one funny enough which is going to be something like this so let me just type it out then I'll explain it this is going to be bytes memory and then it's going to be data and this is going to equal to addr dot call and then we're going to say here that the value is equal to and whatever the amount of ethereum is we want to send and then we're going to call this with one argument okay I believe this is correct let me move this over a bit so we have some more room okay so function pay address payable addr public payable and then we have this kind of crazy line right here so first of all what this is going to do is it's going to decompose the return value of this into two variables first Cent and then second byte memory data now this first one right here is going to be a Boolean variable telling us if this was successful so if it was successful this is going to be true otherwise it's going to be false there's a variety of reasons it could be unsuccessful one of them being you don't have enough money in the contract to send okay then we have bytes memory data now this is going to give us the data of this transaction now you don't really need to worry about this too much in fact I'm not really going to explain it but memory is specifying that we want to store this data which is a reference type in memory again I'm not really going to talk about this much more just write this for now we'll worry about this in a later video then what does this do so what we're doing is we're saying address dot call okay and then inside of curly braces here we're passing the value which is the amount of ethereum we want to send now optionally we can actually choose the amount of gas that we want to send as well so forward with this transaction you don't need to do that you can just leave it to the default value which is what I'm going to do and then we call this whole thing with a string now this is going to be the message that's going to be sent to our uh what do you call it to our transaction or with our transaction so you don't really need to put anything here for right now it just requires one mandatory argument so that's why I put in empty string okay hopefully this makes a bit of sense again address dot call Curly braces with the amount of ethereum that you want to send and then this is setting up the transaction and this is actually going to execute it when you do the kind of parenthesis call right here with the string argument anyways what we can do after this is we can check if this was successful or not and the way we do that is we could use an if statement so ifs do exist in solidity or I can do something like if sent or I can use this fancy thing that we haven't seen yet called require now what require does is similar to an assert statement because it's going to check the value of a condition or a variable and if that's true we're going to continue everything will be fine if that's false it's going to throw an exception and actually tell whoever called this smart contract that there was an issue with that call so I'm going to say require sent and then here I can put an error message so I'll just say error sending money okay like that or error sending let's just go with f okay so again if this is true all is good we will continue if this is false then it's going to tell us that there was an error because we were unsuccessful in sending this ethereum all right now let's add our semicolon and what I can do is deploy this and test it out okay so let's go back here and let's deploy this let me close this contract okay so we have our deployed contract we have pay receive get balance and last sender so let us receive some money first so let's send one ether from this account so let's go receive okay last sender is this get balance is one now let's copy this guy's address right here by clicking on copy let's paste it in here let's click on pay and I think everything should be good we can go back here now and we can see uh if we were paid the ethereum or not all right so I thought something was going wrong until I realized that we actually are only sending a hundred way here rather than an entire ethereum which is what I thought we were going to be sending so what I'm going to do is change this to one ether now ether is actually a builtin word or builtin keyword in solidity and it will just multiply this by 10 to the 18 so that will give me I guess 10 to the 18 way right so one ether anyways I'm going to change that to one ether so now this will pay one ether from this function okay so let me redeploy here and let's close this okay and now we have our contract so let's receive some money so let's go from this account let's just send like five ether okay so let's go receive what's the balance five ether now let's copy one of these okay and we will pay it and let's see if this is all good I'll move up the console and looks like it's sent fine okay so now let's go here and we should see that in one of these accounts we have okay almost 101 ether right so I have 100.9999 because there was gas associated with the transaction so we didn't get a full one ether we got a little bit less perfect there you go that is how you send money using I guess this right here using this line okay great so now that we have that what I want to do is I want to end by quickly writing kind of an example of a bank that allows people to send ethereum to the smart contract and then withdraw up to the amount of money that they had sent to the contract so if I send one ether I can withdraw up to one ether from the contract as soon as I try to withdraw more it's going to tell me hey you don't have a sufficient balance so kind of just like a very simple bank account so let's go ahead and do that all right so let's get into this example of implementing kind of the basic bank accounts so I'm actually just going to get rid of all this we can just rewrite it this will be good practice so I'm going to start by making a mapping and this mapping is going to allow me to associate an amount of ethereum with an address so that way I'll know how much a specific account has sent so far and so I can regulate how much they can withdraw so what I'm going to do here is say mapping and this is going to go address like that and then this will go to an unsigned integer which will be the amount of way that they have sent so amount of ethereum okay then I will call this balances and I can actually manually make this private if I want now when I make this private what that means is there won't be a default getter for this so I can't easily just access the balance of a specific account instead I'll have to use one of the methods or functions that we Define okay now we need some way to receive money so let's write that we're going to say function and we'll say deposit okay and then this is going to be a actually external and then payable okay now what I'm going to do is I'm going to say balances act and then this will be message dot sender which is going to be the address of the sender of the transaction is equal to or sorry plus equal to message dot value okay so remember all of the keys here are going to have a default value of zero so even if this address doesn't kind of exist yet in the balances it's going to have a value of 0 when I access it so I'm going to add message.value which is the amount of ethereum they deposit okay then of course if this already existed I would just be adding to it whatever the amount of ethereum is they deposited in this transaction that's all I need for here I'm just adding this to the balances then what I'm going to do is say function withdraw and this is going to need to take in an address to withdraw to and in fact I don't necessarily need to do that uh because what I could do is just use the message.sender address so whoever was withdrawn whoever sent the transaction I just automatically give the money to them but instead what I'll do here is just put in an actual parameter so that you could technically withdraw your money to someone else's account hopefully that makes sense but you'll see what I mean so I'm going to say address payable and then this will be addr and then we'll say this is going to be a public and then this will be a payable function like that okay so what I need to do here is I need to check that they have a sufficient balance in the uh the balances before they can withdraw something I also need to take in the amount that they're going to withdraw so I'm going to say uint amount like that and this will be the amount in way that they want to take it okay so we'll say withdraw payable amount okay great that's fine now inside of here what I'm going to do is I'm going to confirm that they have a sufficient balance before I let them withdraw so I'm going to say require and I'm going to say balances at addr is greater than or equal to the amount that they want to take out okay perfect so we'll do that then I'm actually going to send the ethereum to them that they want to withdraw so we're going to say I guess this is going to be bull sent and then this will be bytes memory and then what was this data is equal to and then addr dot call and then this is going to be value colon amount okay and then I think I can just call this like that okay so that's good now that I have that I'm going to confirm that they sent it successfully so I'm going to say require sent and we'll say could not withdraw okay we got to spell this properly this is just okay there we go could not withdraw and then what I'm going to do here after I successfully check if they withdrew or not or after I check that they successfully withdrew I'm going to subtract their balance I'm going to say balances and then this is going to be at message dot sender minus equals the amount okay I think that should be good now let's just run through this and make sure we understand so first we're requiring that their balance is greater than the amount so if the balance that they currently have in our kind of bank here is not greater than the amount then we actually need to give them an error message and we'll say in sufficient funds like that okay I think that's how you spell insufficient that should be fine all right and then what we're doing is we're trying to actually send this amount to them so if they have a sufficient balance we'll try to send it to them if this for some reason does not work then we'll tell them that they could not withdraw and we'll keep the balance here right because if we didn't send it then the balance is not gone we still have the money in the contract otherwise we will subtract their balance and then we're good to go okay so now we have deposit and withdraw and if we want to we can write one more function here let's go function get balance and this will just give us the balance of a contract okay so let's just go public view returns unit okay and then let's return the address of this dot balance and that should be good okay now we could also write something that allows us to get the the balance of a specific address or we could just make this public but for now I'm going to leave it private okay hopefully that is all good now what I'm gonna do is just deploy this contract so let's deploy it let me get rid of this one now what we can do is deposit some money so let's go to this account let's deposit 10 ether okay so we're going to deposit uh that should have happened successfully let's check the balance looks like we have 10 ether now let's see if we can withdraw so let me copy this address okay so I'm going to paste that in there in fact let's make this larger and for the amount I wish I could copy this uh let's just go with a bunch of zeros here I don't think I can write F directly in here otherwise that'd be useful okay so let's click on transact and let's look at our console here and see if this was good okay it looks like we successfully sent the way so now if we go we see we have 85 ether rather than 84 which is what we had before so let me see if I can make this something like five now and click transact okay looks like that was successful I guess we're not passing enough zeros okay now we have 85.599 okay now let me try to send an entire five ethereum which we know we don't have for this person actually maybe we do because I think we transacted 10 ethereum sorry but let's try this okay transact and that was successful now let's try this again and notice that when I try to do it again I don't have enough ethereum for this balance so I get insufficient funds as my error message okay if I look at the balance of here we have 4.4 ethereum left in the contract so now let's try to do this from another account so let me copy this address and let's see what happens if I try to withdraw say one ethereum from this address okay if I do that notice we get an error it says uh insufficient funds because this address is not yet deposited any ethereum so let's now deposit some so let's make this one ether let's click deposit okay now let's try to withdraw and notice we're able to withdraw that successfully all right so that is all I have to show you for this example here hopefully that was a decent introduction to solidity I understand there was a lot of stuff covered in this video I don't expect you to know all of it I just wanted to kind of show you how to create a basic smart contract how to send ethereum receive ethereum and then hopefully give you a bit of an idea behind the theory of how smart contracts actually work in the next video we're going to continue learning more about solidity I'm going to show you some more advanced things that we can do and then in future videos we'll talk about some of the limitations of solidity and how to make things more affordable using cartesi which is the sponsor of this video and this series hope you guys enjoyed if you did make sure to leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to another video in this blockchain for beginners tutorial Series in this video we're going to be continuing from the last video and learning more about solidity once we learn a few new topics then we're actually going to work on an auction where we're going to be auctioning an nft now this will work with any type of nfts this is really really cool and if you're interested in nfts you're going to learn a little bit about how they work so with that said we'll get into the content in a second but I do need to thank cartesi again for sponsoring this video and this series they are an awesome company they've been helping me come up with the content for this series and they have a bunch of scaling solutions for ethereum and for developing smart contracts that we're going to look at in a future video regardless let's go ahead and get into the content alright so I'm back in remix and in front of me I have the example that we finished in the last video which is kind of a mock bank account now what I'm going to do is just give you a quick recap of everything that's in this contract so we understand the syntax and get a quick refresher then we'll look at some new solidity features and we'll actually move into working on that auction which is going to be the bulk of the video okay so right now we can see we're inside of a DOT Sol file now the dot Sol stands for solidity and that's the extension you need for your solidity smart contracts now at the top of our contracts we need a pragma line now the pragma line is going to tell solidity what compiler version we should use so in this case we're using 0.8.10 to see the compiler versions you can go to the solidity compiler extension click here and then it will show you the versions in this case 0.8.10 is one of the latest so that's the one that we're going to use great we then Define our contract we say contract my contract open the curly brace and close the curly brace and inside of here is the content of our contract now it's worth noting that you can Define multiple contracts in one solidity file and you can have stuff like contract inheritance that's a little bit complicated we don't need to look at that here but just wanted to mention them okay so inside of our contract here we start by defining what most of you would consider a class attribute this is just going to be actually a private member of this class because we've defined it as private anyways this is a mapping type now the mapping type is like a hash table or a dictionary where we have some key that can be associated with some value now in this case we're having an address this is going to be an ethereum address being associated with a uint so an unsigned integer we then denote this as private meaning we can't directly access this from outside of the contract and then we have balances that's just the name of this mapping okay now we have a function the function is called deposit it's denoted external and payable now external says that we can only call this function from outside of the contract so I couldn't go here and do something like deposit that would be invalid because this is an external function then we have payable payable is saying that this is either going to be sending money to someone or receiving money or specifically ether and in this case since we're going to be getting money we have to make it payable then what we do inside of deposit is we say balances at message dot sender now message.sender is going to be the address of the sender of the transaction who's sending money to this contract so essentially whoever invoked the call to this contract or made the transaction to this contract it's going to be there address we're adding that as a key to balances and then we're going to increment the value here by message.value now message.value is going to store the amount of ether that they sent to this contract and the reason why we can do this is because the default value of all of our uins inside of our mappings is going to be zero so even if this sender does not already exist in the mapping we'll simply make the value equal to whatever the message.value is because the default value is zero hopefully that makes sense that's explained in the previous video in case you are confused regardless we now have withdraw so withdraw is going to take in an address payable this is going to be our addr that's going to take in uint amount now this means that we need to pass an address to this withdrawal function this is the address that we want to withdraw funds to then we have u in to mount this is the amount of funds that we want to withdraw from the contract now this is a public payable function when we say this is public that pretty much means it can be called from anywhere and then we have payable and again what payable means is we're either going to be sending money out or receiving money so of course we need to denote this function as payable okay we then have a require statement and what the require statement is going to do is it's going to check if this condition is true and if it is not true then it's actually going to raise an exception and the exception is going to be insufficient funds that means we're actually going to cancel the entire contract call everything that would have happened is going to be reverted I'm going to talk about this more in a second and essentially this transaction is going to fail because this condition was not satisfied okay so you use require when you want to ensure that something is true before proceeding in the contract okay so we're requiring that the balance of the address is greater than or equal to the amount that we want to withdraw makes sense if we don't have that then the error or the exception is insufficient funds so next we're actually going to send money from the smart contract to this address if they had sufficient funds to withdraw so we're going to say bull sent bytes memory data is equal to 80dr dot call and then we're putting the amount that we want to withdraw and then we're actually calling this transaction now if you're confused on how this line works I spent about three or four minutes explaining it in the last video so you can go back and watch that essentially all this is doing is sending money to this address this is the amount of money that it's going to be sending or the amount of ether great then we have this bull sent now this bull sent is going to be equal to true if we successfully sent this otherwise it's going to be equal to false so if we were not able to successfully send the money some error occurred there then we're just going to raise the exception could not withdraw otherwise what we're going to do is we're going to update the balances so we're going to say balances at message.sender minus equals the amount to make sure they can't just keep withdrawing the same amount of money it's actually going to subtract from their current balance when they withdraw great then we go to this function so this is get balance now let's say public view function now again public means we can call this from anywhere and view actually means that this is only going to be returning or accessing state from this contract it's not going to be modifying it so this means we can call this get balance function without actually having to make a transaction which pretty much means this is free to call so this is a good point in time to remind you that whenever we're just accessing the state of a contract this is free we can just query the state of the contract we don't need to pay for this however if we're going to be actually modifying the state then that requires a transaction that transaction needs to be mined and well that means it's going to cost us some money at least in gas and potentially ethereum if what we're doing requires that we send ethereum Okay so let's continue explaining this we then have returns and then you wins now returns is just stating what this function is going to return we're saying u n standing for unsigned integer and then here all we're doing is we're returning the address of this now this is just going to be the contract we're just going to cast this to its actual address and then we're going to get the balance whenever you have an address you can access the balance by just using dot bounce there you go that is everything that we did inside of this contract so now that we've talked about all of this I just want to spend a second talking about exceptions because we've seen them in this contract but I haven't actually talked about exactly what they do and how they work so in solidity we have a few different ways to actually throw an exception or to cause an exception to occur now an exception is pretty much an error that's going to occur in our program and all exceptions in solidity are State reverting now what that means is if there's ever an exception at any point in time during the transaction call then this is going to revert the state back to what it was previously any changes you've made up until that point will be completely removed so just to give you an example here let's say that I did something like balances at one is equal to two now I know this makes no sense but let's say I did this right here and then I come to this require line and this actually ends up raising an exception because Cent is equal to false well if that's the case this line will be completely reverted we won't actually have done that operation it will be undone and reverted back to what it was before so just worth noting whenever an exception occurs any of the state in the contract that's been changed is going to be reverted now require as I'm kind of alluding to here does cause an exception right so if the condition here is not true then it raises an exception and the message for that exception is going to be whatever we put here now there's a few other ways that we can raise exceptions in solidity I'll quickly show them to you although we're not really going to look at an example of them so one way to raise an exception is to use revert now revert actually allows us to just directly uh revert the entire contract State again this is just going to raise an exception exactly like require will except inside of here we can just put our error message we don't actually need to put any condition so if we ever encounter a revert in the program we're just immediately going to raise an exception the exception message will be this and again that's going to revert the state because that's what all exceptions do in solidity okay so that's revert now another thing that we have is assert now assert is similar to require in fact it works in the exact same way except it's designed to be used when you want to check in variants rather than checking input validation so I'll show you here I could do something like assert uh true is equal to true now of course that's always going to be true but you get the idea now if this condition was false what would happen is we would raise an exception with this as the error message now assert and require are pretty much identical but the reason you use assert is because you're checking an invariance if you don't know what that means don't worry about it and if we're using require we're using that when we want to check input validation okay so that's why we're using require here because we want to ensure that the amount that they passed in is valid now in this case we could probably actually replace this require with an assert it's not a huge deal and there's actually not really any formal recommendation on which one you should use but it's kind of the standard to just use assert when you're checking an invariant and require when you're checking input validation so in this case based on what I'm saying we would use assert here because this is an invariant but we also can just use require like I had before that's completely fine anyways this isn't super important but I just wanted to show you those methods in case you see them in other contracts alright so that's almost everything for exceptions one more thing to note here is that the only thing that will not be reverted if an exception occurs is low level calls like this addr.com now I can't really show you what the other calls are because we haven't seen them but essentially if you were to send money to someone successfully and then later on in the contract there's an exception that occurs that's not going to be reverted you just can't revert that because once the funds are transferred well you can't really just transfer them back and so if I did something like this and let's say that this was successful then that means this is not going to be reverted now everything else will be reverted this balances will be changed back but this isn't going to be reverted the ethereum that was sent to that account is not going to be sent back to the smart contract okay there's some good reasons for that but that's worth noting now a few other things to mention here with exceptions exceptions are cascading now that means if I have an exception that occurs in another smart contract that I'm calling from this smart contract that's going to mean that the state of this contract as well as the state of the other one are going to be reverted so it's kind of hard to show this but let's say I make a contract and I call this my contract two like this and let's just make some functions so we can do something like function test and then just make this public view returns you ins okay and then maybe what I do here is I just say revert okay so that's what I do now if I call this function okay from inside of here then even though it's happening inside of this contract the exceptions occurring here it's going to Cascade into this contract meaning that if any of the state was changed inside of here that's going to be reverted and same with any of the state inside of my contract too hopefully that makes sense but just keep in mind that exceptions Cascade so even if you have like 10 contracts all calling each other and then in the 10th contract an exception occurs every single one of the contracts that we're dealing with that contract are going to get the cascading exception and all of them are going to have their state reverted and the transaction will fail now just to note here the reason why we're getting this error is because I didn't have the semicolon of course revert is fine I can put this here although this doesn't really make much sense because why would you just just revert inside of a function alright so now that we've talked about exceptions what I can do is start showing you some new features in solidity and the first thing I want to do is show you a Constructor so I'm just going to clear everything that's inside of this contract and I'm going to write a public variable here so I'm going to say let's go with address and this is going to be public and then I'm going to say that this is the owner of the contract so what I'm going to show you is a Constructor now a Constructor is simply a special function that's a part of a class or in this case a contract that's going to be called when the contract is initialized now in solidity your Constructor will be called exactly one time and just like any other language Constructor you can accept parameters in here you can do some setup steps and well you'll see how this works so the way you implement a Constructor in this version of solidity is Constructor open and close parentheses open and close curly brace and then inside of here you can do whatever you want so in this case I'm just going to say my owner is equal to the message dot sender now the reason I'm doing this is so that I can keep track of who actually created this contract so when I create a contract I have a message dot sender whoever sent the transaction to actually create the contract so this is perfectly valid I can say my owner is equal to the message.sender and now whoever deployed the contract will be the owner and I'll be keeping track of that inside of this public variable on the contract okay pretty straightforward that's how that works now again this is how you do the Constructor you can only have one of them and this will be called exactly one time and only one time when the contract is deployed this isn't going to be called every single time a transaction is sent to the contract it's only called when it's deployed the very first time so let me show you how this works let's go and actually deploy this to the JavaScript VM let's click on deploy okay we have our contract when I click on owner it's going to give me the address of this account right here which is the one that I'm using now let's try deploying from this account okay so deploy my contracts down here owner now it's giving me the other own pretty straightforward that is how the Constructor works and this is a pretty common thing that you'll want to do is keep track of who actually deployed the contract now another thing you can do in here is accept parameters so maybe I just want to accept a uint and let's just go with something like test for now again this can really be anything okay I want this to be test and then what I will do is say you int public and let's just go with I don't know V I'm just picking random names for now and I can do something like V is equal to test that's completely fine I can access the value of this parameter so now let's get rid of these contracts all right so now we can deploy our contract and notice where the deploy button is it's actually giving me a parameter that I need to pass here it's saying task this is a uint256 so I'm going to do something like two hit transact now I go to my contract I have owner and I have V and I can see V is equal to two there you go that is the basics of the Constructor now of course you can have multiple arguments if you would like or multiple parameters sorry and do whatever you please with them great so what I'm going to do now is just get rid of everything inside of here and I'm going to start talking to you about a new thing which is called a pure function now we've looked at view functions we've looked at payable functions internal functions external functions public functions now we want to look at pure now a pure function is pretty straightforward but it is simply a function that is not going to do anything with the state of the contract you can kind of think of it like a static method because it has no access to the internal state of the contract it just does some type of computations then returns some value so I'm just going to write a function here I'm going to say function and this will be something like add to now we will make this a public and then this will be pure function and this is going to return a uint like that now I'm going to take as a parameter here the uint X and all I'm going to do is just return like this X Plus 2. okay very straightforward but this is a pure function now as I said a pure function is not going to modify or access the state of this contract it's just going to be performing some type of computation that doesn't rely on the actual contract internal state so just like accessing the data from a contract this is going to be free as well we don't need to pay to do this and let me prove this to you so if I go to my injected web 3 now I'm connected to the godreli test Network and I do deploy this okay it's going to ask me for a I guess transaction because when I deploy I need to pay for that and then let's give this a second okay we can see that our contract is deployed now let's do something like add to five notice it gives me the value 7 back I didn't need to add a transaction to be able to do this okay so whenever you have a view or a pure function these are free you don't need to have a transaction to call these so if you ever just want some type of utility functions associated with your contract then you make them pure okay hopefully that makes sense that's all I need to cover with pure okay so now that we've gone through that we can start getting into the important stuff which is events so I'm actually going to hop over to the drawing tablet to explain to you what events are and then we'll start implementing them when we work on the auction all right so I'm now on my drawing tablet I'm going to start explaining events to you but before I can do that I need to talk to you about why we need them so in front of me I have a smart contract now this is going to be our auction contract and on the auction we're going to have some function called start now of course we're going to have some other functions as well but for now just imagine we have start and what start is going to do is it's going to attempt to start the auction so it's going to modify some of the state and then it's going to return a value indicating to us whether or not this was successful so we're expecting this to be a boo let me just write this right here indicating it's going to return a boom okay that's great so now we want to start the auction so let's say we have some account so account one like this we know since this is going to modify State we need to make a transaction to the auction to be able to start this so I'm going to make a transaction we're going to call start on here and then what we're expecting is that we're going to get some return value here indicating to us whether or not this started successfully well if we're just working on our JavaScript VM then we know that it's actually going to work successfully we're going to be able to get a return value we'll see something like true or we'll see something like false however if we're working on a real blockchain we're actually not able to return something from a function that's modifying the state back to our account so essentially whenever we're making a transaction we can't return data back to that transaction now this actually makes sense if you look at how transactions work but for now you really need to understand that if you ever make a transaction to a Smart contract that contract cannot return you any day data now it can try it can have a return statement but you're not going to be able to view that return data from the transaction so really we have to imagine that this is going to be a oneway operation where we're just going to call start now if an exception occurs we're going to be notified of that however if an exception doesn't occur we're not going to get any return value so trying to do something like this is not going to work on a real blockchain now that's a pretty big problem right because in a lot of situations when I make a call or I make a transaction story to my smart contract I probably want to get a return value I need some information I want to know if this started successfully however we can't have a return value so how do we get around this problem well the way we get around this problem is with events so what a smart contract can do is it can actually emit events now that means that what we can do from auction is when we start this we can create or emit something known as an event and this event can have a return value that we might want this account to be able to see so we can emit an event that says something like started and then maybe we can put the time that this started out and we can put if it happens successfully or not so we could but true or alternatively we could put false now these events will be stored on the blockchain however they're going to be stored in a different way than the data associated with your contract so any of the variables you would have defined or kind of the state of the contract is said to be in storage these events are not going to be in storage they're going to be stored as a part of the transaction history on the blockchain so that makes them a little bit less accessible however they are much cheaper to use because of the way that they're stored so I'm not going to get into this too much but essentially just understand that your events are stored in a different way that makes them much cheaper to actually store although they are a little bit harder to access so that means that you usually use a thirdparty tool maybe something like etherscan to actually read and query these events because it's not as simple to go directly look at them like it is for the data on the contract and so we emit this event and then this account here or some external client that's off the blockchain is able to view these events and subscribe to them so they'll be notified if an event occurs now I'm going to get into a detailed example in a second but for now just understand that whenever we have a transaction our smart contract cannot return a value to that transaction instead what it can do is emit an event this event will be stored off the blockchain you can kind of think of these events as a log right we'll be able to then view those logs off of the blockchain and we can search for specific data inside of those logs and subscribe to events which means we'll be notified when an event occurs now just an important note here this is not the case the so the no return value thing is not a case if we're making a call not a transaction now I understand this is a bit confusing but if I'm making a call to a function that does not modify the state so that doesn't require that I spend money on it doesn't need a transaction essentially I'm just querying the state then of course I can get a return value right if all I want to do is just get some data that's stored in the state of the auction that's fine I can do that I can get a return value but if I make a transaction that modifies the state that's the situation where I can't get a return value okay hopefully that makes sense but that is why we need events so now let me clear the screen and let's get into a more advanced example alright so for this example what I want to do is imagine that we're trying to build an application that's going to be partly on the blockchain that's going to allow us to auction our nfts again we still have this auction this is our contract but now what we probably want to do is we probably want to make a nice beautiful user interface that allows users to interact with this auction so to interact with the auction the owner of the auction is going to need to start it and then once it's started we're going to be able to accept bids right now the bid will be a certain amount of ethereum and we'll need to keep track of what the current bid is who's currently winning the auction we need to know when the auction ends and all of that logic again will be handled by auction however we want a very easy way for users to be able to interact with the auction contract I don't want them to have to write some really low level code and send their own transactions instead I want them to just be able to connect their blockchain encounter their ethereum account with my user interface and click this nice big button that says bid okay so they're going to be using my user interface all of my clients are going to have a different instance of the user interface maybe this is something like a react app or something like a JavaScript client whatever right so let's say we have kind of two user interfaces here and we have two people that are bidding against each other just for Simplicity so I'm going to say that this is number one and this is number two now the concept here is that this person is going to press the bid button it's going to send a transaction to the auction it's going to send maybe one ethereum and well that's going to be their bid and then this person maybe they want to send a bid maybe they send a bid of two ethereum now this is all great but again we run into this problem where I want these user interfaces to be able to be updated whenever another bit occurs so essentially if I'm sitting right here I want to know that number two just made a bid so that I can then bid again and I can bid three ethereum right now how do I do that well since I can't get a return value here and since my auction can't send something to my user interface it's not able to do that what I need to do is use my events so what's going to happen is every single time I make a bid an event is going to be emitted so I'm going to say omit and then I'll omit an event that's going to be something like let's write this properly something like bid 1f and then it will be from number one and then it will probably give the time that this bit occurred and a bunch of other information but the idea is we're going to Omit all of these events and then what we can do is we can have these user interfaces subscribe to the events so when they subscribe to the events what's going to happen is they're going to be notified when an event occurs and then they can use the data from the event to update their user interface and tell the user hey you just got outbid do you want a bid again or hey the current bit is this or the auction ended or whatever you get the idea but the concept here is we have an external client right so our JavaScript clients kind of sitting on some type of user interface they are subscribed to the events that this contract is going to be emitting and whenever the contract emits an event they'll be able to update their user interface and they could say query the state of the auction if they wanted to they could do that for free because that doesn't require a transaction hopefully this makes sense but that is the point of events and this is kind of how you would start building out a very simple blockchain application you would deploy your smart contract this would be kind of your source of truth right this would handle all the complex logic then you would have your nice user interfaces that allowed the user to interact with the smart contract and be updated of things that's happening with the smart contract because the smart contract can only do some type of operation when a transaction is performed so you need some type of external client sitting listening for events and updating the user then the user can trigger those transactions to the smart contract when they actually want to do something that is State changing perfect there we go we Now understand the importance of events let's go ahead and go back to the computer we're going to start writing out this auction contract and looking at events alright so I am back on my computer in remix we're actually just going to start working on the auction contract and then as we work on that I'll show you events so I'm going to change the name of my contract here to auction because that's going to be a bit more fitting and I'm going to implement a bunch of public things that we need here for our auction so if we're thinking of an auction we're going to have a time span for this auction so we need to know if the auction has been started if it's ended how much time is left so when the auction is actually going to end we want to know all of the bids we want to know who's selling the nft we want to know what the current highest bid is and who the current highest bidder is and we also need to know what nft we're selling but we'll deal with the nfts later because that's a little bit complicated so for now what I'm going to do is say address payable it's important we do payable here because we're going to want to pay this person who you'll see is the seller so we're going to say address payable public seller now it needs to be payable because well the seller of the nft we're gonna have to pay the profits of the auction so whoever you know the highest bidder was we're going to take money from them and send it to the seller okay now other than that we're going to need to know when the auction started so actually we don't need to know when it started we just need to know when it's going to end if it started and then if it's ended so I'm going to say Bool and then this will be public and this will be started we'll then say Bool public ended and we'll say bull or sorry not Bool this is going to be you ins and then this will be public if we could spell this correctly and then end at and this will be the time that we actually are going to end the auction at now other than that we need the highest bidder so we're going to say U int or sorry we want the highest bid so I'm going to say UNS public and then this will be highest uh bid like that and then we will have a dress and do I want this to be payable let me look at my cheat sheet here no I don't think we need that to be payable we'll just say address public and then highest bidder like that uh and that should be good now other than that we're going to need some mapping to keep track of all of the bids that users have made to this contract so the idea here for the auction is that when you make a bid you have to send money to the contract so if you don't actually end up winning the nft then you need the ability to withdraw your money right so we're going to have a withdrawal function that allows you if you didn't win to actually take all your money back from the contract so I'm going to say mapping and then this is going to be address and this will go to a uint and this will be a public and then this will be bits now the reason all these are public is because I don't need to hide any of this information it's fine if everybody sees it and I want people to be able to see when it started when it ended what the end that is what the highest bid is because you want people to trust this contract that's the whole point of writing smart contracts right okay so now that we have that I'm going to make a Constructor I'm going to say Constructor like this and all I'm going to do is simply assign the seller so I'm going to say the seller is equal to message Dot and then this will be sender so whoever deploy the smart contract will be the seller of the contract now notice I'm getting an error here it's going to tell me that the type address is not implicitly convertible to expected type address payable now I didn't show this to you previously but the way that you can convert a regular address to a payable address is you can just say payable like this and then surround what you want to convert so now this address that is nonaddress payable will be payable and I'll put that in inside of seller okay now what I'm going to do is Implement a start function this function will allow only the seller of the nft to start and they'll need to pass all the nft details to be able to start the auction now we won't implement the nft stuff right now as I mentioned we'll do that at the end so I'm going to say function we'll just call this start then this will be public external okay so we're going to call this from outside of the smart contract and inside of here what I want to do is I want to require that the message dot sender is equal equal to the selling otherwise I will say you did not start the auction exclamation point okay and then we'll go with semicolon now what's the error here it says visibility already specified as public okay so that's my bad story I'm just going to make this external uh because you can't have public external those are going to be you know messing with each other so external is fine now what's the warning uh function State mutability can be restricted to view okay that's fine we're going to change that later okay so now what I'm going to do is I'm going to say started is equal to true and then what I need to do is pick the end at date now this is going to be a little bit weird because we haven't seen this yet but I'm going to say end at is equal to and this is going to be block Dot and then time stamp plus and then seven days now we can actually change this so that it's not days and in fact let me check if that's correct okay actually I think seven days is correct so first of all let's just explain what this line is because I haven't covered this so block is actually referring to the block that this transaction is a part of once it's been mined right so once it's been mined it will be a part of a block and the block is going to have a time stamp that's when the block was created so this is going to give us the relative timestamp of the transaction it's not going to be precisely when we sent it but it will be very close to that because blocks are created very very quickly in ethereum and then we're going to add seven days to that and days is a keyword just like ether in remix so I can or sorry not in remix but in solidity so this way we're just going to add seven days to this timestamp which means we will end seven days after this so of course feel free to modify the number of days I mean you can make this one day if you want two days whatever it doesn't really matter in fact let's just go with two days for now about whatever you set this that's going to be the amount of time the contract or sorry the what do you call it the auction will last for okay so now we have start however what I want to do is add one more require here that just makes it so we cannot start this Con contract if it's already started so I'm going to say not started like that and then I'll say already started exclamation point and what I want to do is I want to Omit an event saying that I started the contract so now we're going to talk about how we actually Implement events now creating an event is actually pretty straightforward you first need to declare an event in the body of your contract so I'm going to do it up here I'm going to say event and then start and I've just created an event now we need to Omit these events but this is an event that is omittable so what you do is you put the keyword event you then put the name of the event in this case I'm going to go with start now notice I'm starting it with a capital because the convention here is Pascal case just like our contracts and then inside of the parentheses you put any arguments you want the event to accept so you could put for example the address of the person who started the event now that wouldn't really be very useful because the only person who can start the event or sorry start the contract or start the auction is going to be the seller but you could put any other data you want here you don't need to put the time because that will automatically be associated with events whenever they're omitted but I can put any data inside of the parentheses and then I pass that data as arguments when I omit the event and that'll be like the data of the event we'll see this in a second right now for start I don't need any arguments so we won't look at that right now but when I do events for a bid I'm going to have the address of the person who bid the amount they bid Etc right okay so anyways we have an event to find which is start and now if I want to emit an event this is really straightforward I just do omit and then I put the name of the event like that okay there you go I'm now emitting the start event now if start was accepting arguments I would pass them right in here so whatever the arguments are right okay there we go pretty straightforward so now that we have that let's deploy this contract let's deploy it to a legitimate Network right so I'm going to deploy it to the go rally test Network and then I'm actually going to go look at the events of my smart contract and show you how you can view them off the blockchain on etherscan so let's do this I'm going to click deploy and then once it's finished I will let you know okay so the contract has now been deployed so I'm going to click on the contract deployment here I'm going to view this on etherscan notice it says that it was successful so what I'm going to do now is Click right on the contract so notice it says contract here it was graded so I'm going to click on that and when I go here we can see we have the hash of the transaction that created the contract then I can click on events now when I go to event notice we don't see any events now that's because we haven't triggered any yet but I'm now going to trigger an event and show you that it will show up right here okay so let's go back to remix let's now go to our contract and let's start by just clicking on some of these so we can see the seller is it started no it's not started so let's start it by clicking on start now when we do this of course we need a transaction because this is going to modify the state so I'm going to click on confirm okay this is going to take a second to complete and let's just go here and it should tell us when this is done then we can go check the corresponding event that would have been emitted okay so this is finished now so let's go back here and let's refresh the page and notice that we have an event now the event is start okay and I can click on this right here and kind of view some of the details now the method will actually be the method that we called in the transaction now this is going to be a special hash of this method I'm not really going to describe exactly how you kind of read this stuff because there is a special way to do that however whenever you're going to be subscribing to events or trying to get the data associated with an event you're not just going to be reading it from this page you're going to have a client this client's going to be using a special live library a library could be something like web3js this is a JavaScript library that kind of handles a lot of this complex lower level stuff for you and it will kind of decode this data and tell you the stuff in the event now I'm not going to show you how we subscribe to events in this tutorial because it's fairly complicated but if you were writing say a JavaScript client or something what you could do is use something like web3.js so let's do this this is the ethereum JavaScript API and inside of here you can subscribe to events so if we go to F dot subscribe this is the thing right here I'll leave a link to this in the description and you can kind of view how you would do this and how you actually get the data associated with events from a smart contract okay let's go back to remix though and let's continue all right so now that we've written the start method let's write the end method or the end function so I'm going to say function end external and inside of here I need to require a bunch of things the first thing I'm going to require is that they started the contract so I'm going to say require started because well if I haven't started it they can't end it so I'll say you need to start first exclamation point it doesn't really matter the error message that I give then I will also require that the block dot timestamp is greater than or equal to end at because I don't want to allow someone to end the auction if uh the end at time is not yet reached right because that would be unfair that means you could have someone like bid on it and then you could end it for them so that they would win it before anyone else was able to bid anyways we're going to do this we're going to say block.time stamp greater than or equal to end at I'll say auction is still ongoing is ongoing one word or two word I think it's one word uh someone can correct me in the comments clearly programming is greater than spelling anyways and then we also want to make sure that it's not already ended right so I'm going to say not ended we'll say auction already ended and let's spell already correctly okay exclamation point perfect so now that we have all of our requires what we can do is say ended is equal to true and then we want to emit an event that says we ended it now of course when we end we're going to actually have to transfer the nft to the highest beta and then we're going to transfer the funds from the contract to the uh what do you call it the seller of the nft but for now we'll just do the events so let's go up here and let's say event and let's say end now for this event I actually want to know what the highest bid was and who the highest bidder was so I know who won the auction right so I'm gonna say let's go with address and this will be I guess highest bidder okay and then we will go with uint and then this will be highest bid okay so that's for event and in fact I guess I can do this yeah that's fine we can do that inside here okay so now for end I'm going to say admit and then end and then inside of here I'm going to pass the highest bidder so let's go high it's better like that and then let's pass the highest bit perfect okay there we go now one thing I want to add to start is I just want to add a parameter here that's going to be the starting uh price or the starting bid or whatever for the auction so I'm going to say uint we'll say starting bid and what I'm going to do is after I start this or it actually it doesn't really matter where I do this but I'm going to say that the highest bid is equal to and then this is going to be the starting bit so this way you're going to have to bid at least a little bit higher than this to be able to actually win the item if you were say the only bidder that way someone doesn't list this and kind of get screwed by only having someone bid like one way or twoway or something and no one else actually bids on the nft regardless we'll have that for now and we can now test if end is going to work and then we can Implement bid and we can Implement withdraw which are the other two functions that we're going to need so let me save this now let's close this I'm going to deploy the contract again this will take a second once it's done I will be back all right so the auction is now deployed now I can start this by passing say a thousand way as the starting bid we will wait for this to go through and then we can try to end it now I will show you that when we end it this isn't going to work now the reason it's not going to work is pretty obvious but we don't have this condition being equal to True right the block.time stamp is not going to be greater than or equal to end at so it's not going to let us end this and I'll just show you that that works in a second once this starts okay so that's started let's now go to this contract uh the way I'm going to get to this is I'm going to open up metamask I'm going to go to contract creation okay let's go here let's view the contract okay it's still indexing uh Let me refresh this once it's done I'll be right back okay so now it is fully successful let me click on the contract uh let's go to events and we can see that the event start has been triggered or been emitted right because we started the contract so now let's see what happens if we try to end it so notice is going to tell us that we're probably going to get a problem here it's saying that gas estimation errored with the following message see below the transaction execution will likely fail do you want you for sending and it's saying that the error's auction is still ongoing so it's actually able to look at our smart contract and realize that we're not going to be able to do this because the block dot timestamp is uh not greater than or equal to the end at time so we can still send the transaction if we want now if we do this what's going to happen is it just gonna fail now when it fails and we hit a require statement the require statement will return whatever remaining gas we had as a part of this transaction back to us however some gas is going to be lost now that's one thing to note here with require it does actually return your gas if this fails again not all of it because it still had to use some gas but it will return whatever was in you so you can see here we're getting this error right it's telling us this didn't work and we weren't able to do that because this require statement would have been well not true right it would have you know caused an exception okay so hopefully that makes sense that is how that works now that we've done that let's start implementing the bid and the withdraw functions that we need Okay so let's code out the bid function let's go with function bid external now this needs to be payable because this is actually going to accept ethereum right so inside of here we need to require a few things we're going to require that we have started the auction if we haven't started then obviously we can't do this I'm going to say not started we're going to require that the block dot timestamp again this is a global keyword that we have access to is going to be less than the end at times this means that the contract is not ended or sorry I keep saying contract I mean auction so we'll say ended exclamation point and then we will also require that the message dot value so this is going to be the value of the bid because they're going to be sending the amount of the bid right is greater than and then this will be the current highest bit okay so now we have all of our required statements now let's see why it's getting mad at us here it's saying expected semicolon but got identifier okay I need a semicolon right there so now if this is the case what we're going to do is we're going to update the amount of money that people have sent to this contract kind of similar to the bank account by using this bids mapping and we're going to update the highest bid and the highest bidder because at this point we know this person would have bid an amount higher than the highest bid so we need to update those values right so we're going to say that the highest bid is equal to message dot value and we're going to say that the highest bidder is equal to the message dot sender okay so now after updating this since the highest bidder has now changed what I need to do is make it so the person who just got outbid is able to withdraw their money from the contract so I'm going to say if and then this is going to be the highest bidder uh so not bid but bitter does not equal the address zero now address zero is the default address I'll talk about this in a second then what I'm going to do is say that bid at and this is going to be highest bidder plus equals and then the highest bit so the logic here uh why is this yelling at me let's see what the problem is uh operate or not compatible with types un256 and address sorry this needs to be highest bid not highest bidder okay that's better but the logic here is that as soon as someone gets outbid I want to allow them to withdraw their money from the contract so that they could withdraw and then bid again right because otherwise they would need to have a ton of ethereum to be able to actually continually out bidding someone if all of their money is stored in the contract so hopefully this makes sense but since we're updating the highest bitter now if the highest bidder was not equal to address zero so essentially if this was not the first person to make a bid then what we do is we take whatever the highest bidder was store that in our bids mapping and then we add whatever their highest bid to that so that now they're able to withdraw and let's say they don't withdrawn they just continue making bids that's fine this will continue to increment however many bids they've made so then they will be able to withdraw all of that if they're not currently the highest bidder okay and actually they'll be able to withdraw whatever amount inside of there is not their current bid that's being stored in highest bit you can look through this logic and probably see why that makes sense but address zero just to clarify here is the default address so when I write something like address public for right now sorry not address public but address public highest bidder it's going to be storing just a zero filled address so I'm just making sure that it's not equal to the zero filled address and you can do that by just writing address and then putting 0 inside of here okay so that is Bid that's pretty much all we need for bid now we want to write the withdrawal function so I'm going to say function withdraw like that and then this is going to be an external payable as well and inside of here what we need to do is withdraw a certain amount or I guess we'll just withdraw the entire amount of whatever the person's bidded that's not the current bid so we're just going to start by getting the amount of money they've sent to this contract that's not currently the highest bid so I'm going to say a uint and I guess I'll just go with something like balance is going to be equal to and then this will be bids at message dot sender and then what I'm going to do is say bids at message dot sender is equal to zero just to reset that and then I'm going to send whatever their balance is to them so the way I'm going to do this is I'm going to write this complex line in fact I'm just going to copy this in because we saw this in the last video I'm going to say bull sent bytes memory data is equal to payable message.center so just converting that address to a payable address dot call Value and then this is going to be balanced balance is right here right and then what I need to do is require that this was successful so I'm going to say require sent and I'm going to say could not withdraw so let's do this could not withdraw let's add our semicolon and there we go we have just implemented the withdraw function now what I'm going to do is actually add some events here as well for bid and for withdraw then we can test this out and then we'll start actually working with an nft because right now we're not really auctioning anything so let's make some events uh let's make an event for bid now what I want to do is have an address now this is going to be indexed now we haven't seen this keyword before but what you're allowed to do whenever you're defining the arguments for your events is you can put an indexed parameter and you can actually put up to three of these and this is what you will be able to search for an event for so if I say indexed here then this means I can search by whatever this parameter is for this event in my logs right or in my events so I'm going to say address indexed let me just look at my cheat sheet to make sure I don't mess this up it's going to be sender and then we're going to say uint amount to specify how much they actually bid and then we'll do an event and this is going to be withdraw and this again will be an address that's going to be indexed this will be the bidder and then this will be you ends and the amount that they withdrew okay I think that is fine now what's it telling me what's what's it saying I did wrong here oh I spelled indexing correctly okay so let's go and let's now omit these events so I'm going to say omit and then this is going to be bid and then we're going to pass to this just the highest bidder and the highest bid okay perfect let's add our semicolon and then for withdraw we will say omit and then withdraw and then we're going to omit the message dot sender and the bounce great there we go okay so now let's actually just deploy this we can do some experiments with it I'll set up another ethereum account uh make sure it works and then we'll talk about the nfts so I'm going to deploy once it's done I will be right back okay so I am back this finished deploying my contract this year I actually started the contract with a minimum bit of a thousand way and now what I'm going to do is change my ethereum account in fact I've actually already done this so I deployed this contract from my tutorial account but now I'm on account one so now I'm going to make a bid from account one and show you how this works so I'm on account one you can see I've reconnected this here to uh what do you call it uh remix and now I'm going to make a bid of a thousand way I'm going to click on bit now when I do this notice it's going to tell me that I'm probably going to get an error the reason I'm going to get an error is because this is not greater than the starting bid and so I'm just going to cancel the transaction so I'm going to change this now to be a thousand one let's click on bid and let's see okay so confirm let's give this a second and again notice I'm not going to get any return value here it's not going to tell me if this was successful or whatever I'm just going to see that the transaction didn't fail whenever this is done and then I should see an event be emitted here okay so let's now refresh this and we now see uh hmm okay maybe we need to wait a second okay so the event has showed up I just had to wait a second I was being impatient but after I refreshed a few times it appeared here anyways this has happened successfully I know this looks like gibberish but if you're actually subscribing to this event then you would have some library that would be translating this for you so you'd be able to read the real data regardless the bid happened and I can look now at for example the highest bid which I can see is 1001 the highest bidder which is this address I can look at the seller which is different if the contract is started and all of this type of stuff now that's pretty much all I wanted to show you for that since we don't really have two days to wait here for this to finish I can't show you it actually ending what I will do though is I will now start implementing the nft stuff which is a little bit complicated uh but it's pretty cool so I'll try my best to explain it to you alright so I've just switched tabs and I'm going to try to explain to you the difference between fungible and nonfungible tokens and how these kind of live on the ethereum network so I'm sure all of you are familiar with cryptocurrencies right we have currencies like ethereum we have currencies like Bitcoin we have a ton of other currencies that are built on top of these main blockchain networks so if we're talking about coins that are built on ethereum these are tokens now really all a token is is a smart contract that defines that your address owns a certain amount of tokens now this is specific to ethereum but if you're working with a token that's on the ethereum network really what gives you the ability to own that token is that there's a smart contract with the name of that token it's named say Tim coin for example right if I had my own token on ethereum and in that contract it says that your address has 20 Tim coins where 100 Tim coins or whatever it is now the way this all gets standardized is that what happens is you need to implement specific methods or specific functions on your smart contracts that make it act like an erc20 or an ERC 721 token now erc20 is simply a protocol for a specific token in this case it's a fungible token now erc20s states that you need to Define some special methods on the smart contract now if you do that ethereum is able to look at your smart contract and treat that smart contract like a token rather than just any other smart contract now that means in your ethereum wallet you're going to see your token showing up or you'll be able to link them you'll be able to then say buy these tokens or exchange these tokens because you've defined certain functions on the token and it meets the erc20 protocol hopefully that makes sense now erc20 is simply a fungible token protocol what that means is every single one of these tokens is exactly the same so there's no difference in you owning one of the tokens or the other tokens like any token is just identical vehicle each of them has the same value and as it says here this makes erc20 tokens useful for things like medium of exchange voting rights staking whatever okay that's where you can use these tokens for however now we go over to ERC 721 now ERC 721 is fungible tokens now fungible tokens mean that these tokens are different so there could be a different value associated with each token maybe there's some assets like an image associated with a token hence nfts right maybe you get some special rights with a specific token tokens are unique they are different and they have a unique ID now this is very similar to erc20 except you're just having these unique tokens and you have some special functions now that you need to Define on Smart contracts that are defining an ERC 721 token so it's a little bit too complicated for me to show you exactly how to create your own nfts or your own erc20 tokens but the concept is again that we have this smart contract this is an example of an nft contract this smart contract defines who owns what nfts it's capable of creating new nfts and then if I wanted to say send my nft from me to you what I would do is call a function on the smart contract that transfers the nft I have to be the owner of the nft to be able to do that and then it changes the internal state of the nft contract to now Define that you own my nft because I sent it to you so hopefully this makes a tiny bit of sense but that's the general idea behind tokens and behind nfts and all of this type of stuff now as you can see here there's some other types of tokens that you can create but ERC 721 is the one we're going to work with right now and what we're actually going to accept in our smart contract that's going to be the auction is the address of a smart contract that represents an nft as well as the unique ID associated with the nft that the user wants to auction so whenever you get an nft it has a unique ID associated with it because every single ERC 721 token is unique when I say ERC 721 that really just means nonfungible token okay and so it has a unique ID if I pass that unique ID along with the contract representing that nft then what I'm able to do is verify that the user owns that nft and then actually list it in the auction and transfer it between different people okay so now let's get into some even more complicated stuff because I need to show you how we can make our own nft and when I say make our own nft I'm not talking about make your own nft contract I'm saying kind of acquire an nft in your ethereum account so you can follow along and actually auction off your own nft in this tutorial all right so to do this I'm going to go up to this other tab here where I have token.sol now I'm not going to explain any of this code but essentially this is my own Tim coin nft okay and I'm going to give you guys all the privilege of owning some Tim coin completely for free it has zero value and it's going to be on an ethereum test network but you can own it for free you are welcome and the way I'm going to do that is I'm going to deploy this smart contract I'm going to leave a link to the contract address in the description and you actually are able to create your own nft by calling this award item function which is going to give you your ethereum address a nft okay it's going to give you a special ID essentially of Tim coin I'll explain this more in depth and I'll show show you exactly how to do this but right now when you're watching this video this will be deployed on the go rally test Network so you need to make sure you're using that test Network and then what you'll be able to do is interact with this contract from remix again I'm going to show you exactly how to do that it will then award you an nft and then once you have that nft you'll be able to auction that nft inside of our test contract now before I show you how to do that we're going to implement kind of the nft logic in our contract then I'll show you how you get your own Tim coin nft again you're welcome you guys can thank me in the comments okay so what we're going to do is we're going to now specify what's known as an interface that we are going to accept for a specific contract which is going to be the contract address of the nft that we want to list so I'm going to say interface so actually there's not a ton of value of me typing this in so I'm just going to paste in the interface and I'll explain what this is so first of all an interface is an abstract data type the reason we're going to use an interface is because we need to verify that the contract passed to this auction does actually represent an nft and so we're going to treat the contract as an IRC 721 type contract which means we're going to make sure it has a transfer and a transfer from function on it now if you're unfamiliar with interfaces I can't explain them too much in depth essentially they just enforce that anything that is of type of this interface has these methods that are specified in this web so for us to have a valid nft contract really all we care about is that it has a transfer and a transfer from function that we can use now the transfer from allows us to transfer from one address to another address a specific um what do you call it nft ID okay so as I was saying before all we're doing is we're going to be calling a function on the nft contract that takes in the address of the owner of the nft the address of the receiver of the nft the nft ID it verifies we own this nft and then it would transfer it to here and then transfer is simply going to take an nft ID and transfer it to a specific address once it's been approved to do that you'll see what I mean in a second but anyways that's our interface so what we're going to do now is we're going to go inside of our auction and we're going to define the nft that we're actually going to be auctioning so I'm going to say I ERC 721 public like this nft and then what I'm going to do is I'm going to say uint public nft ID okay so what I'm saying is I want to store the contract of the nft address here it's going to be of type ierc 721 meaning it has to have these functions on it and then I'm going to have uint public not NDT nft ID which is going to be the unique ID of the nft that we want to auction so now inside of my start function what I'm going to do is take in a starting bid I'm going to take in the nft contract and the unique ID of that nft so I'm going to say IRC 7 21 this is going to be nft and we'll make this underscore nft and then we are going to say uint nft ID we'll just make this underscore again so it doesn't mirror our Global name and then comma Now let me make sure I type that correctly I think I did okay so now inside of here what we're going to do is we're going to set the nft so we're going to say n of t is equal to and then this is going to be underscore nft again this is the contract representing the nft then we're going to say nft ID is equal to underscore nft ID like that now what I'm going to do is just take these two lines here and put them after I do this just in case these return some error although it doesn't really matter because if an error was returned then the state would have been reverted but that's fine okay so we're going to do that now what we also need to do is we need to transfer this nft from the owner of the nft to this contract so now the contract owns the nft and then is able to actually transfer this to whoever wins the nft in the auction right so what I'm going to do is say nft dot transfer from and we're going to transfer from and this is going to be the message.sender who we're assuming owns the nft to this or sorry it's going to be address this like that and then this is going to be nft ID okay so this here is going to fail if we don't own the nft so if whoever called this start here doesn't own the nft then we're not going to allow them to transfer because the nft contract will raise an exception and so that whole thing will Cascade meaning all of this is going to fail as well and so we won't actually start the auction so we're only able to start the auction if we own the nft and if we have the ability to send the nft from the sender to this address okay hopefully that makes sense I'll explain again how we kind of set the nft up and how we actually make an nft and get access to it in a second so now that we have that what we need to do is deal with what happens when the auction ends because once the auction ends we need to send the nft to whoever won it and then we need to take the balance of the contract and specifically whatever the highest bid was and send that actually to ourselves right to the seller of the nft so all we're going to do here is we're going to check if V and this is going to be highest bidder does not equal the address zero because if it's equal to the address 0 that means no one actually bid on this item and so we can just return the funds or return the nft to ourself so anyways we're going to say if this is the case then that means we're going to take whatever the highest beta amount was or the highest bid sorry we're going to transfer that to ourselves and then we are going to transfer the nft to uh whoever won the nft so I'm going to say nft dot transfer and we're going to transfer it to the highest bidder I think that's all I need to put in here let me confirm that's correct oh one more thing the nft ID okay so we're using the nft contract we're using dot transfer we're going to transfer to the highest bidder and then this will be the nft ID now what it's saying is the issue it says transfer is not found well that's because I spelled transfer incorrectly okay that's fine then after that we're going to figure out whatever the highest bid was and we are going to then pay that to ourselves the seller of the nft so the way we do that is we just copy in this line because I really don't feel like writing it again so we're going to say Bool sent and then bytes memory equals data seller.call value and then this is going to be highest bid and then we'll call that like that and then we're going to require sent and we're going to say could not pay the seller okay there we go now in the other situation so if the highest bid actually is equal to address 0 then what we're going to do is just return the nft to ourselves so we're going to say nft dot transfer and then this is going to be two I guess we will just say the seller and then this will be nft ID and I think that's it again I spelled transfer incorrectly let me just make sure that's right looks good to me awesome okay so that is actually all we need for this contract now this contract should work however I need to show you how we can now actually get access to an nft and what that looks like in our account so I'm going to start by deploying this contract now be careful what account you deploy this from I'm going to deploy it from this one so I'm going to deploy uh test.soul which is really just my kind of auction contract let's confirm this okay this will take a second once that's done I'll be right back okay so that has now been deployed now remember to be able to start this auction we actually need the address of our nft so I am now going to deploy this nft contract here I'll leave the link to it in the description or you could just painfully write out all whatever the number of characters are but again it'll be linked in the description and I'll show you how you can use this to get your own nft so let me now deploy this I need to pass a string name and a symbol actually do I need to do that uh oh sorry I'm doing the wrong thing okay let's deploy Tim coin so I'm going to deploy timcoin to the go rally test Network this is going to take a second and then I will show you again how we can actually access this and get our own nft Okay so Tim coin has now been deployed now for me I can see Tim coin right here right and we see all these different methods you don't have to worry about a bunch of them but anyways you're not going to see this inside of your remix because you didn't deploy this contract but you need to interact with the contract again on the gorilli test Network you need to be on the gorilla test Network otherwise this isn't going to work for you so what you're going to do is you're going to take the contract address which will be linked in the description and you're going to paste it right here where it says or at address okay so it should say that right at the bottom you're going to do that and then it will load this contract now notice it just loaded the same contract for me to twice because I already had it here but that's how you can load again just copy it paste it in here and then it will load it right here now what you're going to want to do is you're going to want to start by setting the approval for all now I'm going to discuss what this is in a second but essentially what you need to do here is you need to allow this smart contract being the auction to actually transfer your nft now if you don't allow it to do that you're not going to be able to actually auction the nft the reason you can't auction the nft is because the contract will not have the ability to take the nft and transfer it to itself so you have to explicitly give the contract permission to do that before you create your nft so what you're going to do is go to your auction contract this is going to be different than mine you're going to copy the address of your auction contract okay I've done that I'm going to go to Tim coin I'm going to go to set approved for all I'm going to paste in my contract like this then I'm going to go comma and I'm going to go true now look here it says operator which is this so the operator is the auction contract it's going to be operating on this nft and then true now what this is going to do is it's going to allow this contract to pretty much list any of your nfts now you still have to call the contract for it to do that but you're giving it explicit permission for it to access any of the Tim coin nfts that you have access to so don't worry this doesn't mess with any other nfts you might have on your ethereum account and we're on a test Network anyway so it shouldn't matter but I'm going to press transact this should go or this should be successful once I click confirm here okay so let's wait for that to finish and then we have set the approval for all of the nfts that you own to be able to be operated by the auction contract again what you're passing here is the auction contract now it's very important that you do this first before you actually give yourself an nft otherwise the nft you give yourself will not have the approval set for it for the uh auction contract okay so now that we've done that let's close all these and we're going to go to the award item function now this is what you want to press when you want to give yourself an nft so you're going to copy your address so my address is right here I'm going to copy it in to a word item and then what it says here is that there is a URI now the token URI is actually a URL to Json metadata related to this nft so as you may have seen nfts have like fancy images and music and gifs and all of this very valuable stuff anyways the point is all of that stuff is stored off of the blockchain on a specific URL in Json data and so what you actually have to do is associate data with your nft off the blockchain so when I create the nft I pass the URL of the data sitting off the blockchain that represents my nft and then it links those two together and that's why when you go and you view nfts you see like a nice little fancy image it's because it's referencing the URI of this uh nft and then it's grabbing the image for it and displaying pretty straightforward but that's really how nfts work again I'm not it's not meant to be an entire lesson on nfts but the token URI is just that it's a URL now you actually don't need to pass anything here I'm just going to pass like one two like you have to give some data but you don't have to give a URL so I can pass one two three zero whatever doesn't matter so just go like that and when I hit transact then what's going to happen is it's actually going to give your ethereum account or whatever account you put the address for in nft so let's wait a second and then I'll show you that we actually will have Tim coin showing up in our ethereum won't okay so that finished so now if I go to metamask so let's get out of this here let's go to metamask and let's look at my account let's go to assets and notice how it says don't see your tokens import tokens so I'm going to click on import tokens and I'm going to copy in the token uh contract address of Tim coin now again that's what will be linked in the description I can just copy it from right here so I'm going to go here I'm going to go to assets import tokens I'm going to paste this in notice the symbol is Tim very fitting for the token decimal just put 0 and then add custom token and now it's showing that I have one Tim uh token so I'm going to go import tokens like that and now if I look at my assets I see one Tim coin okay it's just looking at the contract and since it follows the ERC 721 protocol it's able to specify that I have one of these now if you want to own multiple just do this again just call the contract you can even pass the same URI it really doesn't matter and hit transact and now when you do this you're just gonna have to wait a second and then your wallet should update and once this is done you'll now have two Tim coins and in fact just because this is interesting I will show you that if I go to metamask I go to my wallet here and let's go view account on etherscan you can actually view the Tim coins that you have on here so notice I can go to token and I can specify timcoin and when I go here you can see that I have the token ID of one I have one Tim coin that was just added here in one minute now if I refresh this I should have a second Tim coin in a second because I just requested that uh okay it might take a second so let's go back to where we were before okay uh word item let's refresh okay so now we should have two Tim coins if we go here yes there we go now we have Tim coins and the token ID is one and two so if you want to see what your token ID is because all of you're gonna have a different token ID you need to do what I just did go to metamask You're Gonna view your account on metamask so I went to where is that here view account on sorry not metamask on etherscan it's going to bring you to etherscan and then what you can do is go to your Tim coins I showed you how to do that but let's go back so you're just going to click here click on Tim coin and then it will show you your token ID so you own token ID one and two well in this case I own one and two you'll own something that's not one and two because it's going to be a unique ID so this means I can auction token ID one and two because I own that so now how do we auction it well this is kind of the Moment of Truth here to see if this is all going to work so I'm going to copy the address of my Tim coin uh nft contract okay then I'm going to go to start I'm going to paste that in as the first argument so let's go here for the nft ID you have to post an ID that you own so either one or two for me and then put a starting bid so I'm going to put a thousand and I'm going to hit transact like this okay fingers crossed once I hit this let's see if this works and if everything we did was successful okay so very good we see the green check mark here meaning that this was good so now let's go to nft and notice the address is this nftid is one seller is me started is true highest bid is the zero address because no one's made a bid yet and then we have highest bid now of course this will work as it would would work before as we tested it previously and this will now take how many days did we set if we go here I think we set two days yeah so after two days then you'll actually be able to win your nft when someone hits the end button or sends the end request uh to this contract okay so that is going to wrap up the video I hope this was helpful in terms of giving you a deeper understanding of solidity and smart contracts and showing you a real practical application hosted on the blockchain now in the next videos we're going to be talking about some of the scaling limitations of ethereum and of solidity and some of the problems you can run into when you need to perform large computations then I'm going to be showing you some scaling Solutions so ways that you can mitigate those concerns and we'll be talking about cartesi which again is the sponsor of this video and this series and showing you some of the solutions that they provide again I really hope that you guys have learned a lot from these videos I've been having a great time filming them well I look forward to posting more on the Channel with that said if you enjoyed make sure to leave a like subscribe to the channel and I will see you in the next one hello everybody and welcome to the fifth video in this blockchain for beginners tutorial series now in this video I'm going to be talking to you about the limitations of solidity and of smart contracts and some applications that are very difficult to deploy on the blockchain because of these limitations specifically I'll be talking to you about arrays strings for Loops while loops and why it's very expensive to use those things in a spark contract and how they can actually cause your smart contract to break or to be in a state where it can never be ran again I'll get into all of that in this video but before we dive in I do need to thank cartesi for sponsoring this video and this series as I've said many times they're an awesome company I've loved working with them through these videos they've really helped me come up with a great curriculum to teach you guys so another massive thank you to them and with that said let's go ahead and get into the video alright so I'm now on my computer and I am in remix in front of me I have a very simple smart contract and what I'm going to be doing in the first part of the video here is talking to you about arrays strings for Loops while loops and then finally structs now after we do that I'll talk about some of the limitations of solidities and expenses in using these different features and then we will talk about some potential I guess fixes or solutions for these limitations so let's begin by talking about arrays so the way you create an array in solidity is you define the type you would like to be inside of the array for all of the elements so in this case I'll say uint you put your square brackets like this if you wanted a multidimensional array you do another set of square brackets and then what you can do after this is put the name of the array or the modifier so I'm going to do something like public AR and then I can just close it off like that so there you go I've just now created a dynamically sized array in solidity so in solidity you can have both a statically sized or fixed sized array or a dynamically sized array if I do something like this where I just have square brackets with no element inside or no value inside this is dynamically sized so this means it will grow as I add more element moments to it now if I do something like 5 this is going to say this array can only have five elements inside of it and I will initialize those elements I believe all as zero all right so that's the basics for arrays now arrays are a reference type in solidity and that means that they are mutable and we can modify them once they have been created so we have direct index access we can access the length of elements or the length of the array story and again we can push elements inside okay so let's just deploy the contract right now and have a look at how we actually access the elements in this array so I'm going to deploy this when I go here notice I'm going to have ARR and then I can pass the index of the element that I want to access now raise our zero indexed so if I do something like ARR and 0 it's going to give me the value 0 because since we statically initialize this array we're going to have one element with value zero or sorry five elements with value zero inside of the array now let's access index one okay we get zero again let's do index four zero again let's do five and then notice here that we actually are going to get a revert the transaction has been reverted to the initial State and that's because an error would have occurred because we're accessing an index that is out of the bounds of this array perfect so now that we have done that let's look at how we can actually I guess modify the elements of this array so let's create a function let's say function I'm just going to say mod ARR standing for modify array we will make this a public function and we're not going to return anything we'll just actually modify this okay now inside of here I'm just going to take in a uint X and A uint uh idx and instead of X let's actually just go with value just so this is a little bit more clear now essentially what this is going to do is change the element at index to be equal to Value so let's just say AR at index let's go idx is equal to Val notice we're not getting any errors so this should be good to go okay so let's deploy the contract let's go here we're going to look at index 0 . see that that has value zero now let's change this so let's pass to here a value of say 10 and an index of zero let's transact looks like that's all good now when we look here notice we have a value of 10. very basic that's how you can modify this array now what I want to do is create a dynamically sized array so let's simply change this by removing the five and now when we do mod array we're just going to take in a value and I'll show you how we can append this value or push it to the array pretty straightforward but you can use the dot push method so I can say AR dot push I can push the value which is uint and now this should be good so let's try this let's deploy the contract let me just delete this one here okay now we have mod array that takes it a value so let's just pass one let's pass two and let's pass three now let's look at index zero index zero is one index one is two and index two is three perfect there we go we just pushed elements into the array all right great so now that we've done that let me show you how we get the length of the array so I'm just going to say function get length we'll make this an external and then this can be a view function that returns and then we'll just put U ins like that and then inside of here I can simply return error dot length like that okay so this will give us the length you can just use the dot length property so let's now deploy this contract let's go deploy let's mod the array by adding one two and three now let's get the length and notice we have a length of three now let's add another element let's add four get length we're at four there you go that pretty much covers a race I don't think there's actually anything more to go through with the raise one thing you you can do is access individual elements using the index notation so I can do something like array at 0 is equal to one that's perfectly valid or I can just do array at zero that works as well as you saw previously uh last thing I will mention is that if you want to actually Define the literal for the array so you want to do something like this use square brackets so say uint public ARR and then one two three this is different than something like I guess C plus plus or Java where you would use uh squiggly brackets at least I think you use those in those languages anyways in slowly to use square brackets I to define the elements in the array perfect hopefully that is clear that pretty much covers a race okay so now that we have gone through a raise I want to cover strings so let's get rid of all of this now strings and solidity are very expensive to work with and same thing with a race arrays are very expensive as well and in fact the reason I'm showing them to you last is because mappings are much preferred over a Race So you pretty much never want to be using a raise or using strings if you can avoid doing so there is some use cases where you do need them but essentially you always want to go with something like a mapping as opposed to an array I won't get into all of the details but just understand that they cost a lot more gas than something like a mapping so if you can avoid it avoid using arrays and if you want to mess around with kind of the differences in arrays and mappings deploy a few contracts and look at the actual gas cost in terms of working with arrays versus working with mappings and same thing with strings strings are extremely expensive to use in solidity and one of the reasons for that is that a string in solidity is actually a bytes array so you can create a byte array like this now bytes are used for kind of a raw data type and a string and solidity essentially is a bytes array that's going to be decoded and encoded with utf8 just allowing you to actually view the string so let me show you what I mean if I do something like string and I guess we can put public although we don't really need to and we'll expect this equal to a hello we can say this is equal to world that is completely valid now you want to again avoid using strings whenever you possibly can because they're very expensive to work with same reason with the arrays because they are actually represented by 8 bytes array now strings and solidity are extremely simple you do not have index access to them you cannot concatenate them you can't get the length of them there's actually almost no methods or properties for Strings you literally can just store a literal string and in most situations it's going to be much more efficient especially if you're working with large strings to store them off of the blockchain and simply store a hash of that string in the storage of your contract that will be much much cheaper than actually storing the string itself in the contract anyways let's deploy the contract here with the string notice that I can access this and I can have World threat I can see World there so let's create another function let's go function set stream ring and let's go string and then let's go with value now I'm not quite done with this yet I need to uh talk about something with having strings inside of functions but for now I will say hello is equal to Bell okay so notice that I'm getting an error here now why am I getting an error this function actually looks pretty valid right I have my string parameter I have this public I'm setting a value this should be good the reason why I'm getting an error here we can hover over this is because the data location must be memory or call data for a parameter so this is where I'm going to talk about the different storage locations that you have in your contract so in your contract you have state or storage they're kind of the same things storage State now that essentially means that you're persistently going to be storing this data in the smart contract itself now any data you store is going to cost you small amounts of ethereum right it's going to be more expensive to store more data than to store less you want to store the least amount of stuff that you possibly can so that's the first location storage state that's persistent it's always going to be there the other location is memory now memory similar to your computer's Ram is a temporary location that's only going to be used when the contract is actually executing so when I'm using a reference type like a string I need to specify it's going to be stored in memory so I'm going to say memory like this so as soon as I put memory we actually would have seen this before I think now this is valid because it's saying I want to store this parameter in memory as opposed to in the state or storage of the contract and you only need to specify this for reference data types so same thing with arrays let's say I did something like UNS and then I wanted to have my uh value like this I would need to now specify memory to not get yelled at by the compiler okay so let's go back though to what we had before string memory value low equals Bell let's deploy this let's look at this let's go hello world I am Tim let's set the string let's look at a low and now we have hello world I am 10. awesome again avoid using strings if you need to use a large string what you want to do is store it off the blockchain and simply store a hash of that string on the blockchain that will be much cheaper okay so now we've gone through a raise we have gone through strings I want to show you looping and then I will show you the gas costs associated with a lot of these different features I'm just trying to give you kind of the basics right now okay so let us um should we Loop through an array no let's just uh loop over kind of a range of numbers to start so I'm just going to say function and I will say Loop and I'm going to take in U and n and all I'm going to do here is simply Loop Over N numbers so to do a for Loop in solidity is similar to pretty much every other programming language you can say four and then you can Define your looping variable so I'm going to say U and I I'm going to say I is less than n and then I'm going to say I plus plus okay so I'm just incrementing I by 1 in every iteration and then what I'm going to do here is I guess we can just add to some variable or something because I'm just trying to illustrate Luke so I'll do something like uint sum is equal to zero and then sum plus equals I and I think that should be good and then if we wanted to we could return the sum but this is fine we'll just do this for now so I just had to take a quick cut there because my cat was freaking out at me for some reason anyways that is now resolved but continuing here uh we're getting a warning the reason we're getting a warning is because this can be restricted to Pure the reason for that is because we're not actually modifying or accessing the state of the contract so I just want to put pure like this anyways this is how you do a for Loop uh now I will mention that the for Loops again are going to be very very expensive to run if you're not doing them in something like a pure function right in a pure function or something that doesn't require a transaction it's not going to cost you ethereum to run this however it's going to be very expensive to implement for Loops when you're actually working with the state of the con contract now the reason for that is whenever you do a transaction you need to pass gas along with that transaction right and the gas cost is the sum of all the operations that the contract is doing so in this case it's going to cost me gas to actually add a number to another number right for me to add two numbers that cost gas but here in this situation the amount of gas this would cost if it wasn't a pure function is n multiplied by all of the gas used inside of the for Loop now that might not seem like a lot but if an N is a large number say like a thousand or ten thousand and the amount of gas in here is four gas 20 gas 100 gas something along those lines you can see how the amount of gas required adds up very very quickly and it becomes unfeasible to actually be able to Loop inside of smart contracts and in fact there's actually a maximum amount of gas that you can pass to an ethereum smart contract I believe right now it's at 30 million gas in fact I think that's right here it's the gas limit that's showing up regardless you can only pass so much gas so if your smart con contract needs to do a ton of computations you have to have multiple transactions to be able to complete that because you need to pass the required gas and you can only do a certain amount of gas in each transaction anyways that was kind of it for for Loops I just want to show you the syntax this is the basics of for Loops now I will show you while loops so let's do a very similar thing here let's just manually declare I so U and I is equal to zero we'll say well I is less than n we'll say I plus plus we can do that at the end and then we'll say sum plus equals I like that perfect there you go this is a while loop again not really going to explain this I'm sure most of you understand how this works anyways those are for loops and while loops and now that we've looked at those I want to write a very simple smart contract that's going to work with arrays and for Loops or while loops and show you how much gas it actually costs on an ethereum test Network so let's start by just initializing an array here and let's just say you ends and let's go ARR and let's just make this equal I guess actually I can just Define it like that uint AR that's fine for now then I'm going to have a function I'm going to say function create AR I'm going to say U and n and I will go with string value and I'm actually going to change the type of this array to be a string array and show you how expensive this gets okay now I will make this public now what I want to do here is essentially initialize this array with n elements that are equal to this string value now I need to remember to add my memory keyword otherwise it's going to get mad okay so let's do this so what I'm going to do is write a for Loop I'm going to say four again this will be i i u and I this is going to be I is less than n let's add a space here and then I plus plus okay now what we'll do is say ARR dot push and we're going to push the value like so okay so right now we can technically run this infinite number of times and I'll show you what happens if we try to do that but I want to deploy this to our injected web3 to the go rally test Network so it says custom Network right now let me just go to my metamask and change this to go rally and then we will deploy this and test it alright so we are back on go rally I'm going to deploy let's see how much this is going to cost us right now okay so not a significant amount of gas because obviously we haven't done any computation yet in the contract and then once this is deployed we'll actually try running this method and see how much gas it cost us alright so it looks as though the contract has been deployed we can see it down here it says create AR now let's just see again this is going to be kind of antidotal I'll just go through a few uh examples here how much it costs to do one that has 10 elements and the string hello world now I need to quote the string here so let's do that and let's transact and see approximately how much this costs us so when I do this notice we're getting 0.006876 okay so we can kind of copy that and keep that in mind and then I'll show you how this is gonna I guess not exponentially but go up a lot as I increase the value of n so let's now do one that has a thousand elements and see how much this costs so when I do transact now we're going to see that now we're at 0.05 now if you actually put that into the price of ethereum 0.05 ethereum is a lot now I'm not sure if it would be the exact same on the regular ethereum network but the point is you saw how we drastically increase this to a whole decimal point right just by making this a thousand instead of say 10. and then let's go crazy and let's make this something like a hundred thousand and transact and see how much this would cost and here it tells me we actually cannot even send this amount of gas the transaction will likely fail so let's go to ten thousand and see if 10 000 is a doable same thing we can't even do ten thousand let's try doing something like 5000 and see if that's gonna work okay 5000 doesn't work let's try 25 000 transact okay that's not gonna work so just trying to show you here that we really cannot do a lot of looping operations and even if we try to do a lot of looping operations that is going to be very very expensive to the point where it really doesn't make sense to do them inside of the smart contract all right so now that we've gone through those few examples just so you can see kind of in the real world how much the gas is going to cost let me delete all of this and show you that remix can actually give us a gas estimate for specific functions so what I can do is something like let's go uint X is equal to zero and let's go function set X let's take in a uint value let's just make this public and then what we can do is say x is equal to Value okay so this is my function very very simple all we're doing is assigning a variable now if I hover over the function name notice that down here kind of in the right corner or I guess not really corner but right on the console bar it's showing us the execution is going to be 22 498 gas so that's a significant amount of gas considering we're only doing a very simple operation all right so now that we've seen that let's just do a few more examples and estimate some more gas costs so another thing we might want to do is evaluate a condition maybe we want to use a require statement or something like that so let's just do something like require and we'll say Val is greater than and let's just go with 10 and we'll say Val is too low okay put our semicolon let's see how much gas it's telling us now so if I hover over here now you can see the gas has increased a small amount so the require statement doesn't really use that much gas right now let's see what happens if we try to add a number so let's do something like X plus equals Val multiplied by 10 and let's look at the gas estimate now and nose is giving us infinite gas now whenever you're seeing infinite gas that usually means a remix is not able to estimate how much this is going to cost now in this case uh the reason saying infinite is because Val can be any single number now if Val is any number greater than 10 when I multiply this by 10 remix has no idea how much this computation is going to cost because the larger value is then you know the more that this is going to be the more gas this is going to cost because the more addition operations we need to do essentially whenever you're doing multiplication you're really doing repeated addition and while the more repeated addition the more gas this costs so infinite gas is just telling you it could theoretically be anything and you really want to try to limit these functions so that they cannot cost infinite gas because if they cost infinite gas you could do a transaction that will never be able to run because you can't pass enough gas to actually be able to execute it all right hopefully that makes a bit of sense I just want to give you a quick example of the gas costs and how quickly they go up using smart contracts now I will talk to you about structs and then we'll talk about some programs that are really limited on the blockchain because of the fact that we can't really do any looping or at least not very efficiently alright so to illustrate structs to you I first want to start by showing the alternative to structs which would be actually representing objects using contracts now contracts just like classes can be instantiated so I can have different instances of the contract now typically we just deploy a single contract but this contract can instantiate another contract and then have a reference to them so for example I can do something like this I can have contract person I can have you and age string name you and balance I can have a Constructor and I can treat this just like I would any other class and say jump right now from this tutorial class what I might do is create a function like this I might say function create and then person and then maybe I take in my uint age and then my string memory name like that and then the balance we would just imagine would be uh implemented at another time okay then I'm going to say public and then inside of here what I can do is actually create an instance of this person class so I would say person person equals new person and then I would just pass my Constructor values so uh this needs to be a string sorry age and name okay there we go I've just created a person instance now this is an instance of this contract now this looks perfectly fine however this is going to cost you a ton of gas because contracts are much more expensive to work with than structs so instead what you would want to do is replace this contract with the struct now the struct would look something like this uh let's do this struct and then we can remove the Constructor and just do the font now there's a few other changes I need to make here so when I'm working with a struct first of all I no longer need the new keyword and I also need to pass a balance right so I'm going to pass the balance zero the reason I need the balance is because this is a required field in the struct I'm storing an age a name and a balance and if I initialize my struct in this way then I need to pass all of these fields I'll show you another way to initialize it in a second now we're getting an error the error is that I need to specify the location for this type the reason for that is this is a reference data type meaning it's mutable so I can change it later on so I need to specify memory here just like for my strings now when I do this notice it's all good now it's telling me I can make this a pure function I believe yeah because I'm not actually working with the state of the contract this is just an example to illustrate the struct now I'm getting a warning here just saying that this can be a pure function because uh what do you call we're not dealing with the state of the contract anyways this is what you want to do if you want to store like custom data essentially in a custom type create a struct rather than creating a contract so now to really uh kind of show the use case of a struct we'll write a very simple contract that's going to allow us to associate an address with a person so what I'm going to do is put a mapping up here and I'm going to map and address to a person like that totally fine for me to do that and I will just call this people so now when I create my person I will add them into the uh the people map so what I'll do after I make my person is I'll say people at and then this is going to be the address so message dot sender is equal to person like that and then of course I would adjust the balance if money was sent into this contract so now that we've seen this I'll just show you another way of initializing this person because we don't have to do it in this way so I can actually remove kind of the literal I guess written person and just say person memory person like that and now I can just specify the attributes on this person so I can say person.age is equal to age I can say person dot name is equal to name and then if I don't do anything for the balance that's completely fine because the balance will be initialized as zero anyways that's another way that you can initialize a struct just wanted to show you you can do it in this way or you can actually write out kind of I guess the main initialization or the Constructor initialization where you pass in those values anyways that is pretty much all I had for this first section here I showed you the gas costs associated with looping and how looping is really a big problem in smart contracts and is unfeasible especially if you're doing a large amount of computations I also showed you that storing strings and bytes is very expensive and you don't want to do that lastly I talked about structs here and how if you want to represent kind of a custom object or a custom type it's much cheaper and better practice to use a struct rather than to use a separate contract right which would kind of act as a class you don't really want to be doing that in solidity there are some use cases but if we're going to be creating a ton of different people like this we definitely don't want to be using a separate contract now what I would like to do is really focus more on the limitations of solidity based on some of these things you just saw and talk about how we would Implement something like an order book in solidity now an order book is essentially what to use when you're trading stocks you're trading assets of some sort you want to have buy orders and sell orders and match the buy and the the sell orders now in cryptocurrency you definitely need this need a way to exchange your different coins buy coins sell coins whatever it may be so I'm going to hop over to the Blackboard now or the drawing tablet and start talking to you about how we would Implement order book in solidity a lot of the problems that we're going to run into doing that and then some of the solutions we may have to actually make this more feasy alright so I'm here on my drawing tablet I want to begin by explaining to you what an order book is so an order book is essentially used whenever you're trying to trade something so in this situation let's say we're talking about US Dollars and then something like ethereum now in order book just really States the buy and the sell orders for this specific asset so in this case with US Dollars we would be buying ethereums these would be our buy orders and then on the other side we would have sell orders now whenever we want to actually make a trade we need to match buy and sell orders together based on the price so when I put in a buy order I need to specify the price that I want to purchase ethereum at now what I would do is something like one ethereum and then I want to buy this at maybe 4K right that's the price that I'm willing to buy this at I put that buy order into the book now maybe someone wants to sell ethereum maybe they're selling one ethereum and maybe they want to sell it at like 4.4 000. well if this is the case we cannot match these two orders together because they have different prices now you can probably realize just by looking at this it's going to be very difficult to actually match buy and sell orders because the probability that two people are going to have the exact same price in mind for this specific asset well that's just very rare you know the seller is always going to want to sell High the buyer is always going to want to buy low so because of this situation we can use multiple buy orders or multiple sell orders to fill either order right so maybe I have a ton of small bios something like 0.1 ethereum well if all of these small orders allow me to actually fill one large cell order then I would use you know all let's say 10 of these to fill this one ethereum order now of course they have to be at the same price and so we end up running into the same problem again now this is where we talk about something called market makers so I'm going to draw this right here Market make now a market maker essentially provides liquidity to this trading pair or to this order book Because as I was saying it's gonna be very rare to have our buyers and sellers agreeing on a price so the market maker is actually a neutral entity that's always willing to buy and always willing to sell now they have incentives to do this they will earn some rewards some fees whatever it may be but the idea is they're always buying and they're always selling and this allows liquidity in this market they make the market it allows me at any point in time to go and buy my ethereum or sell the ethereum now the market maker is pretty well dictating the price of this asset based on the pressure to buy and the pressure to sell now I don't want to get more into this because it's a bit beyond my scope of knowledge and finance and all of that that's the basics of an order book and now we'll talk about how you would Implement something like that on the blockchain so of course an order book is pretty important especially when we're talking about cryptocurrency people want to buy and people want to sell so let's draw out another order book right here and I'll talk about how we would actually kind of do this algorithmically because of course although this was done manually in the old days we now have computers that do this for us and they can do it very very quickly and efficiently so let's say we have a bunch of buy orders over here in green we have a bunch of cell orders here in red well the first thing that we should realize is that since we're going to implement this as a smart contract if someone is going to be making say a large sell order maybe a one ethereum or maybe a lot more than one ethereum they're going to have to use uh usually multiple buy orders to fill this cell order so they may have to actually Loop maybe 20 30 40 maybe 500 times to actually fill their order and as we saw previously looping is very very expensive and so the more looping we have to do the more it's going to cost whoever is performing the transaction now we also may run into a problem where someone needs to Loop more times than that is allowed in the smart contract based on the gas limit let's say I want to make a sell order of maybe a hundred ethereum well the chances that someone else is going to be buying 100 ethereum is Slim maybe there's a ton of people buying a small amount of ethereum so I might have to Loop say 2 000 times now if the maximum number of Loops I can do in one iteration of my smart contractor one calls or in my smart contract is a hundred then I'm gonna have to split this into two separate orders to be able to actually make this sell right I'm gonna have to do two 50th cells because I can only do a thousand Loops in one smart contract transaction so that's kind of the main problem we're going to run into here and it really just has to do with the ability of looping with the smart contract now this is kind of a naive perspective because this assumes that everyone interacting with this contract is interacting with good intentions they are a good actor everyone wants to buy everyone wants to sell they're not trying to manipulate the market but of course people are always going to try to manipulate the market and one way they could do that with something like this is they could put in a ton of tiny buy orders so let's say we have some buyer who's really trying to kind of lag the smart contract and make it take a very long time or be very expensive to interact with well the way they would do this is they would put in a ton of fractional kind of bogus buy orders and they would do this many many times let's say maybe they have a thousand of these orders realistically it would be way more than that but they have a ton of these orders that they're adding they're all very small bios well now even if I want to make a relatively small sell order of say one ethereum I have to Loop thousands of times in this case probably hundreds of thousands of times to actually be able to fill this order because there's so many small buy orders so now again that requires me as the seller to split this into very very small amounts to be selling so maybe I have to sell this amount at a time because I just cannot do enough Loops in my smart contract transaction so that's kind of a main problem that can arise here you can have people try to manipulate the market and when someone does this if we're not handling this correctly it's going to cause the seller practically to not be able to sell because it's going to take them so long and it's going to cost them a lot of money to do that so the way that we deincentivize this type of behavior is we put the burden of looping on the buyer now the seller is still going to have to Loop to fill their order but we try to make it so that less small buy orders come in by kind of penalizing those so for example if we want to purchase one ethereum what we do as the seller is we Loop through buy orders hopefully in efficient manner and we Mark all of the orders that we require to fill this cell order as executed now when we mark them as executed that essentially means that we've made the trade so we immediately take all of the USD funds we give those to the seller but then we lock this asset in the smart contract and we require that the buyer do as many transactions as they originally did to buy to be able to take their stock back so what I mean by that is if they did a thousand of these tiny little transactions they need to do a thousand more transactions to retrieve all of those funds from the smart contract so for example if they want to take whatever it is they bought for you know 0.0001 USD or after whatever it's going to be then they need to do one transaction and that will give them whatever the amount of stock that was traded in this specific trade hopefully that's making a bit of sense but they will take this amount of ethereum they'll get that from this one transaction then they have to do this a thousand more times because they had so many orders so for every order they need to do one transaction to retrieve all of the funds that were traded in that specific order so this now puts the burden of looping on the buyer and hopefully deincentivizes them from doing this now of course we still have this underlying problem that the seller needs to do looping to be able to actually fill their sell order so we need to come up with an efficient way to do this and that's what I want to talk to you about now as we head over to the other screen so to reiterate here the main problem that we're running into is that we're requiring a ton of Loops to be able to perform buy and sell orders and even if we Implement that previous solution we talked about the seller still needs to determine which buy orders to match with to be able to make the sale right and then we have to mark orders as executed we have to store these orders somewhere how do we do all of that that's really the question right now and how do we do it in an efficient manner because we can't have nested for Loops we can't have any crazy algorithms that are taking really long time to run that's just not feasible on the blockchain and with smart contracts now solution one is really the approach that has to be done on the blockchain and this this is to come up with the most efficient data structures and algorithms possible to implement what we just talked about we need probably an advanced type of tree that's going to allow us to look for the largest possible orders to fill the largest cell orders so we only use four five six orders and require a very little amount of looping to be able to make a sale now of course the same thing happens on the buy side the idea though is that we need to do all of this efficiently and again we need to manage our storage efficiently as well because it's expensive to store orders on the blockchain so solution one is essentially be a genius and come up with a great data structure and algorithm that has no bugs has no problems is never going to be inefficient and use that now of course that's not really the most reasonable approach ask me to implement order book I have no idea where to even start that's going to be very complicated I'm gonna have to do a ton of research hopefully I'm going to find someone who's done something like this before and kind of copy what they have but even then again this is just really an impractical approach for most people trying to implement something like this and even if you do come up with an implementation the first approach is most likely going to be buggy it's going to be inefficient and it's probably going to be infeasible to use so then solution 2 is essentially kind of similar to solution one copy someone else who's already done this hope that there's some genius out there who's written a great order book just take the exact same order book maybe modify it a little bit if you were trying to make your own and use that now again that's really still not a great approach you can still have a lot of inefficiencies and you still might have to Loop a ton of times to be able to fill a buy or sell order now the third solution is kind of more of an abstract one but this would be to use something off the blockchain maybe like a SQL database that's already very efficient at searching for specific orders maybe you write some Advanced select query that can kind of give this information to you and then you store hashes of this on the blockchain whatever it's going to be unfortunately interacting with SQL from the blockchain isn't really possible right now at least I don't know how to do that and so that kind of limits that option as well so even with the only feasible option which is essentially have a really good data structure and algorithm you're still running into problems now you might be asking yourself at this point in time well how is this done then how do people do this if this is such a problem now you can still use an order book it's just not going to be the most efficient thing in the world but what a lot of platforms are doing now is using something called a liquidity pool now liquidity pool has its own issues I'm not going to talk about those in this video essentially liquidity pool is just a store of a ton of the assets that you're going to be trading so you have whatever asset one is an asset to you have usually an equal amount of them in the pool and then based on the demand for the specific assets the price of those assets will fluctuate within the liquidity pool and the people providing liquidity so putting their assets into the pool will be given a type of reward kind of like a fee that you would pay when you're actually trading them right anyways that's liquid equal again has its own issues but that's kind of an approach that's being used currently and really with that said I think I'm going to wrap up the video here now I know I didn't talk too much about the solutions but that's because this this video is really focused on the limitations of the blockchain and showing you that a lot of stuff we would like to be able to create that would be way simpler to do off the blockchain we just can't feasibly do using spark contracts and on the blockchain because of those limitations now even the stuff I showed you at the beginning of the video strings arrays for Loops while Loops those are very inefficient to use they cost a lot of money and the reason we left them until the very end was because we don't really want to encourage their use and I want to make sure that you understand kind of the problems with them and that they do exist you can use them but you should be very careful when you're implementing those specific features alright so with that said I am going to end the video here another massive thank you to cartesi for sponsoring this video and this series in the next video we'll be looking at specific Solutions and how we can actually write scalable smart contracts and decentralized applications I hope you guys enjoyed if you did make sure to leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to the sixth and final video in this blockchain for beginners tutorial Series in this video I'm going to talk to you about ethereum scaling Solutions specifically Solutions on layer 1 and on layer 2. and of course I'll describe what layer 1 and layer 2 meet now the reason we need ethereum scaling Solutions is because as you've seen through this series ethereum can be quite slow and the number of transactions that it can handle per second is very very small now this means it takes a really long time for us to actually submit a transaction to the blockchain and have that processed and validated and if we want to be using a smart contract to perform computations that can take a really long time as well or be infeasible based on the amount of say iterations we need to do within a for Loop or something along those lines so there's tons of reasons why we need better scalability on ethereum and fortunately there's many different solutions so with that said we'll go ahead and get into the video but I do want to thank cartesi for sponsoring this video and this series they're an awesome company that have been helping me come up with all of the content for this series and they're actually working on a bunch of layer 2 blockchain Solutions right now and trying to make the blockchain more accessible and scalable for developers so definitely check them out from the link in the description they have a ton of detailed articles on a lot of the stuff I'm going to go over in this video and I do just want to quickly mention here in the intro that this is going to be very high level I'm not going to get into a ton of technical explanations about these different solutions I just want to give you an introduction to them and then encourage you to research and learn more anyways let's start talking about the difference between layer 1 and layer 2 Solutions so in blockchain world and in this video you're going to see the terms layer 1 and layer 2 a lot now layer 1 is referring to the blockchain network itself so the actual ethereum main Network and layer 2 is referring to stuff built on top of that Network so when we talk about increasing the scalability of ethereum when we're referring to layer 1 we're talking about actually modifying the underlying blockchain technology so changing the architecture increasing the block size decreasing the block size whatever the solution is going to be it's going to be right on ethereum and that's something that we can't really directly modify ourself the people that are working on ethereum would have to actually change then we have layer two layer 2 is referring to Solutions we build on top of the blockchain so we're not touching layer one we're not modifying the ethereum network we're doing stuff on top of this to increase the scalability so of course I'll get into those different solutions but again on layer 2 we're relying on layer 1 to give us the security and aspects of the blockchain but we're not actually going to be modifying that underlying technology and that underlying architecture hopefully that is clear now what I want to do is talk to you about something known as the scalability trilemma which has to do with the different aspects of a blockchain that we want to have and that we need to consider when we're picking different blockchain solutions so the scale ability trilemma is essentially a triangle I'll put a photo up on the screen where each Vertex or point is one of the properties or aspects of a blockchain that we'd like to have so here we have security decentralization and scalability now broadly speaking what this says is that whenever we Implement a solution we end up lacking in one of the areas of this triangle so one of these points for example if we Implement a solution that has great security and great decentralization typically we're going to have a worse scalability where if we Implement something with great scalability and great security we may have worse decentralization now this is not always the case there is some solutions that are great in all three of these areas but this is something that we want to think about when we're actually talking about different blockchain solutions so does this increase decentralization does it decrease decentralization what are the pros and the cons and the tradeoffs as it relates to the scalability trilemma now before we go any further I do really want to Define scalability as well as security and decentralized just to make sure we know those terms so when we're talking about scalability the common thing to refer to as it relates to blockchains is transactions per second or transaction throughput now that is one of the areas of scalability that we're concerned with we're also concerned with data scalability as well as computation scalability so when we're building smart contracts one of the big issues there was we don't want to store a ton of data and we can't do too many computations in the smart contract because of the cost on the ethereum network and the time it takes to actually process those so keep that in mind as we go through this video it's not just a number of transactions it's also computations and data on the blockchain now as we go to decentralization that's really referring to the centralization of power or in this case the lack of centralization of power so the example I always like to use is a bank a bank is an example of a central institution or organization they have you know a few Executives or a few board members that really control what the bank can do they have investors they have government interests whatever it's very very centralized the people that use a bank don't control what the bank is able to do and what control they have of your money it's the bank itself very Central that controls all of them so hopefully that makes a bit of sense now when we talk about blockchain we want everything to be decentralized so there's not one person one institution or maybe a few people or few institutions that have control over the network ideally we want millions of computers or thousands of computers around the world to be running and securing this network so we're less prone to hacks less prone to corruption and all those other things that can happen when you have Central Power and Central you know authority of something so hopefully that makes a little bit of sense then we're talking about security this is pretty straightforward but how secure is the network how easy is it to be hacked how uh sure can we be that this transaction is valid when it's posted on The blockchain Ledger all of those types of things relate to security alright so that is the scalability trilemma keep this in mind as we go through the rest of this video now I'm going to start talking to you about layer 1 Solutions now I'm not going to spend too much time here because we don't have much control over layer 1 Solutions we can't really build a layer 1 solution because we don't have control of the ethereum network regardless though I will talk about why we would want a layer 1 solution so why would we actually want to improve ethereum well as I'm sure many of you are aware ethereum is relatively slow so when we're talking about scalability it only does about 15 transactions per second and in contrast to something like Visa that can do upwards of about 60 000 that's really really slow and that makes it infeasible for a ton of different applications especially something like being the Global Currency right if we wanted everyone to be using ethereum for their daytoday transactions well that would take a really long time because we would have to be waiting hours maybe even days for a transaction to go through because we can only do 15 per second now in terms of computations as well we've seen when we were working with smart contracts we're really Limited in what computations we can do we probably can't Implement any advanced data structures and algorithms we can't store too much information and we can't do too many iterations without it costing us a ton of money on the blockchain so that is kind of the reason we would want to improve ethereum because of those lack of scalability issues now ethereum is very decentralized and is very secure so we're not super concerned with those two aspects we just really want the scalability to increase without hurting the decentralization and hurting the security anyways let's talk about the layer 1 Solutions So currently ethereum is actually working on a layer 1 solution which they're calling ethereum 2.0 this is going to be a complete change to the architecture and the algorithm used for ethereum so I'm sure many of you have heard of this before they've been working on it for a really long time and it should be out relatively soon but they're going to be changing from proof of work to proof of stick now I'm not going to discuss the differences here or get into kind of a debate about which is better but that is what they're doing they're changing the main algorithm for improve of work to proof of stake and ideally they're going to be bringing the transaction throughput from about 15 transactions per second to upwards of a hundred thousand transactions per second now I cannot confirm this these are just the rumors and what I've heard online line and seen when looking at the project anyways that is kind of what they're doing now in ethereum 2.0 they're doing a few other things one of the main things that they're adding is something called sharding so sharding is really this process of taking a large piece of data and splitting it horizontally into smaller pieces of data which can be handled by multiple computers at the exact same time so to put this simply imagine I have one piece of data and this piece of data can only be processed by one computer at a time what's going to be slower to process that data than if I split this data into say 64 chunks or 120 chunks or whatever the number of chunks is going to be and allow 120 computers 2 000 computers whatever the number is to process these smaller pieces of data at the exact same time so that's exactly what ethereum is aiming to do take the large piece of data split it into multiple smaller pieces of data and then allow for parallel processing and to drastically increase the number of transactions per second in fact this is a similar thing that many large companies do in many large databases do to increase the efficiency or increase the scalability of their systems so this is not just something that's done in blockchain this is done generally in computer science and I would encourage you to read more about it and look it up if you're interested in exactly how sharding works so with that said that's going to wrap up our layer 1 Solutions now I'm going to talk about the layer 2 Solutions so as reminder layer 2 Solutions are simply Solutions built on top of ethereum so they rely on the ethereum network and they do not modify it and they aim to increase the scalability while again still keeping the decentralization and security aspect so that said let's talk about some different layer 2 Solutions now the solutions that we have are things like State channels side chains and then RollUps now I'm actually going to start with side chains so I probably should list it in the other order what a side chain is is essentially another blockchain Network that has a different architecture than the ethereum network and makes it better for scalability so what a side chain actually does is it links to the ethereum area main Network it makes it very easy to transfer assets between the two different chains now typically side chains are going to be much smaller they're going to have less validators they may have smaller block sizes and this does actually decrease the security and the decentralization of the side chain but it drastically increases the scalability because now rather than me sending a transaction to ethereum I'm going to send it to a side chain and then the side chain can kind of link up with the ethereum main Network and allow me to transfer the assets between the two networks very very quickly or very easily at minimum so an example of a side chain would be something like polygon I'll put up an image on the screen these are controversial and there's a lot of reasons why you may not want to use a sidechain but again the basic reasoning here is rather than using the ethereum network we're going to use it completely entirely different blockchain network that's going to be somewhat linked to the ethereum main Network which allows us to take the smart contracts running on the side chain and very easily Port them over to the ethereum main Network while still Main containing all of the data all of the assets and all of the information essentially that was posted to the sign chain Network hopefully that makes a bit of sense but those are side chains so the next solution that I'm going to introduce to you is something known as state channels now I just want to emphasize before doing that again I'm bringing this to you at a very very high level there's a lot of details and Nuance with all of these Solutions and you really should do some research and look at these more before actually trying to implement them or use them for your decentralized applications so please keep that in mind this is a very very general introduction anyways state champs to explain the usefulness of State channels I want to introduce to you a problem of making a decentralized application so if we wanted to make a decentralized app we want this to be some type of game maybe a game like chess right well this game requires many state changes now we know when we make a decentralized application we're going to have a smart contract the smart contract handles the state of our application if we're talking about Chess and we need to store the state of the board so if we want to play a game of chess on the ethereum network what we would have to do is send transactions to the smart contract to update the state after every single move was played now at least in the chess games that I play they're like five minutes long we're three minutes long and we make moves every few seconds right so I make a move my opponent makes a move and every time that would happen if we're running this on ethereum we would need to submit a transaction to the network however the next player can't make a move until that transaction is verified and the state has been updated in the smart contract and we know that that can take a really long time to happen so that makes it infeasible for us to play a game that has very rapid State changes hopefully that makes sense but you would be sitting there waiting 30 minutes an hour for the transaction to be finalized before the next player would be able to move and while that completely defeats the purpose of like a quick game of chest or something along those lines so this is where we introduce State channels so the idea here between State channels is that if we have a ton of micro transactions or many any transactions that are going to be occurring in a short period of time rather than doing them on the blockchain we're going to take them off the blockchain and do them in a secure way that can later be verified by the blockchain so a state channel is essentially a communication Channel a peertopeer messaging Channel where me and someone else who are participating in for example some type of game are going to be sending signed messages to and from each other with the state of the game so if we're playing a game of chess I'm going to be sending a message that's signed by me to my opponent saying I made this move and then they're going to send me a message that science said I made this move and we're both going to be verifying that the state is correct at each point in time by signing these messages hopefully that makes a bit of sense now the way that this works is we're first going to send a transaction to a Smart contract sitting on layer 1 to open up the state Channel Once the state channel has been opened we're going to do all of our transactions the micro quick ones off the blockchain they will happen almost instantly then at the end of the game we're going to send one transaction to the smart contract with the final State and we're going to say hey we finished the game and then the smart contract is essentially going to verify that the state is correct and there's a lot of stuff that goes on to do that I won't really talk about how that works and if we're playing for say one ethereum so whoever wins the chess game gets one ethereum then that ethereum would be transferred and we would have had to kind of stake that at the beginning of the game so hopefully that makes a bit of sense but typically State channels allow for us to have very fast transactions they make it very cheap because we don't have to pay gas fees when we're doing this off the blockchain we just have that first and last transaction that require the gas fee to open the state Channel and to close the state Channel and typically they do allow for the same security and decentralization however you may have the security be slightly decreased depending on the way that you're verifying the states and what you're doing between the blockchain and the off chain or between layer 1 and layer 2. again I don't want to get into this too much those are stage channels very useful when you have a ton of micro transactions that need to be performed very very quickly so now we are moving on to the final solution I have in this video which is RollUps now before I get into those I do want to mention that cartesi actually implements a ton of layer 2 Solutions and makes it really easy for developers like yourself to use these Solutions without having a full understanding of how they work and what's going on behind the scenes cartesia is working on operating systems libraries modules packages Frameworks all of the stuff you could imagine is going to make it easier for you as a developer to use these types of solutions that are really complicated on a lower level so make sure you check them out from the link in the description anyways let me talk about roll ups here and I will also mention that cartesi has a ton of articles that explain this stuff more in depth if you're interested again reference them from the link in the description so a roll up is essentially an idea that we're going to take all of the transaction execution so the computations associated with the transaction and perform those off the blockchain will posting transaction data to the blockchain on layer 1. so the basic concept behind rollups is that it's very expensive to perform computations on the blockchain it can also be very time consuming so rather than do them on the blockchain let's perform our transaction execution off of the blockchain and then post the transaction data to layer 1 and have a smart contract on layer one so on the blockchain they can validate that the execution that we did off the blockchain was indeed correct now I know that's confusing but essentially we're taking the time consuming operations and computations Performing them off the blockchain and then posting all of the data to the blockchain where we can then validate that it is correct and we can use the properties of the blockchain to store the data now another advantage of the rollups is that what they can do is they can bundle multiple transactions maybe hundreds or thousands of transactions into one smaller transaction and then post that to layer one so rather than having the user have to send a thousand transactions directly to a Smart contract which costs a lot takes a lot of time we're going to send it to whatever's rolling up these transactions it's going to kind of bundle them all together and then send one transaction to the blockchain that contains all of the data that it needs of the state change that's going to be made so before I can go any further because I do want to give you some more detail here I will mention that there's some different types of RollUps so we have optimistic robes and pessimistic ropes now I'm going to start with optimistic RollUps now I do want to add here that the blockchain community currently considers roll ups to be one of the most promising solutions for scaling ethereum and the reason for that is that they allow you to scale the computations and throughput of the network without compromising on security and decentralization so using that in combination with sharding which allows you to scale the data on the network really gives you the best of both worlds and allows you to scale ethereum in all three of the areas that we talked about so sharding scales the data and the RollUps allow us to scale the computations as well as the throughput so the transactions per second so you're likely going to be hearing a lot more about RollUps in the future and maybe even using them yourself and if you were to pay attention to any of the solutions in this video this would be the one that I recommend so when we talk about optimistic rollups what we're really referring to is that the smart contract that's sitting on layer 1 is assuming that any of the transactions sent to it are valid so any of the state changes that are made any of the transaction data we'd assume that's valid and that it's not malicious now this allows for us to have very quick transactions and to perform faster computations off the blockchain because we don't have to prove that everything is correct however this does mean that someone could submit a malicious transaction now there is incentives put in place to make sure that people do not submit malicious transactions for example there may be something like staking ethereum so whenever people are dealing with rollups you may have to stake some ethereum that says hey I'm going to be a good actor I'm not going to submit any malicious uh transactions or state data and if you do that so if you are malicious your stake could get slashed that could be the incentive or the incentive from performing poorly or having bad behavior on the network hopefully that makes a bit of sense but the idea here is that we're assuming everything is correct now if someone does do something that is not correct or is invalid or malicious or whatever anyone can submit something known as a fraud proof now this fraud proof essentially says I believe that this state is incorrect I believe that someone did something malicious go and verify that it's not or go and verify that they did indeed do something malicious so that's what's called it's a fraud proof this puts the smart contract into a specific mode where it's going to go and validate that all of the transactions and data that are sent is actually correct and if they are not correct it's going to punish whoever submitted the incorrect transaction hopefully that makes a bit of sense but that is optimistic ropes again just really think about the fact that an optimistic rollup is assuming everything is correct and it's only doing a validation if someone submits a fraud proof all right moving on now to pessimistic rollups now pessimistic ropes are kind of the opposite of optimistic ropes in a pessimistic rollup you cannot submit or update the state of a smart contract unless you submit something known as a validity proof now this proof is a specific cryptographic proof I'm not going to really talk about exactly how it works but essentially off the blockchain when you're performing all of your computations you also need to compute this proof and then this proof is sent to the smart contract and you can only submit or update the state story of the smart contract if you have this proof alongside it now the only real issue with these type of proofs though is that they can be inviable to compute for a really complex transactions so these are time consuming and difficult for a computer to come up with these cryptographic proofs and so if you're doing anything that's too complex it can be inviable to come up with one of these proofs and in that situation you need to use an optimistic rollup now the reason you would use one of these proofs though is because this limits the amount of data that the smart contract needs to hold because all it needs to do is hold a state because it can only update the state if it has a valid proof I understand it's a little bit confusing but in the optimistic rollup scenario it's holding all of the transaction data and it's only doing a verification when a fraud proof is sent so it is time consuming when you send the fraud proof but ideally you're not having that happen very oft whereas in a pessimistic scenario here the smart contract is holding much less data it's just storing the state and it's only updating that state when you submit the proof this means it's really easy for the smart contract to validate that everything is correct however it takes more time off the blockchain to be able to submit these State changes because you need to perform this validity proof and sometimes this validity proof can be inviable to compute alright so that's pretty much all I can share with you related to roll up so getting into too much detail again I want to emphasize this at a very high level there's a ton of stuff that I skipped over and omitted in this video with that said I'm going to start wrapping it up here another massive thank you to cartesi for sponsoring this video and this series make sure you check them out from the link in the description they have all kinds of Articles very smart people there that are implementing these types of layer 2 Solutions and are trying to make it much easier for you and me to develop decentralized applications without the huge issues or limitations of ethereum that we looked at in some previous videos hope you guys enjoyed this series if you did make sure you leave a like subscribe to the Channel please leave a comment down below and let me know if you want to see more blockchain on this channel because I'm hoping do some more series in the future and with that said I will see you in another YouTube video foreign