hello everybody and welcome to the fifth video in this blockchain for beginners tutorial series now in this video i'm going to be talking to you about the limitations of solidity and of smart contracts and some applications that are very difficult to deploy on the blockchain because of these limitations specifically i'll be talking to you about arrays strings for loops while loops and why it's very expensive to use those things in a spark contract and how they can actually cause your smart contract to break or to be in a state where it can never be ran again i'll get into all of that in this video but before we dive in i do need to thank cartesi for sponsoring this video and this series as i've said many times they're an awesome company i've loved working with them through these videos they've really helped me come up with a great curriculum to teach you guys so another massive thank you to them and with that said let's go ahead and get into the video all right so i'm now on my computer and i am in remix in front of me i have a very simple smart contract and what i'm going to be doing in the first part of the video here is talking to you about arrays strings for loops while loops and then finally structs now after we do that i'll talk about some of the limitations of solidities and expenses in using these different features and then we'll talk about some potential i guess fixes or solutions for these limitations so let's begin by talking about arrays so the way you create an array in solidity is you define the type you would like to be inside of the array for all of the elements so in this case i'll say you int you put your square brackets like this if you wanted a multidimensional array you do another set of square brackets and then what you can do after this is put the name of the array or the modifier so i'm going to do something like public arr and then i can just close it off like that so there you go i've just now created a dynamically sized array in solidity so in solidity you could have both a statically sized or fixed sized array or a dynamically sized array if i do something like this where i just have square brackets with no element inside or no value inside this is dynamically sized so this means it will grow as i add more elements to it now if i do something like 5 this is going to say this array can only have 5 elements inside of it i will initialize those elements i believe all as 0. all right so there's the basics for arrays now arrays are a reference type in solidity and that means that they are mutable and we can modify them once they have been created so we have direct index access we can access the length of elements or the length of the array sorry and again we can push elements inside okay so let's just deploy the contract right now and have a look at how we actually access the elements in this array so i'm going to deploy this when i go here notice i'm going to have arr and then i can pass the index of the element that i want to access now arrays are 0 indexed so if i do something like arr and 0 it's going to give me the value 0 because since we statically initialize this array we're going to have one element with value zero or sorry five elements with value zero inside of the array now let's access index one okay we get zero again let's do index four zero again let's do five and then notice here that we actually are going to get a revert the transaction has been reverted to the initial state and that's because an error would have occurred because we're accessing an index that is out of the bounds of this array perfect so now that we have done that let's look at how we can actually i guess modify the elements of this array so let's create a function let's say function i'm just going to say mod arr standing for modify array we will make this a public function and we're not going to return anything we'll just actually modify this okay now inside of here i'm just going to take in a uiint x and a uint idx and instead of x let's actually just go with value just so this is a little bit more clear now essentially what this is going to do is change the element at index to be equal to value so let's just say ar at index let's go idx is equal to val notice we're not getting any errors so this should be good to go okay so let's deploy the contract let's go here we're going to look at index 0 see that that has value 0. now let's change this so let's pass to here a value of say 10 and an index of 0 let's transact looks like that's all good now when we look here notice we have a value of 10. very basic that's how you can modify this array now what i want to do is create a dynamically sized array so let's simply change this by removing the five and now when we do mod array we're just going to take in a value and i'll show you how we can append this value or push it to the array pretty straightforward but you can use the dot push method so i can say ar dot push i can push the value which is uint and now this should be good so let's try this let's deploy the contract let me just delete this one here okay now we have mod array that takes it a value so let's just pass one let's pass two and let's pass three now let's look at index zero index zero is one index one is two and index two is three perfect there we go we just pushed elements into the array all right great so now that we've done that let me show you how we can get the length of the array so i'm just gonna say function get length we'll make this an external and then this can be a view function that returns and then we'll just put you in like that and then inside of here i can simply return error dot length like that okay so this will give us the length you can just use the dot length property so let's now deploy this contract let's go deploy let's mod the array by adding one two and three now let's get the length and notice we have a length of three now let's add another element let's add four get length we're at four there you go that pretty much covers erase i don't think there's actually anything more to go through with arrays uh one thing you can do is access individual elements using the index notation so i can do something like array at zero is equal to one that's perfectly valid or i can just do array at zero that works as well as you saw previously last thing i will mention is that if you want to actually define the literal for the array so you want to do something like this use square brackets so say uint public arr and then one two three this is different than something like i guess c plus plus or java where you would use uh squiggly brackets at least i think you use those in those languages anyways and solidity use square brackets to define the elements in the array perfect hopefully that is clear that pretty much covers arrays okay so now that we have gone through arrays i want to cover strings so let's get rid of all of this now strings and solidity are very expensive to work with and same thing with arrays arrays are very expensive as well and in fact the reason i'm showing them to you last is because mappings are much preferred over a race so you pretty much never want to be using arrays or using strings if you can avoid doing so there is some use cases where you do need them but essentially you always want to go with something like a mapping as opposed to an array i won't get into all of the details but just understand that they cost a lot more gas than something like a mapping so if you can avoid it avoid using arrays and if you want to mess around with kind of the differences in arrays and mappings deploy a few contracts and look at the actual gas cost in terms of working with arrays versus working with mappings and same thing with strings strings are extremely expensive to use in solidity and one of the reasons for that is that a string in solidity is actually a bytes array so you can create a byte array like this now bytes are used for kind of a raw data type and a string in solidity essentially is a bytes array that's going to be decoded and encoded with utf8 just allowing you to actually view the string so let me show you what i mean if i do something like string and i guess we can put public although we don't really need to and we'll just make this equal to a low we can say this is equal to world that is completely valid now you want to again avoid using strings whenever you possibly can because they're very expensive to work with same reason with the arrays because they are actually represented by a bytes array now strings and solidity are extremely simple you do not have index access to them you cannot concatenate them you can't get the length of them there's actually almost no methods or properties for strings you literally can just store a literal string and in most situations it's going to be much more efficient especially if you're working with large strings to store them off of the block chain and simply store a hash of that string in the storage of your contract that will be much much cheaper than actually storing the string itself in the contract anyways let's deploy the contract here with the string notice that i can access this and i can have world right let's see i can see world there so let's create another function let's go function set string and let's go string and then let's go with value now i'm not quite done with this yet i need to talk about something with having strings inside of functions but for now i will say hello is equal to val okay so notice that i'm getting an error here now why am i getting an error this function actually looks pretty valid right i have my string parameter i have this public i'm setting a value this should be good the reason why i'm getting an error here we can hover over this is because the data location must be memory or call data for a parameter so this is where i'm going to talk about the different storage locations that you have in your contract so in your contract you have state or storage they're kind of the same things storage slash state now that essentially means that you're persistently going to be storing this data in the smart contract itself now any data you store is going to cost you small amounts of ethereum right it's going to be more expensive to store more data than to store less you want to store the least amount of stuff that you possibly can so that's the first location storage slash state that's persistent it's always going to be there the other location is memory now memory similar to your computer's ram is a temporary location that's only going to be used when the contract is actually executing so when i'm using a reference type like a string i need to specify it's going to be stored in memory so i'm going to say memory like this so as soon as i put memory we actually would have seen this before i think now this is valid because it's saying i want to store this parameter in memory as opposed to in the state or storage of the contract and you only need to specify this for reference data types so same thing with arrays let's say i did something like uint and then i wanted to have my value like this i would need to now specify memory to not get yelled at by the compiler okay so let's go back to what we had before string memory value hello equals val let's deploy this let's look at this let's go hello world i am tim let's set the string let's look at hello and now we have hello world i am awesome again avoid using strings if you need to use a large string what you want to do is store it off the block chain and simply store a hash of that string on the blockchain that will be much cheaper okay so now we've gone through arrays we have gone through strings i want to show you looping and then i will show you the gas cost associated with a lot of these different features i'm just trying to give you kind of the basics right now okay so let us should we loop through an array no let's just loop over kind of a range of numbers to start so i'm just going to say function and i will say loop and i'm going to take in uint n and all i'm going to do here is simply loop over n numbers so to do a for loop in solidity is similar to pretty much every other programming language you can say 4 and then you can define your looping variable so i'm going to say u and i i'm going to say i is less than n and then i'm going to say i plus plus okay so i'm just incrementing i by 1 in every iteration and then what i'm going to do here is i guess we can just add to some variable or something because i'm just trying to illustrate looping so i'll do something like uint sum is equal to zero and then sum plus equals i and i think that should be good and if we wanted to we could return the sum but this is fine we'll just do this for now so i just had to take a quick cut there because my cat was freaking out at me for some reason anyways that is now resolved but continuing here we're getting a warning the reason we're getting a warning is because this can be restricted to pure the reason for that is because we're not actually modifying or accessing the state of the contract so i just want to put pure like this anyways this is how you do a for loop now i will mention that the for loops again are going to be very very expensive to run if you're not doing them in something like a pure function right in a pure function or something that doesn't require a transaction it's not going to cost you ethereum to run this however it's going to be very expensive to implement for loops when you're actually working with the state of the contract now the reason for that is whenever you do a transaction you need to pass gas along with that transaction right and the gas cost is the sum of all the operations that the contract is doing so in this case it's going to cost me gas to actually add a number to another number right for me to add two numbers that cost gas but here in this situation the amount of gas this would cost if it wasn't a pure function is n multiplied by all of the gas used inside of the for loop now that might not seem like a lot but if an n is a large number say like a thousand or ten thousand and the amount of gas in here is four gas 20 gas 100 gas something along those lines you can see how the amount of gas required adds up very very quickly and it becomes unfeasible to actually be able to loop inside of smart contracts and in fact there's actually a maximum amount of gas that you can pass to an ethereum smart contract i believe right now it's at 30 million gas in fact i think that's right here it's the gas limit that's showing up regardless you can only pass so much gas so if your smart contract needs to do a ton of computations you have to have multiple transactions to be able to complete that because you need to pass the required gas and you can only do a certain amount of gas in each transaction anyways that was kind of it for for loops i just want to show you the syntax this is the basics of for loops now i will show you while loops so let's do a very similar thing here let's just manually declare i so u and i is equal to zero we'll say well i is less than n we'll say i plus plus we can do that at the end and then we'll say sum plus equals i like that perfect there you go this is a while loop again not really going to explain this i'm sure most of you understand how this works anyways those are for loops and while loops and now that we've looked at those i want to write a very simple smart contract that's going to work with arrays and for loops or while loops and show you how much gas it actually costs on an ethereum test network so let's start by just initializing an array here and let's just say u end and let's go arr and let's just make this equal i guess actually i can just define it like that u and ar that's fine for now then i'm going to have a function i'm going to say function create ar i'm going to say u and n and i will go with string value and i'm actually going to change the type of this array to be a string array and show you how expensive this gets okay now i will make this public now what i want to do here is essentially initialize this array with n elements that are equal to this string value now i need to remember to add my memory keyword otherwise it's going to get mad okay so let's do this so what i'm going to do is write a for loop i'm going to say 4 again this will be i uh u and i this is going to be i is less than n let's add a space here and then i plus plus okay now what we'll do is set rr dot push and we're going to push the value like so okay so right now we can technically run this infinite number of times and i'll show you what happens if we try to do that but i want to deploy this to our injected web 3 to the go rally test network uh so it says custom network right now let me just go to my metamask and change this to goreli and then we will deploy this and test it out all right so we are back on goreli i'm going to deploy let's see how much this is going to cost us right now okay so not a significant amount of gas because obviously we haven't done any computation yet in the contract and then once this is deployed we will actually try running this method and see how much gas it cost us all right so it looks as though the contract has been deployed we can see it down here it says create arr now let's just see again this is going to be kind of antidote i'll just go through a few uh examples here how much it costs to do one that has 10 elements and the string hello world now i need to quote this string here so let's do that and let's transact and see approximately how much this costs us so when i do this notice we're getting 0.00 okay so we can kind of copy that and keep that in mind and then i'll show you how this is going to i guess not exponentially but go up a lot as i increase the value of n so let's now do one that has a thousand elements and see how much this costs so when i do transact now we're going to see that now we're at 0.05 now if you actually put that into the price of ethereum 0.05 ethereum is a lot now i'm not sure if it would be the exact same on the regular ethereum network but the point is you saw how we drastically increase this to a whole decimal point right just by making this a thousand instead of site 10 and then let's go crazy and let's make this something like a hundred thousand and transact and see how much this would cost and here it tells me we actually cannot even send this amount of gas the transaction will likely fail so let's go to 10 000 and see if 10 000 is doable same thing we can't even do 10 000 let's try doing something like 5000 and see if that's gonna work okay 5000 doesn't work let's try 25 000 transact okay that's not going to work so just trying to show you here that we really cannot do a lot of looping operations and even if we try to do a lot of looping operations that is going to be very very expensive to the point where it really doesn't make sense to do them inside of the smart contract all right so now that we've gone through those few examples just so you can see kind of in the real world how much the gas is going to cost let me delete all of this and show you that remix can actually give us a gas estimate for specific functions so what i can do is something like let's go u into x is equal to zero and let's go function set x let's take in a uint value let's just make this public and then what we can do is say x is equal to value okay so this is my function very very simple all we're doing is assigning a variable now if i hover over the function name notice that down here kind of in the right corner or i guess not really corner but right on the console bar it's showing us the execution cost is going to be 22 498 gas so that's a significant amount of gas considering we're only doing a very simple operation all right so now that we've seen that let's just do a few more examples and estimate some more gas costs so another thing we might want to do is evaluate a condition maybe we want to use a require statement or something like that so let's just do something like require and we'll say val is greater than and let's just go with 10 and we'll say val is too low okay put our semicolon let's see how much gas it's telling us now so if i hover over here now you can see the gas has increased a small amount so the required statement doesn't really use that much gas right now let's see what happens if we try to add a number so let's do something like x plus equals val multiplied by 10 and let's look at the gas estimate now and nose is giving us an infinite gas now whenever you're seeing infinite gas that usually means a remix is not able to estimate how much this is going to cost now in this case the reason it's saying infinite is because val can be any single number now if val is any number greater than 10 when i multiply this by 10 remix has no idea how much this computation is going to cost because the larger value is then you know the more that this is going to be the more gas this is going to cost because the more addition operations we need to do essentially whenever you're doing multiplication you're really doing repeated addition and while the more repeated addition the more gas this costs so infinite gas is just telling you it could theoretically be anything and you really want to try to limit these functions so that they cannot cost infinite gas because if they cost infinite gas you could do a transaction that will never be able to run because you can't pass enough gas to actually be able to execute it alright hopefully that makes a bit of sense i just want to give you a quick example of the gas costs and how quickly they go up using smart contracts now i will talk to you about structs and then we'll talk about some programs that are really limited on the blockchain because of the fact that we can't really do any looping or at least not very efficiently all right so to illustrate structs to you i first want to start by showing the alternative to structs would which would be actually representing objects using contracts now contracts just like classes can be instantiated so i can have different instances of the contract now typically we just deploy a single contract but this contract can instantiate another contract and then have a reference to them so for example i can do something like this i can have contract person i can have you and age string name you end balance i can have a constructor and i can treat this just like i would any other class and say job right now from this tutorial class what i might do is create a function like this i might say function create and then person and then maybe i take in my uint age and then my string memory name like that and then the balance would just imagine would be uh implemented at another time okay then i'm going to say public and then inside of here what i can do is actually create an instance of this person class so i would say person person equals new person and then i would just pass my constructor values so uh this needs to be a string sorry age and name okay there we go i've just created a person instance now this is an instance of this contract now this looks perfectly fine however this is going to cost you a ton of gas because contracts are much more expensive to work with than structs so instead what you would want to do is replace this contract with the struct now the struct would look something like this let's do this struct and then we can remove the constructor and just do the following there's a few other changes i need to make here so when i'm working with a struct first of all i no longer need the new keyword and i also need to pass a balance right so i'm going to pass the balance zero the reason i need the balance is because this is a required field in the struct i'm storing an age a name and a balance and if i initialize my struct in this way then i need to pass all of these fields i'll show you another way to initialize it in a second now we're getting an error the error is that i need to specify the location for this type the reason for that is this is a reference data type meaning it's mutable so i can change it later on so i need to specify memory here just like for my strings now when i do this notice it's all good now it's telling me i can make this a pure function i believe yeah because i'm not actually working with the state of the contract this is just an example to illustrate the struct now i'm getting a warning here just saying that this can be a pure function because uh what do you call we're not dealing with the state of the contract anyways this is what you want to do if you want to store like custom data essentially in a custom type create a struct rather than creating a contract so now to really uh kind of show the use case of a struct we'll write a very simple contract that's going to allow us to associate an address with a person so what i'm going to do is put a mapping up here and i'm going to map an address to a person like that totally fine for me to do that and i will just call this people so now when i create my person i will add them into the uh the people map so what i'll do after i make my person is i will say people at and then this is going to be the address so message.sender is equal to person like that and then of course i would adjust the balance if money was sent into this contract so now that we've seen this i'll just show you another way of initializing this person because we don't have to do it in this way so i can actually remove kind of the literal i guess written person and just say person memory person like that and now i can just specify the attributes on this person so i can say person.age is equal to age i can say person.name is equal to name and then if i don't do anything for the balance that's completely fine because the balance will be initialized as 0. anyways that's another way that you can initialize a struct just wanted to show you you can do it in this way or you can actually write out kind of i guess the main initialization or the constructor initialization where you pass in those values anyways that is pretty much all i had for this first section here i showed you the gas cost associated with looping and how looping is really a big problem in smart contracts and is unfeasible especially if you're doing a large amount of computations i also showed you that storing strings and bytes is very expensive and you don't want to do that lastly i talked about structs here and how if you want to represent kind of a custom object or a custom type it's much cheaper and better practice to use a struct rather than to use a separate contract right which would kind of act as a class you don't really want to be doing that in solidity there are some use cases but if we're going to be creating a ton of different people like this we definitely don't want to be using a separate contract now what i would like to do is really focus more on the limitations of solidity based on some of these things you just saw and talk about how we would implement something like an order book in solidity now an order book is essentially what's used when you're trading stocks you're trading assets of some sort you want to have buy orders and sell orders and match the buy and the sell orders now in cryptocurrency you definitely need this you need a way to exchange your different coins buy coins sell coins whatever it may be so i'm going to hop over to the blackboard now or the drawing tablet and start talking to you about how we would implement order book in solidity a lot of the problems that we're going to run into doing that and then some of the solutions we may have to actually make this more feasible all right so i'm here on my drawing tablet i want to begin by explaining to you what an order book is so an order book is essentially used whenever you're trying to trade something so in this situation let's say we're talking about us dollars and then something like ethereum now an order book just really states the buy and the sell orders for this specific asset so in this case with us dollars we would be buying ethereum so these would be our buy orders and then on the other side we would have sell orders now whenever we want to actually make a trade we need to match buy and sell orders together based on the price so when i put in a buy order i need to specify the price that i want to purchase the ethereum at now what i would do is something like one ethereum and then i want to buy this at maybe 4k right that's the price that i'm willing to buy this at i put that buy order into the book now maybe someone wants to sell ethereum maybe they're selling one ethereum and maybe they want to sell it at like four point four thousand well if this is the case we cannot match these two orders together because they have different prices now you can probably realize just by looking at this it's going to be very difficult to actually match buy and sell orders because the probability that two people are going to have the exact same price in mind for this specific asset well that's just very rare you know the seller is always going to want to sell high the buyer is always going to want to buy low so because of this situation we can use multiple buy orders or multiple cell orders to fill either order right so maybe i have a ton of small buy orders something like 0.1 ethereum well if all of these small orders allow me to actually fill one large cell order then i would use you know all let's say 10 of these to fill this one ethereum order now of course they have to be at the same price and so we end up running into the same problem again now this is where we talk about something called market makers so i'm going to draw this right here market make now a market maker essentially provides liquidity to this trading pair or to this order book because as i was saying it can be very rare to have our buyers and sellers agreeing on a price so the market maker is actually a neutral entity that's always willing to buy and always willing to sell now they have incentives to do this they will earn some rewards some fees whatever it may be but the idea is they're always buying and they're always selling and this allows liquidity in this market they make the market it allows me at any point in time to go and buy my ethereum or sell the ethereum now the market maker is pretty well dictating the price of this asset based on the pressure to buy and the pressure to sell now i don't want to get more into this because it's a bit beyond my scope of knowledge and finance and all of that but that's the basics of an order book and now we'll talk about how you would implement something like that on the blockchain so of course an order book is pretty important especially when we're talking about cryptocurrency people want to buy and people want to sell so let's draw out another order book right here and i'll talk about how we would actually kind of do this algorithmically because of course although this was done manually in the old days we now have computers that do this for us and they can do it very very quickly and efficiently so let's say we have a bunch of buy orders over here in green we have a bunch of sell orders here in red well the first thing that we should realize is that since we're going to implement this as a smart contract if someone is going to be making say a large cell order maybe a one ethereum or maybe a lot more than one ethereum they're going to have to use usually multiple buy orders to fill this cell order so they may have to actually loop maybe 20 30 40 maybe 500 times to actually fill their order and as we saw previously looping is very very expensive and so the more looping we have to do the more it's going to cost whoever is performing the transaction now we also may run into a problem where someone needs to loop more times than that is allowed in the smart contract based on the gas limit let's say i want to make a sell order of maybe a hundred ethereum well the chances that someone else is going to be buying 100 ethereum is slim maybe there's a ton of people buying a small amount of ethereum so i might have to loop say 2 000 times now if the maximum number of loops i can do in one iteration of my smart contract or one call sorry of my smart contract is a hundred then i'm going to have to split this into two separate orders to be able to actually make this cell right i'm gonna have to do two 50 f cells because i can only do a thousand loops in one smart contract transaction so that's kind of the main problem we're going to run into here and it really just has to do with the ability of looping with the smart contract now this is kind of a naive perspective because this assumes that everyone interacting with this contract is interacting with good intentions they're a good actor everyone wants to buy everyone wants to sell they're not trying to manipulate the market but of course people are always going to try to manipulate the market and one way they could do that with something like this is they could put in a ton of tiny buy orders so let's say we have some buyer who's really trying to kind of lag the smart contract and make it take a very long time or be very expensive to interact with well the way they would do this is they would put in a ton of fractional kind of bogus buy orders and they would do this many many times let's say maybe they have a thousand of these orders realistically it would be way more than that but they have a ton of these orders that they're adding they're all very small buy orders well now even if i want to make a relatively small cell order of say one ethereum i have to loop thousands of times in this case probably hundreds of thousands of times to actually be able to fill this order because there's so many small buy orders so now again that requires me as the seller to split this into very very small amounts to be selling so maybe i have to sell this amount at a time because i just cannot do enough loops in my smart contract transaction so that's kind of a main problem that can arise here you can have people try to manipulate the market and when someone does this if we're not handling this correctly it's going to cause the seller practically to not be able to sell because it's going to take them so long and it's going to cost them a lot of money to do that so the way that we deincentivize this type of behavior is we put the burden of looping on the buyer now the seller is still going to have to loop to fill their order but we try to make it so that less small buy orders come in by kind of penalizing those so for example if we want to purchase one ethereum what we do as the seller is we loop through buy orders hopefully in efficient manner and we mark all of the orders that we require to fill this cell order as executed now when we mark them as executed that essentially means that we've made the trade so we immediately take all of the usd funds we give those to the seller but then we lock this asset in the smart contract and we require that the buyer do as many transactions as they originally did to buy to be able to take their stock back so what i mean by that is if they did a thousand of these tiny little transactions they need to do a thousand more transactions to retrieve all of those funds from the smart contract so for example if they want to take whatever it is they bought for you know 0.0001 usd or after whatever it's going to be then they need to do one transaction and that will give them whatever the amount of stock that was traded in this specific trade hopefully that's making a bit of sense but they will take this amount of ethereum they'll get that from this one transaction then they have to do this a thousand more times because they had so many orders so for every order they need to do one transaction to retrieve all of the funds that were traded in that specific order so this now puts the burden of looping on the buyer and hopefully deincentivizes them from doing this now of course we still have this underlying problem that the seller needs to do looping to be able to actually fill their cell order so we need to come up with an efficient way to do this and that's what i want to talk to you about now as we head over to the other screen so to reiterate here the main problem that we're running into is that we're requiring a ton of loops to be able to perform buy and sell orders and even if we implement that previous solution we talked about the seller still needs to determine which buy orders to match with to be able to make the sale right and then we have to mark orders as executed we have to store these orders somewhere how do we do all of that that's really the question right now and how do we do it in an efficient manner because we can't have nested for loops we can't have any crazy algorithms that are taking really long time to run that's just not feasible on the blockchain and with smart contracts now solution one is really the approach that has to be done on the blockchain and this is to come up with the most efficient data structures and algorithms possible to implement what we just talked about we need probably an advanced type of tree that's going to allow us to look for the largest possible orders to fill the largest sell orders so we only use four five six orders and require a very little amount of looping to be able to make a sale now of course the same thing happens on the buy side the idea though is that we need to do all of this efficiently and again we need to manage our storage efficiently as well because it's expensive to store orders on the blockchain so solution one is essentially be a genius and come up with a great data structure and algorithm that has no bugs has no problems is never going to be inefficient and use that now of course that's not really the most reasonable approach ask me to implement order book i have no idea where to even start that's going to be very complicated i'm going to do a ton of research hopefully i'm going to find someone who's done something like this before and kind of copy what they have but even then again this is just really an impractical approach for most people trying to implement something like this and even if you do come up with an implementation the first approach is most likely going to be buggy it's going to be inefficient and it's probably going to be infeasible to use so then solution two is essentially kind of similar to solution one copy someone else who's already done this hope that there's some genius out there who's written a great order book just take the exact same order book maybe modify it a little bit if you were trying to make your own and use that now again that's really still not a great approach you can still have a lot of inefficiencies and you still might have to loop a ton of times to be able to fill a buy or sell order now the third solution is kind of more of an abstract one but this would be to use something off the blockchain maybe like a sql database that's already very efficient at searching for specific orders maybe you write some advanced select query that can kind of give this information to you and then you store hashes of this on the blockchain whatever it's going to be unfortunately interacting with sql from the blockchain isn't really possible right now at least i don't know how to do that and so that kind of limits that option as well so even with the only feasible option which is essentially have a really good data structure and algorithm you're still running into problems now you might be asking yourself at this point in time well how is this done then how do people do this if this is such a problem now you can still use an order book it's just not going to be the most efficient thing in the world but what a lot of platforms are doing now is using something called a liquidity pool now liquidity pool has its own issues i'm not going to talk about those in this video essentially the liquidity pool is just a store of a ton of the assets that you're going to be trading so you have whatever asset 1 is in asset two you have usually an equal amount of them in the pool and then based on the demand for the specific assets the price of those assets will fluctuate within the liquidity pool and the people providing liquidity so putting their assets into the pool will be given a type of reward kind of like a fee that you would pay when you're actually trading them right anyways that's liquidity pool again has its own issues but that's kind of an approach that's being used currently and really with that said i think i'm going to wrap up the video here now i know i didn't talk too much about the solutions but that's because this video is really focused on the limitations of the blockchain and showing you that a lot of stuff we would like to be able to create that would be way simpler to do off the blockchain we just can't feasibly do using smart contracts and on the blockchain because of those limitations now even the stuff i showed you at the beginning of the video strings arrays for loops while loops those are very inefficient to use they cost a lot of money and the reason we left them until the very end was because we don't really want to encourage their use and i want to make sure that you understand kind of the problems with them and that they do exist you can use them but you should be very careful when you're implementing those specific features all right so with that said i am going to end the video here another massive thank you to cartesi for sponsoring this video and this series in the next video we'll be looking at specific solutions and how we can actually write scalable smart contracts in decentralized applications i hope you guys enjoyed if you did make sure to leave a like subscribe the channel and i will see you in another one