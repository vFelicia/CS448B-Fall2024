so in this lecture i am going to take a complex example or you can say lengthy example and we will see step by step explanation how to convert a relation which is in first normal form to bcnf right already i have discussed from first to second from second to third right but in this video i am going to combine all the steps means from first to bcnf how we are going to convert this relation so this is the relation and these are the functional dependencies given in this relation right and this relation is in first normal form if you want to check out obviously we need to find out the candidate key for this first step is this one because i have already discussed many videos many in many previous videos right so how can you check in this is in first normal form obviously we will find out first of all the candidate keys and then we will check if there is any partial dependency then there this is not in second normal form and that is why it is in first normal form by default the relation which is written something like this this is we consider that it is in first normal form right so now find out the candidate key first of all how to find out that also i have already discussed how to find out candidate keys from a given relation in my previous videos i'll provide the link of the complete dbms playlist in the description box you can check out there right so now take all the ah attributes of the relation and find out the closer obviously it will find out all the attributes right now try to discard the attributes using functional dependencies right a can drive bd so if you have a i can discard b and d right see b can drive c means if you have b you can drive c now obviously if you have a i can drive b right and if i i have b then i can drive c so i can discard c as well using e i can drive e and f so if you have e you can discard f and g sorry f and g right now if you have a and e a and e so you can derive h so you can discard h because i have a and e so the remaining attributes are only a and e find out the closer see using a i can drive a e definitely using a i can drive b d using b i can drive c using e i can drive f g and i can drive h all the attributes i can drive so a is what you can say it is a super key we cannot discard any more elements any more attributes from here so this is super key now proper subset is a and e obviously no proper subset would be super key because a closer would only contain a then bd and then we can drive c right not all the attribute e closure can contain e f and g only right so no this is neither this is superhero nor this is super q so that is why we can say that a e is our candidate key right now prime attributes are a and e fine find out more candidate keys are available or not if prime attributes are available on the right hand side of any functional dependencies means there are still more candidate keys but a and e are not on the right hand side so there is only one candidate key that is a fine now find out which functional dependency is creating problem means which function like dependencies partial dependency right see a can drive bd partial dependency means the proper subset of this candidate key drives known prime attribute then that is partial dependency a is partial subset and b d yeah this is non prime attribute because prime attributes are only a and e so this is partial dependency right s b proper subset of this one no so obviously this cannot be a partial dependency is proper subset of this one yes fg are nonprime attribute yes so this is partial dependency a is proper subset of candidate key no a is itself a candidate here you can see super key so this is not partial dependency means this these two functional dependencies are creating problem because of these two this relation is not in second normal form it is in first normal form now we have identified the dependencies which are creating problem so next step is what take out this one this functional dependency and find out a closer a closer would be this one a b c d right using these i will find out now put all these attributes in one relation right find out e closer e closure would be e f g put all these attributes in another relation right and put all the remaining attributes in a third relation remaining attribute is h only right but we cannot put only one attribute in this so now what you have to do see now there should be something common right because in this and this there is no common in this and this also no common so when you will join there should be something common we to to be a lossless joint decomposition right if nothing is common between the relation then this is low c joint decomposition right and we want lossless zone decomposition and dependency preserving so if we join this one and this one so what should we put common here see the common attribute should be super key or you can say candidate key of at least one sub relation right to be that decomposition a lossless joint decomposition right so suppose i put a common here obviously a is candidate key for this one because because using a i can drive b c d all the attributes so it's better to put a common you can put b common either c or d you can put these things common and you can check out right those would be loss c joint decomposition right now between this and this what should be the common attribute it's better to put what e common because each is what candidate key for this sub relation or you can say super key for the sub relation because e can drive f and g all the attribute of the sub relation right so now this is our third relation or in simple terms you can say one i mean in one relation we always put the candidate key c remaining attribute is h and obviously the candidate key is about a so we put a here so that thing also you can consider or you can apply the logic which i am uh telling here in this video right so now we need to check this is lossless during the decomposition right but we need to check the you know highest normal form for this also this also and this also because we are supposed to convert it into bcnf right now check it is converted into bcnf for node or it is still in first and fourth and second and fourth third and we can't say so for that we need to find out the functional dependencies and candidate keys right so functional dependency for this relation would be how to find out functional dependencies that video i have already discussed in detail i'll provide the link of that video particularly in this i button you can check out there here i am just writing the functional dependencies right so the functional dependency for this one would be here a can drive b c d because when you find out a closer you will get this one and a two a is trivial and b c d right when you will find out b closer then you will get b to c this functional dependency right how to find out you have to consider this functional dependency right now if you find out c closer then what would be the case c closure would be c only because see using c i cannot drive anything so this is trivial so we are not going to take it d closer also you can only get d nothing else so this is also trivial we are not going to take it right now a can drive all the attributes so no need to check with a b a c and a d like this because that would be duplicate right and b can drive c c and d are driving nothing so no need to check bc bd and cd right you'll you will not get anything you will check you can if you want to check out you can check out right so you will find out only these two functional dependencies here right now in r2 functional dependency would be if you find out e closure then f g would be there if you find out f closer nothing you will get f 2 f trivial would be there g closer nothing you will get using this function dependency right so there is only one functional dependency right e can drive all the attributes so no need to check ef closer and e g closer because obviously that would be uh duplicate and if you find out f g then that also would be trivial only f g you can drive using f g f j closure would be f g only right so no need to take there is only one ah functional dependency here now here functional dependency would be see if you find out h closer you will get only h trivial if you find out a closer then you will get this one but a2 is trivial bc bcd are not part of this one so no need to take this one we are not going to take e closure would be e f g e 2 is trivial f g is not part of this sub relation so we are not going to take it right so now one relation one ah dependency would be there here a e if you find out a e closure then that would be a using a i can drive bd using b i can drive c using e i can drive f and g right using a e i can drive h all the attributes a to a a is trivial see d is not part of the sub relation c is not part of the sub relation f is no and g only h is part of the sub relation so a can drive h right same you can find out h same you can find find out eh right you will get nothing all the attributes those you will get in closer that are not part of the sub relation right so we are not going to take those functional dependencies so only one functional dependency would be there in this case right now find out the normal form for this this and this same for that you have to find out candidate key the same process you will apply in each sub relations right i am not going to apply again because we have already discussed one time so when you apply the same process then the candidate key for the subrelation would be a from here only you can check you can drive all the attributes right so candidate key would be one candidate key is a and a is not on the right hand side so there is only one candidate key here the candidate key would be only e and here the candidate key would be a e now see is this partial dependency no is this partial dependency no means this is in second nf definitely but is it in third nfc check for three and f two conditions are there one of those two conditions should be satisfied either left hand side is super key or right hand side is prime attribute is left hand side super key yes so this is not transitive dependency right is left hand side super key no is right hand side prime attribute no because prime attribute is only one a so this is transitive dependency so this relation is not in third normal form it is in second normal form r1 check for this one e the left hand side is what only one dependency is there and the e is what candidate here you can see super key right so if the left hand side is super key of the functional dependencies of all the functional dependencies then that relation is in bcnf that rule we already discussed right so this is in bcnf this one left hand side is what super key or you can say candidate obviously candidate key is super key also right so this is also in bcnf but this is in second nf right so it's not like that we have got 2 bcnf so it is in bcnf now no it is still in second normal form because the lowest one we are going to choose right that is second normal form now you have to convert this sub relation only into third nf or bcnf this we have already got two sub relations right now we are going to work on this r1 only now here which functional dependency is creating a problem for third nf this one only because this is not creating a problem this is not transitive dependency this is transitive dependency so now take be closer now see we are not going to consider now this functional dependency because now we are decomposing this relation r1 and we have already got the functional dependency set for this sub relation so now we will consider this one to find out be closer so be closer would be b and using b i can write c only bc so one sub relation would be suppose r one one that is b c and a remaining would be in second sub relation that is a and d now we have to put something common right to get a lossless joint decomposition common should be at least super cube one sub relation as you know we can drive c so b would be definitely super key or you can say candidate k for the sub relation so better to put b common right now find out functional dependencies and then find out that this is or this is in bc and for node are still in third nf or still in second nf this is having only two attributes so this is definitely in bcnf right check for this one find out functional dependencies first f one two set would be if you find out a closer you will get a can drive bcd means b d because c is not part of the sub relation right if you find out d closer nothing you will get trivial functional dependence you will get if you find out b closer then you will get b and c b to b is trivalent c is not part of the sub relation so we are going to take only this one right because a can drive all the attributes so no need to check a d and a b closer right and if you want to check b d closer then you will get what b b and c only so b d is trivial c is not part of this one so we are not going to take that functional dependency also right so there is only one functional dependency now if you find out the candidate key then candidate keyword you will get that would be a only right now if you check left hand side of this functional dependency is a that is candidate key or you can say super key so this is definitely in bcnf so now this is in bcnf right now finally we have converted it into bcnf right because and now how many sub relations are there one two three and four we are not going to consider this because we have decomposed it into this one to to convert it into bcnf because it was in second nf right so four sub relations are there this one this one this one and this one and if you are asked how many sub relations would be required to convert this into b c and f then your answer would be four sub relations would be required these four sub relations right this is how this is the step by step explanation how we are going to convert a relation which is in first and m two first nf to bcnf right so that's it for today now i'll see in the next video till then bye bye take care