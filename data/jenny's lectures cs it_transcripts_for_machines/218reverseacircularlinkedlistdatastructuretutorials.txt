see as we have discussed how to reverse a singly linked list right what a reverse means suppose I have four node in the list right and in circular linked list the last node will contain address of the first node and we are maintaining only in the tail pointer tail pointer is containing address of the last node right so now what the reversing means we are not going to swap these nodes right what we actually do we are going to reverse these legs see here each node is containing address of the next node right but after reversing what it should look like this node would contain address of the previous node we are going to reverse this link right means now see this node is containing address of the next node that is 150 but after reversing this node would contain address this should contain address so the previous node that is here we will store 500 right this node also contain address of the previous node that is we are going to reverse this link we are going to reverse this link so see it is almost same as reversing a singly linked list that we have already discussed only difference is 1 now in this case last node is containing address of the first node but after reversing obviously we are going to reverse this link also so now this node is containing address of the this node now we are going to reverse this now this node should contain address of this node that is this node now should contain 600 so now we are going to reverse this link because after reversing this should be the last node and one more thing now after the versing tail good point here right so when you will display the link list after reversing then then it should print minus 3 6 1 & 7 now for this how you will do this reverse operation see suppose at some point of time I have a pointer to this node right obviously we are going to take some pointers extra pointers because we cannot move this tail right so forever thing we are going to traverse the link this list and with the traversing only we are going to reverse these links right so now suppose I have a pointer M pointing to this node now in this node I should store what value of address of this node for reversing this link right so suppose I have stored temp of next equal to from where I can get this address until I have this address so temp of next equal to L it means here I have stored what rather than this I have 600 now so now you can say this link is no more now this node is pointing to this node okay fine but now this link is no more then how you will reach till this node because obviously we are going to reverse this link also this link also right we need to reverse all the links so now suppose by applying some logic I'll tell you that logic we we have reached till here we have moved our temp here right we will discuss that logic also and we will write that code now in temp of next I will store what this node address of this node address of previous node so we have to maintain address of this node also because if you remove temp here then have you will from there you can get this address 500 because we have only one pointer left but tail pointer is pointing to the last node right so now you have to maintain one another pointer suppose I am taking previous pointer so before moving temp forward we are going to set this previous also now in previous we have 500 so we can write temp of next is equal to previous that is also fine now you have broken this link and now here I have 500 so this is now pointing to this node right now have you will move here so you need some extra point or one more pointers there so basically three pointers we need here fine what you can do before setting this before breaking this link before setting here 500 what you can do we can set suppose a pointer next node third pointer to this node and how you can do in next node next we can write next node is equal to temp of next that is 150 so here I have in next node we will have 150 so this will point to here so now you can break this link you can set temp of next is equal to previous and we have a pointer to next node also so we can reach till this mode right after that we can move the stem then we will move this previous also and the next rule becomes this one and now we are going to move till the snowed right till we reach here till the last node it means we are going to take basically three pointers here rather than temp I am taking what current you can take any name current previous and next node right so see how we will write down the code for this thing so as you can see we have declared three pointers preview pointer current and next node and these pointers are pointer to node because these are containing address of the node so here I am taking struct node right this thing I guess you already know that user defined area type the two parts are there this node data part and one is next point two this will contain address of the next only we have maintained only the tail pointer right so this thing we this is what the global part this we are going to use in all the functions if you call that create CLL function and display function or this function so this thing I'm going to write globally out of all these function and out of main function you can say after header files directly right after that you can define this reverse function now see we have taken three pointers now for reverse obviously we are going to traverse the link so for traversing we need one pointer so I'm taking that current pointer that is main pointer these previous and next node you can say these are supportive pointers of this current one is containing one is storing address of previous node and this will contain address of the next node right so first of all what you will do now we are going to start from head Nona from the first one we're going to start the traversing so we are not having any head pointer so how you can come to know that the which node is the first node so tale of next this will always contain address of the first node so how I can do current is equal to tail off next it means now current is pointing to this node in tail next we have 500 in current now we will store 500 so now as you can see this current is pointing to this node that is to the first node right now you can check if L is equal to 0 it means list is empty you cannot reverse the list right so you can after this you can write down this condition also if L equal to equal to 0 it means list as MPT you can print this thing ah if you want to print that's the rule so that if suppose in list we have only one node how you can check that thing we have discussed when we were discussing how to delete node from the circular linked list right if suppose only one node is there then tail good point here and current for point here right and this node would contain address of itself that is here also 500 here also so you can check else if that tail of Nyx does equal to is equal to pair or you can say current of next is equal to is equal to current right in that case you can directly poll that display function or you can say that there is only one node in the list and only this if seven is the node then seven would be printing after display after reversing the list else we are having four nodes now now see what is the situation now how you will write this thing here I will write a while loop while this current because for traversing we are using this current node when you will stop here right when this current becomes when current will point here it means current is pointing to the tail node it means current becomes equal to tail so we are going to move till current becomes until current becomes still so current is not equal to a till then we are going to move this current right so before moving this current obviously first of all we are going to set our previous pointer right so here you will write the spring is equal to current now the spring is containing five hundred so now this is pointing to this node right now only difference in this case is now it should have address of the this node right because we are going to reverse this link also right but at starting will not reverse this link we are going to reverse this link at last fine because if in while loop only you will write this statement now I can write previous off next here I want to store address of this thing that is 600 so here I can write of next is equal to tail right so if you write that statement in while loop then so then after some iteration current would point to this node in that case previous will point to this node right because this is the previous node now again that condition would be executed means previous of next as equal to tail so previous of next is this this pointer now so here you will store address of 600 so now this node would point to this node but that we don't want and after that previous would be this one current would be this one in that case also previous next is equal to tail so again and again that line would be executed so we don't want that thing so first of all we are not going to reverse this link we are going to reverse what next two links it means we are not going to change this value it means we are not going to break this link right so this link is still there we are going to break this link first of all we are going to store here what address of the previous node that is 500 fine and this link would be there still this link will go to be there at last we will update this pointer so now here obviously we will move this current now so here you will write current has equal to so now in current what we need to store the value of the snake this this node because we are going to move this current now current is pointing to this after that current will point to this node that is 200 right so now here how we can store this 200 in current see now here you need to set this next node pointer also see at starting we have said current is equal to pail next so after this line after this line before this if statement what you will write what you will write you will set next node also next node equal to current off next it means we have set both current and next node pointer now what is current of next current of next that is 200 so here now I have 200 so now this is pointing to this node right so we have said both pointers had starting current and next node after that you will write this if condition if tale equal to equal to 0 here you can print list as empathy right and in else part you will write this while loop now see in current what you will store address of this node from where you can get address of this node that is the next containing this node address of this node so now current is having 200 right so now parent is pointing to this node fine now we have previous we have said previous pointer also current also we have right so now we can update this part here you will store address of previous node for reversing that is 500 so here what I can write how you can access the spot current is equal to sorry current of next equal to how you can exist this part current off next equal to pre whatever the value in previous node right so now see we have 500 so here we have 500 now this node is pointing to this node this link is no more now so now see the problem is next node is also pointing to this node now how you can do it till this node so this thing you need to take care you will you need to write which line first so first before updating this we will move this next node in next nor do you want to store 150 from where I can get 150 here before abrading here I was 150 I was having 150 right so here you can write before this line next node equal to current off next current next means here before updating 150 was there so now current node is pointing to this node right and now you can update this now current of next is equal to previous that is 500 now you can break this link there is no problem because we have already set a pointer to next node right so now we will we are going to repeat these steps till here see again why loop current not equal to tail current is 200 tail is 600 so that is fine condition is true again will enter into this loop now previous is equal to current that is in previous we will store 200 so now previous is pointing to this node right now we will move this current current is equal to next node in next node we have 150 so in current we have 150 now current is pointing to this node right again we will move our next node should point here next node is equal to current of next current of next current is pointing to this node so current the next is 600 so in next node we have 600 so now next node is pointing to this node so now we have set drillings now you can update this value so now here see how you will access this part link to this notice current of only current is pointing to this node so current of next equal to previous in previous you have 200 so here you will store 200 so see what address of previous node is 200 so now this is pointing to this node right again current is not null sorry tail current is 150 tail is 600 so the condition is true we are going to enter into this loop again see previous is equal to current so here we will store now whatever the value in current that is 150 right so now you can see previous is pointing to this node we will move this current current is equal to next node so here we will store 600 right so now current node is this one and now next node is next node equal to current next now in current of next Bo 500 so in next node we will store 500 it means you can see next node is containing address 500 that is now this next node of this next node would point to this node right to the first node fine current of next current is pointing to this node current of next is equal to previous in previous we have 150 so here I will store 150 so it means now 150 this is pointing to this node right so this link was no more now 150 so this link has been broken now right now we need to say to this link see we have set all the links now you can see say current not equal to till now current is 600 tail is also 600 so this condition is not true so we are not going to enter into while loop fine so now you need to update and two things now we will set this pointer see this node is the last row now so this node should contain address of this node now fine because this will be the first node that is 6 now how do you can access this node pointer to this node is next node right so here what you can write in next node next you will store address of this node that is 600 and we can we we already know the last address the sorry that this of last node is always in tail point so here I can write a it means next node and next here I'm storing 600 so now as you can see this is pointing to this node remaining one thing is what you have to move this tail now in a l should point to this node right so in tail we want to store 500 so how you can get this 500 see pointer to this node link is next doors next node is containing 500 so until I can store whatever the value in next node fine so now Intel we have 500 so tail is pointing to this node right as you can see we have reversed all the links as well as tail is pointing to this node and now when you will display when you will call that a display function then what are the value should be printed 3 6 1 & 7 so this is how you can reverse a circular linked list see after reversing and this link is also there no not there now fine so this is I guess same as reversing of a singly linked list only the simple the difference is what here the last node will contain address of the next sorry the first node right so you have to take care of that link also and that link we will update in the last so after this you can write void main function in that main function you can keep in first of all create this linked list you can call that create CLL function then display function right then output would be before reversing 7 1 6 & 3 then you can call reverse function and after that again you can call display function so after that output would be minus 3 6 1 & 7 right so next video we will see the implementation of our doubly circular linked list see it was what a single a circular link ballistic fine so ice in the next video till then bye bye take