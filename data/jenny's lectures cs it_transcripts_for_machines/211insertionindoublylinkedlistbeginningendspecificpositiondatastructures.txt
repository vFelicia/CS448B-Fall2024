in this video we are going to see the insertion operation in doubly linked list insertion ad beginning insertion at end insertion at any specific position as well as insertion after a given position right or another case may be insertion before a given position right so far we have discussed the introduction of doubly linked list what is doubly linked list and how to create a doubly linked list as well as how to display the content of a doubly linked list I will provide you the link of those video in the side button you can check out there before going to this video you must check out those videos right see in the previous video we have created a doubly linked list right like this one head pointer is there this is the node each node is having two pointers one is pointing to the next node and another pointer the previous pointer is pointing to the previous node right it means this point is going to contain address of the next node and this pointer is going to contain address of the previous node right and this is what the data part three parts are there basically right we have already discussed how to represent this node when you are going to write down a c program right and c in that case we haven't maintained our tail pointer since this is doubly linked list it is you know very useful to maintain our tail pointer why so that thing also we will discuss now what is a tail pointer but you can say a last pointer see this head pointer is going to contain the address of the first node right or you can say the head node so the tail pointer is containing the address of the last node like this so in this case we have a pointer to the first node of the list also and to the last node of the list also now what is the use of this tail pointer why we are going to maintain this pointer see when you are going to insert any node in the last suppose I want to insert at end and I'm not maintaining this tail pointer right in that case what we will do we can not directly insert here we have to traverse the list till end right because sequential as possible and we have the information what you have we have just this head pointer we just have the address of the first node right that is why you have to traverse the list till end after reaching till this and now you can insert here right if the tail pointer is not there and if you maintain while creating the list if you maintain the tail pointer in that case you don't need to traverse the list till here why so directly you can insert one node here because we can access this node using the stale pointer right we have the address of this last node so simply you can update these links right how do we are going to update these links that also we are going to discuss when when we will discuss this function inserted and right so in this case the insertion in doubly linked list at end will take time order of 1 if you maintain this tail pointer if you don't maintain the stale pointer in that case you have to press the complete list it means it will be order of N and same with deletion if you want to believe this last node and if you maintain this tail then time complexity which would be order of 1 and if you don't maintain this tail then the time complexity would be order of n the delete operation also we'll discuss in next video so these are some advantages of maintaining this tail pointer but the drawback is what this is going to take some memory space right you have to store the stale pointer for bytes if the 32bit compiler is there and 8 bytes if 64 bit compiler is there if you don't maintain this then only 3 nodes is there then this this this node and that head pointer you have to store but if tail pointer you are maintaining then you have to store this also some memory space would be required to main to store the stale pointer also and you have to maintain this also if you are going to create a list in that case you have to maintain this trail pointer at starting if Lester is having only one node then head is also 100 tail is also hundred if you are inserted second node then head is 100 al is now 200 if you are inserted this node then tail becomes 250 so you have to maintain the value of the stale pointer also right now how to keep we have already discussed how to create a linked list but in that case we haven't maintained this tail pointer if you are going to maintain this tail pointer then how we are going to create the doubly linked list I am quickly write down the code for that thing this is what we have declared on we have defined our own data type that is struct node for this node you can say the type data type of thus node 3 parts are there one is data part and two are pointers and these are pointers to node that is why here data type in the struct node so here we are maintaining would two pointers head and tail so we are going to declare two pointers struct node estwick one is head and one is tail right these pointers are containing address off c head is containing address of this node right so here that is why I am writing we are writing the address of those thing or that that variable whose address this pointer is going to store so that is why here I am writing struct node because they retire both this node is what struct node now how we are going to create the list we are going to define a function you can say a create doubly linked list right so first of all we are going to create a node right first of all I want to create these type of nodes so that we can store these values and these pointers and mommy how in the memory is to be allocated dynamic memory allocation that we have already discussed many times so I'm going to write down that thing here right first of all what do you will do you will declare a pointer struct node type and this is how you can assign the memory dynamically to this new node see this this thing the syntax we have already discussed many times right right Malik is a function for dynamic memory allocation how much size you want size for this node right so here you write size of the data type data type is a struct node and malloc is going to return a pointer to the starting address of the located space or you can say my lock is going to return a void pointer and this pointer is what two nodes so that is why you have to typecast this pointer typecast means you are going to write here struck nodes s trick and whatever this fungus will going to return you are going to store that address in this new node pointer so after executing this wine one node has been created means memory has been assigned to that node so here suppose I am taking that we don't have anything in the list the list is empty right so you can say we have created a node address suppose is hundred and this new node is a pointer that is going to contain the address of this newly created node right say this node is having how many bytes for for this food for this and four for this to L bytes and this 100 is what address of the first byte right so it will malloc will return this address so now this address we will store in this new node fine you know disappointing you know the pointer is pointing to this node at starting me assume that head is equal to zero it means we don't have anything in the list and we have just to declare this tail pointer also fine now we are going to insert this newly created node in the list now first of all we are asked we will ask from the user what data I want to insert here so this is how you can ask from the user using printf and scanf the data I want to insert here into data and how you will insert the data here how you can access this part of this node this part you can do directly access this node you can access this using a pointer we have we have one pointer pointing to this node so new node new node and this arrow crater and which part you want to access data part so the data address of new road and data so here suppose I have inserted five and now here you will insert 0 and 0 first of all so I will in access this part that pointer to this node is new node new node arrow and name of this pointer is previous so is equal to 0 new node arrow next is equal to 0 fine now I want to insert this node in this head pointer now how you will insert this thing see first of all obviously you have to update this head value here you will store what 100 it means after that this is going to point here 5 and the next there is no next note so this is fine it will be zero there is no previous node so this is also fine that this would be zero now one another thing you have to do we are maintaining the scale pointer also so in tail also you are going to store this 100 so now tail is also going to point here now this is done fine now how do you write this thing into this code we have just updated head value and elven so here what I can write head is equal to tail is equal to here you will store hundred from where we can get this 180 so this is stored in this pointer so here I can write new node see but this is the case when head is equal to 0 it means when list is empty if suppose we have inserted this data one node and I want to insert second node right and second node the address of second node is 200 in that case the new node will contain 200 right and if in that case you will do head is equal to tail is equal to new node means both head and tail are going to point that new node that is 200 is going to store in head and tail now you are going you lose the reference to this node so there should not be a case so before writing this you will write if condition if head is equal to is equal to 0 in that case only you will write this thing that is fine but if head is not a 0 then in else part what you will do now this is suppose the list now I am I want to insert a second node in that case what we will do now suppose we have created one more node address is 200 this in this new node now 200 is going to store we have asked from the user using this new printf and scanf the data inserted is 6 and here is 0 and 0 now I want to insert this node into this list so now if head is equal to 0 but head is now 100 so this condition is not true and tail is also hundred so now we are going to enter into else part now in else part what you will do see what you are going to update here this part also and this part also here you will store what address of previous node that is hundred and here you will store address of next note that is this 200 fine after that this link would be established and this link would be established plus one more thing you are going to update this tail also now tail is going to point here because this is the last node so Intel you will store address this that is 200 so here you will store 200 right three things you are going to update now see now first of all this was 0 so how you can exist this part both using head pointer and tail pointer because before updating this tail corner is containing hundred so I can write here in next Elauf next here you will store this one where we from where you can get 200 from this new node because new node is containing 200 is equal to new node so here we I can write 200 so this link is established now enough how you can access this part the link to this node is pointer to this node is a new node so how you can access this new node and the name of this part is previous here you will store 100 from where you can get hundred using this tailored you can say using this head so here I am writing what they write I'm not writing head because say we cannot move this head when you will insert the third node then obviously the Hybris of second node we are going to store here and tail is containing address of the first node only right so here we are going to write here only the tail because we can move this tail only we cannot move this head so now this is containing 100 now remaining part is you are going to update this tail tail is equal to new node from here we can store here 200 now tail is pointing to this node right now the same logic you can apply after this it will ask you do you want to continue and if you press 1 then another a node would be created and inserted if you press 0 then no extra node would be created and only you can call after that you can call the display function so that thing you have missed how you write here you can write printf we want to continue in scanf you can take the value from the user and you can write down a while loop here before this line before this line because if you if you'll insert one in that case only new node would be created so before this line you can write down word while and choice right choice is a variable you can take in this function only into torus is equal to 1 right and here also printf do you want to continue in scanf you can write percentage d address of choice this as we have discussed already here the main motor is what have you can maintain this tail pointer so high hope you got the concept now we are going to insert at beginning how you will write this function C so now let us take this case we have these three node in the doubly linked list head is containing 150 and tail is containing the address of the last node that is 200 we have created this list by calling the Creator DLL function now I am going to insert a node and at the beginning of this list fine so this thing we have already discussed many times we have created this node that is new node we have allocated the memory using the Mallo function dynamic memory allocation and their dress is 500 so this new in new nor pointer we are going to store what 500 son of this is pointing here now we have taken input from the user using this printf and scanf enter data and we have user has entered what the 6 value is 6 so we are going to store the value here in the data part so have you can access this part address of new node pointers new node arrow operator and name of this part is data fine and here we will store a 0 and 0 see here you can store in the previous pointer obviously this is the first this is going to be the first node so in the previous node null would be there so here I can store new nor previous is equal to null but we are going to update this pointer so if you have you will not store this new node next is equal to 0 that is also fine you can only write new node previous as is equal to 0 now how to insert this node into this list right we assume that list is not empty so we are not going to write down that and if head is equal to is equal to null in that case head is equal to tail is equal to this new node only one node is there I'm here assuming that we have three node in the list so how you can write if you want to write you can write down that condition also in else part you can write whatever I am going to write here so now which link we are going to update see you have to update this link first of all this is going to contain address of this mode because this is now the first node right so here you will store what address of this node that is 500 here you will store 500 so how you can store this this 500 here how you can access this part the pointer to this node is head yes we have a pointer so we can access all the three parts so here what you can write head of previous this part is previous is equal to from where I can get this 500 this address in the new node we have 500 so is equal to new node so now this is now containing 500 fine so now this is pointing to this node now again you have to set this link this node should point here so this node should contain address of the next node that is 150 right so here you will store what 150 how you can access this part the pointer to this node is new nodes so here I how you can access new node this part is next name of this pointer is next is equal to from where I can get 150 value in head point that is 150 so is equal to hey now this is pointing to this node now you have to update one more thing that is head now head is containing address of this thing that is 500 so here you will store 500 so now head is pointing to this node this is the first node now from where you can get this 500 from this new node head head is equal to new node right so this is how you can insert this is done now this is how you can insert this inserted beginning no need to change the tail value right now next thing is how you insert how we will insert it and so now the situation is something like this after inserting at the beginning we have enough for node in the list 1 2 3 & 4 and now I want to insert a node at the end right here this node I want to insert here so I hope you got that this coding would be same here I have just updated the name of this function that is inserted and same we have created this node dynamically we have allocated the memory addresses suppose 400 this 400 would be stored in this new node pointer we have taken the data from the user we have here we have put 7 and here we have put 0 and 0 now how to insert this data here see if you don't mean in the scale pointer suppose tail pointer is not there now how you can access this part bigger foreign because for inserting this node here you have to update what you have ported this part here you will store what 400 rather than 0 here you will store 400 right but we cannot access this part because we can only access the structure values or you can say the variables you need some pointer pointing to this node but here we don't have any pointer that is wife tail pointer is not there then you have to Trevor still here like we have discussed in singly linked list using a tenpointer temp is pointing here then here then here and then finally temp will reach here after that using temp you can access this part but here and in that case that time complexity would be what order of n because you are traversing the complete list but here we have maintained a tail pointer already right so no need to traverse the list we can access this part of directly using the tail pointer right so no need to write down the while loop for traversing simply you will write so how you can access this thing the pointer to this node is tail so here you can write tail off next the part of this the name of this part is next is equal to from where I can get 400 the address of the next node in the new node pointer is 400 so here I can write new node so 400 would be stored here now so now this pointer is pointing to this node one another thing you have to take care the previous node of the newly created node here you will store what previous of the sorry then address of the previous node that is 200 right so how you can access this part the pointer to this node is new node so here I can write new node and the name of this part is previous is equal to from where I can get 200 tail is containing 200 so here I can write a so now this is also pointing to this node one ik one more thing see you have to update this tail also because here the last node is this one so tail in tail you should store address this 400 from where I can get 400 from the new node so here I can write new node so now tail is pointing to this node right and this is done say this tail is equal to new node please don't write this here at starting if your right tail is equal to new node here means 10 is equal to new node means now tail is containing 400 so this is pointing to this node so now how you will access this part because you have already changed that L value that is 400 so now we don't have any pointer to this node so we cannot access this part so better you change this point to this point first after that update the tail value right so next thing is how you can insert and is at any specific position so now we will insert a node at a specific position now suppose user enter that I want to insert a node at position 3 it means 1 2 & 3 after this here I want to insert before this and after this because position third is here only after these two nodes right so now first of all you will check if position is in negative or less than 1 then you can say in valid position if position is greater than the length of the list it means also that is invalid position right and how to calculate the length of this list using the predefined function that is length function you can use and you can calculate the length and store that length into a variable you can say L or you can say le n or you can say length variable and an if condition you can check if position is less than 1 and position is greater than length it that is invalid position in else part what you will write that thing Here I am going to write so first of all in this function what you can write you can ask from the user enter the position and in if statement you can write if position is less than 1 or greater than the length then you can say inverted position right here in this function you can declare this variable that is int POS fine and suppose if position is 1 it means position 1 means here at starting only you want to insert fine so here you can write else if position is equal to is equal to 1 in that case you can simply call that function insert add beginning fine if you have created all these function in the same program or you can write down here if you are not creating in the same program then here you can write down that code inserted beginning and now in else part so now if suppose position is 3 user has entered position is 3 means 1 2 & 3 here after this node and before this node so you have to create it create a newly new node you have to assign a memory using malloc function we will here you will put say 7 here we will put a 0 and 0 how we are going to create that this thing you have already discussed many times I am going to write down here simply that thing so now say this is how we have created this new node we have taken the data from the user that is 7 if you don't exert here 7 and 7 that is also sorry 0 and 0 that is also fine because you have to update this thing also in this pointer also right now how you can insert this thing at position 3 you can know that it'll insert here you have to traverse the list till here so we are where we are traversing the list till position minus 1 means till this second node right so how you can traverse using a while loop so here what you will write why and using a variable suppose I am taking a variable I I less then position minus 1 right position is 3 so 3 minus 1 that is 2 he till here I want to traverse the list so here you have to declare this I variable also in this function word insert at position after this when you are going to declare this pose here also can declare int I is equal to 1 you can initialize this also to 1 suppose I is 1 from here I want to start so now see I value is 1 at static values 1 position is suppose 3 so now how he will traverse this list till here see we cannot move this head so we are going to take one another pointer right pointer to a node so here you have to declare one another pointer suppose here I can declare struct node new node and one more point that you can set them right and at starting temp is equal to head temp is also pointing to this one that is 150 so temp is also pointing to this node so here in else part after declaring this temp here what you can write M is equal to head right now you can move the stem now see I less then position minus 1 I is 1 position minus 1 that is 2 so 1 is less than this right how you will move this thing first of all then we will move this temp is equal to here it means now temp is going to store address of the next node that is 100 from where we can get this 100 here we have 100 so here what you how you can write temp is equal to M next because this part is what temp off next so now temp is containing what hundred and amp is now pointing to the snow and we will do it I plus plus right now in I plus plus now I becomes 2 now take 2 less than position minus 1 2 less than 2 no so we are not going to move this temp now see we have reached till that position till position minus 1 because after this only you are going to insert now position is 3 1 2 so here I want to insert this node right now we have raised till this position now we are going to write down the code how to insert this node here see I am going to rub this thing say this is just you know you have find your own datatype this thing you will write outside of these function and outside of the main function that is globally because we are accessing these this thing in all the functions right so now you have to update four links one is this this will contain address of the next node next is this newly created node that is 501 is this this will contain address of the previous node that is 501 link is this this will contain address of the previous node now previous of this node is this one that is hundred and here you will store address of next next one that is 200 so for links we're going to update now first of all it is better to maintain to better it better to update these links so here what you will store address of the previous node address of the previous node would be hundred so from where I can get this hundred see the temp well you is now 100 right so simply what you will write how you can access this part new node previous so here what I can write new node previous as equal to M now we have updated this link now update this link here you will store address of the next node that is 200 so now from where I can get this 200 see here the tail is also containing 200 but always that is not a case suppose I have 10 node in the list so Ted will contain address of the last node so we are not considering the stale now so frame from where I can get this 200 from here now how you can access this part here you will store 200 means it will point to here so first of all I will access this part say new node next so new node next now from 200 how you can access this part this 200 how you will get this thing link of this node is temp so here you can write temp off next so now this link has been set now you can update this end this so now here you will store what address of next node that is 500 here also address of previous node that is 500 so here also 500 and here also 500 and from there we can get 500 that is new node but the main point is how you will this part in this part see how you can access this part simply pointer to this node is yes we have a pointer that is temp so how you can write temp off next is equal to new no so now this link has been set now we have 500 here so this link has been broken and this is now pointing to here right now how you can access this thing because we don't have any link to any pointer to this node right just don't consider now the stale pointer I am considering that suppose I have 10 node in the list and tail is pointing to the last node right so now how you can access this part see the address of this node is 200 right how you can reach till 200 see here we will have 200 right and how you can access this part the link of the pointer to this node is new nodes so here what you will write new node and this part is next it means we have reached till here till 200 right now at this point also we are going to insert we are going to access in this part means previous part so here again multiple arrows you can write and the name is this previous right now we this is how we can access this part so here you will store 500 that is the value of this new node right so now here 500 is there this link has been broken and now this is also pointing to this see I'm not saying that this is the only method you can update these links right maybe after this temp is equal to hundred so you can at this point only you can write down you can take another pointer that is tempo 1 or you can say next node and a next node you can store this 200 from where you can get 200 because before updating here we will have 200 right so in new next node we can write next node is equal to temp off next so now next node is pointing to this node right so you don't have to write these multiple pointers you have a pointer to this node also you have a pointer to this node also right after reaching after this while loop here you can write maybe you can say a next node is equal to tempo next here you have to declare one another pointer that is s trick new node in that case you have to take two pointers but say the concept of two pointers basically be used in singly linked lists but here only the single node is having previous node address and next node address so no need to maintain two pointers using single pointer on only we can insert any node in any specific at any specific position and one third method is also there to access this part right before updating this before updating this 500 here value is 200 right so how you can access this part here you can write temp next temp here you can write temp next and after that again arrow and then previous and there you can store new node so third page also there right if you go to this point then you can write down in the comment box what is the third way have you will write that thing so now we will insert a node after any position so now the function is insert after position here the coding would be same except few changes see after position means suppose now position is 3 1 2 & 3 so after third here I want to insert it's not like at third 1 2 3 here I want to insert in that case here I will insert fine so here I can take that case suppose suppose position is 2 means 1 & 2 so after this after 2 here I want to insert same thing say at starting I am considering this this and this 3 nodes and this is the newly created node and this node I want to insert here so now everything would be same now what you have to change same you will enter the position you will ask from the user if position is you will check position is valid or invalid if invalid then you will print invalid position in else part see you will not write this case else if position is equal is equal to 1 if position is 1 means 1 so after this one here to insert this is not a case of insert at beginning right so this you will not write in this case after position case after this invalid you write directly else and now you are going to create a new node like this you will ask from the user what data you want to insert so now in while look what you will write the condition suppose position is 2 Here I am taking that case where position is 2 C position is 2 in this case after this here I want to insert right so now we are going to traverse the list till this position right so here you will insert I less then position would denote position minus 1 because in that case if you insert insert at position position is supposed 3 means 1 2 & 3 here I want to insert so you have to traverse till 2 means position minus 1 but here after position I want to insert so you have to traverse till that position or position minus 1 if your if position is 2 and you will Trevor still position minus 1 then how you can insert this node here right so you have to reach till here so I is less than position now and this this coding would be same if you don't use this another pointer simply you can write this thing here so here I am NOT going to explain this thing I recommend you to please practice the operation of these doubly linked list and tell me after writing the same code and this change whether insert after position function is working properly or not see I recommend you to please write down the score with your own hand please type each and every line it's not like that copy the code from the neck and just simply run the program and here it's done because if you want to remember the things for a long amount of time for a long period of time then it's better to type each line with their own hand so here now what about time complexity see if you want to insert at beginning then order of 1 if you want to insert it and give tail pointer is there then order of 1 right if you want to insert at any specific position then it depends on the then you can say this proportional to the number of elements in the list you can say if you want to insert in the middle then how many node you have to traverse n by two half node so in that case it is order of n so next video will discuss how to delete a node from a doubly linked list right so I'll so in the next video till then bye bye I take