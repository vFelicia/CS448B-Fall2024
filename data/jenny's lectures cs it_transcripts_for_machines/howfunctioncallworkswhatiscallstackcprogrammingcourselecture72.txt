hey everyone I hope you are safe and doing good so in the series of learning C++ programming language we are discussing functions in C++ right till now we have discussed basics of functions right then call by value call by reference or we can say pass by value pass by reference these two things then function overloading then some coding exercise based on that then how to pass arrays to a function right and one coding exercise for that thing also right now we will discuss in this video how function call actually works right like we call a function in main function we are calling one function then I say the control will pass to another function then that function is doing some you know a computation or some processing and will return some result right so how actually this thing is working how function call is actually works what is happening behind the scene right so you don't need to go in that much deep like because obviously there are these things are working on lay of instructions so we don't need to uh go in deep right but yeah you need to you know to Su what you need to understand how behind the scene what is happening how this function call is working right so we'll see that thing in this video now first before uh discussing this thing the actual working let me show you if you have a program then how actually the memory is laid off for your programing that computer memory right so the memory is divided into into segments actually something like this so we have one segment this is our code area where her actual code the program is there then this one is for those static or if you have some Global variables then for those memory would be allocated and then one we have this area for stack like stack memory and this is Heap right so this is kind of free storage and Heap this we will not discuss in this video because this we will use when we discussing like Dynamic uh memory allocation and all so this thing when you are calling functions then this memory the stack memory is to be used so for about this area we'll be discussing in this video right now functions basically use that function called St it's like the normal stack which works on that Leo principle last and first out it's like you can see a stack of uh your in your wardrobe you put your clothes stack of clothes right so last in first out principle so the same function goal stack also works in this principle last and first down right now see whenever a new function is to be called then an activate ation record is to be pushed or created in that step now what is that activation record that activation record contains some information about that function like about the parameter of the function or you can say store the parameter of the functions or it has space for those local variables of the functions some temporary variables also there in that function and as well as the return address it also stores that activation record of that function stores the return address because obviously we need to know that fun need to know where to return after processing Where to return so that address would also be stored and some other information also some registers information and all so in that much deep we will not go here so this is basically the memory right for our program how the memory is laid off for a program okay but see one thing you need to remember this stack sizes it's not infinite it's finite right so if there are many more activation functions or many more activation records more activation records then there would be a error you can get that um stack Overflow error right and whenever a new activation record is created means whenever a new function is called so obviously activation record is created and pushed into the stack right so and whenever the function terminates then the activation activation record for that function would be popped out out from the stack and the control will return to the calling function now let's see this thing with example okay so let's see this example suppose we have this program and you have to find out you just dry on this we'll dry on this and we'll see what output you will get right okay now at first obviously we know the control will go to here main function main is a function right so an activation report would be one entry would be created for Main and pushed into that function called Step so we have something like this let's take this so this is for me right and what in this activation record this activation record is also so we'll store here what information local variable of the function parameters return address of the function and some other information also I'm value and all but here we will store only local variables and that's it right our parameters so here we have num one and num two so here we have memory would be allocated to num one and num two num one is three and this is seven and one is result one variable and that is zero right now on the next line in the next instruction we have result is equal to addition num one and num two so here we are calling this function see addition num one and num two so this is function call now whenever the control will go to here addition and after processing the control will go back return back to this only right so the return address that would also be stored like where that function would be returned so that returned address would also be stored right but that we are not going to store but yeah behind the scene it is happening the return address is also stored here in the stack right for this activation frame now if addition means next the control will call this function right means what is happening one more stack frame now this is the active stack frame this is for addition right so now this is the active stack frame we have int a int B the parameters so A and B right value to be passed num one is here three here we have seven so in a now we have three in B now we have seven right sum is equal to 0 one more local variable we have that is sum that is Zer here now sum is equal to a plus b means sum becomes 10 right okay fine in the next instruction we have subtra substraction sum a so again we are calling one more function that is substraction now where is that function this is that function substraction right so now one more stack frame would be post or the activation record for substraction function now the active frame is this one right okay now here we have see here we have reference variable m per X so this sum we are passing with pass by reference and this A and B we are passing call by value right so in pass by reference this x is just an alas or alternative name of the sum means actually you're passing the address that is it right so we not passing the actual value of sum that is 10 no so here we have X Y and Z so this x whatever the sum we are passing that would be going to to this x then a to this Y and this B to this Zed fine so in x x we don't have any value X is simply the another name for the sum we passing like basically the address it's passed by reference so it is just pointing to this sum that's it right now in y we have three and in Zed we have 7 here here one instruction we have x = X y Z right so x = X y now X is this 10 10 y 3 7 that is sum becomes zero now here sum becomes zero in this addition here sum becomes now zero because we are passing this value passed by reference so now it means we can alter the ual value we not passing the copy okay now there's no return but as soon as the control will see this curly Braes closing braces means return so where it will return yeah because the return address is also stored in this activation record so this function knows where to return so it will return back to this here here where we are calling this from addition function we are calling addition is calling function so it will return here right and this this Frame would be now removed and the memory would be freed so all these local variables are gone now activation record is now this one is gone now activation record is this addition for this function addition right now here we are here in this in this line so the next instruction is this see obviously the return address is stored so we know using the program counter which next next instruction is to be executed all these information is to be stored right everything sub register values values uh stack pointer return address program counter and all stack pointer and Base address all these values is to be stored right behind the scene right now next instruction is return sum basically we are returning some Where to return where we are calling this sum the addition function here so it will return here now sum would be returned sum would be returned here and in result that sum would be stored so result becomes now zero because sum is zero right and after returning this uh stack is also gone this stack frame is also gone right so now the activation frame is main main function now in main after this we have see out result so result will be printed that is zero and return zero return zero means successfully out of out from this uh program right so now this is also F now all the summary like free right me also poed out so one by one the activation record would be popped out whenever you on I hope you got the internal working I mean how the function f is actually working right that's it for this video in the next video we'll see uh scope of variable right this you need to understand what is the scope of variables right and then we'll see uh recursion in functions right so now I'll see in the next