the topic is deadlock handling in operating system see in the previous video we have discussed discussed what is deadlock and other Coffman conditions for deadlock or you can say necessary condition for occurring the deadlock okay now basically four techniques are there for deadlock handling deadlock prevention that lock avoidance deadlock detection and recovery and finally dead block ignorant see in real life also if some problem comes then basically these four approaches are used to solve the problem so I just want to tell you I just want to give you one reallife example like when educational type of example suppose some students are preparing for gate examination fine so one category is those students who you know not only want to get clear the gate examination they also want to get into IITs they want to score very well fine so they'll then do what they'll maybe dedicate to proper one beer and from starting of the year they start preparing nodes doing coaching and solving more and more previous gate problems and all they're very they're working very hard and ultimately the they get into IIT so that is something prevention of the problem problem means they want to prevent the failure prevent the failure plus they want to perform well so for preventing the failure what they are doing they are studying they're working very hard and doing very well now second category of student is see they don't want to get into IIT they just want to clear they just want the passing marks if thirty five is the cutoff for that gate examination then they just one that they get 35 or 36 then that's okay with those kind of students so they do what they they will not work for to come they will not work hard for a complete year they maybe just devote three or four months and they just do maybe weekend coaching or something like that and they just got thirty five marks these are second category of students so these these students are just they are just avoiding the failure they don't want to perform well but they just want to avoid the failure Casey there I am passage am failing you Amara get clear huija so third category of student is they'll not work hard they'll not study if they think that why should I study maybe I might apply that took a kind of thing and for first ten questions I just mark a and for next ten question I just mark B and something like this and maybe maybe they can get 35 marks that cutoff marks so they can get past so when maybe at some time and result come then therefore they find that they detect that they got less than 30 marks less than 35 marks so now at that time they detect the problem and then they want to recover that problem maybe they think that the next time we'll work hard and we'll get above 35 marks fine so tale problem till the problem doesn't come these kind of students are very cool after problem comes they detect the problem and they try to recover that problem fine now next category of student is they they just ignore the problem it doesn't affect that they are they are getting 35 marks they are getting 30 marks they are getting minus 30 marks or they are getting maybe 80 marks that is fine with them so they are just ignoring the problem it's something like that if you think that there is a problem then okay there is a problem if you think that it is no problem then your mindset will be something like that that yeah there is no problem and you are very cool see all the fourth category of students have solved the problem with their own method so if you come to the terms of operating system then here also we have these four kind of method to handle deadlock or problem right now first method is deadlock prevention we can't say this method is best and this method is not good see it depends we will discuss that them all so first of all see what is deadlock prevention means prevent the deadlock from occurring do something that deadlock will never occur maybe using some techniques apply some set of protocols such that and deadlock will never occur in the system so obviously you can say that this one is best if you prevent the deadlock from occurring then obviously this is the best but problem with this case is what lots of effort will be needed to write down the code how to prevent deadlock and obviously that coast would be very much ghost in the sense like in case of time complexity in case of space complexity and if you add one more functionality to operating system C and C suppose this one is your operating system this one is good for your operating system having some functionalities and if you write one more code to handle deadlock in this case then obviously you are adding one more functionality to operating system then you can say that performance it affects the performance of the operating system also so we cannot say that always deadlock prevention method would be best sometimes deadlock ignoring ignorance is also good C next method is deadlock avoidance avoid the deadlock this is something kind of futuristic approach in this case we we the system maintains a table in which it maintains that a process will need how many resources to complete its execution fine and when any process requests some resources then the system checks that if that request has been fulfilled with develop with the resources which are available then if the system goes after fulfilling that after fulfilling that request if that system goes to unsafe state then the operating system will not fulfill that request and if after fulfilling the request of that process the system is still in safe state then the process then that operating system will fulfill that request we'll discuss this case in next videos in DT fine notice deadlock detection and recovery as the name suggests let the deadlock be occur once a deadlock occur detect it and try to resolve it try to recover from it using some methods though those methods we'll discuss in next video last one is deadlock ignorance or you can say ostrich method simply nor deadlock it is assumed that deadlock will never occur in the system so this kind of technique is used in your Windows and Linux operating systems why so because they think that deadlock occurs very rarely once in a year and if you right so why then if deadlock occurs once in a year very rarely then what is the news to write a fullfledged code a complete code for handling the deadlock which requires so much efforts to write it is very complicated for obviously handling a deadlock preventing a deadlock is not very easy task so writing this code is very tough fine and it will also affect the performance of the operating system as I have discussed operating system is having some functionalities and one more functionality you are adding that you have to handle the deadlock also there obviously performance will be affected of operating system and while you are adding extra button to operating system when deadlock occur very rarely once in a year and if deadlock occur then you can easily reboot that system see this kind of technique deadlock ignorance kind of technique is used in operating system which are basically you know used by end users and user Macduff wiII be the end users usually user laptop for maybe browsing or some normal stuff so it's very you know common for us to reboot our system maybe when system got hold we just power of the system we shut down the system and restart it and that is very common for us but say deadlock ignorance is not applicable in some kind of situations like in our aircraft or you can say an aeroplane maybe obviously there are some systems operating system is also there and which is handled by pilots and all something like that and suppose in the middle of the flight deadlock occurs in that case what happens if system is not working you are not the pilots are not able to control the aeroplane then what will happen it is way whiskey right so in that kind of system we cannot say that deadlock ignorant is a good idea we have to prevent deadlock although it is it is it requires lots of effort and all but you have to handle the deadlock so which which method will be applied when it depends on the nature of the problem second thing is if suppose and you can say you can take example of hospital many machines are there today saying you know hospital many machines are there and they are to be operated with the help of obviously computers and in there we have operating system also and in that case if we suppose that we follow the rule of deadlock ignorance then what will happen although deadlock appears once in a year but for once in a year for that time it is very risky it can it can take lives of many patients if that machine is not working working maybe it is possible so in those kind of system when very critical jobs are there in that case we need to prevent the deadlock if simple for end user if you are using for any user systems it is better to ignore the deadlock rather than putting so much efforts in developing in writing the code for handling or for for preventing the deadlock for avoiding the deadlock this is of no use fine because basically end user wants what performance or speed they they do not focus on correctness we are not any doing any scientific task or something like missilelaunching and something like that fine so we want speed or performance so if for some amount of time for 2 or 3 seconds our system would hold then we simply just restart our system and that is fine with us right so there these are the four techniques will discuss these techniques in details one by one in this video I am going to discuss with you deadlock prevention technique see we have discussed four necessary conditions for occurring deadlock mutual exclusion hold and wait no preemption and circular wait now how to prevent deadlock if suppose you design a system in such a way that anyone at least one at least one out of the four conditions cannot hold in the system then you can say that deadlock will never occur in the system I'm not saying that all the four conditions you have to fail all the four conditions no at least one condition just violate at least one condition from the four from the four necessary conditions and then at any time in the system and then deadlock you can say that deadlock will never occur in the system so first condition was mutual exclusion so you can say that first is the first point is removal of mutual exclusion you have to remove mutual exclusion now what is mutual exclusion at least one resource in the system should be non shareable means only one process can use that particular resource at one time now how to remove which like the mutual exclusion make all the resources shareable but that is not so easy and almost impossible this is in implementable we cannot implement this man and this method we cannot make all the resources shareable because some resources are inherently non shareable you cannot make those resources shareable like a printer that is non shareable resource although in case of printer the spooling method can be used now what is the spooling method see the memory which is associated with that printer takes jobs from all the processes fine and after that printer will collect all the jobs and print one by one in firstcome firstserve so process need not to wait for the printer process can do its own work that is spooling basically but this pooling is also a technique which cannot be applied to every resource so we cannot make some resources shareable and if you force a resource to be used by more than one process at one time then maybe some very serious kind of problem may arise in the performance of the system so this is basically invisible not feasible to implement the removal of mutual exclusion fine second technique is was holding weight so you have to fail that condition so you can say that second point is removal of hold and weight but you can say not holding weight negation of hold animate or you can say either hold or weight now how to remove this technique how to fail this holding weight technique what is Alden wait first of all process is holding some resources and requesting for another resources or you can say waiting for some another resources find that is hold and wait but you have to remove this hold and wait so you have to make sure that when a process is requesting for some resource then that process is not holding any resource now how to you can how to ensure this thing there are three methods first is first is see a process must acquire all the necessary resources before execution starts suppose a process wants ten resources fine so before its execution starts the process must acquire must hold all the ten resources after that it can start its execution let us take one one process let I want to you know print some document and first of all I I'll make the document MSF s so I need my laptop and I want to print that also so two resources I need one is laptop and one is printer so before I start typing the document I acquired printer also so we have laptop plus printer also now suppose when I am typing that document I need maybe you 10 minutes 15 minutes half an hour one hour till then the printer I have acquired that printer so this is what that is wastage of that printer now while I I'm working on my on ms word till then any other process can use that printer and after that I can use that printer so the drawback of this approaches resource utilization would be very low second thing is this this kind of approach is practically not feasible to implement why so because it's starting only process need to acquire all the resources it needs for its execution but it is almost impossible to know how many resources that process will need for its insufficient for completing its execution so that is practically not possible so see this approaches not implement a very practically not feasible now second thing is second approaches so see a process is having nothing at one particular amount of time fine now suppose at some point of time it needs only one resource fine some may be at some particular point of time I need only laptop I want to write the document I don't need printer I need printer after some amount of time so the process will acquire the desired resources when it has no resource fine and use those resources and now now that process wants additional resource but before requesting the additional resource that process has to release all its acquired resources let us take that example see I am writing some document in preparing a document in MS Office on my laptop and I have done with my that that kind of work now I need printer but if I request for printer then I have to release laptop cannot see that I hold that laptop also and I request printer also because we have to remove hold and wait condition so if you are requesting for some additional resource you have to release the acquired resources then I have to release laptop fine and again in that case after that I can request printer and suppose printer is free and I got the printer but in this case what happens sometimes that process needs that previous that old resource also plus the new resource also but that process now only have the new resource but that old that old resource has been released by the process now it has to make a request to that old resource but before requesting some additional request it has to release that printer or it has to release the resource that it have at that particular amount of time so this thing happens so see if I have taken my you know that word file in my pendrive then I don't need laptop I release laptop I only take printer and just take out the printout so that is fine but if I didn't take that file into my pendrive then I need laptop also fine but I have now printer only now I will request laptop but before requesting any additional resource I have to release printer now here I released printer okay now suppose I got laptop now I need printer fine so maybe printer is also free at that particular amount of time and laptop is also free so I got all the do all the two resources at the same time so I can do my work but the drawback of this condition is what this this approach is what starvation problem now again again that thing happens if I have laptop then I have to release printer and printer is taken by some other process fine now when I request for printer I have to release laptop now if printer I have printer then I have to make request for laptop fine so this this kind of thing always happens maybe you have to that one process how to release its resources many times and maybe it is a case that once it is having maybe many number of resources and suppose the process is having 10 resources and it needs one more resource now before that any additional requests it has to release all the tender sources yes or no now maybe after maybe again if that process request and that process is not able to get so many resources at same time so many times that process has to release its resources so starvation problem can be there so third approaches wait time bound poking out third is you allow one processes holding some resources and waiting for someone other resources but here the condition is you you you just make that time bound on the waiting time maybe suppose I have having that same example I have IMing laptop fine and now I'm holding my laptop and I want I have requested for printer now no need to release this laptop but I can wait for printer for a limited amount of time that is to be set and suppose that time is for that time is 10 minutes so I can hold that laptop and I can wait for printer for 10 minutes only if within those 10 minutes I got the printer then that is the best yes I will get the laptop also and printer also I can do my work but if that time bound expires then I have to release all the acquired resources I have to release my laptop also fine so there would be a time bound on the wait that is why it is known as wait time bound the process can hold something can hold some resource can wait for another resource for some time bound if within that time bound that process worked that resource for which it is waiting and it is best thing and but if but if time quondam expires that waiting time expires then that process has to release its acquired resources also so that is very time bomb so next is removal of no preemption no preemption means you cannot forcefully take any resource from a process fine but now you have to remove the snow preemption means we can forcefully take we can forcefully take any resource from a process but from which process you can take from wait process not from a running process right because if and this this kind of approach is used by higher priority processes or you can say system processes may be some system processes there and that process needs some resource fine obviously system processes having higher priorities highest priority so people who don't want that because of that resources that system process got blocked and deadlock is there so we preempted the resource from some low priority processes and give the resources to that system process so that is known as preemption technique this technique is basically applied for higher priority processes where you can say system processes let us take one example see you you got stuck in traffic but suddenly ambulance comes so obviously everybody will you know give way to ambulance because ambulances if having higher priority we cannot say that if we are we we got stuck in the traffic then why this ambulance is allowed to pass that is not a case fine so for higher higher priority processes this preemption technique can be applied not for all the processes okay now what is in this technique so in a non preemption removal of non preemption see resources can be preempted from processes and this this technique will be applied for higher priority processes end so you can say for system processes what are the techniques one technique is if process is holding some resources and requesting some another resources but that request cannot be immediately fulfilled we cannot give that requested resources to that process at that particular amount of time then what will happen then that process then all the resources of all the acquired resources of that process will be preempted same scenario which we have discussed in olden wait second second technique is if suppose a process is requesting a resource if that resource is available then that would be allocated to that process if that resource is not available then we will check why this resource is not available if that particular resources are located to some other process which is also in waiting state which is also in waiting state then what will happen then that particular resource will be preempted from that from that process and will be given to this process see now here what the funda is always the waiting process will be treated as with we can only preempt resources from waiting process not from a running process as you can see here see if that resource is available then allocated if not available then we will check if that particular resource suppose here is process P 1 it is requesting for some resource if this resource is not available and this resources are located to some other process P 2 P 2 and this process is also in waiting state may be waiting for some other resource then what we'll do a preamp in this resource from P 2 and this resource will be given to P 1 so that P 1 can do it well its execution fine so make this thing very clear always the waiting processes will be treated as victim we can preempted sources from waiting processes from not from running processes right so this is the fund of removal of no preemption technique now the next one is removal of circular wait see now what is the circular wait the processes are waiting in a circle like this suppose P 1 is requesting for this R 1 but our wonder sources with P 2 P 2 is requesting for R 2 but R 2 is held by this P 1 so this is what a circular wait so you have to remove the the circular wait how the circular tube it can be removed simple funda is just a sign R number to each process sorry a sign or integer number two processes to two resources like 1 2 3 4 5 like this and after assigning the number just make sure that the processes can request the resources in increasing order or decreasing order strictly increasing or strictly decreasing order only see let us take this example these are some resources so some numerical some numerical integer value will be assigned to these resources like one suppose five suppose six was suppose seven now suppose two processes are there p1 and people now these p1 and p2 processes can only request the resources only in its increasing order fine like 1 5 6 & 7 like its some particular amount of time P 1 is P 1 is holding our source having number 5 that is CP and now P 1 is requesting for this printer is it possible no that would not be possible because 1 1 is less than 5 if the algorithm is like that the resources can be requested in increasing order then what what would what would be the case P 1 can request only 6 and 7 even cannot request 1 if the algorithm is applied something like this that processes can request the resources in strictly decreasing order then what will happen then vice versa won't be there then what will happen if it is having 5 then it can request only this one it cannot request 6 & 7 now one case is there for that particular amount of time P 1 is holding a resource number 1 and 6 fine now P 1 wants this 5 resource then what will happen it cannot request this 5 resource then what the alternative approach is what this P 1 would release would release the resource 6 fine and now P 1 can request this resource 5 and again for 6 this is the case so simply you can write to request a resource suppose RJ RJ a process must first release all the acquire resources are I are I such that such that is greater than or equal to J here you can say here just we can just take one case P one is holding one eight six now P one is requesting for this five then P one has to release this six because I here I is what six so P one has to release this 6 because 6 is greater than equal to this J fine after that it can request this 5 and then can request to 6 so this is how you can you can implement this removal of circular wait just make sure that processes can request the resources in either strictly increasing order or in strictly decreasing order and every resource is assigned some number so here problem of an implementation of this technique is what see it is very difficult to determine the relative for bring of different resources many resources are there and how to how to determine the know that relative ordering of these resources so that is very tough although it is implementable we can implement we can remove the circular weight just assign a number numeric integer or even say priority to each resource and make sure that processes can only request the resources in increasing order strictly increasing or arrow strictly decreasing order then there would not be circular wait never there would be circular wait let us take this example only see at some particular point of time this P 2 is holding R 1 and P 2 is requesting are 2 P 2 can decreased R 2 because it can request all the resources greater than 1 2 3 4 5 like this and this suppose R 2 R 2 is with P 1 suppose P 1 is holding this R 2 now kill P 1 P 1 request this R 1 know why so because P 1 is holding r2 so we can it cannot request any resource less than so that is why we cannot put this edge if will not put this edge then there will not be circular weight so you can take any other example if this kind of thing total load ring is there then there would not be circular weight definitely so this is all the deadlock of all about deadlock prevention techniques in next video and discuss and lock avoidance technique or you can say bankers algorithm till then byebye take