in the previous video we have discussed how to decompose a relation into second NF means second normal form right in this video we are going to see how to decompose a relation into third normal form right I mean suppose a relation is given which is in second normal form then how you are going to convert it into third normal form right maybe a relation is given which is in first normal form and you are supposed to convert it into third normal form same steps would be repeated right but here I am taking relation is in second normal form this is the relation these are the functional dependencies right this is in second normal form means there is no partial dependency there but this is not in third normal form now you have to decompose it into third normal form right to remove the anomaly's fine we have already discussed all the things about why we do normalization and all right in the previous videos you can check out the DBMS playlist link in the description box right so now it is in it is not in third normal form because there is transitive dependency in this relation transitive dependency means C if either the lefthand side is super key or the righthand side is prime attribute then you can say that this is not a transitive dependency right if any of these two condition is satisfied it means either left hand side in super key or right hand side is prime attribute right then this is not transitive dependency otherwise that would be transitive dependency and that would violate the third normal form rules now first of all you have to identify which functional dependency is creating a problem which functional dependency is violating the third normal form rule right so for that you have to find out the candidate key right how to find candidate key that also we have already discussed in the previous videos right take all that Reb use find out the closer try to discard as many elements as you can right using a I can drive B so if you have a you can discard be using transitive property using a I can drive C so I have a I can discard C and now seek and drive D so using a I can drive C and using C I can drive D so by transitivity property a can also drive D so if you have a you can drive D also not only is remaining we have discarded all the elements try to discard as many attributes as you can see find out a closer a using I can try be using B I can drive C using say I can drive do all that my goods are there so is what a super key now right now is there any proper subset no proper subset so you can say that this is also candidate one candidate here we have got prime attributes huh a right because the attributes which are consisting in the candidate key which are known as prime attribute now find out this prime attribute is on the right hand side of any functional dependency or node no it means there is no more candidate he exists here means only one candidate key for this relation that is a if candidate key is simple that is it is having only one attribute then definitely that would be in second normal form because there is no chance of partial dependency now which is transitive dependency C for that you have to check either left hand side is super V for that a left hand side is super cure you can say candidate key yes so this is not transitive dependency right now B is B super key or candidate key you can say no right okay fine now check the right hand side is right hand side any Prime attribute no Prime attribute is only C so this is not satisfying you know neither the first property nor the second property right so this is transitive dependency this is creating a problem now see C is not candidate key or you can say super key yes right hand side B is not prime attribute so this is also transitive dependency see I have already discussed this is thus transitive dependency in detail in the previous video so you must check out those videos first in this video I am NOT going into detail right just going to see the steps of conversion now these two functional dependencies are creating problem right now this first of all take out this one find out be closer right take out this functional dependency and find out though be closer means take the lefthand side be closer means we can drive be using be I can do see using see I can brave be to create a separate relation having B C D attributes right now again this one find out C closer using seek I can drive C then D so create a second relation containing C D right two sub relations are there and the remaining would be in third sub relation now remaining is only a right but it's not like that we are going to put a only in that relation right now see we have to put something common suppose I'm taking first of all the join of r1 and r3 so what I can put common either B or C or B right it's up to you but the problem is what this decomposition should be what dependency preserving a lossless now for lossless join decomposition the common attribute must be super key of at least one sub relation means either this one or this one right so it's better to put that attribute common which is super key for at least one sub relation see now I can see that B is driving BCD all the attributes means all the attribute of this relation we can drive see also and D also means being super key for this relation definitely you can say right so better to put B common now here you can put C common suppose I am taking R 3 is AC so now you have to practice it if I am taking C as a common attribute then it is lossless or lossy right in my opinion actually it would be lossy right but you try it that is why we are taking here be common you can try it and you can tell me in the comment box is it possible or not right now we will see it is dependency preserving or Nadia definitely it is lost less now for dependency preserving you have to find out dependency set for this one f1 right how to find out find out be closer see closer D closer first of all BC B B 2 B is trivial so using B I can drive CD C closer is only CD this is trivial so I can write this C can drive D D closer is only B this is free with right now we take B C but C B is determining all that reduce remaining attributes right so no need to check for B C and B D because that would be what duplicate right because using only bi can drive all that the dudes then what's the need to check B C and B D right definitely they can drive all the attributes right so check for CD CD closer would be only CD and this is trivial so no need to take this one so only functional dependencies are these 2 and f2 would be see closer D closer this is trivial so C can drive D right now if 3 would be a closer and be closer a closer would be what C using this functional dependency you have to find out a closer would be a B C and D so a 2 a struggle C and D are not part of the sub relation so we are not going to take this B is only part of the sub relation so it would be a can drive B be closer would be B C and D B 2 B is trivial and CD are not part of the sub relation so we are going to take this right so f 3 is having only one functional dependency this is 1 and this is having two functional dependencies now check we are supposed to convert this decomposing into third normal form but it is not compulsory that after this decomposition this all the sub are in third normal form right you have to check it again right this is very important now check see this is containing only two attributed to so definitely this would be in bcnf and this would be in bcnf you can check out this thing because we have already discussed the rule of bcnf the lefthand side of every functional dependency must be super key so find out super key for this one and this one using the this method and check out the lefthand side this would be definitely been busier but check out for this one so for checking that it is in third normal form or not we have to find out that there is any transitive dependency exist or rule for that you have to find out candidate you have to find out candidate he using this process right so discard be using the I can drive CD so I can discard CD so B is what only be closed are using B I can find out all that tribute so B is super kick right so B is definitely candidate he because there would be no proper subset now check bees on the right hand side of any functional dependency or not no so there would be only one candidate key that is be only so prime attribute is only B now check see ya this is the left hand side is candidate key what you can say super giving us B is super key also right now this is not transitive dependency not check for this one is C a super key or candidate key know is be a prime attribute no this is still transitive dependency right so this is still in second normal form after decomposition still it is in second normal form it is not in third normal form yeah it isn't be seen if it isn't be seen in but we have to take the lowest one lowest one is among all three second so this decomposition is still in second normal form again you have to apply decomposition again you have to apply the same steps now we are going to decompose only this relation we already got two sub relation now how to decompose the sub relation right so now check which functional dependency is creating a problem this functional dependency is creating a problem because this is not transitive dependency so take out this one and find out see closer see now I am decomposing this one so take this functional dependency we are not going to consider now this one right we are on this relation so you didn't see I can write the only nothing else see two now suppose next sub relation is our 1 1 suppose I am taking sub relation and that will consider that will take a tribute CD remaining attribute would be suppose r1 to the sub relation remaining is only B now we have to put something common to make it lossless common attribute should be what super key any at least 1 sub relation to make it lossless and we know that C can drive CD means all that repute of the sub sub relation so C is what candidate key or you can say super key for the sub relation definitely we know right so we put C common here so this is definitely lossless because the common attribute is super Q at least one sub relation now it is dependency preserving or not check this one also you have to check now also this is in this is containing two attribute into attribute so definitely that would be in bcnf and bcnf right my dear ultimately right so check out it is dependency preserving or not find out dependency set of r11 same find out see closer be closer I think that would be only seek and drive D now we will consider this functional dependency said because we are now decomposing this sub relation not this one so do not consider this one consider now this functional dependency said so only one would be there and f2 in f2 we would have find out be closer that would be B C and D right so d is not part of this one so bacon I see and using you can say see closer I can drive C and E C to say story well D is not part of this one so we are going to take this one so one is this one and one is this one so now we have decomposed this original one into four sub relation one is this one R 1 1 1 is R 1 2 we are not going to take this R 1 because we have what decomposed it into these two one is this R 2 and one is this R 3 4 right now if you check carefully see R 1 1 is also C D and R 2 is also C D so you can discard either this one or this one these are the click 'add right so that the composition is what suppose I am discarding this R 1 1 right I'm not taking this one because this is Syria I'm taking I 2 so that the composition would be R 1 to having bc r 2 having C D and R 3 having a B and as we know this is having only two attribute so this would be in bcnf this is also in bcnf this was also in bcnf this is also in bcnf so we wanted to convert it into 3/3 and F but by default to be how converted into bcnf so that is also possible and the decomposition is lossless as well as dependency preserving how to check dependency preserving see you you know this this this and this is it equivalent of this F or not means a is driving B is this exists here in this for yes this is there we can drive C yes this is there C can drive D yes this is there so all the functional dependency original functional dependencies are there after decomposition so it is dependency preserving also and lossless join decomposition as well right so you have to take care of these two properties also with this decomposition right so maybe sometimes they can ask you they can give you this relation functional dependencies Annika take an ask you how many sub relations are required to convert it into bcnf or to convert it into third normal form right so how many sub relations would be required 1 2 & 3 not 4 1 2 3 4 no because these end this is what same means to placate out there CD and CD so we will take only 1 so 3 sub relations would be required right this type of questions can also be asked right so I hope you got the steps now sometimes when a relation is in 2/3 and 1/2 and when you are going to convert it into bcnf that sometimes dependency preserving bcnf decomposition is not possible sometimes right but up to third normal form it is also always possible lossless Plus dependency preserving right so in that that exceptional case we will discuss in next video with the help of an example right so now in the next video till then bye take care