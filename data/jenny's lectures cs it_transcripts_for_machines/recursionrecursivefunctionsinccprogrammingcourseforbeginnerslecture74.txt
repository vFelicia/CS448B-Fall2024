hey everyone I hope you are safe and doing good so in the series of learning C++ programming language we are discussing functions in C++ in previous video we have seen what are inline functions right now in this video we'll talk about what is recursion and what are recursive functions right we'll be discussing everything about this recursive functions in this video right and with example with program and with real life example as well right and then we'll see coding exercises based on recursion right and then I'll give you an assignment also fine now okay let's discuss this recursion with the real life scenario suppose in my class I have like 60 students and when I call one student like I call Angeli and Angeli will say like yes ma'am or Ang will come to me right then I call like w same will say like yes ma'am and something like this then I say Jenny then what you guys will say like ma'am you are calling yourself and that's true because I'm Jenny and I'm calling myself Jenny right so this technique or this process is known as recursion yes in program we have some functions and if a function call calls itself then this technique is known as recursion right suppose I have this like a function uh fun in my program like something like this here I'm writing something and within this I'm again calling fun here I write something so this function is calling itself this is function calling so it will go to here then again execute this again function calling it will go to here so this function is calling itself so this technique is known as recursion and this function fun is known as recursive function so function calling itself then that that function is known as recursive function and the process or the technique of calling I mean the function calling itself that technique is known as recursive but this is not complete definition I'll tell you the complete definition of recursion and recursive function but first let's understand this thing right now the problem here is if I call some student and he or she will come to me right and then obviously I'll not call him or her but if I call myself Jenny then how will I come to myself right it's like Jenny Jenny so how will I come to myself or I will say like yes ma'am or something like this because here the termination condition is or when I will stop calling that student once that student come to me or respond me then I'll stop calling that student right but here I'm calling myself then how I'm going to stop calling myself right how will I come to me right so here one problem with recursion is what how to stop this recursion because these line will be executed again here again it will call itself again it will call itself again it will call itself so when to stop this how to stop this this thing is very important and that is known as base case or base condition right so here we can set a base condition something like this after calling Jenny five times I'm supposed to stop like Jenny Jenny Jenny Jenny Jenny and then stop calling Jenny right so this is base condition in my case right so same to stop this recursion you have to put some base case or base condition right this thing is very important here base condition or base case right if you will not put a proper base condition or base case then your program your recursion will never stop and ultimately you will get obiously that stack Overflow error or something like this right so now if I call what recursion is so recursion is a technique in which function calls itself repeatedly until a given condition is met this is kind of complete definition of recursion right and a recursive function is what a function which calls itself repeatedly that function is known as recursive function right now why recursion this thing is very important why this concept so sometimes there are some problems like factorial of number series and the Tower of ano problem and then binary search and sorting algorithm quick sort M sort and those you know divide and concrete problems we have like n Queen's problem and backtracking problems and these things these problems are you know we can solve easily with recursion we can model the structure of these problem in a program easily with recursion right rather than than that iterative approach so that is why to solve some problems now we use recursion we will see this thing how right so a recursive function will call itself directly or indirectly through another function here the function is calling itself directly or maybe this function can call itself indirectly with the help of some other function right that is also fine so let's take this example factorial of a number I want to find out fact of five so how you will write this is a mathematical problem like obviously we'll write here 5 into 4 into 3 into 2 into 1 right if I write 4 factorial what you will write 4 into 3 into 2 into 1 3 factorial 3 into 2 into 1 like this multiply the number till you get 1 this is how we are going to get factorial of a number right so in general what what can I write n factorial is equal to n into n 1 into n 2 and so on till into 1 right or can I write this 5 factorial something like this 5 factorial is equal to 5 into 4 factorial can I write this because see this is ultimately 4 factorial 4 factorial is equal to this so rather than this we can I write here four factorial this is true yes so same we can write here n factorial is equal n into n 1 factorial yes or no fine and then again nus1 factorial I can write something like this n 1 into N 2 factorial right so like if I have n minus 1 factorial with me so I just multiply that with n and I'll get n factorial right and to find out n 1 factorial if I have nus 2 factorial then I will simply multiply this with nus1 and I will get nus1 factorial right so here what we are going to do what we are doing here we are dividing that larger problem or complex problem into simpler or you can say sub problems right so we can also say recursion is a process of you know solving complex Problems by breaking it down into small sub problem right so rather than find finding out n factorial now you have to find out only nus 1 factorial and for nus1 factorial you just have to find out nus 2 factorial right and just multiply with this n minus one so we are just simply breaking down this problem into sub problems right so this is what for right so obviously if you write a program then simply we cannot write you know write down in a program the symbol factorial symbol right so rather than this we will use some function so can I write something like this for for this line can I write something like this like factorial of n is equal n into factorial of n minus 1 right this is how we can like model this problem of finding factorial of a number fine so see factorial we can Define factorial as a function and this function is calling itself by doing like n minus one so this is what recurs in can you write this program but here one thing I have told you one thing which is very important to stop the reion is base condition so first to write a program you have to find out what is the base case because this is recursive case here we are calling the function again and again so this is recursive case so what is base case there are two things when you are solving a problem using recursion base case and recursive case base case when to stop that recursive that condition recursive case divide that the problem the rest of the problem accept that base case divide the rest of the problem into sub problem and just call recurs right now what is the base case here when we are going to stop once we reach to one right and by definition we know factorial 0 factorial is one and one one factorial is also one right so once the number reach to like one one just stop this is the base case so this case you have to write down to stop the Trigg in program so now pause the video and write down this program and if you want to write down the basic or the syntax or the structure of this recursive program then how we are going to write that thing see we just write here first obviously return type then that recursive function right here in recursive function we have two things one is base case just to stop that thing and another is recursive case right that's it this is the basic of the you know syntax of structure of writing recursive function so now pause the video and try this program so I hope you have done this so now let's find out suppose I'm just creating a function factorial and here I'm passing five right let's call this in C out factorial of five but obviously you have to define this before calling so let's Define this function and we just what this function is going to return simply that number num into factorial of num minus one that's it and that we have already seen this line factorial of n is n into factorial of n minus1 that's it so num into factorial of numus one but when to stop this you have to put definitely the base condition to stop the secur so if number equal to equal to 1 in that case return one because factorial of one is yeah one so return one this is the base condition and otherwise return this num into factorial of n minus one right and factorial of uh five so let's run this and see what output we getting here factorial of 5 is 120 and we know that's true right but here that one thing is what like if I write factorial of 50 let's run this and see it will give you zero because that would be a very long number so here what we can do is rather than in better to write here inside long long because the range of inside long long is it's very long right so that would be fine if you want to find out factorial of a long number right so better to use this thing here also other than in uh the num return type or the type of num you can take and signed long long right I hope you got this this is very simple right see how simply the code is readable now and it's very simple to write that you know program the logic of finding a factorial of a number we can easily model that in English we have written that thing and we can easily model that thing here using recursion right so this is beauty of reion sometimes for some programs it would be the know the code would be very clear clean and simple to write and easy to understand and easy to model that structure of that program into structure of that question or that problem into program using recursion like here right so sometimes it's very easy to use recursion but sometimes better to use iterative approach rather than recursion because of now if you don't put you know here the base condition correct then it would be the recursion would never stop and it would be like give you stack Overflow now let me just uh show you what is happening behind the scen have to find out factorial of a number see so this is a program right first you know how the function call works that function called stack so we have this stack and first here we have like that one activation record for main function because from here obviously the execution would be started Main and here we're calling factorial 50 right so in main after that one activation record for this function factorial fine would be pushed in this step 50 would be passed here so in this the local variable for this function is num and num is 50 now this condition true no so here return num into factorial n minus one so num is 50 into I'm just writing in short term fact num minus one that is factorial of or rather than 50 obviously it would be very large so let's say let's just keep it five only right just for your understanding purpose so here we are writing simply uh five in Num we have five and five into fact 5 1 4 means it will call again this function so again one record again activation record would be push for fact four this was fact five so you see if in one stack there are two activation record for the same function it means there is recursion right so here we have again num num is four and it will return because this condition is not true so it will turn four into fact of three now fact three means again it will call the same function again itself so fact this is activation record for fact three so now num is equal to 3 and 3 into fact of 3 1 that is two so again it will call itself for this activation record is perfect 2 so here we have num is equal to 2 this condition is again not true so 2 into it will call again fact 2 1 1 so one activation record for Fact one so right now num is equal to here one now see num is one is this condition true yes condition is true so return one so this function will return one where to return where you are calling this function here so it will return one to here so fact this is one so 2 into 1 is 1 right now 2 into 1 is 1 but now this function this function will return this value where we are calling this function from here right so it will return this value 2 to here so 3 into 2 this value is 2 3 into 2 is 6 now where this value would be returned here so here we have 6 6 into 4 is 24 now where this value would be returned here because here we are calling from here we are calling fact 4 so 24 into 5 is 120 so this this is 120 complete 5 into fact 4 is 120 now where this would be returned and this is after returning back this would be popped from the stack right after returning this this is now right after returning from here this would also be popped out like this would also be popped out this one after that this would be popped out this would be po poed out and after returning 12 to here main because we are calling here in main function 120 so this would be out of the step popped out from the step and just C out and see out would be here the answer would be 120 and return zero means successful out successfully I mean the program completion so this main would also be popped out from the stack and that's it right so this is how you will get 120 answer right now I hope you got this what is happening behind the sing the function call stack how this is working in case of recursion right and now see if there is no base condition then we will simply call again again again like this the cursion would be deeper and deeper right like perfect then 0 1 2 3 something like this and at some point of time obviously the stack M would be exhausted out of space and then it will give you stack Overflow error so this base condition is very crucial to stop the recursion this first you need to identify base condition if you're solving a problem with the help of this reion right I hope you got this now second let's discuss with uh the fibon series let's disc that thing see we have this is the faon series 0 and one at starting we have like sometimes they start from one and one and some starts from zero 0 1 then addition of previous two 0 + 1 1 1 + 1 2 2 + 1 3 3 + 2 5 5 + 8 5 + 3 8 8 + uh this 13 21 and like this this is what F Series right the next term if you want to find out then the sum of the previous two terms right so if I want to find out this two this two would be like 1 + 1 that is two so previous two terms so if you want to find out n FIB of n this is fibon series and this is like one term which this is known as fibon number so if you find out a particular term n then we simply write down here like FIB of n minus1 plus FIB of N 2 that's it because if you want want to find out FIB of like n is what 0 1 2 3 4 five or six for this the sixth number you want to find out that is eight so that would be this number plus this number right but now have to find out this five this five is this number plus this number and the three is this number plus this number so obviously you have to find out FIB of N minus1 and FIB of 10 2 like this so FIB of we have fifth term and FIB of fourth something like this and then again FIB of five would be FIB of 4 plus FIB of 3 so same we are dividing the problem into smaller sub problems right and by definition FIB of 0 is zero and FIB of 1 is 1 so here we have two base conditions FIB of 0 FIB of 1 FIB of 0 is 0 one is one so these are base conditions and this is like this is these are base cases and these are this is what particularly this is recursive case right so see here we are calling 2 * FIB FIB right so this is kind of like pre recursion you can say there are types of recursion we'll see the type also in some other video now pause the video and write down the program for the sub Series so this was the program for factorial of a number now let's write for the FCI series I just want to print C out and FIB of suppose same uh that we have done here FIB of five suppose I want to find out FIB 5 that Fibonacci number right obviously you have to Define that function first so that number maybe could be very long so we can take unsigned long long the return type or simply you can take int also right F the name of that function is fib and here we are just taking a number suppose n so what it will return return FIB of nus1 plus FIB of nus 2 but before that you have to put a base condition to stop this so if this n is less than or equal to one then simply return whatever the number n if number is zero return zero if number is one return one you got it and the number should also be unsigned let's take un signed long for this number because obviously we will not find fibon series of minus so okay here we have eror it's minus note underscore right sorry it's not minus it's it's plus sorry my bad and here let's simply print zero so let's run this and see what output we getting here here we have five what is that series 0 1 then two sorry 0 1 1 then two then three then 5 then 8 then 13 and something like this so FIB of five like 0 1 2 3 4 5 so here we have five on like this if we find out FIB of six then it will give you 8 C right so now you have to try on this program please check out how this is working the behind the scene what is happening right and one assignment for you is here I'm just printing for six that particular number but sixth term I mean that in that series there should be six term what is the fibon series like 0 1 1 then two then three then five then eight something like this still eight you have to print so this is your assignment you have to print that fibon series up to a given terms using recursion using recursion and if you want to check out how this is working you can continue watching this video otherwise you can stop so at first see what how recursion is working here we have here we have PB of six right right or rather than six let's take FIB of for smaller let's take FIB of four here right so here we will write FIB of four now what is happening FIB of four means here this condition is not true so it will call this and this so it will call fibo 4 1 that is 3 plus FIB of 4 2 that is 2 so this is like three type of reion now again FIB of three we have so this FIB of three it will call again here so FIB of 3 would be divided here like something like this FIB of 2 plus FIB of 1 and this would be something like this FIB of 2 is 1 + FIB of 0 right now FIB of two this would again be divided into FIB of one plus FIB of 0 and FIB of one would be obviously this is base case so it would not be further divided because base cases n is less than equal to one return n so we got here all the for all the branches base cases so FIB of this one FIB of one will return this condition is true n is one so return n so it will return 1 plus F of 0 it will return zero so 1 + 0 that is 1 so this would be returned here so here now we have one this would be returned here so F both 2 is now 1 plus of one it will return one so 1 + 1 is 2 so this 1 + 1 2 is returned here and here we have now two now for this Branch FIB of one it will return one it will return 0o so 1 + 0 is 1 so it will return one and one is here now 2 + 1 that is 3 so three would be returned here and fibo 4 is three right so as you can see here FIB 4 0 1 1 2 3 F4 is three so this is how that infy series that tree recursion is working right now what are advantages of using recursion that already we have seen like some advantages we have already seen the code would be simple and easy to read a clean code we can write using recursion it can simplify the code of complex problems into sub problems simp sub problems right like those backtracking problems and queen's problem searching problem sorting problem traversing problem DFS BFS those problems in some problems like we can directly model the structure of that problem into program using Rion right but the problem here is what when to stop that that condition sometimes this error generally we get when we use recursion in a program that stack Overflow error this is the drawback of using recursion this you need to handle right and sometimes you know debugging is also difficult in case of recursion because of you know there are so many levels of recursion or that function calling that function call stag there are so many levels that debugging would be a little bit tough right and performance overhead is also there the pushing and popping of activation record rather than in some problems it would be easy to use iterative approach right but for some problems definitely recursive approach is better so now I guess you got it what are recursive function and how recursion Works in detail what are recursion because there are different types of recursion as well direct recursion indirect recursion head recursion tail recursion tree recursion like this tree recursion right so that we will see in a separate video but basics of recursion and what are recursive function that I guess uh you got it right so in the next video we'll see one or two coding exercises for this Rec so now I'll see in the next bye bye take care