in this video we will see how to delete data from our doubly linked list see we have already discussed how to create a doubly linked list and how to insert a data in doubly linked list insertion and beginning insertion at end an insertion insertion at any specific position as well as an insertion after a given position right so I'll prior to the link of all these video in the description box as well as you can check out this I button fine in this video we will see how to delete a data delete from beginning delete from end and delete from our specific position or you can say delete from any given position fine see suppose I assume that we have created our doubly linked list having three nodes two pointers we have one is tail pointer and when his head pointer head is going to store what address of the first node tail is going to store address of the last node this thing we have already discussed in the previous video right how to maintain this tail and head and how to create this W linked list right now I want to delete data from beginning see this node I want to believe in the list from the list fine so now what you have to update for this see if you want to delete this node in that case the head will contain address of this node right so in head you will store 400 fine now head is going to point here second thing what you have to update now this would be the first node right so this link the previous link of this node would contain null why so because we have already delete this node so this is going to point where null see this is I I guess you know the node is having three part this is data part this is what containing address of the next node this pointer is containing address of the previous node so that is why here also you will store what 0 fine means we have detached this node from this list but still we have to free this space because say this space is still located to this node although we have detached this node from the list but second task is you have to free this memory you see memories very crucial part so we cannot leave it like this this is just a garbage now so you have to clean this garbage how you can free this memory you can use a free function in C we are using free function and in free function what you will pass a pointer to this node you can see address of this node that is 200 fine so suppose one pointer is there which is pointing to this node and name of the pointer is temp so here we can pass M if there is no pointer then how you can access this node how you can get this 200 fine so another important point is you how to maintain a pointer to this node fine so you will take another point of that is temp now how to believe this now see how to delete this node see we are going to create a function you can say void delete from Big D fine and here first of all we're going to take another pointer that is M and Y we have I have already discussed here so I am going to take another pointer that is struct node it's trick then why I am taking this truck node we have already discussed many times in the previous video fine because this pointer is going to point this node so here what you will write here always see if if I write int star P it means this is a pointer P and it is a pointer to integer it means this pointer is going to store address of a integer variable so here we always write the data type of that variable whose address this pointer is going to store now here this temp is going to store what this 200 means address of this node and type of this notice we have already discussed we will define our own data type that is struct node so that is why I am taking here struct node fine so now see so now we have taken another pointer that is M amp is not pointing to this node now still by now see first of all you will take if there is no node in the list then we cannot delete anything so you can check what if this head pointer is equal to is equal to 0 means null it means here you can print what list is empty otherwise we will do what now see in else part what you will write now first of all we are going to point this pointer here fine so now in temp we are going to store what temp is equal to head that is this 200 the address of this node 200 now temp is also pointing to this node fine now we can update this head value and this value in head they are going to store what this 400 fine now from where I can get to this 400 address of this node see this node is containing 400 this pointer the next pointer and how we can access this node we can do what this head is also pointing here in temp is also pointing here so basically we use what head so here you can write now head is equal to head off next it means hand the next value would be assigned to head head and next value is head next means 400 would be assigned to head here we will write 400 now this link has been broken fine now this head is pointing to this node now another thing what you will do obviously we are going to break this link also fine now here this would be the first node now so in the previous node of first nor you would store what null that is 0 so now how we can access this part now pointer to this node is what head we have set this pointer so how we can access this part we can write head and previous is equal to null it means here we are going to store 0 it means this link has been broken fine and if you want you can also store here 0 you can say how we can access this node M of next as equal to 0 so here also we can store 0 and this would be broken otherwise by writing these two lines simply you can do what now you can free this memory now how you will free using this free function free and free what you will pass address of this node from where I can get this this temp pointer is pointing to this node tempest containing this address so here I can write then and now this node has been deleted the memory has been freed now this is how you can delete a data from the beginning these four lines code would be there fine now we will see how to delete from end so now to delete this node what you have to do you need to break these links fine means you have to store here what 0 means this node is not pointing to any node now fine how we can access this part see obviously we don't have any pointer pointing to this node because directly we cannot access this part we need some pointer variable or we need some structure member structure variable fine so that is why in single linked list what if in this case also if you don't maintain this tail pointer then you will have to traverse the list till here after that you can delete this data but we have already a tail pointer pointing to this node now no need of traversal order of one time pick would be taken for deleting this node see now how we can update this part see how you can access this part the address of this node is about 400 from where I can get 400 here we have 400 fine and the pointer to this node is a it means tail previous fine we have reached here now how we can access this part in previous and this has what next is equal to 0 this is how you can set fine one more thing you will set what you will also update this tail pointer now tail will contain 400 right and from where I can get 400 see here we have 400 so from here I can get 400 I can store here so simply first of all we will do what and and third thing is also you you are also into free this memory fine because after updating here suppose now tail is containing 400 so now this link has been broken and this link also has been broken fine so now how you can access this node we are also going to maintain a pointer that is spam which is going to point this node and after that we can do free and M so now first of all what we will do we will declare another pointer that is M means we have another pointer m and temp is not pointing to anywhere first of all I will check if L is equal to is equal to 0 or head is equal to is equal to 0 it means Leicester's m / t so here what you can print simply list is empty fine I guess you can all write down this thing now in else part what you will do now we will initialize this tenpointer temp is equal to a now temp is also containing 150 means temp is also pointing to this node now we can update this temp well you now temp we can set this temp pointer pointing to this node and after that we can free this node using this 10 pointer right we can change this tail pointer now now see how we can do here I want to store 0 so that this link I can break this link now how we can access this part see this this part of this mood find that is 400 from where I can get this address here we have 400 and pointer to this node is tail also in temp also fine so you can access this node using temp or tail so here I am writing what tail of tail of previous fine and again double pointer tail of previous means we have reached to this address now this I want exactly I want to reach to this location and now this is what next button again the name of this part is next is equal to 0 it means here now I have 0 now this link has been broken fine second thing we are also going to update this tail so in tail pointer what we are going to store that is 400 address of this node now from where I can get 400 from here and how we can access this part we can write tale of tale of previous that is 400 so here now I have 400 so tale is now pointing to the snow right now I can free this memory so so here simply you can write free m because the pointer to this node is 10 how we can access this address using temp and this is done now now this node has been deleted right this is how we are going to delete a node from the end of the list fine and this will take time complexity order of 1 because we just updated these links we haven't done any traversal and from beginning also it is it will take order of 1 because we just in that case also we have just updated the links fine now we will see how to delete a node from a specific position now before going to the third function I want to tell you something see if you don't get this double pointer concept then what you can do see suppose we haven't updated this part still we have this link pointing to this node and tail is not pointing to this tail is still pointing to this one tail is having now 150 fine so first of all what we can do first update this tail pointer so first you will write M is equal to tail and after this line don't write this line directly line this line tail is equal to tail previous means tail is equal to tail previous that is 400 now it is having 400 so this link has been broken and our tail is pointing to this node now we can update this part have you can access this that node the pointer to this node is tail now after this line after this line do not write this line you can directly write tail off next is equal to 0 so now here 0 this link has been broken after that you can write free temp so 2 is how you can write this thing or this thing also right so now suppose this is our list we have 4 node in the list and I want to delete this node the position is 3 1 2 & 3 this node I want to delete this one so now you have to update what you need to update this linker thusly because this node will indirectly point through this node and this node will directly point to this node so now how they can access this part in this part how we can change obviously we need some point are using a pointer only we can access these parts and second thing the need of point that is what obviously we want to free that memory find so I want to use that free function so so I need a pointer pointing to this node fine so that I can free this suppose I want to delete this data and I'm have a pointer I'm having a pointer pointing to this node that is this one so after updating this link and this link this these links has been broken fine now I can free this node free temp right so now how we can set this pointer to this node you how to traverse the list because only we have the stale value and this head value fine now we will start the traversing from here because sequential access is possible till this position once we reach tail position then we are going to stop after that using a single pointer only I can update this cell also and I can update this also because in the single node I have address of the next node and address of the previous node that is why deletion is also easy in doubly linked list because in this case we need only one pointer but in singly linked list we need two pointers fine that we have already discussed fine you can check out that video in this I button now see what you will do obviously we will ask from the user from which position he wants to delete the data and to get the input we need a variable you can say post field and also we are going to take one this ayah variable I is equal to 1 for Trevor Singh fine now see and we are going to take this M pointer also so how you can declare this struct know a strip M and now temp is not having anything so temp is now not pointing to this node right now see if position is 1 in that case that case is similar to delete from beginning fine so in if you can write if position is equal to is equal to 1 then you can directly delete from beginning function and if position is this one and off this list then simply you can call delete from and fine means how many you can count how many nodes are there one two three and four nodes and if position is four then you can say it is the you you want to delete from the end of the list so you can call delete from and otherwise you will implement the logic to delete from a specific position so first of all will ask from the user using printf and scanf enter the position right and after that we will traverse so suppose user has entered position is equal to three so in post variable we have value three and we have one more variable I in that we have one so now we are going to start traversing till this position right because we need a pointer to this position for freeing this memory so now here what I can write while I less than pose and then we are going to traverse fine so now at starting what you will do have you will Traverse obviously we cannot move this head so we need a pointer we have declared one pointer temp and we first of all set this pointer to the first node and then we are going to update this temp then we are going to update this temp till we reach to tulip to the position so now before traversing before start this traversing we need to set this pointer to first node see you can write after this line after declaring the stem here like you can write temp as equal to head now temp is containing 200 means temp is now pointing to this node head and campus pointing to the first node now I'll start reversing I less than is equal to post then we will move this temp so in M now we will store temp off next it means temp next means hundred fine so in temp we are going to store temp next now it is having hundreds so now temp is pointing to the snow's right and we will do it I plus plus now see one iteration we have done one I was one and position is three one less than three so we have done temp is equal to temp next here now temp now I plus plus now I is equal to 2 now 2 is less than 3 yes now again we will do temp is equal to temp Knicks now temp next is equal to temp is pointing to this node temp next s500 so now here we have 500 so now this camp is pointing to this node fine and I plus plus now I becomes 3 it's 3 less than sorry no so now we are going to we are not going to move this step now we have reached till this position because position is 3 and we have reached till this one point 3 now I can update these links and after that I can free this memory fine so now after this while loop what you will write see now how you can access this part here I want to store address of this node after deleting this that is 150 here I want to store 150 right how you can access this part 500 the address of this node is hundred so how we can reach till this node here we have 100 address of this food and we have a pointer to this node that is temp so how we can access this this part temp of previous so here I can write after this while loop I can write temp temp of previous that is hundred means we have we have raised in this node but in this particular node also I want to reach to this part so here I can write this part is next next is equal to now here I want to store 150 that is this one from where I can get this 150 see here we have 150 and we can access this node because we have a pointer so here I can write temp off next because temp next means 150 it means this is now containing 150 and now this is not pointing to this node now this is pointing to here to this node one Ling we have set one link and now we have we are going to set this link now see how we can reach till here till this part see this know till this node how we can reach that address of this node is 150 but directly we don't have any pointer pointing to this node but don't worry we have a pointer to its previous node and from previous node here here from where I hide from here I can get this 150 fine and pointer to the to this node is 10 so here I can write temp next temp next means we have reached till this node but in this note also I want to reach till this part so the name of this part is again you will write this arrow and the name of this part is previous is equal to now here I want to store what 100 now from where I can get this hundred see here we have hundred and I can access this node because I have a pointer pointing to this node now temp off previous right temp of previous hundred would be stored here now here I am the store hundred so this link is no more and now this is pointing to this node right now we have set this link also and this link also now we can free this space and how you can free this free 10 because stamp is pointing to this node means from this address 500 from this address we are going to free this memory fine so now that's it that is how we can be lead from any specific position I hope you can modify this if I want to ask how to delete a data from a given sorry how to delete a data after a given position or how to delete a data from before a given position fine so now the time complexity for this case has what now we have prover still here means one and two nodes if position is suppose 10 so you need to traverse 10 node if position is 50 so you need to traverse 50 nodes it means obviously it is proportional to end the number of nodes in the list and if you want to delete from middle then you have was what and by two nodes so that is why the time complexity in average case is what it order of in fine so this is all about the deletion from a doubly linked list fine next we will see the circular length list and some operations on circular length is defined so I'll see you in the next video till then byebye take care