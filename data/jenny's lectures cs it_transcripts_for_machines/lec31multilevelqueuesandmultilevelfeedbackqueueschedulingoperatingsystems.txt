fine now see in the actual scenario in your laptop there are many types of processes are there some foreground processes are there some background processes are there right or you can say some processes are that system processes are there like uh interrupt when interrupt comes what happens all the processes all the other processes will be on hold and what CPU will do CPU will first execute what that interrupts if you first handle what the interrupt process right so that kind of process is known as system process so system processes basically you know that that are used to run system programs so that are system processes are of highest priority process some processes are what batch processes are there some processes are interactive processes are there interactive means when you are interacting with an application or you can say when you are working on a word processor or you can say a Microsoft Word or when you are writing a program something like this you are you are continuously working with that application right through the console or something like this right or maybe through command and batch processes are what they are not interactive process these processes are basically running in the background you just submit the processes go and come after some time and collect the result of that processes right so see actually we have different type of processes in our computer which are running right and each process is having its own scheduling needs then why we are going to put all the processes in one ready queue only why we are applying the same scheduling on the all the processes right why can't we divide this ready queue into separate queues so this is the main idea of multilevel Q see as the name suggests to multilevel cues right I'm just taking this example suppose we are having three cues and one queue is assigned to system processes one queue is assigned for interactive processes and one queue is assigned for batch processes right if some system process comes then we are going to put that process into this queue if interactive process comes then in this queue and if batch process comes then in this queue right we have multiple levels of queues that is why it is known as multilevel cues right and now plus more thing now see each queue is having its own scheduling algorithm it's not like that we are going to apply same scheduling algorithm on all the processes like we have discussed in previous hit scheduling algorithms see suppose if if this queue is having system processes maybe maybe this this Q is following round robin scheduling algorithm maybe this queue is following short test job first scheduling algorithm and if batch processes are there then maybe this is following first come first so scheduling algorithm right see this this or this this type of shelling algorithm the queues are following it all depends on the implementer who is going to implement this scenario this scheduling algorithm fine maybe he can Implement that on system processes first come first so on interactive processes are our undone batch processes may be around Robin something like this we can't say it all depends on the implementer who is going to implement this fine now first point is every queue is having its own scheduling algorithm in this case plus second point is as you can see since system processes are having highest priority right and these are having lowest priority fine so these cues how many queues are there it depends on the implementer role so here here may be uh more than three queues can be there four five queues can be there right here I am going to take an example in which I am having only three cues I have divided the process into three different types only right now see this each queue is having its own scheduling algorithm plus plus three queues these queues are also following some scheduling algorithm that is a fixed priority scheduling algorithm in which this queue is having highest priority this queue is having the second highest end this this type of this as we as we come down then the priority of the processes will be you know decreasing so this is having lowest priority so now third important point about this multilevel Hue scheduling is what if a process is assigned to a particular queue then during its execution till its termination that process cannot change its queue cannot migrate to another queue it means in another verse you can say when a process comes then that process will be permanently assigned to a particular queue right if system process comes and that has been assigned to this queue suppose a process P1 comes that has been assigned to this queue then till the termination till the termination this P1 cannot migrate to this Q or this queue and if a process is in this like suppose if P3 is in this batch process in this queue so this P3 cannot change its Q it cannot go here or here till its termination it will be permanently assigned to that queue fine and fourth important point about this multilevel Q scheduling is what see let us suppose we in this in this system processes we are having P1 P2 P3 P4 here we have suppose P5 P6 p7 and here we have p8 P9 right so see no process no process from this this interactive process can execute unless unless this queue this this queue the having system processes becomes empty see after the completion of all these processes any process from this queue can be executed can be assigned to CPU right and same after completion of these processes and these processes from the this q and from this queue after completion of all these processes if this is empathy and this is empathy only then the process from this queue can be executed right Plus fifth important point is if suppose this is empathy and this is empathy all this process has been executed all the process from interactive has been executed from this queue right and CPUs has been assigned to p8 and p8 is running and during this during this if any process in this interactive process comes suppose P10 comes in interactive process in this queue then CPU would be preempted from here from p8 and CPU would be assigned to P10 right so this is you can say a preemptive type of scheduling algorithm right so now see the if suppose the scenario is something like this this queue is having multiple processes the screw is also having multiple processes right and all has been executed now as soon as the time comes that CPU will be assigned to this process paid a process comes in in this queue then CPU would be assigned to this process only right again a process comes in system processes then CPU would be assigned to this process only against a process come in interactive process then CPU would be assigned to this process only and what about this process what about p8 this process will have to wait for a long amount of time or you can say indefinite blocking would be therefore the processes which are in this queue batch processes right so this is known as starvation I have already discussed what is starvation problem in the previous videos you can check out that video right so the multilevel Q scheduling algorithm suffers a disadvantage that is starvation problem and why I have already discussed now to avoid this starvation problem what we can do we can do aging now what is aging that also I have already discussed when we were discussing that priority scheduling you can check out that video so what we can do to avoid this starvation problem see let us suppose this p8 is waiting for a long amount of time still waiting waiting and waiting and processes are coming in here and here and CPU is CPU is executing to CP is executing these processes only right so what we can do what with that waiting process we can we can promote this process to this queue so you can say that we have increased the priority of this process and this is known as what aging increasing the priority of the process after some particular amount of time priority of waiting processes right and still maybe maybe still this processes are now at here but many processes are coming in this Q system processes again coming coming and CPU would be assigned to those processes only now same the speed will be waiting will keep on waiting waiting and waiting now after some threshold value we can promote this pa2 this queue right and ultimately the processes in this quiz of highest priority so ultimately this process would be executed after some amount of time there is no starvation problem there is no indefinite blocking problem but in multilevel queue we cannot migrate these processes I have already told you once a process has been assigned to a particular queue then tell the termination of that process that would be in that queue only we assign permanently a process to a particular queue so this migration can be done in multilevel feedback you scheduling that is why to avoid this problem next scheduling algorithm comes that is multilevel feedback queue scheduling algorithm so what you can say in multilevel feedback you scheduling the processes from a queue of lower priority can be promoted to a queue which is of higher priority fine now see it's not like that only the lower priority processes can be promoted to higher priority processes the processes from higher priority queue can also be demoted to the processes to the queue which is of lower priority this is also a case in multilevel feedback you scheduling fine now what is this case see let us suppose I am going to take three cues fine and here in this I have implemented RR with round with time Quantum 5 here round robin scheduling with time Quantum 10 and and third Q I have implemented first come first so this is suppose the highest priority queue this is lowest priority and let us suppose one process comes P1 and P1 is having worse time 15. right now P1 is of highest priority suppose now P1 would entered into this queue but in this in this queue only the processes can be run for five units of time fine and after completion of five unit those processes would be demoted to here this next queue right so P5 is having both time 15 but here it can be executed for five minutes of time so remaining is 10 so P1 would be demoted to here in this queue right and it will complete its remaining is 10 now and time Quantum is 10 so it will complete its termination here and will be terminated from this queue right and suppose one process come P two that is of having 20 burst time so that process would execute for five minutes of time here then it would be demoted to this process P2 remaining is 15 for 10 unit of time only it can execute in this queue and remaining is five so again it would be demoted to here so here we got P2 and here finally it will complete its termination right so like this the higher priority processes can be demoted to the lower priority queue and the process is from lower priority queue can be promoted to the processes which are of higher priority so see the implementation of this multilevel feedback you scheduling is very tough and the algorithm depends on which factors many factors like how many queues could be there and when to when to promote a process after how many time when to demote a process which queue is having which scheduling algorithm fine so it all depends on the implementer who is going to implement this algorithm I am just taking a case where I have taken three cues this is having round robin scheduling this is also having round robin this is having first come first so maybe someone has implemented this is having priority queue this is having round robin something like this maybe someone has implemented five cues all queues are having round drop in scheduling algorithm with different time quantum right so it depends on the implementer only so this is all about multilevel queues and multilevel feedback you should learn algorithm so I'll see you in the next video till then bye take care