so far in this lecture series of DBMS we have discussed first second and third normal form right what is the basic idea of these those normal forms means what are the rules and regulations for a relation to be in first second and third normal form right and we have also discussed that a particular this type of relation would be given functional dependencies would be given and you have to identify that the particular given relation is in you can say in first second or third normal form or not right using those rules we haven't discussed that if relation is not in second normal form then how to convert it into second normal form means how to decompose that relation fine first of all you will discuss the basic idea of all the normal forms so in this video I will discuss what is bcnf now what are the drawbacks and the second in normal form and because of those drawbacks the concept of third normal form came into picture that also we have discussed in the previous video right but still we have some drawbacks in third normal form it sometimes see I have told you in the previous video that if your database design your relational schema is in third NF then you can say that it is a good database design right but sometimes still because at some cases still there are some redundancy if your table is in third normal form but still there is some redundancy exists in that table and because of that you can get some anomalies right when this type of problem comes because third and if you know it's not able to handle the cases when you have multiple candidate keys and all the candidate keys are overlapping or you can say we have multiple overlapping candidate Keys like this suppose in our relation we have one candidate is a B second is BC next you can say DC like this see this and this is overlapping candidate key is here also see here also see here B here we have B so when these kind of cases exist then third normal form cannot handle these type of cases right to handle these type of cases we have bcnf we cannot say that it is fourth normal form right it is you can say that a stronger version of third normal form where you can say advanced version of 3nf and why it is known as Boyce Codd normal form because it was developed by EF code and Raymond F boys that is why it is known as Boyce Codd normal form it is not fourth normal form right remaining four second or third normal form was developed by EF code only see he's known as father of DBMS right now why this is more strict than third normal form let us discuss that what are the rules for a relation what are the requirements for a relation to be in bcnf and after that we will discuss with the help of two or three examples that something this this type of question would be given and you have to tell this as in bcnf or not and we will also see with one example that you have to tell the highest normal form exist in that relation whether its second third or bcnf right and after this video we will discuss what is the composition and after that we will discuss if a particular relation is not in a desired normal form then how to decompose that relation how to convert that relation into desired a normal phone so the rules are you can say our relation is in bcnf if and only if first one is it is in third and if right second rule is there for each nontrivial functional dependency see I'm talking about known trivial functional dependency not trivial right in the third normal form also we have discussed the rules on known real functional dependency right and by default by default we assume that all the this this relation given is in first normal form plus these dependencies given are in you can say non trivial because we we usually take those kind of dependencies that are known trivial right so second rule is for each known trivial functional dependency the lefthand side of the dependency must be super or you can say that determinant must be super key let me write down these rules so these are two rules it is in third and F second is this one for each nontrivial functional dependency I have discussed what is trivial what is known to your functional dependency suppose is x2y right then X the lefthand side of the dependency must be super key so it is very easy to check if a particular relation is in bcnf or not just you have to find out the super keys or if you don't want to find out all the super keys then you can go for each dependency and you can check a super key or not be a super key or not and see is super cure not and how to check that particular attribute or particular key is a super key or not just find out to find out the closer attribute closer and if attribute closer contains all the attributes of a given relation then that is what a super key right so let's check this relation is in bcnf or not find C so here I will not simply check that this is super key or not this is super cure not or this is super cure note because obviously they'll give you these type of questions and get in it they'll give you a particular relation functional dependencies and they'll ask the highest normal form exists in this relation so for that obviously you need to check for third also and second also and for those normal forms you need to find out the candidate keys so let's find out the candidate keys first of all after that we will check how to find out candidate he's C take the ol attributes take the closer and definitely that would find out all that tribute of the relation so you can say that this is a super key now find out candidate is you discard as many elements as many attributes as you can because can it he wrote a minimal superkey check out the functional dependencies how to discard check out functional dependency see a determined B it means I have a so I can discard B because using a I can determine a and as well as if you have a you can determine B right and it will later mind see it is still having all the attributes so this is what's still a super key now can you discard anything else a determined B be determined C it means a will determine C by transitivity property so you can discard C so here I am left with only a now a is what super key obviously we are not going to discard anything else because it is single attribute single attribute this will attribute closer will contain all that good so it is so foggy now check it as candidate here not definitely it would be why because it is containing a single attribute and no proper subset would be possible if no proper subset is possible then there is no chance that the proper subset of this would be a super key so that is why it is a candidate key so if a is candidate key then prime attribute we got a now how to check that still more super candidate keys are present in this relation or not if prime attributes are present on the right hand side of any functional dependency I have already discussed this trick in the previous video you can check out that video in the cyber turn then there would be more candidate here so check out prime attribute is a is a present on the right hand side of any functional dependency yes here so you can replace this a with C in candidate he can read he is a so you can replace it with C but we cannot say that still it is a candidate key you have to find it out it is super key that thing I can definitely see now how could a proper subset of C is possible no so if no proper subset is there then definitely that would be an innately so we go to candidate key a and C prime attribute a and C check again C is now prime a tribute now C is present on the right hand side of this functional dependency so you can replace this C with B I am replacing this with B now B is super key find out it is candidate or not yes single attribute yes definitely that would be candidate key prime a tribute is B now you can say B is present on the right hand side of this so you could replace this B with a but we have already check is can it get key right so now we have got all the candidate keys that is one is a B and C prime attribute are a B and C right see all that we do is our prime attributes' now you check this is in bcnf or not now check for each dependency C first of all it is in third and if it should be in third and if so this is in third and if I have taken this kind of example that it is already in third and if right and if you want to check the new can check there would be no transitive dependency because all the attributes are prime attributes and positive dependency is what nonprime attribute determining nonprime attribute right or another in another words you can say first either lefthand side is super key or right hand satisfy my tribute write if any of these to condition holds for each functional dependency you can say that this then you can say that there is no transitive dependency and that relation is in third in F right now there would be no nonprime attribute because all are prime so that would definitely be in third and F check for bcnf this is true now for each nontrivial functional dependency these three are nontrivial functional dependency X must be super key check this lefthand side must be super key is a super key yes so first is what according to first it is in bcnf not check this is violating the rule of bcnf or not is being super key yes B is candidate key definitely it would be super key yes you see super key C is candidate key definitely it is a super key so yes means each functional dependency is satisfying the requirement of bcnf right so you can say that this relation is in bcnf see why we are saying that it is more strict than third and F because in third and F we have what rules either lefthand side is super key or right hand side is prime attribute then find that would be in third and if right but here definitely the lefthand side you can say the lefthand side must be super key right no other condition is there this must be satisfied so that is why we are saying that it is a and you can say more strict origin of 3nf because 3 and F doesn't deal these kind of condition like if a nonprime attribute is determining a prime attribute then according to thordan f it is not a transitive dependency B why so because right hand side is prime attribute so it is not going to do these kind of cases a nonprime attribute is determining a prime attribute because of this dependency there would be some problem right but here in this case this left hand side must be super clean but here it is not a super key so it will not allow these kind of dependency here right and what about second normal form this will the second normal form deal with these type of cases right if Prime tribute is determining a nonprime attribute cprime attribute means it should be a proper subset of candidate he it's not like that it is a proper candidate key it should be a proper subset of candidate key then it will lower late the condition of second in it right so now you have the idea of all the normal forms for second third bcnf now i will discuss with one example and i will give you one example and we will discuss that what is the highest normal form given in that relation right see let us take this example and find out the highest normal form of this relation see so for this first of all we need to find out the candidate is all the candidate is how to find out candidate keys first of all take all the attributes of this relation closer obviously will contain all that tribute so this is super key now try to discard is remaining BCDE so I have a so using a I can determine a itself plus B CBE using this dependency so a attribute closure of a will contain all the attributes of the relation so a is definitely a super key now a super key I cannot discard anything else because it is an our single attribute right now definitely that would be a candidate key so now candidate these are first of all if we got one candidate key prime attribute we got a in a part of candidate key those attribute which are part of candidate key are known as primary now check is a this primary will present on the right hand side of any functional dependency if yes then there would be more candidate keys here we have a see this dependency can be splitted into bc determine ABC determine C BC determine e because of that splitting property so bc determine a right right hand side we have a so at the place of a in the existing candidate here I can replace it with BC right bc at the place of me but bc we cannot say that still less candidate unit to check out now B is proper subset and C is proper subset find out that reboot closure of B and C is B determining all that tribute being determining be nothing else because here both bc will later mine a sea but we have only B C is determining only see nothing else so this is not super key this is not super key so definitely see what Canada T now Prime a tribute r1 is B 1 is C now check out B and C a prime attribute those are present on the right hand side of honey this dependency or not yes here we have C right but definitely we will replace the C this is or trivial functional dependency so if you replace the C with BC then that would be same right here we have C this can be splitted a will determine be able determine C a will determine be able determind e for dependencies right by splitting property now at the place of B two cases can be there at the place of B I'm replacing a so first one a C now at the place of C I am replacing a so second one is B these are super easy but I cannot say that these are candidate he'll check out these cannot be candidate is why so because proper subset of this and this is what a and a itself is a super key so this cannot be candidate key this cannot be candidate key right so in this case we have only two candidate is a and B C 3 prime attributes are their nonprime attributes are D and E now check first of all first of all we will check for the highest normal form that is for bcnf right it's better to check for the highest normal form rather than starting from the second the lowest normal form right if this type of questions are you so for each functional dependency we will check the rules first one is this one a is super key or not because this is the main condition right a super key yes so this is satisfying the bcnf property B C is super key yes because BC is candidate key definitely it is a super game is do a super key no even D is not a prime attribute and if still you want to check then you can find out the D closer if D closer contains all the attributes then that would be super key but D closer contains only D and E nothing else you can try by D and E so this is not a super key so thus because of this property this property is volatile the bcnf rules so this is not in bcnf now find out see if this functional dependency satisfying the bcnf property definitely it would be throwing it and third and if no need to check right because for busy and if that dependency should be in third in if right so that is for sure that these and these would satisfy third and if rules you just need to check out this one for this one d to e is this transitive dependency or not because third is an F we will check in third and if you'll check transitive dependency means in that case check out left hand side is what it's super ly no you cannot say that this is royal it incurred in F or right hand side is prime attribute to condition at least one should be satisfied not both so is a prime attribute no so now you can say that this is not satisfying third in F property or it now another term you can say NPA determines NP nonprime attribute B is nonprime attribute yes is nonprime attribute yes so this is transitive dependency so this is not satisfying the property of third and if not check for second in F partial dependency so this isn't third so definitely in second definitely it would be in second check out for this one right if you are not satisfied with this answer that this would be definitely in second and if then you can check right you'll find out that these this and this are in second in it check out for this one second and it will check for partial dependency partial dependency is there it is not satisfying that property right if this is partial dependency then that is not in second in F partial dependency is what proper subset of candidate he will determine nonprime attribute right now is the proper subset of candidate key candidate here a and BC proper subset is obviously there is no proper subset of a proper subset of B C is B and C D is not a proper subset of any candidate key so no need to check the right hand side right because left hand side should be proper subset of candidate key right so this is not proper subset of candidate key so you can see that this is not partial dependency if it is not partial dependency then you can say that it is in second normal form I hope you are getting my point right for this video you must check out the first second third normal form videos so you can check out those videos in the description box I'll provide you the complete you know link of that complete playlist of DBMS in description box so you can see that now the highest normal form of this relation is second NL right let's take one more example so let's take this example and check out the highest normal form in this relation for that you need to find out the candidate keys how to find out candidate keys they call the attribute of the relation definitely the closure would contain all that tribute so this is what super key now try to discard attributes how to discard check the functional dependency a B will determine C D so I have a B so I can discard CD they determine a but I you don't have D so I cannot discard anything so I have now a B may be super key if you still want to find out you can find out a be closer maybe closer will have a B reflexivity property and if you have a B then you can determine C D so it is having all the attributes so a B is what super key now edit that is that candidate key or not find out the proper subset one is a one is be closer of a is a only closure of B is B only so it is not super it is not super so you can say that now a B is candidate key because no proper subset is super you know a B is candidate if you go to one candidate key right so now we got prime attributes that is a and B now check out prime attributes are present on the right hand side of any functional dependency or not yes here we have a so now at the place of a in the existing candidate key I can replace D so now I go to B B but I cannot say that it is candidate key you have to find it out but I can say that it is super he so I have to find it out the closure of it is sorry this proper subset is d when is B find out closer of be closer of B but already we have found out B is not super key now closure of D using D I can find out D and a nothing else so it is also not super key so now you can say that B D is also a candidate e so now prime attribute is would be one more prime attribute we got in Kanto city find out see here we have prime attribute would be these present on the right hand side of this dependency right by splitting I can say that a be determine D only they only see only e so on the place of B I can replace it with a B so if you replace it with a B then we have already discussed that a B is a candidate key no need to replace right so now no more candidate these are their two candidate either they're a b and b d now find out first of all you will check for high years to thatis bcnf is it in bcnf or not for each functional dependency check out the rules for bcnf definitely obviously will check that that condition that the left hand side must be super the left hand side of this dependency is a b is a be super key a b's candidate fee definitely it is super gay so yes it is satisfying the property is the super key is d c DS DB is candidate key right so how a loan deal can be super key and if you still want to find out then you can find out the attribute closer of D at a bit closer over here we already discussed it is only da not containing all the attributes or D cannot be super key we have already discussed right so now this is violating the property of bcnf because left hand side is not super key now check for third NF if this is NBC NFL definitely definitely this functional dependency will satisfy the rule of third NF right it is not it is not a transitive dependency right because obviously for bcnf that relation should be three NF and if this functional dependency is satisfying the property of bc anything by default you can say that it is in 3 NF right if you still want to check you in check out they will check out for this one only D determines a is a transitive dependency because 3 NF in 3 and F we deal with transitive dependency so what is trying to transitive dependency this one how we will check either lefthand side is super key or right hand side is Prime a tribute then you can say that that is in third and if that is satisfying the rules of third in it lefthand side is super key know so we have checked for one condition but check out for a second is this one right hand side prime attribute yes is prime attribute right so this is satisfying the property of three n the rules of 3 NF this is not a transitive dependency in another term you can say what is transitive dependency nonprime attribute determining nonprime attribute but this is what a prime attribute not a nonprime attribute right so it is in 3 NF but it is not in bcnf so definitely it would be in second and ifs in highest normal form of this relation is 3 NF and you will find a rare case in which a relation is in 3 NF but not in bcnf because almost every relation which is in 3 NF will be in bcnf right so this is one of that case when this is in 3 in it but not in bcnf so this is all about bcnf normal form how to find out that a particular relation is in bcnf or not right so we also discussed some practice questions like this also will they will take one relation and we'll discuss the highest normal form we'll find out the highest normal form in that relation write some complicated type of questions in the next video right and also we'll take one table and with the help of that table will not take these type of relation we will take a proper table with some data and we'll find out that particular relation particular table is in that desirable normal form or not right so now I'll see in the next video till then nobody take here