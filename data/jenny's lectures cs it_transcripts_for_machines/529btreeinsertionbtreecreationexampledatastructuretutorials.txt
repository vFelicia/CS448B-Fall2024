if order is given off a tree then maximum children would be same as the order given em minimum children would be my tour ceiling maximum Keys would be M minus 1 and me home keys would be M by 2 ceiling minus 1 right so here I am going to take this example order is 4 so here maximum children can be 4 right minimum children can be to maximum keys can be 3 and minimum keys can be one except root mode see these rules are not applied on root node the root node can have maybe two children root node can have zero child root node can have one key like that now the me one main important property of B plus 3 is what in B plus 3 the data see this given data this data is stored only in leaf nodes right and in B tree data is stored in leaf node as well as in internal nodes but here the data is stored only in leaf node now what is stored in internal nodes in B plus tree only the pointer so you can see the indexes fine indexes to the data which is stored in the leaf node those indexes are stored in internal nodes and second important point is the data which is present in leaf node those data is present in a formal linked list right all the leaves are connected with a link with each other I will show you how we are when we are creating a B plus tree with this example right so these are the two main differences I am going to make a proper video on V + 3 properties and how we plus we are different from B tree in this video I am going to tell you how data is to be inserted in B plus tree right c + b + r ACB tree is what it was a generalization of BST binary search tree so data in parent node right so the data to the left of parent is always less than parent and data to the right of parent is always the greater than that parent so that property is always that properties also for loading meter here as well as in B plus free so now let us start see here order is four so initially no trains there are three is empty so we are going to construct our node you can say right and that mode can have maximum how many keys three keys so that node can have maximum one two three keys and maximum children can be one to see one two three and four so in between these four links only three keys are possible right so now see first first number is 1 insert 1 so we can insert 1 right so next next is 4 now we're 4 is to be inserted food is here only 1 node is there right so 4 is greater than this one so 4 has to be inserted to the right of this one so here we will insert 4 next is 7 7 is greater than 1 also greater than 4 also here we will insert 7 next is 10 now where we can insert 10 after this 7 here but it is not possible you cannot insert 10 in this node why so because it is all flow condition maximum keys in a node can be only 3 here fine in this case so now what should be done now this node should be splitted now B 3 and B plus 2 you also always grow towards root root upward direction not to the towards leaf direction right so we are going to find how how this node is to be splitted now find out the middle element now here we have 4 nodes right see don't do this mistake that 10 you are supposed to insert we cannot insert 10 here so remaining elements are 1 2 & 3 find out the middle of this 1 4 4 would go up and one is to the left of 4 and 7 is to the right of 4 no you have pretend you have to pretend it that you have inserted this 10 and now we are going to split this node right but actually we haven't inserted because we cannot answer maximum limit is only three keys so now the middle element can be this one and this one because we are having even factor four right so if you if you consider this as a middle element and you will split from this node you will split from this data then the tree would be left biased and if you consider seven as a medial middle element and you split from this node then you the tree would be right biased so it's up to you you can take four also you can take seven also but in starting if you if you construct the left bias tree then during the completion of the complete tree you are supposed to follow that rule also the left bias tree and if here you selected that way as right biased then in the whole the complete tree you are going to follow that rule that right biased row right so here I'm taking semanas middle element I am going to construct right biased tree right you can construct left biased also and so your answer would be different from my answer but that is also correct right so now seven suppose seven is middle element so I am going to split from this later now house wedding would be done seven would go one level up or you can say to its parent now here we don't have any parent so seven would go up and that seven would become parent now the tree would be something like this C seven would go up so create another node the maximum capacity is three keys to the left of 7 to the left of 7 we have 1 & 4 1 & 4 right here also we can insert one more data and to the right of 7 to the right of 7 what we can insert maximum capacity is 3 to the right of 7 we have 10 right plus in B plus 3 what you will insert you will insert this 7 also in this node 7 and 10 why so because see I have told you in B plus 3 the data over the data this data should be present in leaf node right so if you do not insert 7 here so this is the leaf node and 7 is not present in the leaf node so data should be present in leaf node now you are inserting seven to the right of this this seven why can't you insert seven here so another rule is that to the left of this one all the data should be strictly less than this node right and to the right of the snow to the right of this node from where you are going to split to the right of that node the data can be either greater than or equal to this node so 7 is equal to this 7 so we are going to insert 7 to the to this right side of this 7 to the right child of the 7 right now see the 7 is only for the index value you can see just pointer to this leaf node actual data is present here right another thing I have told you all the leaf node are connected with a link the data is stored in the form of a linked list so this this leaf node is also connected with this one using a link with this leaf node right now next next we are going to insert is this 17 now where 17 can be inserted always data is to be inserted in the leaf node that you have to take care now 17 is greater than 7 so go to move for this link 17 greater than 7 greater than save this 10 so here you will insert 17 next is 21 we're 21 can insert 21 is greater than 7 greater than 17 and 21 so here you can insert 21 but actually we cannot insert or flow condition is there now you have to split this node now how splitting needs to be done the metal I'll take the middle element and that middle element would go one level up right so now I'm constructing the right by astrayed Oh Here I am going to take 17 as middle element so 17 would go to its parent node or you can say one level up so here you can insert 17 because 2 spaces are still free so now the tree would be 7 and 17 and here still we have one space left same here we have 1 and 4 right and 17 would go up so to the left of 17 7 then to the left of the 17 we have seven eight ten right notice maximum capacity of node is three so one space is free and to the right of seventeen to the right of seventeen the data would be 17 and 21 right because the data should be present in leaf node fine so now next is 31 now where you can insert 31 greater than 7 greater than 17 so go to this link greater than 21 so we'll insert 31 here only now next s 25 very open insert 25 25 has greater than 7 greater than 17 so go to this link greater than 17 greater than 21 and less than 31 so where you can insert 25 here after 21 before 31 right because it is BST also you have to follow the property of BST fine now this cannot be done our flow condition is there now spitting would be done now spitting is what find the middle element sounds I'm going to construct the right bias tree so middle element out from the 17 21 25 and 31 is 25 so 25 would go one level up so 25 would go here only fine now I'm going to update this this tree only so 25 would go here so still we have one space left so we can insert 25 here and if you are splitting from this nor then to the left of 25 way of 17 and 21 fine to the left of this we have 17 and 21 and to the right of 25 what would have 25 and 31 so to the right of 25 you will have 25 and 31 and one node is still free and here also one node is still free now next is 19 where you insert 1919 is greater than 17 but less than 25 so go to this link 19 greater than 17 but less than 21 less than 21 so here you will insert to 19 and 21 would go here next is 20 where you can insert 20 greater than 17 less than 25 greater than 7 greater than 20 in less than 21 so you can insert 20 at this place 17 here you'll write 17 19 20 and 21 right there's no rule with something like this but you cannot answer 21 here you have to split this node from where you are going to split middle element is 20 so 20 would go up fine and here also now you cannot answer 20 because this node is also full now you'll repeat the same step of splitting you will split this node also fine and that that node that from where you are going to split that element would go one level up fine so I'm going to first of all do one splitting from this node only fine so if this node is splitted then 20 would go one level up so now now this tree would be something like this seven seventeen so now if 20 would go one level up so in this node where 20 can go after this 17 here you would write 20 and hill will write 25 right and to the left of 7 we have 1 + 4 to the left of 17 we have 7 and 10 to the right of 17 now from here splitting is done 20 would go up so to the left of 20 we have 17 and 19 to the left of 20 we have 17 and 19 and to the right of 20 we will have 20 and 21 so here you will have 20 and 21 and to the right of 25 you will have 25 and 31 but this is the intermediate space we are not done that is why I am doing there's something like this now again this is not all this is not possible you have to split this node also now from here middle element is 20 20 would go one level up so after that after that after this waiting tree would be something like this see 20 would go one level up when another node would be created having maximum space of 3 keys to the left of 20 we have 7 and 17 7 and 17 at this level right to the right of 20 according to the rule what should be the piece 20 and 25 so to the right of 20 we should have 20 and 25 right and as it is these elements would be 1 and 4 to the right of this we have 7 and 10 to the right of 17 we have 17 19 right now these are leaf nodes right and this is internal node and this is also internal node so now the rule is these keys this cannot be repeated in internal nodes so here you have written just 20 so here you cannot write this 2 and D are going to cross 20 from here because what actual data is in leaf node and in internal nodes we just have indexes so what is the point to repeat the same index again and again we just need one index and using that index are using that pointer only we can reach to the actual data on ax right so that is why in this internal nodes we are not going to repeat the same data so here we have written 20 so we are not going to write 2 nd here fine so here you will just write 25 so now here 20 is not there to the left off to the left of this 25 if the data is to the left of 25 the data is what 20 and 21 Â°c due to the left of 25 we have 20 and 21 20 and 21 fine and to the right of 25 we have 25 and 31 so this is from this stage that tree would be something like this so I am going to rub this intermediate stage fine now here 20 is not present so here we don't have any element 20 is not there when you just have 25 now next next is 28 now where 28 can go 28 is greater than 20 yes greater than 25 go to the right side of 25 you go to this link greater than 25 but less than 31 so here you will insert 28 here you will write 31 next is 42 42 can go to right of 31 so here you can insert 42 but actually you cannot insert this is our flow condition again sweating would be done and middle element is 31 31 would go one level up here only here we have a two space left so that is fine 31 can go here so after this the tree will be something like this we have 20 here we have 7 and 17 to the right of 20 we have 25 and I am 31 31 will go one level up so here here we have 31 right these elements would be same 1 and 4 here you write 7 and 10 here you will write 17 and 19 fine to the left of 25 would be 20 and 21 right and now to the right of 25 would be c 31 would go up so to the left of 31 the data is 25 and 28 to the left of 31 the data is 25 and 28 n to the right of 31 31 and 42 fine and yeah I forgot one more thing see this link this link will all the present in all the between all the leaf nodes from this leaf node to this one from this to this from this to this from this to this from this to this so this link would be present in all the leaf nodes like this you have to insert this link also and from here to here something like right this is the final B+ tree here also you are having the space of the node is having space of three keys so here I have shortage of space that is why I have just made a little bit mashed up fine so I hope you are getting this is that way fine these nodes are having space of three keys right maximum you can insert three keys now see as you can see this this data of this data is present in the leaf node all the data you can check fine and in these internal nodes we are having just the indexes fine or you can say pointers as well as these these leaf nodes are also linked with each other so when you are going to accessor data that is why see that is why in B plus tree searching is very easy because the data is present in the leaf node you have to just fetch the root to block this block and only one leaf one leaf node because one this this leaf node is having the pointer to this leaf node then this then this then this and something like this fine so searching is very easy when data is stored in the form of B plus tree I am going to discuss with you all the properties of B plus tree in next video and in next video we are also going to discuss how to delete a data from B plus tree fine so till then bye bye take care