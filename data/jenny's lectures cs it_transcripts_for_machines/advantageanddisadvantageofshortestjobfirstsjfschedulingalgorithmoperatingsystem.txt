hey guys we have already discussed both the versions of shortage of first CP filling algorithm that is preemptive and non preemptive that preemptive version is also known as shortest remaining time first CPU scheduling algorithm fine so in this video we'll see the advantages and drawbacks of the this algorithm right see now first of all the advantages of this algorithm the that preemptive version of SJ 4 you can say that s RTS shortest remain shortest remaining time first scheduling algorithm gives you the minimal average waiting time I'm not saying that s jf with non preemption gives you the minimal average waiting time but this s RTF guarantees you to give the minimal average waiting time fine you will take any numerical and any problem and you apply all the algorithms on that problem see the society when you apply this si TF then you will get the average waiting time which is minimum out of all the algorithms ok no algorithm will give a burst time less than whatever the si TF will give you ok so the main advantages of this is what it gives you you can say the minimum average waiting time and main minimum turnaround time also fine second thing is it gives the better response time then firstcome firstserve response time is 1 when the CPU would be allocated the first time to the process after arrival of that process so the response response time would be better in case of sjf rather than FCFS why so because you know we maybe apply the funded at the shorter the processes having shorter bursts time will be allocated to the CPU first that is why the response time would be better in this case third one is it gives you the maximum throughput now to put is what you can say a number of processors per unit time like see when you solve any numerical then this you draw the Ghent chart or you can say from here to here suppose we have completed one two three four five processes suppose fine so and here we have like from zero to let us suppose twenty two so from this to this this is known as what shade you'll how much time it is from zero to twenty two that is twenty three unit of time and in twenty three unit of time how many processes has been completed five processes so true patrolling will be five divided by twenty three so this is what the throughput fine so this sjf will give you the maximum throughput fine or you can say that s RTF specifically if you say then you can say aasaiya TF will give you the maximum throughput okay see this overall throughput would be same for all the processes from starting to the ending suppose this is the ending of the range chart this overall throughput would be same for all the algorithms because obviously if there are five processes then five processes would be there till from starting to the ending of this game chart but main funda is what when you stop at any point the schedule at any point and then you check the throughput from here to here in that case you can say that this s RTF will give you the maximum throughput okay more and because in s RTF or you can say in SJ if we try to you know complete or we try to execute the processes as early as possible because we choose the processes having minimum birth time first so we try to you know execute the processes many processes more and more processes as early as possible that is why it gives you the maximum throughput you check at any point of time in between the schedule C or D okay they say overall overall throughput would be same for all the algorithms okay now the fourth point is it providers standard for other algorithm in case of average waiting time okay standard mean means what siano algorithm will give you the burst time less than the Society F will give okay that is why if you apply any other algorithm on any process and the average waiting time is a very close to this average waiting time given by the Society F then you can say that that algorithm is also good fine that is why it it set up standard for other algorithms by checking out the average waiting time and comparing the waiting time with this algorithm you can say that particular algorithm is good or not good fine now let us see that disadvantages of this algorithm the very first or the main drawback is what that this algorithm is not implementable now you will say that if it is not implementable then why we are studying this algorithm although this algorithm is not implementable we cannot you know practically implement this algorithm this has not been implemented in any operating system yet okay but it provides us tender for other algorithm and why this algorithm is not implementable see this algorithm basically depends on the birth time main criteria is what we choose the processors having minimum having the you know shorter births time first rather than the process having larger burst time okay now see in FCFS what is the case the criteria was arrival time obviously that algorithm is implementable why so because in that case we know arrival time of every process before execution of that process when that process came into the ready queue okay that is why that is implementable but in this case prior to the execution it is almost impossible to you know know the burst time of the process or you can say how much time that process would take for its complete execution it is almost impossible to say before the execution of that process okay and the main criteria is what obviously the burst time and we don't know the burst time then how this algorithm can be implemented that is why I am saying this algorithm is practically not feasible to implement okay now although there are some ways using those method we can predict the burst time of the process just approximate prediction of the burst time of the processor I can you know I cannot say that we can predict the exact burst time of the process but we can predict the approximate burst time of a process so that those methods are discuss in next video now second disadvantages is it starvation problem with the processes having larger burst time now what does this starvation problem see in the previous video I have already discussed what is the difference between the convoy effect in the starvation problem FCFS is having convoy effect and in this in that video also I have discussed what a starvation problem okay a process is waiting for a you know indefinite amount of time because of some may be because if they know that processor is biased towards some other processes and that criteria may be priority of the processes or anything okay so let us discuss how the starvation problem is there in stf now let us take a pure life example now suppose you go to a burger shop and there you want to purchase around hundred burgers okay and suppose here is that counter boy and you went there and you you want to purchase hundred burgers and see what if the fund out for this shop is the counter boy will serve those person who are having order of maybe one two three or five burgers or less than you can save hundred burgers okay because 100 is very large amount and this counter boy will serve those persons who are having you know order of small amount of burgers and some other person come who require only one burger then counter boy will will will you know serve this person first fine another person came who is her requirement of two burger another person came three burger one burger five burger and so many persons are coming who require the burger less than 100 less than 100 so you are waiting here fine although you came first maybe after one person maybe you come after one person but he is serving the person who are coming after you but the case is he is serving those person because he is giving priority to those person who want one two or three burger so you can say less than hundred burgers okay now you are waiting waiting and waiting so this is what called starvation this is a long process so starvation problem will be with the processes having larger births time okay this is called starvation that is why here because the priority is what CPU will execute those processes Hamming shorter Borstein like in this case who who wants one or two burger the counter boy will serve those person first rather than you because they want 100 perverse so the first time of you is hundred you can say or these processes are having shorter bursts time than you that is why CPU is executed if you will execute those processes and you will have to wait that is why in this case starvation problem is there with the larger the processes having larger bursts I'm fine see now there can also be convoy effect although this this is not mentioned in any textbook that SDF will suffer from convoy effect but sometimes it is possible I feel it is possible because I observe I observe a case where in a safe also we the processes can suffer from convoy effect okay now let us take that example see I'm taking two cases case 1 and this one is case 2 now we are going to apply sjf with known preemption case as they up with known preemption I am NOT taking the example of SRT F okay with preemption because that gives you the that is the best one see here game chart will start the time from 0 I to 0 only one process is there that is P 1 so we are we are taking SJ with known preemption known preemption in that case once CPU is allocated one process that process will continue its execution tell its termination now the first time is if this one is 50 so it will execute till 50 now next is next see at 50 we have 1 this one is done P 2 and P 3 not ready cube now now pick the process having minimum burst time 1 and 1 the first time is same for those before both the processes in that case you will check the arrival time where you will apply first come first so now check out who came first P to arrival time of this one is 1 this one is 2 1 is less than this 2 so when I locate CPU do P 2 for 1 unit of time burst time is 151 and after that P 3 and this one is 50 so this one is first time is 1 so this would be 52 now calculate the completion time completion time of P 1 is what at what time P 1 has been completed at time 54 p2 it's 51 for P 3s it's 52 now turn around time turnaround time goobie completion time arrival time 50 0 that is 50 51 minus 150 52 minus 2 that is 50 now waiting time waiting time would be turnaround time first time turnaround time worse time 5050 50 minus 1 49 50 minus 1 that is 49 okay now the average would be so the average waiting time would be thirty two point six not check out this case grow again chart time you start from zero at zero we have two processes P 2 and P 3 now the criteria is you have to pick a process having minimum Borstein but both are humming same boss time 1 and 1 so apply first come first so check out the arrival time but arrival time is also same for both the processes in that case what you will do to break the style you will you will check that for the ordering of that process CP 2 has been written before P 3 so we'll take P 2 first okay for how long it will execute first time is 1 so from 0 to 1 in the after that at 1 say at 1 we have 2 processes P 3 is also there P 2 has been done P 3 is also there and P 1 has also arrived at 1 so out of 50 and 1 out of these processes you will choose which one having minimum burst time because we are we are discussing the SJ with known preemption so will allocate cpu 2 P 3 for 1 unit of time 1 2 sorry 1 2 2 now next to P 1 for 15 out of time that is here we have 52 now here calculate completion time of P 1 it's 52 completion time of T 2 1 completion time of P 3 to turnaround time done a long time means completion time arrival time 52 minus 151 1 minus 0 1 2 minus 2 minus 0 that is 2 now check out the waiting time waiting time turnaround time burst time 51 minus 51 1 minus 1 is 0 2 minus 1 that is 1 average waiting time would be 2 by 3 that is 0.6 now you can compare although we have applied what here sjf with known preemption but see here average waiting time is 32.6 here F is waiting time would be 0.6 so this is what convoy effect we have discussed this in FCFS because because of this long process this process the long you can say that the process having larger burst time this p2 and p3 are having very small burst time but small the process is having shorter bursts time had to wait for a long time 450 unit of time that is why average waiting time has increased okay so for the same thing here we have three processes three processes same burst time but the change is what only the arrival time okay here I would hear the processes having shorter bursts time came first that is why we are located CPU to those processes first and that is why average waiting time is very less so we can say that if I feel that if we cannot say that sjf remove the convoy effect totally yes SRT F in a society F there is no if we convoy effect but sjf with known preemption is having convoy effect in some cases okay in next video I will discuss how to predict the burst time what are the methods to predict the burst time for sjf fine so till then byebye take