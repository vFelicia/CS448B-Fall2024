hey everyone I hope you all are safe and doing good so in the series programming language we have completed our inheritance Concept in Python what is inheritance and types of inheritance we have discussed right but small but one thing is still remaining in this inheritance we have a Diamond problem and inheritance classic Diamond problem especially in multiple inheritance now that thing we'll discuss in this video what is this problem Diamond problem why they suffer right and how to solve this problem which method python used to solve this problem what is mro Method resolution order which algorithm the mro use to find out the order like C3 linearization algorithm right so in detail we will see that algorithm as well right it's not like that on simply on your laptop just you can just use that tribute you know that this attribute underscore underscore mro underscore underscore or maybe mro function so you will get the mro but how you are getting that mro what is behind the scene what is the algorithm the working that also step by step I'll show you right okay now let's see first of all what is this classic Diamond problem see this thing we have seen this is Hybrid inheritance right this is what hierarchical and this is what multiple inheritance so this is basically this type of structure as you can see it is somewhat like a diamond right and here what is this problem if suppose I am having same method like maybe show in this parent method and as well as show in this child also and this child one has overridden this method right and suppose show in this child too as well and this also has overrid in this method now this child three is inheriting from Child one as well as from Child two these two are parent of child three so so you would be confused which method it will inherit using the object of child three which method should be cold this method or this method or the parent method because ultimately this is we can say like maybe grandfather type of thing right so from there also it is inheriting right so now style 3 is in confusion which method it is going to call or inherit this or this if they have overridden this method if they are not having any show method any show method so it will inherit from show here right fine okay now to solve this problem in Python it is not a big problem basically we use mro method resolution order to solve this problem right now what is this mro it is just a method or you can say to get the order in which the derived class will inherit or will call the attributes and methods from the base classes or you can say from the hierarchy of classes in which order the drive class is going to inherit if it is inheriting from multiple glasses right let's suppose if in my class I just give an assignment right and I asked all the student to submit that assignment tomorrow only so on the next day everyone is ready with their assignment right and if everyone like comes to me ma'am my assignment my assignment then it would be very hectic for me like from from whom I am going to accept the assignment first because everyone is present here right to solve this problem like the order to solve this problem what I can say like I'll say please be seated at where you are at your seats and I'll call according to I'll call your roll number and according to that you will come and submit your assignment it means first I'll uh say roll number one roll number one one will come and submit his or her assignment then roll number two then roll number three normal four like this so I have used the roll number technique the method right to solve this problem fine same kind of thing in programming because assignment is like you can say it's same same method or same attribute I am going to access from all the students right so same method is in all the parent as so the derived class this child class will access method from which parent to solve this problem this is basically this confusion is classic Diamond problem and because of the shape it is Diamond like that is why it is known as Diamond problem and this is an interview question as well but in some language like in Java Java don't support multiple inheritance because of this problem only they use that interfaces concept right but in Python and it would be resolved easily with the help of this technique mro right now I have told you mro is what mro is used to get the order in which the methods or attributes are to be inherited from the hierarchy of classes in case of multiple inheritance because this problem especially arises when we use multiple inheritance in your program right okay now let me just show you practically this thing this class and how Mr is going to solve this problem right and then we will discuss Right Now the default algorithm which is used to solve this problem in this mro in this mro this mro use C3 linearization algorithm to get mro now what is this algorithm and how we are going to get this thing that also I will show you right let's see practically okay so let's create a new file here Diamond problem dot py right and let's take this example only we have class A having display function display from a class class B it is inheriting from a class class C as well suppose inheriting let's just modify a little bit from a class right it is having display and it is having show as well as let's say it is having display show is going to show like hi from CClass and display display from sorry not b class it's from C class now class D is hiring from both B and C and suppose it is not having any any display function so let's just write down here pass okay now with the help of this D1 object with the help of this D1 object I want to call display function so which display it is going to call from b or from C because both are parent of this class this what we can say d class right so this problem can be solved in Python with the help of mro method resolution mode so it will first search what is the first parent is B so it will search in first of all it will search in B we are not having any method display in B so it will search the first parent is B so it will search in b we are having display yes so it will exist it will inherit this display right that's it so let's run this so display from b class it is inheriting from B Class and suppose I'm not having this display in b class in that case pass now first you will Search in b there is no display then it will search in C it will not go deeper it will not go in the parent of p no the latest technique is switch through linearization that is what it follows left to right first then go deeper and previously deeper means depth first then left to right right so if I run this then it will display from C C Class right in B we are not having in the first parent we are not having display then in Search and C if in C as well I am not having then left to right there is no display then it will go deeper means deeper means the superclass of this B and C super class is a now it will go to a see display from a class right so with the help of mro you can solve this problem so if you want to print the mro of this class for D class then with the help of this function or with that Prof attribute we are having this attribute as well as like this this field Mr with the help of this attribute also you can print the mro see first D then B then C then e then object class like o cluster object class let's take a complex example and then I'll show you step by step what is you know going on behind the scene how we are getting this mro like this what are the steps of this algorithm what is the C3 linearization algorithm right step by step I'm going to show you with help of a complex example I hope you will get it right so if you want to go deeper if you want to understand what is the behind the scene process of this mro the algorithm the steps of that algorithm then you can continue to watch this this video otherwise for you that's it right okay let's take this example I am having Class A B C D E and F class is deriving from ABC then G class is inheriting from dbe then H class from d a and then finally Z class from f g and H right so if it is having you know obviously multiple inheritance and many type of inheritance so if you want to access some method with the help of this object of this Z Glass then what is the mro the method resolution order first in which class it is going to search then this then this with the help of mro attribute or mro function you can easily find out but what is behind the scene what is the algorithm the steps right please don't write down the comment section like the syntax is correct and there should be call and then bars column pass okay now let's just draw first uh diagram of this thing so I'm just starting from here the last class is z so Z is inheriting from f g and H so this order is also very important this is one known as local precedence order right and your amp the algorithm or the technique you use to find out mro that should follow this local precedence means first if given the help of object of uh Z class you want to access something then first it will search in this order in this declaration order F then G then H this is local precedence order right second thing which is important that should follow by the algorithm which is used to find out MRI result monotonicity now what is monotonicity see if the class we have a class C and Base Class of C is even and Base Class of C1 is C2 so if you find find out the mro of C the method then it would be first you will search in C then in C1 then in C2 something like this so if this C1 class is before C2 class when you are going to find out the Precedence order of the mro of C if C1 precedes C2 while finding the mro of C then definitely C1 proceeds C2 if you want to find out mro any subclass of this C if you have any sub class or C like Z and if you want to find out the z Mr of Z then definitely it would be Z then C then C1 then C2 C1 is before C2 in this also in this also this is type of monotonicity it's not like that for Z first C2 then C1 it will create problem right so I hope now you got what is local precedence order and what is monotoncity so these two rules should be followed by the algorithm which is used to find out the mro and which algorithm is used by default in Python 3 is C3 linearization right now what is this algorithm I'll tell you and how this is different from the what was used before uh you know python 2.3 an old style technique to find out mro that was many problems right so we have first Z now is that f g f so in this order only I'll write in the diagram as well f g and H not like h g f something like this right then for fabc so a b c f is hiring from ABC left to right in this order then G is hiding from d b e so B after B we are having e so let's suppose here we are having e and before D is before B so let's write down B here so d b e then for h d a so D and A that's it or one more thing because we know object class or simply you can write down here oh it is root for all the classes by default in Python 3. right so you can write down something like this like here object or simply o or if you don't write that is also fine automatically it will inherit from object class right now this is the diagrammatic representation now how to find out mro of Z what is that C3 linearization algorithm how to find out let's see the steps if you find out linearization of Z then please watch carefully then Z Plus the name of that class plus merge function we are going to use in this see through linearization algorithm right merge then linearization of all the super classes of this Z then linearization of l means linearization of superclass of Z is what F G H so F comma G comma H and then list of super classes fgh in the same order in which we have written like fgh here right okay now obviously we have to find out first linearization of f linearization of f so first find out this F same technique write down f plus merge of linearization of all the base classes of f based classes of f it's a b c it's a b and C right and just write down list of all the base classes ABC okay now linearization of a okay now linear linearization of a is what means with the help of a object if you want to access the method then from first it will search in a then in its Base Class so Base Class of a is object class only right so from diagram only we can just find out L of a is what a o no need to write down this one or if you want to write down then you can just write down like L of a is equal to a plus merge linearization of o and o both are object objects so it could be only sorry yeah only so it it would be a and o that's it right okay so just write down here f plus merge hello phase a o L of B is obviously B O then C O and then a b c now we have these list list of mineralization of a then this list this list this list I'm not writing down like this particular list okay but these are lists fine now have the submerged function works so first of all take the first list and mark the first element of the list as head so K is what head first step is this second step is you have to find out it is a good head or not now how to find out if this a see this a is head and whatever after this a that is tail of the list here only o so this is tail of the list here B is head this is tail C is head this is tail a is head BC tail BC both are 10 not like only C is tail no except head except the first element all the elements are 10 if there are three four five elements right so now a is head second step is if the head is present in the tail of any other list then it is not a good head and we cannot take it so here a is Mark as head is it present in the tail of any other list no so it is not present means it is a good head okay now head we have got an A's head now if it is a good head third step is if it is a good head then just you have to add this here in the mro that class like suppose F then add to this mro that was at the beginning of this line F A Plus and remove this from all the list so remove the say here o b o c o and BC only okay now if you have done this it's okay then take the second element and same step if it is not a good head suppose a was not a good head in that case what you will do next step is switch to the next list Mark the first element as head and same process you have to repeat check if it is in the tail of the other list right if it is present then it is not a good head then switch to next list and like this right okay now like this now next is o so it is not a good head so switch to next list first element is B so mark it as head is it present in the tail of other list no so B is good head if it is good head just remove this and add here in the mro f a b plus as well as remove this B from the all the list o c o c B was done now next is rho is it the tail of other list yes so it is not a good head move to the next list C now C is present in the tail of other list no so let's consider C is a good head so f a b c plus and this is what object so that is why merge of the show is only so finally f a b c o this is linearization of f class F class f a b c o right okay now if you got this then you have to find out linearization of G and H it is up to you same step you have to repeat for G and H right I'm directly write down the algorithm the linearization of G and H because finally we will find out this Z if you haven't got this thing you can pause the video you can rewind the video you can watch this again right okay okay so this is linearization of f the list this is for G this is for H I hope you got this one correct right okay now you have to find out for Z so Z Plus take the first list consider f as H head Now find out f is in the tail of other list tail of this list is this one d b e o d a o for this GH is it present in the tail of other list no so z f plus just remove this from everywhere so f a a b c o then Z j d b e o h d a o and remove this F as well as GH now this is remaining take the next element a mark it as head now check if it is present in the tail of other list tail of this list is no yes d a o it is present in the tail of this list so it is not a good head so we cannot take this if it is not a good head then jump to the next list and consider G as n now J is present in the tail of other list no so yes G is good head so just add G here in the mro Z and remove this G from the list h d e o and here we have now h of B right now G was done now next is D so is D present in the tail of other list yes D so D is not a good head okay switch to the next list now consider H as head is it present in the tail of other list no so it is good head so z f g h plus merge a b c o then remove h d a o right now next is D now D is present in the tail of other list Plus merge a b c u just remove this d b e o and a o now next is B we have removed after Edge it was D now X is a is a present in the tail of other list you know so take this a as well as d a and remove this from there remove this from a here also a is here so b c o b e o and O from every list you have to remove that element that was head and removed from here now after it is o o is present in the tail of other list yes now move to the next place next is BCU back now take B is we present in the tail of other list no so B is good head so remove this see B is present here but it is head I have told you the first element is head other than first every element is a so EO is T so just remove this c o e o and O now after B we have C from here we were taken like B then C is C in the tail of other list no so Z same thing same thing you have to repeat now C plus merge o u and O next is o o is in the tail of other list yes move to the next list e yes you can take e and after e definitely o so that would be O So finally we will get z f g h d a b c then e then four this is the mro for Z in this diagram with the help of this c three layerization technique which is by default in Python this is by default is used in Python 3 right so see if you see from this diagram then this is z f g h d a b c e o so it is left to right then in deep you are going so this technique use this thing the new one if it is not present in any of the class from left to right then go deeper right but in old style the technique was first depth first then left to right in older technique the problem was if I have something like this a b c let me just take a simple example D so if you want to find out Mr of D then it would be D then B then not left to right first deeper we will go parent of B that is a then finally if you consider O then you can consider here o but I'm not considering Arrow object class then C then a then a r 2 time so in old style just remove this one right and after that a new style was also introduced there it was if this is the case then remove this one first one so dbce but this also you know uh having some problem that is why a new technique was introduced that is C3 linearization algorithm and that follows these things like monotony City Rule and local precedence order while finding out the mro but there are still many things left about mro method resolution order right it's very you can say vast concept but if you want to go in deep you can just go to Google and you can find out different different examples and many things that is why I have here taken a complex example so that you can get this algorithm the steps of this algorithm you know clearly I hope you heard this I have tried my best right so this is all about Diamond problem how to solve this problem in Python and the C3 linearization technique and all right so now I'll see you in the next video till then bye