not linked list right what does doubly circular linked list for that this thing we have already discussed the introduction of this list when you were discussing the types of linked lists so you can check out that video here in this I button fine see this is what a doubly circular linked list in this video we will see how to implement this list or you can say how to create this list and how to reverse this list or you can say how to display the content of a doubly circular linked list see as the name suggests it is having the property of both doubly and circular linked list so as you can see here see this is what are doubly linked lists each node is having three parts one is data part and one is pointer this is pointing to the next node this pointer is containing address of the previous node right now have to add the properties of circular linked list in circular linked list what we have discussed the last node would contain address of the first node as you can see here the next pointer of this last node is containing address of the first node that is 500 fine so there is a link like this this to this node plus 1 extra property of this Leste's what why we are this is known as doubly circular linked list here the previous pointer of the first node would also contain address of the last node right the previous pointer of first noon see here that 600 is there and 600 is address of the last node and here the next pointer of the last four would contain address of the previous node right so in this list we don't have any null pointer right so this is what are doubly secular linked list now in the in this case we have maintained both head pointer and tail pointer head is containing address of the first node tail is containing address of the last node if you maintain only head node then also you can create this list see this this link is bidirectional right rather than creating two links here I made this bidirectional link so this 2 this also in this 2 this also we'll see how to create this list right how to represent this node of the list that King I guess you already discussed when we were discussing doubly circular linkedlist right so initially we assume that list is empty we don't have anything in the list right it means you can say head is equal to null at starting all right see how you will create this list so this is how we are going to define our own data type that is how to represent this node struct node three parts are there data parts next pointer and previous pointer right how much memory would be allocated four bytes for this for for this and four bytes for this pointer will would be allocated four bytes because in 32bit compiler if 64 bit compiler is there then eight bytes would be allocated so total 12 bytes block is there right we are going tending to pointers head in a right this is what we will define a datatype global outside of all the function so now we are going to define this function that is create dynamic and this doubly circular length list right so obviously first of all we think that we may assume that the list is empty so for inserting the nodes we have to create this node right it means you have to allocate the memory to this node and how we are going to allocate the memory we use what dynamic memory allocation in linked list right why we use dynamic memory allocation that thing we have discussed when we were discussing introduction to length list you can check out that video here and how we allocate the memory dynamically using malloc function so I guess everybody knows how to write down that syntax you have discussed many times right so it's starting I write here head is equal to null it means there is no list we don't have any list right now I am going to create an node and that pointer of this node this this so the address of this node I am going to store in another pointer that is a new node pointer I have created a new more pointers this this new node is pointer to node that is why I am writing here datatype is struct node right so now what you will do how you will write this so this is the situation now we have created a node we have allocated the memory to this node using malloc function right malloc sizeof how much choice for this struct node for this node so that is why here in bracket will write stock no 12 bytes will be elevated address of the first byte is 500 so malloc would return one point to do the starting address of this node but my luck will return void pointer that is why you have to typecast this thing because this new node in this new node I'm Stu I'm going to store this address and this node is what pointer to node right so here you will write struct no district we are going to typecast to this thing and whatever this will return in new node I am going to store this right now I'm I'm going to ask from the user for the data right which data I want to store here so this is how we are going to store the data right printf enter data scan opposite is d where I want to store data here so how you can exist this part of this node we cannot directly access structure members you need a pointer to this node pointer to this node is new node address of new node and name of this data part so here I am writing arrow data part to suppose user head has entered seven right here you can store 0 and 0 it means null and name but no need to store head because we are going to update both the pointers right so you can leave it like this now it's starting with check work if head is equal to empty it means sorry if head is equal to null it means there is no road is no node in the list right so then have you are going to insert this node in the list see now both head and tail would point to this node because this is the first node this would be the last node oniy right so here what I will write head is equal to tail is equal to new node yes now see both the scale is also pointing to this node and head is also pointing to this node but now you have to insert here also something and here also something now what we have discussed the next pointer of the last node is containing address of the first node right so this pointer would contain this is only the last and first node so here we have to insert 500 address of itself right and here also the previous pointer of first node is containing address of the last node right and this is first and last node so here also you will store 500 now this would be the doubly circular linked list so now how you can exit this part see tail new node and head all the three pointers are pointing to this node so you can access it using any pointer suppose I am writing here head off next equal to head that is also fine if you write tail off next equal to tail that is also fine if you write moon or the next equal to new node that is also fine right and now head set the third thing head of previous this thing is equal to head right so now this is done if there is no node in the list else if we are having some node in the list suppose one node is there and now I want to insert a second node this node I have created a second node and user has entered suppose six here right so now in that case this new node suppose address is 600 so a new node now this new node is having 600 address right so new node is pointing to this node here we are going to run this code again right this one again we are going to create this thing and whatever this will return we are going to store a new node pointer right now I want to store this node in this list now in this case head is not null so now how many pointers you need to update here you need to update I guess five things see this this would contain address of the next node the next pointer means 600 second thing this would contain address of previous node that is 500 third thing now this would contain this would be the last node so this would contain address of the first node that is here also 500 you need to store plus you need to appear decimals because the previous pointer of the first node would contain address of the last node that is here you will store 600 plus fifth thing is now tail would point to this node because this is to win this is now the last node right so now how you will write down that thing see in this case also you need to take care which line you need to write first right see now here I need to store 600 address of the next node right 600 so how you will ex this part tail is pointing to this node tail off next so here I can write tail off next see the obviously hair head is also pointing to this node so you can ask can I can we write head off next no we cannot write head of next because after inserting second node if you we will insert the third node in that case here you need to store address of this node right and how you can access this part because after that tail would be pointing to this node using tail off next we cannot remove this head head will head will always point to the first node so better to use ill know right rather than head we cannot use head tail of next here 600 I want to store from where I can get 600 in new node I have 600 right so now this is pointing to this node this is not pointing to itself now so now this node here we will store address of the previous node right the previous pointer of this node will contain address of the previous node right how you can access this part new node 3 so here I will write new node 3 you because pointer to this node is new node what I want to store address so previous node that is 500 so until we have 500 so I will write here what okay see here also we will not write head because head is also going to containing 500 but we will not write here head because head will also pan head will always contain address of the first movement because but when you will insert third node in that case we need address of the previous node means this node in that case tail would be pointing to this node so we use here a right so here I have now 500 so now we have set 2 links now you need to update 2 links more see this last me this is the last node now so this node would contain address of the the next point of this node would contain address of the first node to make it a circular list right so now how you can access this part here I will write new node next address of the first node we will always find in head pointer so here I will write head in head we have 500 so 500 so now this is this is pointing to this node right plus you need to update this thing also the previous pointer of the first node have you connects is the first node there is always a pointer that is head so here I can write head of dream address of the this this node last node so here what you will write new node right because in you know do we have 600 so here I can write what now it will contain 600 so now this is pointing to this node so I'm making this a bidirectional link right this end this now another thing you need to update now PL will point to this node this would be the last node so in Taylorville store 600 from where I can get the address new node is containing 600 so here so now this is having 600 and and tail is pointing to this node so this is as you can see we have inserted that's not successful now suppose if you want to check out these lines are working properly or not here you can create another node third node suppose user has entered data 1 and this is what the address is 700s and so in new node we have 700 now so and you know this pointing to this node right now I want to insert this node in the list this node in the list right so now if head is equal to null that is not true so we are going to enter into else part now see Elif next in else we have written tale of next means tail of next there is one you do this node that is this one is equal to new node in new node we have 700 that is now this is pointing to this node that is fine new node previous new node previous here I will store tail until we have 600 so 600 so this is the dress so previous node so that is also fine this is pointing to this node third thing new node next new node next this data sorry this part is equal to head in head I have 500 that is 500 this is now pointing to this node right this node for slang head of previous means head is pointing to this node head of previous means you are accessing this part is equal to new node in new node I have 700 so here 700 so this would point to this node so I'm making so I will make the link bidirectional right v if v is equal to new node tail is equal to new node a new node I have 700 so here now tail is moved into this move so now after this you can write down that same while loop while sorry here you can write printf press 1 for continuation and press 0 for exit so here you can write scan a percentage D and the user choice you can take out you know variable you can say choice here you need to initialize the choice is equal to 1 right if user press 1 the data the again node would be created right so now for creation these lines after that these lines should be executed again and again so we will write this code into it while you while the variable is choice and after that you will start while loop and now here you will end this while you write so before closing this while loop you will write what printf press 1 for continuation 0 for exit scanner percentage the address of choice right now if you want to crosscheck that we have created this list or not then see here I am saying the next pointer is containing address of the first node so can we print using this pointer the data of first node right so before closing this create function you can write what printf percentage D and here you can write C a sorry the pointer to this node is now tail is pointing to the last node so here I can write L off next right I will access tail off next so and data again pointer and data so it should print what 7 using this tail and I am printing this first node right as well as you can print using head using the first node can we print to this data so again you can write here head off previous see this previous is containing address of the last node so second thing what you can write here head off please it means 700 means we have reached in this address and again arrow data it means minus 1 it should print minus 1 and it should print 7 so this is how we have created our doubly circular linked list now we will traverse this list means we are going to display the content 7 6 and minus 1 how you will write down that code C so this was the list we have created now I want to define a function that does display how to display the content of this list right so obviously for displaying or for traversing we need a pointer that we can move because head will also head will always point to the first node T will always going to the last node we cannot move these pointers so here we need a third pointer you can say m pointer and initially this temp would point to the first node means in temp we are going to store head right so now this is what a temp pointer in temp we have head that is 500 so temp is pointing to this node to the first node right now you will check if the list is empty or not so here what you can write if head is equal to 0 head is equal to is equal to 0 means you can print list is empty there is no data in the business otherwise in else part what you will write now we will print this head data and move the stem print this head data and we'll move the stem in what till we reach to the last node so what is the termination condition then temp would point to this node it means 10 becomes equal to pay right because tail is containing address of the last node and at some point of time temp will also contain address off this one that is 700 it means we have reached till the last node then we are going to stop right so now in while look what you will write why then not equal to pain in that case we will move and so temp is pointing to this node so first of all what you will print at the data bring their percentage B temp of data and after that we will move this temp right now temporal point to this node that is 600 we will store in temp so in temp we will store temp is equal to temp off next temp off next now see the working of this while loop and starting m+ 500 temp is not equal to pl clearly 700 condition is true so we will enter into this loop end of template a temp of data is 7 temp is equal to temp next now see in temp next we have amp of next 600 so in temp we will store 600 so now this is pointing to this node right now again check temp not equal to L times 600 till is 700 yes condition is true we will enter into this loop again again printf temp of data that is 6 now temp is equal to temp next in temp next we have 700 so here number we will store 700 so now temp is pointing to this node now take the conditioned temp not equal to take MP 700 tail is also 700 means we have raised to the last node right but see condition is not prove enough so we will not enter into this loop control will not go into this loop control will go out from this while loop here but now the output is only 7 and 6 we need to print this data also right so here after this while loop you will write one more line that is percentage D and have you gonna print minus 1 see temp is pointing to this node so temp of data here you can write one more line after that closes the cells else statement and after that this function display function so this is how we are going to display the data but if you are if you don't want to print the last this this data separately then what you can do rather than this while look you can do use do I look right here you can use do because these statements should be executed first in do I look and after that condition would be checked right after that you can write this while condition that thing do by loop also we have discussed when you that implement the circular link list so how to write down do I look that also you can check out in the side button for that when you fine see here in the termination condition if you don't find this thing then you can also write a second termination condition see temp off next temp off next when type of next becomes what the stale of next tale of next as always containing address of the first node right so it means we have race to the last node so while camp off next not equal to Palos next till then we are going to move otherwise we will stop right this condition you can also right so this is the implementation of a doubly circular linked list fine in next video we will see the insertion operation in doubly circular linked list fine inserts not beginning at end and at any specified position so else in the next video till then bye thank you