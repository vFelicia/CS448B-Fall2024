topic is shortest job first or you can say shortest job next so as a name suggests what is the funda in the shin dealing algorithm of all the available processes or you can say out of all the processes who are in waiting state it selects a process having shortest burst time to execute next and towards enough so this type of scheduling algorithm is there one is preemptive preemptive and next one is non preemptive difference between these two is see in non preemptive once a one CPU has been allocated to a process then the that process cannot be forcefully removed from the CPU till the termination of that process fine and in pre M you we can remove that process from CPU based on some time quantum or priority basis okay that is preemptive you can forcefully remove that process from CPU so see when you are asked a question then they specify that you have to apply a stupid preemption okay and if simply they write solve this problem with shortest job first algorithm then by default you have to use what which mode that is non preemptive mode fine and the preemptive mode of this algorithm is also known as shortest remaining time first SRT F or you can say short test remaining time next fine if in a numerical or in question you are given that solve this problem with the shortest remaining time first solution willing algorithm then by default shortest remaining time first means you have to apply what technique preemptive this one is preemptive so you have to apply preemption method fine and if nothing is given preempting non preemptive and sjf is given then by default it is known as non preemptive okay now in this video we'll discuss the non preemptive version of this algorithm okay see and some drawbacks are also there of this algorithm but I will discuss the tropics in next to be after discussing this algorithm also SRT f also so in next video I'll discuss SRT F and both you know the advantages and drawbacks of both the versions preemptive and preemptive and non preemptive okay so let us take one example if two or more processes are given with same burst time then what will you do see the funda is you have to choose a process with minimum words time but if two processes are having same burst time 1 and 1 you can see then then you will apply firstcome firstserve to break the time so first of all will draw what Gantt chart and here we'll start the cpu time from 0 see this one is this this is very important to solve this numerical if you draw you have drawn this Gantt chart properly and correctly then almost 90 percent of your work has been done fine see now time is 0 now at checkout at 0 at time 0 is there any process which has come in ready state out of these processes yes we have this process because arrival time of this process is 0 so at time 0 we have only one process that is p4 so you cannot say that directly you jump to this burst time and check out the burst time serum a shortest burst time is 1 and 1 so if both are same if two processes are having same first time then use FCFS FCFS means p 1 so you can write P 1 no see that is not right because you cannot allocate CPU to either P 1 or P 3 why so we can say p arrival time of piven is to arrival time of P 3 P 3 is 4 so these two processes has not come yet in ready state at time 0 out of all the available processes fine now at time 0 which process is available you have to check first of all check the arrival time only one process that is P 4 so you have no other choice you have to allocate the CPU to this process p4 although the burst time of P for l6 which is the largest burst time out of these processes but you have no other choice because at time 0 only p4 is there in ready state no other process has come so you have to allocate CPU to p4 and till burst time of this process is 6 so this process would require 6 unit of time for completing its execution so here you will write 6 as it is non preemptive mode we are discussing the non preemptive mode so in between the execution you cannot remove this process from CPU because this is non preemptive here the assumption is no process would require any i/o device only CPU bound processes we have taken now at time 6 you have to check out which process has come now this has come to at time 2 1 4 n now this one is done and T Phi so all the processes has been arrived so you can say in our ready queue now we have p1 also p2 also p3 also on p5 also all the three processes and ready queue now you have to apply the funda of estrella now you how to select a process having shot test burst time because we have all the processes out of all the available processes you have to pick fine now see two processes are having same both time because one is the minimum one so p1 is also having one and p3 is also having one now there is a tie now to break the tie you here you have to apply what FCFS fine first come first so now check out the arrival time of these two processes one and one having burst time now which comes first p1 has come at time 2 and P 3 came at time 4 so according to firstcome firstserve CPU would be allocated to p1 because 2 is less than this for so p1 has come before d3 so PCP would be located to p1 ok and now tell you what time check out the first time that is one so it required only one unit of time six to seven now p1 has been terminated now in ready queue how many processes are there three processes P 2 P 3 and P 5 now again apply the same fun down pick the process having minimum birth time which one is having minimum birth time this one one out of P 2 P 3 and P 5 out of these remaining three one is minimum so we'll pick P 3 and 7 to 8 now Pichu is also done now out of remaining P 2 and P 5 5 is smaller than sorry 3 3 is smaller than 5 so we'll pick what P 5 and burst time is 3 now you'll write here what 11 now the remaining is only P 2 and this would be 16 okay now see you see the Gantt chart is there any time when the problem when the CPU was idle no from 0 to this 16 every every time the CPU was busy doing some processing fine so in this case if CPU is not idle from starting to ending this total 16 should be equal to this total of this burst time 6 plus 3 9 10 15 and 16 so this total is also 16 and this is also 16 then you can say you can verify it by this also but in the last numerical we have discussed that at one particular time CPU is idle for one one unit of time so here this and this would not be same in that case you have to take care of this thing also so if CPU was not idle from the starting point to the end point then you can say this they whatever you will get at this point it lasts then that this would be equal to the total of the first time given first time okay now we are we will calculate all the average waiting time average the turnaround time response time and all okay now first of all completion time now completion completion time is what at the time where when the process has been completed now the completion time of p1 is what 637 because that 71 has been completed and terminated for p2 its 1643 it's 8 for P 4 6 4 P 5 11 C do not use do not write at this time for p5 because at this time CPU has been allocated to p5 and at 11 in this p5 has been terminated so we are taking the completion time of that process 11 okay now turn on turnaround time now what is the turnaround time completion time arrival time that is known as turnaround time or you can say waiting time plus burst time now we have both completion time in arrival time 75 75 16 115 8 4 4 6 0 that is 6 a 1 2 that is 9 this is the turnaround time now find out the waiting time waiting time would be what see turnaround time you can say waiting time plus burst then waiting time would be turnaround time both time turnaround time this one this one is burst time 5 1 for 15 5 & 4 1 3 6 6 0 9 3 6 ok now next is response time now response time is what see the time address CPU has been allocated to the process first time after that I will of that process okay now check out response time for p1 for p1 at what time CPU has been allocated to p1 first time first time at time 6 and then what time the p1 has come in ready state check out the arrival time for P 1 that is 2 so response time would be 6 minus 2 that is 4 4 p2 check out at 11 CPU was allocated to this p2 first time 11 and the arrival time of p2 is 1 so response time is so the process has been waiting because at 1 the process has come to ready state but CPU has been allocated to do this process at time 11 so during this time the process was waiting that is 11 minus 1 that is 10 for p3 7 minus 4 that is 3 for p4 0 minus 0 that is 0 and 4 P 5 8 minus 2 that is 6 in previous video I have also told you the rule is if the algorithm is non preemptive then the waiting time and response time would be same here you can check for 10 3 0 6 for 10 3 0 6 ok now I hope you can easily calculate the average waiting time and average turnaround time so average turnaround time would be 7 point 8 and average waiting time would be 4 point 6 ok so that was the nonpreemptive origin of shortest job first next video we'll discuss the preemptive version of shortest job first as well as the drawbacks and advantages of this algorithm ok till then bye bye take