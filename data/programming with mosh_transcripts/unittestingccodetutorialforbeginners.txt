00:00 - [Music]
00:01 - so what is automated testing is it a
00:04 - replacement for manual testing do I
00:06 - really need it how should I do it should
00:08 - I write my tests first which we call
00:11 - test-driven development or TDD or should
00:14 - I write the application code first
00:16 - maash I don't know what to test these
00:19 - are frequently asked questions about
00:21 - automated testing and in this course I'm
00:24 - gonna answer all these questions one by
00:27 - one so let's start with the first
00:29 - question what is automated testing
00:31 - automated testing is the practice of
00:34 - writing code to test our code and then
00:37 - run those tests in an automated fashion
00:40 - so with automated testing our source
00:43 - code consists of application code which
00:46 - we also call production code and test
00:49 - code here's an example imagine you have
00:52 - this function somewhere in your code
00:54 - it's a basic calculate function that
00:57 - takes an input and depending on some
01:00 - conditions
01:00 - it returns different values if you want
01:04 - to test this function manually you have
01:06 - to launch your application in the
01:07 - browser perhaps you have to login or
01:10 - maybe you have to do a few clicks here
01:12 - and there to get to a page where this
01:15 - function is used then you'll have to
01:17 - fill out a form submit it and see the
01:20 - result of this function on the screen
01:22 - and then you have to repeat all these
01:24 - steps each time using different values
01:27 - in your form as you can see this is very
01:30 - time consuming this workflow to test
01:32 - this function may take several minutes
01:35 - every time now to make matters worse
01:37 - this is not the only function in your
01:40 - application in a real application you
01:42 - have tens or hundreds of functions like
01:45 - this as your application grows in size
01:48 - and complexity the time required to
01:51 - manually test all the different bits and
01:53 - pieces increases exponentially so that's
01:57 - why we use automated testing with
01:59 - automated testing you write code and
02:02 - directly call this function with
02:04 - different inputs and verify that this
02:06 - function returns the right output now
02:10 - you can rerun these tests every time you
02:12 - change your
02:13 - every time you commit your code to a
02:15 - repository and before deploying your
02:17 - application with this approach you can
02:20 - test all the execution paths in this
02:22 - function in less than a second you can
02:25 - write several hundreds or thousands of
02:27 - automated tests for various parts of
02:29 - your application and run them all in
02:31 - just a few seconds but there are more
02:34 - benefits to automated testing and that's
02:36 - the topic for the next lecture
02:43 - recently a student of mine asked me
02:46 - maash why on earth should be write code
02:50 - to test our code when we can just run
02:52 - the application and see the result well
02:55 - in the last lecture you'll learn that
02:57 - with automated tests you can test your
02:59 - application code on a frequent basis and
03:02 - in less time but this is not the only
03:05 - benefit of automated testing the most
03:07 - important benefit is that you can catch
03:10 - the bugs before deploying your
03:12 - application and this is extremely
03:15 - important because it allows you to
03:17 - deploy your application with more
03:18 - confidence have you been in a situation
03:21 - where you finish all the work deploy
03:24 - your application left the office
03:26 - thinking everything is working and then
03:28 - got a call from your boss or an end user
03:31 - telling you that one of the major
03:33 - functions of the application is not
03:35 - working then you had to go back to the
03:37 - office and you thought that was a quick
03:39 - fix but you ended up staying there until
03:41 - midnight that's why you should write
03:44 - tests to reduce the number of bugs that
03:47 - will go into production now note that
03:50 - I'm not saying that with automated tests
03:52 - you're gonna release bug free software
03:55 - that's not true but you can certainly
03:57 - reduce the number of bugs and improve
04:00 - the quality of your software another
04:03 - benefit of automated tests is that they
04:05 - allow you to refactor your code with
04:07 - confidence
04:08 - refactoring means changing the structure
04:11 - of your code without changing its
04:13 - behavior if you extract a few lines of a
04:16 - method into a separate private method
04:19 - that's refactoring if you rename a
04:21 - method that's refactoring too you're
04:23 - changing the structure of your code to
04:26 - make it cleaner and more maintainable
04:27 - but you're not changing the
04:29 - functionality when you don't have
04:31 - automated tests every time you refactor
04:34 - your code you have to manually test
04:36 - every part of the application that could
04:38 - be affected by your refactoring and this
04:41 - is very painful because first of all
04:43 - it's time consuming and second as your
04:46 - application grows you may forget about
04:48 - the parts that need to be tested with
04:51 - automated tests
04:53 - you refactor your code you run your
04:55 - tests and make sure you didn't break
04:57 - anything that used to previously work
04:59 - and finally another benefit of writing
05:02 - tests is that it helps you focus more on
05:05 - the quality of the methods you're
05:07 - writing you make sure that every method
05:09 - works with different inputs under
05:12 - varying circumstances next I'm going to
05:15 - talk about different types of tests in
05:23 - automated testing we have three types of
05:26 - tests unit tests integration tests and
05:29 - end-to-end tests a unit test is what I
05:32 - showed you earlier in this section you
05:35 - test a unit of the application without
05:37 - its external dependencies such as files
05:41 - databases message queues web services
05:44 - and so on now note this key word here
05:47 - external dependencies this is really
05:50 - important as you will find out shortly
05:52 - so these unit tests exercise your code
05:56 - without any external dependencies they
05:59 - are cheap to write and they execute fast
06:02 - so you can run hundreds of them in just
06:04 - a few seconds and this way you can
06:07 - verify that each building block in your
06:09 - application is working as expected
06:11 - however since you are not testing these
06:14 - classes or components with their
06:16 - external dependencies you can't get a
06:19 - lot of confidence in the reliability of
06:21 - your application so that's when
06:24 - integration tests come to the rescue an
06:27 - integration test tests a class or a
06:30 - component with its external dependencies
06:33 - so it tests the integration of your
06:36 - application code with these concrete
06:39 - dependencies like files databases and so
06:41 - on again note that I'm emphasizing the
06:44 - word external here these tests take
06:48 - longer to execute because they often
06:50 - involve reading or writing to a database
06:53 - but they give you more confidence in the
06:56 - health of your application now
06:58 - traditionally an integration test is
07:01 - defined as a test that takes a few units
07:04 - or classes
07:06 - and test their behavior as a whole so
07:09 - based on this definition if you test two
07:12 - classes together
07:13 - some people believe you're writing an
07:15 - integration test and not a unit test
07:17 - even if none of these classes talk to an
07:20 - external resource like a database
07:23 - chances are you've heard this definition
07:25 - before now I tell you what this
07:27 - definition is a great recipe for writing
07:29 - fragile tests that are coupled to your
07:32 - implementation detail so as you change
07:36 - the implementation of your classes these
07:38 - tests are gonna break and you will end
07:41 - up wasting a lot of time fixing them not
07:44 - only won't they give you any values but
07:46 - they actually slow you down I'm going to
07:48 - show you an example of this later in the
07:50 - course when I talk about fakes and mocks
07:53 - if you have done unit testing before and
07:56 - failed chances are you follow this
07:58 - definition so once again a unit test
08:01 - tests a class or multiple classes
08:04 - without their external dependencies they
08:08 - test a unit of work an integration test
08:11 - tests a class or multiple classes with
08:14 - their external dependencies we also have
08:18 - another type of test called end to end
08:20 - test that drives an application through
08:23 - its user interface there are specific
08:26 - tools built for creating end-to-end
08:28 - tests one popular tool that you might
08:31 - have heard of is selenium which allows
08:34 - us to record the interaction of a user
08:36 - with our application and then play back
08:38 - and check if the application is
08:40 - returning the right result or not these
08:43 - tests give you the greatest amount of
08:45 - confidence about the health of your
08:47 - application but they have two big
08:49 - problems the first problem is that
08:52 - they're very slow because they require
08:54 - launching the application and testing it
08:56 - through the UI so every test is going to
08:59 - launch the application potentially log
09:01 - in navigate to an internal page submit a
09:04 - form and inspect the results very slow
09:07 - the second problem is that there are
09:09 - very brittle because a small enhancement
09:12 - to the application or a small change in
09:15 - the user interface can easily break
09:17 - these tests
09:18 - [Music]
09:24 - so now you know about the different
09:26 - kinds of automated tasks unit tests
09:28 - integration tests and end-to-end tests
09:31 - but what kind of tests should you write
09:33 - in your application for hell all of them
09:36 - this is what we call the test pyramid
09:39 - this pyramid argues that most of your
09:42 - tests should be in the category of unit
09:45 - tests because these tests are easy to
09:47 - write and they execute quickly but since
09:50 - they don't give you much confidence
09:52 - about the health of your application you
09:54 - should have a bunch of integration tests
09:56 - that test the integration of your
09:58 - application code with its external
10:00 - dependencies these tests provide many
10:04 - advantages of end-to-end tests but
10:06 - without the complexities of dealing with
10:09 - the user interface and finally you
10:11 - should write very few end-to-end tests
10:13 - for the key functions of the application
10:16 - but you should not test the edge cases
10:18 - with these end-to-end tests you only
10:21 - test the happy path and leave the edge
10:23 - cases your unit tests now
10:26 - this pyramid is just a guideline it's
10:27 - not a hard and fast rule that you need
10:29 - to follow in every application the
10:32 - actual ratio between your unit
10:34 - integration and end-to-end tests really
10:36 - depends on your project unit tests are
10:39 - great for quickly testing the logic like
10:42 - conditional statements and loops if you
10:45 - have methods with complex logic and
10:47 - calculation you should test them with
10:49 - your unit tests earlier in the section I
10:52 - showed you an example of a calculate
10:54 - function unit tests are ideal for
10:57 - testing these functions because you can
11:00 - quickly test all the execution paths of
11:02 - these functions in less than a second
11:04 - manually testing this functions through
11:06 - the user interface takes significant
11:09 - amount of time and is prone to errors
11:11 - however not every application has
11:14 - complex logic and functions like our
11:17 - calculate function you might have an
11:19 - application that simply reads some data
11:21 - from or writes it to a database in that
11:24 - case you may need more integration tests
11:27 - than unit tests so in summary this test
11:30 - pyramid gives you three recommendations
11:33 - first is to favour unit tests over a Qi
11:37 - or end-to-end tests because these unit
11:40 - tests are the fastest to run and
11:42 - cheapest to write and they're very
11:44 - precise so they can pinpoint exactly
11:47 - where something fails they give you
11:50 - rapid feedback second is to cover unit
11:54 - test gaps with integration tests and
11:57 - finally use end-to-end tests sparingly
12:00 - only for the key functions of your
12:02 - application the right balance is
12:05 - different for each project on each team
12:07 - at the end of the day you need to use
12:09 - your own judgment to determine what kind
12:11 - of test you need to write for different
12:13 - parts of your application
12:20 - - right unit and integration tests you
12:23 - need a testing framework there are
12:25 - several testing frameworks out there but
12:28 - the most popular ones are an unit which
12:30 - is one of the earliest frameworks out
12:32 - there we've got m/s test which is
12:35 - Microsoft's testing framework built into
12:38 - Visual Studio and X unit which has
12:41 - gained more popularity over the past
12:44 - couple of years
12:45 - all these frameworks give you a utility
12:48 - library to write your tests and a test
12:51 - runner which runs your tests and gives
12:53 - you a report of passing and failing
12:55 - tests which framework is better it
12:58 - depends who you ask and what their
13:00 - definition of better is different people
13:02 - love different tools so here's my
13:04 - suggestion don't get hung up on the
13:06 - tooling in this course our focus is on
13:09 - the fundamentals of writing quality
13:11 - tests that give you value that's what
13:15 - matters you can always use a different
13:16 - framework as you move from one project
13:19 - or team to another in this course we're
13:22 - gonna start with MS test because that's
13:24 - built into Visual Studio and doesn't
13:27 - require any additional steps but shortly
13:30 - after I'm gonna show you how to install
13:32 - and unit and run annually tests in
13:35 - Visual Studio you may use either of
13:37 - these frameworks as purely your personal
13:39 - decision
13:40 - but for the majority of this course I'll
13:42 - be using an unit because it has a longer
13:44 - history than MS tests and I personally
13:47 - find it a more elegant testing framework
13:50 - now an optional tool that I highly
13:53 - recommend is resharper because it has a
13:56 - faster and more powerful test runner
13:58 - than the one built into Visual Studio
14:01 - just to let you know
14:02 - resharper is a commercial product and
14:04 - I'm not their affiliate you may decide
14:07 - to buy a license or not that's entirely
14:09 - your choice what I want to emphasize is
14:11 - that you do not need resharper to write
14:14 - or run tests but I use resharper because
14:18 - it's a huge productivity booster another
14:22 - optional tool is writer if you like
14:25 - Visual Studio plus resharper but you
14:27 - think Visual Studio is too slow for you
14:29 - then
14:30 - highly recommend you to try writer
14:32 - writer is basically a cross-platform IDE
14:35 - built by JetBrains the same company that
14:39 - has made resharper so you have a super
14:42 - fast IDE plus resharper with the exact
14:45 - same shortcuts that you use in Visual
14:47 - Studio in this course I'm gonna record
14:49 - the first few videos with Visual Studio
14:51 - because that's the default IDE for
14:54 - maturity of you but later I'm gonna
14:56 - switch to writer because that's a lot
14:58 - faster you can use Visual Studio with or
15:01 - without resharper that's perfectly fine
15:03 - your focus should be on the fundamentals
15:06 - of writing good tests and not the Thule
15:14 - in the next lecture you're going to
15:16 - write your first unit test so download
15:19 - the zip file I have attached to this
15:20 - lecture this is a visual studio solution
15:22 - that includes some code you're going to
15:25 - test throughout this course
15:31 - hi guys maash here I hope you're having
15:34 - a fantastic day or night wherever you
15:37 - are in the world this tutorial you've
15:39 - been watching is actually part of my
15:41 - complete unit testing course for c-sharp
15:44 - developers and what you see here on
15:46 - YouTube is actually only the first
15:48 - section of this course the complete
15:51 - course includes more than five hours of
15:53 - high quality content with plenty of
15:55 - exercises and challenges that will help
15:58 - you really master unit testing in case
16:01 - you're interested to enroll in the full
16:03 - course I've put the link for you in the
16:05 - video description and if not that's
16:07 - perfectly fine continue watching as the
16:09 - next section is coming up
16:16 - all right in the slingshot you're gonna
16:17 - write your first unit test so here we
16:21 - have this project called test ninja that
16:23 - I'm gonna use throughout this course I
16:25 - give you the link to this project in the
16:28 - last lecture but if you miss that you
16:30 - can see it attached to this lecture so
16:33 - here we have this folder fundamentals
16:35 - let's take a look at this reservation
16:38 - class so imagine you're building an
16:40 - application for reserving a table at a
16:43 - restaurant our reservation class has
16:46 - currently one property which specifies
16:50 - the user who made this reservation now
16:52 - in a real-world application this class
16:54 - can have many other properties but we
16:56 - don't want to get distracted with too
16:58 - much detail this is the method we want
17:00 - to test can be cancelled by a given user
17:04 - so here I have implemented a simple
17:07 - business rule if the user is admin or
17:10 - the user who made this reservation they
17:14 - can cancel this reservation otherwise
17:16 - they can't cancel this reservation ok
17:19 - and if you scroll down you can see our
17:23 - user class very simple with one property
17:26 - is admin so let's go ahead and write the
17:30 - first unit test for this method here in
17:34 - the solution Explorer I'm gonna add a
17:37 - new project to the solution so add new
17:42 - project under installed visual c-sharp
17:47 - test you should see this template unit
17:51 - test project if you don't see it here
17:53 - chances are you have not installed
17:55 - Visual Studio property so go ahead and
17:58 - download the latest version of Visual
18:00 - Studio currently I'm using Visual Studio
18:02 - 2017 Community Edition so here we select
18:06 - unit test project and we give it a name
18:10 - so the name of our main project is test
18:12 - ninja and I'm gonna call this project
18:15 - test ninja dot unit tests this is the
18:20 - convention we follow to organize our
18:23 - test projects we want to separate the
18:25 - unit tests and integration tests because
18:28 - unit tests run
18:30 - quickly whereas integration tests take
18:32 - more time we want to separate them so we
18:35 - can run unit tests more frequently and
18:38 - integration tests before committing our
18:41 - code to a repository okay let's go ahead
18:47 - so Visual Studio creates this new
18:50 - project and you can see here we have a
18:52 - file unit test one is a simple C sharp
18:57 - class that has the test class attribute
18:59 - and it has one method called test method
19:02 - one with this attribute test method
19:05 - these two attributes you see here belong
19:08 - to m/s test framework so the test Runner
19:10 - we have in Visual Studio looks at all
19:13 - the classes decorated with the test
19:16 - class attribute then it looks at all the
19:19 - methods in this class decorated with the
19:22 - test method attribute and it will run
19:24 - them so the first thing I want to do
19:27 - here is change the name of this class so
19:31 - press ctrl R and then R again now you
19:35 - can rename these I'm gonna call this
19:37 - reservation tests because we are testing
19:41 - the reservation class so the convention
19:44 - we follow is the name of the class +
19:47 - tests enter now similarly I'm gonna
19:54 - rename this method once again ctrl R & R
19:56 - the method I wanna test is can be
20:01 - canceled by now here we add an underline
20:07 - we specify a scenario on the line again
20:11 - and expected behavior what is this let's
20:17 - go back to our reservation class when
20:21 - write two unit tests for this method we
20:23 - want to test all the scenarios what
20:26 - scenarios do we have here we have three
20:28 - scenarios one scenario is when the user
20:31 - is an admin the other scenario is when
20:35 - the user is the same person who made
20:38 - this reservation and the third scenario
20:40 - is when someone else tries to cancel
20:44 - this reservation so here we have three
20:46 - scenarios or three execution paths so
20:50 - there are three ways to get out of this
20:52 - method that's why we call this three
20:55 - execution paths okay so back to our unit
21:01 - test class the first scenario we want to
21:03 - test is user is admin now what is the
21:10 - expected behavior if the user is admin
21:12 - this method should return true
21:15 - so returns true this is the convention
21:20 - we use to name and organize our test
21:23 - methods every test method has three
21:26 - parts the first part specifies the name
21:29 - of the method under test the second part
21:32 - is the scenario we're testing and the
21:34 - third part is the expected behavior now
21:38 - inside every test method we have three
21:41 - parts
21:42 - a range act and assert this convention
21:49 - is called triple-a or arranged act and
21:53 - assert the arranged part is where we
21:55 - initialize our objects we prepared the
21:59 - object we want to test in this case we
22:01 - want to create an instance of the
22:03 - reservation class so we create a
22:07 - reservation object new reservation now
22:14 - here the reservation class is not
22:16 - recognized so you need to press ctrl +
22:19 - period and in this context menu select
22:24 - add reference to test ninja okay so we
22:30 - have a reservation object the act part
22:34 - is where we act on this object and that
22:37 - basically means we're gonna call a
22:39 - method that's the method we're going to
22:41 - test in this case reservation dot can be
22:46 - cancelled by now I want to give it an
22:49 - argument in this case we want to give it
22:51 - a user that is an admin user so here I
22:55 - create a user object and set is admin to
23:00 - true so this is the act part now we want
23:06 - to get the result and verify that it's
23:08 - correct so I'm gonna store the result in
23:11 - a variable called result and in the
23:16 - assert part we verify that result is
23:19 - correct in this case result should be
23:21 - true so here I'm gonna use one of the
23:24 - helper classes in Emma's test framework
23:26 - that is called assert this class has a
23:31 - bunch of static methods that we use to
23:33 - make an assertion for example if you
23:36 - want to compare two objects we can use
23:37 - are equal we also have other methods
23:42 - here like is false is instance of type
23:45 - is not instance of type and so on so
23:48 - here we want to assert that this result
23:51 - is true so we call assert dot is true
23:56 - and pass result so this is how we write
24:01 - a unit test now to run this test we go
24:05 - on the top from the test menu go to run
24:09 - and select all tests this is what I
24:13 - don't like about Visual Studio because
24:16 - here we don't have the ability to run
24:18 - only a particular test method like this
24:21 - test method we wrote in this lecture we
24:24 - can only run all the tests in this
24:27 - project and that's why I like resharper
24:29 - because with resharper I can run only
24:32 - this test or I can run all the tests in
24:35 - this class so it's more flexible I'm
24:38 - going to show you that later in this
24:39 - section so let's go on the top from the
24:43 - test menu run all tests and note this
24:47 - shortcut remember this so you can
24:49 - quickly run all your tests
24:52 - they should open this text explorer
24:55 - window if you don't see that you can
24:58 - find it on the top under test windows
25:03 - test explorer okay
25:05 - so you can see we have a passing test we
25:10 - have a green mark you can see the name
25:12 - of our test method and the time it took
25:14 - to run this test in a real world
25:17 - application you're gonna have hundreds
25:19 - or thousands of unit tests so when you
25:21 - run your tests
25:22 - this window is going to be populated
25:25 - with all the tests in your application
25:27 - now let me show you an example of a
25:29 - failing test so I'm going to go back to
25:31 - the reservation class and create a bug
25:34 - in our code so here I'm going to return
25:36 - false let's say the developer who wrote
25:40 - this code made this mistake
25:41 - as I told you before with unit tests we
25:45 - can catch bugs before deploying our
25:48 - application so when we create a unit
25:50 - test class and verify the expected
25:55 - behavior of a method in this case you're
25:58 - verifying that this method is returning
26:00 - true with this unit test we can catch
26:04 - bugs earlier and the software
26:06 - development lifecycle
26:07 - so back to our test Explorer window I'm
26:10 - going to run all the tests again
26:15 - this time our test failed so you can see
26:18 - the benefit of unit tests in action now
26:21 - here is an exercise for you as I told
26:24 - you before this method has three
26:28 - execution paths or three scenarios I
26:31 - want you to use what you learn in this
26:33 - lecture and write the other 2 unit tests
26:36 - for this method in the next lecturer
26:38 - you're going to see my solution
26:45 - in the last lecture we renamed this
26:47 - class to reservation tests but
26:49 - apparently the rename refactoring
26:51 - feature in Visual Studio didn't work
26:53 - properly because the name of the file is
26:56 - still unit test 1 so I'm gonna rename
26:59 - this to reservation tests dot CS with
27:05 - this convention you can easily find all
27:07 - the tests for a given class ok
27:12 - beautiful now that's right the second
27:16 - unit test so I'm gonna write a public
27:23 - void method and by the way all your test
27:26 - methods should be public void so here
27:30 - we're gonna use our convention to call
27:31 - this method the first part is the method
27:34 - on the test that is can be canceled by
27:38 - the second part is the scenario so let's
27:43 - say we want to test the scenario where
27:45 - the same user who made the reservation
27:47 - wants to cancel this reservation so same
27:51 - user canceling the reservation now the
27:58 - third part is the expected behavior what
28:01 - do we expect this method to return you
28:04 - should return true ok now inside this
28:13 - method we should have three parts
28:15 - arrange act and assert in the last
28:18 - lecture I added comments to separate the
28:21 - arranged act and assert parts but in a
28:24 - real world scenario you don't
28:25 - necessarily have to do this if your test
28:27 - method is short and clean so in the
28:30 - arrange part I'm going to create a new
28:32 - reservation object so reservation it's a
28:38 - new reservation in the act
28:42 - I'm gonna call reservation can be
28:46 - canceled by now here I want to simulate
28:48 - a scenario where the same user is
28:51 - canceling this reservation so I'm gonna
28:55 - create a user object here
28:59 - you
29:01 - and first of all set the made by
29:06 - property to this user so this user
29:09 - created this reservation before now I
29:12 - want to pass the same user object as an
29:15 - argument to this method user now we get
29:20 - the result and store it I finally make
29:24 - an assertion so we assert that result is
29:29 - true so now with these vertical spaces I
29:35 - have added in the code you can see the
29:37 - arrange the act and assert parts back in
29:41 - our test Explorer window
29:43 - let's run all the tests so we have one
29:48 - failing test and this is because in the
29:50 - last lecture I created a bug in our code
29:53 - so let me change this here we return
29:57 - true now back to our test class this new
30:02 - method I created here is not picked up
30:04 - by test Explorer we don't see that here
30:06 - why because we forgot to decorate it
30:12 - with the test method attribute so that's
30:15 - why you should decorate every test
30:17 - method with this attribute so it can be
30:19 - picked up by the test runner now save
30:22 - back in test Explorer run all now we
30:28 - have to passing tests beautiful now
30:31 - let's write the last test so I'm gonna
30:37 - start with test method and public void
30:42 - can be canceled by the third scenario is
30:49 - a user trying to cancel someone else's
30:52 - reservation so another user canceling
30:58 - reservation what is the expected
31:01 - behavior this method should return false
31:05 - so return false
31:13 - once again in the orange part I'm going
31:15 - to create a reservation object new your
31:19 - reservation and the act part we call can
31:24 - be cancelled by now here we want to deal
31:27 - with two different user objects so here
31:30 - I can pass a user object and when
31:35 - initializing the reservation I can set
31:37 - made by two different user object and
31:42 - finally we need to store the result here
31:46 - and assert that result is false so is
31:52 - false result now let's run all the tests
32:00 - so we have three passing tests beautiful
32:09 - so I have renamed this test method to
32:12 - make them more consistent and easier to
32:14 - read so we have three scenarios admin
32:18 - canceling same user canceling and
32:21 - another user canceling one thing you can
32:24 - see about these tests is that they act
32:27 - as some kind of documentation about our
32:30 - source code this is another benefit of
32:33 - writing tests imagine you join a new
32:35 - team they give you a new project and
32:37 - your task is to make some modifications
32:39 - to a class if that class is properly
32:42 - supported by a bunch of JUnit tests you
32:45 - can easily figure out what the
32:47 - responsibility of that class is now let
32:50 - me show you another benefit of writing
32:51 - tests earlier in this section I told you
32:54 - that once you have tests you can
32:56 - refactor your code with confidence so
32:59 - back in our reservation class I don't
33:03 - like the way this method is implemented
33:04 - it looks very amateurish so I'm gonna
33:08 - refactor it and then run all my tests
33:10 - and see if I've broken anything or not
33:13 - so the first change I wanna make here is
33:15 - instead of having two if statements I'm
33:18 - gonna have one if statement and use the
33:22 - logical or operator so if user is admin
33:26 - or made by equals user we're gonna
33:31 - return true otherwise we're gonna return
33:33 - false now back in test Explorer run all
33:39 - the tests so my tests are verifying that
33:44 - our application is still working I have
33:46 - not broken anything I can take this to
33:49 - the next level so instead of having this
33:53 - if statement here and then return false
33:56 - I'm simply gonna return the result of
34:01 - this expression now we have only one
34:04 - line of code here once again we run all
34:08 - the tests all the tests are passing
34:15 - our code is much cleaner and you can see
34:18 - another benefit of writing tests
34:25 - so far you have seen Emma's test in
34:28 - action in this lecture I'm going to show
34:30 - you how to use an unit which is my
34:32 - preferred testing framework so an unit
34:36 - is not part of Visual Studio and if you
34:38 - want to use it you need to install a
34:40 - couple of NuGet packages so open a
34:43 - package manager console make sure to
34:47 - select test ninja that unit tests and
34:50 - the project drop down list now we need
34:53 - to install a couple of packages so
34:56 - install - package
34:59 - the first one is any unit and make sure
35:02 - to set the version to the same version
35:04 - that I'm gonna use in this video so you
35:06 - will have the same experience so -
35:09 - version three point eight point one
35:15 - beautiful now the second package install
35:21 - package and unit three test adapter we
35:28 - need this package to run and unit tests
35:30 - inside visual studio because by default
35:33 - the test runner that is built into
35:35 - Visual Studio only recognizes MS tests
35:39 - so set the version here as well this one
35:43 - is three point eight point zero so it's
35:46 - not exactly the same version as any unit
35:48 - because these two packages are developed
35:50 - independently but these two versions are
35:53 - compatible okay beautiful now with n
35:59 - unit we have different attributes so
36:02 - instead of test class we use test
36:06 - fixture now we need to import this type
36:10 - so press ctrl + period and select the
36:14 - first item using n unit dot framework
36:18 - okay and instead of test method we have
36:23 - test
36:27 - like this and finally we need to modify
36:33 - how we make assertions so here we have a
36:36 - compilation error because Visual Studio
36:39 - doesn't know whether we're referring to
36:41 - the assert class in any unit framework
36:44 - or MS test so I'm going to go on the top
36:47 - and remove this using statement for
36:52 - importing Microsoft unit testing
36:54 - framework so delete the compilation is
36:58 - gone so you can see this assert class
37:00 - has the same API as the assert class in
37:03 - MS test but here we have a different way
37:06 - of writing assertions which is more
37:09 - readable so another way to write the
37:13 - same assertion is like this assert that
37:18 - result is true it reads like plain
37:23 - English also another way is to write
37:26 - assert that result equals true so we can
37:33 - add a boolean expression here which I
37:36 - approach you choose is purely your
37:37 - personal preference there is no
37:39 - technical differences between these
37:41 - three ways of making assertions so in
37:44 - this lecture I'm gonna use the second
37:46 - for delete and delete all right now
37:50 - let's run these tests so once again on
37:52 - the top test run all tests
38:01 - so all tests are passing beautiful so
38:04 - this is how you use any unit inside
38:07 - Visual Studio now if you use resharper
38:10 - you don't need to install and unit test
38:12 - adapter because the test runner that
38:15 - comes with resharper automatically picks
38:17 - and unit tests the same is true if you
38:20 - use the writer ID
38:26 - when you get started with automatic
38:29 - testing a word that you hear often is
38:31 - test-driven development or TDD
38:34 - test-driven development or TDD also
38:37 - called test first is an approach to
38:39 - build software with TDD you write your
38:42 - tests before writing the application or
38:46 - production code the first time I heard
38:48 - this I asked how on earth is that even
38:51 - possible how can we test the code that
38:53 - we haven't written chances are have the
38:56 - same question so let's see how you start
39:00 - by writing a failing test this test
39:03 - should fail because you don't have any
39:05 - application code that would make it pass
39:08 - right then you'll write the simplest
39:10 - application code that will make this
39:13 - test pass the absolute simplest you
39:16 - don't want to over engineer here you
39:18 - don't want to design a class diagram
39:19 - with a zillion classes and methods use
39:22 - the simplest implementation that would
39:24 - make the test pass then refactor your
39:28 - code if necessary these three steps are
39:31 - the foundation of TDD you repeat these
39:35 - three steps over and over until you
39:38 - build a complete feature now what is so
39:41 - special about TDD well first is that
39:45 - your source code will be testable right
39:47 - from the get-go you don't have to make
39:49 - any changes your code to make it
39:51 - testable second is that every line of
39:55 - your production code is fully covered by
39:57 - tests which means you can refactor and
40:00 - deploy with confidence and third is that
40:04 - it often results in a simpler
40:06 - implementation when you start with a big
40:10 - class diagram chances are you're
40:12 - over-engineering and making the solution
40:14 - more complex if you write enough code to
40:17 - make all the tests pass and that
40:19 - solution works there is no reason to
40:21 - write more code the fact that all your
40:24 - tests pass means you've fulfilled all
40:27 - the business requirements so unless
40:30 - there is a new requirement you don't
40:31 - need to write more code and if there is
40:33 - a new requirement you start by failing
40:35 - tests so this is TDT in TDD we write our
40:39 - tests
40:40 - first and that's why we call this
40:42 - approach test-driven development so our
40:45 - development is driven by our tests in
40:47 - contrast to TDD or tests first we have
40:51 - code first which is what you have been
40:53 - doing so far you start with your
40:55 - application code and then you write
40:57 - tests which approach is better it
41:00 - depends who you ask
41:01 - in theory TDD is more promising because
41:05 - of the benefits I told you but in
41:07 - practice sometimes it can get really
41:09 - complex and it may slow you down if
41:12 - that's the case it's better to switch to
41:14 - the code first approach and write your
41:16 - tests after in this course our focus
41:20 - will be on the code first approach so we
41:22 - can master the fundamentals of testing
41:25 - once you master the fundamentals then
41:28 - you'll be ready to start your tests
41:30 - first journey TDD really requires a
41:33 - separate course and I'm not going to
41:35 - talk about it throughout this course but
41:37 - if you're interested potentially in the
41:39 - future I can create a course on
41:40 - test-driven development
41:47 - all right now let me give you an
41:50 - overview of how I have structured this
41:52 - course real quick in the next section
41:54 - you're going to learn the fundamentals
41:56 - of unit testing in this section we'll be
41:59 - looking at characteristics of good and
42:01 - trustworthy unit tests we'll be looking
42:03 - at naming and organizing tests writing
42:07 - some basic unit tests as well as
42:08 - creating parameterised tests once you
42:12 - master the fundamentals then we'll be
42:14 - looking at the core unit testing
42:16 - techniques in this section in each
42:19 - lecture I'm going to show you an example
42:21 - of a function to test each function
42:23 - shows you a scenario that you see in a
42:25 - lot of real-world applications the
42:27 - following section is all about exercises
42:30 - so in that section I will give you three
42:32 - unit testing exercises and you will have
42:35 - a chance to put what you learn in the
42:37 - first two sections in practice for each
42:40 - exercise you can see my solution as well
42:42 - now up to this point all our unit tests
42:45 - are four simple classes that don't have
42:48 - any external dependencies but in the
42:51 - real world our code often talks to a
42:53 - database and web servers and so on so
42:56 - section 5 is all about dealing with
42:58 - these external dependencies in this
43:01 - section you will learn about concepts
43:03 - such as dependency injection and marking
43:05 - the following section again is all about
43:08 - exercises so we'll look at three
43:11 - examples of code that touches an
43:13 - external resource and finally the last
43:16 - two sections include more challenging
43:18 - exercises I will show you a snippet of
43:21 - source code taken from a real project
43:24 - and your job is to write all the
43:26 - necessary unit tests for that code and
43:28 - of course you're going to see my
43:30 - solution as well
43:36 - so in this section you learned about
43:39 - automated testing and its benefits
43:41 - Maurice pacifically you learned that it
43:43 - helps you prefactor your code with
43:45 - confidence and release software of
43:48 - better quality and with less bugs you
43:51 - learn about three types of tests unit
43:53 - integration and end-to-end tests and you
43:56 - also saw a glimpse of unit testing in
43:59 - action you learn how to write a basic
44:01 - unit test in Visual Studio and finally
44:04 - you learned how to run and debug your
44:06 - unit tests in the next section we're
44:09 - going to look at the core techniques for
44:11 - writing unit tests so I will see you in
44:13 - the next section
44:18 - bye guys maash here so if you made it
44:22 - this far you seem to be really
44:23 - enthusiastic about learning unit testing
44:26 - so I highly recommend you to enroll in
44:29 - my unit testing course and don't waste
44:31 - your time jumping from one tutorial to
44:33 - another when you enroll you will learn
44:35 - everything about unit testing from A to
44:37 - Z and by the end of watching the course
44:40 - you'll also get a certificate of
44:43 - completion which you can present your
44:45 - current or future employers so the link
44:48 - to the full course is in the video
44:50 - description I hope to see in the course