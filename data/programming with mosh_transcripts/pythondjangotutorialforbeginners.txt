00:02 - welcome to the ultimate django course
00:03 - in this course i'm going to teach you
00:05 - everything you need to know about django
00:07 - from the very basics to more advanced
00:09 - concepts
00:09 - so by the end of this course you'll be
00:11 - able to use django to build
00:13 - production-grade back-ends for your web
00:15 - and mobile apps if you have always
00:16 - wanted to learn web development with
00:18 - python you are in the right place
00:20 - we'll use python and django to build and
00:22 - deploy the backend for an
00:24 - e-commerce application if you're looking
00:26 - for a comprehensive
00:27 - organized and practical course that
00:29 - takes you from zero to hero
00:30 - and prepares you for the job this is the
00:32 - right django course for you
00:34 - everything you need to know about django
00:35 - is in one place in the right order
00:37 - so you don't need to jump back and forth
00:39 - between random tutorials
00:40 - amash hamadani i have taught millions of
00:43 - people how to advance their software
00:45 - engineering skills
00:46 - through my youtube channel and online
00:47 - school code with mosh.com
00:49 - if you're new here be sure to subscribe
00:51 - as i upload new videos
00:52 - all the time now let's jump in and get
00:56 - started
01:02 - let's talk about what you need to know
01:04 - to take this course for starters
01:06 - you need to know python you need to know
01:08 - the basics of python
01:09 - as well as object-oriented programming
01:11 - concepts such as classes
01:13 - inheritance polymorphism and so on you
01:16 - should also know the basics of
01:18 - relational databases
01:19 - so you should be familiar with concepts
01:21 - such as tables columns
01:22 - primary and foreign keys relationships
01:25 - and so on if you need to refresh the
01:26 - fundamentals i have a couple of beginner
01:28 - level tutorials on my youtube channel
01:30 - as well as comprehensive courses on my
01:32 - website codewithmosh.com i'll put the
01:34 - links down below in case you're
01:38 - interested
01:41 - all right so i'm assuming that you're
01:42 - the right student for this course now
01:44 - let's talk about how you should take
01:45 - this course
01:46 - first and foremost i want you to watch
01:48 - this entire course
01:50 - all the way from the beginning to the
01:51 - end even if you're familiar with django
01:53 - because
01:54 - along the way i will share a lot of tips
01:56 - and tricks and i don't want you to miss
01:58 - out on any of them
01:59 - if you have taken any of my other
02:00 - courses you know that i'm not gonna
02:02 - waste your time with
02:03 - repetitive or useless stuff so make sure
02:05 - to watch every lesson
02:07 - now while watching each lesson i want
02:09 - you to take notes
02:10 - you can just write down some keywords on
02:12 - a piece of paper if you don't want to
02:13 - write a lot of notes
02:14 - i strongly believe that the act of
02:16 - writing things down will help you
02:18 - remember new things that you learn
02:20 - then after each lesson go through your
02:22 - notes and repeat the same steps i showed
02:24 - you in the video
02:25 - this is exactly how i personally learn
02:27 - new things also
02:28 - i've carefully designed tons of
02:30 - exercises that help you understand and
02:32 - remember the materials so make sure to
02:34 - do all these exercises because the more
02:36 - you practice
02:37 - the better you'll be at django or coding
02:39 - in general
02:43 - welcome back to the ultimate django
02:44 - course in this section we're going to
02:46 - talk about the basics of django
02:48 - first i will give you a quick
02:50 - introduction to what django is and
02:52 - why it's so popular then we'll talk
02:54 - about the fundamental web development
02:56 - concepts that every web developer must
02:58 - know
02:59 - next we'll set up our machine for
03:00 - development and create
03:02 - our first django project once that
03:04 - project is up and running
03:05 - i will show you two essential techniques
03:07 - for debugging django applications
03:09 - this is going to be a short and sweet
03:11 - introduction to django so
03:12 - let's jump in and get started
03:22 - so what is django and why is it so
03:24 - popular well
03:25 - django is a free and open source
03:27 - framework for building web applications
03:29 - with python
03:30 - it's not the only web framework for
03:32 - python but it's the most
03:33 - popular one because it helps us build a
03:35 - website in less time
03:37 - with fewer lines of code that's why a
03:39 - lot of companies like youtube
03:41 - instagram spotify and dropbox use django
03:44 - in their tech stack
03:46 - now django is what we call a batteries
03:48 - included framework which means
03:50 - it comes with a lot of features out of
03:52 - the box so we don't have to code them
03:54 - from scratch
03:55 - for example it gives us an admin
03:57 - interface for managing our data which is
03:59 - a huge time
04:00 - saver it also has an object relational
04:02 - mapper that abstracts the database
04:04 - so we can query or persist data without
04:07 - writing a lot of sql code
04:09 - it also comes with an authentication
04:11 - package for identifying users
04:13 - it also has a package for caching data
04:15 - and much much more
04:16 - so since django offers all these amazing
04:19 - features
04:19 - we can focus on our application and its
04:21 - requirements we don't have to reinvent
04:23 - the wheel
04:24 - and code all these features from scratch
04:26 - now once in a while you might come
04:27 - across
04:28 - someone like our popular superstar
04:30 - developer john smith who thinks django
04:32 - is a piece of crap
04:34 - because it's old and bloated with so
04:36 - many features he used it
04:37 - hated it and then rewrote his entire
04:39 - project with a new shiny framework that
04:41 - is faster
04:42 - well saying a framework is better than
04:44 - django because it's faster it's kind of
04:46 - like saying
04:47 - a ferrari is better than a truck because
04:49 - it's faster
04:50 - what if you want to move something
04:52 - you're not going to use your ferrari for
04:53 - that right
04:54 - so a wise software engineer doesn't pick
04:57 - up a framework
04:57 - merely based on his performance there
04:59 - are so many other things you need to
05:01 - take into account
05:02 - like the maturity of the framework how
05:04 - stable it is from one version to another
05:06 - its learning curve the size of the
05:08 - community and so on
05:09 - django has been around for a long time
05:11 - and it has a huge community
05:13 - so there are tons of django packages
05:15 - built by the community that you can
05:16 - reuse in your applications
05:18 - also if you get stuck there's always
05:20 - someone out there to help you
05:22 - if you want to hire people there are
05:23 - tons of people to choose from so these
05:25 - are the benefits of having a huge
05:27 - community around the framework
05:28 - now regarding django features yes django
05:31 - comes with a lot of features
05:32 - but you don't have to use or even learn
05:35 - all of them because
05:36 - all these features are optional so you
05:38 - can use the features that make sense for
05:39 - your application
05:41 - so in my opinion debates about the best
05:43 - framework in the world are useless
05:45 - we all like different things and just
05:47 - because someone doesn't like django it
05:48 - doesn't mean it's bad
05:50 - a lot of companies are using django and
05:51 - are looking for django developers
05:53 - here in the us the average salary of a
05:56 - django developer is just over
05:57 - 117 000 a year so
06:00 - if you like python and want to get into
06:02 - web development learning django is a
06:04 - good investment for your future
06:08 - [Music]
06:12 - so you learned that django is a
06:14 - framework for building web applications
06:16 - with python
06:17 - now let's talk about some of the
06:19 - fundamental concepts you need to
06:20 - understand to build web applications
06:23 - let's say we're going to build an online
06:24 - store and publish it at moshby.com
06:27 - now this website is going to have two
06:29 - parts or two applications
06:31 - a front end and a backend the front end
06:34 - is the part that is loaded
06:35 - inside a web browser on a client machine
06:38 - it's the part that the user sees and
06:40 - interacts with
06:41 - the backend is the part that runs on a
06:43 - web server
06:44 - and is responsible for data processing
06:47 - validating business rules and so on
06:49 - now let's imagine that alice wants to
06:51 - visit our website
06:52 - so she points her browser to moshby.com
06:55 - this address is also called a url which
06:58 - is short for uniform
06:59 - resource locator it's basically a way to
07:02 - locate a resource on our internet
07:04 - a resource can be a web page an image a
07:06 - video
07:07 - a pdf and so on so alice types
07:10 - moshby.com in her browser and presses
07:12 - enter
07:13 - at this moment a browser sends a request
07:15 - to the web server that hosts our website
07:17 - and says
07:18 - hey alice wants to see the home page so
07:21 - the web server should take this request
07:23 - process it and return a response back to
07:25 - the client
07:26 - this data exchange is defined by a
07:28 - protocol called http
07:30 - which is short for hypertext transfer
07:32 - protocol
07:33 - it defines how clients and servers can
07:35 - communicate
07:36 - so this is the big picture as alice
07:38 - navigates our website
07:40 - for each page her browser sends an http
07:42 - request to the server
07:44 - and receives an http response now as
07:46 - part of building the backend for this
07:48 - website
07:49 - we need to decide how we're going to
07:50 - respond to clients one option is to
07:52 - generate the requested page on the
07:54 - server
07:55 - and return it to the client we use html
07:57 - for that html is short for
07:59 - hypertext markup language it's a simple
08:02 - language for
08:02 - representing web pages and their content
08:05 - every webpage you have seen on internet
08:07 - is built using html
08:08 - so one option is to generate the page on
08:10 - the server and return an html
08:13 - document to the client the other option
08:15 - is to return only the data needed on the
08:17 - requested page
08:18 - and have the client generate the page so
08:21 - instead of putting a complete page or
08:23 - a complete html document in an http
08:26 - response
08:27 - we only return the data like the list of
08:29 - products
08:30 - now what is the difference well if we
08:32 - push this responsibility to the client
08:34 - we can free up the server so it can
08:36 - serve more clients
08:37 - our application will be more scalable
08:39 - that's why over the past few years
08:41 - this approach has become more trendy and
08:43 - is now considered the industry best
08:45 - practice
08:46 - these days we have tools like react
08:48 - angular and vue for generating web pages
08:51 - on the client
08:51 - these are all client-side tools that are
08:53 - used by front-end developers
08:55 - in contrast we have server-side tools
08:57 - for building back-ends
08:59 - django falls in this category so you
09:01 - should not compare django with let's say
09:03 - react
09:04 - you may compare django with other
09:06 - server-side frameworks like asp.net core
09:08 - which is used by c-sharp developers
09:10 - express used by javascript developers
09:13 - and so on
09:14 - so if we push the responsibility of
09:16 - generating web pages to the client
09:18 - the server essentially becomes a gateway
09:20 - to the data
09:21 - on the server we can provide endpoints
09:23 - that the client can talk to
09:25 - to get or save various pieces of data
09:28 - for example we can provide one endpoint
09:30 - to get the list of products and another
09:32 - endpoint to get the list of orders
09:34 - someone has placed
09:36 - now all these endpoints together
09:38 - represent the interface that clients use
09:40 - to talk to the server
09:41 - in technical terms we say the server
09:43 - provides an api
09:45 - or an application programming interface
09:47 - to clients this api is essentially like
09:49 - the buttons on a remote control
09:51 - all these buttons together represent the
09:53 - interface or the api we use to interact
09:56 - with the tv
09:57 - okay so in this course our focus will be
10:00 - on using django
10:01 - to build an api for our online store
10:03 - client applications can use this api to
10:06 - get or save the data
10:07 - how these clients are built is
10:09 - irrelevant here we can use react
10:11 - angular or even plain javascript that
10:13 - falls under front-end development which
10:15 - has nothing to do with django
10:16 - once we build this api if you know
10:18 - front-end development you can
10:20 - always build a client app that talks to
10:22 - this api
10:23 - alright now that you understand the big
10:24 - picture we are ready to set up our
10:26 - development environment
10:27 - and that's what we will do next
10:32 - [Music]
10:37 - all right let's make sure you have the
10:38 - right setup before we start coding
10:40 - the first thing i want you to do is
10:42 - upgrade your python to the latest
10:44 - version
10:44 - so head over to python.org downloads and
10:47 - download the latest version of python
10:49 - for your operating system
10:50 - once you do that then open up your
10:52 - terminal window and run
10:53 - python version to make sure you have
10:57 - upgraded your python correctly
10:59 - now here we see python 2.7 because on
11:01 - mac we have two different versions of
11:03 - python running side by side
11:05 - we have the old python 2 which is now
11:07 - deprecated
11:08 - and we also have python 3. so if you're
11:11 - using a mac
11:12 - you have to run python3 dash dash
11:14 - version
11:15 - but if you're on windows or linux you
11:17 - have to run python
11:19 - version okay so here i'm using python
11:22 - 3.9.5 great next we're going to use pip
11:26 - or pip3 if you're on mac to install
11:29 - pip n i talked about paypal in my python
11:32 - course
11:33 - it's basically a dependency management
11:34 - tool for installing our application
11:36 - dependencies
11:37 - in virtual environments this way our
11:40 - application dependencies will not clash
11:42 - with other applications dependencies
11:44 - okay so
11:45 - let's go ahead and install this
11:50 - now in this course just like my other
11:52 - courses i'm going to use visual studio
11:54 - code or vs code as my editor it's just
11:57 - my personal preference
11:58 - if you have a preference for a different
11:59 - tool like pycharm that's totally fine
12:02 - having said that i highly encourage you
12:04 - to use vs code
12:05 - because throughout the course i'm going
12:06 - to show you a lot of shortcuts and
12:08 - time saving tips that will not apply to
12:10 - your editor
12:11 - in case you don't have vs code you can
12:13 - get it from code.visualstudio.com
12:16 - now once you run it i want you to go to
12:18 - the extensions panel over here
12:21 - and search for python make sure
12:24 - to install this extension because with
12:26 - this we get features such as
12:28 - intelligence debugging code navigation
12:30 - and so on
12:38 - all right now that we have installed all
12:39 - the necessary tools let's create our
12:41 - first django project
12:43 - so here in the terminal window i'm going
12:44 - to go to my desktop
12:46 - you can go anywhere on your machine it
12:48 - doesn't really matter now we're going to
12:50 - create
12:50 - a directory called store front that is
12:54 - the name of our project
12:55 - next we go inside this directory and run
12:59 - pip and install django so we're going to
13:02 - install django
13:03 - using pip app inside a virtual
13:06 - environment
13:07 - now let's go ahead
13:11 - all right well take a look so over here
13:14 - you can see that p-band has created a
13:16 - virtual environment for this project
13:19 - down below you can see the path to this
13:21 - virtual environment
13:22 - but if you're on windows you're going to
13:23 - see something like c drive
13:25 - backslash whatever now if you're on a
13:27 - mac and using z shell which is this
13:29 - fancy
13:30 - colorful terminal window you can hold
13:32 - down the command key
13:34 - and click on this path to go into it
13:36 - otherwise we can just copy this
13:38 - and use the cd command to go inside this
13:41 - directory
13:42 - now take a look so here's our virtual
13:45 - environment
13:46 - in this environment we have this bin
13:48 - folder that contains a bunch of binaries
13:51 - for example we have python pip django
13:54 - admin and so on
13:55 - so back to the terminal pbn created a
13:58 - virtual environment and
13:59 - installed django inside that environment
14:02 - but in addition to this
14:03 - ppm also created two files in this
14:06 - directory
14:07 - pip file and pay file.log so i'm going
14:10 - to open this directory using visual
14:12 - studio code
14:13 - by running code period if this doesn't
14:16 - work on your machine
14:17 - just drag and drop this folder onto vs
14:19 - code
14:21 - alright so here's our pip file this is
14:23 - like package.json for javascript
14:26 - projects
14:27 - so in this file we can see that our
14:29 - project needs
14:30 - this particular version of python and
14:32 - under packages you can see
14:34 - the packages that our application is
14:36 - dependent upon
14:38 - so here we have django equals asterisk
14:40 - that means
14:41 - any version or the latest version of
14:43 - django
14:44 - if we installed a particular version of
14:46 - django we would see that version here
14:49 - now back to the terminal window we need
14:51 - to activate this virtual environment
14:53 - so we'll use the python interpreter
14:55 - inside this virtual environment
14:57 - not the one that is installed globally
14:58 - on this machine to do that we're going
15:00 - to run
15:01 - ppm shell
15:04 - okay next we're going to use django
15:07 - admin
15:08 - to start a new project django admin is a
15:10 - utility that comes with django
15:12 - so if you run it we can see all these
15:15 - commands that we can use
15:16 - to work with django projects as we go
15:19 - through the course
15:20 - you will become familiar with this
15:21 - command in this lesson we're going to
15:23 - use
15:23 - django admin start project
15:27 - and we're going to call that project
15:28 - store front
15:31 - now back to vs code django admin created
15:34 - this directory for our project
15:36 - and inside this directory it created
15:38 - another directory
15:40 - that is the core of our application in
15:42 - this directory we have these files which
15:43 - i'm going to talk about in a second
15:45 - but before i do so let's get rid of this
15:47 - redundancy
15:48 - because we have three storefront
15:50 - directories
15:51 - the top one is the one that we created
15:54 - earlier in the terminal
15:55 - and then we have these two other
15:57 - directories one for the project
15:59 - one for the core of our application so
16:02 - i'm gonna delete
16:03 - this project directory now we're back in
16:06 - the previous step so we don't have a
16:08 - django project at this stage
16:10 - now back in terminal let's bring up the
16:13 - last command
16:14 - but type it period at the end this tells
16:16 - django
16:17 - to use the current directory as the
16:19 - project directory so django is not going
16:21 - to create
16:22 - an additional directory for our project
16:25 - okay now take a look so we have this
16:29 - directory
16:30 - which is the core of our application in
16:32 - this directory we have
16:33 - this init file which defines this
16:34 - directory as a package
16:36 - we have this settings module where we
16:38 - define our application settings
16:40 - we have the urls module where we define
16:42 - the urls of our application
16:44 - and these two other modules that are
16:46 - used for deployment
16:47 - for now don't worry about them now next
16:50 - to this directory we have
16:52 - this file manage.pi this is a wrapper
16:55 - around django admin so going forward
16:58 - instead of django admin we're going to
16:59 - use manage.pi
17:01 - the reason for this is that manage.pi
17:03 - takes the settings of this project into
17:05 - account
17:06 - let me show you what i mean so now that
17:08 - we have a project
17:10 - we want to run a web server so another
17:12 - command that django admin provides is
17:16 - run server however if you're on django
17:19 - admin
17:20 - run server we get an error saying
17:24 - requested setting debug but settings are
17:27 - not configured
17:28 - because at this point django admin
17:30 - doesn't know about the
17:32 - settings of our project so now that we
17:34 - have a project
17:35 - instead of django admin we're going to
17:37 - run python
17:39 - manage.pi now look we see the same
17:43 - commands
17:44 - that django admin provides so here we
17:46 - can say
17:47 - python manage.pi run server
17:51 - now optionally we can supply a port
17:54 - number
17:55 - if we don't supply this by default this
17:57 - will use port 8000 but you might have
17:59 - another application running on port 8000
18:02 - in that case you might want to
18:03 - explicitly set the port number
18:05 - so let's go ahead with that now we don't
18:08 - get an error
18:09 - because manage the pi knows about the
18:12 - settings of our project
18:13 - now here we get this warning saying you
18:15 - have 18
18:16 - unapplied migrations don't worry about
18:18 - this yet we'll talk about this soon
18:21 - so if you look over here you can see
18:23 - that django has started
18:25 - a development server at this address so
18:28 - we can copy this and paste it into
18:29 - browser
18:30 - or if you're on a mac and using z shell
18:32 - you can hold down the command key and
18:35 - click this all right beautiful
18:38 - our first django project is running
18:39 - successfully so let's move on to the
18:41 - next lesson
18:45 - [Music]
18:50 - so far i've been using a separate
18:51 - terminal window but vs code also has
18:54 - an integrated terminal window that is
18:56 - easier to use but to use that we have to
18:58 - properly configure it to use the python
19:00 - interpreter
19:01 - inside our virtual environment let me
19:03 - show you how to do this
19:05 - so back to our terminal window first
19:07 - we're going to stop the web server
19:09 - by pressing ctrl and c okay
19:12 - now back in vs code on the top under the
19:15 - view menu
19:17 - look we have this command pallet the
19:19 - shortcut on mac is
19:21 - shift command and p
19:24 - now here we're going to search for
19:25 - python interpreter
19:28 - so currently vs code is using this
19:31 - python interpreter that is installed
19:33 - globally on this machine we don't want
19:35 - to use this you want to use the one
19:36 - inside our virtual environment but how
19:38 - can we find the path to our virtual
19:40 - environment
19:41 - very easy so back to the terminal
19:44 - let's run pip and dash dash vm
19:48 - all right here's the path so let's copy
19:51 - this
19:53 - good now back to vs code we're going to
19:56 - select
19:57 - enter interpreter path then we're going
20:00 - to paste the path
20:01 - and append slash bin slash
20:05 - python at the end if you're on windows
20:08 - instead of a forward slash you have to
20:09 - use a backslash
20:11 - okay good now
20:14 - in this project we have an extra
20:16 - directory vs code
20:18 - we have a settings file and here we have
20:20 - the path
20:21 - to a python interpreter good with this
20:24 - we can go to the view menu
20:27 - now look we have this integrated
20:29 - terminal the shortcut on mac
20:31 - is control and backtick
20:35 - now vs code automatically activates the
20:37 - virtual environment for this project
20:39 - so here we can run python manage.pi
20:43 - run server good so going forward
20:46 - i'm going to use the integrated terminal
20:48 - window here it's easier
20:49 - we can always hide it by pressing ctrl
20:52 - and backtick
20:53 - or bring it back we can maximize it move
20:56 - it around and so on
20:58 - now one quick tip sometimes when running
21:00 - this command
21:01 - you might get a syntax error saying
21:03 - invalid syntax
21:04 - this happens every now and then when vs
21:06 - code fails to
21:07 - activate the virtual environment for
21:09 - this project to solve this problem all
21:11 - you have to do
21:12 - is open a new terminal window and look
21:16 - vs code executed this command to
21:18 - activate
21:19 - the virtual environment for this project
21:21 - now we can run
21:22 - python manage.pi run server
21:25 - great hey guys bosh here i just wanted
21:29 - to let you know that this tutorial you
21:31 - have been watching
21:31 - is actually the first hour of my
21:34 - ultimate django course
21:35 - the complete course is about 10 hours
21:37 - and goes way beyond this tutorial
21:39 - so if you're serious about learning
21:41 - django and are looking for a job as a
21:43 - back-end
21:44 - developer i highly encourage you to
21:45 - enroll in the course the course comes
21:47 - with tons of exercises and solutions
21:49 - a full e-commerce project that you will
21:51 - eventually deploy to the cloud
21:53 - plus a 30-day money-back guarantee and a
21:56 - certificate of completion you can add
21:57 - your resume
21:58 - in case you're interested i'll put the
22:00 - link down below and if not that's
22:02 - totally fine let's move on to the next
22:03 - lesson
22:06 - [Music]
22:10 - all right let's talk about apps so every
22:12 - django project
22:13 - is essentially a collection of various
22:15 - apps each providing
22:16 - certain functionality just like the apps
22:19 - on your mobile phone
22:20 - each app provides a certain
22:21 - functionality right django projects are
22:24 - exactly the same so in this project
22:26 - let's open up the storefront directory
22:29 - and then look at our settings module
22:31 - now we can collapse this panel by
22:33 - pressing command and b on mac
22:35 - or ctrl and b on windows okay now in
22:38 - this module we have a bunch of different
22:40 - settings
22:41 - in this lesson we're going to look at
22:43 - the install apps
22:44 - so every django project by default
22:47 - includes these apps
22:48 - the first app is the admin app which
22:51 - gives us an admin interface for
22:53 - managing our data then we have the auth
22:56 - app which is used for
22:57 - authenticating users then we have
22:59 - content types app which we'll talk about
23:01 - later in the course
23:02 - next we have the sessions app which is
23:04 - kind of legacy we don't use sessions
23:06 - anymore
23:07 - a session is a temporary memory on the
23:09 - server for managing users data
23:11 - these days when building apis with
23:13 - django we don't use the sessions app
23:15 - so we can come here and delete this app
23:18 - then we have the messages app
23:19 - which is used for displaying one-time
23:21 - notifications to the user
23:23 - and finally we have the static files app
23:26 - for serving static files like images
23:28 - css files and so on so each app provides
23:31 - a certain piece of functionality okay
23:34 - now we can also create our own apps here
23:36 - so let's save this file now let's open
23:38 - up the terminal window by pressing
23:40 - control and backtick so here's our
23:43 - terminal window where we have
23:45 - our development server running we're
23:47 - going to open a new terminal window
23:50 - okay now let's expand this to clear the
23:53 - window we simply press
23:54 - ctrl and l now we're going to run python
23:58 - manage.pi start app and we're going to
24:01 - call this app
24:02 - playground okay so
24:05 - let's close the screen now and open up
24:08 - the explorer panel
24:09 - all right look here's our new app which
24:11 - is represented using a folder with a
24:14 - special structure
24:15 - so every django app has the exact same
24:17 - structure
24:18 - here we have the migrations folder for
24:20 - generating database tables we'll talk
24:22 - about that later in the course we have a
24:23 - complete section about this topic
24:25 - we have the admin module where we define
24:28 - how the admin interface for this app is
24:30 - going to look like
24:31 - next we have the apps module where we
24:34 - configure this app
24:35 - so the name is misleading i don't know
24:37 - why django developers decided to call
24:39 - this module apps
24:40 - it would be better if it was called
24:41 - config that's just my two cents
24:43 - next we have the models module where we
24:45 - define the model classes for this app
24:48 - we use model classes to pull out data
24:50 - from the database and present to the
24:52 - user
24:52 - next we have the tests module where we
24:54 - write our unit tests
24:56 - and finally we have the views module
24:58 - which we'll talk about in the next
24:59 - lesson
25:00 - again the name is misleading this is not
25:02 - the view that you think if you come from
25:03 - a front-end development background
25:05 - so what we have here is essentially a
25:07 - request handler it's not a view it
25:09 - doesn't have
25:10 - a template or html again we'll talk
25:12 - about that in the next lesson
25:14 - so we created a new app now we need to
25:16 - register this app in the settings module
25:18 - so every time you create a new app
25:22 - you need to register it here in the list
25:24 - of installed apps
25:25 - we simply add the name of the app which
25:27 - is called playground
25:30 - save the changes done in the next lesson
25:32 - we're going to talk about views
25:36 - [Music]
25:40 - alright let's talk about views so
25:42 - earlier you learned that http
25:43 - is a request response protocol so every
25:46 - data exchange
25:47 - involves a request and a response this
25:49 - is where we use views in django
25:52 - so here in the playground folder let's
25:54 - open up the views module
25:56 - this is where we define our views or
25:58 - view functions
25:59 - a view function is a function that takes
26:02 - a request
26:03 - and returns a response so more
26:05 - accurately
26:06 - it's a request handler in some
26:09 - frameworks it's called
26:10 - an action in django it's called a view
26:13 - but i don't agree with this name because
26:15 - from an architectural point of view a
26:17 - view is often associated with something
26:19 - that the user sees
26:20 - that part in django is called a template
26:22 - and we'll talk about that later in this
26:23 - section
26:24 - now that aside let's create our first
26:26 - view function
26:27 - so we're going to create a function we
26:30 - can call it anything we want
26:31 - i'm going to call it say hello
26:34 - now this function should take a request
26:36 - object and return a response
26:39 - so first on the top from django.http
26:44 - package
26:45 - we're going to import the http response
26:47 - class
26:48 - now in this function we can do anything
26:50 - we want in a real-world scenario we can
26:52 - pull data from a database we can
26:55 - transform data
26:56 - we can send emails and so on for now
26:58 - let's just return
26:59 - a simple response so we're going to
27:02 - return
27:03 - an instance of the http response class
27:07 - and in this object in this response you
27:09 - want to add a simple string
27:11 - so let's say hello world okay
27:14 - so this is our first view or first view
27:16 - function
27:17 - now we need to map this view to a url so
27:19 - when we get a request at that url
27:22 - this function will be called and that's
27:24 - what we're going to do next
27:27 - [Music]
27:31 - alright here's our django project now
27:33 - let's say whenever we send
27:34 - a request to playground slash hello
27:38 - our view function should be called and
27:39 - return hello world to the user
27:41 - let's see how we can do that so back to
27:43 - our project
27:44 - here in the playground folder we're
27:46 - going to add a new file
27:48 - called urls.pi you could call it
27:51 - anything the name doesn't matter
27:52 - but by convention we call it urls now
27:55 - in this module we're going to map our
27:57 - urls to our view functions
28:00 - so on the top we're going to import the
28:02 - path function from django.urls
28:05 - so from django.urls we're going to
28:07 - import the path function
28:09 - now don't worry about memorizing any of
28:10 - these as you practice
28:12 - all of this will become second nature
28:14 - also
28:15 - from the current folder we should import
28:17 - the views module
28:19 - so we can reference our view function
28:21 - now we should define
28:22 - a special variable called url patterns
28:25 - all in lower case make sure to split it
28:27 - properly because this is what django
28:29 - looks for
28:30 - we should set this to an array of url
28:33 - pattern objects
28:35 - we use the path function to create a url
28:37 - pattern object
28:38 - so if we call this function look at the
28:40 - signature of this function
28:42 - this function has a bunch of parameters
28:44 - the first one is route
28:45 - which is a string the notation you see
28:47 - here is called type annotation which is
28:49 - kind of a new feature in python
28:51 - with type annotation we can see the type
28:53 - of parameters
28:54 - and the return value of a function so
28:56 - the first parameter is route which is a
28:58 - string
28:59 - the second parameter is view which is a
29:01 - function that returns
29:03 - http response object now look over here
29:06 - this notation represents the return type
29:09 - of this function
29:10 - so the path function returns a url
29:13 - pattern object
29:14 - so i'm going to call this function and
29:15 - give it two arguments a route or a url
29:18 - which is playground slash hello and
29:22 - a view function so from the views module
29:25 - we're going to get
29:26 - say hello note that i'm not calling this
29:28 - function so here we don't have a pair of
29:30 - parentheses
29:31 - we're just passing a reference to this
29:33 - function okay
29:35 - so what we have here is called a url
29:38 - conf module
29:39 - that basically means url configuration
29:42 - so every app
29:43 - can have its own url configuration but
29:45 - now we need to import this url
29:47 - configuration
29:48 - into the main url configuration for this
29:50 - project
29:51 - where is it you saw it earlier so
29:54 - back to the explorer panel here in the
29:56 - storefront folder
29:59 - we have another url's module
30:02 - up here we have a bunch of comments
30:03 - about how we should use this module
30:06 - now look over here if you want to
30:08 - include another
30:09 - url conf there are two things we need to
30:11 - do first we need to import the include
30:13 - function
30:14 - from django.urls so over here we have
30:17 - from django.urls
30:18 - we're going to import the include
30:20 - function next we need to add
30:22 - a url to url patterns
30:25 - so in this module we also have a url
30:29 - patterns object which is an array
30:31 - of url patterns object so here we're
30:33 - going to call path
30:35 - give it a route and then we use the
30:38 - include function
30:39 - to reference the url configuration
30:41 - module
30:42 - in this app so
30:46 - we're going to call path and say
30:49 - any urls that start with playground
30:52 - followed by a forward slash should be
30:54 - routed to
30:55 - our playground app so this is where we
30:57 - use the include function
30:59 - now the include function requires a
31:01 - parameter that is a string
31:03 - here we're going to reference playground
31:05 - dot urls
31:08 - so if we send the request to playground
31:11 - slash hello django knows that
31:14 - all requests that start with playground
31:16 - should be handled by this
31:18 - app so it's going to chop off the first
31:20 - part of this url
31:22 - and pass the rest to the url
31:24 - configuration module
31:26 - in the playground app so back to this
31:28 - url's module
31:30 - we no longer need to add playground here
31:32 - because we added it once
31:34 - in the main url configuration module
31:37 - so we simply add hello followed by a
31:39 - forward slash i forgot to add that we
31:41 - always end our routes with a forward
31:43 - slash
31:44 - so let's save the changes now whenever
31:47 - we change our code
31:48 - django web server automatically restores
31:51 - itself
31:52 - so let's open up the terminal window
31:54 - make sure we don't have any arrows good
31:56 - so back to the browser let's send a
31:59 - request to this endpoint
32:01 - great we see hello world on the screen
32:04 - so this is how we can map
32:05 - urls to view functions next we're going
32:07 - to talk about templates
32:15 - so i told you that views in django are
32:17 - not really views they're more like
32:18 - request handlers or actions
32:20 - what we often call a view in other
32:22 - frameworks is called a template in
32:24 - django
32:25 - so let's see how we can use a template
32:27 - to return html content to the client
32:30 - so here in the playground app we're
32:33 - going to add
32:33 - a new folder called templates
32:36 - and in this folder we're going to add a
32:38 - new file called
32:40 - hello.html and of course we could call
32:42 - it anything
32:44 - and here we can write some html markup
32:46 - for example we can type
32:47 - h1 and press tab to add an h1 heading
32:50 - and say hello world now don't worry if
32:53 - you don't know html we're not going to
32:55 - use it in this course
32:56 - i just want to show you how django
32:57 - templates work
32:59 - so let's save the changes now back to
33:02 - our view function
33:03 - instead of returning a plain http
33:06 - response
33:07 - we're going to use the render function
33:09 - to render a template and return
33:11 - html markup to the client so let's
33:13 - remove this line
33:15 - and call the render function now look at
33:18 - the return type
33:19 - of this function it returns an http
33:22 - response object
33:24 - so here we're going to return the
33:26 - response
33:27 - now let's remove the brackets and type
33:29 - them again so we can see the function
33:31 - signature
33:32 - the first parameter here is a request
33:35 - object and
33:36 - the type of this is http request
33:39 - so we're going to pass this request
33:42 - object
33:43 - right here now the second parameter
33:47 - that's the name of our template which is
33:49 - a string
33:50 - so here i'm going to say hello.html
33:54 - the other parameters are optional so
33:56 - don't worry about them at this point
33:57 - now save the changes let's make sure our
34:00 - project works up to this point
34:02 - so back in the browser refresh beautiful
34:05 - now we see html content we can verify it
34:08 - by right clicking on this page and
34:10 - looking at the page source so look we
34:13 - are returning
34:14 - html content great now let's make this a
34:17 - bit more interesting
34:19 - so back to our template instead of hello
34:22 - world
34:22 - we can dynamically render some value so
34:25 - back to review function let's type a
34:28 - comma
34:28 - to see the next parameter that is a
34:31 - context object
34:33 - and the type of this is a mapping of
34:35 - string
34:36 - to any that means we can pass any
34:39 - mapping object
34:40 - that maps a string value to any other
34:43 - type of
34:43 - object so here we can pass a dictionary
34:47 - so let's pass a dictionary the type of
34:50 - the key should be a string so we can
34:51 - call that name
34:53 - and we're going to set that to a value
34:54 - like let's say mosh
34:56 - now back to our template
35:00 - instead of hello world we can render the
35:02 - name that we passed here
35:04 - so we type two pairs of braces and in
35:07 - between
35:08 - we type the name of the key save
35:11 - refresh beautiful now in this template
35:15 - we can also write some logic so we can
35:18 - type an if statement so we type braces
35:20 - and in between them we add two
35:23 - percentage signs
35:25 - in between them we can write an if
35:27 - statement so we can say
35:28 - if name is set we can render it here
35:32 - otherwise
35:35 - we can render hello world
35:39 - and of course we need an end if clause
35:41 - as well so
35:42 - and if now this syntax is kind of ugly
35:46 - but the good thing about django is that
35:48 - it's modular so you can easily replace
35:50 - django's default template engine with
35:52 - your preferred template engine but once
35:55 - again we don't really use templates in
35:57 - django
35:57 - projects that often these days there are
36:00 - special cases for them but
36:01 - for the most part we use django to build
36:04 - apis that return data
36:05 - not html content so i just included this
36:08 - lesson
36:09 - so you know what templates are and how
36:10 - they work we're not going to spend any
36:12 - more time on templates for now
36:14 - unless we encounter a situation where we
36:16 - really need them
36:19 - [Music]
36:24 - let's talk about debugging django
36:26 - applications in vs code
36:27 - this is particularly useful if our
36:29 - application doesn't produce the right
36:31 - result and we want to run it line by
36:33 - line and see
36:34 - where exactly something has gone wrong
36:36 - so click on this icon
36:38 - to open the run and debug panel now the
36:41 - first time you see this message saying
36:43 - we should create a launch.json file
36:46 - basically we need to create a launch
36:47 - profile
36:48 - so vs code knows how to run or debug
36:50 - this application
36:51 - so let's click on this now in this list
36:55 - select django all right here's our
36:58 - launch.json file
37:00 - what you see here is kind of like a
37:01 - dictionary in python we have a bunch of
37:04 - key value pairs
37:05 - these key value pairs define a launch
37:08 - profile
37:08 - so vs code knows that to run this
37:10 - application
37:12 - it should use the current python
37:14 - interpreter
37:15 - to run manage.pi which exists
37:18 - in our workspace folder and then as an
37:20 - argument
37:21 - it should pass run server to it here we
37:24 - can add
37:25 - an additional argument to specify the
37:28 - port
37:28 - so it doesn't clash with port 8000 which
37:31 - is currently in use
37:32 - okay save the changes we're done with
37:35 - this file
37:36 - so let's close it now if you're curious
37:39 - let me show you where this file exists
37:42 - it's added to our project up here inside
37:45 - the vs code folder so here's our launch
37:48 - profile
37:49 - now that we have a launch profile if we
37:51 - go to the run and debug panel
37:53 - we see something else so here we can
37:55 - start our application for debugging
37:57 - but before doing so i want to write some
37:59 - dummy code here in our view function
38:01 - so let's set x to 1 and
38:05 - y to 2. now i'm going to click on this
38:08 - line
38:08 - to insert a breakpoint when we add a
38:11 - breakpoint
38:12 - via scope will execute every line of
38:14 - code until
38:15 - it hits our breakpoint from that point
38:18 - onward
38:18 - we can execute our code line by line so
38:22 - let's add a breakpoint and then start
38:24 - the application for debugging
38:30 - all right let me collapse this window
38:32 - good
38:33 - so in this new terminal window we have a
38:36 - development server
38:37 - listening on port 9000 so let's hold
38:40 - down the command key on mac or
38:42 - control on windows and click on this
38:44 - link
38:45 - all right here's what we get the home
38:47 - page of our project is gone
38:48 - because we have registered a custom
38:50 - route that is playground
38:52 - hello so we see the homepage only the
38:54 - first time we run our django project
38:56 - so let's go to playground hello
39:00 - all right our breakpoint is activated
39:02 - and we are on this line
39:05 - now on the left side in the variables
39:07 - section you can see the local variables
39:09 - so currently we have the request object
39:11 - that is the request object that
39:13 - we receive in this function so we can
39:15 - expand it
39:16 - and inspect its various attributes
39:19 - we don't want to do that for now so
39:22 - let's close this
39:23 - we want to execute our code line by line
39:26 - so here we have a bunch of functions
39:28 - the first one is step over and the
39:31 - shortcut for this is f10
39:32 - with this we can step over the current
39:34 - line so if we press f10
39:38 - this line gets executed and now we are
39:40 - on the second line
39:41 - now look over here in the list of local
39:44 - variables we have
39:44 - x and its value is one this is very
39:47 - useful when debugging applications
39:49 - so if something is not calculated
39:51 - properly we can inspect it here
39:54 - now most of the time you can see your
39:55 - local variables here
39:57 - but if not you can always add them in
39:59 - the watch window
40:00 - so before recording this video i was
40:02 - practicing that's why you see x here
40:05 - let me select this and delete it so in
40:08 - your watch section you're not going to
40:09 - have any variables
40:10 - to add one we simply click on this and
40:12 - then type
40:14 - the name of our variable okay so this is
40:17 - how we can step over
40:18 - various lines so we can press f10 again
40:21 - and again
40:22 - so this function is executed and now
40:24 - back in the browser
40:26 - we see the final result now let's do
40:28 - something more interesting
40:30 - so back to our code let's close
40:33 - the terminal window so we have more
40:34 - space i'm going to define
40:37 - a function here called calculate
40:40 - and here we're going to set x to 1 y to
40:42 - 2 and return x
40:44 - just some dummy code now over here
40:47 - we're going to call the calculate
40:49 - function okay
40:51 - now save the changes back in the browser
40:55 - let's refresh so our view function gets
40:58 - caught
40:58 - now we are right here now this time
41:01 - instead of stepping over this line
41:02 - we want to step into it because if you
41:05 - step over this line
41:06 - we're not going to see what happened in
41:08 - the calculate function
41:10 - we see the final result so we see x is
41:13 - set to 1 and
41:14 - we can verify that over here as well but
41:17 - sometimes we need to step into a
41:18 - function to see
41:19 - what is happening there maybe there is a
41:21 - bug inside the calculate function
41:23 - so let's restart the debugger
41:29 - okay i'm going to close this back in the
41:31 - browser
41:33 - let's refresh this page
41:36 - okay we're back to this line now this
41:39 - time we're going to step into this
41:40 - function
41:41 - so look over here this is the icon for
41:44 - stepping into a function
41:45 - and as you can see the shortcut is f11
41:48 - so if you press f11
41:51 - we go inside the calculate function now
41:54 - we can execute each line
41:55 - using f10 or step over and see where
41:58 - something has gone wrong
42:00 - now let's imagine this calculate
42:01 - function is a large function with a lot
42:03 - of code
42:04 - at some point we want to step out of it
42:06 - without having to execute
42:07 - every line of code in this function
42:10 - there's a shortcut for this
42:11 - so look over here that is step
42:14 - out the shortcut is shift and f11
42:18 - so if we press shift and f11 we get back
42:21 - to the previous function so this is how
42:24 - we can debug django applications in vs
42:26 - code
42:26 - now once we're done it's always a good
42:29 - practice
42:30 - to remove these breakpoints otherwise
42:32 - they get in the way
42:33 - so as you debug your applications you
42:35 - place various breakpoints in different
42:37 - parts of your code
42:38 - and you will hit them all the time so
42:40 - always remove your breakpoints
42:42 - once you're done with them so we're done
42:44 - with this debugging session
42:45 - now we can disconnect by pressing shift
42:49 - and f5 or clicking on this icon
42:52 - all right now one last tip before we
42:54 - finish this lesson
42:56 - on the top under the run menu look
42:59 - we have a command called run without
43:02 - debugging
43:03 - the shortcut on mac is control and f5 so
43:06 - if we use this shortcut we can start our
43:08 - application
43:09 - without having to run python manage.pi
43:12 - run server let me show you what i mean
43:14 - so
43:15 - first let's bring up our terminal window
43:18 - here's the second terminal window that
43:20 - we use for debugging
43:21 - i'm going to delete this here's the
43:24 - first terminal window where
43:25 - we started our application by running
43:27 - python manage.pi
43:29 - run server so let's press ctrl and c
43:32 - to stop the server good i'm also going
43:35 - to delete this terminal window
43:36 - let's imagine we just opened this
43:38 - project in vs code day one
43:40 - now to run this application without
43:42 - debugging we can press
43:44 - ctrl and f5
43:48 - now our application has started on port
43:50 - 9000
43:51 - so we can go to this address and then
43:54 - hit playground hello
43:57 - so this is how we can run our
43:59 - application without debugging
44:01 - just remember that if you use this
44:02 - command your breakpoints are not going
44:04 - to get hit
44:05 - so if you want to debug your
44:06 - applications you should start it
44:08 - in the debug mode
44:12 - [Music]
44:16 - there is another way to debug django
44:18 - applications using a powerful tool
44:20 - called
44:20 - django debug toolbar so if you go to
44:23 - google and
44:24 - search for django debug toolbar you're
44:26 - going to find this page
44:28 - over here you're going to find the
44:30 - installation instructions
44:31 - so i highly encourage you to follow
44:33 - along with me and repeat the same steps
44:36 - so we installed this toolbar together so
44:39 - first we have to use pip or ppf to
44:41 - install
44:42 - django debug toolbar so back to vs code
44:45 - i'm going to open up a new terminal
44:47 - window
44:49 - and as you can see vs code used the
44:51 - source command to activate our virtual
44:53 - environment
44:54 - so now let's run pipen install
44:58 - django dash debug dash toolbar
45:05 - good now back to the documentation
45:08 - the next step is to add debug toolbar in
45:11 - the list of installed apps
45:13 - in our settings module so back to vs
45:16 - code
45:17 - we can press command and p on mac or
45:19 - control and p on windows
45:20 - to bring up the search box now we search
45:23 - for our settings module
45:25 - good now in the list of install apps at
45:28 - the end
45:29 - we're going to add debug underline
45:31 - toolbar
45:33 - good now the next step
45:36 - the next step is to add a new url
45:38 - pattern in our main url conf module
45:41 - so i'm going to copy this line and back
45:44 - to vs code let's bring up the urls
45:47 - module
45:48 - we're going to pick the one in the
45:49 - storefront folder
45:51 - okay now we add a comma here and paste
45:54 - that line
45:55 - now here we have a compilation error
45:57 - because debug toolbar is a module that
45:59 - we have to import on the top
46:01 - so if you look at the documentation you
46:03 - can see that over here
46:05 - import debug toolbar so copy this and
46:08 - paste it right here
46:10 - good now back to the documentation
46:13 - the next step is to add a middleware we
46:15 - use middleware to hook into django's
46:17 - request response processing
46:19 - so in our settings module we have a
46:21 - setting for middleware
46:23 - we're going to add this line in that
46:26 - file so copy this
46:28 - back to the settings module here we have
46:30 - the install apps
46:31 - right after that you can see the
46:33 - middleware setting
46:35 - so we're going to add that on the top
46:38 - now the final step is to add our ip
46:41 - address
46:42 - in the internal ips setting so for local
46:44 - development
46:45 - we should use 127.001
46:48 - so i'm going to copy this entire setting
46:50 - because by default
46:52 - this doesn't exist in a new django
46:53 - project so copy this
46:56 - and i'm going to paste it anywhere in
46:58 - this settings file it doesn't really
46:59 - matter
47:01 - okay save so we have completed all the
47:03 - steps
47:04 - now back in the browser if you go to
47:06 - this url playground
47:07 - slash hello we don't see the toolbar it
47:09 - should appear here
47:11 - because the toolbar only appears when we
47:13 - return a proper html document
47:16 - if you right click here and look at the
47:17 - page source
47:19 - you can see that we are not returning a
47:21 - proper html document
47:22 - so we don't have the html head and body
47:25 - elements
47:26 - so let's open up hello.html now on the
47:30 - top we type
47:31 - html press tab now inside these elements
47:33 - we're going to add
47:34 - a body and then inside the body
47:38 - we're going to add the code that we had
47:40 - earlier so let's move that right here
47:43 - good now we have a proper html document
47:46 - of course the head element is missing
47:48 - but it doesn't really matter
47:50 - now back to the browser refresh and
47:52 - here's django debug toolbar
47:54 - here we have different panels like
47:55 - history for seeing the urls we have hit
47:58 - so far
47:58 - we have versions to see the version of
48:00 - django python and
48:02 - debug toolbar we're running we have
48:04 - processing time
48:05 - we have our settings we have request
48:08 - headers and so on
48:09 - now my personal favorite panel is the
48:12 - sql or
48:13 - sql panel here we can see the queries
48:15 - that are sent to the database so later
48:17 - in the course
48:18 - where we talk about querying the
48:19 - database using django's
48:21 - object relational mapper we're going to
48:23 - come back to this panel and see
48:25 - what queries django will generate and
48:27 - send to the database
48:28 - so that's it for this lesson we're done
48:30 - with this section in the next section
48:32 - we're going to talk about
48:33 - building a data model so i'll see you in
48:35 - the next section
48:40 - welcome back to another section of the
48:41 - ultimate django course
48:43 - in this section we're going to talk
48:44 - about models which are used to store and
48:47 - retrieve data
48:48 - we'll start off by quick introduction to
48:50 - data modeling to make sure you know the
48:52 - essential concepts
48:53 - then we're going to design the data
48:55 - model for an e-commerce application
48:57 - next we're going to talk about
48:58 - organizing our models in apps to improve
49:01 - reusability
49:02 - this is one of the areas that is often
49:04 - misunderstood so i'm going to demystify
49:06 - it once for all
49:07 - and then we'll spend the rest of this
49:08 - section in coding model classes
49:11 - we'll use these classes to store and
49:13 - retrieve data throughout the course
49:15 - so let's jump in and get started
49:17 - [Music]
49:24 - the first step in every django project
49:26 - is figuring out the pieces of data we
49:28 - want to store
49:29 - so what entities or concepts do we have
49:32 - in an e-commerce application
49:34 - well for starters we need the concept of
49:36 - a product with attributes like title
49:38 - description price and inventory now in a
49:41 - real scenario
49:42 - a product entity might have other
49:44 - attributes it really depends on the
49:46 - requirements of our application
49:48 - for now we just want to keep things
49:49 - simple okay now quite often
49:51 - our products are divided in different
49:53 - categories like shoes
49:55 - beauty products fruits and so on so we
49:57 - need another entity called collection or
50:00 - category with an attribute called title
50:03 - now we need to add a relationship or an
50:05 - association between these entities
50:07 - so we can start from one end and
50:08 - navigate to the other end
50:10 - for example we can get a collection and
50:12 - find all the products in that collection
50:14 - okay now let's assume that in our
50:16 - application
50:17 - a product can belong to one and only one
50:20 - collection
50:21 - and a collection can have multiple
50:23 - products
50:24 - so an asterisk represents many we could
50:26 - also use an
50:27 - n here okay now we have a one-to-many
50:30 - relationship
50:30 - between collection and product so
50:33 - relationships can be one-to-one
50:35 - one-to-many and many too many back to
50:38 - our diagram
50:38 - now over here we can add a label called
50:40 - products and that means
50:42 - when we code these entities or these
50:44 - classes in the collection class we're
50:46 - going to have an
50:47 - attribute called products for now i just
50:49 - want to hide this for simplicity okay
50:51 - now sometimes we can have multiple
50:53 - relationships or
50:54 - multiple associations between two
50:56 - entities so let's imagine that a
50:58 - collection
50:59 - can optionally have a featured product
51:02 - that is the product
51:03 - whose picture we want to show to the
51:05 - user so we can add a second relationship
51:07 - between
51:08 - these entities now look at this number
51:09 - here zero to one means
51:11 - a collection can have zero to one
51:14 - product
51:15 - and we're gonna call that attribute
51:16 - featured product so once again
51:18 - that means in the collection class we're
51:20 - going to have an attribute
51:22 - called featured product okay now you
51:24 - might ask
51:25 - what about the id attribute shouldn't
51:27 - every entity have an id
51:28 - attribute yes but django is going to
51:30 - automatically create that for us
51:32 - that's why i haven't shown it here now a
51:35 - little exercise
51:36 - for you grab a piece of paper and
51:38 - identify the
51:39 - other essential entities we need in an
51:41 - e-commerce application
51:42 - just the bare minimum don't go ahead and
51:45 - create a complex diagram like this
51:47 - i don't want this there are only five
51:49 - entities that i want you to identify
51:51 - so spend a couple minutes and identify
51:53 - these entities along with the attributes
51:55 - and
51:55 - relationships then come back see my
52:02 - solution
52:06 - all right so this is what we ended up
52:07 - with in the previous lesson we have a
52:09 - one-to-many relationship
52:10 - between collections and products now
52:13 - don't take this as a hard and fast rule
52:15 - maybe in your application a product can
52:17 - belong to many collections
52:19 - then you're gonna have a many-to-many
52:21 - relationship between products and
52:23 - collections okay
52:24 - so back to our model i'm gonna remove
52:26 - the collection from here
52:28 - so we have some free space on the screen
52:30 - now what else do we need here
52:32 - well in every e-commerce application we
52:34 - have the concept of a shopping cart
52:36 - right so we're going to have an entity
52:38 - or a model or a class called
52:40 - cart with an attribute called created at
52:43 - let's assume that we need to know when
52:45 - each card is created
52:46 - so every now and then we can do a clean
52:48 - up and remove cards that are 30 days old
52:51 - i just made this up but in a real
52:53 - scenario you should always design your
52:55 - models
52:56 - based on the requirements of your
52:57 - project don't make up your own rules
52:59 - okay
53:00 - now we need a relationship or an
53:02 - association between products and cards
53:04 - because a card can have multiple
53:06 - products and a product might be in
53:08 - different cards
53:09 - so here we have a many-to-many
53:10 - relationship between product
53:12 - and cart now sometimes the relationship
53:15 - between two entities can have
53:16 - attributes for example if a product is
53:19 - in a shopping cart
53:20 - we need to know how many instances of
53:22 - that product we have in the shopping
53:24 - cart
53:24 - so this relationship itself should have
53:26 - an attribute called
53:28 - quantity so we're going to add a new
53:30 - entity here called
53:31 - cart item now look at the notation i've
53:33 - used to represent this concept
53:35 - i've connected cart item to the
53:37 - relationship using a dashed line
53:39 - that means cart item represents the
53:42 - relationship between these two entities
53:44 - product and cart this is what we call an
53:47 - association class
53:48 - so cart item is an association class
53:51 - okay
53:51 - now there's another way to show this
53:53 - instead of using an association class we
53:56 - can add a relationship between
53:57 - cart and cart item because a cart might
54:00 - contain
54:01 - multiple items and an item belongs to
54:03 - one and only one cart
54:06 - similarly we can add a relationship
54:07 - between product and card item because
54:10 - each card item represents
54:11 - a single product and a product might be
54:14 - referenced by
54:15 - many card items so here we have two
54:18 - one too many relationships between these
54:21 - entities
54:21 - now compare this with the association
54:24 - class notation
54:25 - so we can either add a many-to-many
54:27 - relationship with an association class
54:29 - or two one-to-many relationships it's a
54:32 - matter of personal preference okay
54:35 - so we're done with the shopping cart but
54:36 - you might ask what about the user or the
54:38 - customer that owns this cart
54:41 - where is that in the diagram well i
54:42 - haven't connected cart with an entity
54:44 - like
54:44 - customer because we don't want to force
54:46 - people to register and log in
54:48 - before they can add products to their
54:50 - shopping cart okay so there is no
54:52 - relationship between cards and customers
54:54 - so cars are essentially anonymous anyone
54:57 - can have a cart
54:58 - whether they're anonymous users or
55:00 - registered customers okay
55:02 - so we're done with the cart now let's
55:04 - talk about customers
55:06 - so our customer entity can have
55:07 - attributes like name
55:09 - email username password and so on now
55:11 - for simplicity
55:12 - i'm only showing name and email here now
55:15 - a customer can have
55:16 - many orders and each order belongs to
55:19 - one and
55:20 - only one customer so we need a
55:22 - one-to-many relationship between
55:23 - customers and orders
55:25 - now once again the order entity might
55:27 - have multiple attributes
55:29 - for now we just want to know when this
55:30 - order was placed okay
55:32 - now an order can contain multiple
55:34 - products and a product can be in
55:36 - multiple orders
55:37 - so we have a many-to-many relationship
55:39 - between orders and products
55:41 - and similar to the shopping cart example
55:43 - this relationship itself needs
55:44 - attributes
55:45 - so here we need another entity called
55:47 - order item with an attribute called
55:49 - quantity that's our association class
55:52 - alternatively
55:53 - you could add a relationship between
55:55 - order and order item
55:56 - because each order may contain multiple
55:59 - items and each order item
56:01 - belongs to one and only one order
56:04 - similarly an order item references one
56:06 - and only one product
56:08 - while a given product might be
56:09 - referenced by multiple
56:11 - order items so two one-to-many
56:13 - relationships
56:14 - so these are the entities that i wanted
56:16 - you to identify but to make this project
56:18 - more interesting
56:19 - i decided to throw in one more entity
56:22 - tag
56:22 - here we have a minute-to-many
56:24 - relationship between products and tags
56:26 - because the product can have many tags
56:28 - and the tag might be referenced by
56:30 - different products we'll come back to
56:31 - this entity in the next lesson
56:35 - [Music]
56:41 - so i told you that a django project
56:43 - contains one or more apps
56:44 - and just like the apps on your phone
56:46 - each app in a django project provides
56:48 - a specific piece of functionality so
56:51 - that means
56:52 - each app is going to have its own data
56:54 - model so in this lesson we're going to
56:56 - look at a few different ways to
56:57 - organize our entities in different apps
57:00 - one way is to have a single app called
57:01 - the store
57:02 - and drop all of our entities here now we
57:05 - can bundle and distribute this app via
57:07 - pip
57:08 - and this way anyone can install this app
57:10 - in their project
57:11 - and get all these models and the
57:12 - functionality around them
57:14 - so next time we're working on an
57:15 - ecommerce project we don't have to
57:17 - rewrite the same functionality
57:18 - over and over we simply install this app
57:21 - in our project
57:22 - and write extra code for customization
57:24 - great
57:25 - but there's a problem here as this
57:27 - application grows and
57:28 - gets more complex it gets bloated with
57:31 - too many things
57:32 - like too many models too many views and
57:34 - other stuff
57:35 - this is what we call a monolith like a
57:37 - large heavy piece of stone
57:39 - so at some point our application might
57:41 - become hard to understand
57:43 - hard to maintain and hard to reuse it
57:45 - becomes like one of those remote
57:46 - controls with too many buttons
57:48 - when designing these apps we want to
57:50 - follow the unix philosophy
57:52 - so each app should do one thing and do
57:54 - it well
57:55 - so here's another solution we can break
57:57 - down this project into four small apps
58:00 - the products app which represents a
58:02 - product catalog
58:03 - so here we're gonna have three entities
58:05 - product collection
58:07 - and tag then we're going to have the
58:09 - customers app for
58:10 - managing customers we're going to have
58:12 - the shopping cart app
58:13 - for adding the shopping cart
58:14 - functionality and the orders app
58:16 - for adding the ordering functionality
58:19 - not bad right
58:20 - well this is actually a poor way of
58:22 - breaking down this project for a number
58:24 - of reasons
58:25 - look at the coupling or dependency
58:27 - between these apps
58:28 - the orders app is dependent on the
58:30 - shopping cart app which is dependent on
58:32 - the products app
58:33 - so next time we're working on an
58:34 - e-commerce project we'll have to install
58:37 - all these apps one by one first we have
58:39 - to install the products app
58:41 - followed by the shopping cart app the
58:42 - customers app and the orders app
58:45 - ideally each app should be
58:46 - self-contained so we can easily drop it
58:48 - into a new project the other problem is
58:50 - that if we publish a new version of the
58:53 - products app
58:53 - that might cause a breaking change in
58:55 - the shopping cart and
58:56 - subsequently orders apps so anyone using
58:59 - these apps have to upgrade
59:01 - all these apps together again more and
59:03 - more work
59:04 - also it doesn't really make sense to
59:06 - have the shopping cart functionality
59:08 - without having a product catalog right
59:10 - why would we ever want to add the
59:12 - shopping cart functionality to a project
59:14 - without a product catalog so shopping
59:16 - cart functionality and product catalog
59:19 - always go together by the same token
59:22 - why would we ever want to add the
59:23 - shopping cart functionality to a project
59:25 - without the ability to place an order
59:28 - just to allow people to add something to
59:29 - their shopping cart
59:31 - then what again it doesn't really make
59:33 - sense so these concepts are highly
59:35 - related and should be bundled together
59:38 - if we separate them we increase coupling
59:40 - between apps and we end up with the
59:41 - problems i just talked about
59:43 - so does it mean we have to go back to
59:45 - the monolithic design no
59:47 - there is a middle ground here look at
59:48 - the tag entity
59:50 - the ability to tag products is optional
59:52 - we don't necessarily need it in every
59:54 - e-commerce application
59:56 - in fact we might need it in other types
59:58 - of applications like your blog
60:00 - or video platform and so on so tagging
60:03 - is not specific to products or an
60:05 - e-commerce application
60:06 - it's a separate piece of functionality
60:09 - so i'm going to move the tag entity to a
60:11 - separate app called
60:12 - tags and here we're going to have
60:14 - another entity called
60:15 - tagged item which represents an item
60:18 - that is tagged
60:18 - it can be a product an article a video
60:21 - and so on it's an
60:22 - abstract concept now with this
60:24 - separation
60:25 - each app is self-contained and provides
60:28 - a specific piece of functionality
60:30 - so we can use either or both of them in
60:32 - a new project
60:33 - depending on what we're going to build
60:35 - plus we have zero coupling between these
60:37 - apps
60:38 - so we can independently change and
60:39 - deploy them without affecting other apps
60:42 - this is the proper way to break down
60:44 - this project into multiple apps
60:46 - so here's the takeaway if our app
60:49 - boundary is so large
60:50 - we'll end up with a monolith that gets
60:52 - bloated and becomes hard to reuse
60:54 - on the other hand if our app boundaries
60:56 - are so small and fine grained
60:58 - we'll end up with a lot of coupling
61:00 - between them a good design is one with
61:03 - minimal coupling
61:04 - and high cohesion meaning high focus so
61:06 - each app is focused on a specific piece
61:09 - of functionality and
61:10 - includes everything needed to fulfill
61:12 - that piece of functionality
61:13 - okay so back to vs code we're going to
61:16 - create two new apps
61:18 - so we run python manage.pi
61:21 - start app the first app is store
61:24 - and the second one is tags
61:28 - okay now as i told you before every time
61:31 - we create a new app
61:32 - we should add it in the list of
61:34 - installed apps so
61:36 - let's close this window and go to our
61:38 - settings module
61:40 - here's the list of install apps i'm
61:42 - going to add those apps
61:43 - right here so store and tags
61:47 - all right we're done with this step
61:49 - starting from the next lesson we're
61:50 - going to create the model classes for
61:52 - these apps
61:55 - hey guys bosh here i just wanted to let
61:57 - you know that this tutorial you have
61:58 - been watching is
61:59 - actually the first hour of my ultimate
62:02 - django course
62:03 - the complete course is about 10 hours
62:05 - and goes way beyond this tutorial
62:07 - so if you're serious about learning
62:09 - django and are looking for a job as a
62:11 - back-end developer i highly encourage
62:13 - you to enroll in the course
62:14 - the course comes with tons of exercises
62:16 - and solutions
62:17 - a full e-commerce project that you will
62:19 - eventually deploy to the cloud
62:21 - plus a 30-day money-back guarantee and a
62:23 - certificate of completion you can add
62:25 - your resume
62:26 - in case you're interested i'll put the
62:28 - link down below so thank you for
62:30 - watching and i hope to see you in the
62:32 - course
62:35 - you