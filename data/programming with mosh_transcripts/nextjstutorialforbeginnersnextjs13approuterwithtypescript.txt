00:00 - [Music]
00:00 - foreign welcome to the ultimate nexjs
00:04 - course in this course you will learn
00:06 - everything you need to know about nexjs
00:08 - from the basics to more advanced
00:09 - concepts so by the end of the course
00:11 - you'll be able to confidently build fast
00:14 - and scalable applications with the xjs
00:16 - if you have been searching for a
00:18 - comprehensive easy to follow
00:20 - well-organized and practical course that
00:22 - takes you from Zero to Hero this is the
00:24 - right next.js course for you you don't
00:26 - need any prior knowledge of next.js to
00:28 - get started everything you need is right
00:30 - here so you won't need to jump back and
00:32 - forth between random tutorials but
00:34 - here's the catch unlike other courses
00:36 - we're not just building a dummy app
00:38 - we'll be building a beautiful full stack
00:41 - production grade app for tracking issues
00:43 - an app complete with all the features
00:46 - and UI patterns you would expect in
00:48 - modern applications on the home page we
00:50 - have this beautiful dashboard that
00:52 - displays the latest issues and their
00:54 - status and all of this data is stored in
00:56 - a mySQL database we can go to the issues
00:59 - page we can filter issues
01:02 - sort them
01:04 - and go to different pages
01:08 - we can click on an issue to see more
01:09 - details we can assign an issue to a user
01:12 - so here we have full authentication and
01:14 - authorization
01:16 - we can edit an issue
01:18 - and here we have this beautiful markdown
01:20 - editor
01:21 - we can also delete an issue and here we
01:24 - get this confirmation dialog box
01:27 - we'll be building this application using
01:29 - a Cutting Edge stack next she has 13
01:31 - Tailwind Radix UI Prisma react query
01:35 - reactbook forms Zod and more and don't
01:39 - worry if some of these tools are alien
01:40 - to you just like my other courses I will
01:43 - walk you through each one explaining the
01:44 - what the why and the how so if you
01:47 - follow along you will master nexjs and
01:50 - we'll be able to build full stack
01:51 - applications with confidence
01:53 - a software engineer with over 20 years
01:56 - of experience and I've taught Millions
01:58 - how to code and become professional
02:00 - software Engineers through my YouTube
02:02 - channel and online school
02:04 - codewitmarsh.com if you are new here
02:06 - make sure to subscribe as I upload new
02:08 - videos all the time now let's jump in
02:10 - and get started
02:12 - [Music]
02:18 - all right so what exactly do you need to
02:19 - know to take this course well to take
02:22 - this course you don't need any prior
02:23 - knowledge of next.js because I'm going
02:25 - to teach you everything from the ground
02:27 - up however you need to have basic
02:29 - familiarity with react and typescript
02:31 - because next.js is a react framework and
02:34 - if you don't know react you are not
02:36 - really the right student for this course
02:37 - now if you want to learn react I have a
02:40 - great tutorial on my YouTube channel the
02:42 - link is below this video I also have a
02:44 - comprehensive course that goes way
02:46 - beyond that it teaches you everything
02:48 - you need to know to build modern
02:49 - applications with react 18 and
02:52 - typescript the full course is 14 hours
02:54 - divided into two parts so you can easily
02:57 - finish each part in this course you will
02:59 - learn how to build this beautiful
03:01 - application for discovering video games
03:03 - here we have all the common UI patterns
03:06 - you see in real applications like
03:08 - filtering sorting infinite Scrolls and
03:11 - so on again in case you are interested
03:13 - the link is below this video
03:17 - welcome back to our next chess course in
03:21 - this section we'll be talking about the
03:22 - fundamentals of nexjs first I will
03:25 - explain what exactly next.js is and why
03:28 - is it so popular shortly after we'll set
03:31 - up our development environment and
03:32 - create our first next.js project from
03:35 - there we'll talk about some foundational
03:37 - Concepts such as client and server
03:40 - components data fetching caching as well
03:43 - as static and dynamic rendering this
03:45 - section is a great introduction to
03:47 - next.js so let's jump in and get started
03:50 - [Music]
03:59 - so you might be wondering what is this
04:02 - next JS thing everyone is talking about
04:04 - and why should I bother with it well
04:06 - next.js is an incredibly powerful
04:09 - framework for building fast and search
04:11 - engine friendly applications it's built
04:14 - on top of react so everything you have
04:16 - learned about react is still relevant
04:18 - but nexjs takes web development to the
04:20 - next level wild react is just a library
04:23 - for creating interactive user interfaces
04:25 - next.js is a comprehensive framework
04:28 - think of a framework as a collection of
04:30 - libraries tools and conventions that
04:33 - streamline application development for
04:36 - instance next.js includes its own
04:39 - routing Library so we don't need to use
04:41 - a separate Library like react router in
04:44 - terms of tooling it comes with a
04:46 - compiler for transforming and minifying
04:49 - our JavaScript code a command line
04:51 - interface for building and starting our
04:53 - application and a node.js runtime
04:57 - now you might wonder what exactly is a
04:59 - node.js runtime well there are two main
05:02 - ways we can execute JavaScript code
05:04 - within a web browser on the client side
05:06 - or within a node.js runtime on the
05:09 - server so a node.js runtime is just a
05:12 - fancy term for a program that can
05:14 - execute JavaScript code so next JS comes
05:17 - with a node.js runtime and this allows
05:20 - us to do some really cool things the
05:22 - first thing is that we can do full stack
05:24 - development so we can write both the
05:27 - front end and back-end code within the
05:29 - same nyxjs project the backend code gets
05:32 - executed within the node.js runtime and
05:35 - the front-end code gets bundled and sent
05:38 - to the client for execution within a web
05:40 - browser in contrast when building
05:43 - applications with react we have to
05:45 - maintain a separate backend project in a
05:48 - potentially different programming
05:49 - language this node.js runtime also
05:52 - allows us to render our components on
05:54 - the server and send their content to the
05:56 - client this technique is called
05:58 - server-side rendering or SSR and can
06:01 - make our applications faster and more
06:04 - search engine friendly we'll talk about
06:06 - it in detail later in the course but
06:08 - wait there's more with next.js we can
06:11 - pre-render certain pages and components
06:14 - that have static data when we build our
06:16 - application we just render them once and
06:19 - serve them whenever they are needed this
06:21 - technique is called Static site
06:23 - generation and can make our applications
06:25 - super fast
06:27 - so in a nutshell next.js is a framework
06:30 - for building super fast and search
06:32 - engine friendly applications
06:35 - [Music]
06:41 - all right now let's talk about setting
06:42 - up our development environment to run
06:44 - next.js you should have node version
06:47 - 16.8 or higher
06:49 - so head over to nodejs.org and download
06:51 - the latest version
06:53 - now in this course I will be using vs
06:55 - code as my editor just like my other
06:57 - courses you're welcome to use your
06:59 - preferred editor but I encourage you to
07:01 - use vs code because along the way I'll
07:03 - be sharing a lot of tips and techniques
07:05 - for writing code fast
07:07 - so you can get vs code from
07:09 - code.visualstudio.com
07:11 - now here in vs code window let's talk
07:14 - about the extensions I'm going to use in
07:16 - this course
07:17 - so in this panel search for es7
07:22 - all right look at this extension
07:24 - es7 plus react Redux and react native
07:28 - this extension gives us a bunch of code
07:31 - Snippets so we can quickly and easily
07:33 - generate react components the next
07:36 - extension is typescript
07:40 - is this one here JavaScript and
07:42 - typescript nightly
07:44 - and the last one is
07:47 - Tailwind CSS
07:50 - intellisense
07:52 - now if you have never worked with Telvin
07:53 - before don't worry it's super easy and
07:56 - I'm going to hold your hands through the
07:57 - entire course
07:59 - [Music]
08:04 - all right to create our first nexgs
08:07 - project open up a terminal window and
08:09 - run npx create Dash next Dash app add
08:14 - you can use the latest version but in
08:17 - this course I'm going to use version
08:19 - 13.4 so I strongly recommend you to use
08:22 - the same version so you don't have any
08:24 - difficulties going through the course
08:25 - let's go ahead
08:28 - now it's asking if you want to install
08:30 - this package create next app version
08:33 - 13.4.13 let's proceed
08:37 - all right now it's going to ask us a
08:39 - bunch of questions about our new project
08:41 - the first question is the name of our
08:43 - project I'm going to use next Dash app
08:47 - the next question is if you want to use
08:49 - typescript in this project the default
08:51 - answer is yes so let's press enter to
08:54 - accept it the next question is about
08:56 - using eslint which is a common code
08:59 - analysis tool that we can use to find
09:01 - common errors like syntax errors
09:03 - formatting issues and so on again we're
09:05 - going to accept the default value which
09:07 - is yes
09:08 - the next question is about using
09:09 - Tailwind CSS one more time you're going
09:12 - to accept yes the next question is about
09:14 - using the source directory a lot of
09:16 - next.js projects don't use the source
09:19 - directory so I'm going to select no here
09:21 - the next question is about using the new
09:24 - app router I'm going to talk about this
09:26 - later in this section but very briefly
09:28 - in Nexus 13 we have two types of routers
09:31 - we have the new app router and the
09:34 - Legacy Pages router in this course we're
09:36 - going to use the new app router so let's
09:39 - select yes the last question is about
09:42 - customizing the default import aliens
09:44 - we're going to select no
09:46 - all right now it's going to install all
09:49 - these dependencies so you see we have
09:51 - react react on next typescript and so on
09:57 - all right all of our dependencies are
09:59 - installed so now let's go into this
10:01 - folder
10:02 - and run npm run Dev
10:07 - this starts at development server on
10:09 - Port 3000 so let's control and click on
10:13 - this link
10:15 - and this confirms that our first next.js
10:18 - project is open running
10:21 - [Music]
10:26 - let's talk about the key files and
10:28 - folders in this project so at the top we
10:31 - have the app folder or this is also
10:33 - called the app router this is the
10:36 - container for our routing system so in
10:38 - next.js our router is based on the file
10:40 - system so unlike react router we don't
10:43 - have to configure our routes and map
10:45 - them to our components we can simply
10:47 - create files and folders to represent
10:50 - our routes we'll talk about them in the
10:52 - next lesson so in the app folder we have
10:54 - a favorite icon we have our Global CSS
10:57 - file a layout file which is a basic
11:00 - react component that returns an HTML and
11:03 - body element this represents the common
11:05 - layout for our Pages now inside the body
11:08 - element we have children which is
11:10 - replaced by a page dynamically at
11:12 - runtime depending on where the user is
11:14 - in our application
11:16 - now in this folder we also have a page
11:18 - file page.tsx this represents our home
11:21 - page now for this demo let's delete
11:24 - everything here
11:25 - and
11:28 - replace it
11:30 - with a simple markup so we're going to
11:32 - return a main element inside main we
11:36 - want to add an H1 and say hello world
11:39 - now back to the browser
11:41 - here we have fast refresh so anytime we
11:43 - make any changes to our typescript or
11:45 - css files the changes are reflected
11:48 - immediately now here we have a bit of
11:50 - styling issue because there is a
11:52 - gradient a linear gradient applied to
11:55 - the body element
11:56 - so let's go to our Global CSS file
11:59 - down the bottom look at the Styles
12:02 - applied to the body element
12:04 - the background attribute is set to a
12:06 - linear gradient and that is why we have
12:09 - this weird style here so simply remove
12:11 - the background attribute and the issue
12:15 - goes away beautiful now I want to apply
12:18 - a padding here so the content is not so
12:20 - close to the edges of the screen
12:22 - so let's add padding to
12:25 - one REM
12:27 - okay
12:29 - that is better
12:30 - so we're done with the app folder
12:33 - now in this project
12:35 - after that folder we have the public
12:37 - folder this is where we can put our
12:39 - popping assets like images in this case
12:41 - we have two SVG files here which are
12:44 - vector graphics one is next the other is
12:47 - verisal which is the company that has
12:49 - created nexjs now in the root we have a
12:53 - bunch of configuration files we have one
12:55 - for eslint another for next post CSS
12:59 - tailwind and typescript for the most
13:02 - part we don't have to touch this
13:04 - configuration files but if the situation
13:06 - changes in the future we'll come back
13:07 - and revisit them
13:10 - thank you
13:13 - [Music]
13:15 - all right I told you that routing in xjs
13:18 - is based on the file system so here in
13:21 - the app folder we can create a new
13:24 - folder called users now to make this
13:28 - publicly accessible here we should add a
13:31 - page file in this folder so page dot now
13:35 - the extension can be JS jsx or TSX or
13:39 - typescript in this course we use
13:41 - typescript so I'm going to go with TSX
13:43 - now make sure to name this file
13:46 - correctly page in lowercase because this
13:49 - is one of the conventions that nexjs
13:51 - looks for so the routing system in xjs
13:54 - is based on convention not configuration
13:57 - okay
13:58 - so here we have a page file now in this
14:01 - page file we should export a react
14:03 - component that will be rendered when the
14:05 - user is at this location slash users
14:09 - earlier we installed a very useful
14:11 - extension in vs code with that extension
14:13 - we can generate a react component using
14:16 - this shortcut r a f c e that is short
14:20 - for react Arrow function component with
14:23 - an export now the way I remember this is
14:26 - Raf C okay
14:28 - so that's generated beautiful now here
14:31 - we have multiple cursors activated so we
14:34 - can rename this component to something
14:36 - more meaningful like users page
14:39 - the name we assign here it doesn't
14:40 - really matter in terms of routing this
14:42 - is just for better organization of our
14:44 - code okay now let's press escape to
14:47 - deactivate multiple cursors so back to
14:50 - the browser now let's go to slash users
14:54 - and here's our new users page beautiful
14:57 - now one thing you need to know about
14:59 - this routing system is that if you add
15:01 - any other files in this folder let's say
15:04 - test.css this file is not going to be
15:07 - accessible so if you go to slash users
15:10 - slash test.css
15:13 - look we get this not found page so this
15:16 - is how the new app router is different
15:18 - from the old Pages router in the pages
15:21 - router if we put any files in these
15:24 - folders those files would be publicly
15:26 - accessible but this is not the case with
15:28 - the new router okay
15:30 - so let's delete this file
15:33 - now here we can also create nested
15:35 - routes so inside the users folder we can
15:39 - add a new folder called new
15:41 - and in this folder we add
15:43 - a new page file so page.tsx
15:47 - one more time let's create a react
15:50 - component and we're going to call this
15:52 - new user page
15:56 - good so now we can go to users Slash new
16:01 - and see this new page beautiful
16:03 - now let's talk about navigation so we're
16:06 - going to go back to our home page
16:08 - so here we press command and P on Mac or
16:11 - Ctrl mp on Windows to look up files by
16:14 - their name if we type page we can see
16:17 - all our page files so the first item is
16:20 - our home page this is the one we are
16:21 - looking for
16:22 - now on this page let's add
16:26 - an anchor
16:27 - so here we have
16:29 - an anchor we set href to slash users
16:32 - and give it a label like users
16:35 - now there is a problem with this way of
16:38 - implementing navigation let me show you
16:40 - so let's go back to our home page
16:44 - all right now I'm going to open up
16:46 - devtools
16:48 - here in the network tab look at all the
16:50 - requests sent to the server the first
16:53 - one is our HTML document the second one
16:56 - is a font the third one is a CSS file
16:58 - and after that we have a bunch of
17:01 - JavaScript files now I'm going to clear
17:04 - this list
17:05 - look what happens when we click on the
17:08 - user's link
17:10 - let's go back to the network tab look
17:12 - all these resources are redownloaded
17:15 - this is not the optimal way to implement
17:18 - navigation because in the real
17:19 - application we probably have a
17:22 - navigation bar on the top the side panel
17:24 - on the left so as the user navigates
17:26 - from one page to another we don't want
17:28 - to reload all these repetitive parts we
17:31 - only want to replace the content area
17:33 - right this is where we use the link
17:35 - component in next.js so back to our code
17:39 - we're going to replace this anchor with
17:42 - a link component that is defined in next
17:45 - slash link Library
17:48 - okay let's replace it here as well
17:50 - good now back to our home page once
17:54 - again I'm going to bring up the network
17:55 - Tab and clear this list
17:59 - now look what happens when we click on
18:01 - the user's link
18:03 - look we only have two requests and these
18:06 - requests are for downloading the content
18:08 - of the users page so we are not
18:10 - re-downloading a font a CSS file and a
18:13 - bunch of JavaScript files this is what
18:15 - we call client-side navigation now there
18:18 - is more to navigation we have a
18:19 - comprehensive section about this topic
18:21 - later in the course this was just a
18:23 - basic overview
18:25 - [Music]
18:30 - in the next rest projects we have two
18:33 - environments where we can render our
18:35 - components and generate HTML markup
18:37 - either on the client within a web
18:40 - browser or on the server within a
18:43 - node.js runtime rendering components on
18:45 - the client is similar to how react
18:48 - applications work we refer to this
18:50 - technique as client-side rendering or
18:52 - CSR on the flip side we have server-side
18:56 - rendering or SSR where components are
18:59 - rendered on the server so what are the
19:01 - differences well with client-side
19:03 - rendering we have to bundle all our
19:05 - components and send them to the client
19:07 - for rendering this means as our
19:09 - application grows so does our bundle
19:12 - size because it must contain all of our
19:14 - components now the larger the bundle the
19:17 - more memory we need on the client to
19:19 - load all these components so this
19:21 - approach is resource heavy the other
19:23 - problem is that search engine bot Parts
19:25 - which are machines that browse and index
19:28 - our websites can't view our content
19:30 - because they can't execute JavaScript
19:32 - code so they cannot render our
19:34 - components like a web browser and last
19:37 - but not least any sensitive data we have
19:39 - in our components or their dependencies
19:41 - like API keys will be exposed to the
19:44 - client now if we render our components
19:47 - on the server we can get rid of all
19:49 - these problems we only send the
19:51 - essential components to the client and
19:53 - prevent our bundle from becoming
19:55 - unnecessarily large also because the
19:58 - server handles most of the rendering we
20:00 - need less resources on the client plus
20:02 - because rendering is done on the server
20:04 - and we send the actual content to the
20:07 - client search engine Bots can view and
20:09 - index our pages and finally we can keep
20:12 - sensitive data like API keys on the
20:15 - server so these are all the great
20:17 - benefits of server-side rendering
20:20 - however with server-side rendering we
20:22 - lose interactivity so server components
20:25 - which are components that are rendered
20:27 - on the server cannot listen to browser
20:29 - events like Click Change submit and so
20:32 - on they cannot access browser apis like
20:35 - the local storage they cannot maintain
20:37 - state or use effects these
20:40 - functionalities are only available in
20:42 - client components so in real-world
20:45 - applications we often use a mixture of
20:47 - server and client components we should
20:50 - default to server components and use
20:52 - client components only when we
20:54 - absolutely need them here is an example
20:56 - let's imagine we want to build a page to
20:59 - show a list of products to build this
21:01 - page we probably need several components
21:03 - like navbar sidebar product list product
21:07 - card pagination and footer now in
21:10 - standard react applications we have to
21:12 - package all these components and send
21:15 - them to the client for rendering but in
21:17 - next.js we can keep all these components
21:19 - on the server and minimize the bundle
21:22 - size there is just one exception to add
21:24 - a product to a shopping cart we need to
21:26 - handle the click event of a button
21:28 - typically we implement this
21:30 - functionality in the product card
21:31 - component so we have to make it a client
21:34 - component that's one option but there is
21:36 - a better way we can keep this component
21:39 - on the server and do most of the
21:41 - rendering there and instead extract a
21:43 - small component that only contains the
21:46 - add button with this change we only ship
21:49 - that tiny component to the client and
21:51 - keep everything else on the server let's
21:54 - see this in action back to our project
21:56 - in next.js all components inside the app
21:59 - folder are server components by default
22:02 - so that means all the pages we have
22:04 - created so far these are server
22:06 - components and are rendered on the
22:09 - server let me show you so back to the
22:11 - browser let's bring up the network Tab
22:14 - and look at the first request this is
22:17 - the HTML document that we get from the
22:19 - backend so look we have our content here
22:22 - we have our hello world and the user's
22:24 - link this is exactly what search engine
22:27 - Bots see when they browse our website in
22:30 - contrast if we used client-side
22:32 - rendering which is how standard react
22:34 - applications work search engine Bots
22:36 - wouldn't be able to see our content they
22:38 - would see a blank page because all
22:40 - components all the content is rendered
22:43 - on the client okay
22:45 - so back to our project all components
22:48 - inside the app folder are server
22:50 - components by default now if you have
22:52 - worked with nextjs before I should
22:54 - mention that the pages router doesn't
22:56 - support server components so going
22:58 - forward you should stop using it and
23:01 - switch to the new app router okay
23:03 - now let's create a new folder here
23:06 - called components earlier I told you
23:09 - that this folder is not publicly
23:12 - accessible unless we have a page file
23:14 - inside it so that means we can co-locate
23:17 - our project files like our components
23:19 - and other building blocks with our Pages
23:22 - we can put them next to each other and
23:24 - this is perfectly fine so here in the
23:26 - components folder let's add
23:29 - a new file called Product card.tsx
23:33 - here we create a basic react component
23:36 - now earlier I told you that server
23:39 - components cannot have interactivity so
23:42 - they cannot handle browser events like
23:44 - Click Change and so on so that means if
23:47 - we add a button here
23:50 - and handle the click event we get a
23:54 - runtime error let me show you so let's
23:57 - pass a basic error function
23:59 - and log something on the console
24:03 - and we set the label to add to cart
24:06 - now let's add this component to our home
24:08 - page
24:09 - so we go to our first page file
24:12 - and add our new product card component
24:17 - now back to the browser look we got an
24:19 - error saying event handlers cannot be
24:22 - passed to client component props if you
24:25 - need interactivity consider converting
24:28 - part of this to a client component now
24:30 - here we have two options one option is
24:33 - to make this entire component a client
24:35 - component so we go to the top
24:37 - and use the client directive so in
24:41 - quotes we type use client that's all we
24:44 - have to do with this we tell the Nexus
24:46 - compiler to include this file or this
24:49 - component in our JavaScript bundle and
24:52 - that means if this component is
24:54 - dependent on other components those
24:56 - components will automatically become
24:58 - client components and will be included
25:01 - in our JavaScript bundle so we don't
25:03 - have to repeat this directive on every
25:05 - client component okay so here's one
25:07 - option now if you go back to the browser
25:10 - the error is gone but there is a better
25:12 - way to make our applications faster and
25:15 - more search engine friendly we want to
25:17 - render our components on the server as
25:19 - much as possible and use client
25:21 - components only when absolutely
25:23 - necessary so here our product card could
25:27 - have some complex markup we want to
25:29 - render all that markup on the server and
25:32 - move this button to the client
25:34 - so I'm going to extract this button and
25:36 - put it inside a separate component so
25:40 - here in the components folder let's add
25:42 - a new file
25:44 - add to cart
25:47 - again we create a basic react component
25:49 - on the top
25:52 - we use the client directive and then we
25:55 - move
25:56 - this button to our new component
26:00 - like this okay so now we have a client
26:04 - component and we're going to use this in
26:07 - our product card
26:10 - okay
26:11 - with this we can remove use client from
26:15 - this file so this component will be
26:16 - rendered on the server and that means
26:19 - where we have a client component in this
26:21 - case where we have this button there is
26:23 - going to be a hole or a slot where react
26:26 - will later inject our client component
26:28 - okay now if you go back to the home page
26:31 - again we don't see any errors so this is
26:33 - how we can create and use client and
26:35 - server components
26:38 - hey guys I hope you've been having fun
26:40 - watching this tutorial I just wanted to
26:42 - mention that this tutorial is the first
26:44 - hour of my complete next JS course so
26:47 - after you finish this if you want to
26:49 - learn more I highly recommend you to
26:51 - enroll in the full course because it's
26:53 - much faster and easier than jumping
26:55 - between a bunch of random disconnected
26:57 - tutorials here on YouTube the full
26:59 - course is 5 hours long and teaches you
27:02 - everything you need to build full stack
27:04 - applications with nexjs it also comes
27:07 - with a certificate of completion and a
27:09 - 30-day money-back guarantee so if you're
27:11 - not happy ask for a full refund you get
27:14 - all your money back no questions asked
27:15 - in case you are interested the link is
27:18 - below this video
27:19 - [Music]
27:24 - now there are two ways we can fetch data
27:27 - we can fetch it on the client or on the
27:29 - server to fetch data on the client we
27:32 - typically use the state hook to declare
27:34 - a state variable and the effect hook to
27:36 - call the back end get the data and put
27:39 - into our state variable now in my react
27:41 - course I talked about react query as a
27:43 - better alternative to manually using the
27:46 - state and effect hooks but regardless of
27:48 - how we fetch data fetching data on the
27:51 - client in client components has all the
27:53 - problems we talked about in the previous
27:55 - lesson so over time our bundles would
27:57 - get larger because we have to ship more
28:00 - and more components to the client also
28:02 - this approach is resource intensive
28:04 - because all the rendering is done on the
28:06 - client plus our content or our data is
28:10 - not visible to search engines and this
28:12 - approach is less secure because our API
28:15 - keys or any kind of sensitive data will
28:17 - end up on the client but there is one
28:19 - extra a problem the problem is that with
28:21 - this approach there is always an extra
28:24 - round trip to the back end so when a
28:26 - react application loads first the
28:28 - browser downloads the HTML template as
28:31 - well as the CSS and JavaScript files
28:33 - from the back end then it will send an
28:36 - extra request to fetch data from the
28:38 - back end so there's always an extra
28:41 - round trip to the back end now we can
28:43 - fetch data in our server components and
28:45 - get rid of all these problems let me
28:48 - show you
28:49 - in this lesson we're going to use Json
28:51 - placeholder to get some dummy data into
28:54 - our application in case you are not
28:55 - familiar with Json placeholder it's a
28:58 - fake API for getting some dummy data so
29:01 - head over to
29:02 - jsonplaceholder.typeyoucode.com
29:05 - on this page you will find various
29:07 - endpoints for getting dummy data like a
29:10 - list of posts comments albums photos
29:13 - to-do's and users in this lesson we're
29:16 - going to get a list of users into our
29:18 - application
29:19 - so look each user object has a bunch of
29:21 - properties like ID name username and so
29:24 - on so back to our project
29:27 - let's go to the app folder and then open
29:30 - the users folder and then go to this
29:33 - page
29:34 - now this is a server component and in
29:36 - server components we can use the fetch
29:39 - function that you're probably familiar
29:41 - with
29:42 - this function is defined in browsers and
29:44 - with this we can send HTTP requests to a
29:47 - backend
29:48 - so here we pass the URL of our endpoint
29:51 - which we grab from here so copy and
29:55 - paste it
29:56 - now this returns a promise so we have to
29:58 - await it
30:00 - to get the response now because we are
30:03 - using ubaid here we have to make this
30:04 - component async
30:06 - now this is the beauty of this approach
30:08 - with this approach we don't have to use
30:10 - a state variable we don't have to use
30:12 - the effect hook with zero dependencies
30:14 - there's no ceremony we just call fetch
30:17 - to get the data and all of this happens
30:19 - on the server you will see that in a
30:22 - minute so we get the response then we
30:24 - call response.json
30:27 - this also returns a promise so we'll
30:30 - rate it to get the data in this case our
30:33 - users
30:34 - next we map these users to a bunch of
30:37 - list items exactly like how we render
30:39 - them in a react application
30:42 - so for our markup let's replace this div
30:45 - with a fragment here we add an H1
30:48 - called users
30:50 - then we add an unordered list and here
30:52 - we map
30:53 - these users
30:55 - we grab each user now if you type user
30:58 - dot look we don't see anything because
31:00 - the compiler doesn't know about the type
31:03 - of these user objects so if you hover
31:05 - our Mouse over this constant look the
31:08 - type of this constant is any which means
31:10 - we don't know it could be anything this
31:12 - is where we can use some typescript
31:14 - magic to improve our code
31:16 - so outside of this component
31:19 - we Define an interface or a type called
31:23 - user
31:25 - and here we say that each user has a
31:27 - property called ID of type number it
31:31 - also has name of type string and so on
31:33 - we could list all the properties we have
31:36 - here but that is not necessary for this
31:37 - lesson so we're going to keep things
31:39 - simple so with this interface we're
31:41 - defining the shape of our user objects
31:44 - okay
31:45 - now where we declare this constant
31:48 - we annotate it with its type which is
31:51 - user array okay with this
31:55 - when we type user Dot
31:58 - we can see the properties of user
32:00 - objects so this is the benefit of using
32:02 - typescript with typescript we get all
32:05 - the completion when we are coding and
32:07 - also if you have any kind of Errors like
32:09 - typos we can cache those errors at build
32:11 - time before we run and deploy our
32:14 - application okay
32:16 - so here we're going to map each user to
32:18 - a list item
32:19 - first we give it a key
32:21 - which we set to user.id
32:23 - and here we render
32:25 - user.name that's all we had to do so our
32:29 - code is simpler there is no State and
32:31 - effect hook here our bundle is going to
32:33 - be smaller because this component will
32:36 - be on the server
32:37 - now back to the browser let's go to the
32:40 - users page here's our users beautiful
32:42 - now let's bring up the network tab
32:45 - and refresh the page so take a look at
32:49 - the document that we received from the
32:51 - backend so all our users are rendered
32:54 - right here this is because rendering is
32:56 - happening on the server in contrast in
32:59 - typical react applications or wherever
33:02 - we use client-side rendering the browser
33:04 - initially gets a blank document then it
33:07 - will call the backend to fetch the data
33:09 - and then render the content so there's
33:12 - always an extra round trip to the back
33:14 - end and our application is not search
33:16 - engine friendly so to fetch data
33:19 - whenever possible we should fetch it in
33:21 - server components
33:23 - [Music]
33:29 - fetching in server components has an
33:32 - extra benefit and that is caching what
33:34 - is caching well the idea of caching is
33:37 - to store data somewhere that is faster
33:39 - to access basically there are three
33:41 - places where we can get the data from we
33:44 - can get it from the memory from the file
33:46 - system or from the network now as we go
33:49 - down this list getting data becomes
33:51 - slower for example getting data from the
33:53 - network is always slower than getting it
33:56 - from the file system for this reason
33:58 - nexjs comes with a built-in data cache
34:02 - so whenever we use the fetch function to
34:05 - get some data next.js will automatically
34:07 - store the result in its data cache which
34:10 - is based on the file system so the next
34:12 - time we need the same piece of data the
34:15 - next time we hit the same URL next.js is
34:18 - not going to go to Json placeholder it's
34:20 - going to get the data from its data
34:22 - cache from the file system of course we
34:25 - have full control over this caching
34:26 - Behavior if you have data that changes
34:29 - frequently we can disable caching or
34:31 - treat data in Cache as fresh for a
34:34 - certain period of time let me show you
34:37 - so here when we call the fetch function
34:39 - we can pass a second argument which is
34:41 - an options object let me put this on a
34:45 - new line so we can see clearly
34:48 - in this object we can set cache to no
34:51 - store
34:52 - to disable caching that's one option and
34:55 - this is useful if you have data that
34:57 - changes frequently in those situations
34:59 - we always want to show fresh data to our
35:02 - users right the other option is to keep
35:05 - data fresh for a certain period of time
35:07 - to do that instead of sending cash to no
35:10 - store
35:11 - we set next to an object
35:14 - in this object we can specify
35:16 - configuration parameters that are
35:18 - specific to nexjs so here we can set
35:20 - revalidate to Value like 10
35:24 - and this means next.js is going to run a
35:27 - background job and get fresh data from
35:29 - the backend every 10 seconds so this is
35:32 - how caching Works in next.js now one
35:35 - thing you need to know is that this
35:37 - caching behavior is only implemented in
35:39 - the fetch function so if you use a
35:42 - third-party Library like axis you're not
35:44 - going to get this you're not going to
35:46 - get the data cache
35:48 - [Music]
35:53 - in next ways we have another performance
35:56 - optimization technique called Static
35:59 - rendering or static site generation the
36:02 - idea of static rendering is that if you
36:04 - have Pages or components that have
36:06 - static data we can have an xjs render
36:09 - them once when we build our application
36:11 - for production so next time those pages
36:13 - or components are needed next.js is not
36:16 - going to re-render them it's going to
36:18 - get their payload or content from its
36:21 - cache which is based on the file system
36:23 - this is static rendering meaning
36:25 - rendering at build time in comparison we
36:28 - have Dynamic rendering which happens at
36:31 - request time let's see this in action
36:33 - so back to our users page let's add a
36:36 - timestamp above the list of users so
36:39 - here we add a paragraph and render
36:42 - first we create a new data object and
36:44 - then call to Locale time string with
36:48 - this we can see when this page was
36:50 - rendered now back in the browser let's
36:53 - refresh a few times so look the
36:55 - timestamp is changing this only happens
36:58 - in development mode but if you build
37:00 - this application for production you will
37:02 - see that the timestamp is not going to
37:04 - change because next.js will treat this
37:07 - page as a static page and here's the
37:09 - reason earlier I told you that by
37:12 - default whenever we use the fetch
37:14 - function next.js will cache the data so
37:17 - it treats our data as static or
37:19 - unchanging data so when rendering this
37:22 - page next.js is that this page has
37:24 - static data so it decides to render this
37:27 - page statically at build time but if we
37:30 - disable caching next.js thinks the data
37:33 - on this page is going to change so it's
37:35 - not going to render this page statically
37:37 - it's going to render it at request time
37:39 - to see this action let's go back to the
37:42 - terminal window
37:43 - stop this process
37:45 - now earlier we used npm run Dev to start
37:48 - this application in our development
37:50 - server now to build this for production
37:52 - we run npm run build
37:58 - alright here you can see all the routes
38:00 - that are generated when we build our
38:03 - application for production
38:04 - so this is our root route or the home
38:06 - page we have a route for our favorite
38:08 - icon we have one for the users page
38:11 - another for the users Slash new page and
38:13 - so on now look at the icon before each
38:16 - of these routes here we only see circles
38:19 - now down here you can see that a circle
38:21 - means static so these pages are
38:24 - automatically rendered as static HTML
38:27 - now if you start this application in
38:30 - production which we can do by running
38:32 - npm start
38:34 - and then go back to the browser let's
38:36 - refresh look the timestamp is not
38:39 - changing because this page was rendered
38:41 - statically at build time
38:43 - now back to this page let's disable
38:45 - caching and rebuild this application for
38:48 - production
38:49 - so as a second argument we pass an
38:51 - options object and here we set cache to
38:54 - no store
38:56 - okay now back to the terminal let's stop
38:59 - this process
39:00 - and rebuild the application
39:06 - lovely now look at the icon
39:09 - before the user's route instead of a
39:12 - circle we have a Lambda and down here
39:14 - you can see that Lambda means rendering
39:17 - on the server so server side renders at
39:20 - runtime
39:21 - now let's start the application in
39:23 - production
39:25 - back to the browser let's refresh now
39:28 - look every time we refresh the timestamp
39:30 - changes let's recap everything I've
39:33 - learned about rendering in next.js
39:35 - rendering can happen on the client or on
39:38 - the server if it happens on the server
39:40 - it can happen at build time which is
39:42 - called Static rendering or at request
39:45 - time which is called Dynamic rendering
39:47 - so that brings us to the end of this
39:49 - section in the next section we'll talk
39:51 - about styling next.js applications so I
39:55 - will see you there
39:58 - welcome back to our next chess course in
40:01 - this section we'll explore various ways
40:03 - to style our applications and make them
40:05 - beautiful we'll cover Global Styles CSS
40:09 - modules tailwind and Daisy UI so let's
40:12 - jump in and get started
40:16 - [Music]
40:22 - earlier in the course we briefly talked
40:24 - about our Global style shade in the app
40:27 - folder so let's open up globals.css
40:31 - in this file on the top we have three
40:33 - directives to import the base styles
40:35 - from Tailwind now we're going to talk
40:37 - about Tailwind later in this section but
40:39 - very briefly Tailwind is a very popular
40:42 - CSS framework okay
40:44 - then after that we have this root
40:46 - selector this is where we typically
40:49 - Define custom properties like foreground
40:51 - RGB and so on
40:53 - then we have media prefers color scheme
40:56 - dark with the CSS feature which is
40:58 - relatively new we can detect if the user
41:01 - is in the dark mode or not if so you can
41:04 - see that the value of this custom
41:06 - properties is overwritten
41:09 - now down here you can see that we have
41:11 - used the value of this custom property
41:13 - as the color of the body element so we
41:17 - are not using background start and end
41:19 - RGB they were used earlier when we had a
41:22 - gradient on our home page so before
41:24 - going further let's do a bit of cleanup
41:26 - here I'm going to delete these two lines
41:28 - and
41:30 - these two lines from here
41:32 - and also let's go back to the terminal
41:34 - and make sure
41:36 - that we are running this application in
41:38 - development so anytime we make any
41:40 - changes here we can see the changes
41:42 - immediately so npm run Def
41:46 - good now back to this file
41:49 - so this is our Global style shade and we
41:51 - should use it for styles that are truly
41:53 - Global in our application styles that
41:55 - apply to all pages like anything to do
41:58 - with the body element are headings our
42:00 - hyperlinks and so on anything that is
42:02 - specific to a page or a component we
42:05 - should implement it somewhere else so
42:07 - one thing you shouldn't do here is you
42:09 - shouldn't Define custom classes like
42:11 - user list because this only applies to a
42:15 - particular component or a page with this
42:17 - approach as we build more and more
42:19 - components This Global style sheet grows
42:22 - really large and becomes unmaintainable
42:24 - and more importantly as we change or
42:26 - delete our components we'll have to
42:28 - remember to come back and do some
42:30 - cleanup here otherwise over time we'll
42:33 - have a lot of depth Styles in this file
42:35 - if you have been working with CSS for a
42:37 - while you know what I'm talking about so
42:39 - Reserve this file for styles that are
42:42 - truly Global for styles that are
42:44 - specific to a page or a component use
42:46 - CSS modules or Tailwind which we're
42:48 - going to talk about next
42:51 - [Music]
42:56 - all right let's talk about CSS modules a
42:59 - CSS module is a CSS file that is scoped
43:02 - to a page or a component it's a way to
43:05 - prevent styles from clashing or
43:07 - overwriting each other if you have been
43:09 - working with CSS for a while you know
43:11 - that if you have the same class defined
43:13 - in two different places in two different
43:15 - style sheets these classes can override
43:18 - each other depending on how we import
43:20 - these stylesheet files CSS modules aim
43:23 - to solve that problem let's see how they
43:25 - work
43:26 - so here in the components folder we have
43:29 - a component called Product cart now
43:32 - let's say we want to create some styles
43:34 - for this component so here we add a new
43:37 - file
43:38 - we can call this file anything but it's
43:40 - better to call it the same as the
43:42 - component so product card what matters
43:45 - is that the extension has to be dot
43:48 - module dot CSS okay now in this file or
43:53 - in this CSS module we can Define classes
43:56 - that are scoped to our product card
43:58 - component so let's define a class called
44:00 - card
44:02 - and of course we can Define this class
44:04 - somewhere else without worrying that
44:06 - these classes would Clash okay
44:08 - so here we can apply a padding of one
44:11 - ram
44:12 - and a border of one pixel solid CCC
44:18 - now we go back to our component
44:21 - and import
44:23 - this time sheet so we type import styles
44:26 - from current folder
44:29 - product card dot module.css the name we
44:33 - assign here doesn't matter but typically
44:34 - we go with Styles and this will be a
44:37 - JavaScript object so the classes that we
44:40 - Define in the CSS module will end up
44:43 - being properties of that object
44:45 - so here if we type styles we should see
44:49 - those properties but I don't know why
44:51 - intellisense is not currently working
44:53 - for me so I apologize for that so here
44:55 - we should see the classes we have
44:56 - defined like card and so on and that
44:59 - means in CSS modules we cannot use
45:02 - hyphens when naming these classes like
45:05 - card container because this is not a
45:08 - valid name for a JavaScript property so
45:11 - in these files always use the camel case
45:13 - notation so we remove the hyphen and
45:16 - make the first letter of the second word
45:18 - uppercase okay
45:20 - now let's just simplify things we go
45:22 - with card
45:24 - back to our component
45:26 - so we have this object now
45:28 - on this div we set class name to
45:32 - use our curly braces and set it to
45:34 - Styles Dot card
45:37 - now back to the browser
45:40 - here on the home page we can see the
45:42 - style applied to our cart but let me
45:45 - show you something interesting let's
45:46 - right click here and inspect this in
45:49 - Chrome devtools
45:51 - here's our div look at the class name
45:53 - this is not the class that we created
45:55 - right this is auto generated so what is
45:58 - happening here is that this project uses
46:00 - a tool called post CSS for Transforming
46:03 - Our CSS class names so back to our
46:06 - project
46:08 - here in the root folder we have a file
46:11 - called post CSS dot config.js in this
46:15 - file currently we have two plugins one
46:17 - is Tailwind the other is auto prefixer
46:20 - now for the most part we don't have to
46:22 - touch this configuration file but if
46:24 - you're an advanced post CSS user you
46:26 - know this is where you can provide your
46:28 - custom configuration
46:30 - so when building our application next.js
46:32 - uses post CSS to transform our class
46:36 - names and generate unique class names
46:38 - that don't Clash this is how CSS modules
46:41 - work now one last thing before we finish
46:44 - this lesson currently I put
46:46 - the CSS file and the typescript file
46:49 - next to each other if you don't like
46:51 - mixing up your CSS and TSX files you can
46:54 - group them in folders so here we can
46:56 - create a folder
46:58 - like product card
47:01 - this is a container for our component in
47:03 - this component we can have a TSX file
47:06 - and a CSS file okay
47:08 - and of course we can use the same
47:09 - technique with our pages so we can use
47:12 - CSS modules to Define styles that are
47:15 - local to a particular page
47:17 - [Music]
47:23 - all right let's talk about Tailwind so
47:25 - Tailwind is a very popular CSS framework
47:28 - that uses the concept of utility classes
47:31 - so here on
47:33 - tailwindcss.com you can see that we have
47:35 - a bunch of classes like Flex
47:38 - pt-4 which is short for padding top 4
47:41 - text Center and so on so here we have a
47:44 - ton of small utility classes and we can
47:47 - combine them to style our application
47:49 - some people love it some people hate it
47:51 - I have to convince that I also have a
47:53 - love-hate relationship with Tailwind but
47:55 - I think I love it more than I hate it if
47:58 - you have never used it before I strongly
48:00 - encourage you to give it a chance
48:01 - because these days a lot of projects are
48:04 - built with Tailwind so if you want to
48:06 - upgrade your skills and expand your job
48:08 - opportunities you should have Tailwind
48:10 - in your skill set so in Tailwind we have
48:13 - a ton of small utility classes for
48:17 - example for controlling paddings we have
48:19 - a bunch of classes that start with P
48:21 - followed by a number which can be one
48:23 - two three four and so on the larger the
48:25 - number the more padding we'll have we
48:28 - also have PX for applying horizontal
48:30 - padding this is the same as applying a
48:33 - left and a right padding we also have py
48:36 - for vertical padding we have PT for
48:39 - padding top PR for padding right PB or
48:43 - padding bottom and pl for padding left
48:46 - now you don't have to memorize any of
48:48 - this stuff as you practice you'll get
48:50 - the hang of them pretty quickly now for
48:53 - margins we have similar classes but they
48:55 - start with M followed by a number MX or
48:59 - horizontal margin and Y for vertical
49:01 - margin and so on now for styling text
49:04 - again we have a ton of classes for
49:06 - example for controlling the size we have
49:08 - text Dash XS which is extra small we
49:12 - have text small text base which is like
49:15 - the regular size we have text large
49:17 - x-large 2x large and so on for applying
49:20 - colors we have classes that start with
49:22 - text followed by a color
49:25 - so if you Google Tailwind color palette
49:29 - on this page
49:31 - you can see the default color palette
49:34 - that comes with Tailwind so we have all
49:36 - these beautiful colors and for the most
49:38 - part we don't need to customize them
49:40 - they just look great as they are but you
49:43 - can always customize these and use
49:45 - colors that are specific to your brand
49:47 - Now look for example for Sky we have
49:50 - various shades of blue that start with
49:52 - 50 and go all the way to 950. the larger
49:56 - the number the darker the color you will
49:59 - see an example of this later in this
50:01 - video now back to our slide we're
50:03 - controlling the background color we have
50:05 - a bunch of classes that start with BG
50:07 - followed by a color code now for
50:10 - controlling the thickness of font we
50:12 - have a bunch of classes like font thin
50:14 - font light normal medium bold and swap
50:18 - that's the idea of Tailwind now there
50:20 - are a lot more classes in Tailwind that
50:22 - we can cover here but our Focus here in
50:25 - this course is on nyxjs and not Tailwind
50:27 - I just want to show you the basics so
50:29 - you can learn the rest on your own so
50:31 - let's say these classes in action and
50:33 - then I will explain why you may want to
50:35 - use Tailwind so back to our project
50:38 - earlier we used the CSS module to style
50:41 - our product card let's see how we can
50:43 - use Tailwind instead of a CSS module to
50:45 - style this component
50:47 - so
50:48 - in this file we don't need to import our
50:51 - CSS module
50:53 - instead we can apply
50:55 - Tailwind utility classes right here now
50:59 - in this lesson I'm going to use a
51:00 - different set of styles than the Styles
51:03 - we applied in our CSS module so you can
51:05 - see more of Tailwind in action
51:07 - so we're going to give this some padding
51:09 - we type p dash that if you press control
51:12 - and space you can see all the padding
51:15 - classes so we have p-0 which is
51:17 - equivalent to padding zero we have
51:20 - padding one which is equivalent to 0.25
51:24 - Ram or 4 pixels and as the number
51:27 - increases we get more padding so this
51:30 - intellisense comes with the extension
51:32 - that we installed at the beginning of
51:34 - the course so let's give this a padding
51:36 - of five
51:37 - a vertical margin
51:39 - of 5
51:41 - now I want to give it a background color
51:42 - so we type BG Dash that look again in
51:47 - intellisense we can see all the colors
51:49 - I'm going to go with Sky Dash 400.
51:54 - now to make the text white here we apply
51:56 - text Dash White
51:59 - we can make it large
52:01 - so here we use text Excel or 2XL 3XL and
52:05 - so on again on the right side you can
52:08 - see the actual size that is applied so
52:10 - for text Excel font size is 1.25 Ram or
52:14 - 20 pixels
52:16 - now here's a part that gets interesting
52:18 - here we have sudo selectors like hover
52:21 - and with this we can apply Styles when
52:24 - we hover over this box or this div so we
52:27 - can change the background color to BG
52:30 - sky
52:31 - 600 or 500 to make it slightly darker
52:35 - now back to the browser here's our div
52:37 - if we hover over it you can see the
52:39 - color changes
52:41 - so this is how we style our applications
52:43 - with Tailwind now the selling point of
52:45 - Tailwind is that we can start our
52:47 - components right here in our component
52:49 - file we don't have to juggle back and
52:51 - forth between a CSS file and a component
52:54 - file everything is in one place now some
52:57 - people argue that this violates the
52:59 - separation of concerns principle but I
53:02 - have to disagree with that because the
53:04 - whole idea of separation of concerns is
53:06 - organize our code into distinct sections
53:09 - or modules each having a separate
53:12 - concern if you follow this principle
53:14 - we'll have more opportunities for reuse
53:16 - but in this case this react component
53:19 - itself is a module and defines the ReUse
53:22 - boundary so what we have inside this
53:25 - boundary is purely implementation detail
53:27 - we can have markup with JavaScript and
53:30 - style all next to each other what is
53:33 - inside is irrelevant to the outside
53:34 - world as long as this component or this
53:37 - module is reusable that's just what I
53:39 - think if you disagree or don't like
53:42 - using Tailwind that's totally fine but
53:44 - again if you want to expand your job
53:45 - opportunities I highly encourage you to
53:47 - learn Tailwind because it's in high
53:49 - demand these days but there is one more
53:51 - benefit to using tailwind and this is
53:53 - the reason I personally love Tailwind
53:55 - with Tailwind when we build our
53:57 - application our final CSS bundle will
54:00 - only have the utility classes that we
54:02 - have used in our markup so if tomorrow
54:04 - we delete this div none of these classes
54:08 - will be in our final CSS bundle unless
54:11 - we have used them somewhere else so with
54:13 - Tailwind we don't have to remember to
54:15 - clean up as we change or delete our
54:17 - components with CSS modules if we delete
54:21 - this component we have to remember to
54:23 - delete this CSS file as well or if we
54:26 - change the structure here we might still
54:28 - have unused classes in our CSS module so
54:31 - we have to remember to come back and
54:32 - clean up so that's the selling point
54:34 - that convinced me to start using
54:36 - Tailwind but on the flip side I don't
54:39 - like that over time as our marker gets
54:41 - complex will have a lot of these classes
54:43 - and the code is kind of hard to read but
54:46 - it's just a matter of getting used to it
54:48 - it's not terribly bad but it's something
54:50 - that puts some people off early on but
54:52 - over time I think the benefits outweigh
54:55 - the downside
55:02 - all right now let's talk about Daisy UI
55:04 - Daisy UI is a very popular component
55:07 - library for Tailwind it's kind of like
55:09 - bootstrap for Tailwind so if you head
55:12 - over to daisyui.com you can see all
55:15 - these components
55:17 - for example we have accordions alerts
55:20 - we have breadcrumbs buttons cards
55:25 - Carousel chat Bubbles and so on very
55:27 - very useful it's very easy to use so
55:30 - let's go
55:31 - to the installation page
55:33 - first we have to install
55:35 - Daisy
55:36 - as a development dependency so I'm going
55:39 - to copy this line now back in vs code
55:41 - I've opened my terminal window you can
55:44 - open it from terminal new terminal
55:47 - now let's paste that
55:51 - good next
55:53 - we should add daisy as one of the
55:56 - plugins of Tailwind so we should go to
55:59 - Tailwind configuration file in the root
56:02 - of our project
56:03 - so that is right here
56:07 - currently there are no plugins so let's
56:10 - copy
56:11 - this line and
56:13 - paste it here
56:15 - there's literally all we have to do now
56:18 - let's see how we can use these
56:20 - components so as an example
56:24 - we're going to look at the button
56:26 - component
56:27 - so here we have a bunch of classes like
56:30 - BTN BTN neutral BTN primary secondary
56:34 - and so on exactly like bootstrap under
56:36 - the hood these classes use Tailwind so
56:39 - instead of us manually combining a bunch
56:41 - of small Tailwind classes to create a
56:44 - button we can just use the button that
56:46 - comes with Daisy and of course we can
56:49 - always customize these buttons okay so
56:52 - to create a button
56:53 - look we should have an example down here
56:55 - there you go this is just a basic button
56:57 - we also have neutral primary secondary
57:00 - and so on
57:01 - so back to our code
57:04 - less style this component that we
57:07 - created earlier add to cart so here we
57:10 - have a button
57:12 - we set class name to BTN BTN Dash
57:15 - primary we don't have to import anything
57:18 - in this file okay now back to the
57:20 - homepage here's what we get let's remove
57:22 - this blue background because it looks
57:24 - kind of odd so we're going to go back to
57:28 - product card the TSX
57:31 - and I'm going to remove all these
57:33 - Tailwind classes okay
57:36 - so here's what we are left with now in
57:39 - DayZ we have the concept of themes for
57:42 - example if you look at this page
57:45 - themes
57:47 - you can see all the available themes
57:50 - now in this lesson I'm going to use a
57:53 - theme called winter and you can always
57:55 - preview these themes so on the top you
57:58 - can select them and see what your
58:00 - application looks like here's the dark
58:02 - mode here we have the cupcake theme and
58:04 - so on now to use a theme there are two
58:07 - steps we have to follow
58:09 - first we have to go in Tailwind
58:11 - configuration file and add this section
58:14 - for days UI so here we activate the
58:16 - themes we want to use
58:18 - so let's copy
58:20 - this section
58:22 - and go back to Tailwind config.ts
58:26 - right after plugins we paste this so we
58:29 - have Daisy UI we have themes I don't
58:31 - want to use any of these I only want to
58:33 - use
58:34 - the winter theme the second step is to
58:38 - apply this theme on our HTML element so
58:41 - back in the documentation look here we
58:43 - have a data attribute for specifying the
58:46 - theme to do that we have to go to our
58:48 - layout file
58:50 - because this is where we have our HTML
58:52 - element so we set data Dash theme to
58:56 - Winter
58:58 - now back to our home page our button
59:00 - looks blue beautiful now let's go to the
59:02 - users page and
59:04 - put these users inside a table so let's
59:07 - go to the users page
59:10 - and replace
59:12 - this unordered list with a table so we
59:15 - select this and press command and D on
59:18 - Mac or Ctrl ND on Windows to activate
59:21 - multiple cursors now we can change these
59:24 - two elements in one go so we change it
59:26 - to a table
59:28 - then we press escape to deactivate
59:30 - multiple cursors
59:32 - now inside this table we want to have a
59:34 - t head inside the T head we want to have
59:37 - a TR and inside the TR we want to have
59:39 - two th elements let's press tab here's
59:43 - our markup beautiful now here we want to
59:46 - have two columns the first one is
59:47 - username the second is user email
59:51 - now after the t-hat element we should
59:54 - add a tea body
59:56 - then we move mapping our users inside T
59:59 - body and replace Li with TR so once
60:04 - again we press command and D on Mac or
60:06 - Ctrl and D on Windows to change both
60:09 - these elements in one go so let's change
60:11 - it to tr
60:13 - the inside is TR we want to have two th
60:17 - elements so th times two
60:20 - let me put it on a separate line
60:23 - good in the first th we want to render
60:25 - user.name
60:28 - in the second moon render
60:30 - user dot email and currently we don't
60:33 - have email in the interface that we
60:35 - defined for our users that is why we get
60:38 - a compilation error so this is another
60:40 - benefit of using typescript the
60:42 - typescript compiler tells us about these
60:44 - issues before we run or deploy our
60:47 - application we can catch these errors at
60:49 - compile time or even while coding so up
60:52 - here
60:53 - we have the user interface let's add an
60:57 - email property of type string now
61:01 - the error goes away lovely so back to
61:04 - the browser here's what we get now let's
61:07 - apply a couple of classes from Daisy to
61:09 - make this table look a little bit nicer
61:11 - so back to our code here's our table
61:15 - we set class name to table and table
61:18 - Dash bordered
61:21 - and of course you can find these in the
61:23 - documentation for the table component in
61:25 - DayZ UI
61:27 - okay this is much better now I made a
61:30 - mistake earlier when rendering these
61:33 - rows I used the th element
61:36 - that is why they appear as bold but we
61:39 - should use th only as the column of our
61:41 - tables
61:43 - so let's change all of these th elements
61:45 - to TD once again we select one of them
61:48 - and we press command and D to select
61:51 - more of them
61:53 - so now we have four cursors let's change
61:55 - all of them to t d
61:58 - okay here's what we get now we no longer
62:00 - need the timestamp so let's remove it
62:03 - from here as well
62:06 - good so we're done for now in the next
62:08 - section we're going to talk about
62:09 - routing and navigation in more detail
62:13 - hey guys I hope you've been having fun
62:15 - watching this tutorial I just wanted to
62:17 - mention that this tutorial is the first
62:20 - hour of my complete next JS course so
62:23 - after you finish this if you want to
62:25 - learn more I highly recommend you to
62:26 - enter on the full course because it's
62:28 - much faster and easier than jumping
62:31 - between a bunch of random disconnected
62:33 - tutorials here on YouTube the full
62:35 - course is 5 hours long and teaches you
62:37 - everything you need to build full stack
62:39 - applications with nexjs it also comes
62:42 - with a certificate of completion and a
62:44 - 30-day money-back guarantee so if you're
62:47 - not happy ask for a full refund you get
62:49 - all your money back no questions asked
62:51 - in case you are interested the link is
62:53 - below this video