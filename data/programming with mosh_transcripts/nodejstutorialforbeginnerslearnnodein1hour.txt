00:00 - [Music]
00:01 - no js' or note is an open source and
00:04 - cross-platform runtime environment for
00:08 - executing JavaScript code outside of a
00:11 - browser quite often we use no to build
00:13 - back-end services also called api's or
00:17 - application programming interfaces these
00:20 - are the services that power our client
00:23 - applications like a web app running
00:25 - inside of a web browser or mobile app
00:28 - running on a mobile device these client
00:31 - apps are simply what the user sees and
00:33 - interacts with they're just the surface
00:36 - they need to talk to some services
00:38 - sitting on the server or in the cloud to
00:41 - store data send emails or push
00:44 - notifications kick off workflows and so
00:46 - on node is ideal for building highly
00:50 - scalable data intensive and real-time
00:53 - back-end services that power our client
00:56 - applications now you might ask but mosh
00:58 - there are other tools and frameworks out
01:01 - there for building back-end services
01:03 - such as a speed a bed rails Django and
01:06 - so on so what's so special about no well
01:09 - note is easy to get started and can be
01:12 - used for prototyping and agile
01:15 - development but it can also be used for
01:17 - building super fast and highly scalable
01:20 - services it's used in production by
01:23 - large companies such as PayPal uber
01:25 - Netflix Walmart and so on in fact at
01:29 - PayPal that rebuilt one of their Java
01:31 - and spring based applications using node
01:34 - and it found that the node application
01:36 - was built twice as fast with fewer
01:39 - people in 33% fewer lines of code and
01:43 - 40% fewer files and more importantly
01:47 - they double the number of requests
01:49 - served per second while decreasing the
01:52 - average response time by 35% so node is
01:56 - an excellent choice for building highly
01:58 - scalable services another reason for
02:01 - using node is that in old applications
02:03 - we use JavaScript so if you're a
02:06 - front-end developer and know JavaScript
02:08 - you can reuse your JavaScript skills and
02:11 - - a full-stack developer and get a
02:14 - better job with better pay you don't
02:16 - have to learn a new programming language
02:17 - also because you can use JavaScript both
02:21 - on the front end and on the back end
02:23 - your source code will be cleaner and
02:25 - more consistent so you will use the same
02:28 - naming conventions the same tools and
02:30 - the same best practices and finally
02:32 - another reason for using node is that it
02:35 - has the largest ecosystem of open source
02:37 - libraries available to you so for pretty
02:40 - much any features or building blocks you
02:42 - want to add your application there is
02:44 - some free open source library out there
02:47 - that you can use so you don't have to
02:49 - build this building blocks from scratch
02:51 - and instead you can focus on the core of
02:54 - your application next we're going to
02:56 - look at the architecture of node
03:02 - so in the last video you learned that
03:05 - note is a runtime environment for
03:07 - executing JavaScript code but what is a
03:09 - runtime environment really well before
03:12 - node we use JavaScript only to build
03:15 - applications that run inside of a
03:17 - browser so every browser out there has
03:20 - what we call a JavaScript engine that
03:23 - takes our JavaScript code and converts
03:25 - it to code that a computer can
03:27 - understand for example Microsoft eight
03:30 - uses chakra Firefox uses spider monkey
03:33 - and chrome uses v8 and it's because of
03:36 - these varieties of engines that
03:39 - sometimes JavaScript code can behave
03:41 - differently in one browser or another
03:43 - now a browser provides a runtime
03:46 - environment for JavaScript code for
03:49 - example you probably know that in
03:51 - browsers we have the window or the
03:53 - document object these objects allow us
03:56 - to work with the environment in which
03:58 - our code is running now up to 2009 the
04:01 - only way to execute JavaScript code was
04:04 - inside of a browser in 2009
04:07 - Brian Dahl the creator of node came up
04:10 - with a brilliant idea he thought it
04:13 - would be great to execute JavaScript
04:15 - outside of a browser so he took Google's
04:17 - v8 engine which is the fastest
04:20 - JavaScript engine out there and embedded
04:23 - it inside a C++ program and called that
04:26 - program node so similar to a browser
04:29 - node is a runtime environment for
04:31 - JavaScript code it contains a JavaScript
04:34 - engine that can execute our JavaScript
04:36 - code but it also has certain objects
04:39 - that provide an environment for our
04:41 - JavaScript code but these objects are
04:44 - different from the environment objects
04:45 - we have in browsers for example we don't
04:48 - have the document object instead we have
04:50 - other objects that give us more
04:52 - interesting capabilities for example we
04:54 - can work with the file system listen for
04:57 - requests and a given port and so on we
05:00 - can't do stuff like that inside of a
05:01 - browser right so in essence node is a
05:05 - program that includes the v8 JavaScript
05:08 - engine plus some additional modules that
05:11 - give us capabilities not available
05:14 - inside
05:14 - browsers we can work with the file
05:16 - system or the network and so on both
05:19 - chrome and note share the same
05:21 - JavaScript engine but they provide
05:23 - different runtime environments for
05:25 - JavaScript now I've seen people
05:27 - comparing no to c-sharp or Ruby or some
05:31 - other programming languages but this
05:33 - comparisons are fundamentally wrong
05:35 - because node is not a programming
05:38 - language it's like comparing a car with
05:40 - an apple by the same token note should
05:43 - not be compared with frameworks such as
05:45 - a spool of meth or rails or Django and
05:48 - so on these are frameworks for building
05:51 - web applications note is not a framework
05:54 - it's a runtime environment for executing
05:57 - JavaScript code next we're going to look
05:59 - at how node works
06:05 - so earlier I mentioned that note
06:08 - applications are highly scalable and
06:10 - this is because of the non-blocking or
06:12 - asynchronous nature of note what do you
06:15 - mean by asynchronous let me give you a
06:17 - metaphor imagine you go to a restaurant
06:20 - a waiter comes to your table takes your
06:22 - order and gives it to the kitchen then
06:25 - they move on to serve another table
06:27 - while the chef is preparing your meal so
06:30 - the same person can serve many different
06:32 - tables they don't have to wait for the
06:34 - chef to cook one meal before they serve
06:37 - another table this is what we call
06:39 - non-blocking or asynchronous
06:42 - architecture and this is how node
06:44 - applications work the waiter is like a
06:47 - thread allocated to handle a request so
06:51 - a single thread is used to handle
06:53 - multiple requests in contrast to
06:56 - non-blocking
06:57 - or asynchronous architecture we have
06:59 - blocking or synchronous architecture
07:02 - let's see how that works so back to our
07:05 - restaurant example imagine you go to
07:07 - another restaurant and in this
07:09 - restaurant a waiter is allocated to you
07:11 - they take your order and give it to the
07:13 - kitchen now they are sitting in the
07:15 - kitchen waiting for the chef to prepare
07:18 - your meal at this time they're not doing
07:20 - anything else they're just waiting
07:21 - they're not going to take an order from
07:24 - another table until your meal is ready
07:26 - this is what we call blocking or
07:29 - synchronous architecture and that's how
07:32 - applications built with frameworks like
07:34 - a speed net or rails work out of the box
07:37 - so when we receive a request on the
07:39 - server a thread is allocated to handle
07:42 - that request as part of handling that
07:44 - requests and is likely that we're going
07:46 - to query a database and as you know
07:48 - sometimes it may take a little while
07:50 - until the result is ready when the
07:53 - database is executing the query that
07:55 - thread is sitting there waiting it can't
07:58 - be used to serve another client so we
08:00 - need a new thread to serve another
08:02 - client imagine what would happen if we
08:05 - have a large number of concurrent
08:07 - clients at some point we're going to run
08:09 - out of threads to serve these clients so
08:12 - new clients have to wait until three
08:15 - threads are available
08:17 - or if we don't want them to wait we need
08:19 - to add more hardware so with this kind
08:22 - of architecture we are not utilizing our
08:24 - resources efficiently this is the
08:27 - problem with blocking or synchronous
08:29 - architecture and as I explained that's
08:31 - how applications built with frameworks
08:34 - like a speed a that worked by default of
08:36 - course in asp.net it is possible to use
08:39 - asynchronous architecture what you will
08:41 - have to do extra work for now in
08:44 - contrast no the applications are
08:46 - asynchronous by default so you don't
08:49 - have to do anything extra
08:50 - in node we have a single thread to
08:53 - handle all requests when a request
08:55 - arrives that single thread is used to
08:58 - handle that request if we need to query
09:00 - a database or thread doesn't have to
09:03 - wait for the database to return the data
09:05 - while the database is executing our
09:07 - query that thread will be used to serve
09:10 - another client when the database
09:12 - prepares the result it puts a message in
09:15 - what we call an event queue node is
09:18 - continuously monitoring this queue in
09:20 - the background
09:21 - when it finds an event in this queue it
09:23 - will take it out and process it this
09:26 - kind of architecture makes node ideal
09:29 - for building applications that include a
09:31 - lot of disk or network access we can
09:34 - serve more clients without the need to
09:36 - throw in more hardware and that's why no
09:39 - the applications are highly scalable in
09:42 - contrast node should not be used for CPU
09:45 - intensive applications like a video
09:48 - encoding or an image manipulation
09:50 - service in this kind of applications we
09:53 - have a lot of calculations that should
09:55 - be done by CPU and few operations that
09:58 - touch the file system or the network
10:00 - since no the applications are single
10:03 - threaded when performing the
10:05 - calculations to serve one client other
10:07 - clients have to wait and that's why node
10:10 - should not be used or CPU intensive
10:12 - applications it should only be used for
10:15 - building data intensive and real-time
10:18 - applications okay
10:20 - enough theory Nix I'm gonna show you how
10:22 - to install node and build your first
10:25 - node application
10:27 - you
10:31 - in this lecture I'm going to show you
10:32 - how to install note if you're on Windows
10:35 - open up command prompt if you're on Mac
10:37 - or Linux open up the terminal first
10:40 - let's see if you already have node on
10:42 - your machine or not so run note space -
10:46 - - version you can see on this machine
10:50 - I'm running node version 6.0 point three
10:53 - this is an earlier version of node the
10:56 - latest stable version is version eight
10:58 - now on your machine chances are you may
11:01 - not have known or you might have an
11:02 - earlier version either way I want you to
11:05 - install the latest version of node
11:08 - so open up your browser and head over to
11:11 - note J s org on this home page you can
11:14 - see we have two versions for note one is
11:18 - the latest stable version which is
11:20 - recommended for most users at the time
11:23 - of recording this video test version
11:24 - eight point nine point one and there's
11:27 - always a newer version which is
11:29 - experimental and it might not be stable
11:31 - so I want you to install the latest
11:33 - stable version also take into account
11:37 - that in the future when you're watching
11:38 - this video chances are the latest stable
11:41 - version might be newer if you're worried
11:43 - that this course is going to get
11:44 - outdated don't worry because in this
11:47 - course we're going to focus on the
11:48 - fundamentals so I'm going to work with
11:51 - the core modules of note these core
11:53 - modules are stable they have been there
11:55 - for a long time so the code that we're
11:57 - going to write in this course will
11:59 - continue to work with the future
12:00 - versions of note once you master the
12:03 - fundamentals you can always learn about
12:05 - the new features that come in every
12:07 - version by looking at the change lock so
12:10 - let's not worry about the fancy new
12:12 - features in node and focus on the
12:14 - fundamentals so let's go ahead and
12:16 - install the latest stable version
12:20 - you can see here I get a package we run
12:22 - it it's an installer take a look very
12:25 - simple just continue continue continue
12:31 - install you need to enter our password
12:37 - and the installation is complete it took
12:42 - only a few seconds so now back in the
12:46 - terminal let's run node - - version one
12:50 - more time you can see I upgraded my node
12:53 - to version eight point nine point one
12:55 - next we're going to build our first node
12:58 - application
13:03 - alright now we're ready to build our
13:05 - first node application so I'm gonna
13:08 - create a new folder call it first app
13:13 - let's go to this folder now I'm going to
13:17 - open this folder inside of Visual Studio
13:19 - code which is my preferred code editor
13:22 - so code period so this is Visual Studio
13:28 - code or vs code it's a free powerful
13:31 - editor but you can use any editors that
13:33 - you prefer you can use sublime you can
13:36 - use atom or any other editors so here in
13:39 - this folder I'm gonna add in your file
13:42 - app is in this file we can write regular
13:47 - JavaScript just like the JavaScript that
13:49 - we write for the browsers so I'm gonna
13:51 - define a function say hello that takes a
13:55 - parameter name and simply logs a message
14:00 - on the console so hello + name and then
14:05 - we can call this function like this
14:07 - Marsh now to execute this code we're
14:13 - going to go back to the terminal and run
14:15 - node and pass the name of the file as an
14:17 - argument so app the jas so node as I
14:21 - told you before is a C++ program it
14:24 - includes Chrome's v8 JavaScript engine
14:27 - so this app the J's file that we're
14:29 - gonna pass to node node is going to give
14:31 - it to v8 for execution so you can see we
14:35 - got hello Marsh on the console now let
14:37 - me show you something
14:38 - so back in vs code
14:42 - temporarily comment out this line and do
14:45 - it console that log of window let's see
14:49 - what happens so back in the terminal
14:51 - let's run node app a Jas you got an
14:56 - exception window is not defined so as I
15:00 - told you before in node we don't have
15:02 - the window or document objects these are
15:05 - part of the runtime environment that we
15:07 - get with browsers in node we have other
15:10 - objects to work with files with the
15:12 - operating system with the network and so
15:14 - on and that's what you're gonna learn
15:16 - about in the next section I hope you
15:18 - enjoyed this section and thank you for
15:19 - watching
15:24 - in this section we're going to look at
15:27 - the module system in node you will learn
15:29 - what modules are why we need them and
15:32 - how they work throughout this section
15:34 - we'll explore a feel of the modules
15:37 - built into the core of node such as
15:39 - operating system file system events and
15:43 - HTTP you will also learn how to create
15:46 - your own modules now let's get started
15:54 - so in the last section we use this
15:57 - console that log function to lock
16:00 - something on the console now this
16:03 - console object is what we call a global
16:06 - object so it's part of the global scope
16:08 - which means we can access it anywhere in
16:11 - any files we have a bunch of other
16:14 - objects and functions that are also
16:16 - globally available in node for example
16:18 - we have set timeout which you have
16:21 - probably seen before we use this to call
16:24 - a function after a delay like one second
16:27 - two second whatever so this is just part
16:29 - of the standard JavaScript we can use
16:31 - this on the client we can use this
16:33 - inside of a browser or inside of node
16:36 - we also have clear timeout
16:40 - similarly we have set interval which we
16:44 - use to repeatedly call a function after
16:47 - a given delay we also have clear
16:50 - interval which we use to stop that
16:52 - function from being called repeatedly
16:54 - so these are the global objects in
16:56 - JavaScript now he node we have a couple
16:59 - other global objects that you're going
17:01 - to learn about later in this section now
17:04 - in browsers we have this window object
17:07 - that represents our global scope so all
17:10 - the variables and functions that are
17:12 - defined globally we can access them via
17:15 - this window object so we can call window
17:18 - that console that log or simply just
17:21 - console that lock the JavaScript engine
17:24 - will prefix this statement with window
17:27 - that console dot lock because that's
17:30 - where this object is defined similarly
17:33 - all these other functions you see here
17:35 - they belong to the window object so we
17:38 - can call window that's set timeout or
17:41 - call it directly by the same token when
17:44 - we declare a variable let's say message
17:48 - that variable is also available via the
17:52 - window object okay however in the last
17:56 - section I told you that in node we don't
17:59 - have this window object instead we have
18:01 - another object called global so all
18:05 - these functions and objects we have here
18:07 - we can
18:07 - access them find the global object so we
18:10 - can do global that console dot log or
18:13 - global that set timeout and so on of
18:16 - course it's easier to use the shorthand
18:18 - instead of prefix in them with this
18:20 - global but one thing you need to know
18:22 - about note is that these variables that
18:25 - we define here they are not added to the
18:28 - global object in other words if we do a
18:31 - console dot log of global that message
18:37 - we are going to see undefined on the
18:40 - console so let me show you I'm gonna
18:42 - delete all the code here now back in the
18:45 - terminal let's run note app j s so we
18:50 - get undefined in the console so as you
18:54 - can see the variables and functions that
18:57 - we defined here they are not added to
18:59 - the global object they're only scoped to
19:02 - this fire app dot j s so they are not
19:05 - available outside of this file and this
19:07 - is because nodes modular system that
19:10 - you're going to learn about in the next
19:11 - lecture
19:13 - you
19:17 - so in the last section you'll learn that
19:19 - in the client-side JavaScript that we
19:21 - run inside of browsers when we declare a
19:24 - variable or a function that is added to
19:26 - the global scope for example when we
19:30 - define a function like say hello that
19:35 - function is added to the global scope
19:37 - and it's available via the window object
19:41 - now there is a problem with this
19:44 - behavior in a real world application we
19:47 - often split our JavaScript code into
19:49 - multiple files so it is possible that we
19:52 - have two files and in both these files
19:54 - we define this function say hello with
19:57 - the exact same name because this
20:00 - function is added to the global scope
20:01 - when we define this function in another
20:04 - file that new definition is going to
20:07 - overwrite the previous definition so
20:09 - this is the problem with the global
20:11 - scope so in order to build reliable and
20:14 - maintainable applications we should
20:16 - avoid defining variables and functions
20:19 - in the global scope instead we need
20:21 - modularity we need to create small
20:24 - building blocks or modules where we
20:27 - define our variables and functions so
20:29 - two variables or two functions with the
20:31 - same name don't overwrite another
20:33 - variable or function defined somewhere
20:35 - else that encapsulated inside of that
20:39 - module now at the core of node we have
20:42 - this concept called module so every file
20:45 - in a node application is considered a
20:47 - module the variables and functions would
20:49 - define in that file or that module are
20:51 - scoped to that file in object-oriented
20:54 - programming terms we say there are
20:56 - private they are not available outside
20:58 - that container outside that module if
21:01 - you want to use a variable or a function
21:03 - defined in a module outside that module
21:06 - you need to explicitly export it and
21:08 - make it public and we're going to look
21:10 - at that in the next lecture so what I
21:13 - want you to take away from this lecture
21:14 - is that every node application has at
21:17 - least one file or one module which we
21:20 - call a main module so in this case is
21:22 - after J s is our main module now let me
21:26 - show you this module so I'm going to
21:27 - delete all this code here and do
21:30 - a console that log of module
21:35 - now this module object here may appear
21:38 - to be global so you may think we can
21:40 - access it while the global object like
21:44 - global console but actually this is not
21:47 - a global object it appears to be global
21:49 - but it's not global and you will find
21:51 - out why very soon so let's just lock
21:55 - this module object and see what we see
21:57 - in the console back in the terminal node
22:01 - app the jas so you can see we have an
22:04 - object module it's a JSON object with
22:08 - these key value pairs so we have ID
22:09 - every module has an ID or a unique
22:12 - identifier we have exports parent file
22:16 - name which is the complete pass to that
22:18 - file loaded which is a boolean that
22:21 - determines if this module is loaded or
22:23 - not we have children and paths now for
22:26 - now don't worry about these properties
22:28 - as we go through this section you will
22:31 - gradually become familiar with this
22:32 - properties so in node every file is a
22:36 - module and the variables and functions
22:39 - defined in that file are scoped to that
22:42 - module they are not available outside of
22:44 - that module in the next lecture you're
22:46 - going to learn how to create and load a
22:48 - module
22:54 - alright now let's add a new module to
22:56 - this application so I'm gonna add a new
23:00 - file logger dot J s let's imagine we're
23:04 - going to create a module for login
23:07 - messages and we're gonna reuse this
23:08 - module in various parts of this
23:10 - application or potentially in other
23:12 - applications so loggernet J s now in
23:17 - this module let's imagine that we're
23:19 - going to use one of those remote logging
23:21 - services for login our messages so there
23:25 - are websites out there there provide
23:27 - logging as a service they give us a URL
23:29 - and we can send an HTTP request to that
23:32 - URL to log messages in the cloud so here
23:36 - I'm gonna declare a variable like URL
23:41 - and set it to something like this HTTP
23:44 - my lager dot io / lock and of course I'm
23:48 - making this up it may not be a true
23:50 - service out there but let's imagine in
23:53 - this implementation we're going to send
23:54 - an HTTP request to this endpoint to this
23:58 - URL now we also need a function called
24:03 - log that takes a message and in this
24:07 - function we're going to send an HTTP
24:10 - request however to keep things simple
24:13 - here we just want to focus on the
24:15 - modularity we don't want to get
24:16 - distracted with all the details of
24:18 - sending HTTP requests so for now I just
24:21 - want to log this message on the console
24:24 - so console that log message okay
24:30 - now this variable and this log function
24:34 - they're both scoped to this module
24:37 - they're private they're not visible from
24:39 - the outside
24:40 - however in after j/s which is our main
24:44 - module we want to use this logger module
24:47 - so we should be able to access this log
24:51 - function we should be able to call it
24:53 - from the app module so we need to make
24:55 - this public we need to make it visible
24:57 - from the outside
24:59 - now in the last lecture you saw this
25:02 - module object one of the properties we
25:04 - have here is exports you can see this
25:08 - property is set to an empty object
25:10 - anything that we add to this object will
25:13 - be exported from this module and it will
25:16 - be available outside of this module so
25:19 - back in our lager module I'm gonna set
25:23 - module dot exports dot log so I'm adding
25:28 - a method called log to this exports
25:31 - object and simply setting it to this log
25:35 - function we have defined here okay in
25:39 - other words the object that we're
25:41 - exporting here has a single method
25:43 - called lock now similarly if you want to
25:47 - export this URL we could do something
25:49 - like this
25:50 - so module that exports that URL we set
25:55 - it to URL and of course we could change
25:58 - the name that is exported to the outside
26:00 - for example internally we may call this
26:03 - variable URL but when we export it we
26:06 - may call it endpoint okay now in this
26:13 - case we don't need to export this URL
26:16 - variable because this is purely
26:18 - implementation detail so in real world
26:21 - applications every module might have
26:23 - several variables and functions we only
26:26 - want to export a subset of these members
26:29 - to the outside because we want to keep
26:30 - this module easy to use let me give you
26:34 - a metaphor think of a DVD player a DVD
26:37 - player has a few buttons on the outside
26:39 - and these are the buttons or objects
26:41 - that we interact with so these objects
26:44 - represent the public interface of a DVD
26:48 - player okay but inside the box there are
26:51 - lots of other objects or complex objects
26:53 - we don't need to know anything about
26:55 - these objects their implementation data
26:58 - and they can change significantly from
27:00 - one model to another but what you see on
27:03 - the outside is almost stable or static
27:06 - across different models so in our lager
27:09 - module this URL is implementation detail
27:13 - modules don't need to know anything
27:15 - about this they only need to call the
27:17 - log function so we export these make it
27:20 - public but keep the URL private so I'm
27:23 - gonna delete this last line okay so
27:26 - we're done with our logger module now we
27:28 - need to load this module and use it
27:31 - inside app j/s
27:38 - to load the module we use the require
27:41 - function this is one of the functions in
27:44 - node we don't have this in browsers this
27:46 - function takes one argument and that's
27:49 - the name or path of the target module we
27:52 - want to load so here we want to load the
27:55 - logger module now you can see both the
27:58 - app module and longer module are in the
28:00 - same folder so we use period slash to
28:05 - indicate the current folder and then we
28:08 - add the name of our module that is
28:10 - logger ojs or we can make it shorter and
28:13 - just use logger because node assumes
28:16 - this is a JavaScript file and it
28:18 - automatically asked the GS extension now
28:22 - if this logger was in a subfolder we
28:24 - could add that soft folder here or if it
28:27 - was in the parent folder we could use
28:29 - dot dot slash so here we are using the
28:32 - relative path to the target module in
28:35 - this case that module is in the same
28:37 - folder now this required function
28:41 - returns the object that is exported from
28:43 - this target module
28:45 - so this exports object here this is what
28:49 - we get when we call the require function
28:51 - let me show you so I'm gonna declare a
28:55 - variable call it lager the name of the
28:58 - module and set it to the return value of
29:01 - the require function now let's log this
29:05 - logger and see what we get so node
29:12 - object s look we get an object this
29:17 - object has a single method called log
29:20 - can see that's a function so we can call
29:24 - this function or this method in app J s
29:27 - so back here we call logger dot and look
29:31 - here we have intelligence in BS code so
29:34 - we call log and pass a message now I can
29:41 - terminal let's run this app and we get
29:47 - message on the console so this is how we
29:50 - work with modules in node
29:52 - when we define a module we export one or
29:55 - more members and then to load the module
29:58 - we use the require function now in the
30:02 - recent versions of JavaScript we have
30:04 - the ability to define constants so as a
30:08 - best practice when loading a module
30:11 - using the required function it's better
30:13 - to store the result in a constant like
30:17 - this the reason for this is because we
30:20 - don't want to accidentally overwrite the
30:23 - value of logger like this here if we set
30:27 - this to one then when we call the log
30:30 - method we're going to get an exception
30:31 - let me show you so one more time
30:36 - look you got logger that log is not a
30:39 - function now in contrast if we define
30:43 - this as a constant now back in the
30:47 - terminal let's run this program one more
30:50 - time look we got a different kind of
30:53 - error assignment two constant variable
30:56 - now there are tools out there that check
30:59 - our JavaScript code for errors like that
31:01 - so by using this constructs properly we
31:04 - can prevent these errors from happening
31:06 - at runtime
31:07 - so one of these popular tools is J's
31:09 - hint if you have never used it before
31:11 - don't worry I'm just gonna show you a
31:13 - quick demo so if you're on J's hint 1/2
31:17 - Jas we get this error attempting to
31:21 - overwrite logger which is a constant so
31:24 - with tools like jeaious hint we can scan
31:26 - all our JavaScript code for errors like
31:28 - that so that's the benefit of using a
31:31 - constant as opposed to a variable here
31:33 - if you accidentally reset this object
31:36 - then we're gonna get an error at compile
31:39 - time instead of at run time
31:40 - okay and one last thing before we finish
31:43 - this lecture sometimes instead of
31:46 - exporting an object from a module you
31:49 - may want to export only a single
31:51 - function for example here in our lager
31:54 - module we don't necessarily need an
31:56 - object because we have a single method
31:59 - an object would be useful if we had
32:01 - multiple methods or properties here but
32:05 - in this case instead of
32:06 - sporting an object we can export a
32:08 - single function so we can reset this
32:11 - exports to the log function so initially
32:16 - it was an empty object but we reset it
32:19 - to just a function with that I can op j
32:23 - s the logger is no longer an object it's
32:27 - a function that we can call directly
32:29 - like this so logger we call it and give
32:35 - it an argument now a better name for
32:37 - this function is LOC so I'm gonna press
32:40 - f2 to rename these log like this now
32:45 - back in terminal let's run node FJ s and
32:49 - we get the same result so in your
32:53 - modules you can export a single function
32:55 - or an object
33:02 - so now you know the variables and
33:05 - functions we define in a module are
33:07 - scoped to that module they're private
33:09 - and not visible from the outside but you
33:12 - might be wondering how node does this so
33:15 - let me show you on the very first line
33:17 - of the logger jeaious module I'm going
33:20 - to create a syntactical error so define
33:23 - a variable X and set it to nothing like
33:26 - this so make sure to write this code on
33:29 - the very first line in other words if
33:31 - you have a line break here and do this
33:34 - on a second line you're not going to see
33:36 - what I'm gonna show you now so put this
33:38 - back on the first line here we have a
33:41 - syntactical error now back in the
33:44 - terminal let's run the application again
33:48 - okay we got on
33:50 - touken semicolon right but look above
33:53 - this line you see this function
33:56 - declaration so this function has a few
34:00 - parameters exports require module file
34:05 - name and surname so let me copy this
34:10 - code here
34:12 - now basically what happens under the
34:14 - hood is that note does not execute this
34:17 - code directly it wraps it inside of a
34:21 - function and that's the function you saw
34:23 - so at runtime our code is going to be
34:26 - converted to something like this so we
34:30 - have this function declaration here is
34:33 - the body of that function now for now
34:35 - I'm gonna remove this error here so this
34:39 - is our code and then we have the end of
34:42 - this function now the actual code is
34:44 - slightly more complicated than this but
34:47 - we don't want to get distracted with
34:48 - that complexity if you're a more
34:50 - advanced JavaScript developer you
34:52 - probably know this is an immediately
34:54 - invoked function expression or if you if
34:58 - you don't know that don't worry that's
34:59 - not really the scope of note what I want
35:02 - you to take away here is that note does
35:04 - not execute our code directly it always
35:08 - wraps the code inside each module and
35:10 - something like this inside of a function
35:12 - now look at these arguments to this
35:15 - function so you have seen the required
35:18 - function I told you that this required
35:20 - function appears to be global but
35:22 - actually it's not global in fact it's
35:25 - local to each module so in every module
35:27 - require is one of the arguments that is
35:30 - passed to this function we call this
35:33 - function the module wrapper function
35:36 - okay so you have seen the require
35:39 - function you have also seen module that
35:42 - is what we're using here so we have
35:44 - module that exports we also have exports
35:48 - which is a shortcut to module dot export
35:51 - so if you want to add a function to
35:53 - module that exports object you can
35:55 - either write module that exports dot log
35:58 - equals log or you can write exports that
36:02 - log equals log but you cannot reset this
36:07 - export
36:09 - like what we did earlier in other words
36:11 - you cannot write export equals lock
36:15 - because this export is a reference to
36:19 - module and exports we can
36:22 - change that reference okay so these are
36:27 - the first three arguments we also have
36:30 - filename and Durning which represent the
36:33 - name of this file and the pass so let's
36:37 - have a quick look at this argument on
36:39 - the top I'm gonna do a console that log
36:42 - of underline underline file name and
36:47 - also
36:49 - underline underline Durning now we're
36:53 - not going to have this function this
36:54 - module wrapper function this was purely
36:56 - for demonstration so I'm gonna revert
36:59 - the code back to what we had before
37:01 - okay so now we don't have any errors in
37:05 - this module let's go back to the
37:07 - terminal and run this program
37:10 - so note op j s so here on the first line
37:14 - we have file name which is the complete
37:16 - path to that file that is lager a s and
37:18 - on the second line we have the path to
37:22 - the directory that contains and module
37:24 - so now you have a basic idea about node
37:27 - modules and how they work you know how
37:29 - to create them how to load them but
37:31 - knowing itself comes with a bunch of
37:33 - useful modules that we can use in a lot
37:36 - of applications and that's what we're
37:37 - going to look at in the next lecture
37:42 - hi guys thank you for watching my Noah
37:45 - tutorial I wanted to let you know that
37:47 - this tutorial is the first hour of my
37:50 - complete note course where you will
37:52 - learn how to build a real restful api
37:55 - using node Express and MongoDB all of
37:59 - that recorded with the latest version of
38:01 - node and modern JavaScript so you will
38:04 - learn new and modern ways of building
38:06 - applications with node
38:07 - unlike other courses that only show you
38:10 - simple the only examples like how to
38:12 - build a to-do app we're gonna work on a
38:15 - real-world project a restful api for a
38:18 - video rental application if you have
38:20 - taken any of my courses you know I don't
38:22 - waste your time by explaining the
38:24 - obvious like what a code editor or
38:26 - command prompt is we're gonna get
38:28 - straight to the business and as part of
38:31 - this I'll be touching on various
38:32 - important topics that you need to
38:34 - understand really well including working
38:37 - with node package manager or NPM
38:40 - asynchronous JavaScript including
38:42 - callbacks promises async and await
38:45 - implementing crud operations data
38:48 - validations authentication and
38:50 - authorization using JSON web tokens
38:52 - including role management handling and
38:55 - login errors unit and integration
38:57 - testing test-driven development so you
39:00 - will see I will build a feature from A
39:02 - to Z using test-driven development or
39:05 - TDD and finally we'll deploy this
39:07 - application to the cloud throughout the
39:10 - course I will share with you lots of
39:12 - clean coding and refactoring techniques
39:14 - security best practices useful libraries
39:17 - to use as part of your development
39:19 - common mistakes that many node
39:21 - developers make and much much more
39:23 - the course is currently 14 hours long
39:26 - and I'm planning to add more content to
39:28 - it in the future you can watch this
39:30 - course as many times as you want and if
39:32 - you watch it to the end you will get a
39:34 - certificate of completion that we can
39:36 - add to your resume so if you're serious
39:39 - about adding no to your resume I highly
39:42 - encourage you to enroll in the course
39:44 - and don't waste your time jumping from
39:46 - one tutorial to another so click on the
39:49 - link in the video description to enrol I
39:51 - hope to see you in the course
39:53 - you
39:57 - so in the last lecture I told you that
39:59 - in node we have a few useful modules
40:02 - that are built into the core of node
40:04 - with these modules we can work with
40:07 - files with the operating system with a
40:09 - network and so on so let's have a quick
40:12 - look at this built in modules head over
40:14 - to node J s
40:15 - org then go to Docs on the left side go
40:21 - to version eight point nine point three
40:23 - that's the current stable release
40:25 - chances are by the time you're watching
40:27 - this video this version might be
40:28 - different so that doesn't really matter
40:30 - just pick that version now hearing the
40:33 - table of contents we can see the built
40:36 - in modules of course not
40:38 - everything you see here is a module for
40:39 - example we have console which is our
40:41 - console object we have buffer which
40:44 - we're going to learn about in the future
40:45 - in this course again that's a global
40:47 - object but you can see that this is a
40:49 - fairly short list and some of the items
40:52 - in this list are built in modules in no
40:55 - so just that you can see there are not
40:58 - many modules built into note I'm gonna
41:01 - highlight a few very useful modules that
41:04 - you should be aware of for example we
41:06 - have file system to work with files we
41:09 - have HTTP that you're going to learn
41:11 - about later in this section so with this
41:13 - we can create web servers that listen
41:15 - for HTTP requests we have OS to work
41:19 - with the operating system we have path
41:22 - which gives us a bunch of utility
41:24 - functions for working with paths we have
41:27 - process that gives us information about
41:29 - the current process we have query
41:31 - strings which is very useful in building
41:33 - HTTP services we have a stream which
41:37 - allows us to work with streams of data
41:38 - again you're going to learn about this
41:40 - in the future and a bunch of other
41:42 - modules now in this lecture we're going
41:44 - to look at is passed module so on the
41:48 - documentation you can see all the
41:51 - functions defined in this module in this
41:53 - lecture we're going to use the parse
41:56 - method now if you
41:58 - scroll down you can see how you can use
42:01 - this module so I've seen the required
42:04 - function before we call the module using
42:07 - the required function get the result
42:09 - which is an object and store it in a
42:12 - constant so back in vs code in app Jas
42:16 - let's call require and as the argument
42:19 - use half now the argument that we gave
42:24 - to this require function no it assumes
42:26 - that this is a built in module if there
42:30 - is no built in module by the name
42:32 - specified here then node looks for the
42:35 - existence of a relative path to a file
42:37 - in this application so if we have period
42:40 - / or period period / whatever then
42:44 - notice oome this is a file in this
42:47 - application now in this case we're going
42:49 - to load the building path module and
42:51 - store it in a constant called pass so
42:55 - this is an object with a bunch of useful
42:57 - methods the method we're going to use is
43:01 - the parse method so I'm gonna give it
43:04 - this underline underline file name which
43:07 - is one of the arguments and the module
43:10 - wrapper function that you saw in the
43:11 - last lecture so let's call this and
43:14 - store the result in pass object and then
43:20 - finally log it on the console has object
43:25 - now back in the terminal let's run this
43:29 - application so this is the path object
43:31 - it has a few useful properties we have
43:34 - root we have dur which specifies the
43:37 - path to the folder containing this file
43:41 - here's the name of the file after jas
43:44 - here's the extension
43:47 - the name of the file without the
43:49 - extension so if you want to work with
43:50 - pads it's much easier to use the past
43:53 - module as opposed to working with
43:55 - strings in the next lecture we're going
43:57 - to look at another built-in module that
44:00 - gives us information about the operating
44:02 - system
44:07 - in this lecture I'm going to show you
44:09 - how to get information about the current
44:11 - operating system so if I can no
44:13 - documentation in the list of modules if
44:17 - you scroll down you can see this OS
44:19 - module let's have a quick look here so
44:22 - these are the methods that are available
44:24 - in this module for example we have free
44:27 - mem which returns the amount of free
44:30 - memory on this machine
44:31 - you also have total mem which is the
44:33 - total memory we can get information
44:35 - about the current user we can get the
44:38 - uptime of this machine and so on so
44:41 - let's use a couple of these methods here
44:42 - so if you scroll down you can see this
44:45 - is how we load this OS module just like
44:49 - loading other modules we call the
44:50 - required function and store the result
44:52 - in a constant called OS or anything so
44:56 - my can be a scone I'm gonna delete all
44:58 - the code here and define a new constant
45:01 - OS and study to require OS now we can
45:07 - call total mem method
45:11 - or free mem or other methods so let me
45:16 - declare a variable and store the result
45:19 - here
45:22 - and similarly for the free memory free
45:26 - memory and finally let's lock these
45:28 - values on the console so console dot log
45:33 - single code we add total memory and app
45:39 - and this total memory here now we can
45:44 - simplify this expression by using a
45:46 - template string which is available in
45:49 - more recent versions of JavaScript that
45:52 - we refer to as es6 or ES 2015 which is
45:58 - short for ACMA script 6 or 2015
46:03 - that's the specification that defines
46:04 - what features are available in
46:07 - JavaScript so every year Ahmed defines
46:10 - new features that should be added to
46:11 - JavaScript and as you know different
46:14 - browsers implement different set of
46:16 - these features but the v8 engine that we
46:19 - have inside of node that's pretty
46:21 - up-to-date and it implements a lot of
46:23 - new features of JavaScript that is
46:25 - defined in Eggman script so in Eggman
46:29 - script six or eight most script 2015 we
46:32 - have a feature called template string
46:34 - which helps us build a string without
46:37 - concatenations let me show you how that
46:40 - works so console dot log now instead of
46:45 - a single quote we use the backtick
46:48 - character backtick is the character
46:51 - before number 1 on your keyboard so here
46:54 - we add some static text like total
46:57 - memory now we want to add something here
47:01 - dynamically so we use dollar sign and
47:04 - curly braces to add a placeholder for an
47:08 - argument in this case our argument is
47:11 - this total memory variable so we can see
47:15 - with a template string we don't have
47:17 - concatenation okay now I'm gonna
47:20 - duplicate this line and change total to
47:24 - free and here let's add free memory okay
47:29 - now we don't need this first console log
47:32 - we're done with this let's go back to
47:34 - the terminal and run this app
47:36 - occasion so note app but Jas and you can
47:41 - see the total and free memory on my
47:43 - machine now what is interesting here is
47:45 - that before node we could not get this
47:48 - kind of information using javascript
47:50 - javascript used to run only inside of a
47:53 - browser and we could only work with the
47:55 - window or document objects we couldn't
47:57 - get information about the operating
47:59 - system but when using node our
48:01 - JavaScript code is executed outside of a
48:04 - browser or as some people say on the
48:07 - server with this we can get information
48:09 - about the operating system we can work
48:11 - with files we can work with the network
48:14 - for example we can build a web server
48:16 - that listens for HTTP requests on a
48:18 - given port and I'm going to show you all
48:20 - this later in this section
48:28 - and it's lecture I'm gonna show you how
48:30 - to work with files in node so I can no
48:33 - documentation and the list of modules
48:36 - here we have a module called file system
48:39 - in this module we have a comprehensive
48:42 - set of methods for working with files
48:45 - and directories now in this course I'm
48:47 - not gonna waste your time showing you
48:49 - every single method here because that
48:51 - would be very repetitive but let me show
48:53 - you an example so you see how to work
48:56 - with files in node
48:58 - so back in vs code first we need to
49:01 - require the FS module we get the result
49:06 - and store it in this constant now FS dot
49:10 - look almost every operation defined here
49:14 - comes in two forms synchronous or
49:17 - blocking and asynchronous or non
49:19 - blocking for example look we have access
49:22 - which is an asynchronous method we also
49:25 - have access sync which is a synchronous
49:27 - method now even though we have these
49:29 - synchronous methods here you should
49:32 - avoid using them these are there purely
49:34 - for simplicity in a real world
49:36 - application you should use asynchronous
49:38 - methods because these are non blocking
49:41 - so as I told you in the last section a
49:43 - node process has a single thread if
49:46 - you're using node to build the backend
49:48 - for your application you might have
49:50 - several hundreds or thousands of clients
49:52 - connecting to that back-end if you keep
49:55 - that single thread busy you won't be
49:57 - able to serve many clients so always use
50:00 - asynchronous methods now that aside
50:03 - let's take a look at an example we're
50:05 - going to look at rate dir or directory
50:09 - method first I'm going to show you the
50:11 - synchronous form because that's easier
50:13 - to understand so as the first argument
50:17 - we specify the path period slash
50:20 - represents the current folder and this
50:23 - will return all the files and folders in
50:25 - the current folder so files will be a
50:30 - string array now we can display that on
50:33 - the console very simple
50:38 - so note fjs so we can see we get an
50:42 - array of strings and these are the files
50:45 - in this folder on my machine now let's
50:48 - take a look at the asynchronous form of
50:50 - this method so FS dot read directory
50:55 - just like before the first argument is
50:59 - the path so the current folder now all
51:02 - these asynchronous methods take a
51:04 - function as their last argument no it
51:08 - will call this function when that
51:10 - asynchronous operation completes we call
51:13 - this function a callback so here look in
51:17 - the intellisense the second parameter is
51:19 - a callback and this is a function with
51:22 - two parameters an error and result which
51:26 - is in this case a string array so here
51:30 - we need to pass a function or a callback
51:33 - function with an error and the result
51:36 - which is a string array we can call that
51:39 - files so here we need to check if we
51:42 - have an error or the result only one of
51:45 - these arguments will have a value and
51:47 - the other will be not so if we have
51:49 - error
51:50 - we're going to display it on the console
51:54 - error error now this is not how we
51:57 - handle errors in a real world
51:59 - application but don't worry about this
52:01 - later in the course we have a complete
52:03 - section about error handling in note for
52:05 - now we just want to display this error
52:07 - on the console so if you have an error
52:09 - we display otherwise we display the
52:12 - result so console dot log result and we
52:17 - can display this string array so I'm
52:21 - gonna comment out these two lines so we
52:24 - can only look at the result of this
52:26 - asynchronous read directory now note up
52:30 - j/s so we got resolved and this is
52:33 - exactly the string array that we had
52:36 - before
52:36 - now let's simulate an error so I'm going
52:40 - to go back in the code and change this
52:42 - argument to let's say a dollar sign save
52:47 - back in the terminal node fjs this time
52:51 - we go
52:52 - and error no such file or directory
52:56 - so to recap in order to work with files
52:59 - and directories in node first you need
53:01 - to require the FS module and then use
53:04 - one or more of the methods defined in
53:06 - this module all these methods come in
53:09 - pairs asynchronous and synchronous
53:11 - always prefer to use asynchronous
53:13 - methods
53:19 - one of the core concepts in node is the
53:21 - concept of events in fact a lot of nodes
53:25 - core functionality is based on this
53:28 - concept of events an event is basically
53:30 - a signal that indicates that something
53:34 - has happened in our application for
53:37 - example in node we have a class called
53:39 - HTTP that we can use to build a web
53:42 - server so we listen on a given port and
53:45 - every time we receive a request on that
53:47 - port that HTTP class raises an event now
53:51 - our job is to respond to that event
53:54 - which basically involves reading that
53:56 - request and returning the right response
53:58 - so as you go through note documentation
54:01 - you can see that several classes in node
54:04 - raises different kinds of events and in
54:07 - your code you might be interested to
54:09 - respond to those events so in this
54:12 - lecture I'm gonna show you how to work
54:14 - with the events module now back in notes
54:18 - documentation once again in the list of
54:20 - modules you can see here we have this
54:24 - events module so in this module we have
54:28 - one class that is called event emitter
54:31 - it's one of the core building blocks of
54:33 - node and a lot of classes are based on
54:36 - this event emitter so let's see how we
54:39 - can work with this event emitter
54:42 - I can be ESCO first let's load the
54:45 - events module so require events here
54:50 - when we call the require function we get
54:53 - the event emitter class so constant
54:56 - event emitter note that here in terms of
55:01 - the naming the first letter of every
55:03 - word is uppercase this is the convention
55:07 - that indicates that this event emitter
55:10 - is a class it's not a function it's not
55:13 - a simple value it's a class a class is
55:16 - container for properties and functions
55:19 - which we call methods so in this event
55:21 - emitter class
55:24 - we have these metals that you see here
55:26 - in the documentation so a class is a
55:28 - container for a bunch of related methods
55:31 - and properties now here in order to use
55:35 - this event emitter first we need to
55:37 - create an instance of this class so
55:40 - constant emitter we set this to new
55:44 - event emitter so here this emitter is an
55:48 - object in case you don't know the
55:50 - difference between a class and an object
55:52 - let me give you a metaphor a class is
55:55 - like human and an object is like an
55:57 - actual person like John Mary and so on
56:01 - so a class defines the properties and
56:04 - behavior of a concept like a human but
56:07 - an object is an actual instance of that
56:11 - class okay so here this first event
56:15 - emitter is a class it's a blueprint it
56:18 - defines what an event emitter can do but
56:21 - this second emitter is an actual object
56:23 - this is the one that we're going to use
56:25 - in our application so this emitter has a
56:30 - bunch of methods look these are all the
56:33 - metals that you saw in the documentation
56:36 - now even though here we have more than
56:38 - ten metals most of the time we use only
56:40 - two of these methods one is emit that we
56:44 - use to raise an event the first time I
56:47 - saw this method it didn't make sense to
56:49 - me because English is my second language
56:51 - and I didn't know what emit means so if
56:55 - you're in the same boat ma it basically
56:57 - means making a noise or produce
56:59 - something in this case you're making a
57:02 - noise in your application you're
57:04 - signaling that an event has happened
57:07 - okay so that's the meaning of Emmet and
57:10 - here we pass an argument that is the
57:13 - name of the event let's say message
57:16 - locked
57:18 - in the future we're going to extend our
57:20 - lager module and every time we log a
57:23 - message we're going to raise an event
57:25 - called message locked okay now if you
57:29 - run this application nothing is going to
57:31 - happen let me show you back in the
57:33 - terminal node app J gasps look nothing
57:36 - happened because we have raised an event
57:39 - here but nowhere in our application we
57:43 - have registered a listener that is
57:45 - interested in that event a listener is a
57:48 - function that will be called when that
57:50 - event is raised
57:52 - okay so let's register a listener that
57:55 - will be called when the message log
57:58 - event is raised so register a listener
58:03 - so emitter dot look here we have this
58:07 - method add listener but we have an alias
58:09 - for this that we use more often that is
58:12 - on if you're worked with jQuery you have
58:14 - seen this before
58:15 - so on or add listener they're exactly
58:18 - the same but quit often reused on method
58:21 - now this method takes two arguments the
58:24 - first one is the name of the event in
58:26 - this case message locked and the second
58:31 - one is a callback function or the actual
58:34 - listener so here we pass a function and
58:36 - this function will be called when that
58:39 - event is raised okay now for now I just
58:43 - want to lock a message in the console so
58:45 - console let's say listener called like
58:51 - this now let's run this application so
58:56 - node FJ guess and we got this message
58:58 - listener call so this indicates that
59:02 - when we raise this event
59:06 - function or listener was called okay and
59:09 - of course the order is important here if
59:12 - you register this listener after calling
59:16 - the Amit method nothing would have
59:17 - happened because when we call the Amit
59:19 - method this eMeter iterates over all the
59:23 - registered listeners and calls them
59:25 - synchronously okay so this is the basic
59:28 - of raising events and handling them
59:31 - using the eve an emitter class
59:38 - now quite often when you want to raise
59:41 - an event we also want to send some data
59:43 - about that event for example in our
59:47 - lager module when we log a message
59:49 - perhaps our remote login service will
59:52 - generate an ID for that message perhaps
59:55 - we want to return that ID to the client
59:58 - or it may give us a URL to access that
60:01 - log message directly so here when
60:04 - raising an event we can add additional
60:06 - arguments which we refer to as event
60:09 - arguments so we can add an ID like one
60:13 - and we can add a URL but as you can see
60:18 - these magic values here are a little bit
60:20 - confusing if you want to send multiple
60:22 - values about an event it's a better
60:25 - practice to encapsulate those values
60:28 - inside an object so here we have an
60:32 - object we give it a couple of properties
60:34 - like ID we set it to ID of this message
60:37 - that is logged and another property URL
60:41 - like this okay so we're referring to
60:44 - this object as event argument now when
60:50 - registering a listener here this
60:52 - callback function this actual listener
60:54 - can also receive this event argument so
60:58 - here we add a parameter called arc we
61:02 - can call it anything the name doesn't
61:04 - matter
61:04 - but by convention we often use arc or
61:07 - some people use e to refer to the event
61:10 - or event arc whatever you prefer is
61:14 - perfectly fine so here we have arc now
61:17 - let's log in on the console very simple
61:22 - let's run this application so note okay
61:27 - look listen are called and here's our
61:30 - event arc and with this technique we can
61:33 - pass data about the event that just
61:35 - happened
61:37 - now one last thing to make this code a
61:39 - little bit simpler in es6 or equal
61:42 - script six we have this feature called
61:44 - arrow function with an arrow function we
61:49 - can get rid of this function keyword so
61:52 - here we have the arguments and after
61:54 - that we have the body of that function
61:56 - now to separate the two we use an arrow
62:00 - and that's why we call this arrow
62:02 - function you can see this syntax is a
62:04 - little bit simpler and a lot of people
62:06 - prefer to use arrow functions in es6 now
62:10 - here's a simple exercise for you let's
62:12 - imagine in our lager module just before
62:15 - calling our remote service to log the
62:18 - message we're going to raise an event
62:21 - called logging and while raising this
62:25 - event we also want to send some data
62:28 - that is the message that we're going to
62:31 - lock so what I want you to do is to use
62:34 - what you have learned in this lecture
62:36 - and raise and handle is logging event
62:39 - it's a very simple exercise I just want
62:41 - you to get used to this syntax
62:48 - now in the real world is quite rare that
62:51 - you would work with this event emitter
62:54 - object directly instead you want to
62:57 - create a class that has all the
62:59 - capabilities of the event emitter and
63:02 - then you will use that class in your
63:04 - code let me explain what I mean by that
63:06 - and why so let's open up our lager
63:10 - module so in this module we're exporting
63:13 - a simple function log right and here we
63:17 - log that message on the console now
63:19 - after this we want to raise an event and
63:23 - then later in app module we will listen
63:25 - for that event and do something so let's
63:28 - go back to our app module and copy some
63:31 - code into the lager module so on the top
63:34 - I'm gonna copy these two lines to bring
63:37 - the event emitter in this module okay
63:41 - now back in app module I'm also gonna
63:44 - move these two lines for raising an
63:47 - event into the lager module because this
63:49 - code should not be here it's the lager
63:51 - module that emits or signals an event
63:55 - saying the message is locked so cut so
63:59 - here after we log the message you raise
64:02 - an event like this okay
64:05 - now back in app module we don't need
64:09 - this comment here we need to load the
64:11 - lager module and call the log function
64:14 - so constant log we call the require
64:19 - function and set the path to the lager
64:22 - module and here we simply call the log
64:26 - function with a message okay now when we
64:31 - run this application we are only going
64:33 - to see this message on the console in
64:36 - other words this event listener will not
64:39 - be caught let's verify that and then I
64:42 - will explain why that happens
64:44 - so back in terminal node app J s look we
64:50 - only got the message on the console so
64:53 - our event listener was not caught the
64:56 - reason for this is because here we're
64:59 - working with two different event
65:02 - emitters in app j/s we have this even
65:05 - emitter object and in longer module we
65:09 - have another event emitter object so
65:13 - earlier I told you that a class is like
65:15 - a blueprint and an object is an actual
65:18 - instance as a metaphor I said we could
65:21 - have a class called
65:22 - human or person but the objects could be
65:25 - Jack John Mary Bob whatever so in this
65:28 - case we have two different objects in
65:30 - the logger module you're using this
65:33 - emitter object to emit an event whereas
65:37 - in app module we're using another event
65:40 - emitter object to handle that event
65:43 - these are completely different so when
65:46 - we register a listener here that
65:49 - listener is only registered with this
65:51 - event emitter which is completely
65:53 - different from the other event emitter
65:56 - so that's why I told you in your
65:59 - applications it's very rare that you
66:01 - would want to work with this event
66:02 - emitter directly instead you want to
66:04 - create a class that has all the
66:06 - capabilities of this event emitter but
66:09 - it has additional capabilities in this
66:12 - case we want to create a class called
66:14 - logger that has this additional method
66:17 - lock okay so the first thing you want to
66:21 - do here is to define a class in es6 we
66:24 - have this keyword class which is a
66:26 - syntactical sugar for creating a
66:29 - constructor function with this we can
66:31 - define a class logger note that the
66:34 - first letter of every word in a class
66:37 - should be uppercase this is the Pascal
66:39 - case convention that we use for naming
66:42 - classes so class logger we have a code
66:46 - block now we need to move this log
66:49 - function inside this logger class so cut
66:53 - paste it here now we have an error
66:56 - because when we define a function inside
66:58 - a class we don't need this function
67:00 - keyword and from now on we refer to this
67:03 - function as a method so when a function
67:06 - is inside a class we say that's a method
67:09 - in that class okay so here we have this
67:11 - logger class now at the end
67:15 - I'm exporting the log function we're
67:17 - going to export the logger class okay
67:21 - now we want this logger class to have
67:23 - all the capabilities of this event
67:26 - emitter the way we do that is by using
67:29 - the extends keyword that comes in es6 so
67:33 - extends and here we add the name of the
67:36 - parent or the base class so event
67:40 - emitter and with this simple change this
67:44 - logger class will have all the
67:46 - functionality that is defined in event
67:49 - emitter so here when raising this event
67:52 - instead of using this emitter object
67:55 - we're going to use this so in this class
67:59 - we can directly omit or raise events
68:03 - okay and now we no longer need this
68:06 - actual emitter object because we have
68:09 - not used it anywhere in this code so
68:12 - delete we're done with the logger module
68:15 - now back in the app module
68:18 - so here when requiring the logger module
68:21 - we get a class so I'm gonna rename this
68:24 - to lager with capital L that's a class
68:28 - now we create an object so new lager
68:37 - and then to log a message recall logger
68:40 - deadlock now similar to the change that
68:44 - we made in the logger module we no
68:47 - longer need this event a meter object
68:49 - here we want to work directly with this
68:52 - logger object so we're gonna register
68:55 - this listener on this logger object okay
68:59 - so I'm gonna move this code after
69:05 - creating the logger we say hey logger
69:09 - when you raise this message log event I
69:13 - want to execute this code okay and
69:16 - finally you can see we no longer need
69:18 - this event emitter object it's not used
69:21 - anywhere delete now when you run this
69:25 - application we're going to see this
69:27 - message on the console but also because
69:30 - we're using the same logger object for
69:33 - registering an event listener and also
69:35 - raising an event we're going to see this
69:38 - message on the console so note fjs look
69:44 - this is the message on the console and
69:47 - you can see our listener was
69:49 - successfully caught so let's quickly
69:51 - recap if you want to raise events in
69:55 - your application to signal that
69:57 - something has happened you need to
69:58 - create a class that extend event emitter
70:02 - with this that class will have all the
70:05 - functionality defined in event emitter
70:07 - but you can also add additional
70:10 - functionality in this case we have the
70:12 - ability to log a message and then inside
70:15 - that class whenever you want to raise an
70:17 - event you use this that emit because
70:20 - this references this longer class itself
70:23 - which extends event emitter so all the
70:27 - methods defined an event emitter will
70:29 - also be part of this class okay and
70:32 - finally in app module again instead of
70:36 - using an instance of event emitter you
70:40 - will use an instance of the custom class
70:43 - that you have defined that extends event
70:46 - emitter
70:51 - one of the powerful building blocks of
70:53 - node is the HTTP module that we use for
70:57 - creating networking applications for
71:00 - example we can create a web server that
71:02 - listens for HTTP requests on a given
71:05 - port and with this we can easily create
71:07 - a back-end service for our client
71:10 - applications like a web application that
71:12 - we build with react or angular or a
71:15 - mobile application running on a mobile
71:17 - device so once again back in the note
71:20 - documentation in the list of modules we
71:22 - can find this HTTP module in this module
71:27 - you can see various classes like HTTP
71:29 - that agent HTTP that client requests and
71:33 - so on each of this classes has a bunch
71:35 - of properties methods and events so back
71:39 - in vs code let's load the HTTP module so
71:43 - constant HTTP we set it to require HTTP
71:49 - okay now here we can call HTTP dot
71:53 - create server this is one of the
71:57 - functions defined in this module and
71:59 - with this we can create a web server so
72:03 - let's store the result in a server
72:05 - object now what is interesting is that
72:09 - this server is an event emitter so it
72:13 - has all the capabilities of event
72:15 - emitter that you saw earlier in this
72:17 - section so look server dot we have the
72:21 - on method or add listener or omit and so
72:25 - on also if you look at the documentation
72:29 - for the HTTP module on this page you can
72:32 - see HTTP that's server class here the
72:36 - documentation says that this class
72:37 - inherits from net dot server so this is
72:40 - another class defined in the net module
72:43 - let's have a look now here the
72:47 - documentation says that net the server
72:49 - is an event emitter so that's why I said
72:53 - a bunch of notes core functionality is
72:55 - based on if an emitter so back to our
72:59 - server object now we can call server
73:02 - that listen
73:05 - and give it a port let's say port 3000
73:08 - now following that I'm gonna add a
73:11 - console deadlock saying listening on
73:16 - port 3000 okay now when we run this
73:20 - application this server will listen on
73:22 - port 3000 as I told you before every
73:25 - time there is a new connection or new
73:27 - request this server raises an event so
73:31 - we can use the own method to handle that
73:34 - event so before listening we want to
73:36 - register a listener or a handler so
73:39 - server dot on the name of the event is
73:44 - connection then you can find in the
73:46 - documentation so you don't have to
73:48 - memorize any of these stuff okay and the
73:51 - second argument is a callback function
73:54 - or the actual listener as you can see in
73:57 - the tooltip here this listener is a
74:00 - function with one argument that is
74:01 - socket of type socket class and it
74:05 - returns void so here we have the arrow
74:08 - function syntax in es6 so let's add an
74:11 - error function that takes a socket and
74:14 - goes to this code block now here we can
74:19 - simply log something on the console new
74:22 - connection now back in the terminal
74:28 - let's run this application we can see we
74:31 - are listening on port 3000
74:34 - now back in the browser let's head over
74:36 - to localhost port 3000 and now if you
74:40 - look in the terminal you can see we have
74:42 - a new connection here so you can see
74:45 - this server object raises different
74:47 - kinds of events that you can respond to
74:49 - now in real world applications we are
74:51 - not going to respond to the connection
74:53 - event to build an HTTP service this is
74:56 - very low level so let's delete this what
75:01 - we commonly do is we pass a callback
75:04 - function to this create server method so
75:07 - function this function takes two
75:10 - parameters request and response or we
75:16 - can use the error function syntax so we
75:18 - remove the function keyword and add this
75:21 - fat arrow here now in this function
75:25 - instead of working with a socket we can
75:27 - work with the actual request or response
75:30 - objects so we can check if request that
75:33 - URL equals slash then we can send
75:38 - something to the client for example
75:39 - response dot write hello world and then
75:46 - we end the response okay now back in the
75:51 - terminal we can exit here by pressing
75:54 - ctrl + C and then run the application
75:58 - again okay we're still listening on port
76:00 - 3000 let's refresh this page so we got
76:04 - hello world on home page now if you want
76:08 - to build a back-end service for our web
76:10 - or mobile applications we need to handle
76:13 - various routes here for example we can
76:16 - have another if block if requested URL
76:20 - equals slash API slash courses
76:24 - perhaps here we want to return the list
76:26 - of courses from the database so we would
76:30 - do something like this response dot
76:33 - right here we want to return an array of
76:36 - objects using JSON so we use JSON dot
76:41 - stringify and give it an array of
76:45 - objects now for simplicity here we don't
76:47 - have to worry
76:48 - the database or complex objects let's
76:51 - just return an array of numbers 1 2 & 3
76:56 - so we pass this to json stringify which
77:00 - will convert this array into a string
77:02 - using json syntax and then we'll write
77:05 - it to the response and finally response
77:07 - the end now back in the terminal we need
77:13 - to stop this process again and run it
77:17 - one more time now in the future I will
77:18 - show you how we can automate this so
77:21 - every time we make a simple change to
77:22 - our application we don't have to restart
77:24 - it so now back in the browser if we go
77:28 - to slash API slash courses we get an
77:32 - array with three numbers so as you see
77:36 - building a web server we know it is very
77:38 - easy now in the real world we are not
77:40 - going to use this HTTP module to build a
77:43 - back-end service for our application the
77:46 - reason for this is because as you can
77:48 - see here as we add more routes this code
77:52 - gets more complex because we add all of
77:55 - them in a linear way inside this
77:58 - callback function so instead we use a
78:00 - framework called Express which gives our
78:03 - application a clean structure to handle
78:06 - various routes internally the Express
78:09 - framework is built on top of the HTTP
78:12 - module in node