00:03 - Hi! Thank you for taking my C#
tutorial for beginners. Let me quickly give you an
00:08 - overview of what you're going to learn
and how I've structured this tutorial. In the
00:12 - first section, I'm going to talk about
fundamentals of C# and .NET.
00:16 - one of the questions that a lot of
beginners ask is what is the difference
00:20 - between C# and .NET so I'm going
to cover that I'm also going to talk
00:24 - about CLR assemblies namespaces IL code
and stuff like that then over the next
00:31 - two sections I'm going to talk about
types I'm going to talk about primitive
00:35 - and non primitive types now at this
point you still cannot write any C#
00:40 - programs but I have designed a number of
quizzes to help you reinforce what
00:44 - you're going to learn then from Section
four where I talk about control flow
00:49 - you're going to start writing simple
C# programs and from that section
00:53 - onwards in every section you're going to
learn something new about C# and
00:57 - you're going to write more interesting
programs and finally I'm going to
01:01 - conclude this course with a section on
debugging so I'm going to show you some
01:05 - of the tools we have so when you have
bugs in your code you know how to find
01:09 - them and get rid of them I'm also going
to talk about some good program
01:13 - practices that help you write better and
more reliable code so we have a lot to
01:18 - cover and let's get started okay so this
is the very first section of this course
01:24 - in this section I'm going to start by
teaching you the very basics of C#
01:29 - one of the questions that a lot of
beginners ask is what is the difference
01:33 - between C# and net so that's the
first thing I'm going to answer here
01:37 - next I'm going to talk about CLR or
common language runtime which is the
01:42 - runtime environment for .NET
applications next I'm going to talk
01:47 - about the architecture of .NET
applications and as part of this I'm
01:51 - going to introduce you to concepts such
as classes namespaces and assemblies and
01:57 - finally I will show you all these
concepts in action I'm going to
02:01 - introduce you to the very basics of
visual studio and write a very simple
02:05 - C# application so you can see
classes namespaces and methods in action
02:11 - I hope you enjoyed this section and
let's get started
02:15 - okay what is darknet framework and how
is it different from C# some
02:20 - developers who are absolutely new to
C# don't know the difference so in
02:23 - this lecture I'm going to talk a little
bit about C# and .NET framework
02:26 - C# is a programming language .NET
is a framework for building applications
02:33 - on the windows .NET framework is not
limited to C# there are different
02:38 - languages that can target that framework
and build applications using that
02:41 - framework examples are F sharp or vb.net
okay now but what exactly is .NET
02:48 - framework Dartmouth framework consists
of two components one is called CLR or
02:54 - common language runtime and the other is
a class library for building
02:58 - applications in the next lecture we'll
talk about CLR in more detail
03:06 - okay before we understand what CLR is
and why we need it let me explain a
03:11 - little bit about the history of C#
before C# we had two languages in
03:16 - the C family the C language and C++ with
either of these languages when we
03:22 - compiled our application the compiler
translated our code into the native code
03:28 - for the machine on which it was running
which means if I wrote an application in
03:33 - C++ on a Windows machine with 8086
processor architecture the compiler
03:40 - would translate my code into the native
code for that machine that is a Windows
03:45 - machine with an 8086 processor now we
only have different hardware's and we
03:50 - have different operating systems so if I
took the application that compile the
03:55 - application on the computer with a
different architecture that would not
04:00 - run so when Microsoft was designing the
C# language and the .NET
04:04 - framework they came up with an idea that
they borrowed from the Java community in
04:09 - Java when you compile your code it's not
translated directly into the machine
04:14 - code it's translated into an
intermediate language called bytecode
04:18 - and we have the exact same concept in
C# so when you compile your C#
04:23 - code the result is what we call IL or
intermediate language code is
04:28 - independent of the computer on which
it's running now we need something that
04:33 - would translate that il code into the
native code or the machine that is
04:39 - running the application and that is the
job of CLR or common language runtime so
04:46 - CLR is essentially an application that
is sitting in the memory whose job is to
04:51 - translate the il code into the machine
code and this process is called
04:56 - just-in-time compilation or JIT
so with this architecture you can write
05:02 - an application in C# and you don't
have to worry about compiling that into
05:06 - the native code for different machines
as long as a machine has CLR that can
05:11 - run your application
05:16 - okay now let's learn about the
architecture of .NET applications at a
05:22 - very high level when you build an
application with C# your
05:26 - application consists of building blocks
called classes these classes collaborate
05:32 - with each other at runtime and as a
result the application provides some
05:36 - functionality now what is a class a
class is a container that has some data
05:42 - which is also called attributes and
functions which is also called methods
05:48 - functions or methods have behavior they
execute code they do things for us data
05:55 - represents the state of the application
let me use an example think of a car the
06:02 - car has some attributes like its make
its model its color these are the
06:08 - attributes of a car a car also has some
functions we can start it or we can move
06:15 - it so you can think of a car as a class
in a real world application we have tens
06:22 - hundreds or even thousands of classes
each class responsible for a piece of
06:27 - functionality an example of that is
classes that are responsible for getting
06:32 - the data from the user process the data
and display something to the user
06:37 - now as the number of classes in an
application grows we need a way to
06:42 - organize these classes that's where we
use a namespace so a namespace is a
06:48 - container for related classes for
example in .NET framework we have
06:53 - namespaces each containing tens of
related classes we have namespaces for
06:59 - working with data like databases we also
have namespaces for working with
07:04 - graphics and images we have namespaces
for working with security now in real
07:10 - world application as these namespaces
grow we need a different way of
07:14 - partitioning an application and that's
where we use an assembly and assembly is
07:20 - a container for related namespaces
physically
07:25 - it's a file on the disk which can either
be an executable or a DLL which stands
07:32 - for dynamically linked library so when
you compile an application the compiler
07:38 - builds one or more assemblies depending
on how you partition your code in the
07:44 - next lecture we're going to write a very
simple structure application and you're
07:47 - going to see all these concepts in
action
07:53 - okay in this video we're going to have a
quick tour of visual studio and build a
07:57 - very simple C# application so here
I've got Visual Studio open let's go to
08:02 - file new project
08:07 - okay in this dialogue on the left side
we've got a section called templates and
08:12 - here you see the kind of applications we
can build with C#
08:16 - so as you see in the list we can build
desktop applications web applications
08:21 - apps for cloud mobile services workflows
and various kind of things but in this
08:27 - course and the subsequent parts of this
course we're just going to focus on
08:31 - console applications a console
application is a very simple application
08:36 - that does not have a graphical user
interface and it's a great learning tool
08:40 - for learning a new language so we're not
going to be distracted by various
08:44 - complexities of larger applications so
on the left side select windows and on
08:50 - the right side select console
application
08:54 - then give a name to your project so
let's call it hello world which is a
08:59 - common tradition when learning a new
language and specify a location you can
09:04 - put it wherever you want I know this
concept of solution in Visual Studio we
09:09 - have this concept of solution which can
have one or more projects with a very
09:15 - simple application you have only one
solution and one project but as your
09:18 - application grows you add more projects
each responsible for something different
09:23 - but now we don't have to worry about it
now click OK
09:28 - alright let's see what's happening here
some developers get a little bit
09:34 - intimidated the first time they open
visual studio and that's very enough
09:37 - because there are so many menus and
panels here that is a bit confusing but
09:42 - let me tell you something
90% of the time you're going to use only
09:45 - 10% of these or even less so don't worry
about all these menus here you don't
09:50 - need to use all of them at all times
90% of the time all you need is the code
09:55 - editor here
sometimes you need the solution Explorer
09:59 - in fact I personally hardly ever use
solution Explorer because I do
10:04 - everything with my keyboard and if you
watch my course double your coding speed
10:07 - you will see that everything is possible
with keyboard so you don't need these
10:11 - panels here you don't need to grab your
mouse and navigate around you don't
10:15 - really need this stuff
also none of the stuff on the toolbar
10:19 - are ever required don't worry about it
everything you can do with your keyboard
10:25 - alright now let's take a look at this
first to char program so we created a
10:29 - console application and on the right
side you see the solution Explorer panel
10:33 - in case you don't see that go to view
and select solution Explorer
10:40 - top you see we have a solution which has
only one project under that we've got
10:44 - the project called hello world look at
these four items here properties expand
10:50 - that we have a file here called assembly
info this is the identification or the
10:56 - assembly that will be produced as a
result of compiling this application so
11:01 - when we compile the console application
we're going to get an executable and
11:04 - that's an assembly that assembly has an
identification look at these attributes
11:08 - here like the title description which is
currently not set company product
11:15 - copyright trademark culture a grade you
know various kind of things like even
11:20 - version so these are all part of
assembly identification or assembly
11:25 - manifest in most cases you don't have to
worry about it but if you want to create
11:30 - an assembly and you want to distribute
it send to other people then you may
11:34 - want to come here and give you the
proper name and a proper version so for
11:38 - now we don't have to worry about it
11:42 - on the references you see any assemblies
that this project is referencing to do
11:48 - its job when you create a project with
visual studio by default it as a
11:53 - reference to a bunch of assemblies that
you'll see here these are all part of
11:57 - .NET framework so at a minimum Visual
Studio assumes you're going to use
12:02 - classes in system assembly or system the
data to work with databases and so on
12:08 - you may not necessarily use all these
assemblies in your project but that's
12:12 - just part of the template
12:15 - config' is an XML where we store the
configuration for this application
12:20 - sometimes you may want to store
connection strings to the database or
12:24 - you may want to have some settings about
your application all of them will end up
12:29 - here
and finally you see program dot C s
12:32 - which is where we are going to start
writing code all right let's see what's
12:37 - happening here
so in this file program that C S on the
12:41 - top you see a bunch of using statements
what is this all about
12:45 - well our project is called hello world
so by default Visual Studio creates a
12:50 - namespace called hello world when we
write code in this namespace we have
12:56 - access to any classes defined in this
namespace so if you want to use a class
13:00 - that is defined in a different namespace
we need to import it in our code file
13:05 - and that's why we use the using
statement so by default Visual Studio as
13:10 - these five using statements system is a
namespace in .NET framework and that's
13:16 - where we have all these basic utility
classes and primitive types there
13:21 - system that collections that generic is
used to work with lists collections and
13:26 - so on
system that link is used to work with
13:30 - data and it's a comprehensive topic that
I have covered in my C# Advanced
13:35 - Course system the text is used to work
with tags and coding and stuff like that
13:40 - and finally system the threading is used
to build multi-threaded applications in
13:45 - this video we're going to create a very
simple application and we're not going
13:49 - to use any of these for namespaces here
so we're just going to use system for
13:56 - now I'll leave them there and then I
will show you how to clean them up all
13:59 - right so here's our namespace and
insight namespace by default we have a
14:04 - class called program so every console
application you create with Visual
14:08 - Studio has a class called program inside
program by default we have a method or a
14:14 - function called main and that's the
entry point to the application so when
14:19 - you run your application CLR execute the
code inside main method and that's where
14:25 - everything kicks off this method is
declared as static and that's something
14:30 - I'm going to cover later in the next
section methods have input and output so
14:36 - what goes inside parenthesis is the
input to the method which we call
14:40 - parameter or argument note that
parameters are optional but in this case
14:45 - in the default template the main method
has a parameter called args which is of
14:49 - type string array we're going to learn
about string array in the next section
14:54 - what you see before the method name is
the return type or the output of the
14:58 - method void in C# means nothing
that means this method does not return
15:03 - any value it just contains some code
that's it
15:07 - also note that C# is a case
sensitive language so this main has to
15:13 - be with capital M otherwise CLR is not
going to find this method as the entry
15:18 - point of the application okay and one
last thing is note these curly braces so
15:23 - where we have a block of code we need to
surround it with curly braces so that is
15:31 - applicable for methods for classes and
for namespaces
15:36 - alright now let's write a very simple
C# program so let's go here we have
15:42 - a class called console which is used to
read data from console or write data to
15:49 - it it has a bunch of methods
access this method using the dot
15:53 - notation
and here you see various members of this
15:59 - class methods are indicated by a purple
cube so beep is used to play a beep
16:05 - sound or clear is used to clear the
console we're going to use the right
16:10 - line method
this method can optionally take a
16:14 - parameter so I'm going to pass a string
here hello world just that I note that
16:23 - statements in C# terminate with a
semicolon as you see here
16:27 - now take a look at using system on the
top
16:31 - do you see that it's highlighted whereas
the others are grayed out the reason for
16:36 - that is in this file we are using a
class called console which is defined in
16:41 - the system namespace that's why that
using statement is active we are not
16:46 - using any classes defined in other
namespaces and that's why they're grayed
16:51 - out
16:53 - so we can get rid of them to make our
code cleaner we can either delete each
16:56 - one by ctrl X like that or if you're
using resharper you can get rid of all
17:03 - of them
by pressing Alt + Enter here and
17:06 - selecting the first option which is
remove unused directives in file so it's
17:11 - faster now let's run the application
with ctrl + f5
17:20 - so this window that you see here this
black window is what we call console and
17:24 - that's why this kind of project is
called console application
17:29 - you
okay that's it for this lecture from
17:33 - this point in every lecture we're going
to learn something new about C# and
17:36 - we can write more interesting and more
complex programs I hope you enjoyed this
17:40 - lecture and thank you for watching
well hello it's mush here your C#
17:45 - instructor I just wanted to quickly let
you know that this video you've been
17:49 - watching is actually part of my C#
basics course on udemy in this course I
17:54 - walk you through all the core concepts
of C# in a step-by-step fashion
17:58 - plus you get access to exercises cheat
sheets and a discussion board to ask
18:03 - your questions in case you're interested
you can get this course with a discount
18:07 - using the link in the video description
and if not that's perfectly fine
18:11 - continue watching as the next section is
coming up okay this section is going to
18:21 - be the first step in your journey to
learn C# so I'm going to introduce
18:25 - you to variables and constants I'm going
to talk about various data types and
18:29 - type conversion I'm going to talk about
scope and overflowing and finally I'm
18:35 - going to talk about various operators we
have in C# so let's get started
18:42 - okay we are going to start our journey
by learning about variables and
18:46 - constants
18:50 - a variable is a name that we give to a
storage location in memory where we can
18:55 - store a value any constant in an
immutable value that is a value that we
19:00 - know at compile time and that value
cannot change throughout the life of the
19:04 - application why do we use constants the
reason for that is to create safety in
19:09 - our application imagine you're creating
an application that involves some
19:13 - mathematical computation around circles
we have this number called P which is
19:18 - 3.14 and we use that to calculate the
area of a circle that number should
19:25 - always be the same we don't want to
accidentally change that in our program
19:29 - if you accidently change that everything
is going to blow up in terms of the
19:33 - results the program produces so we
declare that number as a constant
19:39 - and this way we create safety in our
application in C# to declare a
19:45 - variable we start with the type followed
by an identifier and finally semicolon
19:52 - here ain't represent integer which is a
number between minus 2 billion and plus
19:58 - 2 billion later in this video I will
show you all the primitive types that
20:02 - you need to know
also note that C# is a case
20:06 - sensitive language which means in this
case these two identifiers are different
20:11 - one has lowercase n and 1 has uppercase
n
20:16 - when declaring a variable we can
optionally assign it the value like what
20:20 - you see here you don't have to but there
is one thing you need to know about
20:24 - variables and that is you cannot use a
variable unless you initialize it so
20:29 - let's say if I declare this int number
here and I decide to display it on the
20:34 - console my application will not become
part I have to assign it a value before
20:39 - I can use it before I can read it I will
show you that later when we jump to
20:43 - coding
to declare constant we start with the
20:47 - keyword cunt next we have the datatype
and an identifier and here we have to
20:52 - initialize it with some value we cannot
define a constant without setting its
20:57 - value
20:59 - there are a few things you need to know
about identifiers first one is that an
21:03 - identifier cannot start with a number so
you cannot have an identifier like the
21:07 - one you see here instead you need to
replace one with the word one
21:14 - so an identifier cannot include
whitespace so you cannot have an
21:17 - identifier like first space name it has
to be one word an identifier cannot be a
21:24 - reserved keyword like int that you saw
earlier if you are desperate to use a
21:29 - word that coincidentally clashes with
one of the C# keywords you can
21:33 - perfect that with the add sign
and finally as a recommendation always
21:39 - use meaningful names for example avoid a
name like f n instead use first name
21:45 - this way your code will be more readable
or maintainable and cleaner and
21:49 - everybody will understand that
21:52 - in terms of naming convention here are
three popular naming conventions that
21:57 - have been around in the C language
family
21:59 - we've got camelcase Pascal case and
Hungarian notation with camelcase as you
22:07 - see I have bolded here the first letter
of the first word is lowercase and the
22:13 - first letter of every word after has to
be uppercase with Pascal case the first
22:18 - letter of every word has to be uppercase
with Hungarian notation we prefix the
22:24 - name of a variable with the datatype it
uses so here str represents a string
22:30 - Hungarian notation is not used in
C# and I have noticed programmers
22:35 - coming from C or C++ background use that
in their code if you're one of them I
22:40 - highly recommend you not to use
Hungarian notation because C#
22:44 - developers are not used to that and they
don't like to see Hungarian notation in
22:47 - the code it makes your code look a
little bit ugly
22:50 - so in C# to name your local
variables use camel case so as you see
22:55 - here the first letter of the first word
is lowercase and if we had more words
23:00 - here in the identifier the first letter
of every word had to be uppercase four
23:06 - constants use Pascal case so here you
see I've got a constant here constant
23:10 - integer and the first letter of every
word is uppercase here is the list of
23:16 - most commonly used primitive types in
C# in fact the actual list is
23:21 - slightly bigger than this but I
deliberately decided not to include
23:24 - those data types because they're hardly
ever used in fact they are there for
23:29 - interoperability with other languages I
personally over the past 12 years of me
23:34 - coding in C# I've hardly ever used
them in fact never so I decided not to
23:39 - confuse you with too much details that
you don't need in the next slide I've
23:43 - got a link here in case you want to
learn about the other primitive types so
23:47 - let's take a look at the table here on
the left side I have divided these
23:51 - datatypes into four categories integral
numbers real numbers character and
23:56 - boolean
this column shows the C# data times
24:00 - and these are C# keywords note that
C# keywords are always lowercase
24:05 - each of these C# keywords or C
sharp types maps to a type in .NET
24:10 - framework which is displayed in this
column
24:13 - so these types are part of the.net
framework and when you compile your
24:18 - application the compiler internally
would translate the C# keyword you
24:23 - use here two equivalent .NET type
the third column here shows the number
24:29 - of bytes each data type uses and I have
listed these data types from the
24:33 - smallest to the largest in each category
so in the category of integral numbers
24:37 - you see byte is the smallest it takes
only one byte whereas long is the
24:42 - largest and it takes 8 bytes the more
bytes we have the more storage we have
24:47 - and we can store larger numbers you
don't really have to memorize the range
24:51 - of each data type but remember white can
store a value between 0 to 255 short can
24:58 - store a value between minus 32,000 to
plus 32,000 integer can store a value
25:05 - between minus 2 billion to Plus 2
billion and long is even bigger than
25:09 - that
in terms of real numbers we have three
25:12 - data types float double and decimal
float maps to the single type in that
25:18 - framework and it takes four bytes and as
you see it can store a very large number
25:22 - double is twice as big so it uses eight
bytes and decimal uses sixteen bytes the
25:29 - more precision you need the bigger data
type you use we also have character
25:34 - which is represented by char keyword and
it's two bytes so characters in C#
25:39 - are unicode and finally we have bull
which represents boolean which can be
25:44 - either true or false
in case you want to learn more about the
25:48 - other data types that I told you they're
not really used you can simply go to
25:52 - Google and search for C# built-in
types and the first page is the MSDN
25:56 - page that lists all the primitive types
in C#
26:01 - and most of these data types are pretty
straightforward but there is something
26:04 - tricky about real numbers in this table
I have listed the data types we have for
26:09 - real numbers load double and decimal
I've highlighted double because that's
26:14 - the default data type used by a C#
compiler when you're using real numbers
26:20 - so if you want to declare a float you
need to explicitly tell the compiler to
26:25 - treat the number you have as a float
here is an example I've declared a float
26:31 - call it number as I need one point two
here I have added the suffix F and that
26:37 - is to tell the compiler to trade this
number as a float if I didn't have this
26:41 - F here compiler would think one point
two is a double because double is the
26:47 - default data type for real numbers and
of course I cannot assign a double
26:51 - number into a float so the program would
not compile same applies to decimals so
26:56 - if you want to declare a decimal you
need to add the suffix M at the end of
27:01 - the number
in C# we also have a few other
27:05 - types which are not considered primitive
types and they are string array enum and
27:10 - class we'll learn more about them
throughout this course okay that's it
27:15 - for this lecture in the next lecture
we're going to talk about the concept of
27:18 - overflowing I hope you enjoyed this
lecture and thank you for watching
27:24 - okay now let's talk about the concept of
overflowing here I've declared a
27:28 - variable of type byte cut the number and
assign it to 255 as I told you earlier
27:35 - in the slide
255 is the largest value you can store
27:38 - in a byte now in the next line I'm
increasing the value of number by one
27:43 - and trying to store 256 in the number
but if you compile the application and
27:49 - display number on the console you will
see zero and this is what we call
27:54 - overflowing so we have exceeded the
boundary of the byte data type in
27:59 - C# by default we don't have
overflow checking which means we can
28:05 - modify the value of a variable at
runtime and if we go beyond the boundary
28:10 - of its underlying data type we will get
overflow now sometimes this is not
28:15 - desirable in your application you want
to stop overflowing if that's the case
28:20 - you need to use the check keyword so
here is how it works we have the checked
28:26 - keyword followed by curly braces which
indicate the code block and inside that
28:31 - block we have the variable declaration
and any kind of arithmetic operations
28:36 - with this code overflow will not happen
at runtime instead an exception will be
28:42 - thrown and the program will crash unless
you handle the exception the topic of
28:47 - exceptions is an advanced topic and I
have covered it in my C# advanced
28:50 - course for now all I want you to know is
that if you use the check keyword
28:55 - overflow will not happen and instead the
program will throw an exception now do
29:00 - we really need that in reality honestly
I have never ever ever came across this
29:06 - situation because if I was concerned
that in this case my number variable
29:11 - would overflow I would just simply use
the short data type instead of byte but
29:16 - I decided to include the concept of
overflowing because I wanted my
29:19 - sous-chef course to be comprehensive so
just be aware of that in case you hear
29:24 - about overflowing somewhere but you're
probably not going to use that in the
29:27 - real world in the next lecture we're
going to talk about the concept of scope
29:33 - okay let's talk about the concept of
scope what is the scope scope is where a
29:39 - variable or a constant as meaning and is
accessible take a look at this block of
29:45 - code here as you know a block is
indicated by curly braces here we have
29:50 - three blocks of code here's one here is
another and here is the last one inside
29:57 - the first block I've got a variable
called a an a is accessible anywhere
30:01 - inside this block or any of these child
blocks
30:05 - if I go out of this block and try to
access a the program will not compile
30:10 - the same rule applies to other variables
so let's take a look at this block here
30:15 - B is meaningful anywhere inside this
block or any of its children if I go
30:21 - outside this block and try to access B
I'm going to get a compile time error
30:27 - okay I think that's enough theory for
now let's open up visual studio and do
30:30 - some coding
30:33 - okay let's start by declaring a variable
of type byte and call it number
30:41 - now we want to display it on the console
so as you remember from the last lecture
30:45 - we type console dot write line and put
the variable here note that as I was
30:52 - typing console dot write line my
resharper plugin automatically added
30:56 - this using statement on the top system
is a namespace and console is a class
31:02 - that is defined in the system namespace
so in order to use the console class we
31:07 - need that declaration here on the top
if you're not using resharper you have
31:11 - to go here and manually type using
system semicolon okay now take a look at
31:18 - this number here it has a red underline
and if we put the mouse cursor here it
31:23 - says local variable number might not be
initialized before accessing if you
31:29 - remember from the slides I told you in
C# before you can access a variable
31:33 - you need to set it you need to
initialize it and that's the reason here
31:38 - we have the red underline we cannot
display the number on the console before
31:41 - initializing that so if I try to compile
the application we're going to get an
31:45 - error to compile an application you
press ctrl shift + B and here is the
31:52 - error list use of unassigned local
variable number we can solve this
31:58 - problem by initializing number like
setting it to 2 for example and you see
32:03 - the red underline is gone
we can compile again control-shift be
32:09 - build succeeded take a look here
okay now we can run the application by
32:14 - pressing ctrl + f5 okay so we got two on
the console now let's extend this
32:23 - example and declare a few more variables
define an integer int count equals 10
32:31 - and a float float say total price equals
20 $95 now note this red underlined here
32:42 - let's find out what's happening here so
I put the mouse cursor here it says
32:48 - cannot convert source type double to
target type float if you remember from
32:53 - the slides I told you
by default the sea-shore compiler traits
32:57 - real numbers like this one here as
double whereas we are declaring a float
33:03 - so here we need to explicitly tell the
C# compiler to treat this real
33:08 - number as a float and we can do that by
appending an F at the end
33:13 - so the error is gone let's take your
character so char character equals a
33:22 - note that in C# we enclose
characters by single quote like here we
33:29 - can also declare a string string is not
one of the primitive types and have
33:34 - covered it in a separate lecture in this
course but for now let me show you how
33:38 - to declare a string which is type string
give it a name first name equals mosh
33:47 - note that with strings we enclose them
in double quote so that's one of the
33:53 - differences between strings and
characters
33:57 - and finally let's declare a bull bull is
working equals true so with bulls we can
34:06 - either set them to true or false both
true and false our keywords as you can
34:12 - see they're indicated by the blue color
here and they're lowercase so everything
34:16 - you see here that is blue is a keyword
like static void string class name space
34:24 - and all these data types here
now let's display these variables on the
34:29 - console so let me show you a trick
instead of writing constant the right
34:38 - line we can do a shortcut this is what
we call a code snippet so we type CW
34:45 - that is short for console.writeline and
then press tab and Visual Studio
34:50 - automatically converts that to console
the right line there are various code
34:55 - snippets that help you write code faster
and I will try to point them out
34:58 - throughout this course so let's display
count now another one totalprice
35:08 - and note that i can just type t oh and
here is what we call intellisense it's
35:13 - visual studios auto completion mechanism
you don't have to type the full name of
35:18 - a type or a variable as long as the
intellisense detects tab and is
35:22 - highlighted here like total price you
can simply press tab and there you go
35:27 - visual studio automatically completes
that for us let's display the character
35:33 - same here I just press tab again I type
only a few characters it can press tab
35:41 - or enter and finally is working we run
the application by ctrl + f5
35:51 - so we got all these values on the
console
35:55 - okay now let me show you something else
in C# we have a keyword called var
36:01 - which makes variable declarations easier
for example here instead of explicitly
36:07 - specifying the datatype for each of
these here I can simply type var
36:14 - and I let the C# compiler detect
the datatype for this variable here so
36:20 - let me replace all of this with var okay
now if we hover the mouse over the VAR
36:35 - keyword
we can see the underlying data type in
36:39 - this case is system that boolean which
is the data type which maps to C#
36:44 - pull keyword how about this one that's a
string
36:51 - and this one is a character and this one
is system that single which maps to
36:58 - float in C# and in the case of
count it's in 32 which is integer and
37:05 - same for a number so the tricky thing
here is by default C# treats
37:10 - integral numbers as integer and when you
use the VAR keyword it assumes that it's
37:16 - an integer if you really want to go for
a byte then you have to explicitly
37:19 - specify it as byte here but tell you
from experience it's safe to use integer
37:25 - in most cases in fact if you look at the
classes in the.net framework in most
37:29 - cases integer is the data type used for
representing integral numbers okay I
37:37 - revert this back
now I show you something else so let's
37:41 - take a look at this one here so it's a
char which is a character
37:46 - I can put the mouse cursor here and
press control and then click
37:53 - that opens the object browser window
take a look here it's object browser and
38:00 - it's a way to look at the various
classes in your project or in the.net
38:03 - framework in this case because I did a
ctrl click on the char or VAR keyword
38:09 - this is what we got here
so char is highlighted in the object
38:14 - browser
on the right side you see all the
38:17 - members of the chart type
so these purple ones are functions or
38:22 - methods if you scroll down here you see
two fields here min value and Max value
38:28 - we'll explore them shortly and note that
here is the Declaration of Char Char is
38:35 - a structure we will cover structures
later in this course
38:38 - and note that it's a member of system
namespace
38:42 - it can click system and that shows the
system namespace as well as all the
38:48 - types defined in the system namespace so
these are part of the.net framework ok
38:55 - let's close this for now let's explore
another example so I'm going to get rid
39:01 - of all the code here we can simply press
control X on each line and that deletes
39:11 - all these lines here ok let's do a
console the right line so CW tab this
39:18 - time I pass a string here I specify two
placeholders
39:26 - and finally supply a couple of arguments
39:35 - okay let's see what's going on here so
here what we have is called a format
39:41 - string it's a kind of string that can be
used as some kind of template so at
39:46 - runtime what we have here indicated by
curly braces and 0 as the argument will
39:53 - be replaced by the value we pass here so
0 represents the first argument after
39:59 - this format string and 1 represents the
second argument after this format string
40:06 - in this case bited max value so let's
run this application
40:13 - we got 0 and 255 and that's the range
that you can store in a byte
40:22 - we can do the same with a float so CW
tap a format string float mean value
40:35 - float Max value run the application
40:45 - so this is the range we can store with a
float it's a huge number that is
40:50 - displayed using the scientific notation
40:57 - okay now let's take a look at constants
so I get rid of these two
41:02 - lines here control X control X we define
a constant with the Const keyword Const
41:10 - float P 3.14 and we have to put F at the
end because it's a float now because we
41:19 - declared P as a constant here I cannot
change it in my program so I cannot go
41:24 - here and say P equals 1 the compiler is
not happy and that's why we see that red
41:32 - underline here if you hover the mouse
here it says
41:36 - read only local constant cannot be used
as an assignment target it's a little
41:41 - weird expression to understand but
basically the intention of using
41:44 - constants is to have some kind of safety
in your program so if there are values
41:49 - that should not be changed throughout
your program you define them as constant
41:52 - and this way you want to accidentally
modify their values well if you made it
42:00 - this far you seem to be very
enthusiastic about learning C# and
42:04 - I highly recommend you to take my C
sharp basics course using the link in
42:07 - the video description this way
you can learn all the core concepts in a
42:12 - structured way and you don't have to
waste time jumping from one free
42:15 - tutorial to another you can see that
currently this course has over 5,000
42:20 - students with over 400 five-star reviews
plus it comes with a 30-day money-back
42:25 - guarantee so if you're not satisfied you
can ask udemy for a full refund within
42:30 - 30 days and you get all your money back
no questions asked again you can get
42:35 - this course using the link in the video
description I hope to see you in the
42:38 - course
42:41 - in this video I'm going to talk about
various kinds of type conversion in
42:45 - C# we have implicit type conversion
explicit type conversion which is also
42:50 - called casting and we also have
conversion between non compatible types
42:55 - here is an example of implicit type
conversion a blight as you know takes
43:01 - only one byte of memory and an integer
takes four bytes so we can easily copy a
43:06 - byte to an integer
what happens at runtime is let's take a
43:11 - look at this slide so here's the binary
representation of our B variable here so
43:17 - one is represented as seven bits of zero
and one bit of one when we copy a byte
43:23 - to an integer what the runtime does is
it prefixes that value with a bunch of
43:29 - zeros to fill the four bytes
there is no data loss
43:34 - in situations like that when the
compiler is 100% sure that the types are
43:39 - compatible and no data loss will happen
values can be converted to a different
43:43 - type implicitly
here is another example of implicit type
43:47 - conversion so we have an integer set it
to one and we copy that to a float again
43:54 - in this example no data loss will happen
but let's take a look at this one here
43:59 - we have declared an integer and we're
trying to copy that to a byte
44:05 - and integer is four bytes so when we
convert that to a byte three bytes out
44:10 - of four bytes will be gone and there is
a chance for data loss
44:14 - now data loss doesn't always happen it
only happens if the value restored in
44:19 - the integer is beyond the capacity of a
byte in this example one can be stored
44:26 - in a byte
so no data loss will happen but if we
44:29 - had let's say 300 here we cannot store
300 in a byte so as a result of that
44:35 - conversion data will be lost when the
compiler knows that there is a chance
44:39 - for data loss it doesn't allow implicit
type conversion and you need to
44:44 - explicitly tell the compiler that you're
aware of the data loss and you still
44:49 - want to go ahead with the conversion in
situations like that what we do is we
44:53 - prefix the variable with the target type
so here I'm trying to convert I to a
44:59 - byte
this is what we call as casting
45:04 - here is another example so we have a
float set to 1.0 and if we try to
45:10 - convert that to an integer the compiler
would complain I will show you that
45:13 - later in the coding demo so we need to
tell the compiler that we are aware of
45:19 - the data loss and we still want to
convert F which is a float to an integer
45:23 - so we cast it like here
sometimes we are working with types that
45:29 - are not compatible but you still need to
convert them for example we might have a
45:33 - number represented as a string as you
see here and we need to convert it to an
45:38 - integer in situations like that because
string and int are not compatible they
45:43 - cannot use explicit casting
so we need a different mechanism for
45:48 - converting a string to a number
in situations like that we need to use
45:52 - the convert class or use the parse
method
45:55 - so convert class is part of .NET
framework and is defined in the system
45:59 - namespace
of methods for converting various types
46:03 - to other types and they all start with
two in this case we're trying to convert
46:08 - s which is a string to an int 32 in 32
as you know is a .NET framework type
46:14 - which maps to a sushar p-- integer type
remember a blight is one byte short is
46:20 - two bytes and integer is 4 bytes and
long is eight bytes you probably know
46:26 - that each byte has 8 bits so an integer
which has four bytes times eight bits
46:33 - ends up being 32 bits that's why it's
called two in 32 and in 16 which
46:39 - represents 16 bits equals to short which
is 2 bytes we also have this parse
46:45 - method here all the primitive types that
I explained in the last lecture
46:49 - like integer long float boolean they all
have this parse method and the parsh
46:56 - method takes a string and tries to
convert that to the target type in this
46:59 - case an integer
here are some of the methods that you
47:04 - can find in the convert class to byte
which converts the given value to a byte
47:08 - 2 in 16 to convert the given value to a
short 2 in 32 to convert the given value
47:15 - to an integer and to n64 to convert the
given value to a long okay in a theory
47:21 - let's jump into code and see all this
concept in action
47:27 - okay let's say implicit type conversion
in action first I declare a bite call it
47:32 - B and set it to 1
now I declare an integer and set it to
47:39 - be again to recap a byte is only one
byte and an integer is 4 bytes so we can
47:47 - copy b2i without data loss and as you
see there is no compile time error here
47:52 - let's put on the console so console dot
write line and we pass I here note that
48:01 - as I typed consult the right line my
resharper plugin automatically added
48:05 - this using system statement on the top
again if you don't have resharper you
48:10 - need to go manually add this statement
here we run the application by ctrl + f5
48:19 - so we got on the console
48:23 - now let's reverse this and see what
happens so I'm going to get rid of this
48:27 - code here control X control X control X
first I declare an integer set it to one
48:37 - then I declare a byte and try to copy I
to B we immediately got this red
48:45 - underline here if you hover the mouse
here the tooltip says cannot convert
48:50 - source type int to target type byte
sometimes this error might be in a
48:54 - different file which is not open in
Visual Studio here so you may see the
48:58 - error when compiling the application
let's simulate that so I compile this
49:02 - application by ctrl shift and B which
stands for build so here's the error
49:12 - cannot implicitly convert type int to
byte an explicit conversion exists are
49:18 - you missing a caste so now you
understand the concept of implicit
49:23 - versus explicit type conversion so what
we need to do here is to do a cast so we
49:31 - casted integer to a byte now in this
case no data loss will happen because
49:36 - the value is small enough to be stored
in one bite let's put B on the console
49:43 - console by right line B we run the
application
49:51 - so everything is good but let's see what
happens if we said I - let's say
49:57 - thousand we cannot store the number
thousand in a byte the maximum we can
50:03 - store in a byte is 255 so if you run the
application now
50:08 - we got to 32 because some of the bits
were lost and this is the reason that
50:16 - C# compiler knows that there is a
chance for data loss and it enforces you
50:20 - to explicitly specify the cast sometimes
you know that despite the differences in
50:27 - data types there is no chance of data
loss like in the last example where I
50:31 - was set to 1 in those cases we can
safely apply a cast okay now let's take
50:36 - a look at non compatible types so let's
clean up this code I start by declaring
50:43 - a string let's call it number and set it
to one two three four
50:50 - recapping from the last lecture note
that here I could declare this with the
50:54 - VAR keyword and since our compiler
automatically detects that this is a
50:58 - string so number will be defined as a
string and we can see that by hovering
51:03 - the mouse here it says system that
string
51:07 - now let's say we want to convert that to
a number
51:10 - if I declare an integer like I I cannot
cast that number to an integer because
51:17 - they're not compatible let's take a look
at the error cannot cast expression of
51:22 - type string to type int so if you see
that error that's the time when you need
51:26 - to use the convert class
51:29 - so we type in convert dot take a look at
this method here - bite - char - in 16
51:36 - in 32 and many other methods here so
let's convert that to an integer which
51:43 - is int 32 and pass number as an argument
here now let's print out the I on the
51:51 - console run application so I is 1 2 3 4
all good but let's see what happens if
52:06 - instead I declare this as a byte and
here we need to use convert dot 2 byte
52:14 - and here we display B on the console a
byte does not have enough storage to
52:23 - store the value of 1234 so when we run
the application now
52:32 - the application crashed
the cancel is here and here is the
52:39 - exception exception is Dartmouth
frameworks error reporting mechanism
52:43 - it's an advanced topic and I have
covered it in detail in my C#
52:47 - Advanced Course but in this video I will
briefly show you how to handle
52:51 - exceptions so here it says unhandled
exception the type of exception is
52:56 - system that overflow exception which
means we try to store a value that was
53:02 - too large or too small for a byte
so each exception or error as a type in
53:08 - this case overflow exception and has a
message value was either too large or
53:13 - too small for an unsigned byte sometimes
the exception messages are friendly
53:19 - enough that are easy to understand
sometimes they're a little bit tricky
53:23 - and the best way to work out what is
going wrong is to jump on Google and
53:26 - search for the error and there's pretty
much always a Stack Overflow page that
53:31 - explains that now let's describe that
let's see how to handle the exception
53:37 - here
happened during conversion of that
53:41 - string to bite what we need to do here
is to wrap these few statements with a
53:47 - try-catch block let's see how it works
53:52 - so I just typed try and press the enter
and visual studio automatically
53:57 - generated this block for me again this
is what we call a code snippet let me
54:02 - undo this I'll show you one more time so
try see this try here in the
54:08 - intellisense and this icon represents a
code snippet so if I press enter or tab
54:13 - you automatically get this code block so
what I'm going to do now is to move this
54:19 - code enter a try block and the catch
block gets an exception by default
54:27 - visual studio as this throw here don't
worry about it just delete it again I
54:31 - will explain it in detail in my sushar
Advanced Course for now let's see what's
54:35 - going on here so the code that you put
inside the try block will be somehow
54:40 - monitored and if an exception happens
this block will be executed this
54:47 - prevents your application from crashing
the reason our application crashed
54:51 - earlier was because we did not handle
the exception so if you don't handle
54:56 - exception the exception will be
propagated to the .NET runtime and
55:00 - that the run times mechanism is to stop
your application and display the error
55:05 - here we can handle the exception and
that would prevent the exception from
55:09 - being propagated to .NET runtime so
instead we can display a friendly
55:13 - message to the user saying for example
console.writeline
55:20 - the number could not be converted to a
byte
55:28 - now let's run the application again
55:33 - see we got the firmly message and the
application didn't crash
55:39 - so what I want you to take away from
this lecture is this
55:43 - we're class works pretty well in most
cases but in cases where the source type
55:48 - cannot be converted to the target type
there is a chance for exception and you
55:52 - need to be aware of that and what you
need to do is to wrap this block of code
55:56 - with try-catch let's take a look at one
more example before we finish this
56:00 - lecture let's remove this and instead
- drink
56:09 - call it STR and set it to true we can
use the convert class to convert that
56:14 - value to a boolean so bull P equals
convert that to boolean and we pass that
56:21 - STR here
56:24 - again in this example string and bull
are not compatible and that's why we
56:29 - cannot use explicit casting so here we
are using the convert class we can
56:36 - display B on the console
56:41 - application
so the true string was successfully
56:46 - converted to a boolean value
56:50 - that's pretty much it for this lecture
before I finish I just need to emphasize
56:54 - something here that throughout this
course during early lectures you may see
56:59 - me using some short variable names like
P or STR here that's purely for
57:04 - demonstration and keeping things simple
and in building real-world applications
57:09 - we should really avoid naming our
variables ABC STR it's not really a good
57:14 - practice the only exception is when we
get to loops which you will see later in
57:19 - this course in for loops we use counter
variables and we call them I or J it's a
57:25 - common convention now here we are just
starting to learn C# and it's
57:30 - really impossible for me to demonstrate
building a real world application
57:33 - because you're just covering their
basics or alphabets I hope you enjoyed
57:39 - this lecture and thank you for watching
57:43 - okay we got two operators in C# we
have five types of operators arithmetic
57:50 - comparison assignment logical and
bitwise let's take a closer look at each
57:57 - of these operators we use arithmetic
operators in computations where we are
58:03 - working with numbers so as you see in
this slide we have add subtract multiply
58:09 - divide and remainder of division we also
have two arithmetic operators called
58:16 - increment and decrement which are a
shortcut for adding one or subtracting
58:22 - one from a variable so a plus plus is
equivalent to a equals any plus one now
58:30 - with this increment and decrement
operator there are two ways you can
58:33 - apply them you can use them as a postfix
so in this example a is 1 and when we
58:40 - apply the postfix increment operator
first the value of a is assigned to B so
58:47 - B is going to be 1 and then a is
incremented by 1 so in this example
58:53 - after the second line is executed a is
going to be 2 and B is going to be 1 now
59:00 - let's take a look at a different way of
applying increment operator as a prefix
59:05 - so in this example in the second line
first a is incremented by 1 and then
59:12 - it's assigned to B so after the second
line both a and B are going to be 2 so
59:19 - be aware of this difference ok next
comparison operators so we got equal
59:26 - which is indicated by double equal sign
not equal greater than greater than or
59:33 - equal to less than and less than or
equal to now what I want you to pay
59:39 - attention to in this list is that the
testing for equality is accomplished by
59:44 - double equal sign and that's different
from a single equal which is the
59:49 - assignment operator next assignment
operators so the most commonly used is
59:55 - the one with a seen
the equal sign so here we set a 2/1
59:59 - pretty basic now look at the next four
types of assignment operators addition
60:05 - assignment subtraction assignment
multiplication assignment and division
60:10 - assignment let's see how they work for
example addition assignment a plus equal
60:17 - 3 means add 3 to a so it's equivalent to
writing a equals a plus 3 and the same
60:25 - rule applies to other 4 assignment
operators logical operators are used in
60:32 - boolean expressions which are often used
in conditional statements will get two
60:37 - conditional statements later in this
course so a real-world example is where
60:42 - you have a condition and you want to
make sure that condition and another
60:46 - condition both are true or maybe one of
them is true so that's where you use a
60:52 - logical operator in C# the logical
end is indicated by double ampersand and
60:58 - the logical or is implemented by double
vertical line we also have the not
61:04 - operator which is indicated by an
exclamation mark and finally in here
61:10 - we've got the bitwise operators bitwise
operators are often used in low-level
61:15 - programming like when working with
windows api or in sockets or encryption
61:21 - explanation of these is beyond the scope
of this course but if you are interested
61:26 - let me know and I write a blog post for
you now what I want you to take away
61:30 - here is that the bitwise End is
indicated by a single ampersand whereas
61:35 - the logical end which we use in
conditional statements is indicated by
61:39 - double ampersand same for bitwise or and
logical or so remember the difference ok
61:46 - enough theory let's flip over to visual
studio and see all these concepts in
61:51 - action
61:54 - okay let's start with the arithmetic
operators first so I define two
61:59 - variables a equals 10 B equals 3 let's
add them together and display the
62:07 - results in the console
62:12 - that's pretty easy right run the
application so the result is 13 now
62:20 - let's take a look at division so I
replace the ad operator with division
62:26 - you
62:28 - the result is three the interesting
thing here is because both a and B are
62:36 - integers the result of the division ends
up being an integer if you like a
62:43 - floating-point number as the result of
the division you need to cast both these
62:47 - numbers to a float so like this
now if you're on the application
63:00 - the result is a floating-point number
63:04 - now let's look at a more tricky example
63:10 - let's say C's 3 B's 2 and a is 1 I want
to show you the concept of operator
63:19 - precedence
63:22 - so if I type a plus B times C what do
you expect the result to be from a
63:30 - mathematical perspective B should be
multiplied by C first which means two
63:36 - times three equals six and then it
should be added to one so the result
63:41 - should be seven let's run the
application
63:46 - so C# behaves exactly as what we
expected so multiply or division
63:52 - operators have higher precedence than
add or subtract if you'd like to change
63:57 - the precedence you can do so by using
parentheses so in this case if you would
64:01 - like to have a and B added together
first and then multiply it by C this is
64:08 - how we would achieve that in this case
the result will be 9
64:14 - there you go
64:17 - okay now let's take a look at comparison
operators
64:21 - so let's get rid of C here and instead
see if a is greater than B very simple
64:30 - example right
64:33 - the result is false so what I want you
to know here is the result of the
64:38 - comparison expression is always a
boolean value which is true or false we
64:44 - can test for equality so double equal
sign in this case a is not equal to B so
64:50 - the result should be false
64:57 - now let's see the not equal operator so
simply have an exclamation mark here
65:02 - followed by an equal sign in this case
because a is not equal to B the result
65:07 - should be true
65:10 - okay now let me show you a more tricky
example what do you expect here well
65:23 - first this is the not operator which is
applied on boolean values or boolean
65:28 - expressions in this case this is a
boolean expression and as you saw
65:33 - earlier it was true because a is not
equal to B so we apply the not operator
65:39 - to that and the result ends up being
false let's run the application
65:46 - so we got files here but this code is
not easy to understand or easy to read
65:52 - because here we have two negatives one
negative and two negative and for us
65:58 - humans to negative is hard to comprehend
two negatives always equal to one
66:05 - positive so in your program if you end
up in situations where you have two
66:09 - negatives make sure to always inverse
them with one positive so in that case I
66:14 - can get rid of the first negative and
convert the second negative to a
66:18 - positive like that and we will get the
same result which is false now let's
66:23 - take a look at logical operators so I
create another variable here VAR c
66:29 - equals 3 I'm going to change that to C
greater than B and C greater than a what
66:41 - do you expect here as the result well C
is greater than B so the result of that
66:46 - expression is true also C is greater
than a so the result of that expression
66:51 - is true as well and here we have the end
operator so true and true equals to true
66:59 - let's run the application
67:03 - there you go now let's make a tiny
change here so this time because we know
67:12 - C is not equal to a this expression
evaluates to false true and false
67:18 - results in false let's run the
application
67:24 - so we got false now let's see the effect
of the or operator so I'm going to
67:31 - replace the end with or which is double
vertical line in this case that is true
67:38 - or false the result ends up being true
67:46 - and of course we can apply not operator
here as you saw earlier which changes
67:54 - the true to false
67:59 - now this expression doesn't really look
easy to understand it's just purely for
68:04 - demonstration of how we can combine
different operators and make up more
68:08 - complicated expressions okay that's it
for this lecture I hope you enjoyed it
68:12 - and thank you for watching
68:15 - okay so we got to comment a comment is
text that we put in our code to improve
68:22 - its readability and maintainability in
C# we have two ways to write
68:27 - comments if your comment is only a
single line you can prefix the comment
68:32 - with double slash but if your comment is
longer and it's multiple lines you need
68:38 - to start it with slash star and then
finish it with star slash this type of
68:44 - comment is more like the comments we
used to write in C and C++ code these
68:49 - days it's more conventional to write
either single line or multi-line
68:53 - comments prefixing with double slash so
in this example we can rewrite this
68:58 - multi-line comment with double slash
style like this now as a rule of thumb
69:04 - keep your comments to minimum use
comments only win required and that's
69:09 - when explaining wise house constraints
and things like that do not explain what
69:16 - the code is doing your code should be so
clean and straightforward that it
69:20 - doesn't need comment if a comment
explains just what the code is doing is
69:25 - redundant and the problem with redundant
comments is we change the code but not
69:30 - everyone is very consistent in changing
the comments so after a while these
69:34 - comments become outdated and because
they don't get compiled like the code
69:38 - there is no way to validate them and
after a while they become useless so
69:43 - again keep them to minimum and explain
wise house and constraints that you had
69:48 - at the time you wrote the code so the
next person who is reading your code
69:52 - knows the reason why you wrote the code
that way
69:59 - in this section you learn that C#
is a statically typed language which
70:05 - means once you ticular a variable you
need to specify its type and that type
70:09 - cannot change during the lifetime of
that variable you also learn about the
70:14 - primitive types in C# such as
integer character boolean and so on now
70:19 - in the next section I'm going to
introduce you to non primitive types in
70:23 - C# such as classes or structures
arrays strings and in ohms so I'll see
70:29 - you the next section