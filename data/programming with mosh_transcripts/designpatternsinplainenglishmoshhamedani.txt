00:00 - [Music]
00:02 - welcome to my ultimate design patterns
00:05 - course I'm mosh
00:06 - and I'm super excited to be your
00:08 - instructor let me give you a quick
00:09 - overview what this course is all about
00:11 - and what you need to know before you get
00:12 - started in this course you're gonna
00:14 - learn how to design reusable and
00:16 - extensible object-oriented software in
00:19 - order to take this course you should
00:21 - have at least three months of
00:22 - programming experience it doesn't matter
00:24 - what language you're familiar with you
00:26 - just need some basic programming
00:27 - experience also if you're familiar with
00:30 - basic object-oriented programming
00:31 - concepts such as classes on interfaces
00:34 - that will be great
00:35 - but not required I'll give you a basic
00:37 - overview of these concepts in the next
00:39 - section now before we get started I want
00:42 - to set the expectation in this course
00:44 - we're not gonna work on any algorithms
00:46 - you're not gonna see me working with
00:47 - loops or Eve statements or implement
00:50 - complex logic that is not the purpose of
00:52 - this course I've covered all the
00:54 - algorithmic topics in my data structure
00:56 - as an algorithms course also we're not
00:59 - gonna build an application instead we're
01:01 - gonna talk about designing
01:02 - object-oriented software we're gonna
01:04 - talk about how you should structure your
01:06 - classes and how this classes should
01:08 - collaborate our focus will be on
01:10 - building reusable and extensible
01:12 - software software that can be easily
01:14 - extended the techniques we are going to
01:16 - cover in this course are extremely
01:18 - important and every software engineer
01:20 - working with object-oriented system
01:21 - should master this so I'm super excited
01:24 - to be your instructor design patterns is
01:26 - one of my favorite topics and a lot of
01:28 - you guys have been waiting for this
01:29 - course for a long time so let's jump in
01:31 - and get started
01:36 - [Music]
01:43 - you might ask what art design patterns
01:46 - well design patterns are elegant
01:48 - solutions to repeating problems in
01:50 - software design for example may want to
01:53 - implement the undo mechanism in your
01:54 - application
01:55 - that's a repeating problem in software
01:57 - design right now we have a couple of
01:59 - different patterns for implementing the
02:01 - undo feature one of them is the momento
02:03 - pattern so a design pattern shows you
02:05 - how you should structure your classes
02:07 - and how these classes should talk to
02:09 - each other now in this series we'll be
02:11 - exploring 23 design patterns that were
02:13 - originally documented in the 90s in the
02:16 - book called design patterns
02:17 - elements of reusable object-oriented
02:20 - software the book was written by four
02:22 - authors that are known as Gang of Four
02:24 - so quite often we refer to these
02:25 - patterns as Gang of Four patterns the
02:28 - Gang of Four patterns include 23 design
02:30 - patterns in three categories creational
02:33 - structural and behavioral creational
02:36 - patterns are all about different ways to
02:38 - create objects structural patterns are
02:40 - about the relationships between these
02:42 - objects and behavioral patterns are
02:44 - about the interaction or communication
02:47 - between these objects in the first part
02:49 - of this series we'll be talking about
02:50 - the behavioral design patterns and by
02:53 - the way these design patterns don't
02:54 - represent all the patterns in their work
02:56 - there are many unofficial and
02:58 - undocumented patterns out there that you
03:00 - might find useful in certain situations
03:01 - but these 23 design patterns are the
03:04 - classic ones that every software
03:05 - engineer must understand one of the
03:07 - benefits of design patterns is that they
03:09 - help us communicate with other
03:10 - developers at a more abstract level for
03:13 - example you may tell your coworker hey
03:15 - we can use the command pattern to
03:17 - improve this code you can simply use the
03:19 - name of the pattern to communicate the
03:21 - idea you don't have to write a lot of
03:22 - code to express that idea another
03:25 - benefit of studying and understanding
03:26 - this design patterns is that it makes
03:29 - you a better designer you will learn how
03:31 - to build reusable extensible and
03:33 - maintainable software no matter what
03:35 - programming language you use or what
03:37 - kind of applications you build and
03:38 - finally another benefit of learning
03:40 - design patterns is that they help you
03:42 - learn and use new frameworks faster one
03:44 - of the questions I often get is march√©
03:46 - how do you learn various things
03:48 - quickly I tell you what I'm not a genius
03:50 - yes I do have years of experience in
03:52 - fact I started programming when I was
03:54 - seven and now I'm 37 but one thing that
03:57 - I believe has helped me enormously is
03:59 - understanding this design patterns
04:00 - because I see these design patterns used
04:02 - in various frameworks and libraries so
04:05 - every time I learn a new framework it
04:06 - kind of looks familiar to me it's just a
04:08 - different syntax that I have to memorize
04:10 - so these are the benefits of learning
04:12 - design patterns
04:18 - unlike other courses on books that teach
04:21 - you design patterns like a list of
04:22 - recipes to follow in this course I'm
04:24 - going to teach you the art of designing
04:26 - object-oriented software so I'm not
04:28 - gonna give you a catalog of design
04:30 - patterns ordered alphabetically I'm
04:32 - specifically ordered the patterns in
04:34 - this course to teach you various
04:35 - important concepts so even though you
04:37 - can jump to a specific pattern to learn
04:39 - more about it it's best if you take the
04:41 - course from the beginning to the end
04:42 - because throughout the sections I'll
04:44 - talk about various principles and if you
04:46 - skip those you're gonna miss out a lot
04:48 - so if you want to get the most out of
04:49 - this course watch all the sections in
04:51 - order every section is short and sweet
04:53 - and you can watch it in half an hour or
04:55 - less if you have taken any of my courses
04:58 - you know that I don't waste your time by
04:59 - long slow and repetitive explanations
05:02 - also in this course I'll be using Java
05:04 - but you don't have to be a Java
05:06 - developer in order to take this course
05:08 - in the next section I'm gonna give you a
05:09 - quick overview of the Java syntax so you
05:12 - can easily understand the code we write
05:13 - if you use Python or C sharp or some
05:16 - other language you can take the concepts
05:18 - in this course and apply them in your
05:20 - favorite programming language again our
05:22 - focus is on the art of designing
05:24 - object-oriented software not a
05:25 - particular programming language now if
05:28 - you are a Java developer I still
05:30 - encourage you to watch the next section
05:31 - even though it may appear a little bit
05:33 - basic for you because in the next
05:35 - section I'm going to talk about the
05:36 - essential object-oriented programming
05:38 - concepts such as encapsulation
05:40 - abstraction inheritance and polymorphism
05:42 - a lot of developers don't really
05:44 - understand this concept properly so I'll
05:47 - see you in the next section
05:51 - in this section I'm going to give you a
05:53 - quick tour of Java and the essential
05:55 - object-oriented programming concepts you
05:57 - need to understand in order to take this
05:59 - course we'll be talking about classes
06:01 - interfaces encapsulation abstraction
06:04 - inheritance polymorphism and UML which
06:07 - is the graphical notation we'll be using
06:09 - throughout this course if you know Java
06:11 - you can skip the first video or two
06:13 - where I create a new project and show
06:15 - you how to work with a class but I
06:16 - highly encourage you to watch all the
06:18 - other lessons especially the lesson
06:20 - about interfaces because interfaces are
06:22 - one of the most misunderstood concepts
06:24 - in Java and in many programming
06:26 - languages also make sure to watch all
06:28 - the other lessons such as encapsulation
06:30 - abstraction inheritance and polymorphism
06:32 - these are extremely important I want to
06:35 - make sure we're on the same page and you
06:37 - really understand what these concepts
06:39 - are if you don't understand these
06:40 - concepts properly you're not going to be
06:42 - able to understand design patterns so
06:44 - let's jump in and get started all right
06:55 - in this course I'm gonna use IntelliJ
06:57 - which is a very popular Java IDE but you
07:00 - can use any ID that you prefer if you
07:02 - want to use IntelliJ and code along with
07:04 - me we can get it from jetbrains comm
07:06 - slash idea slash download it comes in
07:08 - two editions ultimate which is paid and
07:11 - community which is free and open source
07:13 - here in IntelliJ let's create a brand
07:16 - new project so we select Java on the
07:18 - left next we select create project from
07:21 - template we want to create a command
07:23 - line application next we shall give this
07:27 - project a name let's call it design
07:29 - patterns over here we should specify the
07:32 - base package name a package in Java is a
07:35 - container for one or more classes in
07:37 - some languages like C sharp it's called
07:39 - and namespace so here we should type the
07:41 - base package name by convention we use
07:44 - the reverse domain name my domain is
07:46 - code with match calm so here we have
07:48 - calm that code with Marsh this is just a
07:51 - convention it doesn't mean you should
07:53 - have a domain name registered on an
07:54 - Internet you can type anything here okay
07:58 - all right as you can see every Java
07:59 - project has this main file main dat Java
08:02 - and in this file we have a class with
08:04 - the exact same name this class is
08:07 - declared in this package comm that code
08:09 - with wash so the package statement on
08:11 - top of the file determines where this
08:14 - class is going to be defined okay now in
08:16 - this class we have a method called main
08:18 - both this method and this class are
08:21 - declared as public
08:22 - this means they're accessible anywhere
08:24 - in this codebase we'll talk about this
08:27 - later in this section now the main
08:29 - method is declared as static this means
08:31 - we can call this method directly without
08:33 - having to create an instance of the main
08:36 - class void is the return type of this
08:38 - method which means this method is not
08:40 - gonna return a value and here in
08:43 - parentheses we have the parameters of
08:45 - this method in this case we have a
08:47 - single parameter which is a string array
08:49 - called args if we execute this program
08:51 - from the command line and pass a few
08:53 - different arguments we can capture those
08:55 - arguments using the string array okay
08:58 - now in Java we use curly braces to
09:01 - represent a block of code and by
09:04 - convention we put the left brace on the
09:06 - same line in some languages like C sharp
09:09 - we put the left brace on a new line but
09:11 - this is unconventional in Java so let's
09:14 - bring it back where it was so this is
09:16 - the basics of a Java program next I'm
09:18 - going to show you how to create and use
09:20 - classes
09:26 - all right let me show you how to work
09:28 - with classes so in the project window we
09:31 - expand the project folder here we have
09:33 - the source folder this is where we have
09:35 - all the source code for this project and
09:37 - it's folder we have our base package
09:39 - which contains the main class now we
09:43 - right-click the package name and add a
09:44 - new class we're going to call this user
09:48 - in this class we can have filled or
09:51 - attributes for storing data and methods
09:54 - let's declare a field for storing the
09:56 - users name
09:57 - so public string name and we terminated
10:01 - with a semicolon
10:02 - so in Java we terminate our statements
10:04 - with a semicolon
10:05 - now technically this is a bad practice
10:08 - to declare fields as public I'm going to
10:10 - talk about this later in this section
10:11 - for now
10:12 - let's declare everything as public so
10:15 - string is the type of this field and
10:17 - it's called name now we can go to the
10:20 - main class and create a new instance of
10:22 - the user class so we type user user
10:27 - equals new user so we're declaring a
10:30 - variable called user the type of is
10:33 - variable is our user class and here
10:36 - we're setting this to a new instance of
10:38 - the user class once again we are
10:40 - terminating the statement with a
10:41 - semicolon now using the dot operator we
10:46 - can access the field and methods in this
10:48 - class so we can set the name field to
10:51 - Marsh and once again we terminate this
10:53 - with a semicolon
10:54 - note that in Java we use double quotes
10:56 - to surround strings now we can print
10:59 - this field on the terminal so we have
11:02 - the system class this class has a field
11:05 - called out this is an object that has a
11:08 - method called print line this is like
11:10 - console to write line of c-sharp now
11:13 - here we can pass user that name and then
11:16 - we can run this program using ctrl + R
11:20 - there you go so here's my name on the
11:23 - terminal beautiful now we can specify
11:26 - the name when creating a new user so we
11:29 - go back to the user class we add a
11:31 - constructor a constructor is a method
11:33 - that gets called when we create a new
11:35 - instance of a class
11:36 - so here we type public then we type the
11:40 - name of the class
11:41 - and then we had parentheses this is
11:43 - where we can declare parameters
11:45 - next we add our curly braces so let's
11:48 - add a parameter here called string name
11:51 - now we can set the name field to the
11:53 - value of the name parameter however both
11:57 - the parameter and the field have the
11:59 - same identifier so if we type name
12:02 - equals name the Java compiler thinks
12:05 - we're referring to this name parameter
12:07 - so on the left side we should prefix
12:10 - this with this dot
12:13 - so we're saying set the name field of
12:16 - the current object to the value of the
12:19 - name parameter so this is a reference to
12:22 - the current object if we type this dot
12:24 - we can see all the fields and methods in
12:27 - this class okay
12:29 - now back to the main method
12:32 - when creating a new user object we can
12:34 - pass the name we don't need to set it
12:37 - explicitly and then we can print it on a
12:39 - terminal so run we get the same result
12:43 - as before beautiful now let's add a
12:46 - method in this class so we start with
12:51 - public we don't wanna return a value so
12:53 - we use void we call this method say
12:56 - hello
12:58 - and here we're gonna print a message
13:00 - like hi my name is and then we can
13:04 - combine this string with the value of
13:07 - the name field now in this context we
13:10 - don't have a name parameter so we don't
13:12 - have to use that this keyword we can
13:14 - simply reference the name field directly
13:16 - okay now back in the main method instead
13:20 - of printing the name of a user we can
13:23 - call user dot say hello then run and we
13:28 - get this message so this is how we can
13:30 - create and use classes in Java
13:37 - one of the important concepts in
13:39 - object-oriented systems is coupling
13:42 - which determines how much a class is
13:44 - coupled or dependent on another class
13:46 - for example here in the main class we
13:49 - are using the user class so the main
13:51 - class is coupled or dependent on the
13:53 - user class so if you change the user
13:55 - class the main class might be affected
13:57 - we have to change it or at least we have
13:59 - to recompile and redeploy let me show
14:01 - you so I'm going to go back to the user
14:03 - class and introduce a new parameter in
14:06 - this constructor let's say integer H so
14:10 - we have changed the user class now the
14:12 - main class is broken
14:13 - we cannot compile this code we have to
14:16 - pass this argument over here so this is
14:19 - the problem with coupling let me show
14:21 - you another example back in the user
14:23 - class let's add a hyphen before this
14:25 - message now back in the main class we
14:29 - don't have a breaking change our code
14:30 - compiler fect li well however because we
14:33 - have changed the code in the user class
14:35 - this class has to be recompiled and that
14:38 - means all the classes that are dependent
14:40 - on this class have to be recompile as
14:42 - well that this is a very simple program
14:44 - we only have two classes but what if we
14:47 - had hundreds or thousands of classes and
14:49 - many of them were highly dependent on
14:51 - each other in an application like that
14:53 - if it change the class we could end up
14:56 - with lots of cascading changes an
14:58 - application built this way is really
15:00 - hard to change hard to extend let me
15:03 - give you a metaphor think of your car if
15:05 - you get a flat tire you only need to
15:07 - replace that tire you don't need to
15:09 - replace this steering wheel or the
15:11 - engine right your car is an example of a
15:13 - loosely coupled system the components in
15:16 - your car work together but they are not
15:18 - tightly coupled or dependent on each
15:20 - other so you can replace individual
15:22 - parts independently our applications
15:25 - should be the same way but how can we
15:27 - build loosely coupled applications using
15:29 - interfaces and that's what I'm going to
15:31 - cover next
15:37 - interfaces are one of the most
15:39 - misunderstood constructs in Java and in
15:42 - many other programming languages I
15:44 - talked about this in detail in the
15:46 - second part of my ultimate java course
15:48 - that is about 4 hours long but let me
15:50 - explain very briefly an interface is a
15:53 - contract that specifies the capabilities
15:55 - that a class should provide let me give
15:58 - you a metaphor imagine you want to open
16:00 - a restaurant you need a chef it doesn't
16:02 - matter who the chef is so you're not
16:04 - dependent on a particular chef you're
16:06 - only dependent on someone who can
16:08 - perform the role of a chef
16:10 - someone with certain capabilities this
16:12 - is an example of a loosely coupled
16:14 - system now I told you that an interface
16:16 - is a contract that specifies the
16:18 - capabilities that a class should provide
16:20 - so in this example we can represent the
16:23 - role of a chef with an interface and the
16:26 - actual chef's with classes that
16:28 - implement the chef's interface so this
16:30 - is the idea behind interfaces with
16:33 - interfaces we can build loosely coupled
16:35 - applications let me show you this in
16:37 - code so let's say you want to build a
16:39 - tax calculator tax calculation is
16:41 - complex and the rules may change from
16:43 - one year to another we can have a
16:45 - calculator for year 2019 and another for
16:48 - year 2020 just like we can have
16:50 - different people filling the role of a
16:52 - chef at a restaurant right but what do
16:55 - all tax calculators have in common they
16:57 - probably have a method called calculate
16:59 - tax we can represent this with an
17:02 - interface so in this package let's add a
17:05 - new class first we change the kind to
17:09 - interface and call it tax calculator so
17:14 - this is just a contract that specifies
17:15 - the methods that our calculator classes
17:18 - should implement so here we had a method
17:20 - float calculate tax note that we only
17:26 - have a method declaration so we're
17:28 - terminating the statement with a
17:30 - semicolon this method does not have a
17:32 - body it doesn't have implementation if
17:34 - you have curly braces here we get a
17:36 - compilation error so this interface is
17:39 - saying hey if you want to build a tax
17:41 - calculator class that class should have
17:43 - a method with this signature okay
17:46 - let's add a real tax calculator in this
17:48 - project so we add a new class we call
17:52 - this tax calculator 2019
17:56 - now over here we type implements tax
18:00 - calculator now we have a compilation
18:02 - error because we haven't implemented the
18:05 - calculate tax method in this class we
18:07 - can put the caret over here press
18:09 - alternator and select implement methods
18:14 - intellij added the calculate tax method
18:17 - in our class but don't worry about this
18:19 - overwrite this is called an annotation I
18:21 - talked about this in the second part of
18:23 - my ultimate Java series for now all that
18:26 - matters is that this class has a method
18:28 - with this signature here we can return
18:31 - one now let's create another calculator
18:34 - so once again we add a new class we call
18:39 - it tax calculator 2020 once again we say
18:44 - implements tax calculator then
18:48 - alternator implement methods beautiful
18:51 - now in year 2020 and we can return to
18:55 - so we have two different implementations
18:57 - of this interface now in our application
19:01 - instead of working with these concrete
19:03 - implementations we should work with this
19:05 - interface this is called programming to
19:08 - an interface so anywhere we need a tax
19:11 - calculator in this program we're gonna
19:13 - work with this interface for example we
19:15 - can go back in the main class let's add
19:18 - a public static method I made the static
19:22 - so we can call it directly from the main
19:24 - method okay now this method should
19:26 - return a tax calculator so here we're
19:29 - using our interface let's call it get
19:32 - calculator
19:34 - for now we're gonna return a new tax
19:37 - calculator 2019 now in our main method
19:41 - we're gonna call the get calculator
19:43 - method and store the result in a
19:47 - variable called calculator so in this
19:51 - method we have a dependency or coupling
19:53 - to this interface now this interface is
19:55 - very simple it's very lightweight all it
19:58 - has is a method called calculate tax as
20:02 - long as we keep the signature of this
20:03 - method exactly as these we're not gonna
20:06 - have a breaking change this is how we
20:08 - achieve loose coupling so with this
20:10 - style of programming if we go to our tax
20:13 - calculator 2019 and let's say add a new
20:16 - method here public float calculate
20:20 - insurance we have changed this class but
20:25 - this change is not gonna impact
20:29 - our main method over here because we're
20:32 - programming to an interface not a
20:34 - concrete implementation now if you have
20:36 - been paying close attention and you
20:37 - might say but marsh over here we are
20:41 - newing up a tax calculator 2019 so if
20:44 - you make any changes in this class this
20:46 - class has to be recompiled and that
20:48 - means the main class should also be
20:50 - recompile that is true but this is a
20:52 - very simple example to demonstrate this
20:54 - concept in a real enterprise application
20:57 - we're now going to write code like this
20:58 - we use what we call a dependency
21:01 - injection framework that gives us real
21:03 - implementations of an interface so in
21:06 - our code we work with interfaces now if
21:10 - this concept is new to you don't worry
21:11 - we're gonna talk about this more and
21:13 - more throughout the course
21:20 - so you learn the basics of classes on
21:22 - interfaces
21:23 - over the next few videos we're going to
21:25 - talk about the four core principles of
21:27 - object-oriented programming it's easier
21:30 - to explain it using a real example so in
21:32 - this project I'm going to add a new
21:34 - class called account this represents a
21:38 - bank account a human is a field for
21:41 - storing the balance of this account so
21:43 - public float balance now with this
21:47 - implementation we can go to the main
21:49 - class and create a new account
21:54 - now we have repeated the class name
21:56 - twice so it's better to use the VAR
21:58 - keyword over here now with this
22:01 - implementation we can set the balance to
22:03 - any amount we can set it to a positive
22:04 - value or a negative value
22:07 - but what if negative balances are not
22:09 - allowed in our application we shouldn't
22:11 - be able to write code like this in other
22:13 - words we shouldn't allow other classes
22:15 - like the main class to change the state
22:18 - of this object directly they shouldn't
22:20 - be able to change the data in this
22:21 - object so to solve this problem we go
22:25 - back to our account class and replace
22:27 - this public keyword with private public
22:30 - and private are examples of access
22:32 - modifiers many other object-oriented
22:34 - languages have the same concept now back
22:37 - in the main class we have a compilation
22:39 - error because we cannot access the
22:41 - balanced field from outside of this
22:43 - class it's hidden inside this class so
22:46 - within this class we can use it anywhere
22:48 - but we cannot access it from outside of
22:50 - this class but what if you really need
22:52 - to change the balance how are we gonna
22:54 - be able to do that well here in the
22:57 - account class we can add a method public
23:00 - void set balance
23:04 - we give it a parameter called balance
23:06 - and here we set this that balance to
23:08 - balance now because we have a method
23:11 - here in this method we can perform some
23:13 - kind of validation so before setting the
23:16 - balance we can make sure it's a positive
23:18 - value so if balance is greater than zero
23:22 - then we can set it now a better
23:24 - implementation is to throw an exception
23:26 - or an error if the balance is an invalid
23:29 - value but let's not worry about that we
23:31 - don't want to do too much Java in this
23:32 - course we're gonna stick to the basics
23:34 - this is what we call a setter a method
23:37 - that is used for setting the value of a
23:39 - field by the same token we can have a
23:41 - getter so if you want to read the value
23:43 - of the balance field we can call a
23:45 - method called get balance so public
23:48 - float get balance
23:51 - and here we return the value of the
23:54 - banners field this is the encapsulation
23:56 - principle in action so encapsulation is
23:59 - really about bundling the data and
24:01 - methods that operate on the data within
24:04 - one unit or one class and hiding the
24:07 - values or state of an object inside the
24:10 - class so with this we can create robust
24:12 - applications we can prevent our objects
24:14 - from going in an invalid state so this
24:17 - is the encapsulation principle now we
24:20 - can take this to the next level instead
24:22 - of this method set balanced it would be
24:25 - better if you had methods like withdraw
24:27 - and deposit so instead of sending the
24:29 - balance to some kind of random value
24:31 - it's better to record some kind of
24:33 - transaction so we know when we deposited
24:36 - or withdrew money from this account so
24:39 - let's add a new method public void
24:41 - deposit we give it a parameter called
24:44 - amount and then we can set this that
24:47 - balance to this that balance plus amount
24:52 - or in Java we can use the Augmented
24:56 - assignment operator so we can rewrite
24:58 - the statement like this this the balance
25:01 - plus equals amount these two statements
25:05 - are identical right in this case we
25:08 - don't even need the disk keyword because
25:10 - our parameter is called amount so that
25:12 - is better of course here we need to do
25:14 - some kind of validation as well you want
25:16 - to make sure that amount is a positive
25:18 - value so if amount is greater than zero
25:22 - then we update the ballas similarly
25:25 - we're going to add a method called
25:27 - withdraw for taking money out of this
25:30 - account
25:33 - once again we add our validation logic
25:34 - if amount is greater than zero then we
25:38 - reduce the balance by this amount this
25:42 - is a better implementation so let's get
25:45 - rid of the set balance method
25:48 - now from the main method
25:50 - instead of setting the balance to some
25:52 - random value we can use the deposit or
25:55 - withdrawal methods that we created so
25:56 - initially we deposit $10 into this
26:00 - account then we withdraw
26:03 - $5 finally we get the balance and
26:07 - printed so sou t-tap that's our print
26:10 - line statement and here we can call
26:12 - account that get balance let's run the
26:15 - program and the balance is five dollars
26:17 - beautiful so this is all about
26:20 - encapsulation next we're going to talk
26:22 - about abstraction
26:28 - now let's talk about the second
26:30 - principle of object-oriented programming
26:32 - abstraction abstraction means that we
26:35 - should reduce complexity by hiding
26:37 - unnecessary details in our classes let
26:40 - me give you a metaphor think of the
26:42 - remote control of your TV this remote
26:44 - control has a bunch of buttons that
26:46 - allow you to work with your TV inside
26:48 - the remote control you have an
26:49 - electronic board and bunch of
26:51 - transistors and so on now we don't
26:54 - directly work with this transistors
26:55 - their implementation detail there's so
26:58 - much complexity there we don't want to
26:59 - worry about that complexity we don't
27:01 - care what happens inside that remote
27:03 - control when we press the turn on button
27:05 - this is the abstraction principle in
27:07 - action so the abstraction principle says
27:10 - that we should hide the unnecessary
27:12 - details in our classes and this helps us
27:14 - reduce complexity let's say this in code
27:17 - let's say we want to implement a class
27:19 - for sending emails to our users so let's
27:22 - add a new class we call this mail
27:25 - service in this class we need a method
27:28 - for sending an email so public void send
27:32 - email now in a real application here we
27:34 - should have a parameter of type email
27:36 - but let's not worry about it in this
27:38 - demo that's part of sending an email
27:41 - there are a number of things that should
27:42 - happen under the hood we have to connect
27:45 - to a mail server we have to authenticate
27:46 - we have to send the email and then
27:48 - disconnect so we could have a method
27:51 - like connect in this method we simply
27:55 - print a message like connect
27:57 - similarly we can have a method called
27:59 - disconnect and here we print this
28:04 - message and let's add one more method
28:08 - public void authenticate here we're
28:14 - gonna send our username and password to
28:15 - the mail server so let's say I
28:17 - authenticate now in our send email
28:21 - method we're gonna call these methods
28:23 - one by one first we're gonna connect
28:25 - then we're gonna authenticate next we're
28:28 - gonna send the actual email and finally
28:31 - we're going to disconnect now let's use
28:33 - this in our main class so over here
28:36 - let's create a mail service and set it
28:41 - to a new mail service now look at the
28:44 - interface of this class and by interface
28:46 - I'm not talking about the interface
28:48 - construct in Java I'm just talking about
28:50 - the interface of a class like the
28:52 - interface of a remote control what we
28:54 - see on that remote control or what we
28:56 - see in this class here we have four
28:59 - methods but the first three are
29:01 - implementation detail we don't care
29:03 - about this you don't care about
29:04 - connecting to a mail server we don't
29:06 - care about authentication all we care
29:08 - about is the ability to send an email so
29:12 - these three methods are adding extra
29:14 - complexity to this class they're making
29:16 - it harder for the consumers of this
29:18 - class to use this class so we applied
29:21 - the abstraction principle we go to our
29:23 - mail service and make this methods
29:26 - private now there are implementation
29:28 - detail and they're hidden from outside
29:30 - of this class one more time we make this
29:34 - private and one last time
29:37 - now back in the main class
29:40 - look at the interface of this class it
29:42 - has a single method it's much easier to
29:44 - use it's like a remote control with only
29:46 - four buttons have you seen how hard it
29:48 - is to use one of those remote controls
29:50 - that have 50 buttons you really don't
29:52 - know how to use them if you want to
29:53 - change the volume you have to look all
29:54 - over the place now this mail service
29:57 - class has a single method its phrase
29:59 - easy to use and more importantly if we
30:01 - change any of those private methods the
30:03 - main class is not going to get affected
30:05 - so if I introduce a parameter in this
30:09 - method let's say timeout
30:11 - the only breaking change that we have is
30:14 - over here the main class is not affected
30:17 - because the main class cannot see the
30:19 - connect method this is the benefit of
30:20 - applying the abstraction principle we
30:23 - can change the implementation detail
30:25 - without affecting other classes in our
30:27 - application next we're going to talk
30:29 - about inheritance
30:36 - let's talk about the third principle of
30:39 - object-oriented programming inheritance
30:41 - inheritance is a mechanism for reusing
30:43 - code let's say we want to build a Glee
30:45 - framework a graphical user interface
30:48 - framework in this framework we want to
30:50 - have classes like text box button
30:54 - checkbox and so on now Onis classes
30:58 - should have some common behavior for
31:00 - example we should be able to enable or
31:02 - disable them should be able to set their
31:04 - focus we should be able to set their
31:06 - position and so on
31:07 - now when implementing this class is we
31:10 - don't want to implement these behaviors
31:11 - in every single class that's a lot of
31:14 - code duplication inheritance is a
31:16 - mechanism that allows us to reuse code
31:18 - across our classes so we can implement
31:21 - all these common behaviors in a parent
31:24 - or base class and then have all these
31:26 - other classes inherit those behaviors
31:28 - let me show you so let's add a new class
31:32 - we're gonna call this UI control that's
31:37 - the base or the parent class for all
31:39 - widgets on the user interface
31:42 - now in this class we want to have the
31:43 - ability to enable or disable a control
31:46 - so a method called enable and here let's
31:51 - just print a message called enable now
31:54 - let's create a textbox class so we have
31:58 - a new class called textbox we run this
32:02 - class to inherit the code that we wrote
32:03 - in the UI control class
32:05 - so over here we type extends UI control
32:11 - now you can go to the main class and
32:14 - create a textbox object so VAR textbox
32:19 - will send it to a new text box I'll take
32:22 - a look here we have the enable method we
32:26 - didn't implement it in the textbox class
32:28 - we implemented it in the UI control
32:30 - class but the textbox inherited this
32:33 - code from its parent now when we run
32:35 - this program we can see the enabled
32:38 - message beautiful now there is more to
32:40 - inheritance than we can cover in this
32:42 - video I've dedicated an entire section
32:44 - about inheritance in the second part of
32:46 - my ultimate Java serious so if you want
32:48 - to learn more go watch that course next
32:51 - we're going to talk about polymorphism
32:58 - let's talk about the fourth principle of
33:01 - object-oriented programming polymorphism
33:03 - poly means many more fins form so
33:06 - polymorphism means many forms and it's
33:09 - basically the ability of an object to
33:11 - take on many forms let me show you this
33:13 - in code so continuing with a GUI
33:15 - framework we want to have the ability to
33:17 - draw each widget on the screen so in a
33:20 - UI control class let's add a method
33:23 - public void draw now this method is not
33:28 - gonna have an implementation because we
33:30 - don't know
33:30 - how to draw a UI control because the
33:33 - algorithm for drawing a widget is
33:35 - specific to the type of the widget
33:36 - drawing a text box is different from
33:38 - drawing a check box so we can leave the
33:41 - implementation empty or better we can
33:44 - declare this as abstract so public
33:47 - abstract void draw now we have a couple
33:51 - of compilation errors the first one is
33:53 - here because an abstract method cannot
33:56 - have a body so we remove the braces and
33:59 - terminate this with a semicolon this is
34:02 - like a method that we declare in an
34:04 - interface it's only a method declaration
34:07 - it doesn't have implementation now
34:09 - because we have an abstract method in
34:11 - this class we should declare this class
34:13 - as abstract as well this is like a
34:17 - half-baked cake we cannot use it
34:19 - directly we cannot instantiate it we
34:20 - cannot create a new instance of the UI
34:22 - control we can only extend it now if you
34:26 - go to our text box class we see a
34:28 - compilation error because this class has
34:30 - not implemented the draw method of the
34:33 - UI control so we put the caret over here
34:35 - press alt + enter' and implement methods
34:38 - exactly like how we implement the
34:40 - methods on an interface so now we have
34:45 - this public void draw method over here
34:48 - let's print drawing a text box
34:52 - now let's add another class in this
34:54 - project new class we're going to call
34:57 - this checkbox
35:00 - this classroom inherits all the code
35:02 - from the UI control so we type extends
35:04 - UI control then we have IntelliJ
35:08 - implement the abstract methods of this
35:11 - class there you go
35:12 - now we print drawing a checkbox so each
35:17 - widget knows how to draw itself okay now
35:20 - in our main class let's add a public
35:23 - static method public static void draw UI
35:28 - control we give it a parameter of type
35:31 - UI control and in this method we call
35:35 - control dot draw now in our main method
35:39 - we're going to call this method so draw
35:41 - your eye control now the UI control
35:43 - class is the parent or the base of the
35:46 - text box and check box classes so every
35:49 - textbox is a UI control and every check
35:52 - box is a UI control as well so we're
35:54 - calling this method we can pass a new
35:57 - instance of the textbox class and run
36:00 - the program
36:00 - here we see drawing a textbox if we pass
36:05 - and you check box we see drawing a check
36:10 - box so even though in this method we are
36:13 - working with a UI control object at
36:16 - runtime
36:16 - this object can take on many different
36:18 - forms it can behave like a check box or
36:21 - a text box or a button and so on this is
36:24 - polymorphism in action so an object can
36:27 - take on many different forms that's all
36:29 - about polymorphism so we have covered
36:31 - all the essential object-oriented
36:33 - principles next we're going to talk
36:35 - about um L which is the graphical
36:37 - notation we're gonna use throughout this
36:38 - course
36:44 - now that we have covered the essentials
36:46 - of Java let's talk about UML yeoman is
36:49 - short for unified modeling language and
36:51 - it's a visual language that we use to
36:53 - model our systems we're going to use it
36:56 - throughout this course to represent our
36:57 - classes and the relationship here are a
37:00 - few examples this is how we can
37:02 - represent a class in UML so we have this
37:05 - rectangle on the top we have the name of
37:07 - the class in the middle section we have
37:09 - the fields and down below we have the
37:11 - methods so here we have a class called
37:14 - shape in this class we have a field
37:16 - called position X and the type of this
37:19 - field is integer so after the colon we
37:22 - specify the type of a field or a
37:24 - parameter or the return type of a method
37:26 - so here we have a method called render
37:28 - it doesn't have any parameters that is
37:31 - why we have an empty pair of parentheses
37:32 - and it doesn't return any values so we
37:36 - don't have a colon after the name of the
37:38 - method so that means the return type of
37:40 - this method is void now this minus sign
37:43 - means this field is declared as private
37:45 - you can see that over here and obviously
37:48 - the plus sign means this is declared as
37:50 - public now in this course we're assuming
37:53 - that all of our fields are private and
37:55 - all of our methods are public so in the
37:57 - future diagrams I'm not going to display
37:59 - the minus and plus signs to keep things
38:02 - simple so this is how we can represent a
38:04 - class in UML now let's talk about the
38:06 - three types of relationships between
38:08 - classes this is what we call the
38:11 - inheritance relationship so this diagram
38:13 - is saying that the rectangle class
38:15 - inherits from or extends the shape class
38:18 - you can verify that over here so class
38:21 - rectangle extends shape now we're
38:24 - accurately in UML the inheritance
38:26 - relationship is indicated by an arrow
38:29 - with an empty triangle but in the
38:31 - software I'm using we don't have such an
38:33 - arrow so I'm gonna display my
38:34 - inheritance relationships with an arrow
38:37 - with a filled triangle ok now let's talk
38:40 - about the second type of relationship
38:42 - between classes this is called the
38:44 - composition relationship it's indicated
38:47 - by an arrow with a diamond so that means
38:49 - the shape class is composed of the size
38:53 - class
38:54 - in practical terms that means in the
38:56 - shape class we have a field of type size
38:58 - so the shape class is composed of this
39:02 - size class as another example you can
39:04 - say the car class is composed of the
39:07 - wheel class because every car has four
39:10 - wheels now in UML we have another type
39:12 - of relationship called aggregation which
39:14 - is kind of similar to composition but I
39:17 - don't want to bring too much UML in this
39:18 - course you want to keep things simple
39:20 - and focus on design patterns so if you
39:22 - have some background in UML you may
39:24 - argue that here we should use an
39:25 - aggregation relationship instead of
39:27 - composition let's not worry about these
39:29 - subtle details so this is the
39:31 - composition relationship now let's talk
39:34 - about the third type of relationship
39:35 - between classes this is what we call the
39:38 - dependency relationship it's indicated
39:41 - by dashed arrow so that means somewhere
39:43 - in the shape class we have a reference
39:45 - to the document class here's an example
39:48 - in the shape class we have a method
39:50 - called render and this method has a
39:52 - parameter of type document so document
39:55 - is not a field in this class but it's
39:57 - used somewhere in this class in this
39:59 - case it's a parameter but it could also
40:01 - be a local variable defined in the
40:04 - render method so somewhere in the shape
40:06 - class we have a reference or a
40:08 - dependency to the document class okay so
40:12 - here are the three types of
40:13 - relationships we're going to use in this
40:15 - course inheritance composition and
40:18 - dependency
40:21 - hey guys maj here i just wanted to let
40:23 - you know that this video you've been
40:25 - watching is the first hour of my
40:27 - ultimate design patterns course in this
40:29 - youtube video we talked about two design
40:32 - patterns but my ultimate design patterns
40:34 - course includes over 20 design patterns
40:36 - these are the design patterns that every
40:38 - software engineer must master so if you
40:41 - want to learn more I highly encourage
40:42 - you to enroll in my ultimate design
40:44 - patterns course the first 200 students
40:46 - can get the course with a big discount
40:48 - I'll put the link down below if you're
40:50 - interested the first design pattern
40:55 - we're going to talk about is the momento
40:56 - pattern we use this pattern for
40:58 - implementing undo mechanisms let me show
41:01 - you first of all I'm gonna add a new
41:03 - package to this project so in your
41:05 - package we call this momentum this is
41:08 - where we're gonna write all the code for
41:09 - this pattern now let's say we want to
41:12 - build a code editor that supports the
41:14 - undo mechanism so we add a new class in
41:17 - this package we call it editor in this
41:21 - class we need a feel for storing the
41:23 - current content of the editor so private
41:26 - string content we also need a getter and
41:29 - a setter for this field now we don't
41:31 - have to type these manually by hand we
41:34 - can have IntelliJ create these for us so
41:36 - we put the carrot on the field name
41:37 - press alt' + enter' and select create
41:41 - getter and setter for content there you
41:44 - go so here's our editor class now before
41:47 - talking about the momento pattern I want
41:49 - you to spend 10 to 15 minutes and think
41:51 - about a solution to implement the undo
41:53 - feature in this class so in our main
41:55 - class we should be able to create a new
41:58 - editor let's say editor equals new
42:02 - editor then we should be able to set the
42:05 - content of your times let's say a and B
42:07 - and C and then we should be able to undo
42:11 - the content
42:13 - so it spent 10 to 15 minutes and think
42:15 - about a solution to implement this
42:17 - feature this is extremely important
42:19 - because I want to teach you the art of
42:21 - problem solving
42:22 - unlike other courses I'm not gonna give
42:24 - you a UML diagram saying this is the
42:26 - moment of pattern and this is how it
42:27 - works I want to take you through the
42:29 - same thought process that Gang of Four
42:30 - have been through so you understand how
42:32 - and why they came up with a momento
42:35 - pattern so spend 10 to 15 minutes and
42:37 - propose a solution when you're done come
42:40 - back see the next lesson
42:46 - all right here's our editor class with
42:49 - the content field not to keep the screen
42:51 - clean I didn't add the getter and the
42:53 - setter that we created in the last video
42:54 - now the simplest way to solve this
42:57 - problem is by introducing a new field
42:59 - called previous content so every time we
43:02 - want to change the value of the content
43:04 - field we store the current value in the
43:06 - previous content field and then change
43:09 - the content field that's a very simple
43:10 - solution and it works however with this
43:13 - approach we can only undo once if you
43:16 - want to be able to undo multiple times
43:18 - we need a list so we should rename this
43:21 - field to previous contents note the
43:23 - plural name and the type of this field
43:25 - is gonna be a list that's a reasonable
43:27 - solution now what if some time in the
43:30 - future we introduce a new field like
43:32 - title so our editor window is gonna have
43:35 - a content and a title now to support the
43:38 - undo mechanism we need another field
43:40 - like previous titles to keep track of
43:43 - all the changes to the title field now
43:45 - as you can see this solution is not very
43:47 - extensible every time we introduce a new
43:49 - field we need to add an extra field for
43:52 - storing all the changes to that field so
43:55 - we need to come up with a better
43:56 - solution now let me remove these two
43:58 - fields okay that's better so instead of
44:01 - having multiple fields in this class we
44:03 - need a separate class like editor state
44:05 - this class will be purely responsible
44:08 - for storing the state of our editor at a
44:10 - given time correctly we have only one
44:12 - field in this class called content in
44:14 - the future we can add title and other
44:17 - fields all these fields are gonna be in
44:18 - a single class okay so in our editor
44:21 - class we need to store a list of editor
44:25 - States so we need a composition
44:27 - relationship between these two classes
44:29 - and that means we should rename this
44:31 - field from previous contents to previous
44:34 - States so you have a list of editor
44:36 - States inside the area class beautiful
44:39 - now this is a better solution because it
44:41 - allows us to undo multiple times and
44:43 - we're not gonna pollute the editor class
44:46 - with too many fields okay however this
44:49 - solution is violating a very important
44:52 - principle in object-oriented design that
44:54 - is a single responsibility
44:56 - rinsable that basically means every
44:58 - class should have a single
44:59 - responsibility let me give you a
45:01 - metaphor think of a restaurant in a
45:04 - restaurant
45:04 - every person has a specific role they do
45:06 - a single thing the waiter is purely
45:09 - responsible for taking orders they don't
45:11 - cook for you now imagine a restaurant
45:13 - where the waiter takes your order he
45:15 - cooks for you he goes shopping he also
45:17 - does taxes it doesn't make sense a
45:19 - restaurant like that is gonna be very
45:20 - unmanageable we have the same situation
45:23 - in software to build maintainable
45:25 - software we should design our classes in
45:28 - such a way that they have a single
45:29 - responsibility now back to our design
45:32 - our editor class correctly has two
45:34 - responsibilities one of them is state
45:36 - management the other is providing the
45:38 - features that we need from an editor we
45:40 - need to take all the state management
45:42 - work outside of this class and put it
45:44 - somewhere else so we shouldn't have this
45:47 - field inside this class previous States
45:49 - let's delete this that means we're not
45:51 - gonna have an association with the
45:53 - editor of state class so delayed that's
45:56 - better
45:56 - we need to introduce a new class called
45:58 - history this class will have a single
46:01 - responsibility and that would be state
46:03 - management so it will keep track of the
46:05 - changes in the state of the editor okay
46:08 - now in this class we need a field called
46:10 - States this is the field that we
46:12 - previously had in our editor class okay
46:15 - so we have this field here and that
46:17 - means we're gonna have a composition
46:19 - relationship with the editor state the
46:22 - history class is gonna store 0 or more
46:25 - editor state objects in a list ok we
46:28 - also need two methods push and pop with
46:31 - push we add a new state in the history
46:33 - and we pop we remove and return the last
46:36 - state now technically we could use a
46:38 - stat here instead of a list but that's
46:40 - implementation detail let's not worry
46:42 - about it too much at this stage now let
46:44 - the area class no longer stores state
46:46 - objects internally we should give it two
46:49 - new methods create state and restore
46:52 - state the create state method
46:54 - stores the current state of the editor
46:56 - inside a state object and returns it so
46:59 - we call this method and say hey save
47:01 - your current state and give it to me
47:03 - we'll get an editor state object then we
47:07 - call the push method of the history
47:09 - class
47:09 - say hey history save this state this is
47:13 - how these classes collaborate okay
47:15 - the restor method takes a state object
47:17 - and brings this editor back to that
47:20 - state so it will reset its fields based
47:22 - on what we have in this state object now
47:25 - look at the type of relationship we have
47:27 - between the editor and the editor state
47:29 - classes we have a dependency
47:31 - relationship that means the editor class
47:33 - uses the editor of state because to
47:36 - create state method returns an editor a
47:38 - state object okay well congratulations
47:41 - you came up with your first pattern this
47:44 - is called the momento pattern we use the
47:46 - momentum pattern to implement undo
47:48 - mechanisms in our classes now here's our
47:51 - representation of the momentum pattern
47:52 - but if you look at the Gang of Four book
47:54 - or any of the courses or books on this
47:56 - topic you will see different names for
47:59 - these classes the editor is called the
48:01 - originator the editor state is called
48:03 - the momentum and the history is called
48:06 - the caretaker these are just some
48:08 - abstract names that Gang of Four came up
48:10 - with to demonstrate the concept it
48:13 - doesn't mean you have to use them to
48:14 - name your classes always use meaningful
48:16 - names for your classes so this is the
48:19 - moment of pattern in this pattern we
48:20 - have three participants or three players
48:23 - originator momentum and caretaker now
48:25 - that you understand this pattern let's
48:28 - go ahead and implement it in code
48:35 - alright first of all in the moment a
48:37 - package let's add a new class we call
48:41 - this editor state currently we need only
48:44 - a single field in this class so private
48:46 - string content it would be nice to
48:50 - initialize this field from the
48:51 - constructor so we can press alt + enter'
48:54 - and add a constructor with a parameter
48:58 - there you go so we have a constructor
49:01 - this constructor has a single parameter
49:02 - and in the body of this constructor we
49:05 - initialize this field with the value of
49:07 - this parameter pretty simple now I would
49:10 - prefer to declare this field as final
49:13 - this will make sure that once we
49:15 - initialize this field we cannot
49:17 - accidentally change it on our program so
49:19 - this will add robustness to our code now
49:22 - we also need a getter here for reading
49:24 - the value of this field later on so I'll
49:27 - turn enter and create getter for content
49:31 - that's it we're done with this class now
49:34 - let's go to our editor class here we
49:37 - need two new methods create state and
49:40 - restore so public editor state create
49:45 - state when we call this method the
49:48 - editor will save its current state
49:50 - inside an editor state object and return
49:52 - it so return new editor State and here
49:57 - we pass the value of the content field
50:00 - now let's create the restore method it's
50:02 - pretty easy
50:03 - public void restore we give it a state
50:06 - object
50:08 - and here we set the content field to
50:11 - stay it but get content as simple as
50:15 - that the last piece of the puzzle is the
50:17 - history class so in this package let's
50:21 - add in your class we call it history
50:25 - here we can use a stack or a list I
50:27 - don't want this course to be wait Java
50:29 - is specific so I'm gonna go with a list
50:31 - private list of editor State now what is
50:37 - going on here
50:38 - well this list is an interface that is
50:41 - declared in the Java that util package
50:44 - so first we need to import it otherwise
50:46 - the compiler doesn't recognize it we can
50:48 - press alt' + enter' and intellij
50:51 - imported it on the top so import
50:53 - java.util that list now this list
50:56 - interface is a generic interface which
50:59 - means we can use it to build a list of
51:01 - different types of objects we can have a
51:02 - list of strings we can have a list of
51:04 - integers a list of editor states
51:06 - so with this angle brackets we specify
51:09 - the type of objects we want to store in
51:11 - this list in this case we want to store
51:13 - editor state objects okay
51:15 - now let's call this field state and set
51:18 - it to new array list
51:22 - what is going on here well I told you
51:25 - that this list is an interface that is
51:27 - declared in the java.util package in
51:29 - this package we have a class called
51:32 - ArrayList that implements this interface
51:34 - so you're programming to an interface
51:37 - because the ArrayList class might have
51:39 - other methods that we are not interested
51:40 - in we only need the functionality that
51:42 - is declared in the list interface okay
51:45 - now here we need two methods push on pub
51:48 - public void push it takes an editor
51:52 - state object and here we call States
51:57 - then add state this will add the state
52:01 - object at the end of the list okay
52:03 - now public editor state pop here we need
52:10 - to calculate the index of the last item
52:13 - in this list that is very easy so far
52:15 - last index now the list interface has a
52:19 - method called size this returns the
52:21 - number of items in this list now the
52:23 - index of the first item in the list is 0
52:25 - so to get the index of the last item we
52:29 - should get the size and reduce it by 1
52:32 - now we get the last item last item or
52:36 - last state that's better
52:37 - states that get with this we can get an
52:41 - item at a given index so let's get this
52:45 - item then we need to remove it from this
52:47 - list so we call States done remove and
52:50 - pass the last state object and finally
52:54 - we return the last date from this method
52:58 - that is our history class now let's put
53:01 - all of this together and see the undo
53:03 - mechanism in action so here in the main
53:06 - method first we create an editor object
53:08 - next we create a history object so of
53:11 - our history equals new history
53:15 - here we set the content to a at the same
53:18 - time you want to save this date in the
53:20 - history so we call editor that creates
53:23 - date this will return the current state
53:25 - and we'll add it to our history so we
53:28 - call history that push with this object
53:31 - a simple a stack one more time we set
53:35 - the content to be and right after that
53:37 - we save this date in the history next we
53:41 - set the content to see now here we can
53:43 - undo so we call history but pop this
53:48 - will return the Prima state and then
53:49 - we'll give this to our editor so we say
53:51 - hey earlier restore yourself with this
53:55 - date like this now if you print the
53:59 - current state of the editor it should be
54:01 - be take a look
54:03 - so print editor but get content take a
54:07 - look we get B if you undo one more time
54:10 - you're gonna see a so let's duplicate
54:13 - this line now run there you go so this
54:18 - is how we implement the momento pattern
54:25 - in this section I'm going to talk about
54:26 - the state pattern let's say you want to
54:28 - build a drawing application like
54:30 - Photoshop in Photoshop and in many other
54:32 - applications we have a palette of tools
54:35 - over here and this canvas behaves
54:37 - differently depending on the tool that
54:39 - we select for example if you select the
54:42 - selection tool you can see the icon of
54:44 - the cursor changes now when we click and
54:47 - drag we say this - rectangle similarly
54:51 - if you select the brush tool and click
54:53 - and drag we see this orange line so
54:56 - basically this canvas object is
54:57 - responding to Mouse events like Mouse up
55:00 - and mouse down but what it does changes
55:03 - depending on the currently selected tool
55:05 - let's simulate this in code
55:07 - so in this project first I'm gonna add a
55:10 - new package state we're gonna write all
55:13 - the code for this section in this
55:15 - package
55:16 - now here we need a new class called
55:20 - canvas this class should respond to
55:23 - Mouse events like Mouse down and mouse
55:26 - up so here when the two methods public
55:28 - void Mouse down and I'm gonna duplicate
55:33 - this and rename the second one to Mouse
55:36 - up
55:38 - now in both these methods we should do
55:40 - different things depending on the
55:42 - currently selected tool the first minute
55:44 - to figure out what is the currently
55:45 - selected tool we can represent that
55:47 - using an enum an enum in Java is like a
55:50 - set of constants let me show you so in
55:53 - this package we add a new class first we
55:57 - change the kind from class to enum and
56:00 - then call it tool type
56:04 - I hear we need to define a few constants
56:06 - like selection note that I'm using
56:09 - uppercase letters to name this constant
56:11 - this is a convention in Java so this is
56:14 - our selection tool we also need a brush
56:17 - and an eraser now back in our canvas
56:20 - class here may need a field to store the
56:23 - currently selected tool that is really
56:25 - easy so private tool type current - we
56:30 - also need a getter and a setter for this
56:32 - field so we put the carrot over here
56:34 - press alt' + enter' and create getter
56:37 - and setter beautiful now in our mouse
56:41 - down method we should write code like
56:42 - this if current 2 equals tool type dot
56:48 - selection here we should change the icon
56:50 - of the cursor to the selection icon so
56:53 - we simulate that by printing something
56:55 - on the terminal selection icon now else
57:01 - if current tool equals tool type that
57:05 - brush then we're going to print a
57:07 - different message brush icon
57:10 - one more time elsif current total equals
57:13 - tool type that eraser then we're gonna
57:16 - print eraser icon now when it's similar
57:20 - code in the mouse up method so to save
57:23 - time I'm gonna copy this and then paste
57:26 - it over here and then change what we
57:28 - print on the terminal so the moment the
57:30 - user releases the mouse button if the
57:33 - current tool is a selection tool you're
57:36 - gonna draw a dashed rectangle so draw
57:39 - dashed rectangle if the current tool is
57:43 - brush we're gonna draw a line and if
57:46 - it's an eraser we're gonna erase
57:47 - something okay we could also implement
57:51 - this using a switch and case statement
57:54 - now if you have been programmed for a
57:56 - while you have probably seen patterns
57:58 - like this in your code you have a long
58:00 - list of if an LS or Sushant case
58:02 - statements and you have probably
58:03 - repeated these statements in different
58:05 - places in your code so in this example
58:08 - we have this decision making statements
58:10 - in these two methods chances are in a
58:14 - real application in a real drawing
58:15 - application we should also respond to
58:17 - keyboard events like e up and key down
58:20 - and we probably have to repeat all this
58:22 - decision-making inside those methods as
58:25 - well so the approach that we have taken
58:27 - is not maintainable the more tools with
58:30 - support the longer these decision making
58:32 - statements are going to be and
58:33 - maintaining this code is going to become
58:35 - really difficult also here we have the
58:38 - lack of extensibility it's not easy to
58:41 - extend this application let's say
58:43 - tomorrow we're going to add a new tool
58:44 - for drawing a circle we have to go to
58:47 - different parts of our code and make
58:48 - changes for example in our mouse down
58:51 - method we should add another else--if
58:53 - statement to see if the current tool is
58:55 - the circle tool then we change the icon
58:57 - to the circle icon we have to make a
58:59 - similar change in the mouse up method so
59:02 - extending this application is not easy
59:04 - now what we really need here is given
59:07 - the canvas the ability to behave
59:09 - differently based on the currently
59:11 - selected tool so in both these methods
59:14 - we're executing different code depending
59:17 - on the currently selected tool we want
59:19 - this method to behave differently
59:20 - depending on the current tool
59:23 - in the course we talked about the four
59:24 - essential principles of object-oriented
59:27 - programming encapsulation abstraction
59:30 - inheritance and polymorphism which one
59:33 - of these principles do you think we
59:34 - cannot play here to solve this problem I
59:36 - want you to spend ten minutes on this
59:38 - exercise and figure out a way to solve
59:40 - this problem when you're done come back
59:42 - watch the next lesson
59:49 - earlier in the course we talked about
59:51 - polymorphism I told you that
59:53 - polymorphism is a mechanism that allows
59:55 - an object to take on many different
59:57 - forms so earlier we built this UI
60:00 - control class we declared this as
60:02 - abstract because it has a single
60:04 - abstract method abstract methods are
60:07 - methods that have no implementation so
60:10 - here we have a draw method but we don't
60:11 - know how to draw a UI control the
60:14 - drawing algorithm will be dependent on
60:16 - the type of the UI control so we created
60:19 - two specific UI controls one of them was
60:22 - the textbox class which extends the UI
60:24 - control and this is where we're
60:26 - implementing the logic for drawing a
60:28 - textbox now in our main class we had
60:31 - code like this we declared a static
60:34 - method called draw UI control which
60:36 - takes a UI control and simply calls
60:38 - control that draw that depending on the
60:42 - type of the object that we pass to this
60:43 - method
60:44 - our application behaves differently this
60:46 - is polymorphism in action so if it has
60:49 - an instance of the textbox class the
60:51 - draw method of the textbox class will be
60:54 - called even though we're working with
60:55 - the UI control class here so this
60:58 - control object can take on many
61:00 - different forms
61:01 - this is polymorphism here's the UML
61:04 - diagram of this classes so our main
61:06 - class talks to the UI control which is
61:08 - the parent or the base of these two
61:11 - classes text box and checkbox in UI
61:14 - control we have an abstract method
61:16 - called draw and we have implemented this
61:19 - method in our child classes now we can
61:21 - use the same technique to get rid of
61:23 - those ugly if and else statements in our
61:25 - canvas class so here's our canvas class
61:28 - we have the current tool field and these
61:30 - two methods we want these methods to
61:32 - behave differently depending on the
61:35 - current tool so we introduce a new class
61:38 - called tool this is going to be an
61:39 - abstract class like our UI control in
61:41 - this class we're going to declare two
61:43 - abstract methods mouse up and mouse down
61:46 - what happens when the user releases the
61:49 - mouse button will be determined in child
61:52 - classes so we introduce new classes like
61:54 - selection and brush
61:57 - in this classes we're gonna implement
61:58 - the logic for mouse up and mouse down
62:01 - events now our canvas class is going to
62:04 - work with the abstract tool class it
62:06 - doesn't care about any specific tools
62:07 - but it will behave differently depending
62:10 - on this specific tool that we give it at
62:12 - runtime and this is what we call the
62:15 - state pattern because the state pattern
62:17 - allows an object to behave differently
62:19 - when it state changes now if you look at
62:22 - the classic definition of the state
62:23 - pattern in the Gang of Four book or
62:25 - other books on courses you're gonna sit
62:28 - different labels so instead of canvas we
62:30 - have context and instead of tool we have
62:32 - state with two concrete implementations
62:35 - also instead of mouse up and mouse down
62:38 - methods we have the request method that
62:40 - is handled by the state class so as I
62:43 - told you before this is just an abstract
62:44 - concept it doesn't mean you should name
62:46 - your classes context or state there are
62:49 - two abstract always use meaningful names
62:51 - that fit the domain of your application
62:53 - next I'm going to show you how to
62:55 - implement this state pattern in code
63:02 - so here in the state package let's add a
63:05 - new class tool in this class we need to
63:10 - abstract methods so public abstract void
63:13 - mouse down and mouse up now because
63:19 - these methods are abstract we should
63:21 - mark the class as abstract as well now
63:25 - we could also use an interface here
63:26 - because an interface is simply a
63:29 - contract that determines the
63:30 - capabilities that a class should provide
63:32 - so earlier you saw that the metals in an
63:35 - interface don't have an implementation
63:37 - they're exactly like our abstract
63:39 - methods here now what is the difference
63:41 - between an interface and an abstract
63:43 - class well they're both abstract
63:45 - concepts we cannot instantiate them we
63:47 - cannot create a new instance of this
63:49 - tool class or the tool interface so
63:52 - because they're abstract and don't have
63:54 - much code they allow us to build loosely
63:56 - coupled applications we prefer to use an
63:58 - abstract class if you want to provide
64:00 - some common code to all the child
64:02 - classes in this case we're not providing
64:05 - any common code to our tools so I'm
64:07 - gonna replace this abstract class with
64:09 - that interface take a look
64:11 - public interface now in interfaces we
64:14 - don't need the abstract keyword because
64:16 - these methods are considered abstract by
64:18 - default so we remove the abstract
64:21 - keyword also these methods are
64:23 - considered to be public so we don't need
64:25 - the public keyword either that makes our
64:27 - code cleaner so we have an interface for
64:31 - a person take a tool now let's implement
64:34 - specific tools so let's add a class
64:37 - called selection tool here we type
64:41 - implements tool now note that here we
64:44 - have two interfaces with the same name
64:46 - the first one is the one that we just
64:48 - created we also have a tool interface in
64:51 - Java X package don't worry about that
64:54 - let's import the interface that we
64:56 - created okay now we should implement
64:59 - this interface so we press alt' + enter'
65:01 - and implement these methods so this is
65:05 - where we implement the logic
65:07 - with the selection tool when the user
65:09 - presses the mouse button we should
65:11 - change the icon to the selection icon
65:14 - and when they release the mouse button
65:16 - we should draw a dashed rectangle okay
65:21 - now let's add one more class this one is
65:26 - going to be our brush tool brush tool
65:29 - also implements the tool interface here
65:34 - we have a different logic so when the
65:37 - user presses the mouse button we should
65:39 - display the brush icon and when they
65:43 - release the mouse button we should draw
65:45 - a line now let's see how we can
65:48 - incorporate these into our canvas class
65:50 - so let's open up the canvas class first
65:54 - we should change the type of this field
65:57 - from tool type to tool so we're
66:01 - programming to an interface okay now we
66:04 - have a bunch of compilation errors it
66:06 - doesn't matter we're going to delete all
66:07 - the code in these methods all this nasty
66:11 - disgusting code now we should change the
66:15 - return type of our getter
66:17 - instead of tool type we're going to use
66:19 - tool and similarly for our setter
66:22 - we're gonna pass a tool object beautiful
66:25 - now in our mouse down metha
66:28 - we're gonna call current tool dot mouse
66:31 - down and similarly here we call current
66:35 - tool dot mouse up that's all we have to
66:38 - do isn't this code beautiful so the
66:41 - canvas class is simply delegating for
66:44 - your specific tool to determine what
66:47 - should happen when the user process or
66:49 - releases the mouse button with this
66:51 - implementation we don't have a long list
66:54 - of decision-making statements so our
66:56 - application is more maintainable and we
66:58 - can also easily extend it let me show
67:00 - you so right now we only have two types
67:03 - of tools a selection tool and a brush
67:06 - tool let's use this and then I'll show
67:08 - you how to extend this application to
67:10 - support a new tool so we go to our main
67:12 - class first we create a canvas object so
67:17 - Camus's now we set the current tool set
67:23 - current tool here we should pass an
67:25 - object that implements the tool
67:27 - interface so we can pass a selection
67:30 - tool then we call mouse down and finally
67:35 - mouse up let's see what happens
67:40 - so the icon change
67:42 - to the selection icon and then we draw a
67:44 - - rectangle beautiful if we pass an
67:47 - instance of the brush tool class will
67:50 - get different result there you go
67:52 - now let's say tomorrow we're gonna
67:54 - support a new tool that's really easy
67:57 - all we have to do is to add a new class
67:59 - that implements the tool interface take
68:01 - a look so here I'm gonna add a new class
68:06 - let's say eraser tool you have this
68:10 - class implement the tool interface and
68:16 - over here we implement our logic so
68:20 - erase your icon and here erase something
68:25 - now we go back to our main class and
68:28 - simply pass a new instance of the eraser
68:31 - tool class take a look we get different
68:36 - result and that brings us to a very
68:39 - important principle in object-oriented
68:41 - programming open-closed principle that
68:43 - basically means our classes should be
68:45 - open for extension but closed for
68:47 - modification so we're not allowed to
68:50 - change the code in our classes we can
68:52 - only extend it now with this principle
68:54 - we can add new functionality without
68:57 - changing the existing code we can
68:59 - support new functions by adding new
69:01 - classes now why does this matter
69:03 - well how many times have you found
69:05 - yourself changing the code in a class
69:07 - and then breaking something your
69:09 - application the open closed principle
69:10 - prevents situations like that every time
69:13 - we want to support a new feature we
69:15 - simply add new classes and we test those
69:18 - glasses okay so following this principle
69:20 - makes our applications extensible and
69:23 - robust if this concept is new to you
69:26 - don't worry you're going to see more
69:27 - examples of this later in the course
69:34 - so design planners are great they help
69:37 - us build maintainable extensible and
69:40 - reusable objects however sometimes they
69:42 - get misused here's an example you've got
69:45 - this guy over here his name is John
69:47 - Smith he's a fairly arrogant developer
69:49 - you've probably seen him in my other
69:51 - courses he recently learned about design
69:53 - patterns and started refactoring some
69:55 - existing code to apply these patters now
69:57 - he feels superior to his coworkers he
70:00 - feels like a superstar developer just
70:02 - because he learned about this date
70:03 - pattern and applied it in code that is
70:05 - what I call abusing patterns remember
70:08 - this every pattern has a context it's
70:10 - there to solve a particular problem and
70:12 - that's why I've taken a problem driven
70:15 - approach in this course so you learn and
70:17 - understand when and how to apply these
70:19 - patterns if you just blindly apply these
70:22 - patterns in your code you're gonna
70:23 - increase complexity because you're gonna
70:25 - end up with more moving parts so not
70:28 - only haven't you solved the problem but
70:29 - you actually created a new problem you
70:31 - created what we call a design smell in
70:34 - your application that is an application
70:36 - with an overly complicated design some
70:38 - people call it over-engineered I don't
70:40 - like to use that term because a real
70:42 - engineer always tries to understand a
70:44 - problem first and then they think of
70:46 - various solutions and pick the one that
70:48 - best fits the problem that is the
70:51 - definition of an engineer at least for
70:52 - me over engineering a solution is what
70:55 - code monkeys do programmers will blame
70:57 - the right code without understanding the
70:59 - problem they're trying to solve as
71:00 - Leonardo da Vinci said simplicity is the
71:03 - ultimate sophistication
71:05 - so keep things simple and pragmatic
71:07 - don't blindly apply these design
71:09 - patterns without understanding the
71:11 - problem you're trying to solve next I'm
71:13 - gonna show you a real example of abusing
71:15 - the state pattern
71:20 - all right let me show you how the state
71:22 - pattern can easily be abused let's say
71:25 - you want to implement a stopwatch app in
71:27 - this app we need a stopwatch class with
71:30 - a click method when we click it it
71:32 - either starts counting or stops so in
71:35 - our state package let's add a sub
71:38 - package I'm going to call this abuse
71:42 - now this package we're going to add a
71:44 - new class called stop watch here we need
71:49 - the click method now depending on the
71:53 - state of this object we should do
71:55 - different things we can represent the
71:57 - state with an enum with two states or we
72:00 - can use a boolean I think a boolean is
72:02 - easier so let's go with a boolean so
72:04 - private boolean is running now when we
72:10 - click the stopwatch if it's running
72:14 - then we're gonna stop it so we set is
72:17 - running to false and then we print
72:19 - stopped otherwise we're gonna set is
72:23 - running to true and then print running
72:27 - let's test our implementation after this
72:29 - point so in the main class we create a
72:33 - stopwatch and then
72:39 - click it initially it stopped so when we
72:42 - run this application we should see the
72:44 - running message
72:48 - there you go beautiful now if you click
72:51 - it one more time we see two messages
72:53 - running and then stop if we click it one
72:56 - more time
72:58 - we see running stopped running beautiful
73:01 - so this is a very simple straightforward
73:03 - implementation now John Smith takes away
73:07 - this code he's sitting in the office and
73:09 - he thinks hmm the click method is
73:11 - behaving differently depending on the
73:13 - state of the stopwatch so that is the
73:15 - case for the state pattern it's gonna
73:18 - refactor this code like this first it's
73:21 - going to create a new class or an
73:24 - interface called
73:25 - state
73:27 - so we need an interface here this
73:30 - interface is going to have one method
73:32 - click and you're gonna have two classes
73:35 - that implement this interface so John
73:38 - adds two classes one of them is stopped
73:41 - state the other is running state running
73:48 - state now both these glasses should
73:51 - implement the state interface if the
73:56 - stopwatch is running we should stop it
73:58 - and then print a message but how are we
74:00 - going to be able to stop this stopwatch
74:02 - we don't have access to the stopwatch
74:04 - object here well we can add a
74:06 - constructor so public running state
74:12 - we give this constructor a parameter of
74:15 - type stopwatch and then store it in a
74:19 - field
74:19 - so we declare a private field here
74:22 - private stopwatch
74:24 - we call it stopwatch and we initialize
74:27 - it in the constructor this the stopwatch
74:29 - equals stopwatch now in the click method
74:33 - we should change the state of the
74:35 - stopwatch so first we need to go to the
74:37 - stopwatch class
74:40 - an out of field to store the current
74:42 - state of this object so we don't in this
74:44 - field anymore
74:45 - let's declare a private field of type
74:47 - state called current state now let's
74:52 - generate a getter and a setter for this
74:54 - field that is super easy there you go up
74:57 - so back to the running State
75:00 - when we call the click method we should
75:03 - change the state of the stopwatch so we
75:05 - call stopwatch that set state
75:09 - and here we pass the next date that is
75:11 - the stopped state so new stopped State
75:15 - now here we have a compilation error
75:17 - because this class doesn't implement the
75:20 - state interface so let's add it real
75:23 - quick implements state all right
75:29 - the back in the running State class the
75:31 - problem is gone beautiful so we change
75:33 - the state and then print a message
75:35 - saying stopped now we need a similar
75:38 - approach in the stopped state class so
75:44 - here we generate a constructor I'm going
75:46 - to show you a shortcut if you're on Mac
75:48 - press command + n if you're on Windows
75:50 - press ctrl + n with this we can bring up
75:53 - the generate palette and generate a
75:55 - constructor now here we can add a
75:58 - parameter that is stopwatch
76:02 - and at the same time we can create and
76:04 - initialize a private field so we put the
76:06 - carrot on the parameter name press alt'
76:09 - + enter' and select create field for
76:12 - parameter stopwatch there you go so we
76:17 - got a private field and this field is
76:18 - initialized over here beautiful now in
76:21 - the click method we should change the
76:23 - state of the stopwatch so we call
76:25 - stopwatch that's that current state if
76:29 - it stopped we should set it to the
76:30 - running state so new running state now
76:34 - here we should pass a reference to the
76:37 - stopwatch that is the stopwatch field
76:39 - that we have in this class okay then we
76:42 - print a message saying ready okay now we
76:46 - have a compilation error and the running
76:48 - state class because when we try to
76:51 - change the state of the stopwatch we're
76:54 - passing a new instance of the stop state
76:56 - class the constructor of the stop state
76:59 - class expects a stopwatch object so we
77:02 - pass that object over here problem so
77:06 - so you have to state classes and the
77:08 - final part you go to the stopwatch and
77:11 - replace this implementation with current
77:15 - state dot click so we're delegating the
77:19 - task of clicking the stopwatch to the
77:21 - state object and by the way initially we
77:24 - should set this to the stopped state so
77:26 - Neil stop state now here we should pass
77:30 - a reference to a stopwatch object that
77:33 - is gonna be this that represents the
77:35 - current object we're done now back in
77:38 - the main method so internally we changed
77:41 - the implementation of the stopwatch but
77:43 - it behaves the same thing let's run the
77:45 - program
77:47 - we see the exact same result as before
77:49 - beautiful however
77:52 - this implementation is way more complex
77:55 - than the simple if a nail statement that
77:57 - we had before so there is absolutely
77:59 - nothing wrong with even else or Sushant
78:02 - case statements if you have a few
78:04 - decision making branches in a single
78:06 - method like how we did in the stopwatch
78:08 - class we had those decision-making
78:10 - statements in a single place there is
78:12 - absolutely nothing wrong with that
78:14 - implementation but in our previous
78:16 - example in our canvas class we had those
78:20 - decision-making statements in multiple
78:23 - places in the mouse down and mouse op
78:25 - methods and more importantly if you
78:28 - wanted to support a new tool we had to
78:30 - modify different parts of our code that
78:32 - is the reason why we refactor this code
78:34 - we change this structure and use this
78:37 - state pattern in contrast in the
78:39 - stopwatch all that decision-making was
78:42 - in a single place and we know that this
78:44 - Dulwich is not going to have a new state
78:46 - in the future
78:47 - it's either stopped or running a simple
78:50 - as that so we don't have a
78:51 - maintainability issue here
78:52 - we don't have extensibility issue we
78:54 - ended up refactoring this code well I
78:56 - didn't just smoothly that but he made
78:59 - this code overly complicated without
79:02 - gaining any benefits now we have more
79:04 - moving parts
79:05 - we have an interface plus two
79:08 - implementations and our logic is spread
79:10 - over these two different classes in
79:12 - contrast and the previous implementation
79:14 - all that logic was in a single place
79:17 - so here is the bottom line don't abuse
79:20 - the design patterns
79:24 - congratulations on completing this
79:26 - YouTube tutorial as I told you before
79:28 - this video is the first hour of my
79:30 - ultimate design patterns course if you
79:32 - want to learn more I highly encourage
79:34 - you to enroll in my course where we talk
79:36 - about twenty other design patterns these
79:38 - are the essential design patterns that
79:40 - every software engineer must master the
79:42 - first 200 students can get the course
79:44 - with a big discount so if you're
79:45 - interested and will now before this
79:47 - offer expires you can find the link
79:49 - below this video thank you and have a
79:51 - fantastic day
79:54 - [Music]
79:55 - you