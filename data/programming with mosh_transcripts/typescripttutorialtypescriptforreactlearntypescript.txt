00:00 - [Music]
00:02 - in order to build applications with
00:03 - angular you need to be comfortable with
00:06 - typescript so in this section i'm going
00:08 - to introduce you to the fundamentals of
00:10 - typescript and object-oriented
00:12 - programming principles so by the end of
00:15 - this section you will have a good
00:16 - understanding of type annotations arrow
00:19 - functions interfaces classes
00:22 - constructors access modifiers properties
00:25 - and modules
00:27 - if you are familiar with this concept
00:28 - and know how to implement them in
00:30 - typescript feel free to skip this
00:32 - section and move on to angular
00:34 - otherwise you really need to watch every
00:36 - lecture in this section so now let's get
00:38 - started
00:42 - so what is typescript
00:44 - typescript is not an entirely new
00:46 - language
00:47 - it's a superset of javascript so that
00:49 - means any valid javascript code is also
00:52 - valid typescript code but typescript has
00:56 - additional features that do not exist in
00:58 - the current version of javascript
01:00 - supported by most browsers out there
01:03 - for example in typescript we have this
01:05 - concept of strong or static typing if
01:08 - you have worked with languages like
01:09 - c-sharp and java you know that in these
01:12 - languages when we define a variable we
01:14 - need to specify the type of that
01:16 - variable now in typescript typing is
01:19 - optional so we don't have to use this
01:20 - feature but using this feature makes our
01:23 - applications more predictable and it
01:25 - also makes it easier to debug them when
01:28 - something goes wrong
01:29 - typescript also brings quite a few
01:31 - object-oriented features that we have
01:33 - missed in javascript for a long time we
01:36 - have the concept of classes interfaces
01:39 - constructors access modifiers like
01:41 - public and private fields properties
01:44 - generics and so on you're going to learn
01:46 - about this in this section
01:48 - another benefit of using typescript is
01:51 - that with typescript we can catch errors
01:53 - at compile time instead of at runtime
01:55 - but of course not all kinds of errors
01:57 - but a lot of errors
01:59 - so there is a compilation step involved
02:01 - and when we compile our typescript code
02:03 - we can catch these errors and fix them
02:05 - before deploying our application and
02:08 - finally another benefit of using
02:09 - typescript is that we get access to some
02:12 - great tools out there
02:14 - one thing that i personally love about
02:16 - typescript is the intellisense that we
02:18 - get in our code editors again you're
02:20 - going to see that in this section so
02:22 - typescript is a beautiful language and
02:24 - it's basically a superset of javascript
02:26 - so any valid javascript code is also
02:28 - valid typescript code
02:30 - now the browsers out there they don't
02:32 - understand typescript and it's very
02:34 - unlikely that they're going to support
02:36 - it in the future
02:37 - so we need to compile or more accurately
02:40 - transpile our typescript code into
02:43 - javascript
02:44 - so this is part of building our
02:45 - application whenever we build our
02:47 - application typescript compiler kicks in
02:51 - and it transpiles our typescript code
02:53 - into javascript code that browsers can
02:55 - understand
02:57 - now that's enough introduction next i'm
02:59 - going to show you how to install
03:00 - typescript and write your first
03:02 - typescript program
03:06 - in this lecture i'm going to show you
03:07 - how to install typescript and write your
03:09 - first typescript program so here we're
03:12 - in the terminal we're not going to work
03:13 - with angular in this section we're going
03:15 - to purely focus on typescript so first
03:18 - we need to install typescript globally
03:20 - on our machine
03:21 - so npm
03:23 - install
03:24 - dash g which stands for global
03:27 - typescript
03:28 - and of course if you're on mac you need
03:30 - to put sudo at the front
03:35 - all right beautiful so i have installed
03:37 - the latest version of typescript which
03:39 - is currently version 2.3.4
03:42 - now we can type tsc which stands for
03:45 - typescript compiler dash dash version
03:49 - again you can see that i'm running
03:50 - typescript 2.3.4
03:54 - all right now i'm going to create a new
03:55 - folder for this section
03:57 - so let's call this ts
03:59 - hello
04:01 - let's go to this folder
04:02 - now here i'm going to create a new file
04:04 - and open it with vs code so code
04:07 - main.ts
04:11 - so now i'm going to write some plain
04:13 - javascript code and i want to show you
04:15 - that all this javascript code is also
04:17 - valid typescript code so first i'm going
04:20 - to define a function
04:22 - let's call this log
04:24 - that takes a message
04:28 - and here we simply log that message on
04:31 - the console
04:32 - like this
04:35 - then i'm going to declare
04:37 - a global variable let's call this
04:39 - message
04:41 - and set it to this string hello world
04:44 - and finally call
04:45 - our log function
04:47 - message
04:48 - so this is just plain javascript code
04:50 - right
04:51 - now save
04:53 - back in the terminal we need to
04:55 - transpile this typescript file into
04:57 - javascript
04:58 - so
04:59 - tsc or typescript compiler main.ts
05:04 - now if you look at the files in this
05:05 - folder
05:07 - look we have main.js and main.ts
05:10 - now this transpilation or compilation
05:13 - step when you're building an angular app
05:15 - happens under the hood so you don't have
05:18 - to manually call the typescript compiler
05:21 - in fact when you run your application
05:22 - using ng-serve angular cli calls
05:25 - typescript compiler under the hood to
05:28 - transpile all our typescript code
05:31 - all right now let's open our main.js
05:33 - file so code
05:35 - main.js
05:38 - so it's exactly the same code that we
05:39 - wrote but now it's in a javascript file
05:42 - so all javascript code is also valid
05:45 - typescript code
05:46 - now back in the terminal i can execute
05:48 - this code using node so node main.js
05:53 - and we got the hello world message on
05:55 - the console
05:56 - so from the next lecture we're going to
05:57 - look at specific features of typescript
06:00 - that we don't currently have in
06:01 - javascript
06:05 - all right let's export typescript by
06:06 - looking at variable declarations
06:09 - so in typescript there are two ways to
06:11 - declare a variable we can use the var
06:14 - keyword which you have seen in
06:15 - javascript like var number we set it to
06:18 - one
06:19 - or we can use the let keyword
06:21 - so let count
06:23 - to be 2.
06:24 - now before i explain the difference i
06:26 - need to clarify that the let keyword is
06:28 - also being added to the javascript so
06:31 - javascript has a few different versions
06:33 - we have es5 or ecmoscript 5 which is the
06:37 - version of javascript supported by
06:39 - pretty much all browsers out there it's
06:42 - been around for a long time
06:43 - now we have es6 which is a newer version
06:46 - and it was introduced in year 2015 and
06:50 - from that point the ecmascript team
06:52 - which is the team extending javascript
06:55 - decided to use the year number instead
06:57 - of the version number so we have
06:59 - ecmascript 2015 2016 and 2017.
07:04 - now in ecmoscript 2015 which is
07:06 - basically es6 we also have this led
07:10 - keyword but in case you are not familiar
07:12 - with it let me explain how it works
07:15 - so i'm going to define a function
07:18 - let's call it do something it doesn't
07:20 - really matter
07:21 - now here i'm going to define
07:23 - a 4 block
07:24 - so var we set i to 0
07:28 - and as long as i is less than five let's
07:30 - increment it
07:32 - here we have a block and then log it on
07:34 - the console
07:36 - now finally at the end of this function
07:38 - i'm going to log this i one more time
07:42 - but with the label finally
07:46 - and then i'm going to call this function
07:48 - here
07:50 - so in the terminal i'm going to compile
07:52 - this file main.ts
07:54 - and also at the same time run it with
07:57 - node main.js
08:00 - note that the value of i at the end is
08:03 - 5.
08:04 - so this is the issue we have when
08:06 - declaring a variable using the var
08:08 - keyboard
08:09 - so we have declared i here inside this
08:12 - four block but is also meaningful and
08:15 - available outside the four block
08:17 - now if you have worked with languages
08:19 - like c sharp or java you know that we
08:21 - don't have this concept in those
08:22 - languages
08:24 - in javascript a variable declared with a
08:26 - var keyword is scope to the nearest
08:29 - function so in this case the nearest
08:31 - function is do something
08:33 - so once we declare i inside this four
08:36 - block it's available anywhere in this
08:38 - function now let's see what happens when
08:41 - we declare this variable using the let
08:43 - keyword
08:44 - so let
08:47 - now look we immediately got a red
08:49 - underline here which indicates a
08:51 - compilation error this is one of the
08:52 - beauties of typescript
08:54 - when you are writing typescript code you
08:56 - can cache these errors at compile time
08:58 - before you run your application before
09:00 - you deploy it
09:01 - now let's hover our mouse here
09:04 - so this is the error cannot find name i
09:07 - so now i is scoped to the nearest block
09:11 - instead of nearest function and this is
09:12 - the proper way to declare variables
09:15 - which prevents a lot of issues later
09:18 - down the road
09:19 - now i want to clarify something let me
09:21 - save this file
09:23 - back in the terminal
09:24 - first i'm going to remove main.js
09:28 - now i'm going to recompile
09:31 - our main.ts
09:33 - okay we got our error here cannot find
09:35 - name i however
09:37 - if you look at the files in this folder
09:40 - we do have main.js so even though we
09:42 - have a compilation error the typescript
09:44 - compiler still generated main.js
09:48 - let's have a look at the content of this
09:49 - file
09:52 - so this is the code that is generated
09:54 - so by default typescript compiler
09:56 - compiles our typescript code to es5 or
09:59 - ecmascript 5 which is the older version
10:02 - of javascript that is supported by all
10:04 - browsers out there now there we don't
10:06 - have the led keyword so that's why our
10:09 - compile code now uses the var keyword
10:12 - and this is perfectly valid javascript
10:14 - code
10:16 - so i can go in the terminal and simply
10:19 - run this code
10:21 - and get the same output as before
10:23 - so what i want to clarify here
10:25 - is that typescript compiler reports
10:28 - these errors but still generates valid
10:31 - javascript code
10:33 - so here's the takeaway for this lecture
10:35 - from now on anywhere we want to declare
10:38 - a variable we use the let keyword once
10:40 - again this does not stop the compilation
10:42 - step but at least we can catch the
10:44 - issues earlier during the compile time
10:47 - next we're going to look at different
10:49 - types we have in typescript
10:53 - in this lecture i'm going to show you
10:55 - different types we have in typescript
10:58 - so let me start by declaring a variable
11:02 - called count and set it to 5.
11:04 - now if i set this to
11:06 - let's say a character or a string like a
11:09 - note that i immediately get a
11:11 - compilation error here telling me that
11:13 - this a string or a character is not
11:16 - assignable to type number
11:18 - now we can perfectly do this in
11:20 - javascript because in javascript we can
11:22 - change the type of variables on the fly
11:25 - but in typescript we get a compilation
11:27 - error now once again i want to clarify
11:30 - that we can perfectly compile this using
11:32 - typescript compiler and we will get
11:34 - valid javascript code
11:37 - so if i go to terminal and type
11:39 - typescript compiler
11:40 - main.ts
11:42 - now look this is our main.js so we have
11:45 - this count variable and we have changed
11:47 - its value we can perfectly execute this
11:49 - no problem
11:51 - however code like this is very likely
11:53 - that it's going to break at some point
11:55 - in the future because chances are we're
11:58 - going to use this count variable inside
12:00 - a 4 block so our program is going to
12:02 - break at runtime we don't want this to
12:04 - happen right that's one of the reasons
12:06 - it's better to write the same code in
12:08 - typescript so at least we can get a
12:10 - warning during the compilation step
12:13 - now if you hover your mouse over this
12:16 - count variable
12:18 - look at the tooltip
12:20 - you can see a colon and number after a
12:22 - discount so this indicates the type of
12:25 - count variable in our program so here
12:28 - typescript compiler inferred that the
12:30 - type of this variable should be a number
12:32 - because we set it to number five
12:35 - now what if i declare a variable without
12:37 - initializing it
12:39 - let's look at this type
12:41 - its type is now any and that's exactly
12:44 - like the variables we declare in
12:46 - javascript so i can set a to 1 then i
12:49 - can change the value to true and then
12:51 - set it to your string
12:53 - even typescript doesn't complain about
12:55 - this so what's the solution
12:57 - if we don't know the value of a variable
12:59 - ahead of time that's when we use type
13:02 - annotations so here we add colon and
13:05 - after that we set the type of this
13:07 - variable like number
13:10 - and then look on the third and fourth
13:12 - lines we got compilation errors
13:15 - now in typescript we have a few
13:17 - different types so we have number which
13:19 - can include any integer or floating
13:21 - point numbers
13:23 - we have booleans which can be true or
13:26 - false
13:27 - we have strings
13:30 - we have any that you saw
13:32 - earlier we have arrays so let's say we
13:35 - want to declare an array of numbers we
13:38 - would use number
13:40 - with square brackets
13:42 - now we can optionally initialize this to
13:44 - an array like this
13:47 - or we can declare
13:48 - in any array and with this
13:52 - we can set this to an array with these
13:53 - values one
13:55 - true
13:56 - a
13:57 - and false
13:58 - of course it's not a good practice we
14:00 - want to avoid this but i'm telling you
14:02 - what is possible with typescript
14:05 - now we also have another type that i
14:07 - absolutely love and that's enum so let's
14:10 - say we're working with a group of
14:12 - related constants like colors
14:14 - so in plain old or vanilla javascript we
14:18 - would define constant colors like this
14:20 - so color red we can set this to zero
14:23 - constant
14:25 - color
14:26 - green we set this to one and constant
14:28 - color blue set it to 2.
14:31 - now this is a little bit verbose
14:33 - in a lot of object-oriented languages we
14:35 - have this concept called enum so we can
14:38 - put all these related constants in a
14:40 - container
14:42 - so in typescript we can declare an enum
14:44 - like this
14:46 - enum or lowercase
14:48 - we give it a name like color
14:50 - now curly braces and here we set the
14:52 - values so red
14:55 - green
14:56 - and blue
14:58 - then we can declare a variable
15:00 - like background color
15:03 - and set it to color
15:04 - dot
15:05 - now look we have intellisense here so
15:08 - this tooltip you see here allows us to
15:10 - complete this code without remembering
15:12 - all the details
15:13 - and this is one of the things i love
15:15 - about typescript
15:16 - so let's set the background color to
15:18 - color dot red
15:20 - now in terms of the values the first
15:23 - element here automatically gets the
15:25 - value of zero
15:27 - and each subsequent element
15:29 - gets an incremented value
15:32 - so we don't have to explicitly set this
15:34 - but as a best practice it's better to do
15:36 - so because chances are sometime in the
15:39 - future someone may come here and add a
15:41 - new color here like purple
15:43 - and then purple would automatically
15:44 - become two and the value of blue would
15:47 - change to three
15:48 - so this may break parts of our
15:50 - application
15:51 - so
15:52 - let me revert this by explicitly setting
15:55 - the values if somebody adds a new color
15:58 - here like purple
15:59 - then it will not change the value of
16:01 - blue
16:03 - now let me show you something let's
16:04 - compile this code
16:06 - and see how we get enum in javascript
16:10 - so typescript compiler main.ts
16:15 - look at this piece of code here this is
16:17 - how we can implement the concept of
16:20 - enums in javascript we can see it's very
16:22 - complicated
16:24 - now compare this
16:26 - with how we declared an enum here it's
16:28 - much cleaner
16:30 - so the more you work with typescript the
16:32 - more you're going to love this language
16:36 - in this lecture i'm going to show you
16:37 - the concept of type assertions in
16:40 - typescript
16:41 - so i'm going to start by declaring a
16:43 - variable like message
16:45 - and setting it to a string
16:47 - now here we can type message dot
16:50 - and look we get this beautiful
16:52 - intellisense
16:53 - and in this tooltip we can see all the
16:55 - things we can do with a string so all
16:58 - these items with this purple icons are
17:00 - functions for example we have
17:02 - this function called ends with
17:05 - we can call this
17:07 - and see if this message and let's say
17:09 - with c
17:10 - and this returns a boolean
17:12 - so we can store the result in another
17:14 - variable like ends with
17:18 - c
17:20 - however sometimes typescript may be a
17:23 - little bit confused about the type of a
17:25 - variable for example
17:28 - i'm going to remove this initialization
17:29 - here
17:32 - initialize this variable on the second
17:33 - line abc
17:36 - now look at the type of this message
17:37 - variable
17:38 - it's any because by default when we
17:41 - don't set a value the type is any
17:43 - now the problem here
17:45 - is that if i delete this and type period
17:50 - look we don't get that intellisense
17:51 - anymore
17:52 - because ends with is something that we
17:54 - can do with a string not with an object
17:56 - of type any
17:58 - so what should we do in this case we
18:01 - need to explicitly tell typescript
18:03 - compiler that this message variable is
18:05 - actually a string
18:07 - and this is what we call type assertions
18:10 - now how do we do type assertions there
18:12 - are two ways one way is to prefix this
18:15 - variable with angle brackets
18:18 - and here we put the type like string
18:21 - now we need to enclose both these parts
18:24 - in parenthesis
18:26 - like this
18:27 - then if we press period
18:30 - we get our beautiful intellisense with
18:32 - all the functions or methods available
18:34 - on string objects
18:36 - now there is also another way to do type
18:38 - assertion
18:40 - so let's change the name of this
18:42 - variable to alternative way
18:45 - and here instead of angle brackets
18:48 - we use message as string
18:52 - they're exactly the same
18:54 - the approach you choose is purely your
18:55 - personal preference
18:57 - but the first approach is what you see
18:59 - more in a lot of tutorials and code
19:01 - bases out there
19:03 - now i just want to clarify something
19:04 - here this type assertion does not change
19:08 - the type of this variable at runtime in
19:10 - fact it's not going to restructure that
19:12 - object in memory it's purely a way to
19:15 - tell typescript compiler about the type
19:17 - of a variable so we can access the
19:19 - intellisense
19:23 - another concept you need to know when
19:24 - using typescript to build angular
19:26 - applications is the concept of arrow
19:29 - functions
19:30 - so in javascript we can declare a
19:32 - function like this
19:33 - let
19:34 - log we set this to a function
19:37 - this function takes a message object
19:40 - and simply logs it on the console
19:44 - like this
19:45 - now in timescript there is a shorter way
19:48 - to define this function
19:50 - so
19:51 - let's call the other one do log
19:54 - now we don't need the function keyword
19:56 - anymore we can simply add the parameters
20:00 - in this case message
20:02 - then
20:03 - we add this arrow and that's why we call
20:05 - this an arrow function
20:07 - and finally the code block
20:10 - so console.log message
20:13 - now if our function has only one line we
20:16 - can even exclude these curly braces
20:19 - so we can make this code a little bit
20:21 - shorter and cleaner like this
20:24 - if you are working with c sharp you have
20:25 - seen this before in c sharp we call this
20:28 - a lambda expression in typescript we
20:30 - call it an arrow function it's exactly
20:32 - the same thing
20:33 - now if you have one parameter here you
20:35 - can even exclude the parenthesis but i
20:38 - personally don't like this because i
20:39 - think it makes the code a little bit
20:41 - less readable so i always like to put my
20:44 - parenthesis here
20:46 - to indicate to the reader of this code
20:48 - that these are the parameters
20:50 - now what if we don't have any parameters
20:52 - we just add
20:53 - empty parenthesis and of course here we
20:55 - don't have the message
20:57 - so if you have not seen this before get
20:59 - used to it it's a really nice and clean
21:01 - way to define functions
21:06 - all right now let's see how we can use
21:08 - custom types in typescript so i'm going
21:10 - to start by declaring a function like
21:13 - draw point
21:15 - so this function takes an x and a y
21:19 - and simply draws it on the screen now we
21:21 - don't want to worry about the actual
21:23 - drawing algorithm we just want to focus
21:25 - on the signature of this function
21:28 - now this function is not too bad here we
21:29 - have only two parameters
21:31 - but sometimes when working with more
21:33 - complex concepts we may end up with a
21:36 - function that has so many parameters
21:38 - like this
21:40 - this is really really bad and it's
21:42 - something you should avoid at all times
21:44 - in those situations it's very likely
21:46 - that a group of these parameters maybe
21:49 - all of them
21:50 - belong to a single concept
21:52 - as an example think of a car a car has
21:54 - so many different properties we don't
21:56 - want to pass all those properties to a
21:58 - function like drive car instead we want
22:02 - to encapsulate them inside an object and
22:05 - only pass that one object here
22:08 - so in this example
22:09 - instead of passing x and y here it's
22:12 - better to pass a point object
22:15 - and then we can call this function like
22:16 - this draw a point
22:19 - we give it an object with two properties
22:22 - x
22:23 - and y
22:24 - so now our function has a cleaner syntax
22:28 - however there is a problem with this
22:29 - implementation instead of a point object
22:33 - i can pass a person object that has a
22:35 - name property
22:37 - and nowhere here we are getting a
22:38 - compile-time error but we know that this
22:40 - code is going to break at run time
22:42 - because the algorithm in our draw point
22:45 - function is expecting x and y properties
22:49 - so what's the solution
22:50 - well let me revert this back
22:53 - okay we've got x and y
22:55 - so there are two solutions to solve this
22:57 - problem
22:58 - one way is to use what we call inline
23:01 - annotation so just like we can annotate
23:03 - this parameter with the type like number
23:07 - we can annotate it with a custom type or
23:09 - custom object
23:11 - so here we add curly braces
23:14 - to indicate an object
23:15 - this object is going to have a property
23:17 - called x which is a number
23:19 - and also another property called y which
23:22 - is again a number
23:24 - so this is what we call inline
23:26 - annotation
23:27 - it works fine for simple cases
23:30 - but the problem with this as you can see
23:32 - is that this is a little bit verbose
23:35 - also chances are somewhere else we might
23:37 - have another function that expects a
23:39 - point object we don't want to repeat
23:41 - this object literal in multiple places
23:44 - so in those cases a better approach is
23:46 - to use an interface
23:48 - if you have worked with object-oriented
23:50 - program languages like c-sharp and java
23:52 - you know the concept of interfaces we
23:54 - have the same concept in typescript
23:57 - now if you have never worked with
23:58 - interfaces let me show you how they work
24:00 - so on the top i define an interface
24:05 - i'm going to call this point
24:08 - curly braces
24:10 - then i add x
24:12 - is a number
24:13 - and y
24:14 - is a number
24:16 - so with this interface i'm defining the
24:19 - shape of an object
24:20 - and then
24:22 - i can simplify this declaration
24:25 - and set the type of this parameter to
24:28 - point
24:29 - this is much cleaner and we can also
24:31 - reuse this in multiple places
24:34 - just one thing
24:35 - note the naming convention i have used
24:37 - here so because i'm introducing a custom
24:40 - type i've used pascal naming convention
24:44 - so the first letter of every word in the
24:46 - name of the interface should be
24:48 - capitalized so here we have uppercase p
24:51 - not the lowercase p okay
24:53 - so when using interfaces always use
24:55 - pascal naming convention
25:00 - so in the last lecture we used an
25:02 - interface to define the shape of a point
25:05 - object
25:06 - but there is a problem with this
25:07 - implementation
25:09 - in object-oriented programming languages
25:11 - we have this concept called cohesion
25:14 - which basically means things that are
25:16 - related should be part of one unit they
25:19 - should go together this is what we call
25:21 - cohesion now back to this example
25:24 - on the top we have used an interface to
25:26 - define the shape of a point object
25:28 - and below that we have a standalone
25:31 - function
25:32 - and this is where we have violated the
25:34 - cohesion principle
25:35 - so the concept of drawing a point is
25:38 - highly related to the structure of a
25:40 - point it should not be a separate
25:42 - function now if we're going to build a
25:44 - utility library for working with points
25:47 - chances are we're going to create
25:49 - another function
25:50 - like get distance
25:52 - that calculates the distance between two
25:54 - points
25:55 - so point a of type point
25:58 - and point b of type point and this goes
26:01 - to this code block
26:04 - again we have while at the cohesion
26:06 - principle we have two functions hanging
26:08 - in the air separate from the point
26:11 - object
26:13 - since these concepts are highly related
26:15 - they should be part of one unit
26:17 - in object-oriented languages we call
26:19 - that unit a class
26:21 - so a class groups properties and
26:25 - functions that are highly related
26:27 - now in this implementation
26:29 - unfortunately we cannot move these two
26:32 - functions inside our interface
26:35 - because interfaces are purely for
26:37 - declarations they cannot include any
26:40 - implementation in other words we cannot
26:42 - have the algorithm for calculating the
26:45 - distance between two points or drawing a
26:48 - point inside this interface what we can
26:51 - do instead
26:53 - is to add
26:54 - a function here a function declaration
26:58 - so we're going to have a draw function
27:00 - that takes no parameters
27:03 - and returns void which means it doesn't
27:06 - return anything now you might be asking
27:08 - why don't we have this point parameter
27:11 - here
27:12 - because if all these members x y and
27:15 - draw are part of one unit we don't need
27:18 - to pass x and y as parameters to the
27:20 - draw function this function can directly
27:23 - access these properties x and y in the
27:26 - same unit
27:27 - so we don't need this parameter here
27:29 - now in interfaces as i said we cannot
27:31 - have implementation we can only have the
27:34 - signature of a function so with this
27:36 - interface we're telling typescript
27:38 - compiler that our point objects should
27:40 - have two properties x and y and a
27:42 - function called draw the implementation
27:45 - of that is somewhere else
27:47 - so what should we do now to apply the
27:49 - cohesion principle here
27:51 - we need to use a class instead of an
27:53 - interface
27:54 - so on the top i'm going to change the
27:56 - type
27:57 - to class and here i'm going to replace
27:59 - this comma with semicolon
28:02 - so our point class has three members the
28:05 - first two members are what we call
28:07 - fields that we use for storing data
28:10 - and the third member is a function
28:13 - now here in this class we can have the
28:14 - actual implementation of this draw
28:16 - function
28:18 - so we can simply define it like this
28:20 - draw
28:22 - and then add all that logic for drawing
28:25 - a point
28:26 - now similarly we can have another
28:28 - function get distance
28:31 - that returns the distance between this
28:33 - point and another point
28:36 - like this
28:38 - again all that logic will end up here
28:41 - now with this restructuring you can see
28:43 - that everything about a point is in one
28:45 - unit in one class so we have the
28:48 - coordinate which includes x and y and
28:50 - two functions draw and get distance
28:54 - now in object oriented programming terms
28:56 - we refer to these members as fields
28:59 - and to these functions as methods
29:01 - so when a function is part of a class we
29:03 - call it a method
29:05 - all right now with this new
29:06 - implementation
29:08 - we don't want these two functions
29:09 - hanging in the air so delete
29:13 - this is a much better structure
29:15 - also we're not going to call drop point
29:17 - like this anymore
29:20 - so here's our point class in the next
29:22 - lecture i'm going to show you how to
29:24 - create an object of this type and call
29:26 - the draw method
29:30 - all right so here's our class
29:32 - now let's declare a variable of this
29:33 - type
29:34 - so let
29:35 - point
29:37 - be of type
29:38 - point and then
29:41 - we can type point dot
29:43 - look we have this beautiful intellisense
29:45 - we have two methods draw and get
29:47 - distance and two fields x and y
29:51 - now in typescript we also have a concept
29:53 - called property
29:55 - which is different from a field but a
29:57 - lot of people use these terms
29:58 - interchangeably later in this section
30:01 - you're going to learn the difference
30:02 - between fields and properties
30:04 - now if you want to call the draw method
30:06 - simply call it like this
30:09 - so this draw method is now part of the
30:11 - concept of a point it's not a function
30:14 - hanging in the air polluting the global
30:16 - namespace now for this demo i'm going to
30:18 - add
30:19 - a simple
30:20 - console.log here
30:23 - and display the coordinates of this
30:24 - point
30:26 - so x
30:27 - now here i want to add the x field but
30:30 - we cannot use it like this
30:32 - we need to prefix it with this dot
30:35 - so that refers to this field in this
30:36 - class
30:38 - and then i'm going to add y is
30:41 - once again this
30:43 - dot y
30:45 - now let's compile and run this program
30:47 - and see what happens
30:49 - so tsc
30:51 - what should we type here
30:52 - main.ts
30:54 - and we can shortcut by adding this pipe
30:57 - here
30:58 - type node
31:00 - and then main the js
31:02 - okay we got a runtime error
31:05 - cannot read property draw of undefined
31:09 - so this is the problem
31:11 - when we call this draw method this point
31:14 - object was undefined
31:16 - because here unlike the basic types we
31:19 - have in typescript like numbers strings
31:21 - booleans
31:22 - we're dealing with a custom type when
31:25 - defining an object of a custom type we
31:27 - need to explicitly allocate memory to it
31:30 - how do we do that
31:32 - well
31:33 - here where we declare the point object
31:36 - or the point variable
31:38 - we initialize it using the new operator
31:42 - so this object is a new
31:44 - point
31:46 - and here we add parenthesis this is the
31:48 - syntax
31:49 - now you can see that we have repeated
31:51 - this point here twice
31:54 - so we can make this code a little bit
31:55 - cleaner by removing this type annotation
32:00 - because typescript compiler can infer
32:02 - from this assignment here that the type
32:05 - of this object is a point object
32:07 - and let's verify that
32:09 - so look
32:10 - you're working with a point object
32:12 - now one more time save
32:15 - so back into terminal typescript
32:17 - compiler main.ts
32:21 - and then node main.js
32:24 - okay we didn't get an error but you can
32:26 - see that these x and y fields don't have
32:29 - a value because by default they are
32:30 - undefined
32:32 - so we can get back here
32:34 - and set point that x to let's say 1
32:38 - and point that y to 2.
32:41 - now back in the terminal
32:43 - typescript compiler main.ts i actually
32:46 - made a mistake earlier
32:47 - so instead of this pipe operator we need
32:50 - to use
32:50 - double ampersand on mac i don't know the
32:53 - windows equivalent
32:55 - so with this we can combine multiple
32:57 - commands
32:58 - so node main.js
33:02 - all right beautiful x is one and y is
33:05 - two
33:05 - so this is how we use the classes that
33:07 - we define in our programs now i want to
33:10 - highlight something here
33:11 - this point here is a class
33:14 - but this point here is an object
33:16 - an object is an instance of a class
33:20 - as a metaphor think of the concept of a
33:22 - human
33:23 - human could be a class but when we
33:25 - create instances of this class like john
33:27 - bob mary
33:29 - these are all objects so that's the
33:32 - difference between a class and an object
33:34 - next we're going to look at constructors
33:38 - all right so i've simplified the code
33:40 - from the last lecture i simply removed
33:42 - the method get distance because we're
33:44 - not going to use it later in this
33:45 - section so here on the top we define a
33:47 - point class and then below that we
33:49 - initialize a point object this code is a
33:53 - little bit verbose because we have three
33:55 - lines to create a point object and put
33:58 - it in a valid state
34:00 - what if this point object had a few
34:01 - other properties that we had to
34:03 - initialize like this
34:07 - and maybe a few more here
34:10 - is there a cleaner way absolutely
34:13 - so let me delete this first
34:14 - all right
34:15 - in object-oriented programming languages
34:18 - we have this concept called constructor
34:21 - so every class can have a constructor
34:23 - which is basically a method that is
34:25 - called when we create an instance of
34:28 - that class
34:29 - so let me show you how it works
34:31 - in the
34:32 - class i'm going to add a method
34:35 - the name of this method is constructor
34:37 - this is a reserved keyword in typescript
34:41 - now this method can have parameters so x
34:45 - which is a number
34:46 - and y which is also a number
34:49 - and then here in this method we can
34:51 - initialize these fields
34:53 - so what should we write here
34:55 - this dot x we set it to this x argument
34:58 - that we get here
35:00 - and similarly this.y
35:02 - we set it to y
35:05 - now look we got a compilation error here
35:07 - because when creating a new point object
35:09 - we need to supply these values look at
35:12 - the arrow
35:13 - supplied parameters do not match any
35:16 - signature of call target so here we need
35:19 - to supply the values for x and y
35:21 - one and two
35:23 - and with this we can simplify this code
35:26 - and get rid of these two extra lines
35:29 - and here's the end result
35:31 - now what if somewhere else in our
35:32 - program we don't know the initial
35:34 - coordinate of a point
35:37 - in other words what if i want to create
35:39 - a point object without setting these
35:41 - values is that possible
35:43 - yes absolutely but it's a little bit
35:45 - different from how you have seen that in
35:48 - other languages like c sharp and java
35:50 - in c sharp we can have multiple
35:52 - constructors in typescript we can't
35:55 - so the solution for this is to make
35:57 - these parameters optional
36:00 - so here after x i add a question mark
36:04 - and that makes x optional
36:06 - and similarly
36:07 - y should be optional as well because
36:10 - once you make a parameter optional
36:12 - all the other parameters on the right
36:14 - side of that parameter should also be
36:16 - optional this is a rule by typescript
36:18 - and a lot of other program languages
36:20 - so now look we don't have a compilation
36:22 - error when creating a point object
36:25 - without initial values
36:29 - all right so here i've created a point
36:30 - object with an initial coordinate now
36:33 - what if in our program you want to have
36:35 - this rule such that when we initialize a
36:37 - point object we should not be able to
36:40 - change the x or y values
36:44 - with this implementation i can always
36:46 - come here and set point.x to a different
36:49 - value
36:50 - how can we avoid this
36:51 - sometimes we need this feature in our
36:53 - programs because it will make them more
36:55 - predictable it reduces the chance for
36:57 - bugs
36:59 - so how should we prevent the coordinates
37:01 - of this point object to change after
37:03 - it's initialized
37:04 - well in object-oriented languages we
37:06 - have this concept called access
37:09 - modifiers
37:10 - an access modifier is basically a
37:12 - keyword that we can apply to a member of
37:15 - a class
37:16 - to control its access from the outside
37:19 - so in typescript we have three access
37:21 - modifiers
37:22 - public private and protected public and
37:25 - private are the most common and by
37:27 - default all members are public
37:30 - let me show you what i mean
37:31 - so here in our point class we have three
37:34 - members right we have two fields and one
37:37 - method
37:38 - so
37:40 - when we create a pointer object
37:42 - and type point
37:43 - dot look
37:45 - these are the members of the class and
37:47 - because they are all public we can
37:49 - access them here and that's why we can
37:51 - see them in the intellisense
37:53 - however
37:54 - i can go here
37:56 - and prefix this field with the private
37:59 - keyword
38:00 - now
38:02 - once we create this point object
38:04 - if i type point dot
38:06 - look x is not in the list it's not
38:09 - accessible it's private so if we try to
38:12 - set point.x to 3 look we have a
38:14 - compilation error in typescript
38:17 - says property x is private and only
38:20 - accessible within class point
38:23 - now with this technique i can go here
38:27 - and apply the private keyword
38:29 - on the y field as well and now
38:33 - once i initialize a point object i can
38:36 - no longer
38:37 - change its coordinates i can only call
38:39 - the draw method
38:41 - okay so this is why we use axis
38:43 - modifiers to control access to certain
38:46 - members of a class from the outside you
38:48 - can apply these access modifiers on
38:50 - fields properties and methods
38:54 - now by default
38:55 - if you don't set an access modifier
38:58 - it's assumed to be public so here the
39:00 - draw method as you know is public i can
39:03 - also add the public keyword here but
39:05 - this is redundant it's just making my
39:07 - code noisy
39:09 - so you don't really need to add this
39:10 - it's better to keep your code short and
39:12 - clean and use the private access
39:14 - modifier only when you need to
39:17 - next i'm going to show you one of my
39:19 - favorite features of typescript around
39:21 - access modifiers
39:24 - as you write code with typescript you
39:26 - see constructors that follow a pattern
39:29 - like what you see here
39:30 - so here we have two parameters in our
39:32 - constructor and we use these two
39:34 - parameters to initialize the fields in
39:36 - this class the code looks a little bit
39:38 - redundant this dot x equals x and this.y
39:42 - equals y typescript has a fantastic
39:45 - feature that helps you achieve the same
39:46 - thing with less code
39:49 - so here
39:50 - we can delete these two fields here
39:54 - and in our constructor we can prefix our
39:57 - parameters with an axis modifier
40:00 - so here i want to have two private
40:02 - fields x and y i can simply prefix these
40:07 - with the private keyword
40:08 - like this
40:11 - so typescript compiler will generate
40:14 - these fields for us
40:15 - and also
40:16 - we don't need these ugly repetitive
40:19 - assignments either
40:21 - so if we prefix a constructor parameter
40:24 - with an access modifier with a private
40:26 - or public typescript compiler will
40:29 - generate a field with the exact same
40:31 - name and it would also initialize that
40:33 - field with the value of this argument
40:35 - it's one of my favorite features and
40:37 - you're going to see that a lot in this
40:39 - course
40:40 - now clarify something before i finish
40:42 - this lecture
40:43 - in this case our fills were private but
40:45 - if they were public we would use the
40:47 - public keyword here so this means when
40:50 - we create a point object
40:53 - we can access
40:55 - the x field
40:56 - okay
40:58 - so
40:59 - i'm going to revert this back
41:01 - to the private
41:06 - all right now this implementation has a
41:08 - tiny problem we can set the initial
41:11 - coordinate of this point and we can also
41:13 - draw it but there is no way for us to
41:16 - read the coordinate so i cannot access
41:18 - point that x here to display it to the
41:21 - user
41:22 - what's the workaround
41:23 - well one simple solution
41:26 - is to define a method like this get
41:29 - x
41:31 - and here we simply return
41:33 - this dot x
41:35 - because in this class we do have access
41:37 - to all the private members of this class
41:40 - but we cannot access them from the
41:42 - outside okay
41:43 - now here
41:45 - i can always call point dot get x
41:49 - to get the x value and display to the
41:51 - user
41:52 - now let's talk about another use case
41:55 - maybe we want to give the user the
41:56 - ability to set the initial coordinate
41:59 - here
42:00 - but we also want them to be able to
42:02 - change this coordinate later
42:04 - only if they provide a value within a
42:07 - given range
42:08 - what do you mean by that let me show you
42:10 - i'm going to define another method here
42:12 - set x
42:16 - now this method is going to get a value
42:19 - that's the new value for the x field let
42:22 - me scroll down
42:23 - now here first we can do some basic
42:25 - validation so if value is less than zero
42:29 - we want to throw an error throw new
42:32 - error
42:34 - value cannot be
42:36 - less than zero
42:39 - otherwise we want to set this but x to
42:42 - this new value okay
42:45 - now with this implementation
42:47 - we can always change the value of the x
42:49 - field like this
42:51 - point that set x
42:53 - we set it to a new value
42:55 - now if you have a use case like that in
42:57 - your applications you can use what we
42:59 - call a property
43:01 - so in typescript and in a lot of
43:03 - object-oriented programming languages we
43:06 - have a concept called property which is
43:08 - exactly for this very use case
43:11 - so look at how i can define a property
43:13 - here
43:14 - we start with the keyword which is get
43:17 - or set
43:18 - and then the name of the property which
43:20 - is in this case x
43:22 - and after that we're going to have
43:23 - parenthesis just like a method okay
43:27 - now similarly i'm going to change this
43:28 - to set with a space so we have the set
43:31 - keyword and here it's like we have a
43:33 - function a method
43:35 - now what is the difference
43:36 - the difference is that we can use these
43:38 - properties like fields
43:41 - so here
43:42 - i can read x like this dot
43:46 - note the icon of x it's the same icon we
43:48 - have for fields it's not a method
43:51 - anymore
43:52 - so we can read x
43:55 - and we can also set it like this point.x
43:58 - we set it to 10.
43:59 - we don't have to call a method like this
44:02 - it's a cleaner syntax okay
44:05 - so this is what properties are for if
44:08 - you have private fields that you want to
44:10 - give maybe a read-only access to the
44:12 - outside or if you want to give the
44:14 - consumer of your classes the ability to
44:16 - set the values but you want to have some
44:18 - basic validation that's when you use a
44:21 - property now in this case if i want to
44:23 - give only the read only access to this
44:25 - underlying field i can simply comment
44:28 - out
44:29 - the setter
44:31 - so we call this method a setter and the
44:34 - other method a getter okay
44:36 - and now look at this compilation error
44:38 - we cannot change the value of x
44:41 - now let's bring this back
44:43 - one last thing before we finish this
44:45 - lecture
44:46 - so here i have used a capital x for the
44:48 - name of my x property
44:51 - in javascript and in typescript we use
44:53 - camel notation to name our field
44:56 - so that's why
44:58 - earlier we defined this private field
44:59 - here using camelcasing notation
45:02 - camelcasing means the first letter of
45:04 - the first word is lowercase and the
45:06 - first letter of every word after is
45:08 - uppercase
45:10 - now what should we do to use camelcasing
45:12 - notation for our properties
45:15 - if i name this
45:17 - the lowercase x
45:19 - it clashes with the existing field so
45:22 - let me revert this back
45:23 - a convention we use to solve this
45:25 - problem
45:26 - is to prefix the name of the underlying
45:28 - field with an underline so let's rename
45:31 - this using f2
45:33 - and prefix it with an underlay
45:36 - okay
45:37 - similarly for the y parameter or the y
45:39 - field i'm also going to use
45:41 - underline y
45:43 - then we can rename this property from
45:45 - capital x to lowercase x
45:48 - once again we press f2
45:50 - lowercase x
45:52 - and note that both instances both the
45:54 - getter and the setter are updated
45:58 - now we can work with this x property
46:02 - exactly the same way we use the x field
46:05 - so here's the lesson
46:06 - a property looks like a field from the
46:09 - outside
46:10 - but internally it's really a method in
46:12 - the class well more accurately it's
46:15 - either one method which is a getter or a
46:17 - setter or a combination of a getter and
46:20 - a setter
46:24 - all right i've simplified the definition
46:26 - of the point class i removed the
46:28 - properties so we have a simple
46:29 - constructor and the draw method and
46:32 - we're using this point class below its
46:34 - definition
46:35 - now this is a very simple program with
46:37 - only one file but the real world
46:38 - application consists of tens or hundreds
46:41 - of files we don't want to write all the
46:44 - code in one file like main.ts
46:46 - so ideally i want to move the definition
46:49 - of this point class somewhere else in a
46:51 - file like point.ts
46:54 - so here in this project i'm going to add
46:56 - a new file
46:58 - point.ts
47:01 - now back in main.ts
47:03 - i'm going to select all this code
47:05 - cut it
47:07 - and move it to point a ts now in
47:11 - typescript we have this concept called
47:13 - modules
47:14 - now what a module is requires a little
47:16 - bit more explanation but for now let me
47:18 - give you a simple pragmatic definition
47:22 - in typescript you can think of each file
47:24 - as a module so in this program
47:27 - we can say we have two modules but this
47:29 - is not quite accurate because these
47:31 - files are not modules yet
47:34 - so in point.ts we have defined this
47:37 - class called point but this is not
47:40 - accessible anywhere outside this file so
47:43 - this file defines its own scope
47:46 - in order for us to use this class
47:48 - somewhere else in our program
47:50 - we need to export this to the outside
47:53 - so we add the export keyword here
47:56 - and now this is visible outside this
47:58 - file
47:59 - now that we're exporting something on
48:01 - top of this file
48:03 - from typescript's point of view this
48:04 - file is a module
48:06 - now we need to go back to our main.ts
48:09 - and import this class so we can use it
48:12 - so back in main.ts
48:14 - look we have a compilation error
48:17 - cannot find name point because we have
48:20 - not imported this into main.ts
48:24 - so on the top
48:25 - we write import
48:27 - in curly braces we add the name of the
48:29 - types we want to import in this case
48:32 - point now if there are multiple types we
48:35 - want to import
48:36 - we separate them using comma okay
48:41 - so we import point
48:43 - from
48:44 - now here we put the name of the module
48:47 - in quotes what is the name of the module
48:49 - it's the relative path to that module
48:52 - from this file
48:54 - so both these files are in the same
48:55 - folder
48:56 - we can use period slash which refers to
48:59 - the current folder
49:01 - and then
49:02 - point
49:03 - is the name of our module so it's not
49:05 - point.ts look we get a compilation error
49:09 - so the name of our module is point
49:12 - now we no longer have a compilation
49:14 - error here and we can create an instance
49:16 - of this point class and use it
49:18 - now there is a lot more to talk about
49:20 - when it comes to modularity in
49:22 - typescript
49:23 - but that's all you need to know for now
49:25 - in order to start building applications
49:27 - with angular because in angular
49:29 - framework we have a lot of types that
49:31 - are exported so we need to import these
49:34 - into our typescript files and use them
49:37 - you're going to see that a lot in this
49:38 - course
49:39 - the only difference is that angular
49:41 - modules are defined in a different way
49:43 - so we don't add the relative paths to
49:46 - these module files because these files
49:48 - are not really part of our application
49:50 - they're somewhere inside node underline
49:53 - modules folder so when it comes to
49:56 - importing types defined in angular
49:58 - we use the library name as the module
50:00 - name for example one of the libraries is
50:04 - at angular slash core
50:07 - okay
50:08 - so here's the lesson
50:10 - in typescript we divide our program into
50:12 - multiple files
50:14 - in each file we export one or more types
50:17 - these types can be classes functions
50:21 - simple variables or objects and wherever
50:23 - we need to use these types we need to
50:25 - import them first
50:27 - when we have an import or export
50:29 - statement on top of a file that file is
50:31 - a module from typescript's point of view
50:34 - in angular we also have the concept of
50:36 - modules but angular modules are a little
50:39 - bit different they're not about
50:40 - organization of code in different files
50:42 - they are about organization of your
50:44 - application into smaller functional
50:47 - areas you're going to learn about
50:49 - angular modules in the next section
50:53 - hi thank you for watching my angular
50:55 - tutorial if you enjoyed this video
50:57 - please like it and share it with others
50:59 - also you can subscribe to my channel for
51:01 - free new videos every week
51:04 - this video is part of my complete
51:06 - angular course with almost 30 hours of
51:09 - high quality content where you will
51:11 - learn everything about angular from the
51:13 - basic to the advanced topics all in one
51:15 - course so you don't have to jump from
51:17 - one tutorial to another in case you're
51:19 - interested you can get this course with
51:21 - a big discount using the link in the
51:23 - video description and if not that's
51:25 - perfectly fine continue watching as the
51:27 - next section is coming up