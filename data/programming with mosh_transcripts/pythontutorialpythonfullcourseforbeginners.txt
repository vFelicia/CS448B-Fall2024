00:00 - Hi, my name is Mosh, and I'm going to be your instructor in this Python course.
00:04 - In this course, you're going to learn everything you need to get started programming in Python.
00:08 - Python is one of the most popular programming languages, and every day people use it to do
00:12 - cool things like automation, they use it in AI, as well as
00:16 - building applications and websites like Instagram and Dropbox. So if you're looking
00:20 - for a job, Python is for you. In this course I'm going to teach you everything 
00:24 - you need to get started with Python. We're going to talk about all the core concepts
00:28 - in Python, and then we're going to build three Python projects together.
00:32 - Here's the first project we're going to build. We're going to learn how to create this beautiful website
00:36 - for an imaginary grocery store. Here on the homepage we can see all
00:40 - of the products in the shop, and we also have an admin area for managing the
00:44 - stock. We're going to build this using a popular Python framework called Django. 
00:48 - Now if you have never built a website before, don't worry, I will teach you everything from scratch. 
00:52 - You're also going to learn how to use Python in machine learning, or artificial intelligence. 
00:56 - So you will learn how to write a Python programming that will predict
01:00 - the music that people like based on their profile. Just like how YouTube
01:04 - recommends videos based on the videos you have watched before. I will also show you 
01:08 - python to automate boring repetitive tasks that waste your time. 
01:12 - You will write a Python program that will process thousands of spreadsheets
01:16 - in under a second. I've designed this Python course for anyone who wants to learn
01:20 - Python. If you're a beginner, don't worry, I will hold your hand through this entire course. 
01:24 - You're not too old or too young, and Python is super easy to learn. You can write your first
01:28 - Python program in literally seconds. Plus I'm going to give you plenty
01:32 - of exercises to help you build your confidence writing cool Python programs. 
01:36 - My name is Mosh, I'm a software engineer with two decades of experience 
01:40 - and I've taught over 3 million people how to code. I'm super excited to be teaching you
01:44 - Python in this course. So I hope you stick around and learn this beautiful 
01:48 - powerful programming language. 
01:52 - In this tutorial I'm going to show you how to download 
01:56 - and install Python on your computer. So the first thing I want you to do,
02:00 - is open up your browser and head over to Python
02:04 - .org. On this page click on downloads, 
02:08 - here you can see the latest version of Python currently, at the time of recording this video
02:12 - the latest version is python 3.7.2. 
02:16 - Chances are in the future, when you are watching this tutorial, there is a newer 
02:20 - version of Python available, don't worry, all the materials you're going to learn in this course 
02:24 - will apply to the latest version of Python as well. So let's go ahead
02:28 - and download Python 3, alright now, 
02:32 - look at your downloads folder, here, we should have Python 3 installer
02:36 - simply double click that, if you're on Windows 
02:40 - you're going to see this check box here, add Python to
02:44 - python, this is really important, make sure to tick this box, otherwise you're not going to be able to
02:48 - follow this tutorial. If you're on a Mac, 
02:52 - you're going to see an installer like this, with this setup wizard we're going to install Python 3
02:56 - on our computer. So simply click continue, and again, 
03:00 - and again, and agree with the license agreement, and 
03:04 - install it, this is going to take a few seconds so I'm going
03:08 - to pause the recording. 
03:12 - Alright, we have successfully installed Python 3 on our computer. 
03:16 - Let's close this. Alright, next we need to install
03:20 - a code editor, we se a code editor to write our code, just like
03:24 - how we use Microsoft Word to write documents, we use a code editor to write
03:28 - code. Now there are so many code editors out there, the one that I'm going to show you in this
03:32 - tutorial is PyCharm. That is one of the most popular code editors 
03:36 - for writing Python code. You can get it from jetbrains.com
03:40 - /pycharm. Now more accurately pycharm 
03:44 - is considered an IDE, which is short for integrated development
03:48 - environment. And that's basically a code editor on steroids, 
03:52 - it has some additional features that makes it really easy to write code. So
03:56 - let's go ahead and download PyCharm. Now here on the
04:00 - download page, you can see two versions of PyCharm, one is the professional addition 
04:04 - which has additional features and you have to pay for them. The other is the
04:08 - community edition, that is absolutely free, and that's what we're going to use in this tutorial. 
04:12 - So, go ahead and download this as well.
04:16 - Now, once again look at your downloads folder, once again you should have pycharm 
04:20 - so double click this, now if you're
04:24 - in Windows you're going to see an installation wizard, simply click next, next, next
04:28 - until you install pycharm. If you're on Mac you need to drag and drop this icon 
04:32 - onto the applications folder, so drag and drop, 
04:36 - alright, now let's double click this to run it, 
04:40 - the first time we run pycharm we're going to get this warning, because this is an application
04:44 - that we download from the internet. So let's go ahead and open it, 
04:48 - next you're going to see this dialogue box for importing some settings, leave this to
04:52 - do not import settings, it doesn't really matter. Okay,
04:56 - On this page, select I've never used PyCharm you can see some keyword
05:00 - shortcuts that might be useful in the future, just accept this, and down at the bottom, 
05:04 - click the next button. And then next again,
05:08 - one more time, and then finally start using pycharm. 
05:12 - So here's the main page of PyCharm every time you open
05:16 - it, click on create new project, 
05:20 - this is the location for our project, let's call our project Hello
05:24 - World. Now before click and create, expand 
05:28 - this item here, make sure that base interpreter is set to Python
05:32 - 3. Python interpreter is basically a program 
05:36 - that knows how to execute Python code, it will know how to interpret 
05:40 - or translate Python instructions into instructions a computer can understand. 
05:44 - Now, Mac computers, by default come with an older
05:48 - installation of Python, that's Python 2, it's considered legacy
05:52 - which means it's no longer maintained or supported. So earlier we downloaded 
05:56 - Python 3, make sure that this is set to Python 3, if not
06:00 - from this list, select Python 3.7. 
06:04 - Alright, now let's go ahead and create this project,
06:12 - Now here right click on
06:16 - Hello World folder and go to new 
06:20 - Python file, call this file app.py. 
06:24 - So by convention, all Python files should have this
06:28 - py extension. Alright, let's go ahead,
06:32 - now let's collapse this project panel by clicking here and write our
06:36 - first python program. Simply type print, pr
06:40 - int, all in lowercase, open and close parenthesis, 
06:44 - and inside these parenthesis, add quotations we
06:48 - can either use single quotes or double quotes, now
06:52 - in between the codes write your name. I am Mosh Hamedani, so
06:56 - here, so this is your first Python programming. With these piece of code
07:00 - you can print your name on the screen. Now to run this, go
07:04 - on the top, under the run menu, click run, 
07:08 - also note that there is a shortcut associated with this command, when
07:12 - I program I always use shortcuts because that increases my productivity. 
07:16 - So here on a Mac computer, the shortcut is control, option, and
07:20 - R. On Windows it's different. So let's do that, now
07:24 - it's asking where you want to run this, click on app, 
07:28 - down below, you should see this little terminal window, this
07:32 - is a little window into our program, so here you can see our results for
07:36 - output for our program. In the future as you learn more Python, you'll be
07:40 - able to build applications that have a graphical user interface, or gooey. 
07:44 - That is a little bit complicated, so for now we're going to use this little
07:48 - terminal window to see the results of our program. So as you can see my name is
07:52 - printed here, now as you print code, this window might get in the way so
07:56 - always resize it or minimize itty putting this
08:00 - icon here, so this was our first python program. Now
08:04 - if you didn't see the result I showed you in this video, use the comment box below and
08:08 - tell me what error you encountered, I'll do my best to help you move forward. 
08:16 - In this Python tutorial, we're gong to take this program to the next level and make it more interesting. 
08:20 - So I'm going to show you how to draw a dog hair. Now as part of
08:24 - this tutorial you will learn how Python code gets executed and you will also learn
08:28 - about a few programming terms. So press enter, and 
08:32 - on line 2 write another print statement, so print, open and close
08:36 - parenthesis, add a quotation, now here you want to draw a dog. 
08:40 - So, add an o, that is the head of our dog, followed by
08:44 - 4 hyphens. So this is the body. 
08:48 - alright, now one more time another print statement with
08:52 - quotations, now we need to draw the legs. So add a space. 
08:56 - Follow it by 4 vertical bars. So, like this, 
09:00 - so here's a little imaginary dot. Now let's 
09:04 - run this program and see what we get. So on the top right corner you should see this play button, 
09:08 - click that, there you go, so we have our name and 
09:12 - right below that we have our imaginary dog. Now what you need to understand 
09:16 - here, is that our python code gets executed line by line
09:20 - from the top. So earlier I told you about Python interpreter 
09:24 - that is the program that knows how to translate or interpret 
09:28 - our Python code into instructions that a computer can understand.
09:32 - So when we run this program by clicking this program here, 
09:36 - python interpreter starts executing or running our program 
09:40 - line by line from the top. So first it executes line 1, 
09:44 - then, moves onto line 2, and so on. So this is how python 
09:48 - programs get executed. Now let me show you something cool. Let's add 
09:52 - another print statement, with quotations now
09:56 - in between the quotations, add a star or an asterisk, like
10:00 - this. Now after the quotation and before the parenthesis, 
10:04 - add a space, once again, add an asterisk, 
10:08 - space, 10. What is going on here? Well, 
10:12 - anywhere we have quotations like here or here
10:16 - we're defining a string, a string is a programming term which means 
10:20 - a series of characters so here we have a string, we also have
10:24 - a string on line 3, as well as line 2 and line 1. 
10:28 - Now here, we're multiplying the string by 
10:32 - number 10. So this is the multiplication operator, just like the multiplication 
10:36 - operator we have in math. So with this piece of code we can
10:40 - draw 10 asterisks on the terminal, let me show you. So let's run this
10:44 - program one more time, there you go. So we have 10
10:48 - asterisks. Now what we have here, this piece of code here, 
10:52 - is called an expression. An expression is a piece of 
10:56 - code that produces a value. So when Python interpreter 
11:00 - tries to execute line 4, first it will evaluate 
11:04 - the code that we put in between parenthesis, so we could evaluate our expressions 
11:08 - Our expression will produce 10 asterisks and then
11:12 - those asterisks will be printed on the terminal. Now as an exercise 
11:16 - you can use these print statements to draw another shape, you can draw a heart, a 
11:20 - ball, whatever you like. I will see you in the next tutorial. 
11:24 - One of the questions I get a lot on my channel is
11:28 - how long does it take to learn Python and become job ready? Well there is no single 
11:32 - answer. It really depends on you and how much effort and commitment you want to put 
11:36 - into this. But I would say if you spend 2 hours every day
11:40 - consistently, after about 3 months you should be able to write 
11:44 - basic python programs, but quite honestly, that doesn't get you a job. 
11:48 - In order to get a job, you need to specialize in one area,
11:52 - what do you want to use python for? Do you want to build web applications or
11:56 - desktop applications? Or do you want to use it in machine learning and artificial intelligence?
12:00 - So whatever you want to do you need to take additional courses. 
12:04 - For example if you want to become a web developer in addition to learning
12:08 - Python, you should also learn about html, some css, some
12:12 - JavaScript and Django which is a popular Python framework 
12:16 - for building web applications. Learning all these things would take you another 
12:20 - 6 months, so in total you need 9-12 months to become
12:24 - job ready. At that point you can get a junior developer job with a 
12:28 - salary of about 50-60 thousand dollars a year. Now as you work more
12:32 - as you do more Python projects, your resume starts to build and 
12:36 - you can ask for $100,000 a year, or 120,000 dollars
12:40 - a year, depending on where you are, what company, what geographical area, 
12:44 - it really depends, there is no single answer. So are you excited to
12:48 - learn Python and get started on this career path? If you are, I would encourage you
12:52 - to make a commitment and spend 2 hours every day practicing 
12:56 - python. And use the comment box below and let me know why you are learning 
13:00 - Python, what do you want to do with it? What's your dream job? I would love to hear your story.
13:08 - In this Python tutorial, you're going to learn about variables, which are one of the most fundamental 
13:12 - concepts in programming, they're not specific to Python, they exist 
13:16 - in pretty much every programming language out there. We use variables 
13:20 - to temporarily store data in a computer's memory. Here's an example, 
13:24 - let's type price = 10, when Python
13:28 - interpreter executes this code, it will allocate some memory, then it will store 
13:32 - the number 10 in that memory, and finally it will attach this
13:36 - price label in that memory location. As a metahor
13:40 - imagine we have a box. In that box, we have number 10
13:44 - and price is the label that we put on the box. Now we can use this label 
13:48 - anywhere in our program to access the value that we have in that box. 
13:52 - This is a very simplified explanation. So now, let's 
13:56 - print price on the terminal. Print, now this time we're not going to
14:00 - add quotations, because if we put quotations here, we will see the text 
14:04 - price on the terminal. Now the value of the price variable. 
14:08 - So, put it in quotations, and type price, 
14:12 - now, let's run this program one more time, there you go. So we see 10, 
14:16 - on the terminal. So this is how we define variables, we 
14:20 - start with an identifier which is the name of our variable, then, 
14:24 - an equal sign and finally a value. Now more accurately, when
14:28 - this number 10 is about to be stored in the memory, first it will
14:32 - get converted to this binary for presentation. So this number 10, 
14:36 - is in the decimal system which has all the digits from 0 to 9. 
14:40 - Computers don't understand all these digits, they only understand 
14:44 - 0s and 1s. So when we store the number 10 in the computer's memory
14:48 - first it will get converted to it's binary representation which will be 
14:52 - a bunch of 0's and 1's, like 001, 001, whatever 
14:56 - I don't know. Then it will get stored in the computer's memory. So,
15:00 - let's take this program to the next level. On the second line we can 
15:04 - update the value of this price variable, so we can reset it
15:08 - to a new value like 20, now when we run our program, 
15:12 - we should see 20, because as I told you before Python interpreter executes our
15:16 - code line by line from the top. So first we set 
15:20 - the price to 10, then we reset it to 20, and finally we 
15:24 - print it on the terminal, let's run the terminal, there you go, so, 
15:28 - we see 20 here, okay? Now these
15:32 - numbers that we have here are whole numbers without a decimal point. 
15:36 - In programming, we refer to these numbers as integers. 
15:40 - But integer is a number without a decimal point. We can also use
15:44 - numbers with a decimal point for example on line 2, we can define
15:48 - another variable called rating and set it to number
15:52 - 4.9. Now in programming, we refer to this kind of number as 
15:56 - a floating point number of float for short. So we have integers 
16:00 - and floats. We can also define a variable and set
16:04 - it to a string, for example, name equals 
16:08 - Mosh, we also have another kind of value which is called boolean, 
16:12 - which can be true or false. They are line yes and no in English. 
16:16 - Here is an example, I'm going to define a variable, is underline
16:20 - published so we use an underscore to separate
16:24 - multiple words in our variables name. We set this to
16:28 - true, or false. These are
16:32 - boolean values. now note that Python is a case 
16:36 - sensitive language, which means it's sensitive to lower case and upper case letters. 
16:40 - So when defining variables we should always use 
16:44 - lowercase letters, but here false and true are special keywords in the 
16:48 - language, so if we spell it with a lowercase f, Python doesn't
16:52 - understand it. You can see we have a red underline here, which indicates an error. 
16:56 - Make sure to spell this with a capital F, or if you want to set this to true, 
17:00 - make sure the T is capital, so in this
17:04 - program, you're storing simple values in our computer's memory. Simple
17:08 - values can be numbers, which can be integers or floats
17:12 - or they can be strings or booleans. But in Python 
17:16 - we can also store complex values like lists and values. And that's what I'm going to show you
17:20 - in the future. So before going any further, I want you 
17:24 - to do a little exercise. Imagine we're going to write a program for a hospital. 
17:28 - So we check on a patient named John Smith. He's 
17:32 - 20 years old and is a new patient. I want you to define 3 variables here, 
17:36 - for his name, his age, and another variable 
17:40 - for if this is a new or an existing patient. So pause the video and spend one
17:44 - minute on this exercise. When you're done, come back, continue and see my solution. 
17:48 - Alright, so here we need
17:52 - three variables, the first one is the patient's name, 
17:56 - we set that to John Smith. We can also
18:00 - call this full name, these are both valid names for our variables. 
18:04 - The second variable is for the age of our patient. So age 
18:08 - is 20, and finally we need a variable to tell if this is a new 
18:12 - or existing patient. That's where we can use a boolean value. 
18:16 - So, we define a variable, is new and 
18:20 - we set it to true. 
18:24 - So, you have learned how to print
18:28 - messages on the terminal window. In this tutorial, I'm going to show you how to 
18:32 - receive input from the user. So we're going to write a small program that asks 
18:36 - the user's name and then we'll print a greeting message customized
18:40 - for that user. So instead of print we're going to use
18:44 - input. Now both these input and print 
18:48 - are functions that are built into Python. As a metaphor think 
18:52 - of the remote control of the TV. On this remote control we have a bunch of 
18:56 - buttons, these are the functions built into your tv, you can turn it on,
19:00 - turn it off, change the volume and so on. In Python we also have 
19:04 - functions for common tasks such as printing messages, receiving input, 
19:08 - and so on. So we're going to use the input function, now whenever we
19:12 - have these parenthesis, we're going to say we're calling or executing 
19:16 - that function, it's like pressing a button on a remote control. So we're
19:20 - going to call the input function and in between parenthesis
19:24 - we want to add a string to print something on the terminal, 
19:28 - what is your name? With a question mark followed by
19:32 - a space. You will see why in a second. So this input function
19:36 - will print this message on the terminal, and then it will wait for the user to
19:40 - enter a value. Whatever the user enters this input function will
19:44 - return. So now we can get that value and store it in the memory using a variable. 
19:48 - So we get the result and put it in a variable called 
19:52 - name. Okay? Now on the second line
19:56 - we want to print a message like Hi John or Hi Mosh or whatever, so, 
20:00 - print, quotations Hi with a space,
20:04 - now after the quotation we want to dynamically print
20:08 - what we have in the name variable. So we had
20:12 - a plus sign and then name. So here we have
20:16 - Hi which is a string, we're concatenating or
20:20 - combining the string with another string, that is what we have
20:24 - in the name variable. So here's another example of
20:28 - an expression. Remember what is an expression? It's a piece of code that
20:32 - uses a value. So this expression concatenates or combines 
20:36 - 2 strings. Let's run this program and see what happens. So run
20:40 - okay, here is a question, what is your name? Mosh, 
20:44 - now note that earlier we added a space after the question mark, we
20:48 - did this, so here in the terminal window the cursor is
20:52 - separated from the question mark, otherwise it would be so close. So let's type
20:56 - whatever here, plus enter, now we get this message, Hi, Mosh. 
21:00 - Now here's a little exercise for you. I want you to extend this program
21:04 - and ask two questions. First all the person's name and then
21:08 - their favorite color. And then print a message like Mosh likes
21:12 - blue. So pause the video, do this exercise and then come back and continue watching. 
21:20 - Alright, so here's the first question right after that, 
21:24 - all the input functions one more time, this time we're going to ask a different question. 
21:28 - What is your favorite color? 
21:32 - Now, we get the new value and store it in the variable
21:36 - called color, or you could call it favorite underline. 
21:40 - color. Either works. And finally we're going to change
21:44 - what we pass to the print function, so first we print the name 
21:48 - then we concatenate this with a string, here we're going to
21:52 - type likes, we also put one space before and 
21:56 - after likes, and once again we concatenate this. 
22:00 - With the favorite color. So, favorite color, 
22:04 - now let's run this program, so what is your name
22:08 - Mosh enter, favorite color, blue, enter, 
22:12 - we get this message, Mosh likes blue. 
22:16 - Hey guys Mosh here, I just wanted to let you know that
22:20 - you really don't have to memorize anything in this course because I've put together a cheat sheet
22:24 - with summary notes. So you can quickly review the materials in this course. 
22:28 - The link is below this video. So I have done my best to create
22:32 - the best possible Python course on Youtube. And I really appreciate
22:36 - it if you support my hard work by liking this video and sharing it with
22:40 - others, so they can learn as well. And be sure to subscribe to my channel, for more 
22:44 - tutorials like this. Alright, now, let's move onto the next tutorial. 
22:52 - In this Python tutorial, we're going to write a program that will ask the year that we were born
22:56 - in, and then it will calculate our age and print it on the terminal. 
23:00 - So, let's start with our input function, input 
23:04 - let's print birth here, followed by a colon, 
23:08 - and a space. Now let's get the return value and store it in a variable, 
23:12 - called birth_year. 
23:16 - So as I told you before, we use an underscore to separate multiple words
23:20 - Next, we need to calculate the age, so we define another
23:24 - variable called age, and here we do some basic math, 
23:28 - currently we are in 2019, so let's write an expression
23:32 - like this. 2019 - birth
23:36 - year. Now finally let's print 
23:40 - age on the terminal. Let's run our program and see what happens. 
23:44 - So, my birth year is 1982, enter, 
23:48 - oops, we got an error, what is going on here? So 
23:52 - whenever you see this message, that means there is something wrong with your program. With the information
23:56 - here, we can find exactly where the error occurred. So, 
24:00 - next to the file you can see the file that generated this error, in this case
24:04 - that is app.py. So
24:08 - currently our program only has a single file, but real complex programs often
24:12 - have hundreds or even thousands of files. So in this file, 
24:16 - on line 2, this is where we got this error, and right
24:20 - below that we can see the piece of code that generated this error. 
24:24 - So that is where we're calculating the age, and right below
24:28 - that you can see the type of error. In this case, we have a type error, and here's the
24:32 - message. Unsupported operand types for
24:36 - subtraction. Int and str.
24:40 - So int is short for integer and that represents a whole number 
24:44 - and str is short for string, so here we're subtracting 
24:48 - a string from an integer, and Python doesn't know what to do with it. 
24:52 - Let me explain. So I'm going to close the terminal window. So after
24:56 - the first line we executed we have this birth year variable set 
25:00 - to a string, so whatever we type in the terminal is always
25:04 - treated as a string, even if you type the number, in other words, 
25:08 - when we run this program, this birth year variable will be set
25:12 - to a string, with four characters. 
25:16 - 1982. This string is different from the actual number
25:20 - 1982. One is an integer and the other is a string. 
25:24 - Right? So, back to line 2, where this
25:28 - error occurred. At run time, which means when we run our program
25:32 - this expression on the right side of the assignment operator
25:36 - is going to look like this. 2019 - 
25:40 - string 1982. Python doesn't know how to
25:44 - interpret or how to evaluate this expression. To fix this problem 
25:48 - we need to convert this 1982 into an integer
25:52 - and then we'll be able to subtract it from 2019 and that 
25:56 - is easy. So far you have learned about two built in functions 
26:00 - one is print the other is input. We have a few other functions
26:04 - for converting values into different types. So we have 
26:08 - int for converting a string into an integer, we also have
26:12 - float for converting a string into a float, or a number
26:16 - with a decimal point. And we also have bool for converting a string 
26:20 - into a  boolean value. So to fix this problem, 
26:24 - we need to go back on line 2, 
26:28 - and pass this birth year variable to the int function like this.
26:32 - int parenthesis, like this
26:36 - so we pass this string to the int function, int will convert it into an itneger
26:40 - and then Python interpreter will be able to evaluate this expression. 
26:44 - Now let's run this program one more time, so birth
26:48 - year is 1982 enter so I am
26:52 - 37 years old. In Python we have a useful function
26:56 - for getting the type of variables, for example, let's print the type
27:00 - of birth year, so right after line 1, 
27:04 - let's print, now here we're going to call another built in function, 
27:08 - called type, and now let's pass birth 
27:12 - year, okay, now similarly after line 
27:16 - 3, let's also print the type of age, so
27:20 - print type of age. 
27:24 - Okay? So let's run our program, so birth year one more
27:28 - time, 1982, okay, here's the result
27:32 - so the type of birth year as you can see is a class
27:36 - of str or strings, we look at classes in the future so
27:40 - for now don't worry about them, and also below them you cans ee the type of
27:44 - the age variable is int or integer. So
27:48 - here's what you need to take away. Whenever you use the input function, 
27:52 - you always get a string, so if you're expecting a numerical value
27:56 - you should always convert that string into an integer or
28:00 - a float. So here's a little exercise for you. I want you to write a program 
28:04 - ask the user their weight and then convert it to kilograms and print it
28:08 - on a terminal. So pause the video, do the exercise and when you're ready come back
28:12 - to watch it. 
28:16 - Alright so let's use our input function and ask
28:20 - for the weight in pounds
28:24 - here we get the weight in lbs or pounds
28:28 - now we need to convert this into kilograms, it's very easy so
28:32 - we defined another variable weight_kg 
28:36 - we set this to weight_lbs
28:40 - times 0.45. 
28:44 - And finally let's print weight underline
28:48 - kg. Let's run this Python program and see what happens. So
28:52 - my weight is 160, alright once again we got an error, 
28:56 - can't multiply sequence by non int of type
29:00 - float. So as I told you before, this input function returns
29:04 - a string, so we cannot multiply a string by a float. 
29:08 - Python doesn't know what to do with it. So in this case, we should convert this number
29:12 - by an integer or float and then multiply by 0.45. 
29:16 - So let's call the int function. 
29:20 - And pass weight underline lbs.
29:24 - And run our program one more time, 160
29:28 - okay, so I am 72 kg's. 
29:36 - In this tutorial, you're going to learn more about Python strings. 
29:40 - So I've defined this course variable and set it to Python for beginners
29:44 - now earlier I told you you could use both single and double quotes
29:48 - to define a string, but there are times you have to use a specific form,
29:52 - otherwise you're going to run into issues. Here's an example. Imagine you wanted to
29:56 - change this string into Pythons course for Beginners. 
30:00 - So we want to add an apostrophe, like this, 
30:04 - Course for Beginners. You can immediately say this is going
30:08 - crazy, because our string starts here and then terminates here, 
30:12 - all these characters that we have here after the second apostrophe
30:16 - Python interpreter doesn't know what they are. So to solve this problem
30:20 - we need to use double quotes to define our string so we can have 
30:24 - a single quote in the middle of the string. So let's change this
30:28 - to double quotes, now you can see it adds another double quote to close it, 
30:32 - you have to manually remove this, and also one more time
30:36 - at the beginning of the string, we need to add another double quote. Now
30:40 - you can see error is gone, so if you print course 
30:44 - we see Python course for beginners. 
30:48 - Beautiful. Now let's say we don't want this apostrophe here, so we have
30:52 - Python for Beginners, but we want to put Beginners in
30:56 - double quotes. Once again, if you add a double quote here Python interpreter gets
31:00 - confused because it assumes the second double quote indicates that
31:04 - end of the string, so it doesn't know what these characters are, so to solve this
31:08 - we need to change our double quotes to single quotes 
31:12 - like this. And then we can add double quotes in the middle
31:16 - of the string. Now let's run this program, there you go. 
31:20 - So we get Python for Beginners. So these are the cases
31:24 - for using single or double quotes. Now in all the examples
31:28 - I've shown you so far we only deal with short strings, but what if you wanted to define 
31:32 - a string that is multiple lengths? For example, what if you wanted to define a string 
31:36 - for the message that we send in an email. In that case we need to use 
31:40 - triple quotes. So. We delete this. 
31:44 - Now we add three quotes, so 1, 2, 3, there you go, 
31:48 - So, we have three quotes to start our string and three 
31:52 - to terminate it. Again these quotes can be single or double quotes. 
31:56 - Okay? Now, with this we can define a string that spans 
32:00 - multiple lines. For example, we can say Hi Jon 
32:04 - here is our first email to you. Thank you, 
32:08 - The Support Team. Like that.
32:12 - Now, let's run this program and here's the
32:16 - result. So, we get this beautiful multi line
32:20 - string. Now let's change this back to something simple 
32:24 - so, we can look at other characteristics of strings and Python. 
32:28 - So I'm going to use single quotes and set the course name to Python
32:32 - for Beginners. Now here we're going to use square 
32:36 - brackets to get a character and a given index in this string. 
32:40 - Let me show you. So to get the first character we use square brackets 
32:44 - and type 0. So the index of the first character 
32:48 - in the string is 0. In other words, this is how Python
32:52 - strings are indexed. 0, 1, 2, 3, 4, etc. 
32:56 - So the index of the first character is 0, the second character is
33:00 - 1, and so on. So let me delete this and run this program
33:04 - we get p. We can also use a negative 
33:08 - index here. And this is one of the features that we don't have in other programming languages 
33:12 - as far as I know. So we have negative index we can get the characters
33:16 - started from the end. So if I pass negative 1 here, 
33:20 - Assuming that 0 is the index of the first character 
33:24 - negative 1 is the index of the last character. So when we run 
33:28 - this program we should see s. Let's run it, there you go,
33:32 - we get s, if we pass negative 2, this will return
33:36 - the second character from the end. Let's run it one more time, 
33:40 - now we get R because that is the second character from the end. 
33:44 - Okay? So place close attention to this square brackets syntax 
33:48 - because quite often it's the topic for online Python tests 
33:52 - or university exams, so if you're preparing for a python test, 
33:56 - make sure to watch this tutorial one more time and understand exactly how
34:00 - this square brackets syntax works, we can also use a similar 
34:04 - syntax to extract a few characters instead of 1 character. 
34:08 - For example, if we type 0, 
34:12 - colon 3, Python interpreter will return all the characters
34:16 - starting with this index all the way to this
34:20 - second index, but it does not return the character at this index. 
34:24 - In other words, back to these indexes 
34:28 - so you have 0, 1, 2, 3, and so on. When you run this program. 
34:32 - Python interpreter will return the characters starting from the
34:36 - index 0 all the way to index 3, 
34:40 - but excludes the character and index 3, 
34:44 - so when we run this Python program we're going to see pint (?). Let me show you, so we're going to
34:48 - delete this line, run this program, there you go. 
34:52 - We get pint. Now here we also have default values for
34:56 - the start and end index. So if we don't supply 
35:00 - the end index, Python will return all the characters to the end of the string. 
35:04 - Let's take a look. So run this program, there you go,
35:08 - Python for Beginners. But if you change the start index to 1, 
35:12 - this will exclude the first character so when we
35:16 - run this program, we see ython so p is removed. 
35:20 - Okay? Now similarly we have a default value for the
35:24 - start index, so if we don't supply the start index 
35:28 - but add an end index like 5. Python interpreter will assume 
35:32 - 0 as the start index, so, let's run
35:36 - this program, there you go, we get pytho. 
35:40 - Now what if we leave both the start and end
35:44 - index? Well, I told you? Now in this case 0 will be assumed
35:48 - as the start index, and the length of the string will assume
35:52 - as the end index. So with this syntax, you can basically copy
35:56 - or clone a string. In other words, if I define
36:00 - another variable here, let's call it another and set it to course 
36:04 - square brackets with just a colon, now this expression will
36:08 - return all the characters in the course variable so
36:12 - variable will be copy of our first variable. Let's take a look, so, 
36:16 - let's print another, and load our
36:20 - program there you go, we get Python for beginners. So once again
36:24 - the square bracket syntax is pretty important if you're preparing for online
36:28 - python tests, or college exams, make sure to watch this tutorial again. 
36:32 - Now here's a little exercise for you. I'm going to delete all this code 
36:36 - define a variable, called name, and set it to Jennifer. 
36:40 - Now when we print name 
36:44 - of 1: negative 1
36:48 - what do you think we're going to see on the terminal? I want you to use your knowledge 
36:52 - to tell what we're going to see on the terminal, we're now running this program. So
36:56 - pause the video, think about it for a few seconds, then come back and continue watching. 
37:04 - So this expression will return the characters starting from 
37:08 - index 1 which is the second character
37:12 - all the way to the first character from the end, but excluding
37:16 - the character at this index. In this case, the first character from the
37:20 - in is r, so r will be excluded, in other words we're going to see
37:24 - all the characters starting from e all the way 
37:28 - to the second e. Let's take a look. So I'm going to run this program 
37:32 - there you go. This is what we get, 
37:36 - I hope you guessed it right. 
37:40 - In this tutorial, we're going to look at 
37:44 - formatted strings in Python programming language. Formatted strings are
37:48 - particularly useful in situations where you dynamically generate some
37:52 - text with your variables. Let me show you. Let's say we have two variables 
37:56 - first name and last name. So first we set this to
38:00 - John, and last we set this to Smith. Now it's better
38:04 - to call these variables first name and last name, because they're more
38:08 - descriptive. But here I'm using shorter names because I want you to see the entire code on display 
38:12 - screen. So let's say with these two variables, we want to generate
38:16 - some text like this. Jon, in square brackets 
38:20 - Smith is a coder. Let's say we want to print this on
38:24 - the terminal. How do we do this? Well, we define another variable 
38:28 - like message, now here we add the first name, 
38:32 - now we need to concatenate this, with a string that contains a space 
38:36 - and a square bracket next we need to add a last name, 
38:40 - then we need to add a string that contains
38:44 - the closing square brackets followed by is a coder
38:48 - okay? So, then, 
38:52 - if you print message and run this program 
38:56 - to see John Smith is a coder, right? Now, 
39:00 - while this approach perfectly works, it's not ideal 
39:04 - because as our text gets more complicated it becomes harder to
39:08 - visualize the output. So someone else reading this code, they have to 
39:12 - visualize all the string concatenations in their head. This is where we use
39:16 - formatted strings, they make it easier for us to visualize the output. So, 
39:20 - I'm going to define another variable, let's say
39:24 - msg short for message, and set this to a formatted string. A formatted
39:28 - string is one that is prefixed with an f. So f, 
39:32 - quotes. Now in between the quotes, first we want to add
39:36 - the value of the first name variable, so, 
39:40 - we add curly braces and here we type first.
39:44 - Next we add a space, we add our square brackets, in between the square 
39:48 - brackets, we want to display the last name so once again we add curly
39:52 - braces, and type last, and finally here we type 
39:56 - is a coder. So this is what we call the formatted
40:00 - string. With these curly braces, we're defining place holders
40:04 - or holes in our string, and when we run our program these holes 
40:08 - will be filled with the value of our variables. So here we have two place holders
40:12 - or two holes in our string. One is for the value of our first name 
40:16 - variable and the other is for the value of the last name variable. 
40:20 - But compare this formatted string with string 
40:24 - concatenation. With this formatted string we can easily visualize 
40:28 - what the output looks like, right? Now let's print this other
40:32 - terminal to make sure we get the same exact output. So, let's print message
40:36 - there you go. So Jon
40:40 - Smith is a coder. So to define formatted strings, 
40:44 - prefix your strings with an F and then use curly braces 
40:48 - to dynamically insert values into your strings. 
40:56 - In this Python tutorial, I'm going to show you some really cool things you can do with Python
41:00 - strings. So let's start by defining a variable, 
41:04 - course and we set that to Python for
41:08 - beginners. Now to calculate the number
41:12 - of characters in this string, you can use a built in function called len.
41:16 - So len we give it this course variable, and then, 
41:20 - we can print the result. Let's run this program, 
41:24 - so as you can see we have 20 characters in this string, this is 
41:28 - particularly useful when you receive input from the user. For example you have
41:32 - noticed that when you fill out a form online, each input field 
41:36 - often has a limit. For example, you might have 50 characters for your name, 
41:40 - so using this len function we can enforce a limit on the number of characters 
41:44 - in an input field. If the user types in more characters than we allow, 
41:48 - we can display an error, now, this, 
41:52 - len function is another function built into Python, it's 
41:56 - a general purpose function, so it's not limited to counting the number of characters in a 
42:00 - string, in the future when we look at lists, I want to show you that we can use this
42:04 - function to count the number of items in a list. So it's a general purpose
42:08 - function. Now we also have functions specifically for strings 
42:12 - for example we have functions for converting all these characters to upper case
42:16 - or lower case. To access these functions we use the dot operator. 
42:20 - let me show you. So first we type course, 
42:24 - then dot look these are all the functions 
42:28 - that are specific to strings. Now in more accurate terms, 
42:32 - you refer to these function as methods, this is a term 
42:36 - in object oriented programming that we want to look at in the future, but for now, what I want you to take away,
42:40 - is that when a function belongs to something else, or is specific 
42:44 - to some kind of object, we refer to that function as a method. 
42:48 - For example, here we have this function, upper, for converting the string 
42:52 - into upper case, now more accurately because this function
42:56 - is specific to a string, we refer to this as a method. In contrast
43:00 - len and print are general purpose functions, they don't belong 
43:04 - to strings or numbers or other kinds of objects. 
43:08 - So this is the difference between functions and methods. Now let's take  look at this
43:12 - upper method. So, let's print the results
43:16 - and we run our program, there you go, 
43:20 - you get all these characters displayed in uppercase. Now note this method 
43:24 - does not change or modify our original string, in fact 
43:28 - it creates a new string and returns it. So, 
43:32 - if we print our course variable right after we
43:36 - call the upper method, we can see that our course variable still 
43:40 - has it's original form, so let's run this program one more time, there you 
43:44 - go. Look, here is our original course variable, it's not modified. 
43:48 - Now similar to the upper method we have another method
43:52 - for converting a string into lower case. So let me show you. 
43:56 - Print, course.lower. 
44:00 - Now, let's run the program, so on the second line you can see, 
44:04 - all characters are in lower case. Now there are times
44:08 - that you want to find a character or a sequence of characters in a string. 
44:12 - In those situations you can use the find method. So let me delete
44:16 - these few lines. Call course.
44:20 - find here we pass a character, let's say 
44:24 - p, and this will return the index of the first occurrence 
44:28 - of that character, let me show you. So let's print the result
44:32 - we get 0, because the 
44:36 - index of the first capital p in the string is 0. 
44:40 - As another example, if we pass a lower case o here, 
44:44 - let's see what we get, we get 4 because 
44:48 - the index of this o here is 4. Now note that the
44:52 - find method is case sensitive, so it's sensitive to 
44:56 - lower case and and upper case characters. As an example if you pass an upper case 
45:00 - here and run this program, we get negative 1 because
45:04 - we don't have an upper case o anywhere in this string, okay?
45:08 - We can also pass a sequence of characters, for example, we can pass
45:12 - beginners with a capital B
45:16 - let's run this program, we get 11 because 
45:20 - beginners starts with index 11, now we
45:24 - also have method for replacing a character or a sequence of characters
45:28 - and that is called replace. So let's change find 
45:32 - to replace let's say we want to replace beginners with
45:36 - absolute beginners, so we add a comma to pass a second value
45:40 - to this function, or more accurately this method. We add a string, 
45:44 - here I'm going to pass absolute beginners. 
45:48 - Okay, now let's run this program,
45:52 - so, we get python for absolute beginners. 
45:56 - Again, this method like the find method is case sensitive so 
46:00 - if you pass beginners all in lowercase, this method is
46:04 - not going to find this exact word in our string, so it's not going to
46:08 - place it with absolute beginners. Let's take a look. So I'm going to run the program
46:12 - One more time, look, we still get python for beginners. 
46:16 - We can also replace a single character, for example we can replace
46:20 - capital p with let's say capital 
46:24 - j. Now when we run this program we get
46:28 - jython for beginners. So these are the find and replace methods
46:32 - and one last things I want to show you in this tutorial. There are
46:36 - times that you want to check the existence of a character or sequence of characters in your 
46:40 - string. In those situations you use the in operator, 
46:44 - so let's say you want to know if this string contains the word python. 
46:48 - We can write an expression like this. String
46:52 - python space in space course. 
46:56 - So we're checking to see if python is in
47:00 - course variable. And this is an expression that produces a boolean
47:04 - value, and I get true or false, so we refer to this expression
47:08 - as a boolean expression, now if we print this on the terminal, 
47:12 - we should get true, and by the way 
47:16 - I'm going to delete the second line, we don't need it anymore, so run the program 
47:20 - we get true, but if I change this capitol p to a lower case
47:24 - p and run the program we get false because we don't have
47:28 - is exact sequence of characters in our strings. 
47:32 - Now note that the difference between the in operator and the find method
47:36 - is that our find method returns the index of 
47:40 - character or sequence of characters but the in operator 
47:44 - produces a boolean value. Do we have this or not? 
47:48 - So that's the difference. Now let's recap all the cool things you learned
47:52 - to do with strings in this tutorial. We can use the len function
47:56 - to count the number of characters in a string, this is the general
48:00 - purpose function built into python, we also have specific functions 
48:04 - for strings which we refer to as methods, these include 
48:08 - upper for converting a string into uppercase
48:12 - you also have lower and title methods, 
48:16 - you learn about the find method which returns the index 
48:20 - of a character or sequence of characters, we have 
48:24 - the replace method for replacing characters and words in a string and finally 
48:28 - you learned about the in operator. So some characters 
48:32 - in a string. 
48:40 - So, you have learned that in Python programming language you have 2 
48:44 - types of numbers, integers which are whole numbers like 10, they don't have
48:48 - a decimal point, and floating point numbers or floats.
48:52 - Which are numbers with a decimal point. Now in this tutorial you're going to look
48:56 - at the arithmetic operations supported in python language these are the
49:00 - same arithmetic operations that we have in math, we can add numbers, 
49:04 - multiply them and so on. So let's look at a few examples, 
49:08 - we can print, 10 plus 3, so 
49:12 - this is the addition operator, we also have subtraction, we 
49:16 - have multiplication, we have two kinds of division, 
49:20 - here's one with a forward slash, let's run this program and see what we get.
49:24 - we get a floating point number. But we also have
49:28 - another division operator for getting an integer. So 
49:32 - if we add another slash here and run this program 
49:36 - we get an integer. We have 
49:40 - another operator called modulis (?) which is a percent sign.
49:44 - And this returns the remainder of the division. So when we run this program 
49:48 - we should get 1, there you go. And
49:52 - one last operator we have here is exponent which is the power. 
49:56 - So, that is indicated with 2 asterisks and this will return 
50:00 - 10 to the power of 3. So let's run this program 
50:04 - we get 1000 so these are the arithmetic operators 
50:08 - in python programming language. Now for all these operators that you learned 
50:12 - we have an augmented assignment operator. That is
50:16 - very useful, let me show you. So let's say we have a variable 
50:20 - called x we set it to 10, now we want to increment this by
50:24 - 3, we'll have to write code like this. X we set this to
50:28 - x plus 3. So Python interpreter will add 
50:32 - 10 to 3, the result is 13, and then it gets stored 
50:36 - into x again. So when we print x we should see 
50:40 - 13, there you go. So this is how you can increment 
50:44 - a number, right? Now augmented assignment operator is
50:48 - a way to write the same code but in a shorter form. This
50:52 - is how it works. We type x plus 
50:56 - equals 3. What we have on line 3 is exactly 
51:00 - like what we have on line 2. So this is what we call
51:04 - the augmented assignment operator we have augmented or
51:08 - enhanced the assignment operator. Now in this particular 
51:12 - case we are incremented a number using the augmented assignment operator,
51:16 - but we can also subtract or multiply a number by a given value
51:20 - for example, let's delete what we have on line 2, 
51:24 - we can type subtract equals 3. So here we 
51:28 - subtracted 3 from x. When we run this program we should see 7, 
51:32 - there you go. 
51:40 - Now let me ask you a question, I'm going to clear all this code here to
51:44 - define x and set it to 10 plus 3
51:48 - times 2. What do you think is the result of this expression? 
51:52 - this is a very basic math question that unfortunately a lot of people fail to answer. 
51:56 - The answer is 16. Because in math we have this
52:00 - concept called operator precedence which means the order of
52:04 - operations. So the multiplication operator has 
52:08 - a higher precendence which means it's applied first which means 3 x 
52:12 - 2 is executed first, the result is 6 and then 
52:16 - its added to 10, that's why x showed up as 16 after
52:20 - we run this code, let's verify that. So, print x 
52:24 - run the program, x is 16. So this is what we call
52:28 - operator precedence, it's just a basic math concept. 
52:32 - It's not about python programming language. So all the other programming languages 
52:36 - behave the same way, so here's the order, first we have 
52:40 - the exponentiation which is the power, like 2 to the power of 3, 
52:44 - then we have multiplication or division 
52:48 - and finally we have addition or subtraction.
52:52 - This is the order of operations. Let me show you another example. 
52:56 - Here I'm going to add the exponentiation operator, so, 
53:00 - 2 to the power of 2. Once again, what do you
53:04 - think is the result of this expression? Pause the video and think about it for a few seconds. 
53:08 - The answer is 22. 
53:12 - Because the exponentiation operator takes precedence, so first 
53:16 - 2 to the power of 2 is executed, the result is 4, 
53:20 - then 4 is multiplied by 3, that is 12, 
53:24 - and finally 12 is added to 10. So x should be 22. 
53:28 - So let's run this program and verify this. So I'm going to
53:32 - delete these lines here. Run the program, there you go. X 
53:36 - is 22. Now let me bring back these rules here. 
53:40 - We can also use parenthesis to change the order of operations 
53:44 - so if we have parenthesis we always 
53:48 - takes priority. In this case we can add parenthesis 
53:52 - around 10 + 3, so this piece of 3 will be 
53:56 - executed first, the result is 13, then the exponentiation 
54:00 - operator will be executed, so 2 to the power of 2 is 4, 
54:04 - and finally 4 is multiplied by 13. 
54:08 - Now here is a little exercise for you. I'm going to set x to 
54:12 - parenthesis 2 + 3 x 10 minus
54:16 - 3. What is the result of this? Pause the video and think about it for a few seconds. 
54:24 - So you learned that parenthesis always 
54:28 - overrides the order, so this piece of code is executed first. The result
54:32 - of these 5. Then, between the multiplication and 
54:36 - subtraction, you know that multiplication takes precedence. 
54:40 - So next, 5 will be multiplied by 10, the result is 
54:44 - 50 and finally we have subtraction. So 50 minus 
54:48 - 3 will be 47. Let's verify this, print 
54:52 - x, run the program there you go, I hope you guessed it right. 
54:56 - So this is all bout operator precedence, it's a very important topic 
55:00 - and I see it quite often in Python tests. So if you're preparing for a Python test
55:04 - make sure to watch his tutorial one more time. 
55:12 - In this tutorial, we're going to look at a few useful functions for working with numbers 
55:16 - let's start by defining a variable like x and set it to 2 
55:20 - .9. Now to round this number we can use the built in
55:24 - round function, so we call the round function, give it x, 
55:28 - and then print the result. Let's run this program 
55:32 - so, we get 3, we have another useful built in function called 
55:36 - abs which is short for absolute, and this is the absolute function 
55:40 - we have in math, we give it a value and it always returns 
55:44 - the positive representation of this value, even if the value is negative.
55:48 - Here's an example. Let's call the abs function 
55:52 - and give it negative 2.9 When we run this program 
55:56 - we're gong to see 2.9 on the terminal. So let's go ahead 
56:00 - there you go. So absolute always returns a positive number. 
56:04 - But technically in Python we have a handful of built in functions for performing 
56:08 - mathematical operations, if you want to write a program that involves complex 
56:12 - mathematical calculations, you need to import the math module.
56:16 - A module in Python is a separate file with some reusable 
56:20 - code. We use these modules to organize our code into different 
56:24 - files. As a metaphor think of a super market. When you go to a super market 
56:28 - you see different sections for fruits and vegetables, cleaning products, 
56:32 - junk food and so on. Each section in the super market is like a module 
56:36 - in Python. So in Python we have this math module which contains a bunch
56:40 - of rustable functions for performing mathematical calculations. 
56:44 - So, let me show you how to use this module. On the top 
56:48 - we type import, math, all in  lowercase 
56:52 - with this we can import the math module. now math is
56:56 - an object like a string, so we can access it's functions or more accurately 
57:00 - it's methods using the dot operator. So if you type 
57:04 - math. look these are all the mathematical 
57:08 - functions available in this module. For example you can call the
57:12 - seal method to get the sealing of a number. So if you pass 2.9 here
57:16 - and then print the result we should see 3. 
57:20 - Let me delete all this other code here. Alright, let's run this program 
57:24 - there you go. So we get 3. Another useful method is the
57:28 - floor method, so let's give that a try, floor of 2.
57:32 - 9. What do you think we're going to get? We get 
57:36 - 2. Now there are so many functions built in this module and we don't really have time
57:40 - to go through all of them. But let me show you how we can learn about them on your own. 
57:44 - Open up your browser and search for Python 3
57:48 - math module. Make sure to add the version python 3. 
57:52 - Because the math module in python 2 is slightly different from the math module in 
57:56 - python 3. So python 3 math module, 
58:00 - now here you can see the documentation of this kind of module 
58:04 - let's go let's have a look, if you scroll down, 
58:08 - we can see the list of all the functions and their explanation. 
58:12 - So as an exercise I encourage you to have a quick look at this
58:16 - documentation. See what functions are there for you in case you need them. 
58:24 - In this tutorial, I'm going to talk to you about if statements in Python 
58:28 - if statements are extremely important in programming and they
58:32 - allow us to build programs that can make decisions based on some condition. 
58:36 - So if some conditions are true we're going to do certain things, otherwise we're going to do other
58:40 - things. Here's an example. Over here I've got this text file with
58:44 - a bunch of rules for our program. If it's a hot day, perhaps we want to
58:48 - tell the user it's a hot day, so make sure to drink plenty of water. 
58:52 - Otherwise, if it's cold, so here's another condition
58:56 - if this condition is true we're going to tell the user it's a cold day 
59:00 - so where warm clothes. And otherwise if it's
59:04 - either hot or cold, we want to tell the user it's a lovely day. 
59:08 - So let me show you how to write a program that simulates these rules. So, 
59:12 - back to our program here, we start by defining a boolean variable 
59:16 - is underline hot. We set this to true. 
59:20 - Next, we add an if statement, so if, here
59:24 - we need to add a condition, in this case we're going to use our boolean variable. So, 
59:28 - is underline hot. So if this values to true. 
59:32 - Then we're going to do certain things. In this case, we want to tell the user
59:36 - hey it's a hot day, drink plenty of water. So, back to our program 
59:40 - after our condition we add a colon, now, 
59:44 - note that when I press enter pycharm automatically indents 
59:48 - our cursor. Now any code that we write here will be executed 
59:52 - if this condition is true, otherwise it will be ignored. Here
59:56 - is an example. Let's write a print statement, here I'm going to use
60:00 - double quotes because I want to use an apostrophe in our string. So, 
60:04 - it's a hot day. Now let's press enter
60:08 - you can see the cursor is still indented, that means we can write more code 
60:12 - that we executed if this condition is true, in this case let's say we don't want to
60:16 - write any extra code, so to terminate this block 
60:20 - we need to press shift and tab, now the cursor is at the beginning of the line
60:24 - so lets write a print statement with a message like
60:28 - enjoy your day. Now when we run this program, because
60:32 - this condition is true, you're doing to say this message followed by
60:36 - this second message, take a look, so run, there you go, it's a hot day
60:40 - enjoy your day. But if I go over here and 
60:44 - change this boolean value to false and run the program again, our
60:48 - first message disappears and we only see the second message, enjoy 
60:52 - your day. So this is how if statements work. Now back
60:56 - here we can add another print statement let's say
61:00 - drink plenty of water. 
61:04 - Now because this spirant statement is also indented it will be
61:08 - executed if this condition is true. So I'm going to revert is hot to true 
61:12 - and run the program one more time. There you go, so 
61:16 - it's a hot day, drink plenty of water, and enjoy your
61:20 - day. Alright now let's add a second rule here, if
61:24 - it's hot we're going to execute these two lines, otherwise if it's not hot
61:28 - we want to print a different message. So here 
61:32 - we are moving an indentation and typing els 
61:36 - colon. Now when we press enter once again our cursor 
61:40 - indented so the code that we write here will be executed if this
61:44 - condition is not true. So here we can print 
61:48 - it's a cold day, print, 
61:52 - where warm clothes. 
61:56 - Now let's run our program one more time. So we get the message 
62:00 - about a hot day followed by enjoy your day. You don't see any message
62:04 - about a cold day. Now if we go back here on the top. 
62:08 - And change this boolean value to false and run our program 
62:12 - we see different set of messages. It's a cold day
62:16 - wear warm clothes and enjoy your day. But there's a problem with 
62:20 - our program. If it's not hot it doesn't necessarily mean that it's cold, it means
62:24 - it's a lovely day. So the absence of heat doesn't mean its cold. 
62:28 - Back to our conditions, here on line 4 we have this rule that says 
62:32 - if it's a cold day, then print these messages
62:36 - otherwise if it's neither hot or cold say it's a lovely day. 
62:40 - So, to implement this rule we need to go back and put 
62:44 - py and define another variable. So let' say 
62:48 - is underline cold we set this to
62:52 - true. Now here we need to add a second condition. So after
62:56 - our first if statement, we can use an el if statement 
63:00 - to define a second condition. So here's how it works. So, 
63:04 - el if which is short for els if or
63:08 - otherwise if, now here we add another condition, so, 
63:12 - is cold So if t's cold you want to
63:16 - execute these few lines. So let's cut these
63:20 - from here, and move them under our second condition 
63:24 - and finally if none of these conditions are true, 
63:28 - you want to print a different message. It's a lovely 
63:32 - day. So, right now, 
63:36 - is hot is false, is cold is true, 
63:40 - so when we run this program, python interpreter is going to execute the first 
63:44 - if statement, in this case because our condition is false, these two
63:48 - lines will be ignored, then Python interpreter will look at 
63:52 - line 7, it will evaluate this condition, in this case is
63:56 - cold is true so we're going to see these two messages on the terminal. 
64:00 - Now, in this case, because one of these conditions was true, this els statement
64:04 - will be ignored, so we are not going to see this message, and finally 
64:08 - as before, we are always going too see this message. So let's run our
64:12 - program, there you go. it's a cold day, 
64:16 - where warm clothes and and enjoy your day. Now, 
64:20 - back to the top, if we change is cold 
64:24 - to false it's neither hot nor cold so it's going to be a lovely day.
64:28 - Let's run the program, and here you go, it's a lovely day
64:32 - enjoy your day. So these are the basics of using if 
64:36 - statements. As you can see they are very useful in programming and with these
64:40 - we can build all kinds of rules into our programs. Okay here's an
64:44 - exercise or you. Imagine the price of a house is 1 million dollars. 
64:48 - Now if the buyer has good credit, they will need to put down 10 percent 
64:52 - of the price of this property otherwise they need to put down 20 percent 
64:56 - write a program with these rules an display the down payment 
65:00 - card for a buyer with good credit. You will see my solution 
65:04 - next. 
65:08 - Alright let's define a variable for the price of this house so price 
65:12 - we set this to 1 million so 1 with 6 0s. 
65:16 - Next we need a variable to tell if this buyer has good credit 
65:20 - so has good credit, 
65:24 - and we set this to true, now we need an if statement 
65:28 - so if has good credit has true 
65:32 - colon, here we need to calculate a down payment so
65:36 - the down_payment should be equal to
65:40 - 0.1 x the price. That is 10 percent of the price of this
65:44 - property. Otherwise colon
65:48 - the down payment should be 0.2 
65:52 - times price. Now finally we remove the
65:56 - indentation and print here we can use a form 
66:00 - of valid string, first we add a label, down payment 
66:04 - colon and right after that we add a placeholder 
66:08 - or a hole for our down payment variable. So curly braces 
66:12 - down payment. Let's run this
66:16 - program, so down payment for a buyer with good credit 
66:20 - is 100,000 dollars. Now let's improve this by adding a 
66:24 - dollar sign before this number. So back to our formatted string,
66:28 - just before the curly brace I'm going to add a dollar sign let's
66:32 - run this one more time, that is better. 
66:40 - In this tutorial I'm going to talk to you about the logical operators within Python.
66:44 - We use these operators in situations where we have multiple 
66:48 - conditions. Here is an example. Let' say we're building an application for 
66:52 - processing loans. If an applicant has high income 
66:56 - and good credit, then they're eligible 
67:00 - for a loan. So in this example we have two conditions, one is having 
67:04 - high income and the other is having good credit. So if both
67:08 - these conditions are true, then the applicant is eligible for a loan.
67:12 - So this is where we use the logical and operator. 
67:16 - We use this operator to combine two conditions, and by the way
67:20 - this is not specific to python programming language, pretty much any programming language 
67:24 - that supports if statements also supports the logical operators. 
67:28 - So, back to our program, let's define two variables, 
67:32 - has high income, we set this to true. 
67:36 - And another one has good 
67:40 - credit, we also set this to true, now our if statement 
67:44 - if has high income has true, 
67:48 - and has good credit is also true, 
67:52 - then we're going to print eligible 
67:56 - for null. So this is where 
68:00 - we're using the and operator. So if both these conditions are true 
68:04 - then this message will be printed. If one of them is false, we're not going to see 
68:08 - this message. Let's try this out. So I'm going to run this program 
68:12 - so we see it eligible for loan, but if we change 
68:16 - either of these conditions to false, and run the program again 
68:20 - look, the message disappears. 
68:24 - So this is the logical and operator. We also have the
68:28 - logical or, and we want to use that in situations where we want to do certain things
68:32 - at least one of the conditions is true, for example let's change 
68:36 - the rule for this program, such that if the applicant has high income, 
68:40 - or good credit, then they're eligible for a loan, 
68:44 - so if either or both these conditions are true then the candidate is
68:48 - eligible. Now back to our program we can 
68:52 - implement this rule by using the logical or operator. So we simply replace 
68:56 - and with or, now when we run this program we're going to
69:00 - see this message because at least one of our conditions is true, 
69:04 - let's take a look. So the applicant is eligible for a loan
69:08 - for a loan because they have good credit. If you change this to false 
69:12 - but set the other condition to true, we still
69:16 - see the same result, but if both these conditions are false 
69:20 - then we're not going to see this message anymore. So this is the difference 
69:24 - between these operators. With the logical and operator 
69:28 - both conditions should be true, with the logical 
69:32 - or operator at least one condition should be true
69:36 - we also have another logical operator called not
69:40 - and that basically inverses any boolean value we give it, if we give it, 
69:44 - we give it a true boolean value it converts it to false. For example 
69:48 - let's make up a new room, if applicant 
69:52 - has good credit and doesn't have 
69:56 - a criminal record then
70:00 - they're eligible for a loan. Let me show you how to implement this. So, 
70:04 - we go back to our program, in this example we don't need a 
70:08 - first variable for let's delete that. Let's set this variable to true
70:12 - we also define another variable like has criminal 
70:16 - record. We set this to false. 
70:20 - Now, we want to check to see if this applicant has good credit and not
70:24 - a criminal record. This is where we use the not operator. 
70:28 - So, if they have good credit, 
70:32 - and not criminal 
70:36 - record. So, in this example, has criminal
70:40 - record is set to false, when we use the not operator this
70:44 - basically gets changed to true, so we have two conditions that are true. 
70:48 - Here's ones and here's another one. So our applicant is
70:52 - eligible for a loan. And when we run this program we see
70:56 - this familiar message. However
71:00 - if an applicant has a criminal record, so let's change this to 
71:04 - true, now when we run this program we can see our applicant is
71:08 - not eligible because when we apply then operator on this
71:12 - variable, we'll get false. So true changes to false. 
71:16 - And we'll end up with two conditions, one that's true
71:20 - and the other is false. And that's why this message is
71:24 - not printed. So this is all about the logical operators in
71:28 - python. 
71:32 - In this tutorial I'm going to talk to you guys about
71:36 - comparison operators in Python. We use comparison operators
71:40 - in situations where we want to compare a variable with a value, 
71:44 - for example, if temperature is greater than 30, then
71:48 - we want to print it's a hot day. Otherwise, if it's less
71:52 - then 10, it's a cold day, otherwise it it's neither hot
71:56 - nor cold. And by the way I'm taking about celsius, not farenheit. 
72:00 - So, to build these rules into our program, we need to use comparison
72:04 - operators. Back to app.py, I define this
72:08 - temperature value, let's write an if statement, if temperature
72:12 - now we want to check to see if this is greater than 30, so we use 
72:16 - the greater than operator. If this is greater than 30, 
72:20 - we want to print it's a hot day
72:24 - otherwise, let's just print 
72:28 - it's not a hot day. Now, 
72:32 - when we run this program, we're going to see this second message because 30
72:36 - is not greater than 30. So our first condition a value
72:40 - is to false. let's verify that. So run, 
72:44 - it's not a hot day. Now if you change
72:48 - the temperature to 35 and run this again, 
72:52 - we're going to see a different message, it's a hot day, so this is where we use
72:56 - comparison operators. Now what we have here as you know is an expression
73:00 - because it's a piece of code that produces a value. So more accurately this is
73:04 - a boolean expression. So this is the greater than operator, 
73:08 - we also have greater than or equal to, we have
73:12 - less then, less then or equal to, 
73:16 - here's the equality operator, so if the temperature equals to 30, 
73:20 - then you can say it's a hot day. Note that this is different from the assignment operator 
73:24 - that has only one equals sign. You can see that if we use only one equal sign
73:28 - here we immediately get this red underline because this is simply 
73:32 - an assignment statement. We're changing the value of the temperature. 
73:36 - you are setting the value of
73:40 - something else. So we don't have a boolean expression, you are not producing a 
73:44 - boolean value. Okay? So, our equality operator 
73:48 - has two equal signs and finally we have not
73:52 - equal which is an exclamation followed by an equal sign. 
73:56 - Now here's an exercise for you. You have probably seen that when you fill out a 
74:00 - form online, sometimes the input fields have validation messages, 
74:04 - for example, let's say we have an input field for the user to enter their name. 
74:08 - Now if the name is less then 3 characters wrong we want to display a validation 
74:12 - error, like name must be at least three characters, 
74:16 - otherwise, if the name is more then 50 characters long then we want 
74:20 - to display a different validation error like name can be a maximum
74:24 - of 50 characters. Otherwise if the name is between 3 and 50 characters
74:28 - then we just want to tell the user that name looks good. 
74:32 - So go ahead, and write a plan to implement these rules. 
74:40 - Alright let's define a variable called name and set it to
74:44 - let's say j. So we're assuming this is what the user types into an input field.
74:48 - Now, we want to get the number of characters in this string. 
74:52 - So we use the len function, right? Len of name.
74:56 - When we print this we get 1, right
75:00 - you have seen this before. Now here we want to use an if statement so
75:04 - if len of name is less then 
75:08 - 3, then we want to print 
75:12 - name must be at least 3 characters
75:16 - now here we need a second condition 
75:20 - to check the upper limit. So el if
75:24 - len of name is greater than 50, 
75:28 - then we want to print a different message, name, 
75:32 - must be a maximum 
75:36 - of 50 characters. 
75:40 - Okay? And otherwise if else
75:44 - none of these conditions are true that means the name looks good. So, 
75:48 - print, name looks good. Let's 
75:52 - run our program. So in this case we get this message
75:56 - because our name is too short. Now if you go back here and 
76:00 - type something really really long. And then
76:04 - we run our program we're going to see a different message name must be a 
76:08 - maximum of 50 characters and finally if
76:12 - we type a proper name here like John Smith
76:16 - and run our program we get name 
76:20 - looks good. 
76:24 - Here's another good exercise that combines 
76:28 - many of the materials you have learned so far, so earlier you built a program to 
76:32 - convert someone's weight from pounds to kilograms. Now we want to extend this program 
76:36 - and allow the user to enter their weight in either kilograms or
76:40 - pounds and then we will convert it to the other unit. Here's how our program
76:44 - is going to work. So I enter my weight in pounds so
76:48 - 100 and 60 now it's telling me if it's in pounds or
76:52 - kilograms. So here I'm adding l to lbs or k for kilograms. 
76:56 - And by the way, this program is not case sensitive so
77:00 - when I enter a capital l or lowercase l it takes 
77:04 - it as pounds. Now it tells me ur set it to
77:08 - kilos. Let's run this program one more time, 
77:12 - this time I'm going to enter my weight in kilo's, so send it to
77:16 - is the weight and the unit is kilograms so k, 
77:20 - and it says you are 160 pounds. 
77:24 - So go ahead and spend a few minutes on this exercise, you will see my solution next.
77:32 - Alright first let's ask the user their weight. So we use the input
77:36 - function, weight colon we get the return value
77:40 - and store it in the variable called weight.
77:44 - Now the second question, so one more time we use the input function
77:48 - el for pounds. 
77:52 - Or k for kilograms. So, 
77:56 - let's get that too and store it in a variable called unit 
78:00 - now we need an if statement. So if unit 
78:04 - equals l then we need to convert this weight 
78:08 - into kilograms. However, with this implementation we are only allowing 
78:12 - the user to enter a capitol l, if they enter a lowercase l 
78:16 - this code is not going to work. So this is where we use the upper
78:20 - method of string objects so this unit is a string because as I told you
78:24 - before, the input function always returns a string. 
78:28 - So, we can use the dot operator to access all it's methods or
78:32 - functions, here we call the upper method, this
78:36 - will convert whatever the user enters to upper case and then we'll convert it 
78:40 - to a capital l. Now, if this condition is true, 
78:44 - then we need to get the weight and multiply it by 0, 
78:48 - .45 However, as you know this
78:52 - weight is a string object, and we cannot multiply a string 
78:56 - by a floating point number, we talked about this earlier in this course. 
79:00 - So first we need to convert this weight to a numerical value. So 
79:04 - right here, when we call the input function, we can get the return
79:08 - value and pass it to the int function. So, 
79:12 - we call the int function and give it
79:16 - the return value of the input function. Now, the
79:20 - in function will return an integer so we can store it in this weight 
79:24 - variable. So here's the converted weight, let's store it in
79:28 - a variable called converted, 
79:32 - then we print here we can use a formatted string, so
79:36 - we prefix this string with f ur
79:40 - we add curly braces to dynamically insert the value of
79:44 - converted variable. And finally we add kilo.
79:48 - Otherwise, if the unit is kilograms. 
79:52 - We need to divide the weight by 0.45. q
80:00 - So, weight divided by 0.45 and
80:04 - just to refresh your memory, this division operator returns a floating point number
80:08 - but if we use double slashes we'll get an integer. 
80:12 - In this case, we want to get a floating point number, 
80:16 - finally let's print a formatted string, ur
80:20 -  curly braces, converted 
80:24 - pounds. Okay? Now
80:28 - let's run this program and see what happens. So weight is
80:32 - 160 and lbs in
80:36 - and that equals to 72 kilos, perfect, if we run it one more time, 
80:40 - and enter 72 kilos 
80:44 - we get 160 pounds.
80:52 - In this tutorial I'm going to show you how to use y loops in python. We  
80:56 - use y loops to execute a block of code multiple times and there are often
81:00 - useful in building interactive programs and games. In a future tutorial
81:04 - I'm going to show you how to build a simple game using a y loop.
81:08 - So, let's get started with the basics, we write a y statement 
81:12 - and right after that, we type a condition followed by a colon
81:16 - as long as this condition is true the quote that we write 
81:20 - in this block will be repeatedly executed. Here is an example.
81:24 - We can define a variable like i, as in short for
81:28 - index and set it to 1. Now we set our condition to
81:32 - i less than or equal to 5, so as long as I
81:36 - is less then or equal to 5, we can print i, 
81:40 - on the terminal. And then we need to increment i, 
81:44 - by 1. So we set i to i plus 1. The reason
81:48 - we do this is that if we don't do this I will be 1 forever
81:52 - so we'll end up with an infinite loop. Because this condition will
81:56 - always be true. One is always less then 5, so in every iteration of this
82:00 - loop, we increment i by 1, so at some point, i is gonna be
82:04 - six and then that is when this condition will be false and then
82:08 - we'll jump out of this loop, okay? Now to demonstrate how everything works
82:12 - after this loop I'm going to add a print statement
82:16 - say done. So note that these two lines
82:20 - are indented so they are part of the y block. 
82:24 - Okay, now let's go ahead and run this program and see what happens. So, 
82:28 - take a look, we get the numbers 1-5 followed by
82:32 - done. So heres how this program gets executed
82:36 - first we set i to 1 now python interpreter executes line
82:40 - 2, this condition is true because i is less then 5, 
82:44 - so i is printed on the terminal and then incremented by
82:48 - 1. Then the control moves back to the beginning of the y loop.
82:52 - So it doesn't go to the next statement. So, 
82:56 - we come back here and now we are in the second iteration. In the second iteration
83:00 - i is 2, and because 2 is less then 5, our condition is still
83:04 - true, so i will be printed on the terminal, and once again it will be
83:08 - incremented by 1, so at some point i is going to be 6, 
83:12 - and that's when this condition will be false so our look will
83:16 - be terminated and this done message will be printed on the terminal.
83:20 - So this is the basics of y loops. Now let's make this program a little
83:24 - bit more interesting. Here we can write an expression like this. We
83:28 - add a string, and in this string we add an asterisk
83:32 - and then we multiply this string by i. So
83:36 - with this expression, we can repeat a string, when we multiply a string
83:40 - by a number, that string will be repeated. For example, if
83:44 - i is two, this expression will produce a 
83:48 - string with two asterisks. Now let's run the program
83:52 - and see what we get. So we see this little triangle 
83:56 - shape here. Because in the first iteration i is 1, so, 
84:00 - 1 times an asterisk produces 1 asterisk. 
84:04 - In the second iteration i is 2, so when we multiply 2
84:08 - by 1 asterisks, we'll get 2 asterisks. 
84:16 - In this tutorial I'm going to show you how to use a y loop to build 
84:20 - a guessing game like this. So we have this secret number which is currently set to
84:24 - 9. Now the computer is asking me to make a guess. So, 
84:28 - let's say 1 is not right because the secret number is 9, okay, 
84:32 - try again, 2, no it's not right, let's try again, so I
84:36 - only have three chances to make a guess. If I can't guess the number the program 
84:40 - tells me that  I failed. let's run the program one more time, this time
84:44 - I'm going to guess the number, it's 9, there you go, it says you in.
84:48 - So let's go ahead and build this program using a y loop.
84:52 - Alright, let's start by defining a variable to store our secret number
84:56 - so, we call the secret underline number and set it to 9.
85:00 - Now we need a while loop to repeatedly ask a user to
85:04 - make a guess. So while condition colon
85:08 - What is our condition here? Well we want to give our user a
85:12 - maximum of three guesses. So similar to the last tutorial, we can define
85:16 - a variable like I, set it to 0, and assume this represents
85:20 - the number of guesses the user has made. And then we write our condition 
85:24 - as i less then 3. Note that here I'm not
85:28 - using less then or equal to operator, because with this condition
85:32 - our loop will be executed 4 times, while i is 0,
85:36 - one, two, and three, so here we should use 
85:40 - the less then operator. Now if we give this code to someone else it's unclear
85:44 - what does i represent here, it's only in our head that
85:48 - i represents the number of guesses the user has made. So as
85:52 - a best practice, always use meaningful and descriptive names for your variables. 
85:56 - So it's better to rename this variable to guess, count.
86:00 - Let me show you how to rename. So right click on i variable, 
86:04 - and then go to refactor and 
86:08 - rename it. Look at the shortcut. On a Mac computer it's shift and
86:12 - f 6. Now in this dialogue box we can easily
86:16 - rename your variable and pycharm will update all the references to that
86:20 - variable so we don't have to manually update each instance, okay? Let's
86:24 - change this to guess_count
86:28 - enter, there you go, now that is better, 
86:32 - also it's better to store 3 in a separate variable to make our code
86:36 - more readable, because it's not quite clear what does 3 represent here. 
86:40 - So, let's define a variable called guess limit
86:44 - say to 3, and then we can change 3 to guess
86:48 - underline limit, now our code is more readable
86:52 - while guess count is less then guess limit, see it reads like a story
86:56 - this is how you should write code. Okay, so
87:00 - while this condition is true, we want toast the user to make a guess. So here 
87:04 - we use our input function, guess
87:08 - Now whatever the user enters comes out as a string so we need to convert it to an integer.
87:12 - So right here, we pass the result to the end function
87:16 - and then get it and store it in a separate variable called guess.
87:20 - So at this point the user made a guess, now we need to
87:24 - increment guess count so guess count
87:28 - we set it to plus equal 1 or 
87:32 - okay, now we need to check to see if the user will make the right guess.
87:36 - So here we need an if statement. If what the user guessed
87:40 - equals our secret number, 
87:44 - again see our code is so readable. It's like a story you can read it like plain
87:48 - English. So if this condition is true we want to 
87:52 - tell the user they won. So print you won
87:56 - now lets go ahead and run our program up to this point.
88:00 - So okay it's asking me to make a guess, I'm going to make 
88:04 - the wrong guess so one it asked me again, 2 one more time, 
88:08 - 3, okay, what is missing in this implementation is the
88:12 - message that tells me that I failed. We're going to take care of it momentarily, but
88:16 - let's run the program one more time and make the right guess. So, 9
88:20 - okay it says you won, but it's still asking me to make
88:24 - a guess, because our while loop is going to get executed 3 times. Look
88:28 - 1 and 2. So we need to change our program
88:32 - such that if the user makes the right guess, we need to terminate our
88:36 - while loop, we need to jump out of it. How do we do that?
88:40 - So, over here if the user makes the right guess, after
88:44 - we print this message we can use the brick statement to terminate
88:48 - terminate a loop, when python interpreter sees this, it's going to
88:52 - immediately terminate our loop, it's not going to evaluate this condition again. 
88:56 - Now let's run our program and see what happens. So, I'm going to
89:00 - guess the right number, you won and look, you are
89:04 - now asked to make two more guesses, beautiful. Now the last thing we need
89:08 - to add here is the message that tells the user that they failed if they could not guess
89:12 - the right number. How do we do that? Well in Python
89:16 - our while loops can optionally have an else part. 
89:20 - similar to the if statements. So earlier you learned that our if statements 
89:24 - can optionally happen else part. Here, so
89:28 - if this condition is true, do this,
89:32 - otherwise do something else. In this case our if statement doesn't have
89:36 - an else part. Now, similar to the if statements
89:40 - Our while loops, our while statements can also have an else part. 
89:44 - So, right at this level we can add
89:48 - an else block, so else colon. 
89:52 - And the code that we write here will get executed if this while loop
89:56 - completes successfully without an immediate 
90:00 - break. In other words. If the user guesses the
90:04 - right number, you break this loop, you jump out of it so the code that
90:08 - we write in the else block will not get executed. 
90:12 - But if the user cannot guess this number, you're never going to break out of
90:16 - this loop, so this loop will be executed to completion untill
90:20 - this condition become false. In that case, the code that we write
90:24 - in the else block will get executed, and this is the perfect opportunity for us
90:28 - to tell the user hey, you made three guesses but none of them were right.
90:32 - So, print, sorry you
90:36 - failed. Now, let's test the program one more time.
90:40 - So, guess 1, 2, 3, 
90:44 - sorry you failed, let's run it one more time. This time I'm going to make
90:48 - a wrong guess, and then the right guess, 
90:52 - we won and our loop terminated immediately. 
91:00 - Alright, now it's time for you to practice what you have learned so far. 
91:04 - So once again we're going to build a game this game is a simulation 
91:08 - card game. Now our game doesn't have a graphical user interface or gooey 
91:12 - and it doesn't really matter for now, our focus is entirely on building the
91:16 - engine for this game. So let's see how this works. 
91:20 - When we run this, we get this little symbol here, and our program
91:24 - is waiting for us to enter a command. If you type help
91:28 - either a lower case or upper case we get the list of commands
91:32 - that our program or our game currently supports. So we can type the
91:36 - start command to start our car, we can type
91:40 - stop command to stop our car, and quit to terminate the game.
91:44 - Any other commands that we type our program is going to tell us hey I don't understand that.
91:48 - For example, if I type asd here, it's going to say I don't understand 
91:52 - that.If you type start, we get this message, 
91:56 - car started, ready to go, if you type stop it 
92:00 - says car stopped, and finally if we hit quit
92:04 - our program terminates, this is a fantastic exercise for you to practice
92:08 - wha you have learned, so pause the video and spend 5-10 minutes
92:12 - to build this program. 
92:16 - Alright, we're going to start with a while loop with a condition 
92:20 - What is our condition here? We want to run this loop 
92:24 - until the user types quit. So we can define a variable
92:28 - or a story to command what the user enters, and then we can run this
92:32 - loop as long as the command does not equal to quit. So right before
92:36 - the loop, we define a variable, command, and initially we set it
92:40 - to an empty string. An empty string is a string that has no characters
92:44 - in it. We only have the quotes. So then
92:48 - we type out our condition as while command 
92:52 - does not equal to quit then do something. 
92:56 - Now immediately we have a problem here because we're assuming that the user 
93:00 - types the command in lower case, so if they type this in upper case they
93:04 - our program is not going to behave properly, so to fix this problem, you need to
93:08 - call the lower method of the string object and then compare the results.
93:12 - With this quit. You could also call this upper
93:16 - and then type quit in upper case. It's about our personal preference 
93:20 - in this demo I'm going to use lower case characters. 
93:24 - So, okay, now in this loop we need to ask the user to enter
93:28 - a command. So once again we're going to use our input function, we're going to add
93:32 - a greater then symbol followed by a space,
93:36 - whatever the user enters, we get it and store it in our
93:40 - command variable. Now apart from
93:44 - quit command, there are three other commands that we need to support. Start, 
93:48 - stop, and help. So here we need an if statement to compare
93:52 - what the user enters with one of the supported commands. 
93:56 - So, if command.lower
94:00 - equals start then you want to print the message 
94:04 - like the car started. So print the car started. 
94:08 - Ready to go, it doesn't matter, 
94:12 - now the second condition. What if its not start, maybe it's stop? So, 
94:16 - el if command.lower
94:20 - equals stop, there you go, then we print a 
94:24 - different message car stopped. Now look at our code.
94:28 - We have repeated this lower lower lower multiple times. 
94:32 - This is bad, in programming we have a term called dry, which is short for 
94:36 - don't repeat yourself. So whenever you have duplicate
94:40 - your code that means you're doing something wrong. So how can we solve this problem. 
94:44 - Well, instead of calling the lower method in each condition, 
94:48 - we can call it right here when we get the input from the user, so
94:52 - this input function as you know returns a string, we can
94:56 - immediately call the lower method on this string, and with this command 
95:00 - will always be in lowercase, so we don't need to
95:04 - call this method in every condition. Look, 
95:08 - we remove the duplication and also our conditions 
95:12 - are shorter and easier to read. There is also one more place 
95:16 - we need to modify so, it's right here. That is better. 
95:20 - Now, the third command. We need one more el if.
95:24 - If the command equals help, then, 
95:28 - we want to show the commands that we support. So, 
95:32 - here we're going to print a multi line string. So we
95:36 - use triple quotes like this, and 
95:40 - give the user a guideline like this. So start
95:44 - to start the car stop 
95:48 - to stop the car, and 
95:52 - quit to quit. Now finally we need 
95:56 - an else part, so if what the user enters is none of these commands, 
96:00 - we're going to tell them, hey we don't understand these, 
96:04 - else, colon print 
96:08 - sorry I don't understand that. 
96:12 - And by the way note that here becomes I'm using double
96:16 - quotes, I can easily use a single quote as an apostrophe, okay?
96:20 - So let's run our program up to this point and see what happens.
96:24 - Alright, let's type start car is 
96:28 - started, beautiful, stop, car is stopped, help, 
96:32 - we get this guideline, but there's so much indentation
96:36 - before our commands, we'll fix that in a second. And finally 
96:40 - let's test the quit command, oops, our program 
96:44 - didn't work properly. Here is the reason. With these if statements, 
96:48 - we're comparing the command with start stop, and 
96:52 - help. Anything else will end up here, so that's why our
96:56 - program says it doesn't understand that. So that's why our program 
97:00 - says it doesn't understand that command. However, after this el statement 
97:04 - the control will be moved to the beginning of the loop.
97:08 - At this point our command is quit, so our loop will complete and the
97:12 - program terminates. In other words when we run this program
97:16 - and type quit, our program actually quits but 
97:20 - we still see this message which shouldn't appear here. How can we solve this problem?
97:24 - Well, we can come back here and just before 
97:28 - the else block, add another el if, something like
97:32 - this. el if command equals 
97:36 - quit then you can immediately break. 
97:40 - This will solve our problem, but note that we have kind of repeated
97:44 - this expression in two places. The reality is that
97:48 - we don't really need this condition on the top, because with these if statements 
97:52 - well more accurately with this el if we can jump out of this loop and terminate 
97:56 - our program. So, we can simplify our condition
98:00 - to something like this. True. So while true means 
98:04 - this block of code is going to get executed repeatedly, 
98:08 - until we explicitly break out of it,
98:12 - okay? Now let's test our program one more time. So, 
98:16 - quit now our program terminates and we don't see that message 
98:20 - beautiful. So let's fix the last problem. You saw that when we 
98:24 - typed help, these guidelines appeared with so much in
98:28 - indentation, and here's the reason, look, right here in our code, 
98:32 - they are already indented. So when we use triple quotes, what we type here
98:36 - will be printed exactly as is. So, because we 
98:40 - have an indentation here, this indentation will also be printed on the terminal. 
98:44 - So, let's delete these
98:48 - okay, run the program one more time, type help, 
98:52 - the indentation is gone. Beautiful. Now here's a challenge for you. I want you to
98:56 - take this program to the next level. So right now if we type
99:00 - start we get this message car started. And if we type start again 
99:04 - we get the same message. It would be better if
99:08 - we got a message like car is already started so it doesn't make sense to
99:12 - start a car twice. Similarly, if we type stop
99:16 - it says car stopped, if we type it again we get the exact same
99:20 - message, it doesn't make sense to stop the car twice. So here's what I need you to do
99:24 - if the car is stopped and the user tries to stop it again, 
99:28 - the program should say hey, the car is already stopped, what are you doing? And similarly 
99:32 - if the car is already started and the user tries to start it again, 
99:36 - the program should yell at the user. So go ahead and make the necessary changes to
99:40 - implement this scenario. 
99:44 - Alright to add this to our program, we need 
99:48 - to know if the car is started or not. So there is one more piece of information
99:52 - we need to store in the memory. What is the kind of data we need to store here? 
99:56 - A boolean. Is the car started or not, it's a matter of yes 
100:00 - or no. True or false. So on the top, here
100:04 - we can define another variable like started and initially we set it
100:08 - to false. So the car is not started, right? Now
100:12 - when the user types the start command, here we need to check
100:16 - to see if the car is already started. If not the we'll start it 
100:20 - or otherwise we'll yell at the user. So in this block we'll write
100:24 - another if statement, if it's already started
100:28 - and we print car is already 
100:32 - started. Otherwise, so if you add an 
100:36 - el statement here. And at this point, 
100:40 - you set started to true. So we start 
100:44 - the car and we print this message, okay? Now we need to make a similar 
100:48 - change for the stop command. So if the car is
100:52 - already stopped we need to print a different message. If
100:56 - not started, so here we're using the not operator to see
101:00 - if the car is stopped. So if it's not started that means
101:04 - it's stopped, okay? So if it stopped we print
101:08 - car is already stopped with
101:12 - double p's, otherwise so else 
101:16 - we need to stop the car, how do we do that? We 
101:20 - set started to false. And then we'll print this message. 
101:24 - As easy as that. Let's go ahead and run our program. 
101:28 - So, initially our car is stopped. So I'm going to type 
101:32 - stop, it says the car is already stopped, so lets 
101:36 - start it, okay, now our car is started, let's
101:40 - start it one more time. The program is yelling at us. So we can
101:44 - not start the car twice. Beautiful. Now let's stop it
101:48 - it says the car is stopped, let's stop it one more time, we get this message 
101:52 - again. 
101:56 - In this tutorial, I'm going to talk to you guys about 
102:00 - for loops in python. In the last tutorial, you learned about while loops 
102:04 - you learned that we use while loops to execute a block of code multiple times. 
102:08 - In python we have another kind of loop, that is a for loop, and we use that
102:12 - and we use that to iterate over items of a collection, such as a string. 
102:16 - Because a string is a sequence of characters, so it looks like a collection 
102:20 - so we can use a for loop to iterate over each character in a 
102:24 - string and then do something with it. Here's an example. We type out
102:28 - for then we define a variable, this is what we call a loop
102:32 - variable. In each iteration, this variable will hold
102:36 - one item. So, let's call it item, in 
102:40 - here we type out a string like Python, and then 
102:44 - colon. So with this for loop we can iterate over a string and in each
102:48 - iteration this item variable will hold one character at a time
102:52 - in the first iteration it will be set to p then 
102:56 - in the second iteration it will be set to y, and in the third iteration it will be set to
103:00 - t and so on. So here we are inside our for block,
103:04 - because of the indentation here, so whatever we type here will be executed in
103:08 - each iteration, for now we can simply print this item 
103:12 - now let's run this program and see what happens.
103:16 - So you can see each character in this string is printed on 
103:20 - a new line. Let's look at another example. In Python we can
103:24 - define lists using square brackets, so let me remove this string from
103:28 - here, and define a list using square brackets, 
103:32 - a list is simply a list of items, a list of numbers, a list of 
103:36 - customers, a list of emails, products, blog posts, whatever. 
103:40 - So here we can define a list of names like Mosh, 
103:44 - Jon, Sarah, and then go ahead 
103:48 - and run our program so we can see in each iteration we get one name 
103:52 - and print it on a new line. We can also
103:56 - loop over a list of numbers, for example, 
104:00 - 1, 2, 3, 4, let's run it, again
104:04 - we see each number on a new line, but what if we want
104:08 - a list of numbers? We don't to explicitly type out a list
104:12 - with let's say 100 or 1000 numbers, we don't want to type, 5, 6
104:16 - 7 all the way to 100. That is when we use the range function. 
104:20 - So, let me delete this, 
104:24 - In Python we have a built in function called range, for creating
104:28 - range of numbers. So, we give it a number, let's say 10, 
104:32 - let's run this program, now we can see
104:36 - here on the terminal we have 0 all the way
104:40 - to 9. So 10 is not included. 
104:44 - So basically when we call the range function, this range creates
104:48 - an object, it's not a list, it's a special kind of object we can 
104:52 - iterate over, in each iteration this object will spit out a new number.
104:56 - We can also work with a  range of numbers here, let's say you want to start 
105:00 - from 5, and go all the way to 10. 
105:04 - So, let's run our program, now we have the numbers 
105:08 - 5, 6, 7, and 9. Also, this range
105:12 - function can optionally take a step, so we can pass
105:16 - two asa step to this function, 
105:20 - and when we run our program, we can see our first number
105:24 - is 5, now we go two steps forward to get 7, 
105:28 - once again we go to two steps forward we get 9 and that is
105:32 - the end of our range. So this is the basics of using for loops in python. 
105:36 - Now here's an exercise for you. I want you to write a program 
105:40 - to calculate the total cost of all the items in a shopping cart. 
105:44 - So let's say we have a list of prices like 10, 
105:48 - 20, and 30, I want you to use a for loop, 
105:52 - to calculate the total cost of all the items in our imaginary shopping cart, 
105:56 - so calculate that, and then print it on the terminal. That's pretty
106:00 - easy. And you should do it in a couple minutes. 
106:04 - So as you learned we use for 
106:08 - loops to iterate over all the items in a  collection, 
106:12 - a collection can be a string, it can be a list, it can be a range object that is
106:16 - returned from the range function. Anything, any kind of object that has multiple
106:20 - items. So in this example we're going to use a for loop to iterate over
106:24 - the list of prices. So for item in 
106:28 - prices, colon, and by the way this loop variable
106:32 - we don't have to call this item, can call this anything. For example, in this case
106:36 - we can rename it to price. So for price, 
106:40 - in prices. Now in each iteration this
106:44 - price will hold one value. In the first iteration it's going to hold 10, then it's
106:48 - gooing to be 20, and then it's going to be 30. So we need to define 
106:52 - another variable to calculate the total so
106:56 - we define that outside of our for loop, let's call it total
107:00 - and initially we set it to 0. Now in each
107:04 - iteration we get the current price and add it to the total so
107:08 - we write total equals total plus price 
107:12 - or as you learned earlier we can use the augmented 
107:16 - assignment operator to simplify this code. 
107:20 - So, after our for loop. This total variable has 
107:24 - a total of all the prices we can simply print it here, 
107:28 - or we can use a formatted string, so a string 
107:32 - prefix with f, the other label, like total, 
107:36 - curly braces to dynamically include some value in our string, 
107:40 - in this case our total variable. So let's go ahead 
107:44 - and run this program, there you go, so the total cost of
107:48 - all the items in our imaginary shopping cart is 60. 
107:56 - In this tutorial I'm going to talk to you guys about nested loops
108:00 - in python. Using a nested loop basically means adding one loop
108:04 - inside of another loop, and with this technique we can do some amazing things
108:08 - for example we can easily generate a list of coordinates. So, a
108:12 - acquired (?) as you know is a combination of x and y 
108:16 - value. Let's say 0 and 0. Now let's say you wan to generate
108:20 - a list of coordinates like this. So we have 0 and 0, 
108:24 - then we'll have 0 and 1, then 0 and 2, next
108:28 - we're going to change x, so we're going to use 1 for x, 
108:32 - and once again we're going to use these 3 values for the y coordinates
108:36 - so 1 and 0 then 1 and 1 
108:40 - and 1 and 2, you got the point. We can
108:44 - easily generate these coordinates using nested loops. Let me show you. 
108:48 - So, we start with one loop, let's say for x in
108:52 - range 4. With this loop, we can generate value 
108:56 - for the x coordinate. Let's print this on the terminal,
109:00 - Okay, so, we get the values, 0 
109:04 - to 3. Now for each x, like 0, we 
109:08 - should generate a few y values. So that is where we use
109:12 - a nested loop. So inside of this loop we're going to add
109:16 - another loop, so instead of just printing x first we want to add 
109:20 - another loop, for y in range 
109:24 - let's say 3, now we can print x and y together 
109:28 - so, print, here, we use a formatted string. 
109:32 - to display coordinates like this. So we add parenthesis 
109:36 - inside of this parenthesis first we need to add x so curly braces
109:40 - x then a comma followed by 
109:44 - another set of curly braces, and y, 
109:48 - let's run this program and see what we get. 
109:52 - There you go. So, we have these coordinates 
109:56 - 0 and 0, 0 and 1, 0 and 2, then you have
110:00 - 1 and 0 1 and 1 1 and 2 and so on. So let me explain exactly 
110:04 - how this program gets executed. So in the first iteration, 
110:08 - of our outer loop, x is 0. Now we are
110:12 - on line 2, here we have a new loop which we call an
110:16 - inner loop. In this inner loop, in the first iteration y 
110:20 - is going to be 0, so we print 0 and 0 on the
110:24 - terminal. Now the control goes back to line 2 or our
110:28 - inner loop. In this second iteration y will be set to 1, but
110:32 - we are still in the first iteration of our outer loop. So 
110:36 - x is still 0, but now y is incremented to 1. 
110:40 - So that is why we see 0 and 1 on the terminal. 
110:44 - Once again, the control goes back to line 2, we are in the third 
110:48 - iteration of our inner loop, so this will continue until our inner loop
110:52 - completes. That is when y reaches 2 because 
110:56 - this range function generates number 0 to 3 but not including 
111:00 - 3. So we'll have 0 1 and 2. After this inner loop completes, 
111:04 - then the control goes back to line 1, and at this point we're going to
111:08 - be in the second iteration of our outer loop. So x will be 
111:12 - 1, then the control will be moved to line 2, or our inner 
111:16 - loop, at this point, this range function is going to generate the numbers 0
111:20 - to 3 one more time. So this inner loop will be executed 3 times.
111:24 - And then we'll go back to our outer loop. So this is how
111:28 - nested loops get executed. 
111:32 - Okay, here's an exercise for you, but this one is a little bit 
111:36 - more challenging then the exercises you have done so far. So I really don't 
111:40 - expect you to do it, but if you do it, wow, I will be so proud of you, 
111:44 - so see what I've done here? Using nested loops, 
111:48 - I've written some code to draw this f shape, can you see that? So I
111:52 - let me give you a hint, first of all we have this
111:56 - list, called numbers, in this list we have these values, 
112:00 - 5, 2, 5, 2, 5, 2. These values determine
112:04 - the number of x's we have in each line. So, 
112:08 - for example, the first item in this list, this tells us that we should have 
112:12 - 5 x's on the first line. There you go, so 1, 2, 3, 
112:16 - 4, 5, on the second line we're going to have 2 x's, 
112:20 - on the third line we're going to have 5 x's like this. 
112:24 - So I've written code to convert a simple list of numbers
112:28 - into a shape like this. Now here's a tip for you. 
112:32 - Using your for loop you need to iterate over this list. In
112:36 - each iteration you get one number, this determines the number of x's
112:40 - to be displayed on that particular line. So if you want to cheat, 
112:44 - you can get this number and multiply by a string that contains x, 
112:48 - so if you multiply x by 5, we'll get 5 x's, that's not what 
112:52 - I want you to do. I want you to use an inner loop here to 
112:56 - generate a string that contains 5 x's. So imagine 
113:00 - in Python we cannot multiply a string by a number
113:04 - so to solve this problem we need a nested loop. So go ahead and spend 
113:08 - five minutes on this exercise. And by the way, do your best to solve this. It is
113:12 - a little bit challenging, but it's not extremely difficult. It just requires
113:16 - a little bit of focus. You'll see my solution next. 
113:20 - Alright so first we need to iterate over
113:24 - all the items in this list. So for item 
113:28 - in numbers, or, you could rename this variable 
113:32 - to x_count. That is the number of x's
113:36 - on each line. Okay? Now I told you that if you want to cheat you can write code 
113:40 - like this. Print x times 
113:44 - x underline count. If you run this program we get the same 
113:48 - output. So this is the beauty of Python, with Python
113:52 - we can write expressions like this, we can multiply a string by a number to
113:56 - repeat it. A lot of other programming languages don't support this feature. But
114:00 - for this exercise, I wanted you to imagine that we don't have this feature in Python 
114:04 - so you will have to use an inner loop to solve this problem. Here's how
114:08 - it works. In the first iteration, x count is going to be 5.
114:12 - So we need to generate 5 x's. How can we do that?
114:16 - Well, let's say we define a variable called output and initially set it to
114:20 - an empty string. Now we need to add 5 x's to this string. So, 
114:24 - we can use another loop for count in range, 
114:28 - of x underline count. So we're using the range function
114:32 - to generate a sequence of numbers from 0 up to
114:36 - x count. So in our first iteration x count is going to be 5, so
114:40 - range of 5 would generate the numbers 1, 2, 3, 4. 
114:44 - So this inner loop will be executed 5 times. 
114:48 - That is exactly what this count represents. 
114:52 - So now in each iteration we simply need to
114:56 - append an x to our output variable. So we set
115:00 - output, plus, equals x, 
115:04 - and then after this inner loop we simply print 
115:08 - the output. With his we'll print 5 x's on 
115:12 - the first row. Then we go to the second iteration of our outer loop. 
115:16 - At this point x count is going to be 2, now
115:20 - on line 3, we're going to reset our output variable to an
115:24 - empty string. So we start over. Then we go to our inner loop, 
115:28 - this loop will be executed 2 times, so we'll append to x's 
115:32 - to the output variable and then print it, as simple as that. 
115:36 - So see, it wasn't really that difficult, but it was slightly more difficult then the
115:40 - previous exercises. So let's run this program, there you go. 
115:44 - Now if you're adventurous, I want you to modify the values that we have
115:48 - in our numbers list,
115:52 - to print and l here. 
116:00 - Now in this tutorial we're going to take a closer look at lists. 
116:04 - So, I'm going to define a list of names, let's send them
116:08 - to John Bob Mosh 
116:12 - Sarah and Mary. So, 
116:16 - if you print this list here, what we see on
116:20 - the terminal look exactly like how we define our lists we have
116:24 - square brackets, and in between these square brackets we have our item
116:28 - our items, so we have 5 strings in this list. 
116:32 - So we can also access an individual element using an index just like
116:36 - how we can access an individual character in a string using an index. 
116:40 - So, here we type out square brackets, 
116:44 - and specify an index. The index of the first item in this list 
116:48 - is 0. So, let's run this program, there you go, 
116:52 - we get Jon now if you want to print out the third element in this list
116:56 - it's index is 2, so names of 2, 
117:00 - returns Mosh, now we can also pass
117:04 - a negative index here, so negative 1, refers to the last item 
117:08 - in this list, that is Mary, let's run the program, 
117:12 - there you go, we see Mary, if you pass negative 2, this
117:16 - returns the second item from the end of the list. So let's run the program,
117:20 - there you go, we get sarah, so this is exactly like accessing 
117:24 - individual characters in a string. We can also
117:28 - use a colon to select a range of items, for example if 
117:32 - you pass 2 colon. This will get all items
117:36 - starting from the index of 2, that is Mosh here all the
117:40 - way to the end of the string. So let's run this program
117:44 - there you go. We get this list with 3 
117:48 - items, Mosh, Sarah, and Mary. We can also specify 
117:52 - an end index, let's say 4, so this will return all
117:56 - the items up to this index, but it doesn't include the item at this index.
118:00 - So when we run this program we only see Mosh and 
118:04 - Sarah, the item I've indexed 4which is the 5th element or
118:08 - 5th item in this list is not returned. So Mary
118:12 - is not returned. And also here we have default values, so if you
118:16 - leave out the end index this expression is going to return 
118:20 - all the items starting from the index of 2, to the end of the list
118:24 - or if you leave out the start index, this expression asumes
118:28 - 0 as the default index, so it will return all the items from the
118:32 - beginning to the end of the list. And by the way, 
118:36 - just like strings, these square brackets here, don't modify our
118:40 - original list, they simply return a new list. For example, if we pass
118:44 - 2 here, you can see this returns a new list with 3 items. 
118:48 - So if you go back here and print our original 
118:52 - list of names right after you can see it's not affected. 
118:56 - So here we want to use square brackets with a colon to select a 
119:00 - range of items, we get a new list, and by the way we can also 
119:04 - modify any of the elements in this list. For example let's say we made a mistake and
119:08 - the first item shouldn't be john with an h, 
119:12 - so we want to remove the h, that is very easy, so we access it, 
119:16 - using an index that is names of 0, and we set it to a new value
119:20 - like this. Now, let's print our list 
119:24 - so, you can see the first item in this list 
119:28 - is now data. So this is the basics of lists. And here's a 
119:32 - exercise for you. I want you to write a program to find the largest number 
119:36 - in your list. This is a fantastic exercise for beginners, so go ahead and 
119:40 - spend a few minutes on this, then come back and continue watching. 
119:44 - Alright, let's
119:48 - define a list of numbers, numbers, with a bunch of random numbers
119:52 - 3, 6, 2, 8, 4 and 10. 
119:56 - Now to find the largest number in this list. We need to define another 
120:00 - variable let's call it max, this variable will hold
120:04 - the largest number, now initially you want to assume 
120:08 - the first item in this list is the largest number. So we set max to
120:12 - numbers of 0. We're only assuming that the first item 
120:16 - is the largest number. Chances are our assumption is wrong. So we need
120:20 - to iterate over this list, we need to loop through it, get
120:24 - each item and compare it with max. If it's greater than Max, then
120:28 - we need to reset max to that number. So in the first iteration we get
120:32 - 3, and max is also 3. Is 3 greater than
120:36 - 3. No, so we move on, we get the second number, is 
120:40 - 6, greater than 3? It is, so we need to reset max 
120:44 - to 6. Once again, we continue, we get 2, these two greater
120:48 - than 6, no it's not, so we move on, then we get 8, 
120:52 - is 8 greater than 6? It is, so we should reset max to 8. 
120:56 - That is pretty easy. So here we need a for loop, for
121:00 - number in numbers colon 
121:04 - now we need too heck to see if this number is greater than max, 
121:08 - so, if number is greater than max, 
121:12 - max colon then we need to reset max, so max
121:16 - to this new number, that's all we had to do.
121:20 - So, let's print max, and run our
121:24 - program we can see the largest number in this list is 10. 
121:28 - It doesn't matter whether this number is at the end of the list or the beginning. 
121:32 - So if I move 10 and put it right at the beginning 
121:36 - we should still see the same result. Let's run our program,
121:40 - we still see 10, if I put this somewhere in the middle, our
121:44 - program should still work. Let's put it right after 2. 
121:48 - Run the program, we still get 10. 
121:56 - In this tutorial I'm going to talk to you guys about two dimensional 
122:00 - lists in python. Two dimensional lists are extremely powerfully and they have a lot
122:04 - if applications in data science and machine learning. Here's
122:08 - an example, In math we have a concept called matrix, which is like
122:12 - a rectangular array of numbers, let me show you. So
122:16 - we have 1, 2, 3, 4, 5, 6, 7, 8, 9.
122:20 - So we have a rectangular array of numbers. You have rows, 
122:24 - and columns. So this is a 3 x 3 matrix 
122:28 - in math. Now we can model this in python using 
122:32 - a 2 dimensional list. A 2 dimensional list is a list where
122:36 - each item in that list is another list. So,
122:40 - you want to define a matrix. We set it to a list, each
122:44 - item in this list, is going to be another list, and that list represents 
122:48 - the items in each row. So, the first
122:52 - item in our list is going to be another list, and in this other list we're going to have
122:56 - the values 1, 2, and 3. Now the second 
123:00 - item in our matrix list, once again, we have a list, 
123:04 - this list represents the items in the second row. So, 
123:08 - 4, 5, and 6, and finally 7, 8 
123:12 - 9. So as you can see we have a 2 dimensional list
123:16 - Each item in our outer list is another list.
123:20 -  Okay? So, this is how we can implement a matrix in
123:24 - python, now to access an individual item in our matrix, 
123:28 - once again we use square brackets, let me delete this stuff, 
123:32 - alright, so how do we access 1 here, 
123:36 - well, you start with our list then we add square 
123:40 - brackets first we need to go and get the first item in this list. 
123:44 - Right? So we pass 0, now this expression 
123:48 - returns another list. That is the inner list. In this list, 
123:52 - let's say you want to access the second item, so, 
123:56 - once again we add square brackets, and we pass 1, that
124:00 -  is the index of 2 in this list, alright. 
124:04 - So if we print this on the terminal 
124:08 - we get 2. Okay? So using 2 square brackets 
124:12 - we can access individual items in our matrix, and 
124:16 - also we can modify these values using this syntax, so, 
124:20 - before printing this, let's change this to 20, so matrix
124:24 - of 0, and 1, let's change it to 20, 
124:28 - and then print it, there you go, it's modified, now here you
124:32 - can also use nested loops to iterate over all the items 
124:36 - in this matrix. Let me show you. So, 
124:40 - we start with a rows for the rows in matrix, 
124:44 - so with this loop, we are iterating over our Matrix
124:48 - list, in each iteration row will contain 1 
124:52 - list, 1 item, okay? Now, here we need to
124:56 - use an inner loop. So we need to loop over this row
125:00 - which is a list of items. We can type out 4 
125:04 - item in row colon and print 
125:08 - item. Okay? So, let's run this program, 
125:12 - there you go, we get all the item
125:16 - in our list. Hey, I just
125:20 - wanted to make a quick announcement. In case you haven't seen my website yet, head over to codewithmosh.com
125:24 - this is my coding school, where you can find plenty of courses
125:28 - on web and mobile application development. In fact recently I published a 
125:32 - comprehensive python course that goes way beyond this beginners 
125:36 - youtube. And if you're serious about learning python and getting a job, I highly encourage 
125:40 - you to enroll in this course. Just like this tutorial you can watch it anytime, 
125:44 - anywhere as many times as you want, and you will also receive a certificate 
125:48 - of completion that you can add to your resume, and the course comes with a 30 day
125:52 - money back guarantee, so if you're not happy we'll give all your money back, 
125:56 - no questions ask. The price for this course is 149 dollars, but
126:00 - the first 200 students can get it for only 15 dollars. So if you're interested, 
126:04 - the link is below this video, click the link, and get started.
126:08 - In this tutorial, I'm
126:12 - going to talk to you guys about the list methods, or list functions. These are the
126:16 - operations that we can perform in a list. So let's define 
126:20 - a list of numbers, here we pass a bunch of random numbers, like
126:24 - 5, 2, 1, 7, and 
126:28 - 4. Now there are a number of things we can do with this list, we can
126:32 - add new items to it, we can remove existing items, we can check for the existence of an item 
126:36 - these are the operations that we can perform on a list. So, 
126:40 - the we type numbers, we can see all these functions or more accurately 
126:44 - the methods that are available in our list objects. 
126:48 - So we can call the append method to add a new item to this list. Let's say
126:52 - 13. Actually, no it's not a good number. 
126:56 - I'm joking I'm not superstitious, so let's add 20, it
127:00 - doesn't really matter and then print our list 
127:04 - when we run the program we can see 20 is added at the end of this list 
127:08 - but what if you want to add a number somewhere in the middle, or at the beginning
127:12 - of our list? For that we use a different method, that is called
127:16 - insert. So, insert, now this method
127:20 - takes 2 values, let me show you. So when we open parenthesis 
127:24 - look at this little tool tip above the insert method. 
127:28 - You see the first value that we need to pass here is an index, so
127:32 - this is the index at which we want to insert this new item. Let's
127:36 - say we want to add an item at the beginning of our list, so we passed our index position 
127:40 - of 0, and then the second value is the actual 
127:44 - object we want to add to this list. Let's say we want to add the number 10, 
127:48 - now when we print this list you can see that the
127:52 - number 10 is placed at the beginning of the list and 
127:56 - all the other items are pushed to the right. We can also remove an item so
128:00 - we call remove and pass the item that
128:04 - we want to remove 5. Now we
128:08 - print our list so we see 5 is gone, and we have
128:12 - 2, 1, 7, 4. If you want to remove all the items in the list, you can call
128:16 - the clear method, so, clear 
128:20 - this method doesn't take any values, so, we simply
128:24 - call it and it empties our list, all the items are removed. 
128:28 - We also have another useful method called hop, 
128:32 - and with this we can remove the last item in a list. 
128:36 - Let me show you. So, we run our program, you can see the number 4
128:40 - is removed from the end of our list. Now if you want to
128:44 - check for the existence of an item in our list, you can call the index method. 
128:48 - So, we call index and pass a value here, like 5
128:52 - and this returns the index of the first 
128:56 - occurrence of this item. So let's print this on the terminal. 
129:00 - We don't need this line anymore. So the
129:04 - index of 5 is 0. What if we pass a number that doesn't exist
129:08 - in this list? Let's say 50? Run the program,
129:12 - we get an error. We get a value error. 50 is not
129:16 - in the list. There is also another way to check for the existence of an item, 
129:20 - we can use the in operator. So, let me show you
129:24 - we type our 15 in numbers, 
129:28 - earlier we used the in operator with a string, we
129:32 - check for the existence of a character or a sequence of a character in a string,
129:36 - now here we're checking for the existence of 50 in the list of numbers, so
129:40 - let's print this, we get a boolean value, 
129:44 - false, so unlike the index method, this expression, 
129:48 - doesn't generate an error, so it's safer to use this. We also have another
129:52 - method for counting the occurances of an item, let's say we have 
129:56 - another 5 over here. 
130:00 - Now we can call numbers.count and pass 5
130:04 - and this should return 2 because we have 2 5s in this list.
130:08 - Take a look. There you go. That is pretty useful
130:12 - now if you want to sort your lists you can call sort method. So,
130:16 - we call the sort method here, this method doesn't take any values so, 
130:20 - look at he return value, that is none, none
130:24 - is an object in python that represents the absence of a value.
130:28 - So this sort method doesn't really return any values it simply sorts this
130:32 - list, in place, so instead of printing the return value
130:36 - oft his method, we simply call it to sort our list
130:40 - and then print our list. Take a look. 
130:44 - Now, all the items are assorted in ascending order. We can also
130:48 - sort the items in descending order, so after we sort the list 
130:52 - we can call the reverse method. We can simply reverse
130:56 - our list. Now let's go ahead and run our program, take a look.
131:00 - Our numbers are sorted in descending order. 
131:04 - And one last method I want to show you here that is pretty useful is the copy
131:08 - method. So copy, with this method you can get a copy 
131:12 - of our list. So let's define another variable called numbers 2, 
131:16 - now numbers 2, is a copy of our original list. So if
131:20 - you make any changes to our original list, if you add new items to it, if you remove 
131:24 - existing items, these operations are not going to impact our second list. 
131:28 - Let me show you. So after we show you a copy of our numbers list
131:32 - let's add a new item to this list, so numbers.apphend 
131:36 - ten. So the first list is updated, so now we have a 
131:40 - new item in our first list, then lets print the second list.
131:44 - Take a look, we don't have the number 10 here, because these are
131:48 - 2 independent lists. So these are all the operations 
131:52 - that we can perform on lists. We can add new items to a list, we can
131:56 - remove exxisitn items, we can check for the existence of an item, we can sort 
132:00 - our list, and copy them. Now here's an exercise for this tutorial, 
132:04 - I want you to write a program, to remove the duplicates on our list. 
132:08 - Again, this is a fantastic exercise. So spend a few minutes on this and then
132:12 - come back and continue watching. 
132:16 - Alright let's say we have a list of numbers with
132:20 - a bunch of duplicates. So 2, 2, 4, 6, 
132:24 - 6, 3, 4, 6, 1. We want to remove
132:28 - the duplicates. So we need to define another list
132:32 - let's call that new list. Initially we
132:36 - set it to an empty list. Then we need to iterate over
132:40 - our first list, get each item, and if we don't have that number
132:44 - in this unix list, then we'll add it to this second list. 
132:48 - As simple as that. So, for number 
132:52 - in numbers, now we need to check to see if we
132:56 - have this number in the second list. So we use the in
133:00 - operator. If number not 
133:04 - in units
133:08 - so if we don't have an operator in this units list,
133:12 - then we'll need to add it, so units.
133:16 - apphend number, that's all we have to do.
133:20 - So, let's go ahead and print the units list
133:24 - there you go. So you have 2, 4, 
133:28 - 6, 3,and 1. The duplicates are removed. 
133:36 - In this tutorial I'm going to talk to you guys about another important structure. 
133:40 - in Python called tuple. Tuples are similar to lists
133:44 - so we can use them to store a list of items. But unlike lists we can
133:48 - not modify them, we cannot add new items, we cannot remove existing items, we
133:52 - tuples are immutable. We cannot mutate or change them. So
133:56 - let me show you. So I'm going to start by defining a list of numbers, 
134:00 - 1, 2, 3, 4, so we use square brackets to define lists and 
134:04 - parenthesis to define tuples, so if we change this to
134:08 - parenthesis, 1, 2, 3. Now we have a 
134:12 - tuple. So if we type numbers.
134:16 - look here we don't have the append or insert methods, so we cannot add new items to this tuple.
134:20 - We also don't have remove clear and pop, we cannot
134:24 - remove any of these items here. We only have two methods, count, 
134:28 - and index. We use count to count the number of occurrences in an item, 
134:32 - and index, to find the index of the first occurrence, 
134:36 - of an item. So we can only get information about a tuple, we can't change it. 
134:40 - And by the way, these other methods that you see here, they start
134:44 - with two underscores, we refer to these as magic methods, they're more of an advanced
134:48 - topic, so they go beyond the scope of this tutorial. If you're interested
134:52 - to learn bout them. You can get my python course, I've covered them in detail.
134:56 - So similar to lists you can address individual items using
135:00 - squre bracketts,s o we can get the first item like this and then
135:04 - print another terminal, there you go, the first item is 1, 
135:08 - but if you try to change the first item we'll get an error, so, 
135:12 - numbers of 0, we set it to 10 and run our program 
135:16 - there you go. We get this type error, because the tuple object
135:20 - does not support item assignment. So we cannot 
135:24 - mutate or change tuples, they are immutable. Now practically 
135:28 - speaking, most of the time you'll be using lists, but tuples are also
135:32 - useful. If you want to create a list of items and make sure 
135:36 - no where in your program you accidentally modify that list, then it's better to
135:40 - use a tuple, 
135:44 - In this tutorial I'm going to show you a powerful
135:48 - feature we have in python called unpacking.
135:52 -  So lets find a tuple called coordinates
135:56 - and here we pass 3 values, 1, 2, 3. So you imagine these are
136:00 - the coordinates for x y and z. Now let's say
136:04 - we want to get these values and use them in a few expressions, a few complex
136:08 - expressions in our program. Maybe we want to include them as part of a large
136:12 - complex formula. So together we'll have to write code like this,
136:16 - coordinates of 0, then let's say we want to multiply this
136:20 - by coordinates of 1, and then multiply it by coordinates 
136:24 - of 2, our code is getting a little bit too long, this is just
136:28 - a very simple example. But let's say we want to use these values in quite a few places 
136:32 - in our program, a better approach is to get these values
136:36 - and store them in separate variables like we can get
136:40 - coordinates of 0, and store it in x, then you can
136:44 - get coordinates of 1 and store it in y. 
136:48 - And similarly we get coordinates of 2, 
136:52 - and then store it in z. Now we started repeating coordinates of
136:56 - 2 or coordinates of 0 multiple times, we can simply work with these
137:00 - variables, x times y times z, that is better. 
137:04 - Right? So nothing new so far. But in Python we have a powerful
137:08 - feature called unpacking and with that we can achieve 
137:12 - the same result with far less code. So we can define our variables 
137:16 - x, y, and z. And set them to our
137:20 - tuple. What we have on line 6 is exactly
137:24 - identical to what we have on lines 2-4.
137:28 - So this is a shorthand to achieve the same result.
137:32 - So let me delete this and explain how this code works.
137:36 - When Python interpreter sees this statement, it will get the
137:40 - first item in this tuple and assign it to the
137:44 - variable. Then it will get the second item in this tuple, then
137:48 - similarly we get the third item in this tuple and assign it to
137:52 - the third variable we have here, so we are unpacking
137:56 - this tuple into 3 variables. Now if we
138:00 - print x you can see x 
138:04 - is 1, similarly y is 2, there you go. 
138:08 - So this is unpacking. And by the way this is not
138:12 - limited to tuples, we can use this feature for lists as well. So,
138:16 - if I change parenthesis to square brackets, now 
138:20 - coordinates is a list, so we can unpack our list into 3 variables 
138:24 - now we run our program we can see y is 2.
138:32 - In this tutorial I'm going to talk to you about dictionary 
138:36 - in python. We use dictionaries in situations where we want to
138:40 - store information that comes as key value pairs. Here's
138:44 - an example. Think of a customer. A customer has a bunch of attributes
138:48 - like name, email, phone number, address
138:52 - and so on. Now each of these attributes has a value. 
138:56 - For example the name can be jon smith the email can be
139:00 - jon@ gmail.com the phone can be whatevr
139:04 - so what we have ere is a bunch of key value pairs. So in this
139:08 - example, our keys are name, email, and phone, 
139:12 - and each key is associated with a value. So this is where we use 
139:16 - a dictionary. With a dictionary, we can store a bunch of key value pairs. 
139:20 - So let me show you how to define a dictionary in python. 
139:24 - Back to our program, I'm going to define a variable, customer, 
139:28 - and here we set it to curly braces. With these curly braces we can
139:32 - define dictionary. In this example we have an empty dictionary that doesn't have
139:36 - any key value pairs. Now we can add one or more key
139:40 - value pairs in between the braces. So let's
139:44 - add a key value pair here, I'm going to set the key to a  name, and 
139:48 - the value to John Smith, then we add a comma,
139:52 - to add another key value pair. So let's set age to 
139:56 - 30 let's add another key value pair is 
140:00 - underline verified and we set this to a boolean.
140:04 - Now what matters here is that these keys should be
140:08 - unique. So if I add another key value pair here, 
140:12 - set age to 40, now look pycharm
140:16 - has highlighted the age key, because we have duplicated that and
140:20 - that's not allowed. So each key should be unique in a dictionary, just like, 
140:24 - the dictionaries we have in the real world, in a real dictionary we have a bunch of words 
140:28 - and they're definition each word is only listed once in a dictionary.
140:32 - We don't have the word book twice. So let's delete the second
140:36 - duplicate key value pair, so the keys should be unique,
140:40 - and in this example, I'm using strings, but they can also be
140:44 - numbers, we're going to look at that later, but the value can be anything, it can be
140:48 - a string, a  number, a boolean, a list, literally anything.
140:52 - Now we can access each item in this dictionary 
140:56 - using square brackets. So, we type customer, 
141:00 - square brackets and then specify key like name
141:04 - and this will return the value associated with
141:08 - the name key. Let's print it on the terminal, have a look,
141:12 - there you go, so, the name is John Smith, now
141:16 - what if we pass a key that doesn't exist, lets say first date.
141:20 - You run the program, you get a key error because we don't have
141:24 - a key called birth date. Also, if we spell
141:28 - name with let's say a capital N, we get the same
141:32 - error because we don't have a key with the exact same sequence of
141:36 - characters in this dictionary. Now to get around this we can
141:40 - use the get method, so instead of using the square brackets 
141:44 - we call the get method and specify the key
141:48 - Now if you use a key that doesn't exist here, it doesn't yell at us. For example, 
141:52 - if you pass birth date
141:56 - it simply returns the non value. Earlier I told you that none is an object
142:00 - that represents the absence of a value. So
142:04 - instead of getting a key error we get none and we can also option
142:08 - supply a default value, for example, if this dictionary doesn't have this
142:12 - key, we can supply the default value, let's say
142:16 - January 1st 1980. Let's run the program 
142:20 - now instead of getting none we get this default value. 
142:24 - So, this is how we can access the value associated with the key
142:28 - in a dictionary. We can also update these values for example 
142:32 - before a print statement we can write code like this, customer of
142:36 - name, let's update the name to jack 
142:40 - smith, now this little warning is telling us here we can put jac
142:44 - smith here instead of defining it once, and then update
142:48 - it. Don't worry about them, it doesn't really matter. Now with this line if 
142:52 - we print the name of this customer, we should see jack smith, let me show you.
142:56 - So, I'm going to use the square bracket notation again, let's print
143:00 - the name of the customer you can see that is updated here, 
143:04 - we can also add a new key here, let's set the
143:08 - birthdate to some value like january first
143:12 - 1980. And then we can print it here, 
143:16 - so as you see we can easily add new key value pairs
143:20 - to a dictionary. So this is the basics of using dictionaries
143:24 - in python. They're extremely important and they have a lot of applications in the real
143:28 - world. Okay, here's an exercise for you. So here we have
143:32 - this program that asks our phone number. Let's type 1
143:36 - 234. We type it in digits and then this will translate
143:40 - it, to words, take a look. Enter, it prints, 1, 2, 3, 
143:44 - 4. That's a pretty cool program, so go ahead and
143:48 - spend a few minutes on this exercise, it's pretty easy, I will see you
143:52 - next. 
143:56 - Alright, so first we need to get the users phone number, we call the input function 
144:00 - with the label phone, we get the result and store it
144:04 - in this variable, now let's say the user enters 123
144:08 - 4. So we need to look through this string, get each character and 
144:12 - translate it to a world, so what we need to implement this scenario.
144:16 - is a dictionary, because a dictionary is a structure that allows us to
144:20 - a key to a value. So we can have a dictionary with keys
144:24 - like 1234. And we map each of these keys
144:28 - to a word. So we cannot put digit 1 to
144:32 - the word 1 we can map 2 
144:36 - to two you get the point. So let's define 
144:40 - a dictionary, you can call it digits, underline mapping
144:44 - now this dictionary I'm going to add a few key value pairs. 
144:48 - One, we map it to 1, 2, we 
144:52 - to 2, 3, to 3, 
144:56 - and finally, 4 to 4. Now technically we should
145:00 - add all the digits from 0 to 9, but I don't want to waste all your time 
145:04 - typing repetitive things here, you got the point. So lets move on,
145:08 - now we need to look through the phone string. So 
145:12 - 4 character in phone, we get each
145:16 - character and then use it to access a key value pair in
145:20 - dictionary. So, digits underline mapping
145:24 - we can use square brackets or call the get method, 
145:28 - I would prefer to use the get method, so in case the user enters some character
145:32 - that is not part of our dictionary, our program is not going to yell at them.
145:36 - So, we call the gt method and pass this character
145:40 - a the key, and if we don't have this key, we can supply
145:44 - a default value like exclamation mark, so with this we get a word
145:48 - now we need to add this word to an output string, so we can define
145:52 - an output string, initially we set it to an empty string, 
145:56 - in each iteration we get this and add it to our output string. 
146:00 - So, we type output, plus equals. 
146:04 - This and we should also add a 
146:08 - space at get. So the words are not close to each other, okay?
146:12 - That's all we have to do. Now finally let's print
146:16 - this output, run our program, so I want to
146:20 - type 1, 3,4, 5, lets 
146:24 - see what we get. We get 1, 3, 4 with an exlamantion
146:28 - mark. 
146:32 - In this tutorial I'm going to show you something really cool
146:36 - that you can do with dictionaries, so here in this program you can type
146:40 - a message like good morning followed by a smiley face,
146:44 - when we press enter, we get this beautiful smiley face, or
146:48 - we can type i am sad, with a  sad smiley face
146:52 - and it gets translated to this beautiful emoji. 
146:56 - So this is another application if using dictionaries, we have a dictionary 
147:00 - that maps these characters into smiley faces. 
147:04 - So lets go ahead and build this program together, we start by
147:08 - calling the input function, here we pass a greater than symbol
147:12 - as an indicator for the user to type a message, we give that message, store
147:16 - it here, as you know that is a string, now we need to
147:20 - split this string by a space, so if the user types
147:24 - good morning with a smiley face, we want to break this down into
147:28 - 3 words, good morning, and smiley face. 
147:32 - To do that we can call the split method. So we call
147:36 - message.split and pass 
147:40 - a string with one space as a separator. What this method
147:44 - does is basically it goes through this string and anywhere it finds this
147:48 - character, in this case a space, it uses it as a boundary to
147:52 - separate this string into multiple words. And then it will return
147:56 - a list. Let me show you. So let's store that here, words, and then
148:00 - Then print it on the terminal, 
148:04 - let's go ahead and run our program. So if you type good morning 
148:08 - sunshine, enter, we get a list with three items 
148:12 - each item is a string, okay? Now, 
148:16 - back to our program, we need to define a dictionary for mapping special characters
148:20 - like these 2 into a smiley face, so, 
148:24 - we can call that emojis 
148:28 - set it to curly braces, here we add a key value pair, 
148:32 - a smiley face, and we map that to a string, 
148:36 - in this string we want to add an emoji, if you're on a mac keyboard you can press 
148:40 - control command and space and this should bring up
148:44 - this emoji box, if you're on Windows honestly I
148:48 - really don't know how you can do this, but there must be applications who do this for you. So lets go
148:52 - ahead and pick this happy smiley face, good, 
148:56 - now lets add another key value pair, or sad face
149:00 - we map this to, 
149:04 - this face here, good. So, we 
149:08 - have a list of words now we need to look through this list, get
149:12 - each word and potentially map it to an emoji.
149:16 - So we can write a for loop for word in words, 
149:20 - now we want to go to our dictionary, and see if you have an item with this
149:24 - word as the key. If you have an item with that key, we get
149:28 - it's value, otherwise we want to use the same word. So if a user types
149:32 - good morning, we don't want to translate those words, we just want to return those. So that is the case, 
149:36 - where we use the get method to supply a  default 
149:40 - value, so we wan to get an item with a key word, and
149:44 - if we don't have an item with that key, we simply use that word as 
149:48 - the default value. Now similar to the exercise that we did in the last tutorial 
149:52 - we need an output variable. So let's define that here, 
149:56 - output set it to an empty string, now back to line
150:00 - 9, we get the return value of the get method, 
150:04 - and add it to our output variable. So output 
150:08 - plus equals whatever we get from the get method, and finally 
150:12 - we need to append a space at the end. 
150:16 - That's it, we're done. So let's print the output 
150:20 - and run our program and I'm going to type good morning
150:24 - sunshine with a smiley face, we get that 
150:28 - beautiful, let's try the sad face as well, I am sad. 
150:32 - Too bad. Beautiful! So as you can see
150:36 - dictionaries have a lot of use cases in real applications.
150:44 - Here's a solution from the last tutorial where we created an emoji 
150:48 - converter. Now so far we have been writing all our code right here,
150:52 - in app,py, but as our programs grow we need a better way to organize our code. 
150:56 - We need to break up our code into smaller, more manageable 
151:00 - and more maintainable chunks which we call functions. So function 
151:04 - is a container for a few lines of code that perform a specific 
151:08 - task for example you have learned about a few of the built in functions in
151:12 - python like print, and input, each of these functions 
151:16 - have a purpose, they know how to perform a specific task. So when we 
151:20 - build large complex programs, we should break up our code into smaller 
151:24 - reusable chunks which we call functions to better organize our code.
151:28 - And that's what I'm going to show you in this tutorial. So let's write this simple 
151:32 - program, for printing a greeting message. So we're going to do a print, 
151:36 - hi there, and lets add another message 
151:40 - welcome aboard. So here we have a simple 
151:44 - program with only two lines of code. Now let's say these two lines 
151:48 - potentially we're going to need them in other programs so we can put them in a function that
151:52 - we can reuse. Let me show you how to do that, so, 
151:56 - we start typing out death, that is a reserve keyword in
152:00 -  Python, and it's short for define. When Python interpreter sees this it
152:04 - knows that we're defining a function, next we need to give our function 
152:08 - a name, lets say greet_user.
152:12 - So all the best practices you learned about naming your variables also apply here, 
152:16 - which means we should name our functions with lower case characters 
152:20 - if there are multiple words, we need to separate them using an underscore 
152:24 - and you should always, always, always use meaningful
152:28 - descriptive names for your functions. So, here we define a function
152:32 - called greet user, after that we'll need to add parenthesis 
152:36 - followed by a colon. Now you know that whenever we add a colon at the end of a line
152:40 - we're telling python that we're defining a block of code. So when we 
152:44 - press enter, the next line is indented. Now any code that we write here
152:48 - will belong to this function. So I'm going to move these two lines
152:52 - these two print statements inside of our function. You can simply 
152:56 - press tab to indent them, beautiful, also lets remove
153:00 - this extra line break, that is better, so these two lines
153:04 - now are part of our greet user function, so whenever we 
153:08 - call this function, these two lines will be executed. Okay? Now, 
153:12 - let's remove indentation so here we are outside of our function, 
153:16 - let's do a print statement and print start
153:20 - after that let's call our function, so greet user.
153:24 - And finally let's do another create statement and print
153:28 - finish. Now we have this little warning here, this
153:32 - underline, if you hover your mouse over this line, this tool was telling you
153:36 - that we should add two blank lines after a function definition. This is coming from
153:40 - pep8 which is a document that defines the best practices for
153:44 - formatting our code. We'll look at that in the future. So for now to make pycharm
153:48 - happy, lets add an extra line break to this function
153:52 - so whenever we define a function we need to add two lines breaks after.
153:56 - Okay? so, now let's run our program and see what happens.
154:00 - Alright, so we have 4 messages on the terminal 
154:04 - first we get the start message then we get the messages
154:08 -  coming from our create function, so either and welcome aboard, and finally we see
154:12 - the finished message. So let me explain the flow of our program 
154:16 - when python runs this code it doesn't actually print these
154:20 - two messages on the terminal because these two lines of code are inside
154:24 - of this function, so they would only get executed if we call
154:28 - this function. If we don't call this function, these lines don't get executed. 
154:32 - Okay? So the execution of our program actually starts here,
154:36 - the first message that we see on the terminal is the start message. After
154:40 - that, Python sees that we are calling the greet function, so
154:44 - it will jump over here and then execute these two lines.
154:48 - Then, it will jump out of this function and continue the normal
154:52 - execution of our program so it will print the finish message on the terminal.
154:56 - So this is how functions work. Also note that the order of this
155:00 - code matters, so here we're calling the greet function after
155:04 - after we have defined it. If you try and call it before you define it you will see an error.
155:08 - For example, if we call the greet
155:12 - user function right here, see we immediately get this red underline
155:16 - which says unresolved reference, greet user which basically
155:20 -  means python doesn't know what is this greet user, it's not defined anywhere. 
155:24 - So we always define our functions first, and then 
155:28 - call them. 
155:32 - Here's a function we created in the last tutorial
155:36 - now I got a question for you, what is the difference between
155:40 - calling this functions nd the print function of python? The difference 
155:44 - is that the print function takes some information, in this case 
155:48 - the message that we want to print, but our greet function doesn't take 
155:52 - any information. Wouldn't it be nicer if you could pass the name of the user here and then
155:56 - instead of saying hi there, you could print the name of the user. So, 
156:00 - in this tutorial, I'm going to show you how to pass information to your functions, and 
156:04 - that is pretty easy, so back to the definition of our greet
156:08 - user function, inside of these parenthesis, we can add parameters
156:12 - these parameters are pale holders for receiving information. 
156:16 - For example, you can add a name parameter, and we can pass the
156:20 - name of the user when calling this function. So let's pass Jon
156:24 - here, now when we call this function and pass this value
156:28 - this name parameter will be set to Jon. So it
156:32 - will act like a local variable that we defined inside of this function. 
156:36 - Just imagine, we didn't have this parameter, and instead we had 
156:40 - a variable like name that was set to jump. Now here we could simply 
156:44 - print the name of this user, so we could use a formatted string, 
156:48 - and print the value of the name variable, right? Now, 
156:52 - we don't really have this local variable defined in this function
156:56 - we have a parameter, it's exactly the same thing. So 
157:00 - with these parameters we can receive information in our functions. Now let's go ahead and
157:04 - run this program, so take a look. 
157:08 - We get Hi John welcome aboard, we can take this to the next 
157:12 - level. Now we can call this function one more time. So 
157:16 - greet user, and this time supply a different name. Let's say Mary. 
157:20 - So we are reusing our greet function and passing it a different
157:24 - value. Imagine if we didn't have this function you would have to 
157:28 - repeat this line twice , once for hi jon and another time for hi mary. 
157:32 - So this is the benefit of defining functions, we can take a few
157:36 - lines of code that have a specific purpose and put them inside of a 
157:40 - function, so now let's run our program one more time
157:44 - there you go. So you get hi job, welcome aboard, then you get hi mary
157:48 - welcome aboard. Now note that when a function has a parameter 
157:52 - we are obligated to pass a value for that parameter. 
157:56 - So if you remove jon from here and run 
158:00 - our program, we get this type error, greet user, 
158:04 - missing one required positional argument. 
158:08 - Argument in programming is the value that we supply to a function, so
158:12 - back to this example, marrying this case is an
158:16 - argument that we pass to the name parameter. And lot of
158:20 - programmers don't know the difference between parameters and arguments and think they are the same. 
158:24 - But they are not, parameters are the holes or placeholders
158:28 - that we define in our function for receiving information, 
158:32 - arguments are the actual pieces of information that we supply to these functions. 
158:36 - Okay? So, let's bring back 
158:40 - this jon string, now we can also define multiple 
158:44 - parameters, for example, let's rename this parameter to first name as I told 
158:48 - you before, you can right click here, go to refactor and then 
158:52 - rename, or preferably you can use a short cut. So the shortcut for
158:56 - this on Mac is shift and f6. 
159:00 - And this brings up the renamed dial up box, here we can change this to first 
159:04 - underline name. Now we can add a second parameter 
159:08 - so comma followed by last underline name 
159:12 - so back to our formatted string, let's also print 
159:16 - the last name, beautiful, so here when calling this function, 
159:20 - then we can supply another argument so jon
159:24 - smith and lets delete this line we don't really need it anymore 
159:28 - run our program, take a look, hi jon smith, 
159:36 - so in the last tutorial you learned that whenever 
159:40 - we define parameters for our functions we should always supply 
159:44 - values otherwise we'll get an error. Let's look at that error one more time.
159:48 - So In going to delete this second argument and only pass jon. 
159:52 - Run our program, we get this message, 
159:56 - greet user missing one required, position 
160:00 - argument. So these arguments that you have here like jon 
160:04 - and smith you refer to these as positional arguments. 
160:08 - Which means their position or argument matters. In other
160:12 - words, the first argument we add here is the value or the first parameter 
160:16 - and the second argument is the value for the second parameter. 
160:20 - So if you change their position or order, we'll get different results. 
160:24 - Let's take a look. Let's pass smith first and then
160:28 - jon. Okay, good, delete, now let's
160:32 - go with this, so instead of getting Hi Jon Smith, 
160:36 - we get hi smith jon. So that is the reason we refer
160:40 - to these arguments as positional arguments, they're positioned or
160:44 - order matters. But in python we also have keyword arguments, and 
160:48 - with those the position doesn't matter. Let me show you how they work. So, 
160:52 - let's say here you want to pass Jon as the value for the first 
160:56 - name parameter. We can simply specify that here. So first name 
161:00 - equals jon. Now what we have here is a keyword argument. 
161:04 - the key word argument. So this combination of having the parameter name,
161:08 - followed by it's value is what we call a keyword argument, and what we get with this keyword
161:12 - argument the position doesn't really matter. So here we're supplying
161:16 - Jon as an argument fort he first parameter. Now similarly, 
161:20 - we can use a keyword argument for smith, so last
161:24 - name equals smith, so that we have 2 
161:28 - keyword arguments. So with these keyword arguments we don't have to worry about
161:32 - the order of the parameters. Now that doesn't mean we should always use keyword arguments. 
161:36 - Not really. Most of the time we use positional arguments, but
161:40 - in certain situations these keyword arguments helming us improve 
161:44 - the readability of our code. So on line 7 it's quite clear
161:48 - that we are supplying smith as the last name and jon
161:52 - as the first name. Now in this particular example, even if we didn't have
161:56 - the keyword arguments, just passing two positional arguments like jon 
162:00 - and smith, would be sufficient, because it's easy to guess
162:04 - what is the purpose of these arguments. But sometimes you're dealing with functions
162:08 - and you're passing numerical values to them, in those situations
162:12 - it may not be quite clear what those values represent. Let me show you an example.
162:16 - Let's say we have a function for calculating the total cost of an order, 
162:20 - so we still call that calculate, underline cost, 
162:24 - so when calling this function, you need to supply three pieces of information.
162:28 - One is the total cost of all the order items lets say 50
162:32 - dollars. The other is the shipping cost, let's say 
162:36 - 5 dollars, and the last piece is discount, let's say 0, 
162:40 - .1. Someone reading this code, may not be sure 
162:44 - what these three values represent, in this case, we can improve
162:48 - the readability of this code, by using keyword arguments. So we can
162:52 - prefix each value with the name of parameter they target, for example, 
162:56 - we can set total to 50 and then
163:00 - shipping to 5, and then discount to 0.1. 
163:04 - Now if you give this code to someone else, they
163:08 - can immediately tell what these values represent. So that is the power 
163:12 - of keyword arguments. So here's what I want you to take away.
163:16 - For the most part, use positional arguments, but if you're dealing with
163:20 - functions that take numerical values, see if you can improve the
163:24 - readability of your code by using keyword arguments. You simply 
163:28 - prefix the arguments that you pass with the name of their parameters and this will 
163:32 - increase the readability of your code. Now there is one more thing you need to know about
163:36 - keyword arguments. These keyword arguments should always come after
163:40 - positional arguments. Let me show you what I mean. So, 
163:44 - back to our simple greet user function, let's use a keyword argument 
163:48 - for the first thing. So, let's set 
163:52 - first name to jon and see what happens. So we immediately get this error and 
163:56 - positional argument after keyword argument. 
164:00 - So when calling this function we're supplying one keyword argument 
164:04 - and one positional argument, and python doesn't like this. So, 
164:08 - if you're mixing positional and keyword arguments, you should always use
164:12 - and then the keyword arguments. 
164:16 - In other words, lets remove this keyword argument here, 
164:20 - so jon is now a positional argument, is targeting the first
164:24 - parameter. Now after this positional argument we can
164:28 - supply any number of keyword arguments, so if you set last name to smith
164:32 - look, python doesn't have any problem with this because we are adding 
164:36 - a keyword argument after a positional argument.
164:40 - So let's quickly recap, for the most part use positional arguments 
164:44 - if you're dealing with functions that take multiple numerical values 
164:48 - and it's not quite clear what those values represent, use keyword arguments 
164:52 - to improve the readability of your code, and finally if
164:56 - your passing both positional and keyword arguments, use the
165:00 - keyword arguments after the positional arguments. 
165:08 - So far you have learned how to create functions and send them information using
165:12 - their parameters in this tutorial I'm going to show you how to create functions that return 
165:16 - values, this is particularly useful if you're doing some kind of
165:20 - calculation your function and you want to return the result to whoever is using your
165:24 - function. let me show you. So let's start by defining a 
165:28 - function, called square, this function simply calculates
165:32 - the square of a number. So we need to add one parameter here, 
165:36 - that is is our number, now here we want to calculate number 
165:40 - times number, that is the square of a number. 
165:44 - Now to return this color outside of this function we simply 
165:48 - use the return statement. So return. Now, 
165:52 - our square function is very simple, it only had one line of code. 
165:56 - But in a real program, you might have a function that has ten lines of code to calculate
166:00 - something. So, this return statement is very
166:04 - valuable. So now we can return values to the caller of our function. 
166:08 - So, with this, when we call the square function, 
166:12 - let's say we give it 3, now this function returns a value, 
166:16 - just like an input function of python, this input function 
166:20 - waits for the user to type something and press enter and then it will
166:24 - return the user's input as a string so we can get it
166:28 - and store it in a variable like this, right? We have the same story with our
166:32 - story, with our square function. So our square function returns the value
166:36 - we can simply get it and store it in a variable. Let's call that
166:40 - result. Now, we can print 
166:44 - result on the terminal, there you go, so result is 9, 
166:48 - we could also pass this function called
166:52 - directly inside of the print function without defining a separate variable.
166:56 - Sometimes this is useful for writing shorter code, so in this case. 
167:00 - So, in this case, we don't really need this result variable. We simply want to print 
167:04 - the square of 3. So, we could simply pass this function 
167:08 - call right here, as an argument for the print 
167:12 - function. So let's delete this variable now our code is
167:16 - shorter so with this we're calling the square function, this returns a 
167:20 - value and we'll pass that value as an argument to the print function. 
167:24 - Okay? When we run this program, we get the exact same 
167:28 - result. There you go. Now what happens if we don't 
167:32 - use a return statement in our function. So in the last example we simply used
167:36 - a print statement. Let's temporarily remove 
167:40 - this return statement and print the result
167:44 - on the terminal. Like this. So let's run our program 
167:48 - one more time and see what we get. We see two things, the number
167:52 - 9, and none. What is happening here? Well
167:56 - when Python interpreter executes this code, first it will call
168:00 - the square function. So the control moves to the square function 
168:04 - here we calculate the square of this given number and then print it
168:08 - on the terminal. That is the reason we see 9 right here, 
168:12 - now, by default, all functions return the value 
168:16 - none. So if we don't have a return statement 
168:20 - here, by default python returns none. None
168:24 - is an object that represents the absence of a value, it's like nothing 
168:28 - or null i c, c++ java and Javascript. 
168:32 - So, in this example, we didn't have a return statement, and 
168:36 - by default python returned none from this function. 
168:40 - So, after this square function is executed, the value none 
168:44 - is returned and passed as an argument to the print function, that is the reason 
168:48 - we see none on the second line. So here are the two things
168:52 - you need to take away from this tutorial. By default all functions in Python 
168:56 - return none. You can change that, so if you have a function that 
169:00 - calculates something, you can return the result using the return statement. 
169:08 - Here's the code for our emoji converter program that we wrote earlier. 
169:12 - If you missed that tutorial, make sure to go back and watch it, as 
169:16 - I told you before, there is a table of content right below this video in the
169:20 - description. So we can simply click on the emoji converter tutorial to watch it. 
169:24 - Now, your exercise is to reorganize this code using a function. 
169:28 - So I want you to extract a function in this code, because this algorithm
169:32 - for converting these smiley faces into emoji's is something that
169:36 - we probably want to use in a couple different applications. We can use it in a chat
169:40 - application in an email application and so on. We don't want to write all this code every time 
169:44 - we want to convert these characters into smiley faces. 
169:48 - So, out of all these lines of code that we have from line 1 to 
169:52 - line 10, the lines 10-2 belong to our
169:56 - algorithm, all these lines together implement this feature. 
170:00 - So, you should put these lines in a separate function, 
170:04 - Now, why don't we have the input in this function? Because
170:08 - the input will can come in different forms, currently we're using the import function 
170:12 - to receive the input from the terminal, but in other applications 
170:16 - we might receive the input from a graphical user interface, so the input can come in
170:20 - different forms. We don't want to put that in our function, because this line will not be reuseable. 
170:24 - You want to give our function the actual message, 
170:28 - as a string. We don't care how we got that message. In one 
170:32 - program you might get it from the terminal, in another program you might get it from 
170:36 - a graphical user interface. So that is the reason this line up code should not
170:40 - be in that function. By the same function, you shouldn't include
170:44 - the last line in that function because what we do with the output is different from 
170:48 - one program to another. In this program, we are printing the output 
170:52 - in another program, you might send an output as an email, or as a response in 
170:56 - a chat application, so as a general rule of thumb you're function should
171:00 - not worry about receiving input and 
171:04 - printing it. These lines of code should not belong to your functions. So go 
171:08 - ahead and reorganize this code by extracting a function. 
171:16 - Alright, on the top, first we need to define our function. So first we type 
171:20 - def, give our function a name like emoji_
171:24 - converter, so the name of this function clearly tells me what
171:28 - it does. Each function should be responsible for one and only one task, 
171:32 - and that task should be clearly explained in the name of the function. 
171:36 - So, our emoji converter function should take 
171:40 - a parameter, we call that message, that is a string, right? Colon
171:44 - now we need to move the lines 
171:48 - 5 all the way to the end of our for block 
171:52 - into the function, so let's select all these lines, you can
171:56 - cut them from here, by pressing command and x on Mac, or
172:00 - control and x on Windows, then we paste it here, 
172:04 - as you can see these lines are automatically indented 
172:08 - so, they are part of the emoji converter function, if this didn't happen on your
172:12 - computer, make sure to select these lines and use the 
172:16 - tab to indent them. Alright, so here's our emoji converter function 
172:20 - beautiful. Now after that 
172:24 - in the main flow of our program, first we get the input from the user 
172:28 - we store it in this variable message and then we call
172:32 - emoji converter and pass this message, 
172:36 - this function should return a value, that is what we use to calculate
172:40 - the end of this function, so right after this for block we need to add 
172:44 - a return statement, return output, 
172:48 - now that our function returns a value, we can get it and store it
172:52 - in a separate variable, let's call that result 
172:56 - and then we can simply print that here, or
173:00 - we can make this code shorter, we don't really need this code here so we can simply 
173:04 - call the emoji converter, and print the result.
173:08 - Like this. Now here we have an underline because
173:12 - as I told you before we need to blank lines after
173:16 - our function definitions. So currently we have only one blank line 
173:20 - we need to add another black line, good, let's go ahead, 
173:24 - and run this program, and make sure everything works as before 
173:28 - so I'm going to type a message like good morning with a smiley face 
173:32 - good, let's run it one more time, times that, 
173:36 - to add okay beautiful, so, here's the
173:40 - final result, we defined this function called
173:44 - emoji converter, this function takes a parameter called message.
173:48 - And finally returns the output. 
173:56 - In this tutorial I'm going to teach you how to handle errors in your 
174:00 - python programs, so let's start by writing  a small program 
174:04 - to get the user age from the terminal. So we call the input variable 
174:08 - input, and a label here, 
174:12 - like age, this returns a string, so we need to pass it to
174:16 - the end funciton and store the result in
174:20 - a variable called age, now let's print age to make sure you have
174:24 - implemented everything properly we run our program, we type 
174:28 - 20, 20 is printed here, beautiful, now look at 
174:32 - the exit code of this program, exit code 0 means
174:36 - our program terminated successfully, there were no errors, but what if
174:40 - we run this program one more time and instead of entering 
174:44 - a numerical value, we enter something like asd. 
174:48 - We get a value error with his message invalid literal 
174:52 - for int with base 10. Basically what this message is telling 
174:56 - us is that this string asd does not contain 
175:00 - a valid home number that can be converted to an integer. Now look at the exit
175:04 - code of this program, exit code 1 means our exit code crashed, 
175:08 - so 0 always means success and anything but 0 means crash 
175:12 - now as a good python programmer you should anticipate this situation. 
175:16 - You don't want to let your entire program crash just because the user entered 
175:20 - an invalid value. So instead of letting the program 
175:24 - crash you should handle the situation and print a proper error message, and 
175:28 - that's what I'm going to show you in this tutorial, now before we get any further 
175:32 - look at the type of error we get here, value error, 
175:36 - so remember this, we're going to get back to this shortly 
175:40 - now how can we handle these errors, in python we have a construct called 
175:44 - try accept we use that to handle errors. 
175:48 - Let me show you how it works. So on the top
175:52 - we type try: now as you know we are defining 
175:56 - a code block so, I'm going to move these two lines, 
176:00 - inside of our try block so press tab here. 
176:04 - And remove this black line, now these two lines are part of our
176:08 - try block, right? So after try we type 
176:12 - accept, and then we add the type of the error 
176:16 - that our program may encounter, that is value error
176:20 - okay? Then, we add a colon and in this block we can
176:24 - define what should happen if our program encounters 
176:28 - an error of type value error. In this case we want to print 
176:32 - a proper error message, so print, 
176:36 - invalid value. So with this try and accept we are telling python
176:40 - hey, go ahead and try running one or these two lines of code, 
176:44 - if you encounter, an error of type. Value error 
176:48 - then instead of crashing the program, try this error message on the terminal
176:52 - so this is how this works. Now more accurately in programming
176:56 - we reefer to this kind of error as an exception. So an exception 
177:00 - is a kind of error that crashes our program. So our
177:04 - user enters an invalid value, this line of code 
177:08 - in line 2 will raise an exception, and on line 4 will catch it
177:12 - and print this error message, so our program will no longer 
177:16 - crash. Let me show you. So let's go ahead and run this
177:20 - age 20, everything 
177:24 - works just like before and the exit code is 0, let's 
177:28 - rerun this program, and enter asd, 
177:32 - so we get this proper error message invalid error menu and once again 
177:36 - the exit code is 0, so that means our program completed successfully.
177:40 - Didn't crash, now, we can also handle different kinds of 
177:44 - errors or exceptions, for example right when we get the age
177:48 - let's define a variable income and set it to 20,000.
177:52 - And then define another variable called risk and set it 
177:56 - to income divided by age. 
178:00 - Let's run this program and enter 0 as the game to see what happened. 
178:04 - So 0 is obviously a numerical value 
178:08 - so when we enter this value, technically we shouldn't get any exceptions. 
178:12 - Take a look. Our program crashed, we 
178:16 - did a 0 division error, because we cannot divide a number by 0. 
178:20 - Once again look at the exit code, so we couldn't catch this kind of error or
178:24 - this kind of exception with this accept block. 
178:28 - Accept block is only cashing exceptions of type value
178:32 - error. And this happens when we try to convert a nonnumerical value, 
178:36 - to an integer. So in a situation like this. We should handle 
178:40 - different kinds of exceptions, we can add another 
178:44 - except statement for an exception of type 0
178:48 - division error. Now in this block we can print a 
178:52 - different kind of message, like age cannot be
178:56 - 0. Let's run our program one more time. Now, 
179:00 - I'm going to enter 0 as the age so we get this
179:04 - error message age cannot be 0 and look at the exit code.
179:08 - It's 0, so our program didn't crash, so to recap, we 
179:12 - `used try accept blocks to handle exceptions that are
179:16 - raised in our programs, as a good programmer you should always anticipate
179:20 - these kind of exceptions and handle them properly. 
179:28 - In this tutorial I'm going to talk to you guys about comments in python. 
179:32 - We use comments to add notes or comments to our programs. 
179:36 - For example, here I'm going to make a print statement, 
179:40 - sky is blue. Now, before that, I 
179:44 - can add a comment using a hi sign and then whatever we type here 
179:48 - is going to get ignored it's not going to get executed. Let me show you so
179:52 - let's run this program, look we only see this
179:56 - message. Sky is blue. So with this comment we can explain 
180:00 - something about our code, we can use it as reminders to fix things or
180:04 - clear things up, or we can use it to communicate things with other developers 
180:08 - reading our code, why we have written this code in a certain way.
180:12 - These are good use cases for using comments, we can also
180:16 - have comments over multiple lines, so we can simply add more
180:20 - comments, each line should start with a new hi sign. Now
180:24 - one thing you need to avoid when using comments is explaining what the
180:28 - code does. So here's an example of a bad comment. 
180:32 - Let me just delete these two lines, and with this comment I'm going to
180:36 - say print sky is blue. Why
180:40 - is this a bad comment, because it's telling me the obvious, it's telling me 
180:44 - this slide is going to print sky is blue. Now the problem with this comment is
180:48 - that apart from being verbose and repetitive, if you come here, 
180:52 - and change sky to ocean, now this comment gets 
180:56 - outdated. So overtime we change this code, then we have to come back and 
181:00 - modify the corresponding comment. So I've seen some developers 
181:04 - add comments in front of their functions, for example, they define 
181:08 - a function let's say a square that takes a number 
181:12 - and simply returns number times number.
181:16 - But it is obvious that this function calculates and returns the
181:20 - square of the given number. So there is really no need to add a comment and 
181:24 - explain that. Calculates and returns the
181:28 - square of a number. This is very repetitive and it creates 
181:32 - noiser code. Someone else reading your code they get distracted with all
181:36 - these unnecessary comments, so use comments to explain whys and hows.
181:40 - Not why's if you have made certain assumptions, we can use
181:44 - comments to explain those assumptions. Or we can use them to add notes to remind yourself 
181:48 - or other developers to do something in the code. 
181:52 - So comments are good, but too much of a good thing is a bad thing. 
182:00 - In this tutorial I'm going to talk to you guys about classes in python. 
182:04 - Classes are extremely important in programming and they're not
182:08 - specific to python, in fact, a lot of other programming languages
182:12 - do support the notion of classes. We use classes to define new types.
182:16 - For example, so far you have learned about the basic types in Python 
182:20 - like numbers, strings, and booleans, 
182:24 - these are the basic or simple types in python, you also learn 
182:28 - about a couple of complex types like lists and 
182:32 - dictionaries. While these types are extremely useful, they cannot 
182:36 - always be used to model complex concepts, for example, think about 
182:40 - the concept of a point, or a shopping cart. A shopping cart is not
182:44 - a boolean, it's not a list, it's not a dictionary, it's a different kind of
182:48 - thing. So we can use classes to define new types to 
182:52 - model real concepts. Now in this new model I'm going to show you how to
182:56 - define a new type called point, and this new type is going to have methods 
183:00 - for working with points. For example, back to our main program. Let's 
183:04 - create a list, numbers, 1, 2, 3, 
183:08 - you know that here, when we type that dot, 
183:12 - functions or methods available in list objects, now similar to this, 
183:16 - we're going to create a new type called point, this point is
183:20 - going to have metas like move, draw, get, 
183:24 - distance from another point, these are the operations that we can
183:28 - perform on points. So let me show you how to do this.
183:32 - We start by defining a class by using the class keyword, 
183:36 - and right after that we give our class a name. Now look at the
183:40 - naming convention I've used here. I've capitalized the first letter here, this is what we call
183:44 - a pascal naming convention. So the naming convention we 
183:48 - used for naming our classes is different from the convention we use for naming
183:52 - our variables and functions. For variables and functions we always
183:56 - use lower case letters and we separate multiple words using
184:00 - an underscore. But when naming classes, we don't use an underscore 
184:04 - to separate multiple words, instead we capitalize 
184:08 - the first letter of every word. So in this case our class has only a single 
184:12 - word, if you had multiple words, let's say email client 
184:16 - look I've capitalized the first letter
184:20 - of every word. Once again, this is called pascal naming convention
184:24 - and it comes from the old pascal language that you might have heard of.
184:28 - So, back to our point class. Here we add 
184:32 - a colon which means we're going to define a block, now
184:36 - in this block we can define all the functions or methods that belong 
184:40 - to points, for example, we can define a function called 
184:44 - move for moving a port, now note that as soon as we
184:48 - type open parenthesis, pycharm automatically adds self here, 
184:52 - this is a special keyword and we're going to get back to this shortly. 
184:56 - So, for now, in this method, let's print 
185:00 - move on the terminal, now let's define another 
185:04 - method like draw, so define draw 
185:08 - and in this method, let's print draw on the terminal, now
185:12 - let's remove the indentation, we're done 
185:16 - with the definition of our point class, so we need to add two line breaks 
185:20 - okay, so with this class we defined a new 
185:24 - type with this new type we can create new objects, so
185:28 - an object is an instance of a class, a class simply defines 
185:32 - the blueprint or the template for creating objects, and 
185:36 - objects are the actual instances based on that blue print. 
185:40 - So we can have tens of hundreds of points on the screen, these are the
185:44 - objects or the instances. So to create an object,
185:48 - we type out the name of our class and then call it like a function 
185:52 - this creates a new object and then returns it. So then we can store
185:56 - that object in a variable, let's call that point 1, 
186:00 - there you go, now when we use the dot operator. 
186:04 - Look, we have these two methods that we 
186:08 - defined, draw and move, we also have a bunch of other methods that we
186:12 - start with two underscores, these are called magic methods 
186:16 - we'll look at them later in the course. Now, let's call the draw method 
186:20 - of our point object, and run our program 
186:24 - so you can see draw is printed on the terminal. Now
186:28 - apart from methods these objects can also have attributes and these attributes
186:32 - are like variables that belong to a particular object. For example, 
186:36 - here, after we've defined .1. 
186:40 - We can set .1.x to 
186:44 - 10. And .1.1 to 20. 
186:48 - Now we can easily print out these attributes, let's print 
186:52 - .1.x and run our program one more time
186:56 - take a look, so the x coordinate of .1 is 10.
187:00 - Now we can create another object, let's call that.2 
187:04 - so .2 once again we type out the name 
187:08 - of our class and then call it like a function. Now this object is completely 
187:12 - different then the first object. So if you print 
187:16 - .2.x 
187:20 - look we get this attribute error, because this point object doesn't have an
187:24 - attribute called, so each object is a different 
187:28 - instance of our points class. Now here
187:32 - we can assign a value to .2.x. Let's 
187:36 - send that to 1, and then run our program so we can see the 
187:40 - x coordinates of .2 is 1. So to recap
187:44 - we use classes to define new types, these types can have 
187:48 - methods that we define in the body of the class and they can also 
187:52 - have attributes that we can set anywhere in our programs.
188:00 - You have learned how to create new types using classes 
188:04 - now therein a tiny problem in this implementation. 
188:08 - We can create a pooint object without an x or y coordinate
188:12 - let me show you. So point we create this
188:16 - object here, and before we set point.x let's
188:20 - print point .x run our program 
188:24 - we get this attribute error which you
188:28 - saw in the last tutorial, so point object has no attribute called x
188:32 - This is the problem we have here, it is possible, 
188:36 - to have a point object without an x or y coordinates. 
188:40 - And that doesn't really make sense, because whenever we talk about a point, 
188:44 - we ned to know where that point is located. To solve this problem, we
188:48 - use a constructor. A constructor is a function that gets called
188:52 - at the time of creating an object. So here on line 9, when creating this
188:56 - point object, we want to pass values for x or y 
189:00 - coordinates, let's say 10 and 20, and with this, 
189:04 - this point object that we get here, will have it's
189:08 - x and y coordinates initialized. So how do we do this?
189:12 - We need to add a special method in this class called constructor. 
189:16 - So, on the top, I define a new function, 
189:20 - look at the name of this function, double underscore init, double under
189:24 - score. So init is short for initialized, and this is the
189:28 - function or the method that gets called when we create a new point object. 
189:32 - Now, press enter, so this automatically adds, 
189:36 - self in parenthesis, we're going to come back to this shortly. 
189:40 - Now, right after self, we want to add 2 extra parameters, 
189:44 - x and y, so let's type out x and y, 
189:48 - and then in the body of this method, we should read the values past
189:52 - here, and use them to initialize our object, so when we pass
189:56 - 10 and 20, these arguments will be used for
190:00 - x and y parameters. Now to initialize 
190:04 - our object, we type our code like this. Self.x equals 
190:08 - x. And then self.y equals y. 
190:12 - What is going on here, this self that you see here is a reference to the current 
190:16 - object. So, back to line 13, 
190:20 - when we create a new point object, self references that object in
190:24 - memory, the same object, that we're referencing using this cariable.
190:28 - So earlier we typed point.x equals 10, 
190:32 - with this code we set the x attribute of this point object. 
190:36 - Now what we have in the constructor is exactly the same, we use the self 
190:40 - to reference the current object and then we set the x attribute 
190:44 - to the x argument passed to this function. So, 
190:48 - using this init method, we can initialize our objects and 
190:52 - we refer to this method as a constructor, this method is used to construct 
190:56 - or create an object, okay? so,
191:00 - Now, let's remove line 14, so we created
191:04 - point object with these values and then print point.x let's run our program 
191:08 - there you go, x is 10, we can also change 
191:12 - these values later, so just before printing point.x we can set 
191:16 - point.x to 11 and then run our program 
191:20 - so x is updated, beautiful, alright, here's a 
191:24 - exercise for you. I want you to define a new type called person
191:28 - these person objects should have a name attribute as well as a talk
191:32 - method. This is a very easy exercise so, 
191:36 - you can tackle it in probably a couple of minutes. 
191:40 - Alright, so
191:44 - first we start with a  class keyboard, we define this person class 
191:48 - once again look at the naming convention I have used here, the first letter
191:52 - of the first word in this case the only word is uppercase. 
191:56 - Now, in this class we define all the methods we need, currently we only have
192:00 - method that is the talk method, so define talk, 
192:04 - pycharm automatically adds self, we come back to this shortly, 
192:08 - for now let's just print talk. 
192:12 - So this is the body of our person class. We remove the indentation 
192:16 - and add two line breaks after defining our 
192:20 - classes. Now we can create the personal object, let's call that jon, 
192:24 - we set it to person, we can call jon.
192:28 - talk, let's run the program so we get this
192:32 - message, beautiful, but our person objects should also have
192:36 - a name attribute, it doesn't make sense to have a person without the name. 
192:40 - So that is when we use the constructor function. So on the top, 
192:44 - we add a new method, at the name of this method is double 
192:48 - underscore, init double underscore. So we
192:52 - call this method a constructor. Now in this method we need to
192:56 - add another parameter which is name, so we 
193:00 - simply set self.name to name. Once
193:04 - again, self references the current object, we're setting the name 
193:08 - attribute of the current object, to the name argument passed to this method. 
193:12 - With this we can go back to line 9, and 
193:16 - when creating a person object we pass the name, let's see jon smith 
193:20 - now let's print jon.name and run our program 
193:24 - there you go. So jon Smith is printed on the terminal, beautiful, 
193:28 - so this is all you had to do as part of this exercise. But
193:32 - let's make this program a little more interesting. Instead of printing
193:36 - this boring message here, let's print hi, I am Jon Smith. 
193:40 - So, we can use a formatted string with a message 
193:44 - like Hi, I am, now we want to dynamically
193:48 - add the name of this person. How do we do this? Well, look at 
193:52 - the parameter of this talk method. As I told you before, 
193:56 - every method in our class should have this parameter, self.
194:00 - And they should be the very first parameter of each method, okay? So, 
194:04 - with this self we can get reference to the current object, so
194:08 - we can add curly braces and type out self 
194:12 - .name. Thsi returns the name attribute of the current 
194:16 - person object. With this we can remove 
194:20 - line 10, where we print jon.name and simply call
194:24 - jon.talk. Lets run our program.
194:28 - Hi, I am Jon Smith. There we go, beautiful.
194:32 - Now we can build another person object, let's say Bob, is a new person 
194:36 - called Bob Smith, when we say 
194:40 - Bob.talk. And run our program 
194:44 - we get a different message, hi I'm Bob Smith, so
194:48 - each object is a different instance of a person class. 
194:56 - In this tutorial Im going to talk to you about inheritance in Python, 
195:00 - inheritance is a mechanism for using code and once again 
195:04 - it's no limited to python, most languages that support classes
195:08 - also support inherence. So let ms how you how this works. Let's say
195:12 - we have this dog class with a simple walk method, in this method
195:16 - we're simply printing the walk message on the terminal, now let's say
195:20 - in real program, instead of just one line of code here we're going to have 10 lines of
195:24 - code. Now, what if in the future we want to define a 
195:28 - another class let's say cat and we want to add 
195:32 - this walk method there as well. Sow e'll have to repeat all that code, 
195:36 - in this new class, walk. 
195:40 - This is bad. because you have repeated or duplicated our
195:44 - code. In programming we have a principle called dry
195:48 - which is short for don't repeat yourself. 
195:52 - Let's say sometime in the future, we discover a problem with our walk method. If you
195:56 - have repeated or duplicated this method in many other places, then we'll 
196:00 - have to come back and fix that problem in every single place we have
196:04 - duplicated this code. So that's why in programming we should not define something 
196:08 - twice. So how can we solve this problem. 
196:12 - There are different approaches, one approach that is easier to understand for beginners is inherence 
196:16 - Now here's how it works. We define a new class called
196:20 - maml and move the walk method right there. Then we'll have
196:24 - the dog and cat classes inherit that method
196:28 - from their parent just like how humans inherit certain
196:32 - attributes or behaviors form their parents. That' exactly the same, so
196:36 - on the top, we define a new class, let's call it
196:40 - mammal then we need to move the walk method there. So, 
196:44 - we select it, cut it, using command and x on Mac, or
196:48 - control x on Windows and then paste it here, beautiful, 
196:52 - now we want our dog class to inherit this class from the mammal class
196:56 - so right after the class name we add parenthesis and 
197:00 - then type out the name of the parent class. In this case, mammal.
197:04 - That's all we have to do. So with his the dog class
197:08 - will inherit all he methods defined in the mammal class. 
197:12 - Now there is a tiny problem here, if you look at line 9, there is a 
197:16 - red underline here. The reason this is happening is because
197:20 - python doesn't like an empty class, so right now our dog
197:24 - class is empty, it doesn't have anything, we either need to add methods
197:28 - specific to dogs or just to make Python happy, 
197:32 - we can use the path statement, and that basically means nothing.
197:36 - We're telling python interpreter, hey, pass this line, don't worry about it. But with this, we
197:40 - don't have an empty class, okay? Now as I told you before
197:44 - after each class I should have two line breaks so right now we 
197:48 - only have one line break and that is the reason we have this little warning here, so let's add
197:52 - another black line, beautiful, so our dog class is
197:56 - inheriting the walk method from the mammal, you need to apply the same change 
198:00 - to the cat class. So we'll have cat 
198:04 - inherit from mammal, and then, 
198:08 - use the path statement here. With these changes, 
198:12 - now we can create either a dog or  cat object, let's say dog, 
198:16 - one, we set it to a dog object, and 
198:20 - when we type dot look we have the walk method that is defined 
198:24 - in the mamall class. We can easily call it, let's run our program
198:28 - there you go, you see the walk message, 
198:32 - so both the dog and cat classes are inheriting all the classes
198:36 - methods defined in their parent class. Now here we can add methods
198:40 - specific to dogs, for example, we can define a method called 
198:44 - bark, and then print bark. 
198:48 - Now, we don't need the path statement because we already defined 
198:52 - one method in our dog class. So now when we type out 
198:56 - dog1. look we have two methods
199:00 - one is the walk method that we inherited and the bark method that we just
199:04 - defined in the dog class. Similarly, we can add a method 
199:08 - specific to a cat, for example, we can define a method called
199:12 - be annoying, I hate cats, so let's print
199:16 - annoying , now when we create the cat
199:20 - object, let's remove that, cat1
199:24 - and type out cat1. you have these two methods 
199:28 - dog and be annoying. So these are the basics of inheritance in python
199:32 - Now there is more to this that really goes beyond the scope of this beginners tutorial. 
199:36 - If you're interested to learn more about inheritance and other mechanisms 
199:40 - for reusing code, I encourage you to get my complete Python course.
199:48 - In this tutorial, I'm going to talk to you about modules in python. 
199:52 - A module in python is basically a file with some python code. 
199:56 - And we use modules to organize our code into files. 
200:00 - Just like sections in a super market. When you go to a super market there are different sections
200:04 - for fruits, vegetables, cleaning products, and so on. We don't have 
200:08 - one section with all the products in the super market. We have the same concept
200:12 - in programming. So instead of writing all our code, instead of writing
200:16 - all the functions and classes in app.py we want to break up our code
200:20 - into multiple files. We refer to each file as a module. 
200:24 - With this, not only is our code better organized and structured, 
200:28 - but we'll also have the ability to reuse our code. For example, 
200:32 - over here in app.py, I've defined two functions for converting
200:36 - weight from pounds to kilograms and vice versa. 
200:40 - Now we can take these two functions and put them in a separate module
200:44 - called converters, and then we can import that module into any
200:48 - program that needs these converter functions. Let me show you how to do this.
200:52 - So, let's open up our project panel and right
200:56 - click the project, go to new, and add the new file, 
201:00 - we're going to call this file, converters.py. 
201:04 - Then, we go back to app.py 
201:08 - select all this code, cut it and then 
201:12 - paste it into our new module. converters.py. 
201:16 - With this we have cleaned up our app module it's not bloated with different
201:20 - functions, so as we write more functions with classes, we put them in their 
201:24 - corresponding modules, a module should contain all the related
201:28 - functions and classes, okay? Now you want to
201:32 - import the converters module into our app module, and that is really easy, on the
201:36 - top we write import converters 
201:40 - without extension, so we don't add .py we only type out the name of
201:44 - the file. Let me close that project panel. Now, 
201:48 - this converter is an object so we can use the dot operator
201:52 - to access it's members. So currently we have defined 
201:56 - these two functions inside of our module, kilogram to pound, 
202:00 - and pounds to kilograms. So we can easily call one of these functions 
202:04 - let's pass 70 kilos get the result and print it out. 
202:08 - Run our program, so, 
202:12 - that is under 55 pounds. Now there is also another
202:16 - syntax for importing modules, let me show you, so
202:20 - instead of importing the entire module we can import specific functions from that 
202:24 - module. Here's how it works. We type out from 
202:28 - then we add the name of our module, so converters 
202:32 - import, now here if you press control and space
202:36 - we can see the list of all the functions defined in this module. 
202:40 - So here we can grab one of these functions let's say kilogram to pound, and 
202:44 - with this we can directly call this function just like
202:48 - the function defined in this file. App.py. Compare
202:52 - what we have on line 4 to what we have on line 6. On line 6
202:56 - we'll have to prefix this function with the name of an object 
203:00 - converters. So we have to type converters. and then we'll be able to
203:04 - access this function. In contrast. When we import 
203:08 - a specific function from our module, then we can easily call that function
203:12 - without prefixing it with the module name. So here's what
203:16 - you need to take away.  We use modules to better organize our code. Instead of
203:20 - writing all the code, instead of writing all the functions in one file, you break up
203:24 - our code across multiple files. Each file is called 
203:28 - a module and it should contain all the related functions and classes 
203:32 - then we can import a module into another module, in this case, we are importing 
203:36 - the converters module into our app module. And as you saw, 
203:40 - there are two ways to import this module, we can import the entire module, and then
203:44 - we'll get an object with the same name as the module so we can
203:48 - type converters . and then we'll be able to access all the
203:52 - functions and classes defined in this module. The other appraoch
203:56 - is to impot a specific function or class from a module using the
204:00 - from import statement. Now here
204:04 - is your exercise. Earlier in the course you had an exercise for finding the
204:08 - largest number in the list. So here on the top we have
204:12 - a list of numbers, initially we set max to the first number in this list
204:16 - then, we look through this list, get each number, 
204:20 - if the current number is grater than max, then we reset max. 
204:24 - And finally when we are done with our loop we print max on the terminal. 
204:28 - Now here's what I want you to do. This code currently 
204:32 - has no organization. We don't have any functions, we don't have any modules, we wrote all 
204:36 - the code in app.py, that is okay for small programs, 
204:40 - but as your programs grow, you need to properly organize your code into
204:44 - classes and modules. So, as part of this exercise, I want 
204:48 - you to write a function, call it find max. 
204:52 - This function should take a list, and return the largest number in that list. 
204:56 - Now after you do this, go ahead and put this function 
205:00 - in a separate module. So extract it from here, and put it in a module, 
205:04 - called utils. So in this module we're going to have a bunch of 
205:08 - utility functions, oaky? Then import the utility 
205:12 - module into the current module and call this function. 
205:16 - Finally, get the result and print it on the terminal, this is a 
205:20 - fantastic exercise to teach you how to properly organize your code. So, 
205:24 - go ahead and spend a couple minutes on this exercise. 
205:28 - So the first
205:32 - step is to define a function called find max. So on the
205:36 - top, I'm going to define function, find max
205:40 - this function should take a list of numbers, so we
205:44 - add a parameter called numbers. Now inside of this function you
205:48 - want to have these few lines, this is the algorithm for finding the 
205:52 - largest number in a list, we don't want to bring the first line, because this
205:56 - is where we create a list. So somewhere in our program we're going to create this list, 
206:00 - and tehen pass it as an argument to pass max 
206:04 - function. Okay? So, let's go ahead and grab
206:08 - these few lines, cut them, and put them inside
206:12 - of find max function. Alright, so we find the
206:16 - largest number in this list, finally we need to return it, so, 
206:20 - return max. So here's our function. Now we
206:24 - need to move this into a separate module. So let's go to the panel 
206:28 - right click the project and add a new 
206:32 - file, we can also add a new python file that's the same, let's call that
206:36 - utils so if you add a new python file 
206:40 - pycharm automatically adds .py extension, but if you go to
206:44 - new file we'll have to explicitly type out 
206:48 - .py. So make sure to get the extension right. 
206:52 - Now, back to app.py, let's cut this code and 
206:56 - paste it into this new module, okay beautiful. 
207:00 - Now I'm going o go back to app.py and import our new module. 
207:04 - We can either import the entire module, so import utils 
207:08 - and then access individual functions so we can call utils 
207:12 - .find max or we can explicitly 
207:16 - import this function from the utils module. It doesn't really make a difference. 
207:20 - So, we could type from utils
207:24 - import find max. And then we
207:28 - don't need to prefix this with the name of it's object, so we simply call
207:32 - find max. Now we need to call this after we initialize our list.
207:36 - So first we need to define the list of numbers. 
207:40 - Then, we pass that list as an argument to find max
207:44 - we get the result which is max and finally we print it
207:48 - on the terminal. let's go ahead and run our program, so the
207:52 - largest number is 10, beautiful, 
207:56 - now one last thing before we finish this tutorial, here we have this little warning 
208:00 - under max and the tool tip says shadows built in name 
208:04 - max. The reason we see this is because we actually have a function called 
208:08 - max. And it does the exact same job 
208:12 - as our find max function. So this is actually built into python. 
208:16 - But I ask you to do it as an exercise because it's a great exercise for beginners. 
208:20 - Now, back to the warning, this warning is basically telling us that we are
208:24 - overwriting the built in max function in python 
208:28 - so we are changing the meaning of this function, and this is considered a bad practice, 
208:32 - let me show you what I mean. So let's comment out what we have on line 4, 
208:36 - by putting a hash sign here, we can also use, 
208:40 - a short cut command and slash on Mac, or control on slash
208:44 - on Windows. So now this line is commented out. Look at the
208:48 - color of max here, it's purple, it's the same color as print. And this is the color
208:52 - used to identify the built in functions. So now we can call
208:56 - this function and give it a list of numbers 
209:00 - run our program we get the same exact result however, 
209:04 - if we bring this line back, once again we can use the same 
209:08 - shortcut that is command and slash on Mac or control slash on Windows. 
209:12 - Now, we are redefining max, so up to
209:16 - this line, max used to be a function, but after line 4 is executed 
209:20 - max is set to an integer, that is the largest number in this list. 
209:24 - So, we'll no longer be able to call it on line 5, 
209:28 - let's run our program and see what happens. So there you go, 
209:32 - we get this type error, int object is not 
209:36 - callable, because max is now an integer, it's not a function, 
209:40 - so we cannot call it. So to solve this problem, we can rename 
209:44 - this variable to something else. So right click here. 
209:48 - Go to refactor and rename, 
209:52 - and rename this to maximum.
209:56 - So you can see the warning is gone. As you can see we have the same warning 
210:00 - in our utils module. So here we're redefining max 
210:04 - and as I told you before this is a bad practice. We're changing the 
210:08 - meaning of built in functions in python. So, 
210:12 - let's rename these as well, I'm going to use the short cut that is shift and 
210:16 - f6 there you go and here we can change this to 
210:20 - maximum. Enter, done. 
210:28 - In this tutorial we're going to talk about packages in python, 
210:32 - packages are basically another way to organize our code, so currently
210:36 - we have only 3 files for modules in our project but a real project 
210:40 - can contain hundreds or even thousands of modules. 
210:44 - We don't want to add all those modules here, because over time this directory will get 
210:48 - bloated with so many files, so a better approach is to organize related 
210:52 - modules, inside of a package, so a package is a container 
210:56 - for multiple modules In file system terms a package is 
211:00 - a directory or folder. So in our project we can add a new directory 
211:04 - and in that directory we can add all the directed modules, as a metaphor think
211:08 - of a mall. When you go to a  mall or a shopping center there are different 
211:12 - sections for mens women and kids clothing, so that is
211:16 - ilke a package, now when you go to the mens section, there are different areas
211:20 - fior different kinds of products, we have a section for shoes, t shirts, 
211:24 - jackets, and so on, so each of these is like a module, so, 
211:28 - in this tutorial, I'm going to show you how to create and use packages in Python, 
211:32 - here in our project panel, right click the panel and
211:36 - add a new directory. 
211:40 - Let's call this directory e commerce. So we're going to create
211:44 - a package called e-commerce and in this package we're going to have
211:48 - all the modules related for an ecommerce application. For example, 
211:52 - we can have modules for sales, shipping, customer service 
211:56 - and so on. So let's go ahead 
212:00 - Now here we have an empty directory, in order to convert this to a package 
212:04 - we need to add a special file in it. So, right
212:08 - click this directory and add a new python file, 
212:12 - call that file double underscore in it, double underscore 
212:16 - this is a special convention in Python. 
212:20 - When Python interpreter sees a file with this name and 
212:24 - name in a directory, it treats this directory as a package, we also have a 
212:28 - shortcut for that in pycharm so let me delete this directory 
212:32 - and start again. So delete, once again right click 
212:36 - the project, and go to new but instead of creating a new directory 
212:40 - we can create a new python package, let's call
212:44 - our package ecommerce as you can see 
212:48 - pycharm automatically creates this file for us so we don't have to manually create
212:52 - it. Okay? Now, in this package, let's add a new module, 
212:56 - so a new python file, let's call it
213:00 - shipping okay? Now in this module we want to have 
213:04 - a function for calculating the shipping costs. So define 
213:08 - calculate, underline, shipping. 
213:12 - Now don't worry about parameters or implementation, we simply print 
213:16 - calculate underline shipping. 
213:20 - Now lets say you want to import this shipping module 
213:24 - into our app module, with this new structure this shipping 
213:28 - module is now part of the ecommerce package, so we cannot import a direct 
213:32 - you have to start from the ecommerce package. So, 
213:36 - bak to app,py once again there are two ways to import this module. 
213:40 - We can import the entire module or we can 
213:44 - import one of it's functions or classes. So let me show you both approaches. 
213:48 - First, we're going to import the entire module. Now what is the name of our 
213:52 - package? it is ecommerce, right? So ecommerce.
213:56 - shipping. So instead of typing import 
214:00 - shipping we type import ecommerce 
214:04 - .shipping. we have to prefix it with the name of it's package. 
214:08 - Now to access any of the functions or classes in this module 
214:12 - we'll have to type out ecommerce.shipping.
214:16 - and there you go. Now we can access the calculate shipping 
214:20 - function. So let's go ahead and run our program, 
214:24 - we see this message printed on the terminal, beautiful. However 
214:28 - with this approach, every time you want to call one of the functions
214:32 - to this module, we'll have to prefix it with ecommerce.
214:36 - shipping. that is very verbose. So when working with packages 
214:40 - we often use the second approach, using the
214:44 - from statement. So we can type from ecommerce 
214:48 - .shipping import 
214:52 - calculate shipping. Now we don't have to prefix this function
214:56 - with ecommerce.shipping, and we can call it multiple times 
215:00 - in this module, so our code is a little bit shorter. But what if
215:04 - you want to use multiple functions in this shipping module. We can either import them here,
215:08 - so calculate shipping, comma, let's say calculate_
215:12 - tax. Or we can import the entire module and then 
215:16 - access all he functions or classes in that module. So, 
215:20 - let me revert this back. To import the entire module 
215:24 - we type from ecommerce so we remove.shipping 
215:28 - so from this package, import 
215:32 - the shipping module. Now the shipping module, 
215:36 - is an object so we can access 
215:40 - all the functions and classes defined here, using the dot operator, so
215:44 - shipping. there you go, calculate shipping. So to 
215:48 - recap, when using the from statement we can either start from 
215:52 - the package and import a specific module, or we can
215:56 - start from package.module 
216:00 - and then import a specific function. Like calculate shipping. 
216:04 - So, this was the basics of using packages in 
216:08 - python. As I told you before, packages are extremely important, especially 
216:12 - when you want to work with a framework like django, we use django for building 
216:16 - web applications with python, and I'm going to show you that later in this course. 
216:20 - So in Django we have quite a few packages and 
216:24 - each package contains several modules. So make sure to watch the tutorials, 
216:28 - about modules and packages one more time, otherwise you're going to get confused later 
216:32 - when we get to Django. 
216:36 - In this tutorial I'm going to talk to you 
216:40 - guys about the built in modules in python, so python 
216:44 - comes with a standard library that contains several modules for common
216:48 - tasks such as sending emails, working with date and time, 
216:52 - generating random values and passwords and so on. There are so many modules 
216:56 - already built into Python and that means there is already lots of functionality 
217:00 - that we can reuse. Let me show you where you can find 
217:04 - this standard library. So open up this browser
217:08 - and search for python 3, module index, 
217:12 - make sure to add the version number, because the modules in python 2 are
217:16 - different from modules in python3. So here we search for python 3 
217:20 - module index, and the first page here, you can see is
217:24 - python module index, or python 3, let's go ahead, 
217:28 - so these are all the modules built into python, 
217:32 - for example we have modules for working with date and time, 
217:36 - we have modules for sending emails for encoding values, 
217:40 - there are so many modules here. Now the explanation of all these is 
217:44 - beyond the scope of this course, that really requires it's own course. 
217:48 - Because we have so many modules here, but don't let this list intimidate you. 
217:52 - This is not something that you need to learn right now, as you learn python 
217:56 - as you build more applications, gradually you will get familiar with more modules
218:00 - here, in fact nobody knows all the modules in python
218:04 - standard library. Everybody knows some modules based on the applications they have built. 
218:08 - So in this tutorial, I'm going to show you how to use one of the built in modules, 
218:12 - for generating random values. So on the top,
218:16 - we import the random module, now because
218:20 - random is a built in module, we don't need to have a file here 
218:24 - called random.py. So python interpreter knows that random is a built 
218:28 - in module as long as it knows where to find it. 
218:32 - Now if you're curious where this random module is stored on the disk, let me show you, so
218:36 - here in the project panel, expand external 
218:40 - libraries, then expand python 3, 
218:44 - and then one more time python 3.7 library 
218:48 - route. So this is a folder somewhere on your computer, in this folder, we have 
218:52 - all the built in modules in python. So, 
218:56 - if you scroll down, you should be able to find. 
219:00 - The random module. There you go. It's right here. So random.
219:04 - py. You can open this and this shows you the source 
219:08 - code of this module. there you go. Now in this tutorial, 
219:12 - we don't want to worry about hat, so let's go back to our app.py,
219:16 - and use this module to generate random values. So when we import
219:20 - this module, now we have this object, random, so we can use the dot
219:24 - operator to acces it's methods. One method that is useful
219:28 -  here is the random method, and every time we call it it generates
219:32 - a random value between 0 and 1. So here we can do a for loop, 
219:36 - let's say for I in, 
219:40 - range 3. So just to refresh your memory we are using the
219:44 - range function to create a range object. We can look through this range object 
219:48 - and in each iteration this object will spit out a value. 
219:52 - So with this for loop, we can execute this code 3 times. Now, let's 
219:56 - indent this. Okay, and finally, let's print the result, 
220:00 - There you go. So we can see
220:04 - that in each iteration we get a new random value between 0 and 1. 
220:08 - Now what if we want a random value for a particular age?
220:12 - Let's say random values between 10 and 20, well, 
220:16 - there is another method here, rand int, we use 2 arguments here
220:20 - to specify our range, let's say 10 and 20. 
220:24 - Run our program one more time. Now we have the numbers 20
220:28 - 13 and 18. If we run our program one more time, 
220:32 - We get different values, so 20, 19, 11, one more time. 
220:36 - Look, you also have another powerful method for 
220:40 - randomly picking an item from a list. Let's say we have a list of team members and you want to
220:44 - randomly pick someone as the leader. Let me show you how to do that. 
220:48 - So, we define the list of team members, we set it to
220:52 - jon, mary, bob, 
220:56 - and mosh. Now we can call random 
221:00 - .choice and pass our members list 
221:04 - this method randomly picks a method from this list and returns it. SO, 
221:08 - we can store the result in leader and then 
221:12 - print it on the terminal. let's run our program, 
221:16 - so now the leader is mary, if you run our program one more time
221:20 - this line is mosh now it's mosh again one more time, 
221:24 - it really likes mosh, you get the point. So
221:28 - the random module is very powerful, and it has a lot of applications. 
221:32 - Now here's a very cool exercise. I want you to write this program to 
221:36 - roll a dice. So every time we run this program we get a different value. 
221:40 - Now we have 3 in 1, next time we get 3 and 6, one more time 
221:44 - 5 and 6, 4 and 3, double one, that's a very cool exercise. 
221:48 - So before we get started, I want you to pay attention to a few things. 
221:52 - I want you to define a class called dice 
221:56 - in this class we're going to have a method called rope so every time we
222:00 - call this method, we get a tuple, a tuple remember is a list of 
222:04 - values but values cannot be changed, you cannot add a new item to it, we
222:08 - cannot remove it. So it's like a read only list. So every time, 
222:12 - we call the row method, we should get the tuple of two random values. 
222:16 - So go ahead, and do this exercise, You'll see my solution next. 
222:24 - Alright, we start by importing the random module on the top, 
222:28 - then we define a class called dice:
222:32 - this class we want to have a method called row. So define row 
222:36 - parenthesis, this automatically adds self, now in this method, 
222:40 - you want to generate two random values between 1 to 6. 
222:44 - So we call random.randint. 
222:48 - And pass 1 and 6. So this generates the first number, 
222:52 - we can ut that here, now let's call this one more time, 
222:56 - so I'm going to copy what we have on line 5, put it here, and 
223:00 - change this variable to second. So we have two variables first and second.
223:04 - With two random values, finally we need to return them, 
223:08 - in a tuple, so return parenthesis instead of square brackets, 
223:12 - first and second, now 
223:16 - in python when you want to return a python from a  function, you don't have to add
223:20 - this parenthesis, so you can simplify your code and python will automatically 
223:24 - interpret this as a tuple. So we are done 
223:28 - with a definition of our class, we remove the indentation and add 
223:32 - two line breaks. Now we create an object of this type 
223:36 - so you set dice to dice
223:40 - next we roll the dice, so dice.roll and 
223:44 - print the result on the terminal, that's all you have to do.
223:48 - Let's run this program, so now we get 2 and 5, 
223:52 - lets run it one more time, 3 and 2, 1 and 1, beautiful. 
223:56 - Now we have this little warning here, that says 
224:00 - expected 2 black lines found 1. Once again this is
224:04 - coming from pep 8, pep is short for python and 
224:08 - proposal. We have so many python enhancement proposals or peps.
224:12 - Pep 8 is a very famous 1, and in this document we have 
224:16 - all the best practices for formatting our code. So pep
224:20 - 8 says, that after we define our classes we should have 2 lines breaks, we've already done that
224:24 - so the reason this is complaining is because we had 1 line break before 
224:28 - the class, so let's add one more line break, now pycharm 
224:32 - is happy. So basically pycharm is following all the best 
224:36 - practices defined in pep8. Now you don't have to memorize 
224:40 - any of these best practices, as you code in pycharm, pycharm gives you a little more
224:44 - warning, and gradually you will learn how to properly format your code, so it's
224:48 - readable by other people. 
224:52 - In this tutorial, I'm going to show you
224:56 - how to work with directories in python. So here in python3, 
225:00 - module index, you can see we have a module called path lib which provides an object 
225:04 - oriented file system pact. That basically means it provides
225:08 - classes that we can use to create objects to work with directories and 
225:12 - files. So, if you click here, you can see how this module
225:16 - works, we can see all kinds of examples. For example, here on there basic 
225:20 - useage, you can see this is how we import the path
225:24 - class from the path lib module. Let me zooming so you can see
225:28 - clearly. Okay, so look, from path lib, that's
225:32 - our module, import path, note the naming convention. 
225:36 - P is capitalized, that means path is a class, so we need to create 
225:40 - an instance of this class as you can see, right here, 
225:44 - now there's so much documentation here, you can read this on your own, but let me quickly show you
225:48 - a few examples to help you get started. So after pycharm 
225:52 - on the top, from the path led module, that's
225:56 - import the path class. Now we need to create, 
226:00 - a path object to reference a file or directory 
226:04 - on our computer. So there are basically to ways to do this we can use an absolute
226:08 - path, or a relative path which basically 
226:12 - means a path starting from the current directory. For example, 
226:16 - if you wanna reference this ecommerce directory in our project, we can
226:20 - use the relative path. So we start from the current directory and then
226:24 - go somewhere else. With absolute paths we start from the root 
226:28 - of our hard disk. For example, if you're on Windows you might have 
226:32 - an absolute path like this, c drive, backslash, 
226:36 - program, files, backslash microsoft, 
226:40 - so these are directories in c drive. 
226:44 - On Windows we use a backslash to build a path. If you're on
226:48 - Mac or Linux, your paths will look a little bit different, so
226:52 - instead of backslash we have a forward slash lets say user/local
226:56 - /bin. So these are examples of absolute paths. In
227:00 - this tutorial we're going to work with he relative path to work with this ecommerce 
227:04 - directory that we have in our project. Now if you didn't create this directory 
227:08 - earlier, simply right click on the project and then go to new 
227:12 - directory. oaky? So, let's close this panel, 
227:16 - we create a path object, now, 
227:20 - if you don't pas an argument here, this will reference the current directory
227:24 - alternatively, we can pass string, in this string we can
227:28 - add a file or a directory. let's say the ecommerce 
227:32 - directory. Now this runs a path object, so we store it here, 
227:36 - now this path object has a few interesting methods 
227:40 - for example, we can check to see if a path exists by calling 
227:44 - the exist method. This simply returns a boolean so let's print it on the terminal, 
227:48 - there you go. So this path exists, 
227:52 - what if it changes to ecommerce 1, and 
227:56 - run our program and get false, we can also create a new directory 
228:00 - for example, let's change our path to email, now when we
228:04 -  run this program, obviously we don't have this directory but we can 
228:08 - create it by calling the mk dir method 
228:12 - so make directory. Let's run our program
228:16 - alright, this method returns none which basically means 
228:20 - it doesn't return any values. Now if you look at the project panel you can see
228:24 - here we have a new directory called emails, we can also delete this directory 
228:28 - so, instead of mk dir we call 
228:32 - rmdir which is short for remove directory, but 
228:36 - let's go ahead, now we can see that directory is gone. We can also see
228:40 - all the files and directories in a given path, that is, very useful if you want to
228:44 - write a little program to automate something. For example, 
228:48 - you can iterate over all the spreadsheets in a directory one them and 
228:52 - process them. Let me show you. First we change the path
228:56 - to the current directory and then we call the glob 
229:00 - method. With his method we cans each for files and 
229:04 - directories in the current path. So as the first argument we need to pass a string 
229:08 - that defines a search pattern. We can type an asterisk 
229:12 - and that means everything, all files and all directories. 
229:16 - We can optionally add an extension, so to get all the files, you
229:20 - need the files you use star.star. With this 
229:24 - pattern, we'll only get the files in the current directory. But not the directories. 
229:28 - We can also search for all the py files, or all the excel 
229:32 - spreadsheets. Anything. So let's search for all the py files 
229:36 - in the current directory, now when we run our program 
229:40 - we get this generator object. Generator object 
229:44 - are kind of an advanced topic, and they are beyond the scope of this beginners 
229:48 - python course. But for now all you need to know is we can iterate 
229:52 - or loop through these generator objects. So instead of 
229:56 - printing this generator object, let's just iterate over it using 
230:00 - a for loop, so, for, file in, 
230:04 - the generator object that is returned from the glob method. q
230:08 - Let's print file. 
230:12 - We run our program, there you go. So these are all the
230:16 - py files in my current directory, this could be different on your machine
230:20 - if you didn't follow the exercises I gave you earlier. For example, this
230:24 - utils.py, we created this as part of one of the exercises earlier in this course. 
230:28 - So don't worry if the files you see here are different on your machine. 
230:32 - So, you can use the glob method to search for files using 
230:36 - a pattern, we can also get all the files and directories in the current 
230:40 - path, so, we just use one asterisk, then
230:44 - run our program, take a look,  so we have this
230:48 - ecommerce directory, we have notes.txt, this is a file I 
230:52 - added earlier just to write notes as part of my presentation so you're not going to have
230:56 - this file. We also have a bunch of directories and files. 
231:04 - Even though python's standard library is comprehensive and has 
231:08 - so many modules for common tasks, it's not complete by any means. 
231:12 - That's why we have this directory called python package 
231:16 - index. Or pypi. And in this directory you can find hundreds 
231:20 - of packages for doing awesome things. These are packages that people like you
231:24 - and I have built as part of our projects, and then they have published it as part of this directory. 
231:28 - For other people to use. So that's why we have a fantastic community in python, 
231:32 - there are so many python developers out there and there are so many packages 
231:36 - right in front of us to reuse in our programs, let's say
231:40 - you want to send text messages in your programs, you don't have to build this functionality from scratch, 
231:44 - we can simply come to pypi.org and 
231:48 - search for sms aas you can see there are so many 
231:52 - projects or apckages that give you this functionality. Of course not every
231:56 - package, not every project is complete or bug free, some of them are still 
232:00 - in development or they have bugs, but if you look around I'm pretty sure 
232:04 - for any kind of function you can imagine there is a good 
232:08 - reliable and well documented package for you. In my complete python course, 
232:12 - I will show you some of those most useful packages on pypi. For example
232:16 - you will learn how to access the information on yelp.com in your
232:20 - programs. So you can write a program and search for businesses 
232:24 - registered on Yelp. Let's say you want to search for the best barber 
232:28 - in New York City. I will show you how to do that. You will also learn how to use a technique called 
232:32 - web scraping, which means you can build an engine and have that engine 
232:36 - browse a website, and extract information from HDML files.
232:40 - This is the same technique that Google does to index various
232:44 - websites. So they have several engines, or web crawlers, these web crawlers 
232:48 - are continuously looking at various websites and extracting information 
232:52 - from their pages. When you publish a blog post Google's web crawler 
232:56 - finds the title of your post, its keywords and so on. So, 
233:00 - I'm going to show you how to do that with Python, we'll also look at browser automation, and this is extremely 
233:04 - powerful, because you can automate testing of your web
233:08 - applications. So you might get a job as a test engineer, and 
233:12 - your daily job is to browse a website, click here and there, fill out this form, that form, and 
233:16 - ensure that this website is functioning properly. You can automate all that 
233:20 - with a powerful python package called selenium, as I have shown in my complete, as I show in my complete
233:24 - python course. Now in this tutorial, I'm going to show you how to install
233:28 - packages, from pypi.org. So, 
233:32 - here on pypi.org let's search for open py
233:36 - xl. This is a package that we use for working with excel 
233:40 - spreadsheets. So let's search for this package, there you go, so currently 
233:44 - it's at version 2.5. On the top you can see, 
233:48 - this instruction pip install open pyexcel. 
233:52 - this is the command that we need to type in the terminal window to
233:56 - install this package into our program, so back to pycharm, 
234:00 - here on the status bar. You can open up a terminal window for executing 
234:04 - various commands. So let's open it, now if you're on Windows 
234:08 - you're probably going to see something different instead of this dollar sign, don't worry about that
234:12 - just execute this command I'm going to show you. So pip
234:16 - install open py xl
234:20 - Make sure to spell everything properly. So pip is the tool, 
234:24 - that comes with a python installation, and we use it to install or uninstall
234:28 - packages registered on pypi.org. So here, 
234:32 - we're using pip to install this package. open py 
234:36 - xl. Enter, let's go ahead with that, it's going to take a few 
234:40 - seconds, oaky done, now we can import this package and it's
234:44 - modules just like the built in modules in python, or the modules that we have
234:48 - in our project. Now if you're curious where this package
234:52 - is stored on disc let me show you. So open up the project panel, 
234:56 - and then expand external libraries, next
235:00 - expand python 3, and then expand sight packages. 
235:04 - This is where all these packages that we installed with pip are stored. 
235:08 - So here we have open py xl, you can open this, 
235:12 - in this folder we have another folder called cell, now
235:16 - Now, look what we have here you have this init
235:20 - type, earlier I told you that whenever we add this file to a folder, python treats
235:24 - that folder as a package, so sell is a package, and this
235:28 - package we have is modules. Sell, interface, read only and text. 
235:32 - So as you can see, this package openpyxl has several
235:36 - subpackages like cell, start, chart sheet and so on. 
235:40 - And in each package we have several modules, in the next tutorial
235:44 - I will show you how to work with excel files. 
235:48 - So we have covered all the core concepts in Python, I hope you have learned a lot. 
235:52 - please support my hard work by liking this video and sharing it with others. 
235:56 - And be sure to subscribe to my channel for more tutorials like this. Next we're
236:00 - going to work on our first python project that involves automation. 
236:04 - You're going to write a python program that can process thousands of spreadsheets
236:08 - in under a second. Are you excited? Let's get started.
236:16 - In this tutorial I'm going to show you something really awesome you can do with python. You're going to 
236:20 - learn how to process spreadsheets, and this is extremely valuable
236:24 - in situation where you have hundreds or thousands of spreadsheets that need to
236:28 - be updated. If you want to do this by hand it may take hours or days 
236:32 - weeks, or even months, you can simply build a python program in less then 
236:36 - half an hour. And have that python program, automatically process thousands of spreadsheets
236:40 - in under one second. So, here we're going to work on this
236:44 - excel spreadsheet. You can download this below this video.
236:48 - In this spreadsheet we have three columns, transaction ID,
236:52 - product ID, and press. Now don't worry about the fourth column yet. 
236:56 - So in this spreadsheet we're going to record all kinds of transactions, but let's say
237:00 - due to an error, it could be a human error or a system error. The price that we have
237:04 - here is wrong. Let's say we need to decrease this by 10 percent. 
237:08 - If you want to do this manually, we'll have to come back here and 
237:12 - add a formula, so we typed out equal sign, let's say you want to recalculate
237:16 - say you want to recalculate the value of this cell.
237:20 - have to get that and then multiply it by 0.9
237:24 - and that is like 90% of the original price, we are reducing the original
237:28 - reducing the price by 10%. Now when you hit enter you can see the updated price. 
237:32 - Next we'll have to come back here, select this cell and
237:36 - apply the same formula to all the other rows. Now what if you have thousands of rows
237:40 - here? You'll have to scroll up and down, this is going to be very tedious. 
237:44 - So we're going to write a python program that will do this for us. It's going to
237:48 - auotmate this process and not only that it will also
237:52 - add this beautiful chart right here, 
237:56 - once again if you want to open up hundreds or thousands of spreadsheets 
238:00 - and add a chart to each one, this is going to take at least a week or two
238:04 - Our python program is going to do all of this in a matter of seconds.
238:08 - So, let's get started. Alright the first thing I want you to do is
238:12 - to download this transactions file and add it to your project. 
238:16 - I put the link below this video for you to download. So if you're wondering 
238:20 - how to put this in this project, you can simply right click the project, 
238:24 - and if you're on Mac you have this item where
238:28 - reveal in finder, if you're on Windows you should see something like reveal
238:32 - in explorer, or file explorer, or whatever it's called
238:36 - when you click this, this opens up the direct 
238:40 - on your machine where this is stored. So simply copy paste
238:44 - the transactions file right here. Now, 
238:48 - here on the top, first we need to import the open py excel package. 
238:52 - So import open py excel, we can give it a 
238:56 - an alias to make our code shorter. So asxl. 
239:00 - This is not required but it just makes our code a little bit cleaner. 
239:04 - Let me show you. So now instead of typing open pyxl.
239:08 - we type xl. okay so that's an alias for
239:12 - this package. Now in this package we have a function for loading an xl 
239:16 - workbook. So let's call load workbook, 
239:20 - and as the argument we pass transactions. 
239:24 - .xlsx. So this we load
239:28 - our excel workbook and return a workbook object. 
239:32 - Okay? Now if you open this workbook, you can see you add only 1
239:36 - sheet, and that is called sheet 1, so to access that you use 
239:40 - square brackets, and specify the name of the sheet, 
239:44 - that is sheet one, make sure to spell this with a capital 
239:48 - S. Because this is case sensitive, if you don't spell it properly 
239:52 - you're going to get an error, so this returns a sheet, 
239:56 - now in this sheet, we have various cells. So
240:00 - next you need to learn how to access a particular cell, and that is very easy.
240:04 - back to py charm, with this sheet object, you can use 
240:08 - square brackets and give the coordinate of a cell. 
240:12 - Coordinate is the combination of the column and the row. 
240:16 - For example, this cell it's coordinate is a1. 
240:20 - So back to pycharm, we can type a1, and this returns 
240:24 - our first cell. Also, there is another approach to getting
240:28 - a cell, instead of using square brackets with a string, we can
240:32 - use the cell method of the sheet object, so, 
240:36 - sheet.cell, you pass the row and the column, so row 
240:40 - and column 1 these return the exact same 
240:44 - cell. Now let's print the value of this cell, cell.value
240:48 - and run our program so 
240:52 - the value is transaction id, beautiful, 
240:56 - so now we need to iterate over all these rows and for each row we need to get the value 
241:00 - in the third column. That is the price. We'll get that and then multiply 
241:04 - by 0.9. So first we need to know how many rows 
241:08 - we have in this spreadsheet. We can get that from the sheet object so sheet
241:12 - has an attribute called mx_
241:16 - row. Let's print this, so in this sheet, 
241:20 - we have 4 row, and you can verify that here. So we have
241:24 - a total of 4 rows. So we need to add a for loop.
241:28 - that would generate the numbers 1-4. So, 
241:32 - let's delete this print statement, nd add a for loop 
241:36 - for row in were going to use the range function unction to generate a range of numbers, 
241:40 - starting from 1, all the way to sheet 
241:44 - .max_grow. Plus 1. The reason we're 
241:48 - adding 1 to this, is because as I told you before this range function 
241:52 - will generate numbers, starting from this value all the way to this
241:56 - value, but it will not include the second value. So currently 
242:00 - max row returns 4, if you use range of 1-4 this will generate 
242:04 - the numbers 1, 2, and 3, but not 4. 
242:08 - So to include 4, we need to add 1 to it. Let's go over here, 
242:12 - so we tied sheet.max underline row plus 1. 
242:16 - Now before going any further let's just print row and make
242:20 - sure our program is working up to this point. So let's run 
242:24 - this, we get the numbers 1-4 beautiful. 
242:28 - So now we can easily get the cells in the third column. However
242:32 - we don't really want this first cell, that's the heading. 
242:36 - so technically you want to ignore the first row. Back here, you want to change 
242:40 - our range function, and start from 2. Now, 
242:44 - we're going to use sheet.cell to get access to the cell
242:48 - at this row. And the column should be 3. 
242:52 - We get a cell object, let's print it's value
242:56 - and make sure you're on the right track, so run the program
243:00 - these are the values we get. 5.95
243:04 - 6.95 and 7.95 these are the
243:08 - values of the third column. Next we need to multiply each
243:12 - value by 0.9 so instead of printing 
243:16 - cell.value we multiplied by 0.9 and this is
243:20 - the corrected underline price, 
243:24 - so this is the mistake we're going to make with our program, now
243:28 - we need to add a new cell to our worksheet, so we want to add all the corrected
243:32 - prices, ia  new column, it could also overwrite the values in this column, 
243:36 - but in this tutorial I'm going to show you how to add a new column.
243:40 - So using the same method, now we need to get a reference to the cell, to the given 
243:44 - row, but in the fourth column. So, we call sheet
243:48 - .cell, and pass row and four as the arguments. 
243:52 - Once again, this returns a cell object, let's store that in a 
243:56 - separate variable and call it
244:00 - price_cell. So note that my variable names are 
244:04 - very descriptive. There is no guess work. You have corrected price which holds
244:08 - actual value and we have corrected price, which is a cell
244:12 - object in this spreadsheet. Next we have to set the value in this
244:16 - cell. So we set corrected price cell.
244:20 - value to this corrected price. With these few lines 
244:24 - we can easily update our spreadsheet, but first we need to save it. So, 
244:28 - after our for loop, we call workbook.
244:32 - save. Now let's save this in a new file because we don't want to
244:36 - accidentally overwrite the original file in case our program has a bug
244:40 - so, I'm going to call that transactions 2.sms 
244:44 - ex. And finally let's run our program, 
244:48 - so, you can see that happened in a split of a second, now here we have a new file
244:52 - tranactions 2. When we open this we get something like this. 
244:56 - So you can see we have this 4th column with the updated prices. Beautiful.
245:00 - So half of the problem is solved, now we need to add a chart here.
245:04 - To add a chart, we need to add a couple classes on the top, so, 
245:08 - after this import statement let's type out from 
245:12 - open py excel.chart, import, bar chart, 
245:16 - comma, reference. 
245:20 - So lets see what's going on here. In this package you have a module 
245:24 - chart, and from this module we're importing two classes, bar chart, 
245:28 - and reference. Again, look at the naming convention used 
245:32 - here. The first letter of e very word is capitalized. Also it's better
245:36 - to add a line break after our import statements to make our
245:40 - code cleaner. So, before we save our workbook, we need to
245:44 - add achart to the current sheet. First we need to select a range 
245:48 - of values. For this exercise, I'm going to select the values in the fourth column/.
245:52 - So all the values in rows 2-4 these are
245:56 - the values I'm going to use in our chart. Now in this part 2 example it doesn't really
246:00 - make sense to add a chart per transaction, but that doesn't really matter
246:04 - we just want a bunch of numbers to create a chart, so after our
246:08 - for loop, we're going to use the reference class to select a range of
246:12 - values. Now the first argument in the constructor is the
246:16 - sheet. So we pass our sheet here, then we add
246:20 - 4 keyword arguments, the first one is min_row, we set this to
246:24 - 2. The second one is max_row we set
246:28 - this to the maximum row in this sheet. That is sheet, 
246:32 - .max_row, so we want to select the cells in row
246:36 - 2-4. kay? Now to make this code a little bit cleaner 
246:40 - I'm going to put this on a new line, so we
246:44 - can see clearly, now this is going to select all the cells 
246:48 - in all the columns in these rows. That's not what we want. 
246:52 - we only want the values in the fourth column, so back here
246:56 - we need to set a couple more key word arguments men_call
247:00 - or column, we set that to for, and also 
247:04 - max underline call, we set that to 4 as well. So we are limiting the range
247:08 - of cells we're selecting to the fourth column. 
247:12 - Now, we're creating an instance of the reference class, let's store the
247:16 - result in a variable called values, so this values object 
247:20 - will have all these values in the fourth column, now we are ready to create 
247:24 - a chart, so we create an instance of the bar chart class
247:28 - and store it in this object. 
247:32 - Next, we call chart.add_date and 
247:36 - pass our values. That is pretty straight forward finally we need to add this chart 
247:40 - to our sheet. So, we call sheet, 
247:44 - .add_chart and pass this chart object 
247:48 - We should also specify where we want to add this chart.
247:52 - let's say we want to add it here, on row 2, after the fourth column. 
247:56 - So the coordinate of this cell is e2, and this is going to be, 
248:00 - the top left corner of our chart. So as the coordinate I'm going to
248:04 - pass e2 that's all we had to do, done. Let's run our
248:08 - program one more time, beautiful, let's open up the update
248:12 - workbook. And here's the end result, so
248:16 - right after the fourth column, we have this beautiful chart. Now we could take this to the next level, 
248:20 - we could add a legend here, we could change the color of these bars, we could even use a different 
248:24 - kind of chart, it doesn't have to be a bar chart. So to learn more about this we can
248:28 - read the documentation for openpyxl. So
248:32 - our program is complete, for our code is dirty, it's not clean, it's not 
248:36 - organized. We don't have any functions here. We have written all the code in app.py. 
248:40 - So let's goo ahead and organize this code like a professional software developer. 
248:44 - So, on line 4, we are loading our workbook 
248:48 - then we're getting a reference to the first sheet, but we don't really need these two lines here 
248:52 - this is purely for demonstration to show you how to access a cell. So, 
248:56 - let's delete these unnecessary lines, this is a very important practice
249:00 - as you're coding always look at your code, always review it, see if you have some code that is
249:04 - not used. Always delete those. Okay, next we are iterating over 
249:08 - all the rows, fixing the prices, and then 
249:12 - we select the values to add a chart, and finally we save the workbook. 
249:16 - Now, if you were going to use this to automate the process of updating
249:20 - thousands of spreadsheets, this program wouldn't work, because it's only 
249:24 - relying on this file. So we want o reorganize this code, and 
249:28 - move it inside of a function. This function should take the name of a function
249:32 - So let's define a function. Let's
249:36 - call it process_workbook. 
249:40 - It gets a file name. Now, we move all the code inside 
249:44 - of this function, so let's select everything, and press
249:48 - tab, beautiful, now back
249:52 - to our function, instead of loading this transactions file we're going to load
249:56 - this file name, that's better, 
250:00 - Also, now that our program is working properly, there is really no need to store the
250:04 - result in a separate file. So here we can
250:08 - simply overwrite the same file. So let's pass
250:12 - file name, that is the end of our function, so, 
250:16 - now, we have this reusable function, we can simply reuse this
250:20 - to process thousands of spreadsheets. Earlier in this python course you learned 
250:24 - how to find all the files in a  directory, so we can get each file in a directory 
250:28 - and pass the name of the file to this function, this function will go
250:32 - ahead and update this spreadsheet in just a second or less. 
250:36 - So, that was just one example of using python to automate 
250:40 - repetitive boring task that waste your time. But automation is not
250:44 - just about processing excel spreadsheets, there are so many things we can automate. 
250:48 - Here's a question for you, what do you want to automate, how do you want to use python to make your
250:52 - life easier? Use the comment box below and let me know. I love to
250:56 - hear about your ideas. Next we're going to work on  project which involves machine learning, which is a 
251:00 - subset of artificial intelligence. Are you excited? 
251:04 - Let's get started. 
251:08 - In this section, you're going to learn about machine learning, which is a subset of
251:12 - AI or artificial intelligence. It's one of the trending topics in the world, 
251:16 - these days, and it's going to have a lot of applications in the future. Here's an example.
251:20 - Imagine I ask you to write a program to scan an image, and
251:24 - tell if it's a cat or a dog. If you want to build this program using
251:28 - traditional programming techniques, your program is going to get overly complex 
251:32 - You will have to come up with lots of rules to come up with specific curves
251:36 - edges and colors in an image to tell if it's a cat or a dog. 
251:40 - But if I give you a black and white photo, your rules may not work, they may break.
251:44 - Then you would have to rewrite them. Or I may give you a picture of a cat or a dog from a different
251:48 - angle that we did not predict before. So solving this problem 
251:52 - using traditional programming techniques is going to get overly complex or
251:56 - sometimes impossible. Now to make the matter worse. What if I ask you to extend
252:00 - this program such that it supports 3 kinds of animals. 
252:04 - Cats, dogs, and horses, once again you will have to rewrite 
252:08 - all those rules. That's not going to work. So machine learning is a technique 
252:12 - to solve these kinds of problems, and this is how it works. We build
252:16 - a model or an engine and give it lots and lots of data. 
252:20 - For example, we give it thousands or tens of thousands of pictures of 
252:24 - cats and dogs. Our model will then find and learn patterns and the input 
252:28 - data, so we can give it a new picture of a cat that we haven't seen before. 
252:32 - And ask it, is it a cat or a dog or a horse 
252:36 - and it will tell us with a certain level of accuracy, the more input data we give it, the more accurate
252:40 - our model is going to be. So that was a very basic example,
252:44 - but machine learning has other applications in self driving cars, 
252:48 - robotics, language processing, vision processing, 
252:52 - forecasting things like stock market trends and the weather, games and so on.
252:56 - So that's the basic idea about machine learning. Next we'll look at machine 
253:00 - learning in action. 
253:04 - A machine learning project involves 
253:08 - a number of steps, the first step is to import our data which
253:12 - often comes in the form of a csv file. You might have a database with lots of data, 
253:16 - we can simply export that data and store it in a csv file for the
253:20 - purpose of our machine learning project. So we import our data, next, 
253:24 - we need to clean it. And this involves tasks such as duplicated data.
253:28 - If you have duplicates in the data, we don't want to feed this to the model, because
253:32 - otherwise our model will learn bad patterns in our data and will produce the wrong result, 
253:36 - so we should make sure that our input data is in a good, and clean shape.
253:40 - If there is data that is irrelevant we should remove them, if there are duplicates
253:44 - or incomplete we can remove or modify them, if our data is 
253:48 - text based, like the name of countries, or genres of music, 
253:52 - or cats and dogs, we need to convert them to numerical values. 
253:56 - So this step really depends on the kinds of data we're working with, every project 
254:00 - is different. Now that we have a clean data set, we need to split it
254:04 - into two segments. One for training our model, and the other for
254:08 - testing it, to make sure our model produces the right result.
254:12 - For example, if you have 1,000 pictures of cats and dogs, we can reserve
254:16 - 80% for training, and another 20% for testing. 
254:20 - The next step is to create a model, and this involves selecting 
254:24 - an algorithm to analyze the data. There are so many machine learning algorithms 
254:28 - out there, such as decision trees, neural networks and so on.
254:32 - Each algorithm have pros and cons in terms of accuracy and performance 
254:36 - so the algorithm you use, depends on the kind of problem
254:40 - you're trying to solve and your input data. Now the good news isnthat we don't have to
254:44 - explicitly program an algorithm, there are libraries out there that provide these
254:48 - algorithms, one of the most popular ones, which we are going to look at 
254:52 - in this tutorial, is side kick learn. So we build a model using an algorithm , 
254:56 - next we need to train our model. So we feed it our training data. 
255:00 - Our model will then look for the patterns in the data, so enxt
255:04 - we can ask it to make predictions. Back to our examples of cats and dogs, 
255:08 - we can ask our model is this a cat or is this a dog and our model 
255:12 - will make a prediction, now the prediction is not always accurate
255:16 - in fact when you start out, it's very likely your predictions are inaccurate. 
255:20 - So we need to envalue the predictions and measure their accuracy. 
255:24 - Then we need to get back to our model and either select a different algorithm 
255:28 - that is going to produce a more accurate result for the kind of problem 
255:32 - we're trying to solve. Or fine tune the parameters of our model.
255:36 - So each algorithm has parameters that we can modify to optimize the
255:40 - accuracy. So these are the high level steps that you follow in a machine learning 
255:44 - project. Next we'll look at the libraries and tools for machine learning. 
255:52 - In this lecture we're going too look at the popular python library
255:56 - that we use in machine learning projects. The first one is numpy which
256:00 - provides a multidimensional array. A very, very, popular library. 
256:04 - The seconnd one is pandas, which is a data analysis library that
256:08 - provides a concept called data frame. Data frame is a two dimensional 
256:12 - data structure similar to an excel spreadsheet. So we have rows and columns 
256:16 - we can select columns in a row or a column or a range of rows and
256:20 - columns, again, very very popular in machine learning 
256:24 - and data science projects. The third library is mad plot lib which
256:28 - is a two dimensional plotting library for creating graphs on plots. 
256:32 - The next library is sidekick learn, which is one of the most popular machine learning 
256:36 - libraries that provides all these common algorithms like decision trees, 
256:40 - neural networks and so on. Now, when working with machine learning 
256:44 - projects, we use an environment called jupiter for writing our code, technically we can still
256:48 - use vs code or any other code editor, but these editors 
256:52 - are not ideal for machine learning projects, because we need to frequently 
256:56 - inspect the data, and that is really hard in environments like vs code and 
257:00 - terminal. If you're working with a table of 10 or 20 columns 
257:04 - visualizing this data in a terminal window is really, really difficult and messy, so thats why we use jupiter.
257:08 - So that's why we use jupiter, it makes it really easy to inspect our data. 
257:12 - Now to install jupiter, we are going to use  platform called anaconda. 
257:16 - So, head over to Anaconda.com/download.
257:20 - On this page you can download Anaconda distribution for your operating system, 
257:24 - so, we have distributions for Windows Mac and
257:28 - Linux. So let's go ahead and install 
257:32 - Anaconda for python 3.7. Download, 
257:36 - Alright, so
257:40 - here's Anaconda, download it on my machine, let's double click this. 
257:44 - Alright, first it's going to run a program to determine if the software can be installed. 
257:48 - So, let's continue and once again continue, 
257:52 - pretty easy, continue one more time, 
257:56 - I agree with the license agreement, we can use the default 
258:00 - you ca use the default installation location so don't worry about that, just click install,
258:04 - give it a few second, now the beautiful thing about Anaconda is it will install
258:08 - jupiter, as well as all those data popular science libraries 
258:12 - like numpy, Pandas and so on. So we don't have to manually install this
258:16 - using pip. Alright now as part of
258:20 - the next step Anaconda is suggesting to install Microsoft vs code. We 
258:24 - already have this on our machine so we don't have to install it we can go with continue 
258:28 - and close the installation, now finally we can move the
258:32 - this to trash because we don't need this installer in the future.
258:36 - Alright, now open upa  terminal window and type 
258:40 - jupiter, with a y, space, notebook. 
258:44 - This will start the notebook server on your machine. So enter
258:48 - there you go. This will start the notebook server 
258:52 - on your machine, we can see these default messages here, don't worry about them, now 
258:56 - it automatically opens a browser window, pointing to local host 
259:00 - port 888. This is what we call
259:04 - jupiter dashboard. On this dashboard we have a few tabs, the first tab
259:08 - is the files tab, and by default, this points to your home directory.
259:12 - So every user on your machine has a home directory, this its my home directory 
259:16 - on Mac, you can see here we have a desktop folder as well as documents, 
259:20 - downloads and so on. On your machine you're going to see different folders, so somewhere
259:24 - so somewhere on your machine you need to create a jupiter notebook. I'm going to go to desktop
259:28 - here's my desktop I don't have anything here, and then
259:32 - click new, I want to create a notebook for python 
259:36 - 3. In this notebook we can write python code, and execute it line by line.
259:40 - We can easily visualize our data as you can see over the next few videos. So, 
259:44 - let's go ahead with this, 
259:48 - alright, here's our first notebook, you can see by default it's called
259:52 - untitled, let's change that to Hello World so
259:56 - this is going to be the hello world of our machine learning project. Let's
260:00 - rename this now if you look at your desktop you can see this file 
260:04 - hello world.ipynb. This is a jupiter 
260:08 - notebook. It's kind of similar to our py files where we write our
260:12 - python code, but it includes additional data that jupiter uses to execute our
260:16 - code. So back to our notebook, let's
260:20 - do a print hello world. 
260:24 - And then, click this run button here
260:28 - and here's the result printed in jupiter, so we don't have to
260:32 - navigate back and forth between the terminal window we can see all the result
260:36 - right here. Next I'm going to show you how to load a data set from a 
260:40 - csv file in jupiter. 
260:48 - Alright, in this lecture we're going to download a data set from a very popular website called
260:52 - caggle.com. Caggle is basically a place to do data science projects. 
260:56 - So the first thing you need to do is to create an account, you can sign up with Facebook, 
261:00 - Google, or using a custom email and password, once you sign up then come back 
261:04 - here, on caggle.com, Here one the search bar 
261:08 - search for video game sales. 
261:12 - This is the name of a very popular data set that we're going to use in this lecture. So, 
261:16 - here in this list you can see the first item with this kind of reddish 
261:20 - icon, so, let's go with that, as you can see this data
261:24 - set includes the sales data for more then 16,000 videos 
261:28 - games. On this page you can see the description of various 
261:32 - columns in this data set, we have rank, name, platform, 
261:36 - year, and so on, so here's our data source, it's a csv file
261:40 - called vg sales.csv, as you can see there are over 16,000
261:44 - rows, and 11 columns in this data set. 
261:48 - Right below that you can see the first few records of this data set. 
261:52 - So, here's our first record, the ranking for this game is 1, it's the wi sport 
261:56 - game for wii as the platform and it was released in the year 2006,
262:00 - now, what I want you to do is go ahead and 
262:04 - download the data set, and as I told you before you need to sign in
262:08 - before you can download this. So this will give you a zip file as you can see here, 
262:12 - here's our csv file, now I want you to 
262:16 - put this right next to your jupiter notebook, on my machine that is on my desktop
262:20 - so I'm going to drag and drop this onto the desktop folder. 
262:24 - Now, if you look at the desktop you can see here's my 
262:28 - jupiter, hello world notebook, and right next to that we have 
262:32 - vgsales.csv. With that, we go back 
262:36 - to our jupiter notebook, let's remove the first line and instead 
262:40 - import pandas 
262:44 - as pd. With his we're importing pandas module 
262:48 - and renaming it to pd, so we don't have to type pandas. several times in
262:52 - this code. Now let's type pd.
262:56 - read_csv. And pass the 
263:00 - name of our csv file. That is vgsales.
263:04 - csv. Now because this csv file, is in the current folder right next to our jupiter notebook, 
263:08 - we can easily load it, otherwise we have to supply the full path 
263:12 - to this file. So, this returns a 
263:16 - data frame object which is like an excel spreadsheet. Let me show you.
263:20 - So we store it here, and then we can
263:24 - simply type df to inspect it. So one more time let's run this program 
263:28 - here's our data frame with these rows and these columns so we have
263:32 - frank name platform and so on. Now this data frame object 
263:36 - has lots of attributes and methods that we're not going to cover in this tutorial,
263:40 - that's really beyond the scope of what we're going to do, so I'm going to leave it up to you to
263:44 - read pandas documentation or follow other tutorials to find out about pandas data frames. 
263:48 - But in this lecture, I'm going to show you some of the most useful methods and attributes. 
263:52 - The first one is shape, so shape 
263:56 - let's run this one more time, so here's the shape of this data set, we have over 
264:00 - 16,000 records and 11 columns. 
264:04 - Technically this is a 2 dimensional array of 16,000 
264:08 - and 11, okay? Now, we can see here we have another 
264:12 - segment for writing code. SO we don't have to write all the code in the first segment 
264:16 - so here in the second segment we can call one of the methods of the dataframe,
264:20 - that is df.describe. 
264:24 - Now when we run this program, we can see the
264:28 - output for each segment right next to it. So here's our first
264:32 - segment, here we have these three lines, and this is the output of
264:36 - the last line. Below that we have our second segment, here we're calling
264:40 - the describe method, and right below that we have the output of
264:44 - this segment So this is the beauty of jupiter, you can easily visualize 
264:48 - our datsa, doing this with vscode in windows is really tedious and
264:52 - clunky. So what is the describe method returning? Basically it's
264:56 - returning some basic information about each column in this data set, So, 
265:00 - as you saw earlier we have columns like rank, year and so 
265:04 - on. These are the columns with numerical values. Now for each column we have 
265:08 - the count which is the number of records in that column, you can se 
265:12 - our rank column has 16,5
265:16 - -98 records whereas the year column has 16,3-
265:20 - -27 records.. So this shows that some of our records don't 
265:24 - have the value for the year column. We have null values.
265:28 - So in a real data science or machine learning project we'll have to use some 
265:32 - techniques to clean up our data set. One option is to remove the records 
265:36 - that don't have a value for the year column. Or we can assign them a default value. 
265:40 - That really depends on the project. Now another attribute for each column 
265:44 - is mean so this is the average of all the values, now
265:48 - in the case of the rank column, this rank doesn't really matter, but look at the year. 
265:52 - So the average year year for all these video games in our dataset is
265:56 - 2006. And this might be  important in the problem we're trying to solve. 
266:00 - We also have standard deviation, which is a 
266:04 - measure to quanitfy the amount of variation in our set of values, below that we have
266:08 - min, as an example the minimum value for the year column 
266:12 - is 1980. So quite often when we work with a  new data set, 
266:16 - we call the describe method to get some basic statistics about 
266:20 - our data. Let me show you another useful attribute. 
266:24 - So, in the next segment, let's type df.values. 
266:28 - Let's run this, as you can see this returns 
266:32 - a two dimensional array, this square bracket indicates the outer array
266:36 - and a second one represents an inner array. 
266:40 - So the first element inn our outer array, is an 
266:44 - array itself, these are the values in this array, which basically 
266:48 - represent the first row in our data set. So the video game we ranking 
266:52 - 1, which is called wii sports. So this was a basic 
266:56 - overview of pandas data frames, in the next lecture I'm going to show you
267:00 - some of the useful shortcuts of jupiter. 
267:08 - In this lecture I'm going to show to you some of the most useful shortcuts in Jupiter, 
267:12 - Now the first thing I want you to pay attention to is this green bar on the left. 
267:16 - This indicates that this cell is currently in the edit mode, so we can 
267:20 - write code here. Now, if we press the 
267:24 - escape key, green turns to blue, and that means this cell is
267:28 - currently in the command mode. So basically the activated cell can either 
267:32 - be in the edit mode or command mode. Depending 
267:36 - on the mode, we have different shortcuts, so here we're in the command mode. 
267:40 - If we press h, we can see the list of all the 
267:44 - keybord shortcuts, right above this list we can 
267:48 - see, Mac OS modifier keys, these are the
267:52 -  extra keys on a Mac keyboard. If you're a Windows 
267:56 - user you're not gong to see these. So as an example, here is the shape of the 
268:00 - command key, this is control, this is option, 
268:04 - and so on. With this guideline you can easily understand the shortcut associated with 
268:08 - each command. Let  me show you. So here we have all 
268:12 - the commmands when a cell is in the command mode. For example, we have
268:16 - this command, open the command palette. This is exactly like the
268:20 - command palette that we have in vs code. Here is a short cut
268:24 - to execute this command. That is command shift and F. 
268:28 - Okay, so here we have lots of shortcuts, 
268:32 - of course you're not going to use all of them all the time, but it's good to have a quick look here to see 
268:36 - what is available for you. Tis these shortcuts you can write code much faster. 
268:40 - So let me show you somme of the most useful ones. I'm going to close this,
268:44 - now with our first cell in the command mode 
268:48 - I'm going to press b, and this inserts, a new 
268:52 - cell below this cell. We can also go 
268:56 - back to our first cell, press escape, now the cell is in the command 
269:00 - mode. We can insert an empty cell above this cell by pressing a. 
269:04 - So either a or b. A for above or 
269:08 - b for below. Now if you don't want this cell, you can press d 
269:12 - twice to delete  it. Like this. 
269:16 - Now in the cell I'm going to print a hello world message. So print 
269:20 - hello world. Now, to
269:24 - run the code in this cell, we can click on the run button here, 
269:28 - so, here's our print function, and 
269:32 - right below that you can see the output of this function. But note that when you run 
269:36 - a cell, this will only execute the code in that cell. 
269:40 - In other words, the code in other cells will not be executed. 
269:44 - Let me show you want I mean, so in the cell below the cell, I'm going to delete the call 
269:48 - to a describe method. Instead I'm going to print 
269:52 - ocean. Now, I'm going 
269:56 - to put the cursor back in this cell where we print this hello world message
270:00 - and run this cell. So we can see hello world 
270:04 - is displayed here, but the cell below is still displaying 
270:08 - the describe table, so we don't see the changes here. Now, 
270:12 - to solve this problem, we can go to the cell menu on the top, 
270:16 - and run all cells together. This can work for a 
270:20 - small project, but sometimes you're working with a large data 
270:24 - set, so if you want to run all these cells together it's going to take a lot of time. That is
270:28 - the reason jupiter saves the output of each cell, so we don't have to rerun that
270:32 - code if it hasn't changed. So this notebook file that we have here, 
270:36 - includes our source code organized in cells as 
270:40 - well as the output for each cell. That is why it's different 
270:44 - from a regular py file where we only have the source code.
270:48 - Here we also have autocompletion and intellisence, so in this cell, 
270:52 - let's call df data frame 
270:56 - . now if you press tab you can see all the attributes
271:00 - and methods in this object. So let's call 
271:04 - describe, now with the cursor on the name of the method we can
271:08 - press shift and tab, to see this tool tip that describes
271:12 - what this method does and what parameter it takes. So here in front of 
271:16 - so here in front of signature you can see the describe method, these are the paramter
271:20 - and their default value, and right below that you can see
271:24 - the description of what that method does. In this case, it describes
271:28 - generates descriptive statistics, that summarize the central tendency and so on. 
271:32 - Similar to vs code, we can also convert a line to comment 
271:36 - by pressing command and slash on mac, or
271:40 - control slash on windows. Like this. Now that line is a comment, we can 
271:44 - press the same shortcut one more time to remove the comment, 
271:48 - so these are some of the most useful shortcuts in jupiter. 
271:52 - Now over the next few lectures we're going to work on a real machine learning project, but before we get there, 
271:56 - let's delete all the cells here, so we start with only a single 
272:00 - empty cell, so here, in this cell, first I'm going to press the
272:04 - escape button, now the cell is blue, so we're in the command mode, and 
272:08 - we can delete the cell by pressing d twice. There you go. 
272:12 - Now, the next cell is activated and is in the command mode. 
272:16 - So, let's delete this as well, so we have two more cells to delete 
272:20 - there you go, and the last one, like this, 
272:24 - so now we have an empty notebook with a single cell.
272:32 - Over the next few lectures, we're going to work on a  real machine learning project, 
272:36 - imagine we have an online music store, when our users sign up, 
272:40 - we asked our age and gender, and based on their profile, 
272:44 - you recommend various music albums their likely to buy. So in this project, 
272:48 - you want to use machine learning to increase sales. 
272:52 - So, we want to build a model, we feed this model with some sample data, 
272:56 - based on the existing users. Our model will learn the patterns in our data, 
273:00 - so we can ask it to make predictions. When a new user signs up, 
273:04 - we tell our model, hey, we have a new user with this profile, what 
273:08 - is the kind of music, that this user is interested in, our model will say jazz, or hip hop, 
273:12 - or whatever, and baed on that we can make suggestions to the user
273:16 - so, this is the problem we're going to solve, now back to the list of steps in the machine 
273:20 - learning projects, first we need to import our data, then, we should
273:24 - prepare or clean it, next we select a machine learning algorithm 
273:28 - to build a model, we treat our model and ask it to make predictions. 
273:32 - And finally, we evaluate our algorithm to see it's
273:36 - accuracy. if it's not accurate we either fine tune our model or 
273:40 - select a different algorithm. So let's focus on the first step. 
273:44 - Head over to bit.ly/music.csv
273:48 - this is a very basic csv that I've created for this project, it's just some random
273:52 - made up data it's not real. So we have a table with 3
273:56 - columns, age, gender, and genre. Gender 
274:00 - can either be one which represents a male, 
274:04 - or a 0, which represents a female, here I'm making a few assumptions. 
274:08 - I'm assuming that men between 20 and 25 like hip hop men between 
274:12 - 26 and 30 like jazz, and after the age of 30, 
274:16 - they like classical music. For women I'm assuming 
274:20 - that if they are between 20 and 25 they like dance music, if
274:24 - they are between 26 and 30 they like acoustic music, and just like
274:28 - men, after the age of 30 they like classical music. Once again this is
274:32 - a made up pattern, it's not the representation of the reality, so, 
274:36 - let's go ahead and download this csv. Click on this ... icon here
274:40 - and download this file. 
274:44 - In my downloads folder, here we have this music.csv. 
274:48 - I'm going to drag and drop this onto the desktop because that's where I've
274:52 - stored this hello world notebook. So I want you to put this csv file 
274:56 - right next to your jupiter notebook. 
275:00 - Now, back to our notebook, you need to read the csv file, so just like before 
275:04 - first we need to import the pandas module, so import panda 
275:08 - as pd. And then we'll call pd, 
275:12 - .read_csv and 
275:16 - the name of our file is music.csv. As you saw earlier this
275:20 - returns a data frame which is a two dimensional array similar to an xl spreadsheet, 
275:24 - so let's call that music_
275:28 - data. Now let's inspect 
275:32 - this music_data to make sure we loaded everything properly so
275:36 - run, so here's our data frame, beautiful, next we need
275:40 - to prepare or clean the data. And that's the topic for the next lecture. 
275:44 - next lecture. 
275:48 - The second step in a machine learning project, is cleaning, or 
275:52 - preparing the data, and that involves tasks such as removing duplicate 
275:56 - null values and so on. Now on this particular data set we don't have to do anything 
276:00 - kind of cleaning, because we don't have any duplicates, and as you can see 
276:04 - As you can see, all rows have values for all columns, so we don't have null values. 
276:08 - But there is one thing we need to do, 
276:12 - we should split this data set into two separate data sets, one into the first
276:16 - two columns, which we refer to as the input set, and the other 
276:20 - with the last column which we refer to as the output set. So when we train a model, 
276:24 - so when we train a model we give it two separate data sets. The input set and the output set. 
276:28 - The output set which is in this case 
276:32 - the genre column contains the predictions so we're telling our model that
276:36 - if we have a user who's 20 years old and a male they like 
276:40 - hip hop. Once we train our model then we give it a new
276:44 - input set. For example, we have a new user who is 
276:48 - 21 years old and is a male, what is the genre of the music that this
276:52 - user probably likes. As you can see in our input set, we don't have 
276:56 - a sample for a 21 year old male, so we're going to ask 
277:00 - our model to predict that. That is the reason we need to split this data 
277:04 - set into two separate sets. Input and output 
277:08 - So back to our code, this data frame object has a 
277:12 - method called drop. Now
277:16 - if you put the cursor on the method name and press shift 
277:20 - and tab, you can see this tool tip, so this is the signature of
277:24 - this drop method, these are the parameters you can pass here. 
277:28 - the parameter we're going to use in this lecture is set to none by default.
277:32 - Witht his parter we can specify the columns we want to drop, so
277:36 - in this case we set columns 
277:40 - to an array with one string, genre 
277:44 - now this method doesn't actually modify the original data set. 
277:48 - In fact it will create a new data set but without thisq
277:52 - call. So by convention we use a capital X to 
277:56 - represent that data set, so capital x equals this 
278:00 - expression. Now, let's inspect x, 
278:04 - so as you can see our input set or x 
278:08 - includes these two columns, age and gender, it doesn't have the 
278:12 - output or predictions. Next we need to create our output set so, 
278:16 - once again we start with our data frame
278:20 - using data, using square brackets we can get all the 
278:24 - values in a given column. In this case, genre. Once again this returns 
278:28 - a new data set. By convention we use a lower case y
278:32 - to represent that. So that is our output 
278:36 - data. Let's inspect that as well. So, 
278:40 - in this data set we only have the predictions or the answers. 
278:44 - So we have prepared our data, next we want to create a model using an 
278:48 - algorithm. 
278:52 - The next step is to build a 
278:56 - model using a machine learning algorithm. There are so many algorithms out there, each algorithm 
279:00 - has its pros and cons, in terms of the performance and accuracy. 
279:04 - In this lecture we're going to use a very simple algorithm called decision tree. 
279:08 - Now the good news is we don't have to explicitly 
279:12 - program these algorithms, they're already implemented in a  library called side kick
279:16 - learn. So, here on the top, 
279:20 - from sklearn.tree 
279:24 - let's import the decision tree 
279:28 - classifier. So sklearn is the package 
279:32 - that comes with sidekick learn library, this is the most popular machine learning library 
279:36 - in python. In this package, we have a module called tree.
279:40 - And in this module we have a class called decision tree classifier. 
279:44 - This class implements the decision tree operator, okay?
279:48 - So, now we need to create a new instance of this class.
279:52 - So, at the end, let's create 
279:56 - an object called models nd set it to anew instance of decision, 
280:00 - tree classifier. Like this. 
280:04 - So now we have a model, next we need to train it so it learns
280:08 - patterns in the data, and that is pretty easy. You call model,
280:12 - .fit this method takes 
280:16 - 2 data set. The input set and the output set. 
280:20 - So they are capital x, y. 
280:24 - Now finally, we need to ask our model to make a prediction, so we can
280:28 - ask it, what is the kind of music a 24 year old male likes? Now before
280:32 - we do that, let's temporarily inspect our initial data set. That is
280:36 - music data. So, look what
280:40 - we got here. As I told you earlier, I've assumed 
280:44 - that men between 20 and 25 like hip hop music but 
280:48 - here we only have 3 samples for men age 
280:52 - 20, 23,and 25. We don't have a sample for 
280:56 - a 21 year old male. So if you ask our model to predict the kind of music 
281:00 - that a 21 year old male likes, we expect it to say hip hop. Similarly, 
281:04 - I've assumed that women between 20 and 25 like dance music, 
281:08 - but we don' have a sample for a 22 year old female. So once again if
281:12 - you ask our model to predict the kind of music that a 22 year old woman 
281:16 - likes, we expect it to say dance. 
281:20 - So, with these assumptions let's go ahead and ask our model 
281:24 - to make predictions. So let's remove 
281:28 - the last line, and instead we're going to call model 
281:32 - .predict. This method takes a 
281:36 - 2 dimensional array. So here's the outer array. In this array, each element 
281:40 - is an array. So I'm going to pass 
281:44 - another array here, and in this array I'm going to pass a new input set. 
281:48 - a 21 year old male. So 21, 1
281:52 - that is like a new record in this table. Okay? So,  
281:56 - this is one input set, let's pass another input for a 22 year old 
282:00 - female. So here's another array, here, 
282:04 - we add 22 comma 0, so we're asking our model to make 2 predictions 
282:08 - at the same time. We get the result and store it
282:12 - in a variable called predictions, and finally 
282:16 - let's inspect that in our notebook. 
282:20 - Run, look what we got, our
282:24 - model is saying that a 21 year old male likes hip hop, and a  22 year
282:28 - old female likes dance music. So our model successfully 
282:32 - will make predictions here. But wait a minute, building a model that makes 
282:36 - predictions accurately is not always that easy.
282:40 - After we build a model we need to measure it's accuracy.
282:44 - And if it's not accurate enough, we should either fine tune it or build a model using a different 
282:48 - algorithm. So next lecture I'm going to show you how to measure the accuracy of
282:52 - a model. 
282:56 - In this lecture I'm going to show you
283:00 - how to measure the accuracy of your models. Now in order to do so, 
283:04 - first we need to split our data set into two sets. One for training and the other 
283:08 - for testing, because right now, we are passing the entire data set, 
283:12 - for training the model and we're using 2 samples for 
283:16 - making predictions. That is not enough to calculate the
283:20 - accuracy of a model. A general rule of thumb is to annotate 
283:24 - 70-80% of our data to training, and another20-30% 
283:28 - for testing, then instead of passing only two samples for
283:32 - making predictions, we can pass the data set for testing 
283:36 - we'll get the predictions and then compare the predictions with the actual values. 
283:40 - In the test set. Based on that, we can calculate the 
283:44 - accuracy. That's really easy, all we have to do is import a couple functions and 
283:48 - call them in this code. Let me show you. So first on this top
283:52 - from sklearn.model
283:56 - underline selection module we import a function called 
284:00 - train test split. With this function we can easily split our
284:04 - data set into two sets. So training and testing, 
284:08 - now, right here, after we define x and y, 
284:12 - sets, we call this funciton, so train 
284:16 - test split. We give it 3 
284:20 - arguments, x, y, ad a keyword argument that specifies 
284:24 - the size of our test dataset. So test
284:28 - _size we set it to 0.2 So we're allocating 20%
284:32 - of our data for testing. Now this functions returns a 
284:36 - tuple, so we can unpack it into 4 variables
284:40 - right here. x_train
284:44 - x_test y_train and y
284:48 - _test. so the first two variables 
284:52 - are the input sets for training and testing. 
284:56 - And the other are the output sets for training and testing, 
285:00 - now, when training our model, 
285:04 - instead of passing the entire data set we want to pass only the training data set. 
285:08 - So, x_train, 
285:12 - and y_train. Also, when making predictions 
285:16 - instead of passing these two samples, we pass 
285:20 - x_test. So thats the datas set. 
285:24 - That contains input values for testing. Now we get 
285:28 - the predictions. To calculate the accuracy we simply have to compare these predictions 
285:32 - with the actual values we have in the output set 
285:36 - for testing. That is very easy. First on the top, 
285:40 - we need to import a funciton, so, from sklearn.metric 
285:44 - .metrics import accuracy 
285:48 - _score. Now at the end. 
285:52 - We call this function, so accuracy score and 
285:56 - give it two arguments y_test.
286:00 - Which contains the expected values and 
286:04 - predictions which contains the actual value. 
286:08 - Now this functions returns an accuracy score between 0 
286:12 - to 1. So we can store it here, 
286:16 - and simply display it on the console. So let's go ahead 
286:20 - and run this program. So, the accuracy score 
286:24 - is 1 or a 100% but if we run this one more time, we're going to see a different result
286:28 - because every time we split our data set into 
286:32 - training a test sets. We'll have different data sets, because this function 
286:36 - randomly picks data for training and testing. Let me show you, so put the cursor 
286:40 - in the cell, now we can see this is activated 
286:44 - note that if you click this button here, it will run the cell and also insert a new 
286:48 - cell below this cell. Let me show you. So if I go to this second cell
286:52 - press the skip button, now we are in the command mode, 
286:56 - press d twice, okay now it's deleted, if we 
287:00 - click the run button, we can see, this code was 
287:04 - executed, and now we have a new cell, so if you want to run our cell multiple times 
287:08 - every time you have to click this and then run
287:12 - it, and then click again, and run it, it's a little bit tedious. So I'll show you a shortcut. 
287:16 - Activate the first cell, and press control and enter 
287:20 - this runs the current cell without 
287:24 - adding a new cell below it. So, back here, lets run it multiple times 
287:28 - okay, now look the accuracy dropped to 0.75, it's 
287:32 - still good, so the cuuracey scored here, is somewhere 
287:36 - between 75% to a hundred %. But let me show you something, if I 
287:40 - change the test size, from 0.2 to 0.
287:44 - 8, so essentially we're using only 20 percent of our data, 
287:48 - for training this model. And you're using the other 80% 
287:52 - for testing. Now let's see what happens when we run this cell multiple
287:56 - times. SO, control and enter, look, the accuracy immediately 
288:00 - dropped to 0.4 One more time, now 46% 
288:04 - 40%, 26%
288:08 - it's really, really bad. The reason this is happening is because
288:12 - you are using very little data for training this model. This is one of
288:16 -  the key concepts in machine learning, the more data we give to our model and the cleaner
288:20 - the data is, we get the better result, so if you have duplicates, 
288:24 - irrelevant data, or incomplete values, our
288:28 - model will learn back patterns in our data. That's why it's really important to clean 
288:32 - before training our model. Now let's change this back to 0. 
288:36 - 2, run this one more time, okay, now 
288:40 - the accuracy is 1, 75%, now we drop to 50% 
288:44 - again, the reason this is happening, is because we don't have enough data. 
288:48 - Some machine learning problems, require, thousands or even millions 
288:52 - of samples, to train model, the more complex a problem is, 
288:56 - the more data we need. For example, here we're only dealing with a table of three 
289:00 - columns, but if you want to build a model to tell if a picture of a cat or a dog or a horse, 
289:04 - or a lion, we will need millions of pictures, the more animal 
289:08 - it will support the more pictures we need. In the next lecture, we're going to talk about 
289:12 - model persistence. 
289:16 - So this is a 
289:20 - very basic implementation of building a training a model to make a prediction. 
289:24 - Now to simplify things I have removed all the code that you wrote in the last lecture for
289:28 - calculating the accuracy, because in this lecture, you're going to
289:32 - focus on a different topic, So basically we import our data set. 
289:36 - Create a  model, train it, and then 
289:40 - ask it to make predictions, now this piece of code that you see here, is not what we
289:44 - want to run everytime we have a new user or
289:48 - every time we want to make recommendations to an existing user
289:52 - sometimes it's really time consuming. In this example, we're dealing with a 
289:56 - very small data set that only has 20 records. But in a  real application, 
290:00 - you might have a data set with thousands or trillions of examples, training for that 
290:04 - might take seconds or minutes or even hours. 
290:08 - And that is wy model persistence is important, once in a while, 
290:12 - you build and train our model and then we save it to a file. 
290:16 - Now, next time we want to make predictions, we simply load the model from the file and
290:20 -  ask it to make predictions. That model is already trained 
290:24 - you don't need to retrain it, it's like an intelligent person. So let me show you
290:28 - how to do this. it's very very easy. On the top, 
290:32 - from sklearn.externals module
290:36 - we import joblib. This
290:40 - job lib object has methods for saving and loading modules. So, 
290:44 - after we train our model we'll simply call
290:48 - job lib .dump and give it 
290:52 - two arguments. Our model and the name of the file 
290:56 - in which we want to store this model. Let's call this music 
291:00 - -recommender.job lib 
291:04 - That's all we have to do. Now temporarily I'm going to comment 
291:08 - out this line, we don't want to make any predictions, we just want to store
291:12 - train model in a file. So let's run this cell with control, 
291:16 - and slash, okay, look, in the output 
291:20 - we have an array that contains the name of our model file. 
291:24 - So this is the return value of the dump method. Now back to our 
291:28 - desktop, right next to my notebook we can see our job lib file, this is where our model is stored. 
291:32 - It's simply a binary file. Now back to our 
291:36 - jupiter notebook. As I told you before in a real application we don't want to
291:40 - train model every time. So let's comment out
291:44 - these few lines, on Mac, we can press
291:48 - command and slash and on windows control slash.
291:52 - Okay, these lines are commented out, now this time, instead of dumping 
291:56 - our model, we're going to load it, so we call the load method, we don't have the model, we simply 
292:00 - pass the name of our model file. This
292:04 - returns our trained model. Now with this 
292:08 - two lines we can simply make predictions, so, earlier, 
292:12 - we assumed that men between 20-25 like hip hop music. 
292:16 - let's print predictions and see if our model is behaving 
292:20 - so control 
292:24 - so this is how we persist and load models. 
292:32 - Earlier in this section, I told you that decision trees are the easiest 
292:36 - to understand. And that's why we started machine learning with decision trees. In this lecture, we're going to 
292:40 - export our model in visual format, so you will see 
292:44 - how this model makes predictions, that is really, really cool. 
292:48 - Let me show you. So once again I've simplified this code
292:52 - so we simply import our data set, create 
292:56 - input and output sets, create a model, and 
293:00 - train it, that's all we are doing, now I want you to
293:04 - follow along with me, type everything exactly as I show you in this lecture. Don't
293:08 - worry about what everything means we'll come back to it shortly. So on the top,
293:12 - from sklearnimport
293:16 - tree, this object has a method for exporting
293:20 - our decision tree in a  graphical format. So after we 
293:24 - train our model, let's call tree 
293:28 - _graph vis. Now here are a few arguments we need
293:32 - to pass. The first argument is our model,
293:36 - the second is the name oft he output file. So here we're going to use keyword 
293:40 - arguments, because this method takes so many parameters, and we want to selectively pass 
293:44 - keyword arguments without worrying about their order. So, 
293:48 - the parameter we're going to set it out_file 
293:52 - let's set this to music-recommend 
293:56 - .dot. This is the dot format, which is the 
294:00 - graph format, which is a graph description language, you will see that shortly. 
294:04 - Now the other parameter you want to set is feature 
294:08 - _names. We set this to an array of two strings, 
294:12 - age and gender. These are the features 
294:16 - or the columns of our data set. So they are properties or features of
294:20 - our data. Okay? The other parameter 
294:24 - is class names. So class_names 
294:28 - we should set this to the list of classes or labels we have
294:32 - in our output data set, like hip hop, jazz, classical and so on. 
294:36 - So, this y data set includes all the genre
294:40 - or all the classes of our data, but they are repeated a few times in this data set. 
294:44 - So, here we call y.unit this returns 
294:48 - the unique list of classes, now we should sort this alphabetically. 
294:52 - So, we call the sorted function, and pass the 
294:56 - result a y.unique. 
295:00 - The next parameter is labeled, we set 
295:04 - this to a string, all, once again don't worry, 
295:08 - about the details of these parameters, we're going to come back to these shortly. So, 
295:12 - set label to all, then round it, 
295:16 - to true, and finally field to true. So, 
295:20 - so this is the end result, now let's run this sound 
295:24 - using control and enter, okay, 
295:28 - here we have a nw file music recommender .. that's a little
295:32 - bit funny. So we want to open this file with vs code. 
295:36 - So drag and drop this into a vs code window. 
295:40 - Okay, here's a dot format, it's
295:44 - a textural language for describing graphs 
295:48 - Now to visualize this graph we need to install an extension in vs code.
295:52 - So on the left side, click extensions panel and search 
295:56 - for dot, dot. Look at this second extension here. 
296:00 - graphvis or .language
296:04 - by stephon vs. Go ahead and install this extension 
296:08 - and then reload vs code. Once you do that, you can visualize 
296:12 - this dot file. So let me close this tab. 
296:16 - Alright, look at this ... on the right side. Click this, 
296:20 - you should have a new menu, open preview to the side. So like that
296:24 - alright, here's the visualization of our decision tree, 
296:28 - let's close the dot file, there you go. This is exactly 
296:32 - how our model makes predictions. So we have this
296:36 - binary tree, which means every node can have a maximum of two children.
296:40 - On top of each note we have a condition 
296:44 - if this condition is true we go to the child node on the left side. Otherwise we 
296:48 - go to the child node on the right side. So let's see what's happening here, the first condition 
296:52 - is age less then or equal to 30 
296:56 - .5. If this condition is false, that means that user is 30 years 
297:00 - or older, so the genre of the music that their interested in is classical. 
297:04 - So here we're classifying people based 
297:08 - on their profile. That is the reason we have the word class here, 
297:12 - so a user who is 30 years or older, belongs to the class of 
297:16 - classical. Or people who like classical music. Now what if this condition 
297:20 - is true. That means that user is younger then 
297:24 - 30, so, now we check the gender, if it's less then 0.5, 
297:28 - which basically means it equals to 0, then 
297:32 - we're dealing with a female. So we go to the child node here, 
297:36 - now once again we have another condition, so we are dealing with a female 
297:40 - who is younger than 30. Once again we ned to check their age so 
297:44 - is the age less then 25.5? If that's the case 
297:48 - then that user likes dance music, otherwise they like acoustic music. 
297:52 - So this is a decision tree that our model uses to make predictions 
297:56 - Now if you're wondering why we have these floating point numbers
298:00 - like 25.5 These are basically the rules 
298:04 - that our model generates, based on the patterns in our dataset. 
298:08 - As we give our model more data, these rules will change so they are not always the same. 
298:12 - So they are not always the same, also the more columns or the more features 
298:16 - we have, our decision tree is going to get more complex. 
298:20 - We only have two features, age, and gender. Now back to our code 
298:24 - let me quickly explain the meaning of all these parameters, we set field to true 
298:28 - so each box or each node is filled with a color. We set 
298:32 - rounded to true, so they have rounded corners. We set label to all
298:36 - so every node has labels that we can read. 
298:40 - We set class names to the unique list of genres 
298:44 - and that's for displaying the class for each note, right here, and we set
298:48 - feature names to age and gender, sow e can see the rules 
298:52 - in our notes. So that was a short and 
298:56 - sweet introduction to machien learning. Now you can use the materials that you learn in this section 
299:00 - and apply them to solve a different set of problems. Now here's a question for you: 
299:04 - What ideas do you have for machine learning? What kind of problems do you want to solve 
299:08 - with machine learning? Use the comments box below and let me know. I love to
299:12 - hear about your ideas! Next we're going to use python and a popular framework called
299:16 - django. To build a web application. Are you ready, let's get started
299:24 - In this turorial, I'm going to show you how to create your first website with python, and A 
299:28 - and a very popular framework called django. So it's spelled with a silent D, 
299:32 - and is pronounced django. it's a web framework for
299:36 - perfectionists with deadlines. So if you're a perfectionist and you want to quickly put together
299:40 - a website that is fast, scaleable and secure, 
299:44 - django is your best friend. And here are the popular websites 
299:48 - built with Django. Like Instagram, Spotify
299:52 - YouTube, Washington Post, and so on. Now you might say
299:56 - what is a framework, and why do we need a framework to build a web application or a web site?
300:00 - Well, the framework is essentially a library of reusable modules
300:04 - these modules provide functionality for common tasks 
300:08 - for example, in the case of a web framework like django we have modules to work with http requests 
300:12 - url's, sessions, cookies and so on. 
300:16 - These are the concerns of pretty much every website or 
300:20 - application out there. So all this functionality is baked into django, we don't have to
300:24 - code it from scratch, that is why we use a framework like django. Now, 
300:28 - django. Now technically a framework is more then a library, 
300:32 - apart from providing these modules it also provides a structure for each application 
300:36 - It tells us what folders or files we should have in our project. So this
300:40 - provides a consistency among various django projects. So as you
300:44 - move from one company to another and work on different projects, you can easily transition from one
300:48 - project to another, because all these applications follow the same structure
300:52 - now, with that interaction, let's create our first 
300:56 - django project. So back to pycharm, close the hello world 
301:00 - project, and create a new project, create a new project, 
301:04 - let's call this new project pyshop
301:08 - go ahead, alright, now down at the bottom let's 
301:12 - open up a terminal window, in this window we're going to
301:16 - install django. So we use pip to install 
301:20 - django. But be sure to add two equal signs here followed by
301:24 -  2.1 With this we are telling pip that we want to install django version 
301:28 - 2.1. The reason I'm doing this, is because in the future when you're watching this video, 
301:32 - chances are there is a newer version django out there. I 
301:36 - want to make sure that you can easily follow these tutorials, even though what I'm going to show you 
301:40 - in these tutorials will most likely work with the latest version of django. I just want to
301:44 - be on the safe side. So let's go ahead
301:48 - alright, django is installed, 
301:52 - next we need to create a django project, so here press control and L
301:56 - this cleans up our terminal window, you don't have to do it, but it's just
302:00 - easier to see. To create a django project, we need to execute this command, django, 
302:04 - -admin space 
302:08 - start project space, you're going to call this 
302:12 - project pyshop space period. 
302:16 - So when we install django, django brings a 
302:20 - command line utility called django admin so this is a utility or program
302:24 - that we can execute form the command line or terminal, right here. 
302:28 - Now, this program takes various arguments, in this case 
302:32 - we want to use this argument start project, with this we're going to create
302:36 - a project called pushup in the current folder. 
302:40 - So this period is imported here, that means the current folder, if
302:44 - you don't add this period, this utility is going to create an extra folder and that
302:48 - looks a little bit repetitive, so let's go ahead with this, 
302:52 - alright, now, back to the project panel, if you expand py
302:56 - shop we can see that this is our project that we created in pycharm 
303:00 - and in this folder we have these files. 
303:04 - So, init.py, you have seen this before, that means 
303:08 - this folder is package, so we can import various modules, 
303:12 - of this package into other modules, and in this module, 
303:16 - we define various settings for our application, you're going to see this later in
303:20 - this course. You also have this url's module, and with this module 
303:24 - we define what should the user see when they see slash
303:28 - about/contact/products/shopping cart
303:32 - again, we're going to work with this only. And finally we have this module,
303:36 - that wsgi, that is short for web server gateway
303:40 - interface. The purpose of this module is to provide a standard interface
303:44 - between applications built with django and web servers. This is 
303:48 - an advanced topic, so for now, don't worry about it. Now, outside of this folder, 
303:52 - of this folder you also have this new folder in our project 
303:56 - manage.py. As the name implies, we use this to manage 
304:00 - this django project. With this we can start our web server,  
304:04 - we can work with our data base, again, we're going to work with this soon, 
304:08 - let's open up the terminal window one more time, now, 
304:12 - type out this command, python if you're on windows or python 
304:16 - 3 if you're on Mac, because as I told you at the beginning of the course, Mac by 
304:20 - default comes with an installation of python, that is python 2. But that is
304:24 - this course is python 3. So python 3 space manage 
304:28 - .py space run 
304:32 - server. What is going on here? So with python interpreter 
304:36 - we are running this program manage.py and passing run server 
304:40 - as an argument. This manage.py is essentially the same program 
304:44 - that we worked with here, django admin. 
304:48 - But we use django admin before creating a django project, now we have a django project, so now 
304:52 - in this project we work with manage.py this
304:56 - is a module that contains some python code, so we use this module to manage 
305:00 - our django project. So let's go ahead and 