00:00 - today we'll be talking about just like
00:02 - file input and output
00:03 - so the general gist is like how
00:06 - you would want to deal with files in
00:08 - python
00:10 - um i'll be going over just like what is
00:13 - a file
00:13 - how python treats files and then
00:16 - like any built-in um functions related
00:20 - to files
00:21 - and like how you can read a file how you
00:23 - can write to a file and stuff like that
00:24 - if you guys have like any questions or
00:27 - like
00:28 - you want me to clarify anything or like
00:30 - slow down
00:31 - or anything like that feel free to like
00:33 - drop in chat
00:34 - or um or ask in
00:38 - like here on your mic and ask either one
00:40 - is fine
00:41 - um first off what is a file so a file is
00:45 - basically
00:46 - any sort of um container that stores
00:48 - information
00:50 - so just like anything you can see
00:53 - on like your computer is stored in a
00:54 - file um
00:56 - file types include like csv txt
00:59 - html um powerpoints microsoft word
01:02 - documents
01:03 - things like that and another term that's
01:05 - related to files is called parsing
01:07 - which is basically reading in and
01:09 - interpreting the data
01:11 - on a file let's see when you upload like
01:14 - an image
01:15 - or something to like microsoft word
01:19 - um microsoft will basically parse that
01:21 - image file
01:22 - you can it's basically like a program's
01:25 - way of reading
01:26 - information from a file first off i
01:29 - talked about like file i o basics
01:32 - so like just how python
01:36 - will treat a file um
01:39 - for python it basically sees a file as a
01:42 - long sequence
01:43 - of bytes and bytes are basically like um
01:47 - just they're literally just numbers so
01:49 - like ones or zeros
01:51 - and they'll see a file as a long string
01:54 - or a long array of like just numbers
01:59 - and it'll basically keep track of
02:02 - where it is in the file using something
02:04 - called file pointer
02:05 - so how i like to imagine it is like say
02:08 - like
02:09 - you pass in a text document python will
02:12 - basically
02:13 - it's basically like python is reading
02:15 - your file line by line
02:17 - and it's like using a finger to like
02:19 - keep track of where it is
02:21 - in the file so when you open a file
02:24 - python will usually put the file pointer
02:28 - at the beginning of the file and that's
02:30 - like where it will
02:31 - either read or write to the file any um
02:34 - questions about that
02:36 - first let's talk about how you can open
02:38 - a file
02:40 - so we can read the contents of file
02:43 - by um using the open function so
02:46 - this is the general syntax of what you
02:49 - should pass into the open function
02:51 - first you have to tell python like where
02:54 - this file is
02:56 - um generally that's the file name just a
02:59 - heads up
02:59 - um it's only the file name
03:03 - if it's in the same if the file is in
03:06 - the same
03:07 - location as your um as where your
03:10 - program is
03:11 - but you have to first tell python where
03:14 - this file is and what the file is called
03:16 - and then that's you have to tell it what
03:19 - mode it is
03:20 - so like is it reading and or
03:23 - writing to a file where do you where
03:25 - like where should it start reading
03:28 - um sometimes like what kind of encoding
03:31 - the file has things like that and
03:33 - finally
03:34 - um the buffering so
03:38 - buffering is something another option
03:40 - you can pass into the open function
03:42 - generally you don't like you don't pass
03:45 - it past
03:46 - that kind of remembering unless like
03:48 - there's a special buffer that you want
03:50 - to um
03:50 - that your file has so um usually you
03:54 - just pass in the file name
03:56 - and and or the file location and the
03:59 - moon so like read write or append
04:01 - and then you can i'm buying open will
04:04 - give you back a file object that i can
04:06 - use to manipulate files
04:08 - and most importantly if you open files
04:11 - always remember to close them at the end
04:14 - so if you if you have it open
04:18 - in your um in your program always make
04:20 - sure you have a corresponding close
04:23 - next we can talk about like
04:28 - so these are just like um strings that
04:31 - you can pass in
04:32 - as the mode parameter is open um there
04:35 - are generally
04:36 - three basic problems there's read right
04:38 - and a pen
04:39 - so read is just like you read the file
04:43 - um right is when you're um
04:46 - writing to the file so when you want to
04:48 - like um
04:49 - print something into a file just be be
04:52 - aware that
04:53 - if you pass in right it will overwrite
04:56 - anything in the file
04:57 - so basically python will clear out that
04:59 - entire file
05:00 - and then start writing from the very top
05:02 - of the file
05:04 - um finally you have a pen which is
05:08 - basically instead of um putting the file
05:11 - pointer at the end
05:12 - or at the start of the file and open
05:15 - python will actually put it at the end
05:17 - of the file and then you can
05:19 - um write after anything after that
05:23 - so a pen will basically add everything
05:24 - to the end of a file
05:26 - you can also add a plus option after any
05:29 - of these um
05:31 - any of these options which will do like
05:34 - we'll add the extra option onto it so
05:36 - like if you do r plus it'll be read and
05:38 - write
05:39 - um w plus will be right in v and then a
05:42 - plus will be append in b
05:44 - so what's the difference between r plus
05:47 - and w plus done
05:48 - so r plus is basically python will read
05:51 - first
05:52 - and then write so it's kind of like a
05:54 - pen
05:56 - and then w plus will be right first and
05:58 - then v
05:59 - so what that means is um for w
06:02 - plus python will actually clear out the
06:04 - entire file first and then you can
06:07 - start writing or reading to it so just
06:10 - make sure
06:10 - you know the difference between r plus
06:12 - and w plus in case like
06:14 - you don't want to overwrite the file at
06:17 - all
06:17 - and then finally like how do you modify
06:21 - files
06:22 - so you have a few options for like
06:24 - reading and writing
06:25 - files so for reading reading files
06:29 - you can use the read function which will
06:31 - read in
06:32 - the number of bytes from the file and
06:35 - then the default is just reading the
06:36 - entire file
06:38 - read line is similar to b so you can
06:40 - read b
06:41 - bytes but from like b bytes from every
06:44 - any single line in the file and then the
06:46 - default is to read the entire
06:48 - line and then finally you can do read
06:50 - minds with an s
06:51 - which will just um return the list of
06:54 - lines
06:54 - that you read um b bytes from and then
06:57 - again default is reading the entire
07:00 - um the entire line
07:03 - and that is reading the entire file
07:04 - finally um if you ever want to
07:06 - write to a file you can just do file
07:09 - object dot right
07:10 - which will basically just print it into
07:12 - the file
07:14 - and then you can also use a function
07:16 - called seek
07:18 - which will take in a position and a
07:21 - relative
07:21 - location so what seek does is
07:24 - it will change the position of the file
07:26 - pointer so
07:27 - for example if i read entire files
07:31 - then my file pointer will end up will
07:34 - end up being at the end of the file
07:36 - but sometimes like i want to read the
07:38 - file and then like
07:39 - read it again or read it from line three
07:42 - or something like that
07:43 - so what i can do if i want to like
07:45 - rewind the file pointer
07:47 - is i can actually just use seek and then
07:51 - um choose which location to start my
07:53 - file pointer at
07:54 - so pause would be like the position
07:58 - of the file pointer and then lock
08:01 - is like where the um reference point
08:05 - of that position so usually like python
08:08 - will
08:09 - reference the um the position of the
08:12 - file pointer based off of
08:14 - the beginning of the file so like um
08:16 - beginning of file
08:17 - is like the zeroth line and then zero
08:20 - one two three
08:21 - from the beginning of five but sometimes
08:23 - like i want to read the second to last
08:25 - or i want to read
08:27 - the um second line before my current
08:30 - position something like that
08:32 - then you can pass in these different
08:34 - options one or two
08:36 - which will which will base the um
08:38 - position off of like the current
08:40 - location or the end of the file
08:42 - so i know i like i just threw a lot of
08:44 - words at you
08:45 - so first let's
08:49 - i think it would be better explained if
08:51 - i show you
08:53 - a really basic um example
08:57 - of how do you read or write from a file
09:01 - so
09:06 - so there's right have any other options
09:10 - um do you mean like the
09:13 - the right mode or like
09:16 - the um the right function because the
09:19 - right mode um is just one mode for the
09:22 - right function
09:23 - there aren't really any other options
09:26 - right
09:26 - is basically you kind of treat it like
09:29 - you're printing into a file
09:31 - so it's kind of like the print function
09:33 - in that way except you're not printing
09:35 - into like
09:36 - into your console or into the command
09:39 - the um command prompt
09:41 - you're um printing into a file
09:44 - so generally like you'll do something
09:47 - like
09:48 - fileobject.right i know write whatever
09:50 - string you passed it into that file
09:52 - um kind of you could it would usually be
09:55 - like
09:57 - say you're opening a file like f equals
10:01 - spoken
10:02 - file file.txt comma
10:05 - w if you like you'll first call like
10:09 - you'll first get a file object like that
10:11 - and then you can call something like
10:12 - f dot right
10:15 - and then that's the general um the
10:18 - general way
10:19 - you know um that's the general way
10:21 - you'll you'll call right
10:23 - and then make sure like at the end
10:25 - you'll be like f
10:26 - close and i can like show you more
10:30 - um once we go through this example so
10:34 - for this demo um first off we have this
10:37 - example text file which is like hello
10:40 - this
10:40 - is this is an
10:43 - example of text file so these are just
10:46 - like five lines
10:47 - of strings and then you know
10:50 - the general um the general flow of
10:54 - is like you'll open the file so like um
10:56 - file equals open
10:57 - example.pfc and then i'll also pass an
11:00 - option
11:01 - so this option will let me read and
11:03 - write so
11:04 - but for now like the code would just be
11:07 - reading so first
11:10 - i can use something like file.me
11:14 - and that'll read the entire file and
11:16 - then i can print that
11:17 - and as you can see it's printed all
11:20 - these lines
11:22 - however like i can also do like for line
11:25 - and file.readlines that'll first pass
11:28 - back like a list
11:29 - of all the lines in the file and i can
11:31 - print it line by line
11:33 - but like you notice that this oh like
11:36 - theoretically this text file should
11:39 - print twice right
11:40 - because i'm reading it once here and
11:42 - then
11:43 - i'm reading it twice every year so why
11:46 - do you think like
11:48 - this only printed once then so
11:51 - the general thing is like whenever i
11:54 - read something
11:56 - i'm like i'm moving my file pointer so i
11:59 - can read it like
12:00 - letter by letter or line by line so
12:04 - when i called read over here i basically
12:06 - read the entire test
12:08 - so what python did was it basically went
12:11 - through this entire text
12:13 - like pretend the cursor is the file
12:15 - pointer
12:16 - and it basically read line by line like
12:19 - this
12:20 - from like all the way to the end so
12:23 - right now my file pointer is actually
12:25 - once like i've done this read function
12:27 - my file pointer is pointing to the end
12:29 - of the file
12:31 - in the example.text so
12:34 - once it hits like this line where line
12:37 - and file.beadlines
12:39 - well the file pointer is at the end of
12:41 - file
12:42 - so there are no more lines to read
12:44 - according to python like that's what
12:45 - python thinks
12:47 - so that's why this um print line
12:50 - never is never um executed
12:54 - because basically by line six python is
12:57 - like well i'm at the end of the wow
12:58 - there's no more lines to be so i can
13:01 - just like skip
13:02 - all of this code so then
13:06 - like if i want to read if i want this to
13:08 - actually like
13:09 - work and print the text twice what i can
13:13 - do
13:13 - is something like file
13:17 - that speaks zero
13:22 - so what this will do is it'll
13:25 - it'll put the file pointer back to the
13:27 - zeroth point
13:28 - which is basically the um step back to
13:30 - the beginning
13:31 - of the text file
13:34 - and once i put that in you'll see that
13:38 - um file that this for the actually
13:40 - prints twice
13:44 - so another interesting thing is like
13:47 - well
13:48 - why is like why
13:51 - is this like single space and why is
13:53 - this double space so
13:55 - can i get a list of all the words in
13:57 - text
13:58 - using this yep so um
14:03 - you can do it two ways so you can
14:07 - read the um the file line by line
14:10 - and then use um because like
14:14 - you can do something like for a line and
14:16 - file that feed lines
14:18 - and then for each line like since it
14:20 - returns the entire line you can do
14:22 - something like
14:23 - string dot strip which will get rid of
14:25 - like the starting and ending
14:27 - um white space and then string that
14:30 - split
14:30 - which will split the string but
14:34 - by the spaces so give you back each word
14:36 - of each line
14:38 - and then you can add like all of these
14:40 - words
14:41 - into a giant list of all the words in
14:43 - the past
14:44 - and i do stuff like that or you can um
14:48 - i think there is a way for you to just
14:50 - get all the words i didn't follow that
14:52 - read
14:53 - um but to be honest like
14:58 - i personally don't use file.read that
15:00 - much
15:02 - and i think most people will use like
15:04 - four line and file that refines
15:06 - and then add all the words in line into
15:08 - like a giant list
15:10 - of all the words in the file so
15:13 - you can totally get like a list of all
15:15 - the words in text
15:16 - using these file functions
15:21 - so back to before like
15:24 - you notice that this print statement
15:27 - print file got v
15:29 - will return the text
15:32 - like in single space but for a line
15:36 - like this for loop will return a double
15:39 - space
15:40 - why is that basically the reason is like
15:44 - in this file you can't see it like you
15:46 - can't see it when
15:48 - in this sort of text editor but at the
15:50 - end of each line like whenever you press
15:53 - enter
15:54 - you're actually printing out a new line
15:56 - character
15:57 - which will basically tell like whatever
15:59 - program
16:00 - um you're using to view the text file to
16:02 - like hey this is
16:03 - technically the next line of the um
16:07 - of the file and then you have to print
16:09 - you have to like print whatever
16:10 - words on the next line so whenever you
16:13 - press enter
16:13 - that's actually like printing out
16:15 - another character
16:18 - so what happens is for um
16:22 - for read lines because like there's this
16:25 - new line character at the end of each
16:27 - line
16:28 - um how that read lines will actually
16:30 - include that new line character
16:32 - and then what print does is it will add
16:35 - a new line character
16:36 - at the end of everything you print so
16:39 - this is basically um
16:43 - basically equivalent to like you
16:44 - pressing two enters
16:46 - whenever you print lines so that's why
16:49 - this is double space
16:50 - wow wow that read is single space
16:55 - and what you can do to solve this is
16:58 - just like applying that
16:59 - strip
17:03 - and then that'll get rid of like all the
17:05 - extra white space in front of
17:07 - and behind of the um like at the ends of
17:11 - the line
17:12 - and that the white space includes like
17:14 - newline characters
17:17 - just kidding so it should strip the new
17:20 - line characters like this
17:24 - or not but like sorry
17:27 - there's there's like a function to like
17:29 - get rid of spending on characters
17:33 - we're away there we go
17:38 - and then you can use just fine you can
17:40 - find that script minion characters
17:42 - and just make sure like i did i did a
17:44 - sequence but
17:45 - just make sure you reassign it back to
17:47 - your lines so that when you print it
17:49 - it'll get rid of the newline characters
17:53 - so you can like this is how you can
17:56 - basically
17:56 - read mine um like read the file line by
18:00 - line
18:01 - and then you can even do like string
18:02 - manipulation for each of the ones
18:06 - so next we can talk about like how do
18:09 - you
18:09 - how can you um can you print those files
18:14 - so like let's first
18:19 - put our um file player
18:27 - back to begin
18:32 - so like i wrote in chat like
18:35 - you can just use file.right and that's
18:38 - basically like
18:39 - my your print statement and you um
18:44 - into whatever file you're on writing to
18:48 - so i can do something like file.right
18:50 - and as you can see
18:53 - it printed out hat over here and it
18:56 - basically overlooked like the first
18:58 - three
18:58 - um letters of the file
19:02 - so that's basically like how you can
19:06 - write to a file just be aware that like
19:10 - you have if you want to like write
19:12 - multiple lines of files
19:14 - always make sure you add a new line
19:16 - character at the end
19:17 - so um this is this is basically like
19:21 - you pressing enter on the keyboard
19:25 - and you run this
19:29 - as you can see it prints cap on it um is
19:33 - isn't this like super dangerous so like
19:36 - yes and though so you can certainly like
19:39 - you can definitely
19:40 - mess things up like you can
19:43 - overwrite things like accident um
19:48 - dangerous as in like can you mess up
19:51 - like your
19:52 - like any important files in your
19:54 - computer system
19:55 - um you shouldn't be able to because
19:59 - your computer system naturally protects
20:01 - against like
20:02 - against users acne overwriting um
20:05 - files that they shouldn't um write to
20:07 - you so like
20:08 - if it's any super important file like
20:12 - um let's say like whatever um code that
20:15 - actually reads your operating system or
20:17 - something like that like
20:19 - definitely you can't write to that you
20:21 - like
20:23 - it's that would be like a read only file
20:26 - so you wouldn't be able to write unless
20:28 - you have a super special permission um
20:30 - but you can definitely overwrite things
20:31 - by accident so just be careful about
20:33 - that
20:34 - is there a way to copy and then edit
20:37 - um you can definitely copy
20:40 - what you can do is like you can you
20:43 - gotta definitely like use
20:45 - um i would recommend checking out
20:48 - something like
20:50 - the python's os module which will let
20:53 - you like
20:54 - do a lot of um well which will basically
20:58 - let you do things like um new files
21:02 - or like copy files in your computer
21:04 - system
21:05 - and then after that you can like upload
21:07 - it back again
21:08 - um get your file from like the computer
21:11 - system
21:12 - and like get the file name then like
21:14 - change that finding to something like
21:16 - temp dot txt and then right to that
21:19 - and then after you write you that
21:20 - successfully you can then like
21:23 - change that name again to like actual
21:26 - file name
21:27 - dot like dot txt and then that
21:30 - might be a might be a little safer
21:34 - um but that would be that that would be
21:38 - a little more complicated
21:40 - um for it for like what we're talking
21:43 - about right now
21:44 - um so something like
21:50 - um usually when you like when you have a
21:53 - right option
21:55 - so like let me change this w
21:58 - so what right will actually do is like
22:00 - if you don't already have the file
22:03 - in your system um for example like i
22:06 - want to
22:06 - write you e dot txt well if it's not
22:09 - already in my system
22:11 - then um right will actually create it
22:14 - or like the right mode will create that
22:17 - file
22:18 - so let me comment out these first so
22:21 - if i if i'm in right mode and i open my
22:24 - file in right mode and
22:26 - it like this file doesn't already exist
22:30 - in my system
22:31 - then um python will actually create that
22:34 - file
22:34 - once i close this and then that way you
22:37 - can
22:37 - basically guarantee that you're never
22:40 - writing
22:41 - into like into a file that already
22:43 - exists and then you're never
22:44 - actually overwriting it yep
22:48 - so but camilla's camilla was like really
22:51 - close like
22:52 - always be careful about like what you're
22:56 - over
22:56 - writing and like where you're writing
22:59 - you
23:00 - so i could like create examples so like
23:04 - let's say i have a folder called assets
23:07 - and then in my phone like i want to
23:10 - write something into the assets folder
23:14 - always make sure you specify the
23:15 - location
23:16 - [Music]
23:18 - so like you tell python where i want you
23:20 - to you
23:21 - and then it will write it into that
23:22 - folder
23:24 - so basically
23:28 - like let me scroll back up to where we
23:31 - put
23:31 - open there you go
23:35 - so when we're referring to like file
23:37 - name in this open function
23:39 - it's a little bit misleading because
23:41 - it's not really the file name
23:43 - it's more of the file location so
23:47 - you have to tell python where exactly it
23:49 - is
23:50 - because relative to um your current
23:53 - location so like wherever
23:54 - your program is located
23:57 - so if i have like my program
24:00 - over here which is located and say like
24:02 - the main folder
24:04 - i have if i ever want to access a file
24:08 - that's in a different folder or in a
24:10 - different like
24:12 - in a different part of my computer i
24:15 - have to tell python
24:16 - where that location is relative to where
24:19 - my my python script is and then
24:23 - yeah just like be aware of that too
24:26 - any other questions about like anything
24:30 - we've talked about with files so far so
24:33 - next we're gonna just be talking about
24:35 - um csv files
24:37 - um this is sort of optional
24:40 - where um so first off like what are
24:44 - csv files csv files are just commerce
24:47 - separate like csv just stands for comma
24:49 - separated values
24:50 - these are basically files that only have
24:53 - letters and numbers
24:54 - so no like weird ascii things no like
24:57 - stars
24:58 - dots or slashes stuff like that just
25:00 - letters and numbers
25:01 - and these are like all of these
25:05 - values are separated by commas um
25:08 - it's a very common way to store a lot of
25:10 - data so let's say i have like
25:12 - i'm studying the solar system or
25:14 - something and
25:15 - i have um data of like
25:19 - the the temperature in in california
25:23 - from the past 10 years and that's like a
25:26 - that's probably like a data set of like
25:28 - a million data points
25:31 - so um what i can do is
25:35 - i instead of like storing it in a giant
25:37 - word document or like an
25:38 - uh excel file or something like that i
25:41 - can store it as a csv
25:42 - file so that it's only numbers and all
25:46 - these numbers are just separated by
25:47 - commas
25:48 - and this way like my file is small
25:51 - because
25:52 - um csv file doesn't have to account for
25:54 - like a lot of
25:55 - extra fluff that these more complicated
25:58 - files like word documents or
26:01 - xmls have to like store two
26:04 - and it's a lot simpler to be into um
26:08 - into a language like python and this is
26:10 - especially
26:11 - important for python because python is
26:14 - a very important language for like data
26:16 - processing
26:18 - so this is commonly used for like things
26:20 - like computer
26:21 - vision for like statistics um for any
26:24 - type of research where you're dealing
26:25 - with large data
26:28 - and um you can definitely parse the csv
26:32 - file
26:32 - using all of these um
26:36 - all of these file file dot reads
26:40 - um all of the functions that we talked
26:42 - about earlier
26:43 - but you can also um you can there's also
26:45 - an easier way
26:46 - to read a csv file and that's fine using
26:50 - the csv library that's built into
26:53 - private for
26:54 - this one like it's definitely a lot the
26:57 - syntax is definitely not as complicated
27:00 - as um first off it's not as complicated
27:02 - as
27:03 - python and um basically you can just
27:06 - like first open the file
27:08 - and then um make sure you import like
27:11 - the
27:11 - csv library first um
27:15 - the general way is like you open the
27:17 - file and after that
27:19 - you can just call like csv dot reader
27:22 - and then pass in the file object and
27:24 - then pass in a cylinder
27:26 - a delimiter is basically like what is
27:29 - separating
27:30 - the um the each data value and in this
27:34 - case it's just commas
27:36 - and then it'll return a csv reader
27:40 - object that'll basically let you beat
27:42 - the csv file
27:43 - line by line and then call by column
27:49 - so let's just check out a quick example
27:51 - of this
27:52 - yeah the limiter um sorry sorry cylinder
27:55 - can be anything so the thermometer can
27:57 - be anything like it can be spaces it can
27:59 - be
27:59 - cooling stuff like that but um generally
28:03 - like
28:03 - for csv it's always a comma
28:06 - and i think
28:10 - that
28:13 - that like they they've let you set the
28:16 - delimiter to like anything you want
28:18 - because sometimes
28:20 - people will like store csv files like
28:22 - spaces
28:23 - or like commas and spaces
28:26 - um yeah it can be it can be
28:30 - more than one character it can be like
28:31 - aba it can be
28:33 - like a string like note or something
28:35 - like that
28:37 - um as long as it's just one string
28:42 - so what i mean by that is like it can't
28:44 - be like
28:45 - it can't be like a comma or a
28:48 - period it has to like be consistently
28:51 - separated
28:52 - by one string so like it has to be
28:56 - consistently separated by a comma
28:58 - or consistently separated by a space
29:04 - but um yeah i think it's it's to
29:07 - compensate for the fact that like some
29:09 - people will store
29:10 - their data in different ways
29:13 - or like they'll store their csv files
29:16 - except
29:17 - with their data separated by different
29:18 - things but like
29:20 - technically it should always be a comma
29:24 - all right so back to the demo so
29:28 - for this demo we have a dot csv
29:32 - file called test.csv and as you can see
29:35 - it stores like it stores
29:36 - a bunch of strings it stores letters it
29:39 - also stores
29:40 - numbers and
29:43 - most importantly you must first call
29:46 - import.
29:47 - import csv so this will basically tell
29:50 - python like hey i need the csv library
29:52 - make sure you have all the um all the
29:56 - functions that you define in that
29:57 - library ready so that i can use it
30:01 - so the first thing we do is we have to
30:04 - open the file
30:06 - so i opened test.csv in the read mode
30:09 - because right now we'll just be reading
30:13 - um next i have to create like a
30:16 - csv reader object so i have to call csv
30:20 - which is my model module here csv dot
30:23 - reader and then i'll pass it in my file
30:27 - and then i'll pass in the limiter equals
30:30 - a comma
30:31 - and then it'll return a reader object
30:33 - that
30:34 - that i just called data so for a csv
30:38 - um for how a csv work
30:42 - or csb reader object works is that
30:46 - it will basically give you the like
30:49 - everything in that file um by row
30:52 - and by column so it's basically like a
30:56 - to like a nestedness so like a
30:59 - think of it like a matrix um
31:03 - so i'll always have you say like four
31:05 - wrote in data
31:07 - and in this case our data only has one
31:09 - row
31:11 - and then four data point in row so
31:15 - four row and data will just return me
31:17 - like
31:18 - this line of um of the csv
31:24 - and then for um for data point and row
31:29 - we'll return the each of each point in
31:32 - that note
31:33 - oh by the way make sure like you
31:37 - make sure you fork before you change
31:39 - code
31:43 - so that like we won't have issues with
31:46 - like
31:48 - um editing each other's code so just
31:51 - make sure you force before you um play
31:53 - around
31:55 - but um next i just
31:58 - at first i just to put in each data
31:59 - point but um we can also print each from
32:03 - each row as a string so you can see how
32:07 - like
32:08 - over here it shows that each
32:11 - each row is basically each row in this
32:13 - yes me
32:21 - and there you go um let me comment
32:24 - this out first so that we can see each
32:27 - data point
32:39 - and as you can see like it can print out
32:41 - each data point
32:42 - of the csv file so this is just a way
32:46 - um that if you have a csv file
32:49 - that you can like relatively pretty
32:51 - easily like
32:52 - just read each data point in that file
32:54 - without having to
32:56 - like because like if you use all of
32:59 - these like files like general file
33:02 - methods
33:03 - you'll run into like some it'll be like
33:06 - a lot of code that
33:07 - extra code that you'll have to write
33:08 - just to like read a bunch of
33:10 - data points from a very simple file
33:13 - but using the csv module will actually
33:16 - let you um
33:17 - will actually let you save someone's
33:19 - opponent and it'll be a little more
33:21 - intuitive
33:21 - especially like when you're working in
33:23 - like a row-by-row column-by-column basis
33:27 - any questions about that
33:34 - all right um you can also definitely
33:37 - like the csv module has
33:39 - uh um a csv dot writer
33:43 - thing that or object that will let you
33:46 - write
33:46 - your own csv files but it's very
33:49 - complicated
33:50 - so um you can definitely like check that
33:53 - out
33:53 - on your own free time but it takes a
33:55 - little bit
33:56 - more understanding like what exactly
33:58 - like is a csv file and
34:01 - sort of like the specifics of um of
34:05 - that sort that like the um data
34:08 - science sort of side of python
34:12 - so what i would recommend you like if
34:14 - you're interested
34:15 - definitely check that out on in the
34:17 - official documents
34:22 - all right so finally i'm 505.
34:27 - so question one is
34:30 - which of the following are incorrect
34:32 - file handling modes
34:34 - um r a plus c w
34:37 - t plus or w minus and
34:41 - just a hint there are more like there
34:43 - are more than one correct answers
34:45 - and i'll give you a couple of minutes to
34:49 - um
34:50 - to think about it and you can drop your
34:52 - answers in chat
34:53 - yep c is one of the incorrect ones yep
35:02 - so e c
35:04 - [Music]
35:05 - f and d
35:09 - close but not quite b a
35:12 - plus is a valid
35:15 - is a valid about handling mode
35:18 - um i would scroll up to the i would
35:21 - scroll up to the
35:22 - this slide but it will show you all the
35:25 - answers
35:28 - is correct so fs1 sorry f
35:32 - is not a valid value so you can't have
35:35 - minuses because
35:37 - um python would be like i don't know
35:38 - what it what a negative um
35:40 - mode is but you can you can have pluses
35:44 - because the plus represents sort of like
35:47 - if i'm in a right mode then the plus
35:50 - would be like oh i can also read
35:52 - which is a little confusing but
35:54 - unfortunately that's how they designed
35:56 - it
36:00 - but um you guys are very close
36:03 - so it's e c and f
36:06 - so e like there's no um there's no t
36:09 - mode
36:10 - but the so yeah so there's no t mode
36:14 - um c there's no again there's no c
36:17 - mode and then option f you can't have a
36:21 - minus
36:22 - so the w is correct but the minus isn't
36:24 - and um if you guys are
36:26 - familiar with things like encoding you
36:28 - can also have the
36:29 - b mode which is a little confusing but
36:32 - it's basically like
36:33 - um usually i want to say um
36:36 - i want to say most files are encoded in
36:38 - like utf or something
36:40 - so so if you're familiar with like how
36:42 - files are encoded
36:43 - there's like a bunch of ways to encode
36:45 - files it's different between like linux
36:47 - and windows but um
36:50 - generally like most files are included
36:53 - one way but there are some files that
36:54 - are encoded in
36:55 - binary and
36:58 - you can have something like rb which is
37:00 - read a binary file or wp which is right
37:03 - a binary file
37:04 - and like 80 which is append to a binary
37:06 - file so you can definitely have that and
37:08 - then like
37:08 - you can also tack on the plus at the end
37:11 - and that's just a fun fact but
37:13 - we didn't include the binary because
37:15 - like in the slides just because
37:18 - it's it it will be a little confusing if
37:21 - you don't understand like
37:22 - the different sort of ways to encode a
37:25 - file
37:28 - all right so question two what's the
37:31 - output of this code
37:34 - so this doesn't really um related to
37:37 - this is more related to the um
37:40 - the lesson before halloween so we have a
37:44 - um we have code that's we have a equals
37:47 - 100
37:48 - and then we define a function foo
37:51 - and where we define a equals 10
37:55 - and then after that when i print a
37:59 - what will i get back
38:03 - um you will get like the value of a so
38:05 - like what's the
38:06 - value of a
38:11 - correct it'll be a hundred so
38:15 - why is that we have so over here we have
38:19 - the global variable a
38:21 - not exactly yeah
38:24 - so or you're on the right track
38:27 - but technically
38:32 - technically it's jack i can i can
38:35 - explain it first so like
38:37 - you have over here you're defining a
38:39 - global variable egg
38:40 - however inside of food you're actually
38:43 - defining
38:44 - a local variable called a so these two
38:47 - a's are in different scopes
38:48 - so they're technically different
38:50 - variables remember that if i want to
38:53 - refer to a global variable
38:55 - inside of a different scope a non-global
38:58 - scope
38:59 - i have to use a global keyword
39:02 - so if i define some i could have
39:05 - redefined you as like
39:09 - um as something like global
39:13 - a pretend that third tabs in front of
39:15 - this
39:16 - and then a equals ten then that would
39:19 - and then i called
39:20 - you outside so if i did something like
39:24 - print
39:25 - boo that's that way i've actually
39:29 - redefined as 10 but because like
39:32 - so camilo is partially correct that like
39:35 - that
39:36 - first off i didn't call food but even if
39:39 - i did call do
39:42 - um like this definition of food and
39:45 - i printed afn it would still print 100
39:48 - because um this a inside of the two is
39:53 - actually
39:54 - a local variable so once i exit through
39:57 - this a equals 10 inside of you will
40:00 - actually be destroyed
40:01 - and then um python will actually refer
40:04 - back to this global variable
40:06 - a so does a outside of the function
40:09 - have a different reference than the a
40:11 - inside the function
40:12 - yes technically so like let me see if
40:16 - there's a
40:18 - all right let me it might be easier if i
40:20 - draw it out see
40:24 - we have paper so so
40:27 - first off like once i hit that can
40:30 - everyone see my little notepad
40:33 - so when i hit like
40:36 - equals 100 i have a global
40:39 - function or a global variable that'll
40:42 - basically assign
40:43 - a 100. oh wait jessica i don't think you
40:46 - could see yours
40:50 - i think it's because it's a virtual
40:52 - background though
40:55 - let me see okay let me let me try this
40:58 - annotate thing then
41:00 - so like you guys can see me drawing on
41:03 - the screen right
41:05 - yeah sweet so over here like
41:08 - what python would do it'll have
41:10 - basically like a little list
41:12 - tracking like like the variable names
41:16 - and mapping down to like the variable
41:18 - values
41:20 - so over here this little list will have
41:22 - like
41:23 - a equals 100.
41:27 - sorry sorry about the messy handwriting
41:30 - but let's pretend that says 100.
41:34 - then once it enters inside of the scope
41:38 - it'll actually create like
41:42 - a little we'll call it like an inside
41:44 - list
41:47 - of like a local scope so like
41:51 - this like where i'm like drawing this x
41:54 - this big list
41:55 - will be like all the global references
41:58 - so like this
41:58 - a goes a hundred but inside of
42:02 - this little box that you
42:05 - that's actually where um python will be
42:08 - putting
42:09 - this a and the time so
42:12 - inside this little box it'll be
42:14 - assigning the local variable a
42:17 - to the value pen however
42:20 - once it exits that method once it exits
42:23 - through
42:24 - what happens is that this local like
42:27 - this local list will be destroyed so
42:30 - then
42:30 - once i'm back at um print a over here
42:35 - like at the very end so once i'm back at
42:39 - this print a over here
42:41 - it'll actually be referring back to the
42:43 - original list
42:44 - because this little globe like this tiny
42:47 - local um local list of
42:51 - variable names and values will be
42:52 - destroyed so this 8
42:54 - a 10 will be destroyed at the very end
42:58 - does that make sense so like
43:02 - you're right that um technically the a
43:05 - outside
43:06 - function will have a different reference
43:08 - from the a inside the function
43:10 - um in very basic terms it's just that
43:14 - they're they're in different like
43:17 - they're in different reference lists and
43:20 - the a
43:20 - that the reference list that this a was
43:24 - put in inside of um the foo method would
43:27 - have been destroyed once it exits that
43:28 - scope i want to say yes
43:31 - i'm honestly not too sure because python
43:34 - does a lot of
43:35 - a lot of like memory shenanigans so
43:39 - i can't say for sure that like that
43:42 - that's exactly how python works
43:46 - but in i like
43:49 - in general like on a very basic level
43:51 - yeah those are two different
43:53 - references um i can't even say like
43:56 - they're actually references because like
43:59 - python i believe like
44:02 - like the integers count as python
44:05 - primitives so like they're actually just
44:08 - stored like that
44:10 - but um they're not like usually when you
44:13 - like refer to your references in
44:14 - in um in programming you're referring to
44:17 - like
44:18 - um a is pointing to like a different
44:20 - address or like a certain
44:22 - address to like a different object but
44:24 - um
44:27 - technically yeah they're in two
44:28 - different places in memory
44:30 - because they're storing two different
44:32 - values so
44:34 - i i would give that a tentative yes
44:37 - but because python
44:40 - yeah sorry sorry i can't give you like a
44:42 - very definitive answer but it's just
44:43 - like
44:44 - because python does a lot of little
44:46 - memory shenanigans
44:47 - like and hides it away from you it's
44:50 - it's hard to say
44:51 - like yes this is what python does but
44:54 - tentative yes so most likely all right
44:57 - so next question what is the output of
45:00 - this code then
45:02 - so i have a um i have a function called
45:06 - add
45:06 - and it has two variables x and y the
45:09 - default um
45:10 - the default value for y is y equals 100
45:12 - and it just returns x plus y
45:15 - when i call add 10 what will it return
45:18 - so what would be the output
45:20 - of this 110 um
45:24 - you're on like i can see like you've got
45:26 - heard of it right
45:27 - but um camille has a good point 100 is
45:31 - not a number
45:33 - so what happened if i caught add 10
45:36 - in this case then
45:39 - can i add like a string to a number x
45:42 - plus y equals x 100
45:45 - um what's x then are you referring to
45:48 - like
45:49 - are you saying that it will return 10
45:51 - 100 so like one zero one zero zero
45:53 - yep so it will return an error more
45:56 - specifically you'll return a tight error
45:58 - and that's because unfortunately python
46:00 - doesn't
46:01 - like do any conversion of strings to
46:04 - integers for you
46:05 - so you can't so yep
46:09 - exactly you can't um you can't add
46:12 - strings to integers
46:14 - the um the solution would just be like
46:17 - you have to
46:18 - um cast either x to a string
46:22 - or like y to an integer either one would
46:24 - be fine
46:25 - depending on what you want to do with ad
46:29 - or instead of like calling ad 10 i can
46:32 - actually just call add dog or something
46:35 - like that
46:35 - i just have to pass me a string all
46:37 - right question four
46:41 - so what are the advantages of using a
46:43 - csv file
46:44 - so we talked about the forum csv files
46:46 - are
46:47 - only taken numbers or letters
46:52 - and they'll always be separated by
46:53 - commas so
46:55 - why would i ever want to use a csv file
46:58 - then
46:58 - if i have like if i have infinitely more
47:02 - complicated files like
47:04 - why use a csv file over a word document
47:08 - yep it would use less space so like
47:11 - when you when you um save something to
47:14 - like a word document
47:15 - or like a um excel file you'll basically
47:19 - be not just saving saving not just like
47:22 - the is class done um
47:26 - it's seven so like if you have if you
47:29 - once you leave like feel free to um we
47:31 - have one more question left
47:32 - and i can take answers or questions
47:35 - after that
47:36 - but like yeah sorry about running over
47:39 - but if you want you leave feel free to
47:42 - so
47:43 - you're correct that it uses bus space so
47:46 - first off the csv file
47:48 - will like will be consistent
47:52 - yep it'll be easier to automate because
47:55 - it's always you'll have consistent
47:57 - characters you won't have to deal with
47:58 - like
47:59 - weird um weird ascii characters like an
48:02 - exclamation point
48:03 - or like an asterisk or something like
48:05 - that you don't have to take like those
48:07 - into account
48:08 - um it'll also take up a lot less memory
48:10 - space a csv file
48:12 - is doesn't save like your configurations
48:15 - or like
48:16 - any other fancy fluff it'll just save
48:19 - the numbers and the letters and the text
48:22 - and that way like because of those two
48:24 - you can store and process
48:27 - large amounts of data very efficiently
48:29 - using a csv file
48:32 - all right and then last question
48:36 - so what are some applications of file
48:39 - input output then
48:41 - what's the purpose of like learning file
48:43 - items
48:44 - or i guess you put it better like
48:48 - what's um what's one way you can apply
48:51 - file
48:51 - file input output or you can use like
48:54 - file
48:55 - processing in like in a
48:58 - real life application so i think of
49:00 - where some
49:01 - real epic real life examples of
49:04 - of file in like your and like your
49:08 - day-to-day life
49:09 - so like um i would i would give
49:13 - up i would give absolutely like
49:15 - something like word or something like
49:16 - that
49:17 - but how do how do you applications use
49:20 - highlight
49:22 - custom automatic files what do you mean
49:24 - by that
49:25 - like they you mean like make
49:31 - you can have a list or
49:35 - a bunch of lists with different data
49:37 - names
49:38 - age classes something like that
49:41 - then you could call
49:44 - this search for any specific item and
49:47 - make a
49:48 - file for example all my classes or
49:52 - other students that are over 20 years or
49:55 - something like that
49:56 - yep that's a that's it like
50:00 - that's a good way to apply file like you
50:03 - can
50:03 - basically store large amounts of data
50:06 - and then
50:07 - into like a bunch of files and then you
50:09 - can
50:10 - search through those data
50:13 - um capture sensors data yep
50:16 - so a very um
50:20 - a very important part of file io is that
50:22 - you can store
50:23 - information so um if you don't use files
50:28 - what happens is like your program runs
50:30 - um you can like stir a lot of
50:32 - information in your program like
50:33 - get stored in global variables but once
50:35 - that program ends
50:37 - all of those variables disappear they
50:38 - all get cleared out in memory
50:40 - however if you write all those into a
50:42 - file you can have persistent data
50:44 - so your data will persist after that
50:47 - program dies
50:48 - um another thing is like communication
50:50 - between different programs
50:52 - so um you would it would that would be
50:56 - like
50:56 - one like program a will write a bunch of
50:59 - information into a file
51:01 - and then program b can pick up that file
51:03 - and like use that information
51:05 - for like whatever it would do
51:08 - um a very common application of files
51:10 - like file input output
51:12 - is actually like customization so like
51:16 - you know how in um in
51:19 - yeah it's pretty amazing but you know
51:21 - how like in um
51:22 - say like word or um or even like when
51:26 - you're setting up
51:27 - your operating system you can like
51:29 - choose different preferences like
51:31 - i want my night mode to turn on at like
51:34 - 6 p.m
51:35 - or i want my um background to be blue
51:39 - or i want my um i want
51:42 - word to like every time i press like
51:45 - ctrl d i want word to do something those
51:48 - are
51:48 - actually all stored in the file and each
51:51 - time like
51:52 - you open the upward it'll read that um
51:55 - customization file that configuration
51:57 - file
51:58 - and it will be like oh so this is like
52:00 - what the user wants
52:02 - and then it'll be able to like apply
52:04 - that to the program
52:06 - um so those are like that's a very
52:09 - common
52:09 - thing for um that you want to like do
52:13 - file io for
52:17 - any questions about like um file io
52:21 - and these are different
52:24 - um further readings that i would i would
52:26 - highly recommend you
52:27 - check out the um python csv official
52:30 - documentation and like
52:32 - these um these first two links are
52:35 - just like more more um more explanations
52:39 - about like file input output
52:42 - and i'll actually upload
52:47 - um the powerpoint in case you guys want
52:50 - to um
52:50 - check out the demo links or like check
52:53 - out the other slides
52:54 - yep so that's the end of the lesson
52:56 - thank you so much for coming to today's
52:58 - lesson
52:58 - and if you have any questions i'm
53:00 - willing to stay behind and
53:02 - and answer it um otherwise you're free
53:04 - to go