00:00 - okay so for today um we'll just be
00:03 - talking about
00:04 - really basic object-oriented programming
00:06 - concepts in python
00:07 - and um don't like worry about the the
00:11 - terms and stuff this is mostly just
00:13 - about um how do you make classes in
00:16 - python
00:17 - and what how do you like um we'll talk
00:20 - about like data fields
00:21 - and um different different like methods
00:25 - and stuff you can do with like classes
00:27 - in python
00:32 - all right so our agenda today is just
00:35 - like
00:36 - talking about what is object-oriented
00:37 - programming um what are classes
00:40 - and then more specifically for python
00:42 - like how do you make class data fields
00:45 - how you make class methods
00:46 - and if we have time but probably not um
00:50 - for
00:50 - four basic principles of object oriented
00:56 - programming
00:58 - all right so first off what is like oop
01:01 - which is object-oriented programming
01:03 - um it's basically a programming like
01:06 - a programming design concept as you can
01:09 - put like a programming paradigm
01:11 - basically where
01:12 - code is based off of things called
01:13 - objects so objects can be things like
01:16 - um like cars or like animals like
01:20 - just like your basic objects in an
01:22 - abstract sense
01:23 - and these objects will hold things like
01:25 - data and code
01:26 - which will form fields which are
01:28 - basically your class variables
01:30 - and functions which are class methods
01:32 - any questions about that first
01:37 - so basically like in this example you
01:39 - can see we have a class called car
01:42 - and it can have methods like get fuel or
01:44 - like
01:45 - set speed or drive and they can also
01:47 - have
01:48 - attributes or um fields like um
01:51 - fuel max feed number of wheels colors
01:54 - stuff like that
02:01 - all right so first just a basic
02:04 - overview about classes and data fields
02:09 - so first off an object is a collection
02:11 - of variables and functions
02:12 - that like describe something abstract so
02:14 - for example um
02:16 - a car can be an object uh animal can be
02:19 - an
02:20 - object basically a very abstract
02:23 - thing you want to define using variables
02:25 - and functions
02:26 - a class is basically a blueprint of an
02:28 - object so
02:30 - in the previous slide we have like a
02:32 - class called car
02:33 - and that is basically like a blueprint
02:36 - that you can like
02:36 - make an object of a car basically
02:40 - it will tell you like what um what
02:42 - attributes a car should have what a car
02:44 - should be able to do
02:45 - and what information a car can store
02:47 - basically
02:49 - um another thing is an instance which is
02:52 - like the object itself
02:54 - so when you create an object it's called
02:59 - insanitation
03:01 - so that's just like
03:07 - um next like more specifically for
03:09 - python the self keyword refers to the
03:11 - instance
03:12 - so if you use the self keyword in python
03:14 - you're referring to the instant like
03:16 - the instance of that class
03:19 - um next an attribute is just any
03:22 - property of a class
03:23 - so it can be a variable or a function
03:26 - and finally a sub class is a class that
03:30 - inherits
03:30 - attributes from another class
03:35 - all right so first off we'll talk about
03:37 - class data fields
03:43 - all right so a data field is if you
03:46 - remember is something like
03:48 - information that a class can store so
03:51 - like
03:52 - let's go back to our um class card
03:55 - example
03:56 - if we have a class called card a data
03:58 - field that we can
04:00 - have in car could be something like
04:01 - number of wheels or um
04:03 - max driving speed or um the color of the
04:07 - car
04:08 - so these are information that class in
04:10 - store
04:11 - a data field has two types one is static
04:14 - which is a data that is
04:17 - shared across the entire class um
04:21 - or one that is instance which is data
04:24 - that is shared the order that is kept
04:26 - only by the instance
04:28 - of that class so um
04:31 - going back to the car example like we
04:33 - can have a static
04:34 - data field called like total number of
04:37 - cars
04:38 - and that would be the total number of
04:40 - cars would be the same across
04:42 - any instance of a car but like something
04:45 - like
04:46 - uh the color of the car or the um
04:49 - the license plate number would be
04:52 - different
04:53 - um different between each instance of a
04:56 - card
04:57 - and that would be an example of an
04:59 - instant state of view
05:07 - you can also control the visibility
05:10 - of your the data in your class
05:13 - so there are three types one is public
05:16 - which is
05:17 - a field that everyone can see one is
05:20 - private which is
05:21 - a field that can be seen and changed
05:22 - only within the instance
05:24 - or like only within the current class so
05:27 - for example a public data field can be
05:30 - the color of a card because everyone can
05:33 - see that
05:36 - and
05:42 - sorry just a moment
05:45 - so
05:51 - basically um
05:56 - a public data field could be something
05:58 - like number of people in a car
06:00 - um that is a field that can be seen and
06:02 - changed by anyone
06:03 - but a private data field would probably
06:06 - be like
06:07 - the um we could say like the type of
06:10 - engine the car has
06:12 - and can be a field that can be changed
06:14 - only within the current class
06:17 - finally you also have something called
06:18 - protected and that's a field that can be
06:20 - seen and changed
06:21 - within the current class and any
06:23 - subclasses
06:24 - of that class
06:31 - any questions about like data fields so
06:34 - far
06:40 - all right um finally we'll talk about
06:44 - we'll talk a little bit about class
06:45 - methods and then we'll like
06:47 - i'll walk you through some demos that
06:49 - will make all of this a little clearer
06:55 - so class methods are um just
06:58 - something that allows objects to perform
07:00 - actions
07:02 - so like if you have the class car you
07:04 - can
07:05 - have methods called like drive or speed
07:08 - up and slow down
07:09 - and those methods would allow the car to
07:12 - actually do
07:13 - a few things instead of just holding on
07:15 - to information
07:17 - um similar to um data fields
07:20 - you also have static and instance
07:22 - methods
07:23 - so like a data field um static is just
07:26 - the method that is
07:28 - tied to the class and not the instance
07:30 - and instances method is tied to the
07:32 - instance of that class
07:33 - instead of the class itself so the
07:37 - syntax
07:37 - is just if you want to call the static
07:40 - method it's the class name
07:41 - that method and then if you want to make
07:44 - a static method you have to use this
07:46 - static method tag
07:48 - um for instance when calling it it's
07:52 - just
07:52 - instant stop method and then making
07:56 - a um uh instance method
07:59 - it's just like making a regular method
08:02 - um
08:03 - within the class but you have to pass in
08:05 - self
08:06 - as the first parameter of that method
08:15 - and overall a class has three important
08:17 - functions so
08:19 - first one is constructor which just
08:21 - makes an instance
08:22 - second is setters which will help you
08:25 - set variables
08:26 - in the class and finally you have
08:28 - getters which helps
08:30 - you on access variables within class
08:32 - technically
08:33 - all of these are optional methods so
08:37 - technically like you don't have to have
08:39 - a constructor
08:40 - but you'll never be able to make the
08:41 - instance of that class if you don't have
08:43 - a constructor
08:52 - so first are constructors um
08:56 - for python constructors are defined by
08:58 - the under
08:59 - double underscore init double underscore
09:01 - method
09:03 - um if you don't define in it you won't
09:06 - be able to create instance of the class
09:11 - and first off we can look at a demo of
09:20 - this
09:23 - so in this instance you have a um
09:26 - a class called dog
09:30 - and you have like a static
09:33 - variable called dog count so
09:37 - we could we could use this to actually
09:40 - first go over
09:42 - um things everything we talked about
09:44 - before
09:46 - so first we could talk about um
09:49 - data fields so for a static data field
09:52 - you um you initiate it outside of
09:56 - instructor
09:58 - so if you have something called dog
10:00 - count
10:01 - you if you put it outside of like
10:05 - the constructor over here then it'll be
10:08 - defined
10:09 - as a static variable
10:16 - um next any instance variables
10:20 - will be created within the init function
10:24 - so basically um
10:28 - an uh instance variable you have to be
10:30 - referred to as self
10:32 - dot variable name so for example
10:35 - if i pass in name from my constructor
10:40 - then i can store it as an instance
10:42 - variable here
10:43 - self.name equals name you can also set
10:46 - like
10:46 - default um default values for your
10:50 - your instance variable so like self that
10:52 - noise equals bark
10:54 - or um if you don't want to set any
10:56 - specific
10:57 - value like starting value for your
11:00 - instance
11:01 - um be sure to specify it as none
11:04 - so you can't just like declare something
11:07 - like
11:08 - a static variable and leave it like this
11:10 - or also throw an error
11:13 - and python will be mad but
11:16 - so if you want to have something that
11:18 - doesn't have like a specific value to
11:20 - begin with
11:22 - just make sure you start as none first
11:26 - so if we define this init function
11:30 - and we can like we pass in like
11:33 - how many ever parameters we want into
11:35 - our constructor
11:37 - then we can define the instance
11:40 - instances of these classes
11:42 - and then pass in whatever information we
11:44 - need
11:45 - so if i have like a parameter like
11:49 - a constructor that takes in the
11:50 - parameter name av
11:54 - then i would have for like if i ever
11:56 - want to create
11:59 - over here then i'll still have to pass
12:01 - in like
12:04 - the um matching number parameters so
12:06 - name a b
12:08 - is the parameters i defined in this
12:10 - constructor
12:11 - then i'll have to make sure i have
12:12 - passed in like the same number of um
12:15 - variables into that constructor
12:19 - any questions about this
12:25 - all right notice that for my constructor
12:30 - i have to pass itself as the first
12:33 - parameter
12:34 - it's because this constructor is
12:36 - technically like an instance method
12:37 - you're just like creating an and it will
12:40 - actually do the creating of the
12:42 - instances
12:43 - if i don't like have this constructor
12:48 - then i won't be able to like create
12:50 - instances over here
12:51 - and it'll throw an error because there
12:54 - isn't um
12:56 - there isn't a defined in
13:07 - so if i do something like this
13:16 - um we can also do
13:22 - is i can also show you how to like
13:27 - just say you can also um access static
13:31 - variables
13:32 - within um within the class
13:36 - so to access something like a stack
13:39 - variable like dog count
13:41 - just make sure you have to access it
13:43 - instead of
13:44 - keeping like self dot um dog account
13:47 - like you would do with your instance
13:49 - variables
13:50 - you have to access it through the class
13:53 - so that would be like
13:54 - dog dot dog
13:58 - and then i can like edit it like this or
14:02 - um
14:03 - alter the value of the stack variable
14:08 - and then finally down here i can do
14:10 - something like print
14:12 - dog dot dog count
14:16 - and that should print two
14:34 - this is during the error because i added
14:36 - these two
14:41 - so as you can see here like i initiated
14:44 - two dogs
14:45 - and each time i i um call a knit
14:50 - it would increment dog count
14:53 - so and it prints two
14:57 - so this is just how you access instance
14:59 - variables and static variables
15:01 - and how you can like define instances
15:03 - and static variables
15:05 - using init and like placing your staff
15:08 - variables outside over here
15:10 - any questions about this code or
15:13 - anything like we talked about before
15:23 - all right
15:35 - so next we can talk about getters and
15:38 - setters
15:38 - these are just um generic names for
15:41 - methods that will
15:43 - for um get or set your variables
15:47 - so um getters will return like
15:50 - the value of whatever variable you pass
15:52 - in set will
15:53 - just set the value of that variable um
15:56 - the important part about this is it will
15:59 - let you
16:00 - access and change non-public fields
16:03 - and um in general like
16:07 - there are three ways to implement it
16:09 - first is like
16:10 - um implementing a getter and setter as
16:12 - like a normal instance method
16:15 - um next is just like using a
16:19 - app property tag and finally is um using
16:23 - a property method
16:24 - which we won't be going over because
16:26 - it's very complicated
16:27 - and not recommended
16:33 - so first um we can talk about
16:36 - implementing getters insiders like a
16:38 - regular method
16:39 - so this is generally like going over how
16:42 - you can create a regular instance method
16:46 - and um like
16:49 - how you could implement one way you
16:51 - could implement a gettering setter
16:53 - personally i would say like this is the
16:54 - best way to implement it because
16:56 - it doesn't like it's simple it's
16:58 - straightforward and
17:00 - it's a lot more um it's a lot more
17:04 - intuitive
17:05 - than the other two methods
17:08 - and the but the most important like
17:11 - downside of it is that it must be
17:12 - explicitly called
17:14 - so you can't just like
17:19 - you'll be able to see like for the other
17:21 - two methods that you can
17:22 - sort of um make it easy
17:25 - like make getting a setting pretty easy
17:28 - but
17:29 - um for this one just remember like if
17:32 - you implement
17:32 - a getter or setter as a regular method
17:35 - just make sure that
17:36 - like just remember that you have to
17:37 - explicitly call it in order to like
17:39 - change the variables
17:41 - of your um or change the values of your
17:44 - variables
17:46 - so we can take a look at the um
17:52 - the code and just i'll just walk you
17:54 - through like
17:55 - first how do you define non-public
17:58 - methods
17:58 - or non-public variables and then second
18:02 - um a very basic way of
18:06 - of um creating a getter or setter
18:10 - so first off like this is just building
18:12 - off of
18:13 - the dog class that i talked about in the
18:15 - previous demo
18:16 - so you still have like your dog count
18:18 - which is
18:19 - the static um static data field
18:22 - that we defined last summer um
18:26 - but i've changed the visibility of
18:29 - both name and noise a little so
18:33 - for um you notice that i have two
18:36 - underscores
18:37 - in front of name and noise and in python
18:40 - this is
18:41 - how you would define a private method so
18:43 - remember a private method
18:45 - is something that only that class can
18:48 - access like only
18:49 - that instance of that class can access
18:51 - so
18:52 - um usually like for a dog
18:56 - only they know their own name and
18:59 - you what like you shouldn't be able to
19:02 - access like
19:02 - the noise unless like they
19:06 - or they like bark or something so that
19:08 - was like the logic i put behind that
19:11 - but i made these two private methods or
19:14 - private
19:15 - private um properties so private
19:18 - variables
19:19 - so that nobody outside of that instance
19:22 - can see can access it so they can't see
19:25 - it and they can't change it
19:27 - so then if that's the case like how
19:30 - would
19:30 - i like what if i do want to change it in
19:33 - a certain case
19:34 - how would i be able to do that so
19:38 - for that i would define a set like
19:41 - setters
19:42 - that are basically instance methods
19:45 - in my class so one is set name
19:48 - which will just set the name if you like
19:50 - the new name you pass in
19:52 - next is set noise which would just set
19:54 - the self.double underscore noise to
19:57 - the new noise you pass in so
20:01 - it's this is pretty straightforward you
20:03 - just
20:04 - set the private variable to this new
20:06 - value
20:07 - um same with get so what if i want to
20:10 - know the value of these private private
20:13 - variables
20:14 - well you could just return um return
20:16 - self.double underscore name return so
20:18 - that double underscore noise
20:20 - these are basically like in this case
20:23 - like these are just
20:24 - um these are just average instance
20:27 - methods
20:28 - so you notice that i put bypass in south
20:32 - as my first parameter for all of these
20:36 - um and then in the main method
20:40 - you just have to remember to if you want
20:42 - to like get the name
20:44 - or like get the noise or you want to set
20:46 - it then you'll have to um
20:48 - you have to explicitly call it like dog
20:50 - that get named dog dot get noise
20:53 - or a dog that said noise to fred or
20:55 - something like that
20:57 - so um this is pretty straightforward
21:01 - the only downside is like every time i
21:03 - want to like
21:04 - access a dog's name i have to like call
21:06 - this method and maybe i'll take like a
21:08 - few extra lines of code
21:09 - in your program
21:13 - um any questions about this code so far
21:22 - all right
21:28 - so next the next way we can define
21:31 - a getter or setter it's a little more
21:34 - complicated
21:35 - so in python like you have you can tag
21:38 - your um your methods with like special
21:42 - tags
21:43 - um and one of them is the app property
21:46 - tag
21:48 - so if you like
21:51 - it's it allows you to treat like a
21:54 - non-public
21:55 - field like a public field so
21:58 - um and this is basically the general um
22:01 - the general template for defining a
22:03 - gettering setter that way
22:06 - so you would define the um
22:09 - getter as you would first tag it like
22:12 - with the property tag then you do like
22:15 - defau
22:16 - def um whatever attribute name um past
22:19 - himself
22:20 - and then returns the self.attribute
22:24 - next like for setters we'll just do um
22:27 - attribute that setter define the um
22:30 - define a method with the attribute name
22:32 - pass and self command value
22:34 - and then do self.attribute equals value
22:37 - and then af
22:38 - so after you like define it this way you
22:41 - would be able to like
22:42 - just set like treat your own
22:45 - your private values like their public
22:48 - values so you can just do like
22:50 - like outside of your class you can do
22:52 - like instance that attribute equals new
22:55 - value
22:56 - and that would like even if that
22:58 - attribute is private it would still be
23:00 - if you started
23:02 - so this is this would just like in
23:05 - general make your life
23:06 - a little easier
23:12 - um and i
23:16 - so i did do a demo of this
23:19 - and i'm not sure why it did not show on
23:22 - here
23:22 - but i can show you uh
23:26 - i'll share this with you
23:33 - not this
23:40 - there you go
23:50 - all right so
23:54 - here is just like a quick demo of how
23:57 - you can um define a getter and setter
24:00 - using this fancy property width
24:03 - this is the same class as we had um
24:07 - we had for the last demo so you have
24:09 - like your sad variable dog count
24:11 - um name and sound um you have a
24:15 - instance uh instance method called bart
24:18 - which is just printing out the um
24:20 - the sound private instance variable
24:23 - but if you notice for like like
24:27 - say i want to um i want to define a
24:30 - getter and setter
24:33 - for um my name my name attribute
24:37 - and i want to use this fancy property
24:40 - way
24:40 - so first off i would um we could look at
24:44 - the getter
24:45 - so for the getter you first um tag
24:48 - the the method with a property tag
24:52 - so at property and then i would define
24:56 - a instance method with that attribute
24:59 - name
25:00 - so if i want to define a getter for
25:03 - name then i would just do a property
25:06 - depth name and then remember to pass it
25:09 - so
25:10 - and then for the getter i would just
25:11 - return self that name
25:14 - and then next we can talk about um
25:18 - the setter and you would
25:21 - um tag it with at name dot setter so
25:24 - at attribute name dot setter
25:27 - and then it would be similar to the um
25:30 - the getter function
25:31 - except i would also pass in like
25:34 - a parameter that would be the new value
25:38 - of this um of my attribute and i just
25:40 - sent self.name
25:42 - to my new value so what's the
25:45 - benefits of where like the benefits of
25:48 - doing this
25:50 - this roundabout way basically
25:53 - one of them is i i don't have to
25:57 - explicitly call my getters and setters
25:59 - anymore
26:00 - what i can do is just access my um
26:03 - these attributes as public variables
26:06 - basically
26:07 - so if i um create instance of a dog
26:09 - called fred
26:10 - then i can just access my dog name as
26:13 - like
26:14 - as if it was a public a public variable
26:17 - and then same for um setting the
26:20 - variable so
26:21 - if i wanted to change the dog's name
26:23 - then i could just see dog that name
26:24 - equals bomb
26:26 - and then print out dog.name like that so
26:29 - one of the benefits for doing it this
26:31 - way is just that
26:32 - you can save a couple of lines of code
26:34 - and you won't have to worry about like
26:36 - oh do i have to call my getter
26:38 - explicitly and stuff like that
26:40 - any questions about this
26:50 - sweet
26:53 - so finally um you can also
26:56 - use like implement getters and setters
26:58 - using the property method
27:00 - um so basically you can define a static
27:03 - field
27:04 - that contains a property like property
27:07 - object related
27:08 - to that non-public field so i can define
27:10 - like
27:11 - uh um if i wanted to like
27:15 - do it um create like a create a getter
27:18 - and a setter for
27:19 - my um my like dog.name
27:22 - then i can define a stack field called
27:24 - name that contains a property object
27:27 - related to like my name field
27:30 - and then that would like it's similar to
27:33 - the second method
27:34 - with the property tag where it'll then
27:36 - allow me to like treat the non-public
27:38 - field like a public field
27:43 - and um
27:46 - i can just post yeah you can just post
27:49 - the um
27:50 - the link in chat and i personally
27:54 - would highly not recommend you do this
27:56 - because it's this one is like
27:57 - way more complicated than than like the
28:00 - property tag method
28:02 - and i personally don't see the like
28:05 - the benefits of doing it this way but if
28:08 - you're interested like
28:09 - you should totally check it out and
28:11 - there we posted
28:13 - a link to like uh um a tutorial
28:16 - in chat
28:22 - so so far like any questions about
28:26 - like classes or on
28:30 - or like everything we talked about so
28:33 - far
28:33 - i know it's like a lot of information to
28:35 - take in
28:37 - so feel free to like if you have any
28:39 - questions at all feel free to just drop
28:41 - in and chat
28:53 - um
28:57 - let me see if i actually have more demos
29:00 - about
29:06 - about visibility because this these are
29:09 - actually
29:09 - pretty important
29:15 - yeah so i can share more actually share
29:18 - more on
29:22 - more demos about
29:26 - about like the stuff we talked about in
29:28 - the first few slides because it can get
29:30 - a little confusing especially with
29:31 - python's
29:32 - um python's naming conventions
29:35 - so first off like this is
29:39 - just a basic demo about class like
29:42 - the visibility of data fields so
29:46 - just um were the differences between
29:50 - a public variable private a private
29:53 - variable
29:53 - and a protected variable
29:57 - so first off like this is again the
30:01 - um a class fund dog
30:04 - and we can define like
30:08 - we come to find like three different
30:09 - instance variables so one is color
30:11 - um another is name and another is ears
30:14 - so first um for public variables
30:19 - you just do you can um just do like
30:22 - self.color
30:23 - so no underscores before anything public
30:27 - um if you want to make a private
30:28 - variable
30:30 - um just like the last two
30:33 - make sure you put a double underscore
30:36 - before it
30:37 - and that way nobody outside of your
30:40 - specific class
30:41 - can um can access it
30:44 - so this could be useful if i want to
30:46 - make a solution
30:47 - um this could actually because like
30:51 - so if you want to make something like a
30:53 - simulation
30:54 - um sometimes like you would want to
30:57 - simulate like
30:58 - objects flowing in space right like
31:00 - objects within the solar system so you
31:01 - can have like a
31:03 - class called earth and an instagram
31:06 - object called earth
31:07 - or you can have even have like a general
31:09 - class called like planet and then
31:11 - instantiate different instances of
31:13 - planets called like earth venus or mars
31:15 - or something like that
31:16 - and then um you can
31:19 - sort of you can sort of simulate a solar
31:23 - system like that
31:25 - but um the thing about like why you want
31:28 - to make things certain things private
31:30 - and certain things public
31:31 - and other things is that
31:36 - sometimes like you don't want
31:39 - other people accidentally messing up
31:41 - your
31:42 - your variable values and you don't want
31:45 - people
31:46 - accidentally accessing things that they
31:48 - don't want to see
31:50 - so basically um
31:53 - like because in general when it comes to
31:55 - coding especially like when you're
31:56 - working on really large projects
31:57 - is you aren't making like one simple app
32:00 - or you aren't making like
32:01 - one small project that comes together
32:03 - really nicely sometimes you're making
32:05 - like entire libraries
32:07 - and you don't know who's gonna use that
32:09 - library
32:10 - and you don't know like what they're
32:12 - gonna do with that library so sometimes
32:14 - you don't want people to see things and
32:16 - actually change them
32:17 - because maybe like this this value will
32:20 - be important
32:21 - in a like another section of the code
32:23 - and you don't want anybody
32:25 - but yourself touching it and that's when
32:27 - you wouldn't make things like private or
32:29 - protected
32:32 - so in general like this is pretty
32:35 - important when you're um
32:36 - like worrying about privacy
32:39 - and like or visibility in your classes
32:42 - is pretty important
32:43 - if you want to like in order to make
32:45 - sure that like
32:46 - your values the values of your um
32:49 - variables
32:49 - stay consistent and like controlling
32:52 - who can access it and who can change
32:54 - those values
32:59 - so continuing on like we can have like
33:02 - uh we can also have something called
33:04 - protected and that's
33:06 - just we would justify that using one
33:08 - underscore
33:10 - so protective we haven't really talked
33:12 - about because
33:14 - um i'm not gonna go too deep into like
33:16 - inheritance
33:17 - or like making subclasses or like any of
33:20 - that
33:21 - for now because that it gets pretty
33:24 - complicated
33:24 - and there are a lot of like nuances when
33:26 - you talk about that
33:28 - but in general remember that protected
33:30 - it means that
33:32 - that variable is visible and accessible
33:35 - only by
33:36 - your like current class and any
33:38 - subclasses of that class
33:40 - so for example with this one we have a
33:43 - um a protected instance variable called
33:46 - ears
33:47 - and we defined as pointy
33:51 - so but like
33:55 - for protected um we can also like have
33:59 - what if we have like a subclass of dog
34:01 - called husky that might you can access
34:04 - your um your protective variables even
34:06 - in your subclass
34:08 - so that's why like this is here
34:13 - and this way when we run it um
34:17 - as you can see like it prints out like
34:19 - you can print out dog that color
34:21 - just like regularly um then you can like
34:25 - do dog that fart
34:27 - you can print the ears which are pointy
34:30 - and then
34:30 - you can um do like get me so notice
34:34 - that like i when i printed the ears
34:37 - i didn't actually um i didn't
34:40 - just print it like dog that color i
34:42 - actually had to
34:44 - make my own method called print ears
34:46 - within my dog class
34:48 - in order to print them properly so
34:51 - that's because like
34:52 - i can't access a protective um variable
34:55 - outside of
34:56 - that class in my main method and same
34:59 - with git name so like this is an example
35:01 - of the getter
35:03 - so finally like let's look out
35:07 - um why this well like next look at the
35:09 - husky on subclass
35:11 - and i will talk about why this isn't
35:13 - good so
35:15 - we've created um an instance of husky we
35:18 - done like husky.bark
35:20 - and then we print the ears as you can
35:22 - see like they're pointy
35:24 - and then finally like let's look at
35:26 - what's up with get names
35:30 - so for this one um
35:37 - let's see the error is there's no
35:40 - attribute husky that name
35:42 - so if we look at um the husky
35:47 - class so ignore this part
35:50 - this is just like this is just
35:52 - initiating like
35:53 - all the or inheriting like all the
35:55 - inheritance stuff
35:56 - so initiating all of these variables up
35:59 - here
36:01 - but if we look at get name this will
36:03 - throw an error because
36:04 - you can't access a private variable
36:07 - outside of that class
36:09 - even if like i'm in a subclass so unlike
36:12 - a protective variable
36:14 - private variables can't be accessed by
36:15 - subclasses so i'd have to
36:18 - like either initiate uh
36:22 - like let's say so that
36:29 - or something like that
36:33 - and this should be if you run
36:37 - so any questions about um the code in
36:41 - here
36:49 - so i would yeah i would highly recommend
36:51 - you look through this code
36:53 - and read the comments about like why i'm
36:58 - about like the different um levels of
37:00 - visibility
37:01 - and how you could like define like a
37:03 - private or a productive variable
37:06 - and you can also like play around with
37:08 - this just remember like if you want to
37:09 - change any code just to work this
37:11 - rapport before you do anything to it
37:21 - all right any questions
37:28 - otherwise um we can let's see
37:40 - otherwise i can try to find other demos
37:42 - i've made about this
37:45 - but i think that is it oh this one's the
37:48 - static method demo so this one is just
37:51 - talking about like
37:54 - how you can um so we talked about like
37:56 - insisted
37:57 - instance versus static this one's just
37:59 - talking about like
38:00 - how you can create a static method so
38:04 - if we go back to
38:08 - this slide um you can see static methods
38:12 - are methods that are tied to class
38:14 - um instance ones our methods are typed
38:16 - instances so so far in all of our demos
38:19 - we've been dealing with only instance
38:21 - not this
38:21 - methods so like we're passing itself as
38:24 - the first parameter
38:25 - and we're calling all these methods
38:27 - using like um
38:29 - instant stat method so like dog that get
38:31 - name or a dog that
38:32 - um set noise just things like that
38:37 - so this is just an example of
38:41 - a static method and i'll post this link
38:44 - in
38:44 - chat
38:50 - so this is again this is like the dog
38:52 - class
38:53 - and then we have a static variable
38:56 - called dog count
38:57 - so what if i wanted a static method that
39:00 - would return
39:01 - the um the dog count
39:04 - so what i would do is i would first
39:08 - um tag it as static method so this is
39:11 - just telling python like
39:12 - hey this is a static method unlike these
39:15 - other um
39:16 - instance methods and then as you can see
39:20 - we don't have to pass themselves for
39:21 - that because the method is tied to the
39:24 - class
39:24 - and not the instance and then again
39:28 - um just a reminder if you want to access
39:31 - a static variable you have to do it due
39:33 - to class name
39:34 - and not through like self.name or like
39:37 - self.um
39:38 - noise or something like that and then
39:41 - sit like a um static variable you access
39:44 - the static method through the class name
39:47 - so if i want to get dog count i would do
39:49 - dogs get dog count
39:51 - instead of doing like dog or like dog
39:54 - dog get me or something like that and
39:57 - this would return
39:58 - to and then over here it's like yeah
40:02 - if you want to access the instance
40:04 - variable you would just do it through
40:05 - instantly.um
40:07 - that method
40:10 - any questions about that
40:18 - sweet
40:23 - all right finally we can just look
40:25 - through
40:27 - um i'll actually post
40:30 - these examples of methods and we can
40:33 - also look through them
40:35 - and just check them out
40:45 - so this is just an example of a
40:47 - different class
40:49 - so in this one you have like you want to
40:51 - create a class called car
40:54 - and um first off like you have your
40:57 - constructor
40:58 - and in your constructor you're defining
41:00 - like a list of instance
41:02 - instance variables so you can like you
41:06 - can
41:07 - um store anything you pass in to the
41:10 - constructor
41:11 - using like an inspirable so like
41:12 - self.brand equals brand self that color
41:15 - goes color
41:16 - um you can also again if you don't want
41:19 - to like store
41:20 - any um any initial value in particular
41:23 - just remember to assign it as none you
41:25 - can also like store things like lists
41:27 - and dictionaries
41:29 - and then we can define um uh uh
41:34 - instance method so like description and
41:36 - then this will just like return
41:38 - a formatted string of like what the um
41:42 - coloring brand of the car is
41:48 - finally you can like these are just like
41:51 - getters and setters
41:53 - for the manufacturer and you can
41:56 - like look through these yourself and
41:59 - afterwards like this is just a
42:00 - demonstration of like you can create
42:02 - an instance of a car um just make sure
42:04 - you pass in like the
42:06 - proper amount of parameters that you
42:08 - defined in your constructor
42:11 - and then because we use the property tax
42:14 - um to define the getters and setters in
42:16 - this case
42:18 - we can just treat like a non-public
42:21 - variable
42:22 - as a public one so i can just set the
42:25 - manufacturer
42:26 - um using the equal sign instead of using
42:29 - like a specific method to do it
42:32 - and then finally you can like just call
42:34 - your instance method
42:35 - using instance name dot instance method
42:44 - all right and it looks like we have time
42:48 - so
42:48 - i can just go over like the just a
42:51 - really quick overview of the four
42:53 - principles of object-oriented
42:54 - programming
42:56 - so these are
42:59 - like the core principles of
43:01 - object-oriented programming are just
43:03 - um are just things you should take into
43:06 - consideration
43:07 - when using a language that supports
43:10 - object-oriented programming
43:11 - in order to be able to take full
43:13 - advantage of an oop language
43:16 - so this is what you should be thinking
43:18 - about when like you're
43:19 - creating classes in python or like any
43:23 - language in general that supports like
43:25 - making classes and
43:27 - instantiating things um in general like
43:30 - it's these are basic design principles
43:32 - so like
43:34 - so just how you should be designing
43:36 - classes
43:37 - and things to keep into consideration
43:39 - the um
43:40 - reason why like people use these
43:42 - principles or
43:43 - they program by these principles is it
43:46 - helps groups that
43:47 - prevent a lot of unexpected behavior so
43:51 - this like helps you keep your code clean
43:54 - um and keep your code sort of
43:58 - organized in a way that like you don't
44:00 - get
44:01 - weird bugs that come out nowhere
44:08 - so i'm going to focus mostly on the
44:10 - first two which are
44:11 - abstraction encapsulations because um
44:14 - these are the ones that we talked the
44:16 - most or these are
44:17 - ones that that um use the
44:22 - i would say like the concepts that we
44:24 - talk most about so like things like
44:26 - protection
44:27 - um things like data visibility and
44:30 - just like visibility of methods and um
44:34 - variables so first principle is
44:37 - abstraction and this is in general like
44:40 - this is just saying classes don't have
44:42 - to know what's happening under the hood
44:44 - in order to interact with each other so
44:46 - for example if i call like
44:48 - dog dot bark or something i don't have
44:51 - to know what's happening
44:52 - like what's happening in that function
44:55 - in the bark function in order to be able
44:57 - to call it
44:58 - i can just call it and then know
45:01 - like oh it'll return like a string or
45:04 - i'll print a string
45:06 - so what what's like the advantage of
45:09 - this
45:09 - is that it allows us to plug in
45:11 - different implementations of classes
45:13 - without like without drastically
45:15 - changing our code
45:17 - so for example like if you have a giant
45:20 - um piece of software like um something
45:24 - like
45:24 - like something sort of like photoshop or
45:27 - something
45:28 - and you change like one class
45:31 - within your program and you like change
45:34 - it you plug
45:35 - um another class in and
45:38 - or like you plug a similar like version
45:40 - of that class in
45:42 - but like what's happening under the for
45:44 - that class has changed a little bit
45:46 - um if i make small minor changes to that
45:48 - class it won't suddenly change
45:51 - the rest of the code and i won't have to
45:53 - like fix go through like a thousand
45:55 - lines
45:56 - of my program in order to in order to
45:58 - like compensate for one small
46:00 - change in like one tiny portion of my
46:02 - code
46:03 - so this just allows our code to be a
46:05 - little more modular
46:06 - and it allows it to be um
46:09 - it makes each class independent of each
46:12 - other basically
46:15 - the second one and this is the one um
46:19 - i kind of talked about is encapsulation
46:21 - so class attributes should be kept as
46:23 - private as possible
46:25 - so base the general gist is if like if
46:28 - other people
46:29 - don't have to see it then i should make
46:32 - it completely private
46:34 - and um variable should only be on it's
46:37 - sort of like a need to know basis
46:39 - where if other people don't have to see
46:41 - it then they shouldn't see it
46:42 - and this just prevents other classes and
46:45 - other people from modifying data
46:46 - accidentally
46:48 - and that that in turn prevents like a
46:50 - lot of unexpected bugs from happening
46:53 - so in general like this is super
46:55 - important especially if you're um
46:58 - if you're creating sort of like
46:59 - libraries or apis for other people to
47:01 - use
47:04 - and yeah just keep this in mind
47:08 - so the fourth third and fourth one are
47:11 - polymorphism and inheritance so
47:13 - polymorphism is just
47:14 - we can perform one task in many
47:16 - different ways by creating subclasses
47:19 - so like if i have a an overall class
47:22 - called dot
47:24 - and i have like a bunch of different sub
47:27 - sub classes of like husky um wolf
47:31 - beagle or something like that so
47:32 - different types of dogs
47:34 - then i can perform and each of these
47:37 - classes
47:38 - has like a bark method or something and
47:41 - they emit different sounds
47:43 - then i it's basically like i can perform
47:46 - this one bark method
47:47 - on my many different subclasses and they
47:50 - all have like they'll all have different
47:51 - outcomes
47:55 - finally is inheritance like when we make
47:57 - a subclass it also inherits the
47:59 - attributes of its parent class so as you
48:02 - could
48:02 - like if we go back to the
48:06 - let's see if i swap
48:13 - so if we go back to the um
48:17 - the class visibility demo
48:21 - so over here we have like
48:24 - a general dog class that had like color
48:27 - name ears
48:29 - and then we had like a hussy sub class
48:31 - which
48:32 - had um which didn't add any
48:35 - extra instance instance on variable
48:39 - but i could
48:42 - like even though it didn't um
48:45 - add anything extra i could still access
48:48 - like the
48:48 - variables of my parent class which was
48:51 - dog
48:52 - in order and that shows like how
48:55 - basically all the instance variables
48:58 - over here
49:00 - um generally get passed on into my
49:03 - subclass
49:04 - unless specified otherwise so for
49:06 - example like i
49:07 - said name was private so that doesn't
49:10 - get passed on
49:11 - but both color and ears you get passed
49:13 - on to husky over here
49:16 - so in general like a parent class will
49:19 - pass down its attributes
49:21 - to any subclass that has