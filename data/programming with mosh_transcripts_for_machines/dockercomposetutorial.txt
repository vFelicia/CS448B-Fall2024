in this video you're going to learn about docker compose so by the end of this video you'll be able to use darker commands with confidence hi i'm adani and i've taught millions of people how to code through this channel at my online school codewithmash.com this video is part of my ultimate docker course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started welcome back to another section of the ultimate docker course in this section we're going to talk about running multicontainer applications so i'm going to give you a realworld application with three building blocks a frontend built with react a backend built with node and a mongodb database once again you don't need to be familiar or use any of these tools our focus here is on docker and not on development tools i think this is the most exciting part of this course where you can see everything coming together we'll talk about docker compose for building and running multicontainer applications we'll also talk about docker networking database migration and running automated tests so let's jump in and get started in this section we're going to use a tool called docker compose which is built on top of docker engine it makes it incredibly easy to start applications with multiple containers so google docker compose install you will find this page docs.docker.com compose slash install on this page you can see the installation instructions now at the time of recording this docker compose is shipped with docker desktop for mac and windows so if you're on mac or windows you don't have to do anything extra you already have docker compose to verify it just go to the terminal window and type docker compose dash dash version so i'm running docker compose version 1.28.5 make sure your version is the same or newer now if you're using an older version again google upgrade docker compose or you might just install the latest version of docker now back to this page if you're using windows server or linux there are specific instructions you have to follow to install docker compose so go ahead and install docker compose and i'll see you in the next lesson before we get started i want to show you a couple of techniques for cleaning up our workspace so on this machine we have a bunch of images and some running containers they're getting in the way i want to get rid of them all how do we do this well you know that we can remove images using docker image remove command and here we can type one or more image ids now how can we get all image ids and pass them here let me show you a cool trick so we can run docker image ls we see all the images right but if we pass dash q at the end we only get image ids now we can pass this as an argument to docker image remove so docker image remove then here we add a dollar sign and in parenthesis we type that other command so docker image ls dash queue now if we run this we're going to get an error because some of these images are already in running containers or stopped containers so we should always remove containers first we're going to do that using the same technique so i'm going to replace image with container so we get all container ids and then we're going to remove them all in one go also i would like to add dash a here as well this will bring stopped containers as well okay we can also combine switches that's another technique let's go ahead all right we get an error saying you cannot remove a running container because i forgot to pass the force option so let's bring this up one more time when removing we're going to use dash f okay great so all these containers are removed now let's remove the images so docker image ls and docker image remove great now take a look we don't have any images here and no containers including stopped containers so we have a clean workspace that's one way there is a shortcut for this as well if you're on mac you can find the docker icon on the top status bar if you're on windows you will find it in your notification tray let's click on this and then go to preferences now on this page let's click on the troubleshoot icon on this page we have a bunch of useful utilities for example we can restart docker desktop we can also clean and purge data this will essentially remove everything in docker your images your containers your volumes and so on now be aware that if you click on this this is going to restart docker engine so on the top look you can see this animation showing that the docker engine is not started yet so at this point if you go to the terminal window and execute any of docker commands you're going to get an error so you'll have to wait about half a minute for the docker engine to start that's another way so now that we have a clean workspace next we're going to talk about our application so in this section we're going to look at a real world application with multiple building blocks a front end a back end and a database so below this video i've attached a z file go ahead and download it inside that zip file you're going to find this folder structure we have this back end folder which is our node project this is a basic node project that starts a web server on port 3001. once again you don't need to know node to go through this section then we have the frontend project which is a react application that talks to the backend now if you want to run this application outside of docker there are a number of steps we have to follow let's say we just check this out from a github repository first we have to go to our backend project install all dependencies and then start the web server now at the same time we have to open up another terminal window and do the same steps with our frontend project so we have to go to the frontend project install all the dependencies and then start the web server and of course we need two more terminal windows for running our frontend and backend tests and not to mention that we should also download and install mongodb on this machine so there are so many steps we have to follow the moment we check out the source code from our github repository now with docker we don't have to do any of these things all we have to do is run a single command let me show you so i'm going to get outside of the frontend folder now we are in the root of this project if you look here we have a file called docker compose which is used for composing a multicontainer application we're going to talk about that in detail soon now once we have this file in our project we can simply run docker compose up that's all we have to do now docker is automatically downloading this particular version of mongodb so it's downloading all these layers then at the same time it's going to install all the dependencies for our frontend and backend project it will start web servers and run automated tests all in this window now this is going to take a little while so i'll be right back all right our application is up and running and we can access it at localhost port 3000 so here's what we get we have a mini application for managing a list of movies now you know what's the beauty here the beauty is that our database is populated with these movies as part of bringing up our application i didn't have to manually insert these movies in our database so we have a migration script for populating our database and docker automatically executed our migration script as part of bringing up this application this is a very common realworld scenario now here we can add new movies movie one movie two whatever and we can also delete these movies so we brought up this application using a single command now i briefly mentioned this file docker compose.yaml before we talk about this file first you need to understand the yaml format this is a format that a lot of people are not familiar with so in the next lesson we're going to talk about json and yaml formats let's talk about json and yaml formats if you know this form as well feel free to skip this lesson so in the root of this project we're going to add a new file called data.json now json as you probably know is a language it's a human readable language for representing data so in this json file we can have an object or an array let's say we want to represent a course a course can have properties like name price and so on so in this object we can add one or more key value pairs our keys should always be surrounded in double quotes so we can add a key called name and set its value to we can use the string the ultimate docker course then we add a comma to define the next key value pair so we can say price we can set this to a number now the value can also be a boolean so we can define another key value pair and set the value to true or false we can define another key value pair and set the value to an array so we define an array using square brackets now in this array we can have any valid objects so we can have strings numbers booleans or other objects so i'm going to add a couple of strings let's say software and devops and one last key value pair author i'm going to make this an object so once again we use curly braces to define an object in this object we add a couple key value pairs first name is mosh and last name is what hamadani and yes i am iranian i get that question all the time all right so here we have a json file now let's see how we can convert this to yaml yaml is another language for presenting data but it has less clutter than json it's easier to read so i'm going to copy all this code here in the project we're going to add a new file called data the dml the extension can be yaml or yml now on the top we have three hyphens to indicate the beginning of a yaml file then we paste our code now in yaml we don't use curly braces to indicate hierarchy this idea has come from python if you have programmed in python you know that in python we use indentation to represent hierarchy so we don't have curly braces so let's get rid of these braces and remove the indentation good now the next thing you need to know about yaml is that we don't have to use quote so we can bring up the replace dialog and replace all these double quotes with nothing that immediately takes a lot of clutter away also we're not going to use commas to separate key value pairs so on the top we have name price is published how do we represent a list or an array we use hyphens so i'm going to remove this we press enter at a tab on a new line we type hyphen to define the first item in the list software then at the same indentation we add the next item devops now author is an object but as we told you we don't use curly braces we use indentation so because these two properties are indented they belong to the author property okay so this is our yaml file let's compare this with json as you can see yaml is easier to read and understand now why don't we use yaml all the time well because parsing yaml files is a little bit slower than parsing json files because the parser doesn't know if this is a string or a number so it has to read everything as a string and then try to evaluate it in contrast in json strings are represented using quotes and more specifically double quotes so the parser knows that this is a string and it shouldn't evaluate it okay so quite often we use yaml files for configuration files and json for exchanging data between multiple computers like a client and a server so now that you understand these formats next we're going to talk about compose files all right let's see how we can create a compose file from scratch so for this lesson i'm going to rename this file to underline docker compose we want to set it aside and create a new compose file from scratch so here we add a new file called docker dash compose all in lower case make sure to spell it properly otherwise docker compose is not going to find this file because this is the default name that docker compose assumes okay so yaml now the first thing that we need to set here is the version property what version should we use well let's search for docker compose file on this page you can see various compose file formats and their compatibility with docker engine we are using the latest version of docker engine so i want to use the latest compose file format so we have access to the latest features so we're going to set this to 3.8 now here we need to wrap this number with double quotes otherwise it will be evaluated as a number but docker compose expects this value to be a string why i have no clue so here's the version now in this file we define various building blocks or services of our application so we have a property called services now what services do we need here well our application has a front end a backend and a database now your application might have other moving parts so you can define them here now these names are arbitrary so we can call them anything we can change this to db we can change the backend to api and the frontend to well the idea here is that we're defining various services and telling docker how to build images for each service and how to run these images so here we're going to have properties and the value of these properties will eventually be used when running our containers so in the previous section we had to manually run our containers using docker run and here we used parameters like dash p for port mapping or dash v for volume mapping we also had to specify an image like react app all these values can be defined in our compose file so we don't have to manually start our containers docker compose will take care of starting our containers under the hood okay so for each service we need to tell docker how to build an image for that service so here we can use the build property until docker compose where it can find a docker file so if you look at this project you can see that in our backend and frontend folders we have a docker file this docker file is almost identical to the one we created in the previous section so we start from a node image we create a user we set our working directory copy all the files and install the dependencies then expose port 3001 and start the web server we have a similar docker file in our frontend project let's have a quick look so that was the back end here's the front end and here we have a docker file almost identical but the frontend application or the frontend server starts on a different part that is the only difference so each service should have its own docker file okay now back to our compose file for our web or frontend we're going to set the build property to period meaning current folder slash frontend this is where we have a docker file for our api we're going to set build to backend now for our database we're not going to build an image we're going to pull an image from docker hop so instead of the build property we're going to use the image property now for this application i'm going to use version 4.0 dash xeno so that is version 4 built on top of xenial which is ubuntu version 16. if you look at docker hub you can see that also has images built on top of windows but windows images are very large over 2 gigabytes so that's why i prefer to use linux images so for any of these services we can either build an image or pull it down now here we also have port mappings so we set ports to now because we can have multiple port mappings here we need to use the array or list syntax so we use a hyphen and then define a port mapping so our frontend application starts on port 3000 so i want to map for 3000 of the host to poor 3000 of the container running this image now similarly for our api we're going to define a port mapping this one is going to be 3001 to 3001. now mongodb by default listens on port 27017 so i want to map the same port so we can access mongodb using a mongodb client like mongodb compass now if you don't use mongodb you have the same concept with other database engines all these database engines listed on a default port you want to map that port so you can connect your database engine using your favorite database client okay what else do we have here back to this page for compose file if you look at version 3 on the right you can see all valid properties now a lot of these are for really special cases so you don't need to use them all the time but the ones that we use most of the time are build or image you also use ports volumes environment and so on so our api project needs an environment variable that tells where our database is so here we set environment now here we can use the list syntax because we can have multiple environment variables so we said db underline url 2 here we need to type a mongodb connection string these connection strings always start with mongodb colon two forward slashes here we need to type the name of a host so as i will show you later in this section when we start an application with docker compose under the hood a network is created on this network we're going to have three hosts the name of these hosts are equal to the names we have defined here so we're going to have a host called db so that is the connection string to our mongodb server now on this server we can have multiple databases so we're going to specify the database name and the connection string as well so this is one way to set an environment variable but instead of using the list syntax we can also use the object or property value syntax so we get rid of the hyphen we say db url is a property and this is the value of that property i find the syntax more readable because we get color coding and it's just cleaner that similarly we can add additional environment variables now we're almost there the last thing we want to add here is a volume because we don't want mongodb to rate data to the temporary file system of the container so here we set volumes and again we can have one or more volume mappings so we had a hyphen we're going to map a volume called whitley and of course we can call it anything really is the name of this application in case you didn't notice so we're going to map this volume to a directory inside the container now if you look at the documentation of mongodb on docker hub or just a typical mongodb documentation you know that by default mongodb stores this data in slash data db so we want to map this volume to this directory so whatever that is written inside this directory is actually outside of this container it's somewhere else in our volume now because we have used this volume here we have to define it in our compose file so we press enter remove all the indentations so now we are at the same level as services here we're going to define another property called volumes and here we're going to add another property called vidly with no value i know this looks a little bit weird but this is the syntax we have to follow we just have to define the volume first before we can use it so this is our compose file now we can make this more readable by adding line breaks in between these properties we can also order these services any way we want so currently i'm ordering them from front to back we can also order them from back to front so we will put database first then api and then web so we're done with our compose file next i'm going to show you how to build the images earlier i told you that docker compose is built on top of docker engine so everything we have done with docker engine like building images listing them starting containers and so on all of these operations are also available using docker compose let me show you so we type docker compose without any arguments enter look we have all these sub commands like we have rm for removing stopped containers we have run we have push pull and so on the difference is that any of these commands will apply to our application as a whole so most of these commands will impact multiple services or multiple containers in our application so let's look at docker compose build and also use the help option so we have a bunch of options here a couple of them i want to point out that are useful to know is no cache with this we can prevent caching when building the image sometimes you encounter weird issues and you want to make sure that cache is not used in that case you use this option another useful option is dash pool with this we can always pull a newer version of the image that is also good to know so in this lesson i'm not going to use any of this we're just going to run docker compose built this built our web and api services and as you noticed our build was super fast because pretty much everything came from the cache so let's run darker images so i have five images on this machine bitly frontend with the web build the api really backend and obviously came from docker hub now as part of this build process in this lesson we built weedly web and video api these two other images with the front end and back end were built when we started this application earlier so back to our project in this original compose file that i included in this project look i call this services front end and backhand instead of web and api that is why we have these two images with the front end and with the backend also as you have noticed when building images with docker compose our images are prefixed with the name of our application now where does this come from it is the name of the directory so currently we are inside a directory called whitley and that is why all these images are prefixed with whitley i think this is a great convention i got the question for you if you look at the created column you can see all these images were created an hour ago but didn't we just build the web and api images why do you think this happened here's the answer because i built this images front end and backhand an hour ago when i was recording the first lesson in this section now when building these new images docker used everything in the cache because all those files were already available all those layers were there so docker didn't have to do a full rebuild that is why we are still using the build from an hour ago okay now if you want to force a full rebuild we can say docker compose build dash dash no cache all right it's going to take a few seconds so i'll be right back all right our images are built so let's run docker images there you go look at the first two images api and web were built less than a minute ago so that's all about building images next we're going to talk about starting the application you briefly saw how we can start an application with docker compose we just type docker compose up now if the images are ready docker compose will run them inside containers otherwise it's going to build the images automatically now before executing this let's look at the available options so here we have a ton of options a couple of them that are useful are built with this we can force them rebuild every time we want to start our application so we don't have to explicitly run docker compose build and then up we can combine the two using the build option the other useful option is dash d for detached mode so we will start these containers in the background so take a look alright now if we run docker compose ps we can see all the containers relevant to this application in contrast if you type docker ps we can see all the running containers across all applications okay so here we have three containers vidly api one bitly db1 and web1 now what is this one well we can start multiple containers from the same image and this is used for high availability and scalability it's something we'll look at in the future so here you can see the container you can see what command started that container so for our api that was npm start for our database that was mongod or daemon process and for our web front end that was npm start as well you can see all these containers are up and running and over here you can see port mappings so now if we go to localhost port 3000 we can see our application beautiful now how do we take this down let's say we're done with this application and we want to free up resources back to the terminal we type docker compose down this will stop and remove these containers but the images are still there so next time we want to start the application our application will start pretty quickly let's talk about networking in docker when we run our application with docker compose docker compose will automatically create a network and add our containers on that network so these containers can talk to each other let's see this in action so i'm going to bring up the application one more time in the detach mode good now look at the first line creating network with the default so we can run docker network ls here we can see all the networks on this machine i think every docker installation has three networks bridge host and none honestly i'm not sure what these networks are for but what matters here is that we have a network called whitley default the driver for this network is bridge on linux or not on windows now this network contains three hosts or three containers web api and db so these hosts or these containers can talk to each other using their name let's see this in action so back to the terminal let's look at the running containers so we have web and api now we're going to start a shell session on the web container and ping the api container take a look so we're going to execute in the interactive mode the container id is 8 cs6 and we're going to run shell so let's paint api look at the permission error because we have logged in with the app user that comes from our docker file remember so we have logged in with the app user and this user doesn't have pink permission so let's exit i'm going to bring up the last command now here we have to use an extra option for setting the user we're going to log in as the root user good now look at the shell prompt we have a pound sign which means we have the highest privileges so here we can ping api now look we're getting responses from a machine with this ip address now your machine this ip might be different now let's press ctrl c to get out of this so this is what happens under the hood docker comes with an embedded dns server that contains the name and ip of these containers now inside each container we have a component called the dns resolver this dns resolver talks to the dns server to find the ip address of the target container so when we ping the api container this dns resolver asks the server what is the ip address of the api machine or api container the dns server returns the ip address and then the web container can directly talk to the api container using its ip address so each container has an ip address and it's part of a network let me show you one more thing so back to the terminal here we can run ifconfig to see the ip address of this container take a look so this container has two network adapters one of them is ethernet 0 and over here you can see the ip address of this container so 172 2102 is the ip address of the web container now back to our compose file earlier when we defined the api service we added an environment variable that contains a database connection string in this connection string we have db which is the name of the host that is the db host or the db container you saw that our api container can talk to this container because both these containers or all containers in this application are part of the same network now one thing i want you to understand here is that this host is only available inside the docker environment so if i open up my browser and go to localhost db i'm not going to get anything so the api container can directly talk to the db container but if you want to access this container we need port mappings and that is why we have this port mapping over here so this port on the host is mapped to this port on the container so if you open up mongodb compass which is a popular mongodb client we can establish a connection to localhost port 27017 because this port is mapped to our container let's verify this real quick so connect great so here we can see all our databases here's our fiddly database and in this database we have a collection called movies with four documents so here are the movies that we currently have in the database so this is all about docker networking next we're going to talk about viewing logs thank you so much for watching this video as i said this video is part of my ultimate docker course that teaches you everything you need to know about docker from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster and better than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day