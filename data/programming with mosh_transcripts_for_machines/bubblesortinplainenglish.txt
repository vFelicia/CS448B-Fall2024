hey guys maash here today we're gonna talk about bubble sort bubble sort is one of the many sorting algorithms that come up in coding interviews all the time in fact these days more and more companies ask data structure and algorithm questions in their interviews to see if you can think like a programmer in this video I'm gonna show you how bubble sort works and how you can implement it in Java if you don't know Java that's perfectly fine you can still follow along and implement the bubble sort algorithm in your favorite programming language also if you want to learn Java I have a comprehensive to our tutorial for you here on my channel the link is below this video so let's jump in and get started the first sorting algorithm we're going to talk about is bubble sort which is the simplest of all sorting algorithms let's say we have an area of integers and we want to sort this array in increasing order with bubble sort algorithm we scan the array from left to right and if items are out of order we swap them so we start off by comparing the items at index 0 & 1 if the right item is smaller than the left item we swap them because we want to sort this array in ascending order so here to smaller than 8 and we have to swap them now we compare the items at index 1 and 2 again the right item is smaller so we have to swap these items as well one more time again we have to swap these items and one last time ok this was our first iteration or first pass we need multiple passes to fully sort this array at the end of each pass the next largest item moves to its correct position so here 8 is in the correct position this is why we call this algorithm bubble sort because after each pass the next largest item bubbles up and moves to its correct position so in the next pass the next largest item which is 4 will bubble up let me show you once again we compare the items at index 0 and 1 these items are in the right order because 4 is greater than 2 so we don't need to swap them let's look at the next two items 1 is smaller than 4 so we should design ups and one more time again these items are out of order so we need to swap them and the last two items these items are in the right order so we're done with the second pass now for is in the right position as you can see our array is almost sorted we just need one more pass to swap two and one and then our array will be fully sorted so let's do that real quick all right our array is fully sorted now let's talk about time complexity if you're not familiar with this concept you need to go back to part 1 of this series where I talk about Big O notation so what's the time complexity here well in the bestcase scenario where our array is already sorted we need a single pass in the worst case scenario the array is sorted in reverse order here we need n passes now in each pass we need n comparisons well more accurately n minus 1 comparisons so if you have 4 items we need 3 comparisons right so bubble sort runs in O of N or linear time in the bestcase scenario and oo of N squared or quadratic time in the worstcase scenario if you go too big a cheat sheet comm you can see a visual representation of these growth rates as you can see all of N squared is very inefficient because it's in the red area so this algorithm gets real slow as the amount of input data grows later I will show you better sorting algorithms that run in the orange or yellow areas but before we get there let's implement bubble sorting code so pause the video spend 20 minutes and try to implement bubble sort on your own then come back see my implementation you all right here in our project let's add in your class we call it bubble sort in this class we need one method public void sort we give it an integer array and call it array a here we need a loop to iterate over this array multiple times in each iteration the next largest item will bubble up and move to its correct position so a typical for loop for I we set it to 0 as long as it's less than array dot lengths incremented after each iteration now here we did a second loop and we use this loop to compare every two items of this array so let's call this loop variable J we can set it to zero and start from the first item or one and start from the second item so here we'll compare the second item with the previous item okay so we said J 2 1 as long as J is less than a rate that length we're incremented after each iteration now in each iteration and we're going to compare the item at index J with the previous item so if array of J it's smaller than the previous item that means these two items are out of order so we need to swap them how do we do that real easy we've done this before so we use a temporary variable and copy array of J into this variable then we set array of j to array of j minus 1 I'll finally whatever we have stored in a tent variable we use that to set array of J minus one so a rate of J minus 1 equals temp that's our bubble sort now I prefer to extract these three lines into a separate method called swap this will make our code cleaner and more readable so let's declare a private method here private void swap we need to pass our integer array and two indexes so index 1 and index 2 now once again use a temporary variable so we set temp to array of index 1 then we set array of index 1 to array of index 2 and finally we said I already have index 2 to temp right now back to our sort method instead of this Reliance we can call swap pass or array and two indexes J and J minus 1 now because we have a single statement here I would prefer to get rid of this ugly curly braces that is better so we're done with this implementation now let's test it back to the main class let's declare an integer array called numbers and set it to 7 3 1 4 6 2 and let's add a duplicate like 3 now we create a sorter object we set it to a new bubble sort and here we call sorter that's sort pass the numbers array here and finally we're gonna print this on the terminal so here we use arrays dot to string to convert this array into a string so we pass the numbers array and run our program so as you can see our array is sorted now let's test the edge cases what if we have let's say only two numbers here our algorithm still works beautiful but if you have a single number still working beautiful what if you have an empty array no problem so we have successfully implemented bubble sort but there are a couple of places where we can optimize our implementation let me show you so back to our bubble sort class here we are assuming that we need n iterations to sort this array but what if our array is already sorted or partially sorted then we're not going to need n iterations we need fewer iterations so here I'm going to declare a boolean variable called is sorted now in every iteration you want to set this to true and assume that the array is sorted if our assumption is correct then we'll return immediately so let's add curly braces here in every iteration first we set is sorted to true we assume that the array is sorted now we start comparing items if we end up swapping two items that means our assumption was wrong so right after swapping we need to set is sorted to false however if we don't do any swaps that means our array is fully sorted so after this for loop we can write an if statement if there is sorted we can return immediately there's no need to iterate over this array one more time that is one optimization we also have another optimization look at this inner loop here we are going through the entire array comparing every two items but as you learned in every iteration in every pass the next largest item bubbles up and moves to its correct position so we don't really need to compare all the items in this array we only need to compare all the items that are not in the correct position so in our first pass no items are in the correct position that means we should iterate over all the items in this array in the second iteration one of the items is in the correct position so we need to look at all the except the last item so here we can change this expression to a rate that length minus PI again in the first iteration I is zero so we're going to look at all the items in this array in the second iteration I is one so we'll look at all the items except the last item so these optimizations make this algorithm run a little bit faster but it's time complexity is still o of N squared hey guys mahir I wanted to let you know that this video is actually part of my ultimate data structures and algorithms course the complete course is 13 hours long and I've divided it into three parts so it can take and complete each part easily if you're serious about learning data structures and algorithms I highly encourage you to take this course and learn all the essential data structures and algorithms from scratch it's much easier and faster than jumping from one tutorial to another we'll be talking about various types of data structures such as linked lists stacks queues hash tables binary trees AVL trees heaps tries graphs and various types of sorting searching and string manipulation algorithms the course is packed with almost 100 interview questions these are the interview questions that get asked that companies like Google Microsoft and Amazon you can watch the course online or offline anytime anywhere as many times as you want and you would also get a certificate of completion and a 30day moneyback guarantee it's exactly like this tutorial it just has more content if you're interested click on the link below this video to enroll in the course thank you and have a great day