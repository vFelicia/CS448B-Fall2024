welcome back to the second part of the ultimate nextjs Series in part one we covered the essential concept to build full stack applications with nextjs and typescript in this part we'll take everything you have learned and apply it to a real word project we'll build and deploy a full stack production grade issue tracker this project includes all the common features you find in modern applications dashboard with charts filtering sorting and pagination forms with client side validation user authentication and access control model dialog boxes and toast notifications and much much more by the end of the course you will have a fast responsive fully functioning application in the cloud that you can share with your friends or potential employers to get your dream job we'll build this with a cutting is Tex stack for building modern applications nextjs typescript Tailwind Rix UI Prisma and NEX off I'll break down every line of code so you will grasp the whats the wise and the house I will also show you how to structure your projects effectively how to write clean professional quality code that aligns with industry standards and best practices how to use shortcuts to boost your coding speed and overall productivity and how to think like a software engineer and build software in a structured and methodic way this course has everything you need to become a professional nextjs developer so if you follow along you will gain the practical skills and knowledge to build real projects with confidence I'm m hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school code withm mar.com so are you ready to jump start your career as a next year developer then let's jump in and gu started all right so what exactly do you need to take this course as I mentioned in the introduction this course is the second part of my ultimate nextjs Series so ideally you should have watched the first part or at least know the basics of building applications with nextjs and typescript more specifically you need to know the basics of client and server components routing building apis database integration with Prisma and authentication with next off now in this course we'll heavily use Tailwind for styling our application so you need to know the basics of Tailwind as well if you're unfamiliar with these topics I highly recommend you to go back and start from part one otherwise you might find this course a little bit challenging now I've created a GitHub repository for the project we're going to build in this course so go to my GitHub account mh hamadani and search for issue tracker it's right here in this repository we have the complete source code for the project we're going to build and also there is a separate commit for each lesson so as you're following the lessons if something doesn't work you can go and find that commit all these commits are named exactly like our lessons so if something doesn't work look at that comit to compare your code with mine now before we dive in let's talk about how to make the most out of this course there are two ways you can take this course some students prefer to code along with me and that's perfectly fine but I have meticulously edited these videos to take out all the unnecessary time consuming segments so everything is quick and to the point Point otherwise this 7hour course would end up being 10 hours or longer so if you're not a typing ninja you might need to hit the pause button a few times to keep up now here's another way to go about it and that's my recommendation I would say while watching each lesson don't do any coding instead watch closely take some quick notes and then after each lesson give it a shot on your own in my opinion this is a better way to learn because you're not just copying what I do you're thinking on your own and that makes the info stick better A lot of my students ask me msh I don't know how to start and finish a project so in this lesson I'm going to show you a road map that helps us plan our projects effectively this road map gives us a clear path and helps us decide what features to build first so before we get into the specifics let's classify our are features into two categories essential or core features and advanced or nice to have features this classification will help us prioritize and build our issue tracker or any project step by step so what are the essential or core features of an issue tracker I mean the absolute mus haves well the most fundamental feature is the ability to create an issue because that's the primary purpose of an issue tracker to create and Tackle issues right so we should build that feature first once we build that feature the next step is to allow the user to view details of individual issues so they can better understand the problem and after that we want to allow our users to update or delete an issue once we build these features then we can gradually enhance our application by adding more advanced features based on our project's needs so we will Implement features like user authentication assigning issues to users sorting and filtering issues pagination and dashboard now here's the key when building this application we're going to focus on one feature at a time so we're not going to get distracted with the complexity of the entire project also when building each feature our goal is not to come up with a perfect solution right away there's no such thing as perfect in software being a perfectionist wastes a lot of your time you'll spend hours and hours thinking about that perfect solution just to discover that it has flawed so we want to start coding right away and come up with a working solution once we have a working solution then we'll refine and improve our code step by step this is called refactoring okay our feature road map is set our journey is clear so let's set up our development environment and get started all right now let's talk about setting up our development environment in this course course just like my other courses I'll be using visual studio code or vs code you're welcome to use your preferred editor but if you want to use vs code I want you to install these extensions so head over to extensions panel and search for es7 it's this extension right here es7 plus react Redux and react native with this extension we can quickly generate react components it's very handy the next extension we're going to use is typescript it's this one right here JavaScript and typescript nightly the next one is Tailwind Tailwind it's this one right here Tailwind CSS intelligence this gives us autoc completion when using Tailwind classes and the last one is Prisma so Prisma with this extension we get syntax highlighting and and autoc completion when creating Prisma models so make sure you have these extensions before moving on to the next lesson now to create our project open up a terminal window now I'm going to go to my desktop Now to create a nextjs project we run npx create next app version 13.4.1 19 make sure to use the same version so everything I show you in these videos work the same way on your machine let's go ahead let's proceed with the installation of this package now we should give our project a name I'm going to call it isio Das tracker and then we'll accept all the default values for these questions so we're going to use typescript as well as eslint and Tailwind we're not going to use the source directory and we're going to use the new new app router and the final question we don't care about customizing the default import Alias let's go ahead our project is created so let's C into this folder issue tracker and run npm run Dev all right our project is hosted at Local Host Port 3000 here's what we get beautiful now let's open this project in vs code so here in vs code first we have to do a little bit of cleanup so let's go to our app directory and open our homepage we don't care about any of the markup here so let's simplify things I'm going to delete all the mark off where is the end right here and add a simple div and here we say hello world we don't need the import statement on the top either so here's what we get now we have this weird background color because of the gradient applied to our body element so let's go to vs code we're going to go to global. CSS in this file we're going to remove a couple of custom CSS properties one is background start RGB and the other is background end RGB and then here in the body element we remove the background color with that here's what we get looks good and now we make our first commit so we go to our source control panel and make a commit and here we say initial commit now at this level I expect you to be familiar with Git and GitHub if not I highly recommend you to watch my 1 hour YouTube tutorial on this topic I also have a comprehensive course on my website if you want to master git and GitHub so let's make our first commit good all right we're done with this step let's move on to the next lesson all right now we're going to build a navigation bar so here in the app directory let's add a new file called navb bar. TSX now we're not going to put this into a components directory because as I explained in the first part of the course in nextjs 13 with the new app router we don't have to put all our components into a components directory instead we we can collocate our components with the pages or layouts where they are used in this case our navigation bar is not a reusable component the only place where we need it is in our layout so I put it right next to our layout now let's create a new component so we type RAF CE this is one of the shortcuts that come with the es7 extension that we installed at the beginning of the course let's press enter so here we have a navigation bar now let's change change the div element to nav so it's more sematic now in this navigation bar first we want to have our logo so we wrap it with a link component that is defined in the next SL link package when we click on the logo we should go to the homepage so we set href to the root for now I don't want to add a logo so I just want to type logo now right after that we want to add our navigation links so we add an on order list inside this we want to have two list items so Li * 2 tab beautiful now once again we're going to use the link component our first link is going to be our dashboard so let's set HRA to the root as well and our second link is going to be the issues page so here we set hf2 slash isues now before going further let's add our navigation bar to our lay layout so we go to our layout file and add our nav bar inside the body element so nav bar now I would prefer to wrap our children which is going to be a page inside the main element that makes our Pages more semantic good back in the browser here's what we get so we have the logo followed by dashboard and issues now we want to lay this out hard horizontally so back to our nav bar we have to make this nav element a flex container so we set class name to flex now our logo and list items are laid out horizontally and that means when we have a flex container our direct children are laid out horizontally in this case the logo and the UL element but inside the UL element we don't have a flex container and that is why the dashboard and issues are laid out vertically so to lay these out horizontally as well we should apply the flex class on the URL element good now these items are so close to each other so to give them some space we apply another tailb class that is spacex followed by a number in this case I'm going to go with six here's what we get so we have some space between the children or are our outer Flex container now we need to apply the same class to our unordered list so here's our Ur let's give it space X6 that looks better now let's add a border below our navigation bar so we give our nav element the class of border dasb that is short for bottom that's better now to separate our navigation bar from the main page content we should give it a bottom margin so we add one more class here that is mb5 I think that looks good next let's give our navigation bar a horizontal padding so we give it a padding X of let's say five that looks good now our navigation bar is too narrow so to increase the height we apply another class here h14 that looks good but our items are positioned on the top so to put them in a center we apply another class here items Dash Center take a look that looks good so we got the basic layout working next we need to replace our logo text with a beautiful icon and for that we're going to use the react icons Library so search for react icons you will find this page to use this Library first we have to install react icons so here in the terminal let's install react D icons version 4.1.0 beautiful now back to this website we want to have a bug icon as our logo so let's search for bug we have various shapes of bugs in different libraries I'm going to pick the first one AI fill bug now back to our navbar we import this class from react D icons SL AI because this component is defined in the AI library now let's replace our logo with AI fill bug here's what we get looks beautiful now I want to apply a hover effect on these navigation links so we want to make the text slightly lighter and when we hover over these links we want to make it a little bit darker as an example let's apply a few classes on our first navigation link so we said class name two the first class is text zinc d500 this makes our text Medium gray here's what we get now to apply a hover effect we use the hover selector and change the text color to zinc 800 now take a look that looks good now I want to apply a trans ition so the change is smoother to do that we add another class here that is transition Das colors now take a look all right the transition is smotherer beautiful now we have to apply the same classes on this other navigation link and this is repetitive so let me show you a better way instead of defining our navigation links here we're going to Define them in an array then we will map that array to a bunch of list items so let's declare an array call links now each element in this array should be an object with two properties a label like dashboard and an href let's duplicate this and our second link should be issues all right now here we map our links array we map each link to a link component so I'm going to grab this piece of code cut it and then paste it here now each link should have a key we set the key to link. HRA because that value uniquely identifies each link now we no longer need these list items so let's delete them also let me put this on a new line so we can see things clearly so each link should have a key and a class this is the only place where we set these classes so there is no duplication in our code next we set the href prop and here we have to set the value dynamically we set it to link. href and similarly we should add the label dynamically so we add link. label now both our navigation links are dark gray and when we hover over them they become black beautiful so our navigation bar is in a good shape now before going further we have to make a commit to our repository so we go to the source control panel and make a commit and say build the nav bar all right now let's see how we can style the active or the currently selected Link in the navigation bar to do that first we have to create the issues page so back to our project here in the app folder let's add a new folder called issues then we add our page file next we create a react component and call it issues page with this if we click on the issues link we see the issues page beautiful but we want to highlight the active link in the navigation bar to do that we have to go back to our Navar component in this component we have to use one of the hooks that comes with nextjs to get the current pass or the current route that is use pass name use pass name now the auto comption is not picking it up so we have to manually import it on the top so on the top we import use P name make sure to spell it properly we import this from next slash navigation next we call this hook to get the current path now because in this component we are using this hook and this Hook is dependent on browser apis we have to convert this component to a client component because as I told you in part one we can only access browser apis in client components right so on the top we add the use client directive now before going further let's make sure that our application is working up to this point so let's do a console log and log the current pass to make sure we get the right value so let's bring up the console we're currently on the issues page lovely now if you go to the dashboard we see the root path okay so let's let's remove this lock statement now down here where we render our links we want to apply a class dynamically if the HF of the link that we rendering equals the current path instead of Tex sync 500 we want to render Tex sync 900 which is darker so here we have to wrap this string in braces next we need to replace these quotation marks with a back tick so we can add stuff Dynam dally so we select the first quotation mark then we press command and D on Mac or control and D on Windows now we have selected both these quotation marks we have multic cursor editing so in one go we can replace both of them with a back tick good now we press escape to cancel multic cursor editing now here we add a dollar sign followed by braces inside braces we type our condition we say if link .h equals the current path then we render text zinc 900 otherwise we render text zinc 500 so let's grab this class from here and move it inside these quotation marks Let's test our application so back in the browser we're currently on the dashboard and the dashboard link is darker if you go to the issues page the issues link becomes darker beautiful so this is a simple way to style the active link in the navigation bar now as our applications get more complex we might end up with complicated conditions here and tracking what classes are rendered can be a little bit difficult in those cases we can use a very popular package called class names so bring up the terminal and install class names version 2. . 3.2 good now on the top first we import class names from class names now this is a function that we call and give it an object in this object we specify the classes that we want to render and the conditions that they should be rendered this function will then return a string that contains the classes we want to render let me show you how this works so down here let's remove everything inside the braces so here's what we have now here we call class names and give it an object in this object we add one or more key value pairs our keys should be our CSS classes like text zinc 900 and the values should be either true or false if we set this to true this class will always be rendered now in this case we want to render this class only if link. href equals the current path right now similarly we add another key value pair that is text zinc 500 and we want to render this if link. HF does not equal current path let's add one more that is hover text zinc 800 and transition colors we want to render these classes at all times so we set this to true now look at the result we no longer have string manipulation and our code is cleaner we can easily look at this code and see what classes are rendered under what conditions Let's test our application one more time to make sure we haven't broken anything so we go to the dashboard dashboard is darker we go to the issues page the issues link is darker beautiful so we're done with this step and now it's time to make it commit to our repository so here I'm going to say style the active link in the nav bar in this section we're going to use MySQL for storing our data in case you don't know MySQL is a very popular database engine there are of course many other database engines out there like postgress SQL server mongodb and so on if you prefer a different database engine that's totally fine but I would suggest you to use MySQL in this section so you can easily follow the lessons so head over to myql.com go to downloads now at the bottom of this page you'll find this link MySQL Community version which is absolutely free then go to mySQL Community server and on this page page download the latest version for your operating system now for Mac keep in mind that we have two DMG files for different CPU architectures we have one for arm the other for x86 so if you're a Mac User depending on the type of your Mac you have to find the right DMG file once you download this you will get an installation wizard just click through it's very easy to set up just remember as part of that you'll be asked to enter a root password so root is like the admin user for our database engine so whatever password you use for the root user keep a note of that because in the next lesson we're going to come back to it okay now this is just a database server or database engine we also need a tool for viewing our database now MySQL gives you a tool called MySQL workbench again it's free I don't like this tool it's ugly so in this section I'll be using a tool called datag gripe from jetb brains.com I absolutely love this tool but you have to pay to use it having said that you can try it for free for 30 days so head over to jetb brains.com datag grip and download the latest version all right now we're going to install Prisma to allow our application to interact with our database so here in the terminal let's install prismo version 5.3.1 good next we run npx Prisma in it to initialize Prisma in this project all right I told you in part one that when we run this command two things happen let's quickly review first Prisma creates this Prisma folder and here we have this Prisma schema file in this file first we have to change our provider from postgress to mySQL or if you if you prefer to use postgress or any other database engines that's totally fine just make sure that you have set the right provider here next we need to update our database URL which is an environment variable stored in this en file in the root of the project so let's go here first we change the protocol to mySQL then we change the root username in MySQL that is root next we set our password after the colon then we change the port for MySQL we have to use 3306 then we change our database name to issue Das tracker or whatever you prefer now we don't need this query parameter let's remove it we're done with setting up Prisma so let's make a commit and move on to the next step so setup Prisma all right to store issues in our database first we have to create a Prisma model so we go to our Prisma schema file and Define a new model called issue as a reminder make sure to use the Pascal naming convention so we capitalize the first letter of each word and also make sure to use singular names so we don't want to call this model issues just a singular name like issue now our issue is going to have various Fields or properties at this point we want to add only the absolute essential ones so right now we are not going to worry about assigning issues to users and that means we're not going to create a relationship between the issue model and the user model okay so we're going to add the core fields or properties what are those well every issue needs an ID the type of ID should be an integer now here we use the ID attribute to specify that this is an ID column we use the default attribute to give it a default value here we use the autoincrement function so every time a record is inserted into our table our database engine automatically assigns an ID to that record next we add the title field this has to be a string now when we use MySQL the type of the related column in our database is going to be varar of 191 now in case you are not familiar with MySQL or databases in general varar means variable character so varar of 191 means we can store string values up to 191 characters in these columns now 191 is kind of a weird value so here I want to overwrite the default convention and say I want to store a string up to 255 characters to do that we use the DB attribute to specify the type of underling column in our database here we're going to use varar of 255 next we add the description field this also has to be a string now again the type of this column is going to be varar of 1 191 but we want to have really long descriptions so for that we use db. text now every issue has to have a status and the status can be one of three values open in progress and closed we can use an enom to represent that so here we Define an enum called status an enum is a set of constant values so here we're going to add three values open in progress and closed and by convention we use all capital letters so each value on a separate line and here we don't need to separate them using a comma just remember that enums are supported in MySQL but not necessarily in all database engines so if you use a different provider look at the Prisma documentation to make sure that enom are supported so here we add the status field and set the type to status here we can give it the default value of if you press control and space we can see all the possible values so we set it to open now we want to know when each issue is created the next field we need is created at this has to be a datetime and we give it a default value of here we use the Now function so every time a record is inserted into the issue table the current daytime is inserted into this column we need a similar field that is updated at this also has to be a date time now for the value use a different attribute called updated at with this every time an issue record is updated the database engine automatically updates the value of this column okay so here's our issue model now let's reformat our code so here in the terminal we're run npx Prisma format here's the end result it's beautiful the next step is to create and apply a migration so back in the terminal we run npx Prisma migrate Dev let's give it a name like initial migration or we can be more specific and say create issue good so as you know when we create a migration Prisma creates this migrations folder and for each migration it creates a subfolder that has a timestamp and the name of the migration in this folder we have a migration file and here we have SQL instructions for creating or updating our database schema to match our models for example here we have an instruction for creating a table called issue with these columns all right now let's make sure that our database is migrated properly so I'm going to use data grip you can also use workbench in data grip we create a new project let's call it issue tracker now in this project we go to database Explorer we add a new data source here we select MySQL in this window we make sure that our host is Local Host and the port is 3306 we set the username and the password of the root user and next we set the database to issue Dash tracker or whatever you used earlier now down here let me resize the window look there's a link that says we should update the driver you might have a different link that says install missing driver files so make sure to either install or update the driver good so let's click test connection all right the connection is successful beautiful now click on okay let's expand our database so here's our issue tracker database in this database we have two tables Prisma migrations that keeps track of all the migrations we have run so far and the issue table where restore our issues so we're done with this stab and now it's time to make a commit to our repository so here I'm going to say create the issue model all right we have a model now to store issues we have to create an API that clients can call so here in the app folder let's add a new folder called API inside the API folder we add a new folder called issues and here we add our route file in this route file we export a function called post that takes a request object of type next request now here first we call request the Json this returns a promise so we waited to get the body of the request and of course we have to make this function async nothing new so far we covered all of this in part one so if you're not sure what I'm doing you have to go back and start from part one now that we have the request body before we create an issue first we have to validate our request to make sure it doesn't have bad data now for data validation we use zot so back in the terminal let's install Zod version 3.22.20 Z from Zod next we call z. object and give it an object that defines the shape of the object and the body of our request so let's quickly go back to our Prisma schema file look in this issue model we only need values for the title and description because all the other fields have a default value the ID is automatically generated by the database and here we have assigned a default value to these other fields so we only need the title and description and the body of the request so back to our route file here we have two properties title this has to be a string with a minimum of one character and a maximum of 255 characters similarly we add description this also has to be a string with a minimum of one character now now this returns a schema we store it here now in more complex applications we are going to have different schemas for different operations so in those situations we can be more specific in terms of naming here for example we can call this create issue schema okay now that we have this schema we can use it to validate the body of the request so here we call create issue schema. save pars and give it the body object now this returns an object we call it validation next we check if validation is not successful we return the next response and here we include validation. error. errors now for this status what code should we use 400 that means bad request meaning the C client sent invalid data otherwise if the request is valid we should store this issue in our database to do that we have to import Prisma client now in part one I explained that we should have a single instance of the Prisma client and I explained the proper way to create that single instance so back to our browser let's search for nextjs Prisma client you will find this page best practice for instantiating Prisma client with nextjs on this page we have sample code for creating an instance of Prisma client we're going to copy all this code now back to our project we go to our Prisma folder here we add a new file called client. TS and paste all that code here now if this looks complicated don't worry about it you never have to touch it you never have to maintain it all this code is doing is creating a single instance of prismo client it ensures that we don't have multiple instances running okay so we have a prismo client now back to a route file on the top we import Prisma from at which represents the root of our project SL Prisma client with this Prisma client we can insert a new issue in our database so here we call Prisma issue. create we pass an object here we set data to an object with two properties title which we set to body the title and description which we said to body dot description okay now we await the call to get the new issue and finally we return this to the client so we return and next response with the new issue now optionally we can set the status to 2011 which means an object was created so we're done with the API now let's test it so let's bring up Postman and create a new request here we're going to send a post request to Local Host Port 3000 SL API SL isues here on the body tab we select raw and then Json let's pass a Json object first I'm going to set title to an M2 string and leave out the description property let's make sure our date of validation logic is working so send take a look all right we have a bad request and here in the response we have our error object beautiful so now let's send a valid issue I'm going to set the title to first issue and description to description of the first issue send now let's look at the response the status is 2011 and here's the issue that was created as you can see the ID was generated by the database and it's set to one now we can go back to data grip and refresh this table to make sure that our issue is stored in this table beautiful so let's make a commit and say build an API for creating issues all right to build the new issue page we're going to use radex UI which is a very popular component Library so head over to rui.com now radx comes in two flavors we have Radix themes which are beautifully styled components like the components you see here we have input fields buttons avatars and so on but we also have radic Primitives which are a bunch of unstyled components these components only have Behavior so we have to style it ourselves in this course we're going to use radic themes so back to this page let's click get started now to get started there are number of steps we have to follow first we have to install radx themes so let's copy this line and paste it in the terminal all right now let me show you the version that is installed here so let's go to package.json and search for radic the version that I'm using is 112 all right the second step is to import rad CSS file in our root layout so let's copy this line now we go to our root layout and import this style sheet on the top now the last step is to wrap our entire application inside the theme component that comes with Radix UI so back in our layout file here we import the theme component from radx ui/ themes next we wrap everything inside the body element with our theme component like this now to verify that we have set up everything properly let's go to our issues page so issues SL page and add a button here so on the top we import the button component from Rix ui/ themes now let's add a button here and set the label to new issue all right here's what we get so Radix UI set up properly now before we create the new your page let's make a commit and finish this step so setup Radix UI all right now we're going to build the new issue page in this lesson our focus is entirely on the look and feel of this page so we're not going to worry about submitting the form or handling validation errors we just want to build a page that has two input Fields okay so let's go back to the documentation of radx UI let's click on this navigation menu look here we have various components for creating layouts like box Flex grade and so on we also have various components for creating topography like text heading and so on and down here we have more full flesh components for example we have a component called text field so here's an example we start with is text field. root now if you want to have an icon like this magnifying glass inside the root component we add a slot and inside the slot we add our icon right after the slot we add a text field. input component in this case we don't care about an icon so all we need is a root and an input component so back to our project here in the issues folder let's add a new folder called new here we have our page file next we create a react component called new issue page on this page we need a text field component now if Auto completion doesn't work properly for you just restart vs code and the problem should go away so we add text field. root and inside that we add text field. input let's give it a placeholder like title now to add a link to this page we go to the issues page so issues slash page earlier we added this button now inside the button we're going to add a link component so we use the link component that is defined in next SL link package note that there is another link component defined in VX UI themes we don't want this one we should pick the one in the next package so we add a link and here we set href to SL isues slne and the label to new issue now back in the browser let's click this button all right we get an error saying cannot access text field. root on the server so because we're building a form and building forms requires user interaction the text build component cannot be rendered on the server so we have to make the new issue page a client component so on the top we add use client now refresh all right here's what we get by default our text input field takes the entire width of the page so to narrow it we can apply a Max WID to its container so here's the containing div we set class name to Max with x large with that here's what we get that looks better now this input field is so close to the left side of the screen so we should apply a padding to our main element so let's go back to our layout file here's our main element here we set class name to p5 and with that we get a bit of padding here that looks better so here's our text field right after that we want to add a text area again if you look at the documentation you will find the text area area component it's right here it's very easy to use this one is simpler we just add text area and give it a placeholder so back to our page right after our text field we add a text area and give it a placeholder description here's what we get now these two input fields are so close to each other to solve this problem you apply some vertical spacing so back to this page we apply another class here called space Y3 that looks better now finally we need to add the submit button so right after our text area we add a button component that is defined in radex UI and here we set the label to submit new issue all right here's what we get so we're done with this step and now it's time to make a commit to our repository so so here we say build the new issue page one of the great things about Rix UI is that it allows us to easily customize our theme let me show you how to do this so let's go back to our layout file all right look this is where we are using the theme component inside this tag right after the main element we add the theme panel component from radex UI now we get this panel for customizing our theme so as you can see our accent color is set to Blue that is why our buttons blue we can easily change it here and preview the changes in this lesson I'm going to select Violet now we can also change the light or dark mode now for some reason this is not currently working it's a little bit flaky key but don't worry about it here we can also change the radius of our components for example currently the radius is medium we can set it to none now we have sharp Corners here or we can set it to full we have round corners I'm going to select medium now down the bottom we can copy this theme now back to our layout let's paste it here look we get this theme tag with two props appearance and accent color so let's remove this other tag and this is how we can customize our theme we're done with the theme panel let's remove it from here now there is one more thing I want to show you in this lesson so right now we are not using the inter font that is used in nextjs projects by default so to refresh your memory look here in this layout file we are using the inter font from next SL font SLG gooogle Now when using R UI the inter font is not used by default because we have to do a bit of configuration to make it work to verify that the inter font is used let's select one of these links and inspect it all right here in Dev tools let's select the computer tab and look at the font family so font family is set to Apple system this is the default system font so it's not enter now how can we solve this problem back to the documentation of Radix UI here we have a page for topography here under theme let's go to topography and search for next so here are the instructions for using the inter font with radx UI so we have to go to our layout file and assign a custom CSS variable to this font so we copy this line and paste it here so here is where we create and Inter font in this object we set the variable to a custom CSS property in the first part of this course I explained how this feature works so back to this page next we need to go to our root layout and set the class name of the HTML element to enter. variable so by default that is .cl class name we have to change it to enter. variable so we use that custom CSS property so this is our root layout now the font is applied to our body element so we set the class name to enter. variable next we should create a custom CSS file for overwriting the styles of radex UI so we're going to create a file called theme conf. CSS and in that file We'll add this style so here in the app folder we add a new file called theme config CSS now let's copy this piece of code and paste it here and finally we have to import this file in our root layout so let's go back to our root layout on the top so first we import the default styles of RX UI then we import our custom theme file that is period SL theme config see SS and finally we add any Global Styles now back in the browser let's make sure that the inter font is loaded so let's select this element and inspect it now here on the computer tab look at the font family now we're using the inter font so we're done with this step and now it's time to make another commit so here I'm going to say customize radic UI theme hey guys M here I hope you're enjoying what you're seeing so far now after you finished this tutorial if you're ready to take your skills to the next level I highly recommend you to look at my ultimate nextjs series the full series contains two courses and is 12 hours long the first part which is 5 hours teaches you everything you need to know to build full stack applications with nextjs the second part which is 7 hours is where we build and deploy the complete issue tracker project so by the end you will have a complete project that you can show to your friends or potential employers and get your dream job the course comes with a certificate of completion and a 30day money back guarantee so you can try it riskfree if you're not happy just contact us and ask for refund so if you're serious about learning nextjs and want to use it professionally I highly encourage you to enroll in the full course after you finish this tutorial again in case you're interested the link is below this video all right now let's see how we can replace this text area component with a markdown editor for that we're going to use a component called react simple MD editor so search for this you will find this page on npm this is a react component wrapper around e mde which is a popular JavaScript library for rendering a markdown editor so let's look at the installation instructions it's very easy first we have to install these two packages react simple MD editor and easy MD so let's copy this line and paste it in the terminal good now to use this component we have to import the simple MD component and a corresponding CSS file so let's copy these two lines now we go back to our new new issue page and paste these import statements on the top now here we don't need react so let's remove it also we no longer need the text area component now all we have to do is replace this component with simple MD with that we get this beautiful markdown editor now this is fully customizable we can change the buttons on the toolbar here we also have spell checking by default so if you type something that is not a valid English word we get this red highlight now in this course I'm not going to talk about customizing this editor it's really outside the scope and it doesn't value every student of this course so I leave it up to you to read the documentation and figure out how to customize this if you want to all right we're done with this step and now it's time to make another commit so here I'm going to say add a markdown editor all right our form is ready now it's time to handle the form submission and to do that we're going to use a very popular Library called react hook form chances are you're familiar with this library but if not this Library makes it incredibly easy to handle form submission track changes in our form and display validation errors so let's go to the terminal and install react hook form version 7.46 point1 good now we go to our new issue page and on the top we import a hook called use form from react hook form next we Define an interface that defines the shape of our form it specifies What fields we have and what are their types so we Define an interface we can call it issue form here we have two properties title of type string and description of type string next we call this hook in our component so here we call use form and in angle brackets we specify the shape of our form in this case issue form we call this function and get an object now we destructure that object to grab the register function using this function we can register our input Fields with react hook form so it can keep track of them let me show you how this function works so let's do a console. log and call register and give it a label like title now back to the browser let's bring up the console look we get an object with four properties name which is title as well as onchange on blare and ref so these are the props that we should apply to an input field so react hook form can keep track of changes in that input field so let's remove console. log from here and call the register function right here where we use this input component so inside braces we call the register function and register this field with react form now you saw that the register function returns an object with four properties so here we have to use the spread operator so we can add those properties as props to this component now we cannot use the same technique with the simple MD component because it doesn't support additional props using the spread operator so if we add braces here and register this as the description field look we get a compile term error to solve this issue we have to use the controller component component in react hook form so on the top in addition to the use form hook we also import the controller component now let's remove these braces from here so instead of directly rendering this simple MD component we have to render a controller component that here we have to set a few props the first one is name which we set to description the second one is control and we set this to the control object that we can get from this hook so while D structuring this object we also pick the control property now we use that right here and finally here we set the render prop to a function for rendering an input field so we pass a function here and this is where we render a simple mde editor so let's paste it here now the final step we give this function an argument and destructure it to grab the Field property now this field has the same properties that you saw earlier like unblur unchange and so on so this is where we add braces to spread the field object okay so we have registered our input Fields with react hook form now we should handle the form submission to do that we have to grab another function from this object that is handle submit now we should wrap our input Fields with a form so I'm going to change this div to a form here we're going to use multic cursor editing so what was the shortcut command and D on Mac or control and D on Windows now both tags are selected let's change it to a form now here we set unsubmit here we call the handle submit function and give it a function that will be called when our form is submitted so we pass a function and here we can do a Conant the log that we want to display the data in our form data will be an argument in this function so we grab it here and pass it to console.log so let me put this on a new line so you can see things clearly this is how we can handle the submat now let's test our implementation so back in the browser I'm going to set the title to bug one and description to description of bug one now let's submit the form bring up the console here is the object that contains the data in our form all right now the final step instead of logging this data object on the console we want to send it to our API to do that we're going to use axas we can also use the fetch function in browsers but I personally prefer axas because the syntax is kind of easier to use but if you prefer to use fetch that's totally fine so let's bring up the terminal and install axis version 1.5.0 now on the top we import axus from axas now back to our submit Handler instead of Lo plug in the data on the console recall axis. poost as the URL we pass/ API SL isues and here we pass our data object now this returns a promise so we have to await it and make this function async now finally we want to redirect the user with the issues page to do that we have to use the router hook in nextjs so here we call use router now I explained this before you have two router hooks one is defined in next SL router the other is defined in next SL navigation make sure to use the second one because this is the one that works with the app router so we call this and get our router object and finally after this issue is saved we call router. push and send the user to the issues page let's test our implementation so one more time let's fill out this form description of book one and send this to the back end all right we got an error saying Navigator is not defined this is typically what happens when we use the wrong router hook in this case I haven't made a mistake so this could be a temporary issue I'm going to restart the web server and see if that solves a problem all right right now let's refresh this page as well so let's fill out this form one more time and submit it all right we are redirected to the issues page now let's go to our database and make sure this issue is properly saved there you go we have two instances of this book because previously even though we got an error with the Navigator object the bug was actually saved in our database all right we're done with this step so let's make another commit and say handle form submission our code doesn't currently have error handling so the next thing we want to do is to handle potential errors and provide feedback to the user if something goes wrong to do that we have to wrap these two lines inside a TR catch block so here we add a TR catch block select this item from Auto completion when we have the square box that means this is a code snippet so enter now we have this snippet press Escape now we grab these two lines and move them up like this now if you don't know how to do this let me show you the shortcut so on the top go to the selection menu and look at the shortcut for these move line up or down on Mac it's option with up and down I think on Windows should be alt so we put these two lines inside the tri block now let's just log the error that we get in the catch block now back in the browser let's open the form and see what we get in the console all right begin on axio error object now look at the properties here we have the code that is set to error bad request the message says request fail with status code of 400 now because this is an error that we anticipated in our API here we have a response so in the response object in the data property we have the error messages that are generated by zot so let's go back to our API we go to our route file take a look if the validation is not successful we are returning these validation errors now if you don't like the structure if you think this is too complicated here we can call the format method and with this will get a simpler structure so let's refresh and submit the form again take a look once again we go to response and data now for each field in our form we have a property like title and description we also have a generic error property for any validation error errors that are not specific to one of these fields now for each of these fields we have a property called underline errors and here we have a friendly error message like string must contain at least one character now we can also customize these error messages to do that we have to go back to our schema so over here as the second argument to the main method we can provide a custom error message like title is required we can do the same with our description field so description is required now let's submit the form one more time and look at our error object response data let's look at the title property there you go so we have title is required now in this case we don't really care about this error messages because we shouldn't be able to post the form if the form is invalid so in the next lesson we're going to implement client side validation and show errors to the user if the form is invalid but this technique is useful in situations where we have to rely on the backend to validate the data for example if you want to build a registration form we want to make sure that the user select a unique username that's not something that we can validate on the client we have to rely on the backend right in those cases this is how we can read the error messages returned from the server and then we can show that error to the user so back to our error handling code in this case we don't want to lock the error on the console instead we want to show a generic error message for unexpected errors and to do that first we have to declare a state variable for holding the error so here we use the state hook we initialize our variable to an empty string then we add error and set error and in our catch block wece simply call set error and give it a generic error message like an unexpected error occurred now we want to show the error message right above the form to do that we're going to use one of the components in R xui so let's look at our components here it is called where is it um call out so this is how a call out looks like we can also change the color to Red in terms of the structure we start with call out. Root if you want to add an icon then we add a callout icon and otherwise after that we add call out. text similar to how we use the text field component right so right above this form we want to add a call out to do that first we have to wrap this inside a fragment or inside a div I'm going to use a div because later we're going to apply a couple of classes here so let's wrap the form inside a div now right above the form we add call out. root and we want to render this only if we have an error so if we have an error then we render this call out now inside the call out we should add call out. text and this is where we Rend our error message now to change the color to Red we set the color prop to Red now save the changes back to the form let's submit it again now we have this call out on the top but the width of the call out is not the same as the width of our form so we have to move this Max width class to the containing div so let's grab it from here and add it here good now let's submit the form one more time all right that looks better I want to add a margin below this error message so let's give this call out a class of mb5 all right let's try one more time that looks good we're done with this step now let's make a commit and say handle errors all right now let's Implement client side validation so let's go to our route file so earlier we defined this schema for validating the object that is sent with our request now wouldn't that be nice if we could reuse the same schema for validating our form we can certainly do that let me show you how to do it first we have to grab this schema and put it into a separate model module so we can reuse it in two places in our API here and also in our form to do that I'm not going to grab this code and cut it and paste it somewhere else because with that our project will break we'll have to come back here and explicitly import this schema from that other module a better way is to use the refactoring commands in vs code so we put the cursor right here then right click and go to refactor now let's move this to a new file with as you can see vs code put our schema into this module and automatically imported it on the top we didn't have to manually do this right now back to our API folder so this is where our schema exists right next to our route file now we should take it outside of this folder and put it somewhere more General because we want to use this in our form as well so let's grab it and move it to the app folder and also I would prefer to re name this file to something more General like validation schemas so in the future we can add all our validation schemas in this file all right now to use this in our form first we have to install a package so bring up the terminal window and install at hook for/ resolvers version 3.3.1 this package allows react hook form to integrate with various data validation libraries like zot so let's install it good now let's go back to our new issue page on the top we have to import Zod resolver from Hook form SL resolvers slz now when calling the use form hook here we pass a configuration object and set the resolver to Zod resolver and here we pass our Zod schema that is create issue schema so now this schema is imported on the top from our app folder so this is how we can integrate react book forms with Zod now look at this interface we have defined here it kind of looks redundant because here we are defining two properties that already exist in our schema in the future if we decide to extend this form and add a new property we have to add it in two places in this validation schema and also in this interface wouldn't that be nicer if we could generate this interface based on our schema let me show you how to do that so first we import Z from Zod next we remove this interface and here we call z. infer in angle brackets we type type of and here we pass our schema create issue schema this returns a type so we store it in the type object and call it issue form so now we are letting Zod infer this type based on this schema okay all right next so we have integrated react hook form with Zod now to display validation errors here we have to grab the form State object this object represents everything we need to know about our form so we can destructure it right here now let's press control and space to look at various properties so we have errors we have is dirty this is useful if you want to know the form is changed you also have is submitted is valid and so on is valid is useful if you want to disable the submit button if the form is not valid now in this case we only care about this property errors now we want to render an error message after each field so this is where we have the title field right after that here we check if errors. tile is truthy that means we have an error for the title field so here we render a paragraph or we can use the text components in rixi make sure to import it from radex UI and this is for consistency so in this file we're using rui components as much as possible here we can set the color of text to red and with this we can make sure that all our validation errors have the same color and right here we render errors. tile. message now we need to add an error message for the description field as well so right after this controller we check if errors the description is truthy then we add a text component we set the color to red and here we render errors the description do message that's all we had to do now back in the browser let's submit the form we get our validation messages beautiful now here we have a bit of styling issue because the text component is not a block level element so let's right click it and inspect it look it's a span to solve this problem here we can set the as prop to the type of element that should be rendered for this error message we're going to use a paragraph We need to do this same for our description error now let's submit the form one more time all right that looks good we're done with this step so let's make another commit and say Implement client side validation look at the way we are rendering errors on this page do you see a problem here here's a problem every time time we want to render an error we have to remember to set these two props so our errors look consistent this is where we can extract this markup and put it into a separate reusable component so here in our project in the app folder let's add a new folder called components here we add a new file we call it error message now let's create a react component now typically here we Define an interface called props we give it a property called children of type react node then we add props here now we can destructure this to grab children but this is kind of unnecessary because in react we have a type that defines the shape so instead of explicitly defining this interface every time here we can use props with children this type is defined in the react module so if we control click this look this is a type that defines an object with this shape children okay so we no longer need this interface good now here we return a text component that is defined in rui we set those two props so we set color to red and as to p and then here we render children now we have a single place where we Define the look and feel of our errors and with this we can get rid of this duplication or code so we replace this text component with our custom error message now we can take this to the next level instead of checking if there is an error for this property every single time we can move this responsibility inside the error message component so here we can check if children is falsy then we return null so nothing is rendered otherwise we return a text component and with that we can simplify our code we can get rid of this condition now here we get a compilation error because title may be undefined to solve this we use optional chaining so here's the end result it's much nicer much cleaner and we don't have any kind of duplication here let's apply the same technique to the description error so we remove the braces and replace the text component with an error message and here we use optional chaining Let's test our application to make sure we haven't broken anything so I'm going to submit the form beautiful so we're done with this step and now it's time to make another commit extract the error message component now to improve user experience we want to show a spinner in the button when submitting the form to do that search for Tailwind elements spinner on this page you can see various examples of showing Spinners using Tailwind so here's a basic example we can also change the color we can use a different effect we have all sorts of spinners so let's look at the basic example look at the code so we're going to grab this markup and put it into a reusable component so let's copy it here now back to our project here in the components folder let's add a new file called spinner we create a react component and then paste all that markup now we have two class attributes that we should rename to class name one way is to put the cursor here press command and D on Mac or control and D on Windows to select the next occurence but let me show you another technique if we have many instances that we want to rename in one go we don't want to keep pressing command and D we can select all of them using a special shortcut so on the top Under The Selection menu look at the shortcut for select all occurrences on Mac it's shift command and L I guess on Windows is shift control and L so let's press Escape I'm going to press shift command and L now all instances of the class keyword are selected so let's rename this to class name save the changes now to test this let's go to our new issue page and put a spinner inside this button all right here's what we get our spinner is a little bit too large so to make it smaller let's go back to our spinner component and change the height and the width to four now we can take this to the next level and give it a size prop so we can render Spinners at different sizes but at this point that is over engineering because we don't have that requirement that's one of the traps that a lot of software developers fall into they start predicting all kinds of what if scenarios that may never happen so don't over engineer your Solutions instead focus on existing problems as opposed to problems that may never happen in the future so we change the size to four now here's what we get our spinner is a little bit too thick for this size so to make it thinner we change the size of the border from four to two all right I think that looks good now we want to show this only when the form is submitted to do that we go back to our new issue page and declare a state variable we initialize it to false and call it is submitting now in our Tri block before we call the backend first we said submitting to true and in our catch block if something goes wrong we reset it so the spinner doesn't stay there now finally in our button we render the spinner only if the form is submitting so is submitting if it's truthy then we render a spinner now it's also a good practice to disable the button to prevent the user from submitting the form twice this is especially important when building applications that deal with money so so let's set disabled to is submitting all right here's what we have Let's test our application so once again if we submit the form without any values we get our validation errors beautiful now let's add a bug here description of bug three submit beautiful we're done with this step and now it's time to make another commit add a spinner we're almost done with implementing our first feature so now let's spend a few minutes and talk about better ways to organize our code now the first thing I'm going to talk about is this inline function in this component so some people argue that we shouldn't use inline functions in the middle of our markup because they make things unnecessarily complicated now there are other people who like inline functions they prefer inline functions and they argue that inline functions are easier to understand because they don't have to jump back and forth between different parts of the code to see what is going on so this is one of those areas where different people have different opinions there's really no right or wrong here in my opinion inline functions are not necessarily evil if there are one or two lines it's better to keep them in line but otherwise if they get more complex it's better to move them outside and separate them from our markup in this case our inline function has seven lines of code so I prefer to move this logic outside of this markup so let's declare a constant called unsubmit and we set it to this piece of code like this so now the logic for submitting the form is completely separated from our markup we just have to remember to add unsubmit here with this our markup is completely separated from our logic so that was good now there is another issue we want to talk about here and that is this line of code some people argue that using axis in the middle of a component violates the separation of concerns principle what is separation of concerns well it's one of the old computer science principles that says we should separate a program into distinct modules each having a separate concern if concerns are well separated there are more opportunities for code reuse so people who argue that we shouldn't use AXS or make HTTP calls inside a component suggest that we should move this logic into a separate function outside of this module and then call that function here for example we could have a function like create issue that takes the data so in that function we'll have the code for making the HTTP call I I have done this a lot in the past but over time My Views have changed in this application I don't see any value in moving this logic inside a separate function that is just unnecessary abstraction because realistically in this application this is the only place where we need to create an issue so we're not going to reuse this function in other parts of our application so the promise of reusing this piece of logic doesn't apply here but in other applications making HTTP calls might be more comp licated for example sometimes when calling third party apis we have to include certain HTTP headers in each request in those cases we don't want to throw all that complexity inside our components so it's better to move the logic for making HTTP calls into separate modules so here's what I want you to take away software engineering is not black and white there is no one siiz feits all so if someone says this is the best practice you should always do things this way don't listen to that person every project is different every application has different requirements don't take someone else's solution and apply it as silver bullet in all your projects so in this application at this point I don't see a reason for moving this Logic for making HTTP call into a separate module so let's remove this comment we're done with this that so let's make one more commit here I'm going to say refactor move inline function congratulations on reaching this point and creating something awesome along with me now as I said before this tutorial is only the beginning so I invite you to join me in my ultimate nextjs Series this series contains two courses the first part covers everything about nextjs and part two is where we build and deploy this issue tracker project now because you have stuck with me till now I'm offering you a special discount but this is only available to the first 100 people so click the link below and let's continue this journey and build the eso tracker project together