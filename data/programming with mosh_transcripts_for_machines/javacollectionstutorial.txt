in this video you're going to learn everything you need to know about java collections so by the end of this video you'll be able to write java code with confidence hi i'm adani and i've taught millions of people how to code through this channel and my online school codewoodmash.com this video is part of my ultimate java mastery course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started let's start this section by brief overview of what we have in the collections framework so the green boxes you see here are interfaces and the blue boxes are classes that implement these interfaces now don't worry about memorizing any of these we're going to get back to this slide several times throughout this section so at the top of this hierarchy we have the iterable interface this interface represents an object that can be used in a for each statement so if we implement this interface in our generic list class we'll be able to use it in a for each loop i'll show you how to do that later below that we have the collection interface this interface extends the iterable interface and adds additional functionality it represents an object that can act like a container or a collection of objects now here's a question for you what are the capabilities that we need in a collection we should be able to add an object to a collection we should be able to remove an object we should be able to check for the existence of an object and so on so these are the operations that the collection interface declares if you search for java collection interface on this page you can see all the operations that this interface declares for example we have add for adding an object we have add all we have clear and so on now below this collection interface we have three sub interfaces list queue and set each of these again inherits all the capability declared in the collection interface and add something extra for example the list interface allows us to work with an ordered collection and access objects using their index just like how we can access an object by its index in an array now we have different implementations of this interface in the collections framework the one that you would be using most of the time is the arraylist class which is an implementation of a dynamic array so internally it uses an array to store objects if the array gets full it will automatically resize the array we have another implementation called linked list which is based on the linked list data structure the explanation of linked lists goes beyond the scope of this course i've covered them in detail in my data structures and algorithms course so we have two different implementations of the list interface again most of the time you will be using the arraylist class the q interface also extends the collection interface and provides additional operations for working with a queue of objects we use cues in situations where we have a resource that can be shared amongst many consumers a good example of this is the printer at your office different people can print different papers at the same time but a printer is not going to be able to print them all simultaneously so each job should go in a queue the printer will then take these jobs one by one and process them now in the collections framework the class that implements the qr interface is called priority queue we're going to look at that later in this section and finally we have the set interface which represents a collection without duplicates the class that implements this interface is called hiset so that was a very basic overview throughout this section we're going to explore each of these building blocks in detail as i told you in the last video the iterable interface is at the top of our hierarchy now more accurately this interface is not part of the collections framework in fact it's part of the java.lang package so it's one of the fundamental interfaces in java and represents an object that we can iterate or loop over now before we look at the specifics of this interface let's talk about the problem it tries to solve so here in the main method i'm going to create a generic list new generic list of strings let's add a couple of objects here so add a and b now we want to iterate over this list and print each item so we write a for each loop for item in list look we have a compilation error here for each not applicable to type generic list now one way to solve this problem is to go back to the generic list class and make this private field public then we'll be able to access the items array from outside of this class so here in the main method we can type list.items now we can iterate over this array and print each item now the problem with this approach is that we have exposed the internal implementation of this class to the outside so if we decide to change this implementation in the future and replace this array with a different data structure all the code that is dependent on this field will have to be changed as a metaphor think of the remote control of your tv this remote control has a few simple buttons for you to work with but on the inside it has a complex logic board that's the implementation detail now if tomorrow the manufacturing company decides to change this internal implementation you are not going to get affected if they replace a transistor with an advanced model you can still use the same buttons you're familiar with so changing the internal implementation of a remote control should not impact its public interface in objectoriented programming we should design our classes in the same way again i talked about this concept a lot in the second part of the series so back to our generic list we should not expose the items filled to the outside because this is the implementation detail let me show you the problem with this code with this implementation we can go back to our main method and write code like this list that items of zero we set this to a string like a and then we can print less than items.length now what is the problem here well there is no problem right now but if tomorrow we decide to replace this array with an arraylist object our code is going to break let me show you so we type arraylist of t this is a class declared in the collections framework and it's an implementation of a dynamic array we're going to look at it soon so let's create an arraylist object here new arraylist now back to the main method see what happened our code broke because the arraylist class does not support the square bracket syntax for accessing an object by its index also it doesn't have a field called length so a simple change in the implementation detail of our generic list resulted in two breaking changes in our main method now this is a very simple program but in a real application we could have hundreds of references to our generic list so if we change the implementation detail then we'll have to go back and fix all those hundreds of places that are broken so here's the question how can we iterate over a list without knowing anything about its internal implementation that is where the iterable interface comes to the rescue in the next video i'm going to show you how to solve this problem using the iterable interface the iterable interface represents an object that is iterable that means we can iterate or loop over it without knowing anything about this implementation detail so we are using an area here if we decide to replace this with an arraylist or a different data structure in the future the clients of this class are not going to get affected because they are going to code against the iterable interface back to our remote control metaphor think of the buttons for changing the volume if the internal implementation of this remote control changes you're not going to get affected you're still going to use the same buttons these buttons are the interfaces that you work with so we want to implement the iterable interface in this class and then have other classes that use our generic list program against the iterable interface it's like saying that they use the volume control buttons on a remote control okay now here is the documentation for the interval interface as you can see this interface declares three methods the first and last methods have a default implementation so we don't have to implement them the only method that we have to implement is this method over here iterator it returns an iterator object we're going to talk about iterators in the next video but very briefly an iterator is an object that we use to iterate over an iterable now i know the name is confusing but don't worry i'm going to make it super simple for you so back to our generic list class here we type implements iterable of t so this is also a generic interface now we press alt and enter and have intellij implement the method so here you can see the same three methods that i showed you the iterator method is highlighted because it's a required method so let's press ok and here you can see the iterator method for now don't worry about the code we're going to write in this method we're going to come back and complete this in the next video all i want you to pay attention to is the return type of this method it returns an iterator object so back to our main method now that our list implements the iterable interface we know that it has the iterator method so we call it to get an iterator and with this we can iterate or loop over our list without knowing anything about its internal implementation so we can write code like this while iterator has next we're going to call iterator dot next this will return the current object so we store it over here and then print it on the console what's going on here well imagine our list looks like this so we have a b and c this iterator is like a pointer that is pointing at one object so initially it's pointing at the first object at the beginning of our loop we ask do you have more items it says yes so here we call the next method this will return the current item which is the a and then it will advance the pointer to point to b in the next iteration we ask the iterator do you have more items we still do so this method will return true then we read the current item and advance the pointer one more time we read the c and then the iterator ends up here so in the next iteration when we call the hasnext method we'll get false so this iterator is simply an object that we use to iterate over a list or more accurately an object that is iterable now let me show you something really interesting let's compile the code then from the project window let's select the main class and look at its byte code representation take a look so over here we have a reference to iterator that has next and iterator.next now i'm going to delete all the code for using this iterator object and instead use a for each loop so for each item and list we're going to print each item one more time we're going to compile the code and look at the bytecode representation of the main class take a look we still have a reference to the iterator object so the for each loop is actually a syntactical sugar over the iterator object when we use the for each loop the java compiler will convert our code to use an iterator object this is the reason why we can iterate over this list using a forage loop now if i remove this bit of code over here implements iterable and go back to the main class you can see we have a compilation error saying for each not applicable to type generic list so this is the benefit of implementing the iterable interface it allows us to iterate over an object without knowing anything about its internal implementation so i'm going to bring this back now if tomorrow we decide to replace this array with let's say an arraylist our foreign loop is not going to get affected now our implementation is not complete we still have to implement the iterator method and that's what we're going to do next in this video we're going to complete our implementation of the iterator method so as you can see this method returns an iterator object this iterator is actually an interface declared in the java.util package so here on the documentation you can see the four methods declared in this interface these two methods over here have a default implementation so we don't have to worry about them the only two methods that we have to implement are has next and next which you saw in the last video so now we should declare a new class that implements the iterator interface so back to our generic list we're going to implement this iterator as a private nested class inside this generator list class you will see why in a second so after the iterator method we declare a private class called list iterator this class should implement the iterator interface which is generic so iterator of t now this t that we have here is the same t that we used when declaring our generic list so if the client of this class let's say in our main method we create a new generic list of string this type parameter is going to be a string and we're going to use the same type parameter over here because we're going to iterate over a list of strings so that is why i don't want to hard code a type over here like string or integer i want to use the same type parameter that we have on the top okay so here's our private class now let's implement the iterator interface so we press alt enter and select implement methods so the two required methods are highlighted let's click ok now in this class we want to iterate over a generic list so we should pass that generic list over here via a constructor so let's add a constructor public list iterator here we need a parameter of type generic list of t the same type parameter we call it list now we should store this in a private field in this class so private generate list of t recorded list and here we set this that list to list now because we have declared this list iterator inside our generic list here we have access to list that items so we can see the items array and this is perfectly fine because this class is part of the implementation of our generic list so if tomorrow we decide to replace this array with let's say an arraylist this class is the only place where we have to make changes because this class knows how to iterate over a generic list so if we replace the items array with an arraylist nowhere else in the code nowhere inside the main method or anywhere else where we have used a generic list we have to make changes okay now here's a question how can we iterate over an array well we need an index variable initially we set it to zero as long as the index is less than the number of items in the array we increment it right so let's declare a private field of type integer called index now in our has next method instead of returning false we're going to return a boolean expression like this if index is less than list that count then in our next method instead of returning null we're going to return list that items of index and then we'll increment the index so initially index is zero when we call the next method this will return list that items of zero now next time we call this method index is going to be one so we'll return the second item in this array and we're going to do this as long as index is less than the number of items in our list okay so pretty simple we're done implementing our list iterator now back to our iterator method instead of returning null we're going to return a new list iterator now note that here we have another list iterator which is an interface declared in the java.util package we don't want this one we want the list iterator that we declared here so let's create a new object and here we should pass our generic list to the constructor of this class what is that that is the current object this so let's quickly recap we made our generic list iterable by implementing the iterable interface and here we return a list iterator this is an object that knows how to iterate over a generic list so it has intimate knowledge of the implementation detail of our generic list if tomorrow we decide to replace this array with an arraylist or a different data structure this iterator is the only place where we have to modify our code now back to our main class let's add a couple of items in this list let's add a and then b here we can iterate over this list using a 4h loop take a look we get a and b next we're going to talk about the collection interface the next interface we're going to talk about is the collection interface which represents an object that acts as a collection or a container for other objects what are the operations that we need to work with the collection we should be able to add an object to this collection we should be able to remove an existing object we should be able to check for the existence of an object and so on these are the operations that the collection interface declares here on the documentation you can see that the collection interface is also a generic interface because here we have a generic type parameter but instead of t we have e which is short for element that is a common convention for declaring interfaces or classes that have a collection semantic because a collection can have multiple elements okay now over here you can see that this interface extends the iterable interface so every collection is also iterable and that means we can use a for each loop to iterate over all collections in java now over here you can see various classes that implement this interface as you can see there are over 20 implementations of this interface most of the time like 90 of the time you only need to use the arraylist class these other implementations are for special purposes and we're not going to cover them in this course you can learn about them on your own i just want to give you a strong foundation so back to our project i'm going to add a new package a new package called collections we're going to write all the code in this section in this package i'm going to add a new class called collections demo in this class we're going to have a public static method called show this is where i'm going to show you various operations in the collection interface if you download the source code that i've included at the beginning of this course you can see all examples in this class but while i'm recording this video i'm going to delete some of these examples to keep the screen clean and easy to read now back in the main class we're going to call collectionsdemo dot show now here i'm going to declare a variable of type collection of string let's import this type so that is an interface we call this variable collection now here we should set this to a new instance of arraylist because this is one of the classes that implements this interface now let's add a few items to this collection so collection.add we can add a string like a then b and then c because this collection is iterable we can use a forage loop here so for item in collection we can print each item so we get abc we can also print the collection as a whole so print collection now what if you want to add multiple items in one go instead of calling the add method three times well here we have another class called collections that is a utility class declared in the java.util package this class has a method called add all the first parameter of this method is the collection that we want to modify so we pass our collection over here now look at the second argument here we can see the list of parameters by pressing command and p on mac or ctrl p on windows if the shortcut doesn't work for you you can find it under view parameter info okay so look at the second parameter a string dot dot dot when you see dot dot dot that means you can pass a variable number of arguments you can pass zero or more strings so here we can pass a and then b and then c so instead of calling the add method three times we're passing multiple arguments to this method now if we run our program we get the same result as before another useful method is the size method that returns the size of a collection so here we have three items we also have a method for removing an object from a collection so we can call collection.remove a and then we can print the collection so a is gone we can also remove all items by calling the clear method now the collection is empty we can verify that by calling the is empty method so it returns true if you want to check for the existence of an item you can call the contains method so we want to see if this collection contains an a so it contains a and then we can print contains a you get true there are times you want to convert a collection to a regular array so here we call collection.2 array as you can see this method has three forms or three overloads if we don't pass any arguments here this will return an object array so we can store it in an object array so every item in this array is going to be an instance of the object class that means if we get the first item and use the dot operator we don't see any of the string methods if that's what you need then you need to convert this collection to a string array instead of an object array that's very easy we call collection.2 array we're going to use this form this overload that takes a t array so if we pass a new string array here now how many items do we have in this collection one two three so we pass a string array over here and this will return a string array also we don't really have to specify the size here we could simply pass zero and that is a common convention because you don't want to worry about counting the number of items in your collection you can simply pass an empty array and this method would automatically create an array with enough capacity to hold all these items okay now if we get the first item we can access all the string methods for example we can convert this string to the lowercase or uppercase and so on and by the way we can use var here just as usual now some people don't like var they argue that we cannot see the type of this object but that is not right so if you put the carrot over here and then go to view quick documentation the shortcut is f1 you can easily see that this is an object array or if you put the caret over here and one more time press f1 we can see that this is a string array so i personally prefer var because it makes our code cleaner so this is how we can use the two array methods now there are times you want to compare to collections for equality so i'm going to create another collection of type string let's call it other and set it to a new arraylist now what would happen if we use var over here then the type of this variable is going to be the arraylist class not the collection interface so it's going to include the additional methods that are declared in the arraylist class now as i explained in the second part of this series we should program against interfaces this will make our applications more flexible and loosely coupled so i'm going to revert this back to collection of string now i want to add every object that we have in this collection in our second collection so we type other that add all now look at the type of this parameter it's collection of unknown extends string so we have a wildcard again that means we can pass a collection of string or any type that extends the collection of string so i'm going to pass our first collection now you want to check to see if these two collections are equal so i'm going to do a print statement here what do you think is the result of this expression collection equals other are we going to get true or false we're going to get false because these are two different objects in memory look here we have two new operations so these are going to be different objects in memory and this equality operator compares these objects by their references or their addresses in memory now if you want to check to see if two collections have the exact same content you should use the equals method so print collection equals other take a look so we get false as a result of evaluating this expression because these are two different objects in memory but we get true because these two collections have the exact same content so this was all about the collection interface once again don't worry about memorizing any of these all you need to take away from this video is the kind of operations that are provided by the collection interface we can add an object we can remove an object we can check to see if an object exists and so on don't worry about memorizing you can always look at these operations on the documentation next we're going to look at the list interface the list interface represents an ordered collection also called a sequence so with lists we can access objects by their index in collections we don't care about the index of objects we just care about adding or removing them from a collection so in your applications if you want to work with an ordered collection if you care about the index of objects on a collection you should use the list interface so let's declare a variable of type list of string we're going to import this and set it to a new array list now because the list interface extends the collection interface here we have all the methods you learned about in the last video so we can call list.add to add a few items a b and c but we also have an overload of the ad that takes an integer so if you want to insert a value or an object at a particular index we use this overload let's say i want to add an exclamation mark at the beginning so you pass zero as the index of the first item now we can print the list and here's the result we couldn't do this with the collection interface because collections don't support indexing now we can also add multiple items in one go so here we call collections that add all now look at the first parameter it's a collection so because every list is a collection here we can pass our list object along with a few values like a b and c now here we can get an object by its index using the get method so we can get the first item and print it and we get a we also have a method for replacing an object at the given index so list.set let's set the first object to a plus now we print plain turn list and here's the result we can also remove an object by its index here we call list.remove zero again we didn't have this method in the collection interface because collections don't support indexing now take a look a is gone and we only have b and c another useful method is the index of method so we can call the index of method and pass a and this will return the index of the first occurrence of a in this case it's going to be 0. now if we search for a value or an object that doesn't exist here you're going to get negative 1. there you go another useful method is last index of and this will return the index of the last occurrence of this object so if we add another a here the index of the second a is going to be three so there you go now i'm going to remove this another useful method is the sublist method so we can call list.sublist here we pass two indexes from and two from is inclusive but two is exclusive so we can start from index zero and get all the items up to index two and this will return the objects at index zero and one take a look there you go just realize that the original list is not affected because this method returns a new list okay so this is all about the list interface next we're going to talk about sorting data thank you so much for watching this video as i said this video is part of my ultimate java mastery course that teaches you everything you need to know about java from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day