all right we got to profiling which is my favorite part of this section so in this section I'm going to show you a performance problem I have created in this application and then I will show you how we can detect and fix this if you want to follow the steps I'm doing you can download this application from the supplementary materials of this lecture so when you extract the zip file you want to npm install and then ng surf so this is the same application we've been working with in this section with a few minor changes we've got this title here and a new button to change the title also in the list of movies now we have 10,000 movies I deliberately added a lot of objects to pronounce the performance problem so you can see and all these ones you see here are properties of each movie object you will see that in a second so let's go to app component previously we initialize the movie stills right here but I move that in the constructor in a loop so we create 10,000 movie objects and push them into our array but each movie object used to have only one property which was title now we have 10 additional properties here so prop 1 to prop 10 and I just set their value to 1 and if we go to the template for the movie component you can see I'm rendering all these additional properties in a span again I have deliberately done this to pronounce the performance problem so let's see what's going on here when I click this button change title it's going to take several seconds until the hello world title is updated let's have a look look the button still in the push state it's blue and we are waiting and waiting and waiting finally the title is updated so it was really really slow so when you have problems like that in your application the first thing you need to do is profiling so we open up Chrome developer tools go to the profiles tab make sure the first option is selected record JavaScript CPU profile and now we start profiling record now we can get back here and click our button to update the title ok it's taking forever just like before alright done now back to our profiler you've stopped profiling now in this list make sure you have selective heavybottomed off and then sort this list by total time in a descending order here we can see the total time spent for various functions in our application a lot of what you see here is internals of angular that we don't really need to worry about you want to focus on the parts that are about our implementation so for example they've got all these functions like zone tasks that invokes zone that run tasks and so on these are internals of angular and zone J's library but we don't have to worry about it now if you scroll down you see this log function with a total time of 6,000 milliseconds allocated to it this is our console log so a lot of times we throw these console logs into code and we have no idea that they can have a negative impact on the performance of our application in this case if you look at movie components you can see we're calling console log in ng do check which is called pretty frequently so this is very very dangerous the first thing I'm going to do is to comment this out now log aside let's look at other stuff happening here so once again we go from top of the list look at every function if it's about the internals of an angular we ignore it otherwise you want to take a closer look at it so you scroll down here first thing that catches my eye is this function here underlined vo underline app component underline how's that detect changes diagnosis detect changes here so let me zoom out okay hopefully you can see now but the font is a little bit too small so app component host detect changes and the total time for this function is about 8,000 milliseconds so this tells me that the View for app component has a performance problem all right let's go to app start component on HTML what do we have here we have a binding expression to render the title and we have a reference to the movies component now let's take a look at a template for the movies component so movies that HTML again here we have a reference to another component the movie component so back in apps that component on HTML basically we have a subtree here we have this movies component which includes 10,000 more component instances and this is exactly the source of our problem why do we have to go through all this change detection when we are only updating the title of app component we haven't modified anything about movies but as I explained before the default change detection strategy looks at the template for every component in our component tree look at all this binding expressions get all the properties used there and compare they're all value with the new value we don't want all this to happen when you're only changing the title of the app component so I believe we can solve this problem by using the unpretty under movies component this way if the input to this component in this case this movies object is not modified if you still the same reference angular is not going to run change detection and this component and all its children which includes ten thousand movies so let's go to the movies component movies the TF you can see the change detection is set to default so whether we had this line or not it didn't make a difference I'm going to change this to on push now we should make sure that the movies objects that we pass through this component is an immutable object so change detection works properly so we go back to app components these are movies object which is just a plain array I'm going to use an immutable list from immutable library so instead of pushing this objects directly into this movies field I'm going to push them into this temporary array I've declared here now at the end of this constructor we can set this movies field to a list and initialize it with this movies array you have a compilation error because the type of this movies is a plain JavaScript array so I'm going to remove this I have to clarify something earlier in this section when you're working with this click handler we use the unpressed strategy and the movie component but in this application that I have attached to this lecture I have removed the unpressed rata G on the movie component so I was assuming that all components are using the default change detection strategy in this application because the source of the issue is on the change detection of this movies component I only applied the unrestrained this component itself that any of these children not the movie component that's not really required all right now with these simple changes let's test the application again so I'm going to click this button and the title is updated immediately see the difference previously it took several seconds now let's go back to Chrome developer tools I'm going to do another profiling session so record back here click the button and stop the profiling session now compare the results this time I'm gonna sort by function now in this list let's scroll down we want to look at functions that start with underlined view so here we have underlined view underlined add component we only have two functions that match this pattern the full name of this function as you saw earlier is underlined view underline app component does detect changes note the total time spent on this function eight milliseconds this is after the optimization now let's go back to our first profile find the same function and look at the total time so profile one once again we're gonna sort by function scroll down look it's got so many functions that match the pattern underline view underline app component underline view under the movie component and underline you underline movies components so you can see our change detection is going a lot deeper in our component tree it's not just at the app component level now that is like look at the total time spend unchanged the texture in app component it's almost eight thousand milliseconds and we reduce that to how many milliseconds eight milliseconds so in your applications if you have performance problems that are related to detecting changes this is how you find and fix them now one last thing before we finish this lecture in this lecture I started by looking at the template for app components I notice that here we are referencing the movies components then I had to look at the template for movies component and see if they're using other components there you can imagine this can be tedious and complex in a larger real world application so let me show you a tool that helps you visualize your component tree and this is very useful when you want to decide where to apply the unput strategy so in google search for augury Chrome extension this is a great tool for debugging angular apps built by R + L dot IO so simply add this to your Chrome and once you restart it you get a new tab in chrome developer tools so back here when I open up the chrome developer tools you'll see I have a new tab here augury but here on the left opponent tree so we've got app component on the top under that we've got movies component and 10,000 movie components hey thank you for watching my youtube video my name is Muhammad Ronnie and I'm a fullstack developer applause I'd author and in getting me instructor with about 14 courses at the time of recording this video so I've got lots of courses on both front end and back end development including three sharp entity framework a plasma the MVC angular architecture unit testing and so on this video watch is actually part of my angular course on udemy that you can get with a discount using the link in the video description and if you want to see my other courses simply head over to programming with mass comm slash courses you can also subscribe to my youtube channel to get free videos every week have a great day and I'll be back show you