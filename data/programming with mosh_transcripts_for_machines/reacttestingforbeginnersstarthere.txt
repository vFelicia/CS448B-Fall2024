welcome to the complete react testing course in this course you're going to learn everything necessary to write effective valuable and maintainable tests for your react applications if you have been searching for a comprehensive easy to follow well organized and practical course that takes you from Zero to Hero this is the right react testing course for you this course is packed with a ton of coding techniques I've learned over 20 years in software engineering plus it's packed with numerous real word exercises designed to help you master react testing by the end of this course you'll have the skills and knowledge to confidently test react applications like your pro this expertise will set you apart in the world of software development opening doors to exciting opportunities and challenges I'm m hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school cm.com so are you ready to elevate your react skills let's dive in and get started I Promise by the end of this course you will look at unit testing in a whole new way if you're new here welcome aboard make sure to subscribe as we upload new videos all the time let's talk about what you need to know to take this course first and foremost you should have a good grasp of react because we're testing a react application in this course so you need to know all the essential Concepts like components hooks State Management routing and so on if you want to brush up on your react skills I have a couple of comprehensive courses on my website so feel free to check them out now if you're watching this video on YouTube I've put the links Below in the description box you can also go to code withth mos.com to see all my courses now the react application we're going to test in this course is written with typescript so you should know the basics of typescript as well don't worry you don't need to be an expert just knowing the basics is enough you should know how to define types and annotate your objects with types that's all now if you want to learn typescript I have a 1hour tutorial on my YouTube channel as well as a comprehensive course on my website again the links are below this video now there is one more thing you need to know you should know the basics of unit testing plain JavaScript code without any UI Frameworks more specifically you should know how to write basic unit tests and make assertions so I'm assuming you know the basics of unit testing and in this course you want to learn how to test react applications now if you want to learn the basics of unit testing JavaScript code again I have a 1hour tutorial on my YouTube channel as well as a comprehensive course on my website now assuming that you are the right student for this course let's move on to the next Lon all right before we jump in let's take a quick look at what we'll cover in this course shortly after this video we're going to set up our development environment and get all the testing tools we need in the next section we'll explore testing react components with the react testing Library this is where the fun begins you will learn how to use this powerful library to write tests that are maintainable and closely resemble how your web pages are used then we'll talk about mocking apis you will learn how to write tests that are robust and independent of external factors next on our list is testing forms forms are crucial in user interaction and I will show you various techniques to make sure they work flawlessly every time moving forward we'll delve into testing State Management in this section we'll look at a few examples involving react context Redux and react query after that we'll talk about testing authentication and in the final section we'll cover testing routing now a lot of people struggle with unit testing why because they don't know how to write good tests they spend a lot of time writing and fixing lowquality tests these tests get in the way slow you down and can be really frustrating but don't worry because throughout the course I'm going to show you various techniques to write tests that are not just good but great these are the techniques I've learned and M over two decades of working as a software engineer so I will show you how to write tests that are effective valuable and easy to maintain so there's a lot to cover and by the end of this course you'll be really good at testing react applications I promise before we start coding let's talk about how you should take this course first off as you learned in the previous video I've structured this course so it's super clear and easy to follow now you might be tempted to just jump to the sections that seem relevant to you but here's my advice don't do that even if you have been writing tests for a while you might have picked up some bad habits along the way that's why I suggest starting from the beginning and watching every single lesson because throughout the course I share a bunch of shortcuts for navigating your code base and writing code quickly if you skip around you might miss these and feel like the course is moving too fast trust me these tips are game changers now let's talk about exercises this course is incredibly HandsOn and is packed with real boo exercises in fact more than half of the course is dedicated to these practical exercises if you really want to get good at testing you need to do these exercises and don't just do them make sure to watch my Solutions as well that's where I share the techniques I have learned and refined over two decades of working as a software engineer these aren't your everyday tips and tricks you probably won't find them in most other courses I promise every minute you spend on this course is going to be worth your time lastly this course comes with a couple of GitHub repositories there is one for the started project and another one for the finished project which includes all the code we write in this course for each lesson we have a separate commit this way you can see the exact code I write in that lesson step by step so that's how we can get the absolute best out of this course follow it step by step and complete all the exercises I can't wait to see how much you learn and grow as a software engineer all right before we get started let's make sure you have the necessary tools installed on your machine first head over to nodejs.org and download the latest version of node this is really important because sometimes in newer versions of node there are optimizations that make your tests run faster so make sure to download the latest version of node now in addition to node we're going to use git to manage our source code these days pretty much everyone has git on their machine but if you don't head over to gm docomo the latest version for your operating system now in this course just like my other courses I'll be using visual studio code or vs code as my editor you're welcome to use your preferred editor but I highly recommend you to use Visual Studio code because it makes it easier to follow along plus I'm going to show you a lot of shortcuts to boost your productivity and have fun coding all right now let's set up the starter project for this course head over to github.com slmos dhamani then go to repositories here we have two repositories for this course react testing starter which is our starter project and react testing finish which is the completed solution so let's go to react testing starter now here you can find all the details about this project for example you can see that our project uses ozero for authentication and it's built with Tailwind rui react router react query and Redux toolkit ideally you should have basic familiarity with all these Technologies and libraries but if not that's still fine so the first thing we have to do here is setting up off zero for Authentication so head over to off zero.com if you don't have an account sign up it's free and it takes only a couple minutes then once you log in here on the dashboard on the left side go to Applications and create a new application we can call this whatever doesn't really matter I'm going to call it my react app now we go to the settings page and here we have to set a few settings first we have to set application type to single page application next we set allowed call back URLs we set it to http Local Host Port 5173 this is the port that our project uses now I'm going to copy this address and paste it in allowed log out URLs box as well as allowed web Origins then we save the changes all right good so we are done with setting up off zero now we need to go back to GitHub and clone this repository on our machine so let's grab the code then we open a terminal window and clone this repository all right now let's go to react testing starter first we need to install all the dependencies all right good now let's open this with vs code now here in the root directory we have ATV file we're going to take a copy of this for storing our local environment variables so let's make a copy and rename this copy to env. local now we need to replace the azero domain and client ID with the values from our ozero application so back to the settings page of our application on the top you can find the domain and client ID let's copy these values and paste them here and one more time with the client ID lovely now let's go to package.json so look here we have a few scripts we have the server script for starting the backend our backend is implemented with Json server so Json server uses this file db. Json to serve data to our application now in a real application you're not going to use this you're going to use a database but it doesn't really matter as far as testing is concerned because here we're not going to use the real backend we're going to Mark the back end and test the front end in isolation now here we have a script for starting the application using concurrently so using this package we can run both the back end and front end in parallel so back to the term let's run npm start our backend starts at Local Host Port 3000 so make sure you don't have any other applications running on that port and our front end starts at Port 5173 so let's take a look here's our application it's not a fullfledged application but it has a few cool features and patterns that you find in a lot of real world applications for example on the top we have a selector for selecting a language currently English is selected if we change it to Spanish now the message changes here let's go back to English so this is implemented using react context now let's go to the products page here we have a list of products that are feted from the back end we can add them to our shopping cart and the number of items in the shopping cart is updated on the top we also have an admin area that is protected here we get redirected to the universal login page on o zero so let's sign up with a new account all right let's authorize our application all right I'm logged in and now I have access to the admin area here we have a products page where we can manage our products we can add a new product we have a basic form let's add product one give it a price now here we have full validation so if we submit the form without supplying any values we get validation errors so let's give this a price of $10 and assign it to a category like Electronics here's our product we can also edit it let's change the category to appliances good now we get this toast notification on the top beautiful now finally if you log out we get redirected back to the homepage so we have a few interesting patterns and features that you find in a lot of real word applications now to test this application we need a testing framework as I told you in my JavaScript testing course there are many testing Frameworks out there like Gest mocha Jasmine vest and so on just is probably the most popular testing framework but the problem with justest is that its support for Eos script modules or native JavaScript modules is still experimental so setting things up is a little bit awkward so in this course we'll be using Vest which is a relatively new testing framework built for testing modern JavaScript applications so it has builtin support for ecmascript modules as well as typescript and jsx so back to our project on the top let's go to view and then terminal look at the shortcut it's control and back tick so now we have a terminal window pointing to our project directory let's install vest as a development dependency all right good now we need to create a test script in our package.json file so on the top Under The Go menu look at the shortcut for going to a file on Mac it's command and P on Windows is probably control and P so now let's go to our package.json file here in the scripts object we need to add a new script let's call a test and set it to v test now I would prefer to create another script for running tests using the vest UI so let's call this test colon UI and set it to vest with the UI option now let's create a basic test to make sure that our setup is done properly so back to our project here in the root directory we add a new folder let's call that test here we add a new file let's call it main. test.ts now here on the extensions panel I want you to search for vest we have this very useful extension called vest Snippets it's from this developer Dean software with this extension installed here we can import the essential functions from vest by typing IV that is short for import v test so now we have it expect and describe from V Test Now to create a test Suite we type D followed by enter the name doesn't matter let's press tab Now to create a test case we type I followed by enter now I don't know why I have two instances in the autoc completion box the one we need is the one with this Square icon that is a code snippet so let's select that now let's write a basic assertion and say expect one to be truy now let's go back to the terminal window and run npm test or npm to run tests in the terminal all right our test passed beautiful now let's quate and run test using Vest UI so npm run test coland UI now the first time it's asking if you want to install vest UI let's select yes all right good now we need to run this command one more time all right here's v test UI throughout the course we're going to use this interface to run our tests because it's much easier to see what's happening as opposed to running tests in the terminal window now I don't like the light mode so let's change it to dark that's easier on the eyes so we have one passing test beautiful we're done with setting up v test next we're going to set up react testing library to test react components we need a few tools the first one is react testing Library which allows us to render our components and interact with them just like the end user so let's go back to the terminal and install react testing Library as a development dependency so at testing D Library SL react and the version I'm going to install is all right good now the next Library we need is jsd what is this well by default our tests are executed in a node environment but node doesn't know anything about browser apis like the Dom so to test our react components we need to run our tests within an environment that emulates a browser environment we have a couple of options here we have jsd and Happy D which is faster but lacks some apis so we're going to start with JS Dom but later we can switch to happy to optimize our tests so back in the terminal let's install JS Dom as a development dependency and the version I'm going to install is 24.0 point0 now we need to create a configuration file for vest to tell it to use jsdom as the testing environment so back to our project here in the root directory let's add a new file called vest.com config TTS make sure you create this file in the root okay now here on the top first we import Define config from vest SLC config next we call this function and give it an object here we set test to an object and set environment to JS D now this returns a configuration object so we export it as a default object from this module now whenever we change vest configuration we have to restart vest so back to our terminal window where we are running vest UI let's press Q to quit and rerun npm run test UI all right good now the last Library we need is testing Library slj Dum this Library gives us a bunch of matchers for writing assertions that against the Dom for example we can check to see if an element is in the Dom if it has the right content and so on so back in the terminal let's install one more library and that is at testing Library slj ddom welcome back to the complete react testing course in this section we're going to dive deep into the world of testing react components we'll kick things up off by understanding what to test and what not to test when it comes to testing components we'll then jump right in and explore testing rendering and user interactions we'll also look at a few techniques you need to know to test components that use component libraries like radex UI material UI and so on throughout this section I will also show you a few techniques to simplify your tests and make them more maintainable and finally we'll wrap up this section by talking about using ES length to catch common issues in the code this is a foundational section in the course so make sure to watch every lesson and complete every exercise with that now let's jump in and get started okay before we dive into writing tests let's take a moment and talk about what exactly we should be testing and perhaps more importantly what we can skip testing when it comes to testing react components there are two major concerns we need to test how they render and how they respond to user actions for rendering we should verify that our components render correctly under various conditions if a component has props we should pass different props and verify that it renders correctly if our component handles user events like clicks keyboard inputs or anything similar we should simulate those and check if it reacts the way we expect now in my JavaScript testing course we talked about the importance of creating tests that are maintainable robust and trustworthy I mentioned that having no tests is better than writing bad tests because poorly written tests can get in the way and slow us down now one of the best practices I touched on was testing the behavior and not the implementation in simple words that means we should test what our application does not how it's implemented as an analogy think of testing at TV we use the remote Press buttons and watch what happens we don't care what's inside the TV right similarly when testing a component we should test what it does not how it's implemented if our component uses hooks or react context or reducers these are all implementation details we should not write tests against those details because if the implementation details change in the future our tests may break even if our application still works fine so for the most part we shouldn't test building blocks like Hooks and reducers in isolation unless they're used by several components and have complex logic in those cases yes it makes sense to unit test those pieces in isolation but for the most part we should test them as part of testing our components which is what we call integration testing now you have probably seen this test pyramid before the test pyramid suggests that we should write more more unit tests than integration tests and more integration tests than endtoend tests this is just a guide not a strict rule so when testing react applications we often lean towards integration tests our tests might be slower than unit tests because we'll be testing several units together but they give us better confidence that our application works plus our tests are less likely to break if we refactor some code as long as the end result stays the same the other thing you should avoid is testing Styles why well visual tests can be fragile a tinier style change like changing the font size or color can fail a test and honestly passing visual tests don't guarantee that our application looks good that's a job for our own eyes so instead of wasting our time testing Styles we should test our application's behavior and functionality that's where the real value is All Right theory time is over let's dive into some real examples of component testing as we move forward all right let's write our first test here in the source folder inside the components folder we have a component called GRE a very simple component with a name prop of type string if we provide the name our component renders a heading otherwise it renders a login button so here we need two test cases in one test case we provide a name and and assert that we have a heading with this content in the Dom in the other test case we don't provide a name and assert that we have a login button in the Dom so back to our project we go to our tests folder and create a new folder here called components now in terms of test organization there are two schools of thought Some people prefer to have all their tests inside the tests folder other people prefer to have their tests next to their components there is really no right or wrong here but most of the community prefer to have their tests inside the tests folder this also makes things a little bit easier when working with continuous integration and deployment tools so in this course we're going to put all our tests inside the tests folder now here we have a folder for our components so all our component tests are in a single place now we create a new file called greet test.ts now note that here we are using capital G because that's how we name files that have react components now in this file first we have to import the essential functions from vest so IV then we create a test suite for the greed component here's our first test case it should render hello with the name when name is provided now here first we have to render our greed component to do that we have to import the render function from react testing Library so at testing Library SL react so we call render now here we need to pass our greed component now because we're going to write some jsx expression here we have to rename our file from TS to TSX so let's rename our file to TSX good now here we can render our comp component our greet component now in this case vs code Auto imported this for me on the top if your editor doesn't do it make sure to import greet from the right location so we render greet and set the name prop to let's say mosh so this render function renders our component into a virtual Dom that is implemented by JS Dom the library we installed in the first section okay now to see the state of the Dom we can use the screen object so on this line we also import the screen object now after we render our component we call screen. debug now back to v test UI in the browser let's look at our GRE test here on the console tab look this is the state of our virtual do we have body div and our heading now to complete our test we have to find this heading in the Dom and make an assertion against it to to do that we have to use one of the query methods in react testing Library if you search for react testing Library queries you will find this page here we have a bunch of query methods like by Roll by label text by placeholder text and so on most of the time we prefer to use by roll because this makes our tests more robust and less prone to Breaking changes when we change the UI for example if we change some text or class names of our elements a test using this query method is less likely to fail compared to one that relies on text or class selectors okay also this query method encourages us to interact with our components just like the end user focusing on accessibility features so back to our code here we call screen get by roll now here we have a bunch of standard roles like alert article banner and so on here we want to select an element with the role of heading this returns any kind of heading like H1 H2 and so on now we store it in an object and finally we need to write our assertions so just like unit testing JavaScript code we start with expect we pass our heading object now here we need to use one of the matchers that comes with testing Library so on the top we import at testing Library slj Dom slvest now if you're using just you have to modify your import statement in this package we have a bunch of custom matchers you can find them all by searching testing Library just Dom on this GitHub page you can find all these custom matchers like to be disabled to be enabled to be in the document and so on you don't have to memorize any of these as we go through the course as we work on more exercises you will gradually get familiar with these matches okay so back to our code now let's finish our assertion so we expect heading to be in the document okay back to v test UI we have one passing test beautiful now in my JavaScript testing course I emphasize the importance of testing the correct Behavior so to prevent false positives or tests that always pass we can go to our production code make a tiny change and see if our test fails or not so let's go back to our greed component we can comment out the line of code that should make our test pass now if our test fails it means that we're testing the correct Behavior now look our test failed good we can look at the report tab to see what's happening down here you can see the state of the Dom so we have the login button but we were searching for a heading so back to our great component let's bring this back good now we can write a second assertion and Ensure that our heading has the right content so we expect heading to have text content this is another custom matcher that comes with testing library now here we can pass a string or a regular expression it's often better to use a regular expression to make our tests more robust so here we pass a regular expression and search for Hello mosh and we want to make this case insensitive now if in the future we replace hello with hi or good morning or whatever our test is going to break so we don't want to be over specific here we want to make our assertions a little bit looser or more General okay now again our test is passing great so we're done with our first test case now let's repeat and create a second test case to save time I'm going to duplicate this test case and change the test name should render login button when name is not provided now if you remove the name prop we get a compilation error saying property name is missing because our grid component always expects a name so here we have to pass an mty string but this looks a little bit ugly so to make our component more flexible we can make the name prop optional so right here we add a question mark and now we don't have to supply the name prop all right good now in this test case we get an element by the rule of button let's change the name of this constant to button first we expect our button to be in the document and then we assert that it should have the right content in this case login now look we have two passing tests great once again to verify that we are testing the correct Behavior we go to our production code and comment out the line of code that should make our last test pass now our test failed so that means we're testing the correct Behavior so let's bring it back all right you have learned how to write basic tests using react testing library now there is a problem with our setup every time we want to create a test file we have to add these import statements on the top this is repetitive and conversome so in this lesson I'm going to show you a few techniques for simplifying our test setup first we don't have to import these functions from vest in every single test file we can go to our vest configuration file and turn on globals so let's go to vest. config.sys the first import statement now here we get a bunch of compilation errors from the typescript compiler for example the typescript compiler is complaining that it cannot find name describe to fix this issue we have to go to our typescript configuration file which is tsconfig Json here in the compiler options object we add a new property called types we set it to an array and here we pass V test/ globals now the error should go away there you go if this doesn't happen on your machine bring up the command pallet and search for typescript reload project okay so that was the first Improvement now the second Improvement again we don't want to import this module in every test file to get access to these custom matchers so let's go to our tests folder here we add a new file called setup TTS Now we move this line from our test file into our setup file next we go to our vest configuration file and reference our setup file so here we set setup files to tests SLS setup. TS this setup file is run before each test file it's useful for configuring our testing environment okay now because we have changed our vest configuration file we have to go back to the terminal stop this process and run our tests again all right all our tests are passing great now back to our test file the last Improvement I want to show you here is that we don't have to type import render and screen from testing Library every single time there is a shortcut for this here in the extensions panel search for testing Library snippet we have this extension from Dean software let's install this all right now back to our test file instead of manually typing this every single time we can type ITR and press enter as simple as that okay here's a great exercise for you to practice what you have learned so far in our components folder we have have a component called user account this component has a prop called user of type user let's take a look at this type here we have three properties ID name and is admin now this component renders the users's name and an edit button if the user is an admin so I want you to spend 10 to 15 minutes and write all the test cases for this component to give you a hint here we need three test cases in one test case case we assert that the user's name is rendered in the Dom now to write this assertion you cannot use the get by roll method because look the name is rendered inside a div and divs don't have a role by default unless we give them a role but this is unnecessary so in this test case you have to use a different query method that is called get by text okay now we need two test cases for the edit button in one test case we pass an admin user to this component and assert that the edit button is rendered in the other test case we pass a nonadmin user and assert that the edit button is not in the Dom now in this test case again you cannot use the get by roll method because get by roll will throw an error if the element you're looking for doesn't exist in the Dom so in that test case you have to use a different method called query by row so you you look for a button using this method and then as part of writing your assertion you have to use the not property to make sure that that element is not in the document okay so spend 10 to 15 minutes on this and then come back and see my solution all right so we go to our test folder inside the components folder we add a new file called user account. test. TSX first we import screen and render from react testing Library good then we create a test Suite called user account now I'm going to go faster because I'm assuming you have done your exercise okay now here's our first test case it should render user name here first we create a user object we annotate it with its type now here we have two user types types one is defined in all zero the other is defined in the end of this module in this project we're going to pick this one now let's create a user object we set the ID and name to some arbitrary values next we render the user account component and give it this user object now our assertion so here we call screen. get by 10 next and pass user.name now this returns an element but we don't need to store it in a constant because we're going to use it only once so we can pass it directly to the expect function and assert that this element is in the document now look we have one passing test great now once again to verify that we're testing the correct Behavior we go to our production code and comment out the line that that should make that test pass so now our test should fail there you go we're testing the correct Behavior now going forward I'm not going to repeat this over and over because that's repetitive but I want you to practice this as part of writing your tests okay so let's bring this back we are done with our first test case now let's duplicate this and write the test for the edit button so here we say it should render edit button if user is admin here we set is admin to true now our assertion is going to be different so here we call screen. get by roll we look for a button we store it in a constant because we're going to write two assertions against this object first we expect our button to be in the document and then we assert that it has the right write label so to have text content and again here we use a regular expression all right good take a look two passing tests lovely now the final test case so let's duplicate this test first we change the test name to should not render edit button if user is not admin we can set this to false or remove this property now in this test we cannot use get by roll because this will throw an error because we're not going to have a button in the Dom so here we call query by roll we get the button and then expect this button not to be in the document okay let's remove this other assertion good now take a look we have three passing tests well hello msh here thank you for watching my react testing tutorial I wanted to let you know that this tutorial is the first hour of my complete react testing course so after you finish this tutorial if you want to learn more I highly recommend you to enroll in the full course because it's much faster and easier to learn react testing than jumping over a bunch of disconnected tutorials on YouTube everything you need to know is jampacked in a perfectly structured 7hour course will cover more advanced topics like marking apis testing forms testing State Management authentication and routing now just like my other courses this course comes with a 30day moneyb guarantee and a certificate of completion if you're interested click the link below this video to enroll in the course all right now let's look at an example involving lists in our components folder we have a component called user list this component takes a prop called users which is an array of users if the array is empty it renders no users available otherwise it renders a list of hyperlinks one for each user okay so let's test this we go back to our test folder in the components folder we add a new file called user list. test. TSX let's do the ceremony we create a test Suite called user list and here's our first test casee it should render no users when the users array is empty and of course we can word it differently so here we call render and give it user list with an empty array okay now to write our assertion look this message is rendered inside a paragraph and paragraphs don't have a rooll by default so once again we have to use the get by text method so here we call screen that get by text now we don't want to look for the exact message like no users is available because this makes our test fragile if one of the words here changes our test will break so we use a regular expression to look for the presence of certain keywords I think the chances of no users keyword changing in the future is probably minimal we not sure but I think this makes our assertion a little bit more General and our test will be a little bit more robust okay so we find this element and expect it to be in the document and by the way look when you want to find a method you don't have to type the whole method name that's very time consuming instead we can use abbreviations like to be in the document okay so that was our first test now take a look user list we have one passing test grade now our second test this test is more interesting so I'm going to duplicate this test and here we change the test name to should render a list of users now in this test first we create an array of users so we annotate this with user array and again make sure to pick the type in the entities module okay now let's initialize this array with two objects we set the idea name msh and one more let's call this user John so we passed the users array here now how can we verify that we have the right hyperlink for each user well here we can iterate over our array of users and for each user we can look for a link with the user's name and then we can verify that that link has the right HF attribute here's how we're going to do it so here we call users. for each we iterate over this array for each user we find a link with the user's name so we call screen. get by roll we look for a link now all these query methods have a second argument which is optional and this is the options object you can find the details in the documentation so take a look here's get by roll now this is the options object here we have a bunch of properties like name for using a text match we have selected for applying a filter and picking elements that are selected we also have checked pressed and a bunch of other properties I'm not familiar with all of them but you will learn about them depending on the types of test you write okay so here we can pass the options object and apply a filter we only want to find a link with this name user.name now this returns a link first we check if link is in the document and then we check that it has the right href attribute so we expect link now here here is another matcher to have attribute we look for hre and we want this to be like slash users well let's look at our production code here's what we expect SL users user. ID now I need to clarify something here in this case technically I cheated we shouldn't write our tests based on our production code because our production code might have a bug if we write our assertions based on what we have in the production code we'll end up with far false positives our tests will pass but our application will have a book so ideally we should write our tests based on the requirements in other words we should treat each component like a black box we shouldn't care what is inside we shouldn't care about the implementation we should test what it's supposed to do okay now back to our test so here we want to look for an HF like/ users slash now we want to add the ID dynamically so let's replace this string literal with a template literal and here we can insert user. ID take a look our test are passing great now I want to verify that we're testing the correct Behavior so for the last time let's comment out this line now our test fails great all right here's another great exercise for you in the components folder we have we have this component called product image gallery this component receives a list of image URLs as a string array now if the array is empty our component renders nothing otherwise it renders a list of images so here we need two test cases in the first test case we should render this component with an empty array and then assert that the Dom is empty now we haven't done this so far so I want you to do a bit of research and solve this problem on your own it's not complicated it just search for react testing Library assert that the Dom is empty now in the second test case we should render this component with a list of URLs and then assert that we have a list of images with the right Source attribute rendered in the do spend 10 minutes on this then come back and see my solution all right to save your time I created this test file with the basic setup before recording this video so here's our first test case our component should render nothing if given an empty array so here we call render and give it product image gallery here we set image URLs to an empty array now to assert that the Dom is empty we get the object that is returned from this function we can call it result now look result has a bunch of properties one of them is container this is the container for component so here we can destructure this object and grab the container then we pass it to the expect function and here we call to be empty Dom element as simple as that now take a look our test is passing great now let's work on the second test case it should render a list of images now in this test first we deare an AR array of URLs let's call it image URLs we set it to two elements URL 1 and two then we render product image gallery here we set image URLs to image URLs good now in this test unlike the previous lesson we cannot iterate over this array and for each element assert that we have an element with this URL because in the previous lesson we were applying a filter by name but here we cannot filter Elements by their Source attribute so here we have to take a different approach first we call screen. get all by row so all query methods that you have seen before they have a variation for selecting multiple elements so we have get by role we also have get all by ro similarly we have get by text we have get all by text and so on so let's call get all by roll for selecting multiple images the role we should pass is IMG with this we can get all the images in the Dom first we should assert that we have two images so we expect images to have length two then for each element in this array we assert that we have an image with the right Source attribute for example we can say expect images of zero to have attribute source and here we should pass image URLs of zero and of course we have to repeat this for the second element but that looks a little bit ugly so here we can iterate over image URLs using for each we pass an arrow function here with two parameters URL and index Now we move this assertion up here and we check that the element at this index have this attribute that is the URL that we get in this function now take a look our tests are passing all right now let's see how we can test user interactions here we have a component called terms and conditions a very typical implementation where we have our terms and conditions followed by a checkbox for the user to accept the terms and a button that is only enabled if the checkbox is checked now before we write tests for this component let's see it in action so let's go to this file called playground page it's inside the pages folder now here we're rendering the onboarding component we don't need it for now we'll come back to it in the future so instead let's render terms and conditions now back to our website let's go to the playground page here's our component now the button should be initially disabled but we don't see it visually because I forgot to apply a style here so to fix this let's go to index.css here's our button class let's add another button class with a disabled selector here we set the background to CCC now look our button is initially disabled but if if we check the check box it becomes enabled this is the behavior we're going to test in this lesson so back to our project let's go to the tests folder here we add a new file call terms and conditions. test. TSX we do the setup first then we create a test Suite terms and conditions now in our first test we want to make sure that that our component renders correctly so nothing new so far we just want to test the rendering of this component so here we can say it should render with correct text and initial state so we call render and past terms and conditions now here we have some basic text we don't want to look for the presence of this text because this can easily change in the future the only thing we want to look for in terms of text next is our heading so back to our test here we call screen. get by roll look what I'm typing gbr that is short for get by roll okay so we find a heading we store it in this object first we check that this heading is in the document so to be in the document and then we check that it has the right content to have text content now in this case we can pass a string we don't have to use a regular expression because the chances of this heading changing in the future is really minimal okay so that was our text now what about the initial State well we need to verify that we have an unchecked check boox in the dot so we call screen get by roll check box we store it in this object now just like before before we expect checkbox to be in the document and it should also be unchecked how do we do that well we have a matcher here called to be checked okay now we don't have a match called to be unchecked so to verify that our checkbox is unchecked here we use the not property okay now one question you might have here is isn't that better to split these assertions into two tests one testing the heading the other testing the checkbox we can certainly do that but in this case I don't find any value in doing so because look we have to repeat this test case two more times and in each test case we have to render the component it's a little bit repetitive so I prefer to have all these assertions regarding rendering in this test case but don't take it as a hard and fast rule every problem every component every test case is different so we check the check box and finally we verify that we have a disabled button so we call screen get by roll button now if you have multiple buttons here we can apply a filter and look for the button that has what was the label that is submit okay so here we can pass a regular expression to filter our buttons in this case we don't need that so let's simplify our test so we get our button first we check that the button is in the Dom or in the document then we check that our button has the right label to have text content submit and finally we assert that our button is disabled so expect button to be disabled now it is possible that in the future F this label gets changed to something else like continue so in this case I prefer to remove this assertion what we want to focus on is the behavior or the functionality of this component that the button is only enabled when the checkbox is checked testing this behavior is more important and more valuable than testing the content on our web pages okay so that was our first test now look our test is passing great so let's see how we can test user interactions so let's create a second test case and say should enable the button when the checkbox is checked now once again we render our component now to simulate user interactions we have to use a different Library called user event back to the documentation of testing library look here we have this section called user interactions we have this companion Library called user event we have to install this separately to simulate user events just note that in react testing Library we also have fire event a lot of people use this but it's not the best way to simulate user events because fire event as explained here is a lightweight wrapper around the browser's lowlevel dispatch event API so it doesn't simulate a real work scenario and that is why we have the the user event Library the way this Library dispatches events is similar to how users use our application okay now to install this we have to install testing Library sluser event as a development dependency so let's copy this line and paste it in the terminal good back to our test so first we render our component then we look up our checkbox so screen. get by roll checkbox just like before we store it here now to click this checkbox first we call user event this object is defined in testing Library SL user event so if your editor doesn't automatically import this make sure to import it like this on the top okay back to our test here we call user event. setup this returns an object we can call it user then we call user. click checkbox now look at the return type of this method it returns a promise so here we have to await this and make our test function async finally we make an assertion so we call screen get by roll we get our button and expect this button to be enabled now pay attention to how I've formatted this code so here we have the arrange part then we separate it with the line break from the ACT part and finally we have the assert part we don't need to add the comments just using a vertical line bre is enough to give other people how we have structured this test now back in vest UI both our tests are passing great now do we need another test case to assert that our button is disabled if the checkbox is unchecked I find it redundant because our first test case verifies that behavior there is no need to write a separate test case and click the checkbox twice to see if the button is disabled all right here's another fantastic exercise for you to practice unit testing look at this component expandable text our component receives a prop which is a text of type string that if the text is shorter than 250 five characters it gets rendered otherwise it gets truncated with a dot dot dot at the end and here we have a button for expanding or collapsing the text now before testing this let's see it in action so we go to our playground and render our expandable text component now let's set the text to a short text all right here's what we get the full text is rendered but if you pass a long string here which we can generate by typing lurm followed by a number a big number like 100 and tap that's a long lurm if some text now we can grab this and paste it here look what happens so our text is truncated and here we have the show more button ignore the styling I forgot to apply class we can fix it by applying the BTN class to our button so here we set class to well class name to BTN all right that's better now if we click this we see the full text and now we have show less this is a great exercise for you to practice what you have learned so far so spend 15 to 20 minutes on this and then come back and see my solution all right just like before we start with the rendering tests and then we'll move on to user interactions so what aspects do we want to test here for rendering we want to make sure that if the text is is short the full text is rendered otherwise our text is truncated these are the two aspects we need to test so here's our first test case should render the full text if less than 255 characters so here we call render and pass expandable text we set the text prop to some short text now to look this up in the Dom we use screen do get by text now let me show you a shortcut earlier in the course we installed an extension for react testing library in case you didn't do it it's right here testing Library Snippets from Dean software now with this we can generate this statement by typing QT that is query by text if we press enter now we have all query methods for for looking up an element by text so we have get by text get all by text query by text and so on now similarly we have query by role so QR but in this case we're going to go with QT okay so we're going to look up an element by this text now we don't want to repeat this here so let's put it in a constant short text and now we can reuse it in multiple places text and and text now we expect this element to be in the document another shortcut just type T bind that gives us to be in the document okay let's take a look all right we have one passing test great now let's write another test case for a long text so to save time I'm going to duplicate this test now let's change the test name should truncate text if longer than 255 characters now to generate a long text we can grab a character like a and then repeat it let's say 256 times now in this test we have to look for the truncated text so let's declare a constant called truncated text we grab our text apply a substring and grab the first 255 characters and then we append dot dot dot at the end that is what we expect to have in the Dom so let's pass it to get by text take a look our test is passing great now in this scenario we also want to look for the presence of the show more button so to find our button we type QR get by roll and pass button restore it here first we expect the button to be in the document and then we verify that it has the right label so to have text content and here we use a regular expression and look for more now earlier I told you that get by roll throws an error if there is no element matching the criteria so technically speaking we don't even need to check if the button is in the document because if it doesn't exist this test is going to fail on this line anyway so in this case we can safely remove this line but if we didn't have another assertion after our test would look weird it would look unfinished so for clarity if we don't have other assertions I would prefer to check if the element is in the document okay we don't need it for now now let's take a look our test is passing great so these are the rendering tests now let's test the user interactions so again to save time I'm going to duplicate this test because we're dealing with a long text now there are two places where we are generating long text let's move these outside of our test cases into a single place so we can go to our test Suite first of all we can declare a constant called limit we set it to 255 so if the requirements change in the future there is a single place in our tests we need to update now for generating a long text we can grab a and repeat it up to limit plus one now for generating the truncated text we declare a constant and here we get our long text and grab the first 255 characters in this case limit okay now we can simplify our tests a little bit so we we don't need to generate a long text here now we need to replace text with long text and we don't need to compute truned text either okay so always pay attention to these little details because they will always pay off in the long run okay now in our last test case well here we need to change the title to should expand text when show more button is clicked again we don't need to generate a long text here and similarly for the truncated text so we find our button then we need to click it so here we call user event do setup we get a user object and then we call user. click button I told you this returns a promise so we need to await it and make our test function async all right so this is the ACT part now we need to separate it from the assertion part so in this case we expect the full text to be in the document so we expect query by text and here we look for our long text to be in the document okay also the label of our button should be changed to show less now as I've said before there are some folks who are strict about a single assertion in the test but this is impractical call because imagine if we wanted to move this assertion into a separate test we would have to repeat all this logic in that test sure we can create another test suite and use before each but all that ceremony is unnecessary these two assertions are highly related they're logically part of a particular state of our component that is why I prefer to put them in the same test okay let's see if our test passes all right looks like one of our tests failed I made a mistake so what's happening here this this is the test for truncating text the aror is saying unable to find an element with the text whatever okay so let's take a look so in this test we are looking for the truncated text so the test is fine I probably made a mistake up here yes I forgot to add dot dot dot at the end sorry about that all right now all tests are passing great there's one more test we need so we have a test test for expanding the text now we need a test for collapsing the text so let's duplicate this test first we should change the test name to should collapse text when shows button is clicked now in this test in the arrange part first we have to click the show more button so the text is expanded so I'm going to remove this line brick this is our arrange part we click the button to expand the text now in the ACT part we click the button again and then assert that the long text is no longer in the document so we should look for truncated text and the show more button now take a look our tests are passing but I don't like the way I've written this test let me show you a better way first we're going to rename this button to show more button and for clarity here we can apply a filter we can set the name to more now it's clear that on this step we're clicking the show more button now in the ACT part we can call get by row to get a button and here we apply a filter as well this time we are looking for the shows button so we store it in a constant show less button and at this step we are clicking the show lless button even though it's technically the same button now our test code better aligns with the test description this is just a personal preference you don't have to do this now let's see if our tests are still passing there you go beautiful we're done with this exercise so let's move on to the next lesson okay let me show you a great technique for simplifying our tests let's take a look at the tests we wrote for the terms and conditions component now if you have paid close attention you have probably noticed that there are a few places where we are looking up our elements so here we are looking up our check boox and button and similarly in this other test we are looking up these elements this is duplication so let me show you a better way to write these tests back to our test Suite here we Define a helper function for rendering our component and returning the common elements we want to query so we can use the arrow function syntax or function declaration syntax it doesn't matter I'm going to go with the arrow function syntax so we declare a constant called render component we set it to an arrow function now in this function we render our component then we return an object and in this object we add the elements we want to query so look in this test we need the heading the checkbox and the button so here we add three properties heading and we set it to screen. get by roll heading similarly we add our checkbox let's grab the code from here and finally we add our button change it to button good now in this test instead of calling the render function from react testing Library we use our own render function render component this returns an object so we destructure it and grab the elements we need heading checkbox and button now we can remove these lines here's one here's another one and one more now earlier I told you that when we use the get by ro or any other variations of get by query method we don't need to check if the element is in the document because if not this line this statement is going to throw an arrrow so in this test we can safely remove this line and this line and this line now these three assertions are logically related so I put them next to each other because all of them are about checking that our component renders correctly okay okay now look our test is a lot cleaner it's easier to maintain and understand now similarly in this other test we call render component now here we only need the checkbox and the button so we can simplify our test and here we simply pass button to the expect function that's a lot better well hello msh here thank you for watching my react testing tutorial I wanted to let you know that this tutorial is the first hour of my complete react testing course so after you finish this tutorial if you want to learn more I highly recommend you to enroll in the full course because it's much faster and easier to learn react testing than jumping over a bunch of disconnected tutorials on YouTube everything you need to know is jampacked in a perfectly structured 7hour course would cover more advanced topics like marking apis testing forms testing State Management authentication and routing now just like my other courses this course comes with a 30day moneyb guarantee and a certificate of completion if you're interested click the link below this video to enroll in the course