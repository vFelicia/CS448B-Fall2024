in this video you're going to learn everything you need to know about exception handling in java so by the end of this video you'll be able to write java code with confidence hi i'm adani and i've taught millions of people how to code through this channel and my online school codewoodmash.com this video is part of my ultimate java mastery course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started let's start this section by quick overview of exceptions first of all i'm going to add a package in this project i'm going to write all the code for this section in this package so let's add a new package called exceptions as you can see i've created packages for the other sections of this course you can find all these packages and all these files in the zip file that i gave you at the beginning of the course now in the exceptions package i'm going to add a new class called exceptions demo this is where i'm going to demonstrate concepts here i'm going to add a public static void method called show i made it static so we can call it easily from the main method without having to create an object okay now let's go to the main method and call exceptions demo dot show now back to the demo class i'm going to create another static method public static void say hello we give it a parameter of type string called name and here we want to print name in uppercase pretty straightforward now in the show method i'm going to call the say hello method and pass null which represents the absence of a value now when i run this program our program is going to crash let me show you so our program crashed without an exception or an exceptional event and the type of this exception is null pointer exception this is the root cause of many problems in java programs now this null.exception is a class that is declared in this package java.lang so an exception is an object that contains information about an error in this case this object is an instance of the null pointerexception class now we have several exception classes in java and you'll learn about them as we go through the section now let's see where this exception occurs in our program we got this exception in the say hello method on line 9 of this file if we click we can go to the offending line so this happened when we tried to call the two uppercase method or no that is why we got a null pointer exception now how did we get here we got here from the show method on this line okay but how did we get to the show method we got here from the main method so this information that we have here is called the stack trace it shows the methods that have been called in the reverse order and this is very useful when troubleshooting problems we can see exactly how we got to the offending code now back to our say hello method when an exception occurs in a method we say that method through an exception just like how a person can throw a ball a method can throw an exception now when this happens the java runtime looks for a block of code in that method for handling that exception we refer to that as an exception handler in this implementation we don't have any exception handling code i will show you how to add that later so the java runtime looks for an exception handler in this method if it doesn't find it it goes to the previous method that is the show method here again we don't have any exception handling code here so the java runtime goes back to the main method hoping to find an exception handler we don't have one here so that is why the java runtime terminates our program and displays the exception now as a good java developer you should prevent such exceptions from happening or anticipate and handle them properly and that's what you're going to learn in this section in the next video we're going to talk about the different types of exceptions in java we have three types of exceptions checked exceptions unchecked exceptions also called runtime exceptions and errors a lot of people new to java find this confusing so let me make it super simple for you check the exceptions are exceptions that we developers should anticipate and handle properly for example let's say we want to read data from a file what if the file doesn't exist maybe it got deleted just before we tried to open it for reading good developers always anticipate and handle these edge cases so instead of letting the runtime terminate our program we would better display a friendly message to the user saying hey that file doesn't exist now the good news is that the java compiler enforces us to handle these errors that is why they're called checked exceptions because they get checked at compile time let me show you let's create a new file reader for reading data from a file so reader equals new file reader let's say file.txt now look at this read underline the java compiler knows that the constructor of the file reader will throw an exception if the file doesn't exist so it's telling us hey you haven't handled this exception file not found exception this is an example of a checked exception so checked exceptions are exceptions that we should anticipate and recover from and that is why they're called checked exceptions because the java compiler checks them at compile time now the second type of exception is called unchecked exception or runtime exception as the name implies these exceptions are not checked by the compiler at compile time they occur because of programming errors node pointer exemption is an example of a runtime exception in the last video we shouldn't have passed null to the say hello method this is a programming error so unlike checked exceptions we don't want to anticipate and recover by displaying a friendly message like hey we made a mistake and try to use an object reference with the null value doesn't make sense instead we should prevent exceptions like this from happening in the first place how can we do that by good coding practices and testing a lot of testing preferably automated testing that's a topic for an entirely different course now other examples of runtime exceptions are arithmetic exception this gets thrown if we try to divide a value by zero we also have illegal argument exception for indicating that the argument we passed to a method was not accepted again this is a programming mistake not a kind of error that we should anticipate and validate another runtime exception you may see is the index out of bounds exception which occurs if we try to access an element in an array or a string or a list using an invalid index for example we have five elements in an array but we try to access the tenth element another popular runtime exception is illegal set exception which gets thrown if we try to call a method but the underlying object is not in the right state so these are runtime exceptions the third type of exception we have in java is an error which indicates an error external to our application examples are stack overflow error or out of memory error so if the java virtual machine runs out of memory there's nothing we can do about it so just like runtime exceptions we should let the application crash rather than display a friendly message to the user we should try to identify the source of these errors these errors can happen because of programming errors like an infinite recursion or for reasons outside of our application like a problem in the java virtual machine itself next we're going to look at the hierarchy of exception classes in java now let's look at the classes that represent different types of exceptions at the top of the exceptions hierarchy we have the throwable class which defines the common characteristics for all exceptions and errors like an error message and the stack trace so every kind of exception or error has an error message and a stack trace below this class we have two classes exception and error the error class and all its subtypes represent errors that are external to our application like out of memory error the exception class is the parent for all checked and unchecked exceptions below this class we have the runtime exception class which represents runtime or unchecked exceptions so if an exception class derives from the runtime exception it's considered an unchecked exception otherwise it's a checked exception i know this is a bit weird because we might think that any classes that derive from the exception class is a checked exception so runtime exception should also be a checked exception but that's not how it works why honestly i have no clue you have to ask the developers of java so let's quickly explore this hierarchy in java documentation so we search for java null pointer exception here's a documentation on oracle.com all right look at the exception hierarchy so here we have the putter exception this class derives from the runtime exception which derives from the exception class which in turn derives from the throwable and as you can see the object class is the parent of all classes in java now if you're curious what other runtime exceptions we have you can go here and under direct known subclasses you can see all types of runtime exceptions now you don't really need to learn about each of these individually you will get to know them as you build java applications some of them may never occur to you so don't worry about learning all types of exceptions in java next i'm going to show you how to handle exceptions now let's see how we can cache exceptions so let's create a file reader object reader we set it to a new file reader and here we type file.txt the name doesn't matter now right after this line we print a message like file open now we have a compilation error because we haven't handled the file not found exception to do this we should wrap this code inside a try block so we type try followed by curly braces to indicate a block of code then we move these lines inside this try block now right after the try block we type the catch clause and here in parenthesis we specify the type of exception we want to catch in this case file not found exception then we give it a name by convention we call this object x as in short for exception so this x object is an instance of the file not found exception it's an object that contains information about this exception so here we add another block and in this block we print a friendly message to the user something like file does not exist now let's run the program our program didn't crash this is the proper way to handle checked exceptions now we can also get the message from this exception object so we type x dot get message this returns a string so we can print it on the terminal file.txt no such file or directory this error message is defined in the file not found exception class okay now what happened to this statement over here we tried to print file open but we are not seeing that message here's the reason when the line throws an exception the control moves to the catch block for that exception so the code that we have after the offending line will not be executed however if i take this line and put it after our try catch block it will get executed take a look so now we have file open so this is how we can catch exceptions in java now let me show you a trick i'm going to take this line out of our try block put it over here and then delete the rest of this code so let's say you're creating a file reader object and the compiler is complaining that we haven't handled this checked exception now we don't have to manually type a try catch block we can put the carrot over here press alt on enter and select surround with try catch isn't that beautiful so intellij automatically created this try catch block for us now here we're calling the print stack trace method of this exception object this will show us something like what you saw before so we got an exception of type file not found exception here is the error associated with this exception now look at the stack trace this exception was thrown from the file input stream class this is a part of our project this is part of the standard java library so in our show method when we try to create a new file reader the constructor of the file reader was called and then internally this class works with another class called file input stream here we have a few method calls and this is where the exception was thrown so sometimes you see a long stack trace because of the method calls in the java standard library or other libraries that you use next we're going to talk about catching multiple types of exceptions sometimes we need to catch multiple types of exceptions for example after reading a file let's call reader.read this reads one character and returns its numeric value so let's store it in a variable called value here we have another compilation error because we haven't handled the i o exception so this read method may throw an i o exception if it cannot read data from this file to solve this problem we need to type another catch clause here so catch like here we want to catch an io exception we give it a name and in this block we can print a message like could not read data the exception is gone now we have multiple catch blocks and each cache block targets a specific type of exception so only one of these will be executed in this case we try to open a file that doesn't exist so this line will throw a file not found exception and this catch block will catch that exception now the code inside this catch block will get executed and after that the control will move over here so the second catch block will get ignored okay so we have multiple catch blocks and each catch block targets a specific type of exception now does the order of these cache blocks matter sometimes it does so if i move this catch block over here you see a compilation error the java compiler is saying that we have already caught the find not found exception what does this mean well let's look at the documentation for the find not found exception class so we type java file not found exception here it is okay so this class extends the i o exception class and that means if we have a catch clause for an i o exception we don't need this find not found exception this is the polymorphism principle of objectoriented programming we talked about this in the second part of this course let me show you if i have a variable of type i o exception let's call it x i can set this variable to a new instance of our exception or any classes that extend the io exception class so we can set this to a new file not found exception this is polymorphism an object may take different forms so if you have a catch clause to catch an i o exception this catch clause can catch an i o exception or any of its derivatives any classes that extend the i o exception class okay now sometimes we want to treat these exceptions the same way for example here we can display a generic error message but other times we want to handle them differently if that is the case then we need to bring back this catch clause and put it before the first catch clause so now if we get a find not found exception we can print a message like file does not exist so we are giving the user a more specific error message okay now as another example let's create a new simple date format object and call the parse method now here we have another compilation error because this parse method may throw an exception of type parse exception now we can put the carrot over here press alt on enter and have intellij add a catch clause for us there you go so it's right here now we have three catch clauses let's say we want to treat all of these the same way so first we can get rid of the file not found exception now we have two catch clauses we can combine this using a vertical bar so right after i o exception we type a vertical bar then we type parse exception and with this we don't need the second catch clause so this block can catch exceptions of type i o exception or parse exception so these are different ways to catch multiple exceptions the approach you take really depends on your application and its requirements next we're going to talk about the final block let's imagine this file exists so we successfully open it for reading but something goes wrong when we try to read data from this file this could happen because of a hardware problem now we have a problem in this code the problem is that we have opened this file for reading but nowhere we have closed it file handles are operating system resources so whenever we get them we shall always release them otherwise other processes may not be able to access these resources so somewhere in this code we should write reader dot close now there is a problem with this implementation can you tell the problem is that if this line throws an exception the runtime will pass the control to this catch block so this line will never get executed now what if we put this line after our try catch block now the reader variable is not recognized because we have declared it inside this try block so it's only accessible in this block but let's not worry about it for a second the problem with this implementation is that sometime in the future another developer might come here and write some extra code and this code may throw an exception again our reader is not going to get closed the proper way to handle this kind of scenarios is to use the final block so right after the catch block we type finally now in this block we can release external resources like file handles database connections network connections and so on so here we should type reader dot close but once again reader is not recognized because it's only accessible in the try block to solve this problem we need to declare this before our try block so we type file reader reader and then set it over here and by the way we cannot use var over here because we can use var only when we set this to a new instance of a class so the compiler knows that this object is an instance of the file reader class in this case we're not initializing this variable so the compiler doesn't know what is the type of this variable okay so let's type file reader now we have a compilation error variable reader might not have been initialized because in java before we can access an object we should always initialize it so if this line doesn't get executed if it throws an exception we'll try to use an uninitialized object to solve this problem we need to explicitly set this to null the compilation error is gone now we have a different kind of error we'll talk about that in a second but first let's add an if statement we want to call the close method only if the reader is not null so if reader is not null then close it but what is this compilation error on handle exception ioexception so the close method may also throw an i o exception to solve this problem we need to wrap this inside the try catch block so we put the carrot over here press alt enter and then surround with try catch so here's the final result now this code looks really ugly i have to admit that we have a much better exception handling structure in csharp now that aside what i want you to take away here is that this finite block will always get executed whether we have an exception or not if we don't have an exception all the code inside the try block will get executed and then the runtime will pass control to the final block if one of these lines throws an exception one of our catch blocks will get executed and then the final block will get executed so the final block will always get executed no matter what now this implementation is really ugly in the next video i'm going to show you a better way to release external resources thank you so much for watching this video as i said this video is part of my ultimate java mastery course that teaches you everything you need to know about java from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day