in this video you're going to learn everything you need to know about java interfaces so by the end of this video you'll be able to write java code with confidence hi i'm mash hamadani and i've taught millions of people how to code through this channel and my online school codewoodmash.com this video is part of my ultimate java mastery course so once you finish this video if you want to learn more you may want to look at the complete course now let's jump in and get started let's start this section by defining functional interfaces a functional interface is an interface with only a single abstract method so earlier we talked about the comparable interface this interface has a single abstract method called compare2 so this is a functional interface we also talked about the comparator interface that is a functional interface as well now in this video i'm going to create a functional interface from scratch we're going to use this functional interface throughout this section so in this package lambdas i'm going to add a new class let's call this printer and change the kind to interface so this is the interface of a printer in one implementation we may want to print on the terminal in another implementation we may want to talk to an actual printer so we could have different implementations of this interface now what operations do we need here we need a single method for printing a message so void print message now we have an interface with a single abstract method so this is a functional interface now in the second part of this series i told you that in the recent years java introduced the concept of default methods in interfaces these default methods can have implementation so we can have a default method like this default void print twice which takes a message and prints it twice so we can have code we can have implementation in an interface i told you that in my opinion this is a bad approach that the java team has taken because interfaces should not have implementation they should only be used as contracts but that aside what i want to point out here is that this interface has two methods one of them is a default method with implementation the other is an abstract method this interface is still a functional interface because it has a single abstract method so it doesn't matter if we have many default or even static methods in our interfaces as long as we have a single abstract method we refer to that interface as a functional interface now let me delete this ugly default method all right so let's go ahead and implement this interface in a class i'm going to add a new class called console printer in this implementation we're going to print on the console or terminal so let's have this class implement the printer interface here we're going to add a print statement and print this message pretty straightforward right now back to our demo class here i'm going to create a static method public static i'm using static so i can easily call it from this other static method it doesn't have to be static so public static void grid this method needs a printer so here we're going to talk to the printer interface we don't care about the implementation we are programming to an interface okay so printer then we call printer dot print and here we can say hello world now in our show method i'm going to call the greet method here we need to pass an object that implements the printer interface so we can use our console printer object now when we run this program we see the hello world message so pretty straightforward now sometimes we don't want to explicitly create a class to implement an interface because this requires writing a bit of code sometimes we may not want to reuse this class in the next video i'm going to show you how to use anonymous inner classes for this purpose so in the last video we passed a new instance of our console printer class to agree method now as i told you sometimes we don't want to explicitly create a class to implement an interface perhaps we want to implement an interface only once and use it for a single purpose we don't want to reuse that class so that's where we use anonymous inner classes so instead of creating a new instance of the console printer class here we can type new printer so we type the name of the interface and press enter what we have here is called an anonymous inner class it's anonymous because this class doesn't have a name it's just an implementation and we call it an inner class because we're using this inside a method okay so in this class we're implementing the print method here we can use a print statement to print this message now when we run this program we get the exact same result so this is how we can use an anonymous inner class with anonymous inner classes we can achieve the same result by writing less code but java 8 introduced a better and more concise way to achieve the same result that's called a lambda expression and we're going to look at that next so our greet method talks to the printer interface and this is a functional interface because it has a single abstract method now wouldn't it be nice if we could implement this method in a standalone function like a function that exists on its own without belonging to a class that is what lambda expressions are for so a lambda expression is like an anonymous function that we can pass around let me show you so i'm going to rewrite this code using a lambda expression first recall the grid method now here we want to pass an implementation of the print method as an anonymous function so this print method has a single parameter of type string let's add that over here this is where we list our parameters so string message after parenthesis we add an arrow this is called the lambda operator and then we add braces to represent the body of this function now what should we do here we should add a print statement and print this message on the console what we have over here is called a lambda expression so if we have a functional interface we can represent this functional interface using a lambda expression that is why these interfaces are called functional because they represent a function so here we have a lambda expression as you can see this code is very clean and concise but we can make it better first of all we can remove the type of this parameter now the java compiler knows that this parameter is a string object because the lambda expression that we pass over here will be checked against the signature of the print method so the java compiler knows that this method has a single parameter and the type of this parameter is string so we don't have to repeat that type over here if i type message dot now we can see all the string methods by the same token if i add another parameter here the java compiler complains because it knows that our print method has a single parameter but here we're passing two parameters okay so for the most part we can exclude the type of parameters and let the java compiler infer them now if we have a single parameter we can also remove this parenthesis that makes our code cleaner and more concise we use parentheses only if we have no parameters or if we have a method with multiple parameters so we separate these parameters using a comma just like how we declare the parameters of a method okay so here we have a single parameter and we don't need parenthesis also if the body of this function has a single line of code we don't need these braces either so i can clean up this code by pressing alt on enter and selecting replace with expression lambda there you go so this download expression looks really clean and concise compare this with an anonymous inner class this is really ugly so let me remove this all right now here we're passing a lambda expression as an argument to a method but we can also store a lambda expression in a variable for example we can declare a variable of type printer and set it to a new console printer so this is the concrete implementation or we can set this to a lambda expression so here we say message goes to print message so lambda expressions are essentially objects but we can use them to represent anonymous functions in the body of this lambda we're using the message parameter that we have declared over here but we can also access the local variables in the enclosing method so i'm going to declare a variable called prefix and set it to hyphen now here we can reference prefix and then append the message so when we run we get hyphen hello world we can also access the static fields and the enclosing class so i'm going to move this from here and declare it as a static field in this class public static string prefix we set it to hyphen now we can access it in our lambda expression so when we run we get the same result as before we can also access the instance fields so i'm going to make this an instance field and also make the show method an instance method so as you can see we can access the prefix field now what about this what do you think this represents here it represents the current instance of the lambda's demo class so if we type dot you can see the prefix field and the show method so this is one of the differences between lambda expressions and anonymous inner classes in lambda expressions this references the enclosing object whereas in anonymous inner classes this references the current instance of the anonymous inner class another difference between these two types is that anonymous inner classes can have state so they can have fields to store some data in lambda expressions we cannot have fields because this lambda expression is just representing an anonymous function so we cannot have instance fields here we cannot have state we can only access the local variables declared in the enclosing object as well as the static and instance fields in the enclosing class sometimes all we do in a lambda expression is passing the parameter or parameters to an existing method for example over here we're simply passing this message to the print line method of this object in these cases it's easier to reference this method directly let me show you so here's the syntax we type the name of the class or the object that contains this method then we type double colons followed by the name of the method without parenthesis because we don't want to call this method we just want to add a reference to it for example if i want to rewrite this lambda expression using a method reference i would type greet now what is the object that contains the print line method it's this object right so we type system.out then we add double colons followed by the name of the method without parenthesis so this is a method reference and this code is identical to what we have over here now with intellij we can always convert these kind of lambda expressions to a method reference very easily so we put the carrot on the body of the lambda press alt enter and then replace lambda with metal reference there you go now with these method references we can reference static or instance methods in the class as well as constructors let me show you a few examples so i'm going to delete these and add a static method in this class public static void print message now the signature of this method matches the print method of our printer interface okay so here we call the grid method we should pass a printer object so here we can use a lambda expression message we take it and pass it to this method right again all we're doing here is passing the parameter to an existing method so we can use a method reference here we type the name of the class that contains this method in this case lam does demo so lambda's demo then double colons followed by the name of the method there you go or you can convert this using intellij now what if this was an instance method let's see how it works so i'm going to create a lambdas demo object demo we set it to a new instance of the lambdas demo class now we want to call the grid method and pass a lambda expression like this message goes to demo dot here we want to call this instance method so print message now to use a method reference we type the name of the object that contains this method demo double colons and print if we use intellij we get the exact same result now what about passing a value to a constructor let's take a look so delete i'm going to add a constructor here in this constructor we want to add a string parameter now let's say we call the greet method and pass a message to the constructor of the lambda's demo class how can we use a method reference here well we type the name of the class that is lambda's demo double colon and here we type new to represent the constructor if we use intellij we get the exact same result so with method references we can write compact and easier to read lambda expressions thank you so much for watching this video as i said this video is part of my ultimate java mastery course that teaches you everything you need to know about java from the basics to more advanced concepts so if you want to learn more i highly encourage you to take a full course it's much faster than jumping from one tutorial to another if you're interested the link is below this video thank you and have a great day you