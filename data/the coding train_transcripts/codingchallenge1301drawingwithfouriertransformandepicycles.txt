00:00 - (bell dings)
00:01 - - Hello, welcome to a coding challenge.
00:03 - I actually just finished
this coding challenge,
00:04 - and I'm coming back to
re-record a little intro to it.
00:07 - And what I made in this
00:08 - coding challenge is a drawing machine.
00:11 - Maybe let's call this a Fourier
transform drawing machine.
00:13 - There's a few more things
we want to do with it.
00:15 - There's going to be some followup videos.
00:16 - But this very, very long
video, if you can stand
00:20 - to watch it, has, as part
of it, at the end, this.
00:25 - This is the end result.
00:26 - I am using an algorithm
called Fourier Transform
00:30 - to take an arbitrary signal,
in this case, a sequence of X's
00:34 - and a sequence of Y's, the
path of the Coding Train logo,
00:38 - thank you to Tom Fevrier.
00:39 - I will link to Tom Fevrier's
Twitter, who provided
00:42 - the path for this
particular logo, to trace
00:48 - the path of the logo through
this sort of sequence
00:51 - of rotating circles, sometimes
referred to as epicycles.
00:55 - Okay, so what's going on here?
00:57 - So, first thing I should
mention is this is
00:59 - a continuation of my coding
challenge Fourier Series.
01:05 - And so, what I did in that
particular coding challenge,
01:08 - which was inspired by a Smarter
Everyday video on the same
01:11 - topic, was create the Fourier
series for a square wave.
01:19 - I don't know why I just had to write that.
01:20 - But in this video, I'm going
to do something different,
01:23 - which is I'm going to use the
Fourier transform algorithm.
01:27 - And these are different concepts.
01:29 - I somewhat conflated these
in my previous video.
01:32 - The idea of the Fourier transform.
01:34 - Now, where I know this
algorithm from, where I learned
01:37 - about this algorithm first in
like, learning about coding
01:40 - and creative coding and new
media and sound and video
01:43 - is with the terminology FFT, and actually,
01:46 - if you go into the p5
sound library, you'll see
01:51 - there is a class or
function called p5.FFT.
01:55 - I don't remember exactly what it's called,
01:56 - but something like that.
01:57 - The F here stands for fast,
Fast Fourier Transform.
02:04 - The algorithm I'm going to implement,
02:05 - by the way, is discrete Fourier transform.
02:09 - Why is this FFT thing,
where is it typically used?
02:13 - Well, it's typically used in,
it's in signal processing,
02:16 - but a familiar place
where you might find that
02:20 - is in audio signal processing.
02:23 - So let's say you have
some arbitrary sound wave
02:26 - that maybe looks like
this, and it has a really
02:29 - high-pitched, awful,
screeching sound in it.
02:32 - How would you filter that out?
02:34 - Well, if you could take
this sound wave pattern
02:38 - and break it into a bunch
of smaller sound waves,
02:44 - a bunch of sound waves that have varying
02:47 - amplitudes and frequencies,
then you could take,
02:52 - you could sort of remove the one that has
02:54 - the high-pitched sound in it and then
02:57 - add them all back together
and get a new sound wave.
02:59 - So the idea of a Fourier
transform, I think I said this
03:03 - in the Fourier Series, but
it's unsmoothie-ing a smoothie.
03:07 - If we could take a smoothie
that's made with blueberry,
03:10 - mango, and strawberries,
and like, separate it out
03:14 - and then put it back together
without the strawberries,
03:16 - this is essentially what
happens in signal processing.
03:19 - But in this video, what I'm going to do is
03:22 - instead of the signal being
an audio, it's going to be
03:25 - a series of X values or
a series of Y values,
03:29 - and eventually, there
actually a way to do that
03:30 - with the X, Y values
together that I will get to.
03:32 - So, I am not going to go
too deep into the math
03:36 - in this particular video.
03:36 - I'm not going to derive the
Fourier Transform algorithm.
03:39 - I'm not going to talk about
Fast Fourier Transform.
03:41 - I'm just going to use a very
crude, discrete Fourier Transform
03:48 - implementation just to
get the thing working.
03:50 - If you want to know more
about the math, though,
03:53 - let me reference a few
really key references.
03:57 - The 3blue1brown video, But
what is the Fourier Transform?
04:02 - will give you an infinitely
better understanding
04:06 - of what the Fourier Transform algorithm is
04:08 - and what it does, and even how
it works, way better than my
04:12 - trying to ramble through
that over on the whiteboard.
04:15 - I would also highly recommend
this GoldPlatedGoof video,
04:19 - Fourier Analysis for the
Rest of Us, which goes
04:22 - through the details of the
math in a much deeper way,
04:26 - and then there's this wonderful
video from Mathologer,
04:31 - Epicycles, complex Fourier
series and Homer Simpson's orbit,
04:34 - which will give you the
full story of everything
04:37 - that I'm trying to do.
04:38 - But hopefully, what's useful
to you that's different
04:40 - in my video than from these
is I'm just going to sit here
04:44 - and attempt to code the thing.
04:46 - And I know that it's going to
work, because I already did it,
04:49 - and here is the result.
04:51 - So enjoy.
04:51 - This is a very long video.
04:53 - I hope that if you watch
it, you get the code,
04:55 - you make your own variation of
it, please share it with me.
04:58 - You can go to thecodingtrain.com,
to the particular
05:00 - coding challenge page, and
then there's instructions
05:02 - on how to submit a user
community variation thingy there.
05:05 - Okay, goodbye, enjoy, or not, or whatever.
05:09 - I am ready to start coding, finally.
05:12 - Now, this is where I left off
before in my Fourier Series
05:17 - coding challenge, and
the difference now is
05:21 - what I want to do is be able
to have an arbitrary signal
05:24 - and then compute what
all of these amplitudes
05:27 - and frequencies and phases should be.
05:28 - So, the way that I'm going to do that is,
05:31 - so let's think about this.
05:32 - This is really a bunch of Y
values that I'm calculating.
05:37 - So let's make an array
called something like Y,
05:44 - and this is going to be the
signal, this is my signal.
05:47 - This could be audio, it
could be Y positions,
05:52 - any arbitrary digital
signal/array of numbers.
05:56 - Then what I want to do is I want to have
05:59 - like, the Fourier transform
of that particular signal.
06:06 - So I want to say, fourierY
= fourierTransform, or maybe
06:12 - like dft, discrete Fourier
Transform, of the Y value.
06:18 - So this is the idea.
06:19 - The first thing that I
need to do is compute
06:23 - the discrete Fourier transform
of an arbitrary signal.
06:25 - Now I need some kind of signal.
06:27 - So I think what I'm going to absurdly do
06:29 - is hardcode the signal.
06:32 - Let's actually make it the square wave,
06:34 - and then we'll know if it kind of worked.
06:35 - So what is the square wave?
06:37 - Square wave would be
something like 100, 100, 100,
06:40 - - 100, -100, -100, and then
like, do that a few times.
06:50 - So this is going to be
my arbitrary signal,
06:54 - which I'm just hardcoding the square wave.
06:55 - And we'll do some interesting
things that we might,
06:58 - maybe I'll try a Perlin noise signal
07:00 - or just a sine wave signal.
07:02 - We'll try different things,
07:03 - random numbers, and see what that does.
07:05 - So then, this actual code here
can largely stay the same,
07:11 - 'cause in theory, the difference is now,
07:14 - instead of following the
specific Fourier Series
07:19 - for the square wave, I just need to take
07:23 - the results of my discrete
Fourier transform.
07:25 - So this would be a loop that's going to
07:28 - go through the length of
that transform, how many
07:32 - different wave patterns are
there that I'm adding together,
07:36 - and then this ultimately, I'm
going to have to figure out.
07:41 - So let's comment this out right now,
07:47 - and there's a little bit
of an issue where I have
07:49 - this X and Y as like,
local variables here.
07:52 - But let's, I think this will be okay.
07:54 - So let's refresh this,
and DFT is not fine.
07:57 - Okay, step one, let's write
07:59 - the discrete Fourier Transform algorithm.
08:03 - So, I'm going to start by
making a function called dft.
08:06 - It's going to have some
array of values, and now,
08:11 - I need to, at the end, I
need to return something.
08:14 - (instructor laughs)
08:15 - The idea is that I will return
08:17 - the discrete Fourier
transform of those values.
08:22 - So, a couple things.
08:23 - One is I highly recommend,
if you want to pause
08:26 - this video right now and
read this particular article
08:30 - on the Algorithm Archive
08:31 - by James Schloss or the
LeIOS YouTube channel.
08:35 - This is a really nice article
about Fourier transforms
08:39 - and the discrete Fourier
Transform algorithm,
08:41 - and this particular algorithm for FFT.
08:44 - But what I'm going to do
is I'm just going to follow
08:46 - exactly what's here on the Wikipedia page.
08:48 - So, my signal is x sub n, lowercase xn.
08:54 - So what I need to do is basically,
08:57 - and the transform is capital X sub k.
09:01 - So I need to write a
function that computes
09:04 - this exact equation and
returns it as an array,
09:08 - and this is exactly what I'm going to do.
09:10 - This is exciting.
09:11 - Now, one thing I should mention is that
09:14 - in order to work with Fourier transforms,
09:17 - I need to understand something
called a complex number.
09:21 - Now, if I recall correctly,
the last time a complex number
09:26 - came up on this YouTube
channel was probably in my
09:28 - Mandelbrot set coding
challenge, where I visualized
09:31 - the famous Mandelbrot fractal,
and I referenced something
09:36 - called an imaginary number,
and I was way too informal
09:40 - and loosey goosey and jokey
09:42 - about how I talked about imaginary numbers
09:44 - being this pretend thing
that doesn't exist,
09:46 - which is absolutely incorrect.
09:49 - The reason why the term imaginary is used
09:53 - is because there is no
real number solution
09:56 - to the square root of negative
one, but the square root
09:59 - of negative one is referred
to in mathematics as i.
10:05 - I is a complex number.
10:07 - A complex number is a
number with both a real, a,
10:10 - plus an imaginary component.
10:13 - So it's two real values, a real value
10:17 - and another real value
kind of multiplied by i,
10:20 - the square root of negative one.
10:22 - So, this is the idea of a
complex number, and by the way,
10:24 - another way for me to
refer to a complex number
10:29 - is by its position on the complex plane.
10:33 - So if this were the real axis,
10:35 - and this were the imaginary
axis, this would be a,
10:38 - and this would be b, and this
is a vector representation,
10:42 - whoa, of this particular complex number.
10:45 - So, why do I bring this up?
10:47 - The reason why I bring this up
is that the Fourier Transform
10:51 - algorithm, even if I start
with an array of real numbers,
10:56 - single numbers, I'm going to
apply the Fourier Transform
10:59 - and get out a complex number.
11:02 - What I'm going to return
from that function
11:04 - is both a's and b's, otherwise
known as the real component,
11:08 - which is often written in code as re,
11:11 - and the imaginary component,
which is often written as im.
11:14 - So this is one bit that I
really need to understand
11:17 - before working with this formula.
11:19 - So now is this moment, this
moment that happens to you
11:22 - in life, where you see
one of these formulas
11:24 - on a Wikipedia page or in a math textbook,
11:27 - and you're a creative coder making some
11:29 - kind of visualization thing,
and you just want to stop.
11:32 - But together, you and me,
we're not going to stop.
11:35 - We're going to figure out
how to translate all this
11:37 - notation and symbols and
stuff into JavaScript code.
11:41 - Now, again, it'll be super
interesting to go down the rabbit
11:43 - hole of deriving all these
formulas and the background
11:45 - for how Fourier transform works,
but I'm not going to do that.
11:48 - If you look in the video description,
11:49 - there are several excellent
videos and resources
11:52 - linked to that will give
you that background.
11:54 - But I do want to mention one
thing, which is quite important,
11:56 - which is that this particular
formula in the top here
12:00 - for the discrete Fourier
transform uses this symbol e,
12:06 - Euler's number, or the
base of natural law.
12:09 - This is a very famous number
in mathematics, much like pi,
12:13 - but there's also a very well known formula
12:16 - called Euler's formula,
which looks like this:
12:20 - e to the i, which, complex
number i, x, equals
12:25 - cosine of x plus i times sine of x.
12:27 - Really interesting,
kind of looks like polar
12:28 - to Cartesian coordinate transformation.
12:30 - All this stuff is interrelated, right?
12:32 - But so, that is where,
if I come back to here,
12:36 - this is where we get the
second line here, using
12:39 - Euler's formula from the
particular formula that's up top.
12:42 - But this is the one that
I want to implement,
12:45 - and I have written the
formula out right over here
12:49 - so we can unpack it a little bit.
12:51 - What are the components
we need to understand?
12:53 - Now, really, if this were a math lesson
12:55 - about Fourier Transform,
we wouldn't be using
12:57 - summation; we would be using integration.
13:00 - But because we're working on a computer,
13:03 - and I need to write a loop,
and I don't have infinity
13:08 - as a tool that I can just use, I need to,
13:10 - instead of doing integration,
do summation, and that's
13:13 - why also this is called
discrete Fourier transform,
13:16 - 'cause I'm doing it over this
sort of like, discrete space.
13:19 - Okay, so this means summation.
13:23 - So this should give you
clue that I can just do
13:25 - like a for loop, going from
zero all the way up to n.
13:29 - And by the way, n is
going to be the length,
13:31 - the number of values I have in my signal,
13:33 - so the length of that original array.
13:37 - Oh, and then the other thing
that's really important
13:39 - is that basically what I
get to do is separate out.
13:44 - This is the real component,
13:47 - and this is the imaginary component.
13:52 - So even though this is all
written as one formula,
13:55 - I'm going to sum up
all the real components
13:58 - and all the imaginary components together.
13:59 - And by the way, as Simon, who
has been watching this live,
14:03 - pointed out to me, there
are only complex numbers.
14:06 - The term imaginary, it's
really too bad that it's called
14:09 - imaginary, 'cause it's very misleading.
14:10 - But a real number is just a complex number
14:12 - with the imaginary component as zero.
14:15 - Okay, so, I should be able
14:18 - to start writing the
code for this now, right?
14:20 - This is my signal.
14:22 - It's a little confusing
that this is called X,
14:24 - 'cause I called it Y, but this
is just the values, the vals.
14:28 - This n is vals.length
in my code, and then, k,
14:34 - we're going to have to work out what k is.
14:36 - I know what cosine is, two
pi, and all these things.
14:39 - So we're going to work out what k is.
14:41 - Oh, boy, I'm so silly.
14:43 - What is k?
14:44 - This should actually, this is, this is,
14:46 - I completely forgot to
write what is quite possibly
14:49 - the most important part of this formula
14:52 - (instructor laughs)
over here,
14:53 - which is capital X, big X, sub k equals.
15:01 - So, this is what I'm trying to calculate.
15:03 - I'm trying to create
an array of k elements.
15:07 - At each element k, I'm going
15:10 - to sum up n from zero to the end.
15:12 - So there's a little bit of
a nested loop going on here.
15:15 - I want to loop through
every k, which is going
15:18 - from zero all the way up
to n, and then also sum up.
15:20 - So k is going to stay constant
within each one of these,
15:23 - and k is actually really the
frequency, we'll see that,
15:26 - the frequency of the particular
wave pattern in that slot.
15:29 - Okay, all right, so let me
write the code for this.
15:31 - The first thing that I want to
do is create an empty array.
15:37 - This is where I'm going to
store all of the results.
15:39 - Then I need to write a loop,
which is let k = 0; k < N; k++,
15:48 - and then I'm going to be
saying fourier[K] = something.
15:53 - So, this, by the way, I mean,
I could call this capital X
15:56 - if I wanted to be, and maybe I will,
15:59 - just to follow this notation exactly.
16:02 - So this is capital X; this is lowercase x.
16:05 - So let's actually, as
silly as this might be,
16:07 - let's change this to x so I can use
16:10 - all the same notation as that formula.
16:12 - So, I'm trying to calculate this.
16:14 - Now, in order to do this, I need to,
16:17 - for each one, go through N.
16:24 - So this is where the nested loop comes in.
16:28 - To calculate each element of capital X[k],
16:35 - I need to sum up n going
from zero to the n, okay?
16:39 - And then, I'm going to start
doing this formula, okay.
16:43 - So, I need to sum up what?
16:45 - I need to sum up both a real component
16:48 - and an imaginary component.
16:50 - So let's make a real component
and an imaginary component.
16:55 - The real component is going
to go up by some amount,
16:59 - and the imaginary component,
ooh, I do not want to ask Siri.
17:02 - Actually, Siri, please, could you help me
17:04 - with this Fourier transform problem?
17:06 - Just write the code for me.
17:07 - So I'm going to sum up the
real and imaginary components,
17:12 - and then, I'm going to make some object,
17:16 - which is basically just,
what's that thing called
17:19 - where, but I'm not going to
worry about it right now,
17:20 - the fancy ES6 way of making
an object, if I'm doing this.
17:25 - So then I'm going to make
an object that has the real
17:28 - and imaginary components,
and I'm going to return it.
17:32 - There we go.
17:33 - So this is the process, whoo.
17:35 - I could use, HollowBrian in the chat
17:36 - is saying use a p vector.
17:37 - I could certainly use a vector object,
17:39 - but I'm going to write it this way.
17:41 - Okay, so here we are, good,
good, good, good, good.
17:43 - That's my, I've got this and this.
17:45 - Now I just need to add
this stuff in there.
17:47 - So let's do the real component first.
17:49 - Now, one thing you might
notice, this appears twice.
17:55 - So if anything ever appears twice,
17:57 - that might give you a hint to
just put that in a variable.
17:59 - So let's do that.
18:00 - So let's say, I don't
know what to call that.
18:05 - I'm going to just call that something.
18:07 - (instructor laughs)
18:10 - Somebody give me an idea what to call it.
18:11 - I'm going to say TWO-PI
times k times n divided by n.
18:19 - All right, so the chat's
telling me to call it angle
18:21 - or some angle name, but
actually, phi is a good one,
18:24 - 'cause it's the value that's
going into cosine and sine,
18:28 - which is like an angle, or a
Greek letter phi is often used.
18:30 - So I'm going to call it phi,
and then I'm going to say,
18:33 - the real component equals,
and I'm looking over there
18:36 - 'cause that's where my formula is written,
18:38 - is going to say x[n] times cosine of phi.
18:46 - Boy, this should look strangely
18:49 - like a lot of code that I write a lot.
18:52 - And then, x[n] times, and
this should say cosine,
18:56 - times sine of phi, but one
thing you'll notice here
19:01 - is that this, there is a minus here.
19:04 - This minus here is not, is
quite an important detail.
19:09 - So, what I'm going to do is
I don't know the best way
19:12 - to handle this, but I could
just say minus equals,
19:15 - but maybe I'll, yeah, let's
just say minus equals.
19:18 - Let's do that, okay.
19:18 - And then, this is called enhanced
19:21 - object literals, thank you.
19:23 - I can just say this.
19:29 - So this will give me
that, and there, okay.
19:33 - So,
(instructor laughs)
19:34 - all of that explanation,
wow, and here we are,
19:37 - discrete Fourier transform.
19:40 - All right, so thank you
to the chat for asking
19:41 - a couple key questions and
for pointing out some errors.
19:44 - For example, I forgot to
actually define what n is,
19:47 - which is x.length.
19:49 - You know, I should
probably get in the habit
19:51 - of using the variable declaration
const when I know it's
19:55 - something that's going to
stay a constant like this,
19:57 - so I will attempt to use that here.
19:59 - These cannot be const, because
I'm adding them up together.
20:02 - Now, another thing that is typically done
20:04 - with discrete Fourier
transform is to take the sum,
20:09 - and then average its contribution over n.
20:11 - So I would also say the
real component equals
20:14 - the real component divided by n.
20:16 - The imaginary component is
20:17 - the imaginary component divided by n.
20:18 - So I'm going to add that in.
20:19 - And then someone asked
me, well, oh, but this is
20:22 - another question that came in, which was
20:24 - the question, oh, there's i here.
20:26 - Why don't I see i in your
formula, in your code?
20:30 - Where is i in your code?
20:32 - And so, i isn't explicitly in here,
20:34 - but what I'm doing, I'm referencing i
20:37 - by separating out the real
and imaginary components.
20:40 - So, the imaginary component
is always paired with i,
20:43 - and the real component
is in the form a + bi.
20:48 - So this is a, that's
b, but I don't actually
20:51 - have to put i in the equation itself.
20:53 - So, let's save this.
20:55 - Let's feel happy that
we completed something.
20:57 - I'm going to refresh, I'm going
to go back to my code page.
21:00 - So let's just see if that
function dft does something,
21:03 - it doesn't actually produce an error.
21:05 - So I have the y array, which
is my hardcoded square wave,
21:09 - and if I call dft on
y, here in the console,
21:14 - we can see, I get, right, I
had 12 values in my signal.
21:18 - I get 12 complex numbers back,
21:21 - each one with a real and
an imaginary component.
21:24 - So this looks good, in the sense
21:26 - that there are numbers here.
21:27 - I don't see an error,
no red, no not a number.
21:30 - So hopefully, we're in the right place.
21:32 - Now, the question is,
what, what, what do I do
21:38 - with these real and imaginary components?
21:41 - How do those things actually
become circular epicycles?
21:46 - For a circular epicycle, what do I need?
21:50 - I need an amplitude, right.
21:55 - That's basically the
radius of that circle.
21:59 - I need a frequency,
which is how many cycles
22:05 - through the circle does it
rotate per unit of time,
22:11 - and then I also need, this
is what's called a phase.
22:14 - And the phase, another way
is think of it as an offset.
22:16 - So where does the cycle begin?
22:19 - Where does that circular
wave pattern begin?
22:22 - That's the phase.
22:23 - So I need these three things.
22:26 - So, somehow, what I need to
be able to do is I need to be
22:31 - able to say right here, well,
the frequency is something,
22:37 - the amplitude is something,
and the phase is something.
22:43 - And the secret to this lies
in the fact that a complex
22:47 - number is like a vector,
and in fact, here we go.
22:52 - The amplitude is the
length of that vector,
22:55 - and the phase, is the
angle of that vector.
22:58 - Well, so that's amplitude and
phase, but what's frequency?
23:01 - Well, guess what?
23:02 - I don't know if there as
a clue to this on that
23:03 - Wikipedia page, but the
frequency is actually just k.
23:12 - Frequency, yeah, discrete
frequency components.
23:16 - So the whole point of doing
this is to take the signal
23:20 - and divide it into a bunch of
discrete frequency components,
23:23 - zero, one, two, three, four, et cetera.
23:25 - So, here we go, frequency is
k, and that's a little bit
23:30 - redundant, but I might do
something with sorting later,
23:33 - so I'm going to need
to keep track of that.
23:34 - Amplitude is the square
root of the real times real
23:38 - plus imaginary times imaginary.
23:40 - This is basically the
magnitude of a vector,
23:43 - the square root of each component squared.
23:45 - This is Pythagorean's theorem at play.
23:48 - And then the phase is that
angle, which I can use the atan2,
23:53 - and the y would be the imaginary?
23:57 - I think it's this.
23:58 - I'm going to just reference
the code that I wrote before.
24:01 - (instructor laughs)
Yes, I got it right.
24:03 - So this would be the phase.
24:05 - So now, I can add frequency,
amplitude, and phase here.
24:11 - And I can refresh this
page, I can say dft(y),
24:17 - and let's take a look at any one of these,
24:19 - and we can see all right,
I've got an amplitude,
24:22 - I've got a frequency, I've got a phase.
24:26 - Whoo!
24:26 - We are ready.
24:28 - We are ready to start actually
24:30 - now putting this into our code.
24:32 - And the good news is, we have the code
24:35 - for drawing these epicycles already.
24:38 - I commented it out.
24:39 - It was right here.
24:41 - So, if, in fact, I have
this fourierY array,
24:47 - I have this code from before that
24:49 - was drawing the results
of those epicycles.
24:54 - So, I can comment this
all back in, but now,
24:58 - it's not a specific Fourier
series for the square wave;
25:01 - it's whatever's come out
of my Fourier transform.
25:04 - And in this case, n is actually,
25:08 - it's confusing that I'm using
n here, but I'm actually
25:14 - going to just call this
frequency, is fourierY.freq,
25:20 - and the radius is
fourierY times amplitude,
25:25 - and now, not times, is the amplitude.
25:27 - So the frequency is the frequency,
25:29 - the radius is the
amplitude, and now I can say
25:33 - multiply time times
frequency plus that phase.
25:38 - So, and I know I could have,
I could get these things
25:44 - out into a variable in like, one line,
25:46 - but I'm just going to
write this in here, phase.
25:52 - So, all the code remains the same.
25:54 - The difference is what I'm going to do.
25:56 - Time is the that's moving forward, right?
26:00 - It's the angle, and if the
frequency is one, it takes
26:06 - one unit of time for it to
rotate a full rotation around.
26:11 - Phase is the offset and
radius is the amplitude.
26:14 - So, one thing that I have to
be very careful about here
26:17 - is that I can't just arbitrarily
have this 0.05 thing here.
26:22 - What I need to do is I need
to have like, the value dt.
26:27 - What is the amount of time I
move each frame of animation?
26:32 - This would be TWO_PI being a full cycle
26:36 - divided by how many
frequency values I have.
26:41 - So now, time goes up by
this, and we should see now,
26:46 - dare I say,
(instructor laughs)
26:50 - nothing?
26:52 - (bell dings)
26:52 - Oops, I have a terrible error here, ah!
26:55 - I forgot to put index i here.
26:57 - I've got to pull out, right,
I'm getting the frequency,
26:59 - amplitude, and phase of each
element of the array fourierY.
27:06 - Whoops, sorry about that.
27:09 - There we go, all right.
27:10 - So this looks kind of
like maybe it's right,
27:13 - but it doesn't look right at all.
27:14 - Like, something's happening
27:15 - that's pretty decent, but it's wrong.
27:17 - So here's the one thing that's
27:19 - a little bit unfortunate.
(instructor laughs)
27:21 - I'm off my 90 degrees
here, I'm pretty sure.
27:24 - So let's just add HALF_PI in
here, because, and there we go.
27:32 - Now,
(instructor laughs)
27:34 - this is actually correct!
27:35 - This is sort of crazy, though,
'cause it's kind of like,
27:37 - is this really, what we're doing?
27:39 - The thing is I have so,
I have so few values.
27:43 - So it would make more sense
for me to actually count,
27:46 - to precompute some kind of
more interesting signal.
27:49 - So, let's forget about hardcoding
the signal for a second,
27:52 - and let's just say I'm going
to have a signal with a hundred
27:56 - values, and let's just make
them all random numbers.
28:03 - This is going to be a
little bit insane, probably,
28:05 - but let's pick a number
between negative 100 and 100.
28:12 - So you can see, look at this.
28:13 - This, there it is!
28:15 - This is the crazy set of epicycles
28:18 - to draw these random numbers!
(instructor shouts)
28:20 - I could also now do Perlin noise instead,
28:26 - and like, just have it increased
by some arbitrary amount.
28:30 - All right, so there we go.
28:31 - I'm kind of doing nonsense here.
28:32 - But the point is, any
arbitrary signal that I have,
28:36 - I can now compute the Fourier.
28:38 - And you can see, by the way,
28:39 - this is it cycling back to the beginning.
28:41 - That's why it almost looks
like this crazy heartbeat,
28:44 - and there's this extra bit here of it,
28:47 - like the first one not rotating at all,
28:49 - just with this offset up,
because the values itself
28:53 - don't perfectly average a round zero.
28:55 - But this is not the point.
28:56 - This is not the point
of what I want to do.
28:58 - The point of what I want to do,
28:59 - and let me just show you to be clear.
29:02 - If I just made this like
i, like a linear function,
29:10 - you can see this, look at this.
29:12 - These are all the epicycles
for basically now,
29:15 - I've got the triangle wave,
'cause it's going down and then
29:18 - back up at the top and down
repeating over and over again.
29:20 - Okay,
(instructor claps and laughs)
29:22 - We are getting somewhere.
29:25 - Okay, deep breath.
29:26 - First thing is, in my excitement
and exuberance over what
29:29 - I've accomplished, I was
calling this a triangle wave.
29:32 - You know, there's kind
of a triangle there.
29:34 - This is a sawtooth wave,
29:35 - which is what I've recreated right here.
29:37 - But, I need to take a breath here
29:39 - and talk about what the
next step is going to be.
29:42 - The idea now is what
I want to do is I want
29:46 - to be able to draw an
arbitrary path, which,
29:50 - in addition to having Y's,
I want to have X's as well.
29:54 - So I need to do the
Fourier transform twice.
29:56 - Now, ultimately, there's
another way of doing this
29:59 - where I do one Fourier transform
on a set of complex numbers
30:03 - where the real and imaginary components
30:04 - are the X's and the Y's,
but I'm going to stick
30:06 - into this sort of like, simple
place that I am right now,
30:10 - and I am going to add two
signals now, an X and a Y.
30:16 - So I need the transform
for both the X and the Y.
30:21 - I'm just going to like,
in a sort of silly way,
30:26 - have the X's and the Y's be the same,
30:32 - and then I'm going to apply the same exact
30:36 - Fourier transform to
both the X's and the Y's.
30:39 - And now, here's the complicated part.
30:42 - This loop here is visualizing the results
30:47 - of the Fourier transform as a sequence
30:50 - of rotating circles, epicycles.
30:53 - So what I want to do though is,
I think what's going to be good
30:56 - is to refactor this, not later, but now.
30:58 - (upbeat disco music)
30:59 - ♪ I will refactor this later ♪
31:00 - - And put this in a function.
31:02 - ♪ You know I will refactor this later ♪
31:04 - - Let's call it epicycle.
31:06 - ♪ I will refactor this later ♪
31:09 - ♪ You know I will refactor this later ♪
31:13 - - So the idea is that maybe
I would get an X and a Y.
31:21 - Like, what's where it's
going to start, and then,
31:26 - I get the set of epicycles,
and I draw them all.
31:33 - So this is a generic fourier[1].
31:35 - So in other words, the idea
being that I could say,
31:40 - and I'm going to get rid of this
translate, and I'm going to say,
31:43 - basically, what I want to be able to say
31:44 - is like, draw, what did I call it?
31:47 - Draw Fourier?
31:48 - No, I called it epicycles.
31:49 - Epicycles, like 100, comma,
what's the size of this?
31:56 - Windmill at 200, a
fourierX, and the epicycles,
32:02 - you know, 300, 200, fourierY.
32:06 - So we should see both of these now.
32:10 - Let's take a look.
32:12 - Epicycles is not defined.
32:15 - Oh, I don't know why I did this capital C.
32:17 - That's probably unnecessary.
32:19 - Okay, great.
32:20 - So we can see, look.
32:21 - So those are, and now, the
epicycles are the same,
32:23 - 'cause they have the same values.
32:25 - Let's give them different values.
32:29 - So let's actually, let's
do something kind of goofy.
32:31 - Let's make it draw a circle.
32:33 - So this is going to be 100
times cosine of, this is
32:40 - so silly, of an angle,
and that angle is map(i),
32:45 - which goes from zero to
100 to zero to TWO_PI.
32:50 - This is just so I can have
some kind of path to work
32:53 - with that's like, very recognizable,
32:55 - so I know whether it's working or not,
32:57 - and then Y will be the sine of that.
33:02 - So we can see, okay, this
looks promising, right?
33:05 - Now we can see here are
the epicycle calculations
33:08 - for the X's and the Y's.
33:11 - Now, one thing that's
off, though, is that,
33:14 - remember how I had to like,
I kind of like, glossed
33:16 - over this, but I was like,
had the thing on its side?
33:20 - This HALF_PI is really like the rotation
33:24 - of the whole thing, of
how I want to display it.
33:26 - So let's make that an argument here,
33:29 - and we'll call that rotation.
33:31 - And so the Y's, oh, that's
when I, do I want it?
33:37 - Yeah, I think I can just do that
33:38 - when I draw it, that's fine.
33:42 - Where is this now?
(instructor laughs)
33:44 - The Y's should be off by HALF_PI,
and the X's should not be.
33:50 - And so now look at this.
33:51 - Okay, so in theory now,
(instructor laughs)
33:54 - we're getting somewhere, don't worry.
33:56 - What I want to do, let's
position this over here, and then
34:01 - let's position this a little
bit further over in here.
34:06 - And now what I want to do
is over there, where that
34:09 - mouse pointer is, I want
to take the Y from here
34:13 - and take the X from
there and draw the path.
34:16 - So, instead of wave, I was
drawing a wave pattern,
34:19 - I now want an array that is the full path.
34:24 - I want to basically get the end result.
34:28 - So let's have this
epicycles function return,
34:35 - it should return a
value which is a vector.
34:39 - createVector with x and y.
34:43 - So whatever the end result,
like the last x and y point,
34:47 - the end of that epicycle
sequence, and then, so I have
34:54 - vx is this, that's the vector for the X's,
34:58 - and vy is that, and now I
want to say, path.unshift.
35:09 - Okay, so I want to create a new vector.
35:15 - This is like, where I want
35:17 - to draw the thing, I need a vector,
35:20 - which is the x component of
vx and the y component of vy,
35:26 - and then I want to put that
in the path, and then this,
35:29 - let's get rid of this line for a second.
35:33 - I'm going to, instead
of drawing this wave,
35:35 - I'm going to iterate over the path.
35:37 - I don't know if I've, this is a little bit
35:39 - of a strange refactoring
of what I had before,
35:42 - but I think it's going to
make sense to you in a second.
35:45 - Let's see.
35:45 - I might have to come
back and explain this.
35:48 - (instructor laughs)
Let's put this in here.
35:50 - And wave is not defined,
because it is path, path.
35:53 - I'm not going to worry
about this right now.
35:55 - Let's kick that out.
35:58 - All right, it's over there.
35:58 - Oh, it's in the wrong spot.
(instructor laughs)
36:01 - So, this is actually correct.
36:03 - I just put the, now I realize, like,
36:05 - (bell dings)
36:06 - this is correct; I just
put these in weird places.
36:08 - Like, I want the one that's
doing the Y over here
36:10 - and the one that's doing the X over there.
36:12 - I don't know why it just like intuitively
36:13 - didn't put them in the right place.
36:15 - So this should be 400, 50, and
this should be like, 50, 200.
36:20 - This has nothing to do
with Fourier transforms.
36:22 - It's just the weird way.
36:22 - There we go.
(instructor laughs)
36:24 - So, I wanted to see them like this.
36:25 - So now you can see, those
are the Fourier transforms
36:27 - for this particular circle, and let's add
36:30 - a line back in now, which
is basically this thing.
36:38 - So I also want to draw
a line from the vx.vy,
36:45 - oh, so, vx.x, vx.y, to v.x, v.y.
36:52 - Like, I just want to draw these two lines,
36:54 - and the the same thing
from the y.x and the y.y.
36:57 - Wow, my naming is wildly confusing here.
37:01 - So this could definitely
use some refactoring, but.
37:07 - There we go.
37:07 - Now we can see those lines.
37:09 - So this is good.
37:10 - Now, I don't like the
way this is spaced out,
37:12 - so let's, one way to fix that
would just be to make this
37:17 - thing smaller, and that sort
of helps me a little bit.
37:23 - But this can move over.
37:24 - I don't know why I put it
all the way over there.
37:28 - Let's move this over to 300.
37:30 - Okay, this is a little bit better.
37:33 - Now, let's make something
more interesting here,
37:38 - which is,
(instructor laughs)
37:41 - let's start using Perlin noise again.
37:44 - So I'm going to say noise and noise,
37:51 - plus some arbitrary amount,
and we can see, look at this.
37:56 - So you can see that this
works, and let's give it,
38:03 - let's make the amplitude
bigger, and let's give it like,
38:07 - 500 values, whoops, and
there's also no reason why.
38:11 - This is very silly.
38:13 - These should just be in one loop.
38:18 - But let's give it more
values, and let's just say,
38:23 - you know, i divided by 50.
38:25 - I'm just doing arbitrary stuff,
38:28 - 'cause the whole point of
this is to do a drawing.
38:31 - All right, but we can see
how this now will take
38:36 - any arbitrary signal and
compute the Fourier transform
38:40 - for the X's and Y's and draw that path.
38:43 - (instructor claps)
Now, the nice thing about this
38:46 - is I'm about to almost instantaneously
38:49 - do something to make this
much more interesting.
38:52 - I am going to go and grab
the Coding Train logo path.
38:58 - The whole point of this is
forget about computing a path.
39:02 - I want to have a known path, a drawing.
39:06 - (bell dings)
39:07 - I am back, and I have
brought in a JavaScript file
39:11 - that just has a big array of X's and Y's,
39:14 - all in a variable called drawing, which is
39:16 - the continuous path of
the Coding Train logo.
39:20 - Thank you to, I'll link
to Tom Fevrier on Twitter
39:24 - for sending me this particular path.
39:28 - So what I'm going to do
now is if I go to the code,
39:31 - we've done all of this
work for this moment.
39:34 - (instructor laughs)
Oh boy, this better work.
39:35 - I'm so excited.
39:37 - I'm going to go here, right,
and now, I'm going to say,
39:41 - I mean, this is a little bit silly,
39:42 - the way I'm doing this,
by drawing.length, i++.
39:46 - I'm going to go through, right?
39:48 - Remember, this variable,
drawing, is just an array of X's
39:52 - and Y's, and I'm going to
make the X's drawing[i].x,
39:59 - and the Y's, drawing[i].y.
40:06 - Now, here's the thing.
40:06 - I happen to know that the
complexity of that drawing
40:12 - is way more detailed than I need,
40:15 - and it's going to run very, very slow.
40:16 - So I'm actually going to
add a variable called skip,
40:19 - and I'm going to like, skip
every 10, and I'm going to say
40:23 - += skip, and then I'm going
to change this to push.
40:27 - So I'm going to skip and only do
40:29 - every five vertices of the drawing.
40:31 - I'm doing this in advance,
'cause I already know,
40:34 - looking at that, I don't
need that many points.
40:39 - So this should now give
me all of the points,
40:42 - all of the X's and Y's, from
that particular drawing.
40:47 - (instructor laughs)
40:48 - (drum roll)
40:49 - I'm about to go hit refresh,
and hope that this works.
40:57 - (instructor laughs)
There it is!
41:03 - (dramatic fanfare)
41:04 - So there it is.
41:05 - Now, this doesn't look as
beautiful as it possibly could,
41:09 - and there's a couple reasons for that.
41:12 - Right now, one thing is,
these look like these
41:15 - weird alien creatures, by the way,
41:17 - but it would be really
nice to have the epicycles
41:21 - render in order of amplitude.
41:24 - So right now, they're rendering
in order of frequency,
41:26 - and it's like this strange machine,
41:28 - almost like, drawing machine.
41:29 - It would be amazing if someone
could build this physically.
41:33 - But what I'm going to do is sort them.
41:36 - So, I'm going to say
fourierX.sort, and fourierY.sort.
41:46 - Now, the JavaScript
sort function allows you
41:50 - to pass in a callback, which
is essentially a function
41:54 - that tells you how to
compare each element,
41:56 - and I want to compare them by amplitude.
41:58 - So I can actually say, any
two arbitrary elements,
42:01 - and I'm going to use ES6 syntax for this.
42:04 - If you haven't watched my arrow syntax
42:06 - or higher order array
videos, this is something
42:09 - that will give you background for this.
42:11 - And then I can just say, I
think a.amp - b.amp, right?
42:16 - Because if I get a positive number,
42:19 - it'll put one in front of the other.
42:21 - If I get a negative number,
it'll put the other one.
42:23 - If they're equal, it'll leave them.
42:24 - So this is sorting each
one of those by amplitude,
42:28 - and if I refresh this, oops, sorry,
42:30 - the smallest one is, I
sorted it in reverse order.
42:33 - So let's put b there, b here, a here,
42:39 - and let's also give myself,
let's clean up some stuff here.
42:43 - Let's make this 800 by 600.
42:46 - Let's set the offsets to
width divided by two, 100,
42:52 - height divided by two, whoops, sorry, 100,
42:57 - height divided by two.
43:00 - Let's set these offset a little bit more.
43:02 - Let's refresh, whoops,
let's shrink this up,
43:08 - and let's move this down a little bit.
43:11 - Will this work?
(instructor laughs)
43:13 - All right!
43:14 - (bell dings)
43:15 - (train whistle toots)
43:17 - This is the thing finished!
43:19 - 72 hours later, there it is.
43:22 - Oh, it's off the bottom.
43:23 - Oh no, it's kind of sitting
right there perfectly.
43:25 - How did my math, that was
totally accidental, by the way.
43:29 - Now it's just going to draw
it again over and over again.
43:31 - But I want to do a couple other things.
43:33 - One thing I want to do is
if time does a full cycle,
43:43 - then I want to set time
back equal to zero,
43:48 - and path, clear the path.
43:51 - All right, this concludes this
particular coding challenge,
43:56 - where I took a discrete Fourier transform,
44:01 - this particular math
function, I applied it
44:04 - to an arbitrary signal,
two signals of X's and Y's.
44:07 - Then I rendered those
as rotating epicycles,
44:10 - and I had to draw the path.
44:12 - Whoo, I'm very excited
that I accomplished this.
44:14 - So, there are two things
that I want to do, probably
44:17 - more than two, and those are
going to come in separate videos,
44:20 - if you made it through this one.
44:24 - I am going to, first, I'm going
to take a break, and I'm going to
44:29 - come back, and I'm going to
make it so that the user draws
44:31 - something, and then it
computes the Fourier transform.
44:33 - That really, by the way,
44:34 - you should go do that yourself right now.
44:36 - So take this code that I've released,
44:38 - find the link in the video description,
44:40 - and go make a version where
the user draws something
44:42 - and then do the Fourier transform.
44:43 - That's a fun exercise.
44:44 - I'm going to do that in
the next video, and then,
44:46 - I am going to rewrite this so that I have
44:50 - the Fourier transform done
with the X and Y's together
44:55 - as a complex number, and I just have
44:57 - one set of epicycles
rendering the full path.
45:00 - But I kind of like these
two X and Y machine things.
45:03 - It's kind of cool.
45:05 - Oh, yes, and Melvin in the chat is saying,
45:07 - oh, you could use the Quick, Draw dataset.
45:10 - So I'm going to leave
that to you, the viewer.
45:12 - Please make this, share it widely.
45:15 - Make a version of this that
renders random drawings
45:18 - from the Quick, Draw data set.
45:19 - That would be super fun.
45:20 - I would love to see that, okay?
45:23 - If you make any of these
exciting, fun, beautiful,
45:27 - strange, ugly, whatever
they are, variations
45:30 - on this particular coding
challenge, please go to the link
45:33 - to codingtrain.com, look
for the instructions
45:35 - on how to submit your
variation, and submit yours,
45:37 - and if you have trouble doing
that, file a GitHub issue
45:40 - or something saying,
I want to submit mine,
45:42 - but I don't know how,
and we will help, okay?
45:44 - Goodbye, everybody.
45:44 - (bell dings)
45:45 - (train whistle toots)
45:46 - And I will leave you with something
45:47 - that really needs to happen to this code.
45:49 - (upbeat disco music)
45:50 - ♪ I will refactor this later ♪
45:52 - ♪ You know I will refactor this later ♪
45:57 - ♪ I will refactor ♪
45:59 - (upbeat pop music)
46:06 - (bell dings)