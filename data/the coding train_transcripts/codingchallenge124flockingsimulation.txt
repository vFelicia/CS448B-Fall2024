00:00 - (train whistle blows)
00:01 - - Hello and welcome to a coding challenge.
00:03 - In this coding challenge,
00:05 - I should probably go eat
lunch but I'm going to just
00:06 - try this coding challenge.
00:08 - I am going to attempt to program this.
00:10 - This is a flocking simulation.
00:11 - What you're seeing right now is an example
00:13 - that I made many years ago
00:15 - of a flocking simulation, a Boids system
00:18 - running and processing.
00:20 - I'm going to try to make
exactly this or close to it
00:23 - in JavaScript with the p5 library
00:26 - starting from no code at all.
00:28 - Obviously besides the dependencies.
00:30 - Okay, so this is the example running.
00:32 - Let me just give you a little
bit of background here.
00:34 - If you want to learn
more about the flocking
00:37 - algorithm as invented by Craig Reynolds,
00:40 - you can go to this link to
read this explanation of it.
00:45 - And find many other links and resources
00:47 - down here, whoa, that's a lot of stuff.
00:49 - Have fun, see you in a few weeks.
00:52 - You can also check out this YouTube video
00:55 - of the original 1986 flocking simulation.
00:59 - Wow, that's amazing.
01:01 - This is so cool, oh my God, I love that.
01:04 - You can also find an explanation of it
01:07 - as part of my Nature of Code book online
01:10 - with some diagrams and
code written in Processing
01:13 - and an exercise that you
can try which I'll refer to
01:15 - back at the end.
01:16 - But I'm going to start
from this, a blank slate.
01:19 - I just have the canvas,
you have some amount
01:22 - of pixels in it.
01:23 - There is nothing happening in the console.
01:27 - I've got this code set up and draw.
01:30 - So I'm going to write this
code without worrying about
01:32 - being perfectly organized
and being able to scale
01:36 - it very easily.
01:36 - I just want to get the
algorithm working but of course,
01:41 - where is the button?
01:42 - (pop music)
01:44 - If you want to see a
refactored example of it,
01:46 - you can probably go and look and actually,
01:48 - at my finished version
in the Nature of Code
01:49 - which I'll also link to.
01:51 - The first thing that
I want to do though is
01:53 - I want to add another JavaScript
01:59 - file called particle.js.
02:02 - Actually, I should rename this to boid.js.
02:07 - What is this term Boid?
02:09 - When Craig Reynolds
invented this algorithm
02:11 - for simulating a flocking
system like a flock of birds
02:16 - or a swarm of bees, I
suppose he didn't want
02:21 - to use the term bird, but
it is kind of like bird,
02:23 - so Boid, it's kind of like droid but Boid.
02:26 - Go read the original paper
about steering behaviors
02:30 - and flocking systems
and you'll find out more
02:32 - about the history about this.
02:33 - But I'm going to make a class called Boid
02:39 - and I am going to use
the p5 vector object.
02:46 - I'm going to make Boid
objects and each time
02:50 - I made a Boid object, I need a constructor
02:53 - and I am going to give
each Boid a position.
02:58 - I'm going to give each Boid a velocity.
03:04 - I'm going to give each
Boid an acceleration.
03:09 - All of those are going to be vectors.
03:10 - I'm doing this is 2D.
03:11 - You should, after you watch
this, if you watch this,
03:14 - you should make your
own 3D version of this.
03:16 - All of the math will
work exactly the same way
03:18 - but you'll just need to rethink
how you're visualizing this.
03:23 - Just to give things a
start, let's just put
03:26 - the position in the middle of the window
03:31 - and let's write a function called show
03:34 - which will just draw them
as a circle right now.
03:36 - Actually, I'll just even use
point, like strokeWeight 16.
03:42 - Stroke 255, point this.position.x.
03:49 - I think Visual Studio
code will do this for me.
03:52 - No, where does it?
03:54 - It fixed that for me once, whatever.
03:57 - This PointerEvent, I'm not a PointerEvent,
04:02 - I'm a point.
04:03 - So now, if I were to
then here make a flock,
04:09 - which is an array, and
I should probably make
04:13 - a flock class, that might be
a thing to refactor later.
04:16 - But I'm just going to
say a flock.push new Boid
04:21 - and then I just want to say
for every Boid in the flock
04:28 - and I'm using of, I'm using a for-of loop
04:29 - but I said in because that's
the way I feel right now.
04:33 - A boid.show and then I need to make sure
04:36 - I am also referencing
boid.js in my index HTML
04:41 - so I have the basic Boid
class, which just creates
04:45 - a position, velocity,
acceleration and draws it
04:47 - as a point and then I have
my sketch where I make
04:50 - one Boid and I draw it in
the center of the screen.
04:53 - There it is, there's my boid.
04:55 - (bell rings)
04:56 - Step one complete.
04:57 - I probably should plan this out
04:58 - but I have one Boid, that's good.
05:00 - Now, let's have that Boid move.
05:03 - Let's actually write in the Boid object
05:06 - a function called update
and this I probably covered
05:10 - ad nauseum in a lot of other videos
05:12 - in my whole Nature of Code series.
05:14 - But the idea here is
that position is updated
05:18 - based on the Boid's
velocity and its velocity
05:24 - is updated based on the
Boid's acceleration.
05:27 - If I now actually create
a p5.vector, a random 2D.
05:35 - I believe this is a
function that will give me
05:37 - a random velocity vector
and I now go in here
05:42 - and say boid.update.
05:46 - Oh I just spelled it wrong.
05:47 - I thought I missed the this dots.
05:49 - Here we go, look, it's moving.
05:51 - It's moving with a random
velocity each time.
05:54 - Okay, now let's just
make a bunch of these.
06:02 - Now I have a system of 100
Boids but it's interesting,
06:04 - look at this, it fans out
in the perfect circle.
06:08 - Do you know why that is?
06:10 - Because I make a Boid and I
give it a random velocity.
06:17 - That random vector is
always of unit length one.
06:21 - The direction is something
different so they're all
06:24 - actually moving with the same speed.
06:25 - If I wanted them to have,
and this is not an important
06:27 - detail to the flocking
stuff, but just to sort of
06:30 - get a sense of how this
vector stuff works,
06:32 - I could say this.velocity.setMag,
which is set the
06:37 - magnitude to a random
value between 0.5 and 1.5.
06:45 - Now, you can see now
they're all moving with a
06:48 - slightly different velocity.
06:49 - This is by the way, a nice
little almost like explosion
06:53 - motif and I could have
them with a real big burst
06:55 - then they slow down.
06:56 - There's all sorts of
physics-y stuff I could do
06:58 - with this but I just want to do flocking.
07:00 - How, how, how do I do flocking?
07:03 - Let's return to this paper here.
07:06 - This is the key behind Craig
Reynolds' flocking algorithm.
07:11 - Three rules.
07:14 - Separation: steer to avoid
crowding local flockmates.
07:19 - Alignment: steer towards
the average heading
07:23 - of local flockmates.
07:24 - Cohesion: steer to move
toward the average position
07:28 - of local flockmates.
07:30 - Something so crucial in
that description is the
07:33 - word local, local.
07:35 - Local, what does that mean?
07:37 - Let's just do, I think
the easiest one to do
07:40 - actually is alignment.
07:43 - Let's say there are five Boids.
07:47 - Actually, let's make a lot more of them.
07:49 - These are all of my Boids.
07:52 - This is the one that I'm
currently operating around.
07:55 - It has a velocity vector like this.
07:57 - Let me just make up, let's just pretend
07:59 - like the ones around it are kind of moving
08:01 - all in the same direction.
08:02 - Because that'll be easier to think about.
08:05 - This is the current one
that I'm looking at.
08:08 - And maybe some of these
others are also moving
08:10 - in other directions also.
08:14 - I could take the approach
to say this particular Boid
08:17 - needs to align itself to everything.
08:21 - But this is not really how complex systems
08:25 - in nature actually work.
08:27 - The emergent phenomena
comes from this Boid having
08:30 - a limited perception of its environment.
08:33 - So maybe, it's actually
only able to see things
08:36 - that are in front of it or behind it
08:37 - or to the right or what's
probably the most simplest
08:39 - thing to implement is within some radius.
08:43 - So I only want to look
at the Boids that are
08:45 - within this radius,
meaning this one, this one,
08:48 - this one, this one, this one.
08:50 - What if I iterate over
all these ones that are
08:53 - within some distance, average
all of their velocities
08:57 - and shift this velocity in the direction
08:59 - of all those velocities.
09:01 - That's what we want to do.
09:03 - I am going to write a function now.
09:07 - I'm going to put it in
the Boid and I'm going to
09:09 - call it align and it's
going to get presumably
09:13 - an array of other Boids.
09:15 - The idea is this function align this Boid
09:18 - with all the other Boids.
09:20 - So what do I need to do?
09:22 - I'm going to make a
variable called average
09:25 - which is going to be a
vector then I am going to
09:29 - iterate over and I could
do all of these with
09:32 - reduce probably in some
higher order array functions.
09:36 - That's a great thing for you to do.
09:38 - (pop music)
09:41 - Refactor it later but
I'm just going to do it
09:44 - this way, I'm actually going
to use i because that's
09:50 - maybe going to help me.
09:51 - I'm not really sure but I'm
going to use i right now.
09:54 - Actually, no, I'll
still use a for-of loop.
09:56 - Let other, I'm going to
call it other of Boids
10:03 - and I'm going to just say
average.add other.velocity.
10:09 - So I'm adding up all of the velocities.
10:12 - This is how you do an average, right?
10:13 - Vectors, again you might
want to go watch my videos
10:16 - about how vectors work,
but a vector, a p5 vector
10:19 - just holds an x and a
y or a x and y and a z.
10:22 - So I want to average the
vector, represented as an arrow
10:25 - with an x component and a y component.
10:27 - If I want to average,
just like I might average
10:28 - an array of numbers, I
add them all up and divide
10:31 - by the total.
10:32 - Then I would say
average.divide by Boids.length.
10:38 - This would be a way of
getting the average velocity
10:44 - of all the Boids but remember I only want
10:48 - the ones within some distance.
10:49 - So actually, let's
implement that right now.
10:53 - Let's have some sort of distance like max.
10:58 - I'll call it perception
equals let's just make it
11:01 - arbitrarily like 100 and
then I'm going to now
11:04 - say if the distance
between this.position.x.
11:10 - You know what?
11:12 - I think there's a p5.
11:13 - This is fine.
11:14 - It's just going to be, it's kind
of long the way I'm writing this
11:16 - but I don't mind.
11:17 - Let's actually make it in a variable.
11:19 - D = the distance between
this Boid's position
11:26 - and the other Boid's position, x and y.
11:34 - If that distance is less than 100,
11:39 - look at that.
11:40 - Look at this fancy thing that it's doing.
11:42 - I have some prettier
stuff that doesn't want
11:45 - to let me write a long line of code.
11:46 - I guess I'll keep that
in there for right now.
11:49 - So I'm calculating the
distance between this Boid's
11:51 - position and the other Boid's position.
11:53 - If that distance is less
than 100, I'm adding
11:55 - it up and I should also
probably have a total number,
12:00 - total = zero.
12:03 - Add it up.
12:04 - I also should probably
ignore myself and if other
12:11 - does not equal this, right?
12:16 - So I basically, I might
as well put that first.
12:19 - As long as the other thing is not me
12:22 - and the distance is
less than 100, add it up
12:26 - and then divide by the total.
12:28 - But obviously, I only want
to divide by the total
12:33 - if total is greater than zero.
12:37 - All right, so this is
kind of a little bit of
12:39 - a long-winded algorithm now.
12:41 - And perception.
12:42 - If d is less than perception.
12:46 - So I'm starting with a
perception, a radius of 100.
12:49 - Maybe that would be better if I called it
12:51 - perceptionRadius, that's
really what it is.
12:55 - Starting with a perception radius of 100,
12:57 - an empty vector, adding up the velocities
13:00 - of any vector, any Boid that's near me,
13:04 - dividing by the total and
as long as I've found one,
13:07 - dividing by that total.
13:08 - Now here's the thing.
13:09 - I could just say, for
example I could do something
13:11 - weird, this will be really weird.
13:13 - I could just say
this.velocity equals average.
13:17 - What if I did that?
13:19 - Then I said Boid, like here
I said boid.align flock.
13:27 - I don't know what's going to happen here,
13:29 - but let's refresh this.
13:31 - They just basically don't go anywhere.
13:33 - Because they're all instantly equal
13:35 - to each other's velocity.
13:37 - That's not really a good way.
13:38 - What I need to do now is
if I don't want to actually
13:41 - assign its velocity to
that average directly.
13:44 - I want to steer towards it.
13:48 - This is where Craig Reynolds'
steering formula comes in.
13:52 - A steering force equals
some desired velocity
13:58 - minus the current actual velocity.
14:02 - It's kind of like the error.
14:04 - If I am moving this way.
14:08 - Sorry, if I'm moving this way
but I want to move this way,
14:11 - the way I want to move
minus the way I am moving
14:16 - is the steering force meaning
push me in that direction.
14:21 - Apply a force.
14:22 - Maybe I'm going to turn
the steering wheel.
14:24 - You can think of these as bees or cars
14:26 - or birds or whatever.
14:27 - This formula desired minus
velocity will give me
14:30 - the steering force and what
is the desired velocity here?
14:35 - The desired velocity is
actually that average.
14:37 - I'm actually going to
rename this to desired
14:40 - and I'm going to add it up
14:43 - and divide by total and
then I'm going to say
14:46 - this.velocity equals, no,
I'm not going to say that.
14:48 - I'm going to say steering equals.
14:57 - I should actually call this
steering because I could
15:00 - do all of this.
15:02 - I don't need to save
anything as I'm going.
15:04 - I'm going to call that the steering force.
15:06 - I'm going to add all the velocities.
15:09 - I'm going to divide by the total and then,
15:11 - I'm going to say steering
force is the desired
15:15 - subtract this.velocity.
15:20 - And I'm going to say return steering.
15:23 - I want this function to basically,
15:26 - I want this function to return that force.
15:28 - So really what I should
be doing is I should have,
15:30 - I'm going to write a
function called flock.
15:33 - That's maybe more like, yeah.
15:36 - Flock with some number of
Boids and then I'm going to say
15:42 - alignment equals align with those Boids.
15:49 - So I'm going to get
this force and I suppose
15:59 - steering is here, so you know what?
16:02 - I should always return steering.
16:04 - I want to always return a
vector but if it didn't find
16:07 - anything, I'll just
return the zero vector.
16:10 - Then, what I'm going to
do is I'm going to say
16:12 - acceleration add alignment.
16:17 - The idea, the way that
a physics engine works,
16:20 - and this has to do with,
16:23 - this is a very simple
crude physics engine.
16:26 - Force equals mass times acceleration.
16:29 - This is Newton's Law of Motion.
16:31 - Or acceleration equals
force divided by mass
16:35 - or in a world where the
mass of everything is one,
16:37 - acceleration equals force.
16:39 - So if I want to apply
a force to this object,
16:42 - I just need to set the
acceleration to that force.
16:45 - Actually, that's what I'm going
to do just starting out here.
16:48 - I'm going to say acceleration
equals alignment.
16:53 - So now, if I go back to sketch and I say
16:58 - Boid.flock Boids, we should
now have all of Boids
17:05 - doing that with just implemented
with that alignment rule.
17:12 - Let's see.
17:13 - Boids is not defined.
17:14 - Sketch.js line 14.
17:17 - Oh, it's called flock.
17:17 - Oh, this is my variable
naming is terrible.
17:22 - But I'm going to leave
it that way right way.
17:25 - Align is not defined.
17:26 - Boid.js align Boids.
17:31 - Oh, this .align, this .align Boids.
17:35 - Acceleration is not
defined, oh my goodness.
17:40 - (pop music)
17:47 - Let me actually not have them all start
17:49 - in the same place because
that is just to see
17:52 - this effect happen, let
me actually start them
17:55 - in random places on the screen.
17:58 - Let me change that.
18:00 - Let me make the perception
radius a little bit smaller
18:03 - and I don't know why this
matters, but let me draw them
18:05 - like a little bit smaller.
18:08 - Let me actually have them start out going
18:13 - quite a bit faster.
18:17 - You can see as they get near each other,
18:19 - they start to get each other's velocity.
18:23 - They start to average each
velocity with their neighbor's.
18:26 - You start to see these
clumps moving together.
18:29 - So much more to do on this.
18:30 - Oh my goodness, but first a couple things.
18:34 - One is I have now basically
allowed these Boids
18:43 - to steer with infinite power in a way.
18:47 - We should probably have a variable.
18:50 - I'm going to call it maxForce.
18:53 - I'm going to set it
equal to one for a second
18:56 - and then what I'm going to do is here,
18:58 - I'm going to say a steering
limit this.maxForce.
19:05 - What this does is it limits the magnitude,
19:07 - the length of that vector
to some maximum force
19:10 - so this should be exactly the same.
19:12 - We're not seeing anything different but if
19:14 - I were to make maximum force
0.01, like really small
19:19 - right now, you're going to
see they're not actually
19:22 - changing their velocity.
19:24 - They are, but very, very slowly.
19:27 - The other thing we're
really going to need to do
19:28 - is I just have to give up and do this.
19:31 - I'm going to add something
for the edges here.
19:34 - I'm going to say if
this.position.x is greater than
19:38 - the width, this.position.x
should equal zero.
19:45 - Else, if this.position.x
is less than zero,
19:49 - this.position.x equals width.
19:52 - Then I'm just going to do that for the y,
19:54 - with, with, x, x, y, y, y, x, x, x, x,
19:58 - with, with.
19:59 - All right, and now here,
let's do boid.edges.
20:07 - We should see them
reappear wrapping around
20:10 - and now, let's go back to the Boid and
20:16 - let's make this 0.2 is
kind of reasonable-ish.
20:23 - Interestingly enough, they're kind of like
20:25 - it slows them down which is interesting.
20:30 - But I'm only doing alignment right now,
20:31 - but you can see how this works.
20:33 - You can see how they're
all starting to align
20:34 - with each other.
20:35 - I could keep them going
at some minimum velocity
20:37 - which might make sense.
20:38 - You can see how these
are going back and forth.
20:41 - But you get the idea.
20:42 - Why are they all slowing down?
20:46 - Is that just a coincidence?
20:48 - One thing I could do is
20:50 - this is actually going to be worth it
20:54 - because I should also
give them a maximum speed.
20:56 - This is going to be a
parameter of a variable
20:59 - that's going to allow
me to control the system
21:00 - pretty well and I could
consider their desired
21:04 - velocity in the alignment
to not actually be
21:10 - the actual average velocity
but just the average
21:13 - direction because I could
then say steering.setMag
21:17 - to this.maximum speed.
21:19 - So basically I'm saying I
always want to go in the
21:21 - direction of my neighbor
but at maximum speed.
21:24 - I don't know that that's
really an important detail,
21:26 - but if I add that in here,
we might get the effect
21:29 - that I was hoping to get.
21:30 - Now, this is what I was expecting to see.
21:32 - As they get near each other,
21:34 - they're all starting to align together.
21:36 - Let me refresh that one more time.
21:38 - You can see that they're
clumping and as they group,
21:41 - they all start to align.
21:42 - This is the alignment rule.
21:43 - This is a very simple rule.
21:45 - It's predictable, it's
obvious, this is alignment.
21:48 - Now, all we need to do is
add cohesion and separation.
21:52 - Separation is going to
be the hardest one to do.
21:54 - So let's do cohesion next.
21:56 - Same thing, we're going
to look at our neighbors.
21:59 - We should go back to what
the rule was actually
22:01 - defined as, let's go back to
Craig Reynolds' original page.
22:05 - Cohesion: steer to move
toward the average position
22:09 - of local flockmates.
22:10 - This is actually not going to be that hard
22:13 - because we've already
calculated the average velocity
22:17 - of local flockmates.
22:19 - Now, let's just duplicate that code.
22:21 - I know, I know we could refactor it.
22:22 - I won't play the song.
22:24 - Because we could probably do
this all in one fell swoop.
22:26 - There's so many possibilities
but now I just want
22:28 - to get the average location
of my local flockmates
22:31 - and steer towards that.
22:33 - So, the way I'm going to do
that is I'm just going to
22:38 - go nuts and copy paste this whole thing
22:45 - and call it cohesion and I'm going to keep
22:49 - the perception radius, I'm
going to keep this idea
22:51 - of steering, keep this idea of total.
22:53 - Go through all the
Boids, check the distance
22:55 - between myself and the other ones,
22:58 - as long as I'm not myself and
within the perception radius,
23:00 - what am I doing?
23:01 - Steering not the others' velocity
but the others' position.
23:05 - This should clearly be
refactored into its own function
23:08 - but whatever.
23:10 - Then as long as I have
at least one, I'm going
23:14 - to divide by the total.
23:16 - Now I don't want to set the
magnitude to the maximum speed
23:18 - so what I have now in steering
is the average location.
23:22 - So if this is the average location,
23:27 - let's say it's over here, then what I need
23:29 - is a vector that,
23:30 - that's clearly not the average location.
23:32 - But let's just say it was.
23:34 - The average location is kind of like
23:35 - where this Boid is.
23:36 - But I want to steer in that direction
23:38 - so to get a vector in that direction,
23:40 - I take the average location
minus the current position
23:44 - of me which is basically saying
23:47 - now what I want to do
is say steering subtract
23:52 - this.position so subtract my position now,
23:57 - I've got a vector that's pointing from me
23:58 - to the average location,
remember which is in
24:00 - the steering variable
then let's say I want to
24:03 - go at maximum speed.
24:06 - Then, this is now my desired velocity.
24:10 - I'm going to subtract
out my current velocity,
24:12 - limit it to max force and there we go.
24:14 - That's cohesion.
24:15 - (bell rings)
24:16 - Now, in flock, let cohesion
equal this.cohesion
24:26 - Boids and then oh, we have a big problem.
24:29 - This.acceleration equals alignment.
24:31 - This.acceleration equals cohesion.
24:32 - So how can I set the acceleration
to two different forces?
24:36 - But before I even answer
that, there's an easy answer
24:39 - to that question.
24:40 - Let's just comment out
alignment and let's watch
24:42 - cohesion happen.
24:48 - We can see they start to group together.
24:50 - This is cohesion happening.
24:51 - And that neighbor radius, by the way,
24:53 - is a super important value.
24:55 - Right?
24:56 - That neighbor radius,
if I were to change that
25:01 - and I have a different,
that perception radius,
25:03 - if I were to change that to 10,000
25:07 - they're all going to come together as one.
25:10 - Because they all see everybody.
25:12 - If I were to change that to 10,
25:15 - there's really little pairs.
25:18 - You can see they kind
of get in groups of two.
25:20 - The force though isn't so strong.
25:23 - So if I were to change
the maximum force to one,
25:28 - now you see them, almost like these little
25:30 - electron thingies that
start, magnetic things
25:35 - that start to spin around
each other and then fan off.
25:37 - There's so many possibilities here.
25:42 - I could make the maximum speed two.
25:44 - I'm not actually limiting it, you can see.
25:45 - There you go, that's
what I was looking for.
25:47 - They get into these little groups
25:48 - but let me go back and
say maximum speed is four.
25:51 - Maximum force is 22 and I realize
25:53 - this maximum speed is not
actually a maximum speed
25:56 - because in update if I
really wanted it to be
25:59 - a maximum speed, I would want to say
26:03 - this.velocity limit this.maxSpeed.
26:08 - Let's actually add that
in and see what we get.
26:12 - Oh, and let's put the
perception radius back
26:15 - at 100 and there we go.
26:18 - Now we have cohesion.
26:20 - We have cohesion, what
happens if we have cohesion
26:22 - and alignment?
26:23 - How do we get cohesion and alignment?
26:26 - Okay, this is fun.
26:27 - This is really working.
26:28 - This is going to be a really long video.
26:30 - All right, cohesion and alignment.
26:31 - The problem rests here.
26:35 - This is actually a really
easy thing to solve
26:37 - because this is called force,
26:39 - the answer here is force accumulation.
26:42 - In physics, if two forces
are acting on an object,
26:46 - the resulting acceleration
is the sum of those forces.
26:49 - So all I need to do is say
acceleration.add alignment
26:53 - and acceleration.add cohesion because
26:56 - why is this not falling?
27:00 - Because the force of
gravity is pointed this way
27:03 - and the other force of
my hand holding it up
27:06 - is pointed in the other direction
with an equal magnitude.
27:09 - Therefore, it is at rest.
27:11 - Those two forces added together
have a net acceleration
27:15 - of zero.
27:16 - But obviously, all you
do is add them together
27:19 - but there is this, if I
actually do this right now,
27:22 - we're going to see some
really crazy behavior.
27:24 - Looks like it's kind of
working but it really isn't
27:27 - because what it should also
have is this acceleration
27:31 - shouldn't accumulate over time.
27:33 - Every moment in time, I
start with a net acceleration
27:36 - of zero and add all the forces together.
27:39 - So what I should do right
before I flock is say
27:43 - this.acceleration set zero, zero.
27:46 - This is setting its
values to zero and zero.
27:49 - Another way I could do
that is just multiplying
27:50 - it by zero, because
multiplying a vector by zero
27:53 - takes everything out.
27:54 - It could make a new vector, whatever.
27:55 - But this will work nicely and technically,
27:58 - this also might make more sense here
28:00 - because it's kind of like
after I finish updating
28:02 - the velocity then I can
reset the acceleration
28:04 - in case there's other things at play.
28:07 - Now we can see both cohesion and alignment
28:14 - are at play, look at this.
28:15 - Eventually, they're just all
going to become this one clump.
28:18 - Come on, you can catch
up, you got it, go go!
28:21 - Go, catch up!
28:22 - Yeah! One clump.
28:24 - One thing I would like to do.
28:28 - I really want to attach
sliders to those parameters
28:30 - but I got to resist because
we got to have separation.
28:34 - We've got alignment.
28:35 - (bell rings)
And cohesion.
28:35 - (bell rings)
28:37 - Separation, this one is a little bit hard.
28:39 - Steer to avoid crowding local flockmates.
28:46 - Here's the me.
28:48 - That's me, here's my local flockmate.
28:52 - If this local flockmate
is too close, it's within
28:56 - some sort of distance
threshold, I want to steer
28:59 - to avoid that.
29:01 - What would be my desired velocity?
29:03 - My desired velocity would be to move
29:06 - in the opposite direction.
29:09 - So the idea is my desired
velocity is in the observable.
29:13 - What if there is one here?
29:16 - My desired velocity would
also be opposite direction
29:18 - so then my next desired velocity would be
29:21 - the average of these two.
29:23 - It even would make sense
for the magnitude of that
29:26 - desired velocity to be
proportional to the distance.
29:31 - So if this one is here,
I maybe want to avoid it
29:34 - but I only really need to
think about avoiding it
29:37 - a little bit.
29:38 - If this one's really close,
I need to avoid it a lot.
29:40 - So the magnitude of the vector
is inversely proportional
29:43 - to the distance of the local flockmate.
29:46 - This might end up with kind
of like a desired velocity
29:48 - of something like this if I'm
averaging those two together.
29:52 - So let's see if we can implement that.
29:54 - Not going to be super
easy but let's do it.
29:59 - The nice thing is I'm going
to start with cohesion
30:02 - because we've kind of,
30:03 - cohesion is close to separation.
30:05 - Again, boy.
30:08 - (pop music)
30:09 - ♪ I will refactor this later ♪
30:11 - ♪ You know I will refactor this later ♪
30:16 - ♪ I will refactor this later ♪
30:18 - - I should show you that I'm wearing my
30:19 - I will factor this later
t-shirt, by the way.
30:22 - Okay, so separation.
30:24 - I'm going to leave this at 100.
30:26 - Steering, I think I might need to use,
30:29 - I like the idea of just having one vector
30:33 - that ends up as, it's
sort of the average here
30:36 - then it's the difference
but I think I need
30:39 - to think, one step at a time.
30:45 - I'm creating this vector.
30:46 - This is the same.
30:47 - If it's not me and it's
within the perception radius,
30:51 - what do I need?
30:52 - I need a vector, I'm going
to call it difference
30:59 - which is the other's.
31:04 - I want a vector, sorry, that points from
31:10 - the other to me.
31:13 - Because I want that to go
to the opposite direction.
31:16 - So it's my position minus the other.
31:21 - I want a vector, the new vector which is
31:25 - the subtraction between my position
31:30 - and the other's position.
31:34 - This is a way of calling
the subtract function
31:36 - which doesn't operate on a vector
31:38 - but subtracts two vectors and gives us
31:40 - a new vector which is difference.
31:42 - Then, I want the
difference to be inversely
31:47 - proportional to the distance
31:51 - so I'm going to multiply
it or set its magnitude
31:53 - something like that.
31:54 - Or divide by distance.
31:57 - I could just say divide
by distance, right?
32:00 - It's inversely proportional,
the farther away
32:02 - it is, the lower the magnitude.
32:07 - The closer, the higher the magnitude.
32:11 - The distance, I guess
technically that distance
32:12 - could be zero and that
would be problematic
32:14 - but with floating point math rule,
32:16 - it's never going to get a value of zero.
32:18 - Then I want to add.
32:20 - Then that is the thing I add up.
32:23 - That's the thing I want to average.
32:24 - All those vectors that are pointed away
32:27 - from the things near me,
I think we're actually
32:28 - in pretty good shape here.
32:30 - This isn't as hard as I thought.
32:32 - This was the tricky part here.
32:34 - Get a vector that's pointing away
32:36 - from the local flockmate,
make it inversely proportional
32:38 - to the distance, add it
up, then this is the same.
32:42 - Because, oh no.
32:44 - I don't need to subtract position.
32:46 - I kind of don't know if I want to.
32:49 - Let's leave this whole always
go at maximum speed thing
32:52 - and then the rest is the same.
32:55 - Once I have that, just average it,
32:58 - set it to max speed,
subtract out the velocity
33:01 - and limit it to maximum
force and that's the end.
33:03 - Okay, just to be sure this is right,
33:07 - let's go into Boid.
33:09 - Let's go to flock.
33:12 - Let's add let separation
equal this.separation
33:21 - and then let's add in separation.
33:26 - I want to not bother adding
cohesion and alignment.
33:30 - Are these separating?
33:32 - Yeah, it looks like they are.
33:33 - It looks like when they
get close to each other,
33:35 - they're kind of moving
away from each other.
33:38 - Weird, weird behavior.
33:40 - This doesn't look like
exactly what I expected.
33:42 - Let's give the maximum
force, like really let
33:47 - them be super strong about separating.
33:49 - There we go.
33:50 - So that's more like what I expected.
33:52 - That's way too strong.
33:54 - Yeah.
33:55 - Why do they feel like they're,
something is weird here.
33:59 - Let's give it a much
smaller perception radius.
34:03 - Oh yeah, this is what I expected to see
34:05 - and I think it wasn't
really a bug in my code.
34:07 - It's sort of a bug in my conceptual sense
34:10 - of how this works.
34:11 - This is pretty good, this
is what I want to see.
34:13 - This is separation only.
34:15 - Now, we should be able to see and let's
34:18 - I'm going to do this really quickly.
34:21 - I'm going to not be thoughtful
at all about the interface
34:24 - but just so I can debug this effectively,
34:29 - I am going to go into sketch.js.
34:32 - I am going to say let
alignSlider, cohesionSlider
34:40 - and separationSlider.
34:43 - AlignSlider equals createSlider.
34:45 - I'm going to give it a
range between one and five.
34:48 - Actually, let's give it
a range between zero,
34:50 - sorry, zero and five, with
a starting value of one
34:54 - and increment value of 0.1.
34:58 - I want to do this for
all of these sliders.
35:00 - Then in Boid, I want to
say where I call in flock,
35:05 - I want to just scale them.
35:07 - I'm going to say separation.multiply
separationSlider.value.
35:16 - I'm going to do this also for
cohesion and for alignment.
35:21 - Now, by the way.
35:22 - (bell rings)
35:24 - (train whistle blows)
35:25 - Flocking.
35:26 - This is now the flocking simulation.
35:27 - I didn't draw them as triangles.
35:28 - They're not rotating, but this
is the flocking simulation.
35:31 - But just for the sake of
argument, this should be
35:33 - what order did I make them in?
35:35 - They're not labeled.
35:36 - So let's just turn all
the way up to separation.
35:38 - Oh boy.
35:39 - Let's turn off.
35:43 - This is only separation.
35:46 - Now, turn that off.
35:47 - Let's turn on only alignment.
35:50 - Whoa, that's oh they're just the alignment
35:53 - is so strong.
35:54 - When the alignment is
so strong, it makes them
35:57 - go in circles around each other.
35:58 - I have to talk about why.
36:00 - Why did that happen that they
were twirling in circles?
36:02 - Well, look at this.
36:03 - I'm updating them one at a time.
36:06 - The next one is flocking
with the previous ones
36:09 - updated value, right?
36:10 - Instead of taking a snapshot
of all their current
36:12 - velocities and then each one updates based
36:15 - on that snapshot, I start
with a set of velocities.
36:18 - I update the first one based
on the set of velocities
36:20 - and now its new velocity is there.
36:22 - So when the next one, it's
actually updating itself
36:24 - based on the previous one that I updated
36:26 - which is not how the world works.
36:27 - It's not how time works.
36:29 - That's causing them to
ripple into each other
36:31 - based on the order and go in circles.
36:33 - That is something that you
might want to consider fixing.
36:34 - I'm not going to fix that
but now I can really play
36:38 - with these, I can get
different sort of qualities
36:40 - of flocking based on how
strong I make these rules.
36:43 - So no alignment, a lot of cohesion.
36:45 - No separation, add a lot of separation.
36:48 - Less cohesion.
36:51 - Separation, I shouldn't make too strong
36:52 - but it's important and then
let's add some alignment
36:55 - back in and there we go.
36:56 - Flocking.
36:57 - (bell rings)
36:59 - Okay, this coding challenge is complete.
37:01 - It is done.
37:02 - I will be uploading the
code, if you want you can
37:05 - look at the video
description to find the code
37:06 - as a snapshot, that's exactly what it is.
37:08 - Let's go make a list.
37:10 - Let's make a list on the board of things
37:12 - you might try to do.
37:14 - Number one, snapshot of all velocities.
37:20 - That's going to be my code for that.
37:21 - Number two, an optimization you can do
37:25 - is called spatial subdivision
or a quadtree optimization.
37:31 - One of the things that
makes this really slow.
37:34 - And I'll just show you here for a second,
37:36 - is if I were to try to do
this with a 1,000 Boids.
37:43 - Look how slow this is.
37:44 - But you have to realize,
it's not a big deal
37:49 - for p5 to draw 1,000 things moving.
37:52 - Why it's fine drawing 1,000 things moving
37:54 - but as soon as I put
the flock function in,
37:57 - it's super slow.
37:58 - The reason that is is
because it's got to do
38:02 - and every Boid, check
every Boid against every
38:05 - other Boid check.
38:06 - So there's a way of subdividing the space,
38:11 - spatial subdivision into bins or buckets
38:14 - and have the Boids only
check ones that are near
38:16 - each other in the same buckets.
38:17 - That's called, I probably
have a lot of distance
38:20 - calculation, I could
reduce the number of times
38:22 - I call it.
38:24 - But for this, quadtree or just
simple spatial subdivision.
38:31 - These are things you could try.
38:32 - These are just code refactoring, really.
38:34 - Actually, the other thing you could try
38:39 - is really build a more
sophisticated interface
38:44 - and there's lots of
other parameters that you
38:47 - could control and try.
38:49 - There's the perception
radius, there's maximum force,
38:56 - there's maximum speed.
39:00 - Each rule could have a
different perception radius.
39:03 - So many possibilities.
39:06 - This is the stuff that
you could do to really
39:08 - control and tweak all the
values and play with it.
39:12 - Another thing you could do is just design,
39:15 - visual design, like are they triangles,
39:18 - circles, are they flapping butterflies.
39:21 - How do you, design of the Boids?
39:25 - Make your own beautiful
visualization of how you
39:27 - design and draw them.
39:28 - Tadpole-like, there's so many ideas there.
39:32 - Another thing you could try to do is 3D.
39:35 - Can you extrapolate this into 3D?
39:38 - If you see the word
quaternian anywhere you start
39:40 - to research, you might want to turn back.
39:43 - But you could extrapolate this into 3D.
39:46 - Another suggestion which
came from the chat,
39:48 - thank you, is Boids with
different parameters.
39:54 - There's no reason why
every Boid has to have
39:56 - the same max speed or maximum force.
39:59 - Or same perception radius.
40:02 - You could implement this
thing called the view rule.
40:06 - There's two things about this one.
40:07 - Each Boid can see everything around it.
40:10 - But what if the Boid
itself could actually only
40:12 - see if it's moving in this direction,
40:14 - things that are within its
particular view in front of it.
40:18 - Maybe it doesn't deal with
anything that's behind it.
40:20 - It doesn't try to do cohesion
or alignment or separation.
40:24 - Then the view rule which
is posited by Flake
40:28 - in the book A Computational
Beauty of Nature,
40:30 - I'll link to that book also.
40:31 - It's a wonderful book with tons,
40:33 - probably like 90% of
the things on my channel
40:35 - are all from the Computational
Beauty of Nature book.
40:39 - But Flake posits this additional rule
40:41 - that you always want to
keep your view empty.
40:44 - So if there is a Boid in front of you,
40:47 - you want to steer that way
to keep your view empty,
40:52 - clear and this might result, the theory is
40:55 - that this will result
in something that looks
40:57 - more like that pattern that you'll see of
40:59 - actual birds flocking where they kind of
41:02 - appear almost in this triangular pattern.
41:05 - What's interesting about
this, you see a pattern
41:07 - like this, you think, "Ah ha."
41:09 - This is a top-down behavior.
41:11 - There is a leader, this
bird, who is saying
41:14 - to all the other birds, "Fan
out from me and follow me."
41:16 - But yet, this type of intelligent behavior
41:20 - emergent phenomena can
come actually only from
41:24 - simple, local rules of interaction.
41:26 - This by the way, this
is what this whole video
41:27 - was about, if you didn't
gather that already.
41:30 - Other ideas might be adding obstacles,
41:33 - other forces, there's thinking about these
41:37 - living in a world where
they're interacting
41:39 - with other things,
maybe there's a predator
41:40 - that comes in and is chasing them.
41:42 - All sorts of unique and
interesting possibilities.
41:46 - So thank you everyone for
watching this coding challenge.
41:50 - Put your other ideas for
things people could do
41:52 - in the comments and then
if you make your own
41:54 - version of this flocking
code, please go to the
41:57 - codingtrain.com challenge
page and submit a link
42:00 - to what you made.
42:01 - I will also make a
version of this that runs
42:03 - in the web editor and link
to all those resources
42:06 - like the Craig Reynolds original paper
42:07 - about flocking, the video
on YouTube and the chapter
42:11 - in my Nature of Code book, okay?
42:12 - Thanks for watching this coding challenge
42:14 - on flocking and I'll see you soon.
42:15 - (train whistle blows)
42:16 - (upbeat music)