00:06 - Welcome to a very special
episode of The Coding Train
00:10 - with our guest today, Patt Vira.
00:13 - Patt has an incredible number--
00:15 - over 100, at least,
already in the last year--
00:18 - of tutorials and videos
about p5.js creative coding.
00:22 - So if you like the
coding train, you're
00:25 - going to like Patt's channel.
00:27 - I hope so.
00:28 - So we're here today to do
a special collaboration.
00:31 - Patt happens to be in
New York for ITP Camp.
00:35 - ITP is the program where
I teach during the year.
00:37 - They run a month-long
program in June for Camp.
00:40 - And I just so happened
that yesterday,
00:43 - I taught a quick
workshop at ITP Camp
00:46 - on the ML5 library, which
also just yesterday had a 1.0
00:51 - release.
00:51 - So what we're going to do
in this video is introduce
00:54 - to you the new release
of the ML5 library,
00:58 - show you the new ML5 website.
01:00 - I'm going to give you a
quick walkthrough of how
01:02 - to code some stuff in ML5.
01:04 - And then Patt's going to make it
much more visually interesting
01:07 - and exciting.
01:08 - All right, so what is ml5.js?
01:11 - The ML5 project started in
2017 when researchers at Google
01:18 - were developing deeplearn.js.
01:20 - And we asked the question,
could deeplearn.js,
01:24 - which was a library to
run machine learning
01:26 - models in the browser, could
we run those models with p5.js?
01:31 - deeplearn.js later
became TensorFlow.js.
01:34 - And the ML5 project has had
many years of development
01:38 - with different models and
tutorials and examples.
01:41 - But in the last year, a group
of us at NYU in New York
01:46 - and at NYU Shanghai have been
working on updating the library
01:49 - to use a bunch of refreshed,
new models for pose tracking,
01:54 - as well as some new
functions for training
01:57 - a neural network, all of which
I explore in a lot of detail
02:01 - in chapters 10 and 11 of my
new Nature of Code Book, which
02:04 - think I've probably
mentioned way
02:06 - too many times on this channel.
02:07 - So let's take a look
at the ML5 website,
02:10 - and I can show you what some
of the new features are.
02:13 - This is the new ml5.js website.
02:15 - I encourage you to take
a look at the About page
02:18 - so you can learn all about all
of the wonderful people who
02:21 - are contributing and
building this library.
02:23 - The Getting Started
page is probably
02:26 - where you want to begin, just to
find a quick walk through of how
02:30 - to get started with the
library and the p5.js editor.
02:34 - Under the Reference,
you will see here,
02:36 - on the left, all of the
machine learning models that
02:40 - are currently supported in ML5.
02:42 - There is a model for tracking
body pose, for hand--
02:46 - key points on your hand,
key points on your face.
02:49 - That's what we're going to
use for this tutorial today.
02:52 - There's an image classifier, a
sound classifier, a sentiment
02:55 - analysis model, as
well as a module
02:58 - for training your
own neural network.
03:01 - So I think I'm going to
go to the BodyPose page.
03:03 - Each model page includes
a description, a demo--
03:07 - let's run this demo here.
03:09 - I'm going to allow
it to use the camera.
03:11 - So I'm going to just
awkwardly stand up.
03:14 - So the BodyPose model,
you can see, captures
03:16 - 17 key points on the body--
03:19 - eyes, nose, hands, shoulders,
hips, knees, and toes.
03:24 - And this is actually--
this particular model
03:26 - that it's running
is called MoveNet.
03:28 - One of the wonderful
things about on the website
03:30 - is you can run the demo
here, but you can also click
03:33 - to just look at the example.
03:35 - And you can see the example
code here in the P5 editor
03:38 - and start playing
around with it yourself.
03:40 - More examples are linked below
as well as a step-by-step guide.
03:44 - And then, all the
way down on the page,
03:46 - there's more details about
the specific properties
03:49 - and functions for more detailed
documentation of everything
03:53 - you could do with
the BodyPose model.
03:55 - I also just want to
quickly highlight
03:57 - that the new ML5 has a body
segmentation model in it that
04:01 - will give you a colored
pixel map of every pixel
04:05 - and which part of your
body it's associated with.
04:08 - In a minute, I'm
going to show you
04:10 - how to import the new ML5
library and write code with it.
04:14 - But just in case
you happen to be
04:16 - a current user of the
previous versions of ML5,
04:19 - there's a lot of
models and functions
04:22 - that you still would have to
access by using version 12.2.
04:28 - So let's get started using ML5.
04:30 - I've got a completely
blank p5.js sketch.
04:34 - Now, normally, if I'm
working on a project that
04:37 - uses the ML5
library, I'm probably
04:39 - just going to click on one of
the examples which will already
04:41 - have the library imported.
04:42 - But I'm going to show
you here, step-by-step,
04:44 - if you're starting from
a blank p5.js sketch,
04:47 - how to import the ML5 library.
04:49 - If I click on the Getting
Started page and scroll down,
04:52 - there's some instructions
of how to do it here.
04:55 - But this is what
I'm looking for.
04:56 - I'm looking for this
script tag to where
05:00 - the ML5 library is hosted.
05:02 - And you'll notice this @1
because we're using version 1.0
05:06 - of ML5.
05:07 - I'm going to copy
this to the clipboard.
05:09 - I'm going to go back
to the index.html file
05:14 - in the p5.js sketch.
05:16 - You can see how the p5.js
libraries are being referenced
05:19 - here through script tags.
05:20 - And I can now just add by
pasting in the ML5 library.
05:25 - One thing I'll note
is that you want
05:28 - to make sure that you're using
the most recent version of P5.
05:32 - I'm going to show
you in a minute
05:33 - how some features in the
newest P5 work really well
05:37 - with the ML5 library.
05:38 - The next thing I'm going to
do, which is not related to ML5
05:41 - specifically, is
I'm going to open up
05:44 - a connection to the
webcam on this laptop
05:46 - and see that in the p5.js canvas
and create a variable called
05:51 - video.
05:52 - In Setup, I'm going
to call createCapture.
05:57 - And we can see
here already there
05:59 - am that is the DOM element
floating on the page separate
06:04 - from the canvas.
06:04 - Now could leave it there.
06:06 - But what I want to do eventually
is draw over top of the video.
06:10 - So in order to do that,
what I'm going to do
06:12 - is actually call video.hide
so you don't see it anymore.
06:15 - I'm going to change the
size of the canvas to 640
06:18 - by 480, which is the
size of the video,
06:21 - and then draw the video on the
canvas with the image function.
06:26 - I'm going to show
you something that's
06:27 - in the new version of P5 that
is incredibly exciting to me.
06:32 - Now I'm holding up my hand.
06:34 - This is my right
hand, but it's showing
06:36 - on the left side of the canvas
because it is not mirrored.
06:40 - And if you've ever watched
any of my other videos
06:43 - where I try to mirror
the video, I've
06:45 - got to look up
translate and scale
06:47 - and use a negative number
and all sorts of stuff.
06:50 - But the new P5, I can
actually add an option
06:53 - to the createCapture function
with a property called
06:57 - flipped and set it to true.
06:58 - Let's see what happens.
07:01 - I have a syntax error.
07:03 - I'm missing a comma.
07:05 - Look at that.
07:06 - And now, as I hold
up my left hand,
07:08 - it's on the left
side of the canvas.
07:10 - The video is mirrored,
which is incredibly
07:13 - useful for any kind of
interactive application
07:16 - where you want people to see
themselves reflected on a screen
07:18 - and interact with it.
07:19 - It's much more intuitive if that
video is flipped horizontally.
07:23 - All right, so that's it.
07:24 - We have the video.
07:25 - Now is the time to
incorporate ML5.
07:29 - All of the models,
whether you want
07:30 - to look for key points on the
full body, key points on a hand,
07:33 - or key points on the face,
they all work the same way.
07:37 - The first step is to
create a variable that
07:39 - will hold onto that particular
machine learning model.
07:42 - And I'm going to call
that variable faceMesh
07:44 - because we're going to
use the FaceMesh model.
07:48 - I'm going to navigate
over to the FaceMesh page
07:51 - on the documentation.
07:53 - Let's run the quick
start just to see
07:55 - what the example looks like.
07:56 - And you can see
all of the points
07:58 - that it's tracking on the face.
07:59 - Now you might be
wondering, wait a second,
08:02 - where does this even come from?
08:04 - The models that are available
in ML5 are not magic.
08:07 - There's not some magic system
that knows how to find your face
08:11 - and put key points all over it.
08:13 - The FaceMesh model--
and, in fact,
08:15 - all of the pose
detection models in ML5--
08:18 - come from the
TensorFlow project.
08:20 - And you can find
documentation around
08:22 - what are these models,
who trained them,
08:25 - what data sets they were used to
train on the TensorFlow website
08:28 - itself.
08:29 - And this is a really
important question to ask.
08:31 - If you are working with
a machine learning model,
08:33 - it's very helpful
for you to think
08:35 - about who owns this model,
who trained this model,
08:39 - and what data was used.
08:40 - That will really inform
whatever decisions
08:42 - you want to make about how
you want to use that model
08:44 - and in what context it's
going to work well for.
08:47 - In particular, when you're
tracking somebody's face,
08:50 - it's really important to be
thoughtful about these kinds
08:52 - of questions.
08:53 - Back to the documentation-- the
next thing that I want to do
08:56 - is load the model itself.
08:59 - I'm going to add
the preload function
09:01 - and say faceMesh
equals ml5.faceMesh,
09:06 - and let's see what happens.
09:08 - So every function
that you call in ML5
09:11 - is namespaced under
the variable name ml5.
09:16 - And, in fact, in setup, if I
say console.log(ml5.version),
09:20 - we'll see that version 1.0.1
is logged into the console.
09:25 - The next thing that I need to do
is somehow connect this FaceMesh
09:30 - model with the video.
09:33 - The way that I do that is with
a function called detect--
09:37 - and, in fact, in this
case, detectStart--
09:42 - start video.
09:45 - I've loaded the model, and I've
called the detectStart function,
09:48 - which will trigger the model
to continuously analyze
09:52 - the image from the video.
09:54 - Now there is also a function
called just detect then
09:57 - you can use if you
want to analyze
09:59 - a single image one time only.
10:01 - But with detectStart,
what I need to do--
10:04 - and you can see this
in the error message
10:06 - here-- is I need to add
a callback function.
10:09 - So the model returns
the results of what
10:13 - it finds in the
video asynchronously,
10:15 - meaning that after it's analyzed
the image, when the data is
10:19 - ready, it will
execute a function
10:21 - and pass the results
into that function.
10:23 - So I'm going to make up a name
of a function, call it gotFaces.
10:28 - I'm going to define
that function,
10:31 - and I need to give it an
argument which will hold
10:35 - the data, the results of
the machine learning model,
10:38 - and let's just see what's in
there-- console.log(results).
10:43 - One object-- so I'm
just one person.
10:46 - I have one face.
10:47 - So that's why we're
just seeing one object.
10:49 - But this model, presumably,
if a second person--
10:52 - do you want to prove
if this is true, Patt?
10:55 - Let's see if this is true.
10:56 - If you come here--
10:57 - I think you need to--
10:58 - Change the maxFaces?
11:00 - Right.
11:00 - This is important.
11:01 - But actually, the
FaceMesh model,
11:04 - I can also give it options.
11:06 - So I'm going to allow it to have
a maximum of five faces now.
11:10 - Yes, now we have two faces.
11:11 - There we go.
11:12 - All right, thank you
for that demonstration.
11:14 - But it's actually going to
be kind of convenient to work
11:16 - with it with just one face.
11:18 - So I'm going to take out--
11:19 - I'm going to put maxFaces
back to one right now.
11:22 - Here's another aspect
that's very important
11:24 - that I want to emphasize.
11:26 - Even though the model is being
loaded from the cloud, when you
11:30 - call ML5 FaceMesh, the model--
11:34 - a giant file with a
lot of numbers in it,
11:36 - basically-- is being downloaded
from one of Google's TensorFlow
11:40 - servers.
11:41 - That model itself is actually
executing in the browser.
11:45 - So the images that are
being seen from the camera
11:48 - and being sent to
the model are all
11:50 - happening on-device
inside your web browser.
11:53 - This is very important
and quite different
11:55 - than if you were using another
cloud-based service, where
11:59 - you're actually
sending your data,
12:00 - sending your images
to another server
12:02 - to be processed through a
model and then sent back.
12:05 - Everything is happening
on-device here.
12:07 - So the next step
that I need to do
12:10 - is I want to be able to draw
where those points on my face
12:14 - are on top of the Canvas.
12:16 - So I have the model, I have
the video, I have the results,
12:22 - but I don't have the results
inside of the draw loop.
12:25 - So to do that, I'm going to
create a global variable.
12:28 - I'm going to call it faces.
12:29 - I'm going to initialize
it with an empty array.
12:32 - So when the sketch
starts, it will
12:34 - assume it's detected no faces.
12:37 - And then I'm simply going to
pass that array, those results,
12:43 - into that faces variable.
12:45 - So now, inside of
the draw loop, I
12:47 - can access the global
variable faces.
12:50 - But before I do that,
let's actually go and add--
12:54 - I'm going to add the
mousePressed function.
12:56 - And in here, I'm going
to console.log the faces
12:59 - so we can just take
a look at what's
13:01 - inside the actual
object that holds
13:03 - all the results from the model.
13:05 - So let me make the
console a bit bigger.
13:07 - And I think it's
detecting my face.
13:09 - I'm going to click the
mouse, and there we go.
13:12 - Now I can start to look
inside of this object.
13:15 - So, first of all, it's an array
that holds one object, a face,
13:20 - and then all of
these properties.
13:22 - You could look at the
ML5 Reference page, which
13:25 - will have all the
documentation in terms
13:27 - of these properties
of the results object,
13:30 - as well as a diagram that shows
where all the points on the face
13:33 - are and what order in
the array they are.
13:35 - But, for now, one way we
can just figure it out
13:38 - is by poking through this
object in the console.
13:40 - You'll notice there's
a keypoints object.
13:42 - That is an array
with all 468 points.
13:46 - But one of the
things that ML5 does
13:49 - is it takes that raw
array of all the points
13:51 - and divides it into
parts and gives you a bit
13:53 - more information.
13:54 - So let's focus on
the lips for right
13:56 - now because I think
Patt's project is
13:57 - going to have to do with
opening and closing your mouth.
14:00 - So if I unpack
the lips object, I
14:01 - can see there's an x, a y,
a width, a height, center
14:05 - x, center y, as well as
an array of keypoints,
14:07 - and only 42 key points.
14:09 - So let's first see if we can
draw just the bounding box
14:13 - of your mouth.
14:14 - I have to remember I'm going
into faces, index 0, dot lips,
14:18 - dot x, y-- width, height.
14:20 - And I can do that
right here in draw.
14:23 - The first thing, though,
is I should probably
14:25 - check to make sure that it's
detected at least one face.
14:28 - I can use an if statement and
say if faces.length is greater
14:31 - than 0, then let the
face equal faces index 0.
14:35 - Let's just put it in
a separate variable.
14:37 - And then let's draw a rectangle
at face.x, face.y, face.width,
14:44 - face.height, stroke
weight of 4, no fill,
14:49 - and let's give it a nice, I
don't know, blue-ish, pinkish--
14:54 - I don't know, pick a
random color out of a hat.
14:56 - And let's see what we get.
14:59 - OK, I've made a mistake.
15:00 - Oh, I forgot dot lips.
15:02 - So there is no--
15:04 - that's interesting.
15:05 - Let's go back, and let's
look at the object.
15:08 - So I've made a mistake here.
15:09 - I went straight
for assuming there
15:11 - is some-- there is a box which
has the full bounding box
15:14 - of the face.
15:15 - But I'm looking for the
lips, so I forgot dot lips.
15:18 - So it might actually
be nice for me
15:19 - to say let lips equals
faces index 0 dot lips
15:24 - since that's what
I'm using here.
15:25 - And then I can change
face to lips here.
15:28 - And these should
be the properties.
15:30 - OK, let's see if it works now.
15:33 - There we go.
15:34 - Uh-oh, what happened?
15:35 - So one of the unfortunate
but beautiful things
15:39 - that's happening is that I
mirrored the P5 video, which
15:44 - is only mirroring the
way that it's displayed
15:47 - and not actually mirroring
the data that's being
15:49 - passed to the ML5 library.
15:52 - But guess what-- remember how
I was able to add a property
15:55 - called maxFaces to
FaceMesh, and there's
15:57 - lots of other properties
you could add,
15:59 - which are all on
the reference page?
16:01 - I can also add the
flipped property.
16:05 - And now look at that.
16:07 - And I don't know what I did.
16:09 - I thought I did no fill, but--
16:12 - oh, I typed fill here.
16:13 - OK, that was meant to be stroke.
16:15 - I wanted it to be see-through.
16:17 - There we go.
16:18 - So now you see that
this bounding box
16:20 - is tracking my mouth.
16:23 - If I wanted to look at the
specific points on the mouth,
16:28 - then I could actually dig
into not just the x/y width
16:31 - and height, but the key
points array itself.
16:35 - So I'm going to do a for of loop
to look at every point-- well,
16:39 - I shouldn't use the
variable name "point"
16:41 - because point is an
actual P5 function.
16:45 - So let's call it lipPoint.
16:48 - That's a weird name,
and I'll keep it.
16:50 - Let lipPoint of lips.keypoints--
16:52 - I think that's
what it's called--
16:54 - and then I can
just do a little--
16:57 - let's do a stroke weight of 2.
17:00 - And we'll make a green
color to differentiate it.
17:06 - And I'm going to
say make a point.
17:09 - That's why-- of
lipPoint.x and lipPoint.y.
17:15 - So I've got an error.
17:17 - Let's take a look--
lip.keypoints is not iterable.
17:20 - Let's go look again at
that object to see maybe
17:25 - where I went wrong.
17:28 - Oh, keypoints with
a lowercase p--
17:30 - I capitalized the p,
which is incorrect.
17:33 - If I had bothered to
look at the reference,
17:35 - I wouldn't have had that issue.
17:36 - So let's lowercase this p.
17:39 - And I think now--
17:40 - there we go.
17:41 - So you can see, in addition
to the bounding box,
17:44 - we now have the contours
of the actual lips itself
17:48 - that are being detected.
17:49 - And I could pick
specific points to track.
17:52 - I could use those to draw
other colors or shapes.
17:56 - I could give myself
a really bright shade
17:57 - of lipstick or something.
17:59 - I'm sure you're watching
this-- could come up
18:01 - with many more creative ideas.
18:03 - And, obviously, in addition
to simply just the lips
18:07 - part of the face, I could also
use the left eye, eyebrow,
18:11 - right eye, as well as the face
oval for all the other points.
18:15 - So that's the basic how-to to
load the model, open a video,
18:21 - pass the video to the
model, get the result,
18:24 - and then analyze the result
object and draw based on it.
18:27 - But what kinds of
creative projects
18:29 - might you be able
to make with that?
18:31 - Well, I'm going to turn it over
to Patt to see what she can do.
18:34 - What I want to do is I'm going
to step away from the sketch
18:37 - that Dan just made
and create another one
18:40 - to show you how to make the
kinetic topography sketch,
18:43 - and then we'll
combine it at the end.
18:46 - So we're going to start by
declaring a few variables.
18:49 - The first one is center.
18:51 - And center is going
to be a vector.
18:54 - And a vector is an object that
can hold two to three values.
18:57 - And I'm going to use it to hold
the x and y values of my center
19:02 - coordinates.
19:02 - So center will be
equals to createVector.
19:05 - And this is a method
within the vector class
19:08 - that allows us to
create a vector.
19:11 - And I'm going to give it in
the middle of the canvas.
19:13 - So let's do width divided by
2 and height divided by 2.
19:19 - And then another variable
that I want to create
19:21 - is going to be called
pos, for position,
19:24 - and I'm going to set
it as a vector as well.
19:27 - And let's give it at--
19:29 - how about 300 by 300.
19:31 - So it's going to be
at the bottom right
19:33 - corner of the sketch.
19:34 - Now inside draw, I'm going to
draw the positions of the center
19:39 - and the position vectors
using an ellipse function.
19:42 - And the ellipse function takes
in a total of four arguments.
19:45 - The first two are going to
be the x and y-coordinates
19:47 - of the center of the circle.
19:50 - So let's do center.x, center.y.
19:53 - And this is how you can
access the x and y-coordinates
19:56 - of the vector.
19:58 - And then let's give
it a size of 10 by 10,
20:01 - and I'm going to give
it a color black.
20:04 - So nothing's new here.
20:06 - We have a circle in the
middle of the canvas.
20:08 - Let's do one more,
give it a color red,
20:11 - and ellipse of pos.x,
pos.y, 10 by 10.
20:19 - So now what I want
to do next is that I
20:21 - want to move this red circle
in the direction of where it
20:27 - is from this black circle here.
20:29 - So we have to do a few things.
20:30 - The first thing we
need to do is that we
20:32 - need to figure out what is the
direction between these two.
20:36 - So first, we're going to find
the angle between the black dot
20:40 - and the red dot here.
20:42 - We're going to be
using trigonometry,
20:44 - and I think that has many
videos on this already.
20:48 - But, essentially,
we're going to find
20:49 - that the distance between the
x-coordinates of these two
20:52 - points and the y-coordinates
of these two points.
20:55 - And then we're going to use the
inverse tangent formula to find
20:58 - the angle between the two.
21:00 - So instead of just putting
everything inside draw,
21:02 - I'm going to create
another function.
21:05 - And let's call it calcAngle.
21:08 - And the parameters for these
are going to be center and pos.
21:13 - So it's going to be the two
vectors that we have right here.
21:18 - And then I'm going
to now define x
21:23 - to be equals to
center.x minus pos.x,
21:27 - and then y to be equals
to center.y minus pos.y.
21:31 - And then angle will be equals
to inverse tangent, which
21:36 - is a tan of y divided by x.
21:42 - Now we're going to return angle.
21:45 - And we're going to be doing
this in the radians mode.
21:48 - But I'm going to change it to
degrees first because it's more
21:53 - intuitive for me to understand.
21:55 - So we're going to change it by
using the function angleMode,
21:58 - change it to degrees,
and then, inside
22:02 - draw, I'm going to call
the function calcAngle
22:07 - and put in the two
points, center and pos,
22:09 - and then we're going to
print out the result, which
22:11 - should be the angle.
22:14 - And, as you can
see here, what we
22:16 - have here is the angle
45, which is what we want.
22:20 - So where the x-axis here is 0.
22:23 - If you go clockwise,
you get 45 degrees.
22:26 - It works when we're
in quadrant 1.
22:28 - So I'm going to call this
quadrant 1, 2, 3, and 4.
22:32 - Let's try a different point.
22:35 - So what if I put
in 100, comma, 300.
22:40 - So now it is in the
second quadrant,
22:43 - but the return value
is negative 45.
22:46 - But what we want is
actually 180 minus 45.
22:51 - So we are going to be writing
a few conditional statements.
22:54 - So let's start
with the first one.
22:55 - So if pos.x is greater than or
equals to center.x and pos.y
23:02 - is greater than or
equals to center.y.
23:06 - In the case where it is
in the first quadrant,
23:09 - then we'll just return angle.
23:11 - But else if pos.x is greater or
equal to center.x and pos.y is
23:20 - less than or equal to center.y,
which is the case that you are
23:24 - seeing right here, what we're
going to return is actually--
23:27 - it's going to be, what, 180
minus absolute value of angle.
23:33 - So if we do this and I click
Run, what did I do wrong?
23:38 - Oh, so it actually is less
than or equals to center.x
23:42 - And then this is more than
or equals to center.y.
23:46 - Now we get 135 degrees.
23:49 - Now I need to do two
more cases, which
23:52 - is when we're in the third
quadrant, which is here.
23:55 - So let's do 100 by 100.
23:58 - Now it's going to be else
if pos.x is less than
24:02 - or equal to center.x
and pos.y is less than
24:06 - or equals to center.y.
24:09 - So if I just return angle,
what we get would be 45.
24:14 - But what we want is 180 plus 45.
24:20 - And then, for the last case,
which would be 300, comma, 100--
24:27 - yes.
24:28 - What we want is else if pos.x
is greater or equal to center.x
24:34 - and pos.y is less than or equal
to center.y, then return angle.
24:43 - And what we have
here is negative 45.
24:46 - But what we want is actually 360
minus absolute value of angle.
24:54 - So we get 315 degrees.
24:56 - And actually, we also want to
do this as greater than but not
25:01 - equals to for the first case.
25:03 - So that none of these
conditional statements overlap.
25:08 - And I'm going to actually
delete the angle mode here
25:11 - because I want to be
using radians right now.
25:15 - So now that we
get the angle, now
25:18 - we want to get the direction
between these two points.
25:20 - And we can actually use a
method within the vector
25:23 - class called from angle.
25:25 - So we can do that easily,
and I'm going to do it
25:28 - inside a function.
25:30 - So let's do function--
25:32 - how about calcDir for direction?
25:36 - Actually, let's do Vel because
it's going to be a velocity.
25:39 - So velocity is
speed and direction
25:42 - at which this red circle
is going to be traveling.
25:46 - And then we're going to need
two parameters, the same ones,
25:49 - center and post.
25:51 - And then how about I declare
a variable called vel?
25:55 - And to call the P5 vector method
from angle, all we need to do
26:00 - is put in P5.Vector.fromAngle.
26:04 - And we want to put in the
angle that is returned
26:08 - from the calcAngle function.
26:10 - So how about I also create a
variable called angle, and then
26:15 - let's call this function
calcAngle with two arguments,
26:21 - center and pos.
26:22 - And then we just put
in angle in here.
26:25 - And let's return--
actually, let's draw a line.
26:30 - We're going to draw a line
between center.x center.y,
26:34 - center.x plus vel.x and
center.y plus vel.y.
26:43 - I want to draw a line
between these two points.
26:46 - And inside draw, I'm
going to call calcVel.
26:50 - All right, let's delete this.
26:52 - We don't need this.
26:53 - So calcVel, and it will
be center, comma, pos.
27:02 - There's no error, but we
don't see anything right now.
27:04 - Why is that?
27:06 - Let's print what vel is.
27:08 - And as you can see here, it's
an object with three values
27:13 - x, y, and z, but we only
have two values, x and y.
27:16 - And you can see that the
values are less than 1.
27:19 - So the magnitude is very small.
27:21 - So what we want to do is
we want to actually set
27:24 - a magnitude that is greater
than what it is right now.
27:27 - So we can do vel.setMag,
and this is also
27:32 - a method within a vector class.
27:34 - How about we set it to 100?
27:36 - Uh-oh-- oh, I changed
it to the radians mode,
27:40 - but I didn't change these
values, so 180 will be pi.
27:45 - This will be pi, and
then 360 will be 2 pi.
27:51 - And now we have this line that
almost there, but not yet--
27:55 - not there yet.
27:56 - And that is because the
distance between the black dot
27:59 - and the red dot is
actually greater than 100.
28:03 - But how do we figure out
what is that distance?
28:06 - We can do that easily using a
function called dist, D-I-S-T,
28:10 - which allows us to find
distance between two points.
28:14 - And we need to put in
four arguments, the x
28:17 - and y-coordinates
of the two points.
28:18 - So center.x, center.y,
and pos.x and pos.y.
28:25 - And then we want to put
in distance in here.
28:30 - So now that we find the
direction between these two
28:33 - points, now how do
we move the red dots?
28:36 - So let's come inside
the draw function.
28:38 - And now I'm going to actually
set this function here
28:43 - to a variable called vel.
28:45 - And then, instead
of actually drawing
28:49 - the ellipse using the x
and y-coordinates of pos.x
28:52 - and pos.y, what I'm
actually going to do
28:54 - is that I'm going to use
a translate function,
28:57 - and I'm going to
translate the origin
28:59 - point from the top
left corner here
29:01 - to the point where the dot is.
29:04 - So let's do pos.x
and pos.y, and then
29:09 - now, inside the ellipse
function, I can just do 0,
29:12 - comma, 0.
29:13 - Click Run.
29:14 - You should see the exact same
thing, but the line is gone.
29:18 - And that is because vel
was not defined earlier.
29:24 - So now I want to
move the red dot.
29:28 - I want to move it in
an oscillating motion.
29:30 - An oscillating motion is
a back-and-forth motion
29:33 - between a center point.
29:34 - And that center
point is going to be
29:36 - the point where it is right
now, which is the position--
29:39 - pos.x and pos.y.
29:40 - And I want to move
it back and forth,
29:42 - and I can use a sine
or cosine function.
29:46 - So the equation will be
how I define this variable
29:49 - as oscillation or osc.
29:52 - And we're going to use--
29:54 - let's use a sine function.
29:56 - And then, inside
the sine function,
29:57 - I'm going to put in 2
pi times angle here.
30:01 - And then, what we want is
that inside here, we're
30:05 - going to translate it by
vel.x, which is a vector,
30:09 - times osc, and then
vel.y times osc.
30:17 - Let's click Run.
30:20 - Angle is not defined.
30:21 - OK, let's define angle.
30:23 - Let angle equals to 0.
30:27 - 18-- oh, I forgot to return.
30:31 - So inside here, we also need
to return the vel vector.
30:38 - OK, perfect.
30:40 - But it's not moving because
we have not incremented
30:44 - the variable angle yet.
30:45 - So how about we
increment it by 0.005?
30:53 - All right, so now,
as you can see,
30:55 - it's oscillating
around this point here.
30:58 - The original position
where pos.x and pos.y was.
31:02 - So let's just try to change
it to something else.
31:05 - Let's do 150 by 150.
31:09 - So, as you can see
here also, the closer
31:13 - it is to the black dot here,
the smaller the magnitude
31:17 - at which it is oscillating
or the amplitude.
31:20 - Perfect-- now, what
I'm going to do
31:24 - is let's change from
a circle to a letter.
31:28 - And I'm going to comment
out this ellipse,
31:31 - and we're going to be using
a function called text,
31:35 - which takes in three arguments.
31:37 - The first one is a string of
text that we want to draw.
31:40 - I'm going to just
draw a letter A,
31:42 - and then we're going to put in
the x and y-coordinates as 0, 0.
31:49 - Yay.
31:51 - Now what I want to do is
I want to align the text
31:55 - to be at the center for
both x and y direction.
32:01 - All right, so now
it's at the center.
32:03 - And we can also set the
size of this string of text,
32:07 - and we can do it using
the function text size.
32:10 - But actually, what
I'm going to do
32:12 - is I'm going to use a
function called scale.
32:14 - And I'm going to--
32:16 - how about we scale
it by, let's say, 3.
32:19 - So that's really big.
32:21 - Let's do 2.
32:23 - Now that we have
this code ready,
32:25 - why don't we put
it inside a class
32:27 - before we make a bunch of them?
32:28 - So I'm going to come to this
arrow here, click the plus sign,
32:31 - and then click Create File.
32:33 - I'm going to call
this file letter.js.
32:37 - And then before we
start writing a class,
32:39 - make sure you go to index.html
and integrate this file
32:43 - into the whole program.
32:45 - So all you need to do is copy
and paste this line of code,
32:49 - change the name here to the name
of your new file-- in my case,
32:52 - letter.js-- and now we're ready.
32:56 - All right, so inside
the letter class,
32:58 - let's start with the word class.
32:59 - Let's call it letter.
33:01 - And then we're going to
write a constructor function.
33:04 - So what do we want to put
in the constructor function?
33:07 - Let's start by going back here.
33:10 - I'm going to keep center
as a global variable.
33:13 - And so is angle.
33:15 - So this angle is actually
different from the angle
33:18 - in the calcAngle here.
33:20 - Actually, I'm going to
change the name here to theta
33:23 - so that we're not confused
that they're different.
33:26 - So the angle variable
that is global
33:29 - is the variable for moving
the oscillating motion.
33:35 - And then, now what
we need to do is
33:38 - we want pos here to be part
of the constructor function.
33:42 - So this.pos will be
equal to createVector,
33:46 - and the parameter
will be x, comma, y.
33:49 - And then I'm going to write
a method called display,
33:54 - and then we're going
to put all of this
33:57 - here inside the display method.
34:03 - And then don't forget this dot.
34:04 - So this dot-- before I change
all this dot here, let's
34:08 - put these two functions,
calcAngle and calcVel,
34:12 - inside the class as well.
34:16 - And when you put the
functions inside the class,
34:20 - you don't need the
word function anymore.
34:23 - So we can delete that--
34:24 - and here, also.
34:28 - And then, now, it's time
to put in all the this dot.
34:31 - So center is a global variable,
so we don't need that.
34:34 - We are calling the calcVel
method inside the class,
34:37 - so we need this dot as well.
34:39 - We're going to put
this dot OSC and go,
34:42 - here is the global variable,
this dot post this dot Vel,
34:46 - this.osc--
34:48 - a lot of this dot here.
34:50 - That's it for here.
34:52 - And then, under here, we
don't need this inside.
34:56 - Put in this dot,
this dot, and then
34:59 - this dot, this dot, this dot,
this dot, this dot here, here,
35:07 - and here.
35:08 - We don't need this
inside the calcVel.
35:11 - We need this.calcAngle because
we're calling the method.
35:14 - And then we don't need
the parameter here.
35:17 - This will be this.vel.
35:19 - I'm going to call this
as this.distance as well,
35:22 - and this.pos,
this.vel, this.vel.
35:28 - And we don't need
the return function
35:29 - because it's already
part of this.vel variable
35:35 - inside this class.
35:36 - I hope this is all good.
35:38 - Why don't we just
start by creating
35:39 - this one object just to make
sure that the class is working?
35:43 - So I'm going to call
this variable l.
35:46 - And l is going to be
a new letter object.
35:49 - And we need two arguments, which
is the x and y coordinates.
35:53 - And I'm going to put
it as 150 by 150, just
35:57 - like what we have here.
36:00 - Then, in here, we're
going to call the display
36:03 - method-- so l.display.
36:08 - Uh-oh, it seems like I forgot
this dot for one of them.
36:13 - And actually, Dan has a song.
36:17 - OK, one more thing
that I missed--
36:21 - 9.
36:24 - I don't think I need to
set this.vel to this.
36:27 - So we can just call
this method here.
36:31 - All right, so now we
have the same thing
36:34 - but now inside a class.
36:35 - Now we're ready to make a
bunch of letters inside a grid.
36:39 - So I'm going to
start by creating
36:40 - an array called letters.
36:43 - And then we're going to create a
few more variables, cols, rows,
36:47 - and size.
36:49 - And I'm going to set
size to 20, actually.
36:52 - And then, inside
the setup function,
36:54 - first, what I'm
going to do is I'm
36:56 - going to calculate
cols and rows here,
36:59 - which will be determined based
on width divided by size,
37:03 - and rows will be
height divided by size.
37:07 - And now we're going to store
the objects inside a 2D array
37:10 - letters.
37:11 - And I'm going to use
a nested for loop.
37:14 - So let i equal to 0, i less
than cols, i plus plus,
37:18 - and then same thing for the j.
37:21 - So let j equals to 0, j less
than rows, and j plus plus.
37:26 - Now to create a 2D array
inside the outer loop here,
37:31 - we're going to populate this
letter array with a lot of empty
37:35 - arrays.
37:35 - And then, inside here, it's
going to be letters of i
37:40 - and j is going to be
new letter object.
37:43 - But what I'm going to put here
as the x and y arguments--
37:47 - what we need is x will be equals
to i times size, because it's
37:52 - going to be spaced out
by equidistance of size,
37:56 - and then let y equal
to j times size.
38:00 - And I'm going to
put x and y here.
38:02 - Now that we create
letter objects,
38:04 - we just need to display them
using the nested for loop.
38:07 - So I'm just going to copy this
down here, delete this, delete
38:13 - this, and just call
the display method.
38:23 - Whoa, what's going on here?
38:26 - I forgot something
important when
38:27 - you use any type of
transformation functions,
38:31 - which are the two main
functions, push and pop.
38:33 - So whenever you use
transformation functions,
38:35 - you need to think
about whether you
38:37 - want to save the transformation
and then return back
38:40 - to the default mode before you
call the next transformation
38:44 - functions, which is
the case right now.
38:46 - So inside the display method
here, we call translate,
38:50 - and we call scale.
38:51 - To use the push and pop
function, what you want
38:53 - is that you want to put it
before the transformation
38:56 - functions.
38:57 - And so it is going to save
the translate position
38:59 - here and then the scale.
39:01 - And then, afterwards,
we're going to put in pop.
39:04 - So it's going to return
back to the original default
39:07 - settings, which is when
the origin point is
39:10 - at the top left
corner of the canvas
39:12 - before you call the next
transformation functions.
39:15 - So if you do this, it
should fix the issue.
39:19 - Whoa-- it's pretty cool.
39:22 - All right, I'm going to delete
or comment out these lines.
39:27 - We don't need them right now.
39:33 - So as you can see,
all the letters
39:35 - are going from whatever
the amplitude is down
39:39 - to the 0 point.
39:40 - But what if I want it to
travel at a shorter distance?
39:45 - What I can do is actually I can
just multiply this magnitude
39:49 - here by a certain scale.
39:51 - Let's do-- how about 0.3?
39:54 - So you can see that it moves
a little bit at a shorter
39:58 - distance, basically.
39:59 - Instead of putting or
hardcoding this number,
40:02 - I'm going to actually set a
variable-- this.scl, for scale,
40:07 - and put it here.
40:09 - So we can just
change it as we want.
40:14 - And then let's go
back to sketch,
40:16 - and then I'm going to put in
0.3 in the constructor function
40:21 - here.
40:22 - Now what I want to do is I'm
going to comment out this angle.
40:27 - And, as you can see,
it's not in the center.
40:30 - Actually, I need to
fix this a little bit.
40:31 - So instead of just i times
size and j times size,
40:34 - I want to also add my size
divided by 2 for both of them.
40:40 - Perfect.
40:41 - Next, we are going to
actually now draw a rectangle.
40:47 - I just want to draw a
grid so that you can see.
40:49 - So i times size, j times
size, and then size, size--
40:56 - wow, OK.
40:57 - We also want no fill.
41:01 - And how about we scale down the
letter to just 1.2, maybe, here.
41:08 - So let's do 1.2 so it's smaller.
41:12 - I want to get that
feeling of, like, a wave.
41:17 - And we can do that by
actually add a little bit
41:20 - to the simple harmonic
motion equation.
41:23 - So we can add some
shifting and go here.
41:28 - So let's call it this.shift.
41:31 - And, actually, let us try it.
41:33 - If I shift it by--
41:35 - because this is in radians
mode, so if I shift it by 0.4,
41:40 - you can see that everything
is shifted a little bit.
41:44 - So what I want to
do is that I want
41:45 - to shift it based on its
distance from the center point.
41:50 - So I'm going to define
this as this.shift.
41:54 - And this.shift will be
mapped based on the distance.
42:00 - And between the value--
42:01 - how about I just do 0 to 1,000.
42:04 - And I know for this
particular sketch,
42:06 - the canvas size is 400 by 400.
42:08 - So, actually, the distance is
not up to 1,000, but that's OK.
42:12 - You can change or play
around with these values
42:14 - to get the look
that you want later.
42:16 - But I'm going to map it to
the values 10, comma, 0.
42:21 - Let's see what happens.
42:23 - It looks a little bit wavy here.
42:25 - I don't know if you can tell,
but why don't we first move it
42:30 - and to see what happens.
42:34 - Ta-da.
42:36 - That looks really cool.
42:37 - And I can actually stop
here, but I'm not going to.
42:40 - I'm going to make it a
little bit more interesting.
42:43 - And what we can do is
how about we also change
42:47 - the size of the letter A here.
42:49 - And we can do it in
a very similar way
42:52 - by using the oscillating motion.
42:54 - So we're going to actually
create another variable.
42:57 - Let's call it this dot--
43:00 - how about fontS.
43:02 - And we're going to set
it to be equals to--
43:05 - I want it to also
oscillating back and forth.
43:09 - So this.fontS is going to be
mapped to this oscillating
43:14 - motion, which is this.osc, which
will go between negative 1 and 1
43:21 - because the magnitude is just 1.
43:24 - And I want to map it to the
values of-- how about 0.5?
43:29 - Actually, let's
do 0, comma, 1.5.
43:33 - And you can play around
with these values as well.
43:36 - And we need to make sure that
we put this.fontS in here.
43:40 - Let's see.
43:44 - Wow, OK, so because
I put in 0, you
43:48 - can see that there is a point at
which the letters just go away.
43:52 - So you can actually-- if you
don't want that, you can do,
43:55 - let's say, 0.3 maybe.
43:59 - And, actually, another
interesting thing
44:01 - that I want to show is what
if we do this.fontS and set
44:06 - it equals to this.osc, which
oscillates between negative 1
44:09 - and 1.
44:11 - Do you see that?
44:12 - The letter actually flipped,
which is an interesting look.
44:15 - So play around and
see what you like.
44:18 - I'm going to keep it as this.
44:20 - And then, now what
I want to do is--
44:24 - because we're going
to be putting it back
44:27 - with the video part, I'm going
to set the canvas size to 640
44:32 - by 480.
44:33 - And then I'm going to set
the background to black.
44:37 - And, also, we don't need
the rectangle anymore.
44:41 - And then how about
we set the color
44:44 - of the ellipse in the middle or
the center as the color white,
44:49 - and then we're going to
set the font to white.
44:57 - There.
45:00 - All right.
45:01 - So the next thing--
what we can do
45:03 - is also what if
we move the center
45:05 - based on where the mouse is?
45:07 - So inside draw,
all we need to do
45:09 - is actually just set center.x to
be equals to mouseX and center.y
45:16 - to be equals to mouseY.
45:21 - There you go.
45:25 - And remember that
a variable scale--
45:27 - that controls how much
each of the letters travel.
45:31 - I'm going to play around
with that variable
45:33 - as well inside here.
45:35 - So how about I write a
conditional statement
45:37 - that says if mouseIsPressed--
45:41 - and mouseIsPressed
is a blunt variable
45:43 - that returns true when the
mouse is pressed and returns
45:46 - false when it is not--
45:47 - we're going to change
letters of i and j.scl--
45:52 - the scale-- to 1 when the
mouse is pressed or else,
45:57 - then we're going
to set it to 0.3.
46:03 - And I have a typo
here and then here.
46:09 - Let's try that.
46:11 - So the mouse is not pressed.
46:13 - The mouse is pressed.
46:15 - The mouse is not pressed.
46:16 - The mouse is pressed.
46:21 - One last thing that I want to
do, just to add a little bit
46:24 - more complexity to this--
46:26 - so instead of just sending
it right back to 0.3,
46:29 - when you release
the mouse, I'm going
46:31 - to write another
conditional statement that
46:33 - says if letters of i and
j.scl is more than 0.3,
46:40 - then I want to slowly
reduce it by 0.01.
46:46 - Then else here--
we're going to set it
46:48 - to this, just to
keep it a little bit
46:53 - of a nicer transition.
46:55 - I don't know if you
can really notice.
47:00 - Anyway, this part is all good.
47:03 - Now we're going to put
everything back together.
47:07 - All right, so when
you were not looking,
47:08 - I have already put
Dan's code with mine.
47:11 - I didn't change anything at all.
47:13 - We just combined
the two together.
47:14 - And, as you can see,
this is not the effect
47:16 - that we're looking for.
47:18 - So let's just edit
this a little bit.
47:20 - So first, I'm going
to hide the video.
47:22 - Actually, we don't
need it at all.
47:24 - And then, what we want is that
the face is already detected.
47:30 - I want to-- actually, instead
of just using the lips,
47:33 - I'm going to get
all the keypoints
47:35 - for the whole entire face.
47:37 - So let's define a
few more variables.
47:41 - So I'm going to actually
comment out Dan's code here,
47:45 - and I'm going to define
a variable called face.
47:48 - And let's set it equals
to faces with index 0
47:51 - because we're only
detecting one face.
47:53 - Then, I'm going to set another
variable called keypoints,
47:56 - and it's going to
be just face-- which
48:00 - is faces of 0-- dot keypoints.
48:04 - And then we're going to loop
through the entire thing.
48:07 - So i is equal to 0 to i
less than keypoints.length,
48:11 - i plus plus.
48:13 - And I want to draw
all the points out.
48:15 - So we're going to use
an ellipse function, put
48:18 - in the x and y-coordinates
of all the points.
48:22 - So keypoints of i.x
and keypoints of i.y.
48:28 - And let's set the size to be 2.
48:32 - And then let's fill it
with the color white.
48:36 - Let's try that.
48:38 - Can you see that?
48:39 - You see my face in the back
there because the circle
48:44 - is kind of small, a
little bit hard to see,
48:47 - but you can see that there
are so many points on my face.
48:51 - So, next, instead of using
lips, what I'm going to use
48:54 - is that I'm actually
going to pull out
48:56 - a specific point
on the mouth here.
49:00 - And I actually happen to
know what are those values.
49:04 - So let mouthTop equals to
keypoints with the index of 13.
49:11 - And let mouseBottom to be
equals to keypoints of index 14.
49:18 - And then let's just
draw these points out.
49:21 - So mouthTop.x, mouthTop.y--
let's do 10 by 10.
49:28 - Same thing for the bottom.
49:32 - And then let's color it white.
49:37 - Oops-- keypoints.
49:42 - You see the point on
my lips, on my mouth?
49:46 - Perfect.
49:47 - Now what I want, actually,
is the center point
49:51 - between these two points.
49:52 - And I'm going to define
some variables up here.
49:57 - I want to define mouthX, mouthY,
and mouthW for the width.
50:05 - And down here, what
I'm going to do
50:09 - is I'm going to calculate mouthX
to be equals to mouthTop.x
50:16 - plus mouthBottom.x divided by
2, and same logic for mouthY.
50:29 - And then let's just draw
out a circle for this point.
50:36 - mouthX, mouthY, 10 by 10--
50:41 - and we can draw it.
50:42 - We can put this back as well.
50:45 - And you can see, there's
the middle point there.
50:49 - And why am I doing this?
50:51 - I want to actually control
this instead of with the mouse
50:56 - location, but with
our mouth location.
51:00 - So now what we're going
to do is I'm going
51:03 - to comment out these 2 again.
51:05 - And then, instead of
sending center.x to be this,
51:09 - it's going to be
mouthX and mouthY.
51:17 - So you can see that
it's tracking the face.
51:22 - But if I open the mouth,
it doesn't do anything yet.
51:26 - But let's make it do something.
51:29 - So how about we set mouthW to
be equals to-- the calculation
51:34 - would be mouthBottom.y
minus mouthBottom.x.
51:42 - And I'm going to print this
out so you can see the value.
51:45 - So mouthW-- oh, it's
negative because it
51:51 - should be top minus bottom.
51:55 - Well, I did this wrong.
51:58 - It's mouthBottom.y
minus mouthTop.y.
52:07 - See, as I opened my mouth,
the value increases.
52:11 - So we can just set a threshold
at which we want to call this.
52:15 - So how about when I open my
mouth, it goes up to, like,
52:20 - 40-50 here, so we can just do--
52:23 - what did we just do 40?
52:24 - And where are we
going to put it--
52:25 - we're going to put it in
this conditional statement.
52:28 - Instead of mouseIsPressed,
we're going to do if mouth of W
52:33 - is greater than 45, maybe.
52:37 - Let's run.
52:41 - And there you go.
52:42 - So we're going to bring Dan
back so that he can play around
52:47 - with this sketch.
52:50 - Whoa.
52:55 - I love how you're drawing
all the points of the face,
52:57 - like, very subtly there.
53:00 - And then that's
the center point.
53:04 - Ah, OK, my mouth
didn't open as wide.
53:07 - [LAUGHTER]
53:08 - I just decreased this.
53:09 - Let's do 30.
53:16 - That is really fun.
53:18 - I wanted to check how--
53:21 - one thing I was curious about--
53:23 - I'm just looking
at your code here.
53:25 - So, ah, I see-- so you
pick specific points,
53:28 - and then you found
the top and the bottom
53:32 - and then average them.
53:34 - So it's interesting--
I'd be curious to see
53:37 - if we use the lips object,
which analyzes the lips
53:40 - and, in theory, finds
the center, if that's
53:43 - the same point or
a different point.
53:45 - But it's good to
see this technique.
53:49 - It'd be interesting to think
about what other kinds of text
53:52 - you could put in here.
53:53 - It's all the letter
A, but you could
53:54 - imagine this being like
a poem or it somehow
53:57 - is changing as you're
interacting with it.
53:59 - It's also maybe
something to consider
54:00 - as adding the lerp function
because, sometimes,
54:03 - the points that come for
the model-- it's actually
54:05 - quite smooth, but it's
a little bit jittery.
54:07 - And the lerp
function is something
54:09 - that anybody who's
watching could
54:10 - try to add for some smoothing.
54:13 - Amazing.
54:14 - Thanks, everybody, for watching.
54:16 - Thank you, Patt, so much for
demonstrating this project.
54:19 - Hopefully, you've gotten
both now a nice introduction
54:23 - to the new ml5.js library, and
I hope you try that out, as well
54:27 - as seeing how you could take a
creative computational design,
54:32 - which there are many,
many to choose from,
54:34 - from all of Patt's videos that
encourage you to go and check
54:37 - out and see how you
might combine them
54:39 - with interactivity from
the FaceMesh model,
54:42 - but you can also try
HandPose or BodyPose.
54:45 - And this video will be included
on the Coding Train website
54:49 - with the Passenger
Showcase page.
54:51 - So if you make something based
on this video, please share it.
54:55 - Don't forget to check out
Patt's channel and subscribe.
54:59 - And I'll see you next
time on The Coding Train.