00:00 - It's frozen.
00:01 - No.
00:01 - No.
00:02 - No.
00:02 - No, wait.
00:03 - Please, I don't want
to lose all my code.
00:04 - [SOMBER MUSIC]
00:06 - Oh, god.
00:07 - [MUSIC PLAYING]
00:12 - Hi, everyone.
00:13 - It's Pi Day.
00:14 - I've been making videos
to celebrate the number
00:16 - pi on March 14 for quite
a number of years now.
00:19 - Typically, I'll
do something where
00:21 - I'm trying to approximate
the number of pi,
00:24 - or even do some kind
of visualization
00:26 - of the digits of pi itself.
00:29 - This year, I'd like
to just celebrate
00:31 - the circle for Pi Day.
00:34 - I've been working very hard on
the new version of The Nature
00:39 - of Code book, published
by No Starch Press,
00:42 - coming out this summer.
00:43 - Pre-order today.
00:44 - Read the whole thing online
today for free as well.
00:48 - And my coding challenges in
2024 have been extensions
00:53 - of topics in that book.
00:55 - So I thought for
today I'd like to take
00:58 - a look at a particular fractal
pattern called the Apollonian
01:02 - gasket.
01:03 - When I first saw this,
I thought, great,
01:05 - this could be a nice extension,
exercise, additional example
01:09 - for chapter 7 in The Nature Of
Code book, all about fractals.
01:12 - It'll be easy.
01:13 - See now, you draw a circle in
P5 and do a little recursion.
01:16 - You put some other circles.
01:17 - I've also done videos on
circle packing before.
01:20 - Easy peasy, lemon squeezy.
01:22 - No problem.
01:23 - I like to not try to do
too much before I come here
01:26 - and record the coding challenge.
01:28 - But you know, I should do a
little reading, reading up
01:31 - on what the
Apollonian gasket is,
01:33 - its history, what's
the math behind it.
01:36 - There's a wonderful article
here by Dana Mackenzie
01:39 - in American Scientist that
was a terrific reference.
01:43 - This set of blog posts
from the Math Less Traveled
01:47 - from 2016 on the Apollonian
gasket was very helpful.
01:52 - I wandered into this paper
called Beyond the Descartes
01:55 - Circle theorem.
01:57 - And then I started to realize--
02:00 - oh, no-- oh, no--
02:03 - this is going to be a lot
harder than I thought.
02:06 - But guess what?
02:07 - Bonus for you.
02:09 - In this video, you will learn
about not just the position
02:12 - and radius of a
circle, but something
02:14 - called the curvature
or the bend and how
02:17 - that relates to something
called the Descartes theorem.
02:21 - And then I might even wander
into using the Descartes
02:25 - theorem, but applying
it not just with numbers
02:28 - but with complex numbers,
imaginary numbers.
02:31 - And so we're going to have to
solve/use the complex number
02:36 - Descartes theorem.
02:37 - This is probably going
to go off the rails.
02:40 - But if I can make that
Apollonian gasket fractal,
02:44 - hopefully you'll have learned
something new about math.
02:47 - And you might be inspired to
make your own artistic version
02:50 - of this fractal,
varying it with color
02:52 - or some other kind of shape, or
tweaking the algorithm however
02:54 - you want.
02:55 - And muah, won't that be
a wonderful celebration
02:58 - of Pi Day.
02:59 - Strangely enough, this all
begins with a poem, a poem
03:04 - by Frederick Soddy, an English
radiochemist who won the Nobel
03:09 - Prize for chemistry in 1921.
03:12 - Frederick Soddy was
fascinated with something
03:15 - called Apollonius' problem,
named for Apollonius of Perga,
03:20 - the Greek astronomer.
03:21 - Let's say you have three
circles, any three circles,
03:26 - non-overlapping.
03:29 - How could you find
a fourth circle
03:33 - that is tangent to all
three of these circles?
03:37 - Two circles are tangent if
they meet at a single point
03:41 - along their edges.
03:44 - And that tangent can
be expressed as a line.
03:47 - This is actually referred
to as a kissing circle
03:51 - because they're like,
[KISSING SOUNDS]
03:52 - I love you circle.
03:54 - And there typically
isn't just one solution
03:57 - to the Apollonian problem.
03:58 - Let me try to draw one in here.
04:01 - No I can't.
04:02 - I'm not really drawing
this correctly,
04:04 - but you get the idea.
04:05 - Maybe I could also--
04:06 - could I get a circle
that kind of like--
04:10 - This is also tangent to
this circle, this circle,
04:15 - and this circle.
04:16 - The solution to this
problem lies in something
04:19 - called Descartes' theorem.
04:24 - Soddy rediscovered Descartes'
theorem independently in 1936.
04:29 - Found it so beautiful, he
wrote an entire poem about it.
04:33 - The Kiss Precise.
04:35 - For pairs of lips to kiss
maybe involves no trigonometry.
04:41 - 'Tis not so when four circles
kiss, each one the other three.
04:46 - To bring this off the four
must be as three in one or one
04:51 - in three.
04:52 - Since zeros bend's a dead
straight line and concave bends
04:57 - have minus sign, the sum of
the squares of all four bends
05:02 - is half the square of their sum.
05:05 - Kiss the other four the square
of the sum of all five bends
05:10 - is thrice the sum
of their squares.
05:16 - So the problem of Apollonius
is for any three circles.
05:20 - But Descartes's theorem, and
as it relates to the Apollonian
05:24 - gasket, is actually
a problem that's
05:26 - for a more specific scenario,
where the original three
05:30 - circles are mutually tangent.
05:34 - I'm going to begin by drawing
a kind of classic example
05:36 - of three mutually tangent
circles that is symmetrical.
05:40 - And this is going
to be terrible,
05:41 - but I'm going to do my best.
05:45 - The first thing that I need to
define for Descartes' theorem
05:49 - is this idea of the
curvature of a circle.
05:54 - Now the curvature is the
inverse of the radius.
05:58 - A smaller circle is going to
have a much tighter curvature,
06:02 - whereas a bigger circle has
a much wider curvature to it.
06:06 - So curvature,
typically written as K,
06:10 - is equal to 1 divided by
the radius, and vice versa.
06:15 - The radius is equal to 1
divided by the curvature.
06:18 - Now the curvature,
however, is signed.
06:22 - It can be positive or negative.
06:25 - The radius, of course,
is always positive.
06:28 - So we might say, the radius
is equal to the absolute value
06:33 - of 1 over the curvature.
06:35 - Now what makes the curvature
positive or negative?
06:38 - I mean, all the circles,
they bend the same direction.
06:41 - Well, this particular circle,
which is an outer circle--
06:46 - it is enclosing
these two circles--
06:49 - has a negative curvature,
whereas these two circles here
06:54 - have a positive curvature.
06:58 - If I were to draw three
mutually tangent circles where
07:02 - none of them enclose each
other, they would all
07:04 - have a positive curvature.
07:07 - Here are three mutually
tangent circles,
07:10 - all with a positive curvature.
07:13 - So what is Descartes' theorem?
07:15 - And how does it relate
to the Apollonian gasket?
07:19 - The process for drawing
the Apollonian gasket
07:22 - is to start with your three
mutually tangent circles
07:27 - and find their fourth,
the kissing circle.
07:31 - What is the fourth
circle that is mutually
07:34 - tangent to all three of these?
07:36 - Well, once again, there's
more than one possibility.
07:40 - Now if I found
those two, what if I
07:44 - took all the triplets that
are available to me here
07:48 - and found the fourth
mutually tangent circle that
07:51 - goes with those?
07:53 - Maybe I'd find one here, and
here, and here, and here.
07:58 - And then I might find one here,
and here, and here, and here.
08:04 - So I've done a rather poor
job at drawing the Apollonian
08:08 - gasket.
08:09 - But you see how
you are recursively
08:11 - finding the next circle
and the next circle that
08:14 - is mutually tangent to
triplets, the triplets
08:18 - that you're creating through
this recursive process.
08:20 - Descartes' theorem is
expressed in the poem
08:23 - as the sum of the
squares of all four bends
08:27 - is half the square of their sum.
08:32 - So if this is
circle 1, 2, 3, how
08:37 - do I find circle 4
that's inside there?
08:42 - The sum of the squares
of all the bends
08:49 - is equal to 1/2 of the
square of the sums.
08:56 - So if I could somehow
take this equation,
08:59 - knowing the curvature
for circles 1, 2, and 3,
09:05 - could I solve for curvature 4?
09:08 - K4 equals what?
09:11 - This is a quadratic equation.
09:13 - It can be solved.
09:14 - It will, as you see,
have multiple solutions.
09:17 - I'm not going to
derive the solution.
09:19 - But I will put a
reference-- hopefully
09:22 - I can find one-- that shows
the derivation of the solution.
09:25 - Let me show you what it is.
09:27 - Curvature 1 plus curvature 2
plus curvature 3 plus or minus
09:33 - multiple solutions the square
root of K1 times K2 plus K2
09:40 - times K3 plus K1 times K3.
09:44 - No more question mark.
09:46 - So this is now something
we can actually
09:50 - start to implement in our code.
09:53 - Whoops, I forgot
about the 1/2 here.
09:56 - So plus or minus 2 times the
square root of this summation.
10:02 - How long has it been
in this video and I
10:03 - haven't written any code yet?
10:05 - Don't worry.
10:06 - Now's the time.
10:07 - The first thing that
I want to do for this
10:09 - is create a circle class.
10:11 - The circle class will hold on
to the position of the circle,
10:14 - its radius, and its curvature.
10:20 - So if I'm giving it a bend, its
radius is the inverse of that,
10:25 - or the absolute value
of the inverse of that.
10:28 - Let's write a function
for the circle
10:30 - to draw itself, make sure
I add it to the HTML file.
10:37 - And let's create three circles.
10:40 - What should their curvatures be?
10:43 - Well, on this diagram of
the Apollonian gasket,
10:46 - this is one of my circles,
this is one of my circles,
10:50 - and the big circle
is one of my circles.
10:53 - So if the radius of this
circle was something like 200,
10:57 - the curvature would
be 1 divided by 200.
11:00 - But remember, the
outer one is negative.
11:03 - And then the inner
ones would have
11:04 - a curvature of 1 divided by
100, 1 divided by 100 if they're
11:08 - half and they're positive.
11:10 - So the curvature is
negative 1 divided by 200.
11:14 - And it's x, y is at 200, 200.
11:16 - And I'm just hard
coding this now.
11:18 - Later, it's my goal to create
a random arrangement of three
11:22 - mutually tangent circles.
11:24 - We'll see how well that goes.
11:26 - But I'm just going to hard
code an initial location that
11:28 - is kind of a classic version
of the Apollonian gasket.
11:36 - Where are those circles?
11:38 - Oh, I have the
background in draw.
11:41 - Let's get rid of that.
11:43 - There we go.
11:44 - There are those three circles.
11:46 - Now let's see if I can
write a function that
11:50 - will calculate that fourth
curvature, passing in the three
11:55 - circles.
11:58 - And eventually I
might want to work
11:59 - with arrays and kind of store
the circles in different ways.
12:02 - But this should be good
enough to get me started.
12:04 - Now it's time for me to take
that formula on the whiteboard
12:07 - and implement it here.
12:09 - So first, let's get K1, K2, K3.
12:15 - Let's divide the
formula into two parts.
12:18 - First, the sum.
12:21 - Let's call the second part--
12:23 - I don't know-- the
root because it's
12:25 - the square root of the products
of the different curvatures.
12:31 - And I need to multiply it by 2.
12:33 - And now I need to return the
sum plus or minus the root.
12:38 - How do I return a
value plus or minus?
12:40 - Well, I could just
return both values.
12:43 - Let's at least see if
the radius that I'm
12:47 - getting back from
the function is
12:49 - approximately the right side.
12:50 - I mean, the really
complicated part here,
12:52 - that I'm going to
get to soon enough,
12:54 - is to figure out
where the circle goes.
12:57 - But for right now, all I need
to do is check the radius.
13:00 - So radius 4 is
the absolute value
13:03 - of 1 divided by the
fourth curvature.
13:06 - And if I were to just
draw a circle at mouse x,
13:09 - mouse y with radius 4 times 2--
13:12 - and I guess I need to
put this into draw.
13:17 - And these circles will need
to be global variables.
13:24 - What am I missing here?
13:27 - Not a number.
13:30 - Oh, right, of course.
13:33 - I've got to pick one of them.
13:34 - I went through this
whole thing about how
13:36 - I'm returning two values.
13:37 - And I need to have two r4s.
13:40 - So r4 could be--
13:42 - let's just pick 0.
13:43 - Let's just pick
that first value.
13:45 - And we can see, does
this circle fit there?
13:47 - Look, it fits there.
13:49 - So I definitely got
the radius right.
13:50 - Let's look at the second value.
13:53 - Second value is also the same.
13:55 - So that's good to see
that I'm getting both.
13:59 - The correct values,
probably one is
14:01 - going to go down here somehow.
14:03 - And one is going to go up here.
14:06 - So if I have a function--
it's called Descartes here--
14:08 - and it returns the curvature
for all possible fourth circles,
14:14 - all I need next
is a function that
14:18 - returns the position
of that fourth circle
14:21 - or all possible fourth circles.
14:23 - This is where things get
a little bit extra hairy.
14:27 - The solution to finding the
centers of those circles
14:31 - is in this paper Beyond the
Descartes Circle theorem.
14:36 - Right here at the
beginning, you can
14:37 - see how the authors are
referencing the Descartes
14:40 - theorem.
14:41 - The bends, the curvatures,
satisfy the relationship
14:45 - where the sum squared equals 2
times the sum of the squares.
14:50 - In this paper, they
show if you take
14:53 - the centers of those
circles, express them
14:57 - as complex numbers, they also
have the same relationship,
15:03 - essentially yielding what could
be called the complex Descartes
15:08 - theorem.
15:09 - Now I'm not going to
prove this or derive this.
15:12 - If you want to go
deeper into the math,
15:14 - this paper will
have that for you.
15:16 - But let me just explain to
you what a complex number is
15:20 - and how I can take
the Descartes theorem
15:24 - and solve for an x-y pair
instead of a single curvature
15:29 - value.
15:30 - A complex number
is a number that
15:32 - has a real component and
an imaginary component.
15:36 - What do I mean by imaginary?
15:38 - Well, hold that thought.
15:39 - It's written in
the form a plus bi.
15:44 - And "i," like imaginary,
is a representation
15:48 - of the square root
of negative 1.
15:52 - Now the last time I probably
referenced complex numbers was
15:56 - maybe in my Mandelbrot set
coding challenge or perhaps
16:00 - the Julia set coding challenge.
16:02 - And remember how I
was really in love
16:04 - with talking about
imaginary numbers
16:06 - and playing around with the
idea of them being imaginary.
16:08 - But it's a little
bit of a misnomer.
16:11 - This is very much a
number, a kind of number
16:15 - incredibly important
in all sorts
16:18 - of applications of mathematics.
16:20 - And it is necessary when
solving certain kinds
16:26 - of polynomial
equations, especially
16:29 - if you've got something like
x squared equals negative 1.
16:33 - How do we express the solution
for an equation like that?
16:37 - What is kind of magical here
is because a complex number
16:42 - has two components, A and bi.
16:46 - This a and this b can
be mapped to what's
16:50 - called the complex plane.
16:53 - This might be a-axis.
16:55 - This might be the b-axis.
16:57 - So if I put a point over here,
maybe it's the point 5 plus 4i.
17:05 - Well, this might look
kind of similar to you.
17:08 - I mean, aren't we
in a p5 canvas?
17:11 - And maybe I have
this point here,
17:14 - which is the x-y
point, 200, 200.
17:18 - Why not express that
as a complex number
17:21 - where x is the real
component and y
17:25 - is the imaginary component?
17:26 - So this point could be
expressed as 200 plus 200 i.
17:33 - So this is the
Descartes theorem,
17:37 - which expresses the relationship
between the curvatures of four
17:42 - mutually tangent circles.
17:43 - Well, it so happens, if I
think of the centers of all
17:49 - of those circles expressed
as a complex number--
17:53 - maybe I'll call
them z1, z2, z3, z4,
17:58 - each of these being of the
format x plus yi, x plus yi.
18:05 - This would be x1 plus
y1i, x2 plus y2i.
18:08 - The same equation applies if
I take those complex numbers
18:14 - and multiply them
with the bends.
18:17 - So in other words, the product
of the bends and the centers
18:21 - satisfy this exact equation.
18:24 - Let me try to write this out.
18:26 - Z1 squared times K1 squared.
18:37 - This is the new equation.
18:38 - So what's known?
18:40 - I know z1, z2, z3.
18:44 - I know all of the curvatures.
18:46 - I even know k4 because
I was able to solve
18:49 - for the fourth curvature through
the regular, old-fashioned
18:52 - Descartes theorem.
18:53 - So now all I need to
do is somehow solve
18:57 - this equation for z4.
19:00 - Again, not going to
derive the solution.
19:03 - I'm just going to
write it out for you.
19:05 - Here we go.
19:07 - I just spent some time
staring at the Wikipedia page.
19:10 - We'll see if I remember it.
19:11 - z4 equals the sum of the
bends times the circle
19:18 - centers plus or minus the square
root of the products of all
19:27 - that stuff, like before.
19:29 - [LAUGHS] I got to
go look at it again.
19:31 - The curvatures times the
centers plus the curve--
19:35 - all the configurations.
19:37 - Plus or minus 2 times the
square root of z1k1 times z2k2.
19:44 - I'm just going to write it
this way k1 times k2 times
19:47 - z1 times z2 plus--
19:50 - oh, no, I'm going
to run out of room--
19:53 - plus k2k3.
19:59 - Oh, no, no plus there.
20:00 - These are all multiplied.
20:02 - Then the whole thing divided
by the fourth curvature
20:08 - because, remember, we're kind
of solving for what's over here.
20:11 - So this whole thing
divided by k4.
20:15 - So all we got to do is put
this formula into our code.
20:21 - Easy peasy, lemon squeezy.
20:24 - We've got a bit of
a problem, though.
20:26 - Look at my beautiful function
for the Descartes theorem.
20:30 - It uses the plus operator,
and the multiply operator,
20:34 - and the minus operator, because
I'm just taking a number
20:38 - and multiplying it by a
number, and another number,
20:40 - and adding it to a number.
20:41 - You can't do that so easily
with complex numbers.
20:45 - In fact, I'm using the
square root operator.
20:50 - How do you take the square
root of a complex number?
20:53 - This is going to
require at least 5
20:56 - to 10 minutes of this video,
just to implement that math.
20:59 - And the way that
I'm going to do it
21:01 - is much like there's a
p5 vector class in p5,
21:06 - which stores an x
and a y and performs
21:08 - all sorts of vector math.
21:10 - I'm going to create a
complex number class.
21:12 - And I'm sure I could
use one-- like get one
21:14 - from some JavaScript library.
21:16 - But I think it's
worth just quickly,
21:18 - "quickly" implementing my own.
21:25 - So this is the core idea
of a complex number.
21:28 - I need to have both
the real component
21:31 - and the imaginary
component, a and b.
21:33 - The first thing that I might
do is write an Add function.
21:37 - And I think what
I'll do for ease
21:38 - is every single
one of my functions
21:40 - will return a new
object instance.
21:43 - So let's start with
the Add function.
21:45 - That's the easiest one.
21:47 - And I'll use the word "other"
for another complex number.
21:51 - So what do I need to do?
21:52 - Return a new complex
number, which
21:55 - is this dot a plus
other dot a and this
21:59 - dot b plus other dot b.
22:02 - This is adding two
complex numbers together.
22:05 - Let's do a subtract.
22:07 - Let's do a scale, which is
different than multiply.
22:11 - I'll get to that in a second.
22:13 - But let's say I want to just
take a complex number and--
22:16 - I don't know-- multiply it by 2?
22:18 - So I'm scaling it by a value.
22:21 - And that is a new complex
number with this dot a times
22:25 - that value and this
dot b times that value.
22:29 - I'm doing the easy ones first.
22:31 - OK.
22:32 - Let's do multiply.
22:34 - This is where things
get a little bit tricky.
22:36 - And we need to return
back to the whiteboard.
22:38 - Now you might be wondering, why
can't you just use p5 vector?
22:41 - After all, you're
storing a complex number,
22:43 - like you're storing a vector.
22:45 - And p5 vector
already has functions
22:47 - like multiply and add.
22:48 - And this is why.
22:50 - It's this pesky little square
root of negative 1 thing.
22:54 - So let's work out the math.
22:55 - And I've done this before, I
think, in the Mandelbrot video.
22:57 - But let's do it again.
22:59 - A1 plus b1i times a2 plus b2i.
23:07 - This would be multiplying
two complex numbers together.
23:10 - So a1 times a2 plus a1
times b2i plus b1 times a2y.
23:23 - So I'll say a2b1i.
23:27 - Did I say "y" when
I meant to say "i?"
23:29 - And this is b1--
23:31 - oh, this is hard--
23:32 - plus b1b2i squared.
23:37 - Remember, i is the square
root of negative 1.
23:39 - So what's i squared?
23:41 - Negative 1.
23:42 - So this is actually a1a2 minus--
23:47 - this turns into a minus
because I take i squared--
23:52 - minus b1b2 plus-- look at this--
23:57 - a1b2, a2b1i-- a1b2 plus a2b1i.
24:06 - So this is my new
complex number.
24:10 - This is the real component.
24:12 - And this is the
imaginary component.
24:15 - This is how I multiply two
complex numbers together.
24:19 - Now when I go back to
the code, remember,
24:21 - it's not a1, b1, a2, b2.
24:24 - It's this dot a, this dot
b, other dot a, other dot b.
24:29 - Let's see if we can
make that happen.
24:30 - Now let's do multiply other.
24:33 - So let's just say the
a is this dot a times
24:39 - other dot a minus this
dot b times other dot b.
24:45 - And then the b is this dot a
times other dot b plus other
24:57 - dot a times this dot b.
25:00 - Then I'm returning
a new complex number
25:02 - with those a and b values.
25:04 - I have a plus for
complex numbers.
25:07 - I have a scale for
complex numbers,
25:08 - for a complex number
times a scalar.
25:10 - I have a multiply now.
25:12 - I don't have a square root.
25:14 - How do I do the square
root of a complex number?
25:17 - I think that since this
is a video for Pi Day,
25:20 - we should use this
formula because it's
25:24 - taking the complex
number and converting it
25:26 - from rectangular
form to polar form.
25:30 - So the idea here for
taking the square root
25:33 - is if this complex
number, instead
25:37 - of thinking of it
as a comma b, I
25:40 - think of it in its polar form,
where I have some magnitude--
25:44 - I'll call that m--
and some angle--
25:46 - I'll call that theta.
25:47 - Well, if I take this, I
can find the square root
25:51 - by taking the square root of
the magnitude and then half
25:56 - the angle.
25:57 - That works out.
25:59 - So in my code, square root.
26:02 - I first need to convert
the complex number
26:06 - to its polar form.
26:07 - So in that sense, I would
say let m, its magnitude,
26:12 - equal the square root of
a times a plus b times b.
26:16 - Then its angle-- and
this, by the way,
26:17 - is where I could use p5 vector.
26:19 - Its angle is equal to a tan
2, the inverse tangent--
26:24 - this function is beautiful--
26:26 - I've explained it in Chapter
3 of Nature of Code--
26:28 - happy Pi Day, everybody--
26:30 - of b comma a.
26:32 - That would be the angle.
26:34 - Then I need to say,
the new magnitude
26:40 - is the square root
of that magnitude.
26:43 - The new angle is that
angle divided by 2.
26:46 - And then I can just say,
return a new complex number
26:52 - with m times cosine of
that angle, m times sine
26:57 - of that angle, converting it
back to its nonpolar form.
27:03 - If you don't want
to rely on my code,
27:05 - you could use this
Complex.js library,
27:09 - which has a lot of
complex number arithmetic
27:11 - already done and
completed in JavaScript.
27:13 - I should probably be using it.
27:14 - But, you know, I like
to learn this stuff,
27:16 - like get my hands in
as much as possible.
27:18 - Now that I have a fully
functional complex number
27:22 - class, I can adjust
my circle class
27:26 - to store the x-y center
in a complex number.
27:30 - I'll call that center.
27:34 - What broke here?
27:35 - Oh, it's a and b.
27:38 - There we go.
27:38 - OK.
27:39 - I am ready to implement
the complex Descartes
27:44 - function, which
will take in three
27:47 - circles plus the curvature
for the fourth circle
27:52 - and calculate the x-y position
of that fourth circle.
27:59 - And I'll use that
same notation with z.
28:04 - All right.
28:05 - I need the sum and
the root again.
28:09 - But I have to use the
complex number math.
28:13 - And actually, if I'm looking
at this formula, z1 through z3
28:17 - are only ever used
in combination
28:20 - with multiplying it by their
corresponding curvature.
28:25 - I'll call it zk1.
28:26 - So zk1 is equal
to z1 scale by k1.
28:31 - OK, so let's do that.
28:33 - Zk2, zk3.
28:36 - Then the sum is equal
to zk1 add zk2--
28:43 - and I can chain these--
28:45 - add zk3.
28:46 - So this right here should be
now this part of the formula.
28:54 - Next, I want to do this
part of the formula.
28:58 - So the root is equal to
zk1 multiply zk2 add--
29:06 - oh, god-- zk2 multiply
zk3 add zk1 multiply zk3.
29:23 - OK?
29:24 - I think that's right.
29:25 - So this-- I know
it's a little bit
29:27 - hard to look at--
but this should
29:30 - be everything that's in here.
29:33 - Now I just need to take
the square root of that
29:36 - and multiply it by 2.
29:37 - So I should say root
equals root square root.
29:44 - And then I need to
multiply that by 2.
29:47 - And then I need to
get the plus or minus.
29:52 - So I have two options.
29:53 - Remember down here when
life was so simple,
29:56 - I just said some plus
root or some minus root.
29:59 - So those are my two options.
30:01 - I have some add root
or some subtract root.
30:07 - But then I also need to
divide both of those by k4.
30:11 - So that would be, scale
those by 1 divided by k4.
30:15 - These are my two
possible complex numbers.
30:20 - All right.
30:21 - One issue right now is that
k4 is actually two values.
30:26 - So let's pick one of them.
30:29 - I need the center
for the new circle.
30:32 - We'll call that z4, should
equal complexDescartes
30:36 - c1, c2, c3, k4 index 0.
30:41 - So I'm just going
to pick it with one.
30:43 - And then I should be able
to say z4 dot a, z4 dot b.
30:48 - Oh, what's the chance?
30:49 - What's the chance that works?
30:51 - Darn.
30:52 - Oh, well, that needs an s.
30:56 - Oh, this dot.
30:57 - This dot.
30:58 - It's been a while since I
made a good this-dot mistake.
31:03 - OK, I still have
an error down here.
31:06 - OK, console.log z4.
31:09 - Let's see what we got here.
31:10 - oh, because I got two of them.
31:12 - I forgot that I'm getting
two for everything.
31:15 - And let's look at both of them.
31:17 - Let's put in no loop.
31:19 - Not a number, not a number.
31:22 - OK, so something
went wrong somewhere
31:24 - with my complex number math.
31:26 - Probably, this is
a good reason why
31:27 - I should have just used
an existing complex number
31:29 - JavaScript library.
31:31 - But let's see what
I can figure out.
31:33 - Oh, mult, mult. It's scale by 2.
31:36 - It's not multiply by 2.
31:38 - It's scale by 2.
31:40 - There we go.
31:41 - Look.
31:41 - Look.
31:42 - There's a circle
in the right place.
31:44 - I've never been so happy
to see that before.
31:47 - Woo, that was exciting.
31:48 - OK, we're getting somewhere.
31:50 - It was just a simple error.
31:51 - I used multiply instead
of scale because it's
31:53 - scaling by a scalar
not multiplying
31:55 - by a complex number.
31:56 - I really should be now
finding both circles.
32:01 - I guess I could return
two complex numbers.
32:04 - What if I give it k4 that's
an array with two options.
32:09 - And then my complex--
32:11 - oh, my god. oh, but I'm
already getting two back.
32:15 - Wow, so there's actually
four possibilities.
32:17 - Let's just do it twice.
32:19 - So let's get z4.
32:21 - I'll call it z40.
32:23 - And I'm going to send in k4 0.
32:25 - Oh, look at this.
32:26 - Look at this.
32:27 - I had a mistake there.
32:29 - I put a 4 instead of the k4.
32:31 - But now that I'm
realizing it, it
32:33 - would make more sense to
just return all four of them
32:37 - as an array.
32:38 - Let's see.
32:39 - So now I can put this one in
here with add and this one
32:43 - in here.
32:44 - So I can get all
four in this way.
32:48 - So I think this is going
to make more sense,
32:50 - that basically I'm getting the
two components of the formula,
32:54 - the sum and the root.
32:56 - Then I'm going to
plus and minus those.
32:59 - So I have two possibilities.
33:00 - And then divide it by
both k4 0 and k4 1.
33:03 - This is much better because
this is just giving me all four.
33:07 - And now I can actually
just say this.
33:09 - And this is kind of
like all centers.
33:12 - All centers is the result
of the complex Descartes
33:16 - function with all three circles
and both possible bends.
33:20 - And I wonder if what I can
do is like unpack those.
33:25 - I've got an idea.
33:26 - I want it an array
because I'm going to say,
33:28 - let c of allCenters.
33:30 - And then what am I going to do?
33:32 - I'm going to make a new
circle, equals a new circle
33:37 - with k4 index 0.
33:40 - Do I do all the [INAUDIBLE]?
33:42 - I'm so lost here.
33:43 - This isn't going to work.
33:44 - You know what I should do?
33:46 - Let's actually make the circles
in the complex Descartes
33:50 - function because I
need to know which
33:53 - bends go with which circles.
33:55 - So if I go back here.
33:57 - What I'm actually doing
is I have four centers.
34:03 - I'll call those c1.
34:07 - Those are all my centers.
34:10 - Oh, I already used
that variable.
34:12 - OK.
34:13 - Now I need to return an
array of four circles.
34:19 - New Circle k4 0 with
cente1.a, center1.b.
34:27 - So k4 0 goes with
these first two.
34:32 - And these go with one.
34:36 - These are all the possibilities.
34:38 - So now I'm actually
returning the four circles.
34:41 - Where I got them-- now I should
be able to say, allCircles--
34:44 - I could obviously
loop through it.
34:46 - But I just want to look
at them one at a time.
34:48 - 0 dot show.
34:50 - That one.
34:52 - All circles one dot show.
34:54 - That one.
34:55 - Hey, those are the
right two circles.
34:58 - So then-- I don't
want the other two.
35:02 - Oh, that one's maybe
one of the same ones?
35:05 - Oh, actually, maybe I'm fine.
35:06 - They're just duplicates.
35:09 - Good work, everybody.
35:10 - They're duplicates.
35:11 - I think that I am through with
the hardest part of this video,
35:15 - which was all of this math.
35:17 - And now the problem
becomes, once I have the two
35:22 - new circles, I just
need to look at all
35:25 - of the new triplets of three
mutually tangential circles
35:30 - and get the next new circles,
and so on and so forth.
35:35 - This is where the
recursion comes in.
35:37 - This is where I'm more
connected to chapter
35:40 - 7 of The Nature of Code.
35:41 - Now recursion can be done
with a recursive function.
35:45 - And that's what I use in many
of the fractal designs that
35:48 - are outlined in that chapter.
35:50 - What I think I'd like
to do here instead,
35:53 - though, is use an array as
the kind of foundational data
35:57 - structure for the recursion.
35:58 - So if I somehow
had an array acting
36:01 - as like a queue of all
of the possible triplets
36:04 - that I need to evaluate, then
I could run through all those,
36:08 - throw it away, make a new
queue, and keep going.
36:12 - So essentially the
array is the recursion.
36:15 - Everything in the array
will get processed,
36:17 - which will make a new array,
which will get processed,
36:19 - which will make a new array,
which will get processed.
36:21 - So that means, what
I actually want to do
36:24 - is create an array
called allCircles.
36:28 - And I'm going to push these
circles into that array.
36:35 - You know what?
36:36 - I'm going to keep the c1,
c2, and c3 because I'm
36:40 - going to need to make
the queue as well.
36:42 - But I'm going to make
those local variables.
36:44 - So all circles should get
c1, c2, and c3 to start.
36:51 - And then the queue--
36:53 - I need a queue.
36:54 - This is where it's
connected to more to things
36:56 - that I've actually done before.
36:57 - The queue should have in
it all the triplets, which
37:01 - is only this right now.
37:03 - So it's going to be
an array of arrays.
37:05 - And let's just comment
this out for a second.
37:10 - The same math is
going to apply, but I
37:12 - need to figure out how
to process that array.
37:14 - So the first thing
I'll do is just in draw
37:17 - I'm always going to just
show all the circles.
37:20 - Let's get rid of no loop.
37:21 - And let's go from
generation to generation
37:25 - by clicking the mouse.
37:26 - So I'm going to add the
mouse-pressed function.
37:29 - I could use a button or some
other form of interaction
37:31 - or do this automatically,
but I think this
37:33 - will help me figure this out.
37:35 - So what do I want to do
when I click the mouse?
37:37 - I want to process the queue.
37:41 - I'll call it a triplet of queue.
37:43 - So I want to go through every
triplet that's in queue.
37:47 - I'm going to need this.
37:49 - And can I do something like,
say, let c1, c2, c3 equal
37:54 - that triplet?
37:55 - So I would get those three
circles out of the thing that's
37:58 - in the queue.
37:59 - I would calculate k4.
38:02 - Then I would get
all of the circles.
38:06 - I know that this
[INAUDIBLE] allCircles
38:08 - returns four circles.
38:10 - But let's just use the
first circle for a second.
38:13 - Let me think about
what I'm doing.
38:14 - Oh, I don't want to
call this allCircles.
38:16 - NewCircles, this is
called newCircles.
38:19 - And what I want to do is
say like, allCircles push,
38:23 - newCircles 0.
38:25 - So let's just first
put in the new one.
38:28 - So if I click the mouse, I
get that new circle going in.
38:32 - This is good.
38:34 - Now with that new circle,
I need to make a new queue.
38:37 - So I need to have a new queue.
38:39 - Our nextQueue, I'll call
it, is an empty array.
38:43 - And newTriplet is equal to
c1, c2 with new circles 0.
38:54 - Basically, this new
circle is mutually
38:57 - tangent to those first three.
38:58 - So I have three new triplets.
39:01 - I have it with c1 and c2.
39:04 - I have it with c1 and c3.
39:06 - So newTriplet1, newTriplet2.
39:08 - I might not need all
these separate variables.
39:10 - And newTriplet3 is
with the new circle.
39:14 - And c2 and c3.
39:16 - So these are all
the possibilities.
39:18 - And then the queue should get
nextQueue equals nextQueue
39:27 - concatenated with--
39:29 - and let's just call
this t1, t2, and t3.
39:33 - Those are my triplets that I'm
getting from there, t1, t2, t3.
39:37 - And then the queue
should equal next Queue.
39:42 - So again, I'm only doing this
with that first new circle.
39:46 - But in theory, it should
now get that new circle,
39:50 - make all the new triplets.
39:51 - Process them.
39:52 - Process them.
39:54 - Process them.
39:54 - OK, this is working.
39:56 - This is very exciting.
39:57 - One thing I need to do.
39:58 - There's two things I need to do.
39:59 - I need to make sure
that the circles--
40:02 - I mean, they're going
to get infinitely small.
40:04 - First of all, one
thing I can do is
40:05 - I can say-- and let me
hit-- you can already see,
40:08 - it's really slowing down-- for
let newCircle of newCircles.
40:12 - So don't even need
that index anymore.
40:14 - I'm going to do it
with all of them.
40:17 - There we go.
40:18 - For all the new circles,
put them in the array,
40:21 - and make the new triplets,
and add them into the queue.
40:24 - Great.
40:25 - But before I do that, I
need to check some stuff.
40:28 - Like, if newCircle dot
radius is greater than--
40:33 - I'm going to give it a
big number-- like 10.
40:36 - But you can see I'm
getting some bad circles.
40:39 - So I'm pretty sure that--
40:42 - and I don't know exactly
why this is the case.
40:44 - But in all of the possible
combinations of curvatures
40:48 - and centers that I'm getting
out of these equations,
40:51 - not all of them are valid.
40:52 - So I think what I need
to do is check for that,
40:56 - throw away circles
that aren't valid.
40:59 - So let's validate the circles.
41:03 - There's two aspects to
validating the circles.
41:05 - One is a lot of times
these equations will
41:08 - produce the same circle twice.
41:09 - And I don't want to add it
again because that's just
41:11 - going to compound itself.
41:12 - Let me work on that first.
41:14 - Let me write a function
that's like called
41:17 - if validate newCircle.
41:20 - So I'm going to write
this function, function
41:23 - validate and--
41:25 - I'll just call it c for circle.
41:27 - So the first thing I want to do
is check if it already exists.
41:32 - So let's look at the distance
between this circle's center
41:38 - and the other circle's center.
41:42 - If that distance is less
than like 0.1 pixels,
41:47 - that's how I'm going to
know that they're the same.
41:49 - Return false.
41:51 - OK, it's invalid if it's
distance to another circle
41:54 - is too close to it.
41:57 - And we'll just put a
return true at the end.
42:01 - So that's good.
42:02 - You can see this is working.
42:03 - But I'm still getting a
bunch of invalid circles.
42:05 - I need to make sure
that it is actually
42:08 - mutually tangent to c1, c2, c3.
42:12 - So I can actually
add these here.
42:15 - So basically, this
function, first,
42:18 - is going to check to make
sure it doesn't exist already.
42:23 - And I could call it c4.
42:25 - That's really what it is.
42:27 - It's the fourth circle.
42:29 - And now I need to
write a new algorithm.
42:32 - Check if all four circles
are mutually tangential.
42:38 - So how do I know if two
circles are mutually tangent?
42:42 - I think I have an
idea how to do this.
42:44 - OK.
42:45 - There are two ways
for two circles
42:47 - to be tangent to each other.
42:49 - One is for one circle
to be inside another.
42:53 - The other is for them to
be next to each other.
42:57 - Now let's think about the
radii, the two radius values,
43:02 - for each of these scenarios.
43:04 - And I didn't mean for this
to be right in the center.
43:07 - So I'm just going to pretend
the center is over here.
43:09 - So this is r1.
43:10 - And this is r2.
43:12 - This would be r1.
43:14 - And this would be r2 here.
43:16 - Now the important
value is to look
43:18 - at the distance, the distance
between the two circles.
43:22 - So in this case, if they're
tangent to each other,
43:26 - the distance should
equal r1 plus r2.
43:30 - And in this case, the distance
should equal the absolute value
43:35 - of r2 minus r1.
43:38 - Look at that.
43:38 - You can see how--
43:40 - I think I drew this in a weird
way that's making me unsure.
43:45 - And that's the distance.
43:47 - This is r1.
43:49 - That's r2.
43:50 - So if I were to take r1 minus
r2, I would have the distance.
43:56 - That was right.
43:56 - I was right.
43:57 - I just had to look at
it a different way.
43:59 - Now it's going to
be very hard again
44:01 - with this sort of
precision of floating point
44:03 - numbers in JavaScript.
44:04 - Basically, I want to look
at the absolute value
44:06 - of the difference between
d minus r1 plus r2
44:10 - and make sure that's less
than some epsilon value.
44:14 - And the same thing for this.
44:16 - I basically would say d minus
the absolute value of r2 minus
44:21 - r1 and make sure that's less
than some epsilon value.
44:25 - So if either of these is true,
then the circles are tangent.
44:32 - So let's write a function.
44:34 - IsTangent c1 and c2.
44:37 - And I'm basically
saying, first I
44:40 - need to check
difference one is--
44:43 - I should really write a function
inside of the circle class
44:46 - for distance.
44:50 - So now I have a function
here in the circle class
44:53 - that will calculate the
distance between two circles.
44:58 - That makes life much
easier in this code.
45:01 - And I need to do the same thing.
45:03 - The distance equals
c1 distance c2.
45:07 - And r1 equals c1 dot radius.
45:11 - R2 equals dot radius.
45:16 - And I need like
an epsilon value.
45:19 - So now I'm going to say,
return d minus r1 plus r2
45:27 - is less than epsilon, or d minus
the absolute value of r2 minus
45:33 - r1 is less than epsilon.
45:36 - Let's put these as
separate booleans,
45:38 - just because I think it'll make
it easier to read the code.
45:41 - So these are the two booleans
that I need to check.
45:44 - And I'm basically saying, if
either one of these is true,
45:47 - then the circles are
mutually tangent.
45:51 - If isTangent-- this is
a terrible way to do it.
45:54 - But I'm going to
do it right now.
45:56 - If it's not tangent, c4
and c1, return false.
46:02 - And I'm going to do that against
all the other possible ones.
46:06 - And then return true
if I get to the end.
46:09 - I'm not 100% sure about this.
46:10 - So first I'm checking, is it
a circle that already exists?
46:14 - It's invalid, return false.
46:16 - Then if it's not tangent
to those other circles--
46:19 - I don't know where it came from.
46:20 - It's wrong.
46:21 - That one, throw it away.
46:24 - I'm not getting any circles now.
46:25 - Let's just say it's
always going to be true.
46:28 - Every two circles are tangent.
46:31 - Let's now look at this.
46:35 - Is my distance-- let me
check my distance function.
46:38 - Oh, look at this.
46:39 - My distance function is wrong.
46:41 - It's a and b.
46:42 - It's a and b, not x and y.
46:44 - That's how I named my
complex number naming.
46:47 - Oh, so that's not going to give
me results that make any sense.
46:51 - OK.
46:54 - Look at that.
46:55 - Invalid circles are gone.
46:58 - Look, we have the
Apollonian gasket.
47:01 - All right.
47:02 - Before we move on,
one thing I did forget
47:03 - is these distance checks should
really have the absolute value
47:08 - because I could be getting some
weird stray negative numbers.
47:11 - So these should be absolute
value, is less than epsilon.
47:17 - And then here I had
this old calculation
47:20 - for the fourth radius,
which is no longer needed,
47:22 - because the circles
are calculating
47:24 - their own radii in this
new algorithm down here.
47:27 - And also, you can see that
at some point I'm clicking,
47:30 - and it stops.
47:31 - So I'm not getting
any more new circles
47:34 - once I get to a maximum.
47:37 - Or maybe I am.
47:39 - Oh, no, did I just
freeze things?
47:41 - Everybody just hold on.
47:43 - It's frozen.
47:43 - No.
47:44 - No.
47:44 - No.
47:44 - No.
47:44 - Wait.
47:45 - No.
47:46 - No, please, please, I don't
want to lose all my code.
47:48 - Oh, god.
47:49 - Just keep waiting.
47:50 - It's fine.
47:51 - Keep waiting.
47:52 - I mean, I probably had
saved somewhat recently.
47:54 - I had it saved, so
actually I'm fine.
47:57 - Oh, you know what?
47:58 - I didn't check to see
if the circles got
48:01 - too small, below a threshold.
48:02 - Oh, so also, invalidate if
c4 radius is less than 2--
48:10 - let's just stop at two pixels--
48:12 - return false.
48:14 - So that's also an invalid--
48:15 - and actually, let me just
make it 10 just to be sure.
48:21 - Now it stops.
48:22 - Aha.
48:23 - I feel much better
about everything now.
48:26 - So I think I'm actually good.
48:27 - Let's put that at 2.
48:30 - I suppose, yes, there
are arrangements
48:33 - where two circles-- like
if there were a circle that
48:37 - were smaller in the center.
48:39 - So let's check
radiusDiff equals--
48:42 - I mean, there's no reason
not to just check this--
48:46 - c4 dot radius minus
other dot radius.
48:51 - So if the delta, the distance,
is less than epsilon,
48:57 - and the radius difference
is less than epsilon,
49:02 - then they're the same circle.
49:05 - I think now I have a fully
functioning Apollonian gasket
49:10 - algorithm visualization.
49:12 - And the exciting
part is now here,
49:15 - where I believe I should be
able to start with any arbitrary
49:21 - arrangement of three
mutually tangent circles
49:24 - and get a new pattern.
49:27 - How do I get three random
mutually tangent circles?
49:34 - Let's start actually with the
first circle being the larger
49:40 - one.
49:40 - And then now the second circle,
I'll pick a random radius
49:45 - between, let's say, like 20
and c1's radius divided by 2.
49:52 - And then c2 would
be 1 divided by r2.
49:57 - Its position would
be 200 minus--
50:02 - I need to get to the edge of
the circle, which would be
50:05 - c1's radius, plus this new r2.
50:11 - So this is now a random
circle like this.
50:14 - But I would love to position
it at a random vector.
50:17 - So let's use some vector math.
50:19 - And let me get an angle--
50:22 - you know what?
50:23 - I'm going to make a vector.
50:24 - V equals p5 vector random 2D.
50:28 - And v should have the magnitude
of c1's radius minus r2.
50:36 - And then c2 is just at 200 plus
v dot x and 200 plus v dot y.
50:46 - So every time I
do this, I'm going
50:48 - to get a random circle somewhere
tangent to the outside.
50:53 - Now I need to get the other one.
50:55 - So the next radius--
50:59 - I'm just making
this up on the fly.
51:00 - The next radius is
c1's radius minus
51:06 - radius 2, the magnitude of v1.
51:09 - It's actually the
magnitude of that vector.
51:13 - And then where is it positioned?
51:16 - I would basically position
it on the other side.
51:19 - So I would rotate the vector by
pi and then set its magnitude--
51:26 - how far away should it be--
51:28 - by c1's radius minus--
51:32 - Oh, that's the same thing.
51:33 - What if I just rotated it?
51:34 - And then just said, is
this really going to work?
51:38 - The next circle is--
51:39 - no, this doesn't make sense.
51:40 - Something is wrong here.
51:41 - But let's just try it.
51:44 - Oh, and I need to
put it in here.
51:48 - That's kind of right.
51:49 - But it's not in the right place.
51:51 - You can see that's
the right circle.
51:53 - It's just not in
the right place.
51:54 - So where does it go?
51:57 - I need to rotate it.
51:58 - And then it just
needs to go out--
52:01 - I think I need the whiteboard.
52:03 - I have a circle.
52:04 - It's radius is r1.
52:06 - I have another
circle right here.
52:09 - Its radius is r2.
52:11 - And then I made another
circle like this.
52:15 - Its radius is r3.
52:19 - So r1 should equal r2 plus r3.
52:23 - So how do I find
this center point?
52:26 - I just have to go from
wherever this is, r2 plus r3.
52:30 - OK, that's its magnitude,
r2 plus r3, or r1.
52:35 - The vector rotates.
52:37 - And then its magnitude
should be c1 dot radius.
52:42 - Oh, but I'm doing
it from the center.
52:45 - c1 dot radius-- oh, of course--
52:47 - minus r3, of course.
52:49 - There we go.
52:51 - So now I'm always going to get
three mutually tangent circles.
52:57 - Let's pick this one.
52:59 - Oh, no.
53:00 - Where's my gasket?
53:02 - Oh, there we go.
53:05 - I'm trying to figure out
why some starting points,
53:09 - I don't get any circles.
53:11 - So let's try to debug this.
53:14 - Let's see if I can reproduce
arrangement that doesn't work.
53:18 - And I can use
randomSeed to do that.
53:20 - So if I put randomSeed
in setup, and I'll just
53:23 - pick the number 5--
53:24 - well, that one actually works.
53:26 - Let's try the number 4.
53:28 - So with this one--
53:30 - interestingly enough,
it's different each time
53:33 - because my p5 vector--
53:36 - it doesn't really matter.
53:37 - But let's just use from,
Angle random TWO PI.
53:40 - The p5 vector is somehow
not taking my randomSeed.
53:43 - I don't know if that's a bug in
p5 or if I've made a mistake.
53:45 - But now it's going to
be the same every time.
53:47 - Let's console.log k4.
53:51 - Not a number.
53:52 - So something's going wrong
in that initial Descartes
53:54 - calculation, which is here.
53:56 - I have a feeling that this
value here is a negative number.
54:01 - So you can't take the square
root of a negative number.
54:03 - It is negative.
54:05 - I mean, can I just make
it the absolute value?
54:08 - Can I call that product and
take the absolute value of it?
54:11 - I don't know if that would work.
54:13 - That wasn't in any of the pages
I read to understand this.
54:18 - Oh, there we go.
54:19 - Look at that.
54:21 - So now I can go back to
getting rid of randomSeed.
54:25 - Let's give ourselves a
bigger space to work with.
54:32 - And let's have it automatically
create the gasket.
54:36 - So what do I do now?
54:38 - So I'll just call this
like nextGeneration.
54:42 - And if I call in
draw nextGeneration,
54:48 - it should automatically
make the gasket.
54:51 - There we go.
54:52 - Eventually it'll stop.
54:53 - Look at all of these
possible Apollonian gaskets.
54:56 - I feel like I should probably
have the first circle allowed
55:00 - to be a little bit bigger.
55:02 - So let's have it be
at minimum 100 pixels.
55:07 - Challenge complete.
55:09 - Let's think about what
you could do next.
55:10 - First of all, I have
a feeling that I'm
55:13 - kind of fudging some
math stuff here.
55:16 - So if you happen to be a
mathematician or somebody who's
55:20 - gone deeper and
read these papers,
55:21 - please let me in the comments.
55:23 - What did I miss?
55:24 - What did I get wrong?
55:24 - What are some ways
I could optimize
55:26 - the way that I'm doing this?
55:28 - But for you, the
creative coder, I'm
55:30 - wondering, what kind of visual
possibilities can you make?
55:34 - What if you think about color?
55:37 - What if, instead
of using circles,
55:40 - you use a different
kind of origin shape?
55:43 - You could also
recursively put gaskets
55:45 - inside of other gaskets.
55:49 - So I hope that you've learned
something from watching this.
55:53 - I hope that maybe
you can take my code.
55:55 - I certainly need to
clean it up and improve
55:57 - it, make it a little bit easier
for you to build on top of.
56:01 - I will do that to the
best of my ability
56:03 - and include that
in all of the links
56:05 - to all the references
and resources that
56:07 - are in this video description.
56:09 - So Happy Pi Day.
56:11 - If for some strange
reason, the way
56:13 - you spent your day was
watching this incredibly
56:16 - long and convoluted
video, trying
56:18 - to make the Apollonian gasket
in p5.js, then thank you.
56:23 - I appreciate you.
56:24 - I'm glad that you are here.
56:25 - I really want to see some
creative Apollonian gaskets.
56:28 - So share them with me in
the passenger showcase.
56:30 - And I'll see you next
time on The Coding Train.
56:33 - [BLOWS WHISTLE]
56:34 - [MUSIC PLAYING]