00:00 - welcome to another coding challenge in
00:02 - this coding challenge I'm going to
00:04 - tackle diffusion limited
00:07 - aggregation so what is diffusion limited
00:10 - aggregation well I encourage you to take
00:11 - a look at two references there's always
00:13 - of course a Wikipedia page you can kind
00:14 - of find out a little about the history
00:16 - of this algorithm where how it was
00:18 - thought of what it's appli to what it
00:20 - kind of uh um what it's what it can be
00:22 - used for um the reference that I'm using
00:25 - here uh uh that I read right before
00:27 - making this video or actually earlier
00:29 - this morning couple hours ago at this
00:30 - point uh is a page on the internet from
00:33 - June 1991 written by Paul bour which
00:36 - describes the algorithm uh you can see
00:38 - that diffusion describes among other
00:40 - things the diffusion of the aggregation
00:43 - of zinc ions in an electrolytic solution
00:45 - o that sounds kind of exciting but
00:47 - anyway the point of what we can do with
00:49 - this algorithm is to create certain
00:50 - kinds of fractal-like tree like
00:53 - crystal-like growth patterns and you can
00:55 - see there's a variety of possibilities
00:56 - and I there's one down here that I
00:58 - particularly like this one which I might
00:59 - try to rec create by the end of this
01:01 - video but let me um rather than read to
01:03 - you as much as you might enjoy me just
01:04 - reading that web page to you in this
01:06 - video um why don't I describe to you a
01:08 - little bit about how this algorithm
01:10 - works at least how I think it works and
01:12 - then the internet can always correct me
01:14 - and once I start to write the code for
01:15 - it we'll see if I'm thinking about it
01:16 - correctly because honestly I don't know
01:18 - I should have practiced this in advance
01:21 - something is definitely going to go
01:22 - wrong in this video okay so let's say we
01:24 - pick a point at the middle of the screen
01:27 - and then we just say oh hello I don't
01:29 - know saying hello to but uh there's this
01:32 - thing called a random
01:35 - Walker and the random Walker starts here
01:37 - just starts to randomly move around the
01:40 - screen and at some point it hits this
01:43 - point now obviously it's not going to
01:45 - take that exact path although it could
01:46 - randomly and once it hits an existing
01:48 - point it gets stuck and then we release
01:51 - a new random Walker and it starts to
01:53 - walk around and when it hits an existing
01:55 - point it also gets stuck and then we
01:57 - release another random Walker and it
01:59 - gets stuck and another one gets stuck
02:00 - and another one gets stuck and another
02:01 - one gets stuck and as they get stuck we
02:03 - start to see this Fanning out pattern so
02:05 - this is what I want to do now I think it
02:07 - would be really interesting to actually
02:09 - animate the full process there's kind of
02:11 - a spectrum here we could write code to
02:14 - animate the whole thing like we see
02:15 - these random Walkers moving around the
02:16 - screen and getting stuck we could also
02:18 - not animate anything and just see the
02:19 - final image or we could do something in
02:22 - between I think I'm going to try to do
02:23 - Point by Point um but not animate the
02:26 - random walk itself that's what I'm going
02:27 - to attempt so let's go back over and we
02:30 - need some code to start with which I
02:32 - have here no no code I mean I have a
02:35 - p5js sketch with a canvas and a
02:37 - background and if I go back to the
02:39 - browser I think I have it running here
02:40 - in the browser I can open up the console
02:42 - which I'm definitely going to need for
02:43 - debugging um and so let's first start
02:46 - what do I
02:47 - need I want I think I want to have an
02:50 - object no you know what let's just start
02:52 - right now first let's do this rather
02:55 - simply I'm going to say uh I'm going to
02:58 - call
03:00 - the thing that's finished the tree I
03:02 - don't know if that's a good name for it
03:03 - but all of the points that are in the
03:04 - pattern I'm going to call the
03:06 - tree uh I'm going to need a walker the
03:09 - thing the point that's moving
03:12 - around and uh that's just about it
03:15 - really and what I want to do is and I
03:17 - need a size like the size the radius for
03:20 - each one of these points which by the
03:22 - way you could do it on a per pixel basis
03:23 - so that always could be one but I'm
03:25 - going to try I'm going to try something
03:26 - like 16 just to have it be bigger to
03:28 - start with so um the first thing I'm
03:31 - going to do is I'm going to create I'm
03:33 - going to say tree
03:35 - index0 equals create
03:37 - Vector a point in the middle of the
03:41 - window and then what I'm going to do in
03:43 - draw is I'm going to say for all the
03:45 - points in the
03:48 - tree uh uh say stroke weight R and
03:53 - stroke 255 and I'm just going to draw a
03:55 - point tree indexi dox tree indexi doy
04:00 - so and let's not worry about this walker
04:02 - for a
04:03 - second so I'm going to refresh it well
04:05 - okay I don't need to refresh it it's
04:06 - live I'm using this adom package called
04:08 - live reload so there's the point okay so
04:11 - now what I want to
04:12 - do is I want to
04:14 - create something that I'm going to call
04:16 - a walker and I'm going to create it I I
04:18 - don't know if this is such a good idea
04:20 - but I'm just going to put it completely
04:22 - randomly anywhere in the in the sketch
04:24 - window it probably should start along
04:26 - the edge or something or actually if you
04:28 - read Paul bork's Page I remember now
04:29 - reading a point that you can make the
04:30 - algorithm more efficient by cleverly
04:33 - picking it close to where you think it
04:34 - might need to be but I'm just going to
04:36 - create a random Walker and I'm going to
04:39 - say I'm going to see if that Walker
04:41 - should be stuck so first thing I need to
04:43 - do is check again all of the points of
04:45 - the tree and I want to see I want to
04:49 - know uh the
04:52 - distance between that walker and a
04:55 - particular point in the tree and if that
04:58 - distance is less than some threshold
05:00 - R I guess oh no r r * 2 right because I
05:04 - just want to know if those two circles
05:05 - are touching so if the circle if the two
05:08 - circles are touching the distance is
05:10 - less than twice their radi radius um if
05:13 - distance is less than R then uh stuck
05:15 - equals true so I'm going to create a
05:17 - Boolean
05:20 - variable assuming stuck is
05:23 - false and then I'm going to go through
05:26 - all of the points and if stuck is true I
05:28 - can say uh break and now what do I do
05:32 - here I'm going to say uh and actually
05:34 - what I want to do is like keep going
05:37 - until you get stuck so as long as you're
05:39 - not stuck keep checking all of the
05:42 - points and as soon as you get stuck set
05:45 - stuck equal to true and what happens if
05:46 - you get through this Loop and you're
05:48 - still not stuck then
05:51 - Walker should it should randomly walk by
05:54 - some amount let's and you know I could
05:56 - probably be more thoughtful about this
05:58 - walker dox should change and walker. Y
06:00 - should change the other thing I really
06:02 - need to do is I should make sure it
06:05 - stays on the I don't want it to walk
06:06 - randomly Far Far Away off the window so
06:09 - I should constrain it to um to between
06:12 - zero and the width of the
06:17 - window so let's see and
06:20 - now once it finds a part point when it's
06:23 - stuck um then what do I do I say tree.
06:27 - push
06:30 - Walker there we go and now uh let's see
06:34 - what happens here so I've got some
06:36 - infinite Loop problem this always
06:38 - happens uh with live reload I shouldn't
06:41 - be like there we go oh look at that so I
06:43 - missed up like something good is
06:45 - happening but boy did I mess something
06:48 - up this is interesting so I must have
06:50 - used an X and A Y ah
06:53 - okay that should
06:57 - help yeah so interestingly enough this
06:59 - doesn't look so totally crazy is this
07:03 - correct though very hard to tell so
07:05 - let's do a couple things one is um The
07:08 - Stroke weight should really be half the
07:11 - radius um they should be right up
07:14 - against each other uh let's move them by
07:18 - let's move it by just one one thing I
07:20 - want to do is create um uh I'm gonna I'm
07:23 - going to just make a random unit Vector
07:26 - to be a little bit more controlled about
07:28 - how they're moving
07:30 - uh and then I'm just going to say uh
07:32 - walker. add that velocity so this is a
07:34 - little bit better just to make a random
07:35 - vector and add that to the
07:38 - walker uh I I got to I think this live
07:40 - reload thing doesn't work for me because
07:44 - um um
07:47 - because okay that's good and actually
07:50 - maybe I meant for this to be times
07:54 - two yeah there we go okay so this is
07:56 - definitely looking kind of right right
07:58 - now
08:01 - uh
08:02 - let's the basic idea let's make this
08:05 - much
08:07 - smaller
08:10 - yeah so you can see this is actually
08:13 - working although it's quite of the slow
08:18 - algorithm can speed this
08:21 - up so I think I've got the basics of the
08:24 - algorithm correct actually it's just
08:26 - kind of slow to do this one point in
08:29 - time let's do it this way um one thing I
08:34 - want to do wow this maybe this isn't as
08:35 - bad as I thought let's uh let's let's
08:37 - think about this let's do um I think we
08:41 - could release a bunch of walkers at a
08:45 - time so let's try
08:51 - um let's try releasing 10 walkers at a
08:55 - time and uh
09:00 - just to see if we can kind of get this
09:02 - going a little bit
09:05 - faster oh you know what the Walkers I
09:08 - think need to um to start from an
09:10 - outside
09:11 - point right well let me let me do this
09:14 - though anyway and then we're going to
09:15 - pick how where the Walkers start
09:17 - differently which is going to be much
09:18 - better I think so
09:21 - um so all right so I just want to see
09:24 - something if I I'm going to create a
09:26 - bunch of these Walkers and then now
09:32 - uh actually I can just do this as a
09:34 - loop
09:36 - right uh while you're not
09:40 - stuck okay if I'm back and um I thought
09:44 - of something which I think it might make
09:45 - a little bit more sense to be able to
09:48 - play with this a bit more by having the
09:50 - Walker itself be an object so I would
09:53 - like the uh instead of just being a
09:55 - vector I want it to be an object that
09:57 - can store both where it is on the screen
09:58 - it's size I can call functions on it
10:01 - that's going to give us more ways of
10:03 - playing with this algorithm and make it
10:04 - perhaps a bit more efficient so let me
10:07 - go here and what I'm going to do is I'm
10:09 - going to create a new file and I'm going
10:12 - to call that file walker. JS and I'm
10:14 - going to make a walker object a
10:17 - Constructor function and I'm going to
10:20 - say uh I'm going to say this. position
10:22 - equals create
10:24 - Vector uh random width random uh height
10:30 - so I just want to take a lot of this
10:32 - functionality um and that I've written
10:35 - out here and I want to also whoops I
10:38 - want to create a variable called uh
10:42 - this. stuck and I want that variable to
10:45 - be uh false when it starts I want to
10:49 - have a
10:51 - function um that's called
10:56 - walk so I want to um going to the I want
10:59 - to have a
11:02 - function I want to have a function
11:04 - called walk where I implement this
11:06 - algorithm where I pick a random Vector I
11:08 - add it to the Walker so it moves
11:10 - somewhere on the screen I can strain
11:11 - where it is in the window um and I want
11:14 - to have a function that says
11:17 - check uh what What's a better name for
11:19 - that function like uh update no uh uh
11:24 - stick I can't think of a good name
11:26 - whatever uh check sticky
11:30 - check stuck whatever that's going to be
11:32 - the name of the function check stuck and
11:34 - in that function what I'm going to do is
11:36 - I'm going to take this particular
11:40 - algorithm uh and I am going to and I
11:44 - actually kind of want to see them walk
11:46 - but I think I have I actually kind of
11:49 - want to do this without the while
11:53 - loop so what I want to for a second what
11:55 - I want to do is check all of the points
11:57 - on the tree and see if if the distance
12:00 - between this
12:01 - Walker's
12:03 - position right which is actually uh this
12:06 - pause now dot right the Walker is no
12:09 - longer The Walker is now an object with
12:11 - a
12:11 - position um is near anything that's in
12:15 - the tree's position because everything
12:17 - in the tree are Walkers that are stuck
12:20 - oh you know what I didn't do is I'm not
12:21 - delete anyway so okay
12:24 - keep so um and then if it's stuck I'm
12:27 - going to do something obviously
12:31 - okay so what I want to do here now is
12:35 - create an an array of
12:38 - Walkers and actually tree uh index zero
12:43 - is going to be a new
12:46 - Walker that is in the middle of the
12:50 - window uh then and that is stuck so what
12:53 - I'm going to do in the object is I'm
12:55 - going to have some optional
12:56 - arguments I'm going to say x y y stuck
13:00 - and I'm going to say
13:04 - um uh I'm going to say
13:07 - uh
13:09 - X
13:11 - um I'm going to say X or this is a way
13:14 - of doing optional arguments so if I pass
13:17 - in an X I'm going to create the vector
13:18 - at that X but if I don't X will be
13:20 - undefined then I'll get a random
13:23 - value y or or random
13:27 - height okay and then
13:30 - uh same thing here I'm going to say this
13:31 - stuck equals stuck and if it's undefined
13:34 - that's the same thing as saying
13:36 - false um and then I Need To Say by the
13:38 - way this do stuck is true and this is
13:41 - this. pause tree. pause okay and I
13:44 - should really check against uh some
13:47 - other array like the others I'll call
13:51 - that which is called tree so what I want
13:53 - to do right now is I want to create one
13:56 - Walker
13:59 - in the tree and then I want to create in
14:02 - the
14:02 - Walkers I want to put just a random
14:05 - Walker so I have tree and I have
14:08 - walkers and I I might as well do that
14:10 - the same way in index spot
14:13 - zero and then what I want to do is I
14:15 - want to see uh and you know what I
14:17 - should do is I should uh now I can also
14:21 - have a
14:23 - function which is called uh this
14:27 - doow and I can take all this code I
14:30 - should have done this at the beginning I
14:32 - can take all this code and put it in the
14:34 - object so I can um set a stroke weight
14:39 - set a stroke and this. pause and draw
14:42 - the point at this. pause doy and and I
14:45 - you know I could be a little smarter
14:46 - about this and actually just make this
14:48 - an
14:50 - ellipse so I could be more precise about
14:52 - the radius and I could say R * 2 R * 2
14:57 - which is a global variable at some point
14:59 - but I can have them be variable sizes at
15:00 - some point okay so now I have this
15:03 - object I have a walker object which can
15:05 - move it can check to see if it's
15:07 - sticking to anything else in some other
15:09 - array and it can also um it can also
15:14 - draw itself so what I want to do first
15:17 - is I just want to say let me display
15:19 - everything in the
15:24 - tree and let me
15:27 - display everything in the Walker's
15:32 - array okay ready so if I if I reload
15:35 - this
15:37 - sketch Walker is not defined oh uh
15:40 - sketch line seven it's not defined
15:42 - because I have to remember to add a
15:44 - reference to it in my Javascript file uh
15:47 - to walker.
15:48 - JS and missing walker. JS line 25 has an
15:52 - error so let me go down and see uh this
15:56 - do ellipse this. .x
16:01 - this.y I don't see any error here on
16:03 - line five 25 oops I had a period there
16:06 - not a comma there we go great so I
16:10 - should see here whoops I should see this
16:14 - is this and this is the
16:16 - Walker so let's now have let's just now
16:19 - in sketch let's also have walkers indexi
16:24 - do
16:26 - update oh update was not it
16:30 - walk so you can see there it is moving
16:33 - randomly it's going to take a while to
16:36 - randomly intersect
16:39 - that but it is walking randomly uh I
16:42 - could obviously make it uh walk faster
16:44 - so what I want to do now actually just
16:47 - as an experiment is I want to this is
16:49 - not at all I've gone off the beaten path
16:51 - here from the actual probably algorithm
16:54 - but I want to put 100 Walkers into the
16:57 - space
17:03 - right okay so they're all moving around
17:05 - randomly and what I want for them to do
17:08 - is
17:09 - if if
17:11 - Walkers index I check
17:15 - stuck
17:17 - others then
17:20 - Walkers uh then I what I want to do is
17:22 - say
17:24 - walkers. splice I want to take it out of
17:27 - there
17:29 - and I want to say tree. push Walkers
17:33 - index
17:34 - I so I want to uh whoops what I want to
17:38 - do is I want to anytime one of those
17:42 - Walkers gets stuck I want to put it in
17:44 - the tree and I want to take it out of
17:46 - the Walker's array because it's not
17:47 - something that's moving anymore so uh we
17:50 - let's check this do stuck equals true so
17:54 - actually
17:56 - um let's make a function
17:59 - uh
18:01 - is stuck actually so I don't need a I
18:05 - don't need this variable I can just say
18:09 - return true and if it kind of gets to
18:11 - the end return false so let's look at
18:15 - that
18:17 - um and see what happens others is not
18:21 - defined oh tree right I have to pass in
18:23 - the
18:23 - tree there we go you can see them
18:25 - getting stuck
18:30 - go go Walkers go go go go Walkers go so
18:34 - you can see how this takes a very long
18:35 - time I I'm kind of curious to try a few
18:38 - things let's try a thousand
18:44 - Walkers and I and this isn't what Paul
18:46 - bour describes what to
18:49 - do um on the website at all but I kind
18:52 - of like and so I kind of want to um
18:55 - highlight them differently so uh I
18:58 - should actually by the
19:02 - way I should have that be a particular
19:05 - variable
19:07 - uh because what I would like to do when
19:09 - I draw them uh is if if this do stuck I
19:15 - want to give him a different
19:19 - color uh so let's
19:26 - uh so we can see which one are stuck um
19:30 - so now though I think better more than
19:32 - better than
19:34 - adding a ton such still add a let's
19:37 - actually do this particular algorithm
19:40 - multiple
19:41 - times per
19:44 - frame like let's let it try to move all
19:47 - the Walkers 100 times per
19:54 - frame whoa why are they all clustering
19:57 - near each other
20:01 - am I oh I'm drawing them 100 times I
20:04 - don't want to I don't want to do this
20:05 - show so I just want to show them
20:14 - once there we go this is what I was sort
20:16 - of hoping to see so now there finally
20:19 - okay so now we can kind of see the
20:21 - algorithm happening which I think is
20:23 - kind of interesting it's it's going to
20:24 - happen very slow this is a complete and
20:27 - total brute force method
20:29 - um but I
20:30 - finally got something that I like here
20:34 - um and because at least it's sort of
20:35 - interesting to watch it is happening
20:37 - kind of slowly I want to try a few
20:39 - things to make it happen faster let's
20:41 - increase to 200 Walkers and let's
20:43 - increase the number of times uh to
20:47 - 250 um the frame rate is a little bit
20:49 - slower now I kind of like to keep the
20:51 - frame rate up so let's go down to
20:55 - 200 um there we go so we could obviously
20:58 - um and the other thing I could do uh
21:02 - it's interesting oh it's slowing down
21:04 - over time so the reason why it's slowing
21:06 - down over time is there's more distance
21:08 - checking so one thing that I could do
21:10 - that I would hopefully um help this run
21:13 - a bit faster
21:15 - um which normally I wouldn't care about
21:18 - but it is kind of bothering me how slow
21:20 - that it's running is let's see if we can
21:22 - eliminate the square root calculation um
21:25 - and to see if that makes it run a lot
21:26 - faster so one thing that I'm doing here
21:28 - in the check stuck
21:30 - function is using this distance function
21:33 - and I want to write my own distance
21:36 - function I'm going to call it distance
21:38 - Square ukian distance um and I want to
21:41 - take it I want it between two vectors A
21:44 - and B so what I want is the difference
21:47 - in X which is BX minus a a.x I want the
21:51 - difference in Y which is B Yus a doy and
21:55 - now normally if I were I would say
21:58 - return
21:59 - the square root of DX * DX + Dy * Dy
22:04 - this would be regular old fashioned
22:07 - ukian distance right uh a um the square
22:10 - root of you know the hypotenuse of a
22:12 - triangle a squ plus b squal c squ or c
22:15 - equal the square otk of a square plus B2
22:17 - so what I actually want to do here is
22:19 - just write this algorithm but take out
22:21 - the square
22:22 - root and
22:25 - then what I can do now is not use this
22:28 - but but use my own distance squared
22:30 - function and then I can actually have
22:33 - that distance be uh R * R * 4 which is
22:39 - what I want now is for the distance to
22:42 - be did I did I mess something up here
22:43 - yeah I'm missing a parentheses uh what I
22:45 - want is the distance to be instead of
22:48 - checking if the distance is less than R
22:50 - * r i want the distance R 2 or R * 2^ 2
22:54 - is R * R * 4 so this now uh distance uh
22:59 - dist
23:00 - squared this should hopefully be a lot
23:03 - faster um you know uh did I wow good
23:06 - okay so boy just eliminating that square
23:08 - root you can see how much faster this is
23:11 - now okay now here's the other thing is
23:14 - every time I remove a walker oh this is
23:18 - kind of nice actually just to like Let
23:19 - It Grow with a fixed number of Walkers
23:21 - I'm kind of enjoying that back there was
23:24 - a technical glitch there but hopefully
23:25 - you're still seeing me I seem to be I
23:27 - see myself again so you can see here
23:30 - that I have this kind of nice finished
23:32 - pattern which I really quite like
23:33 - actually um so some other things that I
23:36 - can do here are one is
23:40 - whenever I remove a walker uh I could
23:44 - say like I always want to have 200
23:47 - Walkers so
23:50 - um
23:51 - uh I can I can always say like while
23:55 - walkers.
23:57 - length is is sorry is less than 200 um
24:03 - walkers. push um walkers. push uh new
24:09 - Walker so this is even when they get
24:12 - stuck I add new Walkers so I never oh
24:15 - and by the way I started with so let's
24:18 - make a variable called uh Max Walkers
24:22 - equals uh 200
24:25 - 200 and we're going to start with uh
24:28 - that's we're going to do it oh no no no
24:30 - that's a different value Max Walkers I
24:33 - kind of made and then I'm going to make
24:35 - another variable which is uh iterations
24:38 - which I'm also going to make 200 let's
24:40 - make these variables I think is kind of
24:42 - nice right we can see how it behaves and
24:45 - we can see how it behaves so now I'm
24:46 - always keeping um 200 Walkers so I want
24:49 - I want this really to happen pretty fast
24:52 - so let's see if I can up the iterations
24:55 - a bit
24:58 - um and see if we can get this screen now
25:01 - it is uh it is sort of slowing down so I
25:03 - think we're we're in we're in pretty
25:05 - good shape now here's the thing I think
25:07 - what's interesting oh you can see it
25:09 - really slowing down um so if I go back
25:11 - to oh and you know what there's also a
25:14 - problem here which is that I shouldn't
25:16 - be creating random Walkers anywhere in
25:18 - the window I should only be creating
25:21 - them around the edges so let's also make
25:24 - that Improvement okay I think it's worth
25:26 - making that Improvement
25:29 - so I'm going to make I'm going to go
25:30 - back into the Walker and instead of
25:32 - doing random width random height I need
25:35 - a
25:36 - function uh make Rand uh let's do a
25:40 - random point and I'm going to give it
25:42 - that X and
25:44 - Y right I want to have some separate
25:46 - function somewhere that's going to take
25:48 - care of this for
25:51 - me uh actually I'm going to say if x
25:56 - this. equals create Vector at that X and
26:00 - Y so uh if you get an X and A Y um
26:05 - otherwise let's pick a random
26:08 - point now I'm sure there are lots of
26:11 - clever ways I could write a function to
26:14 - give me a random point along the edge
26:17 - but the way I'm going to do it as as
26:19 - follows I want four possibilities top
26:23 - right bottom or left
26:30 - so if if I'm picking something along the
26:33 - top I want a random
26:37 - X and I want to return create
26:41 - Vector uh that random X comma
26:45 - 0er else if I equals 1 let's just say
26:48 - that's the
26:49 - bottom uh and again we could make this
26:52 - more efficient let's make that along the
26:55 - height
26:59 - else if I equals 2 I want a random
27:03 - Y and I'm going to along the left side
27:07 - and in all other
27:11 - cases I want a random Point uh along the
27:16 - right hand side so let's run this now
27:18 - you can see that I'm only picking random
27:20 - points that are coming from the edge
27:22 - which I think is also going to work a
27:23 - lot better because I don't want to pick
27:25 - random points kind of inside the thing
27:27 - that I'm already creating so here we
27:28 - have now uh diffusion limited
27:31 - aggregation go go go I wanted to finish
27:35 - um so one thing that I kind of miss so
27:38 - this I I got to come up with a clever
27:40 - solution to figure out when it's
27:42 - done because you can see it's kind of uh
27:45 - it's now like just infinitely picking
27:47 - points along the edge and it kind of
27:48 - went crazy a little bit when it kind of
27:50 - got to the edge so but I kind of like
27:52 - the idea of actually just for right
27:56 - now um never not adding um not adding
28:00 - any more Walkers and starting with a
28:02 - fixed number of points so I'm going to
28:04 - start with 1,000
28:06 - points and yes it is running kind of
28:09 - slow but when those points are removed
28:12 - we got to get our first point to get
28:13 - stuck randomly there we go I think it's
28:16 - going to kind of speed up over
28:20 - time is my
28:22 - belief but uh and you know one thing I
28:24 - could probably do which might also help
28:26 - it run faster is draw less stuff
28:29 - uh or what might be better is to just
28:31 - add you know add one point at a
28:34 - time uh so I think really the way that
28:36 - you would do this is I might let's just
28:38 - do five but like have like a thousand
28:41 - iterations here's another way to doing
28:42 - it yeah I like this this is nice I like
28:45 - looking at it this way too so there's so
28:46 - many different ways you can visualize
28:47 - this I'm kind of stuck on it um and I
28:50 - encourage you to uh sort of enjoy coming
28:53 - up with ideas on your own but what I
28:55 - what I do want to do is um
28:58 - what I do want to do is uh let's let's
29:01 - go back to
29:03 - this um what I do want to do is kind of
29:06 - look at how um how you can vary this
29:09 - algorithm to get different star
29:11 - different kinds of patterns so let's go
29:13 - back and look at the Paul Bor website
29:15 - and let's first sort of see a couple
29:17 - things one is how right now this is
29:20 - essentially what I'm getting you know I
29:22 - could do a better job of kind of
29:24 - thinking about the layout of the space
29:25 - and making the algorithm more efficient
29:26 - or that you know let it run for a long
29:29 - time I encourage you to do all that um
29:31 - I'm going to release a processing
29:32 - version of this which maybe runs for a
29:34 - while and like renders the final version
29:36 - to an image somebody remind me in the
29:37 - comments if that doesn't exist so we can
29:39 - make a version of it it looks like this
29:40 - in the browser it'll kind of I don't
29:42 - want to like shut down a browser window
29:44 - but let's at least first think let's try
29:46 - to see how we create this pattern so
29:48 - this pattern is all about the seed
29:50 - points what if I fill the tree with
29:52 - points along the
29:53 - bottom so let's let's fill the in the
29:56 - beginning instead of having one Point
29:59 - what if I say for VAR I equals I'm going
30:02 - to say VAR x equals 0 x is less than
30:04 - with X plus equals R time 2 and what I
30:08 - want to do is say tree.
30:11 - push new Walker at X comma height so I
30:17 - just want to create a whole bunch of
30:18 - points that I start with at the
30:20 - bottom and you can see what happens when
30:22 - I do that now what if I want I think I
30:24 - want all my Walkers actually just to
30:26 - start at the top so let's go now to the
30:29 - Walker file and what if I basically say
30:32 - uh you know what let's just all always
30:34 - have I'm going to comment all this out
30:36 - and let's always have all the
30:38 - Walkers start at the top so I just
30:41 - changed this function have all the
30:42 - Walkers start at the top
30:44 - whoa what did I do
30:48 - wrong I'm back there was a major problem
30:51 - with my code which is right here
30:53 - remember how I was saying I'm so clever
30:55 - and I can check to see if the user gives
30:57 - it an X and A Y so if x and if there's
31:00 - an X and A Y make a vector out of the X
31:02 - and the Y otherwise make a random Point
31:05 - well it turns out that if you give it
31:07 - the value zero right zero evaluates to
31:10 - false so when I say make a walker at
31:13 - zero comma zero for example or zero
31:15 - comma height it's actually going to not
31:17 - make it at that point but give me a
31:18 - random point so what I actually need to
31:21 - do here is say as long as X is not
31:25 - undefined and I'm sure there's a more
31:27 - elegant way of doing this but I'm just
31:29 - going to fix it right now and saying n y
31:30 - is not undefined do this and that should
31:36 - I think I have some sort of uh browser
31:38 - having crashed
31:42 - problem infinite Loop problem and also I
31:46 - think I can do away with this third
31:47 - argument stuck and just say this dot you
31:52 - know it's if if I'm making it at a
31:54 - particular point it's automatically
31:56 - stuck otherwise
31:58 - it's automatically not stuck just to be
32:00 - clear about that and now we should see
32:02 - okay so here we go now we have starting
32:05 - all the points at the top and they're
32:06 - going to go they're going to kind of get
32:08 - glued at the bottom so this we should
32:09 - see some kind of pattern as this runs
32:11 - for a little bit you know Speed Ahead in
32:13 - this video if you want you know listen
32:16 - to some music while you're uh
32:22 - waiting come on trees grow so um so we
32:26 - should see a pattern that's coming much
32:28 - more like what we've got here in oops
32:31 - I'm in the wrong place what we've got
32:32 - here in this particular example so
32:34 - here's another so come up with your own
32:36 - scenario what if you start with points
32:38 - all along the edges what if you start
32:41 - with points along a radial path in a
32:43 - circle or have points moving ah you have
32:46 - points starting around the edges of a
32:47 - circle and your random Walkers all start
32:49 - in the center you get something like
32:51 - this um now but I do want to add
32:54 - something else here which is um
32:59 - oops I got too much music playing okay I
33:02 - do want to add something else here uh
33:03 - let's just see how it's going you can
33:05 - see oh it's it's moving along here we're
33:06 - growing our trees I want to go I want to
33:08 - go back to Paul Bor site and you can see
33:10 - something here which is
33:12 - interesting look at this particular
33:14 - image now as I scroll down look at this
33:16 - particular image and look at this
33:18 - particular image there's a kind of
33:20 - density or fuzziness or almost hairiness
33:22 - to it and you can what you can actually
33:25 - do is uh it's called stickiness you can
33:28 - have a probability you can think of when
33:30 - it touches something that's part of the
33:34 - uh part of this tree this this diffusion
33:36 - limited aggregation thing that's growing
33:38 - you could have a probability that it
33:40 - gets stuck rather than automatically
33:42 - getting stuck um so I think that's
33:44 - something interesting to add for example
33:47 - if it's within this threshold Jo don't
33:49 - just automatically have it get stuck but
33:52 - pick a random number between zero and
33:53 - one and if that random number like our
33:55 - stickiness is now 10%
33:58 - uh then I could actually have it get
34:00 - stuck and unfortunately we didn't get to
34:02 - see how that was going um let me see if
34:04 - I can make this run a little faster um
34:07 - there's a couple things um so I'm going
34:09 - to uh I'm going to give it more
34:11 - iterations and more max random
34:13 - Walkers um the other thing that I could
34:15 - do actually that I think would really
34:17 - help is I could have the uh Walkers as
34:20 - they walk not just I could have them
34:23 - only ever walk down so I could actually
34:26 - say I'm just going to comment this out
34:29 - uh VAR velocity equals create
34:32 - Vector some random amount between ne1
34:35 - and one and then some uh random amount
34:40 - between zero and one so that these uh
34:43 - the the random Walkers only ever move
34:46 - down boy they they move down much too
34:50 - fast I guess I should maybe I should
34:52 - weight it just a little
34:54 - bit something like that
34:58 - who okay hold on too many this was a
35:00 - nice idea that I had that doesn't seem
35:02 - to be working out very
35:07 - well there you can sort of see I don't
35:09 - know if this was a good idea or not but
35:10 - you can sort of see how if I have them
35:12 - randomly moving down why do they always
35:14 - uh go back up to the top am I oh I'm
35:16 - adding them back in again that's making
35:18 - it run slower so um uh uh yeah so I I
35:22 - wanted to take that out
35:24 - actually and you can sort of see anyway
35:28 - you can see that by varying lots of the
35:30 - algorithm I'm going to when I when I
35:31 - publish the code for this I'm going to
35:32 - make you a nice clean version that works
35:34 - really well because there's so many
35:36 - variables you can play with here okay I
35:38 - want to play with one last variable so
35:41 - uh look how slowly like come fall
35:44 - Walkers go to the bottom stick to the
35:46 - aggregation pattern oh um okay so let's
35:48 - do one last thing um what I'm going to
35:51 - do now which I think will be
35:53 - particularly interesting and uh is try
35:55 - to recreate this pattern notice how the
35:57 - walkers at the
35:59 - center are larger than the ones on the
36:02 - outside you can see this one as well um
36:04 - I didn't get to do the the the probab
36:07 - didn't get to see that the probability
36:08 - thing play out uh let me take that out
36:11 - for a second and so what I want to do
36:14 - now before I leave you if you're still
36:17 - watching is I don't want to have r as a
36:20 - global variable anymore I want to have
36:22 - each
36:24 - Walker have its own variable so I'm
36:26 - going to make r
36:28 - 32 uh and I need to look for anywhere
36:31 - that I reference it this. R uh other. R
36:35 - right now I'm also importantly checking
36:37 - my own radius against another radius or
36:40 - others index i. R and then I also want
36:44 - to draw it with this.
36:46 - r this.r so one thing that I could do
36:50 - which is and then I want to go back to
36:52 - the center ver the version where it's uh
36:55 - all um
36:58 - where it's starting in the center which
37:00 - I think is a bit easier to kind of work
37:02 - with right
37:03 - now so I'm going to take out this tree
37:05 - that starts off the bottom let's just
37:07 - make sure this still works whoa look at
37:09 - these so if I make them really quite big
37:12 - that was kind of interesting uh let's
37:14 - make this
37:15 - eight okay so you can see what this
37:18 - looks like now and this is working again
37:20 - now with
37:22 - um with uh with just sort of larger
37:25 - circles and I kind of would like to to
37:28 - uh just also when I draw them I would
37:30 - like to give it a little bit of alpha
37:31 - here I think would be worth
37:35 - seeing uh uh
37:38 - let's just a little bit of alpha
37:41 - okay so okay so now we have the basic
37:44 - core algorithm happening and you can see
37:46 - all of these uh Walkers getting stuck so
37:49 - what I want to do I think which I think
37:51 - would be interesting is I'm going to I'm
37:53 - going to make the maximum number of
37:55 - Walkers just 10 but I'm going to
37:57 - increase the iterations by 10 to a
37:59 - th so these are the Walkers now sticking
38:03 - uh one at a time now there were only 10
38:05 - of them so 10 of them are going to get
38:06 - stuck that's all we're going to see but
38:08 - now what I'm going to do is I'm going
38:10 - to each time I delete one from the
38:16 - array uh I am going to add a new
38:21 - one with a smaller radius so what I want
38:25 - to do is let me get the oops let me get
38:30 - the radius
38:32 - of the uh last one in the array this
38:35 - might be a and I'm going to make a new
38:40 - Walker with uh oh boy uh I want to make
38:44 - a new Walker with a that that radius
38:49 - times 0. five so half the size the
38:52 - problem is now I need to make the Walker
38:54 - be able to be created now with a radius
38:59 - but at a random point so I think one
39:02 - thing I need to do one thing I could do
39:03 - actually this is better is I could say
39:05 - if arguments.length equals two that
39:09 - means I've gotten two arguments in X and
39:11 - A Y then create the then create a a
39:15 - walker with a radius of eight
39:20 - otherwise then create it with the radius
39:25 - of and then otherwise if if
39:29 - um yeah otherwise create the AER with
39:32 - the radius of the first argument so if
39:34 - you have less than two arguments so this
39:35 - is another way I could just check that
39:37 - arguments array I have a video tutorial
39:38 - about that otherwise I can uh I can get
39:42 - it I can make one with a particular
39:44 - radius and so let's see uh let's see
39:47 - what happens here
39:49 - um uh okay so where am I making
39:52 - Walkers ah so this is with I forgot no
39:56 - no no no know so with wait or else if
40:02 - arguments.length
40:04 - equals
40:07 - one else now with no
40:11 - arguments right then the position is
40:14 - random the radius is eight and stuck is
40:17 - false so uh now the other whoa what just
40:21 - happened here back I realized there's a
40:23 - problem here where I have actually I'm
40:25 - passing into three arguments because I
40:26 - had an extra straight true from before
40:28 - so let me take that out and you can see
40:30 - this is working now strangely enough
40:32 - though uh the um the Walkers are getting
40:35 - like really really really small really
40:36 - fast and I just realized that's because
40:39 - um what I want to do is get that before
40:41 - I start adding a whole bunch of them I
40:43 - want to get the radius of the last one
40:44 - there because when I add one and get the
40:45 - radius of the last one they're getting
40:47 - smaller and smaller and let's let's just
40:48 - make them uh go down by
40:51 - 75% so you can see here that the Walkers
40:54 - are getting smaller as they add in them
40:56 - back in and maybe that's like too much
40:58 - they just get smaller so quickly so
41:00 - let's see what this
41:05 - does am I yeah so you can see over time
41:08 - as I'm adding more and more walkers in
41:10 - they're getting smaller and smaller and
41:12 - smaller uh we could also do something
41:14 - now while we're here let that run for a
41:16 - little bit um let's let's see if I give
41:18 - it 50 at a time will it kind of perform
41:21 - okay um so one thing that I want to do
41:25 - is uh and I actually could just have
41:28 - every Walker in sequence be actually a
41:30 - little bit smaller than the previous one
41:32 - that might actually be a better way to
41:34 - do it um because I could have like a
41:36 - radius counter uh and and and that's
41:39 - kind of uh yeah let's do it that way
41:41 - actually let's try this I want to have a
41:42 - radius of starting
41:44 - radius starting R uh I actually just say
41:48 - radius
41:52 - equals
41:55 - uh I can have a starting in
41:58 - radius just for that Center one no
42:00 - that's fine radius so I want to have a
42:03 - starting radius of
42:05 - eight and whenever I make a a walker I
42:07 - say radius times
42:10 - equals 0.99 so shrink it a little bit
42:14 - shrink it a little bit and then there's
42:17 - another place where I make new ones
42:19 - which is here shrink it a little bit and
42:22 - then
42:24 - actually I can take out this idea of the
42:26 - argument because I just going to use a
42:28 - global variable I don't love this
42:29 - anymore I'm just use a global variable
42:33 - radius that's always
42:34 - shrinking uh to go back and um put that
42:38 - in
42:40 - here uh and have this always
42:44 - be radius
42:47 - radius so there is no there is only back
42:51 - now I have I'm sort of simplified back
42:53 - to just two
42:54 - cases I either I'm getting an X A Y
42:59 - and this. R is always just equal to that
43:03 - Global variable rate I I don't like now
43:04 - how I've done this but we're going to do
43:06 - it this way anyway so you can see every
43:09 - single one is like 1% smaller than the
43:11 - previous one which it's kind of
43:13 - interesting because we're getting sort
43:14 - of they're actually not exactly in order
43:16 - so that's not what I intended to happen
43:18 - but we are seeing sort of an interesting
43:19 - result from this and they're getting
43:20 - smaller and smaller and smaller and then
43:22 - I could also say what I like about this
43:25 - is I couldn't I now have sort of like a
43:26 - ter point where I can say if the radius
43:29 - is less than one um only
43:32 - oops only bother to do this if radius is
43:36 - greater than two so now we actually like
43:39 - I don't want to have circles where the
43:40 - radius is less than one so now we
43:43 - actually have a terminal condition for
43:45 - this algorithm and I also now want to
43:47 - add one last thing which is coloring
43:49 - them so uh and you know I could actually
43:52 - uh so the other thing we could do is I
43:55 - could have a um
43:58 - I could map their Hue I could map their
44:00 - Hue uh so I could say it I could say uh
44:04 - color
44:05 - mode HSB and in the Walker object
44:10 - itself got to add this in I could say
44:13 - Phil I could I could say the Hue is
44:16 - mapped to the radius which goes kind of
44:18 - between like 0 and eight to between 0
44:20 - and 360 and I could give it that that
44:23 - color
44:27 - and I think I'm actually going to say no
44:29 - stroke and let's forget about the
44:31 - coloring it based on whether it's stuck
44:33 - or
44:34 - not and I have an error
44:44 - somewhere so we can see now and they're
44:47 - not actually so I probably should order
44:49 - their color based on when they get stuck
44:52 - but this is kind of interesting
44:53 - nonetheless and you can see as they're
44:55 - getting smaller and bigger and you know
44:57 - uh I don't know what just why it just
44:59 - stopped right there
45:01 - oops but you could see I'm going to
45:03 - clean up this code and give you a
45:05 - working version I might change the order
45:07 - around the colors I'm going to um uh I'm
45:11 - very good at crashing Chrome but you can
45:13 - see sort of the ideas behind this
45:14 - particular algorithm I don't really I
45:17 - time is up I think because this has G on
45:19 - for way too long I don't have a good
45:21 - perfect version of this to show you but
45:23 - um I will uh I will include that in the
45:26 - the link from this video to the source
45:28 - code I'm going to make both a P5 Jaz and
45:30 - a processing version of this so I can do
45:32 - kind of like a higher resolution one
45:33 - that kind of generates it and just saves
45:35 - it to like a JPEG so you can see how
45:36 - that works maybe I'll come back and do
45:38 - another video followup about that but
45:40 - now you can see sort of the basic idea
45:41 - and the implementation behind this
45:43 - particular algorithm that's on Paul
45:45 - bork's website okay thank you for
45:54 - watching and I'll see you in another
45:56 - coding challenge
46:00 - back for a quick addendum I actually I
46:02 - kind of cleaned up the cat a little bit
46:03 - and it's making it work a little better
46:05 - now um I had two big things that I
46:06 - missed one is that um it was it was
46:09 - crashing the browser I think I need to
46:11 - point this out because I had this wild
46:13 - Loop that was always trying to fill it I
46:15 - was trying to fill it if it ever got
46:17 - less than a certain amount but I didn't
46:19 - allow myself to add any if radius was
46:21 - below a certain amount so it got stuck
46:23 - in that while loop so I fixed it to just
46:25 - say only do the while loop if radius is
46:27 - greater than one and the other thing
46:28 - that I did is I added a hue variable so
46:31 - that each time it gets stuck I increase
46:32 - this sort of global Hue variable and you
46:34 - can see now the Hue is sort of assigned
46:36 - to the order in which it gets stuck so
46:38 - this isn't doesn't exactly match um what
46:42 - you see on the uh these particular
46:44 - scenarios but I bet you with a little
46:46 - bit fiddling and tweaking of the
46:47 - algorithm you could get something like
46:48 - that so um give that a try and uh if you
46:52 - can if and as you make more beautiful
46:53 - and interesting versions of this uh
46:55 - think about ways of optimizing of where
46:57 - you start the Walkers how many you use
46:59 - how you check to see if they're near
47:00 - something um we'll come back and I'll
47:02 - make some improvements to this okay this
47:03 - is really the end now goodbye