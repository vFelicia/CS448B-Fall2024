00:00 - welcome to one more coding challenge
00:02 - about trees and in this coding challenge
00:04 - I'm going to use an algorithm called
00:06 - space colonization which does not have
00:09 - to do with colonizing space all that
00:10 - would be interesting it's really about
00:12 - colonizing a two-dimensional space of
00:14 - leaves in the screen and you'll see how
00:16 - that makes sense as soon as I start to
00:17 - diagram this out so first I want to
00:19 - mention this algorithm is from a 2007
00:22 - paper that you can read on algorithmic
00:24 - botany org I'll include a link in this
00:26 - video's description there is also a
00:28 - tutorial that I used in preparation for
00:30 - this from the sea of beans website and I
00:33 - will also which goes through this see
00:35 - this a space colonization algorithm and
00:37 - also include a link to this particular
00:40 - tutorial as well so I'm going to do it
00:42 - in this video it simply in two
00:44 - dimensions in JavaScript that's a
00:46 - processing version that I already made
00:48 - earlier this morning I'm going to
00:49 - program it again from scratch in
00:50 - JavaScript and then in a separate video
00:53 - I'm going to extend the concepts into 3d
00:55 - to see if we can create a tree in three
00:57 - dimensions so first before I start
00:59 - programming it let's just talk about
01:00 - what this algorithm is in a very general
01:03 - way so most of the fractal tree type
01:07 - algorithms that I've done in previous
01:09 - videos or that you may have seen work
01:11 - with this sort of methodology of always
01:12 - growing from the bottom a branch grows
01:14 - from the bottom and it branches and it
01:16 - branches and it branches etc etc etc we
01:20 - saw an l-system is a very similar thing
01:22 - about starting from a point and
01:24 - following these drawing extra
01:25 - instructions to kind of spread yourself
01:27 - out around the screen the way the space
01:30 - colonization works is let's say this is
01:32 - your canvas and you have some volume
01:37 - some little area and you could imagine
01:39 - like creating something sort of tree
01:41 - like like this that is filled with
01:44 - leaves and the leaves are represented as
01:48 - dots so in other words in a way instead
01:51 - of growing from the bottom and reaching
01:53 - the end this algorithm starts with the
01:55 - end like just a random sea of dots those
01:58 - are all the leaves then what happens is
02:00 - you create these segments and each
02:03 - segment is attached to another segment
02:05 - and once the segment once a segment
02:08 - starts to get close to leaves it becomes
02:12 - a track
02:13 - it almost like gravitational attraction
02:14 - to those leaves and we get to tracked it
02:17 - to a leaf it spawns another branch which
02:20 - then as it goes more for our segment
02:21 - which does goes more for it might start
02:23 - to get attracted to another to another
02:25 - branch so you know this is sort of the
02:27 - basic idea and as I start to write the
02:30 - code and get the code for the branches
02:32 - the segments the branch segments and the
02:34 - tree and the leaves going we'll start to
02:36 - see a little more of an itty Gritty of
02:38 - how this algorithm really works they'll
02:39 - come back to this diagram so let's come
02:41 - back over here and I'm going to go to
02:46 - the browser this is a this is what I
02:48 - have so far it's a blank canvas and I'm
02:50 - going to go to my code and all I have
02:53 - right now is set up and draw but I've
02:55 - already created by the way a whole set
02:58 - of other JavaScript files they're empty
02:59 - but I know I want to have a leaf object
03:01 - I want to have a branch object and I
03:03 - want to have a tree object so the first
03:05 - thing I'm going to do is write a
03:06 - constructor function for a tree and in
03:12 - that tree
03:12 - I'm going to have an array of leaves and
03:17 - when you first make a tree I want to
03:22 - create and let's just start with 100
03:24 - leaves so I need some way of creating
03:26 - all the leaves at first so I'm going to
03:28 - say this dot leaves dot push a new leaf
03:32 - so the very first thing I need to do is
03:34 - just create all those leaves that are
03:36 - going to be in the canvas so I've got
03:38 - that and now in leaf I now want to write
03:45 - a function for a leaf and a leaf is just
03:47 - something with a position so this stop
03:50 - position equals create vector and what
03:53 - I'm going to do actually for simplicity
03:54 - is just make a random location in the
03:57 - canvas so the very first thing I do is I
04:01 - just create a leaf object that has a
04:02 - position vector and the tree object
04:05 - makes an array of a hundred of those
04:07 - leaves and I could also have a function
04:09 - here like this dot show and I could say
04:13 - for all of the leaves
04:22 - draw a of have each leaf leaves index I
04:26 - so to draw the tree draw all the leaves
04:30 - okay so that means now I have to go to
04:32 - the leaf and write a show function and
04:36 - in this show function I'm just going to
04:39 - draw the leaf as a circle at this pause
04:42 - at X this pause Y and you know four by
04:45 - four and maybe the leaf here for
04:49 - simplicity is white and it has no stroke
04:51 - so if I run this particular sketch now I
04:54 - still see nothing why do I see nothing
04:56 - because what I need to do in my main
04:57 - program is I need to say I'm going to
05:00 - actually have a tree and I'm going to
05:03 - make and set up I'm going to make a new
05:06 - tree and then I'm going to say tree dot
05:09 - show okay up leaves is not defined tree
05:14 - is 10 and this is what I forgotten is
05:17 - this dot length and this dot leaves show
05:20 - okay so you can see this is what how I
05:23 - could start I could start with just
05:24 - random leaves now if you how the tree is
05:28 - actually going to look where you place
05:30 - those leaves randomly can really make a
05:32 - difference are they within a box oh
05:33 - they're within a circle or within kind
05:34 - of like a heart shape so there's a lot
05:36 - of possibilities there but this is kind
05:37 - of the basic idea and I'm actually we
05:40 - could see what happens if I create five
05:41 - hundred of them now there's many more
05:43 - leaves in the window so now what I need
05:46 - to do next is create a branch the root
05:51 - of the tree so I need to figure out what
05:55 - goes in this these branch objects so the
05:57 - branch objects if I've been in the wrong
05:59 - place the whole time no the branch
06:02 - objects the branch objects are these
06:07 - little segments and the way that this is
06:10 - going to work or here's an
06:11 - implementation that you could do is you
06:13 - could create a branch object really just
06:15 - only as a position and then when you
06:22 - make a new branch object that new branch
06:25 - object also has a position but it also
06:28 - stores a reference to its parent and if
06:32 - it knows a reference to its
06:34 - parent that segment can always be drawn
06:36 - as a line between its parent and itself
06:39 - so each break each segment is really
06:41 - just also going to be a dot so we're
06:44 - going to start with that so what I'm
06:46 - going to do is I'm going to create a
06:49 - branch object and the branch object is
06:58 - also going to have a position and it's
07:02 - going to have a parent so its parent is
07:06 - another branch so its position is
07:10 - probably something that I'm going to
07:11 - want to get maybe as an X and a Y or
07:14 - even better yet as another as a so as a
07:18 - position and its parent I also want to
07:22 - get as a parent so look at this so I
07:28 - want to create whenever I create a
07:29 - branch I want to give it a position and
07:31 - the parent that's connected to okay so
07:33 - now if I go back to tree in addition to
07:36 - creating a bunch of leaves what I want
07:39 - to also create is the root of the tree
07:42 - so the root of the tree is a new branch
07:46 - and where should it start it can only
07:49 - start anywhere I'm going to weirdly
07:51 - start it in the middle of the window I
07:53 - think that might be interesting and so I
07:55 - need a vector so I'm going to say var
07:58 - position equals create vector in the
08:01 - middle of the canvas with / - height / -
08:04 - and I'm going to make a branch at that
08:08 - position and the root of the tree what's
08:11 - its parent it has no parent so I'm going
08:14 - to just say no so the root is a kind of
08:17 - special case in which that it has no it
08:22 - has no parent so I'm going to have that
08:24 - root and then I also want to have an
08:29 - array of branches and I want to take
08:33 - that root and add it to that array of
08:38 - branches okay now the question oh and
08:42 - you know what I totally forgot something
08:44 - really important so by definition the
08:46 - way that this
08:47 - action algorithm is going to work
08:49 - imagine there are like three leaves here
08:52 - and I have a branch here the branch by
08:54 - definition needs to have a direction a
08:57 - direction that it's pointing because the
09:00 - next branch is the next set and really I
09:02 - should use the word segment the next
09:04 - segment is going to be added at the end
09:06 - and it's going to get a copy of its
09:08 - direction but it's going to get pulled
09:10 - toward the closest leaf which is what's
09:12 - going to cause this kind of meandering
09:14 - of all of these segments so what I need
09:17 - to do in addition is give where am I I
09:23 - need to be in branch each branch needs
09:25 - to have a direction so the direction is
09:28 - also something that I can get from the
09:31 - constructor and so when I make that
09:33 - route I need to and where do I do that
09:36 - entry I need to also give it a direction
09:40 - so I think like the order of my
09:42 - arguments here is a little bit weird I
09:43 - make a new branch at a position and then
09:47 - uh and know is the parent let's go look
09:50 - at that again sorry so position parent
09:53 - let's put the parent first so I'm going
09:59 - to let me come back here and I'm going
10:05 - to say sorry tree branch ah I lost this
10:08 - where am I treat I'm gonna say position
10:10 - null is the parent that's the position
10:13 - and now I also need to give it a
10:15 - direction and I'm just going to
10:16 - arbitrarily have it pointing up so this
10:24 - would make sense especially if I have a
10:25 - root of a tree like pointing up so I
10:27 - want to have that tree pointing up so
10:29 - one thing that I need to do is here's a
10:32 - key there's a key set of there's a key
10:34 - piece of data in this algorithm there's
10:36 - a lot of pieces to this algorithm but
10:38 - key piece of data or something called a
10:40 - minimum distance and a maximum distance
10:43 - and if you read the paper this will be
10:45 - described in the paper the idea here is
10:49 - that later you're going to see that I'm
10:51 - going to be looking at the leaves and
10:54 - I'm going to look at the leaves
10:55 - Leigha Leafs a Leafs distance to various
11:00 - branches very
11:01 - segments that are in the system and
11:03 - belief for it to be relevant has to be
11:06 - between that minimum and maximum
11:07 - distance if it's too far away from any
11:10 - branches it doesn't play a role if it's
11:12 - too close to a branch it's actually been
11:14 - reached and it's done so one thing that
11:16 - I need to do when I start if I only have
11:19 - this single branch I need to make sure
11:21 - that branch is at least within a maximum
11:24 - distance of one of the leaves so the
11:26 - first thing I want to do is add this
11:29 - maximum distance variable and I'm just
11:31 - going to say like a big number for now
11:33 - and a minimum distance and kind of a
11:35 - small number for now so I'm going to say
11:37 - 510 is kind of arbitrary numbers that
11:39 - I'm going to pick what you choose for
11:41 - these values can really affect the
11:42 - system and then what I'm going to do in
11:45 - this tree constructor is I'm going to
11:49 - say okay I made this route and what I
11:51 - want to check is what is the distance oh
11:57 - boy there's a lot going on your p5
11:59 - vector dot distance between the roots
12:02 - position and any given leaf okay so I
12:09 - need to loop through all of the leaves
12:17 - okay I need to loop through all of the
12:19 - leaves leaves index i dot pause so I
12:24 - need to check the distance between the
12:27 - roots position and the leaves position
12:29 - and if the distance is less than max
12:36 - distance then we've got a branch that's
12:39 - close enough to start doing the
12:40 - algorithm so I want to say var found
12:46 - equals false and then I'm going to say I
12:50 - found equals true and actually what I
12:57 - want to say here is current equals root
13:01 - because what I'm going to do is I'm
13:07 - going to say while not found keep doing
13:13 - this
13:16 - so what I'm going to do here is I'm
13:18 - going to say I want to like check this
13:20 - beginning route like the tree is going
13:22 - to keep growing growing just in a
13:24 - straight direction until it's close to
13:26 - some of those leaves and this you'll
13:28 - actually see in most cases we'll do this
13:30 - later though all the leaves are at the
13:32 - top and the root starts from the bottom
13:33 - so it's just growing straight up until
13:35 - it reaches the leaves and starts to fan
13:37 - out so I start by assuming it's not
13:40 - close enough but if the distance is less
13:44 - than max distance found is true and this
13:46 - while loop should stop but but if if it
13:54 - is not found then I need to make a new
13:57 - branch and how do I make the new branch
14:01 - I can actually take that root branch
14:03 - right remember a branch this is tricky a
14:08 - branch is a position and a direction so
14:14 - what I want to do is get the next branch
14:16 - a next segment attached to it which
14:18 - would be this new position and a copy of
14:20 - that direction so what I can do is bar
14:26 - branch equals and what I want to say is
14:28 - current dot next so why not just have
14:32 - the the branch itself
14:36 - give me the branch that's attached to it
14:38 - so so if I go to the branch I could
14:42 - write a function and this is kind of
14:44 - recursion here in a way next is a
14:47 - function where what does it need to do
14:52 - it needs to make a new branch next
14:55 - branch is a new new branch and where is
14:59 - that new branch so first of all the next
15:01 - branch is its parent is this particular
15:04 - object that's its parent its position is
15:10 - is this particular objects this
15:14 - particular branch is position plus its
15:16 - direction so I need next position equals
15:20 - add this position and this direction
15:27 - so next position and then its direction
15:31 - is just all so this branches direction
15:34 - but I want to be careful about this and
15:36 - so I'm going to make a comment
15:38 - call the copy function because I I want
15:41 - to make a copy of the vector in case
15:42 - various branches change their change
15:46 - their direction the original one should
15:47 - keep their original direction so then I
15:50 - can say return next branch so what am I
15:54 - doing here if I go back to the tree what
16:00 - I'm doing is I'm getting the next branch
16:03 - and then current equals oops
16:08 - current now equals that next branch and
16:11 - I also want to say branches dot push
16:14 - current so this is what I'm going to do
16:18 - now I'm not sure i 100% got this right
16:20 - so I need a way of testing this so first
16:22 - of all let's just run this so branches
16:26 - is not defined so I have some errors so
16:29 - I guess I decided I was going to okay so
16:31 - I can't I can never remember to say this
16:35 - so anytime I refer to branches I need to
16:38 - say this leaves is not defined in line
16:43 - 20 so I need to say this dot leave and
16:45 - this dot leave and cannot read pause of
16:50 - undefined in line 21
16:53 - whoops back I had forgot a little bit of
16:57 - code in the for loop there so let's take
16:59 - a run this again to see okay so I don't
17:01 - see anything here because I'm not
17:02 - actually drawing those branches so let's
17:04 - go through now and say also for VAR I
17:08 - equals 0 I is less than this branches
17:11 - length I plus plus and what I want to do
17:16 - is say this dot branches index I dot
17:22 - show so I want to draw all the branches
17:24 - so I need to go to the branch object and
17:26 - I also need to add a this show function
17:31 - and now as long as parent is not equal
17:36 - to null so remember all this is only the
17:38 - root doesn't have a parent what I want
17:40 - to draw is a
17:41 - line from this dot position X this stop
17:44 - position not y2 this parent dot position
17:47 - dot X this dot parent da position dot Y
17:50 - so let's make this line white and and so
17:59 - now if I run this again let's see here
18:02 - now let's change this around a little
18:03 - bit what I want to do is actually have
18:06 - the tree start the root start from the
18:10 - bottom and let's actually also have the
18:14 - leaves get a random location that's
18:17 - about a hundred pixels off of the bottom
18:21 - so in this case we should see the
18:24 - branches being attached themselves up
18:26 - until they get within within maximum
18:29 - distance so although maybe the first one
18:34 - is my maximum distance is so high yeah
18:40 - so that worked so you can see here now
18:43 - the this root is going to go all the way
18:46 - up until it gets within a certain number
18:48 - of pixels of one of those branches okay
18:53 - so now once that's done that's the thing
18:59 - so let's just review what we've got so
19:01 - far the only thing we've done so far we
19:06 - come back to this diagram is start with
19:09 - and I'm going to draw this again over to
19:11 - the right we've started with segments
19:15 - that are approaching the leaves and once
19:19 - one of the segment's gets within minimum
19:22 - and maximum distance we need to do
19:24 - something different okay then we stop so
19:26 - we're really just working on getting the
19:28 - root of the tree in place and once we
19:30 - get the root of the tree in place this
19:32 - is where things start to shift instead
19:35 - of working from the branches we're
19:37 - actually going to work from the leaves
19:40 - okay so let me come back over here and
19:43 - now what I want to do in the tree so
19:45 - this is all the stuff that's kind of
19:47 - happening just at the beginning just to
19:50 - get the tree sort of set up and now what
19:53 - I want to do is
19:54 - add a function called grow and the
19:57 - function called grow I want to look at
20:01 - all of the leaves so we're going to go
20:06 - through every single leaf bar I equals 0
20:09 - I is less than this dot leaves out
20:11 - length I plus plus and I want to look at
20:14 - each leaf so each leaf is this dot
20:16 - leaves index I for every leaf what I
20:22 - want to do is figure out what is its
20:25 - closest branch does it have a closest
20:28 - branch that's in between the minimum and
20:30 - maximum distance so here what I need to
20:36 - do is say VAR j equals 0 j is less than
20:39 - all of the branches dot length and it's
20:42 - this dot branches j plus plus and before
20:48 - I do this I need to figure out a couple
20:50 - things I need to what I what I'm looking
20:53 - for is the closest closest I can't
20:58 - closet closest branch I'm going to
21:01 - assume that to start that there's no
21:03 - closest branch and I also might need the
21:07 - closest direction so the direction of
21:09 - the closest branch but that's in the
21:11 - branch so I don't need to worry about
21:12 - that right now so I'm going to look at
21:14 - every single branch ok so so the main
21:21 - thing I need to do is look for the
21:23 - distance this is really hard this is
21:27 - very long I don't know if this is such a
21:28 - good idea this particular algorithm
21:30 - should have done this in multi parts
21:31 - whatever this is how it's going today
21:34 - ok so what I need to do now I'm looking
21:37 - for the closest branch so I have to find
21:39 - the distance write the P 5 vector
21:43 - distance function gives me the distance
21:45 - between two vectors so I want the
21:48 - distance between the Leafs position and
21:50 - I'm also going to just make a separate
21:54 - variable called branch which is this dot
21:56 - branches index J and that branch is
22:00 - position so a couple things if
22:06 - that distance is between minimum is less
22:09 - than minimum distance so leaves only
22:12 - exists to attract branches toward them
22:15 - once a branch has reached a leaf that
22:17 - leaf is no longer in play so we have to
22:20 - mark that leaf for deletion so I'm going
22:22 - to say lead it's reached leaf dot
22:25 - reached equals true so that means I need
22:27 - to go back to the leaf object and add a
22:30 - variable called reached which is false
22:32 - and we'll use that for something later
22:33 - so the main thing I need to do here in
22:36 - this particular tree I'm in this
22:39 - particular part again okay I'm looking
22:40 - for the closest branch but if I happen
22:42 - to find a branch that's too close that
22:44 - I'm done leaf is reached break and I
22:49 - think I might have when I was doing this
22:50 - earlier I think this might be indication
22:52 - of the bug there was a bug in my code
22:54 - previously and I think maybe this is
22:56 - where it was but we'll find out now
22:59 - otherwise else if distance is greater
23:04 - than max distance then also forget about
23:08 - it this is something to be ignored if
23:10 - it's still greater than max distance
23:13 - forget about it this is a this this
23:16 - particular branch should be ignored
23:18 - actually this no no I shouldn't break
23:21 - because I want to check other branches
23:23 - so I don't need to break I just don't
23:25 - want to include it as anything relevant
23:30 - else if d o else if closest branch is
23:36 - null so if the if it if it's not too far
23:41 - away and there is no closest branch yet
23:43 - guess what it's the closest branch so
23:47 - that means closest branch equals this
23:50 - particular branch and ah what do I need
23:53 - I need a record right that record
23:56 - distance because I want to know if I
23:58 - find another branch that's closer is it
23:59 - even closer so I'll make up some really
24:01 - big number to start with that's kind of
24:04 - ridiculous that's plenty big and then
24:06 - the record is that distance now
24:10 - otherwise last thing else if distance is
24:16 - less than that record
24:20 - right if closest branches not no and
24:23 - it's not greater than the maximum
24:25 - distance if distance is less than that
24:27 - record then guess what we have a new
24:29 - record and a new closest branch so you
24:33 - can notice here that I'm doing the same
24:35 - thing right if it finds something that's
24:36 - null and it's not greater than maximum
24:38 - distance there we go I really think that
24:41 - was the problem my previous code and
24:44 - then otherwise so both of the same thing
24:47 - so I can actually put it over here
24:49 - if you notice like if ever like these
24:50 - two else's do exactly the same thing if
24:52 - it's null or if it's less than record
24:55 - then then this I can I can shorten this
24:58 - so I'm going to do this okay so here we
25:06 - go so this is this whole entire
25:08 - algorithm for every single leaf I'm
25:11 - looking for the branch that's closest to
25:15 - it and it has to be between the minimum
25:18 - distance and the maximum distance so the
25:22 - question now becomes for every leaf
25:24 - after we've looked through all of the
25:26 - branches what do we do what do we do if
25:32 - closest branch is not null that means we
25:37 - found something that means what we need
25:39 - to do is make a new branch with a new
25:43 - direction
25:46 - timeout pause back from a momentary
25:49 - pause I realize there's a very big
25:51 - crucial error in here
25:53 - the thing that I'm checking right I'm
25:55 - trying to find the closest branch and
25:57 - the way that I know I haven't found a
25:59 - closest branch yet is if closest branch
26:01 - is no so this should not be checking if
26:03 - it's not equal to no this should be
26:05 - checking if it's equal to no and I could
26:07 - use 3 equals or 2 equals it's a little
26:08 - bit interchangeable in this spot down
26:10 - here later I'm going to check did I
26:12 - actually find a closest branch so now I
26:14 - have this segmented out if if this
26:17 - particularly is so close to a branch the
26:20 - leaf is done
26:21 - and also this I can also just be safe
26:23 - about this and set closest branch equal
26:25 - to null if it's greater than maximum
26:28 - distance do nothing and if it's
26:32 - between minimum distance and maximum
26:34 - distance then is it actually the record
26:36 - at this point if it's the first one it
26:38 - is the record or if its distance beats
26:40 - the record it is the record okay once we
26:42 - have that we now have we now have our
26:46 - closest branch so when we have the
26:48 - closest branch that we need to do
26:50 - something we need to create a new branch
26:52 - our new segment and let's look at how
26:54 - that works so here I have an existing
27:01 - branch this particular branch and I have
27:04 - this is a an existing leaf and this leaf
27:07 - is the one that's determined to be the
27:09 - close this this branch is closest to
27:11 - this leaf what I need to do is get this
27:14 - as a direction vector normalize it right
27:19 - I want it to be a length one okay well
27:22 - unliving
27:23 - let's not worry about the normalizing it
27:25 - for a second I need to get this as a
27:26 - direction vector essentially I want to
27:28 - add a new segment but I want this leaf
27:31 - to essentially attract it I want it as
27:33 - if this leaf is pulling on the next
27:35 - segment so instead of the next segment
27:36 - just going straight up it goes this way
27:38 - it doesn't go directly to it this is
27:40 - like a force that's pulling it in that
27:42 - direction because here if this continues
27:44 - the next segment is going to pull even
27:46 - more so that an eventual is going to get
27:47 - so close that it'll this leaf will then
27:49 - get deleted so that's why I'm going to
27:50 - get these nice curvy veiny looking paths
27:52 - so how do I pull it a way of pulling it
27:55 - is normalizing it and then adding it to
27:58 - this particular direction and then
27:59 - putting that at the end here so let's
28:01 - look at how I might do that so here with
28:03 - closest branch what I need to do is
28:06 - create a new direction which is
28:12 - subtracting what am i subtracting I'm
28:14 - subtracting that particularly that
28:19 - particularly
28:22 - the closest branches position and then
28:28 - I'm going to normalize it to make it of
28:30 - length 1 just as sort of a generic and I
28:32 - could scale it in different ways you
28:34 - could try different things to play with
28:36 - it but I'm going to normalize it just to
28:37 - to to make it length 1 and then what I'm
28:41 - going to do is create a new branch
28:49 - pause back again after an edit point I
28:53 - did have a problem here this by the way
28:55 - closest branch
28:56 - I meant to set that to null right not
28:58 - true the point is if it's within that
29:01 - minimum distance it doesn't count
29:03 - set closest branch to know now down here
29:06 - what I need to do again I'm back here
29:08 - and back to give is I needed I needed
29:10 - this branch's direction to get pulled
29:12 - towards this particular leaf so what I
29:15 - want to do is say take that closest
29:19 - branch and then I want to take its
29:23 - direction and add this new direction so
29:27 - I use the direction variable way too
29:28 - many times so I'm going to call this a
29:31 - new direction just to be less confusing
29:34 - and I'm taking that existing branch I
29:37 - found the close the branch closest to
29:39 - that leaf I got the direction I found
29:41 - the branch closest to that leaf I found
29:44 - its direction
29:45 - I found that direction and I'm moving
29:47 - its direction toward that the other
29:48 - thing I need to do is the branch then
29:51 - part of this algorithm is actually
29:53 - having the branches have a count
29:55 - variable so the branch needs to count
29:57 - how many times it's been it's been found
30:01 - near one of the particularly use and we
30:03 - are going to see this later because it's
30:04 - going to be immortan because I want to
30:05 - average all of those sort of forces
30:07 - together so what I'm going to do here so
30:11 - I add a count variable and then I say
30:15 - closest branch dot count plus plus okay
30:20 - so let me recap that this is pretty
30:23 - confusing and tricky to see if I can
30:25 - make this make sense
30:26 - I have a particular I have a branch
30:31 - which has a position and it has a
30:34 - direction now I have a bunch of leaves
30:39 - so let's say if I'm going to show you
30:43 - these two leaves so this leaf finds
30:46 - itself closest to this particular branch
30:49 - so what I do is I make a vector that
30:52 - points from here to there I shrink it
30:55 - down and I add it to the direction so
30:58 - now this but this
30:59 - branches Direction is kind of going like
31:01 - this now later I might find this
31:04 - particularly is also close so I need
31:07 - this particular vector and I add it to
31:09 - that it comes back over here so these
31:11 - branch as I go through all the leaves
31:13 - I'm pulling various branches segments
31:16 - that might be close and like stretch I'm
31:18 - stretching them so not stretching them
31:20 - is the wrong word to pen cap went but
31:22 - but but pulling them as if it's a force
31:24 - okay so this this is now done right this
31:29 - this part of the algorithm is done I'm
31:31 - looking at every single leaf the leaf if
31:33 - it's less than minimum distance from
31:36 - from a branch up for every leaf I look
31:38 - at every single branch if it's too close
31:40 - to a branch we're done with that leaf if
31:42 - it's too far away from the branch it's
31:45 - not a can't that branch is not a
31:46 - candidate if it actually is the closest
31:49 - one I'm going to keep track of it and
31:50 - that branch is going to be attracted to
31:51 - that particularly so once I've done that
31:54 - now it's our job to do the following the
31:57 - first is I need to go through and find
32:00 - any leaves that were too close and
32:02 - delete them so I'm going to loop through
32:04 - and I'm going to I'm going to loop
32:08 - through the leaf array backwards because
32:13 - at what deleting things from an array
32:15 - you need to loop through it backwards
32:16 - because you're taking stuff off the end
32:17 - let's not mess it up so I starts at the
32:20 - end of the array goes down to zero and
32:22 - then I - - so and I'm going to say if
32:27 - this dot leaves index I was reached
32:30 - remember I have in the leaf in the leaf
32:35 - object I have a reached variable at set
32:37 - to false and what do I do in the tree if
32:39 - it's within the minimum distance I set
32:42 - that reach to true so then later I can
32:44 - go through in a separate loop I could
32:46 - have done it in the loop above but just
32:48 - for simplicity I'm doing this in a
32:49 - separate loop I can then say this dot
32:51 - leaves splice delete one element from
32:55 - the array at index I so that's the first
32:58 - thing I can take care of the next thing
33:00 - I can take care of is I need to go
33:03 - through all of the given branches so now
33:06 - I need to look at every single branch
33:09 - and I need to figure out
33:13 - what branches were were attracted to
33:18 - what leaves so how do I know if a branch
33:21 - was attracted to a leaf well I know if
33:25 - it's count was increased by at least one
33:27 - so branches could be attacked in two
33:29 - leaves zero one or more times and I only
33:32 - care and I'm going to save our branch
33:34 - equals this branch's index I just to
33:37 - make my code a little easier to work
33:38 - with I only care about branches whose
33:41 - count is greater than zero and if their
33:45 - count is greater than zero what I need
33:47 - to do is make a new branch attached to
33:52 - it so how do I do that so the first
33:57 - thing I need to do is I need to actually
33:58 - average I need to divide by count
34:02 - because I was adding all those vectors
34:04 - to it and if it was near ten ten
34:07 - different leaves then I want to divide
34:09 - by ten so what I should do is take that
34:11 - branch that branches direction and
34:15 - divide it by that branches count so
34:18 - that's a way of averaging however many
34:20 - branches I was sort of attracted with a
34:22 - force and then I want to make a new
34:25 - branch so if I make a new branch
34:28 - I always need three things I need I need
34:33 - the branches parent the new branches
34:35 - parent is that existing branch then I
34:39 - need the branches position which is that
34:42 - branches oh the parents position plus
34:45 - the bat branches direction so a new
34:48 - position equals create equals add add
34:53 - the previous branches position with that
34:57 - branches direction and that's the new
35:01 - position and then also the direction and
35:08 - I'm going to copy it now I have some
35:09 - redundancy here because honestly if if I
35:13 - am I could actually write a function in
35:15 - the branch object to produce the next
35:17 - branch and I did that actually in a
35:19 - previous processing version of this that
35:20 - I didn't but right now this is where we
35:22 - can see what's going on here I have to
35:23 - make a new branch right that this is a
35:27 - it's growing its parent is the previous
35:29 - one it gets a new position based on that
35:31 - new direction and also it's got a store
35:33 - that direction in case it connects to it
35:35 - starts being pulled towards leaves as
35:37 - well and then I should just be able to
35:39 - say branches this branches dot push new
35:46 - branch well someone's telling me line 66
35:49 - I forgot to add thank you so this should
35:51 - add those two thank you very much yeah
35:56 - okay so so let's I think that's kind of
36:01 - everything this is the grow this funk
36:05 - this is the grow function let's just run
36:06 - this and see if I have any syntax errors
36:09 - so this still looks about right but I
36:14 - didn't actually call the grow function
36:16 - I'm a little bit afraid to I added a ton
36:19 - of code I'm gonna add that grow function
36:22 - now and draw hmm I don't see anything
36:26 - happening okay so we got to figure out
36:28 - what am I missing here
36:30 - at least I'm not getting any syntax
36:32 - errors
36:36 - let's first at least see if grow is not
36:39 - isn't there might be getting stuck in an
36:41 - infinite loop somewhere so in the tree
36:44 - function I'm going to just console.log
36:48 - growing so let me just make sure this is
36:51 - getting called over and over again okay
36:52 - so I'm not stuck things are looping oh
36:55 - the count has to be reset so I forgot
36:58 - something very important each generation
37:00 - I've got a reset I've got to reset the
37:04 - count and also actually the branch
37:06 - should have its original direction it
37:09 - shouldn't change so this is great I
37:11 - forgot an important step no wonder it's
37:13 - I don't know if this is what's causing
37:14 - the problem but I certainly did it
37:16 - forget a really important step so
37:17 - branches have to be reset so what one
37:26 - thing I want to do is say original
37:28 - direction equals so I always want to
37:30 - keep a copy of the branches original
37:32 - direction because after a branches
37:38 - Direction gets manipulated in order to
37:40 - in order to create the direction of the
37:42 - next branch I knew I forgot something
37:45 - I need its direction to go back and I
37:51 - need to copy it again so I need to
37:52 - restore its direction I go I could
37:54 - probably after I do this I could
37:55 - probably go through the code and find if
37:57 - extra places where I copied vectors but
37:59 - I have to be very careful that I don't
38:01 - by accident have vectors pointing to the
38:02 - same data changing one place it changes
38:04 - into another place and I also need to
38:06 - reset count by zero so what I need to do
38:08 - is after at the very end here when I go
38:12 - through all of the branches I need to
38:15 - once again and I should go through the
38:17 - branches this is bad by the way I'm
38:19 - surprised that this didn't cause a major
38:21 - major problem because I'm going through
38:24 - this array of branches and adding to the
38:26 - end so here I also want to start at the
38:29 - end of the array and go backwards down
38:35 - to zero and and then add to the end and
38:40 - I can also if and I know just for safety
38:45 - I can reset all of the branches so this
38:48 - is definitely something that I missed
38:49 - what I need to do is as I'm going
38:51 - through the branches to create to throw
38:54 - the ones that were close to leaves to
38:56 - create the next branch I create the next
38:58 - branch and then reset that branch and so
39:02 - now okay
39:04 - original dir is not defined where is
39:06 - that in branch judge as line 9 of so
39:11 - this by the way to say this dot dir
39:13 - actually kind of work because that's
39:14 - there and then this also needs to say
39:16 - this dot originally okay so promising
39:20 - this is all still growing so what did I
39:22 - miss
39:27 - okay so so let me look here in tree and
39:33 - see why things might have gone wrong so
39:37 - let's just see is this actually
39:39 - happening am i finding things I'm not
39:48 - finding any closest branches now I
39:51 - wonder if there's an issue with my
39:54 - just my like Oh maximum distance being
39:57 - the same as minimum distance that can't
39:59 - be good how did I how did I do that by
40:00 - accident there we go something crazy is
40:05 - happening okay so that kind of worked I
40:07 - think maybe my distance was too short
40:15 - something this is kind of doing stuff
40:17 - now hey I like how this works okay it's
40:19 - working now we're getting a nice little
40:21 - tree growing and branches being
40:23 - attracted to leaves and things being
40:25 - spread out you can see how it's working
40:27 - I think this is kind of about right so
40:31 - there's a couple things that I notice
40:33 - like it's actually running quite slow
40:34 - and something I could do to kind of
40:36 - speed things along that makes more sense
40:38 - is also to to have the branches have
40:42 - kind of a minimum length if you might
40:45 - the length is based on the direction
40:47 - vector which I didn't actually normalize
40:50 - I just realized I think I think there's
40:56 - some like technically some correct way
40:58 - of doing this that I probably missed so
41:00 - if I go here when I made the new
41:04 - direction um let me find that where is
41:09 - that oh I already had this next function
41:16 - look at that I forgot that I have the
41:19 - next function so that this is actually
41:22 - could be I should what one thing I could
41:25 - do to improve this I got this now sorry
41:29 - back where is that in the tree I don't
41:31 - actually need to do this here I should
41:37 - be able to just say this dot branches
41:46 - dot push new branch dot next so I should
41:53 - be able to use the next function which
41:54 - just gives me that next that next branch
41:57 - based on that so that I should be able
41:59 - to use this should be identical so that
42:02 - saves me that's I have that next
42:04 - function I should use that and the
42:05 - reason why I thought back to use that
42:07 - is because I should just do this entire
42:13 - video again because I understand this
42:16 - algorithm so much more now from having
42:17 - to like be in this very awkward place of
42:20 - programming it live but what I want to
42:24 - do here is go back to that next function
42:26 - and what I can actually do is I can say
42:33 - I'm going to make a I'm going to
42:38 - multiply this dot Direction times 5
42:41 - right so this is kind of like the length
42:44 - and you know I can actually give this a
42:48 - length so branches can have a sort of
42:52 - default length and then I can add that
42:56 - so if I do that I know I did that kind
42:59 - of quickly but what you'll see here is
43:00 - like it's kind of growing much faster
43:02 - now because each branch by definition
43:04 - moves by five and I wonder if actually
43:08 - this should always be normalized I don't
43:10 - know if that really makes a difference I
43:12 - think it's the same I think by
43:13 - definition because I divided by count it
43:15 - might have been that's sort of like
43:17 - normalizing it but anyway so this is
43:22 - pretty good so I'm going to stop here
43:24 - I guess I'm going to do so I'm gonna I'm
43:27 - gonna go back to this algorithm and look
43:29 - at it in 3d and maybe but here's the
43:31 - thing
43:31 - so I'm gonna post this code it'll be
43:34 - linked in the description of this
43:35 - particular book incredibly long video i
43:37 - don't know i just like 45 minutes long
43:39 - but really what you want it what i want
43:42 - you if you've watched this if you've
43:43 - stayed with this if you're working with
43:45 - this code what what um should um what
43:52 - you somebody the chat oliver and the
43:57 - chat has made an excellent point which
43:59 - I'm going to fix before I go on but what
44:00 - I want you to do is think about how are
44:03 - you arranging those seed leaves
44:05 - what is your minimum distance what is
44:07 - your maximum distance what is your
44:09 - length of each branch so what types of
44:12 - patterns leaf vanie tree like patterns
44:14 - even in 2d how could you use color you
44:16 - know how can you use thickness the more
44:18 - branches that are layered in the same
44:20 - spot can you make it
44:21 - Aker try some of these ideas improve on
44:23 - this and I'll try to come back in
44:25 - another video and kind of make these
44:27 - improvements because I think it would be
44:28 - good to do a follow-up on this but let
44:30 - me just fix one thing I don't need to
44:34 - normalize the direction because I
44:38 - divided by count but where did I divide
44:41 - by count I divided by count here but I
44:45 - really should be dividing by count plus
44:46 - one because I'm also including the
44:49 - original direction vector which is a
44:51 - unit vector so I've added that unit
44:53 - vector with all the other unit vectors
44:54 - of close leaves and so there's one more
44:57 - there so I should so that should
44:58 - probably make things more quote-unquote
45:01 - correct and you can see how this works
45:02 - so I'm just sort of curious just to play
45:05 - with this for a minute here
45:06 - like for example entry what if I give
45:10 - myself only 50 leaves you can see kind
45:17 - of what I get there with only 50 leaves
45:19 - what if I give myself 1500 leaves you
45:23 - can see what's happening with 1500
45:25 - leaves and you can see some are getting
45:27 - kind of like a lot some of these like
45:29 - perfectly equidistant ones or getting
45:31 - ignored like the branches just go right
45:33 - through the middle of them which is kind
45:34 - of interesting but really what be more
45:36 - interesting would be for me to arrange
45:37 - the beginning okay I have to end this
45:39 - video now I'm going to move over to
45:41 - processing in the next video and look at
45:44 - the same algorithm and try to extend it
45:45 - into 3d and at some point I might come
45:47 - back and try to do that in JavaScript in
45:48 - 3d as well okay thanks for watching