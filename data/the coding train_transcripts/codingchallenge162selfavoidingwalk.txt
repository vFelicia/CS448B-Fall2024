00:00 - [Applause]
00:00 - hello welcome to a new coding challenge
00:03 - video
00:03 - this is part two not really or maybe
00:05 - it's part three or four
00:07 - of a video that i made four years ago in
00:10 - 2017
00:11 - the random walker you're seeing the code
00:13 - for it right over there and every time
00:15 - i've ever demonstrated this example
00:17 - i've mentioned how one thing you could
00:19 - consider trying to do
00:20 - is something known as a self-avoiding
00:23 - walk
00:24 - a self-avoiding walk looks like this
00:26 - here's the wikipedia page for it
00:27 - it's a random walk where a random
00:30 - decision is made to move up down left or
00:32 - right
00:32 - but if that spot has already been
00:35 - stepped into
00:36 - then it can't be stepped into again and
00:39 - the walker has to choose a different
00:40 - direction
00:41 - and in theory it can create a path that
00:43 - fills an entire 2d space
00:45 - and i'm going to try to take this code
00:47 - example and change it to that
00:49 - today in this video if i have succeeded
00:52 - then in the magic of post-production the
00:55 - final results will be appearing next to
00:57 - me right over here
00:58 - if i have not succeeded then maybe
01:01 - nobody will ever be watching this ever
01:02 - again in the future
01:04 - we'll see let me first just review what
01:07 - is a random walker
01:10 - so this dot here is my random walker
01:12 - every frame of animation
01:15 - it can choose to go one of four
01:17 - directions up down left right
01:19 - once again here we see this is the
01:20 - visual result that we get from the
01:22 - random walker
01:23 - in order to do a self-avoiding walk i'm
01:25 - going to need
01:26 - some other data structure to keep track
01:28 - of all
01:29 - of the spots inside of this 2d world by
01:33 - the way
01:34 - we should really try someone should try
01:35 - maybe i will making a 3d version of this
01:37 - if i get this done but we'll come back
01:40 - to that another time
01:43 - if i think about a very small 2d space
01:46 - that's five by five
01:48 - and let's say i start the random walker
01:50 - in the middle as usual
01:52 - now if it randomly decides to go up it
01:54 - can go there
01:56 - maybe it decides to go to the right
01:57 - maybe it decides to go up again maybe it
01:59 - decides to go to the left
02:00 - now if it were to try to go this way
02:02 - down to this spot that's already taken
02:05 - it can't it can't choose that anymore
02:08 - instead it should choose to go here
02:10 - so i need some type of data structure to
02:13 - keep track of whether a spot
02:15 - has been hit or not and so that could be
02:17 - a 2d array
02:18 - and i can just put the boolean value
02:20 - false in all of the
02:22 - cells and then if it's been there i
02:23 - could put the volume i can flip the
02:24 - boolean value it'll
02:25 - true and i can use that as a way of
02:27 - checking whether it can go there or not
02:28 - i'll try that in code now getting
02:30 - started i'm just going to add one
02:31 - variable i'm going to call it grid
02:33 - that variable grid will hold the
02:35 - two-dimensional array
02:36 - for every spot in the canvas so i need
02:38 - to make a two-dimensional array which is
02:40 - kind of a wonky thing in javascript
02:42 - fortunately this is something that i've
02:43 - tackled numerous times i think the first
02:45 - time was in my mind sweeper coding
02:47 - challenge not the first time i ever made
02:48 - a 2d array but
02:49 - kind of talked about it in a video and
02:51 - in the code for that example i have this
02:52 - make 2d array function i'm going to grab
02:55 - it
02:55 - copy it over here to my new
02:57 - self-avoiding walk
02:59 - i'm going to change this to let and then
03:02 - i'm going to say grid
03:04 - equals make 2d array
03:08 - and have one spot in the array for every
03:11 - pixel
03:12 - do i really want to do that i think so
03:16 - that i can sort of see what's going on
03:19 - more easily i'm actually going to start
03:20 - coding this by thinking of
03:22 - the 2d canvas as much lower resolution
03:25 - so i'm not going to
03:26 - i'll make it 10 by 10. in other words i
03:29 - want a variable called
03:31 - spacing knowing it's a 400 by 400 canvas
03:34 - i'm going to make it 40
03:35 - and then i need to have columns and rows
03:43 - all right so i've changed this so that
03:46 - instead of just having
03:47 - the random walker walk along every
03:49 - individual pixel
03:50 - i now have a set of columns and rows
03:53 - based on a cell size
03:55 - a spacing valve variable and then my xy
03:58 - position of the
03:58 - walker is going to be in the middle and
04:01 - so when i go to draw the walker
04:03 - instead of i'll just leave it as a point
04:05 - but i'm going to make it uh
04:06 - the stroke weight uh this half of the
04:09 - spacing let's just see that and then
04:11 - the walker should move instead of one
04:14 - pixel
04:15 - according uh according to the spacing
04:20 - i'm not sure what i just did there oh
04:22 - whoops i got a major error i still made
04:24 - the grid
04:25 - with height so the grid needs to be
04:27 - based on the columns and rows
04:29 - oh and of course the point then isn't
04:31 - just x y
04:33 - it needs to be x times spacing
04:37 - y times spacing oh and it can still go
04:40 - by one
04:41 - i see i can have it changed by one i
04:44 - need to have it move according to
04:45 - spacing
04:46 - i'm just going to uh draw it it's still
04:49 - moving one column and one row
04:51 - i'm just going to draw it by multiplying
04:52 - spacing got it
04:54 - there we go there's my random walker now
04:56 - just to be sure that this is working the
04:58 - way that i think it is i'm going to make
04:59 - the spacing 5
05:02 - and then we can see yes so already by
05:04 - the way this is kind of an interesting
05:06 - uh different visualization of the random
05:08 - walker
05:09 - you can see that since i'm drawing it
05:10 - with alpha you can see how many times
05:12 - it's been in a certain spot based on how
05:15 - bright that spot is getting
05:16 - but the point of what i wanted to do
05:18 - here is i want it never to be able to
05:20 - return
05:20 - to the same spot again it needs to avoid
05:23 - itself a self-avoiding walk
05:26 - back to 10 by 10 with
05:29 - uh no alpha first thing i want to do is
05:32 - fill the grid with the value
05:36 - false
05:40 - so a nested loop to hit every column in
05:43 - row set to false
05:45 - then wherever the walker is that spot
05:48 - should be set to true because the walker
05:51 - has been there
05:52 - and as it moves the new spot
05:55 - every time in draw should be set to true
06:00 - ah what happened ah
06:03 - there's an infinite loop problem i
06:05 - forgot to change that i
06:06 - to j oh what a nightmare
06:10 - let me fix that and see if i can run it
06:12 - now
06:13 - okay great oh we just went straight down
06:17 - why is that was that just a coincidence
06:20 - yes that was just a coincidence so i've
06:23 - got an error as soon as i
06:24 - fall off the canvas now i think i need
06:26 - to rethink the way i'm doing this right
06:28 - because now i can't go every
06:31 - possibility i can't go one of all four
06:34 - options
06:35 - if i'm here i can only go one of three
06:38 - because i can't go down to where i've
06:39 - already been
06:40 - so before i pick which way to go i
06:43 - should check
06:44 - all of the possibilities so checking to
06:47 - the right
06:49 - as long as to the right is false and i'm
06:52 - going to make
06:53 - an array called options i'm going to put
06:55 - all of the options
06:57 - in there options dot push
07:00 - and i'm going to make a little object
07:02 - that says
07:04 - uh oh oh oh i i have an idea i have a
07:07 - better idea of how to do this
07:08 - this is a little bit weird but just just
07:10 - bear with me for a second
07:12 - i'm going to just make a global variable
07:15 - called
07:15 - options this is all the ways i could
07:17 - always possibly possibly go
07:19 - and it's going to have four objects in
07:22 - it
07:23 - each object should represent to the
07:25 - right
07:26 - down to the left up and i'll call those
07:29 - dx as in delta x delta y
07:34 - so the first option is to the right
07:37 - delta x is one d y is zero
07:44 - so i've now very obsessively made an
07:46 - array of objects
07:48 - each object storing an element that
07:50 - indicates a direction
07:51 - right left down up so then right here in
07:55 - draw
07:56 - i can just check all of those and see
07:58 - can i go in those directions
08:01 - let every option of options new x the
08:04 - next
08:05 - x spot is x plus option dot
08:09 - x so this is the new
08:13 - spot if the grid
08:17 - if that spot on the grid has the value
08:19 - false then it's a it's a perfectly fine
08:21 - option for me to take
08:23 - and i'm going to call this variable all
08:26 - options i'm realizing i could use
08:29 - in a very clever way the higher order
08:31 - array function filter i'll leave that to
08:33 - you as an exercise i have a video about
08:35 - the filter function maybe i'll come back
08:36 - and do that later myself but i want to
08:38 - just write it out the very long-winded
08:40 - way just to really understand what's
08:41 - going on
08:42 - so i'm going to create a a separate
08:45 - array called options
08:46 - and if it's a valid option then i will
08:49 - add
08:50 - add it to this options array now i
08:53 - realize i'm making this kind of
08:54 - confusing
08:54 - because i'm saying options i'm saying
08:56 - option and i'm saying all
08:57 - options let me just explain that for a
08:59 - second all options is
09:01 - all the possibilities no matter what
09:03 - like it's a global variable it's never
09:05 - going to change
09:06 - now i need to know which options are
09:08 - valid in this particular circumstance
09:10 - that's going to be my array options so
09:12 - i'm going to look at every option
09:14 - in all of the options check to see if
09:16 - it's valid and if it is
09:17 - put it in this new options array so that
09:21 - i can say like step equals a random
09:24 - option then
09:27 - x plus equals step dot x y plus equal
09:30 - step dot y
09:32 - and i've moved to the next one so this
09:33 - is just checking which ways can i go
09:35 - and moving forward
09:39 - cannot read property and not a number of
09:42 - undefined sketch line 52
09:44 - oh i called it dx so this is dx this is
09:47 - dy
09:47 - and this is dx and this is y
09:51 - there we go perfect you can see and i
09:53 - think it would be helpful
09:54 - for me to draw a line between the two
09:57 - i'm going to use begin shape and end
09:58 - shape to do that this is i think this
10:00 - will work
10:07 - what did i get so by the way what i'm
10:08 - trying to do here is say begin shape and
10:11 - end shape draw a line between two
10:13 - vertices
10:14 - the vertices the vertex xy then move to
10:17 - the next place and then set the next
10:18 - vertex why didn't that work
10:20 - oh i forgot about multiplying it by
10:24 - spacing
10:25 - oh i'm always forgetting this time
10:27 - spacing
10:31 - there we go so we can see the
10:33 - self-avoiding walk
10:34 - now i'm getting an error when it reaches
10:36 - the edge so i also need
10:39 - the uh it to be invalid if it's not a
10:42 - proper spot in the grid
10:44 - so as long as new x
10:47 - i'm gonna i'm gonna write a separate
10:48 - function i'm gonna say as long as
10:50 - is valid new x new y
10:54 - and it's not and the grid spot is false
10:56 - so i need to write a new function here
10:58 - let's say
10:58 - function is valid i j
11:03 - let's just say it's oh i could actually
11:05 - do both of these in the function
11:08 - let me do this so if i is less than zero
11:13 - return false so it's not
11:16 - valid if i is off the edge so i is less
11:19 - than 0
11:20 - or i is greater than columns
11:24 - greater than or equal to columns
11:27 - j is less than zero or j is greater than
11:30 - equal to
11:31 - rows so if it's off just that's false
11:34 - otherwise return grid i
11:38 - j this could be consolidated into one
11:41 - simple line of code
11:42 - but i'm just basically checking is this
11:44 - a spot that i can go
11:46 - oh return not grid
11:49 - because it's taken if it's true
11:52 - i should not fill them all with true and
11:54 - then i can't go there if it's false
11:56 - whatever you work that out how do you
11:59 - think about this i was thinking about
12:00 - it's taken i flip it to true
12:02 - so it's valid if it's not true if it's
12:05 - false
12:05 - oh boy i really made a i really made a
12:08 - mess of that
12:10 - but there we go ah so when do i get an
12:12 - error here
12:13 - if there are no options so i can say if
12:17 - options dot length is greater than zero
12:22 - do all of that otherwise console log
12:27 - i'm stuck
12:30 - and stop the program from looping
12:34 - let's change the spacing down back to
12:36 - like 10.
12:40 - and there we go we have a self-avoiding
12:42 - walk we're done
12:44 - are we done in a manner of speaking
12:47 - i'm done if a wise person would stop
12:49 - right here and say
12:51 - now as an exercise to the viewer can you
12:54 - figure out how
12:55 - to if you get stuck go back and try a
12:58 - different direction
12:59 - so that's what i mean i could make that
13:01 - a part two but i'm just gonna plow
13:02 - forward so if you want
13:04 - pause make something out of this i think
13:05 - there's a lot of possibilities of things
13:07 - you could create
13:08 - if you want to stick with me i'm going
13:09 - to keep going and work on what's known i
13:11 - think it's what's commonly known as a
13:13 - backtracking algorithm
13:14 - so i have tackled this before all of my
13:16 - maze generation videos i think it's a
13:18 - four-part series about generating mazes
13:20 - those involve a backtracking algorithm
13:22 - where i'm keeping track of everywhere
13:24 - i'm going
13:24 - and if i get stuck i can go back and try
13:26 - a different way i get stuck again go
13:27 - back and try a different way
13:29 - so to do this i need a couple uh key
13:31 - things
13:32 - one is i will need definitely need like
13:35 - a variable i'll call it path
13:37 - which is an empty array and that will
13:39 - sort of keep track of where
13:41 - what's my current path that i'm on so
13:43 - that at any point
13:45 - i can like back up and keep go try a
13:48 - different way
13:48 - so i need that let me make a simpler
13:52 - a three by three grid i think will help
13:54 - us understand this better
13:59 - okay i'm gonna go to the right i'm gonna
14:00 - go down i'm going to go down
14:02 - i'm going to go to the left i'm going to
14:05 - go up
14:05 - i mean it's to the right but i turned
14:07 - left and then i'm going to go up and
14:08 - realize like nope no more options
14:10 - so i need to then go back to this one i
14:13 - already and i need to remember that i
14:14 - already tried to go this way
14:16 - so now there's still no more options i
14:17 - need to go back down here back down here
14:19 - and then i see i remember that i tried
14:21 - to go this way so don't go that way but
14:22 - i can see i can go this way oh that's
14:24 - going to get me stuck
14:25 - eventually i'm going to realize i have
14:26 - to go over here from here
14:28 - so uh how did i thought that diagramming
14:31 - this would really help
14:32 - probably if i had like a very clever
14:34 - animation to explain it that would
14:35 - really help
14:36 - but i think the way to make this make
14:37 - sense to you the viewer right now in the
14:39 - context of this video
14:40 - is i need an object i think i need a
14:43 - cell
14:44 - class let's call it spot so these are
14:46 - all of the spots
14:48 - a class spot and the spot will have that
14:52 - array of
14:52 - options but the options have not just
14:56 - dx and dy they also have a
14:59 - uh like a variable called like taken was
15:02 - it taken already
15:03 - was it tried maybe i call that tried and
15:05 - it would be false at the beginning so
15:07 - i'm keeping track of
15:08 - what was tried and what wasn't tried is
15:10 - that a grammatically correct
15:11 - sentence i am not sure but i'm just
15:13 - gonna keep going
15:15 - first step let me make the spacing 100
15:18 - so we can really see this very clearly
15:19 - oh and you know i'm realizing
15:21 - everything has shifted a little bit up
15:23 - and to the left i need to just like
15:24 - translate the whole world
15:26 - down a tiny bit uh translate spacing
15:30 - by half of spacing oh i put that in
15:33 - setup
15:33 - how silly me that has to be in draw
15:38 - there we go oh look i did it perfectly
15:40 - that actually hit every spot what a
15:42 - lucky coincidence
15:43 - but most cases that won't happen all
15:45 - right so now it's drawn
15:46 - correctly but i need to change it
15:50 - to say background zero so now that i'm
15:53 - erasing the background i don't see the
15:55 - full path
15:56 - so let me add this variable called path
16:00 - and then every time oh every time i go
16:04 - well i want to keep track of where i was
16:07 - so i could make an object to keep track
16:08 - of where i was but i think this is where
16:11 - i need that spot class
16:16 - so i created a javascript file called
16:17 - spot.js and added it to index.html
16:25 - and i just want each spot to keep track
16:27 - of all of the options but i
16:29 - how do i copy an array
16:36 - matter how many years i've been
16:37 - programming i have to google how to copy
16:39 - an array in javascript it's just the way
16:41 - it is
16:42 - for me for you for everybody we all do
16:44 - it amazingly though i forgot that is
16:46 - this called the spread operator right
16:48 - here
16:49 - thanks to this webpage that i just found
16:51 - from samanthaming.com
16:54 - how to clone an array i forgot i need to
16:56 - make a video about that spread operator
16:58 - i will do that i will do that mental
17:00 - note remind me in the comments
17:02 - and by the way i can't just use equal
17:04 - because i need to make a copy because i
17:06 - want to manipulate it and i want the
17:07 - original array to stay the same
17:09 - i'm going to use slice right now because
17:10 - i know slice will work and eventually
17:12 - i'll learn this
17:13 - other dot dot operator but
17:16 - also i want the options now
17:19 - to each have with them a variable that
17:22 - keeps track of whether it was tried or
17:24 - not
17:24 - so this is really becoming like a
17:26 - template
17:28 - by the way if you're wondering why it
17:29 - looks like this now i used the auto
17:31 - format
17:32 - which then got rid of all my perfect
17:33 - spacing oh
17:35 - so now each spot has its xy position
17:38 - oh you know what i should do i have an
17:40 - idea i have a really good idea
17:42 - this should actually be the xy position
17:44 - should be its actual pixel location
17:46 - and i'm going to call its index into the
17:49 - columns and rows i
17:50 - and j that way whenever i want to draw
17:54 - it i can just grab the x y
17:56 - and whenever i want to like look up
17:57 - where it is in the array i'm going to
17:58 - give it the i ij
17:59 - so now essentially here this grid
18:03 - instead of the grid just having false or
18:05 - true in it i can put a new
18:07 - obj spot object to keep track of all the
18:09 - metadata associated with that spot
18:12 - there oh and i guess the spot itself
18:16 - should know whether it was visited and
18:19 - that would be false
18:21 - so what whether the spot was visited so
18:22 - there's two i'm not only keeping track
18:24 - of
18:24 - which directions out of that spot have
18:26 - been checked but whether that spot has
18:28 - even been visited at all
18:29 - and so i would say grid x y visited
18:33 - equals true also
18:38 - path push grid x i should put that spot
18:41 - into the path
18:42 - i see maybe i don't actually want
18:45 - that x and y variable at all maybe i do
18:47 - i'm not sure but i definitely need a
18:49 - variable called
18:50 - spot so that's the current spot so the
18:53 - current spot
18:56 - will be grid x
18:59 - y e you know what i've got it i've got
19:01 - it i'm going to get rid of this x y
19:03 - entirely this makes total sense now
19:06 - i don't need this x y the whatever the
19:09 - current spot is that's the current x y
19:11 - but it's i
19:11 - j in there so this will be grid and i'm
19:14 - just going to start at 0
19:15 - 0 that's going to be simpler i'll just
19:16 - start in the top left
19:18 - and then that spot
19:21 - has been visited and it goes
19:25 - in the path then this code that picks
19:29 - the next spot that should actually be
19:32 - in the spot object except itself like
19:35 - spot should have a function called
19:38 - next spot and
19:41 - there i'll do this code
19:45 - i'm just going to paste that there for a
19:46 - second i'm noticing this will now be
19:49 - spot.x spot dot y
19:53 - and all of this i'm not going to worry
19:55 - about drawing it right now let's just
19:57 - take all of this
19:59 - that should also be here so
20:02 - i want and i'm going to make this i'm
20:04 - going to it'll be a longer name but
20:05 - it'll
20:06 - help valid options
20:09 - let valid options
20:12 - of this dot options
20:15 - check for the new x and this is this dot
20:18 - i
20:18 - this dot j
20:22 - if it's valid i still need that function
20:25 - push it into the valid options
20:29 - if the valid option is greater than zero
20:31 - do all this i
20:32 - kind of want to take the drawing out for
20:34 - a second
20:35 - because i think that's going to be
20:36 - important to not have that in here
20:40 - but definitely pick the next step from
20:43 - the valid options
20:45 - and then return i know i should just
20:47 - return the next spot in the grid
20:50 - this dot i plus
20:53 - step dot dx this dot j plus step
20:57 - dot d y
21:02 - and then if i get to the end and there
21:03 - are no valid spots return undefined
21:05 - is this really right find all the valid
21:09 - options
21:09 - for this particular object and i'm also
21:12 - going to check whether
21:12 - was it tried already but i'm going to
21:14 - get to that right now i'm not going to
21:15 - worry
21:16 - about that why do i have an error here
21:18 - not a comma
21:19 - this is a two dimensional array that's
21:22 - the next spot in the grid is this dot i
21:25 - plus the step
21:26 - this dot j plus the step so back in
21:28 - sketch
21:30 - let next spot equal
21:34 - spot dot step and actually
21:37 - the spot i'm just moving to the next
21:39 - spot is it is it called step
21:42 - next spot spot dot
21:46 - next spot but i could really use some
21:47 - naming help here
21:49 - if there is no spot console log i'm
21:51 - stuck
21:54 - i don't know why i'm saying i'm there is
21:55 - no it's not a person it's not an
21:57 - eye it's a thing i'm just gonna say
22:00 - stuck
22:02 - there's almost zero chance that i
22:04 - haven't made a mistake here but in
22:05 - theory
22:06 - this should be exactly what i had before
22:11 - option is not defined spot line 14.
22:14 - oh my goodness this is let option
22:18 - that should not have changed to valid
22:20 - options
22:20 - [Music]
22:22 - that was the option of all the options
22:25 - check every option see if it's valid put
22:26 - it in the valid options
22:28 - one mistake stuck
22:31 - interesting did it go anywhere i didn't
22:34 - even know it going anywhere
22:36 - hmm all right i gotta debug this console
22:39 - log spot
22:43 - okay the very first spot was undefined
22:47 - let's see did i get some valid options
22:49 - for that spot
22:51 - no oh my is valid function
22:54 - is no longer uh correct
22:57 - it is valid if it hasn't been visited so
23:00 - if grid
23:01 - not visited i forgot that i made each
23:04 - spot in the grid an object so i have to
23:06 - explicitly check
23:07 - the visited boolean variable there let's
23:09 - see what happens now
23:12 - it seems to be having a fine time going
23:14 - forever
23:16 - oh i'm not setting the thing visited
23:18 - when i got there so right here this
23:20 - setting of the spot to visit
23:22 - it in setup i should be doing that for
23:23 - every new spot
23:25 - every time in draw so i'll just put that
23:27 - right at the beginning of draw
23:30 - and let's try this again all right then
23:32 - it gets stuck
23:34 - i can get rid of this console log valid
23:36 - options
23:37 - um i want to put back in the line
23:41 - well actually what i want to do ah
23:43 - before i put back in the line
23:44 - the whole point is i have that path
23:46 - variable so every time i get a new
23:48 - spot i'm going to put this also in draw
23:51 - i'm going to push the spot
23:52 - into the array and then i can draw
24:02 - everything
24:03 - so now this should be drawing the line
24:07 - through all the spots
24:10 - perfect so i could keep drawing circles
24:11 - and lines or whatever but i kind of like
24:13 - the way this is visualized right now
24:14 - so i'm just going to keep it getting
24:16 - really close i mean i've left the most
24:18 - difficult i think what is the most
24:19 - difficult part to the end
24:20 - but hopefully i've built a pretty good
24:22 - foundation for doing this i need to
24:24 - backtrack
24:25 - so if there are no spots left and i'm
24:27 - stuck
24:28 - instead of just stopping what do i need
24:30 - to do
24:31 - i need to go back to the previous spot
24:33 - let me just save
24:35 - previous i'm going to like temporarily
24:37 - save the previous one
24:39 - so that if i'm stuck i can say spot
24:42 - equals
24:42 - previous and i can try another
24:46 - way let's just see what happens if i do
24:48 - this well there aren't
24:49 - other ways for it to try every time it's
24:52 - stuck
24:56 - i can't tell if it's trying going back
25:00 - and trying a different way
25:01 - oh that's the spot that's stuck i can't
25:04 - try a different way in the spot that's
25:05 - stuck i have to remove it and go back to
25:06 - the previous previous one
25:07 - oh that's easy i have it in an array
25:09 - never mind i don't need this
25:10 - because i have it in an array if there's
25:13 - no spot
25:15 - path dot let's get rid of one pop
25:19 - stuck equals pat take that spot off
25:22 - i'm stuck so pop that spot off the path
25:26 - and then the spot is now
25:30 - the last one in the array now can i is
25:33 - there something called
25:34 - pop that i could do without removing it
25:37 - from the array
25:38 - i'll just say path path dot length minus
25:40 - one
25:41 - so i'm just getting rid of that spot and
25:43 - going back one i can't tell
25:46 - yeah yeah did you see it went ahead and
25:47 - then it went back i think that's
25:49 - still stuck so something is kind of
25:52 - working here but
25:52 - i'm missing so many important steps that
25:54 - i can't tell if i've really got this
25:55 - right
25:56 - the thing that i haven't implemented at
25:58 - all
25:59 - is whether whether a direction has been
26:02 - tried or not
26:03 - remember with all the ways that the
26:05 - walker could go
26:07 - i set all of those possibilities as
26:09 - tried false
26:10 - to start with so that i don't try them
26:12 - again so
26:14 - right here if i am going to
26:17 - pick this particular option this step
26:21 - i need to set that it's been tried
26:25 - then as long as it's a valid option
26:29 - and that option was not tried
26:33 - already then it is a valid option
26:36 - options is not defined
26:38 - oh and and option.tried
26:42 - getting stuck pretty fast oh well
26:45 - certainly one thing that i need to do is
26:48 - once i'm removing it
26:50 - it's cleared like it's not part of the
26:51 - path anymore any ways that i tried i
26:53 - could be coming at it from a different
26:54 - way
26:55 - so i should clear all of that meaning
26:59 - i'm gonna i'm gonna call function called
27:01 - clear
27:03 - and definitely say it hasn't been
27:04 - visited like i haven't been visited
27:07 - and reset all of its options
27:13 - okay i'm very close i think
27:17 - there's now this is going to be really
27:18 - challenging to debug i'm not really sure
27:20 - how i'm going to do it
27:21 - because obviously it's kind of working
27:23 - but it gets stuck
27:25 - immediately i think maybe there's an
27:27 - issue with the fact that i'm adding
27:29 - it to the i think i should only add it
27:32 - to the path
27:34 - if it's valid so i think if there's no
27:38 - spot otherwise yeah yeah i shouldn't be
27:41 - i'm always adding it it's just getting
27:42 - added back
27:43 - in so i should only add it to the path
27:47 - if it's the next spot that's valid and
27:50 - then
27:50 - in that sense and say that it is
27:54 - visited and in that sense maybe i will
27:57 - go back
27:57 - and just do a one-time ad in
28:01 - setup for the first spot
28:09 - i think i got a little bit closer there
28:10 - but it's really not working
28:12 - oh boy i'm gonna try setting the frame
28:15 - rate to 1.
28:25 - okay let me set the option the spacing
28:29 - back to 100.
28:33 - so the point is always one point behind
28:36 - and then oh it gets off
28:38 - that so visually there i mean there
28:41 - might be a better way to debug this but
28:42 - visually i'm seeing something quite off
28:45 - in that the
28:46 - end is like lagging behind and then all
28:49 - of a sudden it skips ahead and then
28:50 - that's lagging behind so something's
28:52 - really wrong
28:53 - oh well this is it has to do with
28:55 - drawing this here
29:01 - what if i draw it down here it shouldn't
29:03 - make any difference
29:05 - oh yeah now it's at the end
29:10 - oh it's backing up it definitely is
29:12 - backing up but it's not
29:14 - able to try a different way i'm just
29:17 - gonna shut off this
29:18 - step dot tried for a second
29:26 - aha okay
29:30 - this is right now in that it is going
29:34 - back
29:34 - and trying other ways i think i'm
29:37 - realizing that this
29:38 - is a major error right here all
29:41 - options dot slice i am making a copy of
29:44 - this
29:45 - array but inside the array are four
29:48 - objects and i didn't copy each and one
29:51 - of those four
29:51 - objects i really should make this into a
29:55 - class
29:56 - like i should make a step class but i
29:58 - was trying to like
29:59 - get cut corners by just using some
30:02 - object literals and i think i let myself
30:04 - into a big
30:05 - problem i led myself down into a major
30:07 - error there
30:08 - oh boy so i'm going to add another class
30:11 - here
30:11 - i'm going to call it a step
30:17 - every single step has a direction it's
30:20 - either left right
30:21 - up and down and whether it was tried or
30:22 - not and instead of
30:25 - just copying from a global array here
30:28 - let me write a function called all
30:31 - options
30:33 - and i'm going to return i'm going to
30:35 - manually make a new array with new
30:36 - objects in it everything's
30:38 - brand new it's a new array with new
30:40 - objects
30:41 - new step 1 comma 0
30:44 - comma so now this
30:48 - function all options will make an
30:50 - entirely new array of new objects
30:52 - all with visited set to false because i
30:54 - was setting visited on one and it would
30:56 - set them
30:56 - then then every single spot everywhere
30:58 - had thought it had visited everybody to
31:00 - the right and left and i was a mess
31:02 - not visited tried tried visit it is for
31:05 - when you've been there
31:06 - try this when you tried to go there
31:14 - this is very dramatic because i set the
31:16 - frame rate to one while i was debugging
31:18 - yeah yeah oh it's going it's going it's
31:20 - trying it let's set that frame rate up
31:23 - back to 60 frames per second everybody
31:26 - it's trying all the possibilities
31:32 - it's gonna get it eventually oh i'm not
31:35 - sure i
31:36 - uh set any condition
31:39 - to stop when it gets it it might have
31:41 - gotten it already
31:42 - yeah all right let's set a condition for
31:44 - when it needs to stop
31:46 - so when is it done if it's hit every
31:49 - point
31:54 - alright so if the path has as many spots
31:57 - in it as
31:58 - every spot on the grid it should be done
32:00 - i'm going to try running this again
32:02 - it'll take a little while but hopefully
32:04 - it's going to stop
32:05 - and we'll see console log solved right
32:08 - there in the content i'll wait
32:09 - oh i got there
32:13 - let's pump up the resolution a little
32:15 - bit
32:20 - i should point out that this is a brute
32:23 - force solution so i don't actually know
32:24 - if this is ever going to end i'm going
32:26 - to wait a little bit longer
32:27 - while this is running i'll also point
32:29 - out that i
32:30 - probably should have used recursion for
32:32 - this so i will
32:33 - include in this video's description a
32:36 - link to a version of the code
32:38 - with recursion a function that calls
32:41 - itself maybe that would have made it
32:42 - easier more elegant more beautiful i'm
32:44 - not entirely sure
32:46 - i can come back and revisit that in
32:47 - another video but for now i i kind of
32:49 - like the way that i had to work it out
32:51 - this way
32:52 - okay i'm much too impatient i want to
32:53 - know that this really works
32:55 - so if i look here at the draw
32:58 - loop i do see that this right here
33:01 - is me checking for the next spot so
33:04 - there's
33:05 - no reason why i couldn't just ask to do
33:07 - that multiple times per frame
33:09 - which won't make the algorithm go any
33:11 - faster but i will do
33:13 - multiple times through the algorithm per
33:15 - frame of animation which will let us
33:16 - experience it in a faster way
33:18 - so let's just try saying uh four let i
33:21 - equal zero i is less than let's just try
33:23 - it a thousand times each frame
33:26 - and then also if it's solved not only do
33:28 - i want to say no loop i want to break
33:30 - out of that loop
33:31 - and let's see what happens here yeah so
33:34 - you can see i'm already you could sort
33:35 - of see the speed at which it's getting
33:37 - through all the possibilities
33:38 - now a thousand probably isn't even
33:40 - enough for me to make any significant
33:41 - progress here
33:43 - let's let's try a hundred thousand
33:48 - i am much too impatient i'm going to go
33:50 - up to 500 000.
33:53 - oh you can see the frame rate is
33:55 - starting to dip now so at a certain
33:56 - point it's sort of diminishing returns
33:58 - here
33:58 - i might be able to get more checks
34:00 - through one cycle of draw but if the
34:02 - animation is going too slow then what's
34:03 - the point
34:04 - right i'm going to hope that this
34:05 - actually ends at some point in the next
34:08 - somebody probably calculate the number
34:10 - of possibilities and the probability
34:12 - that it would
34:13 - that i would have uh get it within a
34:15 - certain amount of time
34:16 - well this doesn't seem to be finishing
34:18 - anytime soon i'm trying to think about
34:20 - what the big o notation of this
34:22 - algorithm this is a brute force method
34:24 - doing a little research about this while
34:26 - i'm waiting for this also it should be
34:27 - clear how this is highly
34:29 - this is a graph theory problem i have a
34:32 - graph
34:33 - in other words i have a system a 2d grid
34:36 - each one of these spots is known as a
34:38 - node the nodes are connected via
34:40 - edges and i've done several problems
34:44 - uh other coding challenges i'll put
34:46 - links and all the stuff flying around to
34:48 - those previously
34:49 - in the video's description but
34:51 - essentially here
34:52 - um you know i have the algorithm that
34:54 - i'm using to
34:55 - find a self-avoiding walk that hits
34:58 - every spot
34:59 - even in just an eight by eight right so
35:01 - it's n
35:02 - squared for sure in the sense that if n
35:04 - is 8 there are
35:05 - 64 spots but then
35:08 - for every spot i need to check every
35:11 - other remaining spot
35:12 - i think this is going to be like n
35:14 - squared factorial or something insane
35:16 - oh that's a big number
35:21 - i did a quick calculation here um that's
35:23 - what i got for
35:25 - 64 factorial meaning
35:28 - uh it's a one with 89 zeros
35:32 - so um i don't think this is finishing
35:34 - anytime
35:35 - soon so definitely i will need to
35:38 - revisit this
35:40 - with a more efficient optimized
35:42 - algorithm
35:44 - i could probably find one just to point
35:46 - you the audience to
35:47 - very quickly so first of all look at
35:49 - this calculating the number of
35:51 - self-avoiding walks in any given lattice
35:53 - is a common computational problem
35:55 - there is currently no known formula
36:01 - although there are rigorous methods of
36:02 - approximation i see here that there's a
36:04 - pivot algorithm
36:06 - to try randomly choosing a point and
36:08 - then applying symmetrical
36:09 - transformations
36:10 - well as we can see here i'm finding a
36:12 - lot of interesting papers about
36:14 - self-avoiding walks
36:15 - and i realize i'm definitely gonna have
36:17 - to do some more
36:18 - research into what are some known
36:21 - optimized methods or techniques
36:24 - for approximating a solution to a
36:26 - self-forwarding walk this kind of
36:27 - reminds me of the traveling sales
36:29 - uh sales person problem which there's
36:32 - like i'm sure some relationships here as
36:33 - well
36:34 - maybe i could use a genetic algorithm
36:35 - and try to evolve
36:38 - an optimal uh self-avoiding walk i have
36:40 - no idea
36:41 - uh i hate to stop this because someday
36:43 - it's gonna end
36:45 - but i actually what i want i'm curious
36:47 - to do right now
36:48 - is just go back to uh it doing it just
36:51 - once per frame
36:54 - and upping the resolution quite high to
36:56 - something like five
36:58 - i'm going to hit save i think you know
37:00 - you might find that this
37:02 - even on its own is quite beautiful just
37:05 - the process
37:06 - of trying every possibility in a space
37:09 - so vast
37:11 - is really quite delightful to look at
37:13 - and experience and i think there are
37:15 - probably
37:16 - many unique visual outcomes that could
37:18 - come from this one i suggested is try
37:20 - extending this into
37:21 - a 3d space what would happen if you did
37:23 - that i'm sure you can think of ways of
37:26 - playing with color
37:27 - and other kinds of generative visuals or
37:29 - tying this to something else
37:32 - i look forward to seeing what you make
37:34 - of this code
37:35 - um i will certainly revisit this in a
37:37 - live stream
37:38 - at some point after this is released so
37:40 - at some point hopefully you'll see a
37:42 - link in this video's description to a
37:43 - live stream where maybe i
37:44 - look at some other examples and make
37:46 - some further improvements to this
37:47 - but if there is a kind of uh optimal a
37:50 - better algorithm that i can investigate
37:52 - and come back and do a video on
37:54 - um i definitely will so um let me know
37:57 - in the comments i'm sure i made
37:59 - countless errors here in this video in
38:00 - terms of talking about um
38:02 - the big o notation of this particular
38:04 - brute force methodology
38:06 - but i hope that you enjoyed this video
38:08 - and i did
38:09 - actually make a self-avoiding walk um
38:12 - and i'll see you
38:13 - sometime else on the coding train
38:16 - goodbye
38:20 - [Music]
38:26 - you