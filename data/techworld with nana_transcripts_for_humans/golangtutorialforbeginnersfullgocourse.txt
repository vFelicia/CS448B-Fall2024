With timestamps:

00:00 - in this full course you are going to
00:02 - learn about one of the youngest
00:04 - programming languages that is becoming
00:06 - more and more popular in the cloud
00:08 - engineering world which is go or also
00:11 - commonly known as go link you will learn
00:14 - everything you need to get started with
00:16 - go and start using it in your projects
00:19 - we're going to write a very simple cli
00:22 - application to learn the basics of go so
00:25 - instead of learning the concepts and
00:27 - syntax of go with isolated examples you
00:31 - will learn them while building an actual
00:33 - application throughout the tutorial
00:36 - so first let's see a detailed overview
00:38 - of what you will learn
00:40 - before diving right into the syntax you
00:43 - will first understand why go was even
00:45 - developed its use cases and differences
00:48 - to other programming languages
00:50 - as a next step we will set up our local
00:53 - development environment and see how the
00:55 - basic structure of a go file looks like
00:58 - then as we start writing our simple
01:01 - ticket booking application you will
01:03 - learn the core concepts and syntax like
01:06 - the most common data types such as
01:09 - strings integers booleans as well as
01:12 - arrays slices maps and struts you will
01:16 - also learn about variables and constants
01:19 - about formatted output getting and
01:21 - validating user inputs a concept of
01:24 - pointers in go as well as variable
01:27 - scopes then you will see how to control
01:30 - the application flow with loops if else
01:33 - and switch statements as well as how to
01:36 - encapsulate logic
01:37 - in functions and generally how to
01:40 - organize your code in go packages
01:42 - finally we will make use of go routines
01:45 - to parallelize some of the execution to
01:48 - make our application faster with
01:50 - concurrency so we're gonna learn a lot
01:53 - of things in this course and i hope you
01:55 - are excited to get started also i want
01:57 - to mention that all the demo code from
01:59 - this course is available in a git
02:01 - repository which we will link in the
02:03 - video description so you can follow
02:05 - along easily
02:07 - we have put a lot of effort in creating
02:09 - this course so if by the end of this
02:11 - course you think it was valuable for you
02:14 - let me know by leaving a like and
02:16 - subscribe for more content like this
02:19 - and also be sure to check out
02:21 - techworldwithnana.com
02:23 - for online courses and a complete devops
02:26 - educational program
02:28 - if you want to further educate yourself
02:30 - and bring your career to the next level
02:32 - now for viewers absolutely new to
02:35 - programming in general you can also
02:37 - check out my python course on youtube
02:40 - which is even more targeted to complete
02:42 - beginners in programming and with that
02:45 - let's get started go was created by
02:48 - google in 2007
02:50 - and open sourced in 2009 so it's a
02:53 - pretty young language
02:55 - now whenever you hear about a new
02:57 - programming language the first question
02:59 - you probably have is
03:01 - why do we need yet another programming
03:03 - language what is the purpose of it or
03:05 - how is it better or different from other
03:08 - already existing languages so before
03:10 - diving into the syntax let's see what
03:13 - was the motivation behind creating the
03:16 - go language well the infrastructure
03:19 - where the applications were deployed
03:21 - changed a lot in the last few years
03:25 - multi-core processors became common and
03:27 - also using cloud infrastructure with
03:30 - hundreds or thousands of servers with
03:32 - multiple processors to deploy
03:34 - applications became pretty universal so
03:38 - infrastructure became much more scalable
03:41 - dynamic and had more capacity however
03:45 - most languages couldn't help in writing
03:48 - applications that would take advantage
03:50 - of these infrastructure improvements so
03:52 - basically you had applications that
03:54 - would just execute one task at a time in
03:57 - order but with infrastructure
03:59 - improvements it was possible to now
04:01 - write applications that would execute
04:04 - tasks in parallel do multiple things at
04:07 - once this way making the application
04:09 - faster and more user-friendly a simple
04:12 - example is if you are using google drive
04:14 - you may be uploading or downloading
04:16 - files and folders but you can keep
04:19 - navigating back and forth in the ui so
04:22 - downloading uploading and navigating the
04:24 - ui all happen in parallel or consider
04:27 - youtube you can be listening to this
04:29 - video then scroll down to the comments
04:32 - write a comment yourself like the video
04:34 - etc so the application allows you to do
04:37 - multiple things at once without
04:40 - affecting any other task and this is a
04:42 - concept of multi-threading so each
04:45 - thread is basically processing one task
04:48 - and you can have many of them running in
04:50 - parallel and this makes applications
04:52 - fast but may also cause some issues for
04:55 - example on google docs many users can
04:58 - work on the same document at the same
05:00 - time so when you have two users changing
05:03 - and adding stuff at the same time to the
05:06 - same document this should work smoothly
05:08 - without one user overriding all the
05:11 - changes that another user is making
05:14 - another example where such issues may
05:16 - happen
05:17 - when things are processed in parallel is
05:19 - a booking system for buying tickets or
05:22 - booking a hotel etc let's say again two
05:24 - users are trying to book the last
05:27 - remaining ticket at the same time of
05:29 - course this should work in a way that no
05:31 - double booking happens and this concept
05:34 - is called concurrency and needs to be
05:36 - handled by developers in code so they
05:39 - must write code
05:40 - that prevents any conflicts between the
05:43 - tasks when multiple tasks are running in
05:47 - parallel and updating the same data and
05:50 - many languages do have features for
05:52 - implementing such applications however
05:54 - the code can get pretty complex and
05:57 - handling and preventing the concurrency
06:00 - issues can be pretty hard and with
06:02 - complexity of course there is always a
06:04 - higher risk of human errors and that's
06:07 - where the main purpose and difference of
06:09 - go comes into the picture so go was
06:12 - designed exactly for that purpose to
06:14 - make writing multi-threaded concurrent
06:17 - applications that take advantage of the
06:20 - new performance infrastructure
06:22 - much easier
06:23 - and we will learn about this in more
06:25 - detail at the end of the course when we
06:28 - use go routines
06:30 - so logically enough the main use case of
06:33 - go or what it's best used for is writing
06:36 - applications
06:37 - that need to be very performant and will
06:40 - run on the modern scaled and distributed
06:44 - infrastructure with hundreds and
06:46 - thousands of servers typically on a
06:48 - cloud platform
06:53 - for developing go they wanted to take
06:55 - the simplicity of syntax of a more
06:58 - high-level language like python and the
07:01 - speed and efficiency
07:02 - of a lower level language like c plus
07:05 - plus so you will see the combination of
07:07 - these things in go and i have to note
07:09 - that go is used on the server side or
07:12 - the back inside of the applications and
07:14 - these types of applications can range
07:16 - from microservices and web applications
07:19 - to database services and so on in fact
07:23 - many cloud technologies or technologies
07:26 - that run on modern cloud environments
07:28 - are actually written in go like docker
07:32 - hashicorp vault kubernetes cockroachdb
07:36 - and so on now on top of this main
07:38 - purpose of go go actually has a lot of
07:41 - other advantages one of them that i
07:44 - already mentioned is it has a very
07:46 - simple syntax which makes your code very
07:48 - maintainable easy to read and extend
07:51 - another advantage is that go
07:53 - applications can be built very fast they
07:56 - are also very fast in startup and also
07:58 - when they're running plus go is very
08:00 - resource efficient which means it uses
08:03 - few resources or it requires fewer
08:06 - resources like cpu and ram to run
08:09 - go is also a compiled language and it
08:11 - compiles actually very quickly into a
08:14 - single binary and you can deploy it and
08:16 - run it on different platforms in a
08:19 - consistent way so no matter which
08:21 - operating system or which environment
08:23 - you're using you can take that same
08:25 - binary and basically use it across
08:27 - different platforms so considering all
08:30 - these benefits of simplicity and speed
08:33 - and so on go is becoming more and more
08:36 - popular for writing
08:38 - simple automation applications and
08:41 - command line interface applications for
08:44 - devops and sre tasks as well
08:47 - so now that we know why go was created
08:50 - and what differentiates it from other
08:52 - languages let's jump right into learning
08:55 - the core concepts and syntax of go
09:00 - now to start writing a go project we're
09:02 - gonna need two software programs first
09:04 - of all we're gonna need go compiler and
09:07 - second we're gonna need an ide or
09:10 - integrated development environment where
09:13 - we're gonna write
09:14 - code for go and also execute it as an id
09:18 - we're gonna use visual studio code which
09:20 - is super easy to download and install so
09:23 - if you don't have it yet on your
09:25 - computer just type in install visual
09:28 - studio code in google and basically on
09:31 - their official page you have the
09:33 - download options for
09:35 - all operating systems so go ahead
09:38 - download and install it so that's the
09:40 - first part
09:42 - i already have visual studio code
09:44 - locally so i'm gonna skip this part and
09:46 - second we're gonna need to install go
09:48 - compiler right now i don't have go
09:51 - locally that's why when i type go it
09:54 - tells me command not found so we're
09:56 - gonna install go which is also super
09:59 - easy again type install go
10:02 - and on their official page you have
10:04 - download and install guide and again for
10:07 - different operating systems i'm working
10:09 - on mac so i'm gonna download the go
10:12 - package for mac awesome once that's
10:15 - downloaded just click on the package
10:19 - and it will show you an installer which
10:21 - basically lets you install go step by
10:24 - step setting up everything necessary in
10:26 - the background so we're gonna do
10:27 - continue
10:29 - install for all users we're going to
10:32 - leave all the defaults
10:34 - install
10:36 - authorize
10:37 - and as you see installation was
10:40 - successful
10:41 - so
10:42 - so if i close this window we can remove
10:44 - the installer and go back to the
10:47 - terminal and type go as you see we have
10:49 - go installed that's why you see a bunch
10:52 - of go commands that you can start using
10:55 - now
10:56 - great so we have everything prepared
10:57 - let's create a folder in which we're
10:59 - gonna write our go project
11:03 - and i'm gonna call it
11:05 - booking
11:08 - app
11:13 - and using visual studio code we're going
11:15 - to write go program in that folder so
11:19 - i'm going to open visual studio code
11:25 - and i'm in the booking app folder you
11:28 - can also simply just open
11:32 - visual studio code and then basically
11:34 - choose a folder
11:38 - that you want to work in and you have
11:40 - the same result and i'm going to make it
11:42 - a little bigger
11:44 - for convenience and there is one more
11:46 - thing that we need to do to prepare our
11:49 - setup and that is installing a go
11:52 - extension inside the visual studio code
11:55 - the extension will basically help us in
11:58 - writing the go code it will give us a
12:00 - nice syntax highlighting intellisense to
12:03 - basically easily navigate our code help
12:06 - with troubleshooting and so on so
12:07 - extensions for different languages make
12:10 - it much easier to write code in that
12:12 - language so let's go ahead and do that
12:15 - to complete our setup and on the left
12:18 - side right here you have the extensions
12:21 - tab
12:22 - so if i click inside and then search
12:24 - go
12:26 - it will give us all the available
12:28 - extensions for visual studio code and
12:31 - the first one with the most downloads is
12:33 - the official one from go team at google
12:36 - and
12:37 - you also have a description of what that
12:39 - extension gives you and that's the
12:41 - extension we're going to use so
12:43 - click on install
12:45 - and that's it now we're all set up to
12:48 - start writing our first go application
12:51 - in visual studio code
12:56 - and for that obviously we need to create
12:58 - a file and this is going to be the main
13:01 - dot go file with dot go extension you
13:04 - will see a bunch of pop-ups here to
13:06 - install things for the go extension so
13:08 - go ahead and click on install all and
13:11 - that will install and set up the rest of
13:13 - the stuff
13:15 - and main dot go is basically a standard
13:18 - name for the main file where the go
13:21 - application code is written
13:23 - and to see that in the file explorer we
13:25 - have this booking app folder and inside
13:27 - we have this main.go file
13:30 - now how do we start writing code in go
13:33 - like printing a simple
13:35 - hello world message to the console
13:39 - let's do print
13:42 - quotes hello world
13:45 - and we already see the first
13:47 - benefit of a go extension because it
13:49 - tells us that this code doesn't work
13:52 - and as you see the error says that go
13:55 - can't find a file called go.mod
13:59 - so the first thing we need to fix is to
14:01 - make our go application into a project
14:04 - and for that we need to basically
14:06 - initialize it
14:08 - that's the error that we get here and to
14:10 - do that we're going to open a terminal
14:12 - in visual studio code
14:15 - new terminal window and
14:18 - this will give us
14:20 - terminal in booking app folder which
14:22 - we're in
14:24 - which is very convenient and here i'm
14:26 - gonna run a go command called go
14:29 - mod or module
14:31 - init
14:32 - and basically name of the project we
14:35 - called it booking app so let's use that
14:37 - name so this is gonna basically initiate
14:40 - our go application into a module or a
14:44 - project
14:45 - and we're calling it booking app so
14:47 - let's execute
14:50 - and save
14:51 - so what this command actually did in the
14:53 - background is it generated this go dot
14:56 - mod file which simply describes the
14:59 - project with the name
15:02 - of the project and the version of go
15:05 - that is used here
15:06 - so the first issue is now fixed now we
15:08 - have another error that says expected
15:11 - package
15:12 - so in go everything is organized into
15:16 - packages and we're going to be using go
15:18 - packages throughout our application and
15:21 - when we create our own application we
15:23 - also have to include it in a package and
15:26 - doing that is actually very simple
15:28 - as the first line of our go application
15:30 - we
15:31 - define keyword package
15:34 - and then name of the package which our
15:37 - application will be part of and the
15:39 - standard name for the main application
15:42 - is
15:43 - package main so now we have an
15:46 - initialized go application which is in a
15:49 - package called main moving on to the
15:52 - next error we now see again a different
15:55 - message that says that a declaration is
15:58 - expected now i have to note here that
16:01 - you may actually have a different
16:02 - sequence of errors so you might see a
16:04 - different message here but i'm going to
16:06 - show it to you with my examples so in
16:09 - this case we have a missing declaration
16:12 - and that is basically
16:14 - goes way of saying
16:15 - i don't know where to start executing
16:18 - this
16:19 - application
16:20 - so give me an entry point
16:22 - and we have to declare
16:24 - the entry point of our application
16:27 - because when we run go applications we
16:30 - need the main starting point for the
16:33 - execution so go needs to know where does
16:36 - it start executing the code on which
16:39 - line because if you have multiple files
16:41 - in the go project you need to give go
16:44 - compiler a starting point the first line
16:47 - of code where the execution starts and
16:50 - the entry point is
16:51 - a main function that go will look for
16:54 - whenever you execute your go application
16:57 - and we create a main function using func
17:00 - keyword
17:02 - name of the function again it has to be
17:04 - called main
17:06 - and we have to put
17:09 - our logic
17:10 - whatever we are executing within that
17:12 - main function so now go will know where
17:15 - to start executing our application and
17:18 - for one go application you're going to
17:20 - have a one main because you can only
17:22 - have one entry point
17:24 - to your application so now we have a
17:26 - slightly changed syntax highlighting for
17:28 - our print function and if we hover over
17:31 - it we see another error message that
17:34 - says undeclared name now we've come to
17:36 - the point where our application belongs
17:39 - to a package we have the entry point so
17:41 - go knows where to start the execution
17:43 - and it sees that print is the first code
17:47 - that it's going to execute but the
17:48 - problem here is that it doesn't know
17:50 - where print is coming from that's why we
17:53 - see undeclared name and print is a
17:56 - function that comes from a go package a
17:59 - built-in package called
18:01 - fmt or format and we have to explicitly
18:04 - import any packages from which we're
18:07 - using the functionality so we're going
18:09 - to do import
18:11 - quotes fmt that's the name of the go
18:14 - package
18:15 - and to use a print function or any
18:18 - function from the package
18:20 - we're going to do
18:21 - fmt dot print
18:24 - and immediately
18:26 - as you see
18:27 - the error is gone
18:28 - and as i mentioned similar to many other
18:31 - programming languages everything is
18:33 - organized into packages so the go
18:36 - program that we installed actually
18:38 - already has some built-in packages with
18:40 - a bunch of functionality
18:42 - that we can use and one of them is this
18:45 - package that we just imported and as i
18:47 - said the packages have functions that we
18:50 - can use so whenever we want to use a
18:52 - built-in go function to print a text to
18:55 - get user input to validate something etc
18:59 - we need to
19:00 - explicitly import it from one of the
19:02 - packages
19:03 - so think of the packages as containers
19:06 - of various functionalities that go gives
19:09 - you readily available for you to use
19:11 - when writing your applications now how
19:14 - do you know which functions
19:16 - are in which packages or let's say if
19:19 - you need to get a user input how do you
19:21 - know in which package you have that
19:23 - functionality available well you
19:25 - actually have to look up the
19:26 - documentation to see that or basically
19:29 - just simply google to find the right
19:31 - package and of course with time when
19:33 - using go and its packages you are going
19:36 - to know the most commonly used packages
19:39 - and all their functionalities and a cool
19:41 - thing we have here is you see this
19:43 - underline under the fmt package
19:47 - and if i hover
19:48 - over it you see a link that actually
19:50 - takes you to the official documentation
19:53 - of the fmt package so here you can
19:56 - actually see what functions you have
19:58 - available in that package and so on
20:01 - so with this we have our first fully
20:04 - functioning go application that we can
20:07 - now execute
20:09 - so let's clean up our terminal and
20:13 - executing a go application is very easy
20:16 - we have go command for it called go run
20:20 - and name of the file that we are
20:23 - executing which is main dot go so go run
20:27 - will basically
20:29 - execute this file
20:30 - it will
20:31 - look for the main function and execute
20:35 - the contents or lines within that
20:38 - function one by one we just have one
20:40 - line so that's getting executed and
20:42 - we're seeing hello world in the output
20:45 - we can do final optimization here
20:48 - to add a new line at the end of this
20:51 - print statement and to do that we're
20:54 - simply going to use a different function
20:56 - from
20:57 - format package called print ln
21:01 - so this will print whatever we pass here
21:04 - with a new line and let's execute that
21:07 - again
21:08 - and there you go
21:09 - now that we have the minimum program
21:11 - structure and know how to run go
21:14 - programs let's start writing our booking
21:17 - application logic the very first thing
21:19 - we need to do in our booking application
21:22 - is to greet
21:24 - our users when they visit the
21:26 - application
21:27 - so let's write some welcome message and
21:30 - information about the conference for
21:32 - which they are booking the tickets
21:34 - so instead of hello world
21:37 - we're gonna write welcome message like
21:40 - welcome
21:42 - to
21:42 - our conference
21:45 - booking
21:46 - application
21:48 - and we can write another message
21:50 - like get your
21:52 - tickets
21:53 - here to attend and again if we execute
21:57 - this
21:58 - we're gonna see our welcome message
22:00 - pretty easy
22:04 - now let's say our conference has a name
22:07 - and we're using this name in many places
22:10 - in our application in the welcome
22:13 - message in the thank you message when
22:15 - the user books the ticket on the ticket
22:17 - itself etc and whenever we have a value
22:21 - like conference name
22:22 - that is used in many places throughout
22:25 - the application
22:26 - it's the most common usage for variables
22:30 - every programming language has a concept
22:32 - of variables where instead of repeating
22:34 - this value everywhere you store it once
22:37 - in a variable assign it a name and now
22:40 - you can reference that value using its
22:42 - variable name wherever you need it in
22:45 - your code now if the value changes you
22:48 - don't have to find and update it in
22:51 - multiple places throughout the
22:52 - application code but you can simply
22:54 - change it in one place where you
22:56 - assigned it to a variable and that's it
22:59 - so how do we create and use variables in
23:02 - go
23:04 - well we have
23:05 - the value
23:07 - like the name of the conference let's
23:09 - call it go conference
23:12 - and we store that value
23:14 - in a variable and we can give that
23:16 - variable whatever name we want like this
23:19 - let's call it a name
23:21 - and finally we tell go
23:24 - that we are creating a variable using a
23:27 - var keyword
23:28 - so this basically lets us store the
23:31 - value go conference the conference name
23:34 - in a variable called name so
23:36 - now we can use that value by referencing
23:39 - the variable name wherever we need it
23:42 - now with variables it's a good practice
23:45 - to create variable names that properly
23:47 - describe what the value is in our case
23:50 - name
23:51 - baby two generic so to make it more
23:53 - specific and clear we can call it a
23:55 - conference name
23:58 - and note the camel case syntax here
24:01 - which is a pretty common variable naming
24:03 - convention in different programming
24:05 - languages including go
24:08 - and if i save those changes you see that
24:11 - we get a red line
24:13 - under our variable definition and that
24:16 - is
24:17 - something specific to go language so in
24:20 - go unlike many other programming
24:22 - languages
24:24 - when we define a variable or when we
24:26 - create a variable with a certain value
24:29 - and we don't use it in the code
24:31 - we get this error that actually says
24:34 - conference name declared but not used
24:37 - so to fix this error we actually have to
24:40 - use that variable and note that same
24:43 - error applies when you import a package
24:47 - but you don't use that package in your
24:48 - code you get the same error that package
24:51 - gets imported but not used which is a
24:53 - very good reminder to clean up your code
24:56 - so
24:57 - to fix this issue we're simply gonna
24:59 - print out that variable value using
25:02 - print line function
25:08 - and again when i save this change the
25:10 - error disappears
25:12 - so let's clean up the terminal output
25:15 - and run our
25:17 - go application again
25:19 - and there you go you see go conference
25:21 - printed out now let's actually use that
25:23 - conference name in our welcome message
25:26 - instead of generic our conference we're
25:29 - going to reference whatever we define as
25:32 - a conference name for that
25:34 - first of all let's delete the print
25:36 - statement and again as a common practice
25:39 - we're going to define the variable at
25:41 - the beginning of the function and we can
25:44 - use the variable within the print
25:46 - message by dividing the actual text
25:49 - that we have here
25:51 - and the variable name
25:53 - with commas inside the print alien
25:56 - function
25:59 - so this will be substituted by
26:01 - conference
26:03 - name
26:04 - and then
26:10 - actual text and the variable name will
26:13 - be separated by commas
26:15 - and let's save this and if i execute our
26:19 - go application again
26:21 - we will see welcome to goconference
26:24 - booking application so it took the value
26:27 - from here
26:29 - also note that the space automatically
26:32 - gets added before and after the variable
26:34 - value now what we also need in our
26:37 - application is the tickets for our
26:40 - conference and let's say we have total
26:43 - of 50 conference tickets available for
26:46 - users to book and for that we will also
26:50 - create a reference called conference
26:52 - tickets to store that value once and
26:56 - then we can reference it as many times
26:58 - as we want so let's call it conference
27:02 - tickets
27:04 - and the value will be 50. we have 50
27:07 - tickets available now
27:09 - this value actually does not change
27:13 - throughout the application right we have
27:15 - 50 conference tickets and it will always
27:18 - stay 50. while our application
27:20 - is running and for such values that do
27:23 - not change or stay constant instead of
27:26 - variables we have
27:28 - constants
27:29 - now as you might think the conference
27:31 - name could also be constant because it
27:33 - also doesn't change throughout the
27:35 - program but for this example we will
27:37 - leave it as a variable so instead of var
27:40 - keyword here we're going to use const
27:43 - and that will give us the same type of
27:46 - reference as with variables but this
27:49 - time we cannot change the value of this
27:52 - constant but we can use it and reference
27:55 - it in our application exactly the same
27:57 - way as our variables
28:00 - so the const keyword tells go that this
28:03 - value is not allowed to change and if we
28:06 - actually try that
28:09 - and
28:10 - somewhere in the application code change
28:12 - it to some other value and then try to
28:16 - use that
28:20 - like this
28:22 - we get a warning here right away that
28:23 - says cannot assign to conference tickets
28:27 - because it's declared as a constant
28:29 - but if we change it to var
28:33 - and save you see that the warning
28:35 - disappears
28:36 - so let's change it back to const
28:39 - and
28:40 - clean those lines up
28:42 - now when users start booking the tickets
28:45 - obviously we need to keep track of the
28:48 - ticket count so when 50 users book their
28:51 - tickets we inform the rest that the
28:53 - conference is completely sold out so
28:56 - every time someone books a ticket we
28:58 - need to basically reduce the number of
29:00 - available tickets that users can book
29:03 - and for tracking that amount we're going
29:06 - to create another variable for remaining
29:09 - tickets
29:12 - and we're going to call it remaining
29:14 - tickets
29:16 - which again is a variable because as
29:18 - users book their tickets this value will
29:21 - get less and less and it starts at 50
29:24 - because that's how many tickets we have
29:27 - in total and again we have this warning
29:29 - because we're not using it so let's
29:31 - actually use that in our welcome message
29:34 - to inform the users about how many
29:36 - tickets are available for the conference
29:39 - and how many of them are still remaining
29:41 - so between these two lines i'm going to
29:44 - add another print statement
29:47 - and here we're going to say
29:48 - we have
29:51 - total of
29:54 - this many tickets
29:59 - and
30:04 - this many are
30:06 - still available
30:11 - and if i save this the warning will go
30:13 - away because we are
30:15 - using
30:16 - both of these
30:18 - values
30:19 - in our code
30:20 - so again separating the actual text from
30:24 - the variable reference using commas
30:28 - now let's run our updated application
30:31 - and
30:32 - in the message we have the name of the
30:34 - conference and here it says we have
30:36 - total of 50 tickets and 50 are still
30:39 - available
30:43 - now whenever we're printing our text
30:46 - mixed with variables we can use a
30:48 - function called printf from the format
30:52 - package this function is specifically
30:54 - used for printing formatted data
30:58 - so it tells go how to format the values
31:01 - of the variables and generally it makes
31:04 - writing these kind of outputs
31:06 - easier so with printf
31:09 - this line for example will look like
31:11 - this
31:12 - so instead of print ln we're going to
31:14 - use printf
31:15 - another function from the format package
31:18 - and instead of the conference name
31:20 - reference we're going to use what's
31:22 - called a placeholder and annotate that
31:25 - using percentage sign and v
31:28 - and you see the syntax highlighting here
31:30 - that shows that it's a special character
31:33 - for placeholder but of course we still
31:35 - need to reference whatever
31:38 - variable we want to substitute here
31:40 - right and we do that right here with a
31:43 - comma
31:44 - and then conference name
31:49 - and if i save this and run
31:54 - we have the same output one thing that
31:57 - is different here is the new line is
32:00 - missing because we were using println
32:02 - that automatically added a new line in
32:05 - this case we're gonna add it explicitly
32:08 - using backslash
32:10 - n so that's a character for newline and
32:13 - if i save this and run we have exactly
32:16 - the same output as before now let's do
32:18 - the same for the second print statement
32:21 - first change it to printf take this
32:24 - reference here and substitute it with
32:26 - percentage v do the same for
32:29 - the second
32:32 - variable reference
32:33 - and again we need to
32:35 - replace so basically we need to tell go
32:38 - which
32:39 - variable values should be used to
32:41 - replace
32:42 - those placeholders and of course they
32:44 - should be in a correct order when we
32:46 - have multiple such placeholders so the
32:48 - first one is
32:50 - conference tickets
32:51 - the second one is remaining tickets
32:54 - and again the new line
32:58 - backslash n
33:00 - save it and there you go
33:02 - now as i mentioned printf
33:05 - or print format function allows you to
33:08 - tell go how to format the variables
33:11 - that you are referencing here the
33:14 - percentage v is the default format but
33:17 - you have other specific formats also
33:20 - available
33:21 - if you want the values to be displayed
33:25 - differently and you can see this whole
33:26 - list
33:27 - in the gold documentation
33:30 - under the fmt package link
33:34 - so the percentage v is the one we used
33:36 - we have a lot of other options as well
33:38 - for numbers and text values and so on
33:45 - now sometimes when we create a variable
33:48 - we don't immediately know its value for
33:50 - example when we're getting user input
33:54 - like a user entering their name
33:56 - and
33:57 - date of birth etc in the application we
34:00 - don't know that value before because we
34:03 - don't know what the user is going to
34:04 - enter
34:05 - so we create a variable
34:07 - and later we assign it the value which
34:10 - is possible to do in go just like in
34:13 - other programming languages so let's see
34:15 - the syntax for that
34:18 - so here let's say we define a variable
34:20 - called username
34:22 - and we don't know what the value of that
34:24 - variable is going to be
34:26 - and on the next line we ask the user
34:32 - for their name and this is a syntax for
34:35 - comment so whatever starts with
34:38 - double forward slash signs is basically
34:40 - interpreted as a comment so it's not
34:44 - executed as code so let's say we have
34:46 - some imaginary code here that asks for
34:48 - user input
34:50 - and
34:51 - they
34:53 - and that user name that we get is
34:57 - let's say tom
35:00 - and finally we can actually use that
35:02 - value
35:04 - so we have defined a variable here and
35:07 - then we are assigning a value for that
35:09 - variable
35:10 - later
35:11 - on a separate line however when i save
35:14 - this code you see that we get another
35:17 - warning here that says
35:19 - unexpected newline expecting type so
35:22 - what's the problem here
35:23 - and why is it expecting a type well in
35:26 - go
35:27 - all values have data types and generally
35:30 - in any programming language you have
35:32 - multiple data types for different use
35:35 - cases and go isn't an exception
35:38 - the difference between these languages
35:40 - is however which data types exactly they
35:43 - support so each language has its own set
35:46 - of data types
35:49 - two most basic and common data types are
35:51 - strings and integers for textual data
35:56 - like the welcome message
35:58 - the name of the conference so anything
36:01 - between the quotes basically
36:04 - is a string data type for numeric data
36:07 - like ticket count
36:09 - h and so on we have integer
36:12 - data type and again you see the syntax
36:15 - highlighting for the integers and
36:17 - strings are different because go
36:20 - basically knows this is a string this is
36:23 - an integer
36:24 - so these are the two most basic ones but
36:26 - we're going to learn a few other data
36:28 - types as we go along
36:30 - here however it's important to
36:31 - understand that each data type can be
36:34 - used differently and behaves differently
36:37 - for example you can do calculations with
36:40 - integers but you can't do calculations
36:42 - with strings
36:44 - you can chain or get a subset of a
36:47 - string but you can do that with integers
36:49 - so the main purpose of having types for
36:52 - values in code is to avoid accidentally
36:55 - using an integer as a string or vice
36:58 - versa and use one data type instead of
37:01 - the other which may break your
37:03 - application
37:04 - so when we create variables in go it
37:06 - needs a type now you may be thinking
37:09 - when we created these
37:11 - two
37:12 - variables right here
37:14 - these two variables and a constant we
37:17 - didn't specify a type so why didn't we
37:19 - get the same syntax error here well when
37:22 - we create a variable
37:24 - or constant and assign a value to it
37:28 - immediately on the same line
37:30 - go can imply
37:33 - the data type based on the value
37:35 - so go knows that this is a variable type
37:38 - for string and this is a constant and
37:41 - variable types for
37:42 - integers because of the values but when
37:45 - we do not assign a value immediately go
37:48 - doesn't know what type of value you are
37:50 - going to store here so it asks you to
37:53 - explicitly define a type to make your
37:55 - code basically more robust and
37:59 - prevent
38:00 - you or other developers from
38:02 - accidentally assigning a wrong data type
38:05 - value to that variable later in the code
38:08 - so in this case we need to define a type
38:10 - explicitly how do we define a type super
38:13 - easy at the end we just say this is a
38:16 - variable of string type if i save this
38:19 - the error disappears and again you see
38:22 - the syntax highlighting for the type
38:25 - and the same way we can define a
38:27 - variable for
38:28 - integer type let's say
38:30 - user tickets
38:32 - which is a number of tickets user wants
38:34 - to buy and this is going to be an
38:37 - integer type
38:38 - and somewhere here
38:41 - we're going to ask user for the input
38:43 - and let's say they enter
38:44 - 2 and in the print statement with printf
38:50 - we're going to say
38:51 - user whatever their username
38:54 - booked
38:56 - this many
38:58 - tickets with a new line
39:04 - and reference
39:05 - the respective variables and again
39:09 - let's run this
39:11 - and here we have our output
39:14 - now you probably already noticed
39:16 - something really cool about go
39:18 - especially if you have worked with other
39:20 - programming languages before and that is
39:23 - that while we're writing this code
39:26 - if we make some mistakes if we have
39:29 - errors in our code for example defining
39:32 - a variable and not using it or
39:34 - forgetting to specify a type etc go
39:37 - basically detects those errors before we
39:40 - even run the application so by the time
39:43 - we're ready to execute the application
39:45 - we have fixed a bunch of errors
39:48 - that go
39:49 - identified and
39:51 - highlighted for us in many programming
39:53 - languages that's not the case usually
39:56 - you discover these kind of errors when
39:58 - you run the application not while you're
40:01 - coding and that is a big advantage of go
40:04 - now going back to the types i mentioned
40:07 - that go actually implies the types of
40:11 - these three values automatically and if
40:14 - we wanted we could actually print out
40:17 - the types of
40:19 - variables
40:20 - using the printf function so with fmt
40:23 - printf
40:32 - let's print out the types of these two
40:35 - variables and a constant so conference
40:37 - tickets is
40:40 - whatever type it has
40:42 - then remaining
40:47 - tickets is
40:50 - whatever type this one has
40:53 - and then conference name is
41:00 - percentage t percentage t is a
41:03 - placeholder
41:04 - for
41:05 - the type of the variable that we're
41:07 - referencing here not the value like
41:10 - percentage v but the type so let's pass
41:13 - in those
41:15 - references
41:17 - and save
41:20 - and if we run our application
41:22 - we should see
41:24 - the output here conference tickets is
41:27 - int or integer
41:29 - remaining tickets is in conference name
41:31 - is string
41:32 - so this lets you print type of any
41:35 - variable now if we wanted we could
41:38 - actually define the types explicitly
41:40 - here even though it's not required so we
41:43 - could do
41:44 - conference name as a string
41:47 - and int
41:48 - and int
41:49 - however specifying a type explicitly
41:53 - when go can detect it
41:55 - makes sense when want to specify a
41:57 - different type than what go would detect
42:00 - for example in go specifically again we
42:03 - have multiple times for
42:05 - numeric values so in addition to int or
42:08 - integer type which represents whole
42:11 - numbers
42:12 - we have int 8 in 16 and 32
42:17 - and int
42:18 - 64 which corresponds to the length of
42:22 - the integer so basically how big or how
42:25 - large the number is
42:26 - and in addition to that we also have
42:29 - uiint or unsigned integer
42:32 - which represents whole numbers like
42:34 - integer but only positive ones so 0 and
42:37 - plus
42:38 - and here's a chart of all the different
42:41 - numeric data types in go and obviously
42:44 - each one has its own purpose
42:46 - so the question is when to use which one
42:49 - and why do we have so many different
42:52 - integer data types for example well this
42:54 - allows you to define data types in a way
42:57 - that the values will automatically be
42:59 - validated so if you're using uiint and
43:02 - assign a negative value to it you will
43:04 - get an error like in our case the number
43:07 - of remaining tickets should never be
43:09 - negative but with int type it can be so
43:13 - somewhere in the code we can actually
43:17 - set it to a negative number like this
43:19 - but if we specify a type uint explicitly
43:23 - instead and save it you see that it will
43:26 - not accept the negative value so setting
43:29 - a type may actually protect our variable
43:31 - from getting a value that it's not
43:33 - supposed to get and obviously you as a
43:36 - developer are not going to assign your
43:38 - variables a wrong value but if you're
43:40 - doing some calculations on your
43:42 - variables or some processing the result
43:45 - of that calculation may be a wrong value
43:48 - we also have float number type which are
43:51 - for numbers with fractional parts so not
43:55 - whole numbers this could be statistical
43:57 - data like a conference attendance
43:59 - compared to last year for example this
44:01 - could also be monetary values like
44:03 - prices of products in an online shop or
44:06 - transactions in an online banking
44:08 - application and so on so basically when
44:10 - a number needs a higher precision float
44:13 - number type needs to be used
44:16 - but as i said there are other data types
44:18 - in go besides textual and numeric types
44:21 - which we will learn as well now there is
44:24 - one more thing in terms of variable
44:26 - definition in go and that is again
44:28 - specific to go
44:30 - is that we have an alternative syntax
44:33 - for creating a variable and assigning it
44:36 - a value directly this is like a
44:38 - syntactic sugar of go language so
44:41 - instead of this syntax for creating a
44:43 - variable we can get rid of the var
44:46 - keyword
44:47 - as well as the type and
44:50 - right here before the equal sign just
44:52 - add a column
44:53 - and this will do the same as
44:55 - before create a variable and assign it a
44:58 - value now note here that with this
45:00 - alternative syntax you cannot declare
45:03 - constants so we cannot do
45:06 - this with constants
45:09 - it only applies to variables and it also
45:11 - doesn't work if you want to explicitly
45:14 - define a type for your variable like
45:16 - here for example
45:21 - now let's clean up our code and let's go
45:23 - back to
45:25 - our ticket booking logic
45:27 - so this is a booking application so want
45:30 - to allow users to book their tickets and
45:33 - for that we want to ask users for their
45:36 - personal information first like first
45:38 - name last name etc and all these values
45:41 - will be then saved into variables
45:44 - like this
45:46 - so we need some logic here that allows
45:49 - the application to ask for user input in
45:52 - order to read user input we use another
45:54 - function from the same format package
45:58 - called skin
46:02 - so basically the format package
46:04 - gives us different functions
46:07 - to print out like this
46:09 - formatted output
46:11 - or read formatted input so it's used for
46:15 - input output processing functionality so
46:18 - let's scan the user input for their
46:21 - first name because instead of assigning
46:23 - the value directly as we did here we
46:26 - want to get that value from the user and
46:29 - then assign it to
46:31 - the username variable now print function
46:34 - like printf or println takes a message
46:37 - as a parameter like this one a formatted
46:41 - message and prints it
46:43 - scan also takes a parameter which is the
46:46 - input it needs to scan and the parameter
46:48 - for
46:49 - scan function is the user input
46:52 - but we don't know what the user will
46:54 - enter as their name so we need a way to
46:57 - save the user input
46:59 - as a variable
47:00 - and then
47:01 - reference that value using that variable
47:04 - name instead of directly assigning it
47:06 - here
47:07 - and let's save it so this is supposed to
47:10 - scan user input
47:12 - and whatever user enters basically
47:14 - assign that value to username variable
47:17 - as a value now if we run this
47:19 - application let's run it you see that it
47:22 - runs it executes all those lines
47:25 - and
47:26 - it just exits it doesn't wait for any
47:29 - user input so we were not able to enter
47:31 - anything and the value of the user here
47:35 - or username variable is also empty so
47:38 - there is one thing that we need to fix
47:40 - here so before the username variable we
47:42 - need to add what's called a pointer
47:45 - like this so what is a pointer simply
47:48 - explained
47:49 - i said that we save a value in a
47:52 - variable in order to use it later so
47:54 - when we create a variable where does
47:56 - that value actually get stored well
47:59 - values are saved in memory on your
48:01 - computer so that 50 or go conference
48:05 - values are actually stored in memory but
48:07 - whenever we reference that value using
48:10 - the variable name we defined go compiler
48:12 - must go and find that value in memory so
48:15 - it needs to know where in memory exactly
48:18 - it is stored or in other words it needs
48:20 - to know the memory address of that value
48:22 - and a pointer is a variable that points
48:26 - to the memory address of another
48:29 - variable that references the actual
48:32 - value 50 for example and pointers in
48:34 - golang are also called special variables
48:38 - so to see that in the code let's
48:40 - actually comment this out
48:42 - and if we print out
48:45 - any variable like remaining tickets for
48:47 - example
48:48 - with value 50 this will give us
48:51 - the actual value 50 but if we print out
48:56 - the pointer
48:58 - this will actually print out
49:00 - the memory location of the remaining
49:03 - tickets variable let's actually see that
49:06 - right here we have
49:07 - value 50 and the next line is
49:11 - a hash which is a memory address for the
49:13 - remaining tickets variable so that's
49:16 - basically a pointer
49:17 - and it's also important to mention that
49:19 - pointers is a concept used in the c
49:22 - programming language but many popular
49:25 - programming languages like java or
49:27 - javascript for example to not have
49:29 - pointers at least not exposed to you as
49:33 - a developer so you will not see the
49:35 - concept of pointers in many other
49:38 - languages so again going back to our
49:40 - scan function instead of passing the
49:43 - value of
49:45 - the username variable which is empty
49:48 - we're passing the memory address of that
49:50 - variable so that scan function
49:53 - will read whatever the user enters and
49:56 - assign that value
49:57 - to that username variable in memory so
50:00 - if i execute the application now
50:03 - you see that it doesn't just exit it
50:05 - actually stops at this line after get
50:08 - your tickets here to attend and it's now
50:10 - waiting for me as a user to input some
50:14 - data and as a username i can input my
50:17 - own name and if i enter it goes to the
50:20 - next line and it prints out whatever is
50:23 - in the username booked to tickets so now
50:26 - we have that value whatever user entered
50:29 - available in our code through this
50:32 - username variable now to make this a
50:34 - little bit user-friendlier we can also
50:37 - ask the user explicitly what we are
50:39 - asking for so we can say
50:43 - enter
50:44 - your first name
50:48 - like this
50:49 - and let's run again
50:51 - and there you go so now we are actually
50:53 - asking the user explicitly what we want
50:58 - and then printing the result out
51:00 - so that's one value
51:02 - now let's read
51:03 - other user data like last name email and
51:07 - number of tickets user wants to book and
51:10 - let's first call this
51:12 - first name
51:13 - and update it
51:16 - everywhere like this
51:21 - let's create last name
51:23 - which is also string
51:25 - and email which is also string
51:28 - and user tickets which we already have
51:31 - which is an int
51:32 - and now one by one let's actually scan
51:35 - all those values
51:38 - i'm going to copy these two lines
51:40 - and we're going to say enter your last
51:43 - name
51:44 - and we're going to save that
51:45 - value that user enters in a last name
51:48 - variable
51:49 - again let's
51:51 - copy
51:52 - and let's say enter your email address
51:58 - and the value will be stored in email
52:01 - variable
52:03 - and finally instead of assigning user
52:06 - tickets directly we're going to ask the
52:08 - user how many tickets they want
52:11 - enter
52:12 - number of
52:15 - tickets
52:16 - and again this will be stored in user
52:19 - tickets variable
52:21 - and at the end let's actually print out
52:23 - some kind of a thank you message
52:25 - to the user
52:27 - with some additional information
52:31 - so let's write
52:32 - thank you
52:34 - first name last name of the user
52:37 - for booking so many tickets
52:42 - you will
52:43 - receive
52:45 - a confirmation
52:47 - email at whatever email address they
52:50 - gave us
52:51 - and don't forget the new line at the end
52:55 - and now let's actually substitute those
52:57 - placeholders with the actual
53:00 - variable references so we have first
53:03 - name
53:04 - last name and here we have
53:07 - the third one
53:09 - user tickets
53:11 - and finally the email address they gave
53:13 - us
53:15 - awesome so let's
53:16 - clean this up and run our program
53:19 - enter your first name
53:23 - nana
53:25 - enter your last name
53:27 - my last name
53:28 - email address
53:31 - something like this
53:33 - and finally number of tickets let's say
53:36 - three tickets and if i enter this is the
53:39 - last
53:41 - skin
53:42 - so now it's gonna
53:45 - execute the print statement that says
53:47 - thank you
53:48 - nashia for booking three tickets you
53:51 - will receive a confirmation email at
53:53 - this email address
53:58 - now we're getting
54:00 - user input but no tickets are being
54:02 - booked the remaining tickets doesn't get
54:05 - reduced it always stays 50.
54:08 - so let's write some simple logic to book
54:11 - the ticket which in our case will be
54:14 - just reducing the number of remaining
54:16 - tickets
54:18 - so after getting user info we will
54:21 - simply add
54:23 - remaining tickets
54:24 - minus user tickets
54:28 - so this will give us some value
54:30 - 50 minus how many tickets user booked
54:34 - and then we have to save it back into
54:36 - the remaining tickets variable to update
54:39 - it right because we have to update the
54:42 - value of this variable by assigning it
54:45 - back now
54:47 - when i save it we see an issue and that
54:50 - is
54:50 - type mismatch
54:52 - of uiint and int because we're doing a
54:54 - calculation
54:56 - on two numbers which have different
54:58 - types one of them
55:00 - is you integer
55:02 - and another one user tickets is an
55:05 - integer so as you see in goal when you
55:08 - do calculations between numbers they
55:11 - have to have the same type one way to
55:13 - handle this issue in many languages is
55:17 - to convert
55:18 - one of them to the other type
55:20 - using various built-in functions that
55:23 - you have available in the language
55:25 - a simple solution for us
55:27 - is to make the user tickets also you in
55:31 - type
55:32 - because users can only book
55:35 - positive number of tickets right they
55:37 - can't book minus one or minus two number
55:40 - of tickets so
55:42 - let's make it you int as well and now
55:44 - the error is gone
55:46 - so that's our super simple booking logic
55:50 - and after the thank you message we're
55:53 - also going to print information about
55:55 - how many tickets
55:57 - are now remaining so let's say this many
56:00 - tickets
56:01 - remaining
56:03 - for
56:04 - this conference
56:08 - remaining tickets and conference
56:12 - name
56:13 - so with these changes let's now run our
56:16 - go application
56:18 - and again
56:19 - enter
56:20 - the user values
56:22 - and let's say we're
56:24 - buying 15 tickets
56:27 - and enter
56:28 - and as you see the remaining tickets are
56:31 - now 35 50 minus 15 that we entered
56:36 - before moving on i want to give a shout
56:38 - out to castin who made this video
56:40 - possible
56:42 - kessen's k10 is the data management
56:45 - platform for kubernetes
56:47 - k10 basically takes off most of the load
56:50 - of doing backup and restore in
56:52 - kubernetes from the cluster
56:54 - administrators it has a very simple ui
56:57 - so it's super easy to work with and has
57:00 - an intelligent logic which does all the
57:02 - heavy lifting for you and with my link
57:05 - you can download k10 for free and get 10
57:08 - nodes free forever to do your kubernetes
57:11 - backups so make sure to check out the
57:13 - link in the video description and now
57:15 - let's continue
57:18 - now we're saving user data in variables
57:21 - and are booking the ticket for them
57:23 - but when multiple users book the tickets
57:26 - we need to save all these user data in
57:28 - some kind of a list right to keep track
57:31 - of who is attending the event and who
57:34 - booked the tickets and for that we have
57:37 - data types called arrays and slices
57:40 - arrays and slices are commonly used data
57:43 - types in go applications so let's create
57:46 - an array for all the bookings so right
57:48 - here i'm going to create a variable
57:50 - called bookings and this is going to be
57:53 - an array when we define an
57:55 - array the first thing
57:57 - we need is the size because arrays in go
58:01 - have fixed size and for that we use
58:05 - square brackets and within those square
58:07 - brackets we define the length or size of
58:10 - an array
58:12 - and let's say we expect maximum 50
58:14 - bookings
58:16 - so we're gonna
58:17 - say 50. so the size of an array is
58:20 - basically how many elements can this
58:23 - array hold so as i said array is like a
58:27 - list of bookings or list of elements and
58:31 - with the size 50 we're saying this can
58:33 - have 50 elements in that list the next
58:36 - thing we need to define is the type
58:38 - of the elements
58:41 - this array will contain a data type so
58:44 - what kind of values are we going to
58:45 - store in that is it going to be a list
58:47 - of integers a list of strings etc in our
58:51 - case let's say
58:53 - we want to store a list of
58:55 - names of the users who book the tickets
58:58 - a name is a string so our array is going
59:02 - to be an array of strings so that's the
59:05 - data type
59:07 - and finally
59:08 - we need the actual value
59:11 - right so this is the same syntax as
59:14 - this one right here where we are
59:16 - assigning
59:17 - a value directly to the variable so we
59:20 - need to actually assign a value of an
59:22 - array and we can have an empty array
59:24 - like this
59:25 - or we can
59:27 - already put some elements in the array
59:30 - and let's say these are some of the
59:33 - names inside
59:37 - and this gives us a bookings array with
59:39 - size 50 with three elements already in
59:43 - that array
59:44 - now there are two things i want to
59:46 - mention here first of all because we
59:49 - have to define the type of the elements
59:51 - for the array we can't
59:53 - mix any other type here so we cannot
59:55 - have names and then
59:58 - an integer for example right this will
60:00 - not work and again this is specific to
60:03 - go you can actually mix the types in
60:06 - some other programming languages the
60:08 - second thing i want to mention is that
60:10 - even though we are starting with three
60:13 - elements here we can actually update our
60:15 - array and add new elements up to 50 as
60:19 - well as remove the elements so again
60:22 - this is a variable so we can add new
60:24 - elements to the list and remove that
60:27 - during the application execution
60:30 - and usually
60:31 - when you create an array you actually
60:33 - start with an empty list
60:36 - like this because you don't know the
60:38 - values at this point and as the program
60:40 - executes you basically add new values
60:43 - one by one so that's going to be our
60:45 - starting point and because we are
60:48 - creating an empty array an alternative
60:51 - syntax for
60:52 - this will actually be to define the
60:55 - array variable
60:57 - like this without assigning a value
61:00 - and going with the default empty array
61:03 - but as you learned in this case we have
61:05 - to define the type
61:07 - for the array because go doesn't know
61:10 - the type and again you see here it's
61:13 - expecting type so what is
61:16 - an array type in go
61:18 - well it's actually
61:20 - a combination of the size that we
61:22 - defined which is 50 and the type of the
61:26 - elements
61:27 - it's going to contain
61:29 - like this
61:30 - so
61:31 - this is actually
61:32 - an array type and we're getting this
61:34 - error because we're declaring a variable
61:36 - but not using it so let's actually use
61:38 - it and let's start by adding new
61:41 - elements to that array how can we do
61:44 - that pretty simple actually we have
61:47 - a syntax
61:48 - with indexes so bookings array
61:53 - with index which is the position in
61:56 - which we're adding a new value like this
61:59 - so again our array has
62:01 - 50
62:02 - empty positions where we can add values
62:05 - and we're saying
62:06 - the position
62:07 - 0 which is the first position let's
62:09 - assign this value and we can say
62:13 - position
62:14 - let's say 10 let's assign
62:18 - a different value but of course normally
62:20 - you would go one by one you would add
62:23 - the next value in the list like this
62:27 - now in our case again we want to add a
62:29 - name of the user
62:31 - that booked the ticket we want to save
62:34 - the first name and the last name of the
62:36 - user so instead of assigning a value
62:39 - directly we're going to say first name
62:44 - and
62:47 - add some space
62:48 - in between
62:50 - and the last name
62:51 - so this will give us first name last
62:53 - name with space separated however as you
62:56 - see here we get an error that first name
62:59 - and last name are not defined because
63:01 - we're using these variables before they
63:04 - are declared here again in a language
63:07 - like javascript for example the order
63:10 - doesn't matter so this would work in
63:12 - javascript but in go you have to use the
63:15 - variable after it has been defined in
63:17 - the code so we're gonna take this
63:21 - assignment
63:23 - and basically move it
63:25 - down here
63:26 - under
63:27 - the logic for
63:29 - updating the remaining tickets
63:31 - and if i save this the error is gone so
63:34 - to wrap this up we're creating an array
63:37 - variable
63:39 - at the beginning which is defined as an
63:41 - array of strings
63:43 - with 50 elements maximum
63:46 - and right here after user has entered
63:48 - their first name last name and booked
63:50 - the ticket we are adding that user's
63:53 - full name to the bookings variable and
63:56 - to also see what's inside the bookings
63:59 - let's actually print out the contents of
64:01 - the array and also some information
64:04 - about the array to see how it actually
64:06 - looks like so let's do
64:08 - fmt print f
64:12 - and first let's print out the whole
64:14 - array
64:19 - placeholder v
64:22 - and newline
64:23 - and this is going to be whole bookings
64:25 - array
64:26 - then let's print the first value
64:31 - which is bookings
64:33 - at index 0
64:36 - and we need to use capital p here
64:39 - like this
64:41 - then let's also print the type
64:45 - of the array
64:47 - like this
64:48 - and finally let's print the size or
64:52 - length of the array and to get the size
64:55 - of an array we have a built-in function
64:58 - called length
65:00 - with l e n
65:02 - that takes the array as a input so to
65:05 - say
65:05 - and gives us the size of
65:08 - the array
65:09 - and here we need percentage and capital
65:12 - t
65:14 - and now let's actually run our
65:16 - application and see how arrays work
65:22 - book five tickets
65:24 - and here you see
65:26 - all the array information so first of
65:28 - all we have the whole array that has
65:31 - one element
65:32 - which is first name last name of my user
65:36 - and you see that it has square brackets
65:39 - at the beginning and here at the end so
65:41 - basically this represents the
65:44 - space for all the other elements in the
65:47 - array because we have a fixed size of 50
65:51 - elements and that's why you have a space
65:53 - here
65:53 - then we have just the first value
65:56 - which is this one right here without the
65:59 - brackets the array type is what we
66:02 - actually defined here
66:05 - as a type and then we have array length
66:08 - which is 50.
66:09 - now what happens if we try to add value
66:13 - to this array
66:14 - at an index
66:16 - 52 for example so basically
66:19 - index outside the range of
66:22 - the array size let's try to do that so
66:24 - instead of zero index
66:27 - we're going to do 52. again without
66:30 - running the application
66:31 - go actually detected that your
66:34 - index is out of range or out of bounds
66:38 - and you need to fix that again if you
66:41 - have
66:42 - some calculated number here
66:44 - that you don't know refers to
66:46 - a wrong index
66:48 - go will help you basically
66:50 - detect that error immediately before
66:52 - even running the application
66:57 - now we have one issue with our array
67:00 - because what if you don't know the size
67:02 - of the array when you're creating it
67:05 - let's say we have an array for users who
67:07 - sign up for our newsletter we don't know
67:10 - how many users are going to sign up
67:11 - right this could be anything between
67:13 - zero and indefinite so how can we fixate
67:16 - the size here it could be same in our
67:18 - case because maybe not all 50 tickets
67:21 - get booked or maybe one user basically
67:24 - books all 50 tickets so we have just one
67:27 - booking and an array of
67:29 - size 50 with just one value inside so
67:33 - how can we
67:34 - define a list that is more dynamic in
67:38 - size
67:39 - for such use cases
67:40 - so basically at least where we don't
67:43 - have to specify
67:44 - a size at the beginning but it
67:47 - automatically expands as new elements
67:49 - get added to it
67:51 - well exactly for that
67:53 - use case
67:54 - instead of array we have what's called a
67:56 - slice
67:57 - slice is basically an abstraction of an
68:00 - array so it uses the array type under
68:03 - the hood but has a dynamic size and
68:05 - working with slices is also more
68:07 - efficient than with arrays so generally
68:10 - using slices is actually a better option
68:13 - than
68:14 - using arrays in our application we will
68:17 - also use slice instead of an array
68:20 - and to define a slice we basically
68:22 - create an array without
68:25 - a size definition
68:27 - like this now in an array we added
68:31 - new elements
68:32 - using this index
68:35 - which is not very convenient because for
68:37 - each
68:38 - new user we have to know exactly what is
68:41 - the next index
68:42 - that has a free
68:44 - spot or free place for the next value
68:48 - in slices however we don't need to use
68:50 - the index instead we can just say
68:53 - add the next element to the slice
68:56 - so the syntax for that is append
68:59 - again a built-in function from go just
69:01 - like this length function
69:03 - and this append takes bookings
69:07 - which is our slice
69:09 - and then whatever value we want to add
69:12 - to this slice is a next element whatever
69:14 - index that may be
69:16 - and then we have to assign this back to
69:19 - our slice
69:20 - and as i said this is much nicer because
69:22 - we don't have to keep track of the
69:24 - indices and let's remove this
69:27 - and now we are working with dynamic
69:29 - lists using
69:30 - slice
69:32 - so adding a value to a slice is
69:34 - different than to an array but
69:37 - retrieving a value getting a value from
69:39 - the slice is the same so we can actually
69:42 - leave this syntax like this we can
69:44 - change the wording here from array to
69:47 - slice
69:49 - and now let's
69:52 - run our application again
69:59 - and as you see the slice basically has
70:02 - these brackets
70:04 - directly wrapped around
70:06 - the value it has and the length of a
70:09 - slice is one so as we add new elements
70:13 - it automatically expands
70:17 - and finally just as a reminder
70:19 - note the alternative syntax for creating
70:22 - a slice
70:23 - just like with an array we can also do
70:26 - an empty slice
70:28 - assignment like this
70:30 - or
70:31 - using
70:32 - this alternative syntax we can also
70:34 - create a slice with this syntax
70:38 - so now we're actually saving user
70:41 - information in the bookings list let's
70:44 - actually clean this up before moving on
70:47 - and instead let us
70:49 - print
70:52 - all the bookings
70:55 - in the application
71:03 - like this
71:04 - and we actually need printf
71:08 - and that's our cleaned up application
71:10 - code
71:14 - now even though we are saving the data
71:16 - of the list of users who booked the
71:19 - ticket we only always have just one user
71:22 - because when we run the application we
71:25 - enter information get the ticket and the
71:28 - application exits
71:30 - now of course in real life this would be
71:32 - a web application with a ui and a
71:35 - database connected to it where multiple
71:37 - people can book
71:38 - at the same time from their browsers and
71:41 - the bookings will be persisted in a
71:43 - database
71:44 - but in our case we have a command line
71:46 - interface application so we're using our
71:49 - application only through the terminal so
71:51 - what we're going to do is create a
71:53 - constant loop where the application
71:57 - keeps asking for another ticket booking
72:00 - after one booking is done
72:02 - to simulate booking a ticket multiple
72:04 - times for different users and loops
72:07 - which is a concept that you may already
72:09 - know from other languages is basically
72:11 - used whenever we need to repeat the same
72:14 - logic multiple times
72:16 - now in go specifically loops are
72:18 - actually simplified you don't have
72:21 - different types of loops like while loop
72:24 - and do while loop for each loop and so
72:26 - on you just have one
72:29 - loop which is a for loop and you can use
72:31 - it for all the different use cases so
72:34 - basically you have for loop with
72:36 - different types
72:37 - our first case is
72:39 - super simple use case for a for loop
72:42 - which is that we just want to allow
72:45 - booking over and over again
72:48 - so after the welcome message
72:50 - the logic
72:51 - which basically asks for user input and
72:54 - then books the tickets
72:56 - and then prints out the summary of the
72:59 - booking
73:00 - need to be repeated so right here at the
73:04 - beginning of this logic we're going to
73:06 - write 4 so that's the beginning of a for
73:09 - loop
73:09 - and the syntax of a for loop is curly
73:13 - braces so whatever we put within those
73:15 - curly braces gets repeated in this loop
73:19 - so i'm going to take this whole thing
73:24 - and put it inside the for loop
73:28 - and let's actually fix the
73:30 - indentation like this
73:33 - so we put that logic inside the for
73:36 - loops block and for each line we have
73:40 - basically
73:41 - indentations
73:42 - like this
73:43 - so that's it this will basically
73:46 - keep asking for a new booking
73:49 - after one booking is done and to test
73:52 - that
73:53 - let's run the application
73:58 - this is the first user
74:03 - and now immediately after we got the
74:05 - output of the booking first of all these
74:07 - three lines
74:09 - right here so we have 46 tickets
74:12 - remaining and this is one booking in our
74:16 - bookings list and immediately after that
74:19 - it asks for another user's input and
74:22 - let's
74:23 - fill it out let's do nicole
74:26 - smith
74:27 - and
74:31 - email address and let's say she books
74:33 - three tickets
74:35 - and as you see
74:37 - the remaining tickets got updated from
74:39 - 46 to 43. right so minus three tickets
74:44 - and now we have
74:46 - two bookings in our bookings list the
74:49 - first user and the second user and we
74:51 - can do this basically indefinitely for
74:54 - as many users as we want so to break the
74:57 - application
74:58 - you can do control
75:00 - c
75:01 - and this will basically interrupt and
75:04 - stop the application
75:05 - but of course when we start the
75:07 - application
75:08 - again it will start from scratch right
75:11 - so the bookings variable as well as
75:13 - remaining tickets variable of course
75:15 - gets updated while the application is
75:17 - running right after each rerun
75:20 - everything gets reset
75:27 - now let's do one more thing here
75:30 - at the end of
75:32 - each booking we're printing out the list
75:35 - of
75:36 - users who already bought the tickets and
75:38 - we're printing out their first names and
75:41 - last names
75:42 - but let's say we want to give our users
75:45 - a little bit of privacy and instead of
75:47 - printing their full names we want to
75:50 - only print their first names to display
75:53 - the bookings with a little bit of
75:54 - privacy so basically we want to go
75:57 - through our bookings list
75:59 - our full names bookings slice
76:02 - and for each entry
76:04 - of the full name we want to extract only
76:07 - the first name part and then print only
76:09 - the first name
76:11 - again we're doing the same thing over
76:13 - and over again to different elements of
76:16 - the bookings list so it's a loop but
76:19 - instead of an indefinite loop like the
76:22 - one we're using here
76:24 - that basically never ends
76:26 - we want to loop through a specific list
76:29 - of elements
76:31 - so let's see how we can do that first of
76:34 - all let's define a slice for only the
76:37 - first names
76:38 - let's call it first names
76:40 - and let's use the shortcut syntax for
76:43 - this
76:44 - so this is going to be a slice of first
76:46 - names which are strings and we are
76:49 - starting with an
76:50 - empty list now when i save of course we
76:52 - get an error because we're not using it
76:55 - next what we're going to do is we're
76:57 - going to
76:58 - loop through or iterate through
77:01 - our bookings list
77:02 - grabbing one element at a time and to
77:05 - iterate through a list
77:07 - we have a pretty simple syntax actually
77:10 - we have four again
77:12 - for loop and while we are iterating
77:15 - through this list we get two values for
77:19 - each iteration first we get an index and
77:22 - you learn the index from the arrays it
77:24 - is basically a position of the element
77:26 - in the list this is the first element
77:28 - second element and so on so we get the
77:30 - index for each iteration and we get the
77:34 - element itself and we can call this
77:36 - element whatever we want it's like
77:37 - defining a variable let's call it
77:39 - booking
77:40 - because we have a bookings list so each
77:43 - element inside will be a booking
77:45 - then we have a syntax of colon
77:48 - equals
77:50 - and here we define
77:51 - what
77:52 - list are we actually iterating and
77:54 - getting these two values from which is
77:58 - bookings
77:59 - so we are iterating through bookings and
78:01 - to iterate through a slice we need a
78:04 - range expression
78:06 - range allows us to iterate over elements
78:09 - in different data structures not just
78:12 - arrays or slices but for slices and
78:15 - arrays specifically it gives us back the
78:18 - index and value for each element
78:22 - so this basically defines the whole
78:26 - logic of go through
78:28 - this list and for each iteration give us
78:32 - index
78:33 - and the element value and at the end we
78:35 - have curly braces for defining logic for
78:39 - our for loop so basically we have a for
78:41 - loop inside another for loop so inside
78:45 - these curly braces we have access to
78:48 - each element
78:50 - stored in a booking variable
78:52 - and
78:53 - index of that variable one by one so the
78:57 - booking variable has a full name like
79:00 - nicole smith with a space character
79:03 - between and in order to get the nicole
79:06 - the first name we can simply split the
79:09 - whole string on a space character using
79:12 - goes built-in function called fields
79:18 - like this
79:19 - and the fields function comes from
79:21 - strings package
79:23 - so this will take our full name string
79:26 - split it on
79:27 - empty space and gives us a slice of
79:30 - strings separated by space
79:33 - which in this case is nicole and smith
79:36 - two values so a slice with two elements
79:40 - and we're gonna save that into a
79:41 - variable called names
79:43 - so names will basically be an array
79:46 - containing two elements the first name
79:48 - and the last name and you learned to get
79:51 - the first element of an array or slice
79:54 - we just use index 0
79:57 - and that's going to be our first name
79:59 - very easy now of course we're using a
80:01 - package and its function so we need to
80:05 - import that package and this is actually
80:08 - one of the cases that i mentioned at the
80:09 - beginning if you want some functionality
80:12 - of go you probably will not know by hard
80:15 - in which package you have such a
80:17 - functionality available and what is the
80:19 - name of the function so of course in
80:21 - this case you just google how to
80:24 - separate strings on space or something
80:27 - similar and you get results probably
80:29 - from ghost
80:30 - official documentation
80:32 - that references
80:34 - this example so let's go ahead and
80:36 - import these strings package
80:38 - right here now here we're just importing
80:40 - one package we haven't actually needed
80:43 - any other but if we want to import
80:45 - multiple packages then we have to
80:47 - enclose it into
80:49 - brackets
80:51 - and each package
80:53 - should be on
80:55 - a new line like this
80:58 - and then close that bracket and there
81:00 - you go now if you scroll down you see a
81:02 - bunch of
81:03 - red lines here which are all about
81:05 - variables that are declared but not used
81:08 - and we're going to fix those one by one
81:10 - first of all we need to save this first
81:13 - name in our first names slice right
81:16 - because we're basically going through
81:18 - these bookings and we're collecting a
81:21 - list of first names in this
81:23 - slice and to add an element to a slice
81:27 - remember we use the append function
81:29 - which has the slice variable inside and
81:33 - the element that we are adding which is
81:35 - actually first name and we have to then
81:38 - assign it back
81:40 - to the slice variable like this so again
81:43 - we're defining a list variable here a
81:45 - slice variable and then within this loop
81:48 - one by one we're adding a first name to
81:51 - this first name slice so at the end of
81:54 - the for loop when we use first names
81:57 - here it's going to have the list of all
82:00 - the first names from the bookings list
82:02 - now we can actually
82:04 - spare us this line here
82:06 - by just grabbing this value here and
82:10 - using it directly
82:11 - in the append
82:13 - so we don't need
82:14 - an additional variable like this
82:17 - so basically when the loop is
82:20 - done collecting the first names we can
82:23 - print it out right here
82:24 - let's do
82:26 - the first names
82:31 - of bookings
82:33 - are
82:35 - and then we have first
82:37 - names
82:39 - instead of the bookings
82:41 - now you see that we still have one error
82:43 - here that we need to fix before we can
82:45 - run our application and that is
82:48 - the index variable that we created here
82:51 - is not being used because we don't
82:53 - actually need this index
82:55 - in our logic but we can't just remove it
82:59 - and just leave booking here
83:02 - it needs to be there because we are
83:04 - expecting two values here so we have to
83:06 - save both of them in a variable so
83:09 - instead we can fix the problem by simply
83:12 - using an underscore in its place which
83:15 - is known as a blank identifier in go
83:18 - underscores are used to identify
83:21 - unused variables so basically we're
83:24 - saying there is a variable here but we
83:26 - just want to ignore it
83:28 - because we don't need to use it and if i
83:31 - save this you see that error is gone and
83:33 - that is because we're telling go that we
83:35 - know that there is a variable defined
83:38 - here that we are explicitly not using
83:41 - that's basically the idea of using
83:43 - underscore so now with these changes
83:45 - let's run our application again
83:48 - and see that only first names get
83:51 - printed out
84:05 - and you see that our application logic
84:07 - works pretty good we have updates in
84:10 - tickets after every booking and
84:12 - at the end of each booking we also get a
84:15 - list of first names printed out and
84:18 - again you can quit the application using
84:21 - control and c
84:26 - great now we have two for loops in our
84:29 - but the first one the indefinite for
84:32 - loop never ends it keeps asking for
84:35 - the next booking but what if all 50
84:37 - tickets are booked out we need to end
84:40 - the application and say that conference
84:42 - is sold out so after every booking we
84:45 - need to check if the remaining tickets
84:47 - is zero
84:49 - and if it is we end the application
84:52 - otherwise we let it continue and we do
84:54 - that using
84:55 - if else checks which is a concept you
84:58 - have in all programming languages and is
85:01 - super easy
85:05 - so let's see how it works so at the end
85:07 - of the booking
85:09 - within our indefinite for loop
85:12 - right here we make the check to see if
85:15 - the remaining tickets is zero so no
85:17 - tickets are left so we start with if
85:20 - keyword and the expression after the if
85:23 - keyword is called a condition like
85:26 - remaining tickets
85:28 - equals zero and the data type of such
85:32 - conditional statement is a boolean true
85:35 - or false
85:36 - so either this
85:38 - statement is true remaining tickets is
85:41 - really zero or it's false so we're
85:44 - telling the program if this condition is
85:46 - true then execute the code within these
85:49 - curly braces or within the if statement
85:52 - block if this condition is not true
85:55 - then skip the execution of whatever code
85:58 - is defined here and skip to the next
86:01 - line which in our case is the next
86:03 - iteration of our for loop
86:07 - so if the remaining tickets is zero we
86:09 - want to basically end the program so
86:12 - here is going to be logic for
86:14 - quitting the application
86:16 - so first let's actually print out
86:19 - a message
86:20 - for the user saying
86:23 - something like our conference
86:28 - is booked out
86:31 - come back
86:32 - next year
86:33 - and after that we end the application
86:36 - how do we do that we basically break the
86:38 - loop
86:39 - using
86:40 - break keyword so this will basically end
86:43 - the loop which means the application
86:45 - execution is over because there is
86:47 - nothing
86:48 - after the for loop right application
86:51 - ends
86:52 - so as i said this
86:54 - expression here
86:56 - or the value of
86:58 - this expression
87:00 - is of a boolean data type so we should
87:02 - have a boolean type keyword for that and
87:05 - be able to create variables of that type
87:07 - as well right just like for other data
87:10 - types so i could actually take this
87:12 - whole expression
87:15 - and save it into a variable
87:18 - which we can call
87:19 - no tickets
87:22 - remaining
87:24 - which is of a boolean type
87:27 - and then we can use this
87:29 - variable as a conditional of the if
87:31 - statement
87:33 - again with an alternative syntax we can
87:39 - write this expression like this
87:42 - and by the way note the syntax for
87:45 - double equal signs here instead of
87:47 - one equal sign so one equal sign is for
87:50 - assigning values to variables
87:53 - double equal sign is for comparing
87:56 - two values to each other again nothing
87:58 - specific to go this is actually same in
88:01 - other programming languages now since
88:04 - we're using this
88:05 - variable only once here there's actually
88:08 - no need to save this expression into a
88:10 - separate variable so i'm going to
88:13 - change it back
88:15 - to before
88:17 - and leave it directly in the if
88:19 - statement so let's actually test that
88:21 - our logic works and the application ends
88:25 - when users have booked all 50 tickets
88:28 - so let's run the application
88:30 - provide the data
88:32 - and let's actually take all 50 tickets
88:35 - at once
88:36 - like this
88:37 - and as you see after it printed the
88:40 - first names of bookings
88:42 - right here we went to the next line so
88:45 - that remaining tickets equals 0 is true
88:49 - so it
88:50 - so this condition was true and because
88:53 - of that it actually executed these two
88:55 - lines
88:56 - and it printed out our conference is
88:58 - booked out come back next year and it
89:01 - broke out of the loop which ended the
89:03 - program now this makes sure that the
89:05 - program ends when all tickets are booked
89:08 - but what if a user wants to book more
89:11 - tickets than available so what if i
89:13 - typed 52 instead of 50. let's see what
89:17 - would happen in this case
89:19 - with our application
89:21 - so let's run it again
89:25 - and i'm going to book 52 tickets
89:29 - and this is the output first of all we
89:32 - have
89:33 - this weird number of tickets remaining
89:36 - and second the application didn't end it
89:39 - actually continues to ask for
89:42 - another user input so as you see our
89:44 - application cannot handle when user
89:48 - wants to book more than available number
89:50 - of tickets
89:52 - and the reason why application didn't
89:54 - end even though we exceeded the ticket
89:57 - amount is because the remaining tickets
89:59 - is not zero anymore it's this number
90:03 - here that's why these two lines were not
90:06 - executed so let's fix this issue and to
90:09 - do that before the booking happens
90:12 - right here where we take the remaining
90:14 - tickets and we deduct
90:16 - the user tickets from it before that
90:19 - even happens we need to
90:21 - check so we need another if statement
90:25 - to check whether user tickets
90:27 - is
90:28 - greater than the remaining tickets so if
90:31 - user is trying to book more tickets than
90:33 - is available again very easy
90:37 - we have if and then condition which says
90:40 - user tickets is
90:42 - more than
90:43 - remaining tickets
90:45 - right
90:47 - so this is going to be an invalid input
90:50 - from the user so we need to tell the
90:52 - user
90:54 - something like we only have
90:58 - this many tickets
91:01 - remaining
91:02 - so you can't
91:04 - book
91:07 - so many tickets
91:10 - and let's substitute those
91:12 - values so we have
91:15 - remaining tickets and this is the user
91:17 - tickets that they're trying to book
91:21 - so we inform the user about their wrong
91:23 - input
91:24 - but we also have to end the program
91:27 - because if this is true then all this
91:31 - rest of the code should not be executed
91:34 - right the ticket should not be booked so
91:36 - same is
91:39 - right here we
91:41 - break from the loop which ends the
91:44 - program so this break here will
91:46 - basically tell go to skip execution of
91:50 - the rest of the code in the iteration
91:53 - and
91:54 - stop the loop
91:55 - so all of these will be skipped so let's
91:58 - test our logic
92:05 - and
92:06 - try with 52 again
92:09 - and as you see
92:10 - the program says we only have 50 tickets
92:12 - remaining so you can't book 52 tickets
92:16 - and as you see none of the
92:18 - next lines gets executed and the program
92:21 - exits so now we are handling an invalid
92:24 - input from the user to protect our
92:27 - application from the outcome that we saw
92:29 - previously now let's say
92:31 - we don't want to end the application if
92:34 - user wants to book more tickets than
92:36 - remaining we want to allow them to try
92:38 - to book again with the corrected number
92:40 - of tickets so we don't want to stop the
92:43 - for loop completely with break we want
92:46 - to tell the user hey you're trying to
92:48 - book an incorrect number of tickets so
92:52 - please try again so we want to skip all
92:55 - of these to the next iteration of the
92:57 - for loop instead of breaking out of the
92:59 - for loop completely and we can do that
93:02 - also very easily
93:03 - using another instruction called
93:06 - continue
93:08 - so instead of break
93:10 - we say continue to the next iteration so
93:14 - continue just like break we'll skip all
93:17 - of this but instead of ending the loop
93:20 - it will basically go to the next
93:22 - iteration of the loop so let's try that
93:24 - as well
93:29 - let's do
93:30 - 52 again
93:32 - and you see the message gets printed out
93:36 - you can't book so many tickets but it
93:39 - skips to the next iteration and it
93:41 - starts with enter your first name again
93:43 - so user has another chance to enter
93:45 - correct amount so this makes our
93:47 - application a little bit more
93:48 - user-friendly
93:52 - now what if we wanted to check for the
93:54 - reverse condition and check if user
93:57 - wants to book
93:58 - less tickets than available or exactly
94:01 - the same number how could we do that
94:04 - first we change the expression to less
94:06 - than or equal so user tickets is either
94:11 - exactly same as remaining tickets or is
94:13 - less and we say if this condition is
94:16 - true so it's a valid input from the user
94:19 - then everything is great they can book
94:21 - the ticket so
94:22 - this whole logic here can be executed so
94:26 - instead of these two
94:30 - lines i'm going to put this outside of
94:33 - the
94:34 - if
94:34 - block
94:36 - so instead
94:37 - this logic will be executed
94:40 - so we are reversing the check and don't
94:43 - forget to fix the indentation here so if
94:46 - this condition is true
94:47 - then
94:49 - this logic should be executed which
94:52 - actually books the tickets
94:54 - now what about this code here where does
94:56 - this logic go well after the if block is
94:59 - finished
95:00 - we add
95:01 - an else statement
95:03 - which says otherwise
95:06 - so if this is not true
95:08 - it's false in that case execute code in
95:12 - this block
95:16 - and that's where this logic will go
95:19 - so basically either at any iteration
95:22 - either the if block will get executed or
95:25 - else block right
95:27 - so this is an if else statement
95:31 - and this basically logic wise does
95:33 - exactly the same as before we just
95:36 - changed
95:37 - the condition here
95:39 - and because only one of those blocks
95:41 - will be executed we don't need the
95:43 - continue part here to skip
95:46 - the booking logic right because the
95:48 - booking logic is in its own
95:50 - block so say so let's move the continue
95:53 - and save and if i test this again
96:02 - and try 52
96:04 - you will see the error message so this
96:06 - line was executed the else block
96:09 - basically and without the continue
96:12 - keyword it skipped to the next iteration
96:14 - because that's actually the next line of
96:17 - the code after the else block
96:22 - now let's say we wanted to do something
96:25 - different if the user tickets and
96:29 - remaining tickets were exactly
96:31 - equal so if that was the case we wanted
96:34 - to do something completely different
96:35 - than what we're doing here or here so
96:39 - where could we put this logic in that
96:41 - case we would split up this condition so
96:44 - here we would say if user tickets is
96:47 - less than remaining tickets then do
96:49 - whatever is defined here otherwise
96:53 - else
96:54 - if
96:56 - user tickets is exactly equal to
96:58 - remaining tickets
97:02 - then
97:03 - do something else
97:07 - and finally
97:10 - if none of these are true so this is
97:13 - false and
97:15 - this is also false
97:18 - then execute the else block and you can
97:20 - have as many else if statements in
97:23 - between if and else as you want but you
97:26 - can only have one if statement and one
97:29 - final else statement now let's revert
97:31 - this because we're not doing anything
97:36 - different here
97:37 - and let's revert back to our if else
97:39 - statement
97:43 - now there is another place where we use
97:46 - conditionals
97:47 - that are true or false
97:49 - and that's in for loops so in addition
97:52 - to looping through a list
97:55 - like this we can also say
97:57 - execute the code in a loop for as long
98:00 - as a specific condition is true like
98:04 - execute code in this block
98:07 - within this for loop
98:09 - for as long as remaining
98:11 - tickets is more than zero or as long as
98:15 - the size of the bookings list is less
98:19 - than 50 or even a combination of both
98:22 - like this
98:27 - so we can use the same conditions that
98:29 - we saw in ifall statements
98:31 - as the for loop conditions
98:33 - and tell our program to execute whatever
98:36 - code is inside that for loop as long as
98:40 - this condition is true as soon as it
98:42 - becomes false the for loop execution is
98:45 - over now you may be thinking at this
98:47 - point why didn't we have any condition
98:51 - in our infinite for loop why doesn't it
98:54 - say anything well since the conditions
98:56 - can be true or false an infinite loop
98:59 - can be written by using condition true
99:02 - so basically hard coding aesthetic true
99:04 - will make this loop an infinite loop and
99:07 - that's what we have and whenever we have
99:09 - that we can just leave out the condition
99:12 - and have
99:13 - for loop with no condition and that's
99:15 - going to be the same as
99:17 - saying for true and that's why we don't
99:19 - have to explicitly specify condition but
99:23 - again as i said if you want to write a
99:25 - for loop that only runs as long as a
99:27 - specific condition is true you can
99:30 - define that condition right here
99:35 - another common use case for if else
99:38 - statements is user input validation in
99:42 - our application we are allowing users to
99:45 - enter their data but users don't always
99:48 - enter data correctly either
99:50 - intentionally or unintentionally and we
99:53 - developers must make sure that our
99:56 - application doesn't crash when user puts
100:00 - in bad input so we have to make sure
100:02 - that our application is so robust that
100:05 - it can actually handle any type of bad
100:08 - user input and the way to do that is to
100:11 - always check whether the user input
100:13 - contains valid information any
100:16 - unexpected values and so on so in our
100:19 - case let's check a couple of things in
100:21 - user input that we're expecting so these
100:24 - are the four pieces of data that we are
100:26 - getting from the user and we want to
100:29 - check all of those first let's check
100:31 - that the names that user provides are
100:35 - valid the first name and last name and
100:37 - let's say the valid name for us is a
100:40 - string with at least two characters now
100:43 - if the user provided a wrong name this
100:45 - would not crash the application but we
100:48 - want to make sure that users are not
100:49 - spamming our application and are
100:51 - actually giving correct information at
100:53 - least we try to partially check that and
100:56 - again we have to do the validation part
100:59 - before
101:00 - the booking logic gets executed right
101:03 - because
101:04 - if they entered invalid data we don't
101:06 - allow the booking
101:08 - so right here let's check that first
101:10 - name and last name length is at least
101:13 - two characters
101:14 - but we're not going to do anything with
101:16 - it yet
101:17 - we will just save it into a variable and
101:20 - use it later now to check the length of
101:22 - a string we have the built-in function
101:26 - called len length which you already
101:29 - learned from arrays and slices so for
101:32 - arrays and slices this checks the size
101:35 - of the list for strings it checks the
101:37 - size of the characters so how many
101:39 - characters are in a string
101:41 - so
101:42 - first name length
101:45 - should be at least
101:47 - two so it can be two as well that's why
101:50 - we're going to do greater than or equal
101:52 - to two and the same should be true for
101:55 - the last name so in addition to that we
101:57 - also want to
101:59 - validate last name in the same statement
102:01 - and we can do that or we can chain these
102:04 - two conditions using
102:06 - end
102:07 - characters again note the double
102:09 - ampersand signs
102:11 - so this basically says this condition
102:14 - and
102:17 - this condition
102:18 - so this is going to be check for last
102:20 - name
102:21 - and whatever value of this expression
102:23 - again assign it to a boolean variable
102:26 - and we're going to call it
102:28 - is valid
102:30 - name
102:33 - again we can skip the boolean type
102:35 - because go can imply from the value that
102:39 - it's a boolean
102:40 - type so we can save that
102:43 - and we can also use the
102:45 - alternative syntax like this so again if
102:49 - user entered the first name that is at
102:52 - least two characters long
102:55 - and last name which is also at least two
102:58 - characters long then this whole thing
103:00 - will be true and we're gonna assign the
103:02 - true to is valid name variable now if
103:06 - any one of those is false so if first
103:08 - name is valid but last name is not or
103:11 - vice versa then this whole expression
103:13 - will be also false and that false value
103:17 - will then be assigned to is valid name
103:19 - variable now let's validate the email
103:21 - address
103:22 - and let's say for email address we want
103:25 - to make sure
103:26 - they're not entering an invalid email
103:28 - format so we're going to check that the
103:31 - value of email or the string
103:34 - contains the it
103:36 - sign now you already learned the strings
103:39 - package
103:41 - from which we use this fields
103:44 - function
103:44 - and the same strings package actually
103:47 - has
103:48 - a function called contains
103:53 - that takes a string
103:55 - as a first input and then a character
103:59 - or
104:00 - multiple characters that we want to
104:02 - search in that string
104:04 - and this will actually give us
104:06 - a boolean result back
104:09 - so if
104:10 - the string
104:11 - contains
104:12 - this character or these characters then
104:15 - it will give us true back if not then
104:18 - it's going to be false
104:20 - so we can call this
104:22 - is
104:24 - valid email
104:29 - and assign this whole value to it
104:32 - so we assume if email user gave us
104:35 - contains this character then it is a
104:38 - valid email if not then it's not valid
104:40 - and finally let's check the user tickets
104:44 - and validate that
104:46 - user
104:47 - didn't enter a number of tickets which
104:49 - is negative or zero so it has to be
104:53 - positive number greater than zero
104:55 - so again user tickets is more than zero
104:59 - will be a valid ticket count now we have
105:02 - another
105:03 - check for the user tickets which is
105:06 - that it's a less than remaining ticket
105:08 - so a user cannot book more tickets than
105:10 - available so that's going to be another
105:12 - validation for this input and we can
105:15 - actually add that
105:17 - right here
105:19 - also with this end sign so both of these
105:22 - expressions
105:23 - need to be true so that we have a valid
105:26 - user ticket if any one of those is wrong
105:29 - let's say user tickets is a positive
105:32 - number but it's
105:34 - more than remaining tickets then it's
105:36 - going to be invalid input so let's call
105:38 - this is valid
105:41 - ticket number
105:44 - and here we have our
105:46 - user input validations so as i said we
105:49 - can chain multiple conditions like this
105:52 - with double end sign to make sure both
105:54 - of these are true to give us a valid
105:56 - ticket number we can also chain
105:59 - conditions with or instead of end
106:02 - let's say the conference is taking place
106:04 - in two cities
106:06 - singapore and london
106:08 - and user can choose which one
106:11 - they want to go to or which location
106:13 - they want to attend so they can choose
106:15 - between those two cities but they can't
106:17 - enter some random city that is not valid
106:20 - so
106:21 - in that case we could have a check
106:24 - is valid city
106:26 - where let's say if we had the city as an
106:28 - input we would check if it's either
106:31 - singapore
106:35 - or
106:40 - london
106:44 - so city cannot have both of these values
106:47 - right it has to have either singapore or
106:50 - london if it has some other value then
106:52 - it is an invalid city but if it's valid
106:54 - then it should be
106:56 - either
106:57 - or so in this case we chain this
106:59 - condition using or instead of
107:02 - int
107:02 - well sometimes we need to check whether
107:04 - the user did not enter a specific value
107:08 - for example let's say we want to check
107:10 - is invalid city
107:15 - which means
107:16 - user didn't enter
107:18 - either singapore
107:20 - so the city is not singapore
107:22 - and
107:24 - it's also not
107:25 - london
107:27 - so basically if both of these conditions
107:29 - are true so the city
107:31 - the value of the city is not singapore
107:33 - and is not london then is invalid city
107:36 - is true
107:38 - so this here is a negation or not equal
107:42 - and it may be a little bit confusing
107:43 - than positive statements like equal or
107:46 - greater than etc so if this is
107:49 - more confusing than the previous
107:51 - statement then what you could also do
107:54 - is revert this back to
107:57 - is valid city and then
108:00 - using that exclamation
108:02 - mark you can
108:04 - negate
108:05 - the result of this so basically this
108:09 - statement with exclamation mark is valid
108:12 - city is exactly the same as the negative
108:15 - check that i just showed you and you
108:16 - could use this in the if statement of
108:18 - course like this
108:20 - okay now let's clean up all these
108:21 - examples
108:26 - and go back to our
108:28 - user input
108:30 - checks we have saved all these checks in
108:32 - variables so now it's time to use those
108:35 - variables in the if statement and
108:37 - execute the booking
108:39 - only if all the user input values are
108:42 - valid and skip the booking if at least
108:46 - one of those
108:48 - user
108:49 - inputs are invalid
108:51 - so if name and email are correct but the
108:53 - ticket number is invalid of course we
108:55 - want to skip the booking so in the if
108:57 - statement we check
108:59 - if is valid
109:02 - name
109:03 - is true
109:04 - and
109:05 - is valid email is also true
109:09 - and
109:10 - is valid ticket number is also true so
109:13 - all three have to be true in order to
109:16 - execute the booking so again we're
109:19 - chaining this with end
109:21 - symbols which means all of these three
109:24 - have to be true in order to execute the
109:26 - booking and if i save this we also get
109:29 - rid of the error and if any of the user
109:32 - inputs is wrong we're going to
109:34 - inform the users about that saying
109:42 - using a simple message that says
109:44 - your input
109:46 - data is
109:48 - invalid
109:49 - try again
109:51 - let's save it and let's actually test
109:53 - that our validation logic works
109:57 - so i'm going to put in
109:58 - first name which is just one character
110:04 - and
110:05 - all the other stuff are correct
110:09 - as you see we get invalid data input
110:12 - let's now try
110:15 - a wrong email address
110:19 - without the add sign
110:22 - and again invalid input data and you can
110:25 - also test ticket number and so on
110:27 - so now we have some kind of protection
110:29 - in our application against
110:32 - bad user input as i said the bad or
110:35 - invalid user input can be intentional or
110:38 - unintentional sometimes
110:41 - users accidentally enter wrong
110:43 - information so we could optimize our
110:46 - application to tell the user
110:49 - what they actually entered incorrectly
110:51 - so they can correct it so instead of
110:53 - this generic message here which says
110:55 - your input data is invalid we're going
110:58 - to say exactly
110:59 - what they entered wrong
111:01 - so right here we're going to have
111:03 - if statements that check which of the
111:07 - inputs were actually wrong
111:10 - so we're going to say if
111:12 - is valid name
111:14 - is not true
111:16 - remember the negation with exclamation
111:18 - mark so if
111:19 - name is invalid so this translates to is
111:23 - invalid name
111:25 - in that case
111:27 - we're going to print
111:32 - first name
111:33 - or last name
111:35 - you entered
111:39 - is too short
111:43 - we're going to do the same for
111:44 - email and we're going to say if
111:49 - email is invalid
111:53 - or if
111:54 - is valid email is not true
111:57 - we're going to print
111:59 - a message that says
112:02 - email
112:05 - address you entered
112:08 - does not
112:10 - contain
112:12 - at sign
112:16 - and finally
112:18 - is
112:19 - not valid ticket number
112:22 - we're going to say
112:24 - number of
112:27 - tickets you entered is invalid
112:32 - and we don't need this generic message
112:34 - here and note that we don't have else
112:37 - here we just have if statements because
112:40 - we want each of these statements to be
112:42 - executed because they might have entered
112:45 - all these data wrong wrong name wrong
112:48 - email wrong ticket number so in that
112:49 - case we want to say your name is wrong
112:52 - your email is wrong the number of
112:54 - tickets is invalid if this were else if
112:57 - conditions like this
112:59 - and user had entered
113:01 - invalid name then this would be true and
113:03 - this line would be executed and
113:06 - the else blocks will be skipped because
113:08 - as i said
113:10 - with if else or if else if statements
113:13 - only one of the blocks gets executed not
113:15 - all of them or not multiple of them
113:18 - that's why we're gonna
113:20 - revert it back to if statements
113:23 - and
113:24 - now let's actually try to input a bunch
113:27 - of wrong data
113:29 - like this
113:31 - wrong email
113:33 - number of tickets zero
113:35 - and we get
113:37 - all of these messages it says the name
113:40 - is too short
113:41 - email is invalid
113:43 - and number of tickets is also invalid so
113:46 - now user knows exactly what they entered
113:48 - wrong
113:49 - so as you see if else statements are
113:52 - super important in applications because
113:54 - they basically control the whole
113:56 - application flow it's like a decision
113:58 - tree right we do different things based
114:01 - on different conditions
114:03 - now let's see another concept in
114:05 - programming which is similar to e-file
114:07 - statements which is switch statement
114:10 - let's say our conference is held in six
114:13 - different cities
114:14 - and for most of the cities we have
114:16 - different booking processes and the data
114:19 - we are asking from users so the
114:22 - application logic is basically different
114:25 - based on for which city you want to book
114:28 - the conference ticket so at the
114:30 - beginning of the application we need to
114:31 - check which city user selected and based
114:34 - on that selection we then execute a
114:37 - different code block now if we have to
114:39 - check for six different cities having
114:42 - six if else statements
114:45 - may not be optimal
114:47 - and for such cases we have switch
114:49 - statements
114:50 - now we're not going to execute this code
114:52 - so i'm just going to show you the
114:54 - example syntax right here of how switch
114:57 - statements actually look like so let's
114:59 - say we have this city
115:02 - variable that user basically selects and
115:05 - let's say the user selected london
115:08 - and right here we need to check which of
115:10 - the six cities
115:13 - user wants to book tickets for so first
115:15 - we have the switch keyword that checks
115:18 - the value of city and here we have
115:21 - multiple cases so case one is
115:25 - city value equals
115:27 - new york
115:29 - in which case
115:32 - we want to
115:33 - execute code
115:37 - for
115:38 - booking
115:40 - new york
115:42 - conference tickets
115:44 - another case or another possible value
115:46 - for
115:47 - city
115:48 - is
115:50 - singapore
115:51 - and again
115:53 - here we would execute code for
115:56 - booking
115:58 - a singapore conference tickets
116:01 - in other case
116:03 - let's say we have london
116:06 - again some code here
116:13 - and i'm just going to copy
116:17 - and let's do mexico city
116:19 - and finally
116:21 - hong kong
116:24 - and after each case we have
116:27 - we need the colon
116:29 - so all these are possible values for
116:32 - city
116:33 - so these are where the conferences are
116:35 - held but as i said users sometimes enter
116:38 - invalid data so we also need to
116:41 - handle
116:42 - when
116:43 - the city has none of these values and
116:45 - that's going to be a default case
116:49 - in the switch statement so basically
116:51 - when none of these are true
116:54 - then we execute a code block
116:57 - which let's say prints out
117:00 - no valid city selected
117:04 - so that's like the else in the e-file
117:06 - statement
117:07 - so switch just like e-files basically
117:09 - controls
117:10 - the application flow and based on a
117:13 - value of whatever variable we pass into
117:16 - switch we execute a different logic in
117:19 - our application
117:20 - now let's say
117:22 - the booking logic for london and berlin
117:25 - is the same
117:26 - as well as booking logic for singapore
117:29 - and hong kong
117:30 - is also the same so in this case we
117:33 - don't want to
117:34 - duplicate the code
117:36 - instead we want to consolidate those two
117:38 - cases
117:39 - saying if
117:41 - the city is london or berlin then
117:45 - execute this code and we can also do
117:47 - that in switch statement
117:49 - by
117:50 - listing all the possible values like
117:53 - this
117:57 - and this will be the same logic
117:59 - for london and berlin
118:01 - and
118:02 - as i said
118:09 - for
118:11 - these two cities as well
118:14 - like this
118:15 - so basically
118:16 - in switch statements you can also
118:18 - consolidate multiple values and execute
118:22 - a certain logic for multiple values
118:25 - so that's how switch statements work
118:27 - again let's clean this up
118:33 - and get back to our
118:35 - booking logic
118:40 - now our super simple application became
118:43 - already pretty crowded
118:45 - we have all this code in our main
118:47 - function
118:48 - that keeps on growing so it would be
118:51 - nice to start cleaning it up by taking
118:54 - parts of the code that do one specific
118:57 - thing
118:58 - and putting them in functions
119:01 - with some descriptive name so we
119:03 - encapsulate a code block into its own
119:06 - container called a function give it a
119:08 - name that makes it immediately clear
119:11 - what that code block does and use that
119:13 - block of code simply by calling the
119:16 - function by its name so let's see how to
119:19 - write functions in go well in fact we
119:21 - have already created a function at the
119:23 - beginning which was the main function so
119:26 - the same way after the main function
119:29 - ends right here
119:31 - that's the end of the main function
119:33 - block
119:34 - we create another one
119:35 - using a func keyword
119:38 - then again name of the function and
119:40 - let's call this one greet
119:42 - users
119:44 - and after that we have again function
119:47 - block using the curly braces so each
119:50 - function has its own
119:52 - block
119:54 - and when we call the function then
119:56 - whatever code is inside those curly
119:58 - braces gets executed
120:00 - like
120:02 - a print statement
120:05 - which says welcome
120:07 - to our
120:10 - conference so we have created a simple
120:13 - function that basically just prints out
120:15 - welcome to our conference now when we
120:18 - run our application this code will not
120:21 - get executed because when we create or
120:24 - define a function it basically just
120:26 - stores whatever code is inside
120:29 - for later use but it doesn't actually
120:31 - execute it for that we need to
120:33 - explicitly execute or call the function
120:38 - inside the main function because this is
120:41 - as i mentioned at the very beginning
120:43 - this is the function that go will look
120:45 - for to start the execution so if we
120:48 - create other functions
120:50 - we have to explicitly call them
120:53 - inside the main function so that code
120:55 - inside them gets executed
120:57 - and calling a function is super easy
121:00 - let's say right here at the beginning we
121:02 - want to
121:04 - call grid users function that will then
121:06 - print out the welcome message
121:11 - so if we run our application we have
121:12 - this
121:13 - welcome to our conference which comes
121:16 - from greet users function
121:19 - and then of course we have whatever we
121:20 - define in the main
121:24 - now let's say we want to greet users
121:26 - with the conference name instead of just
121:28 - a generic
121:30 - welcome to our conference so basically
121:32 - the same way as we're doing right here
121:35 - so how can we give the grid users
121:37 - function the value of the conference
121:40 - name variable which we defined here
121:42 - well we can pass it as an input
121:45 - parameter so we can hand it over to
121:47 - greet user's function saying here is the
121:50 - value of conference name variable
121:52 - you can use it inside your function
121:55 - block in your code
122:00 - by just
122:02 - passing it within the brackets
122:04 - but we also need to tell the
122:07 - function itself
122:08 - that it is expecting a parameter we can
122:12 - just throw some parameters to a function
122:13 - randomly we have to expect it explicitly
122:17 - here as well so in the function
122:19 - definition within the brackets
122:21 - we're going to define that parameter
122:23 - using
122:24 - either the same name as the variable
122:26 - that we're using or we can also give it
122:29 - a completely different name
122:31 - it's up to us so we can call it whatever
122:33 - we want and we also have to specify its
122:36 - type because remember variables in go
122:39 - have to have types so we're telling this
122:42 - function you're expecting an input
122:44 - parameter called conf name which is of
122:47 - type string
122:48 - so think of this as a variable inside a
122:51 - function this is very similar to
122:54 - doing this
122:57 - inside a function
122:58 - and that's actually what happens in the
123:00 - background when the function gets called
123:02 - and then you can use this
123:03 - variable or this variable inside
123:06 - this function block
123:08 - and that's what we're going to do we're
123:10 - going to say welcome to
123:14 - booking
123:15 - application
123:18 - and use the conf name value
123:23 - so now if we run the application
123:26 - and we forgot the new line here
123:31 - we got exactly same output
123:36 - as on this line so we basically
123:39 - extracted
123:41 - this code into a function
123:44 - so we don't need this one and let's
123:46 - actually put
123:47 - the whole greeting logic into our grid
123:50 - function so i'm going to take this
123:55 - and in the grid users function
123:57 - let's edit right here and the same way
124:00 - that we pass the conference name we also
124:02 - need to pass
124:03 - these two
124:04 - values because we have to have them
124:06 - available within the function so we have
124:08 - to pass them as input parameters
124:12 - and as i said we can call these whatever
124:14 - we want
124:16 - like conf tickets
124:18 - which is integer
124:20 - and
124:21 - let's call the other one remaining
124:23 - tickets which is
124:24 - u integer unsigned integer
124:29 - like this and of course now whenever we
124:32 - call this function
124:34 - we have to pass all three parameters
124:36 - otherwise we're gonna get an error like
124:39 - here it says
124:40 - not enough arguments so let's pass those
124:44 - two values as well
124:45 - first one is conference tickets
124:48 - this value and then we have
124:51 - the remaining tickets
124:54 - save and the error is gone so we
124:56 - replaced these print
124:59 - lines with a function call
125:03 - like this which makes our main function
125:06 - a little bit cleaner and now if we run
125:09 - the application we should actually get
125:10 - exactly the same output as before we had
125:13 - the function
125:15 - and as you see we have our welcome
125:17 - statement
125:19 - all the values are substituted
125:20 - everything looks fine
125:23 - so we extracted first
125:26 - group of code
125:27 - into a function and gave it some
125:29 - descriptive name that says
125:31 - this will greet the users
125:33 - now let's take the code for
125:36 - picking out the first names so this code
125:39 - block here and put it in a function
125:41 - called
125:42 - print first names because that's what it
125:44 - does right it
125:46 - goes through the bookings and it prints
125:48 - the first names of the people who booked
125:51 - the tickets so i'm gonna
125:53 - cut this whole thing out
125:55 - so here we will call
125:58 - function
125:59 - print
126:00 - first names and right here we're going
126:02 - to create that function with the name
126:05 - again descriptive name print
126:08 - first
126:09 - names
126:11 - again function block and all the code
126:13 - that i copied will go
126:15 - inside
126:17 - if i save again you'll see that
126:20 - we need some values
126:22 - as an input because we don't have them
126:24 - available here so go doesn't know where
126:26 - this bookings variable comes from it's
126:28 - not available inside this function so we
126:31 - have to pass it as a parameter
126:34 - and we're going to define it here
126:36 - bookings is a slice of strings
126:39 - so the type is going to be
126:41 - square brackets and string that's it
126:44 - and if i save this error will disappear
126:47 - now we have to actually call this
126:49 - function otherwise
126:51 - the first names will not be printed out
126:54 - so
126:57 - function call and we have to pass
126:59 - bookings as a parameter
127:02 - that's it
127:03 - we have extracted
127:05 - another block of code or another logic
127:08 - into its own function
127:12 - now let's say we wanted to print the
127:14 - first names actually in the main
127:17 - function so we only want to pick the
127:19 - first names
127:21 - from the bookings slice
127:23 - in this function but the final printing
127:26 - so this line here should actually be
127:28 - done in the main function for whatever
127:30 - reason so instead of printing
127:33 - the first names we want this function to
127:35 - actually just return the first names to
127:38 - the main function so that main can print
127:40 - it itself so instead of this line we
127:43 - want
127:44 - return
127:47 - first names
127:48 - so return keyword as you see the
127:50 - highlight here
127:51 - says that this function is doing some
127:54 - logic and then returning a result
127:58 - of that logic back to the main function
128:01 - and we have an error here because
128:03 - whenever we are returning something from
128:05 - a function we also have to specifically
128:08 - say that in the function definition that
128:11 - we are returning a value of
128:14 - a certain type in our case first names
128:16 - is also
128:18 - a slice of strings so
128:21 - that's what we're returning so note that
128:24 - within those brackets we have the input
128:26 - parameters and outside
128:29 - those brackets
128:31 - we have
128:32 - output parameters
128:34 - with a type of the output we're
128:36 - returning and this print line
128:39 - should go back to
128:42 - the main function
128:44 - and if i save this of course
128:46 - main function doesn't know this variable
128:49 - because we should get that from this
128:52 - function right here and let's actually
128:54 - rename this function now because it now
128:56 - doesn't print the first names it just
128:59 - returns or gets the first names
129:05 - and whenever function actually returns
129:06 - something to us we can save that return
129:09 - value into a variable
129:12 - and let's call this variable first names
129:14 - because
129:15 - that's what we need here
129:19 - equals first names
129:21 - is a result of
129:23 - whatever get first names function gives
129:26 - us
129:27 - and that's it
129:28 - so our function does its thing its logic
129:31 - it gives us a result and then we take
129:33 - that result in the main function
129:36 - like this and do something with it like
129:38 - print it out
129:39 - let's see what else can we extract here
129:42 - another candidate for its own function
129:44 - can be the user input validation so i'm
129:47 - going to take this logic and let's
129:49 - actually create
129:50 - another function called
129:52 - validate
129:54 - user input
130:00 - and again let's
130:01 - fix the indentation
130:04 - like this
130:05 - by now you already know how this works
130:07 - we need to define all the variables that
130:09 - we're using here
130:11 - we need to define them as input
130:13 - parameters so first name which is a
130:16 - string last name
130:18 - also a string
130:20 - email
130:22 - also a string
130:24 - and
130:24 - user tickets
130:26 - which is integer
130:29 - finally or it's actually you int and
130:32 - finally remaining tickets
130:34 - which is also
130:36 - you int and if i save
130:39 - all these errors are gone
130:41 - and we're going to call this function
130:43 - with all the input parameters we defined
130:46 - so we have the first name
130:49 - last name
130:52 - email
130:54 - user tickets and remaining tickets
131:00 - like this
131:04 - however now we don't have these three
131:06 - variables
131:07 - available in the main function anymore
131:09 - that's why we have these errors here
131:11 - because it doesn't recognize these
131:13 - variables and we have errors here as
131:16 - well so we need those three values
131:18 - actually available
131:20 - in the main function so we need to
131:22 - return all three values back to the main
131:25 - function
131:26 - well in most programming languages
131:28 - you cannot do that you cannot return
131:31 - multiple values from a function you can
131:33 - always return just one value
131:35 - but in go
131:37 - you can return any number of values you
131:40 - want from a function
131:41 - which i think is pretty cool because
131:43 - there are many use cases for this
131:46 - and it works the same way as returning
131:48 - just one value we just say return
131:52 - and we just list
131:54 - any values or variables that we want to
131:57 - return
132:01 - like this
132:02 - and of course
132:04 - the same way as with one return value we
132:06 - have to define
132:07 - the types the data types of all the
132:10 - return values in order
132:12 - which
132:13 - we do outside those parentheses
132:16 - and when we have multiple returns we
132:18 - have to also enclose them in its own
132:21 - separate parentheses so within this
132:23 - block we're going to define
132:25 - the data types of these three values
132:27 - which are all boolean
132:29 - true or false values so this is going to
132:31 - be boolean 1 boolean 2 volume 3.
132:36 - so again
132:37 - input values in the first parenthesis
132:41 - input parameters
132:42 - and then in the second one a list of
132:45 - output parameter types and now that
132:48 - we're returning these three values it's
132:50 - time to grab them or collect them
132:53 - outside here
132:54 - and that is also pretty easy we can just
132:57 - list them one by one like ease valid
133:00 - name
133:02 - is valid email
133:04 - is valid
133:06 - ticket number
133:10 - save and there you go now all these
133:12 - three
133:13 - variables are available in the main
133:16 - function so
133:18 - the errors are gone so let's check our
133:20 - code we have these three functions that
133:22 - we created and our main function got
133:25 - smaller and maybe more descriptive now
133:28 - let's also extract the code for getting
133:31 - user input in a function so i'm going to
133:33 - grab this whole code tool here
133:40 - and save it into
133:43 - a separate function and let's call this
133:46 - get user input
133:52 - fix the indentation and as you see get
133:55 - user input function doesn't need any
133:57 - input parameters because we're asking
133:59 - for input from the users so we don't
134:01 - need anything from the main function
134:03 - however
134:04 - inside the main function we need those
134:07 - values because we're doing all the
134:09 - processing based on whatever user
134:12 - entered right so we have to actually
134:13 - return all these input
134:16 - data
134:17 - back to the main
134:18 - so
134:19 - return first name
134:24 - last name
134:28 - email and
134:31 - use the tickets
134:32 - and again we have to
134:34 - specify the types
134:37 - of those right here
134:39 - so first name last name email and
134:42 - user tickets
134:45 - and in the main
134:47 - just like we did right here
134:53 - we're gonna grab those values one by one
134:56 - so we have the first name
135:00 - last name email and user tickets
135:04 - and if i save this
135:06 - you see
135:07 - all the errors are gone because now we
135:09 - have these four values available here as
135:12 - well
135:12 - and finally let's take the code for
135:16 - booking the application
135:18 - actually this whole logic here
135:21 - and also put it in its own function
135:24 - and
135:27 - logically we're going to call this
135:28 - function
135:30 - book
135:31 - ticket
135:36 - and if i save
135:37 - you see a bunch of errors because we
135:39 - don't have these values available here
135:42 - so we need a lot of input parameters
135:45 - for this function
135:46 - so let's define them one by one
135:49 - remaining tickets
135:54 - user tickets
135:58 - bookings which is a slice of strings
136:01 - we have the first name
136:05 - last name
136:08 - email
136:11 - and finally
136:12 - we also need the conference name
136:15 - which is also
136:16 - string and if i save
136:19 - it all looks fine
136:21 - when we call this function in the main
136:23 - so this is where book ticket happens
136:26 - we're going to pass all those
136:29 - defined parameters
136:30 - which is a long list of
136:33 - values
136:37 - now here you may be wondering if i have
136:39 - to pass so many parameters to my
136:41 - function does it make my code cleaner
136:44 - that's a lot of repeated code because
136:45 - we're passing all these
136:48 - same values
136:49 - and parameters to different functions so
136:52 - to reduce this repetition a bit we can
136:54 - define variables that are shared among
136:58 - multiple functions so variables that are
137:00 - accessible both for main and
137:03 - other functions as well without having
137:06 - to pass them around like this so it
137:08 - makes sense to create those variables in
137:11 - a place that lets multiple functions
137:13 - including the main have access to them
137:16 - and these are called package level
137:18 - variables and these are variables
137:20 - defined outside from all the functions
137:23 - so instead of defining these variables
137:25 - inside of the main we're going to take
137:27 - them and instead define them outside
137:31 - on a package level
137:33 - like this
137:34 - and now they're not only
137:37 - accessible to main but also to all the
137:40 - functions in this package
137:42 - now if i save this you see we have two
137:45 - errors
137:46 - and that is because the package level
137:48 - variables cannot be created using this
137:50 - syntax
137:51 - they need the
137:53 - syntax with var keyword
137:56 - so if i save this you see the error is
137:58 - gone we'll do the same here
138:02 - and that's it we can also take the
138:05 - put the constant
138:07 - at the top like this
138:09 - so now as i said we don't have to pass
138:11 - those variables to other functions from
138:13 - main because
138:15 - these functions also have access to them
138:17 - directly so in the grid users function
138:19 - for example we were
138:22 - passing
138:23 - three of these variables as parameters
138:25 - now we don't need this anymore
138:27 - because
138:28 - grid users
138:30 - can access those
138:31 - variables directly so i'm going to
138:33 - delete this
138:34 - and save and we have an error because
138:37 - now the names of the variables have to
138:39 - be exactly
138:40 - what is defined here right so conference
138:42 - name
138:44 - like this
138:46 - conference
138:48 - tickets
138:49 - and that's it we have no errors and no
138:52 - need to pass those values
138:55 - as input parameters
138:57 - again makes the function execution much
138:59 - cleaner
139:01 - we also have the bookings array which is
139:04 - defined on a package level so we don't
139:06 - need to
139:07 - pass that here as well
139:10 - so i'm going to remove this
139:12 - from get first names
139:14 - and
139:18 - remove these here as well
139:22 - again everything
139:24 - works
139:25 - same thing right here validate user
139:27 - input
139:29 - we're passing it remaining tickets as a
139:32 - variable which it doesn't need anymore
139:34 - but it still needs those four variables
139:37 - obviously because they are still created
139:39 - in the main function
139:40 - and not available directly outside
139:45 - so let's go to
139:46 - validate user input
139:48 - and remove
139:49 - this
139:50 - last
139:53 - parameter and finally our
139:56 - book ticket function that has this long
139:59 - list of
140:00 - parameters we can get rid of remaining
140:03 - tickets
140:06 - bookings and conference name as
140:08 - parameters because they are all defined
140:11 - here
140:15 - so remove this one
140:22 - and if i save everything looks fine
140:24 - again
140:27 - now you may be thinking why not define
140:30 - all the variables at the top right here
140:32 - and then make them accessible everywhere
140:35 - in our functions well this would be a
140:37 - bad practice because generally you want
140:40 - to define a variable as locally as
140:42 - possible so basically create a variable
140:46 - where you need it so if you need a
140:47 - variable only inside a specific function
140:50 - or a specific block inside the function
140:53 - then you should define it there
140:55 - so now if we look at our main function
140:58 - you see that the code is
141:01 - way cleaner
141:03 - we have descriptive function names that
141:05 - basically tells us what exactly is
141:07 - happening within the main function
141:09 - we're greeting the users then we're
141:11 - getting their inputs we're validating
141:13 - that input
141:15 - and if everything is valid we're booking
141:17 - the ticket then getting the first names
141:19 - and printing them
141:22 - and if the remaining tickets is zero we
141:25 - just end the program
141:27 - and all this logic that was basically
141:28 - crowding the main function is now
141:31 - encapsulated in its own
141:34 - small functions
141:36 - now let's actually test that everything
141:38 - still works fine
141:45 - and there you go
141:46 - we have
141:48 - the thank you message
141:50 - the ticket number got updated correctly
141:52 - and we have the first names of the
141:55 - bookings printed here so everything
141:57 - works same as before now in addition to
142:01 - just cleaning things up functions have
142:04 - another important purpose which is that
142:07 - same block of code can be reused in many
142:10 - different places in your application by
142:13 - calling the function name
142:14 - just like variables where we define
142:17 - something once and reuse it hundred
142:20 - times so for example if you were hosting
142:23 - 10 conferences at the same time and
142:25 - needed to ask for and validate user
142:28 - input you can reuse that code for all 10
142:31 - conferences instead of writing that same
142:33 - logic 10 times
142:38 - now we've been working in one single
142:40 - file this whole time so you're maybe
142:42 - asking
142:43 - what if i'm writing a more complex go
142:46 - application
142:47 - with a lot of logic so do i put all the
142:50 - stuff in one go file or how does it work
142:52 - can we create multiple go files that all
142:55 - belong to the same project well remember
142:57 - at the beginning i said that go is
142:59 - organized into packages and the package
143:02 - is a collection of go files which can be
143:05 - one file or several files and we already
143:08 - have one package that we called main
143:10 - which we created and we also have one go
143:14 - file for that package which we called
143:17 - main.go
143:18 - now if our code got larger we can split
143:21 - it into multiple files so for example if
143:24 - we had 10 different conferences for
143:26 - which users could book the tickets on
143:29 - our application
143:30 - we could create own files for each
143:33 - conference booking plus if we had
143:35 - multiple files where we defined bookings
143:38 - for different conferences we might have
143:41 - code that is shared by all these files
143:44 - so we may need the same functionality in
143:47 - all 10
143:48 - conference bookings for example we might
143:50 - need the same
143:52 - user input validation in all our files
143:55 - so we could have a separate file
143:58 - for such shared functionalities as well
144:01 - and all these files could belong to the
144:03 - same package
144:04 - so to demonstrate that i'm going to
144:06 - create a file here and let's call it
144:09 - helper.go
144:12 - or we can also call it common or
144:14 - shared.go and this can
144:17 - include functions that are helper
144:20 - functions of the main application
144:23 - again
144:24 - as an example we can take
144:26 - user input validation
144:28 - the first thing we need to define here
144:30 - is which package
144:32 - this go file belongs to and we have the
144:34 - main package that we created and we want
144:36 - this file to also belong to that
144:38 - main package so that's one thing we need
144:41 - to define in each file and then we
144:44 - basically just need to put some
144:46 - functionality here or list of functions
144:49 - that we can reference from other files
144:52 - again if i had 10 different files here
144:55 - that all share the functions right here
144:57 - we can basically define them here in
144:59 - helper go and then reference it from
145:01 - everywhere so i'm gonna grab validate
145:04 - user input function from here
145:10 - and i'm going to put it into a helper
145:12 - dot go file so we're basically splitting
145:16 - our code into multiple files
145:18 - of course we need to import the strings
145:21 - package here
145:22 - because we're using it
145:25 - and if i save this
145:26 - everything is
145:28 - error-free
145:29 - in helper.go as well as
145:32 - main.go so basically
145:34 - it is super easy to divide your code up
145:37 - into multiple files that all belong to
145:40 - the same package
145:42 - because we're referencing this validate
145:44 - user input in the main dot go file right
145:48 - here and it knows exactly that this
145:51 - function comes from the helper
145:54 - dot go file
145:56 - now we want to validate that everything
145:59 - works and run our application
146:01 - however if i run my application like
146:04 - this
146:05 - with go run main.go and execute you see
146:08 - that it says validate user input is not
146:11 - defined
146:12 - on line 21
146:15 - so right here
146:16 - so this function is not defined and that
146:19 - is because
146:20 - we need to now run the application
146:23 - with all the files that
146:25 - belong to that application so now we
146:27 - have main.go in helper dot go so we have
146:31 - to provide both files to go run command
146:35 - and now if i execute everything works
146:37 - again and
146:39 - let's add some invalid input here
146:44 - to make sure the validate user input
146:46 - also works
146:51 - and as you see we have the messages
146:54 - about wrong user input now of course if
146:57 - you have tens of files here in your
147:00 - application it's not very
147:02 - convenient to have to pass them
147:05 - one by one to go run command so as an
147:08 - alternative you can just specify a
147:11 - folder location from which you want to
147:14 - execute the files so all the files in
147:17 - this folder will be executed and dot
147:20 - specifies the current folder
147:22 - which is the booking app
147:25 - so we're telling go to run
147:27 - application with all the files in the
147:29 - current folder and again it works fine
147:32 - so that's going to be a better
147:33 - alternative of course if you have
147:35 - multiple files in your go project
147:41 - so now we have this helper.go file that
147:44 - belongs to the same main package
147:46 - however we could actually organize our
147:49 - application code into multiple packages
147:52 - so in addition to the main package we
147:54 - can have other packages that all belong
147:56 - to the application
147:58 - so what could be a use case for that
148:00 - let's say we have an application that
148:03 - handles booking for
148:05 - 10 different conferences and the booking
148:07 - logic for each conference is
148:10 - almost completely different in that case
148:13 - we could actually create own packages
148:16 - for each of the conference and put the
148:18 - booking logic there and plus let's say
148:21 - they share some common logic like
148:24 - validating user input and that could
148:27 - also be a separate package that all
148:30 - other packages may share so basically
148:33 - these multiple packages helps you
148:35 - organize your code and group the logic
148:38 - in a way that makes sense for your
148:39 - application so this is a way to
148:41 - logically group your code so let's say
148:44 - in our example we wanted to put this
148:47 - helper functionality in its own package
148:51 - and let's call this package also helper
148:55 - when we have multiple packages we should
148:58 - actually create
148:59 - folders for them and then put all the
149:01 - files belonging to that package in that
149:03 - folder so i'm going to create a folder
149:05 - called helper
149:07 - and put the helper.go file
149:10 - in that folder again this helps organize
149:14 - our code
149:15 - and basically visually represent the
149:18 - separation as well now of course we need
149:20 - to make a couple of adjustments
149:22 - for our application to work again
149:25 - the first thing is if we go to the main
149:28 - dot go file
149:30 - right here where the function is being
149:32 - called you see that it says undeclared
149:35 - names because go doesn't know this
149:37 - function anymore it doesn't know where
149:39 - it's coming from and that's why it says
149:41 - undeclared name so while this function
149:44 - was in the same package go was able to
149:46 - find it without a problem but now that
149:48 - we've moved it to another package it is
149:51 - not
149:52 - recognized anymore in the main package
149:55 - and remember at the very beginning i
149:57 - said that whenever we need to use a
150:00 - function from another package in our
150:04 - main package we need to explicitly
150:07 - import that package and then we will be
150:10 - able to use any functions inside that
150:13 - and that applies to the packages that we
150:17 - create ourselves so the first step will
150:19 - be to actually import
150:22 - the helper package in our main package
150:24 - if we want to use any functions defined
150:27 - inside
150:29 - right here now the question here is can
150:32 - we just import it using its name like
150:35 - this helper well just writing the helper
150:38 - the name of the package is not gonna
150:40 - work because go will try to look for a
150:43 - helper package in one of its built-in
150:47 - modules
150:48 - but this is actually our own package so
150:50 - we have to explicitly tell go hey this
150:53 - is actually
150:54 - a package in
150:56 - our application or in our module so
150:59 - remember this go.mod file that we
151:01 - initiated at the beginning
151:03 - this
151:04 - mod file or module file actually defines
151:07 - the name of the module which we called
151:09 - booking dash app which is also
151:13 - an import path for all the packages
151:16 - defined in this module so if we want to
151:19 - import a helper package inside the main
151:23 - package we have to use
151:25 - the booking app the module name before
151:28 - as a path
151:30 - so now we are telling go
151:32 - import the helper package
151:34 - from our booking app module
151:37 - and if we hover you see that it was able
151:40 - to find that package now we just get an
151:43 - error because we're not using it so how
151:45 - do we use a function from another
151:47 - package
151:49 - simply using the package name
151:51 - dot function name just like we've been
151:53 - doing this whole time
151:54 - so helper dot and then name of the
151:58 - function now there is one more thing we
152:00 - need to do for this to work
152:02 - and right now you see that we have an
152:05 - error that says
152:07 - validate user input or the name of the
152:09 - function is not exported by package so
152:12 - what does this mean
152:14 - whenever we want
152:15 - to create a function
152:18 - in a package
152:19 - that can be used in another package we
152:23 - have to
152:24 - explicitly export that function so it
152:27 - can be imported in another package
152:30 - so exporting basically means we want to
152:33 - make this function available for use in
152:35 - other
152:36 - packages and many programming languages
152:39 - have this concept of exporting functions
152:42 - to make it available
152:43 - for use in other places and they all do
152:46 - it in different ways
152:47 - in go
152:48 - the way to export a function is actually
152:51 - pretty easy
152:52 - we just
152:53 - capitalize the name of that function
152:56 - like this and that's it
152:58 - this simple change in the background
153:01 - will actually
153:02 - export the validate user input function
153:05 - so let's save it
153:07 - go back to
153:09 - main
153:10 - and adjust the function name here
153:13 - and you see
153:15 - the error is gone and now
153:18 - we are able to use that function from
153:20 - another package in our main application
153:24 - and you probably also noticed before
153:26 - that whenever we were using a function
153:29 - from an imported package like fmt or
153:33 - strings or whatever
153:35 - we were using that function name with
153:38 - capital letter right so all the fmt
153:40 - package functions start with capital
153:43 - letter we have printf with capital p
153:45 - print ln
153:47 - here we have strings.fields with capital
153:49 - f so that is the same concept right here
153:53 - these are
153:55 - functions that have been exported in
153:57 - these packages and that's why we're able
154:00 - to use them
154:03 - and by the way you can not only export
154:06 - functions from other packages but you
154:08 - can also export
154:10 - variables
154:11 - also by capitalizing
154:14 - the variable name so for example if all
154:16 - the conferences had the same
154:19 - number of tickets available you could
154:21 - define that in this helper package as a
154:24 - variable
154:25 - and then export it simply by using a
154:27 - capitalized variable name and finally we
154:31 - have an error here because remaining
154:33 - tickets
154:34 - variable is not available anymore
154:37 - for this function and that's again
154:40 - because we move this function from a
154:42 - main package and main package
154:44 - right here defines a package level
154:47 - variable called remaining tickets which
154:49 - is only available within the package
154:52 - main that's why it's called package
154:54 - level so it's not visible to other
154:57 - packages again
154:59 - as i said we could export this variable
155:02 - using uppercase in the name but in our
155:04 - case we will just pass the variable as
155:07 - an input parameter so let's do that
155:09 - validate user input
155:12 - and of course we have to also edit in
155:15 - the function specification
155:17 - and remaining tickets is of you int type
155:21 - and
155:22 - that fixes last issue and our
155:25 - application should work again
155:30 - so if i execute the application
155:33 - everything works fine again
155:37 - and one more thing that i want to note
155:39 - here is all the places we have created
155:42 - variables
155:43 - first of all we have created variables
155:46 - within individual functions which made
155:49 - these variables available only within
155:51 - those functions so these are basically
155:53 - what's called local or function level
155:56 - variables
155:58 - we also created variables that were
156:00 - available only within a specific block
156:03 - of code like right here
156:05 - so this names variable it only exists
156:07 - within this for loop
156:09 - so outside that even within the function
156:12 - the variable names does not exist
156:14 - so you couldn't use it outside that for
156:16 - loop it's undeclared
156:21 - then we saw how to define variables on a
156:24 - package level so that multiple functions
156:26 - can access it directly
156:29 - so we define them right here and finally
156:32 - i mentioned that if we have
156:35 - variables that we want to share across
156:37 - packages
156:38 - then we could create what's called
156:40 - global variable
156:42 - using a capitalized variable name and
156:45 - the concept of
156:46 - where we create variables and where we
156:49 - can use them is called
156:51 - variable scope
156:53 - okay so we have split our application
156:55 - into multiple packages and as i said
156:58 - with multiple packages you can organize
157:00 - your code more logically
157:02 - now for the simplicity
157:04 - we're going to revert our example back
157:06 - to
157:07 - helper.go being in a main package and
157:11 - continue with the rest of the demo
157:13 - examples
157:14 - from that state
157:19 - great now we have organized our code a
157:21 - bit we have cleaned it up with functions
157:24 - we have divided our code into multiple
157:26 - files and so on but there is one thing
157:29 - we want to optimize in our application
157:32 - right now whenever user completes a
157:35 - booking we're saving only their full
157:38 - name in the bookings list
157:41 - but the email address and the number of
157:42 - tickets they provided during the booking
157:46 - just get ignored and thrown away we're
157:48 - not saving them but we would like to
157:51 - have that information also saved for
157:54 - each user on the list of bookings maybe
157:56 - to send them information via email in
157:59 - the future
158:00 - or during the event to kind of validate
158:03 - how many tickets they have booked
158:05 - now bookings in our case is a slice
158:09 - which allows us to save a list of
158:12 - string values which are the full names
158:15 - but instead of just a simple string
158:18 - like this
158:20 - we want a data type
158:23 - with multiple key value pairs
158:26 - per user so something like first name
158:29 - [Music]
158:34 - and its value last name and its value
158:38 - email
158:42 - and
158:45 - number of tickets
158:47 - so instead of a list of
158:50 - these type of values we want at least of
158:52 - this kind of data block for each user
158:57 - and the data type
158:58 - that will allow storing multiple key
159:01 - value pairs per user
159:04 - is called a map
159:06 - so
159:07 - a construct a data type that basically
159:10 - lets us save information about user like
159:13 - this
159:14 - is provided by map and map is a common
159:17 - data type
159:18 - in many other programming languages as
159:20 - well
159:21 - so for each user we will have a map
159:24 - with
159:26 - key names like this and their respective
159:28 - values
159:29 - which of course will be different for
159:31 - each user
159:32 - so let's see how we can
159:36 - turn our bookings list
159:39 - from a list of
159:41 - strings to a list of
159:44 - maps
159:45 - first of all let's go to the book ticket
159:48 - function where we're adding users first
159:51 - name and last name to the bookings list
159:55 - and right before that we're going to
159:56 - create
159:58 - a map
159:59 - for
160:00 - a user
160:01 - and as i said map is a data type so just
160:04 - like with any other data type we need to
160:06 - create a variable of an empty map
160:10 - and we're going to call this
160:13 - let's say a user
160:14 - or user data
160:18 - now how do we create a map first of all
160:21 - we have a keyword map
160:23 - and then we have to define
160:24 - types
160:26 - for
160:27 - the key
160:29 - and a value
160:31 - as i said map is a collection of key
160:33 - value pairs
160:35 - and for each one so for the
160:38 - for the keys which are first name last
160:40 - name email etc we have to define what
160:42 - data type they are and we also have to
160:45 - define the data types of the values
160:49 - and of course these two can be different
160:52 - the keys in the map may be strings and
160:54 - the values may be integers
160:56 - but in our case we have
160:58 - strings for both of them
161:00 - however this only defines the type of
161:03 - the map right just like we have a type
161:07 - of
161:08 - a slice
161:10 - right so this is
161:15 - this is a type of a slice we have a type
161:19 - for a map
161:24 - which is
161:27 - this one right here
161:29 - so this is
161:30 - only a type what we actually need to do
161:32 - is create an empty map
161:35 - and we see that in the error as well it
161:37 - says
161:38 - type definition is not an expression so
161:41 - we need an expression which is creating
161:43 - an empty map
161:46 - and to create an empty map we have a
161:48 - built-in function called make
161:53 - if i save
161:54 - now i only get an error that user data
161:57 - is defined but not used so that will
161:59 - give us an empty map
162:02 - so map creation is done as a next step
162:04 - we want to add all the user data we have
162:08 - available to this user data map how do
162:11 - we add
162:12 - data key value pairs to a map very
162:16 - simple actually
162:18 - we have
162:19 - name of the map and the square brackets
162:22 - syntax that you already know from arrays
162:25 - and slices
162:26 - and inside that we have the key name
162:28 - which is first name
162:30 - and the value to that which is
162:33 - the value of the first name variable
162:35 - so that's the first key value pair that
162:38 - we're saving into user data map
162:42 - let's save
162:44 - another key value pair which is last
162:46 - name and again
162:48 - value will be
162:49 - a last name variable which
162:52 - we get from the user input
162:59 - and we have the email
163:02 - which also comes from
163:04 - variable called email
163:06 - so now we have added three key value
163:09 - pairs to user data map so the key names
163:13 - are strings as we defined here and the
163:15 - values are also strings as we defined
163:18 - here and note that you can call these
163:20 - key names whatever you want so this
163:21 - could be a b c
163:23 - it doesn't really matter right but of
163:26 - course you want to have some descriptive
163:28 - names which tells you what this key
163:31 - actually refers to okay now the fourth
163:35 - data we have is
163:36 - number of tickets but the user tickets
163:39 - value is a uint it's not a string
163:42 - right so the value type
163:45 - is not a string and in go specifically
163:48 - as we saw here map can only have the
163:51 - same data type as keys and the same data
163:54 - type for values so we cannot
163:57 - mix different data types as values
164:01 - again specific to go because in many
164:03 - programming languages you can actually
164:05 - have mixed data types in a map
164:08 - just like in a slice where we also have
164:12 - to have just one data type which is
164:14 - again specific for go because in many
164:17 - other programming languages you can
164:19 - actually have
164:20 - mixed data types
164:22 - so what do we do here how do we add the
164:24 - user tickets value
164:27 - in our user data map well an easy way to
164:30 - handle this
164:31 - is to convert
164:34 - the user ticket's view integer to a
164:37 - number character
164:38 - so basically
164:40 - if
164:41 - user bought 30 tickets instead of 30
164:44 - like this we're gonna have three zero as
164:47 - characters
164:48 - and that will make it a string
164:50 - and this type of conversion there is a
164:52 - built-in function in go called format
164:56 - uiint
165:00 - and this function comes from
165:03 - a package called string
165:05 - convert or
165:07 - scr conf
165:09 - stands for string conversion
165:11 - and this package basically includes
165:14 - different functions for converting
165:16 - strings to and from other data types and
165:19 - one of them is converting uint to string
165:23 - so of course we need to pass in our
165:25 - uiint value
165:27 - so that it can be converted to a string
165:29 - and we do that by
165:32 - using another built-in function called
165:35 - uint64 which is
165:40 - for
165:41 - a uint 64 data type
165:44 - so that's the value we're converting to
165:45 - a string
165:46 - like this and then we have
165:49 - to pass another input parameter here
165:52 - which stands for
165:53 - decimal number
165:55 - base 10. so
165:57 - now you don't need to understand every
165:59 - part of this
166:00 - conversion but shortly explained format
166:03 - unit function takes our u int value
166:08 - which may be
166:09 - anything 1 to 50
166:11 - and formats it to a string as a decimal
166:15 - number and 10 is for base 10 which
166:19 - represents decimal numbers so another
166:22 - example would be
166:23 - 16 for example that represents
166:25 - hexadecimal numbers so that's what's
166:28 - going on here
166:29 - again no need to go into details here
166:31 - because usually if you need these type
166:33 - of conversions in your code you would
166:36 - either check out the official
166:38 - documentation of go or you will just
166:40 - google it and see the example code for
166:42 - that so you don't have to memorize this
166:44 - kind of conversions
166:46 - so as a result this will actually give
166:48 - us
166:49 - our user tickets in string format and we
166:53 - can then save it
166:56 - into our map
166:59 - and this is going to be
167:02 - a key name for that which we can
167:04 - name whatever we want i'm going to call
167:06 - it number of
167:09 - tickets
167:10 - and that is going to equal
167:12 - to this and of course we shouldn't
167:15 - forget to import the string conversion
167:18 - package
167:21 - like this
167:22 - and
167:23 - everything looks fine cool so now we are
167:26 - creating a map
167:28 - for each user
167:29 - because this book ticket function gets
167:31 - executed every time a new user books a
167:34 - ticket so the map is getting created and
167:37 - all the user data gets saved into that
167:40 - map so now we need to actually take that
167:43 - map
167:44 - with all the user data and add it to the
167:47 - bookings list
167:48 - right now we have
167:50 - a slice of strings
167:52 - as bookings
167:53 - so first we need to make bookings
167:56 - variable into a slice of maps
167:58 - so what i'm going to do is i'm going to
168:00 - copy
168:01 - the type of this map
168:07 - and right here
168:08 - instead of the string type i'm going to
168:11 - set
168:12 - a map type so we're having a list of
168:16 - maps and not anymore a list of strings
168:19 - now this curly braces was
168:22 - used to create
168:23 - an empty list
168:25 - of strings however it doesn't work
168:27 - anymore for maps so we need to actually
168:29 - create
168:30 - an empty
168:32 - slice of maps
168:34 - and the syntax for that is
168:36 - at the beginning
168:38 - again the make function that we use to
168:41 - create a map
168:44 - like this
168:46 - note the comparison between the two make
168:49 - calls so here
168:51 - when we created a map we have a type of
168:54 - the map and we wrap it into make
168:56 - function and that creates an empty map
168:59 - here we're not creating an empty map
169:01 - we're creating an empty list of maps
169:04 - that's why now we have the
169:07 - brackets
169:08 - before the map
169:09 - and
169:10 - when i save this we're going to have an
169:13 - error because
169:14 - this time because it's a list we need to
169:17 - actually define
169:18 - a size or initial size of this empty
169:22 - list and because slices are dynamic this
169:26 - is going to be the initial size and it
169:28 - will expand automatically as we add new
169:31 - values which means the size the initial
169:33 - size can be 1 or even 0
169:36 - because it will increase anyways when we
169:38 - add new elements so with this syntax
169:42 - we're initializing
169:44 - a list of
169:45 - maps
169:46 - and finally as the last step
169:51 - going back
169:52 - to our book ticket logic we of course
169:56 - want to add
169:58 - instead of adding first name plus last
170:00 - name in our bookings list
170:03 - we want to add user data map
170:07 - and save
170:09 - there you go
170:10 - so append stays the same because it's a
170:12 - slice again but instead of a string
170:15 - we're adding now a map to our list
170:18 - so now we have
170:20 - a bookings list which contains all user
170:23 - information as key value pairs
170:26 - we still have an error in our
170:28 - application which is right here where
170:31 - we are going through the bookings list
170:33 - and grabbing the first names from each
170:36 - element
170:37 - which is logical because
170:39 - in this code we are treating
170:41 - the element of the bookings list as a
170:45 - string and not a map
170:47 - which obviously has changed so we have
170:49 - to change the logic here as well so now
170:52 - each booking
170:53 - elements or the value of this booking
170:56 - variable
170:57 - is a map with the key value pairs for
171:00 - first name last name email and number of
171:02 - tickets so it's actually now easier to
171:05 - extract the first name from the map by
171:08 - simply
171:10 - using the key name which we called first
171:12 - name
171:13 - and that's it so this will give us a
171:15 - value of the first name we don't have to
171:17 - split a string or do anything here and
171:20 - we can also use that directly right here
171:24 - and save and that's it so again in our
171:27 - bookings list
171:28 - we have maps for each user with
171:31 - different data one of them being first
171:33 - name so
171:34 - we can grab the first name value from
171:37 - each
171:38 - map using this syntax and then edit to
171:41 - the first name slice so that fixes the
171:43 - issue and finally as a great feature of
171:46 - go we're reminded that we're no longer
171:49 - using the strings package
171:51 - so we should get rid of it
171:54 - and no more errors in our application so
171:57 - now we can
171:59 - run our application to make sure
172:01 - everything works
172:02 - perfectly plus to also check
172:05 - our changes
172:06 - that we store
172:08 - the complete user data in the bookings
172:10 - let's also print out
172:12 - the bookings list of maps after every
172:16 - booking let's see
172:19 - list of bookings
172:22 - is
172:28 - i forgot the new line
172:40 - and there you go so after the booking we
172:44 - have a list of bookings which is
172:47 - a slice
172:48 - you see with the brackets and inside
172:50 - that we have one map because we just
172:52 - have one booking and this map contains
172:55 - basically these key value pairs for
172:57 - email first name last name and number of
172:59 - tickets divided separated by columns and
173:03 - let's try another one
173:11 - and now our list of bookings has
173:14 - two maps like this and the printing of
173:17 - first names also works fine
173:22 - now let's say we wanted to collect
173:25 - different types of data on users for
173:28 - example we asked for their date of birth
173:31 - which is a date value type or we asked a
173:34 - user to opt in for a newsletter and we
173:37 - would save that information as a boolean
173:40 - data type like is opted in for
173:42 - newsletter we may even want to save
173:45 - lists associated with users like let's
173:48 - say a manager books tickets for her team
173:51 - and we would like to know names of these
173:54 - team members to know who will attend the
173:56 - conference so for this user we can save
173:59 - a list of team members they will bring
174:02 - with them and this would be an array or
174:04 - slice of attendance names if we wanted
174:08 - the team members email addresses in
174:10 - addition then this would even be a slice
174:12 - of
174:13 - maps where each map will hold the name
174:16 - of the attendant and their email address
174:19 - so user entity would have all these data
174:22 - of different data types associated to it
174:25 - we may also have other entities in our
174:27 - application like a conference which will
174:30 - have its own data associated to it like
174:33 - in which cities the conference is held
174:36 - on which dates it is hosted how many
174:39 - people are attending etc again values of
174:42 - mixed data types and as we saw in the
174:45 - previous example maps in go limit
174:49 - values to only one data type that's why
174:51 - we had to do this type conversion to
174:54 - save number of tickets for a user as a
174:58 - string instead of uiint so how can we
175:01 - save mixed data type values for an
175:04 - entity
175:05 - like a user or conference in our go
175:08 - application
175:09 - well for that we can use what's called a
175:12 - struct
175:13 - in go which stands for structure structs
175:16 - or structures let us define key value
175:19 - pairs for an entity like user but with
175:22 - mixed data types so let's see how we can
175:25 - create a struct so right here outside
175:28 - all the functions on the package level
175:30 - we're going to create a struct first of
175:32 - all we have a keyword struct
175:35 - and it's block
175:37 - with curly braces
175:38 - and within the block we define the list
175:41 - of keys
175:43 - like first name
175:45 - last name
175:47 - email
175:48 - and
175:49 - number of tickets
175:51 - like this
175:52 - note that we're not using quotes here
175:55 - and for each key in the struct we also
175:57 - have to define
175:58 - the type of the value right so instead
176:01 - of having one type for all the values we
176:04 - can choose
176:05 - different type for each value so the
176:07 - first name will be a string the last
176:10 - name will be a string email will be a
176:12 - string and number of tickets will be you
176:14 - int
176:15 - again if we had other data types like a
176:18 - boolean for
176:19 - is user opted in
176:22 - for
176:23 - news
176:24 - letter
176:26 - we can basically add them right so we
176:28 - can have mixed data types for the values
176:32 - but our struct is not done yet first we
176:34 - need a name for our struct
176:36 - which in our case
176:38 - can be a user data for example and
176:42 - finally
176:43 - at the beginning we have to
176:46 - create a struct using type keyword like
176:49 - this
176:50 - this actually means that we're creating
176:52 - a custom type in our application which
176:56 - is called user data
176:58 - another very important advantage of
177:01 - structures over maps is that in addition
177:03 - to
177:04 - just being able to specify these mixed
177:07 - data types
177:08 - the structure gives us this custom type
177:11 - like user where we can define exactly
177:14 - what user
177:16 - type should look like so what properties
177:18 - it should have and with map we just have
177:21 - an empty list where we can just put
177:23 - whatever we want so structure allows you
177:26 - to create a predefined
177:28 - structure
177:29 - by listing all the properties that it
177:31 - should have so here we are defining the
177:34 - structure of our user type and that a
177:36 - user
177:37 - has first name last name email and
177:40 - number of tickets
177:41 - and if you know object oriented
177:43 - languages like java struct can be
177:46 - compared to classes in those languages
177:48 - so we're creating a custom data type
177:51 - called user data with these properties
177:54 - associated to it great so now let's go
177:57 - ahead and use our user data structure
178:00 - instead of the map so first of all we're
178:03 - going to change
178:04 - our bookings from a list of
178:07 - maps to a list of user data structures
178:12 - so we're going to grab the map type and
178:14 - we're going to replace it with user data
178:18 - struct type like this
178:20 - nicer syntax
178:22 - everything else stays the same so this
178:24 - line basically now creates or initiates
178:27 - an empty list of user data structs
178:31 - now of course
178:32 - we also have to create the user data
178:35 - struct instead of the map in the book
178:37 - ticket function
178:39 - so let's scroll down to here and the
178:41 - user data instead of creating a map here
178:44 - we're
178:45 - going to create
178:46 - a struct
178:48 - like this the name of the struct
178:51 - and curly braces
178:53 - and inside that we are going to set the
178:56 - values
178:57 - for each property or each field name so
179:00 - first name is going to be the name from
179:03 - the first name variable in this case
179:05 - they're called the same but of course
179:07 - could be different values
179:08 - then we have the last name
179:11 - field of our struct
179:15 - and the value will be from the last name
179:17 - variable
179:18 - email
179:20 - same here
179:22 - and
179:23 - the key name for user tickets
179:26 - like this and the value called user
179:29 - tickets
179:31 - and when setting these values we have to
179:32 - separate each line using a comma so at
179:35 - the end of each
179:37 - line
179:38 - so this will give us a user data object
179:41 - with all the user data so we don't
179:44 - actually need any conversion from
179:46 - you in type to string as well as we
179:49 - don't need these
179:51 - lines here so let's get rid of it and
179:54 - again our code looks a little bit more
179:56 - cleaner
179:57 - and a reminder from go
180:00 - that we don't need the string conversion
180:03 - package anymore so let's
180:05 - remove that as well and finally as the
180:08 - last fix because we still have one issue
180:14 - which is right here getting the first
180:16 - names because now we are accessing the
180:18 - first name
180:20 - with a syntax for map
180:22 - but a booking
180:24 - variable is not a map anymore it's a
180:27 - struct and to get values from struct
180:31 - basically we use a syntax with dot and
180:34 - as i mentioned a big difference of
180:37 - structures of our maps is that it gives
180:39 - you a predefined structure so now when i
180:42 - type dot after
180:44 - a struct element
180:47 - go actually gives me suggestions
180:49 - property names that destruct has and i
180:52 - can just choose one like this but also
180:55 - if i actually misspell a name of the
180:58 - property of a struct go can help me
181:00 - identify this error even before running
181:03 - the application
181:04 - and this is because we have created a
181:06 - real type with a structure in which the
181:09 - go compiler knows the associated
181:12 - properties so as you see when working
181:14 - with structs the syntax is simpler than
181:18 - with maps so our code looks cleaner
181:22 - and less messy awesome so that's
181:24 - basically the final result of our code
181:27 - we're also using just one package here
181:29 - so we can
181:32 - remove the parentheses here and again we
181:35 - can
181:36 - test
181:37 - our application
181:44 - and in the output you see
181:46 - the line where we're printing the list
181:49 - of bookings which is now a list of
181:52 - structs this is how it looks like so we
181:55 - have a slice with square brackets and
181:57 - inside that we have
181:59 - one element
182:00 - which is a struct with a nice
182:04 - short output and again if we add another
182:07 - user booking
182:09 - like this you see one struct
182:12 - and another one
182:17 - now let's say after user books at ticket
182:20 - we want to generate
182:22 - that book ticket and send it to the user
182:24 - per email address that they entered
182:30 - so let's create a function called send
182:33 - ticket
182:35 - that generates a ticket
182:38 - and then sends it per email and we're
182:40 - just going to simulate this logic with a
182:42 - simple code and to simulate generating a
182:45 - ticket we're just going to put together
182:47 - a string that basically says this is a
182:49 - ticket for a certain user
182:54 - so let's use a printf so we're just
182:57 - printing it out
182:58 - and let's say this many
183:01 - tickets
183:02 - for
183:03 - first name
183:05 - last name
183:06 - of the user and let's
183:14 - add them here
183:15 - if i save this
183:16 - of course we need to
183:18 - pass those
183:19 - variables as input parameters right so
183:22 - we can use them in a function so i'm
183:24 - going to define them all here
183:27 - i'm actually just going to copy this
183:29 - and then just add
183:31 - types so we have
183:32 - uint
183:34 - string
183:36 - and another string
183:38 - like this
183:39 - now let's say instead of just printing
183:42 - out this
183:43 - string we wanted to save it into a
183:46 - variable called ticket that we would
183:48 - then send per email and that may be
183:51 - another useful example that you may need
183:54 - in your applications to basically
183:57 - save formatted strings in a variable
184:00 - instead of just printing them out now if
184:02 - i do variable ticket here and save it
184:06 - you see that
184:07 - i get an error because this doesn't give
184:09 - me the formatted string back it just
184:12 - prints it out to the console and it
184:14 - doesn't return string for that we
184:16 - actually have a different function from
184:18 - the format package which is called
184:21 - s print
184:23 - f and if i save this you see that now we
184:26 - just get an error because ticket is
184:28 - declared but not used so this function
184:31 - basically helps you put together a
184:33 - string just like in the formatted output
184:35 - here
184:36 - but instead of printing it out you can
184:38 - save it into a string variable so we
184:40 - have simulated the tick generation
184:43 - and now let's simulate sending it per
184:45 - email in this case we're just going to
184:47 - use a print statement
184:51 - which says
184:52 - sending
184:54 - ticket
185:00 - and this is the ticket
185:01 - to
185:02 - email address
185:05 - and that's an email address
185:08 - so we have the ticket
185:09 - so here we substitute the ticket itself
185:12 - so this string that we put here together
185:14 - and the email address
185:17 - and now we have to add email address
185:19 - also
185:20 - as
185:21 - input parameter
185:23 - so we can use it here and let's do a
185:25 - little bit more formatting so we can see
185:27 - the ticket part really well so i'm just
185:30 - going to do column here
185:33 - and let's print the ticket on a new line
185:36 - like this
185:38 - let's put a new line here as well
185:40 - and i'm also gonna add some visual
185:43 - divider for the ticket sending logic
185:46 - before sending the ticket
185:50 - and
185:51 - afterwards and that's just going to be
185:54 - simple visual divider something that
185:56 - we're just going to notice immediately
186:00 - like this
186:01 - println there you go so this basically
186:04 - just simulates with simple code a logic
186:08 - for generating a ticket and
186:11 - then sending it to email after user
186:14 - booked the ticket so i'm going to take
186:16 - the name of the function and we actually
186:18 - have to call this right so in the main
186:20 - function right after book ticket gets
186:22 - executed we're going to
186:25 - call send ticket and this expects
186:29 - the variables
186:30 - which are actually the same as here
186:33 - right so we have user tickets first name
186:35 - last name email
186:37 - just like we defined it here
186:40 - awesome so
186:43 - our application is ready let's now
186:44 - actually run our application
186:47 - and see that this output gets printed
186:50 - out
186:57 - and there you go so we have
186:59 - 45 tickets remaining which is in the
187:04 - book ticket function and then send
187:06 - ticket gets executed it starts right
187:08 - here and we are saying sending tickets
187:11 - this is the string we put together how
187:13 - many tickets the user bought and the
187:15 - username last name to email address
187:19 - they gave us awesome everything works
187:21 - fine now let's say
187:23 - that generating
187:25 - the ticket and then sending it per email
187:28 - actually takes some time it's not a fast
187:31 - process that we
187:32 - simulated here some data needs to be
187:35 - processed in the background so if we had
187:37 - a real code that really generates a pdf
187:41 - of a ticket and then sends it using an
187:43 - email client to an email address it
187:46 - would actually take some time right it
187:48 - would not be this fast so let's say it
187:50 - would take 10 seconds and we're also
187:53 - going to simulate this 10 second delay
187:56 - using a function called
187:59 - sleep
188:01 - from a time package
188:03 - and in a slip function we're going to
188:05 - say how long it needs to sleep so 10
188:08 - seconds
188:12 - again the second unit is in the time
188:15 - package and we of course have to
188:18 - import it
188:23 - time
188:25 - and there you go
188:27 - so now whenever this function gets
188:29 - called we're simulating that something
188:32 - happens here for 10 seconds so
188:35 - in this case it's just sleeping and
188:38 - after 10 seconds
188:39 - this code gets executed and we're going
188:42 - to get the summary so the sleep
188:44 - basically just stops the execution of
188:47 - the thread for 10 seconds that's what
188:50 - we're doing
188:51 - so now
188:52 - with this change
188:54 - let's run the application now and see
188:56 - what happens or see how
188:58 - application can handle this kind of time
189:02 - delay
189:04 - so i'm going to clean this up let's run
189:07 - input the data
189:14 - and as you see i didn't get an input
189:17 - enter your last name and if i type
189:19 - something here
189:21 - the application basically is blocked and
189:24 - now you see
189:25 - that after 10 seconds
189:27 - were over
189:28 - this got printed out and now application
189:31 - became responsive again and now it's
189:34 - asking me for
189:35 - inputs for another user right
189:38 - let's do that again
189:45 - and again you see
189:46 - it's stopped here
189:48 - and now whatever i input
189:51 - i don't get a feedback from the
189:52 - application i just have to wait until
189:55 - this here gets printed out or this gets
189:58 - completed
190:02 - so the application is being blocked
190:05 - while this code gets executed and once
190:08 - it's done
190:09 - then we can continue to another booking
190:11 - now if this was an application that
190:13 - should handle multiple bookings of
190:16 - multiple users then this would not be an
190:18 - optimal performance right and that's why
190:21 - we need concurrency in applications and
190:24 - as i mentioned at the beginning the main
190:26 - advantage of goal programming language
190:29 - is the simplicity of coding concurrent
190:32 - applications so we can make our
190:34 - application concurrent in a very easy
190:37 - way
190:38 - in go
190:39 - compared to other languages
190:41 - so what would concurrency mean in this
190:43 - case
190:44 - well our application runs in a single
190:47 - thread
190:48 - right when go starts executing this main
190:51 - function
190:52 - everything that you see here will be
190:54 - executed from start to finish in a
190:57 - single thread which means all code lines
191:00 - get executed one by one in this order in
191:03 - our single threaded application
191:05 - and that means if one of the lines
191:09 - like this one here
191:10 - takes longer
191:12 - the execution in this thread
191:15 - is blocked so the next line gets
191:17 - executed only after this one is done
191:20 - doing its job so this has to wait those
191:23 - 10 seconds
191:24 - until it gets executed but to optimize
191:27 - this instead of
191:29 - just waiting
191:30 - for a certain code line to finish when
191:34 - we know that something takes longer
191:37 - we want to start a separate thread for
191:39 - it and execute
191:41 - this logic in a separate thread so break
191:45 - out of the main thread
191:47 - and do this in its own separate thread
191:50 - so now instead of waiting for 10 seconds
191:52 - to run the next line after the function
191:55 - the application executes it gets to this
191:58 - point it spins off a new thread pushes
192:01 - the code execution there and it
192:04 - immediately continues to the next line
192:06 - so there's no waiting or blocking here
192:08 - very simple concept actually and that
192:10 - would mean in our application
192:12 - that while the ticket is being generated
192:14 - and sent to the user who just booked the
192:17 - ticket we can continue to the next
192:20 - booking for the next user without any
192:23 - interruption when the second user is
192:26 - also done
192:27 - booking her ticket
192:29 - then again the iteration will come here
192:32 - and again it will spin off a new thread
192:35 - to generate the second user's ticket and
192:38 - send it per email and so on so basically
192:41 - if 20 users book the ticket at the same
192:44 - time 20 new threads will be created each
192:47 - one will do its job and once completed
192:50 - the thread will be deleted and this
192:52 - whole time the main application flow
192:54 - will continue without any interruptions
192:57 - all right now that sounds all cool but
192:59 - how do we create those threads and make
193:02 - the code in this function so the
193:04 - centicade function
193:06 - run in that separate thread how do we do
193:08 - that
193:09 - well we just write go in front of it
193:12 - and that's it
193:14 - we just made our application concurrent
193:16 - with a simple go keyword and this
193:19 - keyword basically
193:21 - abstracts away the whole thread creation
193:23 - and cleanup and all these
193:25 - for you so you as a developer don't have
193:28 - to worry about this
193:30 - so now let's actually go and test it i'm
193:32 - going to save it
193:34 - clean up
193:35 - and
193:37 - input our data
193:43 - and now when i click enter
193:45 - i should be immediately
193:47 - prompted for another user's booking so
193:50 - enter and there you go it asks me again
193:53 - for enter your first name so let's
193:55 - continue
194:01 - and while i'm actually
194:03 - typing
194:05 - we see that at some point the ticket
194:07 - creation logic was completed and i see
194:09 - the output here so even though it
194:11 - printed out
194:13 - the text in the middle of my user input
194:15 - it doesn't actually interrupt the
194:17 - application flow so here i have
194:20 - dot com
194:21 - and then continue with user tickets
194:24 - and again i can go on to the next user
194:28 - booking
194:31 - and again at some point the second
194:34 - ticket is done and it gets printed here
194:37 - and the user would be able to basically
194:39 - continue their booking without problems
194:42 - so as you see everything works great and
194:44 - we have improved the performance of our
194:47 - application with a simple change in our
194:51 - code and this means now
194:52 - even if the ticket generation took five
194:55 - times longer or ten times longer the
194:58 - main application flow would be
195:00 - unaffected by that and the users will
195:02 - basically get their tickets per email a
195:05 - little later which is also not an issue
195:07 - and to demonstrate that i'm gonna
195:09 - actually put that timer to 50 seconds
195:13 - instead of 10
195:14 - and let's execute again
195:31 - so basically i have simulated booking
195:33 - for three different users the ticket for
195:36 - the first user is not done yet
195:38 - but we can keep booking new tickets
195:42 - and at some point
195:43 - after the 50 seconds are over you see
195:46 - the output for the first user and the
195:49 - second user
195:52 - and finally
195:53 - for
195:54 - the third user so our application stays
195:56 - responsive no matter how long this code
195:59 - actually takes to execute
196:05 - now let's see one more thing about
196:07 - concurrency in our applications
196:09 - let's say we did not have a for loop
196:12 - here that keeps on asking for the new
196:15 - booking which means once the booking is
196:17 - done the main application would exit
196:19 - there is no
196:20 - next iteration here so i'm going to
196:22 - remove this for loop
196:29 - and save it
196:34 - we don't need a break statement because
196:36 - there is no loop
196:37 - so basically our application only allows
196:39 - for one booking so let's run our
196:42 - application and see what happens with
196:45 - the booking logic
196:53 - so we entered our data
196:55 - the summary
196:57 - got printed out
196:58 - thank you message how many tickets are
197:00 - left and the first names
197:03 - but there is no
197:04 - ticket generation
197:06 - output here so
197:08 - all the code in here send ticket
197:11 - that prints out
197:12 - this three lines we don't see them in
197:15 - the output because they never got
197:17 - executed
197:20 - so the application exited before this
197:23 - function was done and this means that
197:26 - the main thread does not wait for any
197:29 - additional threads to complete or even
197:32 - start when the main thread is done the
197:35 - application is done as well so whatever
197:37 - is happening in the other threads are
197:39 - basically getting terminated and ignored
197:42 - so how can we fix this because obviously
197:44 - we want to send
197:46 - the user their ticket right well for
197:49 - that we need to tell the main thread
197:51 - that it needs to wait until this thread
197:55 - is done doing its job and for that first
197:58 - we need to create what's called a weight
198:00 - group so outside the main function right
198:02 - here we're going to create a weight
198:04 - group
198:06 - with curly braces
198:08 - and this comes from a sync package and
198:11 - we can then save the result into a
198:13 - variable called
198:15 - wg or weight group
198:17 - and
198:18 - of course we need to import the sync
198:21 - package
198:23 - and there you go
198:25 - and weight group
198:26 - has three functions which we can call
198:29 - using this variable so on wg right
198:32 - before we spin off
198:34 - a new thread
198:37 - we're going to call the first function
198:38 - which is called ed
198:40 - and this function adds a number of
198:42 - threads that the main thread should wait
198:45 - for and should be executed before
198:48 - creating a new thread and in our case we
198:51 - have one new thread that we are adding
198:53 - so
198:54 - we're gonna put one here so if you had
198:56 - another
198:57 - go
198:58 - do something else function here
199:01 - then you would put two
199:06 - another function that we have
199:08 - the second function of weight group is
199:11 - called weight
199:12 - and it needs to be executed at the end
199:15 - of
199:16 - the main thread so as a last line of the
199:18 - code we're going to do weight and this
199:21 - basically waits for all the threads that
199:24 - were added right here to be done doing
199:27 - its job before the application can exit
199:30 - so this just waits
199:34 - until this one is done
199:36 - and the third function
199:37 - is called done which gets executed in
199:41 - the function that runs in a separate
199:43 - thread so incenticate
199:46 - and at the end of the logic when
199:48 - everything is done we're going to call
199:51 - weight group
199:52 - done
199:53 - so
199:54 - done function removes the thread
200:00 - that we added right here from the
200:02 - waiting list
200:03 - it's basically saying to the weight
200:05 - group i'm done executing so the main
200:08 - thread doesn't have to wait for me
200:09 - anymore so the add function is
200:12 - increasing the counter
200:13 - of
200:14 - threads that the application should wait
200:16 - for and done is decreasing that counter
200:20 - so when the counter is zero which means
200:23 - the main thread has no threads to wait
200:26 - for it can exit the application so this
200:30 - doesn't have to wait anymore so now with
200:32 - these code changes
200:34 - let's run our application again and we
200:37 - should see the ticket being printed out
200:39 - before the application exits
200:49 - so the summary got already printed out
200:52 - now it's just waiting
200:54 - as you see it's not exiting it is
200:56 - basically waiting for those
200:58 - 50 seconds to be over and then
201:02 - we'll execute these lines of code and
201:04 - you see the output of sent ticket so
201:08 - this time the application actually
201:10 - waited for this separate thread to be
201:12 - done executing its logic and once this
201:15 - was printed out as you see the
201:17 - application exited now you may be
201:19 - thinking you can surely implement
201:21 - concurrency in other languages like java
201:24 - right which is true but in other
201:26 - languages that support concurrency we
201:29 - have two differences with go first of
201:32 - all
201:32 - writing code for concurrency
201:35 - in those languages is way more complex
201:38 - and you have more overhead for the
201:39 - initial configuration and second
201:42 - creating threads is more expensive which
201:45 - means it takes longer to spin off a new
201:47 - thread and it also needs more memory
201:49 - space allocated to it now what is the
201:52 - reason for these differences or what
201:53 - does go actually do better or more
201:56 - efficiently well in go when we create a
201:58 - thread go actually spins off what's
202:01 - called a green thread green thread in go
202:04 - is an abstraction of an actual thread
202:07 - which is an operating system thread and
202:09 - it's called a go routine so with gold
202:12 - keyword we're actually creating go
202:14 - routines so in go we are only
202:16 - interacting with these high level goal
202:18 - routines instead of the low-level
202:21 - operating system threats and an
202:23 - advantage of working with this threat
202:25 - abstraction is that first of all it's
202:28 - cheaper to create it's more lightweight
202:30 - and takes
202:31 - little memory space so each time you
202:34 - create a thread you actually have way
202:36 - less overhead
202:37 - and that means you can easily create and
202:40 - use thousands or tens of thousands of
202:42 - threads pretty fast which in other
202:45 - languages is normally not possible
202:47 - without affecting the application
202:50 - performance so in comparison other
202:52 - programming languages like java that i
202:54 - mentioned use operating system threads
202:57 - which again need more memory space more
203:00 - time to create and that's why in these
203:02 - languages sometimes we have concepts
203:04 - like thread pooling to optimize working
203:07 - with threats
203:08 - and one last difference is that in other
203:10 - programming languages
203:12 - threats do not have an easy
203:14 - communication medium or way to talk to
203:16 - each other in contrast
203:18 - go routines has a concept of channels
203:21 - which is a built-in functionality which
203:24 - allows
203:25 - easy and safe communication between the
203:27 - go routines
203:28 - and this is a functionality that helps
203:30 - you handle
203:31 - concurrency issues which are issues that
203:34 - may occur when threats have shared data
203:38 - or are dependent on each other now we're
203:41 - not covering this in this beginner
203:43 - tutorial because it's a more advanced
203:45 - topic but it's an important one so i
203:48 - will include it in my upcoming go course
203:51 - congratulations you made it till the end
203:53 - so what do you think about go have you
203:55 - already used it in one of your projects
203:58 - share your thoughts in the comments
203:59 - section of the video now in this
204:02 - beginner course we built a simple cli
204:04 - application without persistence but
204:08 - learned a lot of
204:09 - the main goal concepts but of course in
204:12 - real life this would be a web
204:14 - application with a ui and a database
204:16 - connected to it where multiple users can
204:19 - book their tickets at the same time and
204:21 - the bookings will be persisted in a
204:23 - database so if you want to take your go
204:26 - skills to another level and want to
204:28 - learn more advanced concepts in go i'm
204:31 - actually going to create a go course
204:33 - where you will learn to build exactly
204:35 - this kind of application with go
204:38 - if you want to be notified when the
204:39 - course is out then check out the video
204:41 - description for a sign up link or if
204:45 - you're watching this video by the time
204:46 - the course is already released then you
204:49 - will find a link to the course itself
204:52 - and with that thank you for watching and
204:54 - see you in the next video

Cleaned transcript:

in this full course you are going to learn about one of the youngest programming languages that is becoming more and more popular in the cloud engineering world which is go or also commonly known as go link you will learn everything you need to get started with go and start using it in your projects we're going to write a very simple cli application to learn the basics of go so instead of learning the concepts and syntax of go with isolated examples you will learn them while building an actual application throughout the tutorial so first let's see a detailed overview of what you will learn before diving right into the syntax you will first understand why go was even developed its use cases and differences to other programming languages as a next step we will set up our local development environment and see how the basic structure of a go file looks like then as we start writing our simple ticket booking application you will learn the core concepts and syntax like the most common data types such as strings integers booleans as well as arrays slices maps and struts you will also learn about variables and constants about formatted output getting and validating user inputs a concept of pointers in go as well as variable scopes then you will see how to control the application flow with loops if else and switch statements as well as how to encapsulate logic in functions and generally how to organize your code in go packages finally we will make use of go routines to parallelize some of the execution to make our application faster with concurrency so we're gonna learn a lot of things in this course and i hope you are excited to get started also i want to mention that all the demo code from this course is available in a git repository which we will link in the video description so you can follow along easily we have put a lot of effort in creating this course so if by the end of this course you think it was valuable for you let me know by leaving a like and subscribe for more content like this and also be sure to check out techworldwithnana.com for online courses and a complete devops educational program if you want to further educate yourself and bring your career to the next level now for viewers absolutely new to programming in general you can also check out my python course on youtube which is even more targeted to complete beginners in programming and with that let's get started go was created by google in 2007 and open sourced in 2009 so it's a pretty young language now whenever you hear about a new programming language the first question you probably have is why do we need yet another programming language what is the purpose of it or how is it better or different from other already existing languages so before diving into the syntax let's see what was the motivation behind creating the go language well the infrastructure where the applications were deployed changed a lot in the last few years multicore processors became common and also using cloud infrastructure with hundreds or thousands of servers with multiple processors to deploy applications became pretty universal so infrastructure became much more scalable dynamic and had more capacity however most languages couldn't help in writing applications that would take advantage of these infrastructure improvements so basically you had applications that would just execute one task at a time in order but with infrastructure improvements it was possible to now write applications that would execute tasks in parallel do multiple things at once this way making the application faster and more userfriendly a simple example is if you are using google drive you may be uploading or downloading files and folders but you can keep navigating back and forth in the ui so downloading uploading and navigating the ui all happen in parallel or consider youtube you can be listening to this video then scroll down to the comments write a comment yourself like the video etc so the application allows you to do multiple things at once without affecting any other task and this is a concept of multithreading so each thread is basically processing one task and you can have many of them running in parallel and this makes applications fast but may also cause some issues for example on google docs many users can work on the same document at the same time so when you have two users changing and adding stuff at the same time to the same document this should work smoothly without one user overriding all the changes that another user is making another example where such issues may happen when things are processed in parallel is a booking system for buying tickets or booking a hotel etc let's say again two users are trying to book the last remaining ticket at the same time of course this should work in a way that no double booking happens and this concept is called concurrency and needs to be handled by developers in code so they must write code that prevents any conflicts between the tasks when multiple tasks are running in parallel and updating the same data and many languages do have features for implementing such applications however the code can get pretty complex and handling and preventing the concurrency issues can be pretty hard and with complexity of course there is always a higher risk of human errors and that's where the main purpose and difference of go comes into the picture so go was designed exactly for that purpose to make writing multithreaded concurrent applications that take advantage of the new performance infrastructure much easier and we will learn about this in more detail at the end of the course when we use go routines so logically enough the main use case of go or what it's best used for is writing applications that need to be very performant and will run on the modern scaled and distributed infrastructure with hundreds and thousands of servers typically on a cloud platform for developing go they wanted to take the simplicity of syntax of a more highlevel language like python and the speed and efficiency of a lower level language like c plus plus so you will see the combination of these things in go and i have to note that go is used on the server side or the back inside of the applications and these types of applications can range from microservices and web applications to database services and so on in fact many cloud technologies or technologies that run on modern cloud environments are actually written in go like docker hashicorp vault kubernetes cockroachdb and so on now on top of this main purpose of go go actually has a lot of other advantages one of them that i already mentioned is it has a very simple syntax which makes your code very maintainable easy to read and extend another advantage is that go applications can be built very fast they are also very fast in startup and also when they're running plus go is very resource efficient which means it uses few resources or it requires fewer resources like cpu and ram to run go is also a compiled language and it compiles actually very quickly into a single binary and you can deploy it and run it on different platforms in a consistent way so no matter which operating system or which environment you're using you can take that same binary and basically use it across different platforms so considering all these benefits of simplicity and speed and so on go is becoming more and more popular for writing simple automation applications and command line interface applications for devops and sre tasks as well so now that we know why go was created and what differentiates it from other languages let's jump right into learning the core concepts and syntax of go now to start writing a go project we're gonna need two software programs first of all we're gonna need go compiler and second we're gonna need an ide or integrated development environment where we're gonna write code for go and also execute it as an id we're gonna use visual studio code which is super easy to download and install so if you don't have it yet on your computer just type in install visual studio code in google and basically on their official page you have the download options for all operating systems so go ahead download and install it so that's the first part i already have visual studio code locally so i'm gonna skip this part and second we're gonna need to install go compiler right now i don't have go locally that's why when i type go it tells me command not found so we're gonna install go which is also super easy again type install go and on their official page you have download and install guide and again for different operating systems i'm working on mac so i'm gonna download the go package for mac awesome once that's downloaded just click on the package and it will show you an installer which basically lets you install go step by step setting up everything necessary in the background so we're gonna do continue install for all users we're going to leave all the defaults install authorize and as you see installation was successful so so if i close this window we can remove the installer and go back to the terminal and type go as you see we have go installed that's why you see a bunch of go commands that you can start using now great so we have everything prepared let's create a folder in which we're gonna write our go project and i'm gonna call it booking app and using visual studio code we're going to write go program in that folder so i'm going to open visual studio code and i'm in the booking app folder you can also simply just open visual studio code and then basically choose a folder that you want to work in and you have the same result and i'm going to make it a little bigger for convenience and there is one more thing that we need to do to prepare our setup and that is installing a go extension inside the visual studio code the extension will basically help us in writing the go code it will give us a nice syntax highlighting intellisense to basically easily navigate our code help with troubleshooting and so on so extensions for different languages make it much easier to write code in that language so let's go ahead and do that to complete our setup and on the left side right here you have the extensions tab so if i click inside and then search go it will give us all the available extensions for visual studio code and the first one with the most downloads is the official one from go team at google and you also have a description of what that extension gives you and that's the extension we're going to use so click on install and that's it now we're all set up to start writing our first go application in visual studio code and for that obviously we need to create a file and this is going to be the main dot go file with dot go extension you will see a bunch of popups here to install things for the go extension so go ahead and click on install all and that will install and set up the rest of the stuff and main dot go is basically a standard name for the main file where the go application code is written and to see that in the file explorer we have this booking app folder and inside we have this main.go file now how do we start writing code in go like printing a simple hello world message to the console let's do print quotes hello world and we already see the first benefit of a go extension because it tells us that this code doesn't work and as you see the error says that go can't find a file called go.mod so the first thing we need to fix is to make our go application into a project and for that we need to basically initialize it that's the error that we get here and to do that we're going to open a terminal in visual studio code new terminal window and this will give us terminal in booking app folder which we're in which is very convenient and here i'm gonna run a go command called go mod or module init and basically name of the project we called it booking app so let's use that name so this is gonna basically initiate our go application into a module or a project and we're calling it booking app so let's execute and save so what this command actually did in the background is it generated this go dot mod file which simply describes the project with the name of the project and the version of go that is used here so the first issue is now fixed now we have another error that says expected package so in go everything is organized into packages and we're going to be using go packages throughout our application and when we create our own application we also have to include it in a package and doing that is actually very simple as the first line of our go application we define keyword package and then name of the package which our application will be part of and the standard name for the main application is package main so now we have an initialized go application which is in a package called main moving on to the next error we now see again a different message that says that a declaration is expected now i have to note here that you may actually have a different sequence of errors so you might see a different message here but i'm going to show it to you with my examples so in this case we have a missing declaration and that is basically goes way of saying i don't know where to start executing this application so give me an entry point and we have to declare the entry point of our application because when we run go applications we need the main starting point for the execution so go needs to know where does it start executing the code on which line because if you have multiple files in the go project you need to give go compiler a starting point the first line of code where the execution starts and the entry point is a main function that go will look for whenever you execute your go application and we create a main function using func keyword name of the function again it has to be called main and we have to put our logic whatever we are executing within that main function so now go will know where to start executing our application and for one go application you're going to have a one main because you can only have one entry point to your application so now we have a slightly changed syntax highlighting for our print function and if we hover over it we see another error message that says undeclared name now we've come to the point where our application belongs to a package we have the entry point so go knows where to start the execution and it sees that print is the first code that it's going to execute but the problem here is that it doesn't know where print is coming from that's why we see undeclared name and print is a function that comes from a go package a builtin package called fmt or format and we have to explicitly import any packages from which we're using the functionality so we're going to do import quotes fmt that's the name of the go package and to use a print function or any function from the package we're going to do fmt dot print and immediately as you see the error is gone and as i mentioned similar to many other programming languages everything is organized into packages so the go program that we installed actually already has some builtin packages with a bunch of functionality that we can use and one of them is this package that we just imported and as i said the packages have functions that we can use so whenever we want to use a builtin go function to print a text to get user input to validate something etc we need to explicitly import it from one of the packages so think of the packages as containers of various functionalities that go gives you readily available for you to use when writing your applications now how do you know which functions are in which packages or let's say if you need to get a user input how do you know in which package you have that functionality available well you actually have to look up the documentation to see that or basically just simply google to find the right package and of course with time when using go and its packages you are going to know the most commonly used packages and all their functionalities and a cool thing we have here is you see this underline under the fmt package and if i hover over it you see a link that actually takes you to the official documentation of the fmt package so here you can actually see what functions you have available in that package and so on so with this we have our first fully functioning go application that we can now execute so let's clean up our terminal and executing a go application is very easy we have go command for it called go run and name of the file that we are executing which is main dot go so go run will basically execute this file it will look for the main function and execute the contents or lines within that function one by one we just have one line so that's getting executed and we're seeing hello world in the output we can do final optimization here to add a new line at the end of this print statement and to do that we're simply going to use a different function from format package called print ln so this will print whatever we pass here with a new line and let's execute that again and there you go now that we have the minimum program structure and know how to run go programs let's start writing our booking application logic the very first thing we need to do in our booking application is to greet our users when they visit the application so let's write some welcome message and information about the conference for which they are booking the tickets so instead of hello world we're gonna write welcome message like welcome to our conference booking application and we can write another message like get your tickets here to attend and again if we execute this we're gonna see our welcome message pretty easy now let's say our conference has a name and we're using this name in many places in our application in the welcome message in the thank you message when the user books the ticket on the ticket itself etc and whenever we have a value like conference name that is used in many places throughout the application it's the most common usage for variables every programming language has a concept of variables where instead of repeating this value everywhere you store it once in a variable assign it a name and now you can reference that value using its variable name wherever you need it in your code now if the value changes you don't have to find and update it in multiple places throughout the application code but you can simply change it in one place where you assigned it to a variable and that's it so how do we create and use variables in go well we have the value like the name of the conference let's call it go conference and we store that value in a variable and we can give that variable whatever name we want like this let's call it a name and finally we tell go that we are creating a variable using a var keyword so this basically lets us store the value go conference the conference name in a variable called name so now we can use that value by referencing the variable name wherever we need it now with variables it's a good practice to create variable names that properly describe what the value is in our case name baby two generic so to make it more specific and clear we can call it a conference name and note the camel case syntax here which is a pretty common variable naming convention in different programming languages including go and if i save those changes you see that we get a red line under our variable definition and that is something specific to go language so in go unlike many other programming languages when we define a variable or when we create a variable with a certain value and we don't use it in the code we get this error that actually says conference name declared but not used so to fix this error we actually have to use that variable and note that same error applies when you import a package but you don't use that package in your code you get the same error that package gets imported but not used which is a very good reminder to clean up your code so to fix this issue we're simply gonna print out that variable value using print line function and again when i save this change the error disappears so let's clean up the terminal output and run our go application again and there you go you see go conference printed out now let's actually use that conference name in our welcome message instead of generic our conference we're going to reference whatever we define as a conference name for that first of all let's delete the print statement and again as a common practice we're going to define the variable at the beginning of the function and we can use the variable within the print message by dividing the actual text that we have here and the variable name with commas inside the print alien function so this will be substituted by conference name and then actual text and the variable name will be separated by commas and let's save this and if i execute our go application again we will see welcome to goconference booking application so it took the value from here also note that the space automatically gets added before and after the variable value now what we also need in our application is the tickets for our conference and let's say we have total of 50 conference tickets available for users to book and for that we will also create a reference called conference tickets to store that value once and then we can reference it as many times as we want so let's call it conference tickets and the value will be 50. we have 50 tickets available now this value actually does not change throughout the application right we have 50 conference tickets and it will always stay 50. while our application is running and for such values that do not change or stay constant instead of variables we have constants now as you might think the conference name could also be constant because it also doesn't change throughout the program but for this example we will leave it as a variable so instead of var keyword here we're going to use const and that will give us the same type of reference as with variables but this time we cannot change the value of this constant but we can use it and reference it in our application exactly the same way as our variables so the const keyword tells go that this value is not allowed to change and if we actually try that and somewhere in the application code change it to some other value and then try to use that like this we get a warning here right away that says cannot assign to conference tickets because it's declared as a constant but if we change it to var and save you see that the warning disappears so let's change it back to const and clean those lines up now when users start booking the tickets obviously we need to keep track of the ticket count so when 50 users book their tickets we inform the rest that the conference is completely sold out so every time someone books a ticket we need to basically reduce the number of available tickets that users can book and for tracking that amount we're going to create another variable for remaining tickets and we're going to call it remaining tickets which again is a variable because as users book their tickets this value will get less and less and it starts at 50 because that's how many tickets we have in total and again we have this warning because we're not using it so let's actually use that in our welcome message to inform the users about how many tickets are available for the conference and how many of them are still remaining so between these two lines i'm going to add another print statement and here we're going to say we have total of this many tickets and this many are still available and if i save this the warning will go away because we are using both of these values in our code so again separating the actual text from the variable reference using commas now let's run our updated application and in the message we have the name of the conference and here it says we have total of 50 tickets and 50 are still available now whenever we're printing our text mixed with variables we can use a function called printf from the format package this function is specifically used for printing formatted data so it tells go how to format the values of the variables and generally it makes writing these kind of outputs easier so with printf this line for example will look like this so instead of print ln we're going to use printf another function from the format package and instead of the conference name reference we're going to use what's called a placeholder and annotate that using percentage sign and v and you see the syntax highlighting here that shows that it's a special character for placeholder but of course we still need to reference whatever variable we want to substitute here right and we do that right here with a comma and then conference name and if i save this and run we have the same output one thing that is different here is the new line is missing because we were using println that automatically added a new line in this case we're gonna add it explicitly using backslash n so that's a character for newline and if i save this and run we have exactly the same output as before now let's do the same for the second print statement first change it to printf take this reference here and substitute it with percentage v do the same for the second variable reference and again we need to replace so basically we need to tell go which variable values should be used to replace those placeholders and of course they should be in a correct order when we have multiple such placeholders so the first one is conference tickets the second one is remaining tickets and again the new line backslash n save it and there you go now as i mentioned printf or print format function allows you to tell go how to format the variables that you are referencing here the percentage v is the default format but you have other specific formats also available if you want the values to be displayed differently and you can see this whole list in the gold documentation under the fmt package link so the percentage v is the one we used we have a lot of other options as well for numbers and text values and so on now sometimes when we create a variable we don't immediately know its value for example when we're getting user input like a user entering their name and date of birth etc in the application we don't know that value before because we don't know what the user is going to enter so we create a variable and later we assign it the value which is possible to do in go just like in other programming languages so let's see the syntax for that so here let's say we define a variable called username and we don't know what the value of that variable is going to be and on the next line we ask the user for their name and this is a syntax for comment so whatever starts with double forward slash signs is basically interpreted as a comment so it's not executed as code so let's say we have some imaginary code here that asks for user input and they and that user name that we get is let's say tom and finally we can actually use that value so we have defined a variable here and then we are assigning a value for that variable later on a separate line however when i save this code you see that we get another warning here that says unexpected newline expecting type so what's the problem here and why is it expecting a type well in go all values have data types and generally in any programming language you have multiple data types for different use cases and go isn't an exception the difference between these languages is however which data types exactly they support so each language has its own set of data types two most basic and common data types are strings and integers for textual data like the welcome message the name of the conference so anything between the quotes basically is a string data type for numeric data like ticket count h and so on we have integer data type and again you see the syntax highlighting for the integers and strings are different because go basically knows this is a string this is an integer so these are the two most basic ones but we're going to learn a few other data types as we go along here however it's important to understand that each data type can be used differently and behaves differently for example you can do calculations with integers but you can't do calculations with strings you can chain or get a subset of a string but you can do that with integers so the main purpose of having types for values in code is to avoid accidentally using an integer as a string or vice versa and use one data type instead of the other which may break your application so when we create variables in go it needs a type now you may be thinking when we created these two variables right here these two variables and a constant we didn't specify a type so why didn't we get the same syntax error here well when we create a variable or constant and assign a value to it immediately on the same line go can imply the data type based on the value so go knows that this is a variable type for string and this is a constant and variable types for integers because of the values but when we do not assign a value immediately go doesn't know what type of value you are going to store here so it asks you to explicitly define a type to make your code basically more robust and prevent you or other developers from accidentally assigning a wrong data type value to that variable later in the code so in this case we need to define a type explicitly how do we define a type super easy at the end we just say this is a variable of string type if i save this the error disappears and again you see the syntax highlighting for the type and the same way we can define a variable for integer type let's say user tickets which is a number of tickets user wants to buy and this is going to be an integer type and somewhere here we're going to ask user for the input and let's say they enter 2 and in the print statement with printf we're going to say user whatever their username booked this many tickets with a new line and reference the respective variables and again let's run this and here we have our output now you probably already noticed something really cool about go especially if you have worked with other programming languages before and that is that while we're writing this code if we make some mistakes if we have errors in our code for example defining a variable and not using it or forgetting to specify a type etc go basically detects those errors before we even run the application so by the time we're ready to execute the application we have fixed a bunch of errors that go identified and highlighted for us in many programming languages that's not the case usually you discover these kind of errors when you run the application not while you're coding and that is a big advantage of go now going back to the types i mentioned that go actually implies the types of these three values automatically and if we wanted we could actually print out the types of variables using the printf function so with fmt printf let's print out the types of these two variables and a constant so conference tickets is whatever type it has then remaining tickets is whatever type this one has and then conference name is percentage t percentage t is a placeholder for the type of the variable that we're referencing here not the value like percentage v but the type so let's pass in those references and save and if we run our application we should see the output here conference tickets is int or integer remaining tickets is in conference name is string so this lets you print type of any variable now if we wanted we could actually define the types explicitly here even though it's not required so we could do conference name as a string and int and int however specifying a type explicitly when go can detect it makes sense when want to specify a different type than what go would detect for example in go specifically again we have multiple times for numeric values so in addition to int or integer type which represents whole numbers we have int 8 in 16 and 32 and int 64 which corresponds to the length of the integer so basically how big or how large the number is and in addition to that we also have uiint or unsigned integer which represents whole numbers like integer but only positive ones so 0 and plus and here's a chart of all the different numeric data types in go and obviously each one has its own purpose so the question is when to use which one and why do we have so many different integer data types for example well this allows you to define data types in a way that the values will automatically be validated so if you're using uiint and assign a negative value to it you will get an error like in our case the number of remaining tickets should never be negative but with int type it can be so somewhere in the code we can actually set it to a negative number like this but if we specify a type uint explicitly instead and save it you see that it will not accept the negative value so setting a type may actually protect our variable from getting a value that it's not supposed to get and obviously you as a developer are not going to assign your variables a wrong value but if you're doing some calculations on your variables or some processing the result of that calculation may be a wrong value we also have float number type which are for numbers with fractional parts so not whole numbers this could be statistical data like a conference attendance compared to last year for example this could also be monetary values like prices of products in an online shop or transactions in an online banking application and so on so basically when a number needs a higher precision float number type needs to be used but as i said there are other data types in go besides textual and numeric types which we will learn as well now there is one more thing in terms of variable definition in go and that is again specific to go is that we have an alternative syntax for creating a variable and assigning it a value directly this is like a syntactic sugar of go language so instead of this syntax for creating a variable we can get rid of the var keyword as well as the type and right here before the equal sign just add a column and this will do the same as before create a variable and assign it a value now note here that with this alternative syntax you cannot declare constants so we cannot do this with constants it only applies to variables and it also doesn't work if you want to explicitly define a type for your variable like here for example now let's clean up our code and let's go back to our ticket booking logic so this is a booking application so want to allow users to book their tickets and for that we want to ask users for their personal information first like first name last name etc and all these values will be then saved into variables like this so we need some logic here that allows the application to ask for user input in order to read user input we use another function from the same format package called skin so basically the format package gives us different functions to print out like this formatted output or read formatted input so it's used for input output processing functionality so let's scan the user input for their first name because instead of assigning the value directly as we did here we want to get that value from the user and then assign it to the username variable now print function like printf or println takes a message as a parameter like this one a formatted message and prints it scan also takes a parameter which is the input it needs to scan and the parameter for scan function is the user input but we don't know what the user will enter as their name so we need a way to save the user input as a variable and then reference that value using that variable name instead of directly assigning it here and let's save it so this is supposed to scan user input and whatever user enters basically assign that value to username variable as a value now if we run this application let's run it you see that it runs it executes all those lines and it just exits it doesn't wait for any user input so we were not able to enter anything and the value of the user here or username variable is also empty so there is one thing that we need to fix here so before the username variable we need to add what's called a pointer like this so what is a pointer simply explained i said that we save a value in a variable in order to use it later so when we create a variable where does that value actually get stored well values are saved in memory on your computer so that 50 or go conference values are actually stored in memory but whenever we reference that value using the variable name we defined go compiler must go and find that value in memory so it needs to know where in memory exactly it is stored or in other words it needs to know the memory address of that value and a pointer is a variable that points to the memory address of another variable that references the actual value 50 for example and pointers in golang are also called special variables so to see that in the code let's actually comment this out and if we print out any variable like remaining tickets for example with value 50 this will give us the actual value 50 but if we print out the pointer this will actually print out the memory location of the remaining tickets variable let's actually see that right here we have value 50 and the next line is a hash which is a memory address for the remaining tickets variable so that's basically a pointer and it's also important to mention that pointers is a concept used in the c programming language but many popular programming languages like java or javascript for example to not have pointers at least not exposed to you as a developer so you will not see the concept of pointers in many other languages so again going back to our scan function instead of passing the value of the username variable which is empty we're passing the memory address of that variable so that scan function will read whatever the user enters and assign that value to that username variable in memory so if i execute the application now you see that it doesn't just exit it actually stops at this line after get your tickets here to attend and it's now waiting for me as a user to input some data and as a username i can input my own name and if i enter it goes to the next line and it prints out whatever is in the username booked to tickets so now we have that value whatever user entered available in our code through this username variable now to make this a little bit userfriendlier we can also ask the user explicitly what we are asking for so we can say enter your first name like this and let's run again and there you go so now we are actually asking the user explicitly what we want and then printing the result out so that's one value now let's read other user data like last name email and number of tickets user wants to book and let's first call this first name and update it everywhere like this let's create last name which is also string and email which is also string and user tickets which we already have which is an int and now one by one let's actually scan all those values i'm going to copy these two lines and we're going to say enter your last name and we're going to save that value that user enters in a last name variable again let's copy and let's say enter your email address and the value will be stored in email variable and finally instead of assigning user tickets directly we're going to ask the user how many tickets they want enter number of tickets and again this will be stored in user tickets variable and at the end let's actually print out some kind of a thank you message to the user with some additional information so let's write thank you first name last name of the user for booking so many tickets you will receive a confirmation email at whatever email address they gave us and don't forget the new line at the end and now let's actually substitute those placeholders with the actual variable references so we have first name last name and here we have the third one user tickets and finally the email address they gave us awesome so let's clean this up and run our program enter your first name nana enter your last name my last name email address something like this and finally number of tickets let's say three tickets and if i enter this is the last skin so now it's gonna execute the print statement that says thank you nashia for booking three tickets you will receive a confirmation email at this email address now we're getting user input but no tickets are being booked the remaining tickets doesn't get reduced it always stays 50. so let's write some simple logic to book the ticket which in our case will be just reducing the number of remaining tickets so after getting user info we will simply add remaining tickets minus user tickets so this will give us some value 50 minus how many tickets user booked and then we have to save it back into the remaining tickets variable to update it right because we have to update the value of this variable by assigning it back now when i save it we see an issue and that is type mismatch of uiint and int because we're doing a calculation on two numbers which have different types one of them is you integer and another one user tickets is an integer so as you see in goal when you do calculations between numbers they have to have the same type one way to handle this issue in many languages is to convert one of them to the other type using various builtin functions that you have available in the language a simple solution for us is to make the user tickets also you in type because users can only book positive number of tickets right they can't book minus one or minus two number of tickets so let's make it you int as well and now the error is gone so that's our super simple booking logic and after the thank you message we're also going to print information about how many tickets are now remaining so let's say this many tickets remaining for this conference remaining tickets and conference name so with these changes let's now run our go application and again enter the user values and let's say we're buying 15 tickets and enter and as you see the remaining tickets are now 35 50 minus 15 that we entered before moving on i want to give a shout out to castin who made this video possible kessen's k10 is the data management platform for kubernetes k10 basically takes off most of the load of doing backup and restore in kubernetes from the cluster administrators it has a very simple ui so it's super easy to work with and has an intelligent logic which does all the heavy lifting for you and with my link you can download k10 for free and get 10 nodes free forever to do your kubernetes backups so make sure to check out the link in the video description and now let's continue now we're saving user data in variables and are booking the ticket for them but when multiple users book the tickets we need to save all these user data in some kind of a list right to keep track of who is attending the event and who booked the tickets and for that we have data types called arrays and slices arrays and slices are commonly used data types in go applications so let's create an array for all the bookings so right here i'm going to create a variable called bookings and this is going to be an array when we define an array the first thing we need is the size because arrays in go have fixed size and for that we use square brackets and within those square brackets we define the length or size of an array and let's say we expect maximum 50 bookings so we're gonna say 50. so the size of an array is basically how many elements can this array hold so as i said array is like a list of bookings or list of elements and with the size 50 we're saying this can have 50 elements in that list the next thing we need to define is the type of the elements this array will contain a data type so what kind of values are we going to store in that is it going to be a list of integers a list of strings etc in our case let's say we want to store a list of names of the users who book the tickets a name is a string so our array is going to be an array of strings so that's the data type and finally we need the actual value right so this is the same syntax as this one right here where we are assigning a value directly to the variable so we need to actually assign a value of an array and we can have an empty array like this or we can already put some elements in the array and let's say these are some of the names inside and this gives us a bookings array with size 50 with three elements already in that array now there are two things i want to mention here first of all because we have to define the type of the elements for the array we can't mix any other type here so we cannot have names and then an integer for example right this will not work and again this is specific to go you can actually mix the types in some other programming languages the second thing i want to mention is that even though we are starting with three elements here we can actually update our array and add new elements up to 50 as well as remove the elements so again this is a variable so we can add new elements to the list and remove that during the application execution and usually when you create an array you actually start with an empty list like this because you don't know the values at this point and as the program executes you basically add new values one by one so that's going to be our starting point and because we are creating an empty array an alternative syntax for this will actually be to define the array variable like this without assigning a value and going with the default empty array but as you learned in this case we have to define the type for the array because go doesn't know the type and again you see here it's expecting type so what is an array type in go well it's actually a combination of the size that we defined which is 50 and the type of the elements it's going to contain like this so this is actually an array type and we're getting this error because we're declaring a variable but not using it so let's actually use it and let's start by adding new elements to that array how can we do that pretty simple actually we have a syntax with indexes so bookings array with index which is the position in which we're adding a new value like this so again our array has 50 empty positions where we can add values and we're saying the position 0 which is the first position let's assign this value and we can say position let's say 10 let's assign a different value but of course normally you would go one by one you would add the next value in the list like this now in our case again we want to add a name of the user that booked the ticket we want to save the first name and the last name of the user so instead of assigning a value directly we're going to say first name and add some space in between and the last name so this will give us first name last name with space separated however as you see here we get an error that first name and last name are not defined because we're using these variables before they are declared here again in a language like javascript for example the order doesn't matter so this would work in javascript but in go you have to use the variable after it has been defined in the code so we're gonna take this assignment and basically move it down here under the logic for updating the remaining tickets and if i save this the error is gone so to wrap this up we're creating an array variable at the beginning which is defined as an array of strings with 50 elements maximum and right here after user has entered their first name last name and booked the ticket we are adding that user's full name to the bookings variable and to also see what's inside the bookings let's actually print out the contents of the array and also some information about the array to see how it actually looks like so let's do fmt print f and first let's print out the whole array placeholder v and newline and this is going to be whole bookings array then let's print the first value which is bookings at index 0 and we need to use capital p here like this then let's also print the type of the array like this and finally let's print the size or length of the array and to get the size of an array we have a builtin function called length with l e n that takes the array as a input so to say and gives us the size of the array and here we need percentage and capital t and now let's actually run our application and see how arrays work book five tickets and here you see all the array information so first of all we have the whole array that has one element which is first name last name of my user and you see that it has square brackets at the beginning and here at the end so basically this represents the space for all the other elements in the array because we have a fixed size of 50 elements and that's why you have a space here then we have just the first value which is this one right here without the brackets the array type is what we actually defined here as a type and then we have array length which is 50. now what happens if we try to add value to this array at an index 52 for example so basically index outside the range of the array size let's try to do that so instead of zero index we're going to do 52. again without running the application go actually detected that your index is out of range or out of bounds and you need to fix that again if you have some calculated number here that you don't know refers to a wrong index go will help you basically detect that error immediately before even running the application now we have one issue with our array because what if you don't know the size of the array when you're creating it let's say we have an array for users who sign up for our newsletter we don't know how many users are going to sign up right this could be anything between zero and indefinite so how can we fixate the size here it could be same in our case because maybe not all 50 tickets get booked or maybe one user basically books all 50 tickets so we have just one booking and an array of size 50 with just one value inside so how can we define a list that is more dynamic in size for such use cases so basically at least where we don't have to specify a size at the beginning but it automatically expands as new elements get added to it well exactly for that use case instead of array we have what's called a slice slice is basically an abstraction of an array so it uses the array type under the hood but has a dynamic size and working with slices is also more efficient than with arrays so generally using slices is actually a better option than using arrays in our application we will also use slice instead of an array and to define a slice we basically create an array without a size definition like this now in an array we added new elements using this index which is not very convenient because for each new user we have to know exactly what is the next index that has a free spot or free place for the next value in slices however we don't need to use the index instead we can just say add the next element to the slice so the syntax for that is append again a builtin function from go just like this length function and this append takes bookings which is our slice and then whatever value we want to add to this slice is a next element whatever index that may be and then we have to assign this back to our slice and as i said this is much nicer because we don't have to keep track of the indices and let's remove this and now we are working with dynamic lists using slice so adding a value to a slice is different than to an array but retrieving a value getting a value from the slice is the same so we can actually leave this syntax like this we can change the wording here from array to slice and now let's run our application again and as you see the slice basically has these brackets directly wrapped around the value it has and the length of a slice is one so as we add new elements it automatically expands and finally just as a reminder note the alternative syntax for creating a slice just like with an array we can also do an empty slice assignment like this or using this alternative syntax we can also create a slice with this syntax so now we're actually saving user information in the bookings list let's actually clean this up before moving on and instead let us print all the bookings in the application like this and we actually need printf and that's our cleaned up application code now even though we are saving the data of the list of users who booked the ticket we only always have just one user because when we run the application we enter information get the ticket and the application exits now of course in real life this would be a web application with a ui and a database connected to it where multiple people can book at the same time from their browsers and the bookings will be persisted in a database but in our case we have a command line interface application so we're using our application only through the terminal so what we're going to do is create a constant loop where the application keeps asking for another ticket booking after one booking is done to simulate booking a ticket multiple times for different users and loops which is a concept that you may already know from other languages is basically used whenever we need to repeat the same logic multiple times now in go specifically loops are actually simplified you don't have different types of loops like while loop and do while loop for each loop and so on you just have one loop which is a for loop and you can use it for all the different use cases so basically you have for loop with different types our first case is super simple use case for a for loop which is that we just want to allow booking over and over again so after the welcome message the logic which basically asks for user input and then books the tickets and then prints out the summary of the booking need to be repeated so right here at the beginning of this logic we're going to write 4 so that's the beginning of a for loop and the syntax of a for loop is curly braces so whatever we put within those curly braces gets repeated in this loop so i'm going to take this whole thing and put it inside the for loop and let's actually fix the indentation like this so we put that logic inside the for loops block and for each line we have basically indentations like this so that's it this will basically keep asking for a new booking after one booking is done and to test that let's run the application this is the first user and now immediately after we got the output of the booking first of all these three lines right here so we have 46 tickets remaining and this is one booking in our bookings list and immediately after that it asks for another user's input and let's fill it out let's do nicole smith and email address and let's say she books three tickets and as you see the remaining tickets got updated from 46 to 43. right so minus three tickets and now we have two bookings in our bookings list the first user and the second user and we can do this basically indefinitely for as many users as we want so to break the application you can do control c and this will basically interrupt and stop the application but of course when we start the application again it will start from scratch right so the bookings variable as well as remaining tickets variable of course gets updated while the application is running right after each rerun everything gets reset now let's do one more thing here at the end of each booking we're printing out the list of users who already bought the tickets and we're printing out their first names and last names but let's say we want to give our users a little bit of privacy and instead of printing their full names we want to only print their first names to display the bookings with a little bit of privacy so basically we want to go through our bookings list our full names bookings slice and for each entry of the full name we want to extract only the first name part and then print only the first name again we're doing the same thing over and over again to different elements of the bookings list so it's a loop but instead of an indefinite loop like the one we're using here that basically never ends we want to loop through a specific list of elements so let's see how we can do that first of all let's define a slice for only the first names let's call it first names and let's use the shortcut syntax for this so this is going to be a slice of first names which are strings and we are starting with an empty list now when i save of course we get an error because we're not using it next what we're going to do is we're going to loop through or iterate through our bookings list grabbing one element at a time and to iterate through a list we have a pretty simple syntax actually we have four again for loop and while we are iterating through this list we get two values for each iteration first we get an index and you learn the index from the arrays it is basically a position of the element in the list this is the first element second element and so on so we get the index for each iteration and we get the element itself and we can call this element whatever we want it's like defining a variable let's call it booking because we have a bookings list so each element inside will be a booking then we have a syntax of colon equals and here we define what list are we actually iterating and getting these two values from which is bookings so we are iterating through bookings and to iterate through a slice we need a range expression range allows us to iterate over elements in different data structures not just arrays or slices but for slices and arrays specifically it gives us back the index and value for each element so this basically defines the whole logic of go through this list and for each iteration give us index and the element value and at the end we have curly braces for defining logic for our for loop so basically we have a for loop inside another for loop so inside these curly braces we have access to each element stored in a booking variable and index of that variable one by one so the booking variable has a full name like nicole smith with a space character between and in order to get the nicole the first name we can simply split the whole string on a space character using goes builtin function called fields like this and the fields function comes from strings package so this will take our full name string split it on empty space and gives us a slice of strings separated by space which in this case is nicole and smith two values so a slice with two elements and we're gonna save that into a variable called names so names will basically be an array containing two elements the first name and the last name and you learned to get the first element of an array or slice we just use index 0 and that's going to be our first name very easy now of course we're using a package and its function so we need to import that package and this is actually one of the cases that i mentioned at the beginning if you want some functionality of go you probably will not know by hard in which package you have such a functionality available and what is the name of the function so of course in this case you just google how to separate strings on space or something similar and you get results probably from ghost official documentation that references this example so let's go ahead and import these strings package right here now here we're just importing one package we haven't actually needed any other but if we want to import multiple packages then we have to enclose it into brackets and each package should be on a new line like this and then close that bracket and there you go now if you scroll down you see a bunch of red lines here which are all about variables that are declared but not used and we're going to fix those one by one first of all we need to save this first name in our first names slice right because we're basically going through these bookings and we're collecting a list of first names in this slice and to add an element to a slice remember we use the append function which has the slice variable inside and the element that we are adding which is actually first name and we have to then assign it back to the slice variable like this so again we're defining a list variable here a slice variable and then within this loop one by one we're adding a first name to this first name slice so at the end of the for loop when we use first names here it's going to have the list of all the first names from the bookings list now we can actually spare us this line here by just grabbing this value here and using it directly in the append so we don't need an additional variable like this so basically when the loop is done collecting the first names we can print it out right here let's do the first names of bookings are and then we have first names instead of the bookings now you see that we still have one error here that we need to fix before we can run our application and that is the index variable that we created here is not being used because we don't actually need this index in our logic but we can't just remove it and just leave booking here it needs to be there because we are expecting two values here so we have to save both of them in a variable so instead we can fix the problem by simply using an underscore in its place which is known as a blank identifier in go underscores are used to identify unused variables so basically we're saying there is a variable here but we just want to ignore it because we don't need to use it and if i save this you see that error is gone and that is because we're telling go that we know that there is a variable defined here that we are explicitly not using that's basically the idea of using underscore so now with these changes let's run our application again and see that only first names get printed out and you see that our application logic works pretty good we have updates in tickets after every booking and at the end of each booking we also get a list of first names printed out and again you can quit the application using control and c great now we have two for loops in our but the first one the indefinite for loop never ends it keeps asking for the next booking but what if all 50 tickets are booked out we need to end the application and say that conference is sold out so after every booking we need to check if the remaining tickets is zero and if it is we end the application otherwise we let it continue and we do that using if else checks which is a concept you have in all programming languages and is super easy so let's see how it works so at the end of the booking within our indefinite for loop right here we make the check to see if the remaining tickets is zero so no tickets are left so we start with if keyword and the expression after the if keyword is called a condition like remaining tickets equals zero and the data type of such conditional statement is a boolean true or false so either this statement is true remaining tickets is really zero or it's false so we're telling the program if this condition is true then execute the code within these curly braces or within the if statement block if this condition is not true then skip the execution of whatever code is defined here and skip to the next line which in our case is the next iteration of our for loop so if the remaining tickets is zero we want to basically end the program so here is going to be logic for quitting the application so first let's actually print out a message for the user saying something like our conference is booked out come back next year and after that we end the application how do we do that we basically break the loop using break keyword so this will basically end the loop which means the application execution is over because there is nothing after the for loop right application ends so as i said this expression here or the value of this expression is of a boolean data type so we should have a boolean type keyword for that and be able to create variables of that type as well right just like for other data types so i could actually take this whole expression and save it into a variable which we can call no tickets remaining which is of a boolean type and then we can use this variable as a conditional of the if statement again with an alternative syntax we can write this expression like this and by the way note the syntax for double equal signs here instead of one equal sign so one equal sign is for assigning values to variables double equal sign is for comparing two values to each other again nothing specific to go this is actually same in other programming languages now since we're using this variable only once here there's actually no need to save this expression into a separate variable so i'm going to change it back to before and leave it directly in the if statement so let's actually test that our logic works and the application ends when users have booked all 50 tickets so let's run the application provide the data and let's actually take all 50 tickets at once like this and as you see after it printed the first names of bookings right here we went to the next line so that remaining tickets equals 0 is true so it so this condition was true and because of that it actually executed these two lines and it printed out our conference is booked out come back next year and it broke out of the loop which ended the program now this makes sure that the program ends when all tickets are booked but what if a user wants to book more tickets than available so what if i typed 52 instead of 50. let's see what would happen in this case with our application so let's run it again and i'm going to book 52 tickets and this is the output first of all we have this weird number of tickets remaining and second the application didn't end it actually continues to ask for another user input so as you see our application cannot handle when user wants to book more than available number of tickets and the reason why application didn't end even though we exceeded the ticket amount is because the remaining tickets is not zero anymore it's this number here that's why these two lines were not executed so let's fix this issue and to do that before the booking happens right here where we take the remaining tickets and we deduct the user tickets from it before that even happens we need to check so we need another if statement to check whether user tickets is greater than the remaining tickets so if user is trying to book more tickets than is available again very easy we have if and then condition which says user tickets is more than remaining tickets right so this is going to be an invalid input from the user so we need to tell the user something like we only have this many tickets remaining so you can't book so many tickets and let's substitute those values so we have remaining tickets and this is the user tickets that they're trying to book so we inform the user about their wrong input but we also have to end the program because if this is true then all this rest of the code should not be executed right the ticket should not be booked so same is right here we break from the loop which ends the program so this break here will basically tell go to skip execution of the rest of the code in the iteration and stop the loop so all of these will be skipped so let's test our logic and try with 52 again and as you see the program says we only have 50 tickets remaining so you can't book 52 tickets and as you see none of the next lines gets executed and the program exits so now we are handling an invalid input from the user to protect our application from the outcome that we saw previously now let's say we don't want to end the application if user wants to book more tickets than remaining we want to allow them to try to book again with the corrected number of tickets so we don't want to stop the for loop completely with break we want to tell the user hey you're trying to book an incorrect number of tickets so please try again so we want to skip all of these to the next iteration of the for loop instead of breaking out of the for loop completely and we can do that also very easily using another instruction called continue so instead of break we say continue to the next iteration so continue just like break we'll skip all of this but instead of ending the loop it will basically go to the next iteration of the loop so let's try that as well let's do 52 again and you see the message gets printed out you can't book so many tickets but it skips to the next iteration and it starts with enter your first name again so user has another chance to enter correct amount so this makes our application a little bit more userfriendly now what if we wanted to check for the reverse condition and check if user wants to book less tickets than available or exactly the same number how could we do that first we change the expression to less than or equal so user tickets is either exactly same as remaining tickets or is less and we say if this condition is true so it's a valid input from the user then everything is great they can book the ticket so this whole logic here can be executed so instead of these two lines i'm going to put this outside of the if block so instead this logic will be executed so we are reversing the check and don't forget to fix the indentation here so if this condition is true then this logic should be executed which actually books the tickets now what about this code here where does this logic go well after the if block is finished we add an else statement which says otherwise so if this is not true it's false in that case execute code in this block and that's where this logic will go so basically either at any iteration either the if block will get executed or else block right so this is an if else statement and this basically logic wise does exactly the same as before we just changed the condition here and because only one of those blocks will be executed we don't need the continue part here to skip the booking logic right because the booking logic is in its own block so say so let's move the continue and save and if i test this again and try 52 you will see the error message so this line was executed the else block basically and without the continue keyword it skipped to the next iteration because that's actually the next line of the code after the else block now let's say we wanted to do something different if the user tickets and remaining tickets were exactly equal so if that was the case we wanted to do something completely different than what we're doing here or here so where could we put this logic in that case we would split up this condition so here we would say if user tickets is less than remaining tickets then do whatever is defined here otherwise else if user tickets is exactly equal to remaining tickets then do something else and finally if none of these are true so this is false and this is also false then execute the else block and you can have as many else if statements in between if and else as you want but you can only have one if statement and one final else statement now let's revert this because we're not doing anything different here and let's revert back to our if else statement now there is another place where we use conditionals that are true or false and that's in for loops so in addition to looping through a list like this we can also say execute the code in a loop for as long as a specific condition is true like execute code in this block within this for loop for as long as remaining tickets is more than zero or as long as the size of the bookings list is less than 50 or even a combination of both like this so we can use the same conditions that we saw in ifall statements as the for loop conditions and tell our program to execute whatever code is inside that for loop as long as this condition is true as soon as it becomes false the for loop execution is over now you may be thinking at this point why didn't we have any condition in our infinite for loop why doesn't it say anything well since the conditions can be true or false an infinite loop can be written by using condition true so basically hard coding aesthetic true will make this loop an infinite loop and that's what we have and whenever we have that we can just leave out the condition and have for loop with no condition and that's going to be the same as saying for true and that's why we don't have to explicitly specify condition but again as i said if you want to write a for loop that only runs as long as a specific condition is true you can define that condition right here another common use case for if else statements is user input validation in our application we are allowing users to enter their data but users don't always enter data correctly either intentionally or unintentionally and we developers must make sure that our application doesn't crash when user puts in bad input so we have to make sure that our application is so robust that it can actually handle any type of bad user input and the way to do that is to always check whether the user input contains valid information any unexpected values and so on so in our case let's check a couple of things in user input that we're expecting so these are the four pieces of data that we are getting from the user and we want to check all of those first let's check that the names that user provides are valid the first name and last name and let's say the valid name for us is a string with at least two characters now if the user provided a wrong name this would not crash the application but we want to make sure that users are not spamming our application and are actually giving correct information at least we try to partially check that and again we have to do the validation part before the booking logic gets executed right because if they entered invalid data we don't allow the booking so right here let's check that first name and last name length is at least two characters but we're not going to do anything with it yet we will just save it into a variable and use it later now to check the length of a string we have the builtin function called len length which you already learned from arrays and slices so for arrays and slices this checks the size of the list for strings it checks the size of the characters so how many characters are in a string so first name length should be at least two so it can be two as well that's why we're going to do greater than or equal to two and the same should be true for the last name so in addition to that we also want to validate last name in the same statement and we can do that or we can chain these two conditions using end characters again note the double ampersand signs so this basically says this condition and this condition so this is going to be check for last name and whatever value of this expression again assign it to a boolean variable and we're going to call it is valid name again we can skip the boolean type because go can imply from the value that it's a boolean type so we can save that and we can also use the alternative syntax like this so again if user entered the first name that is at least two characters long and last name which is also at least two characters long then this whole thing will be true and we're gonna assign the true to is valid name variable now if any one of those is false so if first name is valid but last name is not or vice versa then this whole expression will be also false and that false value will then be assigned to is valid name variable now let's validate the email address and let's say for email address we want to make sure they're not entering an invalid email format so we're going to check that the value of email or the string contains the it sign now you already learned the strings package from which we use this fields function and the same strings package actually has a function called contains that takes a string as a first input and then a character or multiple characters that we want to search in that string and this will actually give us a boolean result back so if the string contains this character or these characters then it will give us true back if not then it's going to be false so we can call this is valid email and assign this whole value to it so we assume if email user gave us contains this character then it is a valid email if not then it's not valid and finally let's check the user tickets and validate that user didn't enter a number of tickets which is negative or zero so it has to be positive number greater than zero so again user tickets is more than zero will be a valid ticket count now we have another check for the user tickets which is that it's a less than remaining ticket so a user cannot book more tickets than available so that's going to be another validation for this input and we can actually add that right here also with this end sign so both of these expressions need to be true so that we have a valid user ticket if any one of those is wrong let's say user tickets is a positive number but it's more than remaining tickets then it's going to be invalid input so let's call this is valid ticket number and here we have our user input validations so as i said we can chain multiple conditions like this with double end sign to make sure both of these are true to give us a valid ticket number we can also chain conditions with or instead of end let's say the conference is taking place in two cities singapore and london and user can choose which one they want to go to or which location they want to attend so they can choose between those two cities but they can't enter some random city that is not valid so in that case we could have a check is valid city where let's say if we had the city as an input we would check if it's either singapore or london so city cannot have both of these values right it has to have either singapore or london if it has some other value then it is an invalid city but if it's valid then it should be either or so in this case we chain this condition using or instead of int well sometimes we need to check whether the user did not enter a specific value for example let's say we want to check is invalid city which means user didn't enter either singapore so the city is not singapore and it's also not london so basically if both of these conditions are true so the city the value of the city is not singapore and is not london then is invalid city is true so this here is a negation or not equal and it may be a little bit confusing than positive statements like equal or greater than etc so if this is more confusing than the previous statement then what you could also do is revert this back to is valid city and then using that exclamation mark you can negate the result of this so basically this statement with exclamation mark is valid city is exactly the same as the negative check that i just showed you and you could use this in the if statement of course like this okay now let's clean up all these examples and go back to our user input checks we have saved all these checks in variables so now it's time to use those variables in the if statement and execute the booking only if all the user input values are valid and skip the booking if at least one of those user inputs are invalid so if name and email are correct but the ticket number is invalid of course we want to skip the booking so in the if statement we check if is valid name is true and is valid email is also true and is valid ticket number is also true so all three have to be true in order to execute the booking so again we're chaining this with end symbols which means all of these three have to be true in order to execute the booking and if i save this we also get rid of the error and if any of the user inputs is wrong we're going to inform the users about that saying using a simple message that says your input data is invalid try again let's save it and let's actually test that our validation logic works so i'm going to put in first name which is just one character and all the other stuff are correct as you see we get invalid data input let's now try a wrong email address without the add sign and again invalid input data and you can also test ticket number and so on so now we have some kind of protection in our application against bad user input as i said the bad or invalid user input can be intentional or unintentional sometimes users accidentally enter wrong information so we could optimize our application to tell the user what they actually entered incorrectly so they can correct it so instead of this generic message here which says your input data is invalid we're going to say exactly what they entered wrong so right here we're going to have if statements that check which of the inputs were actually wrong so we're going to say if is valid name is not true remember the negation with exclamation mark so if name is invalid so this translates to is invalid name in that case we're going to print first name or last name you entered is too short we're going to do the same for email and we're going to say if email is invalid or if is valid email is not true we're going to print a message that says email address you entered does not contain at sign and finally is not valid ticket number we're going to say number of tickets you entered is invalid and we don't need this generic message here and note that we don't have else here we just have if statements because we want each of these statements to be executed because they might have entered all these data wrong wrong name wrong email wrong ticket number so in that case we want to say your name is wrong your email is wrong the number of tickets is invalid if this were else if conditions like this and user had entered invalid name then this would be true and this line would be executed and the else blocks will be skipped because as i said with if else or if else if statements only one of the blocks gets executed not all of them or not multiple of them that's why we're gonna revert it back to if statements and now let's actually try to input a bunch of wrong data like this wrong email number of tickets zero and we get all of these messages it says the name is too short email is invalid and number of tickets is also invalid so now user knows exactly what they entered wrong so as you see if else statements are super important in applications because they basically control the whole application flow it's like a decision tree right we do different things based on different conditions now let's see another concept in programming which is similar to efile statements which is switch statement let's say our conference is held in six different cities and for most of the cities we have different booking processes and the data we are asking from users so the application logic is basically different based on for which city you want to book the conference ticket so at the beginning of the application we need to check which city user selected and based on that selection we then execute a different code block now if we have to check for six different cities having six if else statements may not be optimal and for such cases we have switch statements now we're not going to execute this code so i'm just going to show you the example syntax right here of how switch statements actually look like so let's say we have this city variable that user basically selects and let's say the user selected london and right here we need to check which of the six cities user wants to book tickets for so first we have the switch keyword that checks the value of city and here we have multiple cases so case one is city value equals new york in which case we want to execute code for booking new york conference tickets another case or another possible value for city is singapore and again here we would execute code for booking a singapore conference tickets in other case let's say we have london again some code here and i'm just going to copy and let's do mexico city and finally hong kong and after each case we have we need the colon so all these are possible values for city so these are where the conferences are held but as i said users sometimes enter invalid data so we also need to handle when the city has none of these values and that's going to be a default case in the switch statement so basically when none of these are true then we execute a code block which let's say prints out no valid city selected so that's like the else in the efile statement so switch just like efiles basically controls the application flow and based on a value of whatever variable we pass into switch we execute a different logic in our application now let's say the booking logic for london and berlin is the same as well as booking logic for singapore and hong kong is also the same so in this case we don't want to duplicate the code instead we want to consolidate those two cases saying if the city is london or berlin then execute this code and we can also do that in switch statement by listing all the possible values like this and this will be the same logic for london and berlin and as i said for these two cities as well like this so basically in switch statements you can also consolidate multiple values and execute a certain logic for multiple values so that's how switch statements work again let's clean this up and get back to our booking logic now our super simple application became already pretty crowded we have all this code in our main function that keeps on growing so it would be nice to start cleaning it up by taking parts of the code that do one specific thing and putting them in functions with some descriptive name so we encapsulate a code block into its own container called a function give it a name that makes it immediately clear what that code block does and use that block of code simply by calling the function by its name so let's see how to write functions in go well in fact we have already created a function at the beginning which was the main function so the same way after the main function ends right here that's the end of the main function block we create another one using a func keyword then again name of the function and let's call this one greet users and after that we have again function block using the curly braces so each function has its own block and when we call the function then whatever code is inside those curly braces gets executed like a print statement which says welcome to our conference so we have created a simple function that basically just prints out welcome to our conference now when we run our application this code will not get executed because when we create or define a function it basically just stores whatever code is inside for later use but it doesn't actually execute it for that we need to explicitly execute or call the function inside the main function because this is as i mentioned at the very beginning this is the function that go will look for to start the execution so if we create other functions we have to explicitly call them inside the main function so that code inside them gets executed and calling a function is super easy let's say right here at the beginning we want to call grid users function that will then print out the welcome message so if we run our application we have this welcome to our conference which comes from greet users function and then of course we have whatever we define in the main now let's say we want to greet users with the conference name instead of just a generic welcome to our conference so basically the same way as we're doing right here so how can we give the grid users function the value of the conference name variable which we defined here well we can pass it as an input parameter so we can hand it over to greet user's function saying here is the value of conference name variable you can use it inside your function block in your code by just passing it within the brackets but we also need to tell the function itself that it is expecting a parameter we can just throw some parameters to a function randomly we have to expect it explicitly here as well so in the function definition within the brackets we're going to define that parameter using either the same name as the variable that we're using or we can also give it a completely different name it's up to us so we can call it whatever we want and we also have to specify its type because remember variables in go have to have types so we're telling this function you're expecting an input parameter called conf name which is of type string so think of this as a variable inside a function this is very similar to doing this inside a function and that's actually what happens in the background when the function gets called and then you can use this variable or this variable inside this function block and that's what we're going to do we're going to say welcome to booking application and use the conf name value so now if we run the application and we forgot the new line here we got exactly same output as on this line so we basically extracted this code into a function so we don't need this one and let's actually put the whole greeting logic into our grid function so i'm going to take this and in the grid users function let's edit right here and the same way that we pass the conference name we also need to pass these two values because we have to have them available within the function so we have to pass them as input parameters and as i said we can call these whatever we want like conf tickets which is integer and let's call the other one remaining tickets which is u integer unsigned integer like this and of course now whenever we call this function we have to pass all three parameters otherwise we're gonna get an error like here it says not enough arguments so let's pass those two values as well first one is conference tickets this value and then we have the remaining tickets save and the error is gone so we replaced these print lines with a function call like this which makes our main function a little bit cleaner and now if we run the application we should actually get exactly the same output as before we had the function and as you see we have our welcome statement all the values are substituted everything looks fine so we extracted first group of code into a function and gave it some descriptive name that says this will greet the users now let's take the code for picking out the first names so this code block here and put it in a function called print first names because that's what it does right it goes through the bookings and it prints the first names of the people who booked the tickets so i'm gonna cut this whole thing out so here we will call function print first names and right here we're going to create that function with the name again descriptive name print first names again function block and all the code that i copied will go inside if i save again you'll see that we need some values as an input because we don't have them available here so go doesn't know where this bookings variable comes from it's not available inside this function so we have to pass it as a parameter and we're going to define it here bookings is a slice of strings so the type is going to be square brackets and string that's it and if i save this error will disappear now we have to actually call this function otherwise the first names will not be printed out so function call and we have to pass bookings as a parameter that's it we have extracted another block of code or another logic into its own function now let's say we wanted to print the first names actually in the main function so we only want to pick the first names from the bookings slice in this function but the final printing so this line here should actually be done in the main function for whatever reason so instead of printing the first names we want this function to actually just return the first names to the main function so that main can print it itself so instead of this line we want return first names so return keyword as you see the highlight here says that this function is doing some logic and then returning a result of that logic back to the main function and we have an error here because whenever we are returning something from a function we also have to specifically say that in the function definition that we are returning a value of a certain type in our case first names is also a slice of strings so that's what we're returning so note that within those brackets we have the input parameters and outside those brackets we have output parameters with a type of the output we're returning and this print line should go back to the main function and if i save this of course main function doesn't know this variable because we should get that from this function right here and let's actually rename this function now because it now doesn't print the first names it just returns or gets the first names and whenever function actually returns something to us we can save that return value into a variable and let's call this variable first names because that's what we need here equals first names is a result of whatever get first names function gives us and that's it so our function does its thing its logic it gives us a result and then we take that result in the main function like this and do something with it like print it out let's see what else can we extract here another candidate for its own function can be the user input validation so i'm going to take this logic and let's actually create another function called validate user input and again let's fix the indentation like this by now you already know how this works we need to define all the variables that we're using here we need to define them as input parameters so first name which is a string last name also a string email also a string and user tickets which is integer finally or it's actually you int and finally remaining tickets which is also you int and if i save all these errors are gone and we're going to call this function with all the input parameters we defined so we have the first name last name email user tickets and remaining tickets like this however now we don't have these three variables available in the main function anymore that's why we have these errors here because it doesn't recognize these variables and we have errors here as well so we need those three values actually available in the main function so we need to return all three values back to the main function well in most programming languages you cannot do that you cannot return multiple values from a function you can always return just one value but in go you can return any number of values you want from a function which i think is pretty cool because there are many use cases for this and it works the same way as returning just one value we just say return and we just list any values or variables that we want to return like this and of course the same way as with one return value we have to define the types the data types of all the return values in order which we do outside those parentheses and when we have multiple returns we have to also enclose them in its own separate parentheses so within this block we're going to define the data types of these three values which are all boolean true or false values so this is going to be boolean 1 boolean 2 volume 3. so again input values in the first parenthesis input parameters and then in the second one a list of output parameter types and now that we're returning these three values it's time to grab them or collect them outside here and that is also pretty easy we can just list them one by one like ease valid name is valid email is valid ticket number save and there you go now all these three variables are available in the main function so the errors are gone so let's check our code we have these three functions that we created and our main function got smaller and maybe more descriptive now let's also extract the code for getting user input in a function so i'm going to grab this whole code tool here and save it into a separate function and let's call this get user input fix the indentation and as you see get user input function doesn't need any input parameters because we're asking for input from the users so we don't need anything from the main function however inside the main function we need those values because we're doing all the processing based on whatever user entered right so we have to actually return all these input data back to the main so return first name last name email and use the tickets and again we have to specify the types of those right here so first name last name email and user tickets and in the main just like we did right here we're gonna grab those values one by one so we have the first name last name email and user tickets and if i save this you see all the errors are gone because now we have these four values available here as well and finally let's take the code for booking the application actually this whole logic here and also put it in its own function and logically we're going to call this function book ticket and if i save you see a bunch of errors because we don't have these values available here so we need a lot of input parameters for this function so let's define them one by one remaining tickets user tickets bookings which is a slice of strings we have the first name last name email and finally we also need the conference name which is also string and if i save it all looks fine when we call this function in the main so this is where book ticket happens we're going to pass all those defined parameters which is a long list of values now here you may be wondering if i have to pass so many parameters to my function does it make my code cleaner that's a lot of repeated code because we're passing all these same values and parameters to different functions so to reduce this repetition a bit we can define variables that are shared among multiple functions so variables that are accessible both for main and other functions as well without having to pass them around like this so it makes sense to create those variables in a place that lets multiple functions including the main have access to them and these are called package level variables and these are variables defined outside from all the functions so instead of defining these variables inside of the main we're going to take them and instead define them outside on a package level like this and now they're not only accessible to main but also to all the functions in this package now if i save this you see we have two errors and that is because the package level variables cannot be created using this syntax they need the syntax with var keyword so if i save this you see the error is gone we'll do the same here and that's it we can also take the put the constant at the top like this so now as i said we don't have to pass those variables to other functions from main because these functions also have access to them directly so in the grid users function for example we were passing three of these variables as parameters now we don't need this anymore because grid users can access those variables directly so i'm going to delete this and save and we have an error because now the names of the variables have to be exactly what is defined here right so conference name like this conference tickets and that's it we have no errors and no need to pass those values as input parameters again makes the function execution much cleaner we also have the bookings array which is defined on a package level so we don't need to pass that here as well so i'm going to remove this from get first names and remove these here as well again everything works same thing right here validate user input we're passing it remaining tickets as a variable which it doesn't need anymore but it still needs those four variables obviously because they are still created in the main function and not available directly outside so let's go to validate user input and remove this last parameter and finally our book ticket function that has this long list of parameters we can get rid of remaining tickets bookings and conference name as parameters because they are all defined here so remove this one and if i save everything looks fine again now you may be thinking why not define all the variables at the top right here and then make them accessible everywhere in our functions well this would be a bad practice because generally you want to define a variable as locally as possible so basically create a variable where you need it so if you need a variable only inside a specific function or a specific block inside the function then you should define it there so now if we look at our main function you see that the code is way cleaner we have descriptive function names that basically tells us what exactly is happening within the main function we're greeting the users then we're getting their inputs we're validating that input and if everything is valid we're booking the ticket then getting the first names and printing them and if the remaining tickets is zero we just end the program and all this logic that was basically crowding the main function is now encapsulated in its own small functions now let's actually test that everything still works fine and there you go we have the thank you message the ticket number got updated correctly and we have the first names of the bookings printed here so everything works same as before now in addition to just cleaning things up functions have another important purpose which is that same block of code can be reused in many different places in your application by calling the function name just like variables where we define something once and reuse it hundred times so for example if you were hosting 10 conferences at the same time and needed to ask for and validate user input you can reuse that code for all 10 conferences instead of writing that same logic 10 times now we've been working in one single file this whole time so you're maybe asking what if i'm writing a more complex go application with a lot of logic so do i put all the stuff in one go file or how does it work can we create multiple go files that all belong to the same project well remember at the beginning i said that go is organized into packages and the package is a collection of go files which can be one file or several files and we already have one package that we called main which we created and we also have one go file for that package which we called main.go now if our code got larger we can split it into multiple files so for example if we had 10 different conferences for which users could book the tickets on our application we could create own files for each conference booking plus if we had multiple files where we defined bookings for different conferences we might have code that is shared by all these files so we may need the same functionality in all 10 conference bookings for example we might need the same user input validation in all our files so we could have a separate file for such shared functionalities as well and all these files could belong to the same package so to demonstrate that i'm going to create a file here and let's call it helper.go or we can also call it common or shared.go and this can include functions that are helper functions of the main application again as an example we can take user input validation the first thing we need to define here is which package this go file belongs to and we have the main package that we created and we want this file to also belong to that main package so that's one thing we need to define in each file and then we basically just need to put some functionality here or list of functions that we can reference from other files again if i had 10 different files here that all share the functions right here we can basically define them here in helper go and then reference it from everywhere so i'm gonna grab validate user input function from here and i'm going to put it into a helper dot go file so we're basically splitting our code into multiple files of course we need to import the strings package here because we're using it and if i save this everything is errorfree in helper.go as well as main.go so basically it is super easy to divide your code up into multiple files that all belong to the same package because we're referencing this validate user input in the main dot go file right here and it knows exactly that this function comes from the helper dot go file now we want to validate that everything works and run our application however if i run my application like this with go run main.go and execute you see that it says validate user input is not defined on line 21 so right here so this function is not defined and that is because we need to now run the application with all the files that belong to that application so now we have main.go in helper dot go so we have to provide both files to go run command and now if i execute everything works again and let's add some invalid input here to make sure the validate user input also works and as you see we have the messages about wrong user input now of course if you have tens of files here in your application it's not very convenient to have to pass them one by one to go run command so as an alternative you can just specify a folder location from which you want to execute the files so all the files in this folder will be executed and dot specifies the current folder which is the booking app so we're telling go to run application with all the files in the current folder and again it works fine so that's going to be a better alternative of course if you have multiple files in your go project so now we have this helper.go file that belongs to the same main package however we could actually organize our application code into multiple packages so in addition to the main package we can have other packages that all belong to the application so what could be a use case for that let's say we have an application that handles booking for 10 different conferences and the booking logic for each conference is almost completely different in that case we could actually create own packages for each of the conference and put the booking logic there and plus let's say they share some common logic like validating user input and that could also be a separate package that all other packages may share so basically these multiple packages helps you organize your code and group the logic in a way that makes sense for your application so this is a way to logically group your code so let's say in our example we wanted to put this helper functionality in its own package and let's call this package also helper when we have multiple packages we should actually create folders for them and then put all the files belonging to that package in that folder so i'm going to create a folder called helper and put the helper.go file in that folder again this helps organize our code and basically visually represent the separation as well now of course we need to make a couple of adjustments for our application to work again the first thing is if we go to the main dot go file right here where the function is being called you see that it says undeclared names because go doesn't know this function anymore it doesn't know where it's coming from and that's why it says undeclared name so while this function was in the same package go was able to find it without a problem but now that we've moved it to another package it is not recognized anymore in the main package and remember at the very beginning i said that whenever we need to use a function from another package in our main package we need to explicitly import that package and then we will be able to use any functions inside that and that applies to the packages that we create ourselves so the first step will be to actually import the helper package in our main package if we want to use any functions defined inside right here now the question here is can we just import it using its name like this helper well just writing the helper the name of the package is not gonna work because go will try to look for a helper package in one of its builtin modules but this is actually our own package so we have to explicitly tell go hey this is actually a package in our application or in our module so remember this go.mod file that we initiated at the beginning this mod file or module file actually defines the name of the module which we called booking dash app which is also an import path for all the packages defined in this module so if we want to import a helper package inside the main package we have to use the booking app the module name before as a path so now we are telling go import the helper package from our booking app module and if we hover you see that it was able to find that package now we just get an error because we're not using it so how do we use a function from another package simply using the package name dot function name just like we've been doing this whole time so helper dot and then name of the function now there is one more thing we need to do for this to work and right now you see that we have an error that says validate user input or the name of the function is not exported by package so what does this mean whenever we want to create a function in a package that can be used in another package we have to explicitly export that function so it can be imported in another package so exporting basically means we want to make this function available for use in other packages and many programming languages have this concept of exporting functions to make it available for use in other places and they all do it in different ways in go the way to export a function is actually pretty easy we just capitalize the name of that function like this and that's it this simple change in the background will actually export the validate user input function so let's save it go back to main and adjust the function name here and you see the error is gone and now we are able to use that function from another package in our main application and you probably also noticed before that whenever we were using a function from an imported package like fmt or strings or whatever we were using that function name with capital letter right so all the fmt package functions start with capital letter we have printf with capital p print ln here we have strings.fields with capital f so that is the same concept right here these are functions that have been exported in these packages and that's why we're able to use them and by the way you can not only export functions from other packages but you can also export variables also by capitalizing the variable name so for example if all the conferences had the same number of tickets available you could define that in this helper package as a variable and then export it simply by using a capitalized variable name and finally we have an error here because remaining tickets variable is not available anymore for this function and that's again because we move this function from a main package and main package right here defines a package level variable called remaining tickets which is only available within the package main that's why it's called package level so it's not visible to other packages again as i said we could export this variable using uppercase in the name but in our case we will just pass the variable as an input parameter so let's do that validate user input and of course we have to also edit in the function specification and remaining tickets is of you int type and that fixes last issue and our application should work again so if i execute the application everything works fine again and one more thing that i want to note here is all the places we have created variables first of all we have created variables within individual functions which made these variables available only within those functions so these are basically what's called local or function level variables we also created variables that were available only within a specific block of code like right here so this names variable it only exists within this for loop so outside that even within the function the variable names does not exist so you couldn't use it outside that for loop it's undeclared then we saw how to define variables on a package level so that multiple functions can access it directly so we define them right here and finally i mentioned that if we have variables that we want to share across packages then we could create what's called global variable using a capitalized variable name and the concept of where we create variables and where we can use them is called variable scope okay so we have split our application into multiple packages and as i said with multiple packages you can organize your code more logically now for the simplicity we're going to revert our example back to helper.go being in a main package and continue with the rest of the demo examples from that state great now we have organized our code a bit we have cleaned it up with functions we have divided our code into multiple files and so on but there is one thing we want to optimize in our application right now whenever user completes a booking we're saving only their full name in the bookings list but the email address and the number of tickets they provided during the booking just get ignored and thrown away we're not saving them but we would like to have that information also saved for each user on the list of bookings maybe to send them information via email in the future or during the event to kind of validate how many tickets they have booked now bookings in our case is a slice which allows us to save a list of string values which are the full names but instead of just a simple string like this we want a data type with multiple key value pairs per user so something like first name and its value last name and its value email and number of tickets so instead of a list of these type of values we want at least of this kind of data block for each user and the data type that will allow storing multiple key value pairs per user is called a map so a construct a data type that basically lets us save information about user like this is provided by map and map is a common data type in many other programming languages as well so for each user we will have a map with key names like this and their respective values which of course will be different for each user so let's see how we can turn our bookings list from a list of strings to a list of maps first of all let's go to the book ticket function where we're adding users first name and last name to the bookings list and right before that we're going to create a map for a user and as i said map is a data type so just like with any other data type we need to create a variable of an empty map and we're going to call this let's say a user or user data now how do we create a map first of all we have a keyword map and then we have to define types for the key and a value as i said map is a collection of key value pairs and for each one so for the for the keys which are first name last name email etc we have to define what data type they are and we also have to define the data types of the values and of course these two can be different the keys in the map may be strings and the values may be integers but in our case we have strings for both of them however this only defines the type of the map right just like we have a type of a slice right so this is this is a type of a slice we have a type for a map which is this one right here so this is only a type what we actually need to do is create an empty map and we see that in the error as well it says type definition is not an expression so we need an expression which is creating an empty map and to create an empty map we have a builtin function called make if i save now i only get an error that user data is defined but not used so that will give us an empty map so map creation is done as a next step we want to add all the user data we have available to this user data map how do we add data key value pairs to a map very simple actually we have name of the map and the square brackets syntax that you already know from arrays and slices and inside that we have the key name which is first name and the value to that which is the value of the first name variable so that's the first key value pair that we're saving into user data map let's save another key value pair which is last name and again value will be a last name variable which we get from the user input and we have the email which also comes from variable called email so now we have added three key value pairs to user data map so the key names are strings as we defined here and the values are also strings as we defined here and note that you can call these key names whatever you want so this could be a b c it doesn't really matter right but of course you want to have some descriptive names which tells you what this key actually refers to okay now the fourth data we have is number of tickets but the user tickets value is a uint it's not a string right so the value type is not a string and in go specifically as we saw here map can only have the same data type as keys and the same data type for values so we cannot mix different data types as values again specific to go because in many programming languages you can actually have mixed data types in a map just like in a slice where we also have to have just one data type which is again specific for go because in many other programming languages you can actually have mixed data types so what do we do here how do we add the user tickets value in our user data map well an easy way to handle this is to convert the user ticket's view integer to a number character so basically if user bought 30 tickets instead of 30 like this we're gonna have three zero as characters and that will make it a string and this type of conversion there is a builtin function in go called format uiint and this function comes from a package called string convert or scr conf stands for string conversion and this package basically includes different functions for converting strings to and from other data types and one of them is converting uint to string so of course we need to pass in our uiint value so that it can be converted to a string and we do that by using another builtin function called uint64 which is for a uint 64 data type so that's the value we're converting to a string like this and then we have to pass another input parameter here which stands for decimal number base 10. so now you don't need to understand every part of this conversion but shortly explained format unit function takes our u int value which may be anything 1 to 50 and formats it to a string as a decimal number and 10 is for base 10 which represents decimal numbers so another example would be 16 for example that represents hexadecimal numbers so that's what's going on here again no need to go into details here because usually if you need these type of conversions in your code you would either check out the official documentation of go or you will just google it and see the example code for that so you don't have to memorize this kind of conversions so as a result this will actually give us our user tickets in string format and we can then save it into our map and this is going to be a key name for that which we can name whatever we want i'm going to call it number of tickets and that is going to equal to this and of course we shouldn't forget to import the string conversion package like this and everything looks fine cool so now we are creating a map for each user because this book ticket function gets executed every time a new user books a ticket so the map is getting created and all the user data gets saved into that map so now we need to actually take that map with all the user data and add it to the bookings list right now we have a slice of strings as bookings so first we need to make bookings variable into a slice of maps so what i'm going to do is i'm going to copy the type of this map and right here instead of the string type i'm going to set a map type so we're having a list of maps and not anymore a list of strings now this curly braces was used to create an empty list of strings however it doesn't work anymore for maps so we need to actually create an empty slice of maps and the syntax for that is at the beginning again the make function that we use to create a map like this note the comparison between the two make calls so here when we created a map we have a type of the map and we wrap it into make function and that creates an empty map here we're not creating an empty map we're creating an empty list of maps that's why now we have the brackets before the map and when i save this we're going to have an error because this time because it's a list we need to actually define a size or initial size of this empty list and because slices are dynamic this is going to be the initial size and it will expand automatically as we add new values which means the size the initial size can be 1 or even 0 because it will increase anyways when we add new elements so with this syntax we're initializing a list of maps and finally as the last step going back to our book ticket logic we of course want to add instead of adding first name plus last name in our bookings list we want to add user data map and save there you go so append stays the same because it's a slice again but instead of a string we're adding now a map to our list so now we have a bookings list which contains all user information as key value pairs we still have an error in our application which is right here where we are going through the bookings list and grabbing the first names from each element which is logical because in this code we are treating the element of the bookings list as a string and not a map which obviously has changed so we have to change the logic here as well so now each booking elements or the value of this booking variable is a map with the key value pairs for first name last name email and number of tickets so it's actually now easier to extract the first name from the map by simply using the key name which we called first name and that's it so this will give us a value of the first name we don't have to split a string or do anything here and we can also use that directly right here and save and that's it so again in our bookings list we have maps for each user with different data one of them being first name so we can grab the first name value from each map using this syntax and then edit to the first name slice so that fixes the issue and finally as a great feature of go we're reminded that we're no longer using the strings package so we should get rid of it and no more errors in our application so now we can run our application to make sure everything works perfectly plus to also check our changes that we store the complete user data in the bookings let's also print out the bookings list of maps after every booking let's see list of bookings is i forgot the new line and there you go so after the booking we have a list of bookings which is a slice you see with the brackets and inside that we have one map because we just have one booking and this map contains basically these key value pairs for email first name last name and number of tickets divided separated by columns and let's try another one and now our list of bookings has two maps like this and the printing of first names also works fine now let's say we wanted to collect different types of data on users for example we asked for their date of birth which is a date value type or we asked a user to opt in for a newsletter and we would save that information as a boolean data type like is opted in for newsletter we may even want to save lists associated with users like let's say a manager books tickets for her team and we would like to know names of these team members to know who will attend the conference so for this user we can save a list of team members they will bring with them and this would be an array or slice of attendance names if we wanted the team members email addresses in addition then this would even be a slice of maps where each map will hold the name of the attendant and their email address so user entity would have all these data of different data types associated to it we may also have other entities in our application like a conference which will have its own data associated to it like in which cities the conference is held on which dates it is hosted how many people are attending etc again values of mixed data types and as we saw in the previous example maps in go limit values to only one data type that's why we had to do this type conversion to save number of tickets for a user as a string instead of uiint so how can we save mixed data type values for an entity like a user or conference in our go application well for that we can use what's called a struct in go which stands for structure structs or structures let us define key value pairs for an entity like user but with mixed data types so let's see how we can create a struct so right here outside all the functions on the package level we're going to create a struct first of all we have a keyword struct and it's block with curly braces and within the block we define the list of keys like first name last name email and number of tickets like this note that we're not using quotes here and for each key in the struct we also have to define the type of the value right so instead of having one type for all the values we can choose different type for each value so the first name will be a string the last name will be a string email will be a string and number of tickets will be you int again if we had other data types like a boolean for is user opted in for news letter we can basically add them right so we can have mixed data types for the values but our struct is not done yet first we need a name for our struct which in our case can be a user data for example and finally at the beginning we have to create a struct using type keyword like this this actually means that we're creating a custom type in our application which is called user data another very important advantage of structures over maps is that in addition to just being able to specify these mixed data types the structure gives us this custom type like user where we can define exactly what user type should look like so what properties it should have and with map we just have an empty list where we can just put whatever we want so structure allows you to create a predefined structure by listing all the properties that it should have so here we are defining the structure of our user type and that a user has first name last name email and number of tickets and if you know object oriented languages like java struct can be compared to classes in those languages so we're creating a custom data type called user data with these properties associated to it great so now let's go ahead and use our user data structure instead of the map so first of all we're going to change our bookings from a list of maps to a list of user data structures so we're going to grab the map type and we're going to replace it with user data struct type like this nicer syntax everything else stays the same so this line basically now creates or initiates an empty list of user data structs now of course we also have to create the user data struct instead of the map in the book ticket function so let's scroll down to here and the user data instead of creating a map here we're going to create a struct like this the name of the struct and curly braces and inside that we are going to set the values for each property or each field name so first name is going to be the name from the first name variable in this case they're called the same but of course could be different values then we have the last name field of our struct and the value will be from the last name variable email same here and the key name for user tickets like this and the value called user tickets and when setting these values we have to separate each line using a comma so at the end of each line so this will give us a user data object with all the user data so we don't actually need any conversion from you in type to string as well as we don't need these lines here so let's get rid of it and again our code looks a little bit more cleaner and a reminder from go that we don't need the string conversion package anymore so let's remove that as well and finally as the last fix because we still have one issue which is right here getting the first names because now we are accessing the first name with a syntax for map but a booking variable is not a map anymore it's a struct and to get values from struct basically we use a syntax with dot and as i mentioned a big difference of structures of our maps is that it gives you a predefined structure so now when i type dot after a struct element go actually gives me suggestions property names that destruct has and i can just choose one like this but also if i actually misspell a name of the property of a struct go can help me identify this error even before running the application and this is because we have created a real type with a structure in which the go compiler knows the associated properties so as you see when working with structs the syntax is simpler than with maps so our code looks cleaner and less messy awesome so that's basically the final result of our code we're also using just one package here so we can remove the parentheses here and again we can test our application and in the output you see the line where we're printing the list of bookings which is now a list of structs this is how it looks like so we have a slice with square brackets and inside that we have one element which is a struct with a nice short output and again if we add another user booking like this you see one struct and another one now let's say after user books at ticket we want to generate that book ticket and send it to the user per email address that they entered so let's create a function called send ticket that generates a ticket and then sends it per email and we're just going to simulate this logic with a simple code and to simulate generating a ticket we're just going to put together a string that basically says this is a ticket for a certain user so let's use a printf so we're just printing it out and let's say this many tickets for first name last name of the user and let's add them here if i save this of course we need to pass those variables as input parameters right so we can use them in a function so i'm going to define them all here i'm actually just going to copy this and then just add types so we have uint string and another string like this now let's say instead of just printing out this string we wanted to save it into a variable called ticket that we would then send per email and that may be another useful example that you may need in your applications to basically save formatted strings in a variable instead of just printing them out now if i do variable ticket here and save it you see that i get an error because this doesn't give me the formatted string back it just prints it out to the console and it doesn't return string for that we actually have a different function from the format package which is called s print f and if i save this you see that now we just get an error because ticket is declared but not used so this function basically helps you put together a string just like in the formatted output here but instead of printing it out you can save it into a string variable so we have simulated the tick generation and now let's simulate sending it per email in this case we're just going to use a print statement which says sending ticket and this is the ticket to email address and that's an email address so we have the ticket so here we substitute the ticket itself so this string that we put here together and the email address and now we have to add email address also as input parameter so we can use it here and let's do a little bit more formatting so we can see the ticket part really well so i'm just going to do column here and let's print the ticket on a new line like this let's put a new line here as well and i'm also gonna add some visual divider for the ticket sending logic before sending the ticket and afterwards and that's just going to be simple visual divider something that we're just going to notice immediately like this println there you go so this basically just simulates with simple code a logic for generating a ticket and then sending it to email after user booked the ticket so i'm going to take the name of the function and we actually have to call this right so in the main function right after book ticket gets executed we're going to call send ticket and this expects the variables which are actually the same as here right so we have user tickets first name last name email just like we defined it here awesome so our application is ready let's now actually run our application and see that this output gets printed out and there you go so we have 45 tickets remaining which is in the book ticket function and then send ticket gets executed it starts right here and we are saying sending tickets this is the string we put together how many tickets the user bought and the username last name to email address they gave us awesome everything works fine now let's say that generating the ticket and then sending it per email actually takes some time it's not a fast process that we simulated here some data needs to be processed in the background so if we had a real code that really generates a pdf of a ticket and then sends it using an email client to an email address it would actually take some time right it would not be this fast so let's say it would take 10 seconds and we're also going to simulate this 10 second delay using a function called sleep from a time package and in a slip function we're going to say how long it needs to sleep so 10 seconds again the second unit is in the time package and we of course have to import it time and there you go so now whenever this function gets called we're simulating that something happens here for 10 seconds so in this case it's just sleeping and after 10 seconds this code gets executed and we're going to get the summary so the sleep basically just stops the execution of the thread for 10 seconds that's what we're doing so now with this change let's run the application now and see what happens or see how application can handle this kind of time delay so i'm going to clean this up let's run input the data and as you see i didn't get an input enter your last name and if i type something here the application basically is blocked and now you see that after 10 seconds were over this got printed out and now application became responsive again and now it's asking me for inputs for another user right let's do that again and again you see it's stopped here and now whatever i input i don't get a feedback from the application i just have to wait until this here gets printed out or this gets completed so the application is being blocked while this code gets executed and once it's done then we can continue to another booking now if this was an application that should handle multiple bookings of multiple users then this would not be an optimal performance right and that's why we need concurrency in applications and as i mentioned at the beginning the main advantage of goal programming language is the simplicity of coding concurrent applications so we can make our application concurrent in a very easy way in go compared to other languages so what would concurrency mean in this case well our application runs in a single thread right when go starts executing this main function everything that you see here will be executed from start to finish in a single thread which means all code lines get executed one by one in this order in our single threaded application and that means if one of the lines like this one here takes longer the execution in this thread is blocked so the next line gets executed only after this one is done doing its job so this has to wait those 10 seconds until it gets executed but to optimize this instead of just waiting for a certain code line to finish when we know that something takes longer we want to start a separate thread for it and execute this logic in a separate thread so break out of the main thread and do this in its own separate thread so now instead of waiting for 10 seconds to run the next line after the function the application executes it gets to this point it spins off a new thread pushes the code execution there and it immediately continues to the next line so there's no waiting or blocking here very simple concept actually and that would mean in our application that while the ticket is being generated and sent to the user who just booked the ticket we can continue to the next booking for the next user without any interruption when the second user is also done booking her ticket then again the iteration will come here and again it will spin off a new thread to generate the second user's ticket and send it per email and so on so basically if 20 users book the ticket at the same time 20 new threads will be created each one will do its job and once completed the thread will be deleted and this whole time the main application flow will continue without any interruptions all right now that sounds all cool but how do we create those threads and make the code in this function so the centicade function run in that separate thread how do we do that well we just write go in front of it and that's it we just made our application concurrent with a simple go keyword and this keyword basically abstracts away the whole thread creation and cleanup and all these for you so you as a developer don't have to worry about this so now let's actually go and test it i'm going to save it clean up and input our data and now when i click enter i should be immediately prompted for another user's booking so enter and there you go it asks me again for enter your first name so let's continue and while i'm actually typing we see that at some point the ticket creation logic was completed and i see the output here so even though it printed out the text in the middle of my user input it doesn't actually interrupt the application flow so here i have dot com and then continue with user tickets and again i can go on to the next user booking and again at some point the second ticket is done and it gets printed here and the user would be able to basically continue their booking without problems so as you see everything works great and we have improved the performance of our application with a simple change in our code and this means now even if the ticket generation took five times longer or ten times longer the main application flow would be unaffected by that and the users will basically get their tickets per email a little later which is also not an issue and to demonstrate that i'm gonna actually put that timer to 50 seconds instead of 10 and let's execute again so basically i have simulated booking for three different users the ticket for the first user is not done yet but we can keep booking new tickets and at some point after the 50 seconds are over you see the output for the first user and the second user and finally for the third user so our application stays responsive no matter how long this code actually takes to execute now let's see one more thing about concurrency in our applications let's say we did not have a for loop here that keeps on asking for the new booking which means once the booking is done the main application would exit there is no next iteration here so i'm going to remove this for loop and save it we don't need a break statement because there is no loop so basically our application only allows for one booking so let's run our application and see what happens with the booking logic so we entered our data the summary got printed out thank you message how many tickets are left and the first names but there is no ticket generation output here so all the code in here send ticket that prints out this three lines we don't see them in the output because they never got executed so the application exited before this function was done and this means that the main thread does not wait for any additional threads to complete or even start when the main thread is done the application is done as well so whatever is happening in the other threads are basically getting terminated and ignored so how can we fix this because obviously we want to send the user their ticket right well for that we need to tell the main thread that it needs to wait until this thread is done doing its job and for that first we need to create what's called a weight group so outside the main function right here we're going to create a weight group with curly braces and this comes from a sync package and we can then save the result into a variable called wg or weight group and of course we need to import the sync package and there you go and weight group has three functions which we can call using this variable so on wg right before we spin off a new thread we're going to call the first function which is called ed and this function adds a number of threads that the main thread should wait for and should be executed before creating a new thread and in our case we have one new thread that we are adding so we're gonna put one here so if you had another go do something else function here then you would put two another function that we have the second function of weight group is called weight and it needs to be executed at the end of the main thread so as a last line of the code we're going to do weight and this basically waits for all the threads that were added right here to be done doing its job before the application can exit so this just waits until this one is done and the third function is called done which gets executed in the function that runs in a separate thread so incenticate and at the end of the logic when everything is done we're going to call weight group done so done function removes the thread that we added right here from the waiting list it's basically saying to the weight group i'm done executing so the main thread doesn't have to wait for me anymore so the add function is increasing the counter of threads that the application should wait for and done is decreasing that counter so when the counter is zero which means the main thread has no threads to wait for it can exit the application so this doesn't have to wait anymore so now with these code changes let's run our application again and we should see the ticket being printed out before the application exits so the summary got already printed out now it's just waiting as you see it's not exiting it is basically waiting for those 50 seconds to be over and then we'll execute these lines of code and you see the output of sent ticket so this time the application actually waited for this separate thread to be done executing its logic and once this was printed out as you see the application exited now you may be thinking you can surely implement concurrency in other languages like java right which is true but in other languages that support concurrency we have two differences with go first of all writing code for concurrency in those languages is way more complex and you have more overhead for the initial configuration and second creating threads is more expensive which means it takes longer to spin off a new thread and it also needs more memory space allocated to it now what is the reason for these differences or what does go actually do better or more efficiently well in go when we create a thread go actually spins off what's called a green thread green thread in go is an abstraction of an actual thread which is an operating system thread and it's called a go routine so with gold keyword we're actually creating go routines so in go we are only interacting with these high level goal routines instead of the lowlevel operating system threats and an advantage of working with this threat abstraction is that first of all it's cheaper to create it's more lightweight and takes little memory space so each time you create a thread you actually have way less overhead and that means you can easily create and use thousands or tens of thousands of threads pretty fast which in other languages is normally not possible without affecting the application performance so in comparison other programming languages like java that i mentioned use operating system threads which again need more memory space more time to create and that's why in these languages sometimes we have concepts like thread pooling to optimize working with threats and one last difference is that in other programming languages threats do not have an easy communication medium or way to talk to each other in contrast go routines has a concept of channels which is a builtin functionality which allows easy and safe communication between the go routines and this is a functionality that helps you handle concurrency issues which are issues that may occur when threats have shared data or are dependent on each other now we're not covering this in this beginner tutorial because it's a more advanced topic but it's an important one so i will include it in my upcoming go course congratulations you made it till the end so what do you think about go have you already used it in one of your projects share your thoughts in the comments section of the video now in this beginner course we built a simple cli application without persistence but learned a lot of the main goal concepts but of course in real life this would be a web application with a ui and a database connected to it where multiple users can book their tickets at the same time and the bookings will be persisted in a database so if you want to take your go skills to another level and want to learn more advanced concepts in go i'm actually going to create a go course where you will learn to build exactly this kind of application with go if you want to be notified when the course is out then check out the video description for a sign up link or if you're watching this video by the time the course is already released then you will find a link to the course itself and with that thank you for watching and see you in the next video
