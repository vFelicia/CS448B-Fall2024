With timestamps:

00:00 - In this video we're going to talk about a 
relatively new hot topic in DevOps and Cloud  
00:05 - space, which is “platform engineering”. 
There is a lot of discussion going on,  
00:10 - where some people are asking whether platform 
engineering replaces DevOps. Many people say  
00:15 - it goes hand in hand and is rather an addition to 
DevOps, but in reality it's a bit more complicated  
00:21 - than that. Platform engineering actually changes 
a lot of established rules we knew about DevOps,  
00:28 - SRE and Cloud engineering, it changes the game 
and introduces some new rules. So let's clearly  
00:34 - define, what platform engineering exactly is, 
more interestingly, why was there even a need  
00:41 - for this new role and how it evolved and of course 
how it compares to DevOps and Cloud engineering  
00:47 - and does it really replace any of these roles? 
Whenever a new role or concept appears, the first  
00:55 - question should always be: Why was there a need 
for it? Because there must be a problem behind,  
01:01 - that couldn't be solved with existing solutions 
and naturally caused the evolution of this role.  
01:06 - So let's talk about these problems that led to 
emerging platform engineering as a solution.  
01:12 - Initially we had developers and operations working 
in separate teams and developers were responsible  
01:18 - for programming the application. And when ready, 
they would throw the packaged application over to  
01:25 - operations, who was responsible for deploying 
and running that application. So while you had  
01:31 - a dedicated operations team with expertise to 
properly manage the infrastructure or operate  
01:37 - company-wide CI/CD platform for example or other 
platforms for the application teams, this was  
01:45 - an inflexible and slow process with developers 
waiting on operations when they needed any change  
01:53 - in infrastructure or needed any infrastructure 
resources like additional servers or Jenkins  
01:59 - pipeline for their applications. Or on the other 
side operations team waiting on developers to fix  
02:06 - something in the application that affected the 
deployment or application runtime etc. So when  
02:11 - DevOps was introduced it united those teams 
removing the inflexible and limiting process.  
02:18 - So it removed the communication challenges 
and knowledge silos between these two parts,  
02:24 - developing application and running and operating 
the application. So this was a huge improvement  
02:30 - to the traditional way of working and this led to 
one DevOps team that now owns the application as  
02:38 - well as the underlying runtime and infrastructure. 
So basically the application itself and everything  
02:45 - the application needs to run. And this is way more 
flexible, fast and just a cool way of working for  
02:53 - the engineers, but with lots of options and 
ownership comes a lot of responsibility and  
02:59 - cognitive load. Now you’re having one DevOps 
team, everyone developing the application and  
03:05 - running the entire stack under the application, 
so you have one team where either developers or  
03:11 - a dedicated DevOps engineer is setting up a 
CI/CD platform and creating the pipelines,  
03:17 - writing Terraform scripts for infrastructures 
code, spinning up Kubernetes clusters, configuring  
03:23 - the cluster with best practices, configuring 
logging and monitoring, adding security scans,  
03:28 - maintaining Helm charts, also maintaining all 
these infrastructures code scripts as the tools  
03:34 - evolve and new versions come out, right? Managing 
Docker repositories and all these in addition to  
03:41 - the actual application development, this is 
why we are even doing all these other things.  
03:45 - And this increases the flexibility and speed of 
work and efficiency, but naturally it also adds  
03:52 - tremendous cognitive load on the team, because 
too many things that just few roles need to be  
03:59 - responsible for. But it goes even beyond that. 
Now imagine you have another application team  
04:04 - developing a completely different application 
and they have the same challenges and tasks.  
04:10 - So to increase their efficiency a DevOps engineer 
designs the same CI/CD workflow for the project,  
04:16 - sets up cluster, maybe this time a managed EKS 
service instead of self-managed one, configures  
04:23 - all integrations with AWS cloud, configures 
the storage, adds security scanning steps,  
04:29 - monitoring the whole secret management and so on. 
Maybe they use a different Docker repository like  
04:35 - ECR for an easy integration with the EKS cluster. 
So they have the same challenges and same needs  
04:42 - for their application to run somewhere, so they 
do all this stuff in their own ways with their  
04:47 - own tech stack, right? And maybe you have 
10 more such teams in your organization,  
04:51 - now all of them need to figure out all these 
things for their projects. So you end up with 10  
04:58 - DevOps teams building and operating 10 different 
platforms to deliver and run their applications,  
05:05 - and this can be hugely inefficient and wasteful 
as well as have high cognitive load on individual  
05:12 - engineers in those teams. And with complex 
systems like Kubernetes, sometimes the part of  
05:18 - managing infrastructure becomes more effort than 
writing application code and producing business  
05:25 - logic itself. So you have teams that are too busy 
building a platform and have less time to build  
05:31 - the business value in the applications. Plus 
you need expertise of so many things within a  
05:39 - single team if they have to manage the entire 
infrastructure stack underneath the application,  
05:45 - which means many experienced engineers to add 
to many teams, which naturally also means higher  
05:52 - human resource costs, right? And finally this 
becomes hard to scale, because each new project  
05:58 - team will have the initial time and effort in 
setting up the infrastructure before they can  
06:05 - even release the application to the end users 
and very very important Point even though you  
06:10 - have these teams managing their own infrastructure 
and platforms they may actually not have enough  
06:16 - expertise to do everything correctly so you may 
end up with Kubernetes misconfigurations or lack  
06:23 - of monitoring and logging entirely or security 
issues all over your systems plus when you have  
06:30 - one compliance or security team in the whole 
company and tens of teams with 10 completely  
06:36 - different Tech stacks and just different different 
ways of running their applications it will be  
06:42 - pretty hard for them to get insights and help 
all these teams Implement proper security because  
06:48 - it will be really hard for them to understand 
what's going on in all these individual projects  
06:53 - so this becomes hard to scale because we have no 
standards also when each team uses different Tech  
07:00 - stack with different configurations this leads to 
inconsistency across the organization and finally  
07:07 - I want to mention that the concept of you build it 
you run it which we know from the SRE was created  
07:15 - back when applications weren't as complex as today 
and the underlying environment for running the  
07:21 - application wasn't as complex either so in today's 
highly complex multi-cloud multi-cluster or hybrid  
07:30 - Cloud world with thousands of microservices and 
hundreds of services for those microservices  
07:35 - it's a bit too much to ask developers to integrate 
this concept in their work like asking an expert  
07:43 - front-end engineer stop your work and focus on 
properly configuring Kubernetes cluster is not  
07:48 - really cool and not the most efficient usage of 
that engineer's skills so to quickly summarize we  
07:55 - either have autonomous DevOps teams going wild and 
doing whatever being fast and flexible but also  
08:02 - leading to too much responsibility on one team 
with high cognitive load and organization-wide  
08:09 - inconsistency or we have the traditional separate 
Dev and Ops where infrastructure is managed and  
08:16 - secured but with a painfully slow process that 
really limits the work of developers and that's  
08:23 - where platform engineering comes in to save 
the day but only when implemented correctly
08:33 - So how does platform engineering solve these 
problems platform Engineers take the tools  
08:39 - that are needed for deploying and running the 
application and standardize their usage across  
08:46 - teams so if 10 teams use 10 different CI/CD 
solutions make a standard CI/CD offering or  
08:54 - if every team uses Kubernetes but in different 
ways standardize usage of Kubernetes so basically  
09:01 - platform Engineers standardize everything 
that is part of applications non-functional  
09:08 - requirements so what are the things that we need 
or the so-called non-functional requirements of  
09:15 - the application so basically things that 
are not business logic but necessary to  
09:20 - deliver the application to its end users well 
first of all every application needs a Version  
09:27 - Control System every application needs SCI 
City pipeline the application needs to run  
09:33 - some somewhere like on a runtime environment 
like Kubernetes Kubernetes cluster of course  
09:38 - needs an underlying infrastructure like AWS 
Cloud platform or even a multi-cloud platform  
09:44 - the application and the underlying infrastructure 
also needs logging and monitoring the application  
09:50 - also needs proper security so as you see there's 
a lot of things going on that need to be set up  
09:56 - for the application to run properly and each of 
these categories have lots of different tools  
10:02 - and Technologies right there are loads of CI/CD 
platforms out there there are different Cloud  
10:07 - platforms and so on so platform Engineers 
standardize usage of tools that offer these  
10:14 - services for the platform now this is a pretty 
large list of services that platform team takes  
10:22 - over so does that mean that platform team now 
becomes completely responsible for all this or  
10:27 - what exactly are they taking over do they create 
currents cluster and configure it do they create  
10:33 - the whole CI/CD Pipeline and manage it 
for the teams as well as operate these  
10:37 - tools or do a platform and product teams share the 
responsibility for those services and if so where  
10:44 - do we draw the line between those responsibilities 
and that's exactly where it gets interesting and  
10:51 - why I mentioned that platform engineering only 
works if implemented correctly so let's talk about  
10:57 - and really understand what platform engineering is 
responsible for when we think about the tools that  
11:04 - application needs like gitlab Kubernetes Jenkins 
Cloud platforms databases and so on each of these  
11:12 - tools has two sides the admin side and the user 
side the admin of the tool sets up and configures  
11:19 - the tool make sure backups are in place access 
is secured they install any needed plugins and  
11:26 - so on so all the things to make the tool ready to 
be used for the actual task that it's meant for  
11:33 - 4. so for example current's cluster needs to be 
provisioned Network plugin needs to be installed  
11:38 - access and permissions need to be configured for 
security load balancer configured for the cluster  
11:44 - and a bunch of other stuff to make the cluster 
ready to be used to deploy applications inside so  
11:52 - once the admins set up and prepare the tools to 
be used the users can come and use the tool for  
11:59 - their intention like application developers access 
Jenkins and create pipelines for their application  
12:06 - so you have a role that operates and manages the 
tool and a role that uses the tool so these two  
12:14 - responsibilities can be easily separated now in 
DevOps teams as I mentioned you have both of these  
12:22 - responsibilities in one self-sufficient team and 
that means individual application teams can decide  
12:29 - how to operate and how to use the tools but as I 
mentioned mentioned these are two separate set of  
12:36 - skills and you actually need separate knowledge 
base to do each they are even separate Kubernetes  
12:42 - certifications for administering the cluster 
which is a Kubernetes administrator certificate  
12:48 - and deploy into the cluster which is called 
Kubernetes application developer certificate  
12:54 - because again you have to specifically learn each 
aspect of the tool so in order to standardize the  
13:01 - tools across teams platform Engineers need to 
take over the operation side of these tools  
13:07 - which means selecting the standard tools setting 
them up again one standard way with production and  
13:14 - security best practices at the same time this is 
an improvement for the application teams because  
13:20 - it takes the load off the application developers 
so at least one part of the services they aren't  
13:27 - responsible for anymore so less cognitive load 
and more capacity for creating the business value  
13:33 - in addition you can use the expertise of your 
engineers more efficiently because now instead  
13:40 - of needing to have an expert on Kubernetes 
cluster Administration in every team you can  
13:46 - have fewer in platform engineering team who take 
over this work for all application teams same for  
13:52 - CI/CD tools database Administration and so on 
so you basically extract the need of expertise  
13:59 - to administer these tools from the application 
teams so instead of Engineers who kind of half  
14:06 - know this in that tool in every team you have one 
expert team who has the expertise to operate these  
14:13 - tools properly plus be because it's their core 
responsibility they also have more time for it  
14:20 - because they don't have an additional stress of 
having to release new features so this distributes  
14:26 - the pressure responsibility and the need of 
expertise among multiple application teams and one  
14:34 - organization-wide platform team and now instead 
of each team deciding which cscd tool to use or  
14:41 - which Kubernetes cluster set up to use platform 
team offers a ready solution for the application  
14:48 - teams and instead of each team building their 
pipeline steps with security scans platform can  
14:56 - standardize that these scans are part of each 
team's pipeline like if for example the company  
15:02 - has specific regulations for their industry or 
country these regulation specific skins will be  
15:09 - part of every pipeline by default but wait didn't 
we put Dev and Ops together to avoid the siled  
15:17 - teams that have separate responsibilities because 
now it sounds like we have a separate platform  
15:23 - team that decides which tools are going to be 
used company-wide and sets up all these tools as  
15:31 - they see needed and gives access to those tools 
to the application teams sounds a bit like that  
15:38 - traditional approach that we definitely don't 
want to go back to well no worries because it  
15:44 - continues from here this is just the Baseline 
so now how do app teams access these Services  
15:50 - obviously it would be no improvement if we went 
back to the slow inflexible process of developers  
15:58 - requesting resources from platform team to give 
them access to some services so how does that work  
16:04 - platform team takes all these tools like Cloud 
platform Kubernetes databases that application  
16:10 - teams need applies their expertise and configures 
them properly so they are secure up to date  
16:17 - Etc then they create an abstraction layer on 
top with a user-friendly interface like a UI or  
16:25 - API so that application teams can now come and 
self-service whatever services and tools they  
16:33 - need so those provisioned configured secured 
services with an interface to easily interact  
16:40 - and access them to use for the applications 
is a platform and since developers can just  
16:48 - log in and self-service without going to platform 
team to ask for the resources it is a platform as  
16:54 - a service for the internal developer teams or 
also called an internal developer platform or  
17:02 - IDP so platform teams are essentially building 
the IDP or internal developer platform hiding  
17:10 - away and abstracting the complexity of operating 
and managing the services that developers need to  
17:16 - release and run their applications so basically 
instead of application team logging into an AWS  
17:22 - cloud and provisioning eks cluster they go to 
the platform or IDP log in to that platform and  
17:31 - use the eks cluster which is pre-configured 
with the proper security backups Etc by the  
17:37 - platform team within minutes independently without 
asking platform team for anything so application  
17:44 - team has the flexibility and speed to access the 
services for their applications without needing  
17:51 - to worry about operating those Services now let's 
go into how this all looks like in real world and  
17:58 - think about the following actual scenario 
remember I said platform standardizes the  
18:04 - tools that are used across teams instead of 
five teams using five different CI/CD tools  
18:11 - now let's imagine platform offers gitlab CI/CD 
as a standard solution but what if application  
18:18 - team a says I want to use Circle CI instead so 
basically teams want to have freedom to use new  
18:27 - modern Cool Tools or tools that may fit better 
to their workflow maybe they want to use Argo CD  
18:34 - or specific service mesh for their microservice 
application so it seems like with platform team  
18:40 - and the whole standardization we are locking down 
the selection and saying that's what we use in  
18:46 - this company and that's it everyone abide well of 
course not that won't actually be an improvement  
18:52 - and will take away a lot of the flexibility and 
creativity that autonomous DevOps teams have  
18:59 - and the last thing platform Engineers want to do 
is become a blocker and have a weird dynamic with  
19:05 - application teams because that will kind of ruin 
the whole concept so instead of saying you can  
19:11 - only use the CI/CD tool or you can only use this 
Cloud platform the platform will say oh you want  
19:18 - to use Circle CI instead okay we will help you 
set it up and configure it with best practices  
19:23 - and once they do that they can now integrate it in 
the platform and offer it to other teams as well  
19:31 - who may also benefit from using Circle CI in their 
workflows and this way when new services are added  
19:37 - to the platform instead of limiting application 
teams to only use the CI/CD tool or this Docker  
19:44 - registry and so on you are saying you can use any 
of these Registries or CI/CD tools or any services  
19:51 - that we offer as part of our platform because 
then we know that they are all properly configured  
19:57 - and operated in the background and with time the 
platform may add more such tools that application  
20:03 - teams can select from now again in real life there 
could be cases where one specific tool may only be  
20:09 - needed in one team in which case platform can 
decide that that application teams stays the  
20:16 - owner of that team specific tool and they can 
operate it themselves instead of integrating  
20:21 - it into the platform or the IDP so in no case 
platform engineering should be mixed up with  
20:27 - the old way of working where the infrastructure 
or operations team analyzes several tools for  
20:33 - security compliance Etc decides on one correct way 
of using that specific tool and lock this down and  
20:40 - say to the developers this is the only way you can 
use this tool and that's it because we already did  
20:45 - our analysis and that's the way to go so when 
implementing platform engineer team in your  
20:50 - company you want to keep the platform flexible 
while adding guard rails and pre-configurations to  
20:57 - ensure security consistency proper configuration 
and so on so it's important to understand that  
21:04 - platform engineering is a step forward from 
DevOps not a step backwards with Dev and Ops  
21:11 - separated again but I have to say in reality I 
think if people don't understand the concept of  
21:18 - platform engineering properly there is a risk 
of it drifting towards the step backwards and  
21:24 - I talked about the right approach but later in the 
video I will go a little bit in more detail to how  
21:30 - to approach building platform engineering teams in 
a right way to avoid that before moving on I want  
21:37 - to give a shout out to Pulumi, who is the sponsor 
of this video. Pulumi is infrastructure as code in  
21:44 - any programming language like python, typescript, 
.Net, Go Java. Pulumi lets you ship infrastructure  
21:52 - as code faster, because you have access to all 
the standard features of programming languages,  
21:58 - like IDE, auto completion, type checking, loops 
and conditionals. You can also ask Pulumi AI to  
22:06 - write your infrastructure as code script for any 
use case, all using natural language prompts. The  
22:13 - automation API allows you to embed Pulumi into 
your applications to power complex infrastructure  
22:20 - automation workflows. So you can manage 10x 
more resources with it. I will leave all the  
22:26 - details of Pulumi in the video description and 
you can use the links to sign up for Pulumi and  
22:31 - you will actually receive free swag from them. 
Now let's move on and see why infrastructure  
22:37 - as code tools are an essential component of an 
IDP? Now avoiding these strict rules apply not  
22:44 - only to which tools developers can choose but 
also the usage of those tools like saying this  
22:51 - is the only EKS configuration you are allowed to 
have well we want to give developers flexibility  
22:57 - in the usage of the tools as well not only in the 
selection of tools and as I mentioned if we split  
23:03 - the responsibilities we see that platform is 
there to take off the load of application teams  
23:09 - and create consistency in the organization in 
the same way they're helping the product team to  
23:15 - correctly use the tools by introducing automated 
guardrails integrated as part of the platform  
23:22 - so now the question is how can they integrate 
those guard rails for using tools correctly into  
23:29 - the IDP and make it as part of the offering 
and that's where infrastructure as code or  
23:35 - configuration is code templates come in platform 
team can leverage infrastructure as code tools  
23:42 - like Terraform, Ansible or Pulumi to create 
the templates this means that these templates  
23:48 - can have baked in best practice configurations 
they will be used to automate provisioning of  
23:55 - resources and additionally offer the flexibility 
for product teams to pass in various parameters  
24:02 - based on their individual project needs to 
create and configure those services so we  
24:08 - have a fully automated self-service process with 
a high flexibility again an example would be to  
24:14 - have various pipeline templates so if product 
team has a python application they can use the  
24:21 - pipeline template for python APK specifically 
which has security scan tools or test steps  
24:27 - for python applications pre-configured and 
this leads to the point of how to implement  
24:33 - this concept successfully in a company the way you 
absolutely should not approach this is by starting  
24:41 - off with a huge Master concept and this ideal 
IDP or self-service platform that has all the  
24:49 - coolest features and modern tech stack integrated 
inside and is super flexible and powerful and can  
24:56 - do thousand things this is not gonna work in 
almost all cases and there are several reasons  
25:03 - for that which we're going to talk about in this 
section instead we want to take a very popular  
25:08 - agile approach here as well you should start with 
small steps which can immediately add value to at  
25:16 - least one team right away the reason is because 
in many cases when application teams are using  
25:22 - old outdated Technologies maybe all the 
versions of modern Technologies and so on  
25:30 - it will be very hard for them to migrate to 
this full-fledged modern tech stack platform  
25:37 - in one full swoop right so it's not going to be 
much improvement for them because they will now  
25:44 - have all the effort and work on their side 
to actually start using that platform so as  
25:50 - a platform team or when implementing internal 
platform in your organization you should always  
25:55 - first consider where the product teams are 
actually starting from so what is a status  
26:01 - quo of Technology usage and then help them slowly 
move from the current state to the ideal state in  
26:09 - steps and this is the approach that is way more 
efficient so the first thing is you should treat  
26:15 - the IDP as a product what does it mean the IDP or 
internal developer platform is is not a project  
26:24 - that you just Implement once and that's it 
application teams should just take it from  
26:29 - there instead it is actually a platform as a 
service that needs to be developed over time  
26:35 - and then continuously improved over time so just 
like the applications that product teams develop  
26:42 - platform is the product that platform Engineers 
develop and just like application team introduces  
26:48 - new features to the applications as well as 
updates those features makes improvements and  
26:54 - so on platform teams also need to manage and 
upgrade versions of the services they offer to  
27:00 - the product teams as well as new services and new 
tools and Tool combinations and so on so it is a  
27:07 - product with its own development and release life 
cycle so they are developing an internal product  
27:13 - or internal platform for developers and that's 
why it's called IDP and as all other products  
27:20 - it needs ongoing work and item operations and as 
I said just like you develop an application one  
27:27 - step at a time one feature at a time starting with 
version 1.0 and iteratively improving it that's  
27:36 - how platform should be developed as well so now 
the interesting question is what is the version  
27:42 - 1.0 of platform where do you start well I have 
some practical steps to answer that start with  
27:49 - low hanging fruits for example if you identify 
the common tools that many teams use across the  
27:56 - organization this could be the first candidates 
of tools that can be integrated into the platform  
28:03 - and be offered as a service this could be Jenkins 
gitlab CI/CD Kubernetes volt so basically any tool  
28:12 - that has kind of become a standard so a lot of 
teams are using it in order to do that you need to  
28:19 - work closely with application teams because you're 
developing the platform for them to make their  
28:25 - work more efficient so it makes sense to see what 
blocks them the most what is the most challenging  
28:31 - thing for them like managing Kubernetes cluster 
and take over that part developers will be willing  
28:37 - to cooperate if they see that you're actually 
solving them an issue or a bottleneck in their  
28:43 - work process if you start with random stuff like 
hey teams you are all using different CI CDs so  
28:50 - we want to introduce a few standard offerings and 
you all have to switch to one of those when you do  
28:56 - that you're actually adding more to their work 
without improving their processes at least not  
29:03 - in the short term so such things should be done 
more in a later step maybe version 2.0 once you  
29:11 - have proven to them that you're actually making 
their work easier and more efficient and already  
29:16 - offloaded some of the work so now they have 
a little bit more capacity to do this kind of  
29:21 - initial additional work so as you see building a 
platform team successfully is as much about human  
29:28 - aspect and how to manage the work with application 
teams and how to create a culture around it said  
29:35 - collaboration rules and clear responsibilities as 
much as it is about tools and technologies that  
29:42 - allow implementing that self-service internal 
developer platform and in long term you have  
29:49 - a company-wide platform engineer team and a bunch 
of app teams and instead of each application team  
29:55 - doing their own thing and handling application 
runtime and infrastructure in their own way  
30:00 - they use pre-configured services that they can 
self-service via a platform that platform team  
30:07 - has built with the best practices and standards 
and all the expertise already baked into it  
30:16 - so now a very interesting and logical question 
is does this mean we don't need DevOps engineer  
30:22 - anymore we talked about the shared responsibility 
between platform and application right that  
30:28 - platform takes over the operations part while 
application team is responsible for properly  
30:34 - using the tools and integrating them into their 
development workflow so application teams don't  
30:40 - need to set up and operate the cluster but 
they still need to know how to deploy their  
30:45 - applications into the cluster properly like 
create correctly configured manifest files  
30:53 - they don't need to know how to create terraform 
modules for infrastructure but they still need  
30:58 - to know how to use those terraform modules and 
maybe integrate them into their pipelines they  
31:04 - may get a CI/CD template from the platform but 
they still need to set it up and add additional  
31:09 - needed steps for their application so in addition 
to application development they still have some  
31:16 - non-functional requirements they need to worry 
about even though the scope of that has become  
31:21 - way less by Distributing that to the platform team 
and this means you still need DevOps engineers in  
31:28 - product teams but they now have shared their 
cognitive load and don't have to have deep  
31:35 - expertise in cloud and Kubernetes and Helm charts 
monitoring security compliance development and  
31:42 - hundred other things because now they are focused 
on properly using those non-functional tools  
31:48 - rather than operating them so the work is more 
focused and easier through this low distribution  
31:55 - but they still need to do those tasks properly and 
need expertise in using those tools but here is  
32:03 - where it gets even more interesting as I said the 
platform is also a product right it's a product  
32:09 - for the application teams the same way you need to 
add features make the UI more user-friendly offer  
32:16 - services for new Cool Tools fixed bugs in the 
platform develop terraform modules and using git  
32:23 - Ops create pipelines for their infrastructure as 
code that is underlying the platform again if you  
32:29 - have a separate cloud or on-premise infrastructure 
team or security team platform team needs to work  
32:36 - closely with them to build their platform product 
so this means platform just like the application  
32:44 - needs a continuous development with many feedback 
iterations and close input Gathering From The End  
32:52 - users which are mostly application teams but 
sometimes also governance and compliance people  
32:57 - because they need access to the information about 
whether systems are compliant across organizations  
33:03 - so all of these that I just described and listed 
are actually processes that require DevOps because  
33:11 - they're the same processes that we use in 
the application development so you have tons  
33:16 - of the DevOps processes needed in the platform 
development process which logically would mean  
33:23 - that you may need a separate DevOps engineer role 
in the platform team as well now in reality as we  
33:31 - know when it comes to DevOps there are lots of 
variations of how organizations Implement that  
33:37 - it could be that companies hire platform engineers 
who do the DevOps and Cloud engineering tasks and  
33:44 - they will just call it a platform engineer role so 
different job title same skills it could be that  
33:50 - they move the DevOps engineers from the product 
teams completely to form a separate platform  
33:56 - team but this would then create a vacuum in the 
application teams because as I said you still  
34:01 - need someone who will create Kubernetes manifest 
files or create CI/CD pipelines and integrate it  
34:07 - with various platforms so companies may make these 
tasks as part of developer work so you may have  
34:13 - application teams without a dedicated DevOps 
engineer role where developers are taking over  
34:19 - those tasks which is already practiced in many 
organizations but the bottom line is that whether  
34:25 - you have a dedicated DevOps engineer role in both 
teams or not you need the DevOps processes both in  
34:33 - the application and platform development and again 
how companies decide to structure the teams and  
34:40 - the roles that is most probably gonna vary across 
organizations So based on that you essentially end  
34:47 - up with application or product DevOps team and a 
platform DevOps team now there is one question we  
34:55 - get asked a lot so I want to address it here in 
this context many people ask which of these parts  
35:02 - do we teach in our DevOps bootcamp and courses 
do we teach the application DevOps side or the  
35:09 - platform DevOps site and this question became way 
more common since the introduction of the platform  
35:15 - role in our DevOps bootcamp you actually learn 
both parts of DevOps administering and operating  
35:22 - or setting up the tools as well as using those 
tools to streamline the development process  
35:29 - for example our Kubernetes administrator course is 
completely about setting up and administering the  
35:36 - cluster as the name also suggests which would 
be part of platform Engineers responsibility  
35:42 - while in Kubernetes module in our DevOps bootcamp 
you'll learn mostly the Kubernetes usage side but  
35:50 - also the part of configuring proper monitoring and 
setting up alerting in the cluster or setting up  
35:57 - load balancer and automatically deploying to the 
cluster from a city pipeline for example when it  
36:04 - comes to infrastructure as code with terraform 
that we talked about here in The Bootcamp  
36:09 - you learn how to automatically provision AWS 
infrastructure like ec2 servers or eks cluster but  
36:17 - you also learn how to use the existing terraform 
modules and integrate it in the application CI/CD  
36:23 - pipeline for example and same with every other 
tool that we cover in The Bootcamp Jenkins next  
36:29 - sources repository for darker images we basically 
provision these tools from scratch on dedicated  
36:36 - virtual machines then write infrastructures 
code scripts to automate the provisioning and  
36:41 - configuration of these tools learn things 
like installing plugins and doing Jenkins  
36:47 - Administration creating users and accesses cleanup 
policies and Nexus for example so tasks that would  
36:54 - actually be part of the platform engineer's 
skills but we also use these tools for setting  
37:00 - up application pipelines on Jenkins learning 
different types of pipelines and how to configure  
37:06 - them how to integrate and hook them into various 
other tools or uploading application artifacts on  
37:13 - Nexus and creating those repositories on Nexus 
and so on and then in the gitlab cic course for  
37:19 - example it is very similar you learn not only how 
to set up the CI/CD pipeline for the microservices  
37:25 - application but also the architecture of of gitlab 
CI/CD and how to configure Runners locally as  
37:33 - well as on AWS virtual machine how to configure 
different agents on those Runners based on your  
37:39 - pipeline tasks which again would be the knowledge 
that platform engineer would need so we've had  
37:46 - for a long time DevOps engineer needing to have 
this skill set of both setting up the cluster and  
37:52 - using the cluster setting up and securing AWS 
infrastructure and using the infrastructure to  
37:58 - deploy and run applications now these tasks and 
roles are split and rightfully so not because  
38:05 - knowing both is too overwhelming or because you 
can't know everything I definitely love knowing  
38:12 - and doing both parts and I have been working on 
those in my projects and you can actually learn  
38:16 - them but in reality depending on how complex a 
project is it may be unrealistic that one person  
38:23 - or role will have time and capacity at their 
job to do both so you you can decide what you  
38:30 - do with your full complete DevOps knowledge after 
finishing The Bootcamp or the courses you can join  
38:37 - the platform team and use your knowledge there 
to configure and administer tools and build the  
38:43 - developer platform with the knowledge or you 
can join the development team and streamline  
38:48 - application development and release processes 
there while being the interface or intermediary  
38:54 - between the platform team and your application 
team and what's absolutely obvious is that you  
38:59 - can do any of these jobs much better when you have 
the full picture and complete knowledge of these  
39:05 - tools from both perspectives because as a platform 
engineer you need to work closely with application  
39:11 - teams and understand their processes to find any 
bottlenecks or things that are needed in all teams  
39:17 - that can be standardized so the full knowledge 
of understanding both sides like we teach in our  
39:22 - courses and bootcamp you can do the job much 
easier because you understand both aspects if  
39:28 - you want to check out any of our courses I will 
leave the information in the video description  
39:32 - and the final topic I want to address is what is 
a difference between platform and Cloud engineer  
39:39 - well generally speaking platform engineering is 
an enhancement of all other Concepts like DevOps  
39:46 - Cloud SRE as we saw throughout this video but if 
we narrow it down to the main differences Cloud  
39:53 - engineer needs to know cloud services be expert in 
that usually even specializing in one of the cloud  
40:00 - platforms so they need to know how to migrate 
from on-premise to Cloud how to set up a hybrid  
40:05 - infrastructure manage the storage and backups and 
Cloud manage Cloud costs so basically everything  
40:11 - Cloud related and they should be able to combine 
cloud services to build infrastructure that maps  
40:18 - to what company needs but platform actually 
has a wider range of knowledge of the tools  
40:25 - outside the cloud alone and they actually build a 
platform that developers or product teams can use  
40:33 - to self-service any resources they need on top 
of the cloud resources and various other tools  
40:40 - so basically they're taking the infrastructure 
and service that AWS for example offers to custom  
40:47 - platform as a service for the company internal 
teams so essentially they build a layer on top  
40:54 - of Cloud with bunch of cloud services as well as 
other services and tools which are not part of  
41:00 - cloud and I'm sure as always each project will 
look different and Implement these Concepts in  
41:07 - various ways many companies will hire DevOps 
Engineers as platform Engineers many Cloud  
41:12 - Engineers will probably become platform Engineers 
as well in smaller companies platform Engineers  
41:17 - will probably take over the DevOps role in larger 
company Cloud team will work with platform team  
41:23 - and share their expertise so Cloud layer with 
platform layer on top and and this may be  
41:29 - like this for a while until an industry standard 
evolves of one standard way to structure the teams  
41:36 - it could be a large company that implements this 
successfully at scale and then other companies  
41:41 - can basically replicate that successful model 
so we have some kind of standardization there  
41:47 - but at its core that's the foundation and from an 
engineer perspective it really helps you in your  
41:54 - job search as well as to actually do your work 
properly when you hired for a specific role when  
42:01 - you understand these differences and the vision of 
responsibility is because you can then guide your  
42:07 - team or you you can guide your company into having 
more clarity around these roles as well so we've  
42:14 - talked about a ton of things in this video and I 
really hope I was able to help you understand what  
42:21 - platform engineering exactly is how it fits into 
the existing DevOps and Cloud world and I hope  
42:28 - you got some valuable information from this video 
that you can use in practice in your own work or  
42:35 - generally in your career and with that thank you 
for watching and see you in the next video! :)

Cleaned transcript:

In this video we're going to talk about a relatively new hot topic in DevOps and Cloud space, which is “platform engineering”. There is a lot of discussion going on, where some people are asking whether platform engineering replaces DevOps. Many people say it goes hand in hand and is rather an addition to DevOps, but in reality it's a bit more complicated than that. Platform engineering actually changes a lot of established rules we knew about DevOps, SRE and Cloud engineering, it changes the game and introduces some new rules. So let's clearly define, what platform engineering exactly is, more interestingly, why was there even a need for this new role and how it evolved and of course how it compares to DevOps and Cloud engineering and does it really replace any of these roles? Whenever a new role or concept appears, the first question should always be Why was there a need for it? Because there must be a problem behind, that couldn't be solved with existing solutions and naturally caused the evolution of this role. So let's talk about these problems that led to emerging platform engineering as a solution. Initially we had developers and operations working in separate teams and developers were responsible for programming the application. And when ready, they would throw the packaged application over to operations, who was responsible for deploying and running that application. So while you had a dedicated operations team with expertise to properly manage the infrastructure or operate companywide CI/CD platform for example or other platforms for the application teams, this was an inflexible and slow process with developers waiting on operations when they needed any change in infrastructure or needed any infrastructure resources like additional servers or Jenkins pipeline for their applications. Or on the other side operations team waiting on developers to fix something in the application that affected the deployment or application runtime etc. So when DevOps was introduced it united those teams removing the inflexible and limiting process. So it removed the communication challenges and knowledge silos between these two parts, developing application and running and operating the application. So this was a huge improvement to the traditional way of working and this led to one DevOps team that now owns the application as well as the underlying runtime and infrastructure. So basically the application itself and everything the application needs to run. And this is way more flexible, fast and just a cool way of working for the engineers, but with lots of options and ownership comes a lot of responsibility and cognitive load. Now you’re having one DevOps team, everyone developing the application and running the entire stack under the application, so you have one team where either developers or a dedicated DevOps engineer is setting up a CI/CD platform and creating the pipelines, writing Terraform scripts for infrastructures code, spinning up Kubernetes clusters, configuring the cluster with best practices, configuring logging and monitoring, adding security scans, maintaining Helm charts, also maintaining all these infrastructures code scripts as the tools evolve and new versions come out, right? Managing Docker repositories and all these in addition to the actual application development, this is why we are even doing all these other things. And this increases the flexibility and speed of work and efficiency, but naturally it also adds tremendous cognitive load on the team, because too many things that just few roles need to be responsible for. But it goes even beyond that. Now imagine you have another application team developing a completely different application and they have the same challenges and tasks. So to increase their efficiency a DevOps engineer designs the same CI/CD workflow for the project, sets up cluster, maybe this time a managed EKS service instead of selfmanaged one, configures all integrations with AWS cloud, configures the storage, adds security scanning steps, monitoring the whole secret management and so on. Maybe they use a different Docker repository like ECR for an easy integration with the EKS cluster. So they have the same challenges and same needs for their application to run somewhere, so they do all this stuff in their own ways with their own tech stack, right? And maybe you have 10 more such teams in your organization, now all of them need to figure out all these things for their projects. So you end up with 10 DevOps teams building and operating 10 different platforms to deliver and run their applications, and this can be hugely inefficient and wasteful as well as have high cognitive load on individual engineers in those teams. And with complex systems like Kubernetes, sometimes the part of managing infrastructure becomes more effort than writing application code and producing business logic itself. So you have teams that are too busy building a platform and have less time to build the business value in the applications. Plus you need expertise of so many things within a single team if they have to manage the entire infrastructure stack underneath the application, which means many experienced engineers to add to many teams, which naturally also means higher human resource costs, right? And finally this becomes hard to scale, because each new project team will have the initial time and effort in setting up the infrastructure before they can even release the application to the end users and very very important Point even though you have these teams managing their own infrastructure and platforms they may actually not have enough expertise to do everything correctly so you may end up with Kubernetes misconfigurations or lack of monitoring and logging entirely or security issues all over your systems plus when you have one compliance or security team in the whole company and tens of teams with 10 completely different Tech stacks and just different different ways of running their applications it will be pretty hard for them to get insights and help all these teams Implement proper security because it will be really hard for them to understand what's going on in all these individual projects so this becomes hard to scale because we have no standards also when each team uses different Tech stack with different configurations this leads to inconsistency across the organization and finally I want to mention that the concept of you build it you run it which we know from the SRE was created back when applications weren't as complex as today and the underlying environment for running the application wasn't as complex either so in today's highly complex multicloud multicluster or hybrid Cloud world with thousands of microservices and hundreds of services for those microservices it's a bit too much to ask developers to integrate this concept in their work like asking an expert frontend engineer stop your work and focus on properly configuring Kubernetes cluster is not really cool and not the most efficient usage of that engineer's skills so to quickly summarize we either have autonomous DevOps teams going wild and doing whatever being fast and flexible but also leading to too much responsibility on one team with high cognitive load and organizationwide inconsistency or we have the traditional separate Dev and Ops where infrastructure is managed and secured but with a painfully slow process that really limits the work of developers and that's where platform engineering comes in to save the day but only when implemented correctly So how does platform engineering solve these problems platform Engineers take the tools that are needed for deploying and running the application and standardize their usage across teams so if 10 teams use 10 different CI/CD solutions make a standard CI/CD offering or if every team uses Kubernetes but in different ways standardize usage of Kubernetes so basically platform Engineers standardize everything that is part of applications nonfunctional requirements so what are the things that we need or the socalled nonfunctional requirements of the application so basically things that are not business logic but necessary to deliver the application to its end users well first of all every application needs a Version Control System every application needs SCI City pipeline the application needs to run some somewhere like on a runtime environment like Kubernetes Kubernetes cluster of course needs an underlying infrastructure like AWS Cloud platform or even a multicloud platform the application and the underlying infrastructure also needs logging and monitoring the application also needs proper security so as you see there's a lot of things going on that need to be set up for the application to run properly and each of these categories have lots of different tools and Technologies right there are loads of CI/CD platforms out there there are different Cloud platforms and so on so platform Engineers standardize usage of tools that offer these services for the platform now this is a pretty large list of services that platform team takes over so does that mean that platform team now becomes completely responsible for all this or what exactly are they taking over do they create currents cluster and configure it do they create the whole CI/CD Pipeline and manage it for the teams as well as operate these tools or do a platform and product teams share the responsibility for those services and if so where do we draw the line between those responsibilities and that's exactly where it gets interesting and why I mentioned that platform engineering only works if implemented correctly so let's talk about and really understand what platform engineering is responsible for when we think about the tools that application needs like gitlab Kubernetes Jenkins Cloud platforms databases and so on each of these tools has two sides the admin side and the user side the admin of the tool sets up and configures the tool make sure backups are in place access is secured they install any needed plugins and so on so all the things to make the tool ready to be used for the actual task that it's meant for 4. so for example current's cluster needs to be provisioned Network plugin needs to be installed access and permissions need to be configured for security load balancer configured for the cluster and a bunch of other stuff to make the cluster ready to be used to deploy applications inside so once the admins set up and prepare the tools to be used the users can come and use the tool for their intention like application developers access Jenkins and create pipelines for their application so you have a role that operates and manages the tool and a role that uses the tool so these two responsibilities can be easily separated now in DevOps teams as I mentioned you have both of these responsibilities in one selfsufficient team and that means individual application teams can decide how to operate and how to use the tools but as I mentioned mentioned these are two separate set of skills and you actually need separate knowledge base to do each they are even separate Kubernetes certifications for administering the cluster which is a Kubernetes administrator certificate and deploy into the cluster which is called Kubernetes application developer certificate because again you have to specifically learn each aspect of the tool so in order to standardize the tools across teams platform Engineers need to take over the operation side of these tools which means selecting the standard tools setting them up again one standard way with production and security best practices at the same time this is an improvement for the application teams because it takes the load off the application developers so at least one part of the services they aren't responsible for anymore so less cognitive load and more capacity for creating the business value in addition you can use the expertise of your engineers more efficiently because now instead of needing to have an expert on Kubernetes cluster Administration in every team you can have fewer in platform engineering team who take over this work for all application teams same for CI/CD tools database Administration and so on so you basically extract the need of expertise to administer these tools from the application teams so instead of Engineers who kind of half know this in that tool in every team you have one expert team who has the expertise to operate these tools properly plus be because it's their core responsibility they also have more time for it because they don't have an additional stress of having to release new features so this distributes the pressure responsibility and the need of expertise among multiple application teams and one organizationwide platform team and now instead of each team deciding which cscd tool to use or which Kubernetes cluster set up to use platform team offers a ready solution for the application teams and instead of each team building their pipeline steps with security scans platform can standardize that these scans are part of each team's pipeline like if for example the company has specific regulations for their industry or country these regulation specific skins will be part of every pipeline by default but wait didn't we put Dev and Ops together to avoid the siled teams that have separate responsibilities because now it sounds like we have a separate platform team that decides which tools are going to be used companywide and sets up all these tools as they see needed and gives access to those tools to the application teams sounds a bit like that traditional approach that we definitely don't want to go back to well no worries because it continues from here this is just the Baseline so now how do app teams access these Services obviously it would be no improvement if we went back to the slow inflexible process of developers requesting resources from platform team to give them access to some services so how does that work platform team takes all these tools like Cloud platform Kubernetes databases that application teams need applies their expertise and configures them properly so they are secure up to date Etc then they create an abstraction layer on top with a userfriendly interface like a UI or API so that application teams can now come and selfservice whatever services and tools they need so those provisioned configured secured services with an interface to easily interact and access them to use for the applications is a platform and since developers can just log in and selfservice without going to platform team to ask for the resources it is a platform as a service for the internal developer teams or also called an internal developer platform or IDP so platform teams are essentially building the IDP or internal developer platform hiding away and abstracting the complexity of operating and managing the services that developers need to release and run their applications so basically instead of application team logging into an AWS cloud and provisioning eks cluster they go to the platform or IDP log in to that platform and use the eks cluster which is preconfigured with the proper security backups Etc by the platform team within minutes independently without asking platform team for anything so application team has the flexibility and speed to access the services for their applications without needing to worry about operating those Services now let's go into how this all looks like in real world and think about the following actual scenario remember I said platform standardizes the tools that are used across teams instead of five teams using five different CI/CD tools now let's imagine platform offers gitlab CI/CD as a standard solution but what if application team a says I want to use Circle CI instead so basically teams want to have freedom to use new modern Cool Tools or tools that may fit better to their workflow maybe they want to use Argo CD or specific service mesh for their microservice application so it seems like with platform team and the whole standardization we are locking down the selection and saying that's what we use in this company and that's it everyone abide well of course not that won't actually be an improvement and will take away a lot of the flexibility and creativity that autonomous DevOps teams have and the last thing platform Engineers want to do is become a blocker and have a weird dynamic with application teams because that will kind of ruin the whole concept so instead of saying you can only use the CI/CD tool or you can only use this Cloud platform the platform will say oh you want to use Circle CI instead okay we will help you set it up and configure it with best practices and once they do that they can now integrate it in the platform and offer it to other teams as well who may also benefit from using Circle CI in their workflows and this way when new services are added to the platform instead of limiting application teams to only use the CI/CD tool or this Docker registry and so on you are saying you can use any of these Registries or CI/CD tools or any services that we offer as part of our platform because then we know that they are all properly configured and operated in the background and with time the platform may add more such tools that application teams can select from now again in real life there could be cases where one specific tool may only be needed in one team in which case platform can decide that that application teams stays the owner of that team specific tool and they can operate it themselves instead of integrating it into the platform or the IDP so in no case platform engineering should be mixed up with the old way of working where the infrastructure or operations team analyzes several tools for security compliance Etc decides on one correct way of using that specific tool and lock this down and say to the developers this is the only way you can use this tool and that's it because we already did our analysis and that's the way to go so when implementing platform engineer team in your company you want to keep the platform flexible while adding guard rails and preconfigurations to ensure security consistency proper configuration and so on so it's important to understand that platform engineering is a step forward from DevOps not a step backwards with Dev and Ops separated again but I have to say in reality I think if people don't understand the concept of platform engineering properly there is a risk of it drifting towards the step backwards and I talked about the right approach but later in the video I will go a little bit in more detail to how to approach building platform engineering teams in a right way to avoid that before moving on I want to give a shout out to Pulumi, who is the sponsor of this video. Pulumi is infrastructure as code in any programming language like python, typescript, .Net, Go Java. Pulumi lets you ship infrastructure as code faster, because you have access to all the standard features of programming languages, like IDE, auto completion, type checking, loops and conditionals. You can also ask Pulumi AI to write your infrastructure as code script for any use case, all using natural language prompts. The automation API allows you to embed Pulumi into your applications to power complex infrastructure automation workflows. So you can manage 10x more resources with it. I will leave all the details of Pulumi in the video description and you can use the links to sign up for Pulumi and you will actually receive free swag from them. Now let's move on and see why infrastructure as code tools are an essential component of an IDP? Now avoiding these strict rules apply not only to which tools developers can choose but also the usage of those tools like saying this is the only EKS configuration you are allowed to have well we want to give developers flexibility in the usage of the tools as well not only in the selection of tools and as I mentioned if we split the responsibilities we see that platform is there to take off the load of application teams and create consistency in the organization in the same way they're helping the product team to correctly use the tools by introducing automated guardrails integrated as part of the platform so now the question is how can they integrate those guard rails for using tools correctly into the IDP and make it as part of the offering and that's where infrastructure as code or configuration is code templates come in platform team can leverage infrastructure as code tools like Terraform, Ansible or Pulumi to create the templates this means that these templates can have baked in best practice configurations they will be used to automate provisioning of resources and additionally offer the flexibility for product teams to pass in various parameters based on their individual project needs to create and configure those services so we have a fully automated selfservice process with a high flexibility again an example would be to have various pipeline templates so if product team has a python application they can use the pipeline template for python APK specifically which has security scan tools or test steps for python applications preconfigured and this leads to the point of how to implement this concept successfully in a company the way you absolutely should not approach this is by starting off with a huge Master concept and this ideal IDP or selfservice platform that has all the coolest features and modern tech stack integrated inside and is super flexible and powerful and can do thousand things this is not gonna work in almost all cases and there are several reasons for that which we're going to talk about in this section instead we want to take a very popular agile approach here as well you should start with small steps which can immediately add value to at least one team right away the reason is because in many cases when application teams are using old outdated Technologies maybe all the versions of modern Technologies and so on it will be very hard for them to migrate to this fullfledged modern tech stack platform in one full swoop right so it's not going to be much improvement for them because they will now have all the effort and work on their side to actually start using that platform so as a platform team or when implementing internal platform in your organization you should always first consider where the product teams are actually starting from so what is a status quo of Technology usage and then help them slowly move from the current state to the ideal state in steps and this is the approach that is way more efficient so the first thing is you should treat the IDP as a product what does it mean the IDP or internal developer platform is is not a project that you just Implement once and that's it application teams should just take it from there instead it is actually a platform as a service that needs to be developed over time and then continuously improved over time so just like the applications that product teams develop platform is the product that platform Engineers develop and just like application team introduces new features to the applications as well as updates those features makes improvements and so on platform teams also need to manage and upgrade versions of the services they offer to the product teams as well as new services and new tools and Tool combinations and so on so it is a product with its own development and release life cycle so they are developing an internal product or internal platform for developers and that's why it's called IDP and as all other products it needs ongoing work and item operations and as I said just like you develop an application one step at a time one feature at a time starting with version 1.0 and iteratively improving it that's how platform should be developed as well so now the interesting question is what is the version 1.0 of platform where do you start well I have some practical steps to answer that start with low hanging fruits for example if you identify the common tools that many teams use across the organization this could be the first candidates of tools that can be integrated into the platform and be offered as a service this could be Jenkins gitlab CI/CD Kubernetes volt so basically any tool that has kind of become a standard so a lot of teams are using it in order to do that you need to work closely with application teams because you're developing the platform for them to make their work more efficient so it makes sense to see what blocks them the most what is the most challenging thing for them like managing Kubernetes cluster and take over that part developers will be willing to cooperate if they see that you're actually solving them an issue or a bottleneck in their work process if you start with random stuff like hey teams you are all using different CI CDs so we want to introduce a few standard offerings and you all have to switch to one of those when you do that you're actually adding more to their work without improving their processes at least not in the short term so such things should be done more in a later step maybe version 2.0 once you have proven to them that you're actually making their work easier and more efficient and already offloaded some of the work so now they have a little bit more capacity to do this kind of initial additional work so as you see building a platform team successfully is as much about human aspect and how to manage the work with application teams and how to create a culture around it said collaboration rules and clear responsibilities as much as it is about tools and technologies that allow implementing that selfservice internal developer platform and in long term you have a companywide platform engineer team and a bunch of app teams and instead of each application team doing their own thing and handling application runtime and infrastructure in their own way they use preconfigured services that they can selfservice via a platform that platform team has built with the best practices and standards and all the expertise already baked into it so now a very interesting and logical question is does this mean we don't need DevOps engineer anymore we talked about the shared responsibility between platform and application right that platform takes over the operations part while application team is responsible for properly using the tools and integrating them into their development workflow so application teams don't need to set up and operate the cluster but they still need to know how to deploy their applications into the cluster properly like create correctly configured manifest files they don't need to know how to create terraform modules for infrastructure but they still need to know how to use those terraform modules and maybe integrate them into their pipelines they may get a CI/CD template from the platform but they still need to set it up and add additional needed steps for their application so in addition to application development they still have some nonfunctional requirements they need to worry about even though the scope of that has become way less by Distributing that to the platform team and this means you still need DevOps engineers in product teams but they now have shared their cognitive load and don't have to have deep expertise in cloud and Kubernetes and Helm charts monitoring security compliance development and hundred other things because now they are focused on properly using those nonfunctional tools rather than operating them so the work is more focused and easier through this low distribution but they still need to do those tasks properly and need expertise in using those tools but here is where it gets even more interesting as I said the platform is also a product right it's a product for the application teams the same way you need to add features make the UI more userfriendly offer services for new Cool Tools fixed bugs in the platform develop terraform modules and using git Ops create pipelines for their infrastructure as code that is underlying the platform again if you have a separate cloud or onpremise infrastructure team or security team platform team needs to work closely with them to build their platform product so this means platform just like the application needs a continuous development with many feedback iterations and close input Gathering From The End users which are mostly application teams but sometimes also governance and compliance people because they need access to the information about whether systems are compliant across organizations so all of these that I just described and listed are actually processes that require DevOps because they're the same processes that we use in the application development so you have tons of the DevOps processes needed in the platform development process which logically would mean that you may need a separate DevOps engineer role in the platform team as well now in reality as we know when it comes to DevOps there are lots of variations of how organizations Implement that it could be that companies hire platform engineers who do the DevOps and Cloud engineering tasks and they will just call it a platform engineer role so different job title same skills it could be that they move the DevOps engineers from the product teams completely to form a separate platform team but this would then create a vacuum in the application teams because as I said you still need someone who will create Kubernetes manifest files or create CI/CD pipelines and integrate it with various platforms so companies may make these tasks as part of developer work so you may have application teams without a dedicated DevOps engineer role where developers are taking over those tasks which is already practiced in many organizations but the bottom line is that whether you have a dedicated DevOps engineer role in both teams or not you need the DevOps processes both in the application and platform development and again how companies decide to structure the teams and the roles that is most probably gonna vary across organizations So based on that you essentially end up with application or product DevOps team and a platform DevOps team now there is one question we get asked a lot so I want to address it here in this context many people ask which of these parts do we teach in our DevOps bootcamp and courses do we teach the application DevOps side or the platform DevOps site and this question became way more common since the introduction of the platform role in our DevOps bootcamp you actually learn both parts of DevOps administering and operating or setting up the tools as well as using those tools to streamline the development process for example our Kubernetes administrator course is completely about setting up and administering the cluster as the name also suggests which would be part of platform Engineers responsibility while in Kubernetes module in our DevOps bootcamp you'll learn mostly the Kubernetes usage side but also the part of configuring proper monitoring and setting up alerting in the cluster or setting up load balancer and automatically deploying to the cluster from a city pipeline for example when it comes to infrastructure as code with terraform that we talked about here in The Bootcamp you learn how to automatically provision AWS infrastructure like ec2 servers or eks cluster but you also learn how to use the existing terraform modules and integrate it in the application CI/CD pipeline for example and same with every other tool that we cover in The Bootcamp Jenkins next sources repository for darker images we basically provision these tools from scratch on dedicated virtual machines then write infrastructures code scripts to automate the provisioning and configuration of these tools learn things like installing plugins and doing Jenkins Administration creating users and accesses cleanup policies and Nexus for example so tasks that would actually be part of the platform engineer's skills but we also use these tools for setting up application pipelines on Jenkins learning different types of pipelines and how to configure them how to integrate and hook them into various other tools or uploading application artifacts on Nexus and creating those repositories on Nexus and so on and then in the gitlab cic course for example it is very similar you learn not only how to set up the CI/CD pipeline for the microservices application but also the architecture of of gitlab CI/CD and how to configure Runners locally as well as on AWS virtual machine how to configure different agents on those Runners based on your pipeline tasks which again would be the knowledge that platform engineer would need so we've had for a long time DevOps engineer needing to have this skill set of both setting up the cluster and using the cluster setting up and securing AWS infrastructure and using the infrastructure to deploy and run applications now these tasks and roles are split and rightfully so not because knowing both is too overwhelming or because you can't know everything I definitely love knowing and doing both parts and I have been working on those in my projects and you can actually learn them but in reality depending on how complex a project is it may be unrealistic that one person or role will have time and capacity at their job to do both so you you can decide what you do with your full complete DevOps knowledge after finishing The Bootcamp or the courses you can join the platform team and use your knowledge there to configure and administer tools and build the developer platform with the knowledge or you can join the development team and streamline application development and release processes there while being the interface or intermediary between the platform team and your application team and what's absolutely obvious is that you can do any of these jobs much better when you have the full picture and complete knowledge of these tools from both perspectives because as a platform engineer you need to work closely with application teams and understand their processes to find any bottlenecks or things that are needed in all teams that can be standardized so the full knowledge of understanding both sides like we teach in our courses and bootcamp you can do the job much easier because you understand both aspects if you want to check out any of our courses I will leave the information in the video description and the final topic I want to address is what is a difference between platform and Cloud engineer well generally speaking platform engineering is an enhancement of all other Concepts like DevOps Cloud SRE as we saw throughout this video but if we narrow it down to the main differences Cloud engineer needs to know cloud services be expert in that usually even specializing in one of the cloud platforms so they need to know how to migrate from onpremise to Cloud how to set up a hybrid infrastructure manage the storage and backups and Cloud manage Cloud costs so basically everything Cloud related and they should be able to combine cloud services to build infrastructure that maps to what company needs but platform actually has a wider range of knowledge of the tools outside the cloud alone and they actually build a platform that developers or product teams can use to selfservice any resources they need on top of the cloud resources and various other tools so basically they're taking the infrastructure and service that AWS for example offers to custom platform as a service for the company internal teams so essentially they build a layer on top of Cloud with bunch of cloud services as well as other services and tools which are not part of cloud and I'm sure as always each project will look different and Implement these Concepts in various ways many companies will hire DevOps Engineers as platform Engineers many Cloud Engineers will probably become platform Engineers as well in smaller companies platform Engineers will probably take over the DevOps role in larger company Cloud team will work with platform team and share their expertise so Cloud layer with platform layer on top and and this may be like this for a while until an industry standard evolves of one standard way to structure the teams it could be a large company that implements this successfully at scale and then other companies can basically replicate that successful model so we have some kind of standardization there but at its core that's the foundation and from an engineer perspective it really helps you in your job search as well as to actually do your work properly when you hired for a specific role when you understand these differences and the vision of responsibility is because you can then guide your team or you you can guide your company into having more clarity around these roles as well so we've talked about a ton of things in this video and I really hope I was able to help you understand what platform engineering exactly is how it fits into the existing DevOps and Cloud world and I hope you got some valuable information from this video that you can use in practice in your own work or generally in your career and with that thank you for watching and see you in the next video! )
