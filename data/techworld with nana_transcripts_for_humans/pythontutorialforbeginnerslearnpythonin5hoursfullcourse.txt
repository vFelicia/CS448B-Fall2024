With timestamps:

00:00 - hello and welcome to this python course
00:03 - in this full course you'll learn
00:05 - everything you need to get started with
00:07 - python
00:08 - python is the most popular programming
00:11 - language out there
00:12 - and is used for so many different
00:14 - industries
00:15 - like web development data science
00:18 - machine learning
00:19 - or generally for writing automation
00:22 - programs to automate repetitive tasks
00:26 - so learning python is definitely a good
00:28 - idea
00:29 - let me give you a short overview of all
00:31 - the topics i'll cover
00:32 - in this course after giving a short
00:35 - introduction to python
00:37 - we will start with the basic building
00:39 - blocks of programming
00:41 - the most important data types like
00:43 - strings
00:44 - numbers lists sets dictionaries
00:47 - boolean data types etc and how to work
00:50 - with them
00:51 - learn about variables and functions and
00:54 - why we need them
00:56 - write a program that accepts user input
00:59 - and learn how to validate the user input
01:01 - using conditionals
01:04 - error handling with try accept
01:07 - and also learn loops with while and for
01:10 - loops
01:10 - and again why we actually need them you
01:14 - will learn all these concepts
01:15 - with hands-on examples as a next step
01:19 - you will learn how to modularize your
01:21 - program by writing
01:23 - your own modules and then see how to use
01:25 - some
01:26 - built-in python modules with all this
01:29 - knowledge we can then
01:30 - build our next demo project to write a
01:33 - small program
01:34 - that accepts a goal and a deadline
01:37 - as user input and then outputs the
01:40 - number of days
01:41 - remaining till the goal deadline
01:44 - within this exercise you will learn how
01:46 - to use the date
01:47 - time module to work with dates
01:50 - after that you will learn about packages
01:53 - and comparison of package
01:55 - versus module and we will use an
01:58 - external python package in our next demo
02:02 - project
02:02 - in which we will automate some tasks for
02:05 - working with a spreadsheet file
02:07 - finally we dive into object-oriented
02:10 - programming
02:11 - you will learn what classes and objects
02:13 - are in programming
02:15 - and python specifically and why this
02:17 - concept is
02:18 - so useful in the final demo project you
02:22 - will learn another common use case with
02:24 - python
02:25 - which is communicating with other
02:27 - applications
02:28 - over the internet by making a request
02:31 - to fetch some data from gitlab api
02:34 - in this specific case we will list the
02:37 - gitlab projects
02:38 - of a specific user so that's what we're
02:42 - gonna learn
02:43 - if you like this course don't forget to
02:45 - give this video a thumbs up
02:48 - i'm really excited to teach you all of
02:50 - these so
02:51 - let's get started
02:55 - first of all python is a programming
02:57 - language
02:58 - just like java or javascript python
03:01 - compared to other languages
03:03 - has two very big advantages first of all
03:06 - it's easy to learn it has a simple
03:08 - syntax
03:09 - and it's very easy to set up and get
03:11 - started with
03:12 - for example compared to java where you
03:15 - need
03:15 - some initial configuration before you
03:18 - can even start your application
03:20 - but it's equally or even more powerful
03:22 - than java
03:23 - now what makes a language powerful or
03:26 - how can i say that python is more
03:28 - powerful
03:29 - well that comes from the ecosystem which
03:32 - means
03:33 - libraries and modules that python
03:35 - developers themselves develop
03:37 - but also external developers create and
03:40 - maintain
03:41 - so the more people adopt the language
03:44 - the more powerful it gets because
03:46 - new libraries and so new functionalities
03:49 - get added to it
03:50 - and the second advantage is that it's
03:52 - flexible now what does a
03:54 - flexible mean in this case what makes a
03:57 - language flexible
03:58 - it is easy to mold to your wishes
04:02 - so you are not limited or restricted by
04:04 - the language specifics like
04:06 - syntax or data types or some other
04:09 - constraints
04:10 - or even library functionalities you can
04:13 - extend
04:14 - python widely and as one of the results
04:17 - of this flexibility
04:19 - python also became a multi-purpose
04:22 - language
04:23 - meaning it is used for many different
04:25 - categories
04:26 - so let's see what these categories are
04:31 - first you can use it to write web
04:33 - applications the popular libraries for
04:35 - that are django
04:36 - or more lightweight flask python became
04:40 - extremely popular because of the rise of
04:43 - data science
04:44 - machine learning and artificial
04:46 - intelligence
04:47 - industries and more and more libraries
04:50 - were created
04:51 - and are still being added for python for
04:54 - all these categories
04:56 - they are very popular and highly used
04:58 - libraries for
04:59 - data analysis and data visualization
05:02 - libraries for
05:03 - artificial intelligence projects for
05:05 - things like
05:06 - face recognition voice recognition and a
05:08 - bunch of very powerful
05:10 - and widely used machine learning
05:13 - libraries
05:14 - python is also often used for data
05:17 - collection
05:17 - like scraping the web creating web
05:20 - crawlers
05:21 - that are basically programs that collect
05:23 - data from internet
05:24 - which you can save and then process
05:26 - later again
05:28 - many different powerful libraries to do
05:30 - all of that
05:31 - and finally automation with python
05:34 - python has many great libraries to
05:36 - automate
05:37 - devops tasks for example starting from
05:40 - ci cd
05:41 - pipelines to cloud platforms and
05:43 - monitoring your infrastructure
05:45 - etc you can also write python scripts to
05:48 - do
05:48 - automated backups cleanups on the
05:51 - servers etc
05:52 - in addition to devops tasks you can also
05:55 - automate
05:56 - just general tasks with python like when
05:58 - working with
05:59 - excel sheets which is a common use case
06:02 - in many big companies
06:03 - or automating some tasks on your own
06:05 - laptop
06:07 - and there are also libraries for mobile
06:09 - development
06:10 - gaming desktop applications but
06:13 - these are less likely use cases for
06:15 - python because there are better
06:17 - alternatives
06:18 - for that so you see that the use cases
06:21 - for python are pretty vast and it
06:24 - actually spans
06:25 - several industries and it's mostly
06:27 - concentrated
06:28 - around data analytics machine learning
06:31 - and automation
06:32 - areas and note that this isn't the case
06:34 - for many other programming languages
06:36 - usually one programming language is good
06:39 - for just
06:39 - few things and you should use something
06:42 - else
06:43 - for other use cases so now you see how
06:46 - useful
06:46 - python knowledge could be and how it can
06:49 - help you
06:49 - in your job but also make you more
06:52 - valuable at your work and for your
06:55 - entire team
06:56 - i hope you are already excited to learn
06:58 - python so let's get started
07:03 - as a first step we're going to configure
07:05 - our local
07:07 - python development environment so the
07:09 - first thing we need
07:10 - is install python locally
07:14 - on our laptop so first we
07:17 - install or download python package
07:20 - for your specific operating system and
07:23 - then basically just click through the
07:25 - installer
07:26 - wizard to install python
07:29 - locally on your laptop
07:32 - and note that if you're doing this on
07:34 - windows
07:36 - very important step in the installation
07:38 - process would be to
07:40 - check the ed python to
07:43 - path option basically that you see here
07:46 - because by default it is unchecked and
07:49 - you have to
07:50 - check mark it so that after the
07:52 - installation
07:53 - you'll be able to execute python
07:55 - commands in your terminal
07:58 - now an interesting note here if you're
08:00 - using mac os
08:01 - like i do is that by default
08:05 - on mac os there is python already
08:07 - installed
08:08 - so if i do python version
08:12 - and execute i see that python version
08:15 - 2.7
08:16 - 10 is installed and that is actually
08:19 - python
08:19 - that mac os the operating system itself
08:22 - is using
08:23 - however for our tutorial and generally
08:26 - when working with python
08:28 - we want to be using the newest version
08:30 - which is
08:31 - python 3. so we're going to leave that
08:34 - default python installation
08:36 - alone we're not going to use that or
08:37 - touched it and instead we're going to be
08:39 - using
08:41 - the python version 3 that we just
08:44 - installed locally
08:46 - so now if i clean this up and we want to
08:48 - execute
08:49 - python version 3 commands we're going to
08:52 - do python 3 instead
08:54 - and version and that will give us the
08:58 - version so that's how we can
08:59 - differentiate between
09:01 - the already installed python and
09:04 - the newest version that we just
09:05 - installed so just be
09:07 - aware of that difference
09:12 - now that we have python available
09:14 - locally it's time to
09:16 - download a code editor for python
09:19 - because we're going to be writing files
09:21 - with python code
09:22 - so we need a proper editor for writing
09:25 - python code
09:26 - and actually the best python code editor
09:29 - available
09:30 - out there currently is pycharm which is
09:34 - from jetbrains
09:35 - so that's what we're going to be using
09:37 - throughout our tutorial
09:38 - so let's go to pycharm it is an
09:42 - intelligent code editor which makes it
09:45 - much easier to write code so it makes
09:48 - you actually very productive when
09:50 - writing code
09:51 - and we will see why throughout the
09:53 - course as you can see there are two
09:55 - versions
09:56 - we have the community version and
09:57 - professional one community version is
10:00 - free and
10:01 - already has a lot of powerful features
10:03 - but the professional edition
10:05 - gives you additional very useful
10:07 - features especially if you're creating
10:09 - web applications
10:11 - or scientific projects in python so with
10:13 - professional
10:14 - version additionally you will get
10:16 - scientific tools that you can use
10:18 - in scientific projects with python but
10:21 - also you get support for
10:22 - python web frameworks and database
10:25 - integration which can be of course
10:26 - very helpful if you're developing web
10:28 - applications if you want to get the
10:30 - professional edition jetbrains actually
10:32 - provided me with a code
10:34 - for my channel to try it out for three
10:37 - months for free
10:38 - just use my code when you install it but
10:40 - for this demo
10:41 - community version is absolutely fine so
10:44 - i will go with this one and
10:46 - install it and just click download
10:49 - and once the pycharm installer is
10:52 - fully downloaded we can just click on it
11:02 - move it to the application and now i can
11:05 - actually use it
11:06 - locally so i'm just gonna open the
11:09 - application
11:10 - and we're gonna take a quick tour around
11:13 - pychar
11:18 - it's actually pretty simple to set it up
11:20 - and there you go
11:21 - we have our pycharm and we can now
11:24 - create
11:25 - a new project and let's call it
11:28 - my python project
11:31 - and that's it basically we don't need to
11:34 - change anything else
11:35 - and here you see the location basically
11:38 - of where this application
11:39 - folder will be created you see pycharm
11:42 - projects
11:43 - folder got created in my users directory
11:46 - so this is basically very convenient
11:48 - because all my
11:49 - pycharm projects or my python projects
11:51 - that i create using pycharm
11:53 - will be created in one location and here
11:56 - you also see that python
11:58 - version 3 that we installed is
12:00 - automatically
12:01 - being used for this project which is
12:03 - exactly what we want
12:05 - and you see it says base interpreter
12:08 - and python interpreter is basically
12:11 - a program that knows how to execute
12:14 - python code it will know how to
12:16 - interpret or translate
12:18 - our python code into instructions
12:22 - that computer can understand so with
12:24 - this configuration we don't have to
12:26 - change anything
12:27 - we're gonna create our project so first
12:30 - of all i'm going to
12:32 - make all this a little bit bigger so
12:34 - that you can see
12:35 - the menu here on the side and the code
12:38 - a little bit better so in preferences
12:42 - editor font we're going to set the size
12:45 - to 20. if i apply this
12:50 - right here you see that this code editor
12:53 - font basically got bigger and i also
12:56 - want to
12:56 - increase the size of this menu font here
12:59 - so in
13:00 - appearance i'm going to
13:04 - set it to maybe 18 and there you go
13:07 - so basically everything is bigger now so
13:11 - you can follow along and see exactly
13:12 - what i'm typing
13:14 - and also another note here if you want
13:17 - to configure
13:18 - your theme basically so if you don't
13:21 - want it to be dark
13:22 - or maybe you want some other color
13:24 - scheme then you can select it here
13:26 - in appearance you have four themes
13:29 - available
13:29 - let's actually try this one out
13:33 - and apply and there you go you have a
13:36 - different theme i actually prefer this
13:38 - one so
13:39 - let's leave it at that so as you see we
13:42 - have a very simple
13:43 - project with one
13:47 - main main.pi file the extension is for
13:50 - python files
13:52 - which basically contains very simple
13:54 - code
13:55 - and we're gonna basically just remove
13:57 - all of these
13:58 - and start from a clean python
14:01 - file state and in the next section we're
14:04 - gonna
14:04 - dive right in and write our first
14:07 - simple python application
14:13 - we're gonna start with the simplest
14:15 - example in python
14:17 - to basically learn python syntax and
14:20 - get started as simply as possible so
14:23 - first of all
14:24 - we're gonna write a very simple
14:26 - application that just
14:27 - prints some output and in python when we
14:31 - want to print
14:33 - basically display results of what we
14:35 - wrote
14:36 - we use this syntax where we say print
14:39 - and
14:39 - here we can pass in basically whatever
14:42 - we want to display
14:44 - and now if i want to see whether this
14:46 - super simple application works
14:48 - i can run it or execute it
14:51 - with this triangle here and i have the
14:54 - output so the basically the output
14:56 - is displayed or printed right here and i
15:00 - see
15:00 - the output is 1. i can display some
15:03 - other values
15:04 - like 200 and run it and there you go
15:08 - let's say we want to display some text
15:14 - basically whatever some sentence and
15:17 - again
15:19 - triangle and we have that output here
15:21 - right
15:22 - so again very simple example of
15:26 - writing python code that basically
15:29 - displays some information when we
15:31 - execute it
15:36 - one thing that i want to note here is
15:38 - you see that we write some code
15:41 - basically
15:42 - in this window right here so in our
15:45 - main.pi
15:46 - file and when we run it
15:49 - or execute it our code we see some
15:52 - display in this window so you may be
15:55 - wondering what is this window and why do
15:58 - we see
15:59 - some output right here the answer to
16:01 - that is that whenever you're working
16:03 - with
16:04 - tools like pycharm which basically
16:07 - have all the functionality that you need
16:10 - to
16:10 - write your code and then execute your
16:12 - code you basically have everything in
16:14 - one place
16:15 - so whatever we write we can execute or
16:18 - run
16:19 - right away now without such tool how
16:22 - would we
16:23 - write code and how would we execute that
16:26 - code and this will help you understand
16:28 - what's going on
16:29 - here and to show that i'm going to go
16:32 - back to my terminal
16:33 - and i'm going to create a new file and
16:36 - i'm going to call it
16:39 - test dot py
16:43 - we're going to write the same
16:47 - code basically in this file
16:51 - you can do it in a file editor i'm just
16:53 - doing it directly in the command line
16:56 - and save it so now we have the same
16:59 - identical
16:59 - file as here
17:02 - but not inside our code editor right
17:06 - not inside this pycharm tool and we have
17:10 - python 3 available locally so
17:13 - now how do i actually execute a python
17:16 - file outside this pie chart
17:21 - i can do that using python 3 test
17:24 - dot p y and if i do that
17:29 - i get the same output in the command
17:32 - line
17:32 - so basically what you see right here
17:35 - this whole thing
17:36 - is integrated so basically all
17:39 - in one place where you can write your
17:42 - code
17:43 - the editor right here where you can
17:46 - navigate
17:46 - your files in your project so basically
17:49 - this is just a folder
17:50 - on your laptop and you can navigate the
17:54 - files here
17:55 - and you have the execution environment
17:58 - at the same time so you have to go to
18:00 - terminal and execute python 3
18:03 - whatever you have everything in one
18:05 - place and
18:06 - tools that provide you with this type of
18:08 - environment for different programming
18:10 - languages
18:11 - for python it happens to be pycharm
18:13 - these are called
18:15 - ides which stand for integrated
18:18 - development environment integrated
18:21 - because you have
18:22 - everything in one place so you don't
18:24 - need to
18:25 - use terminal but in addition to this
18:28 - integration you get more cool features
18:30 - which helps you in writing python code
18:33 - for example
18:34 - syntax highlighting highlighting errors
18:37 - or
18:38 - code suggestions autocomplete
18:40 - suggestions
18:41 - and we will see those cool features
18:43 - actually also throughout this course
18:45 - so basically just makes your life as a
18:48 - developer easier
18:49 - however it's good to understand that
18:51 - connection
18:52 - between executing your files on the
18:55 - terminal
18:56 - when you don't have such a tool versus
18:59 - executing and working on your
19:00 - application inside that tool
19:06 - awesome so let's get back to our code
19:09 - editor
19:10 - a file where we write our code and till
19:13 - now we have done something really simple
19:15 - like print
19:16 - a text basically and print
19:19 - a number right and this leads to
19:22 - the first concept in programming
19:25 - languages which
19:26 - are data types so in python
19:29 - just like in any other programming
19:30 - language you have data types
19:33 - for text and numbers the text data types
19:37 - are called
19:38 - strings so everything within the double
19:40 - quotes is basically a string
19:43 - but note that in python you can also use
19:45 - single quotes
19:46 - for strings so double quotes or single
19:49 - quotes
19:50 - they both work the same and there's
19:52 - actually no difference between them
19:55 - and for numbers we actually have
19:57 - different data types
19:58 - so for whole numbers like 2 20
20:02 - but also 0 and negative numbers as well
20:05 - we have
20:06 - a data type called integer and that's
20:09 - also how it's called in most programming
20:11 - languages
20:12 - however you also have numbers for
20:14 - currency for example how much
20:16 - a product costs right so if you have an
20:18 - online shop you would have
20:20 - prices like this for example so these
20:23 - are basically
20:24 - numbers with precision this could also
20:26 - be
20:27 - for example when you're shipping
20:28 - something you could have
20:30 - a weight of a package that is also
20:33 - not a whole number but has a precision
20:35 - so this type of numbers
20:37 - in python and many other programming
20:39 - languages are
20:40 - represented as float data type
20:44 - so again you have integers
20:48 - and float data types and if we execute
20:52 - that
20:52 - you basically see all of that printed as
20:55 - we wrote them
20:59 - now obviously printing values like
21:02 - numbers and text like this doesn't make
21:05 - much sense unless we're getting some
21:08 - useful information
21:09 - from our simple program right here right
21:12 - so let's do something more useful with
21:15 - python now
21:17 - let's clean all this up and let's say we
21:20 - want to do some
21:21 - calculations very simple logic that
21:24 - basically calculates
21:25 - how many minutes there are in 20 days
21:32 - so we have 20 days which have 24 hours
21:36 - per day
21:37 - which have 60 minutes per hour
21:40 - so this line will give us basically
21:42 - calculation of
21:44 - minutes for 20 days and there you go
21:47 - that's our number now this makes a
21:50 - little bit more sense
21:51 - because now we have a program that
21:53 - actually does something for us
21:54 - so basically as you see you can do any
21:57 - math operations on numbers
21:59 - in python and again in many other
22:02 - programming languages
22:03 - you can do plus minus division whatever
22:06 - just like you know it from basic math
22:09 - however i want to note right here
22:11 - something that many people think about
22:14 - programming
22:14 - and maybe are misinformed about
22:18 - which is if you're doing web development
22:21 - or maybe devops automation with python
22:24 - and not something like data science or
22:27 - data analytics
22:28 - this is probably an example of the
22:32 - highest
22:32 - math knowledge that you need for
22:34 - programming in python
22:36 - because even though we're going to use
22:37 - some calculation
22:39 - examples because they're just good as
22:41 - examples to
22:43 - show you the basic concepts of python
22:45 - you do not
22:46 - really need any advanced or even
22:49 - intermediate
22:50 - knowledge of mathematics when
22:52 - programming
22:53 - because it's really not about meth
22:55 - however what you need is
22:57 - logical thinking and we're going to be
22:59 - doing some of that and
23:01 - see that as examples so just bear that
23:04 - in mind
23:05 - in case you are misinformed about that
23:11 - so back to our example we have this
23:13 - number that is displayed here
23:15 - as a result however maybe if we use this
23:18 - program
23:19 - we don't remember or we don't know what
23:21 - this number stands for
23:22 - if somebody else is using so we want to
23:25 - add some descriptive
23:26 - information about this number that says
23:29 - this is how many
23:30 - minutes there are in 20 days so
23:32 - basically we need a line that says 20
23:34 - days
23:35 - are this many minutes
23:40 - and this should basically be exactly
23:42 - this calculation
23:43 - right here so how do we put this
23:47 - calculation basically right here in the
23:49 - middle
23:50 - so that we end up with this whole phrase
23:54 - displayed right here so how do we
23:56 - combine text
23:58 - and numbers basically or calculation
24:02 - of numbers and in programming languages
24:05 - again this is not specific
24:06 - to python we would do that using
24:09 - something called
24:10 - string concatenation and string
24:13 - concatenation is basically a fancy word
24:16 - for
24:16 - gluing together or combining multiple
24:19 - strings
24:21 - now how does the syntax for that look
24:23 - like
24:24 - we combine the strings using plus sign
24:27 - so apart from adding numbers obviously
24:29 - using plus
24:30 - plus is also used in programming for
24:33 - combining
24:34 - multiple strings so in our example we
24:37 - have
24:38 - three string values and we want to put
24:40 - them all together
24:41 - in one string or one sentence we have
24:44 - the first string 20 days r
24:47 - and then we have the second string
24:49 - minutes and in the middle the third
24:50 - string
24:51 - which will be the value of the
24:53 - calculation
24:54 - however if we just put a number here
24:57 - python
24:58 - interpreter tells us it's not a string
25:01 - it's a number so we need to turn it into
25:04 - a string
25:05 - other programming languages do that
25:07 - automatically in python we need to do
25:09 - that
25:10 - explicitly so we need to tell python
25:14 - take this number but not as a number but
25:17 - as
25:17 - a string and we do that using a syntax
25:23 - that looks exactly like that so
25:25 - basically we
25:26 - have a non-string value but we're
25:28 - telling python we want it as a string
25:31 - because it needs to be printed out as a
25:34 - text basically
25:35 - so if i execute this line
25:39 - let's see what happened and there you go
25:40 - we have our output
25:42 - just like we wrote it here but you see
25:45 - that there
25:46 - are no spaces around so basically 50
25:49 - is just really glued together without
25:52 - any space
25:53 - around and how do we put spaces around
25:56 - these 50
25:57 - basically add a space here add a space
26:00 - here
26:00 - now why does that work because this
26:03 - whole thing for python is a string again
26:06 - because we are
26:07 - putting it within these quotes so
26:10 - basically any character
26:11 - that you see on your keyboard right now
26:14 - if you put it
26:15 - between those quotes is
26:19 - interpreted by python as a string
26:22 - including this space character right so
26:25 - if we execute it again
26:27 - we have spaces around 50 and our
26:30 - sentence our phrase looks fine and if
26:33 - you're thinking right now this is
26:35 - actually kind of annoying because
26:37 - first of all it looks ugly and also
26:39 - there's a high chance you're gonna
26:40 - forget it
26:41 - that is absolutely right so in python
26:45 - again
26:45 - specifically there is a way to do it
26:48 - in a more elegant way using a different
26:52 - syntax and the more elegant syntax
26:55 - for that let's actually close this is
26:59 - print
27:03 - and let's write that again and
27:06 - instead of having these plus
27:10 - we have curly braces and we write
27:13 - our number inside or whatever
27:16 - non-textual
27:17 - value and at the beginning right here
27:20 - basically
27:21 - before we start writing a string which
27:24 - starts with
27:24 - quotes we just write the letter f
27:28 - and you see the syntax highlighting as
27:29 - well basically
27:31 - sees that this is not part of the text
27:35 - this is non-text value and if i
27:38 - execute it i should see the same output
27:41 - from the second line and this is really
27:43 - a way cooler way
27:45 - to write this instead of using plus
27:48 - but this is something very common and
27:50 - also something that
27:51 - you would encounter in most programming
27:53 - languages so just
27:54 - important to know that this is a syntax
27:57 - for
27:57 - string concatenation as well so we can
28:00 - basically just
28:02 - remove it and use this syntax for our
28:06 - examples
28:06 - and also note that this syntax is
28:08 - actually a new addition to python
28:11 - so it only works if you have a latest
28:13 - python version
28:14 - in our project if you remember we
28:17 - actually
28:18 - configured and chose version 3.9
28:22 - and that's why it works for us if you
28:25 - use
28:26 - python 2 for example python version 2
28:29 - this syntax is not going to work for you
28:31 - we can actually demonstrate it
28:33 - so i'm going to copy that line
28:36 - and i'm going to change our test.pi
28:48 - and now if i execute it using my python
28:51 - 3
28:53 - you see it works fine if i do it with
28:56 - python which is version
28:58 - two point something
29:01 - let's see what happens there you go
29:04 - syntax error invalid syntax because
29:06 - python version
29:12 - 2.7.10 so older version basically
29:15 - doesn't recognize this syntax so just be
29:18 - aware of that
29:19 - so this syntax actually only works for
29:21 - python versions
29:22 - starting from 3.6 so everything
29:26 - below that every python version
29:28 - basically will not recognize this syntax
29:31 - as we see right here so again back to
29:33 - our code
29:34 - and now we just have a number here
29:38 - but what we actually want is the
29:40 - calculation
29:41 - for getting the correct result right so
29:43 - we want again
29:44 - 20 days
29:48 - in hours and then in minutes and if i
29:51 - execute it
29:52 - you see that the calculation was done
29:55 - and here we have
29:56 - the full complete sentence with the
29:58 - result in it
30:00 - and if you're curious this f actually
30:02 - stands
30:03 - for format so this is basically
30:06 - formatting
30:06 - our text or our string in a correct way
30:13 - awesome so we have this line of code
30:15 - here that basically
30:17 - calculates for us how many minutes there
30:19 - are in 20 days
30:20 - let's say we want to do the same for 35
30:24 - days
30:24 - right what we can do is basically copy
30:27 - that line
30:28 - and replace the values
30:33 - for 20 with 35 and if i execute it
30:37 - i get the same calculation but for 35
30:40 - days
30:41 - and we can do that basically multiple
30:44 - times
30:44 - for different values so let's say we
30:48 - want it
30:48 - for 50 days and we want the same
30:51 - calculation
30:52 - for i don't know let's say 110 days
30:55 - doesn't really matter
30:56 - and we have obviously different
30:59 - number of minutes for each of these
31:02 - values
31:03 - and now let's say we wrote this program
31:05 - it's ready
31:06 - and we're using it and at some point we
31:09 - decide you know what i want
31:11 - this program to actually calculate
31:14 - how many seconds there are for these
31:17 - provided days
31:19 - instead of minutes so what we would need
31:22 - to do in that case
31:23 - is basically change the calculation in
31:26 - all those four lines
31:27 - so instead of minutes it should actually
31:30 - calculate
31:31 - number of seconds in a day right so we
31:33 - have the hours
31:34 - minutes and seconds and we would have to
31:37 - change the text as well here and we
31:40 - would need to do that
31:41 - for each one of those lines right
31:44 - so we would have it here
31:49 - like this and again if we need to modify
31:54 - this for hours or milliseconds or
31:57 - whatever
31:57 - we basically have to do these changes
31:59 - multiple times
32:00 - right even though if you actually look
32:02 - at that this is
32:04 - the same exact calculation for each line
32:06 - that doesn't change right if you want
32:08 - seconds then this is the calculation
32:10 - that you need to do
32:11 - so how can we actually avoid repeating
32:14 - the same calculation
32:16 - and the same text in our code and the
32:19 - answer to that is variables so in
32:22 - programming languages we have
32:24 - variables that basically hold values
32:27 - that will repeat throughout your code
32:30 - that you can set once and
32:33 - use it in multiple different places so
32:35 - instead of
32:37 - basically repeating this calculation
32:41 - four times we basically do this
32:43 - calculation
32:44 - once like this
32:47 - and we basically save this value
32:50 - in a variable so that we can use it
32:53 - whenever we need right
32:55 - and the way that variables are defined
32:58 - in python
32:59 - is variable name let's call it
33:03 - two seconds
33:08 - equals and whatever that value is that
33:12 - repeats itself and that we want to save
33:14 - into a variable
33:16 - now i want to make two notes here
33:19 - regarding the variables
33:20 - in python first of all in python
33:24 - defining or creating a variable and
33:26 - giving it a value like this
33:28 - syntax for that is actually very simple
33:32 - compared to other languages because you
33:34 - just have the variable name
33:35 - and the value in many programming
33:38 - languages you actually have to define
33:40 - here
33:40 - some kind of data type for that variable
33:42 - for example if it's a number
33:44 - like float or integer or string
33:48 - etc in python you don't have to define
33:50 - that
33:51 - you just have name of the variable
33:53 - simple as that
33:54 - the second one is the naming
33:57 - convention or standard for the variables
33:59 - so we have two words for example if we
34:01 - name
34:02 - our variable calculation to seconds
34:04 - right
34:06 - we have actually three words here so
34:08 - variables that are descriptive so
34:10 - basically they tell you
34:11 - what this value actually is about so
34:14 - they have multiple
34:15 - words in them you can separate them
34:18 - using these
34:19 - underlines again in different languages
34:22 - the
34:22 - naming for variables can be different in
34:24 - python this is actually
34:26 - one of the standard ways of defining
34:29 - variable with underscores
34:30 - which i find pretty nice and easy to
34:33 - read
34:34 - so we're gonna use this syntax basically
34:36 - throughout the course
34:37 - it will be totally and absolutely okay
34:39 - if we wrote it like this
34:41 - or if we used capital letters instead
34:45 - but again this is probably the most
34:48 - readable form
34:49 - and this is what we're going to use now
34:51 - here
34:52 - note that we can decide whatever name we
34:55 - want to give
34:55 - our variable but in python there are
34:58 - some specific words
35:00 - that have special meaning to python
35:02 - these are called reserved words
35:05 - so you can't use these words as variable
35:07 - names
35:08 - and we will use some of these reserved
35:11 - words
35:12 - throughout the course so you will see
35:14 - some examples
35:15 - great so we have our variable defined
35:18 - here and
35:19 - this is the value that this variable
35:21 - gives us so how do we replace now
35:24 - these repeating values with this
35:26 - variable
35:27 - so we're going to delete that and again
35:30 - inside we're simply going to copy
35:34 - the name of the variable so let's
35:36 - execute
35:37 - and as you see we have our
35:40 - value printed just fine and we're going
35:43 - to do the same
35:44 - for all those
35:49 - values and again execute
35:53 - everything works just like before now
35:56 - you may be thinking
35:57 - if we change this to minutes
36:00 - we would have to change the variable in
36:03 - all these places
36:04 - so that's our case we can basically just
36:07 - rename our variable something more
36:10 - generic so let's say calculation
36:12 - to units and this could be
36:16 - now any unit that we want second meaning
36:18 - it doesn't matter
36:19 - and this is exactly the advantage of
36:22 - variable
36:23 - because you can name it whatever you
36:24 - want
36:27 - which basically just describes what this
36:30 - variable is about
36:31 - and now you won't have to change that
36:34 - again
36:35 - and we can also replace this one here
36:38 - accordingly since it's a text we can
36:41 - call it a name
36:42 - of unit we can also call it unit doesn't
36:45 - really matter
36:46 - we're the ones deciding what that
36:48 - variable name is
36:49 - and once we have that variable we can
36:52 - now
36:53 - replace it here how do we do this
36:55 - because this is actually
36:56 - part of a text a string the same way we
37:00 - did
37:00 - right here we're gonna delete that
37:04 - and create an expression create a syntax
37:08 - that basically tells python
37:09 - hey this is not a string this is a
37:12 - non-string
37:13 - value and you already know this could be
37:15 - either number
37:16 - or variable itself and so we're going to
37:19 - use the curly braces
37:21 - and the name of the variable and just
37:24 - like that
37:25 - we have substituted these values here
37:29 - and if i execute it works perfectly fine
37:33 - and we can do that
37:38 - in all four lines and our code is still
37:41 - working
37:42 - and this syntax right here with this
37:44 - format
37:45 - at the beginning basically prevents us
37:48 - or avoids
37:49 - basically saves us from having a bunch
37:53 - of
37:53 - plus signs here and then space
37:57 - characters etc
37:58 - this all looks way elegant now and now
38:01 - if
38:01 - at some point we actually decide you
38:03 - know what i want
38:05 - this program to calculate how many hours
38:08 - there are in the given days instead of
38:11 - seconds
38:11 - and we want to change the program to do
38:13 - that we could basically
38:15 - just change the calculation here and
38:19 - instead of seconds we have hours and if
38:22 - i execute
38:23 - there you go we see the changes right
38:25 - away so
38:26 - this is why when you're programming
38:29 - doesn't matter in which language
38:31 - including python using variables will be
38:33 - probably some of the most frequent thing
38:36 - that you do
38:36 - because you always have values that are
38:38 - repeating themselves
38:40 - and you want to write clean code so you
38:42 - create
38:43 - variables and one of the best practices
38:46 - when
38:46 - creating and using variables is as we're
38:49 - using actually here is to name your
38:52 - variables
38:54 - so that you later and also other
38:56 - programmers who are working with you
38:58 - understand what this variable actually
39:01 - does or what type of value
39:03 - it actually has because if you just look
39:05 - at 24 you would probably not know
39:08 - what this 24 is about right but with
39:10 - variable
39:11 - you actually know that this actually
39:13 - represents a number that is used
39:16 - for calculating units right it could
39:19 - also be more descriptive
39:20 - like units for days but generally
39:24 - another advantage of variable is to
39:27 - basically describe that value
39:29 - as well that you're using in your code
39:35 - now another thing you probably also
39:37 - noticed is that
39:38 - even though we're using variables here
39:40 - so that we don't have to change
39:42 - those values in four different places a
39:45 - lot of
39:45 - these four lines are actually pretty
39:47 - similar the only difference
39:50 - in those four lines are actually these
39:52 - numbers
39:53 - right here everything else is exactly
39:55 - the same
39:56 - so what if instead we wanted to
39:59 - make this code cleaner and basically
40:02 - avoid
40:03 - this type of duplication in our code
40:06 - right so for example if we did this for
40:08 - 10 different values
40:09 - we would have the same line this long
40:12 - line basically 10 times right
40:14 - so how do we avoid this type of
40:16 - duplication
40:17 - so right here we actually avoided
40:19 - duplication
40:20 - for specific values right piece of
40:23 - string here
40:24 - a whole calculation here but how do we
40:27 - actually
40:28 - avoid duplicating a whole line right the
40:32 - whole
40:32 - piece of code basically which has
40:34 - multiple different stuff in it
40:36 - not just a value and we do that using
40:39 - functions so functions are basically
40:42 - blocks of code
40:44 - like this right or basically logic in
40:47 - code
40:47 - that does something it's not just simply
40:49 - a value but actually does something more
40:52 - complex
40:53 - that is again used in order to avoid
40:56 - repeating the same logic or most of the
40:59 - same logic
41:00 - in your code so how do we create
41:04 - functions just like we created variables
41:06 - here
41:07 - we create functions and the way we do
41:10 - that
41:10 - is using following syntax
41:15 - right here let's create our first
41:17 - function
41:19 - we start with def so we define
41:22 - a function just like we define a
41:25 - variable
41:25 - but for function we need this keyword
41:28 - basically called def
41:29 - and now we can give our function a name
41:32 - just like we gave name to our variable
41:34 - we can give our function a name
41:36 - and here we can use the same standards
41:39 - like for variable
41:40 - we can name the function something
41:42 - descriptive something that actually says
41:44 - what this function does and let's call
41:46 - our function days
41:48 - to units and then we have the brackets
41:52 - and a column so this line basically
41:55 - defines a function it tells python hey
41:58 - whatever
41:59 - comes after this is actually going to be
42:03 - a block of code that is going to be
42:06 - referred
42:06 - to or is going to be named these two
42:10 - units and how do you write a function
42:13 - i'm just going to copy this one actually
42:15 - here and let's give us some space
42:18 - and again this is very specific to
42:20 - python
42:21 - we need to indent here with spaces
42:25 - and i'm going to paste in what i copied
42:29 - inside these two lines basically tell
42:31 - python
42:33 - this piece of code or this line of code
42:36 - because we just have one line here
42:38 - belongs to a function called these two
42:42 - units
42:42 - and again we just have one line but this
42:45 - could be function with hundreds of lines
42:47 - right
42:48 - so i can write whatever i want the next
42:50 - line
42:52 - all good and then i can do some
42:55 - calculations and i can basically write
42:58 - whatever logic i want
43:00 - here and all these will belong to
43:03 - this function so now this
43:07 - logic is inside a function that is
43:10 - called
43:10 - these two units and we can actually get
43:13 - rid of this
43:15 - and test our function and here if you
43:18 - noticed
43:19 - we have this yellow line under the
43:21 - function name that's actually a warning
43:23 - for our code style
43:25 - it says we need two blank lines before
43:27 - so pycharm has a
43:29 - built-in official style guide for python
43:32 - that tells you how to style your code or
43:35 - how to write your code correctly
43:37 - now why is code style important well
43:40 - just like you write code you need to
43:42 - read code from other developers or
43:44 - your own code to understand what the
43:46 - code is actually doing
43:47 - so it's important that code is easily
43:50 - readable
43:52 - and this is just another example of how
43:54 - an editor like pycharm
43:56 - helps you to write code so to fix the
44:00 - warning
44:00 - we're just going to add a new blank line
44:03 - before the function definition
44:06 - so now what happens if i execute this
44:09 - block of code i have the variables
44:11 - defined here that i'm using in the
44:13 - function and then we have these two
44:16 - print statements
44:17 - so what happens if i execute now and as
44:20 - you see in the
44:21 - output here there is no output right
44:24 - nothing
44:25 - actually got printed so what actually
44:27 - happened because we have
44:29 - those two print statements that we
44:31 - defined in the function
44:33 - but we don't see anything in the output
44:35 - and the way it works is whenever you
44:37 - create a function or define a function
44:40 - like this
44:41 - you actually have to use that function
44:44 - right again this is a similar concept to
44:46 - variables we have
44:47 - created variables here and we're using
44:50 - that
44:50 - variable in our code the same way we
44:53 - create a function and we
44:55 - need to use that function how do we use
44:57 - a function
44:58 - or in programming languages it's called
45:01 - calling a function or executing a
45:03 - function
45:04 - and we do that using the name of the
45:07 - function
45:08 - like this and as you see in the
45:11 - suggestion as well
45:13 - using brackets like this so
45:16 - this syntax here basically is
45:20 - what we call calling the function that
45:22 - we defined right here or using that
45:24 - function
45:25 - so now if we execute it there you go you
45:28 - see
45:28 - that those two lines got executed and we
45:32 - have the results here
45:33 - so we're creating variables and we're
45:36 - using that here
45:37 - we're creating a function and we're
45:39 - using that function here
45:41 - and note the difference between using a
45:43 - variable and using a function
45:45 - python knows this is a function because
45:47 - we are providing these
45:49 - brackets at the end right that tells us
45:51 - we're making a function
45:53 - call basically
45:57 - but as you see now we have these 20 days
46:00 - so this
46:01 - only works for 20 days right what about
46:04 - other
46:05 - values that we had what about 35 days
46:07 - and 100
46:08 - days we haven't de-duplicated that right
46:11 - we have
46:12 - just one case here so how do we use
46:16 - functions so that everything else
46:20 - except for these two values right here
46:23 - actually stay the same and we do that in
46:26 - programming
46:27 - by giving our functions some kind of
46:30 - input value which are also called
46:33 - parameters
46:34 - so instead of having this 20 basically
46:37 - here hard coded as we said here
46:40 - and here we provide that value of 20 or
46:43 - 35 or whatever that value is
46:46 - basically whenever we use the function
46:48 - so we are
46:49 - telling python use these days to units
46:52 - function
46:53 - with a value of 20 or use that
46:56 - function with a value of 35 and way we
46:59 - define this
47:00 - input parameter in functions
47:03 - is very simply by defining this
47:07 - parameter
47:08 - between those brackets right so
47:11 - this is where the input we as
47:13 - programmers
47:14 - define the input parameters so right
47:17 - here
47:18 - how do we define that using our already
47:21 - familiar
47:22 - variables so basically right here i'm
47:25 - going to
47:25 - define a variable and i'm going to call
47:27 - it whatever i want
47:29 - i'm going to call it days or number of
47:32 - days
47:36 - but i'm not assigning a value to that
47:38 - variable right like
47:39 - i did here because i want it to be
47:41 - assigned
47:42 - whenever i use the function so this
47:45 - basically
47:46 - tells python that a function these two
47:49 - units
47:50 - can be used using one input parameter
47:54 - which is called num of dates right
47:56 - number of days
47:57 - so now the last part which is remaining
48:00 - is
48:01 - replacing these values using this
48:04 - variable right
48:05 - and just like we do it in these two
48:08 - places where we're
48:09 - also using variables defined here
48:12 - exactly the same way
48:13 - we're gonna remove this and
48:17 - define a block for non-textual value
48:20 - and we're gonna put our
48:23 - variable num updates here and
48:28 - also here so you see now that our
48:32 - function
48:33 - actually doesn't have any fixed numbers
48:35 - in it
48:36 - instead we're using variables we're
48:39 - using two variables that are defined
48:41 - outside that function and we're using
48:45 - one variable that is defined within that
48:47 - function right
48:48 - this variable actually belongs to that
48:51 - function
48:52 - and now as you see whenever we want to
48:55 - use
48:56 - that function we're telling python hey
48:59 - call this function called days to units
49:01 - with a parameter an input basically
49:05 - of 35. so now if we execute it
49:08 - by the way we can also do it here you
49:10 - see 35 days
49:11 - are and the calculation was done here
49:14 - and
49:15 - hours and now if we go back to
49:18 - our previous example where we wanted to
49:21 - calculate these for
49:22 - four different values right for
49:24 - different number of days
49:26 - we can actually do the same
49:29 - so we had 20 then we had
49:32 - 50 and we had 110
49:36 - right so this basically gives us exactly
49:39 - the same logic that we had previously
49:42 - but with different syntax right so you
49:45 - see the difference
49:47 - that instead of having this basically
49:50 - four times
49:51 - we have much cleaner syntax where we
49:54 - actually see what this logic is doing
49:58 - which is days to units and then
50:01 - we have the number of days that we pass
50:03 - or
50:04 - give our function as parameter and if i
50:07 - execute this you see that
50:10 - it was printed four times for all
50:12 - different values
50:14 - we can actually remove this line
50:17 - and now if we make some change in
50:20 - our function for example we change the
50:23 - name of this
50:25 - variable we want it to be hours instead
50:27 - of units
50:29 - we just do it once in one place
50:32 - and that's basically it so whatever
50:35 - changes we make
50:36 - inside that function and that is
50:38 - actually
50:39 - the big advantage of using functions in
50:41 - code
50:42 - whatever change we make inside here
50:45 - it doesn't affect how we use the
50:48 - function because
50:49 - for using the function we only need the
50:52 - name of that function
50:53 - and the input parameter now probably
50:56 - you're wondering
50:57 - what happens if i do not give my
51:00 - function a value
51:02 - let's delete those lines and let's say
51:04 - we do not provide any value here
51:07 - and we try to execute or
51:10 - call our function without the parameter
51:13 - and let's execute
51:15 - and you see that python interpreter is
51:18 - complaining because we have told python
51:22 - here is a function called these two
51:25 - units
51:25 - and whenever i want to use that or my
51:28 - colleague another programmer wants to
51:30 - use that function
51:31 - they have to provide an input value here
51:34 - right so now whenever python sees
51:38 - the usage of that function and there is
51:40 - no input
51:41 - parameter that we are giving that
51:42 - function it cannot
51:44 - execute that function right because
51:47 - basically this
51:48 - value is missing here right and that's
51:50 - why we get
51:51 - an error which also says missing one
51:54 - required
51:55 - argument so as you see whenever we
51:58 - define a function with a parameter
52:00 - with input parameter we have to also
52:03 - provide that input parameter
52:04 - another thing that you may be also
52:07 - wondering is
52:08 - what if i want to provide multiple input
52:11 - parameters to functions
52:13 - how do i do that it's actually very
52:15 - simple you can do that by
52:17 - simply defining here another input
52:19 - parameter
52:20 - separated by comma and let's say we want
52:24 - to pass
52:25 - here something that we want to print out
52:26 - additionally like a custom message
52:29 - doesn't really matter and the same way
52:33 - exactly the same way as the first one we
52:35 - can actually
52:36 - use it in here we can even create a new
52:39 - line
52:40 - and basically just print out that
52:42 - message right
52:44 - and note that if you are using a
52:46 - variable without
52:47 - stream so basically it's just the
52:49 - variable itself we're not using any text
52:52 - in that case you don't need this format
52:54 - right
52:55 - so you can basically just print it out
52:57 - directly
52:58 - and now again we have told python
53:02 - i have this function and two input
53:05 - parameters are required
53:07 - so i also need to pass to input
53:10 - values whenever i use that function so
53:14 - now let me just pass in some custom
53:17 - message
53:17 - let's say i'm happy about the
53:18 - calculation or i know i'm going to be
53:20 - happy so
53:21 - let's say awesome and
53:26 - let's do another calculation and this
53:28 - time
53:29 - i say looks good
53:32 - and if i execute it you see that i get
53:36 - awesome the first time and then for 35 i
53:38 - get
53:39 - looks good so you can basically define
53:43 - and provide as many
53:44 - input parameters as you want common
53:46 - practice
53:47 - and also what you will see in just
53:49 - normal code basically
53:51 - is just a handful of input parameters
53:54 - maybe one or two
53:56 - so it's not actually overloaded with 10
53:58 - parameters
54:03 - cool now that we know functions and
54:06 - variables
54:07 - why they're used or why are they useful
54:10 - and how we use them
54:11 - there is one point that i want to
54:14 - mention
54:14 - which is variable scopes in functions
54:18 - what does it mean as i mentioned
54:20 - previously in this function we're using
54:22 - multiple variables right we're using two
54:25 - variables
54:25 - that are part of the input right that
54:29 - we provide when using a function and
54:31 - we're using two variables that are
54:33 - defined outside the function right
54:35 - somewhere else in the code
54:37 - so variable scope basically means where
54:40 - is the variable that function uses
54:44 - defined and variable has a global scope
54:47 - for a function
54:48 - if it is defined outside the function
54:51 - like
54:52 - these two variables right here could be
54:54 - completely
54:55 - in a different file not even in the same
54:57 - file where the function is
54:59 - so these are global variables so all the
55:02 - functions that you have
55:04 - in your python code can use those global
55:06 - variables and then you have
55:08 - local variables local variables are
55:11 - variables that are
55:12 - created within that function right
55:15 - so these two variables are basically
55:18 - only
55:19 - available inside that function
55:22 - because it was created within that
55:25 - function
55:26 - so internal scope and global scope
55:29 - so that means that when we create
55:31 - another function
55:35 - let's call it scope check because that's
55:36 - what we're going to do
55:38 - we want to test the scope
55:43 - in this function i can access
55:47 - the global variables like
55:50 - name of units
55:53 - but i cannot access the internal
55:56 - variables
55:57 - like number of days and let's actually
56:01 - test that
56:05 - so i have num of units which is a global
56:08 - variable defined here
56:09 - outside the function and the second one
56:12 - i have a variable that is defined
56:13 - inside another function right
56:17 - so as i said internal and as you see
56:19 - right here
56:20 - we already get a red line underneath
56:23 - that says
56:24 - unresolved reference num of days
56:27 - so for this function basically that
56:30 - variable
56:31 - is not visible it's not accessible it
56:33 - doesn't exist basically at all
56:35 - and we can even test it out actually
56:40 - so again if we want to see the results
56:42 - we have to actually use that
56:44 - function like this run the function and
56:47 - if i execute it
56:48 - you see that we get an error that says
56:52 - name num of days is not defined right it
56:55 - doesn't know that there is a function
56:56 - like that
56:57 - anywhere in code however it does
57:00 - recognize
57:01 - the global variable and that means that
57:04 - variables defined outside function
57:06 - itself global variables are accessible
57:09 - to all the functions
57:10 - and if you have variables defined inside
57:14 - the function then they're only
57:16 - accessible for that specific function
57:18 - and not for other ones and that means
57:21 - actually that if
57:22 - num of days variable does not exist for
57:25 - scope check variable
57:26 - we can actually create a variable
57:29 - inside scope check with the same name
57:32 - and we would have basically
57:34 - no problem at all so this is not going
57:36 - to be a duplicate
57:38 - because this function doesn't know about
57:40 - this variable the number of days here
57:43 - and scope check doesn't know anything
57:45 - about variable
57:46 - num of days right here and if we
57:50 - want to use that function now we have to
57:52 - put provide the value
57:54 - let's do 20 and if i execute
57:58 - there you go you have name of units and
58:01 - the 20 that we provided so global
58:04 - variable
58:05 - local variable defined here another
58:08 - interesting thing is that
58:09 - as i said inside the function
58:12 - body so to say so this is basically
58:14 - whatever
58:15 - is part of the function right in this
58:18 - indentation
58:19 - is called function body so we can
58:22 - create whatever logic we want inside
58:25 - that function body
58:26 - so whatever i can do in python
58:29 - generally i can do inside the function
58:32 - body
58:33 - so one of those things is actually
58:35 - creating variables
58:36 - right just like we created variables
58:38 - here we can create variables
58:41 - here like this let's call it
58:44 - myvariable and
58:47 - variable inside function
58:51 - and we can print that out as well
58:56 - so now we have three types of variables
58:59 - that we are
59:00 - using in this function we have a global
59:03 - variable
59:04 - we have internal variable that is passed
59:07 - in as a parameter and we have internal
59:10 - variable again
59:11 - that is basically defined so the
59:14 - variable isn't
59:15 - provided when we use the function but
59:17 - it's basically just
59:18 - defined inside the variable and again if
59:22 - i
59:22 - execute this
59:27 - see hours num updates and variable
59:31 - inside function
59:32 - text printed out like this
59:36 - and obviously this is just for
59:38 - demonstration but we're going to see
59:39 - more realistic examples of that in our
59:42 - projects
59:43 - so i'm going to clean this up and
59:46 - we can move on to the next concept
59:52 - so now let's go back to the example
59:54 - where we calculate
59:56 - number of hours and we do that for four
59:59 - different values now if you want this
60:02 - application to be really useful
60:04 - for us or somebody else it doesn't help
60:06 - that we have to
60:07 - fixate here just four different values
60:10 - right
60:11 - the application should be able to take
60:13 - any value that we basically
60:15 - fit it right so we should be able to
60:18 - provide any number of days and the
60:20 - program should calculate
60:22 - the number of hours in those days so
60:25 - what we need here
60:26 - is user input so when we give this
60:29 - application
60:30 - program to somebody else or use it
60:33 - ourselves
60:33 - it should allow some user input so
60:36 - how do we write a program that asks for
60:40 - and accepts
60:41 - a user input and then does something
60:44 - some kind of
60:45 - calculation some kind of other logic
60:48 - based on that
60:49 - user input accepting a user input
60:52 - from a python application is actually
60:54 - pretty easy
60:55 - let's get rid of all of these lines
60:58 - first
60:59 - and we can do that by writing input
61:03 - and this will basically give a user a
61:06 - prompt
61:08 - to enter some input value now
61:11 - you probably already see from the syntax
61:14 - that this looks very much like
61:18 - using our days to units function
61:21 - right in this case with the parameter so
61:24 - input is
61:25 - actually a function that python provides
61:28 - us with
61:29 - so we didn't have to write this input
61:30 - function right we wrote the days to
61:32 - units function
61:34 - but input function is available in
61:36 - python
61:37 - so that we can use it whenever we want
61:40 - and this parenthesis here tells python
61:43 - we want to call
61:44 - an input function and we're calling it
61:47 - or using a function without a parameter
61:50 - so now we know that we can write
61:52 - functions
61:53 - ourselves for logic that we need
61:56 - but python has tons of functions
62:00 - that python developers already wrote and
62:02 - is
62:03 - part of python and we can use it in our
62:06 - code so that not everybody
62:07 - has to write their own input function
62:10 - logic
62:11 - and the code or the functions that
62:12 - python provides
62:14 - are again part of this python that we
62:17 - use in a project
62:19 - and obviously if you're using the latest
62:22 - version
62:22 - of python you will get the latest code
62:26 - and latest
62:26 - functions that python basically provides
62:31 - so back to our function execution
62:35 - and let's see what happens when we
62:38 - execute this program
62:40 - i'm going to run it and in the outputs
62:42 - you actually do not see anything
62:44 - other than my cursor is blinking here
62:48 - so it's actually waiting for user input
62:51 - so i can actually type in
62:53 - something here so i can do 20 and enter
62:57 - and process finished with exit code so i
62:59 - was able to
63:00 - input something doesn't really matter
63:05 - it could also be a string actually
63:08 - doesn't
63:08 - really matter and program basically
63:12 - finishes so that's the simplest usage of
63:16 - input however as you noticed here
63:19 - running this program and basically
63:21 - having this blank
63:23 - output here is a little bit confusing so
63:26 - if another user
63:27 - is using our program they will probably
63:30 - be wondering what's happening here
63:31 - so what we can do is in input function
63:35 - we can provide a parameter that actually
63:38 - tells a user something right like
63:41 - enter a value for number of days or
63:45 - something similar so that it's not just
63:47 - a
63:48 - blank prompt right so we can do that by
63:52 - passing in a parameter a string which is
63:55 - going to be our message
63:56 - so we can do a user
64:00 - enter a number of days
64:04 - and i will convert it to
64:07 - hours and here you see right now that
64:11 - the program wasn't finished because we
64:13 - didn't enter
64:14 - anything so this program finished line
64:18 - wasn't output yet and that means the
64:20 - program is still running
64:22 - it is still waiting for our input
64:25 - and in pycharm in this ide
64:28 - if you want to terminate the program
64:31 - manually yourself
64:32 - you can click this stop button
64:36 - and as you see process finished so
64:40 - now we can run the program again and as
64:43 - you see here we
64:44 - already have a message that we're
64:47 - displaying to the user
64:48 - so that they can enter the hours right
64:52 - and here we can provide our input
64:56 - 30 and there you go however
65:00 - this doesn't look nice here we actually
65:02 - want the user
65:04 - to get a prompt on the next line how do
65:07 - we do that
65:08 - as part of a string we can actually add
65:10 - a new line
65:11 - or newline character basically and
65:14 - that in programming is actually
65:16 - represented
65:18 - by backslash n and you see
65:21 - a special highlighting for that one now
65:23 - let's execute
65:24 - and you see that my cursor is on the
65:27 - next line now
65:28 - and again let's provide a value enter
65:32 - and program ended so we have
65:35 - now a more user-friendly way of asking
65:38 - program user for their input
65:40 - instead of just showing an empty prompt
65:43 - and we're getting user input
65:44 - now we're not doing anything with that
65:47 - user input right
65:48 - that input basically just finishes the
65:50 - program and that's it
65:52 - we're not doing any calculation for that
65:55 - input
65:55 - so how do we use the value that user
65:59 - enters here
66:00 - when input function gets executed we do
66:04 - that and this is a very important
66:06 - concept
66:06 - by assigning whatever result
66:10 - this function usage gives us which is
66:13 - in this case user input assigning that
66:17 - result to a variable so right now it's
66:19 - basically
66:20 - executed and it's just wasted right it
66:22 - just disappears
66:23 - so instead we want to save that value
66:25 - that entered
66:26 - input value in a variable so that we can
66:30 - access it later and we do that by
66:33 - let's call it user input variable
66:37 - equals so just like we created variables
66:40 - here
66:40 - with variable name and a value right or
66:44 - even an expression right if we did a
66:47 - calculation here that will be
66:48 - basically a whole expression whole
66:50 - calculation
66:51 - the same way we can use values
66:56 - that function execution gives
66:59 - us to assign it to a variable so now
67:01 - what i'm going to do
67:02 - is i'm just going to print the user
67:05 - input
67:06 - so that we can see what value that
67:09 - user input variable has so let's execute
67:13 - again
67:13 - it asks for our input let's put 20
67:17 - and print user input gives us 20.
67:20 - so user input variable value basically
67:23 - becomes
67:24 - whatever we provide as an input
67:30 - now that's a new concept and it could be
67:31 - a little bit confusing
67:33 - so let's see another example with our
67:35 - own function
67:36 - what would happen if we
67:40 - assigned value of this
67:44 - to a variable
67:47 - we get a warning as you see here in the
67:50 - editor
67:51 - which is one of the great things about
67:53 - ides that it basically gives you
67:55 - warnings when something is not correct
67:57 - and the warning says function doesn't
67:59 - return anything
68:01 - so basically if we want to have some
68:04 - value
68:05 - as a result of function execution we
68:07 - have to return
68:08 - some value in the function and how we do
68:11 - that
68:12 - instead of printing the value right away
68:15 - we can actually return that value
68:19 - using return keyword again you see
68:22 - special highlighting here just like here
68:24 - because return
68:25 - is a special word that python
68:28 - understands
68:29 - that you want to basically give back
68:32 - a value this value right here as a
68:35 - result
68:36 - of using the function right so you could
68:39 - have
68:40 - some logic here doing the calculation
68:43 - whatever
68:44 - and then as the last line you can return
68:48 - that calculated value and now
68:51 - the warning is gone because we're
68:53 - actually returning something
68:55 - from the function and when we return
68:58 - value from a function again we can
69:01 - assign it
69:02 - to a variable so that we can use that
69:04 - value whatever function
69:06 - returned by referencing the variable and
69:09 - one of the usages will be basically just
69:11 - to print it
69:12 - just like we did before like this let's
69:16 - delete it temporarily and
69:20 - test our program
69:23 - and there you go you see that this
69:25 - function
69:26 - got executed with input 20
69:29 - this text this display text basically
69:33 - was put together in the function and was
69:35 - returned or was given back
69:37 - as a result and we saved that
69:41 - this whole string basically this whole
69:43 - sentence in a variable called myvar
69:45 - and when we print that myvar we see that
69:48 - value
69:49 - printed out here and again if we enter
69:52 - some other value we would get different
69:55 - text
69:55 - and again that is actually a very
69:57 - important concept
69:59 - of giving back some results from a
70:02 - function execution and you saw in our
70:04 - examples that
70:05 - you can have a function that doesn't
70:06 - return a value just print something on
70:09 - maybe does something else
70:11 - or function that returns some value you
70:14 - can have
70:14 - both types
70:18 - so back to our example of
70:21 - user input so now hopefully it makes
70:24 - sense
70:25 - that input function returns
70:28 - whatever value the user entered as a
70:31 - result and we can
70:33 - save it in a variable and then access it
70:35 - later again let's
70:36 - get rid of this line and now let's
70:39 - actually do the calculation
70:41 - on the user input number of days how do
70:44 - we calculate number of days
70:46 - very simple by calling our function that
70:48 - actually
70:49 - does that so we're going to call our
70:52 - function
70:53 - to calculate the number of hours for
70:56 - an input and the parameter that we
70:59 - passed
70:59 - in is going to be whatever the user
71:02 - provided
71:02 - so instead of basically hard coding a
71:05 - value here
71:06 - ourselves we give it a value that user
71:09 - provided instead so the num of days will
71:12 - be
71:12 - the user input and now again because
71:15 - this function
71:16 - returns the whole string it doesn't
71:20 - print it
71:21 - remember it just returns it so when i
71:24 - execute this and i provide in
71:27 - some value that's to 200 you see that
71:30 - i don't have any output here because we
71:33 - didn't print anything we
71:34 - basically just returned the value here
71:37 - we didn't do
71:38 - anything with it so the last piece
71:40 - missing here is
71:41 - to display the text the string that
71:44 - function returns so we save that
71:47 - return value first let's do calculated
71:52 - value so we save this thing
71:56 - in calculated value variable and
71:59 - finally we can print it and now let's
72:02 - execute it and
72:04 - let's see what happens i'm going to type
72:06 - in
72:07 - 10 10 days and let's see what we get now
72:11 - and you see we have this weird value
72:14 - here
72:14 - as a result of the calculation so what
72:17 - exactly happened
72:18 - so this part of calculation basically
72:22 - which represents this number didn't do a
72:24 - proper calculation
72:25 - and the reason for that is because the
72:28 - input value that we get
72:29 - with inputs function is always
72:33 - treated as a string and not a number so
72:36 - basically
72:38 - at this place here number of days inputs
72:42 - 10 here is actually treated as a
72:45 - text and not a number and where this
72:48 - weird result comes from is basically
72:50 - number 10 printed out 24
72:54 - times so instead of doing the actual
72:56 - calculation 10 times 24
72:59 - 10 is printed 24 times and that's what
73:01 - happens when this is interpreted as
73:04 - a string so how do we make python
73:07 - see that number see that input value as
73:11 - a number as an integer and not a
73:14 - text or not as a string and it's
73:16 - actually pretty easy to do
73:18 - on the next line the user inputs again
73:21 - we saw
73:22 - right here it is a string so we have to
73:25 - make it into a number and we're going to
73:28 - do that
73:28 - using int and user input
73:33 - and that process of turning a value from
73:36 - one data type into another
73:38 - is called casting if you remember we
73:41 - already saw an example of it when we
73:42 - turned
73:43 - a number into a string in the string
73:47 - concatenation example
73:48 - again from the syntax you should already
73:50 - know that this is a function
73:52 - call so we're calling a function called
73:54 - int again
73:55 - that python itself provides us with
73:58 - because we didn't write that function
73:59 - and we're passing in
74:01 - one parameter which is a string and we
74:03 - should
74:04 - get an integer from that string as a
74:07 - result
74:08 - and we can save that number into a
74:10 - variable and let's call it user
74:12 - input number and
74:16 - now we have 10 as a number instead of as
74:19 - a string
74:19 - and instead of passing in that string
74:22 - user input we can
74:23 - now give our function number
74:26 - that it expects let's save it and
74:29 - execute
74:31 - let's put in 10 and there you go now the
74:34 - calculation
74:35 - is correct what i want to show you now
74:38 - is how this user input actually works
74:41 - without
74:42 - a code editor like pycharm so i'm gonna
74:46 - copy all this code and let's go back to
74:49 - our terminal
74:52 - and in our test dot pi
74:59 - i'm going to paste in our code
75:03 - and save and let's now actually
75:06 - see how the user input works when we
75:08 - execute it
75:09 - in a simple terminal window and as you
75:12 - see here we have the message first
75:15 - and the prompt is right here so we can
75:17 - enter a value
75:19 - let's do 25 enter
75:22 - and we have a result 25 days are
75:26 - 600 hours
75:30 - great so our program is working it is
75:33 - converting
75:34 - the number of days to number of hours
75:37 - and accepts a user input now what
75:40 - happens
75:41 - if a user enters an invalid value here
75:45 - so for example instead of a positive
75:48 - value for number of days
75:49 - maybe they enter a negative value like
75:52 - -10 for example and obviously
75:55 - that input value doesn't make any sense
75:58 - but we are still
75:59 - calculating and giving a value right and
76:02 - this is another
76:04 - important concept in programming
76:07 - generally
76:08 - that when we allow users to give our
76:11 - program
76:12 - some input value we also want to
76:14 - restrict them
76:16 - and basically validate that what they
76:19 - provided as input is a valid value for
76:22 - our program specifically
76:24 - one that it makes sense like in our case
76:28 - -10 program still does a calculation but
76:30 - it doesn't really make sense
76:32 - and second it doesn't crash our program
76:35 - right
76:36 - so now let's see what happens if we
76:38 - enter
76:39 - some text here you see
76:42 - that the calculation didn't happen
76:44 - because
76:45 - we basically crashed the program
76:48 - application
76:49 - using that invalid user input does make
76:52 - sense
76:53 - or an input that crashes our application
76:56 - because the calculation isn't even
76:58 - possible
76:59 - and we want to avoid users basically
77:02 - either providing a nonsense value or a
77:05 - value that will crash our application
77:07 - so we need to validate user input
77:11 - and this is again important concept in
77:13 - program because
77:14 - whenever you allow user input you always
77:17 - have to validate it so in this part
77:20 - we're going to learn
77:21 - concept called conditionals and we're
77:24 - going to learn this concept
77:25 - with an example of validating a user
77:28 - input so
77:30 - where are we going to do the user input
77:32 - validation we can do it
77:34 - in our function right before we
77:37 - actually do the calculation we can first
77:40 - validate
77:41 - is it a positive number and not a
77:44 - negative one
77:46 - so user gives us their input we
77:50 - convert it to a number and then we pass
77:52 - that number
77:53 - to our function so negative 10
77:57 - positive 10 that is a number basically
78:00 - will be
78:00 - passed on to our function and right here
78:03 - we can check whether this
78:07 - variable value here is a negative number
78:09 - or not
78:11 - how do we do that we do that using
78:14 - if else conditional statements so
78:18 - very simple and intuitive to understand
78:21 - we say if number of days
78:24 - is greater than 0
78:29 - means it is a positive number
78:32 - then we want to do the calculation and
78:35 - return
78:35 - all of this but you see that we have a
78:38 - red line here
78:39 - so basically whenever we use if
78:42 - condition we have to have a proper
78:44 - indentation so all of this line
78:46 - basically goes
78:48 - indented for this line kind of the same
78:51 - way as we indented
78:53 - the whole function body inside the
78:56 - function
78:57 - whatever logic and whatever code is
79:00 - right here
79:00 - indented below the if condition
79:03 - will be executed if number of days
79:07 - is really greater than zero so let's try
79:10 - that again
79:11 - i'm going to execute it let's put a
79:14 - positive 10
79:16 - you see 10 days are 240 hours
79:19 - got calculated now let's put
79:22 - -10 as an input and you see none
79:25 - basically no output for us because
79:29 - this line didn't actually get executed
79:32 - for -10 input value now what if we want
79:35 - to tell a user
79:37 - hey this was an invalid value and that's
79:39 - why we didn't do the calculation
79:41 - instead of just showing none we can do
79:45 - that
79:45 - by returning this feedback message or
79:48 - error message
79:49 - whenever this is not true so whenever
79:52 - number of days is not
79:54 - greater than zero we want to return
79:57 - something else right another message
79:59 - and we can do that using else
80:04 - and the same way as for if we have the
80:07 - indentation
80:08 - and whatever we write here will be
80:10 - executed if number of days is not
80:12 - greater than zero
80:14 - so here we are gonna return
80:17 - you entered a negative
80:21 - value so no
80:24 - conversion for you
80:28 - and here it's time for another special
80:30 - term in programming that greater than
80:32 - sign
80:33 - is called a comparison operator and we
80:36 - have three of them we have greater than
80:38 - less than and equals and these are
80:40 - called comparison operators because
80:42 - they are used in an operation to compare
80:45 - two values
80:47 - and before in this course we learned
80:49 - arithmetic operations
80:51 - like plus minus divide multiply so again
80:54 - fancy words for
80:56 - simple concepts but these are the
80:58 - official terms for these
80:59 - so now if someone mentions them you will
81:02 - know what they're talking about
81:04 - so now let's execute the application
81:07 - and let's provide -10 and you see that
81:11 - this line was printed
81:14 - as a feedback to the user
81:18 - so let's go through the flow again user
81:20 - gives us their input
81:22 - in this case -10 we convert it to
81:25 - integer
81:25 - so now it's -10 integer and we pass it
81:29 - on to our days to units
81:31 - function and these two units function
81:34 - basically has this if else statement
81:38 - that's how it's called in programming
81:40 - and our if else
81:42 - statement validates or checks
81:45 - whether this input is greater than zero
81:50 - if it is then the function will return
81:54 - this as a result so basically the
81:56 - calculation with a proper message
81:58 - else so basically if this is not
82:01 - the case then it will return basically
82:05 - just
82:05 - a feedback message for the user and note
82:08 - that
82:08 - else doesn't have such a check here we
82:11 - don't check
82:12 - num of days is less than zero and the
82:16 - reason for that
82:16 - is because it doesn't check for less
82:19 - than zero
82:20 - because it basically just decides if
82:22 - this is not true
82:23 - else or in that case just do this
82:26 - so we don't need additional check here
82:29 - now this segment right here
82:31 - where we're doing the check is called a
82:34 - conditional
82:35 - so basically we're providing our program
82:37 - a condition
82:38 - if this condition is correct
82:41 - then do something otherwise do something
82:45 - else
82:45 - and that conditional can be true
82:49 - or false if we enter 10 then this
82:52 - conditional will be true
82:53 - because it's greater than 0 if we enter
82:56 - -10 then this conditional will be
82:58 - negative it's not greater than 0
83:02 - and those true and false values in
83:05 - programming
83:06 - actually are represented by its own data
83:08 - type which is called
83:10 - boolean and in order to show it to you
83:13 - that this conditional either gives true
83:16 - or false
83:17 - what i'm going to do is i'm going to
83:19 - print
83:21 - this conditional right before i do the
83:24 - check
83:24 - so for a positive number input this
83:27 - should print
83:28 - true and if it's negative so it's not
83:32 - greater than 0 this should print false
83:35 - so let's test it out
83:38 - first i'm going to provide positive 10
83:42 - and right here you see true
83:46 - because this condition is indeed true
83:49 - and note that this is not a string
83:51 - that's why we don't need the quotes here
83:54 - so we can basically just put in the
83:55 - whole expression in a print
83:58 - function and now let's do the same with
84:01 - negative 10 and you see
84:05 - false and as i said true and false
84:09 - values belong to its own data type in
84:11 - programming
84:13 - which is called a boolean and again we
84:15 - can demonstrate that
84:17 - instead of printing it out
84:21 - we can save it into a variable let's
84:24 - call it
84:24 - conditional check
84:28 - and in python there is a function called
84:31 - type which checks or prints out
84:34 - basically
84:35 - a type data type of a variable or
84:38 - a single value so if we
84:41 - pass it so this will give us data type
84:45 - of conditional check
84:46 - and obviously if you want to see that
84:48 - result we need to print it
84:50 - so print the whole thing so it doesn't
84:53 - matter what we pass in
84:55 - this point and right here you see
84:58 - class boolean so this
85:01 - conditional check here which has a value
85:04 - of
85:05 - true or false is of type boolean
85:09 - now there are two things that i want to
85:11 - note here
85:12 - the first one is that you see that
85:15 - i am calling a function here which is
85:18 - type
85:19 - and then whatever that function type
85:22 - returns
85:23 - which is basically this output here we
85:26 - are printing it
85:27 - so we have two function calls that are
85:30 - basically
85:30 - nested and that is absolutely fine you
85:33 - can nest
85:34 - function calls another example of doing
85:37 - this
85:37 - nested function called would be for
85:39 - example right here
85:41 - instead of assigning these to a variable
85:44 - and then passing it here
85:45 - we can actually save us that step
85:48 - and in the days to units function call
85:52 - pass it as a value so this is a
85:55 - perfectly
85:56 - valid syntax and you can do that you can
86:00 - nest in the function calls and you would
86:02 - not need this additional step
86:04 - and you can do that as many times as you
86:06 - want it just looks cleaner when you have
86:09 - that syntax a little bit separated and
86:11 - not have two three
86:13 - four function calls nested so that's one
86:15 - thing
86:16 - and another thing is we just saw a class
86:19 - boolean type here
86:21 - and let's actually see the same output
86:24 - for
86:24 - string and number so just for the
86:27 - demonstration let's actually
86:29 - see the type of string and integer
86:36 - let's get rid of this for a second
86:38 - because we just want to test
86:40 - so we're going to print the type of
86:44 - a string which says this should be a
86:47 - string
86:48 - type and execute
86:52 - and you see class string and
86:55 - now let's provide an integer
86:59 - you see class int and let's provide
87:04 - a float and there you go we have float
87:08 - so this is a very handy way of checking
87:11 - the type and we're going to need that
87:12 - actually in a later example
87:16 - so back to our
87:20 - application and one note about booleans
87:23 - and conditionals
87:24 - is that you're going to be using a lot
87:27 - of those
87:28 - in programming because they're really
87:31 - the major or the core part of writing
87:34 - any kind of logic in programming so
87:37 - you're going to need
87:38 - if else conditions and statements and
87:41 - booleans
87:42 - in your application so it is a very core
87:45 - concept and we're going to be using a
87:46 - lot of them
87:47 - in our coming examples so let's get rid
87:50 - of
87:50 - this code right here and one note before
87:53 - we move on
87:54 - here is that the negative numbers are
87:57 - not
87:58 - being calculated because of this
88:00 - condition
88:01 - now what about zero let's actually try
88:04 - that out
88:05 - so i'm gonna enter zero which is
88:08 - actually
88:09 - also valued that doesn't make sense
88:11 - because
88:13 - zero days input obviously will give zero
88:15 - of any units
88:17 - so enter and
88:20 - right here you see a feedback to user
88:23 - that says you entered a negative value
88:25 - so no conversion for you
88:27 - and the reason for that is because this
88:30 - condition here number of days checks
88:33 - greater than zero
88:34 - which means that negative numbers and
88:37 - zero
88:37 - will not match this condition so they
88:40 - will
88:41 - basically give you this feedback but our
88:43 - message says you entered a negative
88:45 - value
88:45 - right when we entered zero what if we
88:48 - wanted to
88:49 - have a specific message for a user if
88:52 - they enter
88:53 - zero and a specific one if they enter
88:56 - negative value
88:57 - right we want to differentiate between
88:58 - those two how can we do that
89:01 - in the if else statement in programming
89:04 - we can have multiple conditionals so
89:08 - basically we can have multiple ifs so
89:11 - how do we do that first we check number
89:13 - of days is greater than zero
89:15 - okay great now we want to check whether
89:17 - number of days
89:18 - is equal to zero and we can do that
89:22 - using another if here and in python
89:26 - the syntax for that is el if
89:29 - which basically is a combination of else
89:32 - and
89:32 - if so if this is not true
89:36 - then we want to check another condition
89:40 - number of days equals 0.
89:43 - now you know the equation sign generally
89:46 - is this one right here
89:49 - however when we're checking whether
89:52 - something
89:53 - equals to something else in programming
89:56 - that
89:57 - equation check is represented with two
90:00 - equal signs and the reason is because
90:02 - one equal sign is already
90:04 - used to represent assigning a value to a
90:08 - variable
90:09 - so not to confuse those two actions
90:12 - in programming we have two equation
90:14 - signs
90:15 - when we want to check whether something
90:16 - equals a certain value
90:19 - and just like here we
90:22 - execute some logic whenever this
90:26 - condition is
90:27 - true so in our case we want to
90:30 - tell the user you entered
90:34 - a zero please enter
90:37 - a valid positive number
90:41 - so now again to go through this logic
90:44 - flow if the input value is
90:48 - a positive number then function will
90:50 - return
90:51 - the calculation and the message if it's
90:54 - not a positive number then we will check
90:56 - additionally
90:57 - whether it's zero if it's not zero
91:00 - then this is a last condition basically
91:03 - then we know that it has to be a
91:05 - negative number right
91:07 - so let's test this out
91:10 - let's enter a positive number there you
91:13 - go
91:14 - let's enter zero you entered
91:17 - zero please enter a valley positive
91:19 - number and
91:21 - let's enter negative one and everything
91:24 - works
91:25 - perfectly note that you can have
91:26 - multiple alif's
91:28 - between if and else statements and again
91:31 - note that el
91:32 - if has a condition just like if
91:34 - statement
91:35 - else does not have any condition so this
91:38 - is like the fallback so if
91:39 - everything previously stated all the
91:43 - previous conditions did not
91:44 - match so they were all false basically
91:47 - then
91:48 - this is the logic that will get executed
91:51 - in that case
91:55 - great so we have validated input value
91:58 - for
91:58 - users and we may feel pretty good about
92:01 - our
92:01 - program because it doesn't calculate
92:04 - anything for values that don't make any
92:07 - sense
92:08 - however we still have a problem what
92:11 - happens if
92:12 - a user enters a text instead of a number
92:15 - so basically anything that is not
92:17 - a number value doesn't really matter
92:21 - basically some text if i enter
92:24 - you see that our program actually
92:26 - crashed and this is
92:27 - actually a user input that we want to
92:30 - protect our programs from
92:32 - because we don't want to allow users to
92:35 - blow up our application right so let's
92:38 - see what happened
92:39 - it actually says that we provided an
92:42 - invalid
92:42 - literal literal basically means the text
92:46 - itself or
92:46 - a number so basically a value that we
92:49 - entered
92:50 - for int function that's the problem
92:53 - so this function call basically just
92:56 - blew up
92:57 - because in function expects a value
93:00 - which is a string representation of a
93:03 - number
93:04 - so basically ind expects something like
93:06 - this or something like
93:08 - this it doesn't expect
93:11 - my text or some text so our application
93:14 - crashed on some text input now let's see
93:17 - what happens
93:18 - if i provide a number
93:22 - but a float number instead of integer
93:25 - let's enter 19.99
93:30 - and enter and you see the same error
93:33 - this function basically returns an error
93:35 - because it cannot
93:37 - convert float into integer as well
93:40 - so we have a problem here that whenever
93:42 - user enters
93:43 - anything which is not an integer our
93:46 - program
93:46 - will blow up so how do we avoid
93:50 - that so basically before the int
93:52 - function gets executed with an
93:54 - invalid value we need to validate this
93:58 - whole thing and
93:58 - stop our program before that happens so
94:01 - we need the validation before int gets
94:03 - executed and we can do that right here
94:06 - right
94:07 - so before that line gets executed we're
94:10 - gonna do a validation
94:12 - and one way we can do that is using our
94:15 - familiar if else statement
94:18 - so we can say if user input
94:22 - is digit
94:26 - so again from the syntax you know this
94:28 - is calling a function
94:30 - but note that instead of calling the
94:32 - function
94:33 - like this so basically just stand alone
94:37 - we have the syntax where we have the
94:39 - variable
94:40 - dot and then the function name so
94:42 - instead of passing this
94:44 - as a parameter right here in the
94:46 - function
94:47 - brackets we are passing it as a
94:49 - parameter again
94:51 - but using this syntax right so each
94:54 - digit function will execute
94:56 - for user input as a parameter
94:59 - and again in if we have conditions so
95:02 - this will be either true or false
95:04 - it's a boolean and
95:07 - if user input is digit it's a number
95:10 - basically so basically this will filter
95:13 - out
95:15 - input values that are text so basically
95:17 - they're not
95:18 - numbers and if the input is digit
95:22 - then we want to execute this line
95:26 - and also the rest of our application
95:30 - like this and if it's not true
95:33 - so if the user input is not a digit we
95:36 - don't want to execute
95:38 - anything in our application we want to
95:39 - stop the execution and want to tell the
95:42 - user
95:42 - this was an invalid input value i'm not
95:46 - doing anything
95:46 - with my program so that it doesn't crash
95:49 - so
95:49 - else if not digit we
95:52 - are telling the user your input
95:56 - is not a number
96:00 - don't ruin my program
96:03 - so now let's actually test it
96:07 - so i'm going to execute and write some
96:10 - text
96:13 - and there you go so user input is digit
96:16 - was
96:16 - evaluated to false so
96:19 - none of these got executed instead the
96:22 - else
96:23 - block was executed and it printed a
96:26 - message
96:26 - for our user so we basically avoided our
96:29 - application to crash
96:30 - with this check and
96:34 - if we try a proper number
96:37 - it works and if we enter
96:40 - 0 for example the application
96:44 - will get executed and we will get
96:47 - our message from here
96:50 - so our application is more or less
96:53 - protected
96:54 - and we're not allowing for a invalid
96:58 - input number you say not a valid
97:01 - number now we know that in programming
97:03 - there are different types of numbers
97:05 - we have float numbers as well so
97:08 - let's actually see what ease digit
97:12 - function
97:13 - really checks so let's actually try
97:16 - to provide a float number instead of
97:19 - integer which is not a proper valid
97:22 - input for our program so i'm going to
97:24 - type in 19.99
97:27 - and you see that each digit
97:30 - is false for a float number so we got
97:33 - the same
97:34 - your input is not a valid number output
97:37 - for float number as well which is
97:39 - perfect it's exactly what we need
97:41 - and now let's actually try
97:44 - to enter a negative number and let's see
97:47 - if each digit function
97:49 - returns true or false i'm going to enter
97:52 - and you see that else block got executed
97:56 - because
97:57 - is digit was false for a negative number
98:00 - so basically this function
98:02 - filters out a lot of the bad input
98:05 - for us to protect our application
98:08 - from bad user input and that also means
98:11 - that
98:12 - we don't need a check for negative
98:14 - values anymore and
98:16 - by the way in python you can actually
98:19 - have
98:19 - if statement without an else
98:22 - at the end this will work perfectly fine
98:29 - and this could be our application
98:34 - however note that in programming we
98:36 - don't put this type of
98:38 - logic directly like this
98:41 - basically outside a function as a common
98:44 - and best practice we
98:46 - encapsulate most of the logic basically
98:49 - in functions
98:50 - so as a cleanup for our code
98:54 - we can take all this and put it into
98:58 - a function so right here i'm going to
99:01 - create
99:01 - a function and let's call it
99:05 - validate and execute
99:09 - or something like this
99:13 - and all the logic that i copied
99:17 - will be just simply pasted in that
99:20 - function like this
99:22 - so now we have the logic nicely
99:24 - encapsulated in its own function
99:27 - but as you know when we create a
99:29 - function we have to call that function
99:31 - otherwise nothing happens
99:33 - so we're gonna call it right here
99:36 - we don't have parameters and we don't
99:38 - have to provide a user
99:40 - input because user input is a global
99:42 - variable
99:43 - so our function has access to it let's
99:47 - actually test it out
99:50 - and it works and let's provide some bad
99:54 - input
99:58 - and it works too so that's actually a
100:01 - proper way of writing code
100:03 - having every piece of logic in its own
100:06 - function
100:06 - with a proper description for the
100:08 - function
100:12 - now as a next step i want to show you
100:15 - also a concept or something that you
100:17 - will encounter
100:17 - very often in code which is nested
100:21 - if else statements and i'm going to show
100:24 - that example by
100:25 - cleaning up our program a little bit
100:29 - so as you see here we're doing
100:31 - validation in two different places
100:33 - so we're validating user input here but
100:36 - also
100:37 - inside these two units function itself
100:41 - so what we can do is we can put all the
100:43 - validation in one place
100:45 - in this validate and execute function
100:47 - and basically
100:48 - have all the validate logic in here
100:52 - and let the days to units function just
100:55 - do the
100:56 - calculation and not the validation and
100:58 - this way
100:59 - our functions and code will be a little
101:01 - bit
101:02 - cleaner and more logically built
101:06 - so after we validate that user input is
101:09 - digit we convert it into an integer
101:13 - so right here we have an integer value
101:16 - of the user input
101:17 - so we can actually check whether that
101:19 - integer value is
101:20 - greater than zero or equal to zero and
101:23 - we can do that
101:24 - right here without passing it on to the
101:27 - days to units
101:28 - function and just like this if
101:31 - conditional
101:32 - we're gonna do user input number
101:35 - greater than zero if that's the case
101:39 - we want the calculation to happen so
101:42 - both of these lines will get executed
101:44 - only if user input number is greater
101:46 - than zero
101:47 - and else in our case if it's
101:50 - exactly zero we want to print a message
101:54 - to user you entered zero and remember
101:56 - we've got the negative numbers already
101:58 - covered using
102:00 - this condition here so that's the one
102:03 - remaining
102:03 - i'm just going to copy that and paste it
102:06 - right here
102:07 - variable is called user input number so
102:10 - we'll fix that
102:11 - and we're going to print out that
102:14 - message
102:17 - so that means we don't need any
102:20 - validation
102:21 - right here we can
102:26 - simply do the calculation
102:30 - so to go through this logical flow of if
102:33 - else or nested e-files
102:36 - statements we have the first if right
102:38 - here
102:39 - also note that indentations for
102:42 - these if else so basically they are on
102:45 - the same
102:46 - line here same position and
102:49 - the nested if else or in our case alif
102:53 - they're also in the same position so
102:55 - again first
102:56 - that's the big validation the first one
102:58 - is
102:59 - is the user input digit in the first
103:02 - place if not
103:03 - we basically shut down the program we
103:06 - print out a message to the user and
103:08 - that's it
103:10 - if it is a digit then we need additional
103:13 - validation is that digit a positive
103:16 - number
103:17 - or is it a zero so we do that additional
103:20 - validation using a nested ifall
103:22 - statement
103:23 - and basically this line gets executed
103:26 - only if it is a valid number and if it's
103:29 - a positive number and because of that
103:32 - we don't need any additional validation
103:35 - once the
103:36 - these two units function gets cold
103:40 - and you probably already think and
103:42 - notice that nested
103:43 - if else statements are not the most
103:46 - beautiful thing in the world they are
103:48 - pretty
103:48 - ugly actually and especially we have
103:50 - multiple of them or
103:52 - multiple else ifs in between
103:55 - the function may actually end up looking
103:57 - pretty bad
103:58 - so it's not recommended to have multiple
104:01 - levels of these
104:02 - nested if else statements in your code
104:05 - to basically just keep it clean but as i
104:08 - said
104:09 - you will encounter it a lot in programs
104:12 - in application code
104:14 - because sometimes you just have to write
104:16 - it like this
104:20 - thing i want to show you here is
104:22 - something called
104:23 - a try accept in python so right here as
104:27 - you see we're validating
104:28 - user input right and then we're
104:30 - executing this part of code
104:33 - only if that condition is true
104:36 - what if we had logic here where
104:39 - there were multiple places where
104:43 - something could go wrong let's say a
104:45 - function
104:46 - execution could basically just blow up
104:49 - because of
104:50 - a wrong input or even
104:53 - as an example maybe this is digit
104:56 - doesn't actually cover all the use cases
104:59 - so maybe there is a value that user can
105:01 - input that will still
105:03 - blow up our program so instead of
105:05 - checking each such possible scenario
105:08 - using if statements and then doing the
105:10 - actual calculation once
105:12 - all those things have been validated
105:15 - what we can do instead
105:17 - is basically tell python
105:20 - something like try
105:23 - executing this part of code here
105:27 - and if something goes wrong so if any
105:30 - line any function call or any logic
105:33 - execution
105:34 - fails we want to catch that error and we
105:37 - want to control what happens
105:39 - with that error ourselves
105:42 - programmatically
105:43 - and then catch logic will be
105:46 - accept and we're going to specify
105:50 - what type of value we want to catch
105:53 - basically using this block
105:57 - and the name of that error type is
106:00 - actually what we saw in the output when
106:03 - we provided
106:04 - some text and a float which
106:07 - is value error
106:10 - so that's the error that we want to
106:12 - catch basically so
106:14 - again we tell python you know what try
106:17 - to
106:17 - execute this block of code here
106:20 - and if one of those lines in that code
106:24 - results into a value error then instead
106:27 - of just
106:28 - crashing the program basically catch
106:30 - that error
106:31 - and print out a friendly message to a
106:34 - user
106:35 - so let's actually try this out
106:38 - and note that try doesn't have any
106:40 - validation
106:41 - like if statement so
106:45 - when i entered some text here
106:49 - int function will actually be called
106:51 - with some text
106:52 - and it will result in a value error and
106:55 - this block will then handle that error
106:58 - so i'm going to enter and and you see
107:02 - that
107:02 - your input is not a valid number message
107:06 - got printed and the same will work
107:09 - for a float number
107:12 - that also doesn't convert to integer and
107:15 - for a proper integer value
107:20 - it will work fine and
107:23 - again difference between if else
107:25 - statement and using try except
107:27 - is that you can cover multiple such
107:30 - errors
107:31 - with this whole try except block right
107:34 - so you don't have to do the validation
107:37 - specifically and that is especially
107:40 - useful for cases where you can't
107:42 - really validate something using if
107:45 - condition right if there is a chance
107:48 - that you might miss
107:49 - something in that condition check so
107:51 - basically you just say you know what
107:53 - just try to execute with whatever value
107:56 - and
107:57 - if error happens then i still got it
108:00 - covered
108:00 - and an obvious difference between this
108:03 - if else
108:04 - is that here nothing actually crashes
108:06 - the program the program will still work
108:08 - is just
108:09 - a nonsense value with zero days right
108:12 - and as you see here we have specified
108:15 - an error type but with try
108:18 - except what can also do is you can
108:20 - basically say you know what
108:21 - i want to cover any type of air i don't
108:24 - care if it's
108:25 - value air or some other type of air let
108:28 - me
108:28 - handle any type of air in this case you
108:31 - can basically just leave it without a
108:33 - specific type
108:34 - you get a warning though that it's too
108:36 - general
108:37 - however this would work and you will be
108:40 - covering all the air cases with it
108:42 - but we can go back to our value error
108:44 - and know that in many programming
108:46 - languages this is actually called a try
108:48 - catch so accept is actually pretty
108:51 - specific
108:52 - for python i personally think try catch
108:54 - makes more sense because you are
108:55 - catching
108:56 - any error that may happen right here and
108:59 - then basically
109:01 - handling it in the catch block so if you
109:04 - happen to hear or see
109:05 - try catch in other programming languages
109:07 - note that
109:08 - this is the same thing as try except in
109:10 - python
109:11 - one thing that we're missing because we
109:13 - converted that if statement
109:14 - into try except is now we need to
109:18 - validate the negative numbers again
109:20 - because negative numbers will not cause
109:22 - an error
109:23 - in our application so they're not
109:25 - covered by this
109:26 - except block here so let's add back
109:30 - our previous else block
109:34 - and again if neither of these
109:38 - are true it means automatically would
109:41 - mean that it is a negative number
109:44 - so let's
109:47 - print that message for a user enter
109:50 - negative number
109:55 - no conversion for you
110:01 - so now we got all the cases covered
110:04 - again
110:05 - so let's try that out -10
110:09 - and there you go
110:13 - now there is one minor problem with our
110:16 - application
110:17 - and that is we can only use it once
110:21 - so basically whenever we type in a value
110:24 - it either calculates it or gives us
110:28 - a message that we provided an invalid
110:30 - value
110:31 - then the program basically exits so if
110:34 - we want to do a calculation
110:35 - for another value then we have to
110:37 - restart the application
110:39 - provided value and then do the same
110:42 - so that's not very convenient if we want
110:45 - to use that program to
110:47 - basically calculate a number of hours
110:50 - for many different values so basically
110:52 - we want to
110:53 - keep fitting it some different values
110:56 - for calculation
110:57 - because we don't want to restart the
110:59 - application over and over again
111:01 - so how can we actually make the program
111:04 - continue after it's calculated the first
111:08 - value
111:09 - so we want the program to basically just
111:11 - keep running and
111:12 - accepting our values so how do we do
111:16 - that
111:16 - and we can implement the logic using
111:19 - something called
111:20 - while loop concept of loops in
111:23 - programming
111:24 - is basically you do the same thing
111:28 - so the same logic gets executed
111:31 - multiple times in a loop and how many
111:35 - times
111:36 - that logic gets executed is basically
111:38 - defined
111:39 - in the condition of that loop and the
111:42 - condition could be
111:43 - it should run 10 times or condition
111:45 - could also be
111:46 - it should run until some specific
111:50 - event happens in the application and
111:53 - conditions you already know from if else
111:56 - statement
111:57 - conditions are basically logic that
112:00 - gives you either true
112:02 - or false so condition is checking some
112:04 - logic and then
112:05 - giving you a result which is either true
112:08 - or false
112:09 - so now the question is how many times do
112:11 - we want this application to run
112:13 - in our case let's say we want to run
112:16 - indefinitely
112:16 - right until we actually stop it from
112:19 - here until we kill the program
112:21 - so it means the condition for that
112:24 - should
112:24 - always be true and for our application
112:29 - we're going to use a while loop which is
112:31 - one
112:32 - type of a loop and very simple syntax
112:36 - while and while just like if actually
112:40 - takes
112:40 - a condition this is going to be the
112:42 - condition for the loop
112:44 - so basically we want to tell the while
112:46 - loop how many times
112:48 - it should run the logic coming after it
112:51 - and again you know our familiar
112:54 - indentation
112:55 - these two lines should execute in a loop
112:58 - over and over again with some condition
113:01 - right here so how many times do we want
113:04 - the program to execute
113:06 - in our specific case well we want the
113:09 - program to
113:10 - run indefinitely until we actually stop
113:14 - it from here
113:14 - right from our editor so
113:18 - that means that condition of the loop
113:21 - that decides whether the next lines
113:24 - should get executed or not in our case
113:27 - should always be
113:28 - true because if it's false then
113:32 - the loop will stop right no execution
113:35 - anymore
113:36 - so how can we make sure it's always true
113:38 - we just write
113:40 - true right here and you remember i told
113:43 - you that true and false in
113:45 - programming languages have their own
113:47 - data types well they are also reserved
113:50 - words
113:50 - even though this is just text
113:52 - representation basically you see the
113:54 - highlighting here
113:55 - just like for these other words because
113:57 - python knows
113:58 - this is a boolean value of
114:02 - true and note that again specifically
114:05 - for python we actually
114:07 - write true with capital t
114:10 - unlike in other programming languages so
114:13 - this
114:13 - will basically be just a string
114:16 - so python doesn't know what to do with
114:18 - it but it recognizes
114:20 - true width capital t so we're telling
114:24 - our loop
114:26 - our while loop the condition is always
114:28 - true
114:29 - so basically run these two lines
114:31 - indefinitely because the condition
114:33 - will never change it's always going to
114:34 - be true and
114:36 - the syntax is probably already familiar
114:39 - to you
114:39 - we have the keyword just like if
114:42 - or try we can actually compare the
114:45 - syntax to the if statement
114:46 - so we have the while keyword here
114:50 - then we have the condition so this is
114:52 - the same type of condition
114:54 - as this one right here it's just that
114:56 - with us
114:57 - is basically fixed true value
115:00 - here it could be true or it could be
115:02 - false based on the condition
115:04 - and then we have the colon and then we
115:06 - have the indentation
115:07 - for the next lines so all of these
115:10 - belong to
115:10 - the while loop so that's basically it
115:14 - we can now execute the application and
115:17 - see that our program runs indefinitely
115:19 - so this is the first one
115:21 - let's say we enter 10 awesome we have a
115:24 - result
115:24 - and then we have again the next
115:28 - execution where it's asking for our
115:30 - input again
115:32 - and we can do -10 now it's telling us we
115:36 - provide a negative value
115:37 - but we can enter the value again let's
115:40 - enter some
115:41 - invalid value that should be
115:44 - handled by this value error block
115:47 - execute
115:48 - it's not a valid number and application
115:51 - basically continues so again as you see
115:54 - if you
115:55 - have an application that should continue
115:57 - running and basically get user input
115:59 - over and over again
116:00 - you don't want that application to be
116:02 - crashed at some point by some
116:05 - bad input you want to catch and handle
116:08 - every type of input so that your
116:11 - application
116:12 - continues to run and if we want to stop
116:15 - it
116:16 - we can basically just shut it off here
116:19 - and process finished
116:24 - now we can do one optimization in our
116:27 - program
116:28 - and this would be to allow users
116:31 - themselves
116:32 - to stop the application using
116:36 - some specific input value so for example
116:40 - when they type in exit for example the
116:43 - application
116:44 - should stop only for that specific
116:48 - word so it shouldn't run anymore so how
116:51 - can we do that
116:52 - so basically instead of having a
116:54 - condition that is
116:55 - always true we want a condition that
116:58 - says
116:58 - if the user did not input
117:02 - word exit then continue running the
117:05 - program
117:06 - if user entered exit then basically just
117:09 - stop it right so we need to change our
117:12 - condition right here
117:13 - so here we want user input is not
117:16 - exit right so user input
117:20 - is not exit now we didn't learn
117:24 - how to check for not equals
117:28 - something right we have check for
117:30 - equality so we check whether
117:33 - input number equals zero or if it's
117:35 - greater than
117:36 - or smaller than however we didn't learn
117:39 - how to check for
117:41 - not equals not equals in programming and
117:44 - this is not specific for
117:45 - python is expressed like this
117:49 - so instead of two equation
117:52 - signs we have an exclamation mark and
117:55 - equals
117:55 - and if we want to compare it to a string
117:59 - obviously
118:00 - we type that string in our case it's
118:04 - exit so basically this condition
118:07 - tells our while loop while
118:11 - user input is not exit
118:14 - continue running the program so while
118:17 - this is true
118:18 - basically just keep moving on but if
118:20 - user enters
118:21 - exit this will not be true anymore it
118:23 - will be false
118:24 - so loop will basically break and
118:27 - application will
118:28 - end now you see that we have a warning
118:31 - on this user input
118:32 - that we're using here and if i hover
118:35 - over it you see a message that says
118:37 - name user input can be undefined
118:41 - so it's not always undefined but it can
118:43 - be and here i want to mention again
118:45 - that pycharm because it's an intelligent
118:49 - editor
118:50 - can give you actually this warning when
118:52 - otherwise
118:53 - in a simple or normal code editor
118:56 - you probably wouldn't get such a warning
118:59 - so again it helps you
119:01 - in avoiding some of the mistakes that
119:03 - you might accidentally
119:05 - make when writing code so basically it
119:08 - detects the errors or possible errors
119:10 - for you
119:11 - and tells you to fix it so again
119:15 - this kind of intelligent warnings and
119:17 - error messages
119:18 - can be a lot of help when programming an
119:21 - application
119:22 - and now let's fix that warning so what's
119:25 - that all about
119:26 - the problem is on the very very first
119:29 - run of
119:30 - this while loop user input
119:34 - variable itself will not exist
119:37 - why because we're creating that user
119:39 - input variable
119:41 - on this line first so our
119:44 - application will basically complain
119:47 - because
119:48 - when our while loop runs for the first
119:50 - time it will not be able to find
119:52 - user input variable let's actually try
119:54 - that
119:55 - and as you see user input is not defined
119:58 - so we need to create that user input
120:00 - variable before
120:02 - the first execution of the loop
120:05 - so right here
120:09 - we're going to create user input so
120:12 - we're going to create this user input
120:14 - variable
120:15 - before the while loops first run
120:18 - and it doesn't really matter what the
120:20 - value of that user input variable will
120:22 - be because
120:23 - what matters is the variable exists so
120:26 - the value is basically just empty
120:28 - and as long as it's not exit the
120:32 - loop will start running and our
120:34 - application will get executed
120:37 - so again to go through the flow of this
120:40 - we're creating a
120:41 - user input variable then we're making
120:43 - sure it's not
120:44 - exit if it's not this line will get
120:47 - executed so we get the
120:48 - input from the user that's going to be
120:50 - our first input
120:52 - and then we call validate and execute
120:55 - function
120:56 - that basically does all the checks and
120:58 - execution
120:59 - so that's going to be the first run of
121:02 - that loop
121:02 - on the second run of the loop the
121:05 - condition will get
121:06 - re-evaluated so now the user input is
121:09 - what the user provided so again python
121:13 - will check is the user input
121:14 - exit no cool let's execute the program
121:18 - again user will have to enter another
121:21 - value
121:22 - and then that value will get
121:25 - re-evaluated
121:26 - so note that after each time
121:29 - that this block of code has run and
121:31 - executed
121:33 - every single value that user will give
121:35 - as an input
121:36 - will be evaluated over and over again
121:40 - in that condition and while user input
121:43 - is something else then exit it will run
121:46 - the program
121:47 - if it is exit then the loop will break
121:51 - so let's actually test that
121:55 - so this is our first message and our
121:57 - first input
121:58 - let's do 10 it got calculated
122:02 - let's do minus
122:06 - again calculate it and we can do that
122:08 - over and over and over again
122:10 - and now let's actually enter exit and
122:12 - let's see what happens
122:14 - and as you see a process finished with
122:17 - exit code so our application actually
122:19 - stopped because this condition was not
122:22 - true anymore it was
122:23 - false because we entered exit
122:26 - so that's how we can allow users to
122:30 - finish the application and two takeaways
122:33 - here
122:34 - one is a conditional in a loop
122:37 - and the second one is a negative equals
122:40 - check
122:41 - for values
122:46 - great so now we have our application
122:48 - that basically
122:49 - allows inputs multiple times
122:53 - and can be terminated with exit
122:56 - input now what if i wanted to calculate
123:00 - number of hours for several days but i
123:03 - didn't want to
123:04 - basically just pass it on one after
123:07 - another because that's just
123:09 - too much effort for me so let's say i
123:10 - wanted to give it
123:12 - 10 different values but i don't want to
123:14 - type it in
123:15 - 10 times right i want that application
123:18 - to basically do the
123:19 - whole calculation for all those 10
123:21 - values but
123:22 - i just want to enter that list once
123:25 - instead of
123:26 - entering each value separately
123:30 - so in this part we're going to learn
123:32 - another data type
123:33 - in python called list
123:37 - so till now we have learned several data
123:39 - types
123:41 - like strings for example
123:46 - as well as integers and
123:49 - float numbers and
123:52 - boolean true or false
123:56 - and list is just another data type
123:59 - and the syntax for list is
124:03 - using square brackets and
124:06 - inside the square brackets we have a
124:08 - list of
124:10 - elements and those elements can again be
124:14 - either strings numbers or boolean values
124:18 - in our case we want to provide our
124:20 - application with a list of
124:22 - number of days right so we're going to
124:25 - have
124:25 - a list of integers
124:29 - like this
124:32 - and you can have as many values inside
124:35 - the list as you want
124:36 - and these are going to be comma
124:37 - separated and the syntax will look
124:40 - like this but again as i said you can
124:42 - have a list of strings
124:44 - list of booleans etc so as i mentioned
124:48 - we want to let user basically
124:51 - provide inputs as a list
124:55 - instead of those individual values one
124:58 - at a time
124:59 - so i'm going to copy this let's clean
125:03 - this up
125:04 - and let's actually see what happens if i
125:06 - just
125:07 - input that list as a value
125:10 - right here and enter you see program
125:14 - doesn't recognize that
125:15 - as a valid number obviously because we
125:18 - have the check
125:19 - and causes a value error that's why we
125:23 - get
125:23 - your input is not a valid number don't
125:26 - ruin my program
125:27 - message right here so we want to change
125:29 - that and
125:31 - make our program actually accept that as
125:34 - a valid
125:34 - input so how do we actually implement it
125:38 - and let's go through this logic
125:40 - theoretically first
125:41 - before we start implementing it what we
125:44 - need here is that
125:46 - we want to read this list and we want to
125:48 - do
125:49 - validation and execution for each
125:53 - value one at a time so that means that
125:56 - validate and execute function needs to
125:59 - be called
126:00 - for each value in that list right
126:04 - so basically this function for all this
126:07 - logic
126:08 - needs to be executed for each element
126:12 - now how do we get the individual
126:15 - elements
126:15 - of the list so you remember the
126:18 - definition
126:19 - of a loop loop is basically executing
126:23 - same function with the same logic
126:25 - multiple times
126:27 - and the number of times basically
126:30 - depends on the condition right
126:32 - here we have a condition for while loop
126:34 - and the condition
126:35 - for executing the same logic for each of
126:38 - those
126:39 - elements is going to be the number of
126:42 - elements in that list right so we want
126:45 - to execute the logic
126:46 - as many times as we have elements in the
126:49 - list
126:50 - and for that we have another type of
126:53 - loop
126:54 - called for loop and basically we want to
126:58 - execute validate and execute function
127:00 - using a for loop the syntax for
127:04 - for loop is a little bit different first
127:07 - of all we have four
127:08 - keyword just like for while then we have
127:12 - the
127:12 - element is a variable so we can call
127:15 - that
127:16 - number of days
127:19 - so this variable basically represents
127:22 - each
127:23 - of those elements in the list
127:26 - and then we have in which is again a
127:29 - keyword of python
127:31 - so for in basically puts together the
127:34 - for loop
127:35 - logic in python so python knows what we
127:38 - are trying to execute
127:40 - and finally we need the list
127:43 - that we are executing this loop on
127:47 - and our list is our user input
127:51 - and that's our for loop however
127:55 - again you remember the indentation the
127:57 - logic
127:58 - that for loop executes needs to be
128:01 - indented so it should belong to for loop
128:04 - so now we can read that for loop
128:07 - statement as follows
128:08 - for each element which we call we decide
128:12 - to call number of days
128:14 - in a list called user input
128:18 - we want to execute this logic
128:21 - exactly what i said before so for each
128:23 - element
128:24 - in this user input list we want to
128:26 - execute
128:29 - validate and execute function we don't
128:31 - have a condition
128:33 - written here like we did in while loop
128:35 - or
128:36 - if statement so the condition is
128:38 - basically implicit
128:40 - right the condition says however many
128:43 - elements there
128:44 - are in this list that many times that
128:47 - function or that block of code here will
128:50 - get executed
128:51 - so if i provide five elements you will
128:54 - be executed five times
128:55 - if i provide 10 elements it will be
128:58 - executed 10 times
129:00 - and that's exactly what we want however
129:02 - there are still
129:03 - a couple of things we need to do for
129:05 - this application to work
129:06 - properly first of all validate and
129:09 - execute
129:10 - function still uses user input
129:14 - right here so instead we want it to
129:17 - use the individual values of the user
129:20 - input because now it's going to be a
129:21 - list
129:22 - and not a number so this
129:26 - element we can actually call it num of
129:28 - days
129:29 - element this value should be used here
129:33 - instead
129:34 - right so we're going to use that element
129:37 - instead of the whole user input list
129:41 - and paste it here so that fixes the
129:43 - first problem
129:44 - and the second one is as you know user
129:48 - input is
129:48 - always a string so even if we provide
129:52 - a list of these it is still going to be
129:55 - considered
129:56 - as a string so we need something similar
129:59 - to
130:00 - this right here so the list of numbers
130:03 - that are provided as input needs to be
130:05 - converted
130:06 - in at least in python and we can
130:09 - actually do that
130:10 - in a convenient way using user input
130:15 - dot split and split is a function
130:19 - that will take user input as a parameter
130:23 - and will give us a list data type
130:26 - so split function basically will return
130:29 - a list
130:30 - of all those input values
130:33 - and again note the syntax of executing
130:37 - the split function
130:38 - we're not just calling a split function
130:41 - like this
130:43 - with user input as parameter instead we
130:45 - are basically
130:46 - calling it on user input and i'm going
130:48 - to explain
130:49 - more about this type of functions in
130:51 - python
130:52 - later but for now let's actually execute
130:55 - this application
130:56 - and see what happens so first of all
130:59 - how am i going to provide a list
131:03 - to this application so that
131:06 - userinput.split
131:07 - can actually convert it into a proper
131:10 - list in python and the way i should
131:13 - provide the values are
131:15 - list of values with spaces between them
131:20 - so basically like that so why spaces how
131:24 - come it's not
131:25 - a comma or something else the reason
131:28 - is because split function by default
131:32 - splits that provided list on
131:35 - spaces and then creates a list value
131:39 - out of them so that's the default
131:40 - behavior of split
131:42 - however we can override that behavior
131:44 - and we can decide you know what
131:46 - we want the input to be a list of
131:49 - numbers that are comma separated instead
131:52 - of
131:52 - space separated so what we can do is
131:55 - right here we can do split on a comma
131:59 - so that's what our split function here
132:01 - will do and now if i re-execute it
132:06 - and i can do commas now
132:11 - 40 55.
132:15 - so that's going to be user input and
132:17 - split
132:18 - with comma should convert it into
132:21 - a list value in python so let's execute
132:24 - it
132:26 - and as you see it worked fine we have
132:29 - a calculation for each of those values
132:33 - now let's actually play around with this
132:35 - and let's say we provide
132:37 - a list with some values
132:40 - and somewhere in between we decide to
132:43 - add a text
132:44 - and then maybe a float so let's see what
132:48 - happens now
132:49 - and you see that for those two valid
132:52 - numbers the calculation was done
132:54 - properly and for the other two basically
132:57 - the validation kicked in and it says
133:00 - that these are invalid numbers
133:02 - however again our application ran
133:05 - without any problems
133:06 - and we can even provide another input so
133:09 - now let's actually
133:10 - do 20 maybe a boolean even
133:15 - and a negative number execute
133:18 - and you see that for 20 the number of
133:21 - hours got calculated
133:23 - true is obviously not a valid number
133:26 - and minus 100 is a negative number
133:29 - so everything works perfect validations
133:33 - in place
133:33 - and we can provide a list here now and
133:36 - as a final optimization
133:38 - we can actually change this message here
133:40 - that says
133:41 - hey user enter
133:48 - number of days as a
133:51 - comma separated
133:55 - list and i will convert it
133:59 - to hours so now we can provide
134:02 - either just one value and it works fine
134:05 - or we can provide
134:06 - multiple values
134:10 - as a list
134:14 - and again if we want to see how that
134:16 - list
134:17 - actually looks like and check the type
134:20 - that it has in python let's actually
134:23 - print it
134:24 - so first i'm gonna print type
134:28 - of user input called split
134:34 - and then i'm just gonna print that list
134:38 - itself so let's execute
134:44 - and let's provide
134:51 - some values and here you see
134:54 - this is the class list so basically the
134:57 - data type
134:59 - list and that's how our list
135:03 - looks like so we have these square
135:04 - brackets here and each element inside
135:07 - as a string because we have the quotes
135:10 - here
135:10 - and later our application then
135:14 - transforms it or tries to
135:16 - transform it into an integer
135:19 - and you also see there are some
135:21 - additional spaces here because
135:23 - that's how we entered the values so
135:26 - basically
135:27 - the split splits the values on comma
135:30 - so this space also becomes part of that
135:34 - element
135:35 - so to fix that leading space in each
135:38 - value we can
135:39 - basically just add a space here so it
135:42 - will split on
135:43 - comma and space
135:47 - and let's test it out
135:56 - and there you go we have our values
136:00 - without the space before them
136:06 - so you saw an example of when we
136:09 - actually need
136:10 - to use list data types in this example
136:13 - we wanted to allow users to basically
136:16 - just input multiple values at once as a
136:20 - list
136:21 - but obviously this is just one of the
136:23 - use cases
136:24 - for a list and one of the specific
136:26 - examples because throughout the
136:28 - application you can create
136:29 - lists and you can use the elements of
136:32 - that list
136:33 - in another function so you can use it
136:35 - for multiple use cases
136:37 - and just to show you some basic syntax
136:40 - of
136:40 - how to create lists within your code
136:43 - inside your application so how to
136:46 - initiate it and then how to use that
136:49 - list
136:50 - i will show you the examples here so
136:52 - basically to create a
136:54 - list in your code you would use that
136:56 - syntax that i showed you earlier
136:57 - with square brackets and inside that you
137:00 - would have
137:01 - list of elements and this could be
137:03 - strings
137:04 - so it could be for example names of
137:07 - month
137:08 - let's say like this
137:14 - and then we would have to assign it to a
137:17 - variable right
137:18 - again just like we did for strings or
137:20 - integers or other data types
137:22 - so we can call it my list
137:26 - and this will give us a list with
137:30 - three string values inside
137:33 - and once you have created a list you can
137:36 - then
137:37 - use it to read the values from the list
137:40 - right
137:40 - so basically to get the individual
137:43 - values elements out of that list so for
137:46 - example if we wanted to print out
137:49 - the first element of my list
137:53 - then we would access that
137:56 - using my list and then following syntax
138:00 - with again square brackets and then
138:03 - index number of the element which is
138:06 - starting from zero so this is the first
138:09 - element with index zero this is
138:11 - the element with index one index
138:15 - two and so on right so it could be
138:17 - confusing because it starts with zero
138:19 - not with one but that's how the
138:22 - specific element of a list can be
138:25 - accessed right
138:26 - so if i wanted the march value here the
138:30 - third element then i would just
138:31 - type in index two and this is a syntax
138:34 - of
138:35 - getting elements from a list if i just
138:37 - want specific
138:39 - values and not each element one by one
138:42 - as we had in this example right so one
138:45 - way to use a list
138:46 - is to basically loop through it and get
138:49 - one element at a time
138:51 - and that's why we don't need to use
138:52 - index here because it gives us
138:54 - elements one after another or
138:57 - maybe we don't want all the elements or
138:59 - to do something for each element we just
139:01 - want specific
139:03 - values from the list for different use
139:05 - cases in this case we can
139:06 - access them individually like this and
139:10 - in addition to accessing the values from
139:13 - a list or basically reading the values
139:14 - from release
139:15 - we can also add values to a list
139:19 - and we can do that by typing my list
139:23 - and then on the my list we're going to
139:25 - do dot
139:26 - and use the append function
139:30 - right so append will basically take the
139:33 - next element
139:34 - or another value basically and add it to
139:38 - the list of elements already in the list
139:41 - right
139:41 - so let's say we want to add the next
139:43 - month
139:44 - and now if i print
139:47 - my list we should actually see
139:51 - this here with april as a fourth element
139:54 - right so let's execute and there you go
139:58 - so first we have march here printed out
140:01 - which is
140:02 - the third element right index two
140:05 - and then we have my list append that
140:09 - adds fourth month name into the list
140:12 - so after append this is how my list
140:15 - will look like and now again we can
140:18 - access
140:19 - the specific element for example if we
140:21 - wanted to access
140:22 - the newly edit element on index three
140:26 - so that's going to be the fourth element
140:29 - and there you go we have the new
140:31 - element printed out and also an
140:34 - interesting note is what happens
140:36 - if we use an index here which is
140:39 - too high so basically pointing an
140:41 - element that doesn't exist right so
140:43 - instead of three let's say we have
140:44 - four here so this will point to the
140:47 - fifth element and since we only have
140:50 - four elements let's actually see what's
140:52 - gonna happen so i'm gonna execute this
140:54 - and there you go you see an error index
140:57 - error that says a list index out of
141:00 - range
141:00 - so every time you access or you try to
141:04 - access an
141:04 - element at an index that doesn't exist
141:08 - you will get this list index out of
141:10 - range error
141:12 - and this is actually something that may
141:14 - happen pretty often
141:16 - when working with lists if you're
141:19 - accessing the values like this
141:22 - so this is how you work with lists how
141:24 - you create them and access
141:26 - values in them as well as add some
141:27 - values however
141:29 - note that most of the time if you are
141:31 - using lists
141:32 - you're going to be using them in a for
141:34 - loop because most of the time you would
141:36 - want to do
141:37 - something specific for each element in
141:40 - the list
141:41 - so this basically should give you an
141:42 - idea of syntax of
141:44 - lists and how to use them generally and
141:47 - also how to use them in combination with
141:49 - for loops here i want to take a few
141:52 - seconds to thank jetbrains
141:54 - the creators of the awesome pycharm and
141:57 - intellij editors
141:59 - for sponsoring this complete course
142:01 - besides all the great existing products
142:04 - they have
142:04 - they recently introduced space which is
142:07 - an
142:08 - all-in-one team collaboration platform
142:10 - covering software development
142:12 - project and team management and the
142:15 - great thing about space is that
142:17 - every single tool you would need in a
142:19 - company to collaborate and work together
142:22 - in a team
142:23 - is in one space so you have tools for
142:27 - chats blogs planning and creating tasks
142:30 - meetings but also software development
142:33 - tools like
142:34 - version control ci cd package
142:36 - repositories and much more
142:38 - so all these in one platform and in
142:41 - terms of
142:42 - productivity the great thing is you get
142:45 - all the notifications in one place
142:47 - like code review updates newly created
142:50 - issues
142:50 - new blog posts etc you get all of these
142:53 - in
142:54 - chats where you can react directly in
142:57 - place
142:57 - or add them to your to-do list
143:00 - automatically
143:01 - so i think the main value of space isn't
143:03 - that it has all these tools
143:05 - but rather the fact that it integrates
143:07 - them in such an intelligent way
143:10 - that it improves the team communication
143:12 - and productivity overall
143:14 - now let's go back to coding
143:19 - now at this point here i want to mention
143:21 - a pretty
143:23 - minor and simple detail but something
143:26 - that is also very
143:27 - important and useful in programming and
143:30 - that
143:30 - is comments so how do we write comments
143:33 - in python and why do we need or in which
143:36 - cases
143:37 - are comments actually useful one usage
143:40 - of comments is basically to give
143:41 - yourself
143:42 - some notes on your own code so
143:46 - basically if your code gets a little bit
143:48 - complicated
143:49 - and it's not really clear what the logic
143:51 - or the function body is doing
143:54 - it could be because of bad programming
143:55 - but also because
143:57 - the function logic is just a little too
143:59 - complicated
144:00 - so you want to add some textual notes to
144:03 - that code
144:04 - so that you understand what's going on
144:06 - there even when you look at that code
144:09 - days or maybe weeks after you wrote it
144:12 - so for example right here we may want to
144:15 - add
144:15 - some notes about what
144:19 - this part here is doing and comments in
144:22 - python
144:23 - are written with this character so for
144:26 - example
144:27 - i want to add a note here we want
144:30 - to do conversion only
144:34 - for positive integers
144:40 - and that's basically my note that
144:42 - summarizes
144:44 - all that logic right here and it is not
144:47 - only useful for myself
144:49 - in case i forget what this complex logic
144:52 - actually does but also for your team
144:55 - members so if you're working in a team
144:57 - and your code gets really complex and
145:01 - it's
145:01 - difficult to keep an overview of
145:03 - different functions and variables and
145:05 - what all these things do
145:07 - you can basically add these comments as
145:09 - notes
145:10 - to your team members so they can also
145:12 - understand what you thought
145:14 - or what kind of logic actually you were
145:17 - thinking about when writing this code
145:19 - so comments is a way of communicating
145:22 - your thoughts and your logic on your
145:25 - code so that's one use case for using
145:27 - comments
145:27 - and the second use case if you have a
145:29 - piece of code that you do not want to
145:31 - delete
145:32 - because it has some logic or it has some
145:35 - example that you want to
145:37 - keep as a reference but you don't want
145:39 - that code to be
145:40 - executed so basically you can comment
145:43 - out
145:44 - code so that it still stays there but
145:47 - doesn't get executed and the way to do
145:49 - that is just basically
145:52 - having this character before the line
145:55 - and also
145:56 - note the color of the comment in the
145:59 - editor
146:00 - is gray so it's immediately visible that
146:02 - these are the comments
146:03 - and now these two lines will not get
146:05 - executed by the program
146:06 - they will be ignored but they are for
146:09 - your own reference
146:10 - in case you want to keep it there for
146:12 - example this could happen
146:13 - if you are unsure about the change and
146:16 - you want to delete that whole code
146:18 - from your application because you might
146:20 - actually need that
146:21 - eventually so you're not sure about it
146:24 - so temporary
146:25 - comment the code before you permanently
146:28 - delete that
146:29 - so these are some of the use cases of
146:31 - comments
146:32 - now if you have multiple lines of code
146:34 - that you want to comment out
146:36 - or maybe hold text that you wrote as a
146:38 - note so for example you want to comment
146:40 - out all these four lines here
146:42 - obviously you don't want to do this in
146:44 - front of every line
146:46 - so for multi-line comments you can
146:48 - actually
146:49 - use the following syntax which is three
146:53 - quotes at the beginning and
146:56 - at the end and again you see the
146:59 - highlighting is
147:01 - different here which basically is
147:04 - highlighting of a string however it is
147:06 - ignored
147:07 - by the program and it will not be
147:09 - executed
147:10 - as a best practice you shouldn't have
147:13 - too many comments in your code because
147:14 - it will just add additional clutter
147:17 - and your code will look basically
147:19 - unclean so
147:20 - you should use them only when needed
147:26 - in this part i'm going to show you
147:28 - another data type in python
147:30 - called set so what is a set let's start
147:33 - our application again
147:35 - and let's say i provide here input
147:38 - values as a list let's say 20
147:41 - 40 and 20 again
147:44 - so basically i have duplicate values in
147:47 - my list
147:48 - and when i execute it i see that
147:51 - the program got executed for each
147:54 - element
147:55 - and i have duplicate results because i
147:58 - passed in the same value
148:00 - twice now again users
148:03 - they can input any value they want
148:05 - either
148:06 - intentionally or accidentally this could
148:08 - be bad values
148:10 - or things that don't make any sense so
148:12 - let's say
148:13 - we want our program to behave in a way
148:15 - that
148:16 - if user provides the same values twice
148:19 - or three times we only want to calculate
148:23 - the number of hours for that value just
148:26 - once
148:27 - so basically for this input we want just
148:30 - those
148:30 - two lines and basically ignore the
148:33 - execution again for the same value
148:35 - and you probably already guessed that's
148:37 - where set
148:38 - data type will help us so set is
148:41 - basically a list
148:43 - of elements but with unique values
148:46 - inside
148:47 - so list data type allows duplicate
148:50 - values
148:50 - the same value multiple times set does
148:54 - not allow duplicate values
148:56 - so how do we use set instead of a list
148:59 - and it's actually very easy to convert
149:01 - an existing
149:02 - list into a set and we can do that
149:05 - using a function called set
149:09 - and basically the parameter of our set
149:11 - function will be
149:12 - the list so if this list here contains
149:16 - any duplicated values that will be
149:18 - basically just filtered out
149:20 - when we convert it into a set so that's
149:22 - how it works
149:23 - and again for demonstration let's
149:27 - actually print out
149:28 - how set value looks like
149:32 - so i'm going to print the list first
149:36 - so that we can compare then we're gonna
149:40 - print out the set
149:45 - and let's also print out the types
149:49 - and i don't want to repeat this
149:51 - expression over and over again
149:53 - so what we can do even though this is
149:55 - just for demonstration
149:57 - we can actually
150:01 - extract it into a variable let's say
150:05 - list of days
150:11 - like this and
150:14 - we can use it everywhere we need and
150:16 - this is a little bit cleaner because
150:18 - we don't have to repeat the same
150:20 - expression
150:22 - over and over again and again let's
150:24 - print out the type
150:26 - of list of days and then print out
150:30 - the type of a set
150:34 - of lists of days and again you see that
150:38 - nested function calls three times
150:42 - and this should give us some interesting
150:43 - value that we can compare
150:45 - lists and sets and just a small note
150:48 - here that whenever we have this nested
150:50 - function calls
150:51 - think of the execution from inside
150:55 - out so the first function that will get
150:57 - executed in this chain
150:58 - is actually the set right so it starts
151:01 - from the last function
151:03 - in that chain so set function will get
151:05 - executed and convert that list into a
151:07 - set
151:08 - then type function will get executed on
151:10 - that resulting set value
151:12 - and then print will get executed and
151:14 - print basically the result
151:15 - of the type so the order goes from
151:18 - innermost function to the outer
151:20 - functions
151:22 - so let's save it and execute and now i'm
151:25 - going to
151:25 - again provide a list let's say 10
151:28 - and then 45 and 30 and 10 again
151:33 - and enter and first of all we see that
151:37 - 10 only got executed once and not twice
151:41 - and we can also see the first one
151:44 - is basically value of a list and you see
151:48 - at least here the second one is a set
151:51 - and you already notice the difference
151:54 - that list basically uses square brackets
151:58 - and set
151:59 - is represented using curly braces right
152:02 - and again it has value of 10 just once
152:05 - and again we have the data type of a
152:08 - list
152:08 - and a set so just to demonstrate that
152:11 - they are actually
152:12 - own separate data types
152:18 - and like we saw previously with lists we
152:22 - can also
152:22 - create sets as well as add an excess
152:25 - values from it
152:27 - so let's see an example here for example
152:29 - if you want to create a set
152:31 - the syntax for that will look like this
152:34 - as we already saw again set can have
152:37 - strings or numbers or booleans
152:40 - as its elements let's use the same
152:43 - example we use with lists so
152:45 - i'm gonna just basically type in names
152:48 - of the month here
152:50 - so let's say we have again january
152:55 - february
152:58 - march and we're going to
153:02 - assign that again to a variable
153:05 - so this will give us a set that we can
153:07 - create ourselves
153:08 - not just from the user input and now we
153:11 - can access
153:12 - the values the individual elements from
153:14 - the set
153:15 - and we can also add elements to the set
153:18 - however
153:19 - we cannot access the individual
153:23 - elements of the set like we did on lists
153:26 - right
153:27 - you remember on lists we use the syntax
153:31 - with square brackets and the index of
153:34 - the element
153:36 - in set we cannot actually do that
153:39 - instead we can only access the elements
153:42 - of a set
153:42 - in a loop so for example in a for loop
153:47 - we would write element
153:51 - in my set and then
153:55 - we can basically print that element so
153:58 - let's
154:00 - execute
154:02 - and right here you see all the elements
154:04 - printed out
154:06 - and again as i mentioned with lists also
154:08 - previously
154:09 - most of the time when you're working
154:11 - with lists or sets
154:13 - you're gonna want to look through the
154:15 - elements because you probably would want
154:17 - to do some operation
154:19 - on individual elements or some of the
154:21 - elements right instead of just grabbing
154:23 - individual
154:24 - one or two values from that now how do
154:27 - we
154:28 - add elements to a set
154:31 - let's see it as well we can add elements
154:34 - to my set
154:36 - using my set so the
154:39 - set itself the variable name and then if
154:42 - you do
154:42 - dot you see a bunch of built-in
154:45 - functions again
154:46 - set has its own built-in functions which
154:49 - are completely different from what
154:51 - list has and it has a function called
154:54 - ed and here we can basically add
154:58 - a new element again let's do april
155:01 - and now we can print my set
155:07 - and execute and there you go so we have
155:10 - here individual elements that are
155:12 - printed out
155:13 - and we have the new list after we edit
155:17 - april now one thing you probably already
155:20 - noticed
155:21 - when working with the set like printing
155:24 - its elements or
155:26 - adding a new element it doesn't work
155:29 - in the same sequence as with a list
155:32 - right
155:32 - so for list we basically had this
155:35 - january february march in this
155:37 - exact order and when we edit a new
155:39 - element
155:40 - basically it got added at the end right
155:42 - as a fourth element
155:44 - in set it's not ordered it's basically
155:48 - in a random order right
155:49 - so if i execute this again rerun
155:53 - you see the order changed here and here
155:56 - as well right
155:57 - and if i do it again there you go so
156:00 - this order and this order basically
156:03 - changes right
156:04 - so as you see working with sets
156:08 - is actually pretty different from
156:09 - working with lists
156:11 - so this means that set
156:14 - not having or not allowing duplicate
156:17 - values is
156:18 - basically just one of the differences
156:20 - between
156:21 - sets and lists and
156:24 - of course you're probably wondering i
156:26 - can add elements i can access elements
156:28 - what about removing elements right from
156:31 - lists or
156:32 - sets and you can do that actually
156:36 - the same way for both sets and
156:39 - lists so for example if we want to
156:41 - remove an element from a set
156:43 - we can execute a built-in function
156:45 - called remove
156:47 - and remove basically takes a parameter
156:49 - which is the value itself
156:51 - so let's say if we want to remove
156:53 - january from here
156:55 - then we're going to pass the value to
156:57 - remove function
156:59 - and now if i print my set again
157:03 - after the remove gets executed and let's
157:06 - run it
157:07 - and here you see the last print
157:09 - basically doesn't have january
157:11 - inside and as i said it works the same
157:14 - for lists so let me demonstrate
157:18 - this as well so on my list which has its
157:21 - own
157:22 - set of built-in functions one of them is
157:25 - remove
157:26 - which in this case is called the same
157:28 - for both set and list
157:30 - and this remove built-in function also
157:32 - accepts
157:33 - the value of the element you want to
157:36 - remove
157:36 - and let's print it again my list
157:42 - and execute there you go this is a set
157:46 - with the syntax with curly braces and
157:48 - this is a list
157:49 - which now doesn't have january inside
157:51 - because we removed it
157:53 - and as you know lists can have duplicate
157:56 - values
157:57 - so if we have january
158:00 - again here so two times and
158:03 - we do remove january it will actually
158:06 - remove
158:07 - the first occurrence of that value so if
158:10 - i execute this
158:12 - you see the first one got removed and
158:15 - the last one or the second january value
158:18 - is
158:18 - still there so that's how you work
158:22 - with sets basically and also how to
158:25 - remove
158:26 - elements from sets and lists
158:33 - so at this point i want to take time and
158:36 - review the functions that we have used
158:39 - from
158:40 - python itself so the functions that we
158:42 - ourselves didn't actually
158:44 - write and the functions that python
158:47 - basically makes
158:48 - available for us to use are called
158:51 - built-in functions
158:52 - so till now we have used function
158:55 - print which basically just takes
158:58 - some input this could be a string this
159:01 - could be a variable
159:02 - this could be a number doesn't really
159:04 - matter and
159:05 - basically just prints it in the output
159:08 - console right
159:09 - in the terminal we also saw input
159:13 - function that basically takes user input
159:16 - again we can provide a parameter which
159:19 - will be a message
159:20 - or leave it empty we also in the
159:23 - last example so an example of set
159:27 - function which basically takes a list
159:31 - and converts it into a set and another
159:34 - example
159:34 - is int again takes
159:38 - a string as a parameter and converts it
159:40 - into integer
159:41 - and all of these are built-in functions
159:44 - because python provides them to us
159:46 - so that we can use it in our code and in
159:49 - python
159:50 - there are a lot of very useful built-in
159:53 - functions for different purposes
159:55 - and as i mentioned most of these
159:57 - functions basically accept
159:59 - a parameter and then do something with
160:02 - that parameter
160:03 - that input that we provide that function
160:05 - and give us an
160:06 - output again print basically
160:10 - provides something here and gives us the
160:13 - output
160:14 - in the output window here
160:17 - in input we can provide some message
160:23 - that will again print an input here and
160:26 - the rest of them
160:27 - are giving value inside the code
160:30 - without displaying anything so in set we
160:33 - can
160:34 - provide a list
160:37 - and the same way a parameter here which
160:40 - is logical because the purpose of a
160:42 - function
160:43 - usually is to take some input like
160:46 - this as a parameter do something with
160:49 - that input
160:50 - and give us an output from that
160:52 - parameter and we have created our own
160:54 - functions
160:55 - that also take some input and
160:59 - give back some output like this and
161:02 - in addition to built-in functions that
161:05 - are called like this
161:07 - and our own functions we have also used
161:10 - third type of functions which is called
161:13 - directly on a value right and this is an
161:16 - example of that
161:17 - so basically directly on a value this
161:20 - could be a variable but
161:22 - also the string representation of that
161:24 - itself
161:25 - so if i had a string like that so
161:27 - basically directly on that value
161:31 - call a function like this and these are
161:34 - also built-in functions because
161:36 - python makes them available to us other
161:39 - than the syntax
161:40 - there is one major difference between
161:43 - these
161:44 - type of functions that are called
161:46 - directly like that
161:47 - and the functions that are called on the
161:49 - value itself
161:51 - and the main difference is that each
161:53 - data type
161:55 - has its own set of functions
161:58 - that can be executed like this so
162:02 - again let's take example of a string
162:06 - and if i do dot here you see
162:10 - the ide pycharm basically gives me
162:14 - a list of all the functions
162:17 - again built-in functions in python but
162:19 - functions that i can execute
162:21 - on a string value and
162:24 - again you see split is digit this is the
162:27 - one that we used
162:28 - in one of our previous examples that
162:30 - basically checks if that string
162:33 - is a representation of a digit or just a
162:35 - regular string
162:36 - and as you see lots of different
162:41 - functions so all of these are provided
162:44 - by python
162:45 - to do different stuff like turn the
162:48 - string literal to uppercase or
162:52 - replace a letter for example in that
162:55 - string
162:56 - and so on but the main point here is
162:58 - that those functions
163:00 - are only for string but as i said
163:03 - each data type has its own list of
163:06 - functions
163:07 - that can be called on that data type so
163:10 - for a demonstration let's take a list
163:15 - and if i do dot here
163:18 - again you see a list of functions that i
163:22 - can execute specifically
163:23 - on list values and there are lots of
163:26 - things that you can do with lists like
163:28 - add elements to it remove elements from
163:31 - it
163:32 - sort the list copy and so on
163:35 - so that's basically a major difference
163:37 - between
163:38 - these type of functions and functions
163:40 - that can be executed on
163:42 - specific data type values but the
163:45 - concept is the same here
163:47 - you also have a function that gets a
163:49 - parameter an input
163:51 - and gives you an output and the
163:53 - parameter for this type of functions
163:56 - is actually the value that we are
163:57 - calling that function
163:59 - on so this string here 2 3
164:02 - is going to be parameter of the split
164:05 - and in addition to that we can also
164:07 - provide
164:07 - additional parameters for example for
164:10 - split you saw here that we were able to
164:12 - add
164:13 - a comma space to basically tell
164:16 - the split function on which character to
164:19 - split that text
164:20 - so that was function comparisons in a
164:23 - nutshell
164:27 - in this part we're going to learn a new
164:30 - data type in python
164:31 - called a dictionary and we're going to
164:34 - do that by modifying our application
164:37 - and modifying how users can actually
164:39 - input
164:40 - the values now our program currently
164:44 - takes the number of days and turns it
164:46 - into a number of hours
164:47 - what if we wanted to make our program a
164:49 - little bit more advanced
164:51 - a little fancier and basically allow
164:54 - users to also decide
164:56 - what units it should be converted to so
164:58 - user gives us the number of days
165:01 - and tells us whether to convert it into
165:03 - hours
165:04 - or minutes so instead of the whole list
165:08 - now we're going to get just number of
165:10 - days and
165:11 - the conversion units and this change may
165:14 - be a little bit complex
165:16 - in terms of syntax so i will try to
165:18 - explain everything step by step
165:20 - so the first thing we need to do is
165:22 - adjust
165:23 - how we get input from the user so now we
165:26 - want the user to
165:27 - be able to give us the number of days
165:30 - and units in one input so
165:33 - first of all i'm going to adjust the
165:34 - text here
165:37 - enter a number of days
165:42 - and conversion unit
165:45 - now there are a lot of different ways we
165:47 - can allow a user to do that
165:49 - but what we want to do is something like
165:54 - this as an input so basically number of
165:57 - days
165:59 - colon and minutes or
166:03 - number of days and hours again this is
166:06 - our own decision
166:07 - we decide how the user input should look
166:09 - like
166:10 - but this should be a nice way of
166:13 - providing both of those values
166:15 - basically colon separated so instead of
166:18 - a list
166:19 - we're going to have a single input with
166:21 - two values that are
166:23 - separated by a colon so on the next line
166:26 - i'm going to change this split here
166:28 - into a column and this will give us
166:32 - user input this whole value split into
166:35 - two values as a list this is going to be
166:39 - day and days and
166:42 - unit so least with these two
166:46 - values and let's actually get rid of
166:48 - this for loop because we're not
166:50 - iterating through a list of numbers
166:53 - anymore
166:54 - and to begin with let's just print out
166:57 - the output or the result
167:01 - of days and unit variable
167:04 - so i'm gonna refresh and let's do
167:08 - two hours and enter
167:11 - and this is what we get so basically
167:13 - splitting this string
167:15 - on column will give us a list with
167:17 - elements
167:18 - 20 and hours and note that 20 is still
167:21 - a string right because that's how we get
167:23 - the input and now
167:25 - from those two values we're going to
167:27 - create
167:28 - a value of a data type called
167:31 - dictionary so in python we have another
167:34 - data type
167:35 - called the dictionary which basically
167:38 - looks
167:38 - like this so you have curly braces just
167:42 - like we had for
167:43 - a set and inside we have key
167:46 - value pairs so we don't have just single
167:48 - elements
167:49 - like this but rather we have key value
167:53 - pairs
167:53 - so key in our case is
167:57 - days and the value of that key
168:01 - in our case would be 20. and then comma
168:04 - separated another value would be
168:07 - unit and
168:11 - a string hours so basically this is
168:15 - the syntax of a dictionary and obviously
168:18 - the
168:19 - difference between a list and a
168:21 - dictionary is that we have
168:23 - descriptions for each of our values
168:26 - represented as key value pairs so we
168:29 - want to
168:30 - create this construct right here from
168:32 - those two values
168:34 - and since this is a data type we can
168:36 - create a value and
168:37 - assign it to a variable of that data
168:40 - type so let's call it
168:42 - days and unit
168:46 - dictionary
168:49 - equals and obviously we don't want those
168:52 - values to be
168:53 - hard coded here we want to get it from
168:55 - the list
168:56 - now how do we access an element
168:59 - of a list how do we grab the first value
169:02 - which is
169:03 - 20 out of that list
169:06 - and to do that there is a syntax to
169:09 - access the elements
169:10 - in the list the list name and then you
169:12 - have
169:13 - square brackets and index of the element
169:17 - which if you remember you already
169:19 - learned in the section
169:20 - of lists so again days of unit
169:24 - list is this one right here and with
169:28 - index 0 we are accessing the first
169:30 - element
169:31 - index 1 is the second element and so on
169:34 - and
169:35 - index is basically just location this is
169:36 - location 0 location
169:38 - 1 and so on so this will give us the
169:41 - first value
169:43 - and obviously the second value is going
169:45 - to be with the same syntax with index
169:48 - one and let's actually print
169:51 - that one out as well
169:55 - so that we see the results restart the
169:58 - application
170:00 - let's do 20 hours
170:04 - so again this is our list 20
170:07 - hours as two separate values and this is
170:10 - a dictionary that we
170:12 - created using those two values
170:16 - so we have key value pairs basically and
170:19 - the same way
170:21 - for minutes we would end up with a
170:23 - dictionary that looks like this
170:25 - so now we have these two pieces of
170:28 - information in one variable
170:30 - and now we can give that variable to our
170:32 - function so that it does the validation
170:35 - first of all of the number and
170:39 - calculation based on the units so
170:42 - on the next line we're going to call our
170:45 - validate and execute function
170:50 - and as you see we have this red line
170:52 - here because something
170:53 - is wrong first of all we don't have this
170:57 - variable called num of days element
170:59 - anymore
171:00 - because we deleted the for loop instead
171:04 - we have days and
171:07 - unit dictionary and here we are
171:10 - validating
171:11 - the integer value of the input number
171:14 - and the same way we need to validate
171:16 - this input number here
171:18 - as well so now the question is
171:21 - how do we access a specific value in
171:24 - this case
171:25 - the value of days here in a dictionary
171:28 - because we have to validate this value
171:30 - as well because i might as well
171:32 - have entered text instead of this number
171:36 - so the way to access values
171:39 - inside a dictionary is again
171:42 - using the square brackets just like we
171:45 - did for list
171:46 - but instead of an index index 0 or index
171:50 - 1 we don't need to use an index because
171:52 - we
171:53 - actually have a key so instead of index
171:56 - we're going to
171:56 - use the key like days or
172:00 - unit and this will give us
172:03 - value of 40 which will then be
172:06 - converted into an integer and then
172:08 - validated right here
172:10 - so again i'm gonna copy this
172:13 - for comparison so to access
172:17 - an element of a list let's say
172:21 - my list here and let's do
172:24 - 20 30 doesn't matter in order to access
172:29 - the elements
172:30 - of that list
172:36 - we can do that using an index so this
172:38 - will basically
172:42 - print number 30. again if we had
172:46 - other elements here we can do index
172:50 - 2 so that will print out 100 and let's
172:53 - actually
172:54 - check that and remember to comment out
172:57 - a multi-line code we can use
173:00 - three quotes at the beginning and at the
173:03 - end
173:04 - let's refresh and there you go 100
173:08 - was printed let's do the same with the
173:10 - dictionary
173:13 - so we have a dictionary
173:22 - days
173:24 - like this and
173:28 - to access an element inside
173:31 - that dictionary we use the square
173:34 - brackets
173:35 - and instead of the index like here on
173:38 - the list
173:39 - we use the key itself
173:42 - and again i'm going to print this
173:47 - and there you go you see
173:52 - value 20 and i can also access
173:57 - unit value and if i execute it i see
174:01 - hours and so on and i can
174:04 - add any number of key value pairs in my
174:07 - dictionary as i want
174:09 - so for example i can add a message here
174:13 - all good and
174:16 - i can access that message
174:20 - like this so this is how you create a
174:22 - dictionary and that's how you
174:24 - access the values in a list or in a
174:27 - dictionary
174:28 - so let's clean this up
174:32 - comment in our code again like this
174:36 - and get back to our code
174:39 - so basically again this is how we access
174:42 - the
174:43 - number of days in our dictionary and
174:46 - in our days to units function we need
174:50 - both of those values and we can
174:54 - pass in those values separately so we
174:56 - already have a user input number
174:59 - from the dictionary and the second value
175:01 - would be
175:07 - the unit from the dictionary
175:11 - however we have to add that second
175:13 - parameter to our function
175:15 - so let's do that unit
175:18 - let's call it conversion unit
175:22 - so now we are passing both of these
175:24 - values
175:25 - to our function so we have the user
175:28 - input number here
175:29 - which is already converted into an
175:31 - integer
175:32 - and the second one which is the
175:35 - conversion
175:35 - unit and now we can finish
175:39 - the logic in this function here
175:42 - right now we are using this hard-coded
175:45 - calculation to units which is
175:47 - 24 and number of units which is
175:50 - hard-coded hours
175:51 - so first of all i'm going to remove
175:52 - those two we don't need them anymore
175:54 - because we get those values from the
175:56 - user
175:57 - and now we have to substitute
176:00 - those two so here we're going to check
176:03 - if the conversion unit is
176:04 - hours
176:09 - equals hours
176:13 - then we're going to return calculation
176:16 - with
176:16 - hours it's going to be 24 and
176:20 - conversion unit here we can also hard
176:23 - code
176:23 - hours here because we know it's hours
176:28 - else if
176:31 - so if the conversion unit is
176:35 - minutes
176:39 - then we can return
176:43 - calculation for minutes and a text like
176:46 - this
176:47 - and it could also be that the conversion
176:50 - unit that was provided
176:51 - is none of those or maybe some invalid
176:54 - text
176:55 - and in this case we're gonna add final
176:57 - validation so
176:58 - if it's neither hours nor minutes
177:02 - then we're just gonna say you know what
177:06 - unsupported
177:10 - unit
177:13 - so basically we don't do conversions
177:16 - other than those two
177:17 - so we just tell the user that's an
177:20 - unsupported unit
177:21 - and now if we execute our
177:25 - program and enter
177:29 - value there you go we have
177:33 - our output and same way if we do
177:38 - 90 days to hours
177:41 - we have our calculation in hours so
177:44 - that's how dictionaries work we can do
177:46 - one final thing here and
177:49 - as usual print out the type
177:54 - of our dictionary
178:02 - and there you go you see class of type
178:04 - dictionary here
178:06 - which is another data type and at this
178:08 - point we can actually
178:09 - summarize all the data types that we
178:11 - have learned so far
178:13 - so let's give us some space here so
178:16 - first one was string so basically
178:19 - a message or some output
178:26 - like this
178:31 - that's our string then we have integers
178:34 - example of that we saw already days
178:37 - then we have float numbers which for
178:40 - example can be used for
178:42 - price or
178:45 - weight of a product etc we also have
178:49 - learned boolean data types when we check
178:52 - some kind of condition whether if it's
178:55 - true or not
178:56 - so for example is it a valid number
179:02 - or is the user input
179:05 - exit
179:09 - we also learned a data type of lists
179:13 - so for example usage list
179:16 - of days
179:23 - like this including duplicate values
179:27 - and list data type can be used for
179:30 - strings as well
179:31 - not only for numbers so for example we
179:35 - can have list of month
179:37 - like january
179:41 - doesn't really matter we also learned a
179:43 - data type
179:45 - called set and set basically
179:49 - is very similar to list but it doesn't
179:53 - allow
179:53 - duplicate values and its syntax is
179:57 - with curly braces so the same way we can
180:01 - have
180:02 - numbers or strings or booleans or any
180:06 - other data types
180:07 - inside a set and the last one that we
180:09 - learned
180:10 - was a dictionary
180:14 - and let's take our own example
180:17 - day in unit
180:21 - and dictionary is basically a collection
180:25 - of key value pairs and the syntax
180:29 - is written like
180:32 - this so why do we need all these
180:35 - different data types
180:37 - well depending on the use case or what
180:40 - exactly you are trying to achieve in the
180:42 - program
180:43 - you're gonna need a different data type
180:45 - to achieve exactly that
180:48 - so each data type has its own specific
180:51 - purpose
180:52 - and throughout these days to units
180:54 - calculator i try to
180:56 - demonstrate the purpose of each data
181:00 - type
181:00 - and when we need to use them so these
181:03 - are all the data types that we learned
181:05 - these are also
181:06 - most of the data types available in
181:08 - python and the main ones
181:10 - that you're going to be working with so
181:12 - this should give you a good foundational
181:14 - knowledge about data types
181:16 - in python and also note that most of
181:19 - these data
181:20 - types you will also encounter in any
181:23 - other programming languages
181:24 - because as i said these are the core
181:26 - data types and most of the programming
181:28 - languages actually support these data
181:30 - types as well
181:35 - till now we have been writing all our
181:37 - code
181:38 - in one single file so basically we have
181:42 - a project
181:42 - with just one python file and we're
181:45 - writing all the logic
181:46 - inside that file however you can imagine
181:49 - that
181:50 - if you're writing a little bit more
181:52 - complex applications
181:53 - that have much more complex logic so
181:56 - they end up having
181:57 - lots of functions obviously you're gonna
182:00 - end up with a python file that has
182:03 - hundreds of lines of code maybe
182:05 - thousands of lines of code
182:07 - and it's not very practical to manage
182:10 - all this logic and all this code in just
182:12 - one file so instead you need to
182:15 - structure your
182:16 - code and divide your logic between
182:19 - multiple different python files and you
182:22 - do that
182:22 - with modules to give an example
182:25 - imagine a web application that has
182:28 - basically many features like facebook
182:30 - for example
182:31 - obviously you can put all the facebook
182:33 - logic in
182:34 - one single python file right you will
182:36 - have a structure
182:38 - of facebook project with subfolders in
182:42 - your project
182:43 - which all contain multiple python files
182:46 - so you would have
182:47 - maybe packages for each feature
182:50 - and each such feature has a lot of
182:52 - functionalities
182:53 - so they will be all grouped then again
182:55 - in multiple
182:57 - python files right so you would end up
183:00 - with
183:00 - a project with a hierarchy of folders
183:03 - and lots of lots of python files inside
183:06 - now the question is if i
183:10 - have multiple python files in my project
183:13 - how do i connect them together so for
183:16 - example if i have
183:17 - another file here and let's call it
183:20 - helper
183:21 - dot py
183:25 - and if i have some logic here basically
183:28 - functions defined here how do i use them
183:31 - or how do i reference them
183:33 - in another file and the way it works in
183:37 - python is using the concept
183:40 - called modules so a module is basically
183:43 - a python file that contains
183:46 - functions or variables that
183:50 - you can use in another python file
183:53 - so basically any python file that you
183:55 - have in your project
183:57 - both of these in this case are modules
183:59 - and you can reference
184:01 - one module from another so basically
184:04 - the idea is that you can structure your
184:07 - application
184:08 - your program using modules so you can
184:11 - make your project
184:12 - modular so in this part we're going to
184:14 - create our own module
184:16 - in helper file and we're going to
184:18 - reference that in main dot
184:20 - python
184:23 - and let's say in main.python i only want
184:26 - the code
184:27 - that basically starts the program right
184:29 - all the functions
184:30 - all the logic i kind of want it hidden
184:33 - away
184:34 - and grouped together in a separate file
184:37 - so what we're going to do is copy this
184:40 - entire thing
184:41 - so both of these functions basically and
184:45 - paste it in here so now you already see
184:49 - a couple of
184:50 - red lines here because now the reference
184:53 - is obviously broken right
184:55 - so main.python obviously doesn't know
184:57 - anything about
184:58 - validate and execute function right it
185:00 - says unresolved
185:02 - reference and the same way face to unit
185:05 - dictionary is unresolved for helper
185:08 - because it doesn't know anything about
185:10 - main.python and the variables defined
185:13 - right here so the first thing we need to
185:15 - do is we need to tell
185:17 - main note python file where to find this
185:20 - validate and
185:21 - execute function right we have defined
185:24 - it in helper python so
185:25 - that's what we need to define how we
185:29 - do that is using something called an
185:31 - import
185:32 - statement so we basically import
185:35 - this whole helper.pi module
185:39 - inside main.python and we do that
185:43 - very simply using import
185:47 - helper right helper is the name of the
185:50 - file
185:50 - and therefore name of the module and
185:54 - right now it's grey because we're not
185:56 - using it
185:57 - and the way to use it is helper dot
186:00 - and the function name and you see the
186:02 - red line disappeared
186:04 - so again what we did is we told
186:06 - main.python
186:07 - there is a helper module in this project
186:11 - and please import this whole module
186:14 - and all the functions that this module
186:16 - has and make it available
186:19 - in main.pi and then once we have that
186:22 - helper module
186:23 - we can reference any functions if we had
186:27 - any variables
186:28 - using module name dot
186:31 - function so this has to be the name and
186:35 - if i hover over it you see that pycharm
186:38 - actually displays the whole path
186:42 - to that helper.pi file
186:45 - and now note that here we still have
186:48 - redline
186:49 - because this is a variable which is
186:52 - defined in main
186:53 - dot pi but a helper module doesn't know
186:57 - anything about it and that's an
186:58 - important distinction here
187:00 - because we imported helper module inside
187:02 - main
187:03 - so helper modules functions are
187:05 - available here but not the other way
187:08 - so in order to make this dictionary
187:10 - available
187:11 - invalidate and execute function we would
187:14 - need to
187:14 - pass it in as a variable like this
187:19 - and this will work now now
187:22 - note that in main.python
187:26 - we actually only need this validate and
187:29 - execute function
187:30 - we don't need the days to units function
187:32 - because
187:33 - this function is only used by validate
187:36 - and execute function
187:38 - so that means that we don't need to
187:41 - import the whole entire module inside
187:44 - main.pi
187:45 - we actually only need the validated
187:48 - execute function
187:49 - and this is a small example but if you
187:52 - had a module with
187:53 - 20 30 functions and you just needed one
187:56 - of them
187:57 - you wouldn't need to import the whole
187:59 - module just for that one function
188:02 - so what you could do is you can pick and
188:04 - choose which
188:06 - specific functions you want to
188:10 - make available inside another file
188:13 - or another module and you can do that
188:15 - very easily
188:16 - using the following syntax we say from
188:20 - helper that's the module again import
188:24 - and the name of the function
188:29 - like this and now because we are
188:31 - accessing
188:32 - and importing that specific function we
188:35 - don't need
188:35 - to use module name anymore we have that
188:38 - function
188:38 - available directly so we can delete the
188:41 - module
188:42 - reference here and we have that function
188:44 - available
188:45 - like this so again instead of having
188:48 - entire
188:48 - helper module with all of its functions
188:51 - and
188:51 - other stuff we only have one specific
188:55 - function
188:55 - available here so that means we wouldn't
188:58 - be able to use
188:59 - these two units for example now we saw
189:01 - an example
189:02 - of a module that has just functions
189:05 - right
189:05 - however module can have many other stuff
189:08 - for example
189:09 - variables and you can make those
189:11 - variables also available
189:13 - for another program and that's an
189:16 - example here
189:17 - i'm going to create a variable called
189:21 - user input
189:28 - message
189:30 - and this is our user input message and
189:33 - we can actually
189:34 - put it into a variable instead of having
189:37 - it defined like that
189:38 - so i'm going to copy it
189:41 - and paste it here so now we have
189:45 - the user input in a variable in another
189:48 - file
189:49 - again how do we access it in main dot pi
189:53 - in this statement at the top we can
189:55 - actually import
189:56 - several things from a module
189:59 - right now we are importing a function we
190:02 - can also
190:03 - import our variable and we can do that
190:06 - also very easily
190:09 - like this and we can use that
190:12 - user input message here so basically if
190:15 - you have
190:16 - again 20 functions and variables
190:19 - from a module and you just need maybe
190:22 - five of them
190:23 - you can import them individually
190:26 - like this just basically just list the
190:29 - names
190:29 - of functions and variables what you can
190:32 - also do
190:33 - is import all this is what this
190:37 - asterisk sign represents so we're
190:40 - basically importing
190:41 - everything from the helper module again
190:44 - this is kind of a waste if you just need
190:47 - a couple of
190:48 - functions and variables from that module
190:51 - and not the entire thing
190:53 - however with this syntax you can import
190:56 - everything
190:56 - and now you may be wondering what is a
190:58 - difference between
191:00 - importing everything from the module and
191:02 - importing the whole module
191:04 - because in both cases you have
191:06 - everything in the module available
191:08 - the difference is in the syntax because
191:10 - note that if we
191:12 - use this from import statement
191:15 - you don't need to use name of the module
191:18 - every time you're
191:19 - accessing something defined in that
191:21 - module right
191:22 - so we don't need to do helper dot
191:24 - function name or helper dot
191:26 - variable name whereas if we imported
191:30 - the module like this you see
191:33 - we have red lines because we would need
191:35 - to do
191:37 - helper dot or module name dot
191:40 - whenever we use something from the
191:42 - module now this could be
191:44 - a matter of taste so basically which one
191:47 - you want to use i personally think that
191:52 - this is the most efficient and also
191:54 - cleaner way of
191:56 - using specific functions variables etc
191:59 - defined in a module
192:01 - and as a side note the things that are
192:04 - defined in a module
192:05 - that you can use basically in another
192:08 - file are called
192:09 - definitions so all these those three
192:12 - elements here
192:13 - are definitions of a module and you can
192:16 - use
192:16 - any of those definitions in a file where
192:19 - you
192:20 - import that module what you can also do
192:23 - when importing a module
192:24 - is you can rename that module basically
192:27 - to
192:27 - whatever you want so if the name of the
192:30 - module
192:30 - is too long or you just want to use a
192:33 - different name
192:34 - you can do as and then basically write a
192:37 - name whatever you want
192:39 - like h for example and then obviously
192:42 - you need to use that
192:43 - new name everywhere you access
192:47 - functions or variables of that module
192:50 - so basically how you import a module and
192:53 - whether you rename it
192:54 - is a matter of taste basically how you
192:57 - want
192:57 - to do that in your code
193:01 - however i think that importing specific
193:05 - elements from a module like this is
193:08 - most efficient and also cleanest way to
193:11 - do that
193:12 - so we saw how to create our own module
193:16 - and use it in another file so basically
193:19 - if you had hundred python files here
193:21 - with each one of them having their own
193:23 - functions and variables you can cross
193:25 - reference them from each other using
193:28 - the import statement very easily
193:34 - now in addition to creating your own
193:36 - modules
193:37 - we can actually use modules that python
193:40 - itself already includes so just like we
193:43 - used some
193:44 - functions that python gives us out of
193:47 - the box
193:48 - like inputs or ins so basically all of
193:50 - those
193:51 - the same way python also gives us
193:54 - modules
193:55 - for different scenarios so that we don't
193:58 - have to write this logic
193:59 - ourselves and there are a lot of useful
194:03 - modules that python actually includes
194:06 - for example math module for mathematical
194:09 - operations
194:10 - its own module for working with dates or
194:13 - date times
194:15 - module for working with specific files
194:18 - and so on so basically
194:19 - for many different use cases python
194:21 - already gives you
194:23 - ready modules and these modules will
194:25 - then contain multiple functions
194:27 - and variables for that specific use case
194:30 - again if we take an example of a date
194:32 - so if you have an application that works
194:35 - with dates
194:36 - and times you have this module from a
194:38 - python
194:39 - that gives you a bunch of useful
194:42 - functions
194:43 - for working with dates and again this
194:44 - means you don't have to write this logic
194:47 - yourself but rather use the existing one
194:53 - so to give you some examples of modules
194:56 - that
194:56 - python provides us with for example if
194:59 - you want to
194:59 - work with operating system there is an
195:02 - os
195:02 - module so
195:06 - we can print out we can get the name
195:09 - of the os for example
195:14 - and i'm going to comment all this out
195:19 - and run and you see the name of the os
195:23 - another useful module python offers is
195:27 - logging so if you want to use logging in
195:29 - your application
195:31 - the logging module gives you different
195:33 - functions to log
195:34 - an error message or warning etc
195:38 - as well as basically just configure how
195:41 - the login will look like
195:42 - again to see an example
195:49 - again it may look a little bit complex
195:51 - here but essentially
195:52 - just using the name of the module and
195:55 - then functions that
195:56 - it gives you obviously you need to know
195:59 - the functions
196:00 - and you need to know how to use them and
196:02 - you can get that information from
196:04 - documentation
196:05 - or if you're using pycharm
196:08 - it actually gives you all the
196:10 - information about these functions and
196:11 - the module
196:12 - if you just hover on it so you don't
196:15 - even need to
196:16 - google or check out the documentation
196:18 - and basically we're
196:20 - creating a logger and we're logging an
196:22 - error message
196:23 - so if i execute this now and here you
196:25 - see
196:26 - the output of the logger error happened
196:29 - in the app and logging in application is
196:32 - actually
196:33 - a very important feature so that's why
196:35 - logging module is available
196:38 - by default in python any use case
196:41 - in our application would be right here
196:44 - if an
196:44 - error happened for example instead of
196:47 - using a print basically just
196:49 - log and error so these were just
196:52 - some basic examples but as i said python
196:55 - comes
196:56 - with lots of very useful modules that
196:58 - you can
196:59 - use in your applications for different
197:02 - use cases
197:03 - and that of course makes your work
197:05 - easier
197:06 - because you can just use the logic
197:07 - instead of having to write it
197:09 - yourself in the modules that are part of
197:13 - python so that you can import them like
197:16 - this
197:16 - directly are called built-in modules we
197:19 - learned about built-in functions
197:21 - so these are the functions that python
197:23 - makes available to us
197:25 - directly and there are built-in modules
197:28 - that we get from python
197:29 - and by the way if you're wondering where
197:32 - this module actually comes from so where
197:34 - is the physical location
197:36 - on our machine or where this module
197:39 - files actually
197:40 - leave if you're using pycharm you can
197:43 - actually hover
197:44 - over it and hold down a control key or
197:46 - if you're a mac
197:47 - command key and click inside
197:51 - you see the file opens up which is the
197:53 - module the logging module
197:55 - since i said module is basically just a
197:57 - python file that has
197:59 - multiple functions variables etc
198:01 - available and you see right here
198:03 - on this top line the whole path
198:06 - for that python file so that's the
198:08 - location
198:10 - of that module file locally on my
198:12 - computer
198:14 - and inside this python file basically
198:16 - you again have python code
198:18 - and if we look for get logger function
198:22 - here like this
198:26 - right here you will find the definition
198:30 - of that function right so somebody
198:32 - implemented this function
198:34 - and called it get logger
198:38 - and this is basically the logic all the
198:41 - things that get
198:42 - executed behind the scenes and
198:45 - you as a user of python basically can
198:48 - use the name of the function
198:50 - and write your own programs with it
198:54 - and let's also look for error
198:58 - and there you go we have error function
199:00 - as well right here
199:02 - and obviously this is a more complex
199:04 - code here
199:06 - than what we write but just
199:09 - to give you an idea that this is
199:11 - actually a file on your machine
199:13 - that comes with the python version that
199:16 - you
199:16 - install locally and all the functions
199:20 - are defined already there by python
199:22 - developers
199:23 - and you can just use them like this
199:26 - without worrying about
199:27 - how the logic is actually implemented
199:30 - and another interesting thing is if i
199:33 - click here
199:34 - in this python 3.9
199:38 - like this logging is basically one
199:41 - module
199:41 - that we used and here you will see
199:45 - the list of the complete list of all the
199:48 - built-in modules
199:49 - that you get from python so some of them
199:52 - are folders
199:53 - like logging for example email and bunch
199:56 - of other stuff
199:57 - and the operating system module for
200:00 - example that we used
200:01 - is a python file then you can find
200:04 - right here so these are the built-in
200:08 - modules
200:12 - so now that we know what built-in
200:14 - modules are and how to use them
200:16 - let's actually see a realistic example
200:19 - and
200:19 - also write a little more interesting
200:21 - application using
200:23 - built-in module
200:26 - so what i'm going to do is in my python
200:28 - project i'm going to create a new file
200:31 - and i'm going to call this time to
200:34 - deadline dot pi y
200:38 - and we're going to write an application
200:40 - that basically accepts a user input
200:42 - of a goal and a date like a deadline
200:46 - date
200:46 - and then we're going to print out back
200:48 - to the user
200:49 - how much time it is remaining till that
200:52 - deadline
200:52 - and that deadline will be a date right
200:56 - some date in the future so that means
200:58 - that we're going to be working with
201:00 - dates
201:04 - and in order to work with dates we are
201:07 - going to need
201:07 - python's built-in module that allows us
201:11 - to call functions and do some processing
201:14 - and stuff
201:15 - on date values and that module
201:18 - is called date time so
201:22 - import date time
201:25 - so let's have that import statement
201:27 - right there and we're going to use it
201:29 - in our program so the first thing we
201:31 - want to do is
201:32 - let the user give us an input about
201:35 - their goal
201:36 - and a date or deadline for that goal
201:41 - so let's do that first
201:44 - we already know how to ask for user
201:46 - input
201:47 - with a message so we're gonna say enter
201:51 - your goal with a deadline
201:56 - separated by colon and we also know this
202:00 - already
202:01 - basically what we want to do is user to
202:04 - be able to
202:05 - enter their goal like learn python
202:09 - column and a date and let's say
202:12 - again this is totally up to us to decide
202:15 - we're the ones basically setting the
202:17 - rules here so let's say we want the date
202:20 - to be entered in following format
202:24 - day month
202:28 - and a full year like this
202:31 - so that's the format that we're looking
202:33 - for and this is how user
202:36 - should input the value otherwise with a
202:39 - different format it's not going to work
202:42 - so we're going to save that input value
202:44 - into a variable
202:45 - let's call it user input
202:50 - so we have the user input let's do the
202:53 - split again
202:55 - on a colon remember we have this whole
202:58 - thing as a string as one
203:00 - string so we want to split it into two
203:02 - parts
203:04 - so we have the goal here and the
203:05 - deadline and this will give
203:07 - us a list with those two values
203:10 - and let's call it input list
203:15 - and now from that list we can actually
203:18 - extract
203:19 - or get those individual values using
203:22 - a list syntax so accessing the elements
203:25 - from a list
203:27 - which is what we learned already using
203:29 - an index
203:30 - right so we have input list index
203:34 - 0 which is going to give us learn python
203:38 - and let's save it as a goal variable
203:41 - and let's create another variable which
203:44 - is going to be
203:45 - date let's call it deadline
203:51 - and this will be the second
203:54 - value in our list now
203:57 - let's actually print this out
204:02 - print this whole list out and
204:08 - now note that we are actually in a
204:10 - different file we're not in the main.pi
204:12 - anymore and we don't want to execute
204:15 - main
204:16 - python file instead we want to execute
204:18 - this one right here we basically just
204:20 - want to ignore everything else in this
204:22 - project
204:22 - so how do i go from main to this file
204:26 - execution
204:27 - very easy in this editor just to right
204:30 - click
204:31 - and you see here run time till deadline
204:34 - and i'm going to execute this everything
204:36 - else is ignored in the project we are
204:37 - basically just working on this one right
204:39 - here
204:40 - so enter your goal with the deadline
204:42 - separated by colon
204:44 - let's do that i'm going to do pi learn
204:47 - python
204:48 - colon and then
204:52 - let's enter some date and
204:56 - enter and this is the output so we
205:00 - basically split that into
205:02 - two values and put it in a list right
205:04 - here
205:05 - and very important to note here that
205:09 - both of these elements in this list
205:12 - are strings because again user input is
205:14 - always
205:15 - interpreted as strings so this was a
205:18 - string and it was split into two strings
205:21 - which are learn python and this date
205:24 - here
205:25 - however we don't want date or deadline
205:28 - as a string we want deadline as a date
205:31 - and exactly for that functionality we
205:33 - need
205:34 - this date time module because we don't
205:37 - want to implement it ourselves
205:38 - we want python to give us a ready
205:41 - function
205:41 - from a module that will basically just
205:44 - let us convert this string
205:46 - into a date value and converting string
205:49 - to date is just one example usage of
205:53 - date time module but you can use this
205:55 - module to work with dates
205:57 - generally like creating new dates
206:01 - formatting the dates updating the value
206:04 - etc
206:05 - and we're gonna see some of those
206:07 - examples in this section
206:09 - now if you're learning this type of
206:10 - thing alone you don't have
206:12 - me basically teaching you and giving you
206:14 - an example the way you would do that
206:16 - is you would basically research and
206:18 - maybe google how this is done
206:20 - in python and you would basically see
206:22 - some examples
206:24 - of using this date time and what the
206:26 - name of this function is and how to use
206:28 - that
206:29 - as well as each module has its own
206:31 - documentation page
206:33 - where you can look up the syntax and
206:36 - usage examples
206:37 - because obviously you're not going to
206:39 - know how to do that
206:41 - by yourself so the way we convert a
206:44 - string
206:44 - into a date using this date
206:47 - time module is on this datetime module
206:52 - if i type in dot
206:55 - i will see a list of all the definitions
206:59 - that daytime module gives me right
207:02 - so i have date daytime time etc
207:05 - the one that we need is date time
207:08 - because the function
207:09 - that we need for conversion is inside
207:12 - that definition and don't be confused
207:15 - here because we have date time twice
207:16 - here
207:17 - the first one is a module and the second
207:20 - one is a definition in that module and
207:22 - we can actually check that as well
207:24 - so if i jump into this date time module
207:27 - and inside that if i look for
207:31 - date time again so right here you see
207:34 - this
207:35 - date time definition and on that daytime
207:38 - definition
207:39 - we have now functions that we can use
207:42 - and as you see this is not a function or
207:44 - variable
207:45 - it says class here which is another
207:47 - concept in programming
207:49 - we're gonna see later so just for now
207:52 - think about this as a container of
207:54 - functions
207:55 - and variables inside that module
207:58 - and that's why we have to access it like
208:01 - this
208:02 - and then on that daytime definition this
208:05 - class
208:06 - we now have functions that we can use to
208:08 - do the conversion
208:09 - so the function we need is called str
208:13 - so string p time and this function will
208:16 - take a string
208:18 - representation of a date and we'll
208:20 - convert it into a date format
208:22 - so our string
208:26 - representation is deadline and
208:29 - we need to pass in the second parameter
208:32 - because remember
208:33 - i said we basically decided that the
208:36 - date should be entered like this with
208:38 - points and a full year here
208:41 - and as you know there are lots of
208:43 - different formats and types for dates
208:45 - right
208:46 - depending on a country or a language or
208:49 - even within that language
208:50 - we basically have multiple different
208:52 - formats right we have formats
208:55 - like this or we could also have
209:02 - a shorter version of the ear etc so we
209:05 - need to define here the format
209:07 - that we want python or this method here
209:10 - to use when converting this string into
209:13 - a date
209:14 - again because there are so many
209:16 - different formats available
209:17 - so what we have here is a day then we
209:20 - have a
209:21 - dot then we have a month again a dot
209:24 - and then we have an ear so this is kind
209:27 - of a
209:28 - main structure of a format however
209:31 - formats for dates have their own
209:33 - specific syntax
209:34 - and this is actually for all programming
209:36 - languages so what we need to do
209:38 - is put this percentage sign in front of
209:42 - every
209:43 - letter so again we have day month year
209:46 - and
209:46 - there is one more thing about this
209:48 - format this format right here
209:50 - matches
209:55 - this date however we want the full date
209:58 - not just
209:59 - the last two and the format for that
210:02 - would be a capital y
210:03 - again this is something that you would
210:05 - look up in the documentation
210:07 - of the module instead of knowing it by
210:10 - heart but just know that this type of
210:13 - formats
210:13 - are used when working with dates and
210:16 - this is not specific to python
210:18 - you will actually see something very
210:20 - similar in all the other different
210:22 - programming languages and that will
210:25 - do exactly what we want it will take
210:27 - this date here
210:29 - and give us a proper date format from it
210:33 - let's actually test this so i'm going to
210:36 - print this first
210:40 - and i'm also going to print a type
210:43 - a data type of that value so let's
210:46 - execute
210:56 - i'm actually going to copy that so i
210:57 - don't have to retype it over and over
210:59 - again
211:00 - and enter
211:03 - and here you see we printed first of all
211:06 - the
211:07 - date not a string and now this looks
211:10 - like a
211:10 - proper date and not a string anymore
211:13 - note the
211:14 - change in the format plus we have these
211:16 - zeros here
211:17 - which represent hours minutes and
211:19 - seconds
211:20 - we didn't set any of those so these are
211:22 - all zero and we have the date
211:24 - time type again note date time
211:28 - for a module name and date time of the
211:30 - class name
211:32 - so this is the type of our converted
211:35 - date and the reason why we needed to
211:37 - convert that
211:38 - string into a date is because we want to
211:41 - calculate
211:42 - how many days or how many hours are
211:45 - remaining
211:46 - until the deadline from now starting
211:48 - from
211:49 - today and to do that calculation
211:52 - we need to have date type because we
211:56 - can't do that on a string
211:57 - great so now we have our deadline
212:00 - represented as
212:01 - a date so let's actually assign this to
212:04 - a variable
212:05 - it's a deadline date
212:08 - like this and remove this
212:13 - and now we need to do a calculation
212:18 - how many days from now
212:23 - till the deadline
212:27 - we already have the deadline we need now
212:30 - again now is or today is also a date
212:34 - and since we have this module date time
212:36 - we can
212:37 - also assume that this module will give
212:40 - us some function
212:41 - to tell us the date of today
212:45 - and if i do date time
212:48 - again daytime class
212:53 - and today you see that we have this
212:56 - function available
212:57 - and this will basically give us the date
213:00 - of today so depending obviously when you
213:03 - execute this program
213:04 - it will give you always the current date
213:09 - so let's print it today
213:12 - for me it's 7th of february so if i
213:15 - execute it now
213:18 - i'm going to enter this and today is
213:21 - 7th of february for me so if i execute
213:24 - this
213:24 - let's actually comment this out
213:30 - here i have the date for today which is
213:32 - 7th of february
213:34 - plus the exact time it is now but we
213:37 - don't care about the hours and minutes
213:39 - and seconds
213:40 - we just care about the day
213:45 - so that means we already have deadline
213:49 - and we have today let's also
213:53 - add it to a variable
214:01 - like this and now we can actually
214:04 - do the calculation calculation is
214:07 - super easy we just say deadline date
214:11 - minus today date and this will actually
214:14 - give us
214:16 - the difference between
214:22 - or time difference between today and
214:26 - the deadline date in the future
214:29 - again let's actually try this out
214:36 - and you see that so this is 12th of
214:40 - august for me today is 7th of february
214:43 - so the program calculated that there are
214:46 - 185 days
214:48 - until the time plus how many hours
214:51 - minutes
214:52 - seconds and milliseconds so that was a
214:55 - pretty easy calculation
214:57 - now what we want to do is
215:00 - tell the user some kind of message and
215:02 - we want the message to be
215:04 - dear user the time remaining until the
215:07 - deadline
215:08 - for your goal whatever the goal was is
215:11 - this so let's actually put that text and
215:14 - message together
215:15 - and bring it back to the user
215:19 - so first i'm going to save it into a
215:22 - variable
215:24 - let's call it time
215:28 - till
215:31 - and the message dear user
215:38 - time remaining
215:41 - for your goal and here we want to print
215:45 - what the goal actually is and you
215:47 - remember how we format
215:49 - a string when we want to use a variable
215:52 - we put an f here and in curly braces now
215:57 - we can use
215:57 - variables or numbers or some other
216:01 - expressions
216:02 - which are not string so first of all
216:05 - we're printing back
216:06 - the goal so time remaining for your goal
216:08 - whatever goal they entered
216:10 - is time till
216:16 - and let's execute our program
216:24 - and let's give it some other value
216:27 - like this and enter and here we have
216:30 - our message dear user time remaining for
216:34 - your goal
216:35 - learn python is 132 days
216:39 - and this many hours minutes etc
216:42 - now let's say we don't care about this
216:45 - whole thing here we just want to know
216:46 - how many
216:47 - days are remaining so how do we get rid
216:50 - of
216:50 - this part here again very easy
216:54 - and the time till if i do dot here
216:58 - i get a list of suggestions for
217:01 - functions or variables that i have
217:03 - available
217:04 - and one of them is days as you see here
217:07 - so if i click here
217:08 - and save and i'm going to reuse these
217:12 - inputs
217:13 - because i don't want to type and
217:16 - as you see we got rid of this whole
217:18 - thing here and we just have
217:20 - days and let's actually write days
217:28 - and there you go we have a cleaner
217:31 - output now for
217:32 - our user and finally what if the
217:34 - deadline was
217:36 - just a couple of days in the future and
217:39 - the user wanted to know how many
217:40 - hours are remaining till that deadline
217:43 - we can do that
217:44 - by getting rid of these days and again
217:48 - type in dot and we have something called
217:51 - total seconds here which gives us the
217:53 - time different
217:54 - in total seconds and now we can
217:58 - reverse engineer and calculate the
218:00 - number of hours
218:01 - from this total seconds which is pretty
218:03 - easy
218:05 - like this calculate minutes and then
218:08 - calculate hours
218:11 - and i'm gonna execute this again
218:16 - and here you see the number of hours
218:20 - with a decimal precision so we have 4450
218:25 - hours point
218:27 - some fraction number here again we want
218:29 - to get rid of this
218:30 - extra stuff and as you see from the
218:33 - syntax
218:34 - it is actually a float number with a dot
218:36 - here
218:37 - so what we could do is basically convert
218:40 - this whole thing
218:41 - this float number into an integer so
218:45 - convert this whole thing into an integer
218:47 - using
218:47 - int function and we need this whole
218:51 - calculation here inside the int function
218:54 - and let's execute it again learn
218:58 - python and let's choose a date which is
219:01 - near
219:03 - and there you go we have a whole number
219:05 - 57 again
219:06 - cleaner output and as a code
219:10 - optimization
219:11 - we could take this whole thing out
219:14 - into a variable and call it hours
219:18 - till to make our code a little bit
219:23 - cleaner
219:24 - so now we have the whole program that
219:26 - takes user input
219:28 - and basically prints back to them how
219:31 - many
219:31 - hours are remaining till the deadline
219:34 - for their goal
219:35 - and for this program we used a date time
219:39 - module
219:39 - a built-in date time module from python
219:42 - and we also learned a new data type
219:45 - which is date time and as we learned
219:48 - from the module section
219:49 - we can actually optimize the import of
219:52 - the module because
219:53 - obviously we're just using the date time
219:55 - definition
219:56 - and nothing else from that module
219:59 - so what we could do is from date time
220:03 - module
220:04 - import date time definition
220:07 - which is a class in this case so
220:11 - now you don't need to use the module
220:13 - name
220:14 - so let's get rid of those and this could
220:17 - make
220:18 - the code cleaner as well as make the
220:21 - import more efficient because we're not
220:23 - importing the whole module even though
220:24 - we just need one definition from there
220:29 - when you install python it comes with a
220:31 - set of
220:32 - modules that are built in into python
220:36 - however there are many more modules
220:39 - for other different use cases like web
220:42 - development or data science and machine
220:44 - learning etc
220:45 - that are not part of that installation
220:48 - and these are basically
220:49 - external modules not built-in modules
220:52 - that you have to
220:53 - install as you need and this makes sense
220:56 - because the built-in modules are the
220:58 - ones that
220:59 - most of python programs will probably
221:02 - need
221:02 - and depending on what specifically you
221:05 - are doing with your program
221:06 - whether you are developing a web
221:08 - application or creating some machine
221:10 - learning
221:11 - program you can then add and install
221:13 - them as you need
221:15 - and there are hundreds of such external
221:17 - modules
221:18 - for python out there and obviously it
221:21 - wouldn't be practical
221:22 - to have them all on your laptop when
221:25 - you're just gonna use maybe a handful of
221:27 - them right
221:28 - now if i need to install an additional
221:32 - module for example django for web
221:35 - development
221:36 - where do i find these modules and how do
221:38 - i install them
221:40 - python modules actually live in a module
221:42 - repository
221:43 - where you can find them and that module
221:45 - repository is called
221:47 - pipey so if i look for pipey
221:50 - right here you see the python package
221:53 - index
221:54 - if i click inside you can search for any
221:58 - module that you want to add or install
222:01 - additionally for your application and
222:04 - here you see this word
222:06 - package everywhere instead of a module
222:09 - so what is a package or what is the
222:11 - difference between
222:12 - package and a module
222:17 - to give you a simple comparison module
222:20 - is basically
222:21 - a python file like this one right here
222:23 - that has
222:24 - a name of that file right so we have an
222:27 - ssl
222:28 - module or the one that we used
222:31 - earlier we have this os module right
222:34 - so module is one python file that
222:38 - contains all these functions and
222:39 - variables that you can use
222:42 - package is a collection of modules
222:45 - so if we scroll up and logging
222:48 - is actually one our example
222:52 - so these are actually packages and
222:56 - again let's go to logging so package
222:58 - basically contains
223:00 - multiple python files and use it in the
223:03 - same way you basically
223:05 - import the functions and definitions
223:06 - from the module
223:08 - and as you see clearly the difference is
223:10 - that package
223:12 - is more structured so for example the
223:14 - code is not available in just one
223:16 - single python file but it's divided like
223:19 - this
223:20 - in our case we have two python files and
223:22 - package
223:23 - always has this init python file
223:26 - and this file basically differentiates a
223:29 - normal folder
223:31 - like we have right here with bunch of
223:33 - python files
223:34 - from an actual package with python files
223:37 - so that's the difference between modules
223:40 - and packages
223:41 - and many external modules basically that
223:44 - we want to use in our projects are
223:46 - actually packages so basically package
223:48 - is a
223:49 - good way to define some hierarchy and
223:51 - structure for your modules
223:53 - and kind of group them together so
223:55 - that's why you see
223:56 - package here as a name instead of module
224:00 - so now that we know the difference let's
224:02 - actually search
224:03 - for a package for our project so for
224:06 - example if i type here
224:09 - django you see django packages that we
224:13 - can
224:13 - use from here we also have numpy
224:18 - and so on however in programming when
224:21 - working with and using these external
224:24 - packages a typical example would be
224:26 - where
224:26 - you need to implement some logic for
224:30 - example you want
224:31 - to write a program that basically talks
224:33 - to aws maybe
224:35 - and you don't know exactly the name of
224:37 - that package
224:38 - but you know what you're looking for so
224:41 - in this case
224:42 - instead of the exact name you would
224:44 - actually type in here in the search
224:46 - projects box
224:47 - a description of what you're looking for
224:50 - so let's say we're looking for
224:51 - an aws api package right
224:56 - something that will allow us to connect
224:58 - to the aws api
225:00 - and as you see here we get a list of
225:03 - different packages for that to choose
225:05 - from
225:06 - so basically pipey is a repository
225:10 - or storage for all of those modules and
225:12 - packages
225:13 - and people can also publish their own
225:15 - libraries like individual developers for
225:17 - example
225:18 - they can publish their own packages and
225:20 - modules there
225:22 - and make it available for other
225:24 - programmers to use
225:25 - and that's one reason why large
225:27 - community is
225:28 - so great for a programming language
225:30 - because then you can make
225:31 - use of all these modules and packages
225:35 - that others in the community have
225:37 - developed so for any kind of
225:39 - functionality you need in your
225:40 - application
225:41 - you could imagine that there is a module
225:44 - or package that helps you do exactly
225:47 - that
225:51 - now let's say i need a django package
225:54 - for my
225:55 - web application so first i find the
225:57 - package
225:58 - and now i can actually check some of the
226:01 - documentation for that specific package
226:04 - so if i click inside i see some
226:07 - description
226:08 - for the project as well as documentation
226:10 - and some other links
226:12 - now the question is how do i actually
226:15 - install this package
226:16 - locally so that i can use it in my
226:19 - project
226:20 - in python we install packages
226:23 - using a package manager tool called peep
226:27 - and right here on top below the package
226:29 - name you actually see a command
226:32 - peep install django so this is actually
226:35 - a command
226:36 - that will install that package locally
226:38 - on my laptop
226:39 - so we install packages in python using
226:43 - this pip command so
226:46 - what is this command or where does it
226:48 - come from
226:49 - pip is a package manager for python
226:52 - and if you know any other programming
226:54 - language basically
226:55 - the concept is the same every
226:58 - programming language
226:59 - has its own package manager tool
227:02 - for javascript it's npm for java
227:05 - it's maven or gradle and for python it
227:08 - is
227:08 - pip and one of the main tasks or usages
227:12 - of a package manager tool
227:13 - is to install external packages or
227:17 - libraries
227:18 - or also called dependencies for your
227:21 - project
227:22 - so if python needs this django package
227:26 - basically it's the job of the package
227:28 - manager
227:29 - to install that package and make
227:30 - available for python
227:32 - now where did this command come from do
227:35 - we have pip command available
227:37 - well in python version 3 actually
227:40 - pip is packaged inside the python so
227:43 - when we install the python we actually
227:46 - installed pip as well so basically we're
227:49 - going to copy this command
227:51 - peep install django and we're going to
227:54 - execute it actually from the terminal
227:56 - of pycharm so in pycharm editor we have
228:00 - this
228:00 - integrated terminal so this is actually
228:03 - pretty much the same
228:04 - terminal as you have outside like this
228:08 - so we are going to execute this pip
228:10 - install command directly
228:12 - in this pycharm terminal so i'm going to
228:15 - copy it
228:15 - here and do peep install django
228:19 - and you see it is downloading and
228:21 - successfully
228:22 - installed django 3.1.6
228:25 - and we can actually see that package
228:28 - from our editor directly
228:30 - if i expand these external libraries
228:33 - and site packages
228:37 - and scroll a bit down here i have django
228:41 - 316 version installed so i see that the
228:45 - package is now
228:46 - available in my project and to also test
228:49 - it
228:50 - in the code i can do import and
228:55 - django and you see that pycharm actually
228:58 - recognize that i have django packaged
229:01 - locally
229:01 - so it gives me that package as a
229:04 - suggestion
229:04 - so that will basically import the whole
229:08 - django package
229:09 - so we can now use it in our application
229:11 - here you see pycharm
229:13 - actually noticed you are using or want
229:15 - to use
229:16 - django web framework as i mentioned in
229:18 - the beginning the pycharm professional
229:20 - edition
229:21 - has special support for different python
229:23 - web frameworks
229:25 - supporting you with syntax highlighting
229:28 - suggestions
229:29 - database integration and so on so again
229:32 - if you want to try it out for free for
229:33 - three months just use my code in the
229:35 - video description
229:37 - in the same way as we install the
229:39 - package
229:40 - we can also uninstall packages using pip
229:44 - and let's also actually demonstrate that
229:48 - pip uninstall
229:51 - django and
229:55 - let's confirm that
229:58 - successfully uninstalled django now if
230:02 - in the site packages i click inside
230:05 - you see that django packages are gone so
230:08 - this site packages folder got updated
230:11 - django was removed
230:12 - and you also see that in the code editor
230:14 - now i have this
230:16 - red line under django because pycharm
230:19 - cannot find
230:20 - a module called django and also if i do
230:24 - this
230:25 - obviously it won't give me any auto
230:27 - suggestion for that
230:28 - so that's how you can use peep to
230:30 - install packages and also to uninstall
230:33 - packages
230:34 - for your application
230:38 - now here i want to show you another cool
230:41 - alternative to installing and
230:43 - uninstalling packages directly in the
230:46 - pycharm ide
230:48 - and this is actually a feature in the
230:50 - latest pycharm release
230:52 - and for this i need to switch to an
230:55 - early access pycharm version so you see
230:58 - here
230:58 - it says pycharm eap early access
231:02 - to show you the feature however when you
231:04 - watch the tutorial it probably will
231:06 - already be included in the latest
231:08 - official pycharm version so you should
231:11 - have that already
231:12 - so instead of us basically finding this
231:15 - package in pipey
231:17 - and then executing peep install commands
231:21 - right here what you can do is
231:24 - down here you have another tab called
231:26 - python packages so if we click inside
231:29 - this is a place where you have
231:31 - everything that you need to know
231:32 - about the package the package search and
231:35 - all these
231:36 - features basically in one place so for
231:38 - example
231:39 - in order to install django we can just
231:42 - search
231:43 - for django right here and you see that
231:46 - when i type in the first couple of
231:47 - letters
231:48 - i already get suggestions so this is a
231:50 - list of all the packages
231:52 - that start with this name that are
231:54 - actually available in pipi
231:56 - so let's type in django and we see that
231:59 - right here
232:01 - and on the right you see the
232:03 - documentation
232:04 - of the package that you would actually
232:07 - see in
232:08 - pipey ui so you have that in place as
232:11 - well
232:12 - and in addition to that what they added
232:15 - is the documentation
232:16 - link so this is actually the package
232:18 - how-to guide
232:19 - and the full documentation with examples
232:22 - etc
232:24 - so very convenient way to basically get
232:26 - all the information about the package
232:28 - search the package and then to install
232:31 - the package
232:32 - we can choose the version here so either
232:35 - you can leave the latest
232:36 - or basically select the specific version
232:39 - and then once you have selected that you
232:42 - can just click
232:42 - install and here you see installing
232:45 - package
232:47 - and there you go so now in installed
232:51 - view here so we just had pip and setup
232:54 - tools
232:54 - these two things installed and right
232:56 - here we have now
232:58 - django in the installed packages list
233:01 - and again while you're now using the
233:04 - installed
233:04 - package or library in your code and
233:07 - basically you want to look
233:08 - up some examples or you want to check
233:10 - some documentation
233:11 - right you go back to the package click
233:15 - inside and you have link to
233:16 - documentation and
233:18 - the package information as well and also
233:22 - just by looking at this list you know
233:24 - which versions of which packages you
233:27 - have installed so i think it's really
233:29 - cool way to manage all your packages to
233:31 - install packages
233:32 - and for example if you want to uninstall
233:35 - packages
233:36 - from your project then again just
233:38 - clicking
233:39 - to that specific package right here
233:43 - you can just delete it and it will be
233:44 - removed from your application
233:49 - like this and no django anymore here
233:54 - so a very cool addition to pycharm
233:56 - because this will be very convenient to
233:58 - work with the packages
234:00 - so now i will switch back to my other
234:02 - editor again
234:03 - and continue from there
234:11 - so basically i have just cleaned up my
234:14 - python project we have this main.pi
234:17 - which is
234:17 - empty and we're gonna write an
234:19 - application that will read
234:21 - a spreadsheet file from our local file
234:24 - system
234:24 - it will read some information from that
234:26 - spreadsheet file and do
234:28 - something with that data and this could
234:30 - be a very useful
234:32 - use case if you're working with lots of
234:35 - files and you want to do some
234:37 - data processing in those files and you
234:39 - don't want to do that manually
234:41 - by automating or writing a program in
234:43 - python
234:44 - that basically can do anything in a file
234:47 - or across multiple files so let's see
234:50 - exactly
234:50 - what we are going to be doing with this
234:52 - program so first of all
234:54 - we're going to have an input file a
234:56 - spreadsheet file that we're going to be
234:58 - working with
234:59 - and that spreadsheet will look like this
235:02 - it's called inventory that's how it's
235:05 - going to look like
235:06 - so basically this file simulates
235:08 - something that many companies would have
235:11 - and employees of that company would be
235:13 - working with
235:14 - so we have this list of product numbers
235:18 - inventory for each product price for the
235:21 - product
235:22 - and a supplier so this could be an
235:24 - example file from a company that is
235:26 - basically dealing with
235:27 - selling or buying products so what we're
235:30 - going to do is
235:31 - we're going to read the information from
235:32 - this file and we're going to do
235:34 - something with that information
235:35 - first we're going to write logic that
235:38 - calculates
235:40 - how many products we have per supplier
235:43 - so we have three supplier companies here
235:45 - and per supplier we're gonna calculate
235:48 - number of
235:49 - products from that specific company and
235:51 - as a result we're gonna list
235:53 - the company so all three companies with
235:56 - their respective
235:57 - number of products then we're going to
236:00 - write another logic that
236:01 - lists inventory products that have
236:04 - inventory which is
236:05 - less than 10 so basically those ones
236:09 - the third exercise is going to be to
236:12 - list
236:13 - each company with their respective total
236:16 - inventory value
236:18 - and finally in the last exercise we will
236:21 - calculate the inventory value for
236:23 - each product so product count times
236:27 - price and we're going to write that
236:29 - value to
236:30 - an additional column in the spreadsheet
236:32 - and
236:33 - after that we're going to save that
236:35 - updated spreadsheet file
236:36 - programmatically using python so we're
236:39 - gonna see how to
236:40 - update a file and then save it
236:43 - programmatically
236:44 - in python if any of these sounds a
236:46 - little bit too complicated for you then
236:48 - just bear with me
236:50 - i'm gonna explain everything step by
236:52 - step and
236:53 - it's gonna become much clearer when we
236:55 - actually start writing the
236:57 - logic
237:01 - so the first thing what i'm gonna do is
237:03 - i'm gonna take this
237:04 - file that i have in the downloads folder
237:07 - and i'm actually gonna
237:08 - move that into my project so i'm gonna
237:10 - copy that and i'm gonna drop it in here
237:13 - so that we have the file right in our
237:16 - project and so we can basically just
237:19 - read it
237:20 - easily and okay and here is
237:23 - our inventory file so that's taken care
237:26 - of so obviously what we want to do now
237:28 - is read that file so basically let our
237:32 - python program
237:33 - read the contents of that file right
237:36 - here
237:36 - because we want to write some logic
237:38 - based on the values
237:40 - that are in this inventory file right we
237:42 - want to calculate stuff we want to
237:44 - list some stuff and so on so basically
237:46 - we want to work with these values and in
237:48 - order to do that we need to
237:50 - read all of these values into our
237:52 - program so that we have them available
237:55 - so how do we do that now there is
237:57 - actually a
237:58 - built-in module in python that allows
238:00 - you to work with files
238:02 - generally right it's not specific for a
238:05 - spreadsheet
238:05 - or for any other file type it's for
238:08 - different types of files
238:09 - generally however there is an external
238:13 - package
238:14 - that allows you to work with
238:16 - spreadsheets
238:17 - specifically and the obvious advantage
238:20 - is that
238:21 - that external module that allows you to
238:22 - work with spreadsheets or
238:24 - was created to work with spreadsheets
238:26 - specifically
238:27 - has much more functions and is much
238:30 - easier to use
238:31 - if you are working with spreadsheets
238:33 - compared to this built-in file module
238:36 - so that's one of the cases where you may
238:37 - have multiple ways of
238:40 - actually implementing some functionality
238:42 - for
238:43 - application and then you have to make
238:45 - this decision of maybe finding a better
238:47 - package or better module
238:49 - which is available externally that will
238:51 - make it easier for you
238:53 - to implement that functionality so
238:55 - that's what we're gonna do for our
238:57 - project
238:58 - we're going to choose the package that
238:59 - is actually made for working with
239:01 - spreadsheets
239:02 - we're going to use that one and it's
239:04 - called open
239:06 - pi xl and if i
239:09 - search for it this is the package that
239:11 - we're looking for
239:12 - and if i click inside basically we have
239:15 - some information
239:16 - about this package so here we see a
239:19 - description
239:20 - let's actually make this bigger
239:22 - description
239:24 - library to read write excel
239:27 - files with all these formats
239:30 - so this is the library that we're going
239:32 - to be using in the same way as we did
239:34 - before
239:35 - we're going to copy that command and
239:37 - execute it from pycharms
239:39 - integrated terminal so from here i'm
239:42 - gonna
239:43 - execute this pip command and install
239:46 - our module and as you see
239:50 - successfully installed open pi xl
239:53 - and this is the version of the module
239:55 - that we installed and
239:57 - in external libraries site packages you
240:00 - should be able to see
240:01 - our open pi excel package
240:05 - and now because the package is available
240:07 - locally i can do
240:08 - import and open
240:11 - pi excel again i get a suggestion from
240:14 - pycharm because the module is there
240:16 - and now we are able to use that package
240:19 - for our application and one small note
240:21 - here if you're wondering
240:23 - why there are some packages with
240:26 - basically a dot
240:27 - inside and some without these are the
240:30 - packages
240:31 - that we install python packages and we
240:33 - know that because there's this
240:35 - init python file inside and the ones
240:38 - without the dot they're just folders
240:42 - with bunch of files inside but they're
240:44 - not python packages so to say
240:46 - and inside some of those packages we see
240:50 - other packages as well with their own
240:52 - init file
240:53 - so basically hierarchy of multiple
240:56 - packages
240:57 - and at this point i'm going to say that
241:00 - the word
241:00 - library basically describes package
241:04 - that includes multiple other packages so
241:07 - basically which has a hierarchy of
241:09 - packages
241:10 - so we have module which is basically
241:12 - just one python file
241:14 - that we can use in our project then we
241:16 - have package which is
241:18 - a hierarchy of multiple modules with an
241:21 - init python file inside and then we have
241:24 - library which is basically
241:26 - multiple packages together in a
241:28 - hierarchy
241:29 - just like we see right here so note the
241:32 - difference
241:32 - so you don't get confused when you see
241:34 - library package and module
241:36 - especially if used interchangeably
241:42 - great so now we have our module in place
241:46 - so let's use it now to read our
241:48 - spreadsheet file
241:49 - and again you basically have to know the
241:51 - function names
241:52 - to do that if you don't you can do dot
241:55 - and get suggestions
241:57 - and load workbook is actually the
241:59 - function that we need
242:00 - in order to read our spreadsheet file so
242:02 - i'm going to choose this
242:04 - function and obviously we need to tell
242:07 - this function
242:08 - which file it should read so as a
242:10 - parameter
242:11 - we're going to say please
242:14 - load inventory file and we even get a
242:17 - suggestion because we have this
242:18 - inventory file here
242:20 - and there you go now this function will
242:22 - load the workbook and all its contents
242:25 - and later we obviously want to do
242:27 - something with that content
242:29 - so in order to be able to do that we
242:31 - need to save it first as a variable
242:33 - and let's actually call it inventory
242:36 - file like this and this will give us the
242:40 - file contents
242:41 - now let's actually open that file again
242:45 - and let's see exactly what we need so we
242:48 - can have multiple
242:49 - such sheets basically per file so we
242:52 - need to tell the program which one it
242:54 - should use
242:54 - exactly so for example if this was
242:57 - called a product list
243:01 - you would use that name but we're gonna
243:02 - go with sheet
243:04 - one so we're gonna use that name
243:06 - basically
243:08 - and we're gonna grab that using
243:12 - following syntax and you remember this
243:14 - syntax probably from using a dictionary
243:16 - so this will give us this one specific
243:19 - sheet and all the information inside
243:21 - and we can also save that into a
243:23 - variable so let's actually call that
243:26 - product list so now we have read the
243:29 - whole file then we have read this
243:32 - specific sheet of that file
243:33 - and now we have all this information in
243:36 - that variable
243:37 - so now we can read any of those values
243:39 - and
243:40 - do calculations etc using that variable
243:46 - so let's get to our first task and the
243:49 - first task is basically to calculate
243:52 - how many products we have per supplier
243:56 - and then list the names of the suppliers
243:59 - with that
243:59 - respective number of products so let's
244:02 - go back and do that
244:05 - so the results what we want to get is
244:07 - basically
244:08 - products or number of products
244:11 - per supplier right that's basically what
244:15 - we want to get as a result
244:16 - so we're going to create that variable
244:18 - and we're going to set it
244:20 - to an empty dictionary so
244:23 - by the end our program should give us
244:25 - something like this
244:27 - a dictionary where the name of the
244:29 - company is the key
244:30 - and the value is basically product count
244:34 - for that company and since we have
244:37 - three suppliers or three companies we're
244:39 - gonna end up with
244:40 - a dictionary with three key value pairs
244:43 - per
244:44 - company so we're starting with an empty
244:47 - dictionary for products per supplier and
244:50 - now let's see how we can
244:51 - programmatically calculate this
244:55 - first of all what we need is we need to
244:58 - go through each of these lines basically
245:01 - so we have these rows so we need to go
245:03 - through each and every
245:05 - row in order in sequence and we need to
245:09 - get
245:09 - or check a supplier name for that row
245:13 - and you remember whenever we execute a
245:16 - logic
245:16 - on multiple values over and over again
245:20 - so basically same logic or same function
245:22 - gets executed
245:24 - for multiple different values for a
245:26 - number of times
245:28 - that's basically a use case for a loop
245:30 - right so we're looping
245:32 - through those rows and we're doing the
245:35 - same thing
245:36 - per row which is getting the name of the
245:38 - supplier now
245:39 - as you also remember loops have
245:42 - conditions right
245:43 - we need to tell the loop how many times
245:45 - it should execute
245:47 - that specific logic and if we check our
245:49 - file here
245:50 - how many times we want to execute the
245:52 - logic the answer is
245:55 - as many times as the number of products
245:57 - so
245:58 - if we scroll down we have 74
246:02 - products so we need to do that 74 times
246:07 - for each product so basically as many
246:10 - times
246:10 - as the number of product and obviously
246:12 - we want this program to work for
246:14 - any spreadsheet file right with any
246:16 - number of products so we need to
246:18 - calculate or we need to read that value
246:21 - also from the file
246:22 - so basically we need to read how many
246:24 - products are on this list
246:26 - so let's see how we can do that first of
246:28 - all we're using
246:29 - for loop to execute the logic for
246:32 - specific
246:33 - number of times and if you remember from
246:36 - for loop syntax
246:37 - four then we have the specific item
246:40 - so what is an item in our case our item
246:44 - is a row right product row is going to
246:47 - be an
246:47 - item of iteration so looping basically
246:51 - so we can call our item
246:55 - products row and then comes in
246:59 - and now we need that condition how many
247:03 - times and again this should be generic
247:06 - so we need to calculate or we need to
247:08 - read
247:09 - the number of lines here number of rows
247:11 - here from the file
247:12 - and the way we can read that is remember
247:16 - we have all the information we need in
247:17 - that
247:18 - one specific variable which is product
247:20 - list
247:22 - and that variable has
247:25 - the value for number of rows which is
247:28 - called
247:29 - max row now how do i know that
247:32 - max row attribute is available for
247:35 - product
247:36 - list i basically just looked it up on
247:38 - the documentation of the module
247:40 - and as i previously also mentioned
247:42 - whenever you're using a
247:43 - module this module will have a
247:45 - documentation so
247:47 - if you need some functionality if you
247:49 - need some values
247:50 - you can basically just search inside the
247:53 - documentation
247:54 - which functions and variables are
247:56 - available to
247:57 - get the functionality or values that you
248:00 - need
248:01 - and we can actually test it we can print
248:04 - it out
248:05 - like this
248:08 - and as you see here 75 so basically max
248:12 - row will always give us the number of
248:15 - lines or number of rows
248:17 - in that specific sheet so we know how
248:20 - many times to
248:21 - iterate now whenever we're providing a
248:23 - specific
248:24 - number in a for loop like 75 for example
248:28 - in this case we need to
248:31 - put that number in a range like this
248:35 - so we can't just say 70 or in this case
248:38 - max row now why do we need a range here
248:41 - and why is number just not enough
248:45 - because the for loop is for iterating
248:48 - over a list and the range will create
248:51 - a list of numbers to iterate through
248:54 - in our case range of 75
248:58 - will create a list of numbers or
249:00 - sequence of numbers
249:01 - from 0 to 74. and with that we're going
249:04 - to have
249:05 - a valid for loop where for each
249:08 - item in this list of numbers
249:11 - some logic will be executed so that's
249:13 - why we need a range here
249:15 - and now there's one more thing that we
249:17 - need to fix we go back to our
249:19 - spreadsheet
249:20 - you see that the first row so this is
249:23 - going to be the first row basically
249:25 - does not actually include the product
249:27 - information
249:28 - it just includes the titles for each
249:31 - column
249:32 - right so we actually do not want to read
249:35 - this line we want to skip it and we want
249:38 - to start from the second row
249:41 - so instead of starting for loop from the
249:44 - first row
249:45 - we want to start it from the second row
249:48 - and in order to
249:49 - tell python to start at row 2
249:52 - in the range function we're going to
249:54 - pass first parameter
249:56 - 2. so basically this will give us a new
249:59 - range of numbers
250:00 - starting from 2 instead of starting from
250:02 - 0. and since we're using those
250:04 - numbers in the range as an index for the
250:07 - rows
250:08 - the first number is going to be 2 so
250:10 - we're going to start iterating from the
250:12 - second row
250:13 - so this will be the start point and this
250:15 - will be the end point
250:17 - so basically from here to the end
250:21 - now there are two things specific
250:24 - to a range that you should be aware of
250:28 - first of all when we do not
250:32 - provide the start index basically
250:36 - the start number in the range by default
250:39 - it's actually
250:40 - zero so it's not one but it's zero
250:43 - and obviously we don't have a line zero
250:46 - here
250:47 - so if we executed it with the default
250:49 - one
250:50 - we would get an error so that's one
250:53 - thing to consider that
250:54 - range actually by default starts at 0
250:57 - and not 1. but for us it doesn't matter
251:00 - because we're skipping the first one
251:02 - anyways and we're starting from line 2
251:04 - because our spreadsheet doesn't have
251:07 - line 0
251:08 - obviously another specific of the range
251:10 - is that
251:11 - the second value here basically the last
251:15 - number of execution in the loop in our
251:18 - case this is going to be 75
251:20 - because we have 75 lines and we printed
251:23 - that out here
251:24 - that number is actually exclusive
251:27 - it's not inclusive that means that
251:31 - the range will execute from line 2
251:34 - to 75 exclusive so basically
251:38 - till here this line will not be included
251:42 - in the loop
251:43 - again that's a specification of the
251:46 - range
251:47 - which we need to fix and
251:50 - basically want to tell you know what we
251:52 - want that iteration
251:53 - including the last number as well
251:56 - including that max row
251:58 - and a simple fix for that is going to be
252:00 - to
252:01 - do plus one here so basically whatever
252:05 - the max row is we want to include that
252:07 - one as well
252:08 - so we want to add one to it so now we
252:11 - have a range
252:12 - starting from two and ending in 76
252:16 - exclusive so obviously the 76th
252:19 - line will not be red and
252:22 - this will now give us a range that we
252:25 - need
252:28 - and now that we have condition for the
252:30 - loop and we have set
252:32 - how many times it should execute let's
252:34 - actually execute the logic
252:36 - itself so what is the first information
252:38 - we need from that
252:40 - product row for each row we basically
252:42 - need the supplier name
252:44 - so that we can increment or start
252:46 - counting how many
252:47 - products this supplier has so we need
252:50 - this
252:51 - one two three fourth column and the
252:53 - value in that fourth column
252:55 - for each and every row right
252:58 - let's go back to editor how do we get a
253:01 - value
253:02 - in the cell you have to imagine when we
253:04 - iterate we have
253:05 - one row per iteration
253:09 - so right here we actually have this
253:11 - product row which is just
253:12 - one row and we have four columns here
253:15 - and we want
253:16 - value in this specific cell and
253:19 - we can get it using first of all product
253:22 - list
253:22 - because again we have all the
253:23 - information here so in this list
253:27 - we need a cell right we need a value of
253:30 - a
253:30 - cell so that's the name of the function
253:33 - and the cell basically takes two
253:36 - parameters again product list
253:39 - contains the whole sheet here so the
253:42 - whole list
253:43 - with all the rows and columns and we can
253:46 - get a specific
253:48 - cell value so whatever we are doesn't
253:51 - really matter
253:52 - from that variable by providing two
253:55 - values
253:56 - the row number and the column number
253:59 - that's it
253:59 - so row nine column one basically will be
254:03 - this specific value row five column
254:07 - four will be this specific value so
254:10 - for each iteration we're gonna do
254:13 - exactly
254:14 - that so for our case the supplier is
254:16 - always column four
254:18 - and the row is dynamic because we are
254:21 - iterating
254:22 - and therefore we're going to use
254:25 - whatever row we're at at the current
254:28 - iteration
254:29 - so that's the first parameter and column
254:32 - 4 as i said and this will give us
254:36 - the supplier name for each and every
254:40 - row so we can grab that value like this
254:42 - and this is going to be supplier
254:46 - name so we can save it in a variable
254:50 - as a next step we're going to start
254:52 - building
254:53 - how many products each supplier has
254:56 - we're going to start building a
254:58 - dictionary
254:59 - with the name of the supplier and then
255:01 - how many products they have
255:03 - so we're going to be building this
255:05 - dictionary here
255:06 - so this is a reminder now for what i
255:09 - said previously
255:10 - that you don't need knowledge of math in
255:13 - programming
255:14 - rather you need logical thinking right
255:16 - so you're going to get tasks like this
255:18 - where you have to
255:19 - basically logically decide how you are
255:22 - going to do a certain task
255:24 - and think all this through right so
255:27 - programming is more about logic rather
255:29 - than pure calculation or math
255:32 - which is actually more interesting and
255:34 - cooler and that's exactly
255:36 - what we're going to need in this example
255:38 - we're going to need some
255:39 - logical thinking to basically build this
255:42 - application
255:43 - so bear with me on this one the first
255:45 - thing we need to check here
255:47 - so think about this iteration on the
255:49 - first time
255:50 - and second time the first time the list
255:53 - or the dictionary is actually
255:54 - empty so we want to add the first
255:58 - supplier to the list right away right
256:01 - so we're gonna grab that and the syntax
256:05 - for
256:05 - adding a new entry in a dictionary is
256:09 - like this where we have a key
256:14 - and a value here so basically what we
256:17 - want to end up with
256:18 - is supplier name like a
256:21 - company and
256:25 - number of products for that supplier
256:27 - that's the
256:28 - dictionary that we want to end up with
256:30 - then it's going to be
256:33 - bbb company and so on
256:38 - so the very first supplier goes directly
256:40 - into the list
256:42 - and we're going to need the name of that
256:44 - supplier we don't know what it's going
256:45 - to be
256:46 - so name as a key
256:50 - and value is going to be
256:53 - 1 at the beginning right this is the
256:55 - very first iteration
256:57 - so after the first it iteration we're
256:59 - gonna have
257:00 - the first company name supplier name and
257:03 - count one for that on the second loop
257:06 - second iteration basically if
257:10 - the next line is a different supplier
257:14 - like here for example then a new entry
257:17 - will be added
257:18 - because we have a new key now with
257:21 - count one right so now we're gonna have
257:24 - company a
257:25 - with one product company b with one
257:27 - product
257:28 - now what happens when on the next
257:30 - iteration
257:31 - we get company a again right
257:35 - what we want to happen is
257:38 - company a the product count to
257:42 - increase to two right because now we
257:44 - found another product that
257:46 - is supplied by the same company however
257:49 - with this land we are actually
257:50 - overriding and setting it
257:52 - back to one so how do we make sure that
257:56 - number of products gets incremented
257:58 - instead of always setting it to one
258:00 - what we're going to do is before we
258:03 - execute this line
258:04 - we're going to check is it a new
258:06 - supplier or
258:07 - an existing one because that makes a
258:09 - difference
258:10 - so how do we know if it's a new one or
258:13 - an existing one
258:14 - we can look that name up in the
258:17 - dictionary
258:18 - if we have already edited that name in
258:20 - the dictionary then it's going to be
258:21 - there
258:22 - and we can do that very easily again
258:25 - with the syntax
258:26 - if supplier name in
258:30 - the dictionary it's actually very
258:33 - readable syntax that says is the
258:36 - supplier
258:36 - already added to the list or is it a new
258:39 - one
258:40 - so if this is true again
258:43 - remember if conditional so if this
258:47 - is true statement if the supplier name
258:50 - is already there
258:51 - then it is an existing one so we need to
258:54 - increment
258:55 - the product number instead of setting it
258:57 - to one
258:58 - so instead of assigning a new value we
259:01 - want to
259:02 - grab that value the existing one and
259:05 - basically add
259:06 - one to it right just increment by one so
259:09 - getting a value from a dictionary you
259:12 - probably remember the syntax already
259:14 - using the key and we can save it into
259:17 - a variable let's call it current
259:22 - number of products
259:26 - like this remember we're using a key
259:29 - in order to get the value and the key is
259:31 - the supplier name
259:32 - value is the product count so this will
259:34 - give us
259:35 - the current number of products on the
259:38 - first iteration this will be one
259:39 - or after the first iteration we're going
259:41 - to have one product for that specific
259:43 - supplier
259:44 - and if we already have that supplier
259:49 - in the dictionary we want to increment
259:52 - the number of products for that specific
259:54 - supplier by one
259:56 - because we just found another product
259:58 - from that supplier
259:59 - so we want this value to now be
260:03 - plus one right so current number of
260:06 - products
260:07 - plus one so that's the new value that we
260:10 - want
260:11 - for the existing for this current
260:14 - supplier and how do we assign it back
260:17 - to the dictionary again we grab that
260:21 - and assign it so as you see
260:25 - taking the value from the dictionary has
260:27 - the same syntax as
260:29 - setting that value in the dictionary
260:32 - in fact we could actually use a shortcut
260:35 - here
260:36 - so instead of current numproducts we
260:38 - could just
260:39 - take that value and add plus to it and
260:41 - then
260:42 - set it back as a new value and
260:46 - this will basically just give us a
260:47 - one-liner for the logic
260:50 - depends on the taste whether this looks
260:52 - nice or not
260:53 - or whether it's better to have a new
260:55 - variable and
260:56 - increment the value like this let's
260:58 - actually leave it like this
261:00 - so this logic will take care of adding a
261:03 - product count
261:04 - every time we find another product for
261:05 - the same supplier
261:07 - however now we have to decide what
261:09 - happens
261:10 - when it's a new supplier so if this
261:13 - condition
261:14 - is false if the supplier name is not on
261:16 - the list
261:17 - and this is going to be the case on the
261:18 - very first iteration
261:20 - as well because the dictionary is
261:23 - basically
261:23 - empty so there are no supplier names and
261:26 - for that case
261:28 - else we're going to do what we had
261:32 - before
261:32 - which is just setting that number to one
261:35 - right this is going to be the first
261:37 - value so this will do
261:39 - two things basically it will create
261:42 - a new entry in this dictionary for this
261:44 - new supplier
261:46 - and it will set the product count number
261:49 - to one for that new supplier and that's
261:52 - it that's actually our logic
261:54 - and let's actually try this out and
261:56 - print it out
261:57 - so right here i'm gonna print
262:01 - adding a new supplier
262:04 - and this is going to happen three times
262:06 - because we have three suppliers
262:08 - so we can safely print it because just
262:10 - gonna happen three times
262:12 - there is one more thing we need to fix
262:14 - here and that is
262:16 - getting the value from the cell so if we
262:18 - actually
262:19 - execute this now let's comment this out
262:21 - and actually print out
262:23 - what the supplier name here is
262:27 - let's actually get rid of this line we
262:29 - don't need this
262:30 - and run the program you see here we have
262:34 - cell information so it's not actually
262:36 - the
262:37 - the value the name of the supplier but
262:40 - it's just
262:41 - the object cell and the reason for that
262:44 - is because we're accessing a cell but
262:47 - we're not actually extracting or getting
262:49 - the value out of it
262:51 - and we can do that using this value
262:54 - attribute on that complete object
262:58 - again something that you can look up in
263:00 - the documentation of
263:02 - this open pi xl module
263:05 - so now let's run it again and now we
263:08 - have
263:09 - the actual values of that cell
263:12 - and this will take care of that small
263:16 - problem and now we are ready to
263:19 - execute our
263:23 - program and after the for loop actually
263:26 - let's print out the
263:28 - dictionary because we want to see the
263:31 - results of the dictionary that we are
263:32 - building here
263:34 - and i'm going to execute it now
263:37 - and there you go first of all we have
263:39 - three times adding a new supplier
263:42 - because we have three suppliers and this
263:44 - is the
263:45 - resulting dictionary and it looks
263:48 - actually very good
263:49 - first we have company a because this was
263:53 - the first on the list
263:55 - and we have number of products that were
263:57 - counted
263:58 - for that company then we have the second
264:01 - one
264:02 - with number of products and the third
264:04 - one
264:05 - so it looks like our program did exactly
264:08 - what we wanted
264:12 - so that takes care of the first exercise
264:15 - now i want to note here
264:17 - one small thing which is an alternative
264:21 - syntax for
264:21 - getting values from a dictionary which
264:24 - is actually
264:25 - a more recommended way of doing it which
264:28 - is instead of
264:29 - having these brackets here
264:32 - to have a get method right
264:36 - to use a get function
264:40 - with the key name so now you see the
264:44 - difference between those two
264:46 - so this is setting the value of that key
264:49 - again remember key is this one here and
264:52 - this is the value
264:54 - so we are accessing the value of the
264:55 - dictionary using that key
264:57 - and get function is actually
265:01 - another way of grabbing this value out
265:05 - of a dictionary using the key name
265:07 - again if i execute this i should see
265:11 - the same result
265:14 - after the first exercise basically we
265:16 - see from which company
265:18 - from which supplier we have the most
265:20 - product or the highest number of
265:22 - products now in the second exercise
265:24 - we're going to calculate
265:26 - the total inventory value per supplier
265:29 - meaning in our list for each product we
265:32 - have
265:33 - number of units for the product and the
265:35 - price so basically for
265:36 - each supplier we want to calculate how
265:39 - much is the total
265:40 - value of inventory of their products
265:43 - of all their products and again as a
265:46 - result
265:47 - we want to create a dictionary that
265:48 - basically tells
265:50 - us that value per company let's go ahead
265:53 - and do that
265:55 - so this was calculation
266:00 - calculation for number
266:03 - of products per
266:07 - supplier
266:12 - and here we're going to give us some
266:14 - space
266:18 - and do calculation
266:21 - total value per
266:25 - supplier or total value of inventory
266:31 - per supplier that's what we want to
266:33 - calculate
266:34 - so just like we did before we're going
266:36 - to create a new dictionary now
266:38 - and we're going to call it appropriately
266:41 - total value
266:44 - per supplier
266:48 - and start with an empty dictionary
266:52 - again for starting in an easy way let's
266:55 - consider the first
266:56 - very first iteration for the first
266:58 - supplier
267:00 - how are we going to calculate for the
267:02 - first supplier
267:03 - for the first product so i'm going to
267:07 - take this new dictionary and
267:12 - with our familiar syntax i'm gonna do
267:16 - supplier name so that's gonna be our key
267:18 - and the value
267:20 - of the very first iteration for the
267:22 - first product
267:23 - is going to be inventory
267:27 - times price so for the first product
267:31 - we're going to calculate how much
267:33 - or how many of the product items we have
267:36 - and
267:36 - number of price right that will give us
267:39 - value of the total inventory for
267:41 - that one specific product and that means
267:44 - we need those two values
267:47 - right now we're just getting the value
267:49 - of the supplier
267:51 - so we need inventory
267:58 - i'm actually going to copy this so we
268:01 - need
268:02 - cell for product row and
268:05 - column inventory is on column two
268:09 - and value so whatever the product row is
268:13 - going to be so for each product
268:14 - basically for each row
268:16 - we need always the second column so all
268:18 - these values here
268:20 - and then we need price which
268:23 - going to be product list cell
268:27 - and we are looking for
268:32 - the third column for every row
268:36 - number three and value
268:40 - so now we have inventory and price per
268:43 - product and the way to calculate
268:46 - value is basically inventory that's the
268:49 - number of
268:50 - product items times price very easy
268:53 - that will give us the first value
268:57 - for the first supplier now again the
269:00 - same way
269:01 - if we are getting a new supplier so
269:04 - basically in the next iteration
269:05 - if it's a new supplier then this line
269:08 - will get executed and everything is fine
269:11 - however if it's an existing supplier
269:13 - that we already have in the dictionary
269:15 - then we have to add to that previous
269:18 - value right instead of setting a new one
269:23 - so we're going to do very similar logic
269:26 - as we did here
269:27 - so we have the supplier name we're
269:29 - checking
269:30 - is it a new supplier or an old one an
269:33 - existing one
269:35 - this time in our new dictionary
269:40 - and if it is we're gonna
269:43 - grab that old or existing value
269:47 - again using this get syntax here
269:51 - existing value now is hundred we want to
269:55 - add to that hundred right
269:57 - so we're gonna grab that value this is
269:59 - going to be current
270:01 - total value
270:05 - and then we're going to add to that
270:08 - current total value
270:12 - the inventory value for the current
270:15 - product and assign it back to
270:19 - our dictionary
270:23 - now our variable names a little bit
270:26 - long so the code kind of looks a bit
270:29 - cluttered
270:30 - but it's easy to read and descriptive so
270:34 - you can also go for shorter variable
270:36 - names to have a cleaner code
270:37 - again matter of taste i usually name the
270:40 - variables
270:41 - something descriptive something that
270:43 - basically really
270:44 - differentiates or says what the value is
270:46 - about
270:48 - and that basically takes care of
270:52 - existing suppliers or the suppliers that
270:55 - we already
270:56 - have in the dictionary else we do
270:59 - this and this is complaining about
271:03 - too many blank lines so let's fix that
271:06 - and
271:07 - that's basically our logic again to go
271:09 - through it once
271:10 - for new suppliers again this is going to
271:12 - happen three times because we have three
271:14 - suppliers
271:15 - we are basically setting the total
271:18 - inventory price or inventory value for
271:20 - that specific product
271:22 - because remember we are iterating
271:24 - through products
271:26 - and then every time a new product
271:30 - iteration happens for the same supplier
271:32 - we basically just
271:33 - add an inventory price or total value
271:36 - for that specific product
271:38 - for what we already have in the
271:41 - dictionary
271:42 - for that specific supplier so now
271:45 - let's again print out
271:49 - our dictionary
271:54 - let's actually print both values
271:59 - so the first dictionary is this one
272:02 - right here
272:03 - supplier and number of products second
272:06 - one
272:06 - is going to be supplier and total value
272:09 - of all the products they have in the
272:12 - inventory
272:13 - with us execute and there you go we have
272:16 - both dictionaries printed here and here
272:19 - you see
272:20 - for each company we have the value
272:23 - in price basically right here the value
272:27 - for the total inventory of all the
272:29 - products they have
272:31 - on this list and we see that value
272:35 - per supplier and the values are
272:38 - decimal numbers with cent precision so
272:41 - 95
272:42 - cents 47 cents because the prices
272:45 - are obviously like this as well and if
272:48 - you're wondering this
272:49 - comma here is actually a german format
272:52 - for number precision so this is going to
272:55 - be actually equivalent to
272:57 - english dot and we don't have to worry
273:00 - about this actually because
273:01 - python reads it and
273:05 - interprets it correctly so no problem
273:08 - with
273:08 - different language formats so that takes
273:11 - care of
273:12 - our second calculation
273:16 - now the third logic we're going to write
273:18 - is basically printing out
273:20 - all the products that have inventory
273:23 - less than 10
273:25 - like this ones here for example so
273:28 - the logic for that is actually going to
273:30 - be pretty easy
273:31 - what we need as a result is again a
273:34 - dictionary
273:35 - let's call it products which have
273:39 - inventory under 10
273:43 - like this and the value in the
273:45 - dictionary
273:47 - should be the product number
273:50 - which we have in the first column and
273:53 - the inventory count so let's get rid of
273:56 - these print statements
273:58 - and let's do calculation
274:01 - or we can do logic products
274:05 - with inventory less than
274:09 - 10. so basically as i said for each
274:12 - product
274:13 - which has inventory under 10 we want to
274:15 - print out
274:16 - or we want to save in a dictionary the
274:19 - product number
274:19 - and the inventory count so
274:23 - we have the inventory count already the
274:26 - value
274:27 - from the cell but we don't have the
274:30 - product number
274:30 - we're not accessing it so let's actually
274:33 - do that
274:35 - product number
274:40 - and we already know how this works
274:43 - this is going to be the first column
274:46 - right
274:47 - this one here and this gives us
274:50 - product number and now in our dictionary
274:55 - products under 10
274:59 - we want to add value like this product
275:02 - number
275:04 - and it's going to be set to value of the
275:07 - inventory
275:09 - like this however we don't want it for
275:11 - every
275:12 - product we wanted only for products with
275:14 - inventory less than 10
275:17 - and that's going to be an easy if
275:19 - conditional here
275:20 - if inventory again remember
275:23 - this logic all this logic happens for
275:27 - each product row right so all these get
275:30 - executed
275:30 - for each of these rows so basically we
275:33 - have inventory number
275:35 - on each iteration for each specific
275:37 - product
275:38 - and that's why we can just say if
275:41 - inventory is less than 10
275:44 - so if the value on that specific row is
275:47 - less than 10
275:48 - we want to add that product
275:52 - the current product that we are
275:54 - iterating on
275:55 - on the list and set the value of
275:58 - inventory as well
275:59 - again we have some complaining here
276:01 - because of the lines
276:03 - and this will be the logic basically
276:06 - and a use case for this type of
276:09 - calculation would be
276:10 - if we find products that have inventory
276:13 - which are less than 10
276:15 - means we need to reorder them right
276:17 - because they're going to get out of
276:18 - stock soon
276:19 - and now at the end
276:23 - let's print the list of all the products
276:25 - that have
276:26 - inventory less than 10. so i'm going to
276:29 - execute it
276:30 - and here we have the product number and
276:34 - inventory count so we have three
276:36 - products basically
276:38 - which have inventory less than 10 and
276:41 - let's actually
276:42 - check that product number 25 right here
276:46 - which has inventory of seven and product
276:50 - number
276:51 - 30 inventory of six
276:54 - and the third one as well now you're
276:56 - probably wondering why we have this dot
276:58 - zero here because by default those
277:00 - values are interpreted as
277:03 - float numbers and not integers if we
277:05 - wanted to we can actually fix that
277:08 - using the integer function
277:13 - in both cases like this
277:16 - let's execute it again and we have the
277:20 - integers and not floats
277:24 - and finally as a last exercise what
277:27 - we're going to do is we're going to
277:29 - actually
277:29 - add some value inside that spreadsheet
277:32 - till now we have been reading the values
277:34 - and doing some calculations and just
277:36 - printing the result
277:37 - on the terminal as the last exercise
277:40 - we're actually going to create a new
277:42 - column here for every row and we're
277:44 - going to
277:45 - calculate basically the total price of
277:48 - inventory
277:49 - right the number of units times the
277:51 - price and we're going to
277:53 - basically set the value for each product
277:56 - inventory multiplied by price so
278:00 - how do we add a column or how do we make
278:03 - changes
278:04 - to a file it's actually pretty easy
278:07 - the same way as we were grabbing the
278:09 - value from this
278:10 - file and basically reading the values we
278:12 - can
278:13 - add values to it and add columns and
278:15 - rows etc
278:17 - so to add a fifth column
278:20 - we're gonna do product list cell
278:25 - product row this is going to be the
278:27 - number of the row and
278:28 - a column number so the same way we
278:31 - accessed
278:32 - the cells for all other values we can
278:35 - basically
278:36 - access the cell on column five
278:39 - which has an empty value right so
278:43 - we're not actually creating a new column
278:45 - we're just grabbing
278:46 - a value of a column five which happens
278:50 - to be
278:50 - empty and we are overriding that value
278:52 - and we could
278:53 - do the same actually for any other
278:56 - columns here right we can overwrite all
278:57 - these values
278:58 - if we wanted to so that's basically what
279:00 - we're doing
279:01 - so we're grabbing that cell and we can
279:04 - now save it into a variable
279:06 - let's actually call it inventory
279:10 - price so now that cell
279:14 - is saved into that variable so we can
279:16 - reference it
279:17 - and note here that i didn't add dot
279:20 - value at the end
279:21 - because if we want to update the cell
279:24 - we need the whole cell object right so
279:27 - that we can
279:28 - actually set a value on that so how do
279:30 - we set a value
279:31 - for that specific cell so again note
279:34 - that this is
279:35 - iteration so for each product row
279:38 - the value will be set so how do we set
279:42 - the cell value i'm just going to grab
279:44 - this
279:45 - variable here inventory price which is
279:47 - representing the cell
279:49 - in column five for each iteration
279:52 - and right here at the end because this
279:54 - is our last exercise
279:55 - let's write this is a logic
279:59 - or basically add value for
280:02 - total inventory price
280:06 - and the way we set the value in a cell
280:10 - is dot value equals
280:13 - and the calculation for that is actually
280:16 - very easy we already did it here
280:18 - inventory times the price for that
280:21 - specific product
280:23 - and that's it so we're using that dot
280:25 - value here
280:26 - in order to set the value instead of
280:28 - grabbing the value
280:29 - and that will actually update and
280:33 - add this calculation a result of the
280:36 - calculation
280:37 - on each line on this column but note
280:40 - that this will only
280:41 - change the value in a temporary file but
280:44 - it's not going to save
280:45 - anything right so what we want to do at
280:48 - the end
280:49 - if we want this change to persist to
280:52 - actually be
280:53 - saved we want to explicitly save the
280:56 - file
280:56 - so for example if i manually did
280:59 - something here added some value
281:01 - i would need to save it here as well
281:03 - right so that's exactly what we need to
281:05 - do
281:05 - here but programmatically using python
281:09 - so how do we save a file using python
281:11 - again
281:12 - this package or this module that we use
281:15 - here
281:16 - also gives us a function that we can use
281:19 - to save the file
281:20 - and since we're doing an operation on a
281:22 - file and not a sheet here
281:24 - we're going to grab that variable in
281:26 - file
281:27 - and here at the end we're going to call
281:31 - a save function on it and this will save
281:34 - the file changes
281:35 - however we're not overriding the same
281:37 - file the existing inventory file
281:40 - we're creating a new one and because of
281:42 - that we need to provide
281:44 - a name of the new file that is going to
281:46 - be created
281:47 - with the save function and we're going
281:50 - to call that
281:52 - file let's say inventory
281:56 - with total value
282:00 - and extension
282:04 - the same extension as we have here so
282:07 - this line will now save the changes and
282:10 - create a new file
282:12 - from the original one which has these
282:15 - values generated basically
282:17 - so now that we are done with the fourth
282:20 - exercise let's actually print out
282:22 - everything
282:30 - that we've done so far i'm gonna take
282:33 - all those values
282:50 - so this is going to be execution of all
282:53 - our logic
282:54 - printing these three dictionaries here
282:56 - and then updating
282:58 - the spreadsheet file and saving it into
283:00 - a new file
283:02 - so with this let's actually execute our
283:05 - program and see what happened
283:08 - first of all we have all those three
283:10 - dictionaries listed here
283:12 - or printed here with the values
283:15 - and if we pull this aside
283:19 - here you see a new file got generated
283:21 - with the name
283:22 - inventory with total value and if we
283:25 - open this file
283:26 - we should see that for each row a new
283:30 - column was generated and filled with
283:32 - values
283:33 - which is calculated for each product's
283:35 - inventory and price
283:38 - so that's basically our project that's
283:41 - how you work with
283:42 - files in python specifically with
283:45 - spreadsheet
283:46 - files and as i said at the beginning
283:48 - this could be actually very useful
283:50 - automation logic when you're working at
283:53 - a company where there are lots of
283:54 - excel files or spreadsheet files that
283:57 - employees have to work with
283:59 - and manually update stuff inside
284:05 - in this part we're going to learn the
284:06 - concept of objects and
284:09 - classes in python and generally object
284:12 - oriented
284:13 - let's consider an example of an
284:16 - application with
284:17 - lots of users for example linkedin right
284:19 - we have
284:20 - users and each user will have some
284:23 - information for example
284:25 - email address
284:31 - name of the user
284:40 - password
284:42 - maybe a current job title
284:56 - work experience a set of skills and so
285:00 - on
285:00 - right so each user will have all this
285:03 - information but
285:04 - obviously the actual values the actual
285:06 - information will be different
285:09 - for each user in addition to that users
285:12 - are able to do something with their own
285:14 - information right
285:15 - so for example a user can change their
285:17 - password
285:22 - change their current job title add a new
285:25 - skill
285:34 - and again basically do stuff with their
285:37 - own
285:38 - personal information and our program
285:40 - will be
285:41 - able to handle this user information
285:44 - plus
285:44 - user changing their information right so
285:47 - this will be
285:48 - user data and in order to do something
285:52 - so to perform some action we would have
285:54 - functions for that right
285:56 - so all of these will actually be
285:59 - functions however as i mentioned
286:03 - every user will have their own data and
286:05 - whenever a new user basically registers
286:08 - for an application
286:09 - all these data should be gathered for
286:11 - that new user
286:13 - and saved in the application so
286:15 - basically that means that
286:17 - in our program we need some way to
286:20 - define
286:20 - kind of a blueprint for a user for all
286:23 - the data
286:24 - user information and user behavior right
286:28 - things that the user can do in the
286:30 - application
286:31 - because if we have thousand users in our
286:33 - application obviously we can't
286:35 - write the same logic and same variables
286:39 - thousand times right we want to have a
286:41 - blueprint once
286:43 - and then we can use the blueprint for
286:45 - all those thousand users
286:47 - and that blueprint for a user is called
286:50 - a class
286:51 - and the specific implementation of that
286:54 - blueprint
286:55 - is called an object so think of this
286:58 - like a blueprint of a building right you
287:01 - can have a blueprint
287:02 - once which is like a general description
287:05 - of
287:06 - building with doors and windows and
287:08 - everything that
287:09 - every single building has and then the
287:12 - specific implementation
287:13 - of that blueprint will be the actual
287:16 - built ready buildings right
287:18 - so that's the same concept we're going
287:20 - to create a class
287:21 - blueprint for a user and the user class
287:24 - blueprint will define
287:26 - what information a user has
287:29 - and what actions user can perform in the
287:32 - application
287:33 - and object then will contain the actual
287:35 - information
287:36 - like this information right here
287:40 - for each specific user so let's clean
287:43 - all these up
287:44 - and let's now actually create class
287:47 - user
287:50 - so let's create a new file in our
287:52 - project and let's actually call it
287:55 - user dot pi so this is going to be our
287:58 - user class
288:00 - and inside that i'm going to paste in
288:03 - this piece of code that basically will
288:06 - represent
288:07 - data for the user and some behavior
288:11 - these pieces of data are also called
288:13 - attributes
288:14 - for that class so now let's turn
288:17 - all of these into a class so first of
288:20 - all
288:21 - we create a class using class special
288:23 - work and you also see the syntax
288:25 - highlighting
288:26 - and we're going to call that user
288:29 - and you know the syntax already for
288:30 - functions um etc
288:33 - with indentation so this is going to be
288:35 - where our class definition goes
288:37 - now note here the capital letter for u
288:39 - for user
288:41 - and lowercase user in the
288:44 - python file name so a standard
288:47 - convention is that we call classes with
288:50 - a capital letter
288:51 - and the file names are written in
288:53 - lowercase letters
288:54 - and now all of these should actually go
288:57 - inside that
288:58 - indentation right like this now we said
289:01 - that
289:01 - class is a blueprint for specific
289:04 - objects
289:04 - and blueprint cannot actually have
289:07 - specific
289:08 - values right so all these needs to
289:11 - be removed so in the blueprint we don't
289:13 - have any specific values we just have
289:15 - the attributes
289:16 - so basically we say this user will have
289:19 - an email
289:20 - name password and current job title the
289:24 - actual values of those attributes
289:27 - will be then set when we create an
289:29 - object from the blueprint
289:31 - however we need a function that will
289:34 - actually
289:34 - take those specific values and assign
289:37 - them
289:38 - to an object which is created from the
289:40 - blueprint
289:41 - and we're gonna create that function
289:44 - right here in the class
289:45 - and that function actually is called
289:48 - init with
289:50 - underscore or two underscores at the
289:53 - beginning and
289:53 - at the end a couple of notes here first
289:55 - of all you see the syntax highlighting
289:57 - just changed
289:58 - to this different color second note is
290:01 - that these
290:02 - functions that start with underscore in
290:04 - python are special functions
290:06 - so python basically gives them some
290:09 - special meaning so it knows
290:11 - exactly what this init function is and
290:13 - we also have to call it init we can't
290:15 - just call it whatever we want and final
290:18 - note is that this init function in
290:20 - python is
290:21 - something called a constructor again we
290:24 - have a blueprint and we're constructing
290:27 - objects from the blueprint and this init
290:29 - function
290:30 - the constructive function will help us
290:32 - construct
290:33 - objects from that user class and now
290:37 - for a function syntax you know that we
290:39 - use
290:40 - these brackets right and when i
290:44 - start writing the bracket you see that
290:46 - self
290:47 - got automatically created as the
290:50 - parameter here
290:51 - and the reason is as i mentioned python
290:54 - knows what the init function is and that
290:56 - it's a
290:56 - constructor so it knows that it needs
290:59 - this
291:00 - self as a parameter again self is also a
291:04 - special
291:04 - word in python it has a special meaning
291:07 - and it actually
291:08 - refers to this class here
291:11 - right this entire class if i hover over
291:15 - it
291:15 - you see self points to the user class
291:19 - and it will basically just help us
291:22 - access
291:22 - and reference all the attributes and
291:24 - functions within that class
291:26 - so it's for special usage within that
291:29 - user class
291:31 - and we're going to see examples of how
291:32 - to use that in a second
291:34 - now you can think of those attributes as
291:37 - variables
291:38 - within the class because they belong to
291:40 - the class right they describe basically
291:42 - what attributes or what characteristics
291:45 - this
291:45 - class has and in order to define that
291:48 - these
291:48 - variables belong to the class we need to
291:51 - use
291:52 - self here so
291:58 - and you see again syntax highlighting
292:00 - changed
292:01 - and the red line disappeared so
292:03 - basically we are defining
292:05 - that email name password and current job
292:07 - title
292:08 - belong to this class using this self
292:12 - keyword and now the last thing remaining
292:14 - in this constructor again remember
292:16 - constructor
292:17 - is to construct new objects so whenever
292:19 - a new object is created
292:22 - the specific values will be assigned
292:25 - to all these four variables right and
292:28 - those
292:28 - values those specific values will be
292:31 - passed into the constructor as
292:33 - parameters so email name
292:36 - password and current
292:40 - job title those four values
292:43 - must be provided to the constructor
292:46 - whenever we're creating
292:47 - a new object note that these
292:51 - names here could be different from this
292:53 - these are not the same these are just
292:55 - parameters and using these parameter
292:57 - values we are going to
292:59 - basically set the variables or
293:03 - attributes
293:03 - of the class like this
293:07 - and the warning is gone as well again as
293:10 - i mentioned this could be something else
293:12 - we could call it user email so it
293:15 - doesn't actually have to be
293:16 - the same it's just for convenience so
293:20 - this function will construct an object
293:23 - with parameters that we provide when we
293:26 - actually create it
293:27 - and we're going to see how to create an
293:29 - object later this is just the definition
293:32 - as remember when you define a function
293:33 - nothing actually happens
293:35 - until you call or you use that function
293:38 - so
293:38 - right here we're just defining that
293:40 - function so that we can use it
293:42 - later so constructor logic is
293:45 - done now we have these two functions
293:49 - that any user in our application
293:52 - can do right any user can change their
293:54 - password or change their job title
293:57 - and logically when change password
293:59 - happens
294:00 - by user basically user provides a new
294:03 - password
294:04 - in order to override the old one so the
294:07 - flow will be following
294:08 - the object will be created for the
294:11 - specific user
294:12 - so the initial data for that object will
294:15 - be provided
294:16 - so we'll have the user email name
294:18 - password and current job title
294:20 - and later at some point user may decide
294:22 - to change their password
294:24 - and their current job title and that
294:26 - means the
294:27 - initial data will be changed and that
294:30 - means
294:32 - that we're actually changing the
294:34 - attributes
294:38 - self.password with a new password
294:41 - right so logic will be like this
294:44 - now we have red lines here why because
294:47 - we need
294:48 - this self as a parameter first of all we
294:50 - also have that
294:51 - as um note right here
294:56 - so just like here we need to actually
294:58 - pass that self as a parameter that's
295:00 - just how it is
295:01 - because we need to access attributes
295:04 - of that class in that function and
295:07 - new password will be
295:12 - new password variable will be the new
295:14 - password
295:15 - basically that user wants to set so this
295:18 - will change
295:19 - the initial password with the new one
295:22 - and the same way
295:23 - in change.title we have self as a first
295:26 - parameter
295:27 - we always need it in all the functions
295:29 - because
295:30 - otherwise we cannot access the
295:32 - attributes in the class
295:33 - and new job
295:38 - title
295:45 - so now let's review this class that we
295:47 - created
295:48 - first of all we have this class keyword
295:50 - here with a capital letter
295:52 - for user you already know the syntax
295:55 - with colon and then
295:56 - indentation so this all of these
295:59 - inside this indentation is class body
296:03 - so part of the class logic first we have
296:05 - this
296:06 - init constructor that sets the initial
296:09 - values
296:10 - of that class attributes whenever we
296:13 - create
296:13 - a specific object for that class right
296:17 - so this happens only when we construct a
296:18 - new object
296:20 - and then on that constructed object we
296:22 - can change password we can change
296:24 - job title and note that right now we
296:27 - have
296:28 - nothing basically hard coded we have no
296:30 - specific
296:31 - values here right everything is just
296:34 - parameterized
296:36 - and also this is just a definition for
296:39 - class and its functions nothing will
296:42 - actually happen when we execute this
296:44 - because we're not creating any user
296:47 - objects
296:48 - so if i right click here and execute
296:51 - this
296:51 - run user you see that
296:54 - nothing happened because the class
296:56 - definition was created
296:58 - but we're not doing anything with that
297:00 - class definition we're not creating
297:02 - new users so now let's actually go ahead
297:05 - and
297:05 - do that
297:09 - in the same file in user.py
297:13 - i would actually use that class
297:15 - blueprint to construct a new
297:17 - user object and creating an object from
297:20 - a class is actually very simple
297:22 - we just write name of the class and
297:25 - parentheses this is actually the same
297:28 - syntax as
297:29 - calling the function with parameters
297:32 - and the parameters that we need to give
297:34 - that
297:35 - class are these four values here
297:39 - and note that calling this user
297:42 - class function basically in the
297:44 - background we'll call
297:45 - init function right so the constructor
297:48 - will be called whenever we write this
297:50 - syntax with class name and parentheses
297:53 - and this init constructor as you see
297:56 - expects
297:57 - four parameters so we have to provide
297:59 - all those parameters
298:01 - right here in the parenthesis so let's
298:03 - actually provide them
298:05 - let's do user email
298:09 - like this
298:13 - my username and password
298:22 - and a current job title again very
298:25 - similar to calling a function
298:27 - and this will actually construct a new
298:30 - object from the user class which has
298:33 - these four attributes with
298:37 - values that we just provided here and
298:39 - has these
298:40 - two functions that we can use
298:44 - to either change a password or change
298:46 - job title
298:47 - one note here is that functions that
298:50 - belong to a class
298:52 - are actually called methods so there's a
298:54 - special name for functions
298:56 - which are part of a class so we can
298:58 - refer to them as
299:00 - methods so user object basically gives
299:03 - us
299:04 - two methods that we can use now again if
299:07 - we execute this program now
299:08 - we will not see anything even though
299:11 - user will be created because
299:12 - we're not printing anything to the
299:14 - console we're not doing anything so
299:17 - let's do that run user nothing happens
299:20 - because
299:21 - we need to print a message or some kind
299:23 - of information
299:24 - so what i'm going to do now is inside
299:26 - that class
299:27 - i'm going to create a function or a
299:30 - method as we learned now
299:32 - that basically prints back some user
299:34 - information right
299:35 - prints me the name email and current job
299:38 - title because we don't want to display
299:40 - password so let's give us some space
299:43 - here
299:43 - and let's create a function called get
299:47 - user info so that we can see something
299:51 - and again as soon as i typed in
299:54 - these first parentheses self got
299:57 - generated
299:59 - because we need self in every function
300:01 - within the class
300:02 - and in the function body we're gonna
300:06 - print user information
300:10 - so let's say user
300:14 - and name of the user which we can access
300:17 - using self
300:18 - remember all the attributes that the
300:20 - object has can be accessed with
300:23 - this special word here so self
300:26 - dot name
300:29 - so user whatever the user's name is
300:32 - currently works
300:35 - as a and now we need the job description
300:40 - or job title
300:44 - and you can contact
300:47 - them at and now we can
300:51 - use the email
300:54 - so this message will be printed for the
300:57 - user
300:58 - again because this will be used for
301:01 - any user of our application the message
301:05 - these parts will be the same but each
301:07 - user will have their own different name
301:09 - different job title and different email
301:11 - address
301:12 - so all of these are
301:15 - and written as variables because we
301:17 - don't know these values up front
301:19 - so now we can actually use this function
301:23 - or method to print out information of a
301:27 - specific
301:28 - user so how do we use or how do we call
301:31 - that function of the user
301:33 - we first save it into a variable
301:36 - app user one
301:40 - or nana doesn't really matter let's call
301:42 - it app user one so it's generic
301:45 - so how do we use that function
301:49 - to print out the information about the
301:50 - user if i do
301:52 - app user one and dot
301:56 - you see that i have the attributes here
301:58 - the four attributes that
302:00 - our user object has or user class
302:03 - and we have these three methods of the
302:06 - class get user infor
302:07 - change job title and change password so
302:10 - using get
302:11 - info we can call this function
302:17 - and if i execute this right here you see
302:20 - user
302:20 - nanogenasia currently works as a devops
302:23 - engineer
302:24 - you can contact them at this email
302:27 - and now let's say we want to change
302:30 - job title of that user we do that in the
302:34 - same way
302:35 - app user one dot
302:38 - change job title and
302:41 - we're gonna provide the job title
302:44 - parameter
302:45 - note that even though you see two
302:47 - parameters here on that function
302:48 - this first parameter is passed in
302:50 - automatically so we don't have to
302:53 - basically pass that self right it's
302:55 - already done automatically we just have
302:57 - to worry about these parameters
302:59 - so new job title is let's say
303:03 - devops trainer
303:07 - and now we can call that
303:10 - user info method again
303:13 - and execute and you see first
303:16 - message printed here before we change
303:19 - the job title
303:20 - now it's devops trainer
303:23 - so that's how we can create a new
303:26 - object from a class and we can
303:30 - use methods of that object by first
303:32 - saving that object into a variable and
303:34 - then calling that function
303:36 - on that variable and obviously now this
303:39 - is just
303:40 - one user but if we had another one
303:45 - user two that's actually
303:50 - clean this up we can create
303:54 - a new user with different values
303:58 - like this
304:04 - they have their own email
304:08 - own name
304:16 - own password and on
304:19 - job title and again
304:24 - we can create that user and basically
304:27 - just use the methods defined in the
304:30 - class
304:31 - and in two different cases or for two
304:34 - different users
304:35 - obviously the user info will be
304:38 - different
304:39 - so let's execute this and right here you
304:41 - see the user
304:43 - information for both users and obviously
304:46 - if you have an application like
304:48 - linkedin you don't have two users or a
304:50 - thousand users
304:51 - you probably have millions of users and
304:53 - having
304:54 - a user definition once and
304:57 - reusing it every time a new user gets
305:00 - created or
305:02 - basically existing users do something in
305:04 - application
305:06 - is only possible when using classes
305:09 - and objects instead of just having all
305:12 - these logic
305:13 - non-structured throughout the code and
305:16 - again in this type of applications
305:19 - you would not have four attributes and
305:22 - three methods you will have
305:23 - probably hundreds of attributes and
305:25 - hundreds of such
305:27 - methods now as you see here
305:30 - we have created this user.pi
305:34 - file for user class but we're also
305:37 - creating these
305:38 - objects in the same file which actually
305:40 - doesn't make sense because
305:42 - the file should be only for defining the
305:44 - class right
305:45 - so all of this logic actually needs to
305:47 - move out from here
305:49 - and this should be just only for class
305:53 - definition
305:54 - so in the application again using an
305:57 - example of linkedin
305:58 - we would have class user and then we
306:01 - would have
306:02 - a class post right whenever someone
306:05 - posts something
306:07 - each post will have their own attributes
306:09 - like the actual
306:11 - message or text in that post the author
306:14 - who wrote the post how many likes it has
306:16 - etc
306:17 - as well as specific functions right for
306:20 - example
306:21 - changing the post commenting on the post
306:23 - etc
306:24 - so you will have separate file for each
306:28 - such class right in the application and
306:30 - then you would have
306:32 - one file somewhere else this could be a
306:34 - main dot pi
306:35 - where you would actually use all those
306:37 - different classes and create
306:39 - objects from those classes and that
306:41 - means that logic that we wrote here
306:44 - constructing a user object and then
306:46 - calling some functions on that
306:48 - will actually happen in another file in
306:51 - our case let's use
306:52 - main.pi and now let's see how we're
306:54 - going to do that
306:55 - i'm going to paste in the code that i
306:58 - copied from there
306:59 - and as soon as i paste in you see those
307:02 - red lines
307:03 - so basically main.pi says that it cannot
307:07 - find
307:07 - a reference to user so this file doesn't
307:10 - know anything about the user class
307:12 - so how do we fix that or how do we make
307:15 - this user class available
307:17 - in another file and if you remember
307:20 - when we needed to use modules or
307:23 - basically functions
307:24 - variables whatever from other files in
307:26 - python
307:27 - we use import to basically import those
307:30 - functions
307:31 - and make them available here or import
307:34 - the whole module
307:35 - to make its functions and variables
307:37 - available here
307:38 - and the same way we can import classes
307:41 - from another file import
307:45 - user and note here that i'm using the
307:48 - name of the file
307:50 - user lowercase and not the class name
307:53 - with capital user right
307:54 - so we are importing that file so now we
307:58 - can use
307:59 - anything that is defined in that file
308:01 - and one of them
308:02 - is class called user and the way we can
308:06 - access that class now is using the name
308:10 - of module and not the class
308:13 - user itself and this is basically
308:16 - exactly the same concept as we saw
308:18 - before
308:19 - because we are importing a module called
308:22 - user
308:23 - remember every python file that has
308:26 - functions or variables or classes inside
308:30 - is a module so we are importing a module
308:33 - and once we have that module imported
308:36 - now we can use
308:37 - and access functions variables or
308:40 - classes
308:41 - of that module and we can do that by
308:43 - copying the name of the module
308:45 - dot and there you go in the same way
308:48 - here so exactly the same concept whether
308:51 - this is a function or a class doesn't
308:54 - matter
308:55 - we use it the same way remember when we
308:57 - use the date
308:58 - time module with the syntax
309:01 - datetime.daytime
309:02 - and that was an example of using a class
309:06 - from a module now user.user may
309:09 - look a little bit weird so we can use
309:12 - our
309:13 - familiar import statement where instead
309:16 - of
309:17 - importing the whole module we can pick
309:19 - and choose and import specific
309:21 - definitions or specific elements of that
309:24 - module
309:25 - in our case we just have one element
309:26 - which is the class
309:28 - so we're going to say from user module
309:30 - import
309:31 - user class and now we don't need the
309:35 - module name anymore because we imported
309:37 - the
309:38 - class itself and now if we
309:41 - execute main dot p y
309:45 - let's do it again here we have the same
309:48 - result
309:49 - for two of our users
309:54 - and again as i said in applications you
309:57 - will have multiple classes
309:59 - that are connected to each other so for
310:01 - example if we have a post here
310:03 - post blueprint basically whenever a new
310:06 - post gets created
310:08 - with some specific values like the
310:10 - actual message
310:11 - and creation date time etc
310:14 - it will also have an author and that
310:17 - author will
310:17 - actually be one of those user objects
310:20 - right
310:21 - so you will have some functions here
310:23 - that actually
310:24 - reference the post and we can also see
310:28 - that in action
310:29 - let's actually create a post class
310:36 - let's give it just two attributes to
310:38 - keep it simple
310:39 - so we need a constructor here
310:43 - in it
310:47 - and we're gonna pass in message
310:50 - and author right this is gonna be the
310:53 - user who wrote it
310:55 - and you know the drill already
311:09 - and let's create another function
311:12 - which displays a post with its
311:15 - respective author so let's do get
311:19 - post info
311:23 - again we have self here and let's print
311:30 - post
311:36 - written by
311:39 - and the author name so this is going to
311:43 - be our simple
311:44 - post class and user
311:47 - is able to create new posts so we have
311:50 - the blueprint for a post
311:52 - and the same way we can create that post
311:56 - inside the main dot pi so first let's
311:59 - import
312:02 - the post class
312:08 - and then here we're going to create a
312:10 - new post
312:11 - in pycharm you get this nice display of
312:14 - parameters
312:14 - that function or class basically
312:18 - expects so we have message and author
312:21 - let's do some
312:27 - message or post and as a second
312:29 - parameter
312:31 - we have the author and we can use
312:36 - the name of a user so let's do
312:41 - app user to dot name and this will
312:44 - create
312:44 - an object also called instance in
312:47 - programming
312:48 - special instance of that post class
312:52 - and then we can print the information
312:56 - of that post first assign it
312:59 - to a variable let's say it's a new post
313:02 - and on a new post we're gonna call get
313:06 - post info let's actually run this
313:08 - application now and see the result
313:10 - and here we have our post message that
313:13 - gets
313:14 - printed by this get post info method
313:18 - in the post class
313:22 - and at the beginning i mentioned object
313:24 - oriented programming
313:26 - which basically means that when you're
313:27 - writing your code with
313:29 - objects and classes like this to create
313:32 - blueprints and then
313:33 - use those blueprints for specific
313:35 - instances
313:37 - that's called object-oriented
313:38 - programming and also an
313:40 - interesting note here is that in python
313:43 - almost
313:43 - everything is actually an object for
313:46 - example the data types like string
313:49 - integer list set etc when we printed
313:52 - them out we saw
313:54 - class of string or class of
313:57 - list so these data types are also
314:00 - classes in python
314:01 - and this int or sdr for string functions
314:05 - we called
314:06 - where actually the constructor we called
314:09 - to create a string
314:10 - or integer object and the constructor of
314:14 - int for example took a string
314:16 - representation of a number
314:18 - and in its init function and constructed
314:21 - an integer out of it now for us in terms
314:24 - of
314:24 - using these data types and variables etc
314:28 - it doesn't actually matter but it's just
314:30 - an interesting thing to know
314:32 - about how this whole thing works in
314:34 - python
314:40 - in this part we're going to learn how to
314:43 - use
314:43 - python to talk to external applications
314:48 - in our case we're going to use gitlab
314:49 - and then application and just
314:51 - note here that communication between
314:54 - two applications in our case our python
314:57 - application
314:58 - and a gitlab application usually happens
315:02 - using a common protocol like http
315:05 - so basically our python application will
315:08 - send an http request
315:09 - to gitlab application and from the
315:12 - gitlab application it will get
315:14 - an http response for that request
315:17 - so just know that http is just a
315:19 - protocol
315:20 - that these two applications can
315:22 - communicate with
315:24 - over the internet i have a couple of
315:26 - projects on gitlab
315:27 - so we're gonna write a very simple
315:29 - python application
315:30 - that basically goes to gitlab and asks
315:33 - for the list
315:34 - of projects for my user and
315:37 - then just prints it here in our run
315:40 - window
315:41 - and the concept of one application
315:44 - talking to another is basically done
315:47 - using
315:48 - something called api requests so the
315:51 - remote
315:52 - application in this case gitlab has an
315:54 - api
315:55 - so these are functions basically that
315:58 - gitlab
315:59 - makes available for other applications
316:02 - to call
316:03 - and we're going to call those functions
316:04 - from our python application
316:06 - in order to get the list of projects for
316:08 - my user and that
316:10 - communication or python basically asking
316:13 - for this information
316:14 - is going to be an api request or api
316:18 - call and what we get in response from
316:20 - this gitlab
316:22 - api is going to be api response
316:25 - so let's go ahead and do that
316:30 - in python in order to make those
316:33 - external requests
316:34 - to remote applications we're going to
316:37 - need a module
316:38 - called requests this is a generic module
316:41 - that you can use for
316:42 - any external application and as i
316:45 - mentioned at the beginning the
316:46 - communication happens
316:48 - using http protocol between two
316:50 - applications
316:52 - and as you see here also in the module
316:54 - description it says
316:55 - an http library which allows you to send
316:58 - http requests and then receive http
317:02 - responses
317:03 - from another application and that's
317:05 - exactly what we're going to be doing
317:07 - and this request module is not part of
317:10 - python
317:11 - so we're going to install it using pip
317:13 - again remember that we're using pip
317:16 - that actually comes packaged with the
317:18 - pycharm
317:19 - so in the terminal window of my ide of
317:22 - pycharm
317:23 - i'm going to execute peep install
317:27 - requests
317:32 - successfully installed request this is
317:34 - the version of that module
317:38 - and if i expand this external library's
317:41 - site packages
317:42 - i'm going to see the requests package
317:46 - in the list great
317:50 - so once we have the module available
317:51 - locally we can
317:53 - import that module in our file
317:56 - and this requests module now has or
317:59 - package actually
318:00 - has functions variables and objects
318:04 - that we can use to talk to these remote
318:07 - applications like gitlab
318:09 - as i said gitlab is just one example you
318:11 - can talk to any
318:12 - remote application that has an api and
318:15 - we can not only do
318:16 - requests for getting the existing
318:18 - information but we can also make
318:20 - requests
318:21 - to change something in that remote
318:24 - application so for example
318:25 - i can write a python application that
318:27 - will actually create
318:29 - a new project on my gitlab account
318:32 - but to keep the demo simple we're just
318:34 - going to be
318:35 - fetching information from gitlab so
318:38 - how do we make requests to an api of an
318:42 - application
318:44 - with this requests module we get a
318:46 - function called
318:47 - get and get takes one main parameter
318:51 - which is url so basically we need to
318:54 - tell python where to find that remote
318:56 - application
318:57 - or again in our case where to find
319:00 - gitlab
319:01 - to talk to it so we need the url of
319:03 - gitlab
319:04 - and where do you find this url
319:07 - information of a remote application
319:09 - you can basically google that every
319:11 - application has their own documentation
319:13 - where you can see the urls
319:14 - so for example for gitlab i actually
319:17 - googled it
319:18 - so if i do gitlab api documentation
319:22 - like this
319:27 - let's make it bigger so you have
319:29 - basically description
319:30 - for the api and what type of information
319:34 - you can get from gitlab
319:35 - and also what kind of things you can
319:37 - create in gitlab
319:39 - and you see an example api here that
319:42 - basically
319:43 - just lists all the projects however we
319:45 - want to list
319:46 - projects of one specific user in this
319:49 - case i want to list my own projects
319:51 - and in this documentation i found this
319:54 - list user project
319:56 - section where i have an example
319:59 - of how to use projects for a specific
320:02 - user
320:02 - so we have slash users and the user id
320:05 - so that's going to be my gitlab user id
320:07 - and projects so basically the url will
320:11 - now look like this
320:12 - first we're gonna have this base url so
320:14 - that's basically
320:15 - https gitlab.com api v4
320:18 - and all the things that we want to do is
320:21 - going to be
320:22 - at this base api and
320:25 - after that we can basically depending on
320:28 - what exactly we want to do
320:29 - we can choose one specific action
320:32 - and again going back this is
320:36 - the action we want to execute
320:39 - on this base url so from gitlab we want
320:43 - projects that belong to user and right
320:46 - here i'm going to add
320:47 - my own gitlab user id
320:51 - so if you have a github account you
320:52 - should add your own user id here
320:55 - and that's going to be an api url for
320:58 - user projects and this will actually
321:01 - give us
321:02 - some kind of response so requests.get
321:05 - will make that request
321:06 - to gitlab and it will return some kind
321:08 - of response and we can save that
321:10 - response into a variable
321:12 - so let's call this variable response
321:15 - because that's what it is
321:17 - and on the next line let's actually
321:19 - print and see what's in that response
321:27 - let's run our application and
321:30 - right here you see we have an object
321:33 - response
321:34 - with a code here 200 is a code for a
321:37 - successful
321:38 - request but we're not seeing the actual
321:41 - contents right we want to see the
321:42 - projects with their
321:44 - details and in order to get that we're
321:47 - gonna
321:48 - do dot and text and let's actually
321:51 - execute this now
321:52 - and now you see these square brackets
321:56 - which means it is a list because we have
321:59 - a list of projects
322:01 - and this whole bunch of information
322:03 - about projects there
322:05 - and you also see curly braces so this is
322:08 - a list of
322:09 - dictionaries and each dictionary holds
322:12 - information
322:13 - of one specific project now
322:16 - if i actually print the type of that
322:20 - response text
322:27 - like this see that it is a
322:30 - string so even though we see the format
322:33 - is actually
322:35 - a list of dictionaries we're getting a
322:38 - string because we're accessing
322:40 - text attribute now there is actually
322:43 - another attribute which will give us
322:45 - the same thing but as an actual list of
322:49 - dictionaries instead of string and this
322:52 - will be actually a better way to get
322:54 - that information because then we can
322:55 - work on it so we can
322:57 - look through it and get the individual
323:00 - elements
323:00 - and access the values so what i'm gonna
323:03 - do now instead of
323:04 - dot text i'm gonna
323:08 - use json json is a standard format that
323:12 - all programming languages
323:14 - understand and usually when two
323:16 - applications
323:17 - communicate with each other which are
323:19 - written in different languages
323:20 - and with different technologies with
323:23 - json they have a common format
323:26 - for communication and this requests
323:28 - module basically gives us this
323:30 - json function to read the json format
323:33 - that
323:33 - gitlab sent us so json function will
323:36 - read the json response
323:38 - from gitlab and turn it into one of the
323:41 - python data types
323:43 - so i'm going to execute this now and now
323:46 - you see that response.json actually
323:50 - gave us list data type instead of string
323:54 - so again for demonstration
324:02 - since this is a list i'm going to
324:05 - access the first element of that list
324:09 - and print that out and right here you
324:12 - see
324:13 - that is actually the first element
324:17 - just the first one from the list and
324:19 - that element
324:20 - is a dictionary as you see so all these
324:23 - just to give you an idea
324:24 - of what we're getting back from that
324:27 - gitlab
324:28 - api and what we can do with that
324:30 - response or how we can actually work
324:32 - with that response
324:33 - so i'm gonna clean all this up and we
324:36 - saw that
324:37 - response.json gives us exactly what we
324:40 - want
324:40 - and that is a list of my projects so
324:44 - let's call this
324:47 - variable my projects and now what i want
324:50 - to do with this
324:51 - is i want to print out
324:55 - in our window for each project
324:58 - project name and project url so
325:01 - basically the repository url for that
325:04 - project
325:05 - so i don't want to have any other values
325:08 - like id
325:09 - or description or whatever
325:12 - other stuff i have in this dictionary i
325:14 - just want name
325:15 - and project url for every single
325:18 - project and i want that information
325:20 - printed out in this
325:22 - window so how do we do that
325:25 - we have a list so we're gonna loop
325:28 - through that list
325:29 - to access each element inside that list
325:33 - so you remember we have for loop to loop
325:37 - through
325:37 - or iterate through a list and give us
325:40 - access to each element
325:42 - one at a time so here i'm going to write
325:45 - for loop and if you remember the syntax
325:47 - of for loop we have
325:49 - four and then a variable which will
325:51 - represent the single element in that
325:53 - list
325:54 - and in this case it's going to be a
325:55 - project a single project
325:58 - and then we have in
326:02 - list so for project in my projects
326:06 - do something so for every project
326:09 - element
326:09 - in this my projects list we want to
326:12 - print out the name and the url
326:15 - so right here i will do print
326:18 - and let's do our formatted string here
326:21 - and let's start writing our message
326:24 - let's do
326:25 - project name
326:28 - and the project name will be this one
326:31 - right here
326:32 - now how do we actually access
326:35 - the name of the project in each project
326:39 - element as you see here these project
326:42 - elements are actually
326:43 - dictionaries and how do we access a
326:46 - value in a dictionary
326:48 - using the name of the dictionary in this
326:51 - case
326:51 - our variable project so this whole thing
326:54 - is going to be
326:55 - saved into a variable called project and
326:57 - then on that
326:59 - variable on the dictionary we're going
327:01 - to pass in
327:02 - the name of the key which is name
327:06 - now i've been using double quotes
327:08 - throughout our project
327:09 - and for a syntax for dictionaries as
327:12 - well
327:13 - like this
327:16 - right however here we have a small
327:19 - problem which is
327:20 - we have double quotes inside the double
327:23 - quotes but as you remember
327:25 - for string representation we can
327:27 - actually use
327:28 - single quotes as well as double quotes
327:31 - and this is one of the
327:32 - really important use cases for why we
327:35 - can actually use
327:36 - both single and double quotes for a
327:39 - string
327:40 - and that is if we have a string inside
327:42 - another string
327:43 - like right here we can actually use that
327:47 - interchangeably so that we don't have
327:49 - this problem here
327:51 - so now as you see back to normal
327:53 - everything works because
327:55 - now python knows okay this is another
327:58 - string
327:59 - which we're using inside this string
328:02 - so we can use these interchangeably as
328:04 - we want so this could be single quotes
328:06 - and this could be double quotes
328:08 - wouldn't really matter but that's a
328:10 - really good use case why we need
328:11 - both types of quotes so we have the
328:15 - project name
328:16 - now we need a project url
328:22 - and let's see where the project url is
328:25 - in our dictionary
328:26 - this is one element one dictionary right
328:29 - so
328:29 - i'm gonna scroll it to the left
328:33 - and we have web url this is what we
328:35 - could use
328:36 - or we could also use http url to repo
328:40 - let's go with the web url so again this
328:43 - is a
328:44 - key inside the dictionary so we can
328:47 - access
328:48 - the value so this is actually the value
328:50 - we need and we can access that using
328:53 - the dictionary name projects
328:57 - and the key name which is web url and
329:00 - this is actually project
329:02 - not projects and this code will now
329:05 - print
329:05 - name and url for each project so let's
329:08 - actually execute our program
329:11 - and as you see we have project name and
329:14 - project url
329:16 - for each project we can make the output
329:20 - a little bit cleaner
329:21 - let's do a new line here
329:25 - and a new line here so we can separate
329:27 - the projects from each other and
329:30 - run again and there you go this looks a
329:33 - little bit cleaner
329:34 - for each project we have a name and a
329:37 - url
329:38 - so if i click inside i'll go directly to
329:41 - this
329:42 - project so that's basically a very
329:46 - simple example of how to use
329:49 - requests module to talk to external
329:52 - applications
329:53 - or external urls and then do something
329:56 - with the response that we get
329:58 - from that external application by first
330:00 - converting that into an actual data type
330:03 - that we're getting using json function
330:05 - so in our case it was a list
330:07 - and that's why json function actually
330:09 - converted it into
330:11 - a list if the response was a dictionary
330:14 - instead of at least
330:15 - then json would convert it into a
330:18 - dictionary
330:19 - and then we can do something with that
330:20 - response value
330:25 - congratulations you made it till the end
330:27 - i hope you learned a lot
330:29 - and got some valuable knowledge from
330:31 - this course if you like the course
330:33 - please leave a thumbs up on this video
330:36 - on my channel i actually cover
330:38 - lots of different devops topics like
330:40 - docker ci cd
330:41 - terraform and more so be sure to check
330:45 - out
330:45 - my tutorials if you're learning python
330:48 - to become a devops engineer
330:49 - i actually have a complete devops
330:52 - bootcamp
330:53 - with all the technologies you need to
330:55 - learn as a devops engineer
330:57 - which also includes a module for
331:00 - automation with python
331:02 - with several cool demo projects to
331:05 - automate some
331:06 - common devops tasks like application and
331:10 - server monitoring
331:11 - cloud automation tasks with aws
331:14 - jenkins etc so if you're interested
331:17 - check out more info in the description
331:20 - also happy to connect with you on social
331:22 - media
331:23 - so i would love to see you there with
331:25 - that said
331:26 - thank you for watching and see you in
331:28 - the next video

Cleaned transcript:

hello and welcome to this python course in this full course you'll learn everything you need to get started with python python is the most popular programming language out there and is used for so many different industries like web development data science machine learning or generally for writing automation programs to automate repetitive tasks so learning python is definitely a good idea let me give you a short overview of all the topics i'll cover in this course after giving a short introduction to python we will start with the basic building blocks of programming the most important data types like strings numbers lists sets dictionaries boolean data types etc and how to work with them learn about variables and functions and why we need them write a program that accepts user input and learn how to validate the user input using conditionals error handling with try accept and also learn loops with while and for loops and again why we actually need them you will learn all these concepts with handson examples as a next step you will learn how to modularize your program by writing your own modules and then see how to use some builtin python modules with all this knowledge we can then build our next demo project to write a small program that accepts a goal and a deadline as user input and then outputs the number of days remaining till the goal deadline within this exercise you will learn how to use the date time module to work with dates after that you will learn about packages and comparison of package versus module and we will use an external python package in our next demo project in which we will automate some tasks for working with a spreadsheet file finally we dive into objectoriented programming you will learn what classes and objects are in programming and python specifically and why this concept is so useful in the final demo project you will learn another common use case with python which is communicating with other applications over the internet by making a request to fetch some data from gitlab api in this specific case we will list the gitlab projects of a specific user so that's what we're gonna learn if you like this course don't forget to give this video a thumbs up i'm really excited to teach you all of these so let's get started first of all python is a programming language just like java or javascript python compared to other languages has two very big advantages first of all it's easy to learn it has a simple syntax and it's very easy to set up and get started with for example compared to java where you need some initial configuration before you can even start your application but it's equally or even more powerful than java now what makes a language powerful or how can i say that python is more powerful well that comes from the ecosystem which means libraries and modules that python developers themselves develop but also external developers create and maintain so the more people adopt the language the more powerful it gets because new libraries and so new functionalities get added to it and the second advantage is that it's flexible now what does a flexible mean in this case what makes a language flexible it is easy to mold to your wishes so you are not limited or restricted by the language specifics like syntax or data types or some other constraints or even library functionalities you can extend python widely and as one of the results of this flexibility python also became a multipurpose language meaning it is used for many different categories so let's see what these categories are first you can use it to write web applications the popular libraries for that are django or more lightweight flask python became extremely popular because of the rise of data science machine learning and artificial intelligence industries and more and more libraries were created and are still being added for python for all these categories they are very popular and highly used libraries for data analysis and data visualization libraries for artificial intelligence projects for things like face recognition voice recognition and a bunch of very powerful and widely used machine learning libraries python is also often used for data collection like scraping the web creating web crawlers that are basically programs that collect data from internet which you can save and then process later again many different powerful libraries to do all of that and finally automation with python python has many great libraries to automate devops tasks for example starting from ci cd pipelines to cloud platforms and monitoring your infrastructure etc you can also write python scripts to do automated backups cleanups on the servers etc in addition to devops tasks you can also automate just general tasks with python like when working with excel sheets which is a common use case in many big companies or automating some tasks on your own laptop and there are also libraries for mobile development gaming desktop applications but these are less likely use cases for python because there are better alternatives for that so you see that the use cases for python are pretty vast and it actually spans several industries and it's mostly concentrated around data analytics machine learning and automation areas and note that this isn't the case for many other programming languages usually one programming language is good for just few things and you should use something else for other use cases so now you see how useful python knowledge could be and how it can help you in your job but also make you more valuable at your work and for your entire team i hope you are already excited to learn python so let's get started as a first step we're going to configure our local python development environment so the first thing we need is install python locally on our laptop so first we install or download python package for your specific operating system and then basically just click through the installer wizard to install python locally on your laptop and note that if you're doing this on windows very important step in the installation process would be to check the ed python to path option basically that you see here because by default it is unchecked and you have to check mark it so that after the installation you'll be able to execute python commands in your terminal now an interesting note here if you're using mac os like i do is that by default on mac os there is python already installed so if i do python version and execute i see that python version 2.7 10 is installed and that is actually python that mac os the operating system itself is using however for our tutorial and generally when working with python we want to be using the newest version which is python 3. so we're going to leave that default python installation alone we're not going to use that or touched it and instead we're going to be using the python version 3 that we just installed locally so now if i clean this up and we want to execute python version 3 commands we're going to do python 3 instead and version and that will give us the version so that's how we can differentiate between the already installed python and the newest version that we just installed so just be aware of that difference now that we have python available locally it's time to download a code editor for python because we're going to be writing files with python code so we need a proper editor for writing python code and actually the best python code editor available out there currently is pycharm which is from jetbrains so that's what we're going to be using throughout our tutorial so let's go to pycharm it is an intelligent code editor which makes it much easier to write code so it makes you actually very productive when writing code and we will see why throughout the course as you can see there are two versions we have the community version and professional one community version is free and already has a lot of powerful features but the professional edition gives you additional very useful features especially if you're creating web applications or scientific projects in python so with professional version additionally you will get scientific tools that you can use in scientific projects with python but also you get support for python web frameworks and database integration which can be of course very helpful if you're developing web applications if you want to get the professional edition jetbrains actually provided me with a code for my channel to try it out for three months for free just use my code when you install it but for this demo community version is absolutely fine so i will go with this one and install it and just click download and once the pycharm installer is fully downloaded we can just click on it move it to the application and now i can actually use it locally so i'm just gonna open the application and we're gonna take a quick tour around pychar it's actually pretty simple to set it up and there you go we have our pycharm and we can now create a new project and let's call it my python project and that's it basically we don't need to change anything else and here you see the location basically of where this application folder will be created you see pycharm projects folder got created in my users directory so this is basically very convenient because all my pycharm projects or my python projects that i create using pycharm will be created in one location and here you also see that python version 3 that we installed is automatically being used for this project which is exactly what we want and you see it says base interpreter and python interpreter is basically a program that knows how to execute python code it will know how to interpret or translate our python code into instructions that computer can understand so with this configuration we don't have to change anything we're gonna create our project so first of all i'm going to make all this a little bit bigger so that you can see the menu here on the side and the code a little bit better so in preferences editor font we're going to set the size to 20. if i apply this right here you see that this code editor font basically got bigger and i also want to increase the size of this menu font here so in appearance i'm going to set it to maybe 18 and there you go so basically everything is bigger now so you can follow along and see exactly what i'm typing and also another note here if you want to configure your theme basically so if you don't want it to be dark or maybe you want some other color scheme then you can select it here in appearance you have four themes available let's actually try this one out and apply and there you go you have a different theme i actually prefer this one so let's leave it at that so as you see we have a very simple project with one main main.pi file the extension is for python files which basically contains very simple code and we're gonna basically just remove all of these and start from a clean python file state and in the next section we're gonna dive right in and write our first simple python application we're gonna start with the simplest example in python to basically learn python syntax and get started as simply as possible so first of all we're gonna write a very simple application that just prints some output and in python when we want to print basically display results of what we wrote we use this syntax where we say print and here we can pass in basically whatever we want to display and now if i want to see whether this super simple application works i can run it or execute it with this triangle here and i have the output so the basically the output is displayed or printed right here and i see the output is 1. i can display some other values like 200 and run it and there you go let's say we want to display some text basically whatever some sentence and again triangle and we have that output here right so again very simple example of writing python code that basically displays some information when we execute it one thing that i want to note here is you see that we write some code basically in this window right here so in our main.pi file and when we run it or execute it our code we see some display in this window so you may be wondering what is this window and why do we see some output right here the answer to that is that whenever you're working with tools like pycharm which basically have all the functionality that you need to write your code and then execute your code you basically have everything in one place so whatever we write we can execute or run right away now without such tool how would we write code and how would we execute that code and this will help you understand what's going on here and to show that i'm going to go back to my terminal and i'm going to create a new file and i'm going to call it test dot py we're going to write the same code basically in this file you can do it in a file editor i'm just doing it directly in the command line and save it so now we have the same identical file as here but not inside our code editor right not inside this pycharm tool and we have python 3 available locally so now how do i actually execute a python file outside this pie chart i can do that using python 3 test dot p y and if i do that i get the same output in the command line so basically what you see right here this whole thing is integrated so basically all in one place where you can write your code the editor right here where you can navigate your files in your project so basically this is just a folder on your laptop and you can navigate the files here and you have the execution environment at the same time so you have to go to terminal and execute python 3 whatever you have everything in one place and tools that provide you with this type of environment for different programming languages for python it happens to be pycharm these are called ides which stand for integrated development environment integrated because you have everything in one place so you don't need to use terminal but in addition to this integration you get more cool features which helps you in writing python code for example syntax highlighting highlighting errors or code suggestions autocomplete suggestions and we will see those cool features actually also throughout this course so basically just makes your life as a developer easier however it's good to understand that connection between executing your files on the terminal when you don't have such a tool versus executing and working on your application inside that tool awesome so let's get back to our code editor a file where we write our code and till now we have done something really simple like print a text basically and print a number right and this leads to the first concept in programming languages which are data types so in python just like in any other programming language you have data types for text and numbers the text data types are called strings so everything within the double quotes is basically a string but note that in python you can also use single quotes for strings so double quotes or single quotes they both work the same and there's actually no difference between them and for numbers we actually have different data types so for whole numbers like 2 20 but also 0 and negative numbers as well we have a data type called integer and that's also how it's called in most programming languages however you also have numbers for currency for example how much a product costs right so if you have an online shop you would have prices like this for example so these are basically numbers with precision this could also be for example when you're shipping something you could have a weight of a package that is also not a whole number but has a precision so this type of numbers in python and many other programming languages are represented as float data type so again you have integers and float data types and if we execute that you basically see all of that printed as we wrote them now obviously printing values like numbers and text like this doesn't make much sense unless we're getting some useful information from our simple program right here right so let's do something more useful with python now let's clean all this up and let's say we want to do some calculations very simple logic that basically calculates how many minutes there are in 20 days so we have 20 days which have 24 hours per day which have 60 minutes per hour so this line will give us basically calculation of minutes for 20 days and there you go that's our number now this makes a little bit more sense because now we have a program that actually does something for us so basically as you see you can do any math operations on numbers in python and again in many other programming languages you can do plus minus division whatever just like you know it from basic math however i want to note right here something that many people think about programming and maybe are misinformed about which is if you're doing web development or maybe devops automation with python and not something like data science or data analytics this is probably an example of the highest math knowledge that you need for programming in python because even though we're going to use some calculation examples because they're just good as examples to show you the basic concepts of python you do not really need any advanced or even intermediate knowledge of mathematics when programming because it's really not about meth however what you need is logical thinking and we're going to be doing some of that and see that as examples so just bear that in mind in case you are misinformed about that so back to our example we have this number that is displayed here as a result however maybe if we use this program we don't remember or we don't know what this number stands for if somebody else is using so we want to add some descriptive information about this number that says this is how many minutes there are in 20 days so basically we need a line that says 20 days are this many minutes and this should basically be exactly this calculation right here so how do we put this calculation basically right here in the middle so that we end up with this whole phrase displayed right here so how do we combine text and numbers basically or calculation of numbers and in programming languages again this is not specific to python we would do that using something called string concatenation and string concatenation is basically a fancy word for gluing together or combining multiple strings now how does the syntax for that look like we combine the strings using plus sign so apart from adding numbers obviously using plus plus is also used in programming for combining multiple strings so in our example we have three string values and we want to put them all together in one string or one sentence we have the first string 20 days r and then we have the second string minutes and in the middle the third string which will be the value of the calculation however if we just put a number here python interpreter tells us it's not a string it's a number so we need to turn it into a string other programming languages do that automatically in python we need to do that explicitly so we need to tell python take this number but not as a number but as a string and we do that using a syntax that looks exactly like that so basically we have a nonstring value but we're telling python we want it as a string because it needs to be printed out as a text basically so if i execute this line let's see what happened and there you go we have our output just like we wrote it here but you see that there are no spaces around so basically 50 is just really glued together without any space around and how do we put spaces around these 50 basically add a space here add a space here now why does that work because this whole thing for python is a string again because we are putting it within these quotes so basically any character that you see on your keyboard right now if you put it between those quotes is interpreted by python as a string including this space character right so if we execute it again we have spaces around 50 and our sentence our phrase looks fine and if you're thinking right now this is actually kind of annoying because first of all it looks ugly and also there's a high chance you're gonna forget it that is absolutely right so in python again specifically there is a way to do it in a more elegant way using a different syntax and the more elegant syntax for that let's actually close this is print and let's write that again and instead of having these plus we have curly braces and we write our number inside or whatever nontextual value and at the beginning right here basically before we start writing a string which starts with quotes we just write the letter f and you see the syntax highlighting as well basically sees that this is not part of the text this is nontext value and if i execute it i should see the same output from the second line and this is really a way cooler way to write this instead of using plus but this is something very common and also something that you would encounter in most programming languages so just important to know that this is a syntax for string concatenation as well so we can basically just remove it and use this syntax for our examples and also note that this syntax is actually a new addition to python so it only works if you have a latest python version in our project if you remember we actually configured and chose version 3.9 and that's why it works for us if you use python 2 for example python version 2 this syntax is not going to work for you we can actually demonstrate it so i'm going to copy that line and i'm going to change our test.pi and now if i execute it using my python 3 you see it works fine if i do it with python which is version two point something let's see what happens there you go syntax error invalid syntax because python version 2.7.10 so older version basically doesn't recognize this syntax so just be aware of that so this syntax actually only works for python versions starting from 3.6 so everything below that every python version basically will not recognize this syntax as we see right here so again back to our code and now we just have a number here but what we actually want is the calculation for getting the correct result right so we want again 20 days in hours and then in minutes and if i execute it you see that the calculation was done and here we have the full complete sentence with the result in it and if you're curious this f actually stands for format so this is basically formatting our text or our string in a correct way awesome so we have this line of code here that basically calculates for us how many minutes there are in 20 days let's say we want to do the same for 35 days right what we can do is basically copy that line and replace the values for 20 with 35 and if i execute it i get the same calculation but for 35 days and we can do that basically multiple times for different values so let's say we want it for 50 days and we want the same calculation for i don't know let's say 110 days doesn't really matter and we have obviously different number of minutes for each of these values and now let's say we wrote this program it's ready and we're using it and at some point we decide you know what i want this program to actually calculate how many seconds there are for these provided days instead of minutes so what we would need to do in that case is basically change the calculation in all those four lines so instead of minutes it should actually calculate number of seconds in a day right so we have the hours minutes and seconds and we would have to change the text as well here and we would need to do that for each one of those lines right so we would have it here like this and again if we need to modify this for hours or milliseconds or whatever we basically have to do these changes multiple times right even though if you actually look at that this is the same exact calculation for each line that doesn't change right if you want seconds then this is the calculation that you need to do so how can we actually avoid repeating the same calculation and the same text in our code and the answer to that is variables so in programming languages we have variables that basically hold values that will repeat throughout your code that you can set once and use it in multiple different places so instead of basically repeating this calculation four times we basically do this calculation once like this and we basically save this value in a variable so that we can use it whenever we need right and the way that variables are defined in python is variable name let's call it two seconds equals and whatever that value is that repeats itself and that we want to save into a variable now i want to make two notes here regarding the variables in python first of all in python defining or creating a variable and giving it a value like this syntax for that is actually very simple compared to other languages because you just have the variable name and the value in many programming languages you actually have to define here some kind of data type for that variable for example if it's a number like float or integer or string etc in python you don't have to define that you just have name of the variable simple as that the second one is the naming convention or standard for the variables so we have two words for example if we name our variable calculation to seconds right we have actually three words here so variables that are descriptive so basically they tell you what this value actually is about so they have multiple words in them you can separate them using these underlines again in different languages the naming for variables can be different in python this is actually one of the standard ways of defining variable with underscores which i find pretty nice and easy to read so we're gonna use this syntax basically throughout the course it will be totally and absolutely okay if we wrote it like this or if we used capital letters instead but again this is probably the most readable form and this is what we're going to use now here note that we can decide whatever name we want to give our variable but in python there are some specific words that have special meaning to python these are called reserved words so you can't use these words as variable names and we will use some of these reserved words throughout the course so you will see some examples great so we have our variable defined here and this is the value that this variable gives us so how do we replace now these repeating values with this variable so we're going to delete that and again inside we're simply going to copy the name of the variable so let's execute and as you see we have our value printed just fine and we're going to do the same for all those values and again execute everything works just like before now you may be thinking if we change this to minutes we would have to change the variable in all these places so that's our case we can basically just rename our variable something more generic so let's say calculation to units and this could be now any unit that we want second meaning it doesn't matter and this is exactly the advantage of variable because you can name it whatever you want which basically just describes what this variable is about and now you won't have to change that again and we can also replace this one here accordingly since it's a text we can call it a name of unit we can also call it unit doesn't really matter we're the ones deciding what that variable name is and once we have that variable we can now replace it here how do we do this because this is actually part of a text a string the same way we did right here we're gonna delete that and create an expression create a syntax that basically tells python hey this is not a string this is a nonstring value and you already know this could be either number or variable itself and so we're going to use the curly braces and the name of the variable and just like that we have substituted these values here and if i execute it works perfectly fine and we can do that in all four lines and our code is still working and this syntax right here with this format at the beginning basically prevents us or avoids basically saves us from having a bunch of plus signs here and then space characters etc this all looks way elegant now and now if at some point we actually decide you know what i want this program to calculate how many hours there are in the given days instead of seconds and we want to change the program to do that we could basically just change the calculation here and instead of seconds we have hours and if i execute there you go we see the changes right away so this is why when you're programming doesn't matter in which language including python using variables will be probably some of the most frequent thing that you do because you always have values that are repeating themselves and you want to write clean code so you create variables and one of the best practices when creating and using variables is as we're using actually here is to name your variables so that you later and also other programmers who are working with you understand what this variable actually does or what type of value it actually has because if you just look at 24 you would probably not know what this 24 is about right but with variable you actually know that this actually represents a number that is used for calculating units right it could also be more descriptive like units for days but generally another advantage of variable is to basically describe that value as well that you're using in your code now another thing you probably also noticed is that even though we're using variables here so that we don't have to change those values in four different places a lot of these four lines are actually pretty similar the only difference in those four lines are actually these numbers right here everything else is exactly the same so what if instead we wanted to make this code cleaner and basically avoid this type of duplication in our code right so for example if we did this for 10 different values we would have the same line this long line basically 10 times right so how do we avoid this type of duplication so right here we actually avoided duplication for specific values right piece of string here a whole calculation here but how do we actually avoid duplicating a whole line right the whole piece of code basically which has multiple different stuff in it not just a value and we do that using functions so functions are basically blocks of code like this right or basically logic in code that does something it's not just simply a value but actually does something more complex that is again used in order to avoid repeating the same logic or most of the same logic in your code so how do we create functions just like we created variables here we create functions and the way we do that is using following syntax right here let's create our first function we start with def so we define a function just like we define a variable but for function we need this keyword basically called def and now we can give our function a name just like we gave name to our variable we can give our function a name and here we can use the same standards like for variable we can name the function something descriptive something that actually says what this function does and let's call our function days to units and then we have the brackets and a column so this line basically defines a function it tells python hey whatever comes after this is actually going to be a block of code that is going to be referred to or is going to be named these two units and how do you write a function i'm just going to copy this one actually here and let's give us some space and again this is very specific to python we need to indent here with spaces and i'm going to paste in what i copied inside these two lines basically tell python this piece of code or this line of code because we just have one line here belongs to a function called these two units and again we just have one line but this could be function with hundreds of lines right so i can write whatever i want the next line all good and then i can do some calculations and i can basically write whatever logic i want here and all these will belong to this function so now this logic is inside a function that is called these two units and we can actually get rid of this and test our function and here if you noticed we have this yellow line under the function name that's actually a warning for our code style it says we need two blank lines before so pycharm has a builtin official style guide for python that tells you how to style your code or how to write your code correctly now why is code style important well just like you write code you need to read code from other developers or your own code to understand what the code is actually doing so it's important that code is easily readable and this is just another example of how an editor like pycharm helps you to write code so to fix the warning we're just going to add a new blank line before the function definition so now what happens if i execute this block of code i have the variables defined here that i'm using in the function and then we have these two print statements so what happens if i execute now and as you see in the output here there is no output right nothing actually got printed so what actually happened because we have those two print statements that we defined in the function but we don't see anything in the output and the way it works is whenever you create a function or define a function like this you actually have to use that function right again this is a similar concept to variables we have created variables here and we're using that variable in our code the same way we create a function and we need to use that function how do we use a function or in programming languages it's called calling a function or executing a function and we do that using the name of the function like this and as you see in the suggestion as well using brackets like this so this syntax here basically is what we call calling the function that we defined right here or using that function so now if we execute it there you go you see that those two lines got executed and we have the results here so we're creating variables and we're using that here we're creating a function and we're using that function here and note the difference between using a variable and using a function python knows this is a function because we are providing these brackets at the end right that tells us we're making a function call basically but as you see now we have these 20 days so this only works for 20 days right what about other values that we had what about 35 days and 100 days we haven't deduplicated that right we have just one case here so how do we use functions so that everything else except for these two values right here actually stay the same and we do that in programming by giving our functions some kind of input value which are also called parameters so instead of having this 20 basically here hard coded as we said here and here we provide that value of 20 or 35 or whatever that value is basically whenever we use the function so we are telling python use these days to units function with a value of 20 or use that function with a value of 35 and way we define this input parameter in functions is very simply by defining this parameter between those brackets right so this is where the input we as programmers define the input parameters so right here how do we define that using our already familiar variables so basically right here i'm going to define a variable and i'm going to call it whatever i want i'm going to call it days or number of days but i'm not assigning a value to that variable right like i did here because i want it to be assigned whenever i use the function so this basically tells python that a function these two units can be used using one input parameter which is called num of dates right number of days so now the last part which is remaining is replacing these values using this variable right and just like we do it in these two places where we're also using variables defined here exactly the same way we're gonna remove this and define a block for nontextual value and we're gonna put our variable num updates here and also here so you see now that our function actually doesn't have any fixed numbers in it instead we're using variables we're using two variables that are defined outside that function and we're using one variable that is defined within that function right this variable actually belongs to that function and now as you see whenever we want to use that function we're telling python hey call this function called days to units with a parameter an input basically of 35. so now if we execute it by the way we can also do it here you see 35 days are and the calculation was done here and hours and now if we go back to our previous example where we wanted to calculate these for four different values right for different number of days we can actually do the same so we had 20 then we had 50 and we had 110 right so this basically gives us exactly the same logic that we had previously but with different syntax right so you see the difference that instead of having this basically four times we have much cleaner syntax where we actually see what this logic is doing which is days to units and then we have the number of days that we pass or give our function as parameter and if i execute this you see that it was printed four times for all different values we can actually remove this line and now if we make some change in our function for example we change the name of this variable we want it to be hours instead of units we just do it once in one place and that's basically it so whatever changes we make inside that function and that is actually the big advantage of using functions in code whatever change we make inside here it doesn't affect how we use the function because for using the function we only need the name of that function and the input parameter now probably you're wondering what happens if i do not give my function a value let's delete those lines and let's say we do not provide any value here and we try to execute or call our function without the parameter and let's execute and you see that python interpreter is complaining because we have told python here is a function called these two units and whenever i want to use that or my colleague another programmer wants to use that function they have to provide an input value here right so now whenever python sees the usage of that function and there is no input parameter that we are giving that function it cannot execute that function right because basically this value is missing here right and that's why we get an error which also says missing one required argument so as you see whenever we define a function with a parameter with input parameter we have to also provide that input parameter another thing that you may be also wondering is what if i want to provide multiple input parameters to functions how do i do that it's actually very simple you can do that by simply defining here another input parameter separated by comma and let's say we want to pass here something that we want to print out additionally like a custom message doesn't really matter and the same way exactly the same way as the first one we can actually use it in here we can even create a new line and basically just print out that message right and note that if you are using a variable without stream so basically it's just the variable itself we're not using any text in that case you don't need this format right so you can basically just print it out directly and now again we have told python i have this function and two input parameters are required so i also need to pass to input values whenever i use that function so now let me just pass in some custom message let's say i'm happy about the calculation or i know i'm going to be happy so let's say awesome and let's do another calculation and this time i say looks good and if i execute it you see that i get awesome the first time and then for 35 i get looks good so you can basically define and provide as many input parameters as you want common practice and also what you will see in just normal code basically is just a handful of input parameters maybe one or two so it's not actually overloaded with 10 parameters cool now that we know functions and variables why they're used or why are they useful and how we use them there is one point that i want to mention which is variable scopes in functions what does it mean as i mentioned previously in this function we're using multiple variables right we're using two variables that are part of the input right that we provide when using a function and we're using two variables that are defined outside the function right somewhere else in the code so variable scope basically means where is the variable that function uses defined and variable has a global scope for a function if it is defined outside the function like these two variables right here could be completely in a different file not even in the same file where the function is so these are global variables so all the functions that you have in your python code can use those global variables and then you have local variables local variables are variables that are created within that function right so these two variables are basically only available inside that function because it was created within that function so internal scope and global scope so that means that when we create another function let's call it scope check because that's what we're going to do we want to test the scope in this function i can access the global variables like name of units but i cannot access the internal variables like number of days and let's actually test that so i have num of units which is a global variable defined here outside the function and the second one i have a variable that is defined inside another function right so as i said internal and as you see right here we already get a red line underneath that says unresolved reference num of days so for this function basically that variable is not visible it's not accessible it doesn't exist basically at all and we can even test it out actually so again if we want to see the results we have to actually use that function like this run the function and if i execute it you see that we get an error that says name num of days is not defined right it doesn't know that there is a function like that anywhere in code however it does recognize the global variable and that means that variables defined outside function itself global variables are accessible to all the functions and if you have variables defined inside the function then they're only accessible for that specific function and not for other ones and that means actually that if num of days variable does not exist for scope check variable we can actually create a variable inside scope check with the same name and we would have basically no problem at all so this is not going to be a duplicate because this function doesn't know about this variable the number of days here and scope check doesn't know anything about variable num of days right here and if we want to use that function now we have to put provide the value let's do 20 and if i execute there you go you have name of units and the 20 that we provided so global variable local variable defined here another interesting thing is that as i said inside the function body so to say so this is basically whatever is part of the function right in this indentation is called function body so we can create whatever logic we want inside that function body so whatever i can do in python generally i can do inside the function body so one of those things is actually creating variables right just like we created variables here we can create variables here like this let's call it myvariable and variable inside function and we can print that out as well so now we have three types of variables that we are using in this function we have a global variable we have internal variable that is passed in as a parameter and we have internal variable again that is basically defined so the variable isn't provided when we use the function but it's basically just defined inside the variable and again if i execute this see hours num updates and variable inside function text printed out like this and obviously this is just for demonstration but we're going to see more realistic examples of that in our projects so i'm going to clean this up and we can move on to the next concept so now let's go back to the example where we calculate number of hours and we do that for four different values now if you want this application to be really useful for us or somebody else it doesn't help that we have to fixate here just four different values right the application should be able to take any value that we basically fit it right so we should be able to provide any number of days and the program should calculate the number of hours in those days so what we need here is user input so when we give this application program to somebody else or use it ourselves it should allow some user input so how do we write a program that asks for and accepts a user input and then does something some kind of calculation some kind of other logic based on that user input accepting a user input from a python application is actually pretty easy let's get rid of all of these lines first and we can do that by writing input and this will basically give a user a prompt to enter some input value now you probably already see from the syntax that this looks very much like using our days to units function right in this case with the parameter so input is actually a function that python provides us with so we didn't have to write this input function right we wrote the days to units function but input function is available in python so that we can use it whenever we want and this parenthesis here tells python we want to call an input function and we're calling it or using a function without a parameter so now we know that we can write functions ourselves for logic that we need but python has tons of functions that python developers already wrote and is part of python and we can use it in our code so that not everybody has to write their own input function logic and the code or the functions that python provides are again part of this python that we use in a project and obviously if you're using the latest version of python you will get the latest code and latest functions that python basically provides so back to our function execution and let's see what happens when we execute this program i'm going to run it and in the outputs you actually do not see anything other than my cursor is blinking here so it's actually waiting for user input so i can actually type in something here so i can do 20 and enter and process finished with exit code so i was able to input something doesn't really matter it could also be a string actually doesn't really matter and program basically finishes so that's the simplest usage of input however as you noticed here running this program and basically having this blank output here is a little bit confusing so if another user is using our program they will probably be wondering what's happening here so what we can do is in input function we can provide a parameter that actually tells a user something right like enter a value for number of days or something similar so that it's not just a blank prompt right so we can do that by passing in a parameter a string which is going to be our message so we can do a user enter a number of days and i will convert it to hours and here you see right now that the program wasn't finished because we didn't enter anything so this program finished line wasn't output yet and that means the program is still running it is still waiting for our input and in pycharm in this ide if you want to terminate the program manually yourself you can click this stop button and as you see process finished so now we can run the program again and as you see here we already have a message that we're displaying to the user so that they can enter the hours right and here we can provide our input 30 and there you go however this doesn't look nice here we actually want the user to get a prompt on the next line how do we do that as part of a string we can actually add a new line or newline character basically and that in programming is actually represented by backslash n and you see a special highlighting for that one now let's execute and you see that my cursor is on the next line now and again let's provide a value enter and program ended so we have now a more userfriendly way of asking program user for their input instead of just showing an empty prompt and we're getting user input now we're not doing anything with that user input right that input basically just finishes the program and that's it we're not doing any calculation for that input so how do we use the value that user enters here when input function gets executed we do that and this is a very important concept by assigning whatever result this function usage gives us which is in this case user input assigning that result to a variable so right now it's basically executed and it's just wasted right it just disappears so instead we want to save that value that entered input value in a variable so that we can access it later and we do that by let's call it user input variable equals so just like we created variables here with variable name and a value right or even an expression right if we did a calculation here that will be basically a whole expression whole calculation the same way we can use values that function execution gives us to assign it to a variable so now what i'm going to do is i'm just going to print the user input so that we can see what value that user input variable has so let's execute again it asks for our input let's put 20 and print user input gives us 20. so user input variable value basically becomes whatever we provide as an input now that's a new concept and it could be a little bit confusing so let's see another example with our own function what would happen if we assigned value of this to a variable we get a warning as you see here in the editor which is one of the great things about ides that it basically gives you warnings when something is not correct and the warning says function doesn't return anything so basically if we want to have some value as a result of function execution we have to return some value in the function and how we do that instead of printing the value right away we can actually return that value using return keyword again you see special highlighting here just like here because return is a special word that python understands that you want to basically give back a value this value right here as a result of using the function right so you could have some logic here doing the calculation whatever and then as the last line you can return that calculated value and now the warning is gone because we're actually returning something from the function and when we return value from a function again we can assign it to a variable so that we can use that value whatever function returned by referencing the variable and one of the usages will be basically just to print it just like we did before like this let's delete it temporarily and test our program and there you go you see that this function got executed with input 20 this text this display text basically was put together in the function and was returned or was given back as a result and we saved that this whole string basically this whole sentence in a variable called myvar and when we print that myvar we see that value printed out here and again if we enter some other value we would get different text and again that is actually a very important concept of giving back some results from a function execution and you saw in our examples that you can have a function that doesn't return a value just print something on maybe does something else or function that returns some value you can have both types so back to our example of user input so now hopefully it makes sense that input function returns whatever value the user entered as a result and we can save it in a variable and then access it later again let's get rid of this line and now let's actually do the calculation on the user input number of days how do we calculate number of days very simple by calling our function that actually does that so we're going to call our function to calculate the number of hours for an input and the parameter that we passed in is going to be whatever the user provided so instead of basically hard coding a value here ourselves we give it a value that user provided instead so the num of days will be the user input and now again because this function returns the whole string it doesn't print it remember it just returns it so when i execute this and i provide in some value that's to 200 you see that i don't have any output here because we didn't print anything we basically just returned the value here we didn't do anything with it so the last piece missing here is to display the text the string that function returns so we save that return value first let's do calculated value so we save this thing in calculated value variable and finally we can print it and now let's execute it and let's see what happens i'm going to type in 10 10 days and let's see what we get now and you see we have this weird value here as a result of the calculation so what exactly happened so this part of calculation basically which represents this number didn't do a proper calculation and the reason for that is because the input value that we get with inputs function is always treated as a string and not a number so basically at this place here number of days inputs 10 here is actually treated as a text and not a number and where this weird result comes from is basically number 10 printed out 24 times so instead of doing the actual calculation 10 times 24 10 is printed 24 times and that's what happens when this is interpreted as a string so how do we make python see that number see that input value as a number as an integer and not a text or not as a string and it's actually pretty easy to do on the next line the user inputs again we saw right here it is a string so we have to make it into a number and we're going to do that using int and user input and that process of turning a value from one data type into another is called casting if you remember we already saw an example of it when we turned a number into a string in the string concatenation example again from the syntax you should already know that this is a function call so we're calling a function called int again that python itself provides us with because we didn't write that function and we're passing in one parameter which is a string and we should get an integer from that string as a result and we can save that number into a variable and let's call it user input number and now we have 10 as a number instead of as a string and instead of passing in that string user input we can now give our function number that it expects let's save it and execute let's put in 10 and there you go now the calculation is correct what i want to show you now is how this user input actually works without a code editor like pycharm so i'm gonna copy all this code and let's go back to our terminal and in our test dot pi i'm going to paste in our code and save and let's now actually see how the user input works when we execute it in a simple terminal window and as you see here we have the message first and the prompt is right here so we can enter a value let's do 25 enter and we have a result 25 days are 600 hours great so our program is working it is converting the number of days to number of hours and accepts a user input now what happens if a user enters an invalid value here so for example instead of a positive value for number of days maybe they enter a negative value like 10 for example and obviously that input value doesn't make any sense but we are still calculating and giving a value right and this is another important concept in programming generally that when we allow users to give our program some input value we also want to restrict them and basically validate that what they provided as input is a valid value for our program specifically one that it makes sense like in our case 10 program still does a calculation but it doesn't really make sense and second it doesn't crash our program right so now let's see what happens if we enter some text here you see that the calculation didn't happen because we basically crashed the program application using that invalid user input does make sense or an input that crashes our application because the calculation isn't even possible and we want to avoid users basically either providing a nonsense value or a value that will crash our application so we need to validate user input and this is again important concept in program because whenever you allow user input you always have to validate it so in this part we're going to learn concept called conditionals and we're going to learn this concept with an example of validating a user input so where are we going to do the user input validation we can do it in our function right before we actually do the calculation we can first validate is it a positive number and not a negative one so user gives us their input we convert it to a number and then we pass that number to our function so negative 10 positive 10 that is a number basically will be passed on to our function and right here we can check whether this variable value here is a negative number or not how do we do that we do that using if else conditional statements so very simple and intuitive to understand we say if number of days is greater than 0 means it is a positive number then we want to do the calculation and return all of this but you see that we have a red line here so basically whenever we use if condition we have to have a proper indentation so all of this line basically goes indented for this line kind of the same way as we indented the whole function body inside the function whatever logic and whatever code is right here indented below the if condition will be executed if number of days is really greater than zero so let's try that again i'm going to execute it let's put a positive 10 you see 10 days are 240 hours got calculated now let's put 10 as an input and you see none basically no output for us because this line didn't actually get executed for 10 input value now what if we want to tell a user hey this was an invalid value and that's why we didn't do the calculation instead of just showing none we can do that by returning this feedback message or error message whenever this is not true so whenever number of days is not greater than zero we want to return something else right another message and we can do that using else and the same way as for if we have the indentation and whatever we write here will be executed if number of days is not greater than zero so here we are gonna return you entered a negative value so no conversion for you and here it's time for another special term in programming that greater than sign is called a comparison operator and we have three of them we have greater than less than and equals and these are called comparison operators because they are used in an operation to compare two values and before in this course we learned arithmetic operations like plus minus divide multiply so again fancy words for simple concepts but these are the official terms for these so now if someone mentions them you will know what they're talking about so now let's execute the application and let's provide 10 and you see that this line was printed as a feedback to the user so let's go through the flow again user gives us their input in this case 10 we convert it to integer so now it's 10 integer and we pass it on to our days to units function and these two units function basically has this if else statement that's how it's called in programming and our if else statement validates or checks whether this input is greater than zero if it is then the function will return this as a result so basically the calculation with a proper message else so basically if this is not the case then it will return basically just a feedback message for the user and note that else doesn't have such a check here we don't check num of days is less than zero and the reason for that is because it doesn't check for less than zero because it basically just decides if this is not true else or in that case just do this so we don't need additional check here now this segment right here where we're doing the check is called a conditional so basically we're providing our program a condition if this condition is correct then do something otherwise do something else and that conditional can be true or false if we enter 10 then this conditional will be true because it's greater than 0 if we enter 10 then this conditional will be negative it's not greater than 0 and those true and false values in programming actually are represented by its own data type which is called boolean and in order to show it to you that this conditional either gives true or false what i'm going to do is i'm going to print this conditional right before i do the check so for a positive number input this should print true and if it's negative so it's not greater than 0 this should print false so let's test it out first i'm going to provide positive 10 and right here you see true because this condition is indeed true and note that this is not a string that's why we don't need the quotes here so we can basically just put in the whole expression in a print function and now let's do the same with negative 10 and you see false and as i said true and false values belong to its own data type in programming which is called a boolean and again we can demonstrate that instead of printing it out we can save it into a variable let's call it conditional check and in python there is a function called type which checks or prints out basically a type data type of a variable or a single value so if we pass it so this will give us data type of conditional check and obviously if you want to see that result we need to print it so print the whole thing so it doesn't matter what we pass in this point and right here you see class boolean so this conditional check here which has a value of true or false is of type boolean now there are two things that i want to note here the first one is that you see that i am calling a function here which is type and then whatever that function type returns which is basically this output here we are printing it so we have two function calls that are basically nested and that is absolutely fine you can nest function calls another example of doing this nested function called would be for example right here instead of assigning these to a variable and then passing it here we can actually save us that step and in the days to units function call pass it as a value so this is a perfectly valid syntax and you can do that you can nest in the function calls and you would not need this additional step and you can do that as many times as you want it just looks cleaner when you have that syntax a little bit separated and not have two three four function calls nested so that's one thing and another thing is we just saw a class boolean type here and let's actually see the same output for string and number so just for the demonstration let's actually see the type of string and integer let's get rid of this for a second because we just want to test so we're going to print the type of a string which says this should be a string type and execute and you see class string and now let's provide an integer you see class int and let's provide a float and there you go we have float so this is a very handy way of checking the type and we're going to need that actually in a later example so back to our application and one note about booleans and conditionals is that you're going to be using a lot of those in programming because they're really the major or the core part of writing any kind of logic in programming so you're going to need if else conditions and statements and booleans in your application so it is a very core concept and we're going to be using a lot of them in our coming examples so let's get rid of this code right here and one note before we move on here is that the negative numbers are not being calculated because of this condition now what about zero let's actually try that out so i'm gonna enter zero which is actually also valued that doesn't make sense because zero days input obviously will give zero of any units so enter and right here you see a feedback to user that says you entered a negative value so no conversion for you and the reason for that is because this condition here number of days checks greater than zero which means that negative numbers and zero will not match this condition so they will basically give you this feedback but our message says you entered a negative value right when we entered zero what if we wanted to have a specific message for a user if they enter zero and a specific one if they enter negative value right we want to differentiate between those two how can we do that in the if else statement in programming we can have multiple conditionals so basically we can have multiple ifs so how do we do that first we check number of days is greater than zero okay great now we want to check whether number of days is equal to zero and we can do that using another if here and in python the syntax for that is el if which basically is a combination of else and if so if this is not true then we want to check another condition number of days equals 0. now you know the equation sign generally is this one right here however when we're checking whether something equals to something else in programming that equation check is represented with two equal signs and the reason is because one equal sign is already used to represent assigning a value to a variable so not to confuse those two actions in programming we have two equation signs when we want to check whether something equals a certain value and just like here we execute some logic whenever this condition is true so in our case we want to tell the user you entered a zero please enter a valid positive number so now again to go through this logic flow if the input value is a positive number then function will return the calculation and the message if it's not a positive number then we will check additionally whether it's zero if it's not zero then this is a last condition basically then we know that it has to be a negative number right so let's test this out let's enter a positive number there you go let's enter zero you entered zero please enter a valley positive number and let's enter negative one and everything works perfectly note that you can have multiple alif's between if and else statements and again note that el if has a condition just like if statement else does not have any condition so this is like the fallback so if everything previously stated all the previous conditions did not match so they were all false basically then this is the logic that will get executed in that case great so we have validated input value for users and we may feel pretty good about our program because it doesn't calculate anything for values that don't make any sense however we still have a problem what happens if a user enters a text instead of a number so basically anything that is not a number value doesn't really matter basically some text if i enter you see that our program actually crashed and this is actually a user input that we want to protect our programs from because we don't want to allow users to blow up our application right so let's see what happened it actually says that we provided an invalid literal literal basically means the text itself or a number so basically a value that we entered for int function that's the problem so this function call basically just blew up because in function expects a value which is a string representation of a number so basically ind expects something like this or something like this it doesn't expect my text or some text so our application crashed on some text input now let's see what happens if i provide a number but a float number instead of integer let's enter 19.99 and enter and you see the same error this function basically returns an error because it cannot convert float into integer as well so we have a problem here that whenever user enters anything which is not an integer our program will blow up so how do we avoid that so basically before the int function gets executed with an invalid value we need to validate this whole thing and stop our program before that happens so we need the validation before int gets executed and we can do that right here right so before that line gets executed we're gonna do a validation and one way we can do that is using our familiar if else statement so we can say if user input is digit so again from the syntax you know this is calling a function but note that instead of calling the function like this so basically just stand alone we have the syntax where we have the variable dot and then the function name so instead of passing this as a parameter right here in the function brackets we are passing it as a parameter again but using this syntax right so each digit function will execute for user input as a parameter and again in if we have conditions so this will be either true or false it's a boolean and if user input is digit it's a number basically so basically this will filter out input values that are text so basically they're not numbers and if the input is digit then we want to execute this line and also the rest of our application like this and if it's not true so if the user input is not a digit we don't want to execute anything in our application we want to stop the execution and want to tell the user this was an invalid input value i'm not doing anything with my program so that it doesn't crash so else if not digit we are telling the user your input is not a number don't ruin my program so now let's actually test it so i'm going to execute and write some text and there you go so user input is digit was evaluated to false so none of these got executed instead the else block was executed and it printed a message for our user so we basically avoided our application to crash with this check and if we try a proper number it works and if we enter 0 for example the application will get executed and we will get our message from here so our application is more or less protected and we're not allowing for a invalid input number you say not a valid number now we know that in programming there are different types of numbers we have float numbers as well so let's actually see what ease digit function really checks so let's actually try to provide a float number instead of integer which is not a proper valid input for our program so i'm going to type in 19.99 and you see that each digit is false for a float number so we got the same your input is not a valid number output for float number as well which is perfect it's exactly what we need and now let's actually try to enter a negative number and let's see if each digit function returns true or false i'm going to enter and you see that else block got executed because is digit was false for a negative number so basically this function filters out a lot of the bad input for us to protect our application from bad user input and that also means that we don't need a check for negative values anymore and by the way in python you can actually have if statement without an else at the end this will work perfectly fine and this could be our application however note that in programming we don't put this type of logic directly like this basically outside a function as a common and best practice we encapsulate most of the logic basically in functions so as a cleanup for our code we can take all this and put it into a function so right here i'm going to create a function and let's call it validate and execute or something like this and all the logic that i copied will be just simply pasted in that function like this so now we have the logic nicely encapsulated in its own function but as you know when we create a function we have to call that function otherwise nothing happens so we're gonna call it right here we don't have parameters and we don't have to provide a user input because user input is a global variable so our function has access to it let's actually test it out and it works and let's provide some bad input and it works too so that's actually a proper way of writing code having every piece of logic in its own function with a proper description for the function now as a next step i want to show you also a concept or something that you will encounter very often in code which is nested if else statements and i'm going to show that example by cleaning up our program a little bit so as you see here we're doing validation in two different places so we're validating user input here but also inside these two units function itself so what we can do is we can put all the validation in one place in this validate and execute function and basically have all the validate logic in here and let the days to units function just do the calculation and not the validation and this way our functions and code will be a little bit cleaner and more logically built so after we validate that user input is digit we convert it into an integer so right here we have an integer value of the user input so we can actually check whether that integer value is greater than zero or equal to zero and we can do that right here without passing it on to the days to units function and just like this if conditional we're gonna do user input number greater than zero if that's the case we want the calculation to happen so both of these lines will get executed only if user input number is greater than zero and else in our case if it's exactly zero we want to print a message to user you entered zero and remember we've got the negative numbers already covered using this condition here so that's the one remaining i'm just going to copy that and paste it right here variable is called user input number so we'll fix that and we're going to print out that message so that means we don't need any validation right here we can simply do the calculation so to go through this logical flow of if else or nested efiles statements we have the first if right here also note that indentations for these if else so basically they are on the same line here same position and the nested if else or in our case alif they're also in the same position so again first that's the big validation the first one is is the user input digit in the first place if not we basically shut down the program we print out a message to the user and that's it if it is a digit then we need additional validation is that digit a positive number or is it a zero so we do that additional validation using a nested ifall statement and basically this line gets executed only if it is a valid number and if it's a positive number and because of that we don't need any additional validation once the these two units function gets cold and you probably already think and notice that nested if else statements are not the most beautiful thing in the world they are pretty ugly actually and especially we have multiple of them or multiple else ifs in between the function may actually end up looking pretty bad so it's not recommended to have multiple levels of these nested if else statements in your code to basically just keep it clean but as i said you will encounter it a lot in programs in application code because sometimes you just have to write it like this thing i want to show you here is something called a try accept in python so right here as you see we're validating user input right and then we're executing this part of code only if that condition is true what if we had logic here where there were multiple places where something could go wrong let's say a function execution could basically just blow up because of a wrong input or even as an example maybe this is digit doesn't actually cover all the use cases so maybe there is a value that user can input that will still blow up our program so instead of checking each such possible scenario using if statements and then doing the actual calculation once all those things have been validated what we can do instead is basically tell python something like try executing this part of code here and if something goes wrong so if any line any function call or any logic execution fails we want to catch that error and we want to control what happens with that error ourselves programmatically and then catch logic will be accept and we're going to specify what type of value we want to catch basically using this block and the name of that error type is actually what we saw in the output when we provided some text and a float which is value error so that's the error that we want to catch basically so again we tell python you know what try to execute this block of code here and if one of those lines in that code results into a value error then instead of just crashing the program basically catch that error and print out a friendly message to a user so let's actually try this out and note that try doesn't have any validation like if statement so when i entered some text here int function will actually be called with some text and it will result in a value error and this block will then handle that error so i'm going to enter and and you see that your input is not a valid number message got printed and the same will work for a float number that also doesn't convert to integer and for a proper integer value it will work fine and again difference between if else statement and using try except is that you can cover multiple such errors with this whole try except block right so you don't have to do the validation specifically and that is especially useful for cases where you can't really validate something using if condition right if there is a chance that you might miss something in that condition check so basically you just say you know what just try to execute with whatever value and if error happens then i still got it covered and an obvious difference between this if else is that here nothing actually crashes the program the program will still work is just a nonsense value with zero days right and as you see here we have specified an error type but with try except what can also do is you can basically say you know what i want to cover any type of air i don't care if it's value air or some other type of air let me handle any type of air in this case you can basically just leave it without a specific type you get a warning though that it's too general however this would work and you will be covering all the air cases with it but we can go back to our value error and know that in many programming languages this is actually called a try catch so accept is actually pretty specific for python i personally think try catch makes more sense because you are catching any error that may happen right here and then basically handling it in the catch block so if you happen to hear or see try catch in other programming languages note that this is the same thing as try except in python one thing that we're missing because we converted that if statement into try except is now we need to validate the negative numbers again because negative numbers will not cause an error in our application so they're not covered by this except block here so let's add back our previous else block and again if neither of these are true it means automatically would mean that it is a negative number so let's print that message for a user enter negative number no conversion for you so now we got all the cases covered again so let's try that out 10 and there you go now there is one minor problem with our application and that is we can only use it once so basically whenever we type in a value it either calculates it or gives us a message that we provided an invalid value then the program basically exits so if we want to do a calculation for another value then we have to restart the application provided value and then do the same so that's not very convenient if we want to use that program to basically calculate a number of hours for many different values so basically we want to keep fitting it some different values for calculation because we don't want to restart the application over and over again so how can we actually make the program continue after it's calculated the first value so we want the program to basically just keep running and accepting our values so how do we do that and we can implement the logic using something called while loop concept of loops in programming is basically you do the same thing so the same logic gets executed multiple times in a loop and how many times that logic gets executed is basically defined in the condition of that loop and the condition could be it should run 10 times or condition could also be it should run until some specific event happens in the application and conditions you already know from if else statement conditions are basically logic that gives you either true or false so condition is checking some logic and then giving you a result which is either true or false so now the question is how many times do we want this application to run in our case let's say we want to run indefinitely right until we actually stop it from here until we kill the program so it means the condition for that should always be true and for our application we're going to use a while loop which is one type of a loop and very simple syntax while and while just like if actually takes a condition this is going to be the condition for the loop so basically we want to tell the while loop how many times it should run the logic coming after it and again you know our familiar indentation these two lines should execute in a loop over and over again with some condition right here so how many times do we want the program to execute in our specific case well we want the program to run indefinitely until we actually stop it from here right from our editor so that means that condition of the loop that decides whether the next lines should get executed or not in our case should always be true because if it's false then the loop will stop right no execution anymore so how can we make sure it's always true we just write true right here and you remember i told you that true and false in programming languages have their own data types well they are also reserved words even though this is just text representation basically you see the highlighting here just like for these other words because python knows this is a boolean value of true and note that again specifically for python we actually write true with capital t unlike in other programming languages so this will basically be just a string so python doesn't know what to do with it but it recognizes true width capital t so we're telling our loop our while loop the condition is always true so basically run these two lines indefinitely because the condition will never change it's always going to be true and the syntax is probably already familiar to you we have the keyword just like if or try we can actually compare the syntax to the if statement so we have the while keyword here then we have the condition so this is the same type of condition as this one right here it's just that with us is basically fixed true value here it could be true or it could be false based on the condition and then we have the colon and then we have the indentation for the next lines so all of these belong to the while loop so that's basically it we can now execute the application and see that our program runs indefinitely so this is the first one let's say we enter 10 awesome we have a result and then we have again the next execution where it's asking for our input again and we can do 10 now it's telling us we provide a negative value but we can enter the value again let's enter some invalid value that should be handled by this value error block execute it's not a valid number and application basically continues so again as you see if you have an application that should continue running and basically get user input over and over again you don't want that application to be crashed at some point by some bad input you want to catch and handle every type of input so that your application continues to run and if we want to stop it we can basically just shut it off here and process finished now we can do one optimization in our program and this would be to allow users themselves to stop the application using some specific input value so for example when they type in exit for example the application should stop only for that specific word so it shouldn't run anymore so how can we do that so basically instead of having a condition that is always true we want a condition that says if the user did not input word exit then continue running the program if user entered exit then basically just stop it right so we need to change our condition right here so here we want user input is not exit right so user input is not exit now we didn't learn how to check for not equals something right we have check for equality so we check whether input number equals zero or if it's greater than or smaller than however we didn't learn how to check for not equals not equals in programming and this is not specific for python is expressed like this so instead of two equation signs we have an exclamation mark and equals and if we want to compare it to a string obviously we type that string in our case it's exit so basically this condition tells our while loop while user input is not exit continue running the program so while this is true basically just keep moving on but if user enters exit this will not be true anymore it will be false so loop will basically break and application will end now you see that we have a warning on this user input that we're using here and if i hover over it you see a message that says name user input can be undefined so it's not always undefined but it can be and here i want to mention again that pycharm because it's an intelligent editor can give you actually this warning when otherwise in a simple or normal code editor you probably wouldn't get such a warning so again it helps you in avoiding some of the mistakes that you might accidentally make when writing code so basically it detects the errors or possible errors for you and tells you to fix it so again this kind of intelligent warnings and error messages can be a lot of help when programming an application and now let's fix that warning so what's that all about the problem is on the very very first run of this while loop user input variable itself will not exist why because we're creating that user input variable on this line first so our application will basically complain because when our while loop runs for the first time it will not be able to find user input variable let's actually try that and as you see user input is not defined so we need to create that user input variable before the first execution of the loop so right here we're going to create user input so we're going to create this user input variable before the while loops first run and it doesn't really matter what the value of that user input variable will be because what matters is the variable exists so the value is basically just empty and as long as it's not exit the loop will start running and our application will get executed so again to go through the flow of this we're creating a user input variable then we're making sure it's not exit if it's not this line will get executed so we get the input from the user that's going to be our first input and then we call validate and execute function that basically does all the checks and execution so that's going to be the first run of that loop on the second run of the loop the condition will get reevaluated so now the user input is what the user provided so again python will check is the user input exit no cool let's execute the program again user will have to enter another value and then that value will get reevaluated so note that after each time that this block of code has run and executed every single value that user will give as an input will be evaluated over and over again in that condition and while user input is something else then exit it will run the program if it is exit then the loop will break so let's actually test that so this is our first message and our first input let's do 10 it got calculated let's do minus again calculate it and we can do that over and over and over again and now let's actually enter exit and let's see what happens and as you see a process finished with exit code so our application actually stopped because this condition was not true anymore it was false because we entered exit so that's how we can allow users to finish the application and two takeaways here one is a conditional in a loop and the second one is a negative equals check for values great so now we have our application that basically allows inputs multiple times and can be terminated with exit input now what if i wanted to calculate number of hours for several days but i didn't want to basically just pass it on one after another because that's just too much effort for me so let's say i wanted to give it 10 different values but i don't want to type it in 10 times right i want that application to basically do the whole calculation for all those 10 values but i just want to enter that list once instead of entering each value separately so in this part we're going to learn another data type in python called list so till now we have learned several data types like strings for example as well as integers and float numbers and boolean true or false and list is just another data type and the syntax for list is using square brackets and inside the square brackets we have a list of elements and those elements can again be either strings numbers or boolean values in our case we want to provide our application with a list of number of days right so we're going to have a list of integers like this and you can have as many values inside the list as you want and these are going to be comma separated and the syntax will look like this but again as i said you can have a list of strings list of booleans etc so as i mentioned we want to let user basically provide inputs as a list instead of those individual values one at a time so i'm going to copy this let's clean this up and let's actually see what happens if i just input that list as a value right here and enter you see program doesn't recognize that as a valid number obviously because we have the check and causes a value error that's why we get your input is not a valid number don't ruin my program message right here so we want to change that and make our program actually accept that as a valid input so how do we actually implement it and let's go through this logic theoretically first before we start implementing it what we need here is that we want to read this list and we want to do validation and execution for each value one at a time so that means that validate and execute function needs to be called for each value in that list right so basically this function for all this logic needs to be executed for each element now how do we get the individual elements of the list so you remember the definition of a loop loop is basically executing same function with the same logic multiple times and the number of times basically depends on the condition right here we have a condition for while loop and the condition for executing the same logic for each of those elements is going to be the number of elements in that list right so we want to execute the logic as many times as we have elements in the list and for that we have another type of loop called for loop and basically we want to execute validate and execute function using a for loop the syntax for for loop is a little bit different first of all we have four keyword just like for while then we have the element is a variable so we can call that number of days so this variable basically represents each of those elements in the list and then we have in which is again a keyword of python so for in basically puts together the for loop logic in python so python knows what we are trying to execute and finally we need the list that we are executing this loop on and our list is our user input and that's our for loop however again you remember the indentation the logic that for loop executes needs to be indented so it should belong to for loop so now we can read that for loop statement as follows for each element which we call we decide to call number of days in a list called user input we want to execute this logic exactly what i said before so for each element in this user input list we want to execute validate and execute function we don't have a condition written here like we did in while loop or if statement so the condition is basically implicit right the condition says however many elements there are in this list that many times that function or that block of code here will get executed so if i provide five elements you will be executed five times if i provide 10 elements it will be executed 10 times and that's exactly what we want however there are still a couple of things we need to do for this application to work properly first of all validate and execute function still uses user input right here so instead we want it to use the individual values of the user input because now it's going to be a list and not a number so this element we can actually call it num of days element this value should be used here instead right so we're going to use that element instead of the whole user input list and paste it here so that fixes the first problem and the second one is as you know user input is always a string so even if we provide a list of these it is still going to be considered as a string so we need something similar to this right here so the list of numbers that are provided as input needs to be converted in at least in python and we can actually do that in a convenient way using user input dot split and split is a function that will take user input as a parameter and will give us a list data type so split function basically will return a list of all those input values and again note the syntax of executing the split function we're not just calling a split function like this with user input as parameter instead we are basically calling it on user input and i'm going to explain more about this type of functions in python later but for now let's actually execute this application and see what happens so first of all how am i going to provide a list to this application so that userinput.split can actually convert it into a proper list in python and the way i should provide the values are list of values with spaces between them so basically like that so why spaces how come it's not a comma or something else the reason is because split function by default splits that provided list on spaces and then creates a list value out of them so that's the default behavior of split however we can override that behavior and we can decide you know what we want the input to be a list of numbers that are comma separated instead of space separated so what we can do is right here we can do split on a comma so that's what our split function here will do and now if i reexecute it and i can do commas now 40 55. so that's going to be user input and split with comma should convert it into a list value in python so let's execute it and as you see it worked fine we have a calculation for each of those values now let's actually play around with this and let's say we provide a list with some values and somewhere in between we decide to add a text and then maybe a float so let's see what happens now and you see that for those two valid numbers the calculation was done properly and for the other two basically the validation kicked in and it says that these are invalid numbers however again our application ran without any problems and we can even provide another input so now let's actually do 20 maybe a boolean even and a negative number execute and you see that for 20 the number of hours got calculated true is obviously not a valid number and minus 100 is a negative number so everything works perfect validations in place and we can provide a list here now and as a final optimization we can actually change this message here that says hey user enter number of days as a comma separated list and i will convert it to hours so now we can provide either just one value and it works fine or we can provide multiple values as a list and again if we want to see how that list actually looks like and check the type that it has in python let's actually print it so first i'm gonna print type of user input called split and then i'm just gonna print that list itself so let's execute and let's provide some values and here you see this is the class list so basically the data type list and that's how our list looks like so we have these square brackets here and each element inside as a string because we have the quotes here and later our application then transforms it or tries to transform it into an integer and you also see there are some additional spaces here because that's how we entered the values so basically the split splits the values on comma so this space also becomes part of that element so to fix that leading space in each value we can basically just add a space here so it will split on comma and space and let's test it out and there you go we have our values without the space before them so you saw an example of when we actually need to use list data types in this example we wanted to allow users to basically just input multiple values at once as a list but obviously this is just one of the use cases for a list and one of the specific examples because throughout the application you can create lists and you can use the elements of that list in another function so you can use it for multiple use cases and just to show you some basic syntax of how to create lists within your code inside your application so how to initiate it and then how to use that list i will show you the examples here so basically to create a list in your code you would use that syntax that i showed you earlier with square brackets and inside that you would have list of elements and this could be strings so it could be for example names of month let's say like this and then we would have to assign it to a variable right again just like we did for strings or integers or other data types so we can call it my list and this will give us a list with three string values inside and once you have created a list you can then use it to read the values from the list right so basically to get the individual values elements out of that list so for example if we wanted to print out the first element of my list then we would access that using my list and then following syntax with again square brackets and then index number of the element which is starting from zero so this is the first element with index zero this is the element with index one index two and so on right so it could be confusing because it starts with zero not with one but that's how the specific element of a list can be accessed right so if i wanted the march value here the third element then i would just type in index two and this is a syntax of getting elements from a list if i just want specific values and not each element one by one as we had in this example right so one way to use a list is to basically loop through it and get one element at a time and that's why we don't need to use index here because it gives us elements one after another or maybe we don't want all the elements or to do something for each element we just want specific values from the list for different use cases in this case we can access them individually like this and in addition to accessing the values from a list or basically reading the values from release we can also add values to a list and we can do that by typing my list and then on the my list we're going to do dot and use the append function right so append will basically take the next element or another value basically and add it to the list of elements already in the list right so let's say we want to add the next month and now if i print my list we should actually see this here with april as a fourth element right so let's execute and there you go so first we have march here printed out which is the third element right index two and then we have my list append that adds fourth month name into the list so after append this is how my list will look like and now again we can access the specific element for example if we wanted to access the newly edit element on index three so that's going to be the fourth element and there you go we have the new element printed out and also an interesting note is what happens if we use an index here which is too high so basically pointing an element that doesn't exist right so instead of three let's say we have four here so this will point to the fifth element and since we only have four elements let's actually see what's gonna happen so i'm gonna execute this and there you go you see an error index error that says a list index out of range so every time you access or you try to access an element at an index that doesn't exist you will get this list index out of range error and this is actually something that may happen pretty often when working with lists if you're accessing the values like this so this is how you work with lists how you create them and access values in them as well as add some values however note that most of the time if you are using lists you're going to be using them in a for loop because most of the time you would want to do something specific for each element in the list so this basically should give you an idea of syntax of lists and how to use them generally and also how to use them in combination with for loops here i want to take a few seconds to thank jetbrains the creators of the awesome pycharm and intellij editors for sponsoring this complete course besides all the great existing products they have they recently introduced space which is an allinone team collaboration platform covering software development project and team management and the great thing about space is that every single tool you would need in a company to collaborate and work together in a team is in one space so you have tools for chats blogs planning and creating tasks meetings but also software development tools like version control ci cd package repositories and much more so all these in one platform and in terms of productivity the great thing is you get all the notifications in one place like code review updates newly created issues new blog posts etc you get all of these in chats where you can react directly in place or add them to your todo list automatically so i think the main value of space isn't that it has all these tools but rather the fact that it integrates them in such an intelligent way that it improves the team communication and productivity overall now let's go back to coding now at this point here i want to mention a pretty minor and simple detail but something that is also very important and useful in programming and that is comments so how do we write comments in python and why do we need or in which cases are comments actually useful one usage of comments is basically to give yourself some notes on your own code so basically if your code gets a little bit complicated and it's not really clear what the logic or the function body is doing it could be because of bad programming but also because the function logic is just a little too complicated so you want to add some textual notes to that code so that you understand what's going on there even when you look at that code days or maybe weeks after you wrote it so for example right here we may want to add some notes about what this part here is doing and comments in python are written with this character so for example i want to add a note here we want to do conversion only for positive integers and that's basically my note that summarizes all that logic right here and it is not only useful for myself in case i forget what this complex logic actually does but also for your team members so if you're working in a team and your code gets really complex and it's difficult to keep an overview of different functions and variables and what all these things do you can basically add these comments as notes to your team members so they can also understand what you thought or what kind of logic actually you were thinking about when writing this code so comments is a way of communicating your thoughts and your logic on your code so that's one use case for using comments and the second use case if you have a piece of code that you do not want to delete because it has some logic or it has some example that you want to keep as a reference but you don't want that code to be executed so basically you can comment out code so that it still stays there but doesn't get executed and the way to do that is just basically having this character before the line and also note the color of the comment in the editor is gray so it's immediately visible that these are the comments and now these two lines will not get executed by the program they will be ignored but they are for your own reference in case you want to keep it there for example this could happen if you are unsure about the change and you want to delete that whole code from your application because you might actually need that eventually so you're not sure about it so temporary comment the code before you permanently delete that so these are some of the use cases of comments now if you have multiple lines of code that you want to comment out or maybe hold text that you wrote as a note so for example you want to comment out all these four lines here obviously you don't want to do this in front of every line so for multiline comments you can actually use the following syntax which is three quotes at the beginning and at the end and again you see the highlighting is different here which basically is highlighting of a string however it is ignored by the program and it will not be executed as a best practice you shouldn't have too many comments in your code because it will just add additional clutter and your code will look basically unclean so you should use them only when needed in this part i'm going to show you another data type in python called set so what is a set let's start our application again and let's say i provide here input values as a list let's say 20 40 and 20 again so basically i have duplicate values in my list and when i execute it i see that the program got executed for each element and i have duplicate results because i passed in the same value twice now again users they can input any value they want either intentionally or accidentally this could be bad values or things that don't make any sense so let's say we want our program to behave in a way that if user provides the same values twice or three times we only want to calculate the number of hours for that value just once so basically for this input we want just those two lines and basically ignore the execution again for the same value and you probably already guessed that's where set data type will help us so set is basically a list of elements but with unique values inside so list data type allows duplicate values the same value multiple times set does not allow duplicate values so how do we use set instead of a list and it's actually very easy to convert an existing list into a set and we can do that using a function called set and basically the parameter of our set function will be the list so if this list here contains any duplicated values that will be basically just filtered out when we convert it into a set so that's how it works and again for demonstration let's actually print out how set value looks like so i'm going to print the list first so that we can compare then we're gonna print out the set and let's also print out the types and i don't want to repeat this expression over and over again so what we can do even though this is just for demonstration we can actually extract it into a variable let's say list of days like this and we can use it everywhere we need and this is a little bit cleaner because we don't have to repeat the same expression over and over again and again let's print out the type of list of days and then print out the type of a set of lists of days and again you see that nested function calls three times and this should give us some interesting value that we can compare lists and sets and just a small note here that whenever we have this nested function calls think of the execution from inside out so the first function that will get executed in this chain is actually the set right so it starts from the last function in that chain so set function will get executed and convert that list into a set then type function will get executed on that resulting set value and then print will get executed and print basically the result of the type so the order goes from innermost function to the outer functions so let's save it and execute and now i'm going to again provide a list let's say 10 and then 45 and 30 and 10 again and enter and first of all we see that 10 only got executed once and not twice and we can also see the first one is basically value of a list and you see at least here the second one is a set and you already notice the difference that list basically uses square brackets and set is represented using curly braces right and again it has value of 10 just once and again we have the data type of a list and a set so just to demonstrate that they are actually own separate data types and like we saw previously with lists we can also create sets as well as add an excess values from it so let's see an example here for example if you want to create a set the syntax for that will look like this as we already saw again set can have strings or numbers or booleans as its elements let's use the same example we use with lists so i'm gonna just basically type in names of the month here so let's say we have again january february march and we're going to assign that again to a variable so this will give us a set that we can create ourselves not just from the user input and now we can access the values the individual elements from the set and we can also add elements to the set however we cannot access the individual elements of the set like we did on lists right you remember on lists we use the syntax with square brackets and the index of the element in set we cannot actually do that instead we can only access the elements of a set in a loop so for example in a for loop we would write element in my set and then we can basically print that element so let's execute and right here you see all the elements printed out and again as i mentioned with lists also previously most of the time when you're working with lists or sets you're gonna want to look through the elements because you probably would want to do some operation on individual elements or some of the elements right instead of just grabbing individual one or two values from that now how do we add elements to a set let's see it as well we can add elements to my set using my set so the set itself the variable name and then if you do dot you see a bunch of builtin functions again set has its own builtin functions which are completely different from what list has and it has a function called ed and here we can basically add a new element again let's do april and now we can print my set and execute and there you go so we have here individual elements that are printed out and we have the new list after we edit april now one thing you probably already noticed when working with the set like printing its elements or adding a new element it doesn't work in the same sequence as with a list right so for list we basically had this january february march in this exact order and when we edit a new element basically it got added at the end right as a fourth element in set it's not ordered it's basically in a random order right so if i execute this again rerun you see the order changed here and here as well right and if i do it again there you go so this order and this order basically changes right so as you see working with sets is actually pretty different from working with lists so this means that set not having or not allowing duplicate values is basically just one of the differences between sets and lists and of course you're probably wondering i can add elements i can access elements what about removing elements right from lists or sets and you can do that actually the same way for both sets and lists so for example if we want to remove an element from a set we can execute a builtin function called remove and remove basically takes a parameter which is the value itself so let's say if we want to remove january from here then we're going to pass the value to remove function and now if i print my set again after the remove gets executed and let's run it and here you see the last print basically doesn't have january inside and as i said it works the same for lists so let me demonstrate this as well so on my list which has its own set of builtin functions one of them is remove which in this case is called the same for both set and list and this remove builtin function also accepts the value of the element you want to remove and let's print it again my list and execute there you go this is a set with the syntax with curly braces and this is a list which now doesn't have january inside because we removed it and as you know lists can have duplicate values so if we have january again here so two times and we do remove january it will actually remove the first occurrence of that value so if i execute this you see the first one got removed and the last one or the second january value is still there so that's how you work with sets basically and also how to remove elements from sets and lists so at this point i want to take time and review the functions that we have used from python itself so the functions that we ourselves didn't actually write and the functions that python basically makes available for us to use are called builtin functions so till now we have used function print which basically just takes some input this could be a string this could be a variable this could be a number doesn't really matter and basically just prints it in the output console right in the terminal we also saw input function that basically takes user input again we can provide a parameter which will be a message or leave it empty we also in the last example so an example of set function which basically takes a list and converts it into a set and another example is int again takes a string as a parameter and converts it into integer and all of these are builtin functions because python provides them to us so that we can use it in our code and in python there are a lot of very useful builtin functions for different purposes and as i mentioned most of these functions basically accept a parameter and then do something with that parameter that input that we provide that function and give us an output again print basically provides something here and gives us the output in the output window here in input we can provide some message that will again print an input here and the rest of them are giving value inside the code without displaying anything so in set we can provide a list and the same way a parameter here which is logical because the purpose of a function usually is to take some input like this as a parameter do something with that input and give us an output from that parameter and we have created our own functions that also take some input and give back some output like this and in addition to builtin functions that are called like this and our own functions we have also used third type of functions which is called directly on a value right and this is an example of that so basically directly on a value this could be a variable but also the string representation of that itself so if i had a string like that so basically directly on that value call a function like this and these are also builtin functions because python makes them available to us other than the syntax there is one major difference between these type of functions that are called directly like that and the functions that are called on the value itself and the main difference is that each data type has its own set of functions that can be executed like this so again let's take example of a string and if i do dot here you see the ide pycharm basically gives me a list of all the functions again builtin functions in python but functions that i can execute on a string value and again you see split is digit this is the one that we used in one of our previous examples that basically checks if that string is a representation of a digit or just a regular string and as you see lots of different functions so all of these are provided by python to do different stuff like turn the string literal to uppercase or replace a letter for example in that string and so on but the main point here is that those functions are only for string but as i said each data type has its own list of functions that can be called on that data type so for a demonstration let's take a list and if i do dot here again you see a list of functions that i can execute specifically on list values and there are lots of things that you can do with lists like add elements to it remove elements from it sort the list copy and so on so that's basically a major difference between these type of functions and functions that can be executed on specific data type values but the concept is the same here you also have a function that gets a parameter an input and gives you an output and the parameter for this type of functions is actually the value that we are calling that function on so this string here 2 3 is going to be parameter of the split and in addition to that we can also provide additional parameters for example for split you saw here that we were able to add a comma space to basically tell the split function on which character to split that text so that was function comparisons in a nutshell in this part we're going to learn a new data type in python called a dictionary and we're going to do that by modifying our application and modifying how users can actually input the values now our program currently takes the number of days and turns it into a number of hours what if we wanted to make our program a little bit more advanced a little fancier and basically allow users to also decide what units it should be converted to so user gives us the number of days and tells us whether to convert it into hours or minutes so instead of the whole list now we're going to get just number of days and the conversion units and this change may be a little bit complex in terms of syntax so i will try to explain everything step by step so the first thing we need to do is adjust how we get input from the user so now we want the user to be able to give us the number of days and units in one input so first of all i'm going to adjust the text here enter a number of days and conversion unit now there are a lot of different ways we can allow a user to do that but what we want to do is something like this as an input so basically number of days colon and minutes or number of days and hours again this is our own decision we decide how the user input should look like but this should be a nice way of providing both of those values basically colon separated so instead of a list we're going to have a single input with two values that are separated by a colon so on the next line i'm going to change this split here into a column and this will give us user input this whole value split into two values as a list this is going to be day and days and unit so least with these two values and let's actually get rid of this for loop because we're not iterating through a list of numbers anymore and to begin with let's just print out the output or the result of days and unit variable so i'm gonna refresh and let's do two hours and enter and this is what we get so basically splitting this string on column will give us a list with elements 20 and hours and note that 20 is still a string right because that's how we get the input and now from those two values we're going to create a value of a data type called dictionary so in python we have another data type called the dictionary which basically looks like this so you have curly braces just like we had for a set and inside we have key value pairs so we don't have just single elements like this but rather we have key value pairs so key in our case is days and the value of that key in our case would be 20. and then comma separated another value would be unit and a string hours so basically this is the syntax of a dictionary and obviously the difference between a list and a dictionary is that we have descriptions for each of our values represented as key value pairs so we want to create this construct right here from those two values and since this is a data type we can create a value and assign it to a variable of that data type so let's call it days and unit dictionary equals and obviously we don't want those values to be hard coded here we want to get it from the list now how do we access an element of a list how do we grab the first value which is 20 out of that list and to do that there is a syntax to access the elements in the list the list name and then you have square brackets and index of the element which if you remember you already learned in the section of lists so again days of unit list is this one right here and with index 0 we are accessing the first element index 1 is the second element and so on and index is basically just location this is location 0 location 1 and so on so this will give us the first value and obviously the second value is going to be with the same syntax with index one and let's actually print that one out as well so that we see the results restart the application let's do 20 hours so again this is our list 20 hours as two separate values and this is a dictionary that we created using those two values so we have key value pairs basically and the same way for minutes we would end up with a dictionary that looks like this so now we have these two pieces of information in one variable and now we can give that variable to our function so that it does the validation first of all of the number and calculation based on the units so on the next line we're going to call our validate and execute function and as you see we have this red line here because something is wrong first of all we don't have this variable called num of days element anymore because we deleted the for loop instead we have days and unit dictionary and here we are validating the integer value of the input number and the same way we need to validate this input number here as well so now the question is how do we access a specific value in this case the value of days here in a dictionary because we have to validate this value as well because i might as well have entered text instead of this number so the way to access values inside a dictionary is again using the square brackets just like we did for list but instead of an index index 0 or index 1 we don't need to use an index because we actually have a key so instead of index we're going to use the key like days or unit and this will give us value of 40 which will then be converted into an integer and then validated right here so again i'm gonna copy this for comparison so to access an element of a list let's say my list here and let's do 20 30 doesn't matter in order to access the elements of that list we can do that using an index so this will basically print number 30. again if we had other elements here we can do index 2 so that will print out 100 and let's actually check that and remember to comment out a multiline code we can use three quotes at the beginning and at the end let's refresh and there you go 100 was printed let's do the same with the dictionary so we have a dictionary days like this and to access an element inside that dictionary we use the square brackets and instead of the index like here on the list we use the key itself and again i'm going to print this and there you go you see value 20 and i can also access unit value and if i execute it i see hours and so on and i can add any number of key value pairs in my dictionary as i want so for example i can add a message here all good and i can access that message like this so this is how you create a dictionary and that's how you access the values in a list or in a dictionary so let's clean this up comment in our code again like this and get back to our code so basically again this is how we access the number of days in our dictionary and in our days to units function we need both of those values and we can pass in those values separately so we already have a user input number from the dictionary and the second value would be the unit from the dictionary however we have to add that second parameter to our function so let's do that unit let's call it conversion unit so now we are passing both of these values to our function so we have the user input number here which is already converted into an integer and the second one which is the conversion unit and now we can finish the logic in this function here right now we are using this hardcoded calculation to units which is 24 and number of units which is hardcoded hours so first of all i'm going to remove those two we don't need them anymore because we get those values from the user and now we have to substitute those two so here we're going to check if the conversion unit is hours equals hours then we're going to return calculation with hours it's going to be 24 and conversion unit here we can also hard code hours here because we know it's hours else if so if the conversion unit is minutes then we can return calculation for minutes and a text like this and it could also be that the conversion unit that was provided is none of those or maybe some invalid text and in this case we're gonna add final validation so if it's neither hours nor minutes then we're just gonna say you know what unsupported unit so basically we don't do conversions other than those two so we just tell the user that's an unsupported unit and now if we execute our program and enter value there you go we have our output and same way if we do 90 days to hours we have our calculation in hours so that's how dictionaries work we can do one final thing here and as usual print out the type of our dictionary and there you go you see class of type dictionary here which is another data type and at this point we can actually summarize all the data types that we have learned so far so let's give us some space here so first one was string so basically a message or some output like this that's our string then we have integers example of that we saw already days then we have float numbers which for example can be used for price or weight of a product etc we also have learned boolean data types when we check some kind of condition whether if it's true or not so for example is it a valid number or is the user input exit we also learned a data type of lists so for example usage list of days like this including duplicate values and list data type can be used for strings as well not only for numbers so for example we can have list of month like january doesn't really matter we also learned a data type called set and set basically is very similar to list but it doesn't allow duplicate values and its syntax is with curly braces so the same way we can have numbers or strings or booleans or any other data types inside a set and the last one that we learned was a dictionary and let's take our own example day in unit and dictionary is basically a collection of key value pairs and the syntax is written like this so why do we need all these different data types well depending on the use case or what exactly you are trying to achieve in the program you're gonna need a different data type to achieve exactly that so each data type has its own specific purpose and throughout these days to units calculator i try to demonstrate the purpose of each data type and when we need to use them so these are all the data types that we learned these are also most of the data types available in python and the main ones that you're going to be working with so this should give you a good foundational knowledge about data types in python and also note that most of these data types you will also encounter in any other programming languages because as i said these are the core data types and most of the programming languages actually support these data types as well till now we have been writing all our code in one single file so basically we have a project with just one python file and we're writing all the logic inside that file however you can imagine that if you're writing a little bit more complex applications that have much more complex logic so they end up having lots of functions obviously you're gonna end up with a python file that has hundreds of lines of code maybe thousands of lines of code and it's not very practical to manage all this logic and all this code in just one file so instead you need to structure your code and divide your logic between multiple different python files and you do that with modules to give an example imagine a web application that has basically many features like facebook for example obviously you can put all the facebook logic in one single python file right you will have a structure of facebook project with subfolders in your project which all contain multiple python files so you would have maybe packages for each feature and each such feature has a lot of functionalities so they will be all grouped then again in multiple python files right so you would end up with a project with a hierarchy of folders and lots of lots of python files inside now the question is if i have multiple python files in my project how do i connect them together so for example if i have another file here and let's call it helper dot py and if i have some logic here basically functions defined here how do i use them or how do i reference them in another file and the way it works in python is using the concept called modules so a module is basically a python file that contains functions or variables that you can use in another python file so basically any python file that you have in your project both of these in this case are modules and you can reference one module from another so basically the idea is that you can structure your application your program using modules so you can make your project modular so in this part we're going to create our own module in helper file and we're going to reference that in main dot python and let's say in main.python i only want the code that basically starts the program right all the functions all the logic i kind of want it hidden away and grouped together in a separate file so what we're going to do is copy this entire thing so both of these functions basically and paste it in here so now you already see a couple of red lines here because now the reference is obviously broken right so main.python obviously doesn't know anything about validate and execute function right it says unresolved reference and the same way face to unit dictionary is unresolved for helper because it doesn't know anything about main.python and the variables defined right here so the first thing we need to do is we need to tell main note python file where to find this validate and execute function right we have defined it in helper python so that's what we need to define how we do that is using something called an import statement so we basically import this whole helper.pi module inside main.python and we do that very simply using import helper right helper is the name of the file and therefore name of the module and right now it's grey because we're not using it and the way to use it is helper dot and the function name and you see the red line disappeared so again what we did is we told main.python there is a helper module in this project and please import this whole module and all the functions that this module has and make it available in main.pi and then once we have that helper module we can reference any functions if we had any variables using module name dot function so this has to be the name and if i hover over it you see that pycharm actually displays the whole path to that helper.pi file and now note that here we still have redline because this is a variable which is defined in main dot pi but a helper module doesn't know anything about it and that's an important distinction here because we imported helper module inside main so helper modules functions are available here but not the other way so in order to make this dictionary available invalidate and execute function we would need to pass it in as a variable like this and this will work now now note that in main.python we actually only need this validate and execute function we don't need the days to units function because this function is only used by validate and execute function so that means that we don't need to import the whole entire module inside main.pi we actually only need the validated execute function and this is a small example but if you had a module with 20 30 functions and you just needed one of them you wouldn't need to import the whole module just for that one function so what you could do is you can pick and choose which specific functions you want to make available inside another file or another module and you can do that very easily using the following syntax we say from helper that's the module again import and the name of the function like this and now because we are accessing and importing that specific function we don't need to use module name anymore we have that function available directly so we can delete the module reference here and we have that function available like this so again instead of having entire helper module with all of its functions and other stuff we only have one specific function available here so that means we wouldn't be able to use these two units for example now we saw an example of a module that has just functions right however module can have many other stuff for example variables and you can make those variables also available for another program and that's an example here i'm going to create a variable called user input message and this is our user input message and we can actually put it into a variable instead of having it defined like that so i'm going to copy it and paste it here so now we have the user input in a variable in another file again how do we access it in main dot pi in this statement at the top we can actually import several things from a module right now we are importing a function we can also import our variable and we can do that also very easily like this and we can use that user input message here so basically if you have again 20 functions and variables from a module and you just need maybe five of them you can import them individually like this just basically just list the names of functions and variables what you can also do is import all this is what this asterisk sign represents so we're basically importing everything from the helper module again this is kind of a waste if you just need a couple of functions and variables from that module and not the entire thing however with this syntax you can import everything and now you may be wondering what is a difference between importing everything from the module and importing the whole module because in both cases you have everything in the module available the difference is in the syntax because note that if we use this from import statement you don't need to use name of the module every time you're accessing something defined in that module right so we don't need to do helper dot function name or helper dot variable name whereas if we imported the module like this you see we have red lines because we would need to do helper dot or module name dot whenever we use something from the module now this could be a matter of taste so basically which one you want to use i personally think that this is the most efficient and also cleaner way of using specific functions variables etc defined in a module and as a side note the things that are defined in a module that you can use basically in another file are called definitions so all these those three elements here are definitions of a module and you can use any of those definitions in a file where you import that module what you can also do when importing a module is you can rename that module basically to whatever you want so if the name of the module is too long or you just want to use a different name you can do as and then basically write a name whatever you want like h for example and then obviously you need to use that new name everywhere you access functions or variables of that module so basically how you import a module and whether you rename it is a matter of taste basically how you want to do that in your code however i think that importing specific elements from a module like this is most efficient and also cleanest way to do that so we saw how to create our own module and use it in another file so basically if you had hundred python files here with each one of them having their own functions and variables you can cross reference them from each other using the import statement very easily now in addition to creating your own modules we can actually use modules that python itself already includes so just like we used some functions that python gives us out of the box like inputs or ins so basically all of those the same way python also gives us modules for different scenarios so that we don't have to write this logic ourselves and there are a lot of useful modules that python actually includes for example math module for mathematical operations its own module for working with dates or date times module for working with specific files and so on so basically for many different use cases python already gives you ready modules and these modules will then contain multiple functions and variables for that specific use case again if we take an example of a date so if you have an application that works with dates and times you have this module from a python that gives you a bunch of useful functions for working with dates and again this means you don't have to write this logic yourself but rather use the existing one so to give you some examples of modules that python provides us with for example if you want to work with operating system there is an os module so we can print out we can get the name of the os for example and i'm going to comment all this out and run and you see the name of the os another useful module python offers is logging so if you want to use logging in your application the logging module gives you different functions to log an error message or warning etc as well as basically just configure how the login will look like again to see an example again it may look a little bit complex here but essentially just using the name of the module and then functions that it gives you obviously you need to know the functions and you need to know how to use them and you can get that information from documentation or if you're using pycharm it actually gives you all the information about these functions and the module if you just hover on it so you don't even need to google or check out the documentation and basically we're creating a logger and we're logging an error message so if i execute this now and here you see the output of the logger error happened in the app and logging in application is actually a very important feature so that's why logging module is available by default in python any use case in our application would be right here if an error happened for example instead of using a print basically just log and error so these were just some basic examples but as i said python comes with lots of very useful modules that you can use in your applications for different use cases and that of course makes your work easier because you can just use the logic instead of having to write it yourself in the modules that are part of python so that you can import them like this directly are called builtin modules we learned about builtin functions so these are the functions that python makes available to us directly and there are builtin modules that we get from python and by the way if you're wondering where this module actually comes from so where is the physical location on our machine or where this module files actually leave if you're using pycharm you can actually hover over it and hold down a control key or if you're a mac command key and click inside you see the file opens up which is the module the logging module since i said module is basically just a python file that has multiple functions variables etc available and you see right here on this top line the whole path for that python file so that's the location of that module file locally on my computer and inside this python file basically you again have python code and if we look for get logger function here like this right here you will find the definition of that function right so somebody implemented this function and called it get logger and this is basically the logic all the things that get executed behind the scenes and you as a user of python basically can use the name of the function and write your own programs with it and let's also look for error and there you go we have error function as well right here and obviously this is a more complex code here than what we write but just to give you an idea that this is actually a file on your machine that comes with the python version that you install locally and all the functions are defined already there by python developers and you can just use them like this without worrying about how the logic is actually implemented and another interesting thing is if i click here in this python 3.9 like this logging is basically one module that we used and here you will see the list of the complete list of all the builtin modules that you get from python so some of them are folders like logging for example email and bunch of other stuff and the operating system module for example that we used is a python file then you can find right here so these are the builtin modules so now that we know what builtin modules are and how to use them let's actually see a realistic example and also write a little more interesting application using builtin module so what i'm going to do is in my python project i'm going to create a new file and i'm going to call this time to deadline dot pi y and we're going to write an application that basically accepts a user input of a goal and a date like a deadline date and then we're going to print out back to the user how much time it is remaining till that deadline and that deadline will be a date right some date in the future so that means that we're going to be working with dates and in order to work with dates we are going to need python's builtin module that allows us to call functions and do some processing and stuff on date values and that module is called date time so import date time so let's have that import statement right there and we're going to use it in our program so the first thing we want to do is let the user give us an input about their goal and a date or deadline for that goal so let's do that first we already know how to ask for user input with a message so we're gonna say enter your goal with a deadline separated by colon and we also know this already basically what we want to do is user to be able to enter their goal like learn python column and a date and let's say again this is totally up to us to decide we're the ones basically setting the rules here so let's say we want the date to be entered in following format day month and a full year like this so that's the format that we're looking for and this is how user should input the value otherwise with a different format it's not going to work so we're going to save that input value into a variable let's call it user input so we have the user input let's do the split again on a colon remember we have this whole thing as a string as one string so we want to split it into two parts so we have the goal here and the deadline and this will give us a list with those two values and let's call it input list and now from that list we can actually extract or get those individual values using a list syntax so accessing the elements from a list which is what we learned already using an index right so we have input list index 0 which is going to give us learn python and let's save it as a goal variable and let's create another variable which is going to be date let's call it deadline and this will be the second value in our list now let's actually print this out print this whole list out and now note that we are actually in a different file we're not in the main.pi anymore and we don't want to execute main python file instead we want to execute this one right here we basically just want to ignore everything else in this project so how do i go from main to this file execution very easy in this editor just to right click and you see here run time till deadline and i'm going to execute this everything else is ignored in the project we are basically just working on this one right here so enter your goal with the deadline separated by colon let's do that i'm going to do pi learn python colon and then let's enter some date and enter and this is the output so we basically split that into two values and put it in a list right here and very important to note here that both of these elements in this list are strings because again user input is always interpreted as strings so this was a string and it was split into two strings which are learn python and this date here however we don't want date or deadline as a string we want deadline as a date and exactly for that functionality we need this date time module because we don't want to implement it ourselves we want python to give us a ready function from a module that will basically just let us convert this string into a date value and converting string to date is just one example usage of date time module but you can use this module to work with dates generally like creating new dates formatting the dates updating the value etc and we're gonna see some of those examples in this section now if you're learning this type of thing alone you don't have me basically teaching you and giving you an example the way you would do that is you would basically research and maybe google how this is done in python and you would basically see some examples of using this date time and what the name of this function is and how to use that as well as each module has its own documentation page where you can look up the syntax and usage examples because obviously you're not going to know how to do that by yourself so the way we convert a string into a date using this date time module is on this datetime module if i type in dot i will see a list of all the definitions that daytime module gives me right so i have date daytime time etc the one that we need is date time because the function that we need for conversion is inside that definition and don't be confused here because we have date time twice here the first one is a module and the second one is a definition in that module and we can actually check that as well so if i jump into this date time module and inside that if i look for date time again so right here you see this date time definition and on that daytime definition we have now functions that we can use and as you see this is not a function or variable it says class here which is another concept in programming we're gonna see later so just for now think about this as a container of functions and variables inside that module and that's why we have to access it like this and then on that daytime definition this class we now have functions that we can use to do the conversion so the function we need is called str so string p time and this function will take a string representation of a date and we'll convert it into a date format so our string representation is deadline and we need to pass in the second parameter because remember i said we basically decided that the date should be entered like this with points and a full year here and as you know there are lots of different formats and types for dates right depending on a country or a language or even within that language we basically have multiple different formats right we have formats like this or we could also have a shorter version of the ear etc so we need to define here the format that we want python or this method here to use when converting this string into a date again because there are so many different formats available so what we have here is a day then we have a dot then we have a month again a dot and then we have an ear so this is kind of a main structure of a format however formats for dates have their own specific syntax and this is actually for all programming languages so what we need to do is put this percentage sign in front of every letter so again we have day month year and there is one more thing about this format this format right here matches this date however we want the full date not just the last two and the format for that would be a capital y again this is something that you would look up in the documentation of the module instead of knowing it by heart but just know that this type of formats are used when working with dates and this is not specific to python you will actually see something very similar in all the other different programming languages and that will do exactly what we want it will take this date here and give us a proper date format from it let's actually test this so i'm going to print this first and i'm also going to print a type a data type of that value so let's execute i'm actually going to copy that so i don't have to retype it over and over again and enter and here you see we printed first of all the date not a string and now this looks like a proper date and not a string anymore note the change in the format plus we have these zeros here which represent hours minutes and seconds we didn't set any of those so these are all zero and we have the date time type again note date time for a module name and date time of the class name so this is the type of our converted date and the reason why we needed to convert that string into a date is because we want to calculate how many days or how many hours are remaining until the deadline from now starting from today and to do that calculation we need to have date type because we can't do that on a string great so now we have our deadline represented as a date so let's actually assign this to a variable it's a deadline date like this and remove this and now we need to do a calculation how many days from now till the deadline we already have the deadline we need now again now is or today is also a date and since we have this module date time we can also assume that this module will give us some function to tell us the date of today and if i do date time again daytime class and today you see that we have this function available and this will basically give us the date of today so depending obviously when you execute this program it will give you always the current date so let's print it today for me it's 7th of february so if i execute it now i'm going to enter this and today is 7th of february for me so if i execute this let's actually comment this out here i have the date for today which is 7th of february plus the exact time it is now but we don't care about the hours and minutes and seconds we just care about the day so that means we already have deadline and we have today let's also add it to a variable like this and now we can actually do the calculation calculation is super easy we just say deadline date minus today date and this will actually give us the difference between or time difference between today and the deadline date in the future again let's actually try this out and you see that so this is 12th of august for me today is 7th of february so the program calculated that there are 185 days until the time plus how many hours minutes seconds and milliseconds so that was a pretty easy calculation now what we want to do is tell the user some kind of message and we want the message to be dear user the time remaining until the deadline for your goal whatever the goal was is this so let's actually put that text and message together and bring it back to the user so first i'm going to save it into a variable let's call it time till and the message dear user time remaining for your goal and here we want to print what the goal actually is and you remember how we format a string when we want to use a variable we put an f here and in curly braces now we can use variables or numbers or some other expressions which are not string so first of all we're printing back the goal so time remaining for your goal whatever goal they entered is time till and let's execute our program and let's give it some other value like this and enter and here we have our message dear user time remaining for your goal learn python is 132 days and this many hours minutes etc now let's say we don't care about this whole thing here we just want to know how many days are remaining so how do we get rid of this part here again very easy and the time till if i do dot here i get a list of suggestions for functions or variables that i have available and one of them is days as you see here so if i click here and save and i'm going to reuse these inputs because i don't want to type and as you see we got rid of this whole thing here and we just have days and let's actually write days and there you go we have a cleaner output now for our user and finally what if the deadline was just a couple of days in the future and the user wanted to know how many hours are remaining till that deadline we can do that by getting rid of these days and again type in dot and we have something called total seconds here which gives us the time different in total seconds and now we can reverse engineer and calculate the number of hours from this total seconds which is pretty easy like this calculate minutes and then calculate hours and i'm gonna execute this again and here you see the number of hours with a decimal precision so we have 4450 hours point some fraction number here again we want to get rid of this extra stuff and as you see from the syntax it is actually a float number with a dot here so what we could do is basically convert this whole thing this float number into an integer so convert this whole thing into an integer using int function and we need this whole calculation here inside the int function and let's execute it again learn python and let's choose a date which is near and there you go we have a whole number 57 again cleaner output and as a code optimization we could take this whole thing out into a variable and call it hours till to make our code a little bit cleaner so now we have the whole program that takes user input and basically prints back to them how many hours are remaining till the deadline for their goal and for this program we used a date time module a builtin date time module from python and we also learned a new data type which is date time and as we learned from the module section we can actually optimize the import of the module because obviously we're just using the date time definition and nothing else from that module so what we could do is from date time module import date time definition which is a class in this case so now you don't need to use the module name so let's get rid of those and this could make the code cleaner as well as make the import more efficient because we're not importing the whole module even though we just need one definition from there when you install python it comes with a set of modules that are built in into python however there are many more modules for other different use cases like web development or data science and machine learning etc that are not part of that installation and these are basically external modules not builtin modules that you have to install as you need and this makes sense because the builtin modules are the ones that most of python programs will probably need and depending on what specifically you are doing with your program whether you are developing a web application or creating some machine learning program you can then add and install them as you need and there are hundreds of such external modules for python out there and obviously it wouldn't be practical to have them all on your laptop when you're just gonna use maybe a handful of them right now if i need to install an additional module for example django for web development where do i find these modules and how do i install them python modules actually live in a module repository where you can find them and that module repository is called pipey so if i look for pipey right here you see the python package index if i click inside you can search for any module that you want to add or install additionally for your application and here you see this word package everywhere instead of a module so what is a package or what is the difference between package and a module to give you a simple comparison module is basically a python file like this one right here that has a name of that file right so we have an ssl module or the one that we used earlier we have this os module right so module is one python file that contains all these functions and variables that you can use package is a collection of modules so if we scroll up and logging is actually one our example so these are actually packages and again let's go to logging so package basically contains multiple python files and use it in the same way you basically import the functions and definitions from the module and as you see clearly the difference is that package is more structured so for example the code is not available in just one single python file but it's divided like this in our case we have two python files and package always has this init python file and this file basically differentiates a normal folder like we have right here with bunch of python files from an actual package with python files so that's the difference between modules and packages and many external modules basically that we want to use in our projects are actually packages so basically package is a good way to define some hierarchy and structure for your modules and kind of group them together so that's why you see package here as a name instead of module so now that we know the difference let's actually search for a package for our project so for example if i type here django you see django packages that we can use from here we also have numpy and so on however in programming when working with and using these external packages a typical example would be where you need to implement some logic for example you want to write a program that basically talks to aws maybe and you don't know exactly the name of that package but you know what you're looking for so in this case instead of the exact name you would actually type in here in the search projects box a description of what you're looking for so let's say we're looking for an aws api package right something that will allow us to connect to the aws api and as you see here we get a list of different packages for that to choose from so basically pipey is a repository or storage for all of those modules and packages and people can also publish their own libraries like individual developers for example they can publish their own packages and modules there and make it available for other programmers to use and that's one reason why large community is so great for a programming language because then you can make use of all these modules and packages that others in the community have developed so for any kind of functionality you need in your application you could imagine that there is a module or package that helps you do exactly that now let's say i need a django package for my web application so first i find the package and now i can actually check some of the documentation for that specific package so if i click inside i see some description for the project as well as documentation and some other links now the question is how do i actually install this package locally so that i can use it in my project in python we install packages using a package manager tool called peep and right here on top below the package name you actually see a command peep install django so this is actually a command that will install that package locally on my laptop so we install packages in python using this pip command so what is this command or where does it come from pip is a package manager for python and if you know any other programming language basically the concept is the same every programming language has its own package manager tool for javascript it's npm for java it's maven or gradle and for python it is pip and one of the main tasks or usages of a package manager tool is to install external packages or libraries or also called dependencies for your project so if python needs this django package basically it's the job of the package manager to install that package and make available for python now where did this command come from do we have pip command available well in python version 3 actually pip is packaged inside the python so when we install the python we actually installed pip as well so basically we're going to copy this command peep install django and we're going to execute it actually from the terminal of pycharm so in pycharm editor we have this integrated terminal so this is actually pretty much the same terminal as you have outside like this so we are going to execute this pip install command directly in this pycharm terminal so i'm going to copy it here and do peep install django and you see it is downloading and successfully installed django 3.1.6 and we can actually see that package from our editor directly if i expand these external libraries and site packages and scroll a bit down here i have django 316 version installed so i see that the package is now available in my project and to also test it in the code i can do import and django and you see that pycharm actually recognize that i have django packaged locally so it gives me that package as a suggestion so that will basically import the whole django package so we can now use it in our application here you see pycharm actually noticed you are using or want to use django web framework as i mentioned in the beginning the pycharm professional edition has special support for different python web frameworks supporting you with syntax highlighting suggestions database integration and so on so again if you want to try it out for free for three months just use my code in the video description in the same way as we install the package we can also uninstall packages using pip and let's also actually demonstrate that pip uninstall django and let's confirm that successfully uninstalled django now if in the site packages i click inside you see that django packages are gone so this site packages folder got updated django was removed and you also see that in the code editor now i have this red line under django because pycharm cannot find a module called django and also if i do this obviously it won't give me any auto suggestion for that so that's how you can use peep to install packages and also to uninstall packages for your application now here i want to show you another cool alternative to installing and uninstalling packages directly in the pycharm ide and this is actually a feature in the latest pycharm release and for this i need to switch to an early access pycharm version so you see here it says pycharm eap early access to show you the feature however when you watch the tutorial it probably will already be included in the latest official pycharm version so you should have that already so instead of us basically finding this package in pipey and then executing peep install commands right here what you can do is down here you have another tab called python packages so if we click inside this is a place where you have everything that you need to know about the package the package search and all these features basically in one place so for example in order to install django we can just search for django right here and you see that when i type in the first couple of letters i already get suggestions so this is a list of all the packages that start with this name that are actually available in pipi so let's type in django and we see that right here and on the right you see the documentation of the package that you would actually see in pipey ui so you have that in place as well and in addition to that what they added is the documentation link so this is actually the package howto guide and the full documentation with examples etc so very convenient way to basically get all the information about the package search the package and then to install the package we can choose the version here so either you can leave the latest or basically select the specific version and then once you have selected that you can just click install and here you see installing package and there you go so now in installed view here so we just had pip and setup tools these two things installed and right here we have now django in the installed packages list and again while you're now using the installed package or library in your code and basically you want to look up some examples or you want to check some documentation right you go back to the package click inside and you have link to documentation and the package information as well and also just by looking at this list you know which versions of which packages you have installed so i think it's really cool way to manage all your packages to install packages and for example if you want to uninstall packages from your project then again just clicking to that specific package right here you can just delete it and it will be removed from your application like this and no django anymore here so a very cool addition to pycharm because this will be very convenient to work with the packages so now i will switch back to my other editor again and continue from there so basically i have just cleaned up my python project we have this main.pi which is empty and we're gonna write an application that will read a spreadsheet file from our local file system it will read some information from that spreadsheet file and do something with that data and this could be a very useful use case if you're working with lots of files and you want to do some data processing in those files and you don't want to do that manually by automating or writing a program in python that basically can do anything in a file or across multiple files so let's see exactly what we are going to be doing with this program so first of all we're going to have an input file a spreadsheet file that we're going to be working with and that spreadsheet will look like this it's called inventory that's how it's going to look like so basically this file simulates something that many companies would have and employees of that company would be working with so we have this list of product numbers inventory for each product price for the product and a supplier so this could be an example file from a company that is basically dealing with selling or buying products so what we're going to do is we're going to read the information from this file and we're going to do something with that information first we're going to write logic that calculates how many products we have per supplier so we have three supplier companies here and per supplier we're gonna calculate number of products from that specific company and as a result we're gonna list the company so all three companies with their respective number of products then we're going to write another logic that lists inventory products that have inventory which is less than 10 so basically those ones the third exercise is going to be to list each company with their respective total inventory value and finally in the last exercise we will calculate the inventory value for each product so product count times price and we're going to write that value to an additional column in the spreadsheet and after that we're going to save that updated spreadsheet file programmatically using python so we're gonna see how to update a file and then save it programmatically in python if any of these sounds a little bit too complicated for you then just bear with me i'm gonna explain everything step by step and it's gonna become much clearer when we actually start writing the logic so the first thing what i'm gonna do is i'm gonna take this file that i have in the downloads folder and i'm actually gonna move that into my project so i'm gonna copy that and i'm gonna drop it in here so that we have the file right in our project and so we can basically just read it easily and okay and here is our inventory file so that's taken care of so obviously what we want to do now is read that file so basically let our python program read the contents of that file right here because we want to write some logic based on the values that are in this inventory file right we want to calculate stuff we want to list some stuff and so on so basically we want to work with these values and in order to do that we need to read all of these values into our program so that we have them available so how do we do that now there is actually a builtin module in python that allows you to work with files generally right it's not specific for a spreadsheet or for any other file type it's for different types of files generally however there is an external package that allows you to work with spreadsheets specifically and the obvious advantage is that that external module that allows you to work with spreadsheets or was created to work with spreadsheets specifically has much more functions and is much easier to use if you are working with spreadsheets compared to this builtin file module so that's one of the cases where you may have multiple ways of actually implementing some functionality for application and then you have to make this decision of maybe finding a better package or better module which is available externally that will make it easier for you to implement that functionality so that's what we're gonna do for our project we're going to choose the package that is actually made for working with spreadsheets we're going to use that one and it's called open pi xl and if i search for it this is the package that we're looking for and if i click inside basically we have some information about this package so here we see a description let's actually make this bigger description library to read write excel files with all these formats so this is the library that we're going to be using in the same way as we did before we're going to copy that command and execute it from pycharms integrated terminal so from here i'm gonna execute this pip command and install our module and as you see successfully installed open pi xl and this is the version of the module that we installed and in external libraries site packages you should be able to see our open pi excel package and now because the package is available locally i can do import and open pi excel again i get a suggestion from pycharm because the module is there and now we are able to use that package for our application and one small note here if you're wondering why there are some packages with basically a dot inside and some without these are the packages that we install python packages and we know that because there's this init python file inside and the ones without the dot they're just folders with bunch of files inside but they're not python packages so to say and inside some of those packages we see other packages as well with their own init file so basically hierarchy of multiple packages and at this point i'm going to say that the word library basically describes package that includes multiple other packages so basically which has a hierarchy of packages so we have module which is basically just one python file that we can use in our project then we have package which is a hierarchy of multiple modules with an init python file inside and then we have library which is basically multiple packages together in a hierarchy just like we see right here so note the difference so you don't get confused when you see library package and module especially if used interchangeably great so now we have our module in place so let's use it now to read our spreadsheet file and again you basically have to know the function names to do that if you don't you can do dot and get suggestions and load workbook is actually the function that we need in order to read our spreadsheet file so i'm going to choose this function and obviously we need to tell this function which file it should read so as a parameter we're going to say please load inventory file and we even get a suggestion because we have this inventory file here and there you go now this function will load the workbook and all its contents and later we obviously want to do something with that content so in order to be able to do that we need to save it first as a variable and let's actually call it inventory file like this and this will give us the file contents now let's actually open that file again and let's see exactly what we need so we can have multiple such sheets basically per file so we need to tell the program which one it should use exactly so for example if this was called a product list you would use that name but we're gonna go with sheet one so we're gonna use that name basically and we're gonna grab that using following syntax and you remember this syntax probably from using a dictionary so this will give us this one specific sheet and all the information inside and we can also save that into a variable so let's actually call that product list so now we have read the whole file then we have read this specific sheet of that file and now we have all this information in that variable so now we can read any of those values and do calculations etc using that variable so let's get to our first task and the first task is basically to calculate how many products we have per supplier and then list the names of the suppliers with that respective number of products so let's go back and do that so the results what we want to get is basically products or number of products per supplier right that's basically what we want to get as a result so we're going to create that variable and we're going to set it to an empty dictionary so by the end our program should give us something like this a dictionary where the name of the company is the key and the value is basically product count for that company and since we have three suppliers or three companies we're gonna end up with a dictionary with three key value pairs per company so we're starting with an empty dictionary for products per supplier and now let's see how we can programmatically calculate this first of all what we need is we need to go through each of these lines basically so we have these rows so we need to go through each and every row in order in sequence and we need to get or check a supplier name for that row and you remember whenever we execute a logic on multiple values over and over again so basically same logic or same function gets executed for multiple different values for a number of times that's basically a use case for a loop right so we're looping through those rows and we're doing the same thing per row which is getting the name of the supplier now as you also remember loops have conditions right we need to tell the loop how many times it should execute that specific logic and if we check our file here how many times we want to execute the logic the answer is as many times as the number of products so if we scroll down we have 74 products so we need to do that 74 times for each product so basically as many times as the number of product and obviously we want this program to work for any spreadsheet file right with any number of products so we need to calculate or we need to read that value also from the file so basically we need to read how many products are on this list so let's see how we can do that first of all we're using for loop to execute the logic for specific number of times and if you remember from for loop syntax four then we have the specific item so what is an item in our case our item is a row right product row is going to be an item of iteration so looping basically so we can call our item products row and then comes in and now we need that condition how many times and again this should be generic so we need to calculate or we need to read the number of lines here number of rows here from the file and the way we can read that is remember we have all the information we need in that one specific variable which is product list and that variable has the value for number of rows which is called max row now how do i know that max row attribute is available for product list i basically just looked it up on the documentation of the module and as i previously also mentioned whenever you're using a module this module will have a documentation so if you need some functionality if you need some values you can basically just search inside the documentation which functions and variables are available to get the functionality or values that you need and we can actually test it we can print it out like this and as you see here 75 so basically max row will always give us the number of lines or number of rows in that specific sheet so we know how many times to iterate now whenever we're providing a specific number in a for loop like 75 for example in this case we need to put that number in a range like this so we can't just say 70 or in this case max row now why do we need a range here and why is number just not enough because the for loop is for iterating over a list and the range will create a list of numbers to iterate through in our case range of 75 will create a list of numbers or sequence of numbers from 0 to 74. and with that we're going to have a valid for loop where for each item in this list of numbers some logic will be executed so that's why we need a range here and now there's one more thing that we need to fix we go back to our spreadsheet you see that the first row so this is going to be the first row basically does not actually include the product information it just includes the titles for each column right so we actually do not want to read this line we want to skip it and we want to start from the second row so instead of starting for loop from the first row we want to start it from the second row and in order to tell python to start at row 2 in the range function we're going to pass first parameter 2. so basically this will give us a new range of numbers starting from 2 instead of starting from 0. and since we're using those numbers in the range as an index for the rows the first number is going to be 2 so we're going to start iterating from the second row so this will be the start point and this will be the end point so basically from here to the end now there are two things specific to a range that you should be aware of first of all when we do not provide the start index basically the start number in the range by default it's actually zero so it's not one but it's zero and obviously we don't have a line zero here so if we executed it with the default one we would get an error so that's one thing to consider that range actually by default starts at 0 and not 1. but for us it doesn't matter because we're skipping the first one anyways and we're starting from line 2 because our spreadsheet doesn't have line 0 obviously another specific of the range is that the second value here basically the last number of execution in the loop in our case this is going to be 75 because we have 75 lines and we printed that out here that number is actually exclusive it's not inclusive that means that the range will execute from line 2 to 75 exclusive so basically till here this line will not be included in the loop again that's a specification of the range which we need to fix and basically want to tell you know what we want that iteration including the last number as well including that max row and a simple fix for that is going to be to do plus one here so basically whatever the max row is we want to include that one as well so we want to add one to it so now we have a range starting from two and ending in 76 exclusive so obviously the 76th line will not be red and this will now give us a range that we need and now that we have condition for the loop and we have set how many times it should execute let's actually execute the logic itself so what is the first information we need from that product row for each row we basically need the supplier name so that we can increment or start counting how many products this supplier has so we need this one two three fourth column and the value in that fourth column for each and every row right let's go back to editor how do we get a value in the cell you have to imagine when we iterate we have one row per iteration so right here we actually have this product row which is just one row and we have four columns here and we want value in this specific cell and we can get it using first of all product list because again we have all the information here so in this list we need a cell right we need a value of a cell so that's the name of the function and the cell basically takes two parameters again product list contains the whole sheet here so the whole list with all the rows and columns and we can get a specific cell value so whatever we are doesn't really matter from that variable by providing two values the row number and the column number that's it so row nine column one basically will be this specific value row five column four will be this specific value so for each iteration we're gonna do exactly that so for our case the supplier is always column four and the row is dynamic because we are iterating and therefore we're going to use whatever row we're at at the current iteration so that's the first parameter and column 4 as i said and this will give us the supplier name for each and every row so we can grab that value like this and this is going to be supplier name so we can save it in a variable as a next step we're going to start building how many products each supplier has we're going to start building a dictionary with the name of the supplier and then how many products they have so we're going to be building this dictionary here so this is a reminder now for what i said previously that you don't need knowledge of math in programming rather you need logical thinking right so you're going to get tasks like this where you have to basically logically decide how you are going to do a certain task and think all this through right so programming is more about logic rather than pure calculation or math which is actually more interesting and cooler and that's exactly what we're going to need in this example we're going to need some logical thinking to basically build this application so bear with me on this one the first thing we need to check here so think about this iteration on the first time and second time the first time the list or the dictionary is actually empty so we want to add the first supplier to the list right away right so we're gonna grab that and the syntax for adding a new entry in a dictionary is like this where we have a key and a value here so basically what we want to end up with is supplier name like a company and number of products for that supplier that's the dictionary that we want to end up with then it's going to be bbb company and so on so the very first supplier goes directly into the list and we're going to need the name of that supplier we don't know what it's going to be so name as a key and value is going to be 1 at the beginning right this is the very first iteration so after the first it iteration we're gonna have the first company name supplier name and count one for that on the second loop second iteration basically if the next line is a different supplier like here for example then a new entry will be added because we have a new key now with count one right so now we're gonna have company a with one product company b with one product now what happens when on the next iteration we get company a again right what we want to happen is company a the product count to increase to two right because now we found another product that is supplied by the same company however with this land we are actually overriding and setting it back to one so how do we make sure that number of products gets incremented instead of always setting it to one what we're going to do is before we execute this line we're going to check is it a new supplier or an existing one because that makes a difference so how do we know if it's a new one or an existing one we can look that name up in the dictionary if we have already edited that name in the dictionary then it's going to be there and we can do that very easily again with the syntax if supplier name in the dictionary it's actually very readable syntax that says is the supplier already added to the list or is it a new one so if this is true again remember if conditional so if this is true statement if the supplier name is already there then it is an existing one so we need to increment the product number instead of setting it to one so instead of assigning a new value we want to grab that value the existing one and basically add one to it right just increment by one so getting a value from a dictionary you probably remember the syntax already using the key and we can save it into a variable let's call it current number of products like this remember we're using a key in order to get the value and the key is the supplier name value is the product count so this will give us the current number of products on the first iteration this will be one or after the first iteration we're going to have one product for that specific supplier and if we already have that supplier in the dictionary we want to increment the number of products for that specific supplier by one because we just found another product from that supplier so we want this value to now be plus one right so current number of products plus one so that's the new value that we want for the existing for this current supplier and how do we assign it back to the dictionary again we grab that and assign it so as you see taking the value from the dictionary has the same syntax as setting that value in the dictionary in fact we could actually use a shortcut here so instead of current numproducts we could just take that value and add plus to it and then set it back as a new value and this will basically just give us a oneliner for the logic depends on the taste whether this looks nice or not or whether it's better to have a new variable and increment the value like this let's actually leave it like this so this logic will take care of adding a product count every time we find another product for the same supplier however now we have to decide what happens when it's a new supplier so if this condition is false if the supplier name is not on the list and this is going to be the case on the very first iteration as well because the dictionary is basically empty so there are no supplier names and for that case else we're going to do what we had before which is just setting that number to one right this is going to be the first value so this will do two things basically it will create a new entry in this dictionary for this new supplier and it will set the product count number to one for that new supplier and that's it that's actually our logic and let's actually try this out and print it out so right here i'm gonna print adding a new supplier and this is going to happen three times because we have three suppliers so we can safely print it because just gonna happen three times there is one more thing we need to fix here and that is getting the value from the cell so if we actually execute this now let's comment this out and actually print out what the supplier name here is let's actually get rid of this line we don't need this and run the program you see here we have cell information so it's not actually the the value the name of the supplier but it's just the object cell and the reason for that is because we're accessing a cell but we're not actually extracting or getting the value out of it and we can do that using this value attribute on that complete object again something that you can look up in the documentation of this open pi xl module so now let's run it again and now we have the actual values of that cell and this will take care of that small problem and now we are ready to execute our program and after the for loop actually let's print out the dictionary because we want to see the results of the dictionary that we are building here and i'm going to execute it now and there you go first of all we have three times adding a new supplier because we have three suppliers and this is the resulting dictionary and it looks actually very good first we have company a because this was the first on the list and we have number of products that were counted for that company then we have the second one with number of products and the third one so it looks like our program did exactly what we wanted so that takes care of the first exercise now i want to note here one small thing which is an alternative syntax for getting values from a dictionary which is actually a more recommended way of doing it which is instead of having these brackets here to have a get method right to use a get function with the key name so now you see the difference between those two so this is setting the value of that key again remember key is this one here and this is the value so we are accessing the value of the dictionary using that key and get function is actually another way of grabbing this value out of a dictionary using the key name again if i execute this i should see the same result after the first exercise basically we see from which company from which supplier we have the most product or the highest number of products now in the second exercise we're going to calculate the total inventory value per supplier meaning in our list for each product we have number of units for the product and the price so basically for each supplier we want to calculate how much is the total value of inventory of their products of all their products and again as a result we want to create a dictionary that basically tells us that value per company let's go ahead and do that so this was calculation calculation for number of products per supplier and here we're going to give us some space and do calculation total value per supplier or total value of inventory per supplier that's what we want to calculate so just like we did before we're going to create a new dictionary now and we're going to call it appropriately total value per supplier and start with an empty dictionary again for starting in an easy way let's consider the first very first iteration for the first supplier how are we going to calculate for the first supplier for the first product so i'm going to take this new dictionary and with our familiar syntax i'm gonna do supplier name so that's gonna be our key and the value of the very first iteration for the first product is going to be inventory times price so for the first product we're going to calculate how much or how many of the product items we have and number of price right that will give us value of the total inventory for that one specific product and that means we need those two values right now we're just getting the value of the supplier so we need inventory i'm actually going to copy this so we need cell for product row and column inventory is on column two and value so whatever the product row is going to be so for each product basically for each row we need always the second column so all these values here and then we need price which going to be product list cell and we are looking for the third column for every row number three and value so now we have inventory and price per product and the way to calculate value is basically inventory that's the number of product items times price very easy that will give us the first value for the first supplier now again the same way if we are getting a new supplier so basically in the next iteration if it's a new supplier then this line will get executed and everything is fine however if it's an existing supplier that we already have in the dictionary then we have to add to that previous value right instead of setting a new one so we're going to do very similar logic as we did here so we have the supplier name we're checking is it a new supplier or an old one an existing one this time in our new dictionary and if it is we're gonna grab that old or existing value again using this get syntax here existing value now is hundred we want to add to that hundred right so we're gonna grab that value this is going to be current total value and then we're going to add to that current total value the inventory value for the current product and assign it back to our dictionary now our variable names a little bit long so the code kind of looks a bit cluttered but it's easy to read and descriptive so you can also go for shorter variable names to have a cleaner code again matter of taste i usually name the variables something descriptive something that basically really differentiates or says what the value is about and that basically takes care of existing suppliers or the suppliers that we already have in the dictionary else we do this and this is complaining about too many blank lines so let's fix that and that's basically our logic again to go through it once for new suppliers again this is going to happen three times because we have three suppliers we are basically setting the total inventory price or inventory value for that specific product because remember we are iterating through products and then every time a new product iteration happens for the same supplier we basically just add an inventory price or total value for that specific product for what we already have in the dictionary for that specific supplier so now let's again print out our dictionary let's actually print both values so the first dictionary is this one right here supplier and number of products second one is going to be supplier and total value of all the products they have in the inventory with us execute and there you go we have both dictionaries printed here and here you see for each company we have the value in price basically right here the value for the total inventory of all the products they have on this list and we see that value per supplier and the values are decimal numbers with cent precision so 95 cents 47 cents because the prices are obviously like this as well and if you're wondering this comma here is actually a german format for number precision so this is going to be actually equivalent to english dot and we don't have to worry about this actually because python reads it and interprets it correctly so no problem with different language formats so that takes care of our second calculation now the third logic we're going to write is basically printing out all the products that have inventory less than 10 like this ones here for example so the logic for that is actually going to be pretty easy what we need as a result is again a dictionary let's call it products which have inventory under 10 like this and the value in the dictionary should be the product number which we have in the first column and the inventory count so let's get rid of these print statements and let's do calculation or we can do logic products with inventory less than 10. so basically as i said for each product which has inventory under 10 we want to print out or we want to save in a dictionary the product number and the inventory count so we have the inventory count already the value from the cell but we don't have the product number we're not accessing it so let's actually do that product number and we already know how this works this is going to be the first column right this one here and this gives us product number and now in our dictionary products under 10 we want to add value like this product number and it's going to be set to value of the inventory like this however we don't want it for every product we wanted only for products with inventory less than 10 and that's going to be an easy if conditional here if inventory again remember this logic all this logic happens for each product row right so all these get executed for each of these rows so basically we have inventory number on each iteration for each specific product and that's why we can just say if inventory is less than 10 so if the value on that specific row is less than 10 we want to add that product the current product that we are iterating on on the list and set the value of inventory as well again we have some complaining here because of the lines and this will be the logic basically and a use case for this type of calculation would be if we find products that have inventory which are less than 10 means we need to reorder them right because they're going to get out of stock soon and now at the end let's print the list of all the products that have inventory less than 10. so i'm going to execute it and here we have the product number and inventory count so we have three products basically which have inventory less than 10 and let's actually check that product number 25 right here which has inventory of seven and product number 30 inventory of six and the third one as well now you're probably wondering why we have this dot zero here because by default those values are interpreted as float numbers and not integers if we wanted to we can actually fix that using the integer function in both cases like this let's execute it again and we have the integers and not floats and finally as a last exercise what we're going to do is we're going to actually add some value inside that spreadsheet till now we have been reading the values and doing some calculations and just printing the result on the terminal as the last exercise we're actually going to create a new column here for every row and we're going to calculate basically the total price of inventory right the number of units times the price and we're going to basically set the value for each product inventory multiplied by price so how do we add a column or how do we make changes to a file it's actually pretty easy the same way as we were grabbing the value from this file and basically reading the values we can add values to it and add columns and rows etc so to add a fifth column we're gonna do product list cell product row this is going to be the number of the row and a column number so the same way we accessed the cells for all other values we can basically access the cell on column five which has an empty value right so we're not actually creating a new column we're just grabbing a value of a column five which happens to be empty and we are overriding that value and we could do the same actually for any other columns here right we can overwrite all these values if we wanted to so that's basically what we're doing so we're grabbing that cell and we can now save it into a variable let's actually call it inventory price so now that cell is saved into that variable so we can reference it and note here that i didn't add dot value at the end because if we want to update the cell we need the whole cell object right so that we can actually set a value on that so how do we set a value for that specific cell so again note that this is iteration so for each product row the value will be set so how do we set the cell value i'm just going to grab this variable here inventory price which is representing the cell in column five for each iteration and right here at the end because this is our last exercise let's write this is a logic or basically add value for total inventory price and the way we set the value in a cell is dot value equals and the calculation for that is actually very easy we already did it here inventory times the price for that specific product and that's it so we're using that dot value here in order to set the value instead of grabbing the value and that will actually update and add this calculation a result of the calculation on each line on this column but note that this will only change the value in a temporary file but it's not going to save anything right so what we want to do at the end if we want this change to persist to actually be saved we want to explicitly save the file so for example if i manually did something here added some value i would need to save it here as well right so that's exactly what we need to do here but programmatically using python so how do we save a file using python again this package or this module that we use here also gives us a function that we can use to save the file and since we're doing an operation on a file and not a sheet here we're going to grab that variable in file and here at the end we're going to call a save function on it and this will save the file changes however we're not overriding the same file the existing inventory file we're creating a new one and because of that we need to provide a name of the new file that is going to be created with the save function and we're going to call that file let's say inventory with total value and extension the same extension as we have here so this line will now save the changes and create a new file from the original one which has these values generated basically so now that we are done with the fourth exercise let's actually print out everything that we've done so far i'm gonna take all those values so this is going to be execution of all our logic printing these three dictionaries here and then updating the spreadsheet file and saving it into a new file so with this let's actually execute our program and see what happened first of all we have all those three dictionaries listed here or printed here with the values and if we pull this aside here you see a new file got generated with the name inventory with total value and if we open this file we should see that for each row a new column was generated and filled with values which is calculated for each product's inventory and price so that's basically our project that's how you work with files in python specifically with spreadsheet files and as i said at the beginning this could be actually very useful automation logic when you're working at a company where there are lots of excel files or spreadsheet files that employees have to work with and manually update stuff inside in this part we're going to learn the concept of objects and classes in python and generally object oriented let's consider an example of an application with lots of users for example linkedin right we have users and each user will have some information for example email address name of the user password maybe a current job title work experience a set of skills and so on right so each user will have all this information but obviously the actual values the actual information will be different for each user in addition to that users are able to do something with their own information right so for example a user can change their password change their current job title add a new skill and again basically do stuff with their own personal information and our program will be able to handle this user information plus user changing their information right so this will be user data and in order to do something so to perform some action we would have functions for that right so all of these will actually be functions however as i mentioned every user will have their own data and whenever a new user basically registers for an application all these data should be gathered for that new user and saved in the application so basically that means that in our program we need some way to define kind of a blueprint for a user for all the data user information and user behavior right things that the user can do in the application because if we have thousand users in our application obviously we can't write the same logic and same variables thousand times right we want to have a blueprint once and then we can use the blueprint for all those thousand users and that blueprint for a user is called a class and the specific implementation of that blueprint is called an object so think of this like a blueprint of a building right you can have a blueprint once which is like a general description of building with doors and windows and everything that every single building has and then the specific implementation of that blueprint will be the actual built ready buildings right so that's the same concept we're going to create a class blueprint for a user and the user class blueprint will define what information a user has and what actions user can perform in the application and object then will contain the actual information like this information right here for each specific user so let's clean all these up and let's now actually create class user so let's create a new file in our project and let's actually call it user dot pi so this is going to be our user class and inside that i'm going to paste in this piece of code that basically will represent data for the user and some behavior these pieces of data are also called attributes for that class so now let's turn all of these into a class so first of all we create a class using class special work and you also see the syntax highlighting and we're going to call that user and you know the syntax already for functions um etc with indentation so this is going to be where our class definition goes now note here the capital letter for u for user and lowercase user in the python file name so a standard convention is that we call classes with a capital letter and the file names are written in lowercase letters and now all of these should actually go inside that indentation right like this now we said that class is a blueprint for specific objects and blueprint cannot actually have specific values right so all these needs to be removed so in the blueprint we don't have any specific values we just have the attributes so basically we say this user will have an email name password and current job title the actual values of those attributes will be then set when we create an object from the blueprint however we need a function that will actually take those specific values and assign them to an object which is created from the blueprint and we're gonna create that function right here in the class and that function actually is called init with underscore or two underscores at the beginning and at the end a couple of notes here first of all you see the syntax highlighting just changed to this different color second note is that these functions that start with underscore in python are special functions so python basically gives them some special meaning so it knows exactly what this init function is and we also have to call it init we can't just call it whatever we want and final note is that this init function in python is something called a constructor again we have a blueprint and we're constructing objects from the blueprint and this init function the constructive function will help us construct objects from that user class and now for a function syntax you know that we use these brackets right and when i start writing the bracket you see that self got automatically created as the parameter here and the reason is as i mentioned python knows what the init function is and that it's a constructor so it knows that it needs this self as a parameter again self is also a special word in python it has a special meaning and it actually refers to this class here right this entire class if i hover over it you see self points to the user class and it will basically just help us access and reference all the attributes and functions within that class so it's for special usage within that user class and we're going to see examples of how to use that in a second now you can think of those attributes as variables within the class because they belong to the class right they describe basically what attributes or what characteristics this class has and in order to define that these variables belong to the class we need to use self here so and you see again syntax highlighting changed and the red line disappeared so basically we are defining that email name password and current job title belong to this class using this self keyword and now the last thing remaining in this constructor again remember constructor is to construct new objects so whenever a new object is created the specific values will be assigned to all these four variables right and those values those specific values will be passed into the constructor as parameters so email name password and current job title those four values must be provided to the constructor whenever we're creating a new object note that these names here could be different from this these are not the same these are just parameters and using these parameter values we are going to basically set the variables or attributes of the class like this and the warning is gone as well again as i mentioned this could be something else we could call it user email so it doesn't actually have to be the same it's just for convenience so this function will construct an object with parameters that we provide when we actually create it and we're going to see how to create an object later this is just the definition as remember when you define a function nothing actually happens until you call or you use that function so right here we're just defining that function so that we can use it later so constructor logic is done now we have these two functions that any user in our application can do right any user can change their password or change their job title and logically when change password happens by user basically user provides a new password in order to override the old one so the flow will be following the object will be created for the specific user so the initial data for that object will be provided so we'll have the user email name password and current job title and later at some point user may decide to change their password and their current job title and that means the initial data will be changed and that means that we're actually changing the attributes self.password with a new password right so logic will be like this now we have red lines here why because we need this self as a parameter first of all we also have that as um note right here so just like here we need to actually pass that self as a parameter that's just how it is because we need to access attributes of that class in that function and new password will be new password variable will be the new password basically that user wants to set so this will change the initial password with the new one and the same way in change.title we have self as a first parameter we always need it in all the functions because otherwise we cannot access the attributes in the class and new job title so now let's review this class that we created first of all we have this class keyword here with a capital letter for user you already know the syntax with colon and then indentation so this all of these inside this indentation is class body so part of the class logic first we have this init constructor that sets the initial values of that class attributes whenever we create a specific object for that class right so this happens only when we construct a new object and then on that constructed object we can change password we can change job title and note that right now we have nothing basically hard coded we have no specific values here right everything is just parameterized and also this is just a definition for class and its functions nothing will actually happen when we execute this because we're not creating any user objects so if i right click here and execute this run user you see that nothing happened because the class definition was created but we're not doing anything with that class definition we're not creating new users so now let's actually go ahead and do that in the same file in user.py i would actually use that class blueprint to construct a new user object and creating an object from a class is actually very simple we just write name of the class and parentheses this is actually the same syntax as calling the function with parameters and the parameters that we need to give that class are these four values here and note that calling this user class function basically in the background we'll call init function right so the constructor will be called whenever we write this syntax with class name and parentheses and this init constructor as you see expects four parameters so we have to provide all those parameters right here in the parenthesis so let's actually provide them let's do user email like this my username and password and a current job title again very similar to calling a function and this will actually construct a new object from the user class which has these four attributes with values that we just provided here and has these two functions that we can use to either change a password or change job title one note here is that functions that belong to a class are actually called methods so there's a special name for functions which are part of a class so we can refer to them as methods so user object basically gives us two methods that we can use now again if we execute this program now we will not see anything even though user will be created because we're not printing anything to the console we're not doing anything so let's do that run user nothing happens because we need to print a message or some kind of information so what i'm going to do now is inside that class i'm going to create a function or a method as we learned now that basically prints back some user information right prints me the name email and current job title because we don't want to display password so let's give us some space here and let's create a function called get user info so that we can see something and again as soon as i typed in these first parentheses self got generated because we need self in every function within the class and in the function body we're gonna print user information so let's say user and name of the user which we can access using self remember all the attributes that the object has can be accessed with this special word here so self dot name so user whatever the user's name is currently works as a and now we need the job description or job title and you can contact them at and now we can use the email so this message will be printed for the user again because this will be used for any user of our application the message these parts will be the same but each user will have their own different name different job title and different email address so all of these are and written as variables because we don't know these values up front so now we can actually use this function or method to print out information of a specific user so how do we use or how do we call that function of the user we first save it into a variable app user one or nana doesn't really matter let's call it app user one so it's generic so how do we use that function to print out the information about the user if i do app user one and dot you see that i have the attributes here the four attributes that our user object has or user class and we have these three methods of the class get user infor change job title and change password so using get info we can call this function and if i execute this right here you see user nanogenasia currently works as a devops engineer you can contact them at this email and now let's say we want to change job title of that user we do that in the same way app user one dot change job title and we're gonna provide the job title parameter note that even though you see two parameters here on that function this first parameter is passed in automatically so we don't have to basically pass that self right it's already done automatically we just have to worry about these parameters so new job title is let's say devops trainer and now we can call that user info method again and execute and you see first message printed here before we change the job title now it's devops trainer so that's how we can create a new object from a class and we can use methods of that object by first saving that object into a variable and then calling that function on that variable and obviously now this is just one user but if we had another one user two that's actually clean this up we can create a new user with different values like this they have their own email own name own password and on job title and again we can create that user and basically just use the methods defined in the class and in two different cases or for two different users obviously the user info will be different so let's execute this and right here you see the user information for both users and obviously if you have an application like linkedin you don't have two users or a thousand users you probably have millions of users and having a user definition once and reusing it every time a new user gets created or basically existing users do something in application is only possible when using classes and objects instead of just having all these logic nonstructured throughout the code and again in this type of applications you would not have four attributes and three methods you will have probably hundreds of attributes and hundreds of such methods now as you see here we have created this user.pi file for user class but we're also creating these objects in the same file which actually doesn't make sense because the file should be only for defining the class right so all of this logic actually needs to move out from here and this should be just only for class definition so in the application again using an example of linkedin we would have class user and then we would have a class post right whenever someone posts something each post will have their own attributes like the actual message or text in that post the author who wrote the post how many likes it has etc as well as specific functions right for example changing the post commenting on the post etc so you will have separate file for each such class right in the application and then you would have one file somewhere else this could be a main dot pi where you would actually use all those different classes and create objects from those classes and that means that logic that we wrote here constructing a user object and then calling some functions on that will actually happen in another file in our case let's use main.pi and now let's see how we're going to do that i'm going to paste in the code that i copied from there and as soon as i paste in you see those red lines so basically main.pi says that it cannot find a reference to user so this file doesn't know anything about the user class so how do we fix that or how do we make this user class available in another file and if you remember when we needed to use modules or basically functions variables whatever from other files in python we use import to basically import those functions and make them available here or import the whole module to make its functions and variables available here and the same way we can import classes from another file import user and note here that i'm using the name of the file user lowercase and not the class name with capital user right so we are importing that file so now we can use anything that is defined in that file and one of them is class called user and the way we can access that class now is using the name of module and not the class user itself and this is basically exactly the same concept as we saw before because we are importing a module called user remember every python file that has functions or variables or classes inside is a module so we are importing a module and once we have that module imported now we can use and access functions variables or classes of that module and we can do that by copying the name of the module dot and there you go in the same way here so exactly the same concept whether this is a function or a class doesn't matter we use it the same way remember when we use the date time module with the syntax datetime.daytime and that was an example of using a class from a module now user.user may look a little bit weird so we can use our familiar import statement where instead of importing the whole module we can pick and choose and import specific definitions or specific elements of that module in our case we just have one element which is the class so we're going to say from user module import user class and now we don't need the module name anymore because we imported the class itself and now if we execute main dot p y let's do it again here we have the same result for two of our users and again as i said in applications you will have multiple classes that are connected to each other so for example if we have a post here post blueprint basically whenever a new post gets created with some specific values like the actual message and creation date time etc it will also have an author and that author will actually be one of those user objects right so you will have some functions here that actually reference the post and we can also see that in action let's actually create a post class let's give it just two attributes to keep it simple so we need a constructor here in it and we're gonna pass in message and author right this is gonna be the user who wrote it and you know the drill already and let's create another function which displays a post with its respective author so let's do get post info again we have self here and let's print post written by and the author name so this is going to be our simple post class and user is able to create new posts so we have the blueprint for a post and the same way we can create that post inside the main dot pi so first let's import the post class and then here we're going to create a new post in pycharm you get this nice display of parameters that function or class basically expects so we have message and author let's do some message or post and as a second parameter we have the author and we can use the name of a user so let's do app user to dot name and this will create an object also called instance in programming special instance of that post class and then we can print the information of that post first assign it to a variable let's say it's a new post and on a new post we're gonna call get post info let's actually run this application now and see the result and here we have our post message that gets printed by this get post info method in the post class and at the beginning i mentioned object oriented programming which basically means that when you're writing your code with objects and classes like this to create blueprints and then use those blueprints for specific instances that's called objectoriented programming and also an interesting note here is that in python almost everything is actually an object for example the data types like string integer list set etc when we printed them out we saw class of string or class of list so these data types are also classes in python and this int or sdr for string functions we called where actually the constructor we called to create a string or integer object and the constructor of int for example took a string representation of a number and in its init function and constructed an integer out of it now for us in terms of using these data types and variables etc it doesn't actually matter but it's just an interesting thing to know about how this whole thing works in python in this part we're going to learn how to use python to talk to external applications in our case we're going to use gitlab and then application and just note here that communication between two applications in our case our python application and a gitlab application usually happens using a common protocol like http so basically our python application will send an http request to gitlab application and from the gitlab application it will get an http response for that request so just know that http is just a protocol that these two applications can communicate with over the internet i have a couple of projects on gitlab so we're gonna write a very simple python application that basically goes to gitlab and asks for the list of projects for my user and then just prints it here in our run window and the concept of one application talking to another is basically done using something called api requests so the remote application in this case gitlab has an api so these are functions basically that gitlab makes available for other applications to call and we're going to call those functions from our python application in order to get the list of projects for my user and that communication or python basically asking for this information is going to be an api request or api call and what we get in response from this gitlab api is going to be api response so let's go ahead and do that in python in order to make those external requests to remote applications we're going to need a module called requests this is a generic module that you can use for any external application and as i mentioned at the beginning the communication happens using http protocol between two applications and as you see here also in the module description it says an http library which allows you to send http requests and then receive http responses from another application and that's exactly what we're going to be doing and this request module is not part of python so we're going to install it using pip again remember that we're using pip that actually comes packaged with the pycharm so in the terminal window of my ide of pycharm i'm going to execute peep install requests successfully installed request this is the version of that module and if i expand this external library's site packages i'm going to see the requests package in the list great so once we have the module available locally we can import that module in our file and this requests module now has or package actually has functions variables and objects that we can use to talk to these remote applications like gitlab as i said gitlab is just one example you can talk to any remote application that has an api and we can not only do requests for getting the existing information but we can also make requests to change something in that remote application so for example i can write a python application that will actually create a new project on my gitlab account but to keep the demo simple we're just going to be fetching information from gitlab so how do we make requests to an api of an application with this requests module we get a function called get and get takes one main parameter which is url so basically we need to tell python where to find that remote application or again in our case where to find gitlab to talk to it so we need the url of gitlab and where do you find this url information of a remote application you can basically google that every application has their own documentation where you can see the urls so for example for gitlab i actually googled it so if i do gitlab api documentation like this let's make it bigger so you have basically description for the api and what type of information you can get from gitlab and also what kind of things you can create in gitlab and you see an example api here that basically just lists all the projects however we want to list projects of one specific user in this case i want to list my own projects and in this documentation i found this list user project section where i have an example of how to use projects for a specific user so we have slash users and the user id so that's going to be my gitlab user id and projects so basically the url will now look like this first we're gonna have this base url so that's basically https gitlab.com api v4 and all the things that we want to do is going to be at this base api and after that we can basically depending on what exactly we want to do we can choose one specific action and again going back this is the action we want to execute on this base url so from gitlab we want projects that belong to user and right here i'm going to add my own gitlab user id so if you have a github account you should add your own user id here and that's going to be an api url for user projects and this will actually give us some kind of response so requests.get will make that request to gitlab and it will return some kind of response and we can save that response into a variable so let's call this variable response because that's what it is and on the next line let's actually print and see what's in that response let's run our application and right here you see we have an object response with a code here 200 is a code for a successful request but we're not seeing the actual contents right we want to see the projects with their details and in order to get that we're gonna do dot and text and let's actually execute this now and now you see these square brackets which means it is a list because we have a list of projects and this whole bunch of information about projects there and you also see curly braces so this is a list of dictionaries and each dictionary holds information of one specific project now if i actually print the type of that response text like this see that it is a string so even though we see the format is actually a list of dictionaries we're getting a string because we're accessing text attribute now there is actually another attribute which will give us the same thing but as an actual list of dictionaries instead of string and this will be actually a better way to get that information because then we can work on it so we can look through it and get the individual elements and access the values so what i'm gonna do now instead of dot text i'm gonna use json json is a standard format that all programming languages understand and usually when two applications communicate with each other which are written in different languages and with different technologies with json they have a common format for communication and this requests module basically gives us this json function to read the json format that gitlab sent us so json function will read the json response from gitlab and turn it into one of the python data types so i'm going to execute this now and now you see that response.json actually gave us list data type instead of string so again for demonstration since this is a list i'm going to access the first element of that list and print that out and right here you see that is actually the first element just the first one from the list and that element is a dictionary as you see so all these just to give you an idea of what we're getting back from that gitlab api and what we can do with that response or how we can actually work with that response so i'm gonna clean all this up and we saw that response.json gives us exactly what we want and that is a list of my projects so let's call this variable my projects and now what i want to do with this is i want to print out in our window for each project project name and project url so basically the repository url for that project so i don't want to have any other values like id or description or whatever other stuff i have in this dictionary i just want name and project url for every single project and i want that information printed out in this window so how do we do that we have a list so we're gonna loop through that list to access each element inside that list so you remember we have for loop to loop through or iterate through a list and give us access to each element one at a time so here i'm going to write for loop and if you remember the syntax of for loop we have four and then a variable which will represent the single element in that list and in this case it's going to be a project a single project and then we have in list so for project in my projects do something so for every project element in this my projects list we want to print out the name and the url so right here i will do print and let's do our formatted string here and let's start writing our message let's do project name and the project name will be this one right here now how do we actually access the name of the project in each project element as you see here these project elements are actually dictionaries and how do we access a value in a dictionary using the name of the dictionary in this case our variable project so this whole thing is going to be saved into a variable called project and then on that variable on the dictionary we're going to pass in the name of the key which is name now i've been using double quotes throughout our project and for a syntax for dictionaries as well like this right however here we have a small problem which is we have double quotes inside the double quotes but as you remember for string representation we can actually use single quotes as well as double quotes and this is one of the really important use cases for why we can actually use both single and double quotes for a string and that is if we have a string inside another string like right here we can actually use that interchangeably so that we don't have this problem here so now as you see back to normal everything works because now python knows okay this is another string which we're using inside this string so we can use these interchangeably as we want so this could be single quotes and this could be double quotes wouldn't really matter but that's a really good use case why we need both types of quotes so we have the project name now we need a project url and let's see where the project url is in our dictionary this is one element one dictionary right so i'm gonna scroll it to the left and we have web url this is what we could use or we could also use http url to repo let's go with the web url so again this is a key inside the dictionary so we can access the value so this is actually the value we need and we can access that using the dictionary name projects and the key name which is web url and this is actually project not projects and this code will now print name and url for each project so let's actually execute our program and as you see we have project name and project url for each project we can make the output a little bit cleaner let's do a new line here and a new line here so we can separate the projects from each other and run again and there you go this looks a little bit cleaner for each project we have a name and a url so if i click inside i'll go directly to this project so that's basically a very simple example of how to use requests module to talk to external applications or external urls and then do something with the response that we get from that external application by first converting that into an actual data type that we're getting using json function so in our case it was a list and that's why json function actually converted it into a list if the response was a dictionary instead of at least then json would convert it into a dictionary and then we can do something with that response value congratulations you made it till the end i hope you learned a lot and got some valuable knowledge from this course if you like the course please leave a thumbs up on this video on my channel i actually cover lots of different devops topics like docker ci cd terraform and more so be sure to check out my tutorials if you're learning python to become a devops engineer i actually have a complete devops bootcamp with all the technologies you need to learn as a devops engineer which also includes a module for automation with python with several cool demo projects to automate some common devops tasks like application and server monitoring cloud automation tasks with aws jenkins etc so if you're interested check out more info in the description also happy to connect with you on social media so i would love to see you there with that said thank you for watching and see you in the next video
