With timestamps:

00:00 - so in this video we will learn about one
00:02 - of the popular devops platforms called
00:05 - azure devops we will see what it is and
00:07 - what you can do with azure devops
00:09 - platform how to use it for your software
00:12 - development projects and generally how
00:14 - is this relevant for you as an engineer
00:16 - we will see different features and use
00:18 - cases of azure devops how it all works
00:21 - and how you can implement the whole
00:23 - software development and deployment
00:25 - lifecycle with it we will also review
00:27 - the azure devops architecture and how it
00:30 - works in the background and finally we
00:33 - will also compare it with alternative
00:35 - tools and talk a bit about which of
00:37 - these tools you need to learn for your
00:39 - career with so many alternative options
00:42 - so let's get started so first of all
00:44 - what is azure devops as the name
00:47 - suggests it is a devops platform it is a
00:51 - software as a service offering which was
00:54 - created to basically be a one-stop shop
00:56 - for implementing
00:58 - all your devops processes for your
01:00 - project and it had many names before it
01:02 - became known as azure devops it was
01:05 - called team foundation server then
01:08 - visual studio team services so it had a
01:10 - bunch of other names before azure devops
01:12 - because it extended from existing
01:14 - services and tools so it kind of got
01:17 - names of these tools and even though it
01:20 - was for the same purpose of implementing
01:23 - the devops processes at that time devops
01:26 - was still practiced by a smaller group
01:28 - of projects so that's why the name
01:31 - devops never actually came up in the
01:34 - name of the platform itself however
01:36 - since devops became more mainstream and
01:39 - as it is now used
01:40 - in
01:41 - lots of projects worldwide it was
01:44 - actually renamed to azure devops which
01:47 - is pretty smart because devops is
01:49 - already a popular term everybody knows
01:51 - what it is so just by the name you know
01:53 - that it's a platform for devops but it
01:56 - still sounds too general because what is
01:59 - a devops platform devops is many things
02:01 - right
02:02 - so what is a platform for devops and to
02:05 - answer that question let's look at what
02:07 - azure devops is exactly and how it helps
02:10 - in implementing devops processes well
02:13 - devops as i said is many things it is a
02:15 - combination of concepts and tools and
02:19 - basically anything that makes developing
02:21 - and releasing applications fast in an
02:24 - automated way and with high quality
02:26 - possible so a project needs to implement
02:29 - devops practices in order to achieve
02:32 - an efficient workflow if you want to go
02:35 - more in detail about devops and learn it
02:37 - in more depth all its tools and concepts
02:40 - etc i actually have a separate video on
02:42 - that but shortly explained it's to make
02:45 - the software development lifecycle as
02:47 - efficient as possible by fully or mostly
02:51 - automating it and azure devops is
02:53 - basically a technological implementation
02:56 - of that devops process which covers the
02:59 - whole software development lifecycle and
03:02 - it has features for each part of this
03:04 - lifecycle so let's go through the steps
03:07 - or parts of that software development
03:09 - lifecycle and see how the various azure
03:13 - devops features map to those parts
03:20 - now what does a software development
03:22 - lifecycle include
03:24 - it's not just developing the application
03:26 - or writing the code it actually starts
03:28 - before you have
03:30 - written a single line of code
03:32 - because before coding any feature or an
03:35 - improvement needs to be planned first
03:37 - right mostly by a product manager so the
03:40 - first step is to define what we are
03:43 - developing and why are we developing it
03:45 - or in other words what's the business
03:47 - value behind it and there are several
03:49 - ways of defining the workflow of how the
03:52 - project team will work on the
03:53 - application which roles they have within
03:56 - the team how they will divide and split
03:58 - the tasks etc
04:00 - two of the most popular workflows are
04:02 - agile and scrum many modern projects use
04:06 - one of these approaches for their
04:08 - development so once you have created a
04:10 - project in azure devops for your
04:13 - application
04:14 - the first feature you will probably use
04:16 - here will be azure boards and depending
04:19 - on which workflow you use for your
04:21 - projects in your company generally like
04:24 - agile scrum or even some basic workflow
04:27 - you can choose the corresponding board
04:29 - for this project because as i said azure
04:32 - devops or any other similar platform is
04:35 - basically just a tool that gives you
04:37 - various features to implement whatever
04:40 - workflows you have in your company
04:42 - so on azure boards you can create
04:45 - tickets or tasks for features
04:47 - improvements or fixes for your
04:49 - applications as part of that agile or
04:52 - scrum processes you can assign it to
04:55 - people to work on and you can also track
04:58 - progress of those features or
04:59 - improvements while they are being
05:02 - developed now developers need to take
05:04 - that planned task and actually develop
05:07 - it right in that process they may have
05:10 - questions about the task so azure boards
05:13 - can be used for communicating between
05:15 - the developers testers product owner etc
05:19 - within the task description plus it can
05:22 - be used to have an overview and
05:24 - transparency over the status of the
05:26 - feature as it is being developed who is
05:29 - working on it what stage it is in what's
05:32 - its progress status has it been deployed
05:34 - already etc
05:38 - now the application code that developers
05:41 - are creating is also part of that life
05:44 - cycle actually the main part of it
05:46 - an azure repository feature is what you
05:50 - can use in order to host that code
05:53 - now of course you know the popular code
05:55 - repositories like github gitlab
05:58 - bitbucket etc which are all based on git
06:01 - and that's basically an alternative to
06:04 - those platforms so editor repository
06:07 - also supports git which is the most
06:09 - popular version control tool so
06:12 - developers can host their code in azure
06:14 - repository and push their changes to it
06:17 - however the code repositories have
06:20 - actually evolved and became much more
06:22 - feature reached and just hosting code is
06:25 - one of the many features that they
06:27 - provide so azure repository also it's
06:29 - not just for hosting the code as part of
06:32 - the devops life cycle developers
06:34 - collaborate and work together to develop
06:38 - high quality code so in the repository
06:41 - as part of the git workflow
06:44 - you have features such as pull requests
06:47 - branches
06:48 - various collaboration features and so on
06:51 - so when developer starts a task they
06:54 - create a temporary branch when done they
06:56 - create a pull request and other
06:57 - developers can review and comment on the
07:00 - pull request they can communicate and
07:02 - collaborate until the pull request is
07:05 - good enough to be merged into the main
07:07 - branch
07:08 - now this is what's called a git workflow
07:11 - so basically how your team decides to
07:15 - work on the code and to make sure that
07:17 - the quality of code is very good
07:20 - and there are many git workflows or the
07:22 - way teams use git and all its features
07:25 - and different companies may use
07:27 - different approaches or different
07:29 - workflows but the key point here is that
07:31 - with azure repository you have the tool
07:33 - that enables you to implement whatever
07:36 - git workflow you choose to work with
07:40 - plus note that the repository and
07:42 - branches and the pull requests are all
07:45 - linked back to the feature task so you
07:48 - see the activity and status of
07:50 - development
07:51 - there as well
07:55 - now once the feature is developed and
07:58 - pull request is approved and merged into
08:00 - the main branch it needs to be released
08:03 - right that's the reason we're developing
08:05 - the feature in the first place so we can
08:07 - release it and the end users can use it
08:10 - so in order to release our code changes
08:13 - we first need to test it and package it
08:16 - into an artifact which is a deliverable
08:19 - that we can then deploy on the end
08:21 - environment and again devops is all
08:24 - about automating things and workflows so
08:27 - that it's fast and efficient so this
08:29 - process of testing and building the
08:31 - application is done by an automated ci
08:35 - or continuous integration process and
08:38 - for building the ci pipeline azure has
08:41 - what's called azure pipelines section
08:43 - pipelines can be written in yemo which
08:46 - means you can have your pipeline script
08:48 - as part of your code
08:50 - the main building blocks of azure build
08:52 - pipelines are steps for example if we
08:55 - want to test and package the application
08:58 - we may have steps to run tests package
09:01 - application build an image push that
09:03 - image to an image repository
09:05 - so that later it can be deployed so each
09:08 - step will execute a certain command
09:11 - to run the test to package the
09:13 - application build a docker image
09:16 - and so on and this is an example
09:18 - pipeline for building a.net application
09:22 - which is a common type of application
09:23 - built on azure devops platform since
09:26 - asp.net is also part of the microsoft
09:29 - technology stack in the first two steps
09:31 - in this pipeline we test and build the
09:33 - application with net commands and then
09:36 - build the image with a docker command
09:38 - and as you see we execute commands in
09:41 - script attribute
09:43 - however we have another option for
09:45 - executing step commands instead of
09:47 - scripting it directly in yemo ourselves
09:51 - so in addition to writing the scripts
09:53 - yourself you can use what's called a
09:56 - task instead
09:57 - so what is the task and how does it work
10:00 - in azure devops you have loads of tasks
10:03 - already available to choose from
10:06 - for different use cases
10:08 - and they can be selected and configured
10:10 - using a ui
10:12 - you can select the tasks directly from
10:14 - the list of available tasks on the right
10:17 - side of the pipeline's yaml editor and
10:20 - configure any needed parameters for the
10:22 - task and when you have the task
10:24 - configured basically you fill in and set
10:27 - all the parameters you can add the task
10:30 - back to your yaml pipeline it will be
10:33 - automatically converted and edit as yaml
10:36 - code and of course you can adjust or add
10:38 - any additional configuration to it
10:42 - so here for example if you look for
10:44 - asp.net task you will find one
10:48 - for executing various.net commands like
10:51 - test build etc
10:53 - and once configured you can add the test
10:56 - task in place of the script you can do
10:58 - the same for docker
11:00 - you can search for docker tasks and find
11:02 - the one with build and push commands and
11:05 - add that task to your yaml pipeline and
11:09 - this obviously can be convenient in many
11:11 - use cases because you don't have to know
11:14 - the commands exactly you don't even have
11:16 - to know or memorize the exact syntax for
11:20 - the pipeline and you also don't have to
11:22 - script the steps from scratch so this
11:24 - basically gives you a simple um an
11:27 - easier high level approach to adding
11:29 - steps to your pipeline now this is a
11:32 - very simple scenario of a pipeline with
11:35 - one single job that has all the steps
11:38 - but in practice we often have more
11:40 - complex scenarios where we would need
11:42 - multiple jobs in a single pipeline let's
11:45 - say we want to execute the test step on
11:47 - two different operating systems we want
11:49 - to test the application on linux and
11:51 - windows before we build it
11:53 - or let's say we test and deploy our
11:56 - application on linux machine but we need
11:59 - a database for our application which
12:01 - must run on a windows machine for this
12:04 - use case we would need two separate jobs
12:06 - now i'm mentioning jobs but we haven't
12:09 - seen a job defined in our simple
12:11 - pipeline yet so what is a job exactly
12:14 - well all these steps actually belong to
12:16 - one job and can be defined like this so
12:19 - a job is basically a group of multiple
12:22 - steps however when we have only one job
12:24 - in our pipeline we don't need to
12:26 - explicitly define it that's why we could
12:28 - skip this in a simple pipeline but when
12:30 - we have multiple jobs we need to define
12:33 - them within
12:34 - jobs attribute so we have multiple jobs
12:37 - each with multiple steps and now we can
12:40 - actually execute
12:41 - each job so all the steps within the job
12:44 - on a different environment also called
12:47 - an agent so agent is a machine that will
12:50 - execute the tasks or the steps of the
12:53 - pipeline like running the test building
12:55 - an image etc and an agent is selected
12:58 - from an agent pool like pool of windows
13:01 - machines or linux machines or mac os
13:04 - machines etc
13:06 - and that's why we have a pull attribute
13:09 - in the job to define what kind of
13:11 - machine we want to dedicate for that job
13:15 - and as you see inside the pool we can
13:17 - define if the end image that specifies
13:20 - what kind of operating system we want
13:22 - and you can also specify what version of
13:25 - that operating system you want to run
13:27 - that step or that job
13:30 - another very common use case for
13:31 - multiple jobs would be if we have a set
13:34 - of steps that can run in parallel so
13:38 - that the build overall is faster this
13:40 - could be running multiple tasks that can
13:43 - run at the same time testing different
13:45 - parts of the application so they don't
13:46 - have to wait for each other to complete
13:49 - they can all
13:50 - run at once
13:52 - so by creating multiple jobs for all
13:54 - these tests you can actually run them in
13:57 - parallel on different environments
13:59 - so overall the main task of this build
14:02 - pipeline is to test the code changes and
14:05 - if everything is fine produce an
14:07 - artifact that we can deploy
14:09 - before moving on i want to give a shout
14:11 - out to polumi who made this video
14:13 - possible polomi is a universal
14:16 - infrastructure as koto and the cool
14:18 - thing about polomi is that you can use
14:21 - your familiar programming languages
14:23 - tools and engineering practices to
14:26 - deploy and manage your cloud
14:28 - infrastructure you can use polami for
14:30 - any cloud but for azure specifically it
14:33 - has the most complete infrastructure as
14:35 - code support for the azure platform and
14:38 - is the only one with guaranteed same day
14:41 - support thanks to
14:43 - as your native provider polomi can
14:46 - easily integrate into any cicd platform
14:48 - for azure devops they actually build a
14:50 - task extension that lets you easily use
14:53 - polumi in your ci cd pipelines it can be
14:56 - used with azure pipeline's wizard ui or
14:59 - the yaml configuration if you want to
15:01 - learn more about polomi i actually have
15:03 - a separate video on it where you can see
15:06 - fully how it works in practice with that
15:09 - let's move on to azure artifacts
15:12 - now traditionally depending on the
15:14 - application programming language the
15:17 - artifact produced will be different
15:19 - could be a jar or war file for a java
15:22 - application a new ga file for net
15:25 - a zip file tar file etc
15:28 - and for storing this kind of artifacts
15:32 - you actually have another feature in
15:34 - azure devops called azure artifacts and
15:36 - azure artifacts actually currently
15:38 - supports three types of artifacts which
15:41 - are maven packages nuka packages and npm
15:45 - packages so if you're developing and
15:47 - building your application with any of
15:49 - these tools then you can
15:51 - store the artifacts produced in the
15:54 - build pipeline in the azure artifacts
15:57 - however in the modern software
15:59 - development we usually don't produce
16:02 - such artifacts anymore to deploy them
16:04 - instead we create docker images is
16:07 - artifacts so no matter what language you
16:10 - use
16:10 - what tools you use the artifact is
16:13 - always the same which is a container
16:15 - image so if you have 10 microservices
16:18 - all in different languages you can still
16:20 - produce the same container image type of
16:22 - artifacts
16:24 - and images actually need a dedicated
16:26 - type of repository so if your build
16:29 - pipeline produces docker images you will
16:32 - connect your azure devops to some docker
16:34 - registry like docker hub azure container
16:37 - registry etc and basically store your
16:40 - images
16:41 - in that repository
16:46 - now let's say we successfully built
16:49 - our application
16:50 - into a docker image
16:52 - we pushed it to a docker repository and
16:55 - now it's time to deploy it to the end
16:57 - environment this would be the next stage
17:00 - of the pipeline which is also called the
17:03 - cd or continuous deployment or
17:05 - continuous delivery if you're not
17:07 - totally new to devops you already know
17:10 - that at the heart of devops there is the
17:12 - ci cd pipeline which is ideally the
17:16 - fully automated process of taking the
17:19 - code changes and deploying it all the
17:22 - way to the production
17:24 - by testing and validating all parts of
17:27 - those changing from is the application
17:29 - functioning is it secure
17:31 - etc and in that process we have these
17:34 - two main parts which is build stage and
17:36 - the deploy stage again we haven't
17:38 - defined a stage in the pipeline yet
17:41 - since we only had one stage with all the
17:43 - build jobs when we have multiple stages
17:46 - however we need to configure that as
17:48 - well so in order to create a complete ci
17:50 - cd pipeline we'll have the stages in our
17:53 - yaml pipeline script for building and
17:56 - for deploying the application and by the
17:58 - way we can use a specific type of job in
18:03 - the deploy stage which is called
18:05 - deployment which is specifically meant
18:07 - for deploy job and has some features for
18:09 - that purpose for example it doesn't
18:11 - check out the code like job type does
18:14 - etc now when we are deploying the new
18:17 - application version usually we don't
18:19 - directly deploy to the production
18:20 - instead we deploy to intermediate
18:23 - environments we test it extensively and
18:25 - gradually promote it to the production
18:27 - when we're almost 100 sure everything is
18:30 - fine common is to have development
18:33 - testing
18:34 - and production environments so we can
18:36 - have all these as separate stages
18:38 - after the build stage deployed to
18:40 - development deployed to testing deployed
18:43 - to production
18:46 - now the code for deployment to different
18:49 - environments will be pretty much the
18:51 - same except for a couple of parameters
18:53 - so how can we avoid repeating the
18:56 - pipeline configuration code in this case
18:58 - or maybe we have multiple applications
19:00 - that all have the same pipeline logic
19:04 - so we don't want to write the same
19:06 - pipeline configuration for each
19:07 - application in our company instead
19:10 - ideally we want to write that logic once
19:12 - properly and then reuse it for all the
19:15 - applications that may need it in azure
19:17 - devops pipelines yaml syntax we can
19:20 - actually put any code that is repeated
19:22 - and extract it in what's called a
19:24 - template which is a separate file and
19:27 - can be referenced in the pipeline
19:29 - using template attribute and it can even
19:33 - be configured with parameters so it's
19:35 - like a reusable piece of configuration
19:38 - that you can reference in different
19:41 - pipelines
19:42 - so you can split your entire pipeline
19:44 - into multiple individual files
19:47 - and these files can even be stored and
19:50 - managed in a dedicated separate
19:52 - repository and as i said all the
19:54 - pipelines can reference them and by the
19:57 - way you can have a template for a job a
20:00 - step or stage so for any of these levels
20:04 - and you can also have templates within
20:06 - the templates creating a hierarchy like
20:08 - this
20:12 - now when you have multiple
20:14 - environments for multiple applications
20:16 - it may become difficult to have an
20:18 - overview of what version of what branch
20:21 - is deployed where
20:23 - or when the code was last deployed to a
20:25 - specific environment and so on and
20:28 - that's where the environment feature
20:29 - comes in which is part of azure
20:32 - pipelines we can create environments in
20:35 - azure devops which will map to the
20:37 - actual deployment environments and then
20:40 - you can configure in your pipeline which
20:42 - of these azure devops environments you
20:44 - want to deploy to so you kind of have
20:46 - this abstraction there and once the
20:48 - application gets deployed to these
20:50 - various environments you can actually
20:52 - view the deployment history per
20:54 - environment so this can actually be some
20:56 - additional valuable ui feature that
20:58 - gives you a better overview of your
21:00 - deployments plus the deployment status
21:03 - can also be linked back to the original
21:05 - ticket so you have that additional
21:07 - information
21:09 - for the feature or improvement to which
21:11 - stages or environments it has been
21:13 - deployed to already which again can be
21:16 - pretty convenient
21:19 - now that deployment process or
21:22 - deployment part of the pipeline which as
21:24 - i said is called cd or continuous
21:26 - deployment
21:28 - on azure devops can also be built as a
21:31 - separate pipeline called release
21:33 - pipeline interesting to note that many
21:36 - ci cd platforms like jenkins gitlab csd
21:39 - etc they have one pipeline for the whole
21:42 - process so we have one file and one ui
21:44 - unit for both
21:46 - in this case it will be split into
21:48 - separate ci and cd pipelines so the way
21:51 - it works is that you select a build
21:53 - pipeline that produces an artifact
21:56 - or you choose the already built artifact
21:59 - location or source and you create a
22:02 - release pipeline for that artifact note
22:05 - that release pipelines in azure devops
22:07 - can only be created using the ui so you
22:10 - have no yaml file for that however the
22:12 - pipeline structure itself is the same
22:15 - you can create steps by choosing from
22:17 - available tasks and also have multiple
22:19 - stages like deployment to development
22:21 - testing and production so with release
22:24 - pipelines you say when this build
22:26 - pipeline completes and successfully
22:29 - creates the docker image artifacts for
22:31 - example trigger this release pipeline so
22:34 - this way you chain them but as i quickly
22:36 - mentioned as the artifact source you can
22:39 - actually use not only the build pipeline
22:42 - output but also already built artifact
22:46 - from various sources
22:47 - now generally it's usually a better idea
22:50 - to always have one ci cd pipeline
22:53 - defined in yemel instead of splitting
22:56 - that into two plus you have all the
22:58 - benefits of scripting your pipeline and
23:00 - making use of the reusable templates etc
23:04 - so the release pipelines is probably for
23:06 - more specific use cases
23:08 - maybe when you want to deploy existing
23:10 - artifacts from the artifact repository
23:12 - directly but as i said usually you
23:14 - should have one pipeline for the
23:15 - complete cicd process
23:20 - now an important part of an application
23:23 - release process is testing and you need
23:26 - to extensively test your code changes
23:29 - before deploying it to production and of
23:31 - course the more complex the application
23:33 - the more tests you need so in azure
23:35 - devops you actually have a dedicated
23:37 - section for tests and here you can
23:40 - actually create a unified central view
23:43 - of all the test cases or many of your
23:46 - test cases that need to be checked
23:47 - before giving a green light to
23:50 - production deployment and here you can
23:52 - create manual test cases or plans
23:54 - so when a new feature is being released
23:57 - a tester can go through these steps and
24:00 - test the application
24:01 - but this could also be automated tests
24:04 - which will be executed as part of the ci
24:06 - cd process and the test reports from the
24:09 - pipelines can be published and viewed
24:11 - here
24:12 - and the main advantage of this is that
24:15 - you have own centralized place with an
24:18 - overview of all the test plans whenever
24:20 - releasing your application whether these
24:22 - are automated tests that were run in the
24:24 - pipeline or manual tests from developers
24:27 - product owners testers etc and again you
24:30 - can see the results of those test
24:32 - executions in your feature descriptions
24:35 - to decide whether you can release the
24:36 - changes or not and you can even view and
24:39 - run the test cases related to a feature
24:41 - directly from the convent board
24:46 - now the pipelines execute tasks like
24:49 - running tests building an image etc and
24:52 - as i mentioned you can execute these
24:54 - tasks on different machines with
24:55 - different operating systems
24:57 - so where are those machines exactly and
25:00 - how do we get access to them
25:02 - to run our tasks and which machines and
25:05 - which environment do we get to answer
25:07 - this question let's look at the azure
25:09 - devops architecture on a high level
25:12 - at the core we have what's called the
25:14 - azure devops services a software as a
25:17 - service or the managed online solution
25:20 - from azure and that's the main part
25:23 - where configurations are made pipelines
25:25 - and repositories are created and stored
25:28 - etc so these are all dedicated machines
25:31 - for those things but the pipeline tasks
25:34 - themselves
25:35 - run on separate machines called agents
25:38 - which are connected to the azure devops
25:41 - services platform
25:43 - now
25:43 - who manages these agent machines well
25:46 - azure offers managed agents as well so
25:49 - you can let microsoft actually manage
25:51 - the whole setup for you including the
25:54 - main service which holds the
25:56 - configuration plus the machines that
25:58 - actually execute the pipelines however
26:00 - in practice many companies need control
26:04 - over these machines plus they want to
26:06 - remain flexible and save costs maybe
26:08 - they have these machines on premise or
26:10 - even on another cloud platform so they
26:12 - want to make use of this so you have an
26:15 - option to configure your own agents and
26:18 - connect them to the azure devops
26:20 - platform or you can even have a mixture
26:22 - of both and this is actually pretty
26:25 - similar architecture to what other
26:28 - similar platforms like eclipse icd etc
26:31 - look like so nothing really
26:33 - extraordinary here and since this is a
26:36 - managed service of course you have to
26:39 - pay for these services and using for
26:41 - these resources but azure devops does
26:43 - have a free tier to get started with
26:46 - that basically includes a certain amount
26:48 - of free resources that you can use to
26:51 - get started with including using managed
26:54 - agents for your pipeline jobs
26:58 - great so till now we actually saw
27:01 - various features of azure devops that
27:04 - map to different parts of the
27:07 - application development life cycle
27:09 - starting from planning the task all the
27:11 - way to developing and deploying it to
27:14 - the end environment
27:16 - now throughout these processes we
27:17 - actually have tasks that we execute on
27:20 - other platforms for example when we
27:22 - build and push an image that needs to be
27:25 - pushed or stored in an external image
27:28 - repository right which is outside of
27:30 - azure devops or when we deploy to a
27:33 - remote server it will be on some cloud
27:35 - platform like azure aws or even
27:38 - on-premise or maybe we deploy to
27:40 - kubernetes cluster etc plus we may have
27:43 - the pipeline connected to the external
27:46 - code repository in github instead of
27:48 - using the azure repository so for all
27:51 - these tasks azure devops needs to
27:53 - connect to those platforms right and
27:55 - normally you have credentials like
27:57 - username and password or access token
28:00 - from these platforms that you need to
28:03 - make available in azure devops so that
28:05 - it can connect and authenticate itself
28:08 - with those platforms now for those use
28:11 - cases in azure devops you have what's
28:13 - called service connections feature
28:16 - which makes managing access to external
28:18 - platforms much easier
28:21 - first of all it's less configuration
28:22 - effort because you don't have to create
28:25 - these credentials in the respective
28:26 - surveys and then replicate in azure
28:29 - devops instead the credentials are
28:31 - created automatically when azure devops
28:33 - connects to those services and second
28:36 - advantage is that it's more secure
28:38 - actually because service connections use
28:41 - short-lived credentials which as i said
28:44 - gets generated on the fly when the
28:46 - connection is established so you don't
28:48 - have to worry about rotating or
28:50 - invalidating credentials and so on
28:52 - and the service connections can be
28:54 - created in the project settings section
28:57 - so you have a separate section for
28:59 - administering the project here you can
29:02 - manage settings for all the features
29:05 - like boards repositories pipelines test
29:08 - plans and artifacts plus as i mentioned
29:11 - you can use self-hosted agents
29:14 - to run your pipelines and this is also
29:17 - where admins can configure these agents
29:19 - as well
29:21 - now after learning all the various
29:23 - features of azure devops and what the
29:25 - azure devops platform even is
29:27 - you're probably wondering if this is so
29:29 - great why aren't all the projects using
29:31 - it or is it that great and what is the
29:33 - difference from other similar platforms
29:35 - like aws or gitlab etc and which one are
29:39 - you supposed to learn should you become
29:41 - an expert in azure devops and ignore all
29:44 - other tools so let's look at comparison
29:47 - with
29:48 - similar tools and answer the question
29:50 - about which one to learn first let's
29:53 - compare it with traditional ci cd tools
29:55 - like jenkins or modern ones like argo cd
29:58 - circle ci etc the main difference here
30:01 - is that these are exclusively ci cd
30:04 - tools right so jenkins circle ci etc
30:08 - they're specifically built to
30:10 - create and manage cicd processes but
30:14 - azure devops actually strives to be the
30:16 - complete devops platform not only the ci
30:19 - cd so any feature you need for covering
30:22 - the whole devops process including the
30:25 - ci cd is in one place which can be
30:28 - extremely convenient as i said because
30:30 - in devops you need multiple tools for
30:32 - different parts of the process
30:35 - like jenkins for build code repository
30:37 - jira board
30:39 - artifact repository etc
30:41 - which means you need to integrate these
30:43 - tools together so you have an effort in
30:46 - putting all these tools together
30:49 - like connecting git repository with
30:51 - jenkins connecting jenkins with jira to
30:54 - update status of feature tasks etc so
30:57 - when you use a platform that offers
30:59 - these services in one place obviously
31:02 - it's more convenient because they are
31:04 - already integrated
31:06 - and plus you get a better traceability
31:08 - meaning you have links between all parts
31:10 - of the process feature task has links to
31:13 - corresponding feature branch or pull
31:15 - requests to its pipelines maybe the
31:17 - artifact that was produced with the
31:19 - version and so on so you have a better
31:21 - overview because you have linked data
31:23 - from all features a direct comparison to
31:27 - azure devops is however gitlab because
31:30 - gitlab which started off as a git
31:33 - repository actually made a turn and
31:36 - decided to create an all-in-one devops
31:39 - platform as well
31:40 - and to be honest many of the features
31:43 - and use cases are pretty similar between
31:45 - gitlab and azure devops or generally how
31:47 - the things work
31:49 - and if you're interested i actually have
31:50 - a crash course as well as full course on
31:53 - gitlab ci cd
31:55 - for building complete devops processes
31:57 - with it
31:58 - you can also compare it with aws however
32:01 - aws is way bigger and way more
32:04 - encompassing than just the devops
32:06 - processes
32:07 - and here i want to mention an
32:09 - interesting note about comparing azure
32:12 - with aws and where azure devops platform
32:15 - actually plays a role in that as we know
32:18 - azure and aws are both cloud platforms
32:21 - where you can create and configure your
32:23 - complete virtual infrastructure create
32:26 - virtual servers and use a bunch of other
32:28 - services as well but while aws has all
32:31 - its services on one place with one
32:33 - account azure platform and azure devops
32:36 - platforms are more separated so you have
32:39 - two separate accounts for them and you
32:40 - can manage them separately and even use
32:43 - each platform without the other however
32:45 - they are both obviously microsoft
32:47 - products part of the same ecosystem so
32:50 - they have some integration so
32:51 - essentially they are still connected so
32:54 - for example the hosted runners for azure
32:57 - devops run on azure platform as well as
32:59 - the code on azure devops repositories
33:02 - are also hosted on azure platform and
33:04 - you can also integrate the azure active
33:07 - directory which is one of the azure
33:09 - services in your azure devops account so
33:12 - they're two separate platforms but
33:14 - integrated with each other for various
33:16 - use cases and that means when you want
33:19 - to deploy to azure virtual machines
33:22 - azure app services etc or azure
33:25 - kubernetes service from azure devops you
33:27 - basically have to connect to just like
33:29 - you would to any other cloud platform to
33:32 - deploy to it and an interesting use case
33:34 - in many projects many companies is that
33:36 - projects who use azure devops actually
33:38 - deploy to multiple
33:40 - infrastructure environments or cloud
33:42 - platforms so they may deploy from azure
33:45 - devops pipeline to azure
33:48 - virtual machines and aws virtual
33:51 - machines and that's probably the main
33:53 - example that may answer the question of
33:55 - which technology you should learn
33:58 - or whether you should learn azure devops
34:00 - and the answer is
34:01 - usually companies that already use azure
34:05 - platform or already use
34:07 - microsoft services and products they
34:10 - actually tend to use azure devops as
34:12 - well however in terms of cloud
34:14 - technologies um or cloud platforms aws
34:18 - is still the winner and number one in
34:20 - this category and on the other end in
34:23 - terms of the cicd tools themselves
34:25 - usually the open source solutions like
34:28 - gitlab scarcity or jenkins etc are
34:31 - preferred
34:32 - rather than using proprietary services
34:34 - like azure devops and very often you
34:37 - have a case where company already has
34:39 - tools and processes it has been using
34:41 - for years like they work with jira and
34:43 - jenkins and aws platform they use
34:46 - internal docker registry and github
34:48 - repository so they want and they can't
34:51 - just move everything to azure device so
34:54 - as an engineer when learning new tools
34:57 - one of the things you should ask
34:58 - yourself is
35:00 - when you get a job what tools you will
35:03 - most likely be working with based on
35:06 - which tools are mostly used by companies
35:08 - today and as i said tools like jenkins
35:11 - aws platform gitlab or github platforms
35:15 - etc in devops are still the most
35:17 - commonly used ones
35:19 - and the leaders in their own categories
35:22 - so you should definitely look at those
35:24 - tools first and since many viewers
35:26 - actually ask that that's the main reason
35:28 - why in our devops educational bootcamp
35:31 - we teach exactly those technologies
35:33 - which are the most popular and most used
35:36 - in each category even if there are
35:38 - cooler or better alternative tools
35:41 - for those technologies
35:43 - but again some companies that already
35:45 - use microsoft services may decide to go
35:48 - for azure devops or you may be in a
35:51 - project or interviewing for a job where
35:53 - you need this knowledge in which case of
35:55 - course you should learn and get
35:57 - expertise in azure devops now i hope i
36:00 - was able to give you clarity on what
36:02 - azure devops is and give you all the
36:05 - needed information to get started with
36:07 - it i will add any relevant links in the
36:10 - video description so you can check them
36:11 - out there as well as share in the
36:13 - comment section
36:15 - whether you already have experience or
36:17 - have worked with azure devops or what is
36:19 - your experience with any comparative
36:21 - tools
36:22 - and which one you would recommend
36:24 - and with that thank you for watching and
36:27 - see you in the next video

Cleaned transcript:

so in this video we will learn about one of the popular devops platforms called azure devops we will see what it is and what you can do with azure devops platform how to use it for your software development projects and generally how is this relevant for you as an engineer we will see different features and use cases of azure devops how it all works and how you can implement the whole software development and deployment lifecycle with it we will also review the azure devops architecture and how it works in the background and finally we will also compare it with alternative tools and talk a bit about which of these tools you need to learn for your career with so many alternative options so let's get started so first of all what is azure devops as the name suggests it is a devops platform it is a software as a service offering which was created to basically be a onestop shop for implementing all your devops processes for your project and it had many names before it became known as azure devops it was called team foundation server then visual studio team services so it had a bunch of other names before azure devops because it extended from existing services and tools so it kind of got names of these tools and even though it was for the same purpose of implementing the devops processes at that time devops was still practiced by a smaller group of projects so that's why the name devops never actually came up in the name of the platform itself however since devops became more mainstream and as it is now used in lots of projects worldwide it was actually renamed to azure devops which is pretty smart because devops is already a popular term everybody knows what it is so just by the name you know that it's a platform for devops but it still sounds too general because what is a devops platform devops is many things right so what is a platform for devops and to answer that question let's look at what azure devops is exactly and how it helps in implementing devops processes well devops as i said is many things it is a combination of concepts and tools and basically anything that makes developing and releasing applications fast in an automated way and with high quality possible so a project needs to implement devops practices in order to achieve an efficient workflow if you want to go more in detail about devops and learn it in more depth all its tools and concepts etc i actually have a separate video on that but shortly explained it's to make the software development lifecycle as efficient as possible by fully or mostly automating it and azure devops is basically a technological implementation of that devops process which covers the whole software development lifecycle and it has features for each part of this lifecycle so let's go through the steps or parts of that software development lifecycle and see how the various azure devops features map to those parts now what does a software development lifecycle include it's not just developing the application or writing the code it actually starts before you have written a single line of code because before coding any feature or an improvement needs to be planned first right mostly by a product manager so the first step is to define what we are developing and why are we developing it or in other words what's the business value behind it and there are several ways of defining the workflow of how the project team will work on the application which roles they have within the team how they will divide and split the tasks etc two of the most popular workflows are agile and scrum many modern projects use one of these approaches for their development so once you have created a project in azure devops for your application the first feature you will probably use here will be azure boards and depending on which workflow you use for your projects in your company generally like agile scrum or even some basic workflow you can choose the corresponding board for this project because as i said azure devops or any other similar platform is basically just a tool that gives you various features to implement whatever workflows you have in your company so on azure boards you can create tickets or tasks for features improvements or fixes for your applications as part of that agile or scrum processes you can assign it to people to work on and you can also track progress of those features or improvements while they are being developed now developers need to take that planned task and actually develop it right in that process they may have questions about the task so azure boards can be used for communicating between the developers testers product owner etc within the task description plus it can be used to have an overview and transparency over the status of the feature as it is being developed who is working on it what stage it is in what's its progress status has it been deployed already etc now the application code that developers are creating is also part of that life cycle actually the main part of it an azure repository feature is what you can use in order to host that code now of course you know the popular code repositories like github gitlab bitbucket etc which are all based on git and that's basically an alternative to those platforms so editor repository also supports git which is the most popular version control tool so developers can host their code in azure repository and push their changes to it however the code repositories have actually evolved and became much more feature reached and just hosting code is one of the many features that they provide so azure repository also it's not just for hosting the code as part of the devops life cycle developers collaborate and work together to develop high quality code so in the repository as part of the git workflow you have features such as pull requests branches various collaboration features and so on so when developer starts a task they create a temporary branch when done they create a pull request and other developers can review and comment on the pull request they can communicate and collaborate until the pull request is good enough to be merged into the main branch now this is what's called a git workflow so basically how your team decides to work on the code and to make sure that the quality of code is very good and there are many git workflows or the way teams use git and all its features and different companies may use different approaches or different workflows but the key point here is that with azure repository you have the tool that enables you to implement whatever git workflow you choose to work with plus note that the repository and branches and the pull requests are all linked back to the feature task so you see the activity and status of development there as well now once the feature is developed and pull request is approved and merged into the main branch it needs to be released right that's the reason we're developing the feature in the first place so we can release it and the end users can use it so in order to release our code changes we first need to test it and package it into an artifact which is a deliverable that we can then deploy on the end environment and again devops is all about automating things and workflows so that it's fast and efficient so this process of testing and building the application is done by an automated ci or continuous integration process and for building the ci pipeline azure has what's called azure pipelines section pipelines can be written in yemo which means you can have your pipeline script as part of your code the main building blocks of azure build pipelines are steps for example if we want to test and package the application we may have steps to run tests package application build an image push that image to an image repository so that later it can be deployed so each step will execute a certain command to run the test to package the application build a docker image and so on and this is an example pipeline for building a.net application which is a common type of application built on azure devops platform since asp.net is also part of the microsoft technology stack in the first two steps in this pipeline we test and build the application with net commands and then build the image with a docker command and as you see we execute commands in script attribute however we have another option for executing step commands instead of scripting it directly in yemo ourselves so in addition to writing the scripts yourself you can use what's called a task instead so what is the task and how does it work in azure devops you have loads of tasks already available to choose from for different use cases and they can be selected and configured using a ui you can select the tasks directly from the list of available tasks on the right side of the pipeline's yaml editor and configure any needed parameters for the task and when you have the task configured basically you fill in and set all the parameters you can add the task back to your yaml pipeline it will be automatically converted and edit as yaml code and of course you can adjust or add any additional configuration to it so here for example if you look for asp.net task you will find one for executing various.net commands like test build etc and once configured you can add the test task in place of the script you can do the same for docker you can search for docker tasks and find the one with build and push commands and add that task to your yaml pipeline and this obviously can be convenient in many use cases because you don't have to know the commands exactly you don't even have to know or memorize the exact syntax for the pipeline and you also don't have to script the steps from scratch so this basically gives you a simple um an easier high level approach to adding steps to your pipeline now this is a very simple scenario of a pipeline with one single job that has all the steps but in practice we often have more complex scenarios where we would need multiple jobs in a single pipeline let's say we want to execute the test step on two different operating systems we want to test the application on linux and windows before we build it or let's say we test and deploy our application on linux machine but we need a database for our application which must run on a windows machine for this use case we would need two separate jobs now i'm mentioning jobs but we haven't seen a job defined in our simple pipeline yet so what is a job exactly well all these steps actually belong to one job and can be defined like this so a job is basically a group of multiple steps however when we have only one job in our pipeline we don't need to explicitly define it that's why we could skip this in a simple pipeline but when we have multiple jobs we need to define them within jobs attribute so we have multiple jobs each with multiple steps and now we can actually execute each job so all the steps within the job on a different environment also called an agent so agent is a machine that will execute the tasks or the steps of the pipeline like running the test building an image etc and an agent is selected from an agent pool like pool of windows machines or linux machines or mac os machines etc and that's why we have a pull attribute in the job to define what kind of machine we want to dedicate for that job and as you see inside the pool we can define if the end image that specifies what kind of operating system we want and you can also specify what version of that operating system you want to run that step or that job another very common use case for multiple jobs would be if we have a set of steps that can run in parallel so that the build overall is faster this could be running multiple tasks that can run at the same time testing different parts of the application so they don't have to wait for each other to complete they can all run at once so by creating multiple jobs for all these tests you can actually run them in parallel on different environments so overall the main task of this build pipeline is to test the code changes and if everything is fine produce an artifact that we can deploy before moving on i want to give a shout out to polumi who made this video possible polomi is a universal infrastructure as koto and the cool thing about polomi is that you can use your familiar programming languages tools and engineering practices to deploy and manage your cloud infrastructure you can use polami for any cloud but for azure specifically it has the most complete infrastructure as code support for the azure platform and is the only one with guaranteed same day support thanks to as your native provider polomi can easily integrate into any cicd platform for azure devops they actually build a task extension that lets you easily use polumi in your ci cd pipelines it can be used with azure pipeline's wizard ui or the yaml configuration if you want to learn more about polomi i actually have a separate video on it where you can see fully how it works in practice with that let's move on to azure artifacts now traditionally depending on the application programming language the artifact produced will be different could be a jar or war file for a java application a new ga file for net a zip file tar file etc and for storing this kind of artifacts you actually have another feature in azure devops called azure artifacts and azure artifacts actually currently supports three types of artifacts which are maven packages nuka packages and npm packages so if you're developing and building your application with any of these tools then you can store the artifacts produced in the build pipeline in the azure artifacts however in the modern software development we usually don't produce such artifacts anymore to deploy them instead we create docker images is artifacts so no matter what language you use what tools you use the artifact is always the same which is a container image so if you have 10 microservices all in different languages you can still produce the same container image type of artifacts and images actually need a dedicated type of repository so if your build pipeline produces docker images you will connect your azure devops to some docker registry like docker hub azure container registry etc and basically store your images in that repository now let's say we successfully built our application into a docker image we pushed it to a docker repository and now it's time to deploy it to the end environment this would be the next stage of the pipeline which is also called the cd or continuous deployment or continuous delivery if you're not totally new to devops you already know that at the heart of devops there is the ci cd pipeline which is ideally the fully automated process of taking the code changes and deploying it all the way to the production by testing and validating all parts of those changing from is the application functioning is it secure etc and in that process we have these two main parts which is build stage and the deploy stage again we haven't defined a stage in the pipeline yet since we only had one stage with all the build jobs when we have multiple stages however we need to configure that as well so in order to create a complete ci cd pipeline we'll have the stages in our yaml pipeline script for building and for deploying the application and by the way we can use a specific type of job in the deploy stage which is called deployment which is specifically meant for deploy job and has some features for that purpose for example it doesn't check out the code like job type does etc now when we are deploying the new application version usually we don't directly deploy to the production instead we deploy to intermediate environments we test it extensively and gradually promote it to the production when we're almost 100 sure everything is fine common is to have development testing and production environments so we can have all these as separate stages after the build stage deployed to development deployed to testing deployed to production now the code for deployment to different environments will be pretty much the same except for a couple of parameters so how can we avoid repeating the pipeline configuration code in this case or maybe we have multiple applications that all have the same pipeline logic so we don't want to write the same pipeline configuration for each application in our company instead ideally we want to write that logic once properly and then reuse it for all the applications that may need it in azure devops pipelines yaml syntax we can actually put any code that is repeated and extract it in what's called a template which is a separate file and can be referenced in the pipeline using template attribute and it can even be configured with parameters so it's like a reusable piece of configuration that you can reference in different pipelines so you can split your entire pipeline into multiple individual files and these files can even be stored and managed in a dedicated separate repository and as i said all the pipelines can reference them and by the way you can have a template for a job a step or stage so for any of these levels and you can also have templates within the templates creating a hierarchy like this now when you have multiple environments for multiple applications it may become difficult to have an overview of what version of what branch is deployed where or when the code was last deployed to a specific environment and so on and that's where the environment feature comes in which is part of azure pipelines we can create environments in azure devops which will map to the actual deployment environments and then you can configure in your pipeline which of these azure devops environments you want to deploy to so you kind of have this abstraction there and once the application gets deployed to these various environments you can actually view the deployment history per environment so this can actually be some additional valuable ui feature that gives you a better overview of your deployments plus the deployment status can also be linked back to the original ticket so you have that additional information for the feature or improvement to which stages or environments it has been deployed to already which again can be pretty convenient now that deployment process or deployment part of the pipeline which as i said is called cd or continuous deployment on azure devops can also be built as a separate pipeline called release pipeline interesting to note that many ci cd platforms like jenkins gitlab csd etc they have one pipeline for the whole process so we have one file and one ui unit for both in this case it will be split into separate ci and cd pipelines so the way it works is that you select a build pipeline that produces an artifact or you choose the already built artifact location or source and you create a release pipeline for that artifact note that release pipelines in azure devops can only be created using the ui so you have no yaml file for that however the pipeline structure itself is the same you can create steps by choosing from available tasks and also have multiple stages like deployment to development testing and production so with release pipelines you say when this build pipeline completes and successfully creates the docker image artifacts for example trigger this release pipeline so this way you chain them but as i quickly mentioned as the artifact source you can actually use not only the build pipeline output but also already built artifact from various sources now generally it's usually a better idea to always have one ci cd pipeline defined in yemel instead of splitting that into two plus you have all the benefits of scripting your pipeline and making use of the reusable templates etc so the release pipelines is probably for more specific use cases maybe when you want to deploy existing artifacts from the artifact repository directly but as i said usually you should have one pipeline for the complete cicd process now an important part of an application release process is testing and you need to extensively test your code changes before deploying it to production and of course the more complex the application the more tests you need so in azure devops you actually have a dedicated section for tests and here you can actually create a unified central view of all the test cases or many of your test cases that need to be checked before giving a green light to production deployment and here you can create manual test cases or plans so when a new feature is being released a tester can go through these steps and test the application but this could also be automated tests which will be executed as part of the ci cd process and the test reports from the pipelines can be published and viewed here and the main advantage of this is that you have own centralized place with an overview of all the test plans whenever releasing your application whether these are automated tests that were run in the pipeline or manual tests from developers product owners testers etc and again you can see the results of those test executions in your feature descriptions to decide whether you can release the changes or not and you can even view and run the test cases related to a feature directly from the convent board now the pipelines execute tasks like running tests building an image etc and as i mentioned you can execute these tasks on different machines with different operating systems so where are those machines exactly and how do we get access to them to run our tasks and which machines and which environment do we get to answer this question let's look at the azure devops architecture on a high level at the core we have what's called the azure devops services a software as a service or the managed online solution from azure and that's the main part where configurations are made pipelines and repositories are created and stored etc so these are all dedicated machines for those things but the pipeline tasks themselves run on separate machines called agents which are connected to the azure devops services platform now who manages these agent machines well azure offers managed agents as well so you can let microsoft actually manage the whole setup for you including the main service which holds the configuration plus the machines that actually execute the pipelines however in practice many companies need control over these machines plus they want to remain flexible and save costs maybe they have these machines on premise or even on another cloud platform so they want to make use of this so you have an option to configure your own agents and connect them to the azure devops platform or you can even have a mixture of both and this is actually pretty similar architecture to what other similar platforms like eclipse icd etc look like so nothing really extraordinary here and since this is a managed service of course you have to pay for these services and using for these resources but azure devops does have a free tier to get started with that basically includes a certain amount of free resources that you can use to get started with including using managed agents for your pipeline jobs great so till now we actually saw various features of azure devops that map to different parts of the application development life cycle starting from planning the task all the way to developing and deploying it to the end environment now throughout these processes we actually have tasks that we execute on other platforms for example when we build and push an image that needs to be pushed or stored in an external image repository right which is outside of azure devops or when we deploy to a remote server it will be on some cloud platform like azure aws or even onpremise or maybe we deploy to kubernetes cluster etc plus we may have the pipeline connected to the external code repository in github instead of using the azure repository so for all these tasks azure devops needs to connect to those platforms right and normally you have credentials like username and password or access token from these platforms that you need to make available in azure devops so that it can connect and authenticate itself with those platforms now for those use cases in azure devops you have what's called service connections feature which makes managing access to external platforms much easier first of all it's less configuration effort because you don't have to create these credentials in the respective surveys and then replicate in azure devops instead the credentials are created automatically when azure devops connects to those services and second advantage is that it's more secure actually because service connections use shortlived credentials which as i said gets generated on the fly when the connection is established so you don't have to worry about rotating or invalidating credentials and so on and the service connections can be created in the project settings section so you have a separate section for administering the project here you can manage settings for all the features like boards repositories pipelines test plans and artifacts plus as i mentioned you can use selfhosted agents to run your pipelines and this is also where admins can configure these agents as well now after learning all the various features of azure devops and what the azure devops platform even is you're probably wondering if this is so great why aren't all the projects using it or is it that great and what is the difference from other similar platforms like aws or gitlab etc and which one are you supposed to learn should you become an expert in azure devops and ignore all other tools so let's look at comparison with similar tools and answer the question about which one to learn first let's compare it with traditional ci cd tools like jenkins or modern ones like argo cd circle ci etc the main difference here is that these are exclusively ci cd tools right so jenkins circle ci etc they're specifically built to create and manage cicd processes but azure devops actually strives to be the complete devops platform not only the ci cd so any feature you need for covering the whole devops process including the ci cd is in one place which can be extremely convenient as i said because in devops you need multiple tools for different parts of the process like jenkins for build code repository jira board artifact repository etc which means you need to integrate these tools together so you have an effort in putting all these tools together like connecting git repository with jenkins connecting jenkins with jira to update status of feature tasks etc so when you use a platform that offers these services in one place obviously it's more convenient because they are already integrated and plus you get a better traceability meaning you have links between all parts of the process feature task has links to corresponding feature branch or pull requests to its pipelines maybe the artifact that was produced with the version and so on so you have a better overview because you have linked data from all features a direct comparison to azure devops is however gitlab because gitlab which started off as a git repository actually made a turn and decided to create an allinone devops platform as well and to be honest many of the features and use cases are pretty similar between gitlab and azure devops or generally how the things work and if you're interested i actually have a crash course as well as full course on gitlab ci cd for building complete devops processes with it you can also compare it with aws however aws is way bigger and way more encompassing than just the devops processes and here i want to mention an interesting note about comparing azure with aws and where azure devops platform actually plays a role in that as we know azure and aws are both cloud platforms where you can create and configure your complete virtual infrastructure create virtual servers and use a bunch of other services as well but while aws has all its services on one place with one account azure platform and azure devops platforms are more separated so you have two separate accounts for them and you can manage them separately and even use each platform without the other however they are both obviously microsoft products part of the same ecosystem so they have some integration so essentially they are still connected so for example the hosted runners for azure devops run on azure platform as well as the code on azure devops repositories are also hosted on azure platform and you can also integrate the azure active directory which is one of the azure services in your azure devops account so they're two separate platforms but integrated with each other for various use cases and that means when you want to deploy to azure virtual machines azure app services etc or azure kubernetes service from azure devops you basically have to connect to just like you would to any other cloud platform to deploy to it and an interesting use case in many projects many companies is that projects who use azure devops actually deploy to multiple infrastructure environments or cloud platforms so they may deploy from azure devops pipeline to azure virtual machines and aws virtual machines and that's probably the main example that may answer the question of which technology you should learn or whether you should learn azure devops and the answer is usually companies that already use azure platform or already use microsoft services and products they actually tend to use azure devops as well however in terms of cloud technologies um or cloud platforms aws is still the winner and number one in this category and on the other end in terms of the cicd tools themselves usually the open source solutions like gitlab scarcity or jenkins etc are preferred rather than using proprietary services like azure devops and very often you have a case where company already has tools and processes it has been using for years like they work with jira and jenkins and aws platform they use internal docker registry and github repository so they want and they can't just move everything to azure device so as an engineer when learning new tools one of the things you should ask yourself is when you get a job what tools you will most likely be working with based on which tools are mostly used by companies today and as i said tools like jenkins aws platform gitlab or github platforms etc in devops are still the most commonly used ones and the leaders in their own categories so you should definitely look at those tools first and since many viewers actually ask that that's the main reason why in our devops educational bootcamp we teach exactly those technologies which are the most popular and most used in each category even if there are cooler or better alternative tools for those technologies but again some companies that already use microsoft services may decide to go for azure devops or you may be in a project or interviewing for a job where you need this knowledge in which case of course you should learn and get expertise in azure devops now i hope i was able to give you clarity on what azure devops is and give you all the needed information to get started with it i will add any relevant links in the video description so you can check them out there as well as share in the comment section whether you already have experience or have worked with azure devops or what is your experience with any comparative tools and which one you would recommend and with that thank you for watching and see you in the next video
