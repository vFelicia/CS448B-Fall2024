With timestamps:

00:00 - in this video we're gonna learn how to
00:02 - install
00:03 - istio service mesh in a kubernetes
00:05 - cluster first we will install
00:07 - istio core in the cluster the main istio
00:10 - component
00:12 - then we will install istio add-ons for
00:14 - monitoring and tracing
00:16 - after that we will configure our cluster
00:18 - so that estio can
00:20 - automatically inject invoice proxies in
00:23 - our application pods
00:25 - and finally we will deploy an example
00:28 - demo microservices application in the
00:31 - cluster
00:31 - so that we can see all the features and
00:34 - visualization
00:35 - for those microservices in istio and for
00:38 - this demonstration we're going to use
00:40 - a local minicube cluster so let's jump
00:44 - right in now if you want to learn what
00:46 - istio is
00:47 - and what it's used for you can watch my
00:50 - other video about it where i explain
00:52 - what service mesh is and what istio is
00:54 - and all of its use cases
00:56 - and then you can come back and learn the
00:58 - setup of istio in your kubernetes
01:00 - cluster
01:05 - so the first thing we need to do is
01:07 - create or start our mini cube cluster
01:09 - and one note here is that istio will
01:12 - actually need some resources
01:14 - so the default resources that minicube
01:16 - cluster gets created with
01:18 - will not be enough so in the minicube
01:20 - start command
01:22 - we're going to provide options to
01:24 - increase the cpu
01:25 - and memory resources that our minicube
01:28 - cluster gets
01:34 - and this resource configuration should
01:37 - be
01:37 - now enough for our demonstration so make
01:40 - sure to set those resources
01:42 - high and we're gonna start a mini cube
01:45 - cluster
01:46 - so now that we have our mini cube
01:47 - cluster running with enough resources
01:49 - we can actually install issio and the
01:52 - first thing to installing istio is to
01:54 - download
01:55 - istio release package locally on our
01:57 - computer
01:58 - and on istio's official documentation
02:01 - page
02:02 - actually you have a guide to
02:05 - installing istio and in this guide we
02:07 - have link to istio releases
02:10 - you can also download the latest istio
02:13 - release for your specific
02:15 - operating system using this command here
02:17 - but we're going to do this
02:19 - using this istio release link and here
02:22 - you have all the releases we're going to
02:24 - install the latest one
02:25 - and i'm using mac so that's what i'm
02:28 - going to download
02:29 - make sure to download the one for your
02:31 - operating system
02:33 - and as you see this is a tar file so
02:36 - basically we just
02:37 - unpack it or unturn it and we'll see
02:39 - what's inside
02:40 - so what i'm going to do is i'm going to
02:42 - create
02:43 - a folder in my home directory i'm going
02:46 - to call it istio
02:48 - installation
02:51 - and i'm gonna move that downloaded istio
02:55 - tar file to that folder
03:00 - like this and
03:03 - let's go to eastern installation and
03:06 - right here is our tar file so that's the
03:09 - east
03:09 - installation folder and here we have the
03:11 - tar file i'm just gonna
03:13 - double click and unpack it and
03:16 - let's actually see what's inside we have
03:18 - the executable
03:20 - istio binary folder and some other files
03:24 - and what we're going to need from istio
03:26 - is actually
03:28 - an istio control command line
03:31 - which is in this binary folder and we
03:33 - want that command line tool
03:35 - to be executable and right now if i do
03:38 - istio ctl
03:43 - and execute you see command not found so
03:46 - we need that command
03:48 - which is here in the binary folder so in
03:51 - order to make that command available
03:52 - we're gonna add it to a path right to
03:55 - executable path
03:56 - and we can do that by adding the path to
03:59 - this binary folder
04:01 - to our path right basically appending it
04:04 - so right now this is how my path looks
04:07 - like
04:08 - like this and basically here we just
04:11 - want to append
04:12 - the path to this folder here let's
04:15 - actually find out what the path
04:17 - is i'm going to go inside that istio
04:20 - folder like this and i'm going to print
04:23 - out the path
04:25 - that's it this whole thing here and now
04:27 - we can
04:28 - append that to the path variable right
04:31 - so we have the original one the path
04:35 - and separator and we're just gonna add
04:38 - this one here slash bin
04:41 - and there you go i'm going to execute it
04:43 - and now if i do
04:45 - istio ctl and execute
04:48 - there you go so we have istio ctl
04:51 - available or istio control command line
04:54 - interface available here because we set
04:56 - the path now
04:58 - just note that this only
05:01 - sets that path or appends that
05:04 - executable
05:04 - only in this terminal so if i open a new
05:07 - window
05:08 - and try to do istio ctl here you see
05:12 - command not found so it only works
05:14 - wherever you
05:15 - execute this export command so let's
05:18 - close it
05:19 - and there you go we have downloaded
05:21 - istio and now we have istio ctl
05:24 - available
05:28 - and now as a next step we're gonna
05:30 - install istio
05:32 - with this istio ctl command inside
05:36 - our mini cube cluster so first of all
05:38 - i'm gonna do get namespace
05:40 - and let's see that we have just these
05:42 - default namespaces
05:44 - so no istio namespace here and
05:49 - right now also nothing running right so
05:52 - we have an empty cluster
05:53 - and now let's install istio in our
05:55 - cluster
05:56 - and we can do that very easily using
05:59 - istio
06:00 - ctl install command that's it
06:03 - i'm going to execute it and i'm going to
06:06 - confirm it here
06:07 - yes and everything is successfully
06:11 - installed
06:12 - we have istio core then we have istiod
06:15 - which is the main process of istio or
06:18 - main component
06:20 - and ingress gateway so now if i do cube
06:22 - ctl get
06:24 - namespace right here you see istio
06:27 - system namespace got created and let's
06:30 - actually check what's inside there
06:33 - let's print out the pots
06:36 - and there you go we have an istiod pod
06:39 - running here
06:40 - as well as istio ingress gateway
06:43 - now if you already know the istio
06:46 - service mesh
06:47 - architecture you know that we have this
06:49 - istiod component
06:51 - which is a control plane and we have the
06:53 - data plane
06:54 - which are basically the proxies that are
06:56 - injected into
06:57 - application pods right so if you have a
07:00 - micro service application
07:01 - you would have pod for each micro
07:04 - service
07:04 - and then istio would inject proxy
07:08 - and envoy proxy in each of those micro
07:10 - service pods
07:12 - so that means in order to see istio in
07:15 - action and in order to
07:16 - see those invoice proxies we need to
07:19 - deploy
07:19 - an application a micro services
07:22 - application
07:22 - ideally where the proxies will be
07:25 - injected
07:26 - so that's going to be our next step
07:32 - and as an example microservices i have
07:35 - found actually
07:36 - one from google cloud platform
07:38 - microservices
07:39 - demo project and we're going to use this
07:42 - one
07:42 - to deploy that in the cluster and then
07:45 - use istio service mesh
07:47 - for this micro services so in this
07:49 - release folder here
07:51 - you have kubernetes manifests
07:54 - and these are basically kubernetes
07:57 - configuration files
07:58 - for creating deployments and services
08:01 - for
08:02 - a couple of micro services so you can
08:05 - clone this repository
08:07 - and we're going to be using this
08:09 - specific file
08:10 - i have cloned the repo and i have that
08:13 - specific file
08:14 - now in this istio installation folder
08:17 - right here so that i can execute it
08:20 - directly from here
08:21 - so right now i'm inside istio folder
08:26 - and this is my manifests file so
08:29 - obviously this is just kubernetes
08:31 - manifest files so we can do cubectl
08:33 - apply
08:35 - minus f and
08:38 - start our services and they will all
08:40 - start
08:41 - in a default namespace
08:44 - and you see a bunch of them got created
08:47 - we have deployment and service for each
08:49 - one of those
08:50 - and now if i do cubectl getpod
08:53 - again it's in default so directly here
08:56 - you see
08:57 - a list of them and all of them are
08:59 - getting created
09:00 - so we're gonna wait for this one to
09:02 - initialize
09:03 - and start and make this smaller so we
09:05 - can see better
09:07 - and let's do get pod again
09:10 - and there you go all the pods are now
09:12 - running
09:13 - all the micro services and it took
09:15 - actually around eight minutes for all of
09:17 - them to
09:18 - come up and get in the running status
09:21 - so you might have to just wait a little
09:24 - bit for that
09:25 - and also i guess because we are
09:27 - deploying all this in mini cube and
09:29 - because of limited resources
09:31 - it's also a little bit slower so i
09:33 - assume in a bigger cluster
09:34 - this should be a little faster when
09:36 - you're deploying
09:38 - complex microservice applications in
09:40 - kubernetes
09:41 - managing your application data will be
09:43 - challenging however
09:44 - caston who is sponsoring this video has
09:47 - made data management in kubernetes way
09:49 - easier
09:50 - using its k10 data management platform
09:54 - k10 basically takes off most of the load
09:57 - of doing backup and restore in
09:58 - kubernetes
09:59 - from the cluster administrators it has a
10:02 - very simple ui so it's super easy to
10:04 - work with
10:05 - and intelligent logic which does all the
10:08 - heavy lifting for you
10:09 - on top of that casting integrates with
10:12 - all major cloud platforms
10:14 - so you can easily migrate your
10:16 - application from one cluster
10:18 - to another with all of its data and
10:20 - casting does all of that with
10:22 - end-to-end security in mind you can
10:24 - check them out at casting.io
10:27 - now back to our istio setup so now we
10:30 - have our istio core
10:32 - and we have the microservices running as
10:34 - pods
10:35 - now note one thing here that each micro
10:38 - service
10:39 - has one container inside the pod
10:42 - right and you remember i said that istio
10:45 - should
10:46 - actually inject these proxy containers
10:49 - in each of those pots
10:50 - so why don't we have two containers
10:53 - inside each pot
10:54 - or basically why don't we have the proxy
10:56 - containers inside
10:57 - and the reason is because we didn't
10:59 - explicitly tell istio
11:01 - to inject proxies in the application
11:04 - parts
11:05 - and it doesn't work by default right it
11:08 - doesn't
11:08 - inject proxies into every pod that
11:10 - starts in the cluster
11:12 - we actually have to configure that
11:14 - specifically
11:15 - and the configuration for that is
11:17 - actually very simple
11:21 - what we do is basically we label a
11:24 - namespace
11:25 - with a label called istio injection
11:27 - enabled
11:28 - now how do we label namespaces first of
11:31 - all let's actually
11:32 - see the labels that our namespace has
11:37 - and we're deploying our applications or
11:39 - microservice applications in the default
11:41 - namespace
11:42 - so that's the namespace we're going to
11:44 - be labeling so qctl get namespace
11:46 - default and what you can do is show
11:50 - labels and this will give you
11:53 - a list of labels for a namespace
11:56 - and actually you can do this or you can
11:58 - add these
11:59 - show labels option for any other
12:02 - kubernetes component
12:03 - like pods and services etc because
12:07 - all these components can have labels so
12:10 - default namespace has no labels and in
12:13 - order to add the label
12:14 - again very easy we do cubectl label
12:19 - namespace default
12:23 - so name of the namespace basically and
12:25 - finally we
12:26 - define that specific label again it's a
12:29 - key value pair
12:30 - and the key is istio
12:33 - injection and value is
12:36 - enabled so this is something that istio
12:39 - will understand
12:40 - so we have to name this exactly that is
12:44 - to injection enabled
12:45 - let's execute and now if i do
12:49 - get or show labels again for namespace
12:53 - right here you see that label got edit
12:55 - and you can add as many labels as you
12:57 - want
12:57 - to any component so now we can actually
13:00 - shut down
13:01 - all these parts all those micro services
13:04 - and then recreate them to see the
13:06 - proxies
13:07 - being injected so
13:11 - we're going to do cube ctl delete
13:17 - the manifest let's delete all of them
13:23 - if i do cube ctl get pot now i should
13:26 - see all of them terminating
13:30 - and now all the pods are gone we can now
13:33 - just
13:34 - reapply this kubernetes manifests file
13:40 - like this and note here that i have
13:42 - actually not done
13:43 - anything to the existing kubernetes
13:46 - configuration files right
13:48 - all we did is basically just label the
13:50 - namespace
13:51 - and we're doing exactly what we did
13:53 - previously just apply the kubernetes
13:55 - manifest file
13:56 - without any modification there right and
13:58 - that's the great thing about istio that
14:00 - you don't have to
14:02 - reconfigure your existing configuration
14:05 - or the
14:05 - existing kubernetes configuration files
14:09 - for the proxies to get injected and now
14:12 - if i do cube ctl get pod
14:14 - instead of one container per pod you see
14:17 - two containers
14:18 - which are all initializing and this will
14:22 - take some time as well
14:23 - and there you go all the pots are now
14:25 - running and this actually took
14:27 - just two minutes to start this time and
14:31 - again as you see two containers per pot
14:34 - and now i'm actually going to describe
14:36 - one of those parts
14:39 - let's take the first one and in this
14:42 - describe we're going to see
14:44 - the containers in that pot
14:47 - so if we scroll up
14:51 - right here we have init containers
14:54 - is still in it and this is istio proxy
14:58 - image and then in the container section
15:01 - we have
15:02 - our microservices application image
15:04 - itself
15:05 - so basically this part here or the init
15:08 - container
15:09 - got automatically injected in this part
15:12 - by istio because we don't have that
15:15 - container
15:16 - definition inside this kubernetes
15:18 - manifests file
15:22 - so if i open this manifest file and
15:24 - search for it there is no proxy
15:27 - container definition here or init
15:28 - container
15:29 - so this is done by issue automatically
15:37 - so now we have the istio component
15:39 - running in a cluster
15:40 - that automatically injects the invoice
15:43 - proxy container
15:44 - into every pod that we create in a
15:47 - default namespace
15:49 - so we have all that configuration
15:51 - already set up
15:52 - now that's all great but we don't have
15:55 - any
15:56 - data visualization for what's going on
15:58 - in our micro services
16:00 - right so theoretically if you know
16:03 - istio again i explained that all in
16:05 - detail in this what is istio section
16:07 - but istio actually collects the metrics
16:10 - from all these proxy containers so you
16:13 - have all these
16:14 - data about how your microservices are
16:17 - performing
16:18 - what kind of requests they're getting
16:19 - metrics data and so on
16:22 - but we don't see any of this here right
16:24 - and this is where
16:25 - istio add-ons come in and in the
16:28 - istio official documentation you
16:30 - actually see this integrations part
16:33 - and these are add-ons or additional
16:36 - elements that you can install with eco
16:39 - that will give you all this data
16:40 - visualization about the metrics
16:43 - tracing and basically what your micro
16:45 - services are doing and how they are
16:47 - performing
16:48 - so we're going to install some of those
16:50 - add-ons in our cluster now
16:52 - and that is also very simple
16:55 - so in this e-sto folder here where we
16:58 - have this binary for
17:00 - istio control or ctl we have
17:03 - a folder called samples and inside
17:05 - samples
17:07 - we have a folder called add-ons
17:10 - and these are actually just kubernetes
17:12 - configuration files
17:14 - for those services right
17:17 - so the integrations that are listed here
17:19 - for grafana jaeger
17:21 - prometheus etc we have
17:24 - those files or configuration files for
17:26 - those services
17:27 - in that istio installation folder and in
17:30 - order to install them in a cluster
17:33 - we're gonna apply those kubernetes yaml
17:36 - files
17:37 - using cubectl apply command in a cluster
17:40 - very straightforward so again i'm in the
17:44 - istio installation folder
17:47 - so from here i can do cube ctl apply
17:51 - and then in istio 190
17:55 - i have samples and add-ons
17:58 - and i can apply those files one by one
18:01 - or if i want to apply
18:02 - all the configuration files in the
18:04 - folder i can do it
18:06 - like this so execute and
18:09 - there you go so you see that a bunch of
18:11 - stuff got created we have
18:12 - services deployments config maps etc you
18:15 - actually don't need to understand all
18:17 - those
18:18 - components what's important now is if i
18:21 - let's actually clean this up
18:25 - if i do cube ctl get pod
18:29 - from the istio system namespace where we
18:32 - had two parts running if you remember
18:35 - and now we have grafana jaeger
18:38 - kiali and prometheus parts running
18:42 - or prometheus is starting up let's do it
18:44 - again and there you go
18:46 - so now we have those four add-ons
18:50 - running as pods in istio system
18:54 - and in order to access those parts
18:58 - obviously we need services
19:00 - so let's check that as well istio
19:03 - system and we're going to quickly go
19:06 - through each one of those services that
19:08 - are deployed as
19:10 - istio add-ons in the cluster first we
19:12 - have
19:13 - graffana and prometheus and
19:16 - if you don't know prometheus is used for
19:18 - basically monitoring
19:19 - anything in your cluster this could be
19:22 - the servers
19:23 - itself memory cpu usage
19:26 - as well as kubernetes components
19:28 - themselves like pods and
19:29 - services and all this stuff so this is a
19:32 - monitoring tool
19:33 - and grafana is a data visualization tool
19:37 - for metrics data now if you want to know
19:39 - more details about prometheus and
19:41 - grafana i actually have a separate video
19:43 - on that
19:44 - as well as how to deploy prometheus
19:47 - in your cluster so you can go ahead and
19:50 - check that out
19:51 - if you want to know more as a next one
19:54 - we have
19:54 - jaeger collector and tracing this is
19:58 - actually
19:58 - a service for tracing microservice
20:02 - requests
20:03 - now if you know how microservices
20:06 - application
20:07 - works you basically get a request in
20:09 - your application
20:10 - and then that request goes through
20:12 - multiple microservices right
20:14 - so the request basically gets forwarded
20:17 - multiple
20:18 - times and that creates a chain of
20:20 - requests
20:21 - for one request that a user initiated
20:25 - and tracing service basically helps you
20:28 - trace that whole chain of requests of
20:30 - microservices
20:31 - from one microservice to another and
20:34 - with jager you can then
20:36 - visualize that data right you can see
20:38 - those tracing
20:39 - data for those requests and you can use
20:42 - that to analyze and debug and see where
20:45 - the request basically slows down etc so
20:48 - that's tracing
20:49 - and we also have zipkin here which
20:52 - actually is an
20:53 - alternative to jager right so in your
20:56 - cluster
20:56 - when you deploy istio add-ons you should
20:59 - have just
20:59 - one of those two and the reason why we
21:01 - have a zip key in here as well
21:04 - is because in this addons folder we have
21:06 - grafana jaeger kiali prometheus
21:09 - but we also have this extras folder
21:11 - which
21:12 - contains the zipkin yaml file right so
21:15 - that one also got deployed because it's
21:17 - also a kubernetes
21:18 - configuration file so we have it here as
21:21 - well as we have prometheus operator yaml
21:23 - file in this extras folder
21:25 - which basically is configuration
21:28 - to monitor the easter components
21:31 - themselves
21:32 - with prometheus and for this to work you
21:34 - actually have to have prometheus
21:36 - operator already installed
21:38 - in your cluster which we don't have in
21:41 - our cluster
21:42 - now again if you want to know the
21:43 - difference between prometheus operator
21:45 - and this prometheus or what grafana is
21:48 - i have own video about that that
21:50 - explains all these in detail so you can
21:52 - go watch that
21:53 - and finally we have a service here
21:56 - called kiali which is actually
21:58 - my favorite service for working with
22:01 - microservices because it has
22:03 - an amazing data visualization features
22:06 - as well as features to actually
22:09 - configure
22:10 - your services setup and communication
22:13 - so we're going to take a quick look on
22:16 - kiali
22:16 - and how it looks and basically we have
22:19 - all types of visualization
22:21 - including the monitoring data in the
22:24 - tracing data
22:25 - because it's so cool actually we're
22:26 - going to take a very quick look at
22:28 - kiali specifically in our demo
22:35 - in order to access kiali we need access
22:37 - to its service so i'm gonna do
22:39 - cube ctl port forward
22:44 - and this is a service kiali
22:48 - in an istio system namespace
22:53 - and as a final parameter for port
22:56 - forward we need
22:57 - the port of that service so this will
23:01 - configure port forwarding for this
23:03 - internal service which we can't access
23:05 - from outside
23:06 - so i will be able to access it locally
23:09 - localhost on this port
23:10 - so let's execute and
23:14 - that's the address and let's
23:18 - open it here
23:22 - and there you go this is actually kiali
23:25 - dashboard or view and we have default
23:28 - namespace and istio system namespace
23:31 - and we have 12 applications running in a
23:34 - default namespace and these are actually
23:36 - our microservice applications and if i
23:38 - click inside here
23:40 - i switch to applications and i see
23:43 - basically some data about the
23:44 - applications but the coolest
23:46 - feature or part is the graph here
23:49 - if i load this graph
23:53 - so actually make the graph bigger and
23:56 - right here you see
23:58 - the network of our microservices
24:02 - visualized in this form
24:05 - and kali overview and how it works could
24:07 - actually be its own video but
24:09 - just to give you a very quick idea you
24:11 - see that
24:12 - just by looking at this graph even if
24:14 - you have no idea about
24:16 - how those micro services are implemented
24:19 - you actually
24:20 - see how they communicate with each other
24:22 - which microservice talks to which one
24:25 - and so on and
24:29 - in the service graph basically you see
24:31 - these are kubernetes
24:33 - services basically that are
24:36 - interconnected so you see frontend talks
24:39 - to the recommendation service which
24:40 - talks to product
24:41 - catalog service etc and then per
24:45 - application as i mentioned you have
24:49 - metrics and traces and everything
24:52 - also in one place in kiali so you have
24:55 - the traffic
24:56 - inbound metrics traces etc
25:00 - again there there is much more to kiyali
25:02 - which could be
25:03 - its own video but you can definitely
25:05 - just play around with it and
25:07 - check out some features but there's just
25:10 - one final thing that i want to
25:13 - mention about istio configuration
25:16 - and how all of this actually works
25:22 - i mentioned that for istio configuration
25:25 - you actually don't need to adjust
25:27 - anything in your kubernetes
25:28 - configuration files
25:30 - but there's actually one thing that you
25:32 - need to do or you need to have
25:34 - in your manifest files for your
25:36 - deployments and services
25:39 - for this graph here
25:42 - to work or this display here to work and
25:45 - that is
25:46 - a label called app right right here you
25:49 - see
25:50 - label f and name of the microservice
25:55 - and if i search for it you see all the
25:58 - occurrences we have them
25:59 - in services and
26:02 - deployments and app label
26:06 - actually has a special meaning in istio
26:09 - so whenever you're deploying your
26:12 - microservices
26:13 - in istio enabled cluster you actually
26:15 - have to have this
26:16 - app label on your deployments and
26:18 - services
26:20 - for the data visualization to work i
26:22 - mean the pods will still deploy you will
26:24 - not have any errors
26:26 - but the visualization will not work like
26:29 - this right
26:30 - and as you see here the names at service
26:33 - front end
26:33 - these actually are the values of app
26:37 - label here and in the applications tab
26:42 - also as you see we have
26:45 - for each application these are the
26:49 - deployments basically
26:50 - you have these app label so that's how
26:54 - istio basically knows how to visualize
26:56 - your application graph
26:58 - and the communication like this
27:01 - so that's the one thing you would
27:03 - probably need to adjust in your
27:04 - kubernetes configuration files so that's
27:07 - how you install
27:08 - istio in your cluster how you deploy
27:10 - additional
27:11 - add-ons in order to visualize metrics
27:14 - data
27:15 - and communication data between your
27:17 - microservices
27:18 - and how to configure your cluster for
27:20 - istio proxy injection
27:23 - thank you for watching and see you in
27:25 - the next video

Cleaned transcript:

in this video we're gonna learn how to install istio service mesh in a kubernetes cluster first we will install istio core in the cluster the main istio component then we will install istio addons for monitoring and tracing after that we will configure our cluster so that estio can automatically inject invoice proxies in our application pods and finally we will deploy an example demo microservices application in the cluster so that we can see all the features and visualization for those microservices in istio and for this demonstration we're going to use a local minicube cluster so let's jump right in now if you want to learn what istio is and what it's used for you can watch my other video about it where i explain what service mesh is and what istio is and all of its use cases and then you can come back and learn the setup of istio in your kubernetes cluster so the first thing we need to do is create or start our mini cube cluster and one note here is that istio will actually need some resources so the default resources that minicube cluster gets created with will not be enough so in the minicube start command we're going to provide options to increase the cpu and memory resources that our minicube cluster gets and this resource configuration should be now enough for our demonstration so make sure to set those resources high and we're gonna start a mini cube cluster so now that we have our mini cube cluster running with enough resources we can actually install issio and the first thing to installing istio is to download istio release package locally on our computer and on istio's official documentation page actually you have a guide to installing istio and in this guide we have link to istio releases you can also download the latest istio release for your specific operating system using this command here but we're going to do this using this istio release link and here you have all the releases we're going to install the latest one and i'm using mac so that's what i'm going to download make sure to download the one for your operating system and as you see this is a tar file so basically we just unpack it or unturn it and we'll see what's inside so what i'm going to do is i'm going to create a folder in my home directory i'm going to call it istio installation and i'm gonna move that downloaded istio tar file to that folder like this and let's go to eastern installation and right here is our tar file so that's the east installation folder and here we have the tar file i'm just gonna double click and unpack it and let's actually see what's inside we have the executable istio binary folder and some other files and what we're going to need from istio is actually an istio control command line which is in this binary folder and we want that command line tool to be executable and right now if i do istio ctl and execute you see command not found so we need that command which is here in the binary folder so in order to make that command available we're gonna add it to a path right to executable path and we can do that by adding the path to this binary folder to our path right basically appending it so right now this is how my path looks like like this and basically here we just want to append the path to this folder here let's actually find out what the path is i'm going to go inside that istio folder like this and i'm going to print out the path that's it this whole thing here and now we can append that to the path variable right so we have the original one the path and separator and we're just gonna add this one here slash bin and there you go i'm going to execute it and now if i do istio ctl and execute there you go so we have istio ctl available or istio control command line interface available here because we set the path now just note that this only sets that path or appends that executable only in this terminal so if i open a new window and try to do istio ctl here you see command not found so it only works wherever you execute this export command so let's close it and there you go we have downloaded istio and now we have istio ctl available and now as a next step we're gonna install istio with this istio ctl command inside our mini cube cluster so first of all i'm gonna do get namespace and let's see that we have just these default namespaces so no istio namespace here and right now also nothing running right so we have an empty cluster and now let's install istio in our cluster and we can do that very easily using istio ctl install command that's it i'm going to execute it and i'm going to confirm it here yes and everything is successfully installed we have istio core then we have istiod which is the main process of istio or main component and ingress gateway so now if i do cube ctl get namespace right here you see istio system namespace got created and let's actually check what's inside there let's print out the pots and there you go we have an istiod pod running here as well as istio ingress gateway now if you already know the istio service mesh architecture you know that we have this istiod component which is a control plane and we have the data plane which are basically the proxies that are injected into application pods right so if you have a micro service application you would have pod for each micro service and then istio would inject proxy and envoy proxy in each of those micro service pods so that means in order to see istio in action and in order to see those invoice proxies we need to deploy an application a micro services application ideally where the proxies will be injected so that's going to be our next step and as an example microservices i have found actually one from google cloud platform microservices demo project and we're going to use this one to deploy that in the cluster and then use istio service mesh for this micro services so in this release folder here you have kubernetes manifests and these are basically kubernetes configuration files for creating deployments and services for a couple of micro services so you can clone this repository and we're going to be using this specific file i have cloned the repo and i have that specific file now in this istio installation folder right here so that i can execute it directly from here so right now i'm inside istio folder and this is my manifests file so obviously this is just kubernetes manifest files so we can do cubectl apply minus f and start our services and they will all start in a default namespace and you see a bunch of them got created we have deployment and service for each one of those and now if i do cubectl getpod again it's in default so directly here you see a list of them and all of them are getting created so we're gonna wait for this one to initialize and start and make this smaller so we can see better and let's do get pod again and there you go all the pods are now running all the micro services and it took actually around eight minutes for all of them to come up and get in the running status so you might have to just wait a little bit for that and also i guess because we are deploying all this in mini cube and because of limited resources it's also a little bit slower so i assume in a bigger cluster this should be a little faster when you're deploying complex microservice applications in kubernetes managing your application data will be challenging however caston who is sponsoring this video has made data management in kubernetes way easier using its k10 data management platform k10 basically takes off most of the load of doing backup and restore in kubernetes from the cluster administrators it has a very simple ui so it's super easy to work with and intelligent logic which does all the heavy lifting for you on top of that casting integrates with all major cloud platforms so you can easily migrate your application from one cluster to another with all of its data and casting does all of that with endtoend security in mind you can check them out at casting.io now back to our istio setup so now we have our istio core and we have the microservices running as pods now note one thing here that each micro service has one container inside the pod right and you remember i said that istio should actually inject these proxy containers in each of those pots so why don't we have two containers inside each pot or basically why don't we have the proxy containers inside and the reason is because we didn't explicitly tell istio to inject proxies in the application parts and it doesn't work by default right it doesn't inject proxies into every pod that starts in the cluster we actually have to configure that specifically and the configuration for that is actually very simple what we do is basically we label a namespace with a label called istio injection enabled now how do we label namespaces first of all let's actually see the labels that our namespace has and we're deploying our applications or microservice applications in the default namespace so that's the namespace we're going to be labeling so qctl get namespace default and what you can do is show labels and this will give you a list of labels for a namespace and actually you can do this or you can add these show labels option for any other kubernetes component like pods and services etc because all these components can have labels so default namespace has no labels and in order to add the label again very easy we do cubectl label namespace default so name of the namespace basically and finally we define that specific label again it's a key value pair and the key is istio injection and value is enabled so this is something that istio will understand so we have to name this exactly that is to injection enabled let's execute and now if i do get or show labels again for namespace right here you see that label got edit and you can add as many labels as you want to any component so now we can actually shut down all these parts all those micro services and then recreate them to see the proxies being injected so we're going to do cube ctl delete the manifest let's delete all of them if i do cube ctl get pot now i should see all of them terminating and now all the pods are gone we can now just reapply this kubernetes manifests file like this and note here that i have actually not done anything to the existing kubernetes configuration files right all we did is basically just label the namespace and we're doing exactly what we did previously just apply the kubernetes manifest file without any modification there right and that's the great thing about istio that you don't have to reconfigure your existing configuration or the existing kubernetes configuration files for the proxies to get injected and now if i do cube ctl get pod instead of one container per pod you see two containers which are all initializing and this will take some time as well and there you go all the pots are now running and this actually took just two minutes to start this time and again as you see two containers per pot and now i'm actually going to describe one of those parts let's take the first one and in this describe we're going to see the containers in that pot so if we scroll up right here we have init containers is still in it and this is istio proxy image and then in the container section we have our microservices application image itself so basically this part here or the init container got automatically injected in this part by istio because we don't have that container definition inside this kubernetes manifests file so if i open this manifest file and search for it there is no proxy container definition here or init container so this is done by issue automatically so now we have the istio component running in a cluster that automatically injects the invoice proxy container into every pod that we create in a default namespace so we have all that configuration already set up now that's all great but we don't have any data visualization for what's going on in our micro services right so theoretically if you know istio again i explained that all in detail in this what is istio section but istio actually collects the metrics from all these proxy containers so you have all these data about how your microservices are performing what kind of requests they're getting metrics data and so on but we don't see any of this here right and this is where istio addons come in and in the istio official documentation you actually see this integrations part and these are addons or additional elements that you can install with eco that will give you all this data visualization about the metrics tracing and basically what your micro services are doing and how they are performing so we're going to install some of those addons in our cluster now and that is also very simple so in this esto folder here where we have this binary for istio control or ctl we have a folder called samples and inside samples we have a folder called addons and these are actually just kubernetes configuration files for those services right so the integrations that are listed here for grafana jaeger prometheus etc we have those files or configuration files for those services in that istio installation folder and in order to install them in a cluster we're gonna apply those kubernetes yaml files using cubectl apply command in a cluster very straightforward so again i'm in the istio installation folder so from here i can do cube ctl apply and then in istio 190 i have samples and addons and i can apply those files one by one or if i want to apply all the configuration files in the folder i can do it like this so execute and there you go so you see that a bunch of stuff got created we have services deployments config maps etc you actually don't need to understand all those components what's important now is if i let's actually clean this up if i do cube ctl get pod from the istio system namespace where we had two parts running if you remember and now we have grafana jaeger kiali and prometheus parts running or prometheus is starting up let's do it again and there you go so now we have those four addons running as pods in istio system and in order to access those parts obviously we need services so let's check that as well istio system and we're going to quickly go through each one of those services that are deployed as istio addons in the cluster first we have graffana and prometheus and if you don't know prometheus is used for basically monitoring anything in your cluster this could be the servers itself memory cpu usage as well as kubernetes components themselves like pods and services and all this stuff so this is a monitoring tool and grafana is a data visualization tool for metrics data now if you want to know more details about prometheus and grafana i actually have a separate video on that as well as how to deploy prometheus in your cluster so you can go ahead and check that out if you want to know more as a next one we have jaeger collector and tracing this is actually a service for tracing microservice requests now if you know how microservices application works you basically get a request in your application and then that request goes through multiple microservices right so the request basically gets forwarded multiple times and that creates a chain of requests for one request that a user initiated and tracing service basically helps you trace that whole chain of requests of microservices from one microservice to another and with jager you can then visualize that data right you can see those tracing data for those requests and you can use that to analyze and debug and see where the request basically slows down etc so that's tracing and we also have zipkin here which actually is an alternative to jager right so in your cluster when you deploy istio addons you should have just one of those two and the reason why we have a zip key in here as well is because in this addons folder we have grafana jaeger kiali prometheus but we also have this extras folder which contains the zipkin yaml file right so that one also got deployed because it's also a kubernetes configuration file so we have it here as well as we have prometheus operator yaml file in this extras folder which basically is configuration to monitor the easter components themselves with prometheus and for this to work you actually have to have prometheus operator already installed in your cluster which we don't have in our cluster now again if you want to know the difference between prometheus operator and this prometheus or what grafana is i have own video about that that explains all these in detail so you can go watch that and finally we have a service here called kiali which is actually my favorite service for working with microservices because it has an amazing data visualization features as well as features to actually configure your services setup and communication so we're going to take a quick look on kiali and how it looks and basically we have all types of visualization including the monitoring data in the tracing data because it's so cool actually we're going to take a very quick look at kiali specifically in our demo in order to access kiali we need access to its service so i'm gonna do cube ctl port forward and this is a service kiali in an istio system namespace and as a final parameter for port forward we need the port of that service so this will configure port forwarding for this internal service which we can't access from outside so i will be able to access it locally localhost on this port so let's execute and that's the address and let's open it here and there you go this is actually kiali dashboard or view and we have default namespace and istio system namespace and we have 12 applications running in a default namespace and these are actually our microservice applications and if i click inside here i switch to applications and i see basically some data about the applications but the coolest feature or part is the graph here if i load this graph so actually make the graph bigger and right here you see the network of our microservices visualized in this form and kali overview and how it works could actually be its own video but just to give you a very quick idea you see that just by looking at this graph even if you have no idea about how those micro services are implemented you actually see how they communicate with each other which microservice talks to which one and so on and in the service graph basically you see these are kubernetes services basically that are interconnected so you see frontend talks to the recommendation service which talks to product catalog service etc and then per application as i mentioned you have metrics and traces and everything also in one place in kiali so you have the traffic inbound metrics traces etc again there there is much more to kiyali which could be its own video but you can definitely just play around with it and check out some features but there's just one final thing that i want to mention about istio configuration and how all of this actually works i mentioned that for istio configuration you actually don't need to adjust anything in your kubernetes configuration files but there's actually one thing that you need to do or you need to have in your manifest files for your deployments and services for this graph here to work or this display here to work and that is a label called app right right here you see label f and name of the microservice and if i search for it you see all the occurrences we have them in services and deployments and app label actually has a special meaning in istio so whenever you're deploying your microservices in istio enabled cluster you actually have to have this app label on your deployments and services for the data visualization to work i mean the pods will still deploy you will not have any errors but the visualization will not work like this right and as you see here the names at service front end these actually are the values of app label here and in the applications tab also as you see we have for each application these are the deployments basically you have these app label so that's how istio basically knows how to visualize your application graph and the communication like this so that's the one thing you would probably need to adjust in your kubernetes configuration files so that's how you install istio in your cluster how you deploy additional addons in order to visualize metrics data and communication data between your microservices and how to configure your cluster for istio proxy injection thank you for watching and see you in the next video
