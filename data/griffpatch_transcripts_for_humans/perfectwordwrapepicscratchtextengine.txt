With timestamps:

00:02 - hello fellow scratchers today we are
00:05 - going to unravel the mysteries of word
00:07 - wrapping specifically how to extend our
00:09 - text engine to wrap any length of text
00:11 - neatly within a specified rectangular
00:14 - boundary but how are we going to get
00:16 - scratched to break up our text at the
00:17 - right points or to handle extra long
00:20 - text that overflows an entire line
00:22 - well stay tuned to find out as we
00:25 - continue this awesome series coding a
00:27 - text engine in scratch so as we begin
00:31 - load up your episode 2 projects and
00:33 - let's save them as a new copy
00:36 - but this is episode
00:38 - um oh okay you got me this is episode 3
00:41 - i promise anyhow guys let's get
00:44 - scratching
00:46 - so word wrapping this will look cool if
00:49 - we have some kind of page or dialogue to
00:51 - write upon to create a new sprite named
00:54 - page
00:56 - for the costume i'm going to draw a
00:57 - simple rectangle in pastel yellow like a
01:00 - post-it i'm making sure it's nice and
01:02 - central now we can spend lots of time
01:04 - later making this look awesome but for
01:07 - now this will do
01:09 - when you run the project you may find
01:11 - that the text has moved behind the new
01:13 - page sprite no problem click into the
01:15 - font sprite and for the time being under
01:18 - the when i receive test script just drop
01:21 - in a go to front right away the text
01:23 - springs to the front great
01:27 - so we have a nice page but we don't want
01:30 - our text flowing right up to the
01:32 - costumes edges no indeed so we'll try to
01:35 - define our actual text bounds as a
01:37 - rectangle within this page giving us a
01:40 - simple margin
01:41 - a rectangle can be defined by its top
01:44 - left and bottom right points we'll call
01:46 - these x1 y1 and x2 y2
01:50 - let's make a new custom block to make
01:52 - this easy to define set page left with
01:56 - an input of x1
01:58 - the label top
02:00 - with an input of y1
02:03 - and then a label right
02:05 - with an input of x2
02:08 - and the bottom label
02:10 - with an input of y2
02:13 - click to run without screen refresh and
02:15 - we are ready now these values we will
02:19 - store in four new variables first one
02:22 - page l
02:24 - for page left
02:26 - setting it to x1
02:31 - and page t for page top
02:35 - setting it to y1
02:40 - page r for page right
02:44 - setting it to you guessed it
02:46 - x2 and lastly page b for page bottom
02:51 - setting it to y2
02:54 - so let's set up the page dimensions now
02:57 - under our when i receive test script
03:00 - drop in the new set page block
03:03 - so how can we tell what screen location
03:06 - the top left corner should be set to hmm
03:09 - tricky in scratch 3 well if you have
03:12 - scratch add-ons then actually it's not i
03:14 - just hover my mouse at the location i
03:16 - want and the mouse location add-on shows
03:19 - me where i am it's like negative 150 by
03:23 - 90. no need to be super accurate and
03:26 - type the value in
03:28 - but if you have not got scratch add-ons
03:30 - then how can we find out our location
03:32 - well how about this when space key
03:35 - pressed ask
03:38 - mousex
03:40 - and we can ask mouse y2
03:43 - then hover over the position we want to
03:45 - know and press the space
03:47 - so that's an x of 159
03:51 - but of course we want the margins to be
03:53 - symmetrical so i'm actually going to put
03:54 - in an x of 150
03:57 - and then i'll reposition again and it's
03:59 - a y of negative 31. i just pressed enter
04:02 - to find out okay brilliant so we have
04:05 - our page bounds defined next up we need
04:08 - to make sure when we write to the screen
04:11 - the text will appear at the top of the
04:13 - page rather than at our mouse cursor
04:15 - that was so episode 2.
04:17 - so we make our way over to the define
04:20 - right block
04:21 - when our text is left aligned the
04:23 - position of the text is set here set xx
04:26 - to the input x
04:29 - well no longer these inputs are going to
04:31 - go in favor of using the page bounds
04:35 - and for the left align text that will be
04:38 - page l the left edge of the page now
04:42 - before i forget we also want to remove
04:43 - the set y block here we will assume the
04:46 - y position is already set before we
04:49 - begin to write to the screen that's a
04:51 - bit of a change but don't worry about
04:53 - that right yet
04:55 - now what about the other alignments
04:57 - let's look at the right align text that
05:00 - will want to be offset relative now to
05:02 - the right hand edge of the page so we
05:04 - enter page r page right and subtract the
05:07 - width of the text and that's it
05:10 - centering takes a little more thought we
05:12 - need to find the center of the page
05:14 - bounds
05:15 - to calculate this we need to take the
05:17 - average of the left and right edges of
05:19 - the page
05:21 - that is the sum of page l and page r
05:26 - and then we'll need to divide by two but
05:29 - hold on because then we subtract with
05:32 - divided by two well if these are all
05:35 - being divided by two we can simplify
05:37 - this by subtracting the width from page
05:39 - r plus page l
05:42 - and then divide the whole thing by 2
05:44 - afterwards got that
05:46 - excellent
05:48 - but now the x and y inputs are
05:50 - completely unused within this custom
05:52 - block
05:53 - but also the sprite's y position is
05:56 - never set
05:58 - what we'll do is come back over to the
06:00 - when i receive test script and drop in a
06:03 - set y position
06:05 - right before setting the pages
06:06 - dimensions
06:08 - setting y2 of course page top
06:12 - now our text will begin at the top of
06:13 - the page let's slap that green flag and
06:16 - see what we've got
06:19 - well yes the good news is that our text
06:22 - has appeared somewhere near where we
06:23 - wanted it to begin
06:25 - the downside is that both lines of text
06:27 - are located one on top of the other
06:30 - not surprising considering the y
06:32 - position of our right block is no longer
06:34 - used
06:36 - easy to fix scroll back to the define
06:38 - right block and down to the bottom
06:41 - and once we've written out a line of
06:43 - text
06:44 - we want to advance to the next line so
06:47 - change y by
06:49 - and we are moving downwards so use a
06:52 - zero subtract and drop in the line
06:55 - height variable
06:57 - there we go looking much better i'm glad
07:00 - we set up that variable so every use of
07:03 - the right will advance the text to the
07:05 - next line
07:07 - so what is the point of keeping this y
07:09 - position input now
07:10 - well absolutely no point at all let them
07:13 - be gone
07:15 - edit the write block and delete the x
07:18 - and y labels and inputs wow i hope you
07:21 - did make a copy of your project because
07:23 - it's a hard journey back from these
07:25 - changes
07:26 - i'll just tidy up these orphaned
07:28 - variables
07:33 - and as you can see running the project
07:35 - shows no ill effects from the changes
07:37 - since those inputs really weren't used
07:40 - any longer
07:41 - and if i duplicate the last right block
07:43 - you can see that the auto advancement of
07:45 - the y position works a treat without any
07:47 - further work required really like how
07:50 - that is working
07:52 - let's also check out the center
07:54 - alignment so that now is centered on the
07:56 - page rather than our mouse cursor and
07:59 - the writer line is likewise now aligned
08:02 - to the right-hand edge of the page
08:03 - bounce very cool
08:06 - so then this is where it gets exciting
08:10 - we've mastered positioning and aligning
08:12 - to the page bounds but if we enter a
08:15 - longer line of text in here
08:17 - the text is still allowed to overflow
08:19 - the page bounce and this looks as ugly
08:22 - as an ugly thing and that's very ugly
08:25 - indeed it's obvious what our next job
08:28 - must be
08:29 - the most obvious fix might be to place a
08:32 - limit on the x position in the right
08:35 - script check if xx is greater than
08:46 - page r the right hand edge of the page
08:49 - and then set it back to the left edge
08:52 - page l
08:56 - then of course make sure to change y by
08:58 - the negative line height to move the
09:00 - cursor down to the next line
09:02 - so if we were to drop this in after
09:04 - changing xx then
09:07 - not bad right
09:09 - looks to me like we have some
09:10 - rudimentary wrapping going on and yes we
09:13 - do but this is not word wrapping no this
09:17 - is word break wrapping see how the word
09:20 - mostly has been split into mid-word this
09:24 - is not how we want our wrapping to work
09:27 - no word should be split unless it's
09:29 - absolutely necessary
09:32 - so what do we do now well we really want
09:35 - to treat an entire word as a single unit
09:38 - and therefore move any word that does
09:40 - not fit on the page onto the next line
09:43 - as a whole
09:44 - to detect a word all we need to do is
09:46 - look back for the last space before we
09:49 - overflowed the page
09:51 - but hang on
09:54 - if we've already been cloning or
09:56 - stamping letters to the screen then it's
09:58 - already too late the deed has been done
10:01 - so we must detect spaces before
10:04 - we hit the page bounds and before we
10:07 - draw anything to the screen the process
10:09 - should look something like this
10:11 - work out the page width the text length
10:14 - must not exceed this
10:16 - we already have a variable i that as
10:19 - before represents the index of the
10:21 - letter to be written to the screen one
10:23 - is the first letter to the next etc
10:26 - but this stays right where it is while
10:29 - we look ahead to find out what text will
10:31 - fit on the line
10:33 - so we have a new variable wrap i used to
10:37 - trace forward looking for spaces
10:39 - but as we go we will also sum up the
10:41 - letter widths in the variable width as
10:44 - before
10:45 - now this is new
10:46 - if we find a space character then we
10:49 - make a note of where it is storing the
10:51 - last found index in
10:53 - safe i
10:54 - and the width in safe width
10:57 - this keeps a record of the last safe
10:59 - wrapable position
11:01 - if at any point the width becomes too
11:03 - wide to fit on the page we have the safe
11:05 - variables to go back to for drawing our
11:08 - text
11:09 - but otherwise if all the text does fit
11:12 - then we just use the wrap eye and width
11:14 - as they are does that make sense i think
11:17 - so
11:18 - cool then delete the little experimental
11:21 - if
11:22 - and before we add any more code i note
11:24 - this right block is getting really
11:25 - rather long so it's a good time to try
11:28 - to split it up with some custom blocks a
11:30 - prime candidate being this alliance
11:33 - scripts here
11:34 - from the if align equals c to the set i
11:38 - to zero
11:40 - yeah make a new custom block
11:42 - naming it calculate alignment
11:45 - and it will need an input named align
11:48 - just tick run without screen refresh and
11:51 - ok
11:52 - we'll attach this define to the
11:53 - alignment scripts
11:55 - and make use of the new align block here
11:58 - where we took the scripts from
12:00 - we just need to make sure to pass
12:01 - through the align variable so it knows
12:03 - what alignment we are using
12:05 - brilliant join that all back up
12:08 - and i'll move my scripts into some free
12:10 - space
12:11 - if i can find some and a quick tap on
12:14 - the green flag to ensure things are
12:16 - still working tickety boo and yes no
12:20 - changes good change um good news uh yeah
12:23 - so moving quickly on
12:24 - let's get those new variables made so
12:27 - that we can start processing our first
12:29 - line of text
12:30 - so we need a wrap i
12:32 - and for this sprite only
12:34 - safe i
12:36 - for this sprite only
12:40 - save width again for this sprite only
12:44 - and one more i'll name c
12:46 - this one is for storing a single
12:48 - character that is a letter of the text
12:50 - we are processing again make it for this
12:52 - sprite only i'm going to hide them for
12:55 - now
12:56 - okay so because the text will be
12:58 - processed a line at a time we can no
13:01 - longer use a repeat length text here for
13:04 - this reason i'm going to start i at 1
13:07 - instead of 0 and then we can use a
13:10 - repeat until i is greater than
13:14 - the length of text instead
13:18 - move all the contained scripts over into
13:20 - the new loop
13:22 - not forgetting the change y from the end
13:24 - and we can replace that old repeat with
13:26 - this new one great
13:29 - of course since we start i at one
13:31 - instead of zero the change i by one
13:34 - needs to move down to be the last block
13:36 - in the repeat
13:38 - do you see how this works we start at
13:40 - letter one and check each time that the
13:42 - letter index has not gone past the end
13:45 - of the text string
13:46 - again we can give it a test and it still
13:49 - is working but no magic wrapping yet oh
13:52 - no this is what we'll start work on now
13:56 - you know what make one more variable
13:58 - that i forgot name it page width for
14:02 - this sprite only
14:03 - we want to know the maximum width of
14:05 - text that can fit on the page
14:08 - we get that by setting page width to a
14:11 - subtract operator and subtract page left
14:14 - page l from page r page right stick that
14:18 - at the top of the write script
14:20 - now let's set up the wrap i variable
14:23 - ready to start scanning across the text
14:25 - set wrap i to and this time yes we do
14:29 - set it to zero this will make comparing
14:31 - the i variable to the rapid variable
14:34 - that little bit easier you'll see
14:36 - and here we go make a custom block
14:39 - naming it find text wrap index
14:42 - and definitely tick that run without
14:45 - screen refresh
14:46 - we'll make use of it right away sticking
14:48 - it in after we've set wrap eye to zero
14:51 - but before we calculate the alignment
14:53 - that makes sense as we will need to
14:54 - align whatever length of text comes back
14:56 - from using this new block
14:58 - okay so this new defined block it's
15:01 - going to initially have a very similar
15:03 - function than our old get width of text
15:06 - block in fact it is destined to replace
15:09 - it altogether
15:10 - however we don't need to set txt as this
15:14 - has already been done in the right
15:16 - script before we get here
15:17 - what we do need is to set width to zero
15:21 - the loop again can't use a repeat length
15:24 - as we can't say how many letters we will
15:26 - need to repeat for so let's instead use
15:29 - a forever loop we'll find other ways to
15:31 - break out of it so don't worry it won't
15:33 - be forever really
15:35 - now duplicate the scripts from the
15:37 - previous get width of text loop into our
15:39 - forever loop
15:41 - this too wants to check along the text
15:43 - calculating the combined width
15:45 - however it's using the wrong variables
15:48 - switch the i variables or wrap i
15:51 - variables including the one in the
15:53 - switch costume here
15:54 - great that's right but we will need to
15:57 - check the value of this letter to look
15:59 - out for spaces so rather than use the
16:02 - letter of block more than once to get
16:04 - the same letter again we'll set the
16:06 - variable c before we switch costumes to
16:09 - the letter wrap i of text and then pop
16:12 - that c variable in the second switch
16:14 - costume
16:15 - so now we are free to check if
16:19 - c is equal to
16:22 - but for starters don't put a space on
16:25 - the right hand side no instead have the
16:27 - empty value we get this result when
16:29 - we've reached the end of the string the
16:31 - text and there's no more letters so we
16:34 - should stop this script
16:37 - drop that in right after setting c to
16:39 - stop this forever loop and drop back to
16:41 - the main write script
16:43 - nice we can test this now by coming back
16:45 - to the right script and switching out
16:47 - the length of text
16:49 - for a wrap i
16:51 - this will stop the text from writing any
16:53 - more than the fine text wrap block asks
16:55 - us to write out
16:57 - how much is that though run the project
17:00 - and of course it's still everything so
17:03 - don't panic we've not done anything
17:05 - wrong this is all good news
17:08 - now i don't know if you had your
17:10 - alignment set to left like me or we're
17:12 - using center or right aligned at this
17:14 - point but we have a little change to
17:16 - make in there before i forget find that
17:18 - define calculate align script
17:21 - now see how it's getting the width of
17:23 - text
17:24 - well we can scrap that now the width
17:27 - will already have been found by our new
17:30 - find text wrap script remove those
17:32 - blocks they're no longer needed
17:36 - so looking at our running project what
17:38 - we should do next is start looking for
17:40 - the gaps between words the space letters
17:44 - find the define find text to index
17:47 - script
17:48 - to begin with just duplicate the ifc
17:51 - equals check and this time we will enter
17:54 - a space in the right hand side comparing
17:57 - c to space
17:59 - stuff that under the other if
18:01 - and why are we stopping the script when
18:03 - we hit a space
18:04 - simple it's a great way to check that
18:06 - the script is working run the project
18:10 - the how oh yeah i love it both lines of
18:13 - text have been cut off just after one
18:16 - word exactly what we would have expected
18:19 - so we can move on
18:21 - if you can remember the plan of action
18:23 - when we find a space we don't want to
18:25 - stop no
18:27 - we want to record where the space was by
18:30 - setting safe i
18:34 - to the current index that's
18:36 - wrap i
18:38 - and also we want to record in safe width
18:43 - the current width
18:45 - that's better
18:47 - but this is only useful once we also
18:49 - detect that our text has become too long
18:51 - to fit on the page so at the bottom of
18:54 - our forever loop after changing x by the
18:56 - width of the last letter
18:58 - check if
19:00 - greater than
19:02 - width
19:03 - is greater than our page width
19:07 - and if it is then we will stop here but
19:10 - before we do we reset the wrap i back to
19:14 - the last recorded safe i
19:19 - and likewise resetting the width
19:24 - to the last recorded safe width
19:27 - before finally stopping this script oh
19:30 - yeah that sounds perfect we gotta give
19:33 - this a test smash the green flag
19:37 - okay now what have we got here the rain
19:41 - in spain certainly does fall
19:44 - but no longer mainly in the plane mainly
19:47 - didn't fit on the line and has been cut
19:49 - off and we would expect it now to wrap
19:51 - onto the next line instead but we
19:54 - haven't coded up it yet now i'm really
19:57 - excited to get this fully working and
19:59 - we're so close now so find with me the
20:02 - define write script once more
20:04 - once we've written out all the text that
20:06 - fits on a single line we need to be able
20:08 - to continue processing the same text
20:11 - string looping back up to the top of
20:13 - this script again to find the next text
20:16 - wrap index
20:18 - okay so in that case let's wrap this
20:21 - repeat loop up in a custom block create
20:24 - a new block naming it
20:26 - write
20:27 - letter feed
20:30 - run without screen refresh
20:34 - put the whole of that repeat script into
20:36 - there
20:37 - so the find index and calculate size
20:39 - blocks will need to be repeated but the
20:42 - set eye definitely needs to go above
20:44 - these then outside any loop
20:48 - we'll use another repeat until block
20:50 - after setting i repeating until
20:54 - yes bring back the i is greater than
20:56 - length of text check once more
21:00 - we can pop in the two custom blocks to
21:02 - get them to run until all the text has
21:04 - been processed split and then written to
21:08 - the screen by dropping in the new right
21:10 - letter feed block there
21:13 - now it doesn't make a difference but
21:14 - i'll move the final change y block up
21:17 - into this repeat loop just so we can see
21:19 - it
21:20 - oh my goodness guys if everything has
21:23 - gone right then we are ready to run this
21:25 - baby smashing the green flag and oh yes
21:29 - look at that perfect wrapping text at
21:32 - least it looks like it we'd better do
21:34 - some more tests
21:36 - try changing the alignment right aligned
21:39 - check
21:40 - centered
21:42 - yes check so cool how it aligns to this
21:45 - box now of course to really see this
21:47 - wrapping in action how about we cheekily
21:50 - pop a mousex into the set page left
21:53 - input
21:54 - now the left margin is controlled by our
21:56 - mouse and we get this so cool dynamic
21:59 - wrapping isn't that crazy it's so
22:01 - buttery smooth and it works just as well
22:05 - with other alignments man it's cool
22:08 - seeing this wrapping working like this
22:10 - i've just got one more test case to try
22:12 - and that's to see what happens when we
22:14 - try to write a single word longer than
22:17 - the width of our page
22:19 - oh no
22:20 - that didn't work out well at all did it
22:23 - so why didn't this break onto a new line
22:25 - do you think
22:27 - the answer is obvious it doesn't have
22:29 - any spaces in it to split at
22:31 - this unfortunate fact means we'll need a
22:34 - special case to handle it scroll over to
22:37 - the define find text wrap index script
22:40 - and go down to the bottom
22:42 - we know that for long words this width
22:45 - will indeed be longer than the page
22:47 - we just need to handle the special case
22:50 - of no spaces with an if else check
22:53 - we check if safe i
22:55 - is greater than
22:57 - the empty value
23:00 - safe i is only set when we found a space
23:03 - we should ensure it does start blank
23:04 - though by setting safe i to the empty
23:07 - value before we begin our forever loop
23:12 - so now if safe is set then we did find a
23:15 - space and we can revert back to using
23:17 - the safe i and the safe width values as
23:19 - planned hey move this stop this script
23:23 - under the if else because both branches
23:25 - are still going to break out of the loop
23:27 - so then if no space was found in this
23:30 - else block then this must have been a
23:33 - long line of unbroken text like those
23:35 - w's just now
23:37 - well then we need to just break right
23:40 - here only because we did overflow we
23:43 - should backtrack by only one letter to
23:45 - the left
23:47 - change wrap i by negative one
23:51 - the width is a little tricky to fix we
23:53 - need to subtract the width of the last
23:55 - letter added
23:56 - we can duplicate the change width line
24:00 - and use a subtract
24:02 - block to change the width by zero
24:05 - subtract the letter width
24:09 - cool
24:10 - run the project
24:13 - oh yes i am really really pleased with
24:16 - this the wrapping is working exactly as
24:18 - it should to a very professional level
24:21 - indeed we are right on track to getting
24:23 - this to function as a scratch dialogue
24:25 - system or gosh why not even try creating
24:28 - a functioning word processor what do you
24:30 - think could you do it
24:32 - well we still have a good number of
24:34 - features to cover but if you're enjoying
24:37 - these episodes please please smash that
24:39 - like button i spend a lot of time making
24:41 - these videos for you and to keep them
24:43 - free i need as many people to love the
24:45 - project and subscribe to my channel as
24:47 - possible thanks guys i appreciate it now
24:51 - the final stage of this tutorial will be
24:53 - to bring back the option to slowly
24:55 - display text but perhaps with a cool
24:57 - animation if you like that the real
24:59 - trick though is how to also allow for
25:01 - fast skipping through without
25:03 - accidentally skipping too much text
25:06 - we also want to allow paging of the text
25:09 - for when it overflows the bottom of a
25:10 - page love that little animating continue
25:13 - option then we can consider the entrance
25:16 - and exit animations for our dialogue
25:17 - page and whether to add a cool hero icon
25:20 - to highlight who's talking and all this
25:23 - operated through a simple yet powerful
25:25 - list language really oh gosh wow i'm
25:29 - dead excited to wrap this all up and
25:32 - share it with you but i'm afraid that's
25:34 - all we've got time for today that just
25:36 - leads me to say thank you for watching
25:38 - have a great week ahead and scratch on
25:42 - guys

Cleaned transcript:

hello fellow scratchers today we are going to unravel the mysteries of word wrapping specifically how to extend our text engine to wrap any length of text neatly within a specified rectangular boundary but how are we going to get scratched to break up our text at the right points or to handle extra long text that overflows an entire line well stay tuned to find out as we continue this awesome series coding a text engine in scratch so as we begin load up your episode 2 projects and let's save them as a new copy but this is episode um oh okay you got me this is episode 3 i promise anyhow guys let's get scratching so word wrapping this will look cool if we have some kind of page or dialogue to write upon to create a new sprite named page for the costume i'm going to draw a simple rectangle in pastel yellow like a postit i'm making sure it's nice and central now we can spend lots of time later making this look awesome but for now this will do when you run the project you may find that the text has moved behind the new page sprite no problem click into the font sprite and for the time being under the when i receive test script just drop in a go to front right away the text springs to the front great so we have a nice page but we don't want our text flowing right up to the costumes edges no indeed so we'll try to define our actual text bounds as a rectangle within this page giving us a simple margin a rectangle can be defined by its top left and bottom right points we'll call these x1 y1 and x2 y2 let's make a new custom block to make this easy to define set page left with an input of x1 the label top with an input of y1 and then a label right with an input of x2 and the bottom label with an input of y2 click to run without screen refresh and we are ready now these values we will store in four new variables first one page l for page left setting it to x1 and page t for page top setting it to y1 page r for page right setting it to you guessed it x2 and lastly page b for page bottom setting it to y2 so let's set up the page dimensions now under our when i receive test script drop in the new set page block so how can we tell what screen location the top left corner should be set to hmm tricky in scratch 3 well if you have scratch addons then actually it's not i just hover my mouse at the location i want and the mouse location addon shows me where i am it's like negative 150 by 90. no need to be super accurate and type the value in but if you have not got scratch addons then how can we find out our location well how about this when space key pressed ask mousex and we can ask mouse y2 then hover over the position we want to know and press the space so that's an x of 159 but of course we want the margins to be symmetrical so i'm actually going to put in an x of 150 and then i'll reposition again and it's a y of negative 31. i just pressed enter to find out okay brilliant so we have our page bounds defined next up we need to make sure when we write to the screen the text will appear at the top of the page rather than at our mouse cursor that was so episode 2. so we make our way over to the define right block when our text is left aligned the position of the text is set here set xx to the input x well no longer these inputs are going to go in favor of using the page bounds and for the left align text that will be page l the left edge of the page now before i forget we also want to remove the set y block here we will assume the y position is already set before we begin to write to the screen that's a bit of a change but don't worry about that right yet now what about the other alignments let's look at the right align text that will want to be offset relative now to the right hand edge of the page so we enter page r page right and subtract the width of the text and that's it centering takes a little more thought we need to find the center of the page bounds to calculate this we need to take the average of the left and right edges of the page that is the sum of page l and page r and then we'll need to divide by two but hold on because then we subtract with divided by two well if these are all being divided by two we can simplify this by subtracting the width from page r plus page l and then divide the whole thing by 2 afterwards got that excellent but now the x and y inputs are completely unused within this custom block but also the sprite's y position is never set what we'll do is come back over to the when i receive test script and drop in a set y position right before setting the pages dimensions setting y2 of course page top now our text will begin at the top of the page let's slap that green flag and see what we've got well yes the good news is that our text has appeared somewhere near where we wanted it to begin the downside is that both lines of text are located one on top of the other not surprising considering the y position of our right block is no longer used easy to fix scroll back to the define right block and down to the bottom and once we've written out a line of text we want to advance to the next line so change y by and we are moving downwards so use a zero subtract and drop in the line height variable there we go looking much better i'm glad we set up that variable so every use of the right will advance the text to the next line so what is the point of keeping this y position input now well absolutely no point at all let them be gone edit the write block and delete the x and y labels and inputs wow i hope you did make a copy of your project because it's a hard journey back from these changes i'll just tidy up these orphaned variables and as you can see running the project shows no ill effects from the changes since those inputs really weren't used any longer and if i duplicate the last right block you can see that the auto advancement of the y position works a treat without any further work required really like how that is working let's also check out the center alignment so that now is centered on the page rather than our mouse cursor and the writer line is likewise now aligned to the righthand edge of the page bounce very cool so then this is where it gets exciting we've mastered positioning and aligning to the page bounds but if we enter a longer line of text in here the text is still allowed to overflow the page bounce and this looks as ugly as an ugly thing and that's very ugly indeed it's obvious what our next job must be the most obvious fix might be to place a limit on the x position in the right script check if xx is greater than page r the right hand edge of the page and then set it back to the left edge page l then of course make sure to change y by the negative line height to move the cursor down to the next line so if we were to drop this in after changing xx then not bad right looks to me like we have some rudimentary wrapping going on and yes we do but this is not word wrapping no this is word break wrapping see how the word mostly has been split into midword this is not how we want our wrapping to work no word should be split unless it's absolutely necessary so what do we do now well we really want to treat an entire word as a single unit and therefore move any word that does not fit on the page onto the next line as a whole to detect a word all we need to do is look back for the last space before we overflowed the page but hang on if we've already been cloning or stamping letters to the screen then it's already too late the deed has been done so we must detect spaces before we hit the page bounds and before we draw anything to the screen the process should look something like this work out the page width the text length must not exceed this we already have a variable i that as before represents the index of the letter to be written to the screen one is the first letter to the next etc but this stays right where it is while we look ahead to find out what text will fit on the line so we have a new variable wrap i used to trace forward looking for spaces but as we go we will also sum up the letter widths in the variable width as before now this is new if we find a space character then we make a note of where it is storing the last found index in safe i and the width in safe width this keeps a record of the last safe wrapable position if at any point the width becomes too wide to fit on the page we have the safe variables to go back to for drawing our text but otherwise if all the text does fit then we just use the wrap eye and width as they are does that make sense i think so cool then delete the little experimental if and before we add any more code i note this right block is getting really rather long so it's a good time to try to split it up with some custom blocks a prime candidate being this alliance scripts here from the if align equals c to the set i to zero yeah make a new custom block naming it calculate alignment and it will need an input named align just tick run without screen refresh and ok we'll attach this define to the alignment scripts and make use of the new align block here where we took the scripts from we just need to make sure to pass through the align variable so it knows what alignment we are using brilliant join that all back up and i'll move my scripts into some free space if i can find some and a quick tap on the green flag to ensure things are still working tickety boo and yes no changes good change um good news uh yeah so moving quickly on let's get those new variables made so that we can start processing our first line of text so we need a wrap i and for this sprite only safe i for this sprite only save width again for this sprite only and one more i'll name c this one is for storing a single character that is a letter of the text we are processing again make it for this sprite only i'm going to hide them for now okay so because the text will be processed a line at a time we can no longer use a repeat length text here for this reason i'm going to start i at 1 instead of 0 and then we can use a repeat until i is greater than the length of text instead move all the contained scripts over into the new loop not forgetting the change y from the end and we can replace that old repeat with this new one great of course since we start i at one instead of zero the change i by one needs to move down to be the last block in the repeat do you see how this works we start at letter one and check each time that the letter index has not gone past the end of the text string again we can give it a test and it still is working but no magic wrapping yet oh no this is what we'll start work on now you know what make one more variable that i forgot name it page width for this sprite only we want to know the maximum width of text that can fit on the page we get that by setting page width to a subtract operator and subtract page left page l from page r page right stick that at the top of the write script now let's set up the wrap i variable ready to start scanning across the text set wrap i to and this time yes we do set it to zero this will make comparing the i variable to the rapid variable that little bit easier you'll see and here we go make a custom block naming it find text wrap index and definitely tick that run without screen refresh we'll make use of it right away sticking it in after we've set wrap eye to zero but before we calculate the alignment that makes sense as we will need to align whatever length of text comes back from using this new block okay so this new defined block it's going to initially have a very similar function than our old get width of text block in fact it is destined to replace it altogether however we don't need to set txt as this has already been done in the right script before we get here what we do need is to set width to zero the loop again can't use a repeat length as we can't say how many letters we will need to repeat for so let's instead use a forever loop we'll find other ways to break out of it so don't worry it won't be forever really now duplicate the scripts from the previous get width of text loop into our forever loop this too wants to check along the text calculating the combined width however it's using the wrong variables switch the i variables or wrap i variables including the one in the switch costume here great that's right but we will need to check the value of this letter to look out for spaces so rather than use the letter of block more than once to get the same letter again we'll set the variable c before we switch costumes to the letter wrap i of text and then pop that c variable in the second switch costume so now we are free to check if c is equal to but for starters don't put a space on the right hand side no instead have the empty value we get this result when we've reached the end of the string the text and there's no more letters so we should stop this script drop that in right after setting c to stop this forever loop and drop back to the main write script nice we can test this now by coming back to the right script and switching out the length of text for a wrap i this will stop the text from writing any more than the fine text wrap block asks us to write out how much is that though run the project and of course it's still everything so don't panic we've not done anything wrong this is all good news now i don't know if you had your alignment set to left like me or we're using center or right aligned at this point but we have a little change to make in there before i forget find that define calculate align script now see how it's getting the width of text well we can scrap that now the width will already have been found by our new find text wrap script remove those blocks they're no longer needed so looking at our running project what we should do next is start looking for the gaps between words the space letters find the define find text to index script to begin with just duplicate the ifc equals check and this time we will enter a space in the right hand side comparing c to space stuff that under the other if and why are we stopping the script when we hit a space simple it's a great way to check that the script is working run the project the how oh yeah i love it both lines of text have been cut off just after one word exactly what we would have expected so we can move on if you can remember the plan of action when we find a space we don't want to stop no we want to record where the space was by setting safe i to the current index that's wrap i and also we want to record in safe width the current width that's better but this is only useful once we also detect that our text has become too long to fit on the page so at the bottom of our forever loop after changing x by the width of the last letter check if greater than width is greater than our page width and if it is then we will stop here but before we do we reset the wrap i back to the last recorded safe i and likewise resetting the width to the last recorded safe width before finally stopping this script oh yeah that sounds perfect we gotta give this a test smash the green flag okay now what have we got here the rain in spain certainly does fall but no longer mainly in the plane mainly didn't fit on the line and has been cut off and we would expect it now to wrap onto the next line instead but we haven't coded up it yet now i'm really excited to get this fully working and we're so close now so find with me the define write script once more once we've written out all the text that fits on a single line we need to be able to continue processing the same text string looping back up to the top of this script again to find the next text wrap index okay so in that case let's wrap this repeat loop up in a custom block create a new block naming it write letter feed run without screen refresh put the whole of that repeat script into there so the find index and calculate size blocks will need to be repeated but the set eye definitely needs to go above these then outside any loop we'll use another repeat until block after setting i repeating until yes bring back the i is greater than length of text check once more we can pop in the two custom blocks to get them to run until all the text has been processed split and then written to the screen by dropping in the new right letter feed block there now it doesn't make a difference but i'll move the final change y block up into this repeat loop just so we can see it oh my goodness guys if everything has gone right then we are ready to run this baby smashing the green flag and oh yes look at that perfect wrapping text at least it looks like it we'd better do some more tests try changing the alignment right aligned check centered yes check so cool how it aligns to this box now of course to really see this wrapping in action how about we cheekily pop a mousex into the set page left input now the left margin is controlled by our mouse and we get this so cool dynamic wrapping isn't that crazy it's so buttery smooth and it works just as well with other alignments man it's cool seeing this wrapping working like this i've just got one more test case to try and that's to see what happens when we try to write a single word longer than the width of our page oh no that didn't work out well at all did it so why didn't this break onto a new line do you think the answer is obvious it doesn't have any spaces in it to split at this unfortunate fact means we'll need a special case to handle it scroll over to the define find text wrap index script and go down to the bottom we know that for long words this width will indeed be longer than the page we just need to handle the special case of no spaces with an if else check we check if safe i is greater than the empty value safe i is only set when we found a space we should ensure it does start blank though by setting safe i to the empty value before we begin our forever loop so now if safe is set then we did find a space and we can revert back to using the safe i and the safe width values as planned hey move this stop this script under the if else because both branches are still going to break out of the loop so then if no space was found in this else block then this must have been a long line of unbroken text like those w's just now well then we need to just break right here only because we did overflow we should backtrack by only one letter to the left change wrap i by negative one the width is a little tricky to fix we need to subtract the width of the last letter added we can duplicate the change width line and use a subtract block to change the width by zero subtract the letter width cool run the project oh yes i am really really pleased with this the wrapping is working exactly as it should to a very professional level indeed we are right on track to getting this to function as a scratch dialogue system or gosh why not even try creating a functioning word processor what do you think could you do it well we still have a good number of features to cover but if you're enjoying these episodes please please smash that like button i spend a lot of time making these videos for you and to keep them free i need as many people to love the project and subscribe to my channel as possible thanks guys i appreciate it now the final stage of this tutorial will be to bring back the option to slowly display text but perhaps with a cool animation if you like that the real trick though is how to also allow for fast skipping through without accidentally skipping too much text we also want to allow paging of the text for when it overflows the bottom of a page love that little animating continue option then we can consider the entrance and exit animations for our dialogue page and whether to add a cool hero icon to highlight who's talking and all this operated through a simple yet powerful list language really oh gosh wow i'm dead excited to wrap this all up and share it with you but i'm afraid that's all we've got time for today that just leads me to say thank you for watching have a great week ahead and scratch on guys
