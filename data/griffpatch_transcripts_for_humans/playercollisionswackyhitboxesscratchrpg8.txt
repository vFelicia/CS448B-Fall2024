With timestamps:

00:00 - foreign
00:03 - scratchers today in our epic scratch RPG
00:06 - tutorial series we will finally be
00:08 - coding up the player to level collisions
00:10 - beginning simple with basic Square
00:12 - colliders and then gradually adding in
00:14 - support for the awesome Collision pins
00:16 - that we put in place in the previous
00:18 - episode did you finish setting yours up
00:20 - now you might assume that we'll be
00:22 - smashing the player hitbox into these
00:24 - Collision pins watching for when they
00:26 - Collide but since our level Grid is
00:28 - stationary we'll shrink the player
00:30 - hitbox back to a point while expanding
00:33 - the tile pin hitboxes outwards these
00:35 - changes actually cancel each other out
00:37 - and lead to exactly the same Collision
00:39 - responses but as it turns out this is
00:42 - far more easy to code now notice how the
00:45 - Collision pins form a simple grid layout
00:47 - and simple is good because we then have
00:50 - to deal with neighboring tiles where
00:52 - Collision squares overlap oh and did I
00:55 - mention we also have to consider we've
00:57 - got three layers of tiles these days too
00:59 - in overload well hopefully not it's a
01:03 - lot of fun honest so stay tuned until
01:05 - the end of this video to see how it all
01:07 - comes together I'm excited are you
01:09 - enough talk guys let's get scratching
01:13 - open up your episode 7 projects and
01:16 - before we do anything else from the file
01:18 - menu save them as a new copy for this is
01:21 - episode 8.
01:23 - so here we are able to walk over any
01:26 - tile we want well not for much longer
01:29 - right firstly we'll simply prevent our
01:31 - player from walking over the tiles that
01:33 - we've painted on layer one that's these
01:36 - ones all the coding today is going to be
01:38 - within the player Sprite and within the
01:41 - movement code that's down here in the
01:43 - Define try move custom block
01:46 - we coded this up way back in episode one
01:48 - and it simply moves the player by DX and
01:51 - d y
01:52 - so we want to test whether this movement
01:55 - is possible whether we Collide and if we
01:57 - do then not let them move after all
02:01 - but just before we do let's just
02:04 - consider that we don't want any wall
02:06 - collisions when we are in the level
02:07 - editor mode so duplicate the change
02:10 - player X and Y so that we can code up
02:12 - both modes independently
02:14 - check whether the level editor is active
02:17 - if editor is greater than zero and if it
02:20 - is then change the player's position and
02:23 - stop this script exactly what it
02:26 - currently does
02:28 - if you want to test that then smash the
02:30 - green flag and you'll find that when not
02:32 - in the editor we can no longer move at
02:35 - all but when the editor is open well
02:38 - there you go we can move just fine great
02:41 - now that we are splitting the editor in
02:43 - game movement this does open up another
02:45 - opportunity for us to accelerate the
02:48 - editor movement with bigger levels this
02:50 - can be super useful so just multiply the
02:53 - DX and ey by 2 each next up we'll
02:57 - consider the X and Y movements
02:59 - independently for the normal game so
03:02 - split them apart
03:04 - doing this will prevent us getting
03:05 - caught on walls
03:07 - okay make a new custom block naming it
03:11 - check solid all around with an input of
03:14 - X and another input y
03:18 - run without screen refresh this will
03:20 - eventually be used to check for
03:21 - collisions all around us on all layers
03:24 - but right now just the single tile
03:26 - collisions
03:27 - we'll store whether we touch something
03:29 - solid by making a new variable naming it
03:32 - solid for this Sprite only
03:35 - for starters we'll just set solid to
03:38 - zero meaning no Collision detected and
03:40 - leave that as it is while we finish off
03:43 - the try move script
03:45 - so we check solid all around player X
03:48 - and player y
03:51 - but we want to add DX to player X to
03:54 - test the movement along the x-axis first
03:59 - we will know this movement is safe if
04:01 - solid comes back less than one
04:09 - which it always will right now and so we
04:12 - are free to then change player X by DX
04:15 - to do the actual movement great so the
04:19 - y-axis movement is just the same
04:21 - duplicate the check solid and scripts
04:23 - below changing it to B player X on the
04:27 - left and this time player y plus and be
04:32 - careful to switch the DX for the d y
04:34 - input as we are moving up and down this
04:37 - time
04:38 - if there was no solid Collision then we
04:40 - Chuck away the change player X and
04:42 - replace it with a change player why
04:45 - perfect that's the pattern of things we
04:48 - are just missing any actual Collision
04:50 - detection in our check solid script but
04:52 - not to worry let's give this a test to
04:55 - reassure us everything is still working
04:57 - and good news then because I'm able to
05:00 - walk around again while not in the
05:02 - editor for you oh and for those curious
05:05 - yep I can now Dash super fast when the
05:08 - editor is open oh yeah but enough of
05:12 - that we want to test for basic tile
05:15 - collisions right so back in the code
05:18 - it's this check solid all-around script
05:20 - that we need to work on and before we
05:23 - can do any Collision checks we need to
05:25 - know which grid tile is actually at
05:27 - position x y
05:30 - make a new custom block naming it get
05:33 - grid index
05:35 - with two inputs X
05:37 - and Y run without yeah you know what
05:43 - then make three variables sorry there's
05:46 - going to be a lot of these in this
05:47 - episode grid X or GX for short for this
05:51 - Sprite only grid y or do y for this
05:54 - Sprite only and grid index G idx also
05:59 - for this Sprite only
06:01 - we get the grid X by dividing X by 32
06:05 - that's our tile size
06:09 - but remember to round the result down
06:11 - using a floor operator
06:18 - calculate grid y in the same way setting
06:20 - gy to the floor of Y divided by 32
06:23 - instead
06:25 - and finally to calculate our grid index
06:28 - we set G idx to the result of summing
06:33 - one with grid X that's GX
06:39 - and finally we take g y and multiply
06:43 - that by G Max to move up a grid row to
06:46 - time and then we sum that all together
06:50 - if that doesn't seem familiar then you
06:52 - can always re-watch my gridless tutorial
06:54 - to refresh your memory
06:56 - so under the check solid all around
06:58 - script make use of the new get grid
07:01 - index block feeding it with the X and Y
07:04 - inputs that we are to check for
07:06 - fantastic a good point to test our
07:09 - scripts click the green flag and move
07:11 - the player around we should find the
07:13 - player's grid position and the resultant
07:16 - grid index is now calculating moving
07:19 - left and right changes the grid index by
07:21 - 1 and up and down by a whole grid Max
07:23 - which is counting in hundreds on my
07:26 - level could be different for you though
07:29 - cool because with that we are ready to
07:32 - look for simple collisions
07:34 - we'll get the tile under the player a
07:37 - new variable to store that in call it
07:39 - tile for this Sprite only and we set
07:43 - tile to item of grid
07:47 - and the item is our calculated G idx of
07:50 - course nice it all plugs together right
07:53 - so the absolute simplest Collision check
07:56 - we can do is to see if there is a tile
07:58 - under the player at all if tile is
08:01 - greater than zero if it is we count it
08:04 - as solid so set solid to one oh yeah
08:08 - this is it after seven full episodes
08:11 - without any collisions This Is The
08:13 - Moment of Truth here we go and up boom
08:17 - would you look at that these full tiles
08:20 - are rock solid there's no getting
08:21 - through these on any sides that is so
08:25 - satisfying right yeah even the fence
08:27 - looks reasonable from the side the other
08:30 - side well a little overlappy you might
08:33 - start to wonder though did we need pin
08:35 - collisions at all
08:36 - okay so this is perhaps where it starts
08:39 - to get a little bit off looking we don't
08:41 - want to get this close to a wall and oh
08:43 - man there's no walking through this Gap
08:45 - at all
08:47 - I can skip over this with the level
08:49 - editor but it turns out flowers are also
08:52 - solid so we are stuck okay uh delete
08:55 - these and look at this these are the
08:59 - real gotchas for full tile collisions we
09:01 - really need to use those pins to let us
09:04 - get right up close to these edges
09:06 - but let's not get ahead of ourselves
09:09 - right now we can't even walk over a
09:11 - flower or a road indeed any tile placed
09:14 - on layer 1 of our level is impassable
09:16 - and solid a quick win would be to look
09:19 - in our tile pin data and say only tiles
09:23 - with pins are solid all others we can
09:25 - walk through with no problem
09:28 - set rate off the if tile is greater than
09:30 - zero check and we'll get the pin values
09:33 - for this title make a new variable pin
09:36 - string for this Sprite only
09:40 - setting it to
09:43 - item of tile pins nice and we want the
09:49 - pin layout for the tile under the player
09:51 - and that is our tile variable
09:54 - so lastly we will look at the resulting
09:57 - pin string and just check if it is
09:59 - greater than zero any pin layout with a
10:02 - 1 in it will be considered solid
10:05 - now this is exciting smash that green
10:08 - flag
10:09 - right you can see the pin string is
10:11 - empty as we are not over any tiles right
10:12 - now
10:13 - so let's walk over to the path okay nice
10:16 - I can walk on it and that is a huge
10:19 - Improvement already and check out the
10:21 - pinstring and you can see it has an all
10:23 - zero string pattern that means there is
10:26 - a tile present but it has no solid pins
10:28 - defined
10:29 - and lastly if we walk into something
10:32 - solid From Below we can see the pin
10:34 - string contains once and so we are
10:37 - blocked because it's now counted as
10:38 - fully solid so cool we are making
10:42 - progress and just before we continue can
10:44 - I ask if you're enjoying the video so
10:46 - far please remember to hit the like
10:48 - button below doing so helps me no end
10:50 - thank you guys right what's the next
10:53 - step well although we can collide with
10:55 - tiles on layer one not all tiles are on
10:59 - this layer some are also on Layer Two
11:01 - okay well the script responsible for
11:04 - detecting the solidity of a tile on the
11:07 - grid is these four scripts starting with
11:09 - the set tile here let's separate them
11:12 - off we want to now do this twice once
11:15 - for layer 1 and again for layer 2 we'll
11:18 - ignore layer 3 because it tends to sit
11:20 - above us in the game anyhow
11:22 - it makes sense to pop this in a new
11:24 - custom block naming it check solid at
11:28 - with an input of grid index gidx and we
11:32 - run without screen refresh
11:35 - the set tile scripts can go under this
11:37 - new Define and then place the call to
11:40 - check solid at from where those scripts
11:42 - came then we need to bring the grid
11:44 - index variable out from our custom block
11:47 - passing it in as the input which means
11:50 - we can make the check solid script use
11:52 - the GI DX input as its new item number
11:55 - like so
11:57 - okay that's good this should work just
12:00 - the same except now we can duplicate the
12:03 - Czech solid block to check the tile in
12:06 - the layer above this one we do that by
12:08 - simply adding gmull to G index that's
12:11 - the number of items in a full grid layer
12:15 - now if either of these check solid
12:17 - blocks find a solid tile they will set
12:20 - solid to one let's give this a try I'll
12:24 - first just walk into a standard layer 1
12:26 - tile they seem just as solid as before
12:28 - so where's that layer 2 Bush hooray we
12:32 - have success both layers of tiles are
12:34 - now solid when they are found to contain
12:36 - pins well you know what that means all
12:40 - that's left to implement is the full pin
12:43 - collisions are you ready for this
12:45 - okay we have the player and a tile to
12:49 - collide with tile has five solid
12:52 - Collision pins which I explained earlier
12:54 - would be represented as a grid of nine
12:57 - Collision zones like so these are
13:00 - numbered from one to nine in the same
13:02 - order as a standard grid list
13:05 - the first problem we face is that the
13:07 - Collision grid is not aligned with our
13:09 - tile grid this makes it hard to detect
13:11 - collisions outside of the tile they are
13:14 - defined Within to fix this we offset the
13:17 - player and the tiles up and to the right
13:19 - by quarter of a tile this brings the
13:22 - Collision Grid in line with the tile
13:24 - grid and yet maintains the same
13:26 - collisions you may have noticed this
13:29 - brings the top and right hand colliders
13:31 - outside the main tile now
13:33 - that will be a problem but it's one for
13:36 - later right now we have enough to go on
13:39 - to get coding these pin collisions
13:41 - we'll start then by offsetting our
13:43 - player by 8 pixels under the Define
13:46 - check solid around when getting the grid
13:48 - index we first add 8 pixels to X and 8
13:53 - pixels to y
13:55 - funnily enough we already observe the
13:57 - additional effect of this by running the
13:59 - project and colliding with solid tiles
14:01 - from the left we are no longer able to
14:03 - get as close to these blocks as before
14:05 - this is the desired effect making it
14:08 - feel like our player has width of course
14:11 - as things stand the opposite applies to
14:13 - collision's walking left where now we
14:16 - can actually overlap even more than
14:18 - before just ignore that for now we are
14:20 - not finished coding the next step is to
14:23 - work out which of the four pin squares
14:25 - the player is within we'll code this
14:27 - within our get grid index script and now
14:30 - we might as well duplicate the entire
14:33 - script as getting the Collision grid
14:35 - index is very similar to getting the
14:37 - original grid index
14:39 - firstly the Collision grid split the
14:42 - tile grid into the two by two
14:44 - so we must half the tile size to divide
14:47 - not by 32 but by 16 in both cases
14:52 - however this will tell us how many half
14:54 - tiles across the entire level the player
14:56 - is located so to switch to return 0 or 1
14:59 - for this tile we mod the result by two
15:02 - keeping it cycling around from zero to
15:04 - one to zero and back to one again
15:08 - do the same now for gy
15:11 - right lastly the pin Collision index we
15:16 - need a new variable to store this in
15:18 - naming it just pin for this Sprite only
15:21 - and switch the set grid index for a set
15:24 - pin
15:26 - nearly there this Collision pin layout
15:28 - has just three pins in a row so the row
15:31 - multiplier at the end here should be
15:33 - changed from gmax to the plain old
15:36 - number three
15:38 - let's give that a quick sanity check run
15:41 - the project
15:42 - and with GX and gy and pin variables
15:45 - visible we can see after we begin moving
15:47 - the GX toggles between 0 and 1 great as
15:51 - does gy when we move up and down and the
15:54 - pin value is only ever matching pin one
15:56 - two four and five this is the number of
16:00 - the pin under our player so exciting now
16:04 - if you see anything other than pin one
16:06 - two four or five after you've moved then
16:09 - something is up go back and check your
16:11 - script again but if all is good then yay
16:14 - we are going to code up the first actual
16:17 - pin Collision Now find the Define check
16:20 - solid app Block this is no longer quite
16:23 - fit for purpose as rather than looking
16:25 - for entire solid tiles it needs to now
16:28 - apply to only a specific pin of a tile
16:31 - therefore right-click the Define block
16:34 - and choose edit
16:36 - and we'll add a text label at the end at
16:40 - pin and a new input pin hash cool just
16:46 - before we code that up let's see where
16:48 - this block was used
16:50 - here in the check solid all around
16:52 - that's where and see these empty inputs
16:55 - so we just calculated which pin we'll be
16:57 - checking so drop the pin variable into
17:00 - both the solid checks both layer 1 and
17:03 - layer 2. great go back now to the Czech
17:07 - solid at script
17:09 - let's implement the actual pin lookup
17:11 - and it's quite straightforward luckily
17:14 - we've already got the pin string all we
17:17 - need to do to access the individual pin
17:19 - values is use the letter of pin string
17:22 - and the letter number is given by the
17:25 - new PIN hash input we've just passed in
17:28 - here Splendid so if the pin value is
17:32 - greater than zero we set solid to one
17:35 - now this is perfectly good for now but
17:39 - looking ahead let's make a small change
17:42 - as we check through the pins and layers
17:45 - of this potential Collision we want to
17:47 - keep track of the most solid Collision
17:50 - not just the one value here
17:52 - instead then check if greater than the
17:55 - value already in the solid variable and
17:59 - then if the new PIN is greater set solid
18:03 - to the value of the pin letter pin hash
18:07 - of pin string cool I like that it will
18:10 - keep track of the largest pin Collision
18:12 - value from our pin string guys we've
18:15 - completed the first part of the pin
18:17 - collisions excitedly smashing that green
18:20 - flag now I'm going to try a simple
18:22 - Collision to begin with
18:24 - these full-size tiles seem to work just
18:26 - the same we are now nicely far away
18:29 - that's great news but where things get
18:32 - fresh is when we try to collide with a
18:34 - half tile like this left-facing fence
18:37 - over here goes nothing oh my goodness
18:41 - look at that it works a half tile
18:43 - Collision I'm so happy sometimes the
18:46 - math befuddles my mind but somehow it
18:48 - all falls into place yes and collisions
18:51 - From Below are also correctly handled
18:54 - so we are oh so close now the pin
18:57 - collisions that work are the ones that
18:59 - lie in regions one two four and five
19:02 - it's a shame then that the pins we need
19:05 - for right hand collisions like this one
19:07 - are currently excluded from our
19:09 - Collision scripts as such we can walk
19:11 - right through them let's just back this
19:14 - up a moment though the solution to this
19:17 - problem is not as complex as it may seem
19:19 - let's look at the tile next to this one
19:22 - hit 2 is divided into four Collision pin
19:25 - regions one two four and five what you
19:28 - might see though is that PIN number one
19:31 - on the new tile sits perfectly on top of
19:34 - the elusive pin number three of the tile
19:36 - to its left likewise pin 4 sits over pin
19:40 - 6 of the tile to its left and this is
19:43 - the key whenever we check any pin one or
19:46 - four that is the left side of a tile we
19:49 - automatically also need to look at the
19:51 - corresponding pin three and six of the
19:54 - tile to its left simple wanna try this
19:58 - out let's code find the Define check
20:02 - solid all around
20:04 - after we get the grid index we currently
20:06 - check for solid pins on layer 1 and 2.
20:09 - separate these off
20:11 - and we'll place them in a new custom
20:13 - block naming it appropriately check
20:16 - solid across layers with an input grid
20:20 - index gidx a label pin
20:24 - and a final input pin hash
20:27 - run without screen refresh
20:29 - great pop those two blocks in there and
20:32 - make use of it right away dropping it
20:35 - back from where we took the blocks from
20:37 - and now the inputs need matching up the
20:39 - gidx variable comes up here and the pin
20:42 - variable drops into that pin input
20:45 - then back down in a new block the G idx
20:48 - input goes in first
20:50 - and pin hash second
20:53 - just need to do the same for the block
20:55 - below 2 replacing them both and cleaning
20:58 - those old ones away cool make a little
21:01 - space
21:03 - we want to check if we are looking at
21:05 - pins one or four but since GX will
21:07 - always equal zero in these cases we
21:10 - might as well just check that instead if
21:12 - GX is equal to zero
21:19 - in that case we then want to check solid
21:22 - across layers again this time for the
21:25 - tile to our left that's gidx subtract 1.
21:30 - and the pin number we need to move from
21:33 - one to three and from four to six that's
21:36 - just adding two to the pin right so drop
21:39 - in a pin plus two
21:42 - okay so here we go right collisions
21:46 - should work as before but left Legends
21:50 - and look at that what an awesome sight
21:54 - after all this work it's perfect next up
21:57 - then we need to do the same for the top
22:00 - row of pins
22:01 - pin 7 and 8 follow a very similar line
22:05 - to three and six you'll find pin 1
22:07 - always sits on top of pin 7 and pin two
22:11 - sits on top of pin eight so we are
22:14 - looking for any collisions on the bottom
22:16 - row now
22:17 - here we go then duplicate that if check
22:20 - and we can switch to look for the bottom
22:23 - row of pins if g y is equal to zero then
22:28 - instead of looking at the tile to the
22:30 - left we look at the tile below us to get
22:33 - that we subtract a full grid width G Max
22:37 - lastly we switch pins up two rows of
22:41 - pins from one to seven and from two to
22:44 - eight that's just adding six right
22:48 - exciting let's give it a test
22:52 - left Legions check upward collisions two
22:55 - so downwards man this is sweet we are
22:59 - simply rocking now are we done well not
23:03 - quite there's this one little corner
23:06 - case remaining literally see how we can
23:09 - sneak into the corner here so we have
23:12 - this one final pin unaccounted for pin
23:15 - number nine and this one sits also under
23:18 - pin number one wow pin one sure does
23:22 - overlap a lot of other pins come on then
23:25 - duplicate the last if and drop it inside
23:29 - the first if like this
23:31 - when both GX and gy is equal to zero we
23:35 - are looking at the bottom left pin pin
23:37 - number one so now as well as subtracting
23:40 - gmax from grid index we also need to
23:43 - subtract another one to move diagonally
23:46 - down and to the left by a tile
23:49 - and the pin number this is always going
23:52 - to move to pin number nine so forget all
23:55 - the pin pluses and just enter the number
23:57 - nine
23:59 - guys believe it or not that was the last
24:02 - script of the episode smash that green
24:06 - flag because we are going to play go on
24:09 - try and get into that corner now it's
24:12 - not having it I can tell you and that is
24:14 - great news indeed wow all these
24:16 - collisions are working just great how
24:18 - about this little entrance oh yes we can
24:21 - get in at last that's awesome so how
24:24 - about these thin walls we neatly hug the
24:27 - outside it's Lamppost yeah we hug that
24:30 - too this looks too cool the outside of
24:33 - this what what's going on here is this
24:36 - house on the wrong layer or something no
24:39 - apparently not it's on layer one so how
24:41 - come we are not colliding oh wait if I
24:44 - press the E over the house it's not
24:46 - selecting in the palette this means this
24:48 - house was drawn before I coded up the
24:50 - Sprite palette fencing so it's probably
24:52 - set to a negative costume number or
24:54 - something on my map I need to redraw it
24:57 - with the correct costume numbers from
24:58 - the palette and then yeah there we go
25:02 - collisions repaired it wasn't our
25:03 - Collision code at all any other problems
25:06 - [Music]
25:10 - ah here's one the black needs to be a
25:14 - collision until we create actual
25:16 - doorways so I'll find that black tile on
25:18 - layer one
25:20 - pressing e to identify it there we go
25:23 - and then toggle the pins with the peaky
25:25 - and fill it out with pins
25:31 - with that right back into the game and
25:34 - the collisions are updated really Nifty
25:38 - and that my friends brings us to the end
25:41 - of another episode if you enjoyed
25:43 - watching then please take the time to
25:45 - smash that like button to show your
25:46 - appreciation and then if you haven't
25:48 - already there's no better time to
25:50 - subscribe to this channel clicking the
25:52 - Bell notification to ensure you don't
25:54 - miss the next exciting episode when it
25:56 - drops if you just can't wait then
25:58 - there's also my Early Access Channel
26:00 - membership which also comes with added
26:02 - perks like trial 2 replies to comments
26:04 - and custom Channel Emoji lastly I want
26:07 - to give a shout out to my awesome
26:09 - YouTube channel members and supporters
26:11 - over at patreon this channel wouldn't be
26:13 - the same without you so that's it for
26:15 - today thank you for watching have a
26:17 - great week ahead and scratch on guys
26:21 - foreign
26:26 - [Music]

Cleaned transcript:

foreign scratchers today in our epic scratch RPG tutorial series we will finally be coding up the player to level collisions beginning simple with basic Square colliders and then gradually adding in support for the awesome Collision pins that we put in place in the previous episode did you finish setting yours up now you might assume that we'll be smashing the player hitbox into these Collision pins watching for when they Collide but since our level Grid is stationary we'll shrink the player hitbox back to a point while expanding the tile pin hitboxes outwards these changes actually cancel each other out and lead to exactly the same Collision responses but as it turns out this is far more easy to code now notice how the Collision pins form a simple grid layout and simple is good because we then have to deal with neighboring tiles where Collision squares overlap oh and did I mention we also have to consider we've got three layers of tiles these days too in overload well hopefully not it's a lot of fun honest so stay tuned until the end of this video to see how it all comes together I'm excited are you enough talk guys let's get scratching open up your episode 7 projects and before we do anything else from the file menu save them as a new copy for this is episode 8. so here we are able to walk over any tile we want well not for much longer right firstly we'll simply prevent our player from walking over the tiles that we've painted on layer one that's these ones all the coding today is going to be within the player Sprite and within the movement code that's down here in the Define try move custom block we coded this up way back in episode one and it simply moves the player by DX and d y so we want to test whether this movement is possible whether we Collide and if we do then not let them move after all but just before we do let's just consider that we don't want any wall collisions when we are in the level editor mode so duplicate the change player X and Y so that we can code up both modes independently check whether the level editor is active if editor is greater than zero and if it is then change the player's position and stop this script exactly what it currently does if you want to test that then smash the green flag and you'll find that when not in the editor we can no longer move at all but when the editor is open well there you go we can move just fine great now that we are splitting the editor in game movement this does open up another opportunity for us to accelerate the editor movement with bigger levels this can be super useful so just multiply the DX and ey by 2 each next up we'll consider the X and Y movements independently for the normal game so split them apart doing this will prevent us getting caught on walls okay make a new custom block naming it check solid all around with an input of X and another input y run without screen refresh this will eventually be used to check for collisions all around us on all layers but right now just the single tile collisions we'll store whether we touch something solid by making a new variable naming it solid for this Sprite only for starters we'll just set solid to zero meaning no Collision detected and leave that as it is while we finish off the try move script so we check solid all around player X and player y but we want to add DX to player X to test the movement along the xaxis first we will know this movement is safe if solid comes back less than one which it always will right now and so we are free to then change player X by DX to do the actual movement great so the yaxis movement is just the same duplicate the check solid and scripts below changing it to B player X on the left and this time player y plus and be careful to switch the DX for the d y input as we are moving up and down this time if there was no solid Collision then we Chuck away the change player X and replace it with a change player why perfect that's the pattern of things we are just missing any actual Collision detection in our check solid script but not to worry let's give this a test to reassure us everything is still working and good news then because I'm able to walk around again while not in the editor for you oh and for those curious yep I can now Dash super fast when the editor is open oh yeah but enough of that we want to test for basic tile collisions right so back in the code it's this check solid allaround script that we need to work on and before we can do any Collision checks we need to know which grid tile is actually at position x y make a new custom block naming it get grid index with two inputs X and Y run without yeah you know what then make three variables sorry there's going to be a lot of these in this episode grid X or GX for short for this Sprite only grid y or do y for this Sprite only and grid index G idx also for this Sprite only we get the grid X by dividing X by 32 that's our tile size but remember to round the result down using a floor operator calculate grid y in the same way setting gy to the floor of Y divided by 32 instead and finally to calculate our grid index we set G idx to the result of summing one with grid X that's GX and finally we take g y and multiply that by G Max to move up a grid row to time and then we sum that all together if that doesn't seem familiar then you can always rewatch my gridless tutorial to refresh your memory so under the check solid all around script make use of the new get grid index block feeding it with the X and Y inputs that we are to check for fantastic a good point to test our scripts click the green flag and move the player around we should find the player's grid position and the resultant grid index is now calculating moving left and right changes the grid index by 1 and up and down by a whole grid Max which is counting in hundreds on my level could be different for you though cool because with that we are ready to look for simple collisions we'll get the tile under the player a new variable to store that in call it tile for this Sprite only and we set tile to item of grid and the item is our calculated G idx of course nice it all plugs together right so the absolute simplest Collision check we can do is to see if there is a tile under the player at all if tile is greater than zero if it is we count it as solid so set solid to one oh yeah this is it after seven full episodes without any collisions This Is The Moment of Truth here we go and up boom would you look at that these full tiles are rock solid there's no getting through these on any sides that is so satisfying right yeah even the fence looks reasonable from the side the other side well a little overlappy you might start to wonder though did we need pin collisions at all okay so this is perhaps where it starts to get a little bit off looking we don't want to get this close to a wall and oh man there's no walking through this Gap at all I can skip over this with the level editor but it turns out flowers are also solid so we are stuck okay uh delete these and look at this these are the real gotchas for full tile collisions we really need to use those pins to let us get right up close to these edges but let's not get ahead of ourselves right now we can't even walk over a flower or a road indeed any tile placed on layer 1 of our level is impassable and solid a quick win would be to look in our tile pin data and say only tiles with pins are solid all others we can walk through with no problem set rate off the if tile is greater than zero check and we'll get the pin values for this title make a new variable pin string for this Sprite only setting it to item of tile pins nice and we want the pin layout for the tile under the player and that is our tile variable so lastly we will look at the resulting pin string and just check if it is greater than zero any pin layout with a 1 in it will be considered solid now this is exciting smash that green flag right you can see the pin string is empty as we are not over any tiles right now so let's walk over to the path okay nice I can walk on it and that is a huge Improvement already and check out the pinstring and you can see it has an all zero string pattern that means there is a tile present but it has no solid pins defined and lastly if we walk into something solid From Below we can see the pin string contains once and so we are blocked because it's now counted as fully solid so cool we are making progress and just before we continue can I ask if you're enjoying the video so far please remember to hit the like button below doing so helps me no end thank you guys right what's the next step well although we can collide with tiles on layer one not all tiles are on this layer some are also on Layer Two okay well the script responsible for detecting the solidity of a tile on the grid is these four scripts starting with the set tile here let's separate them off we want to now do this twice once for layer 1 and again for layer 2 we'll ignore layer 3 because it tends to sit above us in the game anyhow it makes sense to pop this in a new custom block naming it check solid at with an input of grid index gidx and we run without screen refresh the set tile scripts can go under this new Define and then place the call to check solid at from where those scripts came then we need to bring the grid index variable out from our custom block passing it in as the input which means we can make the check solid script use the GI DX input as its new item number like so okay that's good this should work just the same except now we can duplicate the Czech solid block to check the tile in the layer above this one we do that by simply adding gmull to G index that's the number of items in a full grid layer now if either of these check solid blocks find a solid tile they will set solid to one let's give this a try I'll first just walk into a standard layer 1 tile they seem just as solid as before so where's that layer 2 Bush hooray we have success both layers of tiles are now solid when they are found to contain pins well you know what that means all that's left to implement is the full pin collisions are you ready for this okay we have the player and a tile to collide with tile has five solid Collision pins which I explained earlier would be represented as a grid of nine Collision zones like so these are numbered from one to nine in the same order as a standard grid list the first problem we face is that the Collision grid is not aligned with our tile grid this makes it hard to detect collisions outside of the tile they are defined Within to fix this we offset the player and the tiles up and to the right by quarter of a tile this brings the Collision Grid in line with the tile grid and yet maintains the same collisions you may have noticed this brings the top and right hand colliders outside the main tile now that will be a problem but it's one for later right now we have enough to go on to get coding these pin collisions we'll start then by offsetting our player by 8 pixels under the Define check solid around when getting the grid index we first add 8 pixels to X and 8 pixels to y funnily enough we already observe the additional effect of this by running the project and colliding with solid tiles from the left we are no longer able to get as close to these blocks as before this is the desired effect making it feel like our player has width of course as things stand the opposite applies to collision's walking left where now we can actually overlap even more than before just ignore that for now we are not finished coding the next step is to work out which of the four pin squares the player is within we'll code this within our get grid index script and now we might as well duplicate the entire script as getting the Collision grid index is very similar to getting the original grid index firstly the Collision grid split the tile grid into the two by two so we must half the tile size to divide not by 32 but by 16 in both cases however this will tell us how many half tiles across the entire level the player is located so to switch to return 0 or 1 for this tile we mod the result by two keeping it cycling around from zero to one to zero and back to one again do the same now for gy right lastly the pin Collision index we need a new variable to store this in naming it just pin for this Sprite only and switch the set grid index for a set pin nearly there this Collision pin layout has just three pins in a row so the row multiplier at the end here should be changed from gmax to the plain old number three let's give that a quick sanity check run the project and with GX and gy and pin variables visible we can see after we begin moving the GX toggles between 0 and 1 great as does gy when we move up and down and the pin value is only ever matching pin one two four and five this is the number of the pin under our player so exciting now if you see anything other than pin one two four or five after you've moved then something is up go back and check your script again but if all is good then yay we are going to code up the first actual pin Collision Now find the Define check solid app Block this is no longer quite fit for purpose as rather than looking for entire solid tiles it needs to now apply to only a specific pin of a tile therefore rightclick the Define block and choose edit and we'll add a text label at the end at pin and a new input pin hash cool just before we code that up let's see where this block was used here in the check solid all around that's where and see these empty inputs so we just calculated which pin we'll be checking so drop the pin variable into both the solid checks both layer 1 and layer 2. great go back now to the Czech solid at script let's implement the actual pin lookup and it's quite straightforward luckily we've already got the pin string all we need to do to access the individual pin values is use the letter of pin string and the letter number is given by the new PIN hash input we've just passed in here Splendid so if the pin value is greater than zero we set solid to one now this is perfectly good for now but looking ahead let's make a small change as we check through the pins and layers of this potential Collision we want to keep track of the most solid Collision not just the one value here instead then check if greater than the value already in the solid variable and then if the new PIN is greater set solid to the value of the pin letter pin hash of pin string cool I like that it will keep track of the largest pin Collision value from our pin string guys we've completed the first part of the pin collisions excitedly smashing that green flag now I'm going to try a simple Collision to begin with these fullsize tiles seem to work just the same we are now nicely far away that's great news but where things get fresh is when we try to collide with a half tile like this leftfacing fence over here goes nothing oh my goodness look at that it works a half tile Collision I'm so happy sometimes the math befuddles my mind but somehow it all falls into place yes and collisions From Below are also correctly handled so we are oh so close now the pin collisions that work are the ones that lie in regions one two four and five it's a shame then that the pins we need for right hand collisions like this one are currently excluded from our Collision scripts as such we can walk right through them let's just back this up a moment though the solution to this problem is not as complex as it may seem let's look at the tile next to this one hit 2 is divided into four Collision pin regions one two four and five what you might see though is that PIN number one on the new tile sits perfectly on top of the elusive pin number three of the tile to its left likewise pin 4 sits over pin 6 of the tile to its left and this is the key whenever we check any pin one or four that is the left side of a tile we automatically also need to look at the corresponding pin three and six of the tile to its left simple wanna try this out let's code find the Define check solid all around after we get the grid index we currently check for solid pins on layer 1 and 2. separate these off and we'll place them in a new custom block naming it appropriately check solid across layers with an input grid index gidx a label pin and a final input pin hash run without screen refresh great pop those two blocks in there and make use of it right away dropping it back from where we took the blocks from and now the inputs need matching up the gidx variable comes up here and the pin variable drops into that pin input then back down in a new block the G idx input goes in first and pin hash second just need to do the same for the block below 2 replacing them both and cleaning those old ones away cool make a little space we want to check if we are looking at pins one or four but since GX will always equal zero in these cases we might as well just check that instead if GX is equal to zero in that case we then want to check solid across layers again this time for the tile to our left that's gidx subtract 1. and the pin number we need to move from one to three and from four to six that's just adding two to the pin right so drop in a pin plus two okay so here we go right collisions should work as before but left Legends and look at that what an awesome sight after all this work it's perfect next up then we need to do the same for the top row of pins pin 7 and 8 follow a very similar line to three and six you'll find pin 1 always sits on top of pin 7 and pin two sits on top of pin eight so we are looking for any collisions on the bottom row now here we go then duplicate that if check and we can switch to look for the bottom row of pins if g y is equal to zero then instead of looking at the tile to the left we look at the tile below us to get that we subtract a full grid width G Max lastly we switch pins up two rows of pins from one to seven and from two to eight that's just adding six right exciting let's give it a test left Legions check upward collisions two so downwards man this is sweet we are simply rocking now are we done well not quite there's this one little corner case remaining literally see how we can sneak into the corner here so we have this one final pin unaccounted for pin number nine and this one sits also under pin number one wow pin one sure does overlap a lot of other pins come on then duplicate the last if and drop it inside the first if like this when both GX and gy is equal to zero we are looking at the bottom left pin pin number one so now as well as subtracting gmax from grid index we also need to subtract another one to move diagonally down and to the left by a tile and the pin number this is always going to move to pin number nine so forget all the pin pluses and just enter the number nine guys believe it or not that was the last script of the episode smash that green flag because we are going to play go on try and get into that corner now it's not having it I can tell you and that is great news indeed wow all these collisions are working just great how about this little entrance oh yes we can get in at last that's awesome so how about these thin walls we neatly hug the outside it's Lamppost yeah we hug that too this looks too cool the outside of this what what's going on here is this house on the wrong layer or something no apparently not it's on layer one so how come we are not colliding oh wait if I press the E over the house it's not selecting in the palette this means this house was drawn before I coded up the Sprite palette fencing so it's probably set to a negative costume number or something on my map I need to redraw it with the correct costume numbers from the palette and then yeah there we go collisions repaired it wasn't our Collision code at all any other problems ah here's one the black needs to be a collision until we create actual doorways so I'll find that black tile on layer one pressing e to identify it there we go and then toggle the pins with the peaky and fill it out with pins with that right back into the game and the collisions are updated really Nifty and that my friends brings us to the end of another episode if you enjoyed watching then please take the time to smash that like button to show your appreciation and then if you haven't already there's no better time to subscribe to this channel clicking the Bell notification to ensure you don't miss the next exciting episode when it drops if you just can't wait then there's also my Early Access Channel membership which also comes with added perks like trial 2 replies to comments and custom Channel Emoji lastly I want to give a shout out to my awesome YouTube channel members and supporters over at patreon this channel wouldn't be the same without you so that's it for today thank you for watching have a great week ahead and scratch on guys foreign
