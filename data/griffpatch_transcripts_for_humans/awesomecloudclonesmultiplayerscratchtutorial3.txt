With timestamps:

00:00 - foreign
00:03 - scratchers welcome back to the wonderful
00:05 - world of online multiplayer scratch
00:07 - games and I'm so excited because in this
00:10 - third episode in the series all our hard
00:13 - work finally comes together we'll be
00:15 - using clones to bring the cloud players
00:18 - to life and yes supporting from two to
00:20 - over 100 players in game at the same
00:23 - time and those move re buffers from
00:25 - episode 2 will ensure everyone is moving
00:28 - as smooth and Pixel Perfect as possible
00:32 - what's this uh you've gone blank are you
00:36 - still there and now I often get asked
00:38 - how we can know when players leave our
00:40 - Cloud games well perhaps I just gave you
00:43 - a clue drop me a comment under the video
00:45 - if you think you know and we can compare
00:48 - strategies as we cover this and much
00:50 - more in today's video so let's open up
00:54 - our episode two projects and before we
00:57 - begin to code here's a really Speedy
00:59 - recap of what we've done so far in our
01:02 - player Sprite we move the player around
01:03 - with the mouse now recording their X and
01:06 - Y positions in the my values list over a
01:09 - number of frames while doing this we
01:11 - broadcast Cloud tick this is received in
01:14 - the cloud player Sprite and then into
01:17 - the send my cloud data script this code
01:21 - only runs once every fourth frame to
01:23 - ensure we don't exceed the cloud sending
01:26 - limit now we encode our Cloud message
01:28 - beginning with the player's unique ID a
01:31 - large random number that only our player
01:33 - uses followed by the rest of the data
01:36 - values from the AI values list of X and
01:38 - Y positions for the previous four frames
01:40 - of motion and Bam we set the cloud
01:43 - variable these updates are also picked
01:46 - up by everyone playing our scratch game
01:48 - we are only checking the first Cloud
01:50 - available Cloud 1 at present we compare
01:53 - it to our stored copy to check if it has
01:55 - changed if not there's nothing more to
01:58 - do but otherwise we begin to decode it
02:00 - the first number we read out is of
02:02 - course the sending player's unique ID
02:04 - now of course it's possible that we sent
02:06 - this message so we ignore our own IDs
02:10 - right away then either it's a new player
02:13 - one with a uid not in our playlist in
02:16 - which case we add them to our list or we
02:18 - saw them before and either way we ensure
02:20 - we also store the cloud data against the
02:23 - correct Row in the player list that's
02:25 - our data dictionary Splendid did all
02:28 - that make sense I hope so and this got
02:31 - us pretty far but the next step is so
02:33 - much more exciting we want to move from
02:36 - funky yet slightly boring scratch lists
02:39 - too awesome and Visually appealing Cloud
02:41 - Player Sprites all moving around on the
02:43 - screen together oh yes without further
02:46 - Ado then make sure to save the project
02:48 - as a new copy for this is episode three
02:52 - guys let's get scratching the first
02:56 - thing we want to do is make our Cloud
02:57 - players visible we already have an item
03:01 - in our player uid list for every player
03:03 - that joins our game the next step is to
03:06 - create a corresponding Sprite clone for
03:08 - each player too we already hid the
03:10 - original cloud player Sprite for this
03:13 - will act as a clone Factory creating
03:16 - visual clones one for each player that
03:18 - is added to our player list and so they
03:20 - remain identifiable will give each clone
03:23 - a player item number player hash
03:24 - matching their list item number as for
03:27 - the Clone Factory we'll just keep their
03:29 - player hash blank
03:31 - so beginning in the cloud player Sprite
03:33 - find the Define process Cloud item
03:36 - script and scroll down to where we just
03:38 - added a new player to the players list
03:40 - and if we create a clone of this Sprite
03:43 - immediately after setting the player
03:45 - hash then the new clone will be created
03:47 - with its player hash already set to the
03:49 - appropriate new list item number
03:51 - excellent then right at the bottom to
03:54 - keep our clone Factory identifiable we
03:56 - must set player hash back to the empty
03:58 - value now this won't affect the Clone we
04:01 - just created only the Clone Factory
04:04 - okay scroll over to the when I receive
04:07 - Cloud tick script we now have a problem
04:10 - with this when I receive block when we
04:12 - broadcast this message not only will it
04:14 - run on this Sprite but also on every
04:17 - clone that we just created so in effect
04:19 - it can run many many times per tick we
04:23 - should guard against this if player hash
04:26 - is greater than the empty value that's
04:29 - true for any of the Clones
04:31 - then we'll want to do player clone stuff
04:33 - like moving around the screen make a new
04:35 - custom block for that named player clone
04:38 - tick
04:39 - and we'll let it run without screen
04:41 - refresh
04:42 - okay
04:44 - and make use of it right away
04:47 - before stopping this script
04:50 - the Clones don't want to run any of the
04:52 - scripts below this only the single
04:54 - original clone Factory Sprite will go
04:56 - down that code path now perfecto
05:00 - let's take that Define player clone tick
05:02 - script into some free space
05:05 - each player clone will run this script
05:06 - individually and we want it to take the
05:09 - encoded cloud data and use it to move
05:12 - the Sprite around the screen as it
05:14 - happens when we created this clone we
05:16 - did so having just read the player uid
05:19 - out of their encoded string therefore we
05:23 - can continue where we left off and read
05:25 - out the very next pair of X and Y
05:27 - position values read number from encoded
05:31 - string into the valve variable and then
05:34 - set X position to the new value vowel
05:38 - do the same again for the Y value read
05:41 - number interval and set y position again
05:44 - to Val and I love that it's so
05:47 - straightforward and when we come around
05:49 - again after the next screen refresh
05:51 - we'll read out the next pair of X and Y
05:53 - values and that will continue to play
05:55 - back the animation one frame at a time
05:57 - but this encoded string is not boundless
06:00 - only containing four pairs of data so
06:03 - once we reach the end we'll need to feed
06:05 - it more data to keep our player moving
06:08 - smoothly
06:09 - and that is where our player data list
06:11 - comes in with luck while we were playing
06:14 - back the last animation from the buffer
06:16 - The Next Movement buffer will have
06:17 - arrived over the cloud and have been
06:19 - popped into the corresponding player
06:21 - data list ready for us to pick it up now
06:24 - so when we've reached the end of the
06:26 - encoded string if encoded index
06:29 - is greater than
06:34 - the length of encoded string
06:42 - make a new custom block named get next
06:45 - data packet
06:47 - and we'll run without screen refresh
06:50 - okay we'll code that up in a second
06:54 - first what happens when we get the next
06:56 - data packet but we haven't received any
06:59 - more data yet over the cloud
07:01 - if encoded string
07:03 - is equal
07:05 - to the empty value in that case there's
07:08 - nothing we can do except wait so stop
07:11 - this script and we'll try again the next
07:13 - game tick the whys off we go again right
07:18 - get the next data packet
07:21 - so we need to fetch it from the player
07:23 - data list set the encoded string to
07:27 - item of player data
07:30 - and at item number given by our player
07:33 - hash variable
07:35 - cool and I didn't mention this before
07:37 - but since we don't want to ever read the
07:40 - same value out of this list again we'll
07:42 - blank it out in the list using a replace
07:44 - item
07:46 - play a hash of player data and stuff in
07:50 - the blank value
07:52 - so the encoder string is set we should
07:54 - also set encoded index to the number two
07:57 - ready to begin reading from the second
07:59 - character after that initial C that we
08:02 - joined on the front do you remember that
08:04 - and the last step now read in the first
08:07 - encoded number that will be the sending
08:09 - player's unique ID we can simply skip
08:12 - over that for now as it gets us ready to
08:14 - read out the X and Y position values
08:16 - next and then off we go again the smooth
08:18 - playback can continue it's a beautifully
08:21 - clean process and I'm excited to test it
08:24 - out only hold on I just remembered we
08:27 - haven't yet made our clones visible so
08:30 - drop a show block here triggering as
08:33 - soon as we have successfully reading the
08:35 - second packet of data
08:37 - okay this is it we need two windows side
08:40 - by side and you'll notice the window I
08:42 - left open for testing on the right is
08:44 - still showing the old project I need to
08:46 - reload that one
08:48 - hold on to your scratch cats and here we
08:51 - go starting the right hand project first
08:53 - and there's my cat and then the left
08:56 - window oh yes are you seeing this we
09:00 - finally have two cats visible in a
09:02 - single project at once and as I move my
09:05 - cat around look how smoothly the motion
09:08 - is playing back on screen two very cool
09:11 - how about if we switch over to the
09:13 - second window
09:15 - oops a little glitch there but we are
09:18 - pushing scratches Cloud servers pretty
09:20 - hard and things are quickly back again
09:22 - pretty sweet right and I can switch back
09:25 - and forth without any issues whatsoever
09:27 - let's level this up how about three
09:30 - players okay not bad not bad at all the
09:33 - motion is still smooth with a few
09:35 - glitches now and then but don't forget
09:37 - we are still running this on a single
09:40 - Cloud variable so what would this be
09:43 - like if we upgraded the project to use
09:45 - say eight Cloud variables at a time now
09:48 - that would be eight times more bandwidth
09:50 - for the players to communicate over find
09:53 - the cloud setup script this is where we
09:55 - record the original value of the first
09:58 - Cloud variable let's duplicate that
10:00 - eight times over ready to support eight
10:03 - Cloud variables
10:09 - just make sure not to lose those two
10:11 - blocks off the bottom
10:13 - now we already have a Cloud 2 variable
10:16 - left over from episode one so drop it in
10:18 - as the second item added to the list
10:22 - make Cloud three
10:24 - as a cloud variable and then we do the
10:28 - same for cloud four Cloud five six seven
10:32 - and finally Cloud eight all as Cloud
10:36 - variables
10:37 - then drag each one in to be added to the
10:41 - list in the order one two eight
10:44 - this ensures we know the starting value
10:46 - of each Cloud variable
10:48 - next we need to observe each Cloud
10:50 - variable watching for changes of value
10:52 - and that's handled in our Cloud tick
10:54 - script down here
10:56 - process Cloud item one so again
10:59 - duplicate that block eight times over
11:05 - and then we switch to use cloud
11:07 - variables 1 2 3 4 5 6 7 and 8.
11:13 - and then set the corresponding Cloud
11:15 - item numbers down the left again
11:17 - matching it in one through eight
11:21 - Splendid that handles the reading in of
11:24 - changes from all of our eight Cloud
11:26 - variables but there's no point in doing
11:29 - any of this if we don't actually make
11:31 - use of these other variables look down
11:33 - here in the send my cloud data script
11:36 - yeah we're only ever setting Cloud one
11:39 - but we are faced with a choice how do we
11:42 - pick which Cloud variables to use now
11:45 - do we assign each player a random
11:46 - variable when we join the game or
11:49 - perhaps we switch every time we send a
11:51 - value
11:52 - or do we try to pick the least used
11:54 - Cloud variable over time is that even
11:56 - possible man well that's some
11:59 - complicated stuff but you don't have to
12:01 - worry the simplest method is probably
12:03 - the best and that is to switch every
12:07 - time
12:08 - so make a new variable to keep track of
12:10 - our choice name it my channel and keep
12:13 - it for all Sprites
12:15 - then set it
12:18 - to a pick random
12:19 - from one to the length of cloud values
12:24 - that should be eight right now
12:26 - okay move the set Cloud one out of the
12:29 - way for now
12:31 - we have eight choices of variables to
12:33 - set it may seem easiest to make eight if
12:36 - blocks and we could but instead we're
12:39 - going to use the binary chop technique
12:41 - to only require three if checks by
12:43 - splitting the problem in half over and
12:45 - over again to each a goal faster
12:48 - if my channel is less than five that
12:51 - splits the 8 channels in half from one
12:53 - to four and five to eight then we can
12:56 - narrow it down further with another if
12:58 - my channel is less than three that
13:00 - splits the one to four as one to two and
13:03 - three to four
13:04 - one more time then if my channel is less
13:07 - than two and hurray we have channel one
13:09 - so set Cloud one to encoded string in
13:13 - here
13:14 - otherwise it was channel two so set
13:17 - Cloud 2 to encoded string
13:19 - this pattern must continue duplicate the
13:22 - innermost if
13:25 - and check if my channel is less than
13:28 - four if so we set Cloud 3 to encoder
13:31 - string else set Cloud four
13:34 - now the biggest duplication of all the
13:37 - completed my channel is lesson 3 script
13:39 - down into the empty else branch and we
13:43 - can now see a pattern so simply set the
13:45 - right hand Cloud variables five six
13:48 - seven and eight in that order
13:51 - and then we notice that these are both
13:54 - less than seven
13:55 - five is less than six
14:00 - and for the other choice seven is less
14:03 - than eight
14:04 - job done and with that it's high time we
14:08 - gave it a test we should make all our
14:11 - Cloud variables visible so we can
14:13 - confirm they're all getting set
14:15 - if any are not now changing value then
14:18 - you'll have to go back and confirm that
14:20 - you got all those if conditions correct
14:23 - looking good here though every cloud
14:25 - variable has changed so I am confident
14:27 - to progress on and test this across the
14:29 - cloud bring back the second window I'm
14:32 - making sure of course that you save the
14:34 - project and reloaded that second browser
14:36 - window
14:36 - and now let's see what we've got
14:39 - okay yes it's looking pretty much the
14:43 - same but that is a good thing all we've
14:46 - done is make the engine eight times more
14:48 - capable and stable and that is a great
14:51 - thing if we are really wanting to
14:53 - support 20 50 100 players right now with
14:57 - three players again and we already are
15:00 - able to observe the benefits of extra
15:02 - Cloud bandwidth in the form of fewer
15:04 - dropouts in glitches yeah this engine is
15:07 - really coming together now so what else
15:09 - is left
15:11 - the natural progression is to next talk
15:13 - about what happens when a player leaves
15:15 - the game player clicks the stop button
15:17 - or closes their browser window and yet
15:19 - every other player continues to see the
15:21 - player 3 in their game just no longer
15:24 - moving around not only that but we are
15:27 - also no longer getting any Cloud
15:29 - variable updates from that player
15:31 - so how do we detect that they've left
15:35 - how about this we keep a record of how
15:38 - long it has been since each player sent
15:40 - us a cloud update and after a short
15:42 - period without any contact we can be
15:45 - pretty sure that they've left the game
15:46 - how simple is that this should be a
15:50 - cinch to code up in the cloud player
15:52 - Sprite find the player clone tick script
15:57 - make a new variable named inactive for
16:01 - this Sprite only that's important as
16:04 - each clone will need to keep track of
16:06 - their own inactivity
16:07 - and then every time we look for the new
16:10 - cloud data but don't find any we change
16:13 - inactive by one
16:15 - with no activity this will grow by 30
16:18 - ticks every second so if inactive is
16:21 - greater than
16:24 - 150 that will be five seconds we want to
16:28 - remove them from this game
16:30 - and you may find this a little
16:32 - surprising we don't delete the Clone
16:34 - only hide them instead
16:37 - and we scrub their unique ID out of the
16:39 - player list the reason each clone has a
16:42 - player hash that matches their item
16:45 - number in the player list if we were to
16:47 - delete an item then that link gets all
16:49 - skewed and things will go very wrong
16:52 - disaster so we don't do that
16:56 - so just scrub out the player uid by
16:59 - replacing item player hash
17:02 - of player uid
17:04 - with the blank value
17:06 - and hide this player clone
17:09 - out of sight out of mind
17:12 - lastly down here when we do receive data
17:15 - from the player we can set inactive back
17:17 - down to zero
17:20 - it is now active
17:22 - perfect it's testing time remember to
17:25 - save the project and reload the second
17:26 - window
17:27 - the first test is to check that both our
17:30 - players are visible and not becoming
17:32 - inactive when they shouldn't
17:34 - check then I stop the right window and
17:38 - this is the Moment of Truth the second
17:39 - player is still visible in the top left
17:41 - corner of the window and they are not
17:43 - they have left the game haha that is
17:47 - awesome take a look in the player uid
17:49 - list and confirm that their uid has been
17:52 - blanked out too that worked a treat but
17:56 - hold on what happens if I restart player
17:59 - 2's project the answer is the first
18:01 - player slot stays empty and a brand new
18:04 - slot is added for the rejoining player
18:06 - now I mean that does work okay but it's
18:10 - not very efficient and we will hit
18:12 - problems after enough players leave and
18:13 - rejoin eventually using up all 300 of
18:16 - the Clones that we have at our disposal
18:19 - so instead how about we get players to
18:21 - reuse the expired empty slots as they
18:24 - join our game guys let's get recycling
18:28 - find the process Cloud item script and
18:32 - scroll down to where we are adding the
18:33 - new players here instead of instantly
18:36 - adding new rows let's check for those
18:39 - empty slots duplicate the set player
18:42 - hash block and drop it in before we add
18:44 - rows to the player list but this time we
18:47 - are looking for empty items in the list
18:49 - the blank value
18:51 - then using an if else
18:53 - if player hash is again zero then nope
18:57 - there were no empty slots so go ahead
19:00 - and add that new row after all
19:03 - but if player hash is greater than zero
19:05 - then we did find a free slot so this
19:08 - time don't create a new clone and simply
19:11 - replace player hash of and not play data
19:15 - but the player uids and replace it with
19:18 - Val as that still holds the unique ID of
19:21 - the joining player at this point
19:24 - and then the Clone player should pick up
19:26 - the new data packet and spring back to
19:29 - life
19:30 - vanderbar we have to test this right
19:33 - away save and reload the second window
19:35 - and smash those green flags straight
19:38 - away I'll stop player 2's game and wait
19:41 - for them to leave yep there they go now
19:45 - we have an empty game slot so will it
19:47 - get reused when we rejoin
19:49 - yes they do that is so smart clone
19:53 - recycling for the win we can of course
19:55 - push this a little harder and try the
19:57 - same test with many more players at once
20:00 - to make this more fun to watch let's
20:02 - change the my player script to cause the
20:04 - cat to dance in small circles we only go
20:07 - to the mouse pointer when the mouse
20:09 - button is down then always move forward
20:12 - by five and turn clockwise by 10. this
20:15 - will take us in those small circles
20:18 - switch the direction mode to don't
20:20 - rotate for the time being as direction
20:23 - will be covered in the next episode
20:26 - finally to distinguish our player from
20:27 - all the others why not set their color
20:29 - effect to 20. nice okay let's do this
20:34 - save and reload all the project Windows
20:36 - here I'm using four now and it's easy to
20:39 - see which player is mine on each screen
20:41 - and the movement makes it more obvious
20:43 - which players are having Network
20:44 - glitches pretty sweet so far I'm
20:47 - enjoying their hypnotic dance I'll stop
20:50 - one player and they are removed from the
20:53 - other windows after five seconds then
20:56 - rejoining yeah it's instant and now the
21:00 - blank slot is recycled so that is good
21:02 - next I'm stopping all but one player and
21:06 - there are three empty player slots and
21:09 - as I rejoin the player slots get
21:11 - refilled and the gameplay resumes that
21:15 - works great so who's ready to begin
21:17 - plugging this into our own games I know
21:20 - I am and in the next video I'll show you
21:24 - exactly how it's done so please drop me
21:27 - a comment under this video to let me
21:29 - know what game types you'd like to see
21:30 - covered first I'm planning to show it
21:32 - off in a platformer a top-down game
21:35 - maybe the raycaster and perhaps some
21:37 - kind of shooter game too what do you
21:39 - guys suggest anyhow we have reached the
21:42 - end of this episode I do hope you're
21:44 - enjoying this series if so please do
21:46 - smash that like button and if you
21:48 - haven't already subscribe to the channel
21:49 - ticking that Bell icon so you get
21:51 - notified as soon as the next episode
21:53 - lands but until then thanks for watching
21:57 - have a great week ahead and scratch on
22:00 - guys
22:02 - [Music]

Cleaned transcript:

foreign scratchers welcome back to the wonderful world of online multiplayer scratch games and I'm so excited because in this third episode in the series all our hard work finally comes together we'll be using clones to bring the cloud players to life and yes supporting from two to over 100 players in game at the same time and those move re buffers from episode 2 will ensure everyone is moving as smooth and Pixel Perfect as possible what's this uh you've gone blank are you still there and now I often get asked how we can know when players leave our Cloud games well perhaps I just gave you a clue drop me a comment under the video if you think you know and we can compare strategies as we cover this and much more in today's video so let's open up our episode two projects and before we begin to code here's a really Speedy recap of what we've done so far in our player Sprite we move the player around with the mouse now recording their X and Y positions in the my values list over a number of frames while doing this we broadcast Cloud tick this is received in the cloud player Sprite and then into the send my cloud data script this code only runs once every fourth frame to ensure we don't exceed the cloud sending limit now we encode our Cloud message beginning with the player's unique ID a large random number that only our player uses followed by the rest of the data values from the AI values list of X and Y positions for the previous four frames of motion and Bam we set the cloud variable these updates are also picked up by everyone playing our scratch game we are only checking the first Cloud available Cloud 1 at present we compare it to our stored copy to check if it has changed if not there's nothing more to do but otherwise we begin to decode it the first number we read out is of course the sending player's unique ID now of course it's possible that we sent this message so we ignore our own IDs right away then either it's a new player one with a uid not in our playlist in which case we add them to our list or we saw them before and either way we ensure we also store the cloud data against the correct Row in the player list that's our data dictionary Splendid did all that make sense I hope so and this got us pretty far but the next step is so much more exciting we want to move from funky yet slightly boring scratch lists too awesome and Visually appealing Cloud Player Sprites all moving around on the screen together oh yes without further Ado then make sure to save the project as a new copy for this is episode three guys let's get scratching the first thing we want to do is make our Cloud players visible we already have an item in our player uid list for every player that joins our game the next step is to create a corresponding Sprite clone for each player too we already hid the original cloud player Sprite for this will act as a clone Factory creating visual clones one for each player that is added to our player list and so they remain identifiable will give each clone a player item number player hash matching their list item number as for the Clone Factory we'll just keep their player hash blank so beginning in the cloud player Sprite find the Define process Cloud item script and scroll down to where we just added a new player to the players list and if we create a clone of this Sprite immediately after setting the player hash then the new clone will be created with its player hash already set to the appropriate new list item number excellent then right at the bottom to keep our clone Factory identifiable we must set player hash back to the empty value now this won't affect the Clone we just created only the Clone Factory okay scroll over to the when I receive Cloud tick script we now have a problem with this when I receive block when we broadcast this message not only will it run on this Sprite but also on every clone that we just created so in effect it can run many many times per tick we should guard against this if player hash is greater than the empty value that's true for any of the Clones then we'll want to do player clone stuff like moving around the screen make a new custom block for that named player clone tick and we'll let it run without screen refresh okay and make use of it right away before stopping this script the Clones don't want to run any of the scripts below this only the single original clone Factory Sprite will go down that code path now perfecto let's take that Define player clone tick script into some free space each player clone will run this script individually and we want it to take the encoded cloud data and use it to move the Sprite around the screen as it happens when we created this clone we did so having just read the player uid out of their encoded string therefore we can continue where we left off and read out the very next pair of X and Y position values read number from encoded string into the valve variable and then set X position to the new value vowel do the same again for the Y value read number interval and set y position again to Val and I love that it's so straightforward and when we come around again after the next screen refresh we'll read out the next pair of X and Y values and that will continue to play back the animation one frame at a time but this encoded string is not boundless only containing four pairs of data so once we reach the end we'll need to feed it more data to keep our player moving smoothly and that is where our player data list comes in with luck while we were playing back the last animation from the buffer The Next Movement buffer will have arrived over the cloud and have been popped into the corresponding player data list ready for us to pick it up now so when we've reached the end of the encoded string if encoded index is greater than the length of encoded string make a new custom block named get next data packet and we'll run without screen refresh okay we'll code that up in a second first what happens when we get the next data packet but we haven't received any more data yet over the cloud if encoded string is equal to the empty value in that case there's nothing we can do except wait so stop this script and we'll try again the next game tick the whys off we go again right get the next data packet so we need to fetch it from the player data list set the encoded string to item of player data and at item number given by our player hash variable cool and I didn't mention this before but since we don't want to ever read the same value out of this list again we'll blank it out in the list using a replace item play a hash of player data and stuff in the blank value so the encoder string is set we should also set encoded index to the number two ready to begin reading from the second character after that initial C that we joined on the front do you remember that and the last step now read in the first encoded number that will be the sending player's unique ID we can simply skip over that for now as it gets us ready to read out the X and Y position values next and then off we go again the smooth playback can continue it's a beautifully clean process and I'm excited to test it out only hold on I just remembered we haven't yet made our clones visible so drop a show block here triggering as soon as we have successfully reading the second packet of data okay this is it we need two windows side by side and you'll notice the window I left open for testing on the right is still showing the old project I need to reload that one hold on to your scratch cats and here we go starting the right hand project first and there's my cat and then the left window oh yes are you seeing this we finally have two cats visible in a single project at once and as I move my cat around look how smoothly the motion is playing back on screen two very cool how about if we switch over to the second window oops a little glitch there but we are pushing scratches Cloud servers pretty hard and things are quickly back again pretty sweet right and I can switch back and forth without any issues whatsoever let's level this up how about three players okay not bad not bad at all the motion is still smooth with a few glitches now and then but don't forget we are still running this on a single Cloud variable so what would this be like if we upgraded the project to use say eight Cloud variables at a time now that would be eight times more bandwidth for the players to communicate over find the cloud setup script this is where we record the original value of the first Cloud variable let's duplicate that eight times over ready to support eight Cloud variables just make sure not to lose those two blocks off the bottom now we already have a Cloud 2 variable left over from episode one so drop it in as the second item added to the list make Cloud three as a cloud variable and then we do the same for cloud four Cloud five six seven and finally Cloud eight all as Cloud variables then drag each one in to be added to the list in the order one two eight this ensures we know the starting value of each Cloud variable next we need to observe each Cloud variable watching for changes of value and that's handled in our Cloud tick script down here process Cloud item one so again duplicate that block eight times over and then we switch to use cloud variables 1 2 3 4 5 6 7 and 8. and then set the corresponding Cloud item numbers down the left again matching it in one through eight Splendid that handles the reading in of changes from all of our eight Cloud variables but there's no point in doing any of this if we don't actually make use of these other variables look down here in the send my cloud data script yeah we're only ever setting Cloud one but we are faced with a choice how do we pick which Cloud variables to use now do we assign each player a random variable when we join the game or perhaps we switch every time we send a value or do we try to pick the least used Cloud variable over time is that even possible man well that's some complicated stuff but you don't have to worry the simplest method is probably the best and that is to switch every time so make a new variable to keep track of our choice name it my channel and keep it for all Sprites then set it to a pick random from one to the length of cloud values that should be eight right now okay move the set Cloud one out of the way for now we have eight choices of variables to set it may seem easiest to make eight if blocks and we could but instead we're going to use the binary chop technique to only require three if checks by splitting the problem in half over and over again to each a goal faster if my channel is less than five that splits the 8 channels in half from one to four and five to eight then we can narrow it down further with another if my channel is less than three that splits the one to four as one to two and three to four one more time then if my channel is less than two and hurray we have channel one so set Cloud one to encoded string in here otherwise it was channel two so set Cloud 2 to encoded string this pattern must continue duplicate the innermost if and check if my channel is less than four if so we set Cloud 3 to encoder string else set Cloud four now the biggest duplication of all the completed my channel is lesson 3 script down into the empty else branch and we can now see a pattern so simply set the right hand Cloud variables five six seven and eight in that order and then we notice that these are both less than seven five is less than six and for the other choice seven is less than eight job done and with that it's high time we gave it a test we should make all our Cloud variables visible so we can confirm they're all getting set if any are not now changing value then you'll have to go back and confirm that you got all those if conditions correct looking good here though every cloud variable has changed so I am confident to progress on and test this across the cloud bring back the second window I'm making sure of course that you save the project and reloaded that second browser window and now let's see what we've got okay yes it's looking pretty much the same but that is a good thing all we've done is make the engine eight times more capable and stable and that is a great thing if we are really wanting to support 20 50 100 players right now with three players again and we already are able to observe the benefits of extra Cloud bandwidth in the form of fewer dropouts in glitches yeah this engine is really coming together now so what else is left the natural progression is to next talk about what happens when a player leaves the game player clicks the stop button or closes their browser window and yet every other player continues to see the player 3 in their game just no longer moving around not only that but we are also no longer getting any Cloud variable updates from that player so how do we detect that they've left how about this we keep a record of how long it has been since each player sent us a cloud update and after a short period without any contact we can be pretty sure that they've left the game how simple is that this should be a cinch to code up in the cloud player Sprite find the player clone tick script make a new variable named inactive for this Sprite only that's important as each clone will need to keep track of their own inactivity and then every time we look for the new cloud data but don't find any we change inactive by one with no activity this will grow by 30 ticks every second so if inactive is greater than 150 that will be five seconds we want to remove them from this game and you may find this a little surprising we don't delete the Clone only hide them instead and we scrub their unique ID out of the player list the reason each clone has a player hash that matches their item number in the player list if we were to delete an item then that link gets all skewed and things will go very wrong disaster so we don't do that so just scrub out the player uid by replacing item player hash of player uid with the blank value and hide this player clone out of sight out of mind lastly down here when we do receive data from the player we can set inactive back down to zero it is now active perfect it's testing time remember to save the project and reload the second window the first test is to check that both our players are visible and not becoming inactive when they shouldn't check then I stop the right window and this is the Moment of Truth the second player is still visible in the top left corner of the window and they are not they have left the game haha that is awesome take a look in the player uid list and confirm that their uid has been blanked out too that worked a treat but hold on what happens if I restart player 2's project the answer is the first player slot stays empty and a brand new slot is added for the rejoining player now I mean that does work okay but it's not very efficient and we will hit problems after enough players leave and rejoin eventually using up all 300 of the Clones that we have at our disposal so instead how about we get players to reuse the expired empty slots as they join our game guys let's get recycling find the process Cloud item script and scroll down to where we are adding the new players here instead of instantly adding new rows let's check for those empty slots duplicate the set player hash block and drop it in before we add rows to the player list but this time we are looking for empty items in the list the blank value then using an if else if player hash is again zero then nope there were no empty slots so go ahead and add that new row after all but if player hash is greater than zero then we did find a free slot so this time don't create a new clone and simply replace player hash of and not play data but the player uids and replace it with Val as that still holds the unique ID of the joining player at this point and then the Clone player should pick up the new data packet and spring back to life vanderbar we have to test this right away save and reload the second window and smash those green flags straight away I'll stop player 2's game and wait for them to leave yep there they go now we have an empty game slot so will it get reused when we rejoin yes they do that is so smart clone recycling for the win we can of course push this a little harder and try the same test with many more players at once to make this more fun to watch let's change the my player script to cause the cat to dance in small circles we only go to the mouse pointer when the mouse button is down then always move forward by five and turn clockwise by 10. this will take us in those small circles switch the direction mode to don't rotate for the time being as direction will be covered in the next episode finally to distinguish our player from all the others why not set their color effect to 20. nice okay let's do this save and reload all the project Windows here I'm using four now and it's easy to see which player is mine on each screen and the movement makes it more obvious which players are having Network glitches pretty sweet so far I'm enjoying their hypnotic dance I'll stop one player and they are removed from the other windows after five seconds then rejoining yeah it's instant and now the blank slot is recycled so that is good next I'm stopping all but one player and there are three empty player slots and as I rejoin the player slots get refilled and the gameplay resumes that works great so who's ready to begin plugging this into our own games I know I am and in the next video I'll show you exactly how it's done so please drop me a comment under this video to let me know what game types you'd like to see covered first I'm planning to show it off in a platformer a topdown game maybe the raycaster and perhaps some kind of shooter game too what do you guys suggest anyhow we have reached the end of this episode I do hope you're enjoying this series if so please do smash that like button and if you haven't already subscribe to the channel ticking that Bell icon so you get notified as soon as the next episode lands but until then thanks for watching have a great week ahead and scratch on guys
