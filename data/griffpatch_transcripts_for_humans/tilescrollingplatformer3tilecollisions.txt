With timestamps:

00:02 - hello fellow scratchers
00:04 - and welcome back to part three of our
00:06 - series creating a tiled scrolling
00:08 - platformer in scratch
00:09 - and wow this is going to be a good one
00:12 - we are going to introduce a playable
00:14 - character to the game
00:15 - and delve into the world of tile
00:17 - collisions the bad news is that unlike
00:19 - sprite costume collisions
00:21 - we need to do a lot more scripting to
00:23 - pull it off but the great news
00:25 - is that not only will our scripts run
00:27 - faster and sprite sensing collisions but
00:29 - they will also work
00:30 - off screen and allow us to know what
00:32 - collided with what
00:34 - this is crucial for making really
00:36 - awesome games in scratch
00:37 - so stay with me and let's get scratching
00:42 - okay continuing from where we left off
00:44 - in episode two
00:45 - make sure we have the mario sprite
00:47 - selected he's not visible yet so
00:50 - click the show icon here to make him
00:52 - visible
00:53 - yay there he is i'll click and drag him
00:56 - into a free space
00:57 - this also ensures he's brought in front
00:59 - of all the other sprites in the game
01:02 - now gosh he's really small so set his
01:04 - size to 200 just here
01:06 - and then finally set his direction mode
01:09 - to left right
01:10 - this makes him simply flip directions
01:12 - when he's facing left or right
01:14 - that's great mario's in the game but if
01:17 - i run the project
01:18 - well he kind of looks like he's
01:20 - scrolling around the level but
01:21 - nah that's just wishful thinking he's
01:24 - simply sitting where we left him
01:26 - and doesn't know anything about
01:27 - scrolling levels yet
01:29 - to begin with let's get him controlled
01:31 - by the keyboard
01:32 - make with me a new block named reset
01:35 - player
01:36 - ticking to run without screen refresh we
01:39 - will put all
01:40 - the scripts in here that set the
01:41 - player's starting position and state
01:44 - we need to include two new variables to
01:46 - store our player's real position on the
01:47 - level
01:48 - make the first one named simply x
01:51 - now let's just hold it right there for a
01:53 - moment you've no idea how much i
01:55 - struggled with naming this variable
01:57 - i wanted to call it playerx but having a
01:59 - very specific name would not make it
02:01 - easy to copy scripts between sprites so
02:04 - we will go with a simple name x good
02:08 - then we'll need to make a y variable for
02:10 - this sprite only
02:12 - and set them both to 100 this will be
02:15 - the player's start position
02:16 - on the level
02:19 - next move the set camera x and y scripts
02:23 - to here
02:24 - replacing them with our new reset player
02:26 - block
02:28 - lastly it is a good idea to use a move
02:31 - camera block after setting up the player
02:33 - to ensure the camera is not out of
02:35 - bounds
02:37 - next create a new custom block named
02:39 - game loop
02:41 - now because a game loop is long running
02:43 - script we must leave
02:45 - the run without screen refresh unchecked
02:48 - you got that
02:49 - excellent now bring the forever loop
02:51 - down
02:52 - into the new define block and replace it
02:54 - with a call to this new block
02:57 - add a broadcast for the new event we'll
03:01 - name
03:02 - move player the order of the broadcasts
03:06 - is
03:06 - very important we want the player to
03:08 - move first
03:09 - and then we'll update the camera
03:10 - position before finally redrawing all
03:12 - the tiles
03:13 - this is to avoid sprites appearing to
03:15 - lag behind the scrolling of the level
03:18 - bring in a when i receive move player
03:21 - hat block
03:22 - make a new variable named speed x for
03:25 - this sprite only
03:27 - this will represent mario's current
03:29 - horizontal speed
03:31 - that is the velocity along the x-axis
03:33 - left and right
03:34 - now i want to show you a really neat
03:36 - trick bring in
03:37 - a set speed x block and set it to
03:40 - key right arrow pressed now run the
03:42 - project and see the value of speed
03:44 - x changing from false to true when we
03:47 - hold down the right arrow key
03:50 - okay no surprises there but look what
03:52 - happens when we place
03:53 - a minus block around the keypress block
03:58 - the value has changed from true false
04:01 - to one or zero because scratch knows we
04:04 - are working with numbers
04:05 - due to the subtract operator it has
04:08 - helpfully converted the true false value
04:10 - to a one zero value
04:11 - we can use this to our advantage c if we
04:14 - place
04:15 - a key left arrow pressed in the right
04:17 - hand side of the minus operator
04:19 - and test again we are able to get one
04:21 - for right
04:22 - zero for no direction and minus one for
04:25 - left
04:26 - and all this from one line of script
04:28 - awesome
04:30 - we can simply multiply this by six and
04:32 - we have a very quick way of changing the
04:34 - speed
04:36 - so make a new variable named speed y for
04:38 - this sprite only
04:39 - and we'll do the same for the up and
04:41 - down keys 6 multiplied by
04:43 - up key minus down key next we actually
04:47 - move the player
04:49 - introducing a change x by speed x
04:52 - followed by a change y by speed y
04:56 - bring the move camera block down from
04:58 - the game loop to here
04:59 - we want to position the camera right
05:01 - after we've updated the player's
05:02 - position on the level
05:04 - finally let's position the mario sprite
05:07 - on the screen
05:08 - just use a regular go to xy with our
05:11 - standard
05:12 - x minus camera x and y minus camera y
05:16 - great so it's testing time click the
05:19 - green flag
05:20 - and use the arrow keys to move mario we
05:22 - can still use the camera x and y
05:24 - scrollers to scroll the level but don't
05:26 - forget to click back on the stage
05:28 - after doing this otherwise the arrow
05:30 - keys stop working
05:31 - well that's funky but my hand is getting
05:34 - tired of operating the camera sliders
05:36 - let's get the camera to follow mario
05:38 - automatically
05:40 - locate the define move a camera script
05:44 - here at the top set camera x to x
05:47 - right away we can test this and see how
05:49 - the camera is following the player left
05:51 - and right
05:51 - nicely fenced in on the left and right
05:53 - by the edge of the level
05:55 - it would be easy to do the same for the
05:57 - camera y but instead let's do something
05:59 - a little better
06:01 - change camera y by y
06:04 - subtracted camera y all divided by four
06:09 - we can test this to see how the camera
06:11 - now tracks more smoothly
06:12 - up and down this is better for jumping
06:15 - games as it avoids any sharp
06:17 - up and down movements of the camera when
06:19 - the player is quickly jumping around
06:21 - try different values instead of four to
06:23 - track faster or slower
06:24 - but for us four is a very good value
06:27 - right
06:28 - we can finally hide those camera sliders
06:30 - from the screen yay
06:32 - so far so good the movement is excellent
06:35 - but unless we are some kind of ghoul we
06:37 - should really do something about walking
06:39 - through solid walls
06:41 - okay i hope you've got your wits about
06:43 - you because this requires some more
06:44 - tricky scripting
06:46 - to make it easier to follow we'll break
06:47 - the process down into four
06:49 - steps step one is to calculate the
06:52 - location of a point on the level grid
06:54 - step two determining the tile under that
06:57 - point step three handling point
06:59 - collisions
06:59 - and step four handling larger sprite
07:02 - collisions
07:03 - so here we go step one calculate the
07:05 - location of a point on the level grid
07:08 - rather than working with the mario
07:09 - sprite we'll open the costume editor
07:12 - and create a new costume and draw a
07:14 - small dot in the very center
07:16 - just here this will be easier to work
07:18 - with than the mario sprite for the next
07:20 - few tasks
07:22 - remember our explanation of how we use a
07:24 - simple number square to give
07:26 - a unique index to each tile in the level
07:28 - grid
07:29 - we are going to create a custom block
07:31 - that given a position
07:33 - x and y will give us back the tile at
07:35 - that location
07:37 - we'll make a new custom block get tile
07:40 - at x
07:41 - colon add a numeric input x
07:44 - a text label of y colon and another
07:48 - input
07:49 - of y click to run without screen refresh
07:53 - we'll use this block right after we
07:55 - update the player's y variable in the
07:56 - game loop
07:58 - pass into it the x and y of our player
08:01 - create a new variable named tile grid
08:04 - x for this sprite only now look again at
08:08 - this tile grid
08:09 - given the x and y position of the player
08:12 - we want to first calculate
08:13 - how many tiles across and up the screen
08:16 - the player is
08:18 - luckily this is easy to do we just
08:20 - divide the x and y position
08:22 - by the tile size 32
08:25 - so back in the code set our tile grid x
08:28 - to the floor of the new input variable
08:31 - x divide it by 32.
08:34 - the floor operator is used to round
08:36 - numbers down to their nearest whole
08:38 - number
08:39 - we'll create another new variable tile
08:41 - grid y
08:42 - and do the same thing for the y input
08:51 - okay run the project and if we move the
08:53 - mario dot to the bottom left tile of the
08:55 - level
08:56 - we will see that tile grid x and y are
08:58 - both
08:59 - zero as i walk upwards our tile grid y
09:03 - variable increases by one for each tile
09:05 - walking to the right has a similar
09:07 - effect on tile grid
09:08 - x and we can use this to calculate the
09:11 - unique index of the tile in the grid
09:13 - list
09:15 - now we want the actual tile index so
09:18 - create a new variable naming it
09:20 - tile index for this sprite only
09:23 - now look at our number square example
09:25 - again the script for calculating the
09:27 - tile index from the grid x and y
09:29 - is quite straightforward the first tile
09:32 - starts at one
09:33 - then we add the grid y to get to here
09:37 - finally we add grid x multiplied by
09:40 - grid height to get us to the correct
09:42 - tile index
09:44 - so putting that into code add a set tile
09:47 - index to
09:51 - one plus grid tile y
09:58 - plus greater x times grid height
10:04 - let's run the project again and see if
10:05 - this works as expected we can check that
10:07 - the bottom left corner of the level is
10:09 - indeed
10:10 - tile index 1. moving up we'll add 1 to
10:13 - this number for each grid tile
10:14 - and moving right should add 20 assuming
10:17 - our grid height
10:18 - is still the original 20 tiles high
10:21 - that's working
10:21 - really well i'll just hide these
10:23 - variable reporters
10:25 - okay so step two determining the tile
10:28 - under that point
10:30 - since we already have the tile index
10:32 - getting the corresponding tile costume
10:34 - out of the targrid list
10:35 - is now super easy make a new variable
10:38 - named
10:39 - tile for this sprite only
10:43 - and set it to item
10:47 - tile index of tile grid
10:50 - and that's it i told you that was going
10:52 - to be easy let's run the project again
10:54 - this is really awesome if you remember
10:57 - our key tile costume 2
10:58 - is the blank tile 9 the golden tile and
11:01 - 10 the wooden tile
11:02 - as we pass over the tiles in the level
11:05 - we see that we are now picking up the
11:07 - correct costume number from the grid
11:08 - list
11:09 - just as we intended perfect
11:12 - ok so step three handling point
11:14 - collisions
11:16 - we now have a way to detect what tile we
11:18 - are touching using our get tile at
11:20 - costume block
11:22 - it's not a great stretch then to now be
11:24 - able to look for collisions
11:25 - and try to prevent them we'll start by
11:28 - doing it the easy way
11:29 - bring in a new if tile is greater than 2
11:33 - remember tile 2 is the blank one so this
11:35 - collision will be true
11:36 - for any non-blank tile if this is the
11:39 - case
11:40 - then we have collided and we change the
11:42 - player's y value back to where it came
11:44 - from
11:44 - that is negative speed y let's do the
11:47 - same for the change x
11:49 - remembering to also add a get tile at
11:52 - block
11:52 - like this
12:06 - okay run the project and let's have a
12:08 - wander around
12:10 - oh yes this is looking good we have been
12:12 - able to prevent the player dot walking
12:14 - through the walls
12:15 - this is fun however if we now swap the
12:19 - player's sprite back to mario
12:21 - and test again we shall find that we are
12:24 - not quite there yet
12:26 - our clever collision detection is only
12:28 - looking for a
12:29 - single collision point in the center of
12:31 - the player's sprite
12:32 - it doesn't know anything about handling
12:34 - collisions for a sprite with a width and
12:36 - height
12:37 - so step 4 handling larger sprite
12:41 - collisions
12:42 - the left and right hand collisions are
12:44 - not such a problem
12:46 - but the head and feet need to be
12:48 - addressed we'll do this by defining the
12:50 - player's
12:50 - height and then testing for collisions
12:53 - not just at the central point
12:55 - but at his head and feet too make a new
12:58 - variable named
12:59 - height for this sprite only
13:04 - within the reset player script set
13:07 - height to 24.
13:08 - this is actually half the full height of
13:11 - the sprite in case you're wondering
13:13 - it's just easier to work with half sizes
13:16 - to avoid repetition of scripts create a
13:18 - new custom block
13:20 - named fix collision in direction
13:23 - dx colon adding a numeric
13:26 - input dx then a text label
13:29 - d y colon and another numeric input
13:32 - d y ensure this is running without
13:35 - screen refresh
13:37 - we'll use it in place of both of the get
13:39 - tile at blocks here
13:41 - moving one of the if conditions into the
13:43 - define block we just created
13:45 - we only pass into the fixed collision
13:47 - block the amount we just changed speed
13:49 - x or y by
14:03 - and this is free just have both the
14:05 - change x and change y scripts in here
14:07 - together
14:12 - this is a good point just to retest the
14:14 - scripts to ensure that they are still
14:15 - working
14:16 - as before good we now have one script
14:19 - handling both the horizontal and
14:21 - vertical collisions
14:23 - now you're not going to believe me but
14:25 - let's make yet one more custom block
14:27 - named fix collision at point
14:31 - x colon an input of x a label of y colon
14:35 - and an input of y and we'll swap this
14:38 - out for the get tile x y that we just
14:41 - moved
14:42 - we'll pass in the sprites x and y
14:44 - variables so that it knows where to look
14:46 - for collisions
14:47 - and then within the define block plug
14:49 - the x and y
14:50 - input parameters to the get tile block
14:53 - so here we are checking just the central
14:56 - point of mario
14:57 - let's duplicate the fixed point
14:59 - collision twice more
15:00 - changing the top usage to check at
15:02 - mario's feet by subtracting
15:04 - height from y
15:09 - and the bottom to check his head by
15:11 - adding height
15:12 - to y to keep track of whether any of
15:15 - these points collided
15:16 - we make a new variable named solid for
15:19 - this sprite only
15:22 - and set it to the blank value before we
15:25 - use the fixed point blocks
15:30 - now at the end of the define fixed point
15:32 - collision script
15:34 - we add the if block that checks whether
15:36 - tile is greater than 2.
15:40 - if a collision has occurred then we set
15:42 - solid to the number 10.
15:44 - right now this value doesn't mean much
15:46 - except that any number larger than 0
15:48 - is some kind of solid collision i've
15:51 - chosen 10 to mean
15:52 - very solid we can now update the if
15:55 - under the calls to fix
15:56 - point to confirm whether solid has been
15:58 - set to a value greater than zero
16:01 - this indicates that one or more of the
16:03 - above collision checks has indeed
16:05 - registered a collision
16:07 - we can run this to see the effect ah yes
16:10 - this is much better
16:11 - much better indeed collisions at his
16:13 - feet work extremely well
16:15 - as do the ones at his head good work if
16:18 - you've made it this far
16:19 - we are not going to worry about giving
16:21 - mario any defined width at present
16:23 - as to be honest he works pretty well
16:25 - without it we'll revisit this later
16:29 - our next move in developing this project
16:31 - will be to give our player
16:32 - a more platforming feel the scripts for
16:35 - movement
16:36 - will only get more complex so let's
16:38 - split up the code with custom blocks
16:40 - for handling player keyboard input make
16:43 - with me a new block named
16:45 - handle keys dash left right
16:49 - run without screen refresh this block is
16:52 - replacing the set speed
16:53 - x block in our move player script let's
16:56 - update this script
16:57 - to give the player a little acceleration
17:00 - make a new variable named
17:01 - key walk for all sprites
17:04 - and set it to the right arrow key take
17:07 - away
17:08 - the left arrow key then we will set
17:10 - speed x
17:11 - to speed x multiplied by 0.8
17:15 - this simulates friction slowing the
17:18 - player down
17:19 - add to this key walk multiplied by
17:22 - two this will cause the player to
17:24 - accelerate in this direction
17:26 - give this a test
17:30 - oh nice the left and right movement
17:32 - feels much more natural and fluid
17:36 - next we'll add in some gravity and
17:37 - jumping
17:39 - make a new block named handle keys
17:42 - dash jump and run without screen refresh
17:45 - this will replace the set speed y
17:47 - block
17:55 - firstly let's handle the jump key wrap
17:58 - the set speed y in an if
18:00 - and use the key up arrow pressed as the
18:02 - trigger
18:03 - we'll set speed y to 14 for a nice quick
18:06 - upwards thrust
18:08 - now let's handle gravity so we'll change
18:10 - speed y
18:11 - by -2 accelerating our player
18:14 - downwards we'll place a cap on how fast
18:17 - he can fall using an if speed y
18:20 - is less than -22 then
18:23 - set speed y 2 minus 22
18:27 - this way his downward speed will never
18:29 - exceed negative 22 pixels
18:32 - okay time for another test now
18:35 - this is feeling more real perhaps a
18:38 - little more flappy bird than mario but
18:40 - that's okay we will improve
18:42 - things no end going forwards what is
18:44 - important is that his collisions work
18:46 - well
18:47 - and do they well not as well as
18:50 - you may have hoped introducing variable
18:53 - speeds of movement has revealed an
18:54 - issue with how we fix a collision after
18:56 - it has occurred
18:58 - firstly after a collision we need to set
19:00 - the player's speed back to zero
19:03 - find and define fix collisions in
19:05 - direction script
19:06 - and see where we resolve a collision by
19:09 - changing the position back
19:11 - by negative at dx and dy insert an if
19:14 - else block after that and check for dx
19:16 - equaling zero if this is true then we
19:19 - have collided by moving up or down
19:21 - so set speed y to zero otherwise
19:25 - it was a sideways collision so set speed
19:27 - x to zero
19:28 - we can test this again it should now fix
19:30 - some of the oddness after a collision
19:33 - yep we do now see the player perfectly
19:36 - touching the floor after each jump
19:38 - but it almost looks like he's bouncing
19:40 - back on impact
19:41 - did you see that this is down to a
19:44 - second and more
19:45 - complex issue due to the way we move the
19:47 - player back out of a solid block after a
19:50 - collision
19:51 - see how we are just moving them back by
19:53 - the same amount they moved in
19:55 - this does ensure the player will be out
19:57 - of the collision but it often results in
19:59 - them
19:59 - ending up quite far from the wall still
20:02 - we instead
20:02 - need to find out the smallest amount to
20:05 - move the player back to get them
20:06 - free of the collision now if we were
20:09 - using sprite touching level sensing
20:11 - blocks
20:12 - we would do this by moving the player a
20:14 - pixel at a time away from the wall
20:16 - until they were no longer touching it we
20:18 - could do a similar thing looping the
20:20 - fixed collision point blocks
20:21 - but for a tile based game it's much more
20:24 - efficient and dare i say fun
20:26 - to use a little maths first make two new
20:29 - variables named
20:31 - fix dx for this sprite only and
20:34 - fix d y for this sprite only at the
20:37 - start of the define
20:38 - fix collisions in direction script set
20:40 - these new variables to the input
20:42 - variables dx and dy
20:44 - this is so that we can make use of them
20:46 - later
20:49 - now we'll remove the change x change y
20:51 - from the script for the time being
20:53 - now scroll to the define fixed point
20:55 - collision script
20:57 - we are going to need another two
20:58 - variables so make a mod
21:00 - x for this sprite only and a mod y
21:03 - also for this sprite only we'll set them
21:06 - to the side here using the x and y input
21:08 - variables
21:10 - set mod x to x modulus 32.
21:16 - and mod y to y modulus 32
21:22 - look at this diagram notice how this
21:24 - point has collided with a tile block
21:27 - to push this point out of the tile we
21:30 - need to know how far the point is
21:32 - from the next grid line mod to the
21:34 - rescue
21:36 - the distance from previous grid line to
21:38 - the point y
21:39 - is calculated using y mod 32
21:42 - therefore to move the collision point
21:44 - upwards out of this block
21:46 - we just need to move by the remainder of
21:49 - the tile's height
21:50 - that is 32 subtract y
21:53 - mod 32 we can code this directly
21:58 - after setting mod x and mod y add an if
22:01 - fixed d y is less than zero this checks
22:04 - that the player was moving downwards
22:07 - then here we go change y by 32
22:11 - subtract our mod y variable just as we
22:14 - described
22:15 - we've only coded this for one direction
22:18 - but it's a great one to test
22:20 - oh yes falling onto the ground works
22:23 - like a dream
22:24 - i'm well pleased with how that looks
22:27 - colliding to the left
22:28 - is just a reflection of the down
22:30 - collision so
22:31 - add an if fixed dx is less than zero
22:35 - then change x by 32 subtract
22:38 - our mod x variable up and right are a
22:41 - little different
22:43 - look at this diagram this time we've
22:45 - collided from the right
22:46 - we are simply overlapping by the
22:48 - distance from the last grid line
22:50 - that is x mod 32 but because we are
22:54 - moving to the left
22:55 - you must negate this amount that would
22:58 - be
22:58 - zero minus x mod 32
23:01 - however it just turns out that because
23:04 - we always round our numbers down
23:06 - when we're working with tiles moving by
23:09 - this much
23:10 - would not take us fully out of the
23:12 - collision
23:13 - to do so we must subtract a tiny little
23:15 - bit more
23:17 - minus 0.01 should do so
23:20 - drag in and if fixed dy is greater than
23:24 - zero
23:30 - and then change y by minus 0.01
23:35 - subtract mod y this will move us down
23:38 - by mod y and a small amount extra
23:42 - lastly add an if fixed dx is greater
23:45 - than zero
23:51 - then change x by minus 0.01
23:54 - subtract mod x and with that we are
23:58 - seriously done launch the project again
24:01 - with the green flag and confirm that
24:03 - all the collisions are working just the
24:04 - way we intended
24:06 - and yes they are amazing job the great
24:10 - thing about tile games is
24:11 - that although the initial complexity can
24:13 - be a little off-putting
24:15 - once you have the engine in place things
24:17 - get very exciting
24:18 - very quickly i'm really excited to
24:20 - complete the basic platforming scripts
24:23 - and add some player animation and then
24:25 - see where we go from there
24:27 - what would you like to see next perhaps
24:29 - off screen enemies
24:30 - the level designer or should we go
24:31 - deeper and add drop through and sloping
24:34 - platforms
24:35 - why not drop me a comment under the
24:36 - video with this scratch engine
24:38 - the world is seriously our oyster if
24:41 - you've enjoyed this tutorial
24:42 - then please smash the like button don't
24:44 - forget to subscribe to the channel
24:46 - to avoid missing any next exciting
24:48 - videos until then
24:50 - scratch on guys

Cleaned transcript:

hello fellow scratchers and welcome back to part three of our series creating a tiled scrolling platformer in scratch and wow this is going to be a good one we are going to introduce a playable character to the game and delve into the world of tile collisions the bad news is that unlike sprite costume collisions we need to do a lot more scripting to pull it off but the great news is that not only will our scripts run faster and sprite sensing collisions but they will also work off screen and allow us to know what collided with what this is crucial for making really awesome games in scratch so stay with me and let's get scratching okay continuing from where we left off in episode two make sure we have the mario sprite selected he's not visible yet so click the show icon here to make him visible yay there he is i'll click and drag him into a free space this also ensures he's brought in front of all the other sprites in the game now gosh he's really small so set his size to 200 just here and then finally set his direction mode to left right this makes him simply flip directions when he's facing left or right that's great mario's in the game but if i run the project well he kind of looks like he's scrolling around the level but nah that's just wishful thinking he's simply sitting where we left him and doesn't know anything about scrolling levels yet to begin with let's get him controlled by the keyboard make with me a new block named reset player ticking to run without screen refresh we will put all the scripts in here that set the player's starting position and state we need to include two new variables to store our player's real position on the level make the first one named simply x now let's just hold it right there for a moment you've no idea how much i struggled with naming this variable i wanted to call it playerx but having a very specific name would not make it easy to copy scripts between sprites so we will go with a simple name x good then we'll need to make a y variable for this sprite only and set them both to 100 this will be the player's start position on the level next move the set camera x and y scripts to here replacing them with our new reset player block lastly it is a good idea to use a move camera block after setting up the player to ensure the camera is not out of bounds next create a new custom block named game loop now because a game loop is long running script we must leave the run without screen refresh unchecked you got that excellent now bring the forever loop down into the new define block and replace it with a call to this new block add a broadcast for the new event we'll name move player the order of the broadcasts is very important we want the player to move first and then we'll update the camera position before finally redrawing all the tiles this is to avoid sprites appearing to lag behind the scrolling of the level bring in a when i receive move player hat block make a new variable named speed x for this sprite only this will represent mario's current horizontal speed that is the velocity along the xaxis left and right now i want to show you a really neat trick bring in a set speed x block and set it to key right arrow pressed now run the project and see the value of speed x changing from false to true when we hold down the right arrow key okay no surprises there but look what happens when we place a minus block around the keypress block the value has changed from true false to one or zero because scratch knows we are working with numbers due to the subtract operator it has helpfully converted the true false value to a one zero value we can use this to our advantage c if we place a key left arrow pressed in the right hand side of the minus operator and test again we are able to get one for right zero for no direction and minus one for left and all this from one line of script awesome we can simply multiply this by six and we have a very quick way of changing the speed so make a new variable named speed y for this sprite only and we'll do the same for the up and down keys 6 multiplied by up key minus down key next we actually move the player introducing a change x by speed x followed by a change y by speed y bring the move camera block down from the game loop to here we want to position the camera right after we've updated the player's position on the level finally let's position the mario sprite on the screen just use a regular go to xy with our standard x minus camera x and y minus camera y great so it's testing time click the green flag and use the arrow keys to move mario we can still use the camera x and y scrollers to scroll the level but don't forget to click back on the stage after doing this otherwise the arrow keys stop working well that's funky but my hand is getting tired of operating the camera sliders let's get the camera to follow mario automatically locate the define move a camera script here at the top set camera x to x right away we can test this and see how the camera is following the player left and right nicely fenced in on the left and right by the edge of the level it would be easy to do the same for the camera y but instead let's do something a little better change camera y by y subtracted camera y all divided by four we can test this to see how the camera now tracks more smoothly up and down this is better for jumping games as it avoids any sharp up and down movements of the camera when the player is quickly jumping around try different values instead of four to track faster or slower but for us four is a very good value right we can finally hide those camera sliders from the screen yay so far so good the movement is excellent but unless we are some kind of ghoul we should really do something about walking through solid walls okay i hope you've got your wits about you because this requires some more tricky scripting to make it easier to follow we'll break the process down into four steps step one is to calculate the location of a point on the level grid step two determining the tile under that point step three handling point collisions and step four handling larger sprite collisions so here we go step one calculate the location of a point on the level grid rather than working with the mario sprite we'll open the costume editor and create a new costume and draw a small dot in the very center just here this will be easier to work with than the mario sprite for the next few tasks remember our explanation of how we use a simple number square to give a unique index to each tile in the level grid we are going to create a custom block that given a position x and y will give us back the tile at that location we'll make a new custom block get tile at x colon add a numeric input x a text label of y colon and another input of y click to run without screen refresh we'll use this block right after we update the player's y variable in the game loop pass into it the x and y of our player create a new variable named tile grid x for this sprite only now look again at this tile grid given the x and y position of the player we want to first calculate how many tiles across and up the screen the player is luckily this is easy to do we just divide the x and y position by the tile size 32 so back in the code set our tile grid x to the floor of the new input variable x divide it by 32. the floor operator is used to round numbers down to their nearest whole number we'll create another new variable tile grid y and do the same thing for the y input okay run the project and if we move the mario dot to the bottom left tile of the level we will see that tile grid x and y are both zero as i walk upwards our tile grid y variable increases by one for each tile walking to the right has a similar effect on tile grid x and we can use this to calculate the unique index of the tile in the grid list now we want the actual tile index so create a new variable naming it tile index for this sprite only now look at our number square example again the script for calculating the tile index from the grid x and y is quite straightforward the first tile starts at one then we add the grid y to get to here finally we add grid x multiplied by grid height to get us to the correct tile index so putting that into code add a set tile index to one plus grid tile y plus greater x times grid height let's run the project again and see if this works as expected we can check that the bottom left corner of the level is indeed tile index 1. moving up we'll add 1 to this number for each grid tile and moving right should add 20 assuming our grid height is still the original 20 tiles high that's working really well i'll just hide these variable reporters okay so step two determining the tile under that point since we already have the tile index getting the corresponding tile costume out of the targrid list is now super easy make a new variable named tile for this sprite only and set it to item tile index of tile grid and that's it i told you that was going to be easy let's run the project again this is really awesome if you remember our key tile costume 2 is the blank tile 9 the golden tile and 10 the wooden tile as we pass over the tiles in the level we see that we are now picking up the correct costume number from the grid list just as we intended perfect ok so step three handling point collisions we now have a way to detect what tile we are touching using our get tile at costume block it's not a great stretch then to now be able to look for collisions and try to prevent them we'll start by doing it the easy way bring in a new if tile is greater than 2 remember tile 2 is the blank one so this collision will be true for any nonblank tile if this is the case then we have collided and we change the player's y value back to where it came from that is negative speed y let's do the same for the change x remembering to also add a get tile at block like this okay run the project and let's have a wander around oh yes this is looking good we have been able to prevent the player dot walking through the walls this is fun however if we now swap the player's sprite back to mario and test again we shall find that we are not quite there yet our clever collision detection is only looking for a single collision point in the center of the player's sprite it doesn't know anything about handling collisions for a sprite with a width and height so step 4 handling larger sprite collisions the left and right hand collisions are not such a problem but the head and feet need to be addressed we'll do this by defining the player's height and then testing for collisions not just at the central point but at his head and feet too make a new variable named height for this sprite only within the reset player script set height to 24. this is actually half the full height of the sprite in case you're wondering it's just easier to work with half sizes to avoid repetition of scripts create a new custom block named fix collision in direction dx colon adding a numeric input dx then a text label d y colon and another numeric input d y ensure this is running without screen refresh we'll use it in place of both of the get tile at blocks here moving one of the if conditions into the define block we just created we only pass into the fixed collision block the amount we just changed speed x or y by and this is free just have both the change x and change y scripts in here together this is a good point just to retest the scripts to ensure that they are still working as before good we now have one script handling both the horizontal and vertical collisions now you're not going to believe me but let's make yet one more custom block named fix collision at point x colon an input of x a label of y colon and an input of y and we'll swap this out for the get tile x y that we just moved we'll pass in the sprites x and y variables so that it knows where to look for collisions and then within the define block plug the x and y input parameters to the get tile block so here we are checking just the central point of mario let's duplicate the fixed point collision twice more changing the top usage to check at mario's feet by subtracting height from y and the bottom to check his head by adding height to y to keep track of whether any of these points collided we make a new variable named solid for this sprite only and set it to the blank value before we use the fixed point blocks now at the end of the define fixed point collision script we add the if block that checks whether tile is greater than 2. if a collision has occurred then we set solid to the number 10. right now this value doesn't mean much except that any number larger than 0 is some kind of solid collision i've chosen 10 to mean very solid we can now update the if under the calls to fix point to confirm whether solid has been set to a value greater than zero this indicates that one or more of the above collision checks has indeed registered a collision we can run this to see the effect ah yes this is much better much better indeed collisions at his feet work extremely well as do the ones at his head good work if you've made it this far we are not going to worry about giving mario any defined width at present as to be honest he works pretty well without it we'll revisit this later our next move in developing this project will be to give our player a more platforming feel the scripts for movement will only get more complex so let's split up the code with custom blocks for handling player keyboard input make with me a new block named handle keys dash left right run without screen refresh this block is replacing the set speed x block in our move player script let's update this script to give the player a little acceleration make a new variable named key walk for all sprites and set it to the right arrow key take away the left arrow key then we will set speed x to speed x multiplied by 0.8 this simulates friction slowing the player down add to this key walk multiplied by two this will cause the player to accelerate in this direction give this a test oh nice the left and right movement feels much more natural and fluid next we'll add in some gravity and jumping make a new block named handle keys dash jump and run without screen refresh this will replace the set speed y block firstly let's handle the jump key wrap the set speed y in an if and use the key up arrow pressed as the trigger we'll set speed y to 14 for a nice quick upwards thrust now let's handle gravity so we'll change speed y by 2 accelerating our player downwards we'll place a cap on how fast he can fall using an if speed y is less than 22 then set speed y 2 minus 22 this way his downward speed will never exceed negative 22 pixels okay time for another test now this is feeling more real perhaps a little more flappy bird than mario but that's okay we will improve things no end going forwards what is important is that his collisions work well and do they well not as well as you may have hoped introducing variable speeds of movement has revealed an issue with how we fix a collision after it has occurred firstly after a collision we need to set the player's speed back to zero find and define fix collisions in direction script and see where we resolve a collision by changing the position back by negative at dx and dy insert an if else block after that and check for dx equaling zero if this is true then we have collided by moving up or down so set speed y to zero otherwise it was a sideways collision so set speed x to zero we can test this again it should now fix some of the oddness after a collision yep we do now see the player perfectly touching the floor after each jump but it almost looks like he's bouncing back on impact did you see that this is down to a second and more complex issue due to the way we move the player back out of a solid block after a collision see how we are just moving them back by the same amount they moved in this does ensure the player will be out of the collision but it often results in them ending up quite far from the wall still we instead need to find out the smallest amount to move the player back to get them free of the collision now if we were using sprite touching level sensing blocks we would do this by moving the player a pixel at a time away from the wall until they were no longer touching it we could do a similar thing looping the fixed collision point blocks but for a tile based game it's much more efficient and dare i say fun to use a little maths first make two new variables named fix dx for this sprite only and fix d y for this sprite only at the start of the define fix collisions in direction script set these new variables to the input variables dx and dy this is so that we can make use of them later now we'll remove the change x change y from the script for the time being now scroll to the define fixed point collision script we are going to need another two variables so make a mod x for this sprite only and a mod y also for this sprite only we'll set them to the side here using the x and y input variables set mod x to x modulus 32. and mod y to y modulus 32 look at this diagram notice how this point has collided with a tile block to push this point out of the tile we need to know how far the point is from the next grid line mod to the rescue the distance from previous grid line to the point y is calculated using y mod 32 therefore to move the collision point upwards out of this block we just need to move by the remainder of the tile's height that is 32 subtract y mod 32 we can code this directly after setting mod x and mod y add an if fixed d y is less than zero this checks that the player was moving downwards then here we go change y by 32 subtract our mod y variable just as we described we've only coded this for one direction but it's a great one to test oh yes falling onto the ground works like a dream i'm well pleased with how that looks colliding to the left is just a reflection of the down collision so add an if fixed dx is less than zero then change x by 32 subtract our mod x variable up and right are a little different look at this diagram this time we've collided from the right we are simply overlapping by the distance from the last grid line that is x mod 32 but because we are moving to the left you must negate this amount that would be zero minus x mod 32 however it just turns out that because we always round our numbers down when we're working with tiles moving by this much would not take us fully out of the collision to do so we must subtract a tiny little bit more minus 0.01 should do so drag in and if fixed dy is greater than zero and then change y by minus 0.01 subtract mod y this will move us down by mod y and a small amount extra lastly add an if fixed dx is greater than zero then change x by minus 0.01 subtract mod x and with that we are seriously done launch the project again with the green flag and confirm that all the collisions are working just the way we intended and yes they are amazing job the great thing about tile games is that although the initial complexity can be a little offputting once you have the engine in place things get very exciting very quickly i'm really excited to complete the basic platforming scripts and add some player animation and then see where we go from there what would you like to see next perhaps off screen enemies the level designer or should we go deeper and add drop through and sloping platforms why not drop me a comment under the video with this scratch engine the world is seriously our oyster if you've enjoyed this tutorial then please smash the like button don't forget to subscribe to the channel to avoid missing any next exciting videos until then scratch on guys
