With timestamps:

00:00 - foreign
00:00 - [Music]
00:02 - ERS welcome back to part two of our
00:06 - online multiplayer scratch game tutorial
00:08 - today we'll be pushing past scratch's
00:10 - Cloud available limits looking at how to
00:12 - smooth out our Cloud player's motion
00:14 - beginning to add the exciting online
00:16 - code ready to handle that large influx
00:19 - of players waiting to join your game now
00:21 - you know once this series is done we'll
00:23 - have to organize some official dates and
00:25 - times so that we can jump on scratch
00:26 - together to play through the best of
00:28 - your shared online projects that will be
00:31 - fun but where were we ah yes before we
00:34 - begin coding let's take a look at why
00:36 - our player movement isn't yet smooth and
00:38 - what can be done about it if you
00:40 - remember from episode 1 our player moves
00:43 - enough forever loop at 30 frames per
00:44 - second nice and we diligently set our
00:48 - Cloud available one to the position
00:49 - after every move the problem is
00:52 - scratch's cloud rule number two states
00:54 - that scratch will not send Cloud
00:56 - billable updates faster than 10 each
00:59 - second therefore two out of every three
01:02 - updates are being lost in the post the
01:06 - end result is shopping movement at a
01:08 - mere 10 frames per second
01:10 - well two solutions spring to mind we
01:14 - smooth out the missing animation frames
01:16 - in code using position tweening this can
01:19 - work well for some game styles like
01:20 - Slither IO but in a platformer it leads
01:24 - to a rather unnatural floaty movement
01:26 - that doesn't follow our players
01:27 - movements exactly so instead we will use
01:30 - motion buffering this doesn't rely on
01:33 - any guesswork instead recording our
01:35 - players exact movements in a buffer hey
01:38 - scratch list then this data is packaged
01:40 - up every three to four frames and sent
01:43 - in a single Cloud variable update well
01:46 - since no position data is now lost we
01:48 - are able to play back each player's
01:50 - movements exactly as they were recorded
01:53 - Perfecto the other feature we're going
01:56 - to be working on today is extending our
01:57 - multiplayer code support player joining
02:00 - so no more of that pressing two key ah
02:02 - nice one
02:03 - so load up your projects from where we
02:06 - left off in episode one and now is a
02:08 - good time to save it as a new copy for
02:11 - this is episode 2. guys let's get
02:15 - scratching as our project grows it will
02:18 - be best for us to separate the player
02:20 - sprite from the multiplayer Sprite this
02:22 - will make it simpler and easy to
02:24 - backpack into other scratch projects so
02:26 - name our first Sprite my player
02:30 - and then duplicate it naming the copy as
02:33 - Cloud Player this will become our
02:36 - backpackable Cloud engines right but
02:38 - we'll Begin by tidying up the my player
02:41 - Sprite click back in there now
02:43 - all we want to keep is the simplest
02:45 - player position script
02:47 - so we can delete the when 2 key press
02:49 - script goodbye then read numbers custom
02:52 - block be gone
02:54 - the set encoded string and following
02:56 - blocks thank you for your service and
02:59 - lastly the right number script ah so we
03:02 - sure cut that down time to start
03:05 - building it back up
03:06 - we always begin with initialization
03:09 - scripts to set things up broadcast and
03:12 - wait
03:13 - with a new message cloud setup
03:16 - now we want to record The Player's
03:18 - motion this will now be as we just
03:20 - talked about into a scratch list name
03:23 - the new list my values to send
03:27 - leaving it for all Sprites so it can
03:29 - also be accessed by our Cloud Sprite
03:33 - and we add the current sprite's
03:35 - exposition
03:38 - and Y position
03:40 - to that list the result if we smash the
03:43 - green flag is our list get flooded with
03:46 - new X and Y positions at a rate of 30
03:48 - per second and yes it's currently
03:50 - growing out of control but once we start
03:54 - sending this data over the cloud we'll
03:56 - also be removing items on the list to
03:58 - keep it under control so broadcast
04:02 - a new message
04:04 - Cloud tick and we'll let the Cloud
04:07 - Player Sprite take on the rest of the
04:09 - work this way our main game code could
04:11 - stay in this Sprite but all the cloud
04:14 - related work gets done in the cloud
04:16 - player Sprite
04:18 - great we'll move on to the Cloud Player
04:21 - Sprite now and first things first we can
04:23 - strip out any unnecessary scripts
04:25 - deleting the green flag script and yes
04:29 - even the when to key pressed script
04:32 - that only leaves our beautiful encoding
04:35 - and decoding scripts make sure not to
04:38 - delete these but you can scroll them off
04:40 - screen to give more space to work in
04:42 - when I receive Cloud setup make sure we
04:46 - hide this Sprite as we begin with no
04:48 - visible Cloud layers
04:50 - then delete all all of my values we
04:54 - don't want any previous game movements
04:56 - being included in a new game
04:58 - we'll add more to this setup script as
05:00 - we go but for now we'll move on to the
05:03 - when I receive Cloud tick
05:05 - this will trigger 30 times a second once
05:08 - after every player movement but this
05:10 - time we only want to encode and send the
05:13 - player movements once every three or
05:16 - four broadcasts now to keep track of
05:18 - this make a new variable naming it Cloud
05:21 - tick for all Sprites and we'll change it
05:24 - by one each tick of our game
05:28 - next to prevent triggering until the
05:31 - third or fourth frame will use a mod
05:33 - block
05:34 - if Cloud tick mod some number of frames
05:37 - is greater than zero then stop this
05:41 - script
05:45 - now if we were to place a 4 in here the
05:48 - modlock would cycle the cloud tick
05:49 - around in counts of four resulting in
05:52 - this guard condition only letting our
05:54 - code below execute every fourth frame
05:58 - okay to make this extra clear I'm going
06:00 - to wrap this in a custom block name it
06:03 - send my cloud data after
06:06 - with a number input named count
06:10 - and another label to
06:12 - take one without screen refresh
06:17 - we can make use of this block here and
06:19 - fill out the number of frames to wait
06:21 - for
06:22 - frames for now
06:24 - then plug the count input into the right
06:27 - side of the modblock like so
06:30 - it would be nice to test this as indeed
06:33 - counting off four frames correctly so
06:35 - how about we delete all from my values
06:38 - only temporarily as that will help us to
06:41 - see things are working
06:42 - now smash that green flag and there we
06:46 - go our my values list is only filling as
06:49 - far as the first four pairs of X and Y
06:51 - values before it is being reset by our
06:54 - delete script ready to be refilled once
06:56 - again over the next four frames great
06:59 - test
07:00 - but rather than simply deleting these
07:02 - buffered X and Y positions our goal is
07:05 - to First encode and then send all that
07:08 - data to the other players of our game
07:10 - with a single Cloud update
07:12 - start by removing that delete all
07:16 - and instead prepare to encode our values
07:19 - by setting encoder string to the empty
07:21 - value
07:23 - we want every item in our list to be
07:25 - encoded
07:26 - so repeat for the length of the my
07:31 - values list
07:33 - then simply write out the first item
07:35 - using our beautiful custom block write
07:38 - number
07:39 - item one of my values
07:41 - two in the encoded string
07:44 - after it's written we can delete that
07:46 - first item from the list what I love
07:48 - about this trick is that any remaining
07:50 - items in the list will move up to take
07:52 - its place so we can continue looping
07:54 - around processing the first item until
07:57 - there are no more items left and every
07:59 - item has been encoded
08:01 - well hoorah all that's left to do is set
08:04 - our Cloud variable Cloud one to our
08:06 - fully encoded string
08:09 - and it must be testing time smash that
08:11 - green flag
08:13 - okay this is cooler than it looks the my
08:16 - values buffered list is filling up in
08:19 - cycle to four frames as before but this
08:21 - time when it fills we can see that cloud
08:24 - one is then set to a much longer encoded
08:27 - value that looks very promising indeed
08:30 - obviously what we'd love to see next are
08:33 - these values decoded in other browser
08:35 - windows then we can finally see that
08:38 - smooth player motion that I promised you
08:40 - in action well we are having to start
08:42 - over with our player 2 scripts so let's
08:45 - piece together what we will need to do
08:47 - we'd load the project and notice that
08:49 - the cloud available is already set to
08:51 - some value probably left over from
08:54 - another game so we just ignore it
08:56 - meanwhile in another window another
08:58 - player is already moving around and boom
09:01 - they have recorded all frames of motion
09:03 - and updated the cloud variable this
09:05 - causes the cloud variable in our first
09:07 - window to also change and this is our
09:10 - trigger point it's this change of value
09:12 - that we need look out for as it tells us
09:15 - another player is active and playing the
09:17 - game
09:18 - how do we know if a cloud available has
09:20 - changed naha we keep a record of the
09:23 - previous value of that cloud variable in
09:26 - a list
09:27 - then if any Cloud variable is different
09:29 - from our recorded values then someone
09:32 - must have changed it so scroll up to our
09:35 - setup script and oh talking of setup we
09:38 - should have initialized Cloud tick to
09:41 - zero
09:43 - right we'll make that new list Cloud
09:46 - values false Sprites
09:49 - this will record the last known values
09:51 - of all the cloud variables
09:53 - and we delete all of cloud values before
09:56 - we begin
09:57 - now we are only using one Cloud variable
09:59 - at present so add that to the cloud
10:02 - values list cloud 1.
10:04 - if we run the project we can confirm
10:06 - that it appears and as the cloud
10:08 - variable subsequently changes we can now
10:11 - tell in Code by comparing these values
10:14 - ah except there is one slight
10:17 - complication when it comes to scratch
10:19 - and comparing very long numbers
10:22 - here is a script I prepared earlier I'm
10:25 - setting Val to a number that is 250
10:28 - digits long just shy of the 256 digit
10:31 - Cloud length limit
10:33 - tell me does Val equal Val in this case
10:36 - well I should hope so too and as you
10:40 - might expect it doesn't equal this other
10:42 - random number
10:44 - but and this is where it gets a bit
10:46 - weird does Val equal itself plus one
10:50 - well of course not except apparently it
10:54 - does her to understand why you'd have to
10:58 - know that when scratch Compares values
11:00 - it assumes you are doing a numeric
11:02 - comparison on two numbers oh which we
11:05 - are and so scratch tries to do the math
11:08 - but these numbers are so big that in
11:11 - doing so it loses some of the Precision
11:14 - and the result is that the two numbers
11:16 - appear the same the only safe work
11:20 - around is to force scratch to compare
11:22 - the values as text strings instead by
11:25 - cunningly joining a letter onto the
11:27 - start
11:28 - these are no longer pure numbers so
11:31 - scratch treats them as text values and a
11:34 - comparison is all good
11:36 - so let's do that and join the letter c
11:39 - with the cloud one variable
11:41 - as we begin using more Cloud variables
11:43 - we'll have to come back and add them to
11:45 - this list too
11:47 - okay so we know another player has sent
11:51 - this message but how do we know which
11:53 - player it was gosh it could even have
11:56 - been US changing it right
11:59 - a valid option would be to encode each
12:01 - player's username in with the rest of
12:04 - their cloud value but remember how we
12:07 - are testing our game multiple windows
12:09 - with the same user logged into each note
12:12 - we need a unique identifier for each
12:15 - scratch window even when the username is
12:18 - the same
12:19 - not a problem make a new available named
12:22 - My Player uid for Sprites this will hold
12:25 - the player's unique ID
12:28 - then at setup set my player uid
12:32 - to a pick random lock
12:35 - with a random number between one and
12:38 - nine million 999
12:42 - 999 that should be large enough to make
12:45 - it practically impossible for two
12:47 - players to be assigned the same number
12:49 - every time we run the project we get a
12:51 - brand new ID brilliant we just need to
12:54 - tag this on to the start of every cloud
12:56 - methods that we send down in the send my
12:59 - cloud data script pop in a right number
13:02 - block immediately after the encoded
13:04 - string is first cleared and pop in the
13:07 - my player uid variable
13:10 - sweet now we can begin to watch for
13:13 - changes to our Cloud variables
13:16 - scroll up to the when I received Cloud
13:18 - tick script and we'll add in a new
13:21 - custom block
13:22 - process Cloud item with a number input
13:26 - which
13:28 - then another label value
13:31 - and a second number input new value
13:35 - remembering to take the run without
13:37 - screen refresh block
13:39 - okay so we'll use it before we try to
13:43 - send our own cloud data that way we can
13:46 - check for changes before we overwrite
13:48 - the cloud value with our own player data
13:51 - we'll start with the only Cloud variable
13:53 - we are using Cloud variable number one
13:55 - and pass in its current value but
13:58 - remembering to also join it with the
14:00 - letter c so it can be accurately
14:03 - compared
14:04 - cool and we'll do that now
14:07 - if the new value of the cloud variable
14:11 - is still equal to
14:13 - the last recorded value which is stored
14:16 - in item which of cloud values that will
14:20 - be item one then if they are the same
14:23 - then we can ignore it this is not a new
14:25 - Cloud communication so stop this script
14:28 - but if it was changed well then that's
14:32 - more exciting I wonder who changed it
14:35 - but don't jump the gun if the cloud
14:37 - value has changed we should update the
14:40 - cloud values list so it too has the
14:42 - latest value replace which of cloud
14:45 - values
14:46 - with the new value
14:49 - we can see this in action by running a
14:51 - project and now the cloud values list is
14:54 - also being updated as the cloud variable
14:57 - changes cool so the cloud variable has
15:00 - been updated and we want to know who
15:03 - updated it let's decode it and find out
15:07 - set encoded string
15:09 - to the new value of the cloud variable
15:13 - and then set encoded index
15:16 - ah not the first letter of the encoded
15:19 - string this time but the second do you
15:23 - know why because we have to skip the
15:26 - first letter C of course therefore we
15:29 - start on the second letter
15:31 - Val equals read number from encoded
15:34 - string this will pull out the first
15:36 - encoded value and that will now be the
15:39 - sending players unique ID yes that's
15:43 - exactly what we wanted
15:45 - now there are two cases where we might
15:47 - want to ignore a new communication
15:50 - if Val happens to be less than one then
15:52 - this is not a valid ID and something has
15:55 - gone terribly wrong
15:57 - but otherwise this is the second case if
16:00 - uid is equal to my player uid yes we
16:04 - also will be detecting our own cloud
16:07 - messages since we share these Cloud
16:09 - variables so in both of these cases we
16:12 - stop this script otherwise we'll end up
16:15 - seeing another copy of ourselves walking
16:17 - around the game funky but not what we
16:20 - want here
16:22 - it would be nice to give this a test at
16:24 - this point so to allow us to see another
16:26 - player's uid make a new variable naming
16:29 - it player hash for this Sprite only
16:35 - and just for the time being set player
16:38 - hash to the Val the other players uid
16:43 - before we test go back to the setup
16:46 - script
16:48 - and set player hash to that empty value
16:52 - right do you remember how to test the
16:54 - Project's side by side we have to make
16:57 - sure the project is saved and then load
16:59 - up two browser windows for the same
17:01 - project
17:03 - and run them both
17:06 - what you should find is that the left
17:08 - Windows Mario player uid my unique
17:11 - player ID is now showing up in the right
17:14 - window under the player hash variable
17:17 - and vice versa for the right hand window
17:22 - well this is excellent this shows that
17:25 - each player is able to send their unique
17:27 - ID across the web and the other projects
17:29 - are able to decode and display it
17:31 - ignoring their own cloud updates yes
17:34 - they are both aware of each other's
17:36 - presence
17:38 - the next step is to be able to identify
17:40 - if this is an existing or a new Cloud
17:44 - Player in other words have we seen this
17:46 - player uid before
17:48 - to keep track of players we'll have a
17:51 - new list named player uids as we decode
17:54 - a cloud message if this contains a uid
17:56 - we've not seen before this is a new
17:59 - player and we add them to the list
18:01 - not only that but we also introduce a
18:05 - second paired list player data in which
18:08 - we stuff the full Cloud message
18:10 - this ties the player uid to their latest
18:13 - posted data ready for processing later
18:16 - on and the technical name for this
18:18 - pairing is a data dictionary
18:20 - if on the other hand the decoded uid
18:22 - does exist in the list of players and
18:25 - all we need to do is update the player's
18:27 - data with the up-to-date Cloud message
18:29 - for that player job done shall we code
18:33 - that
18:35 - make that new list
18:38 - player uids
18:40 - and leave it for all Sprites
18:43 - then to check if we've seen the uid
18:45 - before we will use the not item one of
18:48 - list no but the very funky item hash of
18:52 - list block
18:54 - and the available vowel contains the
18:56 - player's uid that we just decoded
18:59 - ah a result of xero indicates that the
19:02 - uid isn't yet in the list
19:05 - indeed it starts empty talking of which
19:08 - we should ensure it does start empty by
19:11 - scrolling up to the setup script and
19:13 - deleting all of the player uids list
19:16 - okay so now we can use that player hash
19:19 - variable correctly and that is to set
19:22 - player hash to the value given by the
19:25 - item hashing list
19:27 - so like I said if this player hash is
19:30 - equal to zero then this is a new player
19:32 - we haven't seen before we add them to
19:35 - the list
19:39 - add Val to player uids
19:42 - and now we need our second list make a
19:45 - new one naming it player data
19:48 - also for all Sprites
19:51 - whenever we add to the player uid list
19:53 - we also add to the player data list to
19:56 - ensure that they have the same number of
19:58 - values we add the full cloud data value
20:02 - from the new value input variable
20:06 - now to handle existing players player
20:08 - hash will be set to the item number of
20:11 - the matching player's uid so we just
20:14 - need to replace the actual cloud data
20:16 - over here replace item of player data
20:19 - again popping in the new value cloud
20:21 - data and it's for item number
20:24 - player hash
20:26 - but hmm when we have a new player we are
20:29 - setting the player data to the same
20:31 - value twice here and here we can
20:34 - simplify that initially let's set it to
20:37 - blank instead and then ensure we set
20:40 - player hash
20:42 - to reference the last item in the list
20:44 - that's the length of player data the row
20:48 - we just added
20:49 - now the replace below handles both new
20:51 - and existing player data updates cool
20:55 - a final cleanup set player hash to an
20:59 - empty value at the end of this script
21:02 - this will be important going forward and
21:04 - I'll explain more on that later so just
21:07 - before we test make sure to reset the
21:10 - player data list in the setup script
21:13 - delete all of player data
21:17 - and it's testing time I'd recommend
21:19 - making the data list larger so that we
21:22 - can see the full content and then save
21:24 - the project and bring up two windows
21:27 - side by side
21:28 - don't forget to reload that right hand
21:30 - project if you kept it open from last
21:32 - time okay what do we see
21:36 - each player's unique ID has been shared
21:38 - with the opposite window and added as a
21:41 - single new player to the uid list as we
21:44 - move our Mouse around their cloud data
21:46 - is finding its way into the player data
21:48 - list too
21:49 - if I bring my mouse over to control the
21:51 - second window we see the player data now
21:53 - being updated in the left window Instead
21:56 - This is excellent and shows these
21:58 - scripts are coded correctly of course if
22:01 - you are curious like me then you might
22:04 - be tempted to see what happens when a
22:06 - third player joins the game just open a
22:09 - third browser window and then I'll stop
22:11 - all three and click the green flags
22:13 - wallet at a time
22:15 - there did you see that every player is
22:18 - aware that there are two other players
22:20 - communicating with them now as I move
22:22 - over each window the other two correctly
22:25 - identify which player is communicating
22:26 - and updates their players player data
22:29 - the crazy thing is this will work to
22:32 - scale way up to tracking over 100
22:34 - players believe it or not but man don't
22:38 - try to open 100 windows on your own PC
22:41 - even running two or three Windows puts a
22:44 - lot more pressure on your PC than just a
22:47 - single player alone and it might result
22:49 - in your game running just a little bit
22:50 - slower something to bear in mind while
22:53 - you're testing now then it's quite
22:55 - exciting seeing these data values flying
22:58 - around but not half as exciting as it
23:01 - will be to see the players actually
23:02 - moving around on our screens yeah but
23:06 - I'm sorry to say that will have to wait
23:08 - until our next exciting episode where we
23:12 - will be implementing the Cloud Player
23:13 - clones and handling their buffered move
23:16 - that's when all our hard work will
23:18 - finally come together
23:20 - well I do hope you're enjoying a series
23:23 - and if you are then please do smash the
23:25 - like button and don't forget to
23:27 - subscribe and click the Bell icon so as
23:29 - not to miss the next video the moment it
23:32 - drops we can have so much fun I'm
23:34 - telling you let me know in the comments
23:36 - how you're getting on and what you're
23:38 - going to use is multiplayer engine 4.
23:40 - and I'll see you next time thanks for
23:42 - watching have a great week ahead and
23:45 - scratch on guys
23:47 - [Music]
23:52 - thank you

Cleaned transcript:

foreign ERS welcome back to part two of our online multiplayer scratch game tutorial today we'll be pushing past scratch's Cloud available limits looking at how to smooth out our Cloud player's motion beginning to add the exciting online code ready to handle that large influx of players waiting to join your game now you know once this series is done we'll have to organize some official dates and times so that we can jump on scratch together to play through the best of your shared online projects that will be fun but where were we ah yes before we begin coding let's take a look at why our player movement isn't yet smooth and what can be done about it if you remember from episode 1 our player moves enough forever loop at 30 frames per second nice and we diligently set our Cloud available one to the position after every move the problem is scratch's cloud rule number two states that scratch will not send Cloud billable updates faster than 10 each second therefore two out of every three updates are being lost in the post the end result is shopping movement at a mere 10 frames per second well two solutions spring to mind we smooth out the missing animation frames in code using position tweening this can work well for some game styles like Slither IO but in a platformer it leads to a rather unnatural floaty movement that doesn't follow our players movements exactly so instead we will use motion buffering this doesn't rely on any guesswork instead recording our players exact movements in a buffer hey scratch list then this data is packaged up every three to four frames and sent in a single Cloud variable update well since no position data is now lost we are able to play back each player's movements exactly as they were recorded Perfecto the other feature we're going to be working on today is extending our multiplayer code support player joining so no more of that pressing two key ah nice one so load up your projects from where we left off in episode one and now is a good time to save it as a new copy for this is episode 2. guys let's get scratching as our project grows it will be best for us to separate the player sprite from the multiplayer Sprite this will make it simpler and easy to backpack into other scratch projects so name our first Sprite my player and then duplicate it naming the copy as Cloud Player this will become our backpackable Cloud engines right but we'll Begin by tidying up the my player Sprite click back in there now all we want to keep is the simplest player position script so we can delete the when 2 key press script goodbye then read numbers custom block be gone the set encoded string and following blocks thank you for your service and lastly the right number script ah so we sure cut that down time to start building it back up we always begin with initialization scripts to set things up broadcast and wait with a new message cloud setup now we want to record The Player's motion this will now be as we just talked about into a scratch list name the new list my values to send leaving it for all Sprites so it can also be accessed by our Cloud Sprite and we add the current sprite's exposition and Y position to that list the result if we smash the green flag is our list get flooded with new X and Y positions at a rate of 30 per second and yes it's currently growing out of control but once we start sending this data over the cloud we'll also be removing items on the list to keep it under control so broadcast a new message Cloud tick and we'll let the Cloud Player Sprite take on the rest of the work this way our main game code could stay in this Sprite but all the cloud related work gets done in the cloud player Sprite great we'll move on to the Cloud Player Sprite now and first things first we can strip out any unnecessary scripts deleting the green flag script and yes even the when to key pressed script that only leaves our beautiful encoding and decoding scripts make sure not to delete these but you can scroll them off screen to give more space to work in when I receive Cloud setup make sure we hide this Sprite as we begin with no visible Cloud layers then delete all all of my values we don't want any previous game movements being included in a new game we'll add more to this setup script as we go but for now we'll move on to the when I receive Cloud tick this will trigger 30 times a second once after every player movement but this time we only want to encode and send the player movements once every three or four broadcasts now to keep track of this make a new variable naming it Cloud tick for all Sprites and we'll change it by one each tick of our game next to prevent triggering until the third or fourth frame will use a mod block if Cloud tick mod some number of frames is greater than zero then stop this script now if we were to place a 4 in here the modlock would cycle the cloud tick around in counts of four resulting in this guard condition only letting our code below execute every fourth frame okay to make this extra clear I'm going to wrap this in a custom block name it send my cloud data after with a number input named count and another label to take one without screen refresh we can make use of this block here and fill out the number of frames to wait for frames for now then plug the count input into the right side of the modblock like so it would be nice to test this as indeed counting off four frames correctly so how about we delete all from my values only temporarily as that will help us to see things are working now smash that green flag and there we go our my values list is only filling as far as the first four pairs of X and Y values before it is being reset by our delete script ready to be refilled once again over the next four frames great test but rather than simply deleting these buffered X and Y positions our goal is to First encode and then send all that data to the other players of our game with a single Cloud update start by removing that delete all and instead prepare to encode our values by setting encoder string to the empty value we want every item in our list to be encoded so repeat for the length of the my values list then simply write out the first item using our beautiful custom block write number item one of my values two in the encoded string after it's written we can delete that first item from the list what I love about this trick is that any remaining items in the list will move up to take its place so we can continue looping around processing the first item until there are no more items left and every item has been encoded well hoorah all that's left to do is set our Cloud variable Cloud one to our fully encoded string and it must be testing time smash that green flag okay this is cooler than it looks the my values buffered list is filling up in cycle to four frames as before but this time when it fills we can see that cloud one is then set to a much longer encoded value that looks very promising indeed obviously what we'd love to see next are these values decoded in other browser windows then we can finally see that smooth player motion that I promised you in action well we are having to start over with our player 2 scripts so let's piece together what we will need to do we'd load the project and notice that the cloud available is already set to some value probably left over from another game so we just ignore it meanwhile in another window another player is already moving around and boom they have recorded all frames of motion and updated the cloud variable this causes the cloud variable in our first window to also change and this is our trigger point it's this change of value that we need look out for as it tells us another player is active and playing the game how do we know if a cloud available has changed naha we keep a record of the previous value of that cloud variable in a list then if any Cloud variable is different from our recorded values then someone must have changed it so scroll up to our setup script and oh talking of setup we should have initialized Cloud tick to zero right we'll make that new list Cloud values false Sprites this will record the last known values of all the cloud variables and we delete all of cloud values before we begin now we are only using one Cloud variable at present so add that to the cloud values list cloud 1. if we run the project we can confirm that it appears and as the cloud variable subsequently changes we can now tell in Code by comparing these values ah except there is one slight complication when it comes to scratch and comparing very long numbers here is a script I prepared earlier I'm setting Val to a number that is 250 digits long just shy of the 256 digit Cloud length limit tell me does Val equal Val in this case well I should hope so too and as you might expect it doesn't equal this other random number but and this is where it gets a bit weird does Val equal itself plus one well of course not except apparently it does her to understand why you'd have to know that when scratch Compares values it assumes you are doing a numeric comparison on two numbers oh which we are and so scratch tries to do the math but these numbers are so big that in doing so it loses some of the Precision and the result is that the two numbers appear the same the only safe work around is to force scratch to compare the values as text strings instead by cunningly joining a letter onto the start these are no longer pure numbers so scratch treats them as text values and a comparison is all good so let's do that and join the letter c with the cloud one variable as we begin using more Cloud variables we'll have to come back and add them to this list too okay so we know another player has sent this message but how do we know which player it was gosh it could even have been US changing it right a valid option would be to encode each player's username in with the rest of their cloud value but remember how we are testing our game multiple windows with the same user logged into each note we need a unique identifier for each scratch window even when the username is the same not a problem make a new available named My Player uid for Sprites this will hold the player's unique ID then at setup set my player uid to a pick random lock with a random number between one and nine million 999 999 that should be large enough to make it practically impossible for two players to be assigned the same number every time we run the project we get a brand new ID brilliant we just need to tag this on to the start of every cloud methods that we send down in the send my cloud data script pop in a right number block immediately after the encoded string is first cleared and pop in the my player uid variable sweet now we can begin to watch for changes to our Cloud variables scroll up to the when I received Cloud tick script and we'll add in a new custom block process Cloud item with a number input which then another label value and a second number input new value remembering to take the run without screen refresh block okay so we'll use it before we try to send our own cloud data that way we can check for changes before we overwrite the cloud value with our own player data we'll start with the only Cloud variable we are using Cloud variable number one and pass in its current value but remembering to also join it with the letter c so it can be accurately compared cool and we'll do that now if the new value of the cloud variable is still equal to the last recorded value which is stored in item which of cloud values that will be item one then if they are the same then we can ignore it this is not a new Cloud communication so stop this script but if it was changed well then that's more exciting I wonder who changed it but don't jump the gun if the cloud value has changed we should update the cloud values list so it too has the latest value replace which of cloud values with the new value we can see this in action by running a project and now the cloud values list is also being updated as the cloud variable changes cool so the cloud variable has been updated and we want to know who updated it let's decode it and find out set encoded string to the new value of the cloud variable and then set encoded index ah not the first letter of the encoded string this time but the second do you know why because we have to skip the first letter C of course therefore we start on the second letter Val equals read number from encoded string this will pull out the first encoded value and that will now be the sending players unique ID yes that's exactly what we wanted now there are two cases where we might want to ignore a new communication if Val happens to be less than one then this is not a valid ID and something has gone terribly wrong but otherwise this is the second case if uid is equal to my player uid yes we also will be detecting our own cloud messages since we share these Cloud variables so in both of these cases we stop this script otherwise we'll end up seeing another copy of ourselves walking around the game funky but not what we want here it would be nice to give this a test at this point so to allow us to see another player's uid make a new variable naming it player hash for this Sprite only and just for the time being set player hash to the Val the other players uid before we test go back to the setup script and set player hash to that empty value right do you remember how to test the Project's side by side we have to make sure the project is saved and then load up two browser windows for the same project and run them both what you should find is that the left Windows Mario player uid my unique player ID is now showing up in the right window under the player hash variable and vice versa for the right hand window well this is excellent this shows that each player is able to send their unique ID across the web and the other projects are able to decode and display it ignoring their own cloud updates yes they are both aware of each other's presence the next step is to be able to identify if this is an existing or a new Cloud Player in other words have we seen this player uid before to keep track of players we'll have a new list named player uids as we decode a cloud message if this contains a uid we've not seen before this is a new player and we add them to the list not only that but we also introduce a second paired list player data in which we stuff the full Cloud message this ties the player uid to their latest posted data ready for processing later on and the technical name for this pairing is a data dictionary if on the other hand the decoded uid does exist in the list of players and all we need to do is update the player's data with the uptodate Cloud message for that player job done shall we code that make that new list player uids and leave it for all Sprites then to check if we've seen the uid before we will use the not item one of list no but the very funky item hash of list block and the available vowel contains the player's uid that we just decoded ah a result of xero indicates that the uid isn't yet in the list indeed it starts empty talking of which we should ensure it does start empty by scrolling up to the setup script and deleting all of the player uids list okay so now we can use that player hash variable correctly and that is to set player hash to the value given by the item hashing list so like I said if this player hash is equal to zero then this is a new player we haven't seen before we add them to the list add Val to player uids and now we need our second list make a new one naming it player data also for all Sprites whenever we add to the player uid list we also add to the player data list to ensure that they have the same number of values we add the full cloud data value from the new value input variable now to handle existing players player hash will be set to the item number of the matching player's uid so we just need to replace the actual cloud data over here replace item of player data again popping in the new value cloud data and it's for item number player hash but hmm when we have a new player we are setting the player data to the same value twice here and here we can simplify that initially let's set it to blank instead and then ensure we set player hash to reference the last item in the list that's the length of player data the row we just added now the replace below handles both new and existing player data updates cool a final cleanup set player hash to an empty value at the end of this script this will be important going forward and I'll explain more on that later so just before we test make sure to reset the player data list in the setup script delete all of player data and it's testing time I'd recommend making the data list larger so that we can see the full content and then save the project and bring up two windows side by side don't forget to reload that right hand project if you kept it open from last time okay what do we see each player's unique ID has been shared with the opposite window and added as a single new player to the uid list as we move our Mouse around their cloud data is finding its way into the player data list too if I bring my mouse over to control the second window we see the player data now being updated in the left window Instead This is excellent and shows these scripts are coded correctly of course if you are curious like me then you might be tempted to see what happens when a third player joins the game just open a third browser window and then I'll stop all three and click the green flags wallet at a time there did you see that every player is aware that there are two other players communicating with them now as I move over each window the other two correctly identify which player is communicating and updates their players player data the crazy thing is this will work to scale way up to tracking over 100 players believe it or not but man don't try to open 100 windows on your own PC even running two or three Windows puts a lot more pressure on your PC than just a single player alone and it might result in your game running just a little bit slower something to bear in mind while you're testing now then it's quite exciting seeing these data values flying around but not half as exciting as it will be to see the players actually moving around on our screens yeah but I'm sorry to say that will have to wait until our next exciting episode where we will be implementing the Cloud Player clones and handling their buffered move that's when all our hard work will finally come together well I do hope you're enjoying a series and if you are then please do smash the like button and don't forget to subscribe and click the Bell icon so as not to miss the next video the moment it drops we can have so much fun I'm telling you let me know in the comments how you're getting on and what you're going to use is multiplayer engine 4. and I'll see you next time thanks for watching have a great week ahead and scratch on guys thank you
