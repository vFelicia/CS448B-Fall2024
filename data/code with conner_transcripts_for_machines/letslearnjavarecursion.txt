hello humans all right here we are in code with conor we're going to be looking at uh ap computer science stuff java stuff we're looking at recursion today so we're gonna do a little mini lesson on recursion and talk a bit about what it is and how it works let's jump into some code and start there okay so here i am in my class let's just go over briefly what i have i've got a my program file my program.java which has a main method then i have a nonpublic class inside that same file you can do multiclasses in the same file you just can't have multiple public classes in the same file which is fine again if you want to have a separate file do that so this just can be my main where i'm going to make objects and stuff in my recursor class we're going to talk about this function here we're done with this method here the factorial now we already know how to do a factorial okay so 5 factorial is 5 times 4 times 3 times 2 times 1. it stops at 1 because if we times by 0 then the whole thing's zero so obviously we don't want to do that so the idea here is using recursion in order to do that so what is recursion well i'll show you just right here inside of our factorial method you can see that there is a call to the factorial method this is creating what's called like a recursive stack or a recursive set of calls when you are calling the function from within the function essentially what happens is the first call can't end until all the nested calls have ended kind of imagine a set of like russian nesting dolls right if you were to take them all apart and you keep taking the tops off you can't put the thing back together again unless you close each of the inner pieces of it and then finally at the end you put the outer top back on it's the same idea as soon as you open that recursive box by doing a function call from within itself you have to let all of those inner function calls resolve themselves before your kind of outer function ends up being able to end okay so this means every time we do recursive functions we have to make sure that there's what's called a base case which means there has to be a way for the function to fully execute without calling itself if that doesn't exist there's no way for the function to end without calling itself then you'll end up in an infinite recursive loop because if not you'll end up in a recursive infinite loop which you don't want okay so let's look and find our base case in this factorial method so we have if n is not equal to zero return n so our current value multiplied by the factorial of n minus one else so in this case look at our precondition our precondition said that n has to be greater than or equal to zero coming into the function so if n is not equal to zero then it's anything above zero else should really just be the condition of if n is zero so else return one and you'll notice this line of code can execute without ever triggering another call to the factorial func method and because of that it's our base case so when n equals zero we are going to return a value of one okay that's going to be our base case got it so let's code trace this a little bit so we can see what's going on don't mind my handwriting it's terrible so let's say we wanted to do four factorial okay so we're gonna pass four to the first call of factory so four is going to come in here for n so n is not equal to zero so we're not running the else we're running the if n its value is four so you can see that there and it's gonna do four times by but then it's gonna start a new call and it's gonna pass a three and we're back calling the function again okay so now this is a three which means n is not zero so this is a three this is not happening now we're going to call it again on two scroll down now we're calling it again with two and is not zero so this is two this is not happening we're going to call it again with one okay come down here this is now one okay which means n is not zero so this is now one and we're going to call it again this time with zero zero is going to come into the function n is not equal to zero that's not true anymore so that's not happening so we are going to run the else which means we're going to return one now we need to trace backwards on the returns where does this one go this one is gonna track up here and all of this is gonna get replaced with a one so now it's gonna do one times one and then that's gonna get returned so it's gonna return one times one which is one and that's going to come here and replace this whole method call that's a one now it's ready to turn this one so it'll do two times one and it'll return that two value so this whole factorial is gone replaced with two three times two is going to return six so this whole factorial is gone replaced with six four times six is going to get returned and we're out this whole thing is 24. so this is the idea of that recursive stack okay some people like to think of it um kind of like nested like square bracket style i'll show you that as well so when we call factorial four it does four times by fact three fact three goes again which is three times fact two okay which runs its code which gives it two times fact one fact one which runs its code and does one times fact zero fact zero returns one then this returns one this returns two which returns six which returns 24. so there's a couple of different ways to visualize that nested idea but the idea with recursion is you have to have that base case okay without the base case infinite recursion happens bad things happen you also have to make sure that you can reach your base case so if we had just called factorial n within our function within our method then the value had never been going down which means it never would have reached our base case or if we had called it on a negative end to start it would have just kept going down forever never would have reached the base case so it's both having a base case but then also ensuring that our code allows the base case to be reached all right that's it for the tg bit let's jump over and just kind of look at some code examples of recursion so we've already looked at our factorial example okay so if i run my code and show you what it looks like there it is i know it's small i'm sorry i can't make it bigger on code hs 4 factorial is 24. cool so that works so couple other functions that work well with recursion i'll show you one is a sum function so you can see it here in my code so precondition is k is greater than or equal to zero so it takes one integer okay it doesn't need to be static here ditch that so if k is greater than zero then it returns k plus a recursive call to sum with k minus 1. very similar we saw with factorials but with a plus and then else which would mean k would be equal to zero we return zero now the reason we couldn't return zero in the last one is because it was multiplicative if we returned to zero the whole thing would be zero so we needed our base case to return one right so this is almost identical code with summing so let's consider that for an example here so let's do int n equals 10. okay so i have indent is 10 result is now mr.sum of n print out the sum of all integers up to n equals and then the result so let's run this and see how it works the sum of all this up to 10 is 55 10 19 27 34 40 45 49 52 54 55 and works okay so that was one example the other one was a sum that takes two parameters so this one takes a start and an end value so we obviously want the n to be bigger than the start and we need them both to be positive so we need star to be greater than equal to zero and n to be greater than zero and the idea is it sums all the integer values between the two so if end is greater than start then we still have some room to go so then return our end value plus the sum of our start and n minus one so taking in one so essentially if we did like from two to five it's going to start at the 5 value it's going to hang on to that then it's going to call it again from 2 to 4. it's going to hang on to the the answer to the 4 and then call it again from 2 to 3. hang on to the 3 call it again on 22 get a base case then back up to the two to five okay so call with the end stuck in our current function the sum start to n minus one and then else so once end and start are equal we just return that n value so whatever that final value is which will now be equal to start as well so we can see like if i called it on two five it would start here with five is greater than two keep the five call it again from two to four okay keep the four call it again from two to three keep the three call it again from two to two two to two is going to return two and then it's gonna be two plus three and then it's gonna be that answer plus four and then that answer plus five and then we're going to get our result okay so we can do this thing again let's do uh n1 is two and n2 is five okay i got this all typed out m1 is two n2 is five call it on the double variable okay this is overloaded and then n1 to n2 is a result and there we go sum of all integers from two to five is fourteen okay two to five two from three so let's go the other way because that's where the code goes five plus four okay actually the code does go the other way so we go two and three is five and then another four is nine and then five is fourteen hey it's working okay just a couple of examples of that recursive piece there and i'll share a snippet of this code in the description of the video so you can go check it out if you wanna kind of explore it and play with it a little bit but that's the idea of recursion and i realized that one of my print lines was cut off in the video but you know what you got to be able to concatenate strings on your own if you're doing a lesson on recursion and you're stressed out about how i printed variables with strings together you might want to go back and learn that no offense don't you okay so i'll share that code so you can have a look at a little bit more but this is the idea of recursion just use recursion with intent use it you know in a way that's going to help you always remember the base case and always make sure that your code is way to reach the base case that's super important all right thanks for watching see you soon bye humans