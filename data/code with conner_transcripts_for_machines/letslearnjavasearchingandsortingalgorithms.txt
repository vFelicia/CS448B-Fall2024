hello humans welcome back to co with connor glad you're here we are covering some more advanced java topics here that are part of the ap computer science a curriculum specifically we're going to be looking at searching and sorting algorithms now we're cherrypicking a bit here from the nonrecursive which is part of the arraylist kind of section of the course and the recursive which is part of the last unit in the course we're just going to look at them all together because i think it fits well to kind of analyze them together so we're going to look at a few things we're going to look at a sequential or linear search as well as a binary search and then we're going to look at some sorting algorithms so we'll look at a selection sort we'll look at an insertion sort and finally we'll look at a merge sort now my focus with this is not on code as much as it's on theory and this really just correlates to kind of the college board views on this which is that you need to be able to code trace these concepts and understand and read code for these searching and sorting algorithms you don't necessarily need to be able to code your own versions of them from scratch okay so particularly things like merge sort which get fairly advanced from a coding perspective with the recursive writing we'll kind of code trace a little bit but we're not going to go too heavy into writing the code now that being said i'm going to put some links in the description for some sites that break down the code okay and i'm actually pulling my code from geeksforgeeks so props to them for the great website and i will put that in the description so you can go and have a look at the code in more detail if you want to do that all right let's jump right in and talk about searching all right so we're gonna have a look at some searching algorithms we're gonna start with the sequential or linear which is kind of your straightforward you know left to right searching for something in a list or in a data structure all right so you can imagine not super efficient now that i say that let's just talk briefly we are not going to be talking efficiency in this kind of lesson if we wanted to window efficiency that's a whole other thing okay so we're not going to touch it i know you're going to get cranky of me if you're a higher level person and you know about this stuff you aren't sure about efficiency well it's a choice we're not doing that today sorry okay moving on i've got a list of numbers here i'm going to say i'm going to look for the 679 so i'm just going to do a really quick linear search of this okay so here we go and you see it's just tracing left to right it's going one index iterate the index check the value iterate the index check the value and so on and it's just checking are they equal to 679 that's it so you can see with a sequential or a linear search like this there's no prerequisite the list has to already be sorted because we're just going to scan the whole list from left to right until we find the value so that is a benefit of a linear or sequential is that it doesn't rely on the list being sorted you can see when it reached index 20 the value 679 was equal to the value in question so it stopped didn't finish it doesn't need to go the whole list it can have a stopping point but there's no requirement the list is in order when we're doing a linear or a sequential search let's hop over and look quickly at the code for a linear search so here's my code for linear search i'm taking an array okay and i'm taking a value and i'm going to search that array for that value all right if i don't find it i'm going to return negative 1. that's a very common practice anytime we're searching for an index of something in a data structure because negative one does not refer to an index so i start by finding the length of the array and is the array.length and then i do my for loop from zero to n iterating by one if the array value is equal to the value that was passed to my method then return the index in question if i make it all the way to the end of this loop and that if statement was never triggered it means it did not find the value therefore return negative one okay so that's what we're looking at with a linear search super straightforward just scan the array from left to right all right we're going to move on and talk binary search okay so this time we're going to look for that same number that's 679 using a binary search the way the binary search works is it's going to start at the beginning and the end index of our data structure then it's going to calculate the middle index okay and it's going to check if that middle index is the value we want and if it's not it's going to shrink the list either the first half or the second half and then continue the process so let's trace through it so we can understand it a bit better so i'm going to search that 679 you'll see that it set my low value to zero and it set my high value to 31. those are the indices okay now it's going to calculate my mid so let's step forward so my mid has been calculated to be 15. so again 31 minus 0 divided by 2 and then casa as an integer we're looking at 50. all right cool so it's going to check the value that 456. is that equal to my number no it's not but not just is it equal is it less than or is it greater than that value so because our number is bigger than 456 and it can't possibly come before because remember we are working with an ordered list so back when we did our first one you know when we did uh back when we did sequential or linear listed need to be an order didn't matter but when we do a binary there's a precondition here and the list must already be in order from smallest to greatest okay and that allows us to work so now i know my number comes after 456. so i can actually just ignore everything that came before index 15. so here we go how are we going to do that we're going to bring our low value up to 16 because 15 is out everything from 0 to 15 is out so we're going to set our low to 15 and we're going to recalculate our mid so we recalculate our mid to 23 again 31 minus 16 divided by two cast as an integer we find our mid okay now we're going to check our mid value 696 is bigger than 679 so now i know it's not in the right hand side of this so it's got to be in the left so i'm going to bring my high value down so my high value is going to come down to index 22 recalculate my mid recalculates my mid to 19. okay i'm going to check that 678 ooh just too small so i got to move to the right got to bring my low up bring my low up to 20 okay recalculate my mid get 21 i'm going to check that value 683 it's too big so i can go back but guess what there's nowhere to go back to because there's only one value left to the lefthand side so our low comes to 20 our high comes to 20. our mid gets calculated to 20 and our value is 679 and we found the value okay if we got to this point and the value still wasn't there then we would return negative one all right because it didn't find it it tried it got close but it didn't find it all right so at some point binary search is going to narrow down to a single vowel that value may or may not be the value but it'll be like kind of through this less than greater than less than greater than less than greater than at some point it reaches a point where it's like okay it's either this or it's not here and that's what happened here in this case it was here so it would return index 20. okay let's jump over look at the code now binary search is a recursive algorithm so we are going to be calling our function from within our function makes sense okay because again we're starting big and then we kind of recall it on the smaller we recall it on the smaller we recall it on the smaller until eventually there's really nothing left okay so let's have a look so we're going to take the array we're going to take a left value a right value and we're going to take the value we're looking for so if the right is greater than or equal to the left awesome then we find the mid all right it's left plus right minus one and then divide by two all right so the average in between them awesome so we check the value so if the value at mid is equal then we're done and we return the index awesome okay if the value is bigger than x then that means we need to move to the left so we need to bring our high dam okay so we're going gonna call it again but you can see our right now our right value is no longer the actual right value we started with it's the middle minus one so we're recalling it by shifting that high value shifting that right value down okay otherwise you'll notice we're recalling on on new left so we're bringing up the left to mid plus one so that's our else so that's if it's less than okay so what are we doing we're returning a recursive call to binary search and at some point binary search has only two choices it either has to return mid as a base case because we found the value or if it's not equal to and it's not less than and it's not greater than it's going to return negative 1 right and guess when that happens look at this if statement if right is greater than equal to the left do the check well guess what's going to happen at some point if we don't find this value we're going to keep iterating this mid right minus one plus one each time we recursively call at some point we're going to cross mid over and our left and rights are gonna cross and they're gonna be backwards and then the if statement's gonna fail and in the base case it's gonna return negative one okay so our recursive function has a base case where it'll return negative one if it doesn't find it it has the second base case where it'll return the actual index if it does find it and then otherwise it's returning that recursive call okay so that's where we're gonna see that recursion eventually kind of filter its way down so if the base case returns the actual index then it just returns that returns every time it returns until the end of the recursive call returns that same index so there's our binary search now binary search required that we were sorted well that's a whole other animal we got to talk about sorting algorithms so let's jump over and look at our first one all right so we're going to start here we're going to talk about a selection sort all right selection's already going to look very familiar too so i'm going to run the visualization and then i'll kind of pause it and talk through it as we look so you can see how it's traversing the array and it's got that red on the three what it's doing is it's scanning the array looking for the lowest number so it finds two it now flags that as the minimum value it's going to keep going all the way to the end of the array when it reaches the end of the array it's going to take that lowest value and shoot it to the front mark it as orange because now we're done with it we're not going to look at it anymore so we're actually going to start scanning now from the second position from index one and again we're scanning for the minimum in the remaining array so currently it's five now it's going to be three it's going to keep scanning four is no good 19 no good it's going to get to the end and it's going to swap that three with index 1 swapped now that's locked in now we're starting at index 2 and we're going to continue the scan looking for the minimum value and we're going to continue this kind of process of going from our kind of new starting position to the end of the array looking for a min once we finish the scan we swap them in with that starting position iterate the starting position and then keep going until we've reached the end of the array with the starting position okay we're going to reach the end of the array many times it's that starting position once that has shifted to the end of the array then we know that the array is in order it's been sorted okay so i'm just going to speed this up we're going to watch it finish and now our starting has reached the end and therefore our list has been sorted and we can see that it's in order from smallest to biggest all right so we call this a selection sort okay and you can see the pseudo code above my head all right so we're going to repeat a bunch of times we're going to set that first unsorted element as our min go through the whole thing looking for if something is actually lower than it and then we'll do the swap with that first unsorted and then enter it okay let's have a look at the code for how we can do this all right so here's our selection sort code so we start by finding the length of the array awesome okay now we're gonna kind of move that boundary over so we have one loop that outer loop is gonna start at zero and it's going to go to the end and that's going to be our starting position okay are we going to start at zero but then the next time it loops we're starting at one and each time we're going to go to the answer we have a nested loop here so you can see our nested loop here so this one is starting at i plus one okay so we've set zero to be our minimum and then we're gonna loop the remaining then we're gonna set one to be our minimum we're gonna loop from two on we're gonna set two to be the minimum loop from three on okay and that's kind of holding our starting position in the i value and then our j value is our looper as we're working our way through the array okay so my minimum index is our i value and then we're going to loop through from there so we're just checking if our current value is less than the value that's at our minimum index okay then we reassign our minimum index to that new index all right and then once we finish the loop that min index should point to the smallest value in the remaining array okay and that gives us a chance to do the swap so then we do remember with a swab you have to use a temporary variable okay you can't do a direct swap you've got a store one move one and then store back so we do a temp is whatever was at the minimum index so that's our minimum and the remaining array then we overwrite that with whatever was at our starting position that's all and then we override our starting position with the value of 10. so that's a completing our swap and then i is going to iterate we've got a new starting position and we loop again all right so a little tricky you got the nested loops there you've got you know there's a little play you gotta take your time to get that code and kind of understand how it works so that's our selection sort that's the easiest of our sorts now we're gonna jump over we're gonna look at insertion sort okay so this is insertion sort so again we'll trace through we'll explain as it goes so insertion sort you can see right away kind of what's happening we're looking at the 38 deciding where it fits in the array to the left now we're going to go to the five would be okay no it's smaller than 44 shift that over smaller than 38 shift that over is it smaller than three no okay we found the spot stick it there let's go to 47. okay it's good leave it where it is 15 okay no smaller than that shift smaller than that shift smaller than 38 shift is it smaller than 5 no up we go 36 and we're going to work our way through so we are going one time through and with each value we're kind of going to the left until we find its position in order of the values that are there so the deeper we get the more swaps we might have to make working our way to the left to find the correct place for each value so 26 one more move always do the compare back to 15 okay stop place it 27 and we work our way through all right so let's watch this finish and then we'll look at the code of how this works so the two is going to have to go all the way to the left a lot of compares compare compare compare compare compare hey we're at the beginning we already know where it goes before again we're going way back until it compares with the three compare and there we go and continue till we reach the end and there we go we've got a sorted list using an insertion sort algorithm let's look at the code for how we pull this off all right so our insertion sort we're going to start by setting up the length okay we have our outer loop from 1 up to the end all right and then our j value is going to be one less than our y value okay and that that is because we're kind of pulling out that key value at i and then we want to move to the left from it so we need to store that key value and then as we shift to the left we need room to kind of move everything up so we'll go starting from one less okay and then we can shove everything up out of the way until we find a place to put the key value so our j starts at one less than i and our key is kind of the pulled out value at our position as we work our way through the array so we work our way through the array we pull key out and then using a while loop so while j is greater than or equal to zero so as we move to the left and the value at j is bigger than my key value then that means i need to move that value over and get ready to check if my key goes there okay so while i'm greater than zero and while the left value is bigger than my key okay then i'm going to move that value over bring my key down and then move that value over bring my key down and i'm going to keep while looping that until one of those two statements is false so either i reach the end of the array in which case i found my home or the value kind of j is not bigger than key which means that i've found my location for key it's at i all right so array j plus one is now equal to key and i lock that in the value of j is not not touched we just checked it okay so now i've locked my key position in i iterate i and i repeat the process over and over again again this code's a little sticky you've got to take some time type it out trace it yourself kind of play with it you know again we're not writing this code from scratch so i'm kind of burning through it a little quicker than i would otherwise hopefully that makes you know a little bit of sense all right now we're going to move on with the most complex one which is a recursive sorting it's called a merge sort and again i'm going to visualize it i'm going to go through this code pretty quick okay if you really want to dive into merge short go dive into merge sort the links will be in the description i'm not going to go too crazy with it just because it does get a little bit more complex because we're running a two method structure uh in terms of merging two arrays together which shouldn't be too hard for you you should be able to do that that part absolutely you need to be able to do and then the second piece is the recursive merge short piece which uses the merge anyways i'll get ahead of myself let's go visualize virtual okay merge sort here we go let's see if we can make any sense of this here's our whole thing start with those two elements okay cool they're in order let's go to the next two elements okay oh they're not in order let's fix them now they're in order okay now let's pull those two pairs of two elements into one array that has four elements and let's put them in order okay we've merged that okay let's repeat that process over again with the next two elements 47 and 15. we're going to put those in order okay we're going to shove those back up kind of temporary as an array let's grab the next two 26 36 we're going to put those in order okay let's merge those two arrays is to one sorted array of four so 15 okay and then the 26 okay and then the 36 and then the 47 okay now let's take our two four arrays and let's merge those into a sorted array so we're going to take the three from the red array okay and then the 15 and the five note we're going to take the five the 15 the 38 take the 15 take the 26 take 36 take the 38 take the 44 anything left over we'll take the 47 okay we're gonna run this whole shebang again on the right hand side so we're going to take the twos the two and the 27 the 4 and the 46 we're going to merge them take the 19 and the 50 take the 48 we're going to merge them and repeat the process let's watch it go 2 and 27 put it back 4 and 46 merge it sort it and put it back take those two arrays of 2 and merge them into an array of 4 in order 2 and then the 4 and then the 27 and then the 46 and then shove it back okay let's take a 19 in the 50 put them in order okay 48's alone will kind of treat it like it's a thing anyway 48 okay let's merge those three okay good and we're merged and back up and now we'll take all seven and we're gonna merge those two and then four and then 19 and then 27 46 and anything that's left over okay beautiful now let's merge our eight in our seven into our final sorted list all right so the two and the three we take the two the three and the four we take the three we take the four over the five then we take the five over the 19 and we take the 15 over the 19. 19 over 26 26 then 27. now we got 36 then we got 46. oh sorry 38 then 44 then 46 47 48 and then 50. it's all merged it's all sorted and it's done and it's complicated but it's also beautiful okay so we're kind of taking these mini arrays we're sorting them and then we're merging them together into a new sorted array and then taking other arrays merging them sorting them right it's this kind of repeated process of merging the arrays and then sorting the merged arrays all right and we're going to look at the code for how we do this again it's a little bit complex that's okay all right so there's two pieces here there's our merge method which serves the purpose of merging two arrays okay so it takes our main array it takes a left a mid and a right okay a left and mid and a right so we're going to find the sizes of the two sub arrays to be merged remember merge does some sorting this isn't just slapping two arrays together in any order so we're going to take our first which is our middle minus our left plus one and then our right minus our middle so those are going to be the two sizes of our sub arrays we'll call them the left array and the right array l and r set them up to their sizes cool now we're going to copy the data into these arrays so just raw data again we're just going to take everything that was an array and just dump it into the left and the right or right just a perfectly even split no sorting yet so everything up to n1 goes into the left array everything from n1 up to n2 right goes into the right array all right so this starts at zero goes to n2 so that's the number of times it'll repeat but it actually starts at that mid plus one and then plus j so mid plus one and then one and and add on from there so that's going to fill the left and the right with whatever values we're on the left hand side and the right hand side of the original array that was passed now we're going to sort them back into the array okay so we have to have an i and a j so the i is for the left array the j is for the right array and they're both starting at zero of those respective arrays because we might iterate i three times and then iterate j once it's not going to be consistent okay because it all depends on the size of the values in those arrays so while i is less than n1 so that's keeping us within the size of the l of the left array and j is less than n2 again keeping us in the size of the right array then if the left value is less than or equal to the right value then we're going to keep the left value so the main array position k which is starting at l which is the left value that we wanted this whole shebang to start at is equal to that value and then we iterate i which is our left iterator otherwise okay so otherwise if left is not less than or equal to right then that means right must be bigger than left so array k is now equal to the right and we're going to iterate the right iterate or the jet okay and then when all that's done we're going to iterate our k so that now we're ready to check the next one and whether we pull it from the left we pull up the right doesn't matter this is going to run until one of the arrays left or right runs out of values okay so we've pulled everything from either the left or right or the right array so at that point we just need to get anything that's left over because one of them is going to have something left over so if i is less than n1 then we're going to run the while loop which means there's something left over in the left array and we're just going to literally just pull array k is equal to left iterate the left iterate k grab the next until the left array is empty we're never going to have the situation where both of these while loops run because the only reason we got here is because one of the left or right array has already been kind of blood drawn so one of them is going to run so either the left one's going to run or the right one's going to run but when the merge method is done the array that it was passed is now going to be sorted okay and it's going to be sorted using this kind of merge style so this array from its left to right value will be sorted okay so let's look at the merge sort it's the second method so this takes an array a left and a right if left is less than right okay good we're allowed to do our thing then we find our mid all right average we call merge short recursively passes the array the left and the middle so that's the left half then we pass it the array and the right half okay and then we're going to merge those two halves stay with me i'm going to merge those two halves okay now you'll notice no returns here no return statements in any of these okay so they're going to run until they're done and then our base case is literally just code execution stops and code execution is going to stop essentially because we're going to reach a point where the right and the left kind of overlap again okay and that's going to stop our execution chain all right so essentially we take a big array we split it in half and we call merge sort on the left half so we call merge sort on the left and what that does is it calls this same method recursively okay now the right value is mid okay so if left is less than right then we still have room to go so it's going to call it again on the new left to mid and then it's going to call it again on the new left to mid and you can see all the recursive calls happening here so it's essentially going to go left to half to half until it reaches that last little list of two then it's going to merge that which is then going to allow the righthand call to happen which is going to sort that which is then going to allow the merge call to happen the greater merge call which is going to sort those four items but now that kind of recursive chain is done but the next recursive chain is still happening which was on the right hand part of the last call and then that all gets woven down to two and then back out and you can kind of see from the visualization how it works again if that code didn't make sense in my short little video explanation that's okay i'd be surprised if it really did you've gotta code it you've gotta work with the code you gotta play with the code you gotta go look at it it's not gonna happen just from one explanation i'm sorry it's just not that easy okay so the links are in the description go check it out and then see how you get with it let me know again it's a high level concept it's one of the last things you learn in ab computer science so if it's easy then good for you that's awesome if not then you might have to put in some work that's okay so put in the work play with it a little bit see what you can do with it hop on over to some different websites like practice it or coding bat and try some practice problems and see if you can pull them off good luck thanks for checking it out if it's your thing like share subscribe i like making videos so if that's your thing keep doing it and i'll keep doing my thing and hopefully people learn something it's a goal see you humans have a good one