With timestamps:

00:00 - this video covers key strategies and
00:03 - knowledge that will make working an hour
00:04 - much easier in the near and long term
00:07 - let's start by opening our if we want
00:11 - you can type directly into the console
00:13 - however this makes it a bit difficult to
00:16 - recreate our work so it's helpful to
00:17 - open a new our document also called an R
00:20 - script we can open a script by holding
00:23 - down command and hitting n whenever you
00:27 - write our commands you should write them
00:28 - in our script then you can send the
00:30 - commands in your script to an our
00:32 - console to be run for example if your
00:35 - cursor is online in the our script you
00:37 - can run that line of code in the console
00:40 - by holding down command and hitting
00:41 - return to run a larger block of code
00:46 - highlight the code hold down command and
00:48 - hit return it is useful to type your
00:52 - commands into an R script because you
00:53 - can organize their commands and you can
00:55 - run and rerun these commands quickly and
00:57 - easily you can also save an R script so
01:00 - you can use it later and this makes it
01:02 - easy to pick up where you left off in
01:04 - your next work session here I'll save my
01:07 - script to the desktop with the name temp
01:09 - dot R saving and loading files an hour
01:12 - can be very helpful Hara is always
01:14 - looking in a particular folder on your
01:16 - computer and it is sometimes important
01:18 - to know where it is looking so you can
01:19 - access and save files there are two
01:22 - tools that will make this easier get WD
01:25 - and set WD which stands for get working
01:28 - directory and set working directory to
01:32 - get WD function will tell you which
01:34 - directory R is currently working from if
01:37 - you'd like to change the directory
01:39 - you're working in use the set WD
01:41 - function and specify a file path inside
01:43 - the parenthesis where the path is
01:45 - contained in quotation marks for those
01:49 - work in OS X there's one more tool
01:52 - command D typing command e will open a
01:56 - window where you can navigate to folder
01:58 - of your choosing when you are done in an
02:02 - hour session save your script and then
02:04 - type Q open parentheses close
02:07 - parentheses into the console as long as
02:10 - you carefully document your work in an R
02:11 - script there's little reason to save
02:13 - your work
02:13 - space in the next video we'll begin
02:17 - creating objects in our to get
02:24 - acquainted with our let's do some basic
02:25 - calculations we can add numbers multiply
02:29 - numbers and we can invoke built-in
02:32 - functions to do more complex
02:34 - calculations so R is good at
02:40 - calculations but we don't want to type
02:43 - in all of our data instead we'll often
02:46 - store our data into our objects in a
02:50 - later video will load in larger data
02:52 - objects but for now let's create some
02:54 - simple R objects
02:57 - let's save the value for to an object
03:00 - called X usually we use a less than
03:04 - symbol followed by a dash to communicate
03:07 - that we want to save something like a
03:08 - number into an R object now we can use X
03:13 - to do some basic calculations for
03:15 - example X times X or we can calculate
03:18 - the square root of x note that sometimes
03:23 - people might call X a variable so think
03:26 - of the terms object and variable as
03:29 - meaning the same thing in our the names
03:35 - of our objects can include letters
03:36 - numbers underscores and periods however
03:41 - the name should always start with the
03:43 - letter usually one that is a lowercase
03:46 - if you'll be sharing your code with
03:48 - others check with your group to see if
03:50 - there's a style guide that you should
03:51 - follow for your R code one last tip if
03:57 - you want to review an earlier command
03:58 - you made click the command line on the
04:01 - our console and then hit the up arrow on
04:03 - your keyboard when you do this you will
04:07 - be able to see earlier commands you have
04:09 - run and if you desire you can rerun them
04:16 - in the next video we'll create and work
04:19 - with vectors in our one of the
04:24 - fundamental objects in R is a vector
04:27 - which is just a term to mean a single
04:29 - set of values in a particular order we
04:33 - can create a simple vector in R using
04:34 - the concatenate function which is a
04:36 - function represented by a lowercase C
04:38 - inside the parentheses we put values or
04:41 - other vectors separated by commas and
04:43 - these will be stuck together to create a
04:45 - new vector when we print the vector R
04:49 - simply prints the values one after
04:52 - another you might wonder what happens if
04:56 - there are so many values in the vector
04:57 - that it hits the end of the line well
05:00 - the values wrapped to the next line just
05:02 - like the text would if you were writing
05:03 - a paragraph notice that there's also
05:06 - little extra information in the first
05:08 - and second lines in the first line we
05:12 - have a number one in brackets and on the
05:13 - second line we have a number 10 in
05:15 - brackets in each case these correspond
05:18 - to how far our is into the vector at the
05:20 - start of each line for example the 10
05:24 - indicates the first element on the
05:26 - second line is the tenth element of the
05:29 - vector the one in the brackets at the
05:32 - start of the output indicates that this
05:34 - line was the start of the printed vector
05:38 - this brings up a subtle point looking
05:42 - back on our earlier output we can see
05:44 - the bracket one in each output while
05:46 - each earlier output looked like a scalar
05:49 - that is a standalone number each of
05:52 - these is really a vector with a single
05:53 - value in our a vector of length one is
05:56 - equivalent to a scalar for those vectors
06:00 - with length greater than one it is
06:02 - common for us to want to access a
06:03 - specific element let's call our longer
06:07 - vector V
06:10 - if you wanted to look at just the first
06:12 - element of V we use brackets with a 1 or
06:17 - if we wanted the third value we could
06:18 - use a 3 in the brackets we can also
06:24 - request several values at once to do so
06:28 - we create a vector that indicates the
06:29 - positions of the values we want returned
06:31 - then we put this vector into the
06:33 - brackets so let's suppose we want to
06:36 - look at the first three values we start
06:39 - by creating a vector of one two three
06:41 - here I've done that using the special
06:43 - notation 1 colon 3 which produces a
06:46 - vector with the values 1 2 3 I'll save
06:51 - this vector into a variable called look
06:53 - at and then I'll use look at inside the
06:56 - brackets to get at the first three
06:58 - values of V there are three more
07:02 - functions worth remembering when it
07:04 - comes to vectors length head and tail
07:07 - the length function indicates the number
07:09 - of elements in a vector the head
07:11 - function returns the first six
07:13 - observations in the vector and the tail
07:16 - function returns the last six
07:18 - observations in the vector here's V
07:22 - printed out for comparison also if we
07:26 - want we can specify a second argument in
07:29 - the head or tail functions this second
07:31 - argument says how many observations we
07:33 - want to see for example here I'll
07:36 - specify that I want to see just the last
07:38 - three values of V using the tail
07:40 - function with 3 as the second argument
07:44 - in the next video we'll work with
07:46 - character and boolean vectors
07:53 - our can handle a lot more than numbers
07:56 - for example you can handle character
07:58 - objects which are also known as strings
08:01 - we can make a simple character object
08:04 - just by putting some text in quotation
08:06 - marks
08:07 - you might notice something we saw before
08:10 - which is that the output is again
08:12 - preceded by a 1 in brackets this
08:15 - character object is a vector and we can
08:18 - create a longer vector using the
08:19 - concatenate function as with numeric
08:23 - vectors we can apply functions to a
08:24 - character vector to learn more about it
08:26 - or get summary information in addition
08:32 - to the numeric and character type of
08:34 - vector we can create a boolean vector in
08:38 - the simplest case we can write true in
08:40 - all caps or we can write false in all
08:44 - caps we could also create a vector of
08:48 - true and false values using the
08:50 - concatenate function one of the really
08:55 - handy features of boolean vectors is
08:57 - that they can be used to extract
08:58 - specific elements of a vector that meet
09:00 - a certain criteria for example here
09:06 - we'll use the end char function to find
09:08 - out the number of characters in each
09:10 - character string in the vector then
09:14 - we're going to create a new vector
09:15 - called under 10 this vector will
09:18 - indicate which elements of V have less
09:21 - than 10 characters finally I can subset
09:25 - V using under 10 in the next video we'll
09:32 - start doing arithmetic with vectors
09:39 - the simplest type of vector arithmetic
09:42 - anar is just adding a number to a vector
09:45 - let's create a vector V of values 10 20
09:49 - 30 40 50 and 60 then we'll add one to
09:55 - this vector when we add a single number
09:58 - to a vector it adds that number to each
10:00 - element of the vector we can also do
10:03 - simple multiplication which works in the
10:06 - same way things get a little trickier
10:10 - when you multiply two vectors where each
10:12 - are longer than length 1 let's create a
10:16 - second vector called W that takes values
10:18 - 2 3 4 5 6 & 7
10:23 - I've constructed this vector using a
10:25 - special notation of 2 : 7 which
10:29 - generates a sequence of integers 2
10:31 - through 7 this is a handy way to create
10:34 - a sequence of all integers between two
10:35 - values let's multiply V and W is that
10:42 - what you expected
10:43 - our performs element-wise vector
10:46 - multiplication that is it'll take the
10:50 - first value in each vector and multiply
10:52 - them then it'll take the second value
10:55 - from each vector and multiply those and
10:56 - so on when working with vectors are
11:01 - works in the same way when do an
11:02 - addition subtraction division and other
11:05 - basic operations things get a little
11:09 - more confusing when we multiply vectors
11:11 - of different lengths
11:13 - let's overwrite W with a vector of
11:16 - length 2 that takes values 5 and 10 when
11:21 - we multiply V and W now the result might
11:24 - be surprising we get another vector with
11:28 - 6 elements let's take a closer look at
11:32 - what happened the first two values make
11:35 - sense they are again the element wise
11:37 - multiplication however when we get to
11:41 - the third value it appears to be the
11:43 - product of the third value of V and the
11:45 - first value of W the fourth value is the
11:49 - product of the last value of V
11:51 - second value W what we've just observed
11:54 - is that our recycled the vector W so
11:57 - that it could complete the
11:58 - multiplication across the full length of
12:00 - V it also did so without any warning or
12:04 - error r is built to recycle vectors and
12:07 - it doesn't always tell you when it does
12:09 - so let's do one more vector
12:11 - multiplication well overwrite W one more
12:15 - time and make it a vector of length four
12:18 - with values 5 10 15 and 20 here this
12:24 - vector has been created using the
12:25 - sequence function the first argument
12:28 - says where the sequence starts the
12:31 - second where the sequence should end and
12:33 - a third how big of jumps to take to get
12:37 - from the first to the last value here
12:41 - again we multiply out V and W are again
12:45 - will recycle W but this time it gives us
12:47 - a warning in this case when our recycled
12:51 - W it still had elements left over when
12:54 - it ran out of elements with V so it
12:56 - wanted to make sure that we are aware of
12:57 - this there are several ways we can
13:00 - perform arithmetic and are using vectors
13:02 - we can raise every element in a vector
13:05 - to a power or a different power for each
13:07 - element here I've again use the integer
13:10 - colon integer notation to create a
13:12 - vector of values two three four five six
13:15 - seven many functions also work nicely
13:18 - across vectors such as the square root
13:20 - function in the next video we'll learn
13:25 - about matrices
13:32 - matrices are just slightly more
13:33 - complicated than vectors to create a
13:36 - matrix we usually start by creating a
13:38 - vector here I'll create a vector that
13:40 - has elements 1 through 12 using the
13:41 - integer colon integer notation next I'll
13:46 - use the matrix function to create the
13:48 - matrix
13:48 - whenever creating a matrix it is helpful
13:51 - to provide the number of rows and the
13:52 - number of columns to ensure that you're
13:54 - creating the precise matrix you expect
13:56 - you can do this using the n row and n
13:59 - call arguments if you happen to forget
14:03 - to use the argument names our will try
14:05 - to guess what you meant it usually does
14:07 - this based on the order of the arguments
14:09 - for the matrix function if we specify
14:12 - the number of rows before the number of
14:13 - columns we get the same type of result
14:17 - you can also experiment with leaving off
14:19 - one of the arguments notice that if I
14:22 - only include the number of columns I
14:24 - need to specify the N call argument name
14:26 - if I want to get the same matrix that I
14:28 - got before the matrix function is very
14:32 - handy in that
14:33 - well you might specify the complete set
14:35 - of data for the matrix right up front
14:36 - you don't always have to do this if
14:39 - parts of the matrix will repeat here's
14:42 - the matrix with all zeros we only need
14:44 - to specify a single zero for the entire
14:46 - matrix we can also specify a partial
14:49 - vector that can be used to fill in the
14:51 - entire matrix let's create a 3 by 4
14:54 - matrix with values 11 12 and 13 filled
14:57 - in in the entire matrix in this example
15:01 - the vector which had length 3 was
15:03 - recycled until the 3 by 4 matrix was
15:05 - filled up notice that the vector runs
15:08 - down the columns rather than across the
15:10 - rows if we had wanted to make it run
15:12 - across the rows we can add a fourth
15:14 - argument to the matrix function by row
15:16 - equals true we also sometimes want to
15:23 - learn more about a matrix we might start
15:25 - using the DIMM function to learn the
15:27 - dimensions of the matrix here the output
15:31 - of dim is a vector of length 2 the first
15:34 - values the number of rows in the matrix
15:35 - and the second is the number of columns
15:38 - we can also apply the length head and
15:40 - tail functions to a matrix
15:44 - the length will return the number of
15:46 - elements in the entire matrix and the
15:49 - head and tail functions will provide up
15:51 - to six rows from the top and bottom of
15:53 - the matrix if we want we can specify a
15:56 - second argument in the head or tail
15:58 - function take it a different number of
16:00 - rows back one last matrix topic to
16:04 - consider is how does like a one or more
16:06 - elements of the matrix let's return to
16:09 - the matrix that we had at the beginning
16:11 - of the video here it's just values 1
16:13 - through 12 in the matrix that has three
16:16 - rows and four columns like with vectors
16:20 - we can subset a matrix to select one or
16:23 - more parts of the matrix but since a
16:25 - matrix is two-dimensional we need to
16:27 - specify two dimensions in the brackets
16:30 - for example if we use 2 comma 4 we will
16:33 - get the element in the second row in the
16:35 - fourth column if we leave the column
16:39 - entry blank we'll get all of the columns
16:41 - and if we leave the rows blank we get
16:43 - all of the rows just like with vectors
16:47 - you can use vectors of length greater
16:49 - than 1 inside the sub setting to return
16:52 - more than one value using vectors with
16:58 - lengths greater than 1 to get both rows
17:00 - and columns may produce a slightly
17:02 - surprising result another matrix let's
17:05 - consider the matrix where we specify the
17:07 - rows 1 and 2 and the columns 3 and 4
17:10 - doing so gives us back a sub matrix
17:12 - specified by these dimensions finally
17:17 - before moving on one final word on
17:20 - matrix sub setting if you forget the
17:23 - comma R will still return a value each
17:26 - matrix is stored in R as a vector with
17:28 - extra dimensions so if we request the
17:31 - third element of the matrix it counts
17:33 - down the first column and returns the
17:35 - third element if we specify the fifth
17:38 - element our runs out in the first column
17:40 - and so goes the second column as it
17:42 - keeps counting I wanted to highlight
17:45 - this not because subset in this way is a
17:47 - good idea but just to make clear that it
17:49 - can be accidentally done and so it's
17:51 - something you need to watch out for
17:52 - using the row column subsidy notation is
17:55 - the preferred
18:00 - in the next video we'll take a look back
18:02 - at the first six videos and also how to
18:04 - access help files for functions inside
18:07 - of our functions are special our objects
18:17 - have taken other objects as arguments
18:19 - and produce something in many cases the
18:23 - person who wrote the function provides
18:24 - default values for some or even all of
18:26 - the arguments we've now seen a couple
18:29 - important functions and techniques first
18:32 - we saw the concatenate function that was
18:34 - easy to create vectors and we saw we
18:36 - could create vectors that are sequences
18:38 - of integers using the integer colon
18:40 - integer notation we use the length head
18:44 - and tail functions to learn more about
18:46 - vectors we also saw character vectors
18:50 - the letters object is a built-in vector
18:53 - of letters inside of our and we wanted
18:56 - we could examine a subset of the letters
18:59 - we also saw how to construct matrices
19:01 - using the matrix function as well as how
19:04 - to specify the number of rows and
19:05 - columns for a matrix Susan the second
19:06 - and third arguments the dim function
19:10 - provided a way to check the dimensions
19:11 - of a matrix and we could again use
19:13 - brackets to examine a subset of the
19:15 - matrix except that we specified both
19:17 - rows and columns or just one
19:26 - videos are great but they're no stand in
19:28 - for documentation thankfully most
19:31 - functions an hour are very well
19:32 - documented to access the help file for a
19:35 - function just type a question work the
19:38 - function name and then hit return here's
19:41 - the help file for the sequence function
19:44 - at the top of the file is a description
19:46 - of the sequence function and other
19:48 - related functions described in this help
19:50 - file the next section shows the sequence
19:53 - function and its variants and arguments
19:56 - section provides details for what type
19:58 - of inputs are reasonable and how to
19:59 - specify additional options the next
20:03 - sections of particular interest are the
20:04 - see also and examples sections it's a
20:09 - good idea to take a look at the example
20:10 - section early on when you're exploring a
20:12 - new function on OS X it's also easy to
20:16 - run examples from the help file by
20:18 - highlighting the example text holding
20:20 - down command and then hitting return
20:26 - congratulations you've completed the
20:28 - first section of our videos take some
20:31 - time to try out what you've learned and
20:32 - when R gives you an air check for typing
20:37 - mistakes which are common after you
20:41 - finished experimenting fuel up and start
20:44 - section 2 welcome to section 2 R is a
20:52 - powerful tool for data analysis and the
20:55 - first step to working with data in R is
20:57 - to get the data into R suppose I have a
21:00 - CSV file on my computer and I want to
21:02 - load into R since I'm running R on OS X
21:06 - I could use the command V trick to
21:08 - change my working directory to the
21:10 - folder with the file but it's also
21:12 - helpful to know how to navigate using
21:13 - the get WD and set WD functions will
21:18 - also make use of the list files function
21:20 - which lists the files and folders in the
21:22 - current working directory I want to get
21:26 - into my Google Drive folder so I'm going
21:28 - to specify that in a set WD function
21:31 - next I'm going to print out the folders
21:33 - in this Google Drive folder and navigate
21:36 - to projects
21:39 - next I'm going to navigate to the top
21:41 - secret folder and since I know there's a
21:43 - data folder there I'm just going to add
21:44 - this folder into my set delete command
21:47 - alright I've arrived and I can now see
21:50 - the dataset of interest in my current
21:52 - working directory the state dot CSV data
21:54 - set since I'll be saving this code I
21:58 - might as well save my current working
21:59 - directory in a set WD command at the top
22:02 - of my script this way I won't need to
22:05 - set the directory in the future unless I
22:07 - changed the working directory of my
22:08 - project files now that I'm ready to go
22:12 - I'll load in the state CSV file using
22:14 - the read CSV function specifying the
22:17 - name with the file in quotation marks
22:20 - when you're reading a CSV file in DAR
22:23 - it's stored as a data matrix it is more
22:26 - formally called a data frame in are just
22:29 - like with the regular matrix I can use
22:31 - the DIMM function to see how many rows
22:33 - and columns are in the data set there
22:35 - are 51 rows representing all US states
22:38 - in Washington DC and 12 different
22:40 - columns representing the 12 different
22:41 - variables recorded for each state I'll
22:45 - use the head function to print out the
22:46 - first two rows of the state data set
22:49 - just like I could do with a regular
22:50 - matrix however if I apply the length
22:54 - function R we'll just return the number
22:56 - of variables in the data set which are
22:57 - represented by the columns data frames
23:00 - are one of the most common objects for
23:02 - holding data inside of our meagan subset
23:05 - on them in ways similar to how I might
23:06 - subset a matrix this is fine but they're
23:10 - actually better ways with data frames a
23:12 - new function for data frames worth
23:15 - remembering is the names function which
23:17 - is used to access the variable names
23:19 - once you know the names of the variables
23:21 - it's easy to extract out the entire
23:23 - variable using the dataset name followed
23:26 - by dollar sign then followed by the
23:27 - variable name let's take a look at the
23:30 - smoke variable the smoke variable is a
23:33 - numerical variable representing the
23:34 - percentage of people who smoke in each
23:36 - state if I wanted I could apply some
23:39 - standard functions like the mean or
23:40 - standard deviation function to get some
23:42 - summary information about this variable
23:45 - in addition to substudy with brackets I
23:47 - can make use of the subset function
23:50 - here I'm gonna examine only states with
23:53 - smoking rates higher than 25% if I
23:57 - wanted I could also specify that I only
23:59 - want to select a small number of columns
24:03 - next I'll take a look at the party that
24:06 - won each state in the 2012 presidential
24:08 - election this is in the press 12
24:10 - variable
24:11 - note that the press 12 variable isn't
24:14 - numerical yet it was stored the smoke
24:16 - variable which was a numerical object in
24:19 - the state data frame data frames can
24:21 - hold a different type of variable in
24:23 - each column while a matrix can only hold
24:25 - a single data type for the entire matrix
24:28 - notice also that the output doesn't look
24:30 - like a regular string output which
24:32 - generally has quotation marks when it is
24:33 - printed out additionally there's a
24:36 - listing at the bottom that indicates
24:38 - there are two levels output like this
24:40 - indicates that this is a factor variable
24:42 - or a factor object a factor object is a
24:45 - special kind of object that's sort of a
24:47 - blend between character and numerical
24:49 - variables if you ever have substantial
24:51 - trouble working with factors in our you
24:53 - can just convert the factor to string
24:55 - with the Eze character function R will
24:59 - generally convert a character variable
25:00 - back into a factor variable when it is
25:02 - appropriate to do so however we know R
25:05 - does do this conversion it may notify
25:07 - you with Orion just read your warnings
25:09 - carefully and make sure that that's all
25:10 - that's happening in the next video we'll
25:14 - talk about ways to take a quick look at
25:16 - a data object inside of our and we'll
25:19 - also take a look at data objects there
25:24 - are two other functions I'll consider
25:26 - that provide a brief overview of a data
25:28 - frame
25:29 - but first I'll load in data set this
25:32 - time stock market data
25:33 - I've already navigated to the proper
25:35 - folder and I can see the file in my
25:37 - current working directory if I use the
25:39 - list files function this particular data
25:42 - set is saved as a tab delimited text
25:44 - file so to import it into R I'm going to
25:47 - use the read the limb function in the
25:50 - last video we saw how to load in CSV
25:51 - files and in this video we've seen now
25:53 - how to load and tab delimited files if
25:55 - you aren't sure how to load in your
25:57 - particular data set Google your question
25:59 - there are many online resources about
26:01 - loading data in tar
26:03 - likely to be very useful all right back
26:06 - to the data set I'll take a look at the
26:08 - first in the last three rows I can also
26:10 - get a better overview of the data set by
26:12 - using the STR function that provides a
26:14 - breakdown of the objects structure here
26:17 - I can see that stocks is an object with
26:19 - over 70,000 rows and eight variables I
26:22 - can also see each of the names of each
26:24 - of the variables and the first several
26:26 - observations get a sense of what each
26:27 - contains note that observations for
26:30 - factor variables may look like numerical
26:32 - variables another helpful function to
26:35 - get an alternative look at an object is
26:36 - the summary function in the case of a
26:40 - data frame the summary object returns a
26:42 - summary of each column notice that
26:44 - there's n/a values represented in some
26:46 - of the columns in our na means that
26:49 - there's a missing observation and here
26:51 - it lists the number of missing
26:52 - observations for each of these columns
26:54 - note that the STR and summary functions
26:57 - are not specific to data frames they can
26:59 - be applied to any other object to get a
27:01 - quick peek about the object and its
27:02 - characteristics you might have noticed
27:05 - that one of the variables in the stock
27:06 - data set is a date I'm going to take a
27:09 - closer look at the date and printout the
27:10 - first 20 values if I look carefully I
27:14 - can see there's also levels attribute
27:16 - associated with these dates that means
27:19 - that R has interpreted this field as
27:21 - being a factor it'd be much more useful
27:23 - to keep this as an actual date object in
27:26 - this case the dates are formatted as day
27:28 - month and year and in such cases I want
27:32 - to examines variables a date object
27:33 - using the as date function I also need
27:37 - to specify the format of the date there
27:41 - are many different ways to format dates
27:42 - so you may need to look up how to
27:44 - specify the date format so you run into
27:46 - for this purpose you'll probably want to
27:49 - look an STR P time function help file
27:52 - you can do this by typing question mark
27:55 - STR PE time and hitting Enter I'm gonna
27:59 - save the formatted dates and then the
28:00 - object called s date while having this
28:04 - date object is helpful I really would
28:06 - like to replace the original date object
28:08 - with this one in fact it actually
28:10 - would've been much easier had I just
28:11 - skipped the step of creating a state and
28:13 - is saved the modified version over the
28:15 - date object right from the start
28:17 - now if I look at the stock objects again
28:19 - with the head function I can see that
28:21 - the date variable is now formatted a
28:23 - standard way starting with all four
28:25 - digits of the year than the next two
28:27 - digits for the month and then the last
28:30 - two digits being the days you might
28:33 - wonder why go to all this trouble to
28:35 - format the date why not just leave it as
28:37 - a factor or decided as a character first
28:41 - you might like to examine the
28:42 - differences of dates to learn the
28:43 - proximity of two observations to each
28:45 - other second if you generate a time
28:47 - series plot that makes use of the date
28:49 - object R will do its part to help make
28:51 - the plot look nice for example here I'll
28:54 - plot the time series of the stock price
28:55 - for Google I'm specifying the data's
28:58 - variable for the horizontal axis and
29:00 - since this is formatted as a date hour
29:03 - we'll use this information and plot the
29:05 - years all along the axes
29:07 - had I not converted the date over to a
29:09 - date object the plot wouldn't have
29:10 - looked nearly as nice there are several
29:13 - other reasons to properly process and
29:15 - format dates in R but the general reason
29:18 - is that doing so communicates the data
29:20 - structure accurately and this will make
29:21 - it easier for you and others to use and
29:24 - reuse your code in the next video we'll
29:29 - talk about if statements and also the
29:31 - which function
29:38 - in this video I'll cover two important
29:40 - structures in any language the if
29:42 - statement and logical operators I'll
29:45 - also introduce the if-else and which
29:47 - functions I'm going to occasionally rely
29:51 - on the stock data used in the last video
29:53 - but to keep things simple I'm also going
29:55 - to omit any rows that have an na value
29:57 - as these represent missing observations
29:59 - in the data an if statement is used to
30:04 - execute some section of code on the
30:06 - condition that a particular statement is
30:07 - true in this setup the code inside the
30:11 - braces will run if the condition is true
30:15 - for example suppose I want to check
30:17 - whether the first entry in the stock
30:19 - data was up or down if it was up I want
30:23 - to create a variable called status that
30:24 - takes the value up it would also be
30:28 - informative to label the statuses down
30:29 - if the stock is down so I'll add an else
30:32 - statement the code in the second set of
30:36 - braces will execute if the condition is
30:38 - false however this still isn't quite
30:40 - right what if the stock opens and closes
30:43 - at the same price I can add a condition
30:45 - for the second set of code using a
30:47 - second if statement after the else
30:49 - command then I'll add another else
30:51 - command at the end that labels status
30:53 - with a value of flat if the stock is
30:55 - flat for the day I also want to briefly
30:58 - mention the if-else function which could
31:00 - be used in this context to create an up
31:02 - down flat vector for all the elements in
31:06 - the stocks data in just a few lines of
31:08 - code the if-else function takes three
31:11 - arguments a vector of length 1 or more
31:13 - that contains true and false values a
31:16 - value to take for each true instance and
31:19 - a value to take for each false instance
31:22 - though this still isn't quite right
31:25 - because I need to return a value of down
31:26 - if the close is lower than the open I
31:29 - can do this by creating the second
31:31 - condition and I need one more if else
31:33 - command here I've done something subtle
31:37 - I've provided the status argument for
31:40 - those cases where the close is not lower
31:42 - than the open I've exploited a special
31:44 - feature of the if-else function which is
31:47 - that when a vector of length greater
31:48 - than 1 is provided in the second or
31:50 - arguments if-else will be performed
31:52 - element wise for that argument I'll
31:56 - leave it to you to verify that this code
31:58 - works and why it works you should think
32:00 - about each possible case a stock can be
32:03 - up-down or flat and I strongly recommend
32:06 - you create some test data and work your
32:08 - way through each step of the code next I
32:12 - want to talk about logical operators I'm
32:15 - going to create a vector with ten random
32:17 - integers between negative 1 and 13 and a
32:21 - second vector in the same way I'd like
32:24 - to know whether all the elements in X
32:25 - are greater than 0 I might intuitively
32:28 - start by using the command X greater
32:31 - than 0 however as our does in many other
32:35 - scenarios it also performs this check
32:37 - element wise here you can see I have a
32:39 - vector of true and false values but I
32:41 - can use the all function around X
32:43 - greater than 0 to answer the question as
32:45 - to whether all of the values of X are
32:47 - greater than 0 we can also check other
32:50 - things such as do any elements of X line
32:53 - up with those in Y this again returns a
32:56 - vector of true and false but this time I
32:58 - can use the any function to check
33:00 - whether any of the values are equal we
33:03 - can also do other checks that relate x
33:05 - and y for example consider the separate
33:08 - commands X greater than 0 and y greater
33:10 - than 0 if I wanted to check in which
33:13 - elements this was true in both vectors I
33:15 - could use a single ampersand between the
33:18 - commands here the single ampersand means
33:22 - to check whether both the first and the
33:24 - second condition are true on the element
33:26 - wise basis there's a similar or command
33:31 - using a pipe or a vertical line
33:33 - character that creates an element-wise
33:34 - basis on whether one statement or the
33:37 - other statement is true are like other
33:41 - languages also has a double ampersand
33:43 - and double pipe notation though I'm
33:45 - going to move on if you're interested in
33:48 - this you should check out the help file
33:49 - for X or
33:52 - the last topic I wanted to cover in this
33:54 - video is the which function you use to
33:56 - identify which elements or observations
33:58 - satisfy a particular condition for
34:01 - example I'd like to know which
34:03 - observations had a big intraday
34:04 - fluctuation to begin I'll create an
34:07 - object called fluctuation that gives the
34:10 - raw intraday fluctuation I can scale the
34:14 - fluctuation by dividing the difference
34:16 - by the opening share price of the day
34:19 - next I'll create a condition for whether
34:22 - the fluctuation was greater than say 25
34:25 - percent this is a boolean vector of true
34:30 - and false values that report whether
34:31 - each row in the data frame satisfied or
34:33 - did not satisfy this big fluctuation
34:36 - condition if I wanted a vector reporting
34:38 - just those rows that satisfy the
34:40 - condition I can use the which function
34:43 - these rows are present observations
34:45 - where the stock price fluctuated by more
34:47 - than 25 percent in a day if I wanted I
34:50 - could examine each of these rows in the
34:51 - original data set in the next video I'll
34:55 - talk about for loops a second key
35:03 - programming tool is the for loop a for
35:05 - loop is a structure used to execute a
35:07 - set of code repeatedly the for loop
35:10 - statements specifiers an index over
35:12 - which the loop is computed for example
35:15 - here I'll execute a for loop using an
35:17 - index called I the object I will start
35:21 - the loop by taking the first value in
35:22 - the 1 through 10 vector that is to start
35:26 - I will equal 1 next the for loop will
35:29 - execute then I will take the next value
35:31 - in this vector which is 2 and loop will
35:33 - execute again this will continue until I
35:35 - is taken the last value in the vector 10
35:38 - and the code executes one last time in
35:42 - this set of code the value I squared
35:44 - will be appended to vector X using the
35:46 - append function here I got an error
35:50 - I'll take a closer look I can see that X
35:53 - never actually existed so there is no
35:55 - way to pend anything onto the first
35:57 - iteration to fix this
36:00 - I'll just initialize X as an empty
36:01 - vector using the concatenate function
36:02 - but leaving the arguments empty
36:06 - okay this runs well look at X in each
36:10 - iteration value of I squared was
36:12 - appended to the end of X so the first
36:15 - element was created when I was 1 the
36:17 - second when I was 2 and so on okay I've
36:21 - done something pretty cool here I've
36:24 - done ten calculations using a for loop
36:26 - and it wouldn't be hard to do many more
36:27 - with the same set of code for example I
36:30 - could easily go from 1 to 100 rather
36:32 - than just 1 to 10
36:35 - while there are other better ways to do
36:37 - this particular calculation there are
36:39 - instances where for loop is very useful
36:43 - all right one more look at the stock
36:45 - data to calculate the smallest and
36:49 - largest values for each stock in the
36:51 - stock data set I'm going to start by
36:53 - creating an object called the tickers
36:55 - that is just a list of the unique stock
36:57 - tickers in the data since for loops can
37:02 - iterate over any vector I will write a
37:04 - for loop to iterate over the object that
37:06 - I've called the tickers it's sometimes
37:10 - helpful to also give a meaningful name
37:12 - to the index so I'm going to change the
37:15 - index I to ticker now I need to create
37:21 - code for the general case for a given
37:23 - ticker calculate with the low and the
37:25 - high value
37:27 - I'll start by identifying which rows are
37:30 - of interest in the stocks data set the
37:34 - vector called look at is a boolean
37:36 - vector indicating which observations
37:37 - represent the ticker for the given
37:40 - iteration next I can create two
37:43 - statements calculus to low and highest
37:45 - high of these observations finally I
37:51 - need to store these values somehow I can
37:54 - start by initializing two objects lows
37:56 - and highs next I can use an append
37:59 - command to append a value on to the end
38:01 - of the vector alright I can run the code
38:07 - and print the results but something's
38:09 - wrong well I'd want to spot check some
38:12 - of my data anyways something bad has
38:14 - happened
38:16 - a value of na in R means that a value is
38:19 - missing and more generally oftentimes
38:22 - functions will return na if any of the
38:24 - observations are missing if I took a
38:27 - look through our data set I'd find that
38:29 - there are several observations with
38:30 - missing na values here I've checked how
38:37 - many entries in the column lo of the
38:38 - stocks data set are missing in many
38:42 - functions such as min and Max there's an
38:45 - optional extra argument that is useful
38:47 - for ignoring missing data the narn
38:50 - argument which I'll set to true in the
38:53 - min and Max functions now when I rerun
39:02 - the code I get sensible results I'd want
39:05 - to look at the data more carefully to
39:06 - see why some observations are missing
39:08 - but I'll leave this as a topic for
39:10 - another set of videos one final word
39:15 - even in this example there are other
39:17 - better functions that could have been
39:18 - used to get the same results much more
39:20 - quickly this would be important for code
39:23 - that should be implemented efficiently
39:24 - and I'll get to these functions in the
39:27 - future however for the beginning our
39:30 - programmer it's sometimes easier and
39:32 - clearer to simply implement a for loop
39:39 - lists are a special type of object that
39:42 - hold other objects I can initialize a
39:44 - list by simply using the list function I
39:48 - can create items in the list by
39:50 - providing arguments to the list function
39:54 - what is important to understand is that
39:56 - a list can hold objects of all different
39:58 - types in this example the first object
40:01 - is a numerical vector of length 5 second
40:04 - objects is a character vector of length
40:05 - 1 and a third object is a boolean vector
40:08 - of length 1 if I wanted to access an
40:11 - item I use the subset in a double
40:13 - bracket I can also add on new items even
40:17 - providing the character name for the
40:19 - item when a list has named objects those
40:23 - objects can be accessed using a special
40:25 - dollar sign notation but is reminiscent
40:27 - of the same notation for data frame
40:31 - Liss also aren't restrained to holding
40:34 - just vectors they can also hold matrices
40:36 - data frames and even other lists lists
40:39 - are so powerful since you create helpful
40:41 - ways to organize diverse sets of data or
40:43 - results oftentimes I have many groups of
40:47 - data and would be helpful to calculate
40:48 - statistics reach I might organize these
40:51 - statistics using a list I'm going to
40:54 - load it in the stock data just as we
40:56 - have in the last couple of videos my
40:58 - goal will be to create a summary of the
41:00 - prices for each stock I'm going to do
41:03 - this using a for loop the first line in
41:07 - the for loop will identify the rows of
41:08 - interest the second line will calculate
41:11 - the summary and start an object called
41:13 - stock summary I also shouldn't forget to
41:16 - initialize a stock summary object here
41:18 - as a list finally I can take a look at
41:25 - the results not surprisingly there's a
41:28 - lot to look at if I wanted I could look
41:30 - at a specific summary for a particular
41:32 - stock say Google's stock what I've done
41:39 - here in just six lines of code is very
41:41 - powerful I've calculated summaries for
41:44 - every stock in data set and this code
41:46 - works regardless of if I have five
41:48 - stocks or five thousand stocks in other
41:52 - instances I might choose to do something
41:54 - even more complex like fit a linear
41:56 - model to the data for each stock
41:57 - separately even in that complex case a
42:01 - list can be used to store the result I
42:03 - noted in the last video that is a become
42:06 - more familiar with our you'll find out
42:08 - that there are more helpful functions to
42:10 - do operations commonly done in for loops
42:12 - this is also true with this example
42:14 - which could have been written much more
42:16 - compactly using some additional
42:17 - functions some of these functions we'll
42:20 - encounter in the next section like the
42:22 - function is buy and apply
42:27 - great work on making it through the
42:29 - second section of videos take a short
42:32 - coffee break practice what you've seen
42:34 - and then get started on the third
42:36 - section writing your code into our
42:43 - scripts is valuable for managing or
42:44 - organizing our objects but sometimes you
42:47 - may wish to clear some objects from your
42:49 - workspace to get a look at what objects
42:52 - exist in your current workspace use the
42:54 - LS function if you want to remove an
42:57 - object use the remove function with the
43:00 - argument name as the object to be
43:02 - removed if you want to remove all the
43:05 - objects in a workspace you can use the
43:07 - list argument in the remove function and
43:09 - specify all the objects in the workspace
43:11 - using the LS function it's also helpful
43:16 - to be able to easily convert between
43:17 - objects of different types will consider
43:20 - three functions for converting objects
43:22 - to numerical character and factor object
43:24 - types for instance we can apply each of
43:27 - these functions to the object X applying
43:31 - the as character and the as factor
43:33 - functions back to the outcome had I
43:35 - wanted to actually change X to say a
43:37 - factor I could have assigned the new
43:39 - result tax one special note here if you
43:45 - have a factor variable that also looks
43:46 - numeric always convert it to a character
43:49 - before converting it to numerical value
43:52 - there are other comparable functions
43:54 - that you may occasionally find useful
43:55 - such as as matrix as data frame and as
43:59 - list one last functional considering
44:04 - this video is the unlist function in the
44:07 - usual process of data analysis I might
44:09 - create a list to hold summary results of
44:11 - an experiment here I'll construct a list
44:14 - manually for four groups in this example
44:17 - you can think of the first number for
44:19 - grouped represent its corresponding
44:21 - sample size the second number might
44:23 - represent the average response for that
44:25 - group and the third value might
44:27 - represent the standard deviation for the
44:28 - group
44:31 - just a side note worth mentioning I
44:34 - typically perform these types of
44:36 - calculations in an automated way which
44:38 - would make it easier for the code to be
44:39 - scaled to an arbitrary number of groups
44:41 - if you need to refresh her on this topic
44:43 - look back to the fifth video in section
44:46 - two all right so the results are stored
44:49 - in a list where each list item
44:51 - represents the results for a single
44:53 - group if I unlist this object I get a
44:56 - vector of the unlisted results it would
44:59 - actually more useful to hold this object
45:01 - as a matrix or as a data frame so I'll
45:04 - form these unlisted results into matrix
45:06 - if I'd prefer a data frame I could use
45:09 - the as data frame function applied to
45:11 - this matrix if I wanted I could also
45:15 - adjust the column names of the data
45:16 - frame using the names or the column
45:18 - names function in the next video we'll
45:25 - explore the family of apply functions
45:27 - which are helpful for applying a
45:29 - function across the rows or columns of
45:31 - matrix or across the elements of a list
45:38 - the apply function and its variants are
45:40 - useful for applying a function across an
45:42 - hour object we'll consider two variants
45:45 - of these special class of functions
45:46 - apply and T apply and we'll also look at
45:50 - the by function I'm going to start by
45:53 - loading in a new dataset website revenue
45:55 - for the month of March for ten
45:57 - businesses I've used the argument header
46:00 - equals false because there are no call
46:02 - names stored in this comma separated
46:04 - values file the data in this data matrix
46:06 - have been stored in a slightly
46:07 - unorthodox way each business is
46:10 - represented as a column and each row
46:12 - represents a day in order of March 1st
46:15 - through March 31st so for example on
46:19 - March 3rd the 10th business made $23.98
46:24 - it might be helpful for me to take a
46:26 - quick look at how the businesses are
46:27 - doing by taking a look at their total
46:29 - revenue I could take the sum for each
46:32 - column using a for loop and store that
46:34 - result in a vector but this would
46:36 - actually be inefficient instead I should
46:39 - use the apply function which will be
46:41 - more compact and also run faster with
46:43 - larger data sets the apply function is
46:48 - useful for applying a function across
46:49 - the rows or columns of a data matrix
46:52 - that is I might want to apply a function
46:55 - across each row separately or across
46:57 - each column separately the first
47:00 - argument is the data matrix itself the
47:03 - second argument is the dimension number
47:05 - over which to apply the function rows
47:07 - are represented by number one and
47:09 - columns by number two think of the
47:11 - second argument as specifying the
47:13 - dimension that you actually want to
47:14 - retain the last argument is the function
47:17 - to be applied in a similar way we can
47:21 - also compute the total revenue for all
47:22 - the companies on each day of the month
47:24 - by applying the sum function over each
47:26 - of the rows notice that there are some
47:29 - missing observations if we would look
47:32 - into the data more carefully we would
47:34 - find that there are two missing values
47:35 - each in the third column if we know that
47:39 - it's okay to omit these data we can tell
47:41 - the sum function to ignore the missing
47:42 - observations using n/a remove equals
47:45 - true the apply function passes this
47:48 - argument on to the sum function
47:51 - generally any extra arguments to apply
47:54 - will be passed to the function you
47:55 - specify in the third argument in this
47:58 - particular use case we probably should
48:00 - want to investigate the missing
48:01 - observations rather than simply ignore
48:03 - them also just a technical note for this
48:07 - application of apply I could have used
48:09 - either their call sums or row sums
48:11 - functions
48:14 - all right onwards the second function T
48:17 - apply to help explain this new function
48:20 - I'm going to load in a second data set
48:22 - that summarises eBay auctions for the
48:23 - Mario Kart video game for the Wii this
48:27 - is a tab delimited text file of the data
48:29 - so I'm going to read it in using read
48:31 - elimb to keep things simple let's focus
48:35 - on three variables wheels conditions and
48:39 - total price the t apply function is
48:42 - similar to the apply function in that it
48:44 - helps aggregate data efficiently for
48:47 - instance we could examine the sum of all
48:49 - the total prices of auctions that were
48:50 - new and used separately by providing the
48:53 - vector for the total price as the first
48:55 - argument the vector for the conditions
48:57 - is a second and then the sum function as
49:00 - the third just like an apply the third
49:03 - argument for the t apply function is
49:05 - another function to be applied across
49:07 - the data however in this case the
49:10 - function is applied to each group where
49:12 - the groups are specified by the second
49:14 - argument which in this case is the
49:16 - condition of the game I'm going to
49:19 - modify this command a little bit since
49:21 - it makes more sense to look at the
49:22 - average price of the game as you might
49:24 - have anticipated the games that are new
49:26 - tend to sell for more than the games
49:28 - that are used here the difference is
49:30 - about ten dollars there's a second
49:34 - important variable in this application
49:35 - that relates the price the number of
49:37 - steering wheels that come with the game
49:39 - in the auction these steering wheels are
49:41 - game accessory that make playing Mario
49:43 - Kart a bit more fun let's look at the
49:46 - average price of the auctions with
49:47 - different numbers of wheels included as
49:50 - you might expect we again see a steady
49:54 - increase in price associated with having
49:56 - more wheels included in the auction
49:57 - about six to ten dollars per wheel
50:01 - now there's something interesting to
50:03 - think about here if I consider the
50:05 - influence of both price and the number
50:07 - of wheels simultaneously what will this
50:09 - do to the estimated cost of a new game
50:11 - versus a used game and also the cost of
50:13 - an extra wheel a table to look at the
50:15 - average price across each of the
50:17 - combinations of condition and wheels can
50:18 - be made using the T apply function to do
50:21 - this I'm going to provide the data frame
50:23 - with just the condition in the wheels
50:25 - columns as the second argument some of
50:28 - these numbers will look a little bit
50:29 - surprising for instance going from no
50:32 - wheels to one wheel doesn't seem to
50:34 - influence the price and then the game is
50:35 - new if we dig in a little more here
50:38 - using length function in place of the
50:40 - mean function I can see that one of the
50:42 - groups had very few observations and so
50:45 - this average is probably less reliable
50:46 - and this might explain the difference if
50:50 - I was going to continue this analysis
50:51 - I'd probably look into this some more
50:53 - one last function before we wrap up the
50:57 - buy function is a variant of the T apply
50:58 - function but by default it returns a
51:01 - vector of the results note that when it
51:04 - is printed it won't really look like a
51:06 - vector that you could access the
51:08 - elements just as if it was a vector in
51:13 - the next video we'll take a look at
51:14 - three functions with within and
51:18 - aggregate
51:23 - in this video I'll take a look at three
51:25 - functions with within and aggragate to
51:29 - explore these functions I'm going to
51:31 - load in the Mario Kart data set the
51:34 - width function can be used to access
51:35 - variables in a data frame with ease this
51:38 - is especially important when the name of
51:40 - the data frame is long and multiple
51:42 - variables are being accessed for a
51:43 - calculation I can read this command as
51:47 - with Mario Kart compute the total price
51:50 - minus the shipping price the width in
51:54 - function is similar to with except that
51:56 - it's easy to create new columns and
51:58 - merge them with the original data set
52:00 - for instance here I'll add an auction
52:03 - closing price to the data frame and
52:05 - store the result in a new data frame
52:06 - called m'kay notice that the commands to
52:09 - generate the new variables goes inside
52:11 - braces as the second argument if I had
52:15 - wanted I could have added multiple
52:16 - variables by creating more variables
52:18 - inside of the braces as you can probably
52:21 - guess the width function is useful for
52:23 - one-off calculations well within is
52:26 - useful for expanding a dataset to
52:27 - include new variables when I want to
52:31 - aggregate or summarize results I often
52:34 - use the aggregate function here I'll
52:36 - aggregate cross the number of wheels and
52:38 - the condition variables the first
52:41 - argument is a formula the dot on the
52:44 - left side of the tilde means keep all
52:45 - the variables for the output and the
52:48 - variables on the right side separated by
52:49 - a plus sign indicate which variables to
52:51 - aggregate across the second argument is
52:55 - a data frame and the third argument is
52:57 - how to a great the variables had I only
53:01 - wanted to aggregate across one variable
53:02 - say the total price I could have
53:05 - replaced the dot with the total price
53:07 - variable notice the similarities between
53:11 - what the aggregate and t apply functions
53:13 - produce which you should use depends on
53:17 - what you will use the output for
53:21 - congratulations you finish section three
53:23 - the next section will introduce how to
53:26 - write your own functions
53:33 - building functions in hours a key skill
53:35 - that we'll cover in this section of
53:36 - videos in this first video the basic
53:39 - structural function will be introduced
53:41 - in the context of reporting both the
53:42 - mean and the standard error of a data
53:44 - set I'm going to start by creating a
53:47 - test dataset called D here D is a sample
53:50 - of 25 observations from a Poisson
53:52 - distribution with 8 degrees of freedom
53:54 - next I'd like to ensure that my test
53:56 - dataset is stable so if I rerun my code
53:59 - I'll get the same kind of results I'm
54:00 - going to do this using a set seed
54:03 - function now if I regenerate my data and
54:07 - multiple times I get the same test data
54:09 - set now on to the general structure of a
54:14 - function
54:15 - I'll start by carefully choosing a
54:17 - function name here I've thought about
54:18 - this ahead of time I'm going to call it
54:21 - get mean and standard error next I'll
54:25 - assign a function object to this name
54:27 - using the function declaration I've
54:31 - provided a generic argument X to
54:33 - represent the data and I'll use braces
54:35 - to contain the code to be executed using
54:36 - the arguments I'll compute the mean the
54:41 - length of the data set and the standard
54:43 - error of the mean inside of these braces
54:46 - presently the function identifies the
54:49 - mean and it's standard error however the
54:52 - variables m and se
54:54 - only exist in the scope of the function
54:56 - so when I run the function I don't
54:58 - actually get any results what I need to
55:00 - do is add a return statement now
55:03 - whenever you run the function the mean
55:05 - and the standard error will be returned
55:07 - this new function can be helpful however
55:09 - its present output isn't actually ideal
55:12 - it would be nice to make explicitly
55:14 - clear what each of the outputs is from
55:16 - the function in the next video I'll
55:18 - expand the function and take a look at
55:20 - this challenge
55:25 - the function in the last video is used
55:27 - to report the mean and the standard
55:28 - error suppose I wanted to also report a
55:31 - 95% confidence interval for the mean
55:33 - here L can start a confidence interval
55:37 - the Qt function is used to identify the
55:39 - ninety-seven point fifth quantile of the
55:41 - T distribution with n minus 1 degrees of
55:43 - freedom there might be some temptation
55:46 - to concatenate the confidence interval
55:48 - with the current results being reported
55:50 - from the function in some instances this
55:52 - might be fine
55:53 - but it isn't a very clear way to
55:54 - organize the results for example what if
55:57 - another user mistakenly thought the
55:59 - first two values with the confidence
56:00 - interval and last two were the mean and
56:02 - the standard error that could be
56:04 - disastrous when multiple objects are
56:07 - being returned from a function it's
56:09 - usually helpful to return them in a list
56:10 - but even now things might still be a
56:13 - little bit unclear for this reason it's
56:15 - useful to add names to each element of
56:17 - the list and before I forget I should
56:21 - update the name of the function I'm
56:23 - going to name it get CI for get
56:26 - confidence interval there's one more
56:30 - change I want to make before moving on
56:31 - making the function slightly more
56:33 - general by allowing for a different
56:34 - confidence level I'm going to do this
56:37 - using a second argument called level
56:38 - sense the 95% confidence level is so
56:41 - commonly used I'll so spy 0.95
56:44 - confidence level as the default next I
56:48 - need to make some slight adjustments the
56:49 - body of the function to make use of this
56:51 - new argument I can compute the upper
56:54 - percentile for the confidence interval
56:56 - then provide this as a substitute for
56:58 - 0.975 now I can run the function without
57:04 - specifying the level to get a standard
57:06 - 95% confidence level or if I want a
57:09 - different confidence level say 99% I can
57:13 - easily make that request suppose the
57:17 - user input a value for a level of 99
57:19 - rather than 0.99 for the level argument
57:22 - in this application it would be nice if
57:25 - the function failed elegantly and
57:27 - communicated why there was an error
57:28 - rather than simply reporting a warning
57:30 - this will be the topic of the next video
57:38 - providing clear feedback to users is one
57:41 - part of building great functions I'm
57:43 - going to take a look at the function
57:45 - from the last video that was used to
57:46 - compute a confidence interval for the
57:48 - mean using the sample of data what if a
57:51 - user provided a percentage instead of a
57:53 - proportion for the confidence level
57:55 - currently the user simply gets a warning
57:57 - and the reason behind the warning isn't
57:59 - going to be obvious to new our users
58:01 - instead it'd be helpful to stop the
58:03 - execution of the function and clearly
58:05 - communicate what is wrong I'll do this
58:07 - by stopping the function if the level of
58:09 - the argument takes value less than zero
58:11 - or greater than one to stop the
58:13 - execution of a function and return an
58:15 - error use the stop function the argument
58:18 - if the stop function is a character
58:20 - string to communicate why the air was
58:21 - generated here I'll communicate that the
58:24 - level variable should have been
58:25 - represented by a proportion between 0
58:27 - and 1 now when a user inputs a level
58:31 - value that is invalid it stops and
58:33 - returns an error I'm also a little
58:37 - concerned that a user might provide a
58:38 - level that takes value like 0.05 or 0.1
58:41 - they might think they are supposed to
58:43 - provide a significance level rather than
58:45 - a confidence level if the confidence
58:47 - level is smaller than 0.5 I'd like to
58:50 - warn the user that they should rethink
58:51 - their input I can do this using the
58:54 - warning function in the next video I'll
58:59 - introduce how to pass an arbitrary
59:00 - number of arguments to a function
59:07 - in this video I'll cover how to pass
59:09 - arguments to existing functions inside
59:11 - of functions you are creating to do so
59:14 - I'll use the website Revenue data
59:16 - highlighted in the last section I'd like
59:19 - to create a function that summarizes the
59:21 - revenue and other objects like it I'll
59:23 - call the function Rev summary it'll take
59:26 - just one argument that should be a data
59:27 - frame or a matrix where the rows
59:29 - represent days columns represent
59:32 - different websites and the entries
59:34 - represent revenue for the websites on
59:35 - each day I'll build in a simple check to
59:39 - make sure that the data object comes in
59:40 - in a form of a matrix or a data frame if
59:43 - it doesn't then I'll provide a suitable
59:45 - air next I'll calculate to summaries the
59:51 - average revenue per company and the
59:53 - average revenue per day for the
59:54 - companies in a previous video I use the
59:58 - apply function for this but here I'll
60:01 - use two functions and are specifically
60:02 - built for taking the mean across rows
60:04 - and columns row means and call means
60:09 - I'll return those results in a list with
60:12 - two items that we returned at the close
60:13 - of the function mean revenue per company
60:16 - and mean revenue per day finally I'll
60:20 - apply my new function to the revenue
60:22 - data when I execute the function I get a
60:26 - list back as expected however there are
60:29 - some n/a values that indicate that some
60:31 - data are missing here al dente' Phi
60:33 - which observations in the revenue data
60:34 - are missing using is n/a function
60:36 - together with a which function and an
60:38 - additional argument array index equals
60:41 - true the first is for the 12th day and
60:44 - the third company the second is for the
60:47 - 13th day and the third company it's
60:50 - possible that some end users of this
60:52 - function including myself may
60:54 - occasionally want to have such
60:55 - observations omitted from the
60:57 - calculations in the functions using an
60:58 - n/a argument similar to how we've seen
61:01 - this argument used with other functions
61:03 - however this n/a remove argument would
61:06 - need to be passed to both row means and
61:08 - call means this is fine but it's
61:10 - actually a little bit more generalizable
61:12 - to accept an arbitrary number of
61:13 - arguments we pass to these functions
61:16 - I can do this using an ellipsis in rev
61:19 - summaries declaration this allows the
61:22 - Rev summary function to accept extra
61:24 - arguments not specified in the function
61:25 - declaration next I indicate which
61:28 - functions should receive these X
61:30 - arguments since my intention here is to
61:34 - allow users to pass the n/a a remove
61:35 - argument to row means and call means I
61:38 - will add an ellipsis to the end of each
61:40 - of these functions now if I pass any
61:45 - remove equals true into the rev summary
61:47 - function this argument we passed the row
61:49 - means and call means functions which
61:52 - will then remove the any values from the
61:54 - calculations note that if you want you
61:57 - may access the arguments from the
61:58 - ellipsis in your function using the list
62:00 - function with an ellipsis as its
62:03 - argument in this way you may also write
62:06 - functions that allow for an arbitrary
62:07 - number of arguments and then access all
62:09 - of those arguments and list what's been
62:13 - covered in this video is how to easily
62:14 - pass additional arguments inside your
62:16 - functions and how to access those extra
62:18 - arguments using the list function in the
62:21 - next video I'll show how to hide
62:23 - function output that might flood a
62:25 - user's screen and we'll also cover a
62:26 - useful tool for building recursive
62:28 - functions which are functions that call
62:30 - themselves
62:38 - in this video I'll show how to make
62:40 - output invisible which is helpful when
62:42 - I'll function is a large output and I'll
62:44 - also cover how to use a function
62:45 - recursively if your function returns a
62:50 - lot of results it might be a bit
62:51 - obnoxious when a person forgets to
62:53 - assign the output to an R object if you
62:56 - think your output is likely to be
62:57 - annoying when it's printed out you can
62:59 - use the invisible function in place of
63:01 - the return function then when user fails
63:05 - to save the result to an R object
63:07 - their console will not be flooded with
63:09 - output and if they do assign the output
63:12 - to an object the object will store the
63:13 - result that said invisible output can
63:17 - confuse users so use this trick with
63:19 - caution it's also worth noting that
63:21 - using classes and methods inside of R is
63:24 - another way to address this challenge
63:26 - however classes and methods aren't topic
63:28 - I'll cover in this video and one more
63:32 - tip before we move on to recursive
63:33 - functions if you happen to flood your
63:36 - console screen or if you simply want to
63:38 - clear the console if you're on a Mac use
63:40 - command Alltel or if you on windows
63:42 - control l which will clear your console
63:45 - screen all right on to recursive
63:49 - functions a recursive function is a
63:51 - function that may call itself for
63:54 - example I can create a function called
63:55 - log me that takes the log of a value if
63:58 - the value is larger than 1 and keeps
64:00 - doing this until it gets a value that's
64:01 - less than 1 if the value is less than 1
64:04 - then the function simply returns the
64:07 - result the way the code is written works
64:10 - but what if I happen to change the
64:11 - functions name I would still want the
64:14 - function to call itself to make sure it
64:16 - does I should use the function called
64:18 - recall which automatically calls the
64:20 - function it's in in general using
64:24 - recalls the preferred way to build
64:26 - recursive functions in our in the next
64:30 - video we'll look at how to use a custom
64:32 - function with the apply function
64:41 - in the last section I talked a bit about
64:43 - the apply family of functions these are
64:46 - very powerful functions for applying the
64:48 - same function across many sets of data
64:50 - they're even more powerful when combined
64:53 - with custom functions to begin I'm going
64:57 - to create a sample object X that's a
64:59 - matrix with 1000 rows and 10 columns
65:01 - containing 10,000 random draws from a
65:04 - Poisson distribution with 8 degrees of
65:06 - freedom if you recall I could easily to
65:11 - apply a function across each row or
65:13 - column here I've calculated the mean for
65:17 - each column if I wanted I could also
65:21 - create a custom function on the fly that
65:23 - calculates the standard error of the
65:24 - mean using each column separately note
65:28 - that here I've omitted the prices for
65:29 - the function declaration I did this
65:32 - since the function can fit on one line
65:34 - but I could include braces if I liked
65:38 - this inline use of functions is very
65:40 - useful since it allows you to apply
65:42 - simple custom functions on the fly it's
65:45 - also common to make complex functions
65:47 - and use them in a third argument of
65:48 - apply here I'm going to first load in
65:52 - the get CI function then I'm going to
65:54 - call it inside of apply you might recall
65:59 - that the get CI function actually
66:00 - returned the list the apply function
66:03 - adapts its output to accommodate complex
66:05 - outputs by the function being applied
66:08 - sometimes they'll return a vector other
66:10 - times the matrix and other times the
66:12 - list here since get CI outputs a list
66:16 - the best way to represent many outputs
66:18 - of that function is to contain them in a
66:20 - sort of super list this completes the
66:25 - fourth section of videos take some time
66:27 - to try out what you've learned in these
66:29 - first four sections of video browse
66:31 - online for some data or acts some of
66:33 - these datasets that are already present
66:35 - in your accession

Cleaned transcript:

this video covers key strategies and knowledge that will make working an hour much easier in the near and long term let's start by opening our if we want you can type directly into the console however this makes it a bit difficult to recreate our work so it's helpful to open a new our document also called an R script we can open a script by holding down command and hitting n whenever you write our commands you should write them in our script then you can send the commands in your script to an our console to be run for example if your cursor is online in the our script you can run that line of code in the console by holding down command and hitting return to run a larger block of code highlight the code hold down command and hit return it is useful to type your commands into an R script because you can organize their commands and you can run and rerun these commands quickly and easily you can also save an R script so you can use it later and this makes it easy to pick up where you left off in your next work session here I'll save my script to the desktop with the name temp dot R saving and loading files an hour can be very helpful Hara is always looking in a particular folder on your computer and it is sometimes important to know where it is looking so you can access and save files there are two tools that will make this easier get WD and set WD which stands for get working directory and set working directory to get WD function will tell you which directory R is currently working from if you'd like to change the directory you're working in use the set WD function and specify a file path inside the parenthesis where the path is contained in quotation marks for those work in OS X there's one more tool command D typing command e will open a window where you can navigate to folder of your choosing when you are done in an hour session save your script and then type Q open parentheses close parentheses into the console as long as you carefully document your work in an R script there's little reason to save your work space in the next video we'll begin creating objects in our to get acquainted with our let's do some basic calculations we can add numbers multiply numbers and we can invoke builtin functions to do more complex calculations so R is good at calculations but we don't want to type in all of our data instead we'll often store our data into our objects in a later video will load in larger data objects but for now let's create some simple R objects let's save the value for to an object called X usually we use a less than symbol followed by a dash to communicate that we want to save something like a number into an R object now we can use X to do some basic calculations for example X times X or we can calculate the square root of x note that sometimes people might call X a variable so think of the terms object and variable as meaning the same thing in our the names of our objects can include letters numbers underscores and periods however the name should always start with the letter usually one that is a lowercase if you'll be sharing your code with others check with your group to see if there's a style guide that you should follow for your R code one last tip if you want to review an earlier command you made click the command line on the our console and then hit the up arrow on your keyboard when you do this you will be able to see earlier commands you have run and if you desire you can rerun them in the next video we'll create and work with vectors in our one of the fundamental objects in R is a vector which is just a term to mean a single set of values in a particular order we can create a simple vector in R using the concatenate function which is a function represented by a lowercase C inside the parentheses we put values or other vectors separated by commas and these will be stuck together to create a new vector when we print the vector R simply prints the values one after another you might wonder what happens if there are so many values in the vector that it hits the end of the line well the values wrapped to the next line just like the text would if you were writing a paragraph notice that there's also little extra information in the first and second lines in the first line we have a number one in brackets and on the second line we have a number 10 in brackets in each case these correspond to how far our is into the vector at the start of each line for example the 10 indicates the first element on the second line is the tenth element of the vector the one in the brackets at the start of the output indicates that this line was the start of the printed vector this brings up a subtle point looking back on our earlier output we can see the bracket one in each output while each earlier output looked like a scalar that is a standalone number each of these is really a vector with a single value in our a vector of length one is equivalent to a scalar for those vectors with length greater than one it is common for us to want to access a specific element let's call our longer vector V if you wanted to look at just the first element of V we use brackets with a 1 or if we wanted the third value we could use a 3 in the brackets we can also request several values at once to do so we create a vector that indicates the positions of the values we want returned then we put this vector into the brackets so let's suppose we want to look at the first three values we start by creating a vector of one two three here I've done that using the special notation 1 colon 3 which produces a vector with the values 1 2 3 I'll save this vector into a variable called look at and then I'll use look at inside the brackets to get at the first three values of V there are three more functions worth remembering when it comes to vectors length head and tail the length function indicates the number of elements in a vector the head function returns the first six observations in the vector and the tail function returns the last six observations in the vector here's V printed out for comparison also if we want we can specify a second argument in the head or tail functions this second argument says how many observations we want to see for example here I'll specify that I want to see just the last three values of V using the tail function with 3 as the second argument in the next video we'll work with character and boolean vectors our can handle a lot more than numbers for example you can handle character objects which are also known as strings we can make a simple character object just by putting some text in quotation marks you might notice something we saw before which is that the output is again preceded by a 1 in brackets this character object is a vector and we can create a longer vector using the concatenate function as with numeric vectors we can apply functions to a character vector to learn more about it or get summary information in addition to the numeric and character type of vector we can create a boolean vector in the simplest case we can write true in all caps or we can write false in all caps we could also create a vector of true and false values using the concatenate function one of the really handy features of boolean vectors is that they can be used to extract specific elements of a vector that meet a certain criteria for example here we'll use the end char function to find out the number of characters in each character string in the vector then we're going to create a new vector called under 10 this vector will indicate which elements of V have less than 10 characters finally I can subset V using under 10 in the next video we'll start doing arithmetic with vectors the simplest type of vector arithmetic anar is just adding a number to a vector let's create a vector V of values 10 20 30 40 50 and 60 then we'll add one to this vector when we add a single number to a vector it adds that number to each element of the vector we can also do simple multiplication which works in the same way things get a little trickier when you multiply two vectors where each are longer than length 1 let's create a second vector called W that takes values 2 3 4 5 6 & 7 I've constructed this vector using a special notation of 2 7 which generates a sequence of integers 2 through 7 this is a handy way to create a sequence of all integers between two values let's multiply V and W is that what you expected our performs elementwise vector multiplication that is it'll take the first value in each vector and multiply them then it'll take the second value from each vector and multiply those and so on when working with vectors are works in the same way when do an addition subtraction division and other basic operations things get a little more confusing when we multiply vectors of different lengths let's overwrite W with a vector of length 2 that takes values 5 and 10 when we multiply V and W now the result might be surprising we get another vector with 6 elements let's take a closer look at what happened the first two values make sense they are again the element wise multiplication however when we get to the third value it appears to be the product of the third value of V and the first value of W the fourth value is the product of the last value of V second value W what we've just observed is that our recycled the vector W so that it could complete the multiplication across the full length of V it also did so without any warning or error r is built to recycle vectors and it doesn't always tell you when it does so let's do one more vector multiplication well overwrite W one more time and make it a vector of length four with values 5 10 15 and 20 here this vector has been created using the sequence function the first argument says where the sequence starts the second where the sequence should end and a third how big of jumps to take to get from the first to the last value here again we multiply out V and W are again will recycle W but this time it gives us a warning in this case when our recycled W it still had elements left over when it ran out of elements with V so it wanted to make sure that we are aware of this there are several ways we can perform arithmetic and are using vectors we can raise every element in a vector to a power or a different power for each element here I've again use the integer colon integer notation to create a vector of values two three four five six seven many functions also work nicely across vectors such as the square root function in the next video we'll learn about matrices matrices are just slightly more complicated than vectors to create a matrix we usually start by creating a vector here I'll create a vector that has elements 1 through 12 using the integer colon integer notation next I'll use the matrix function to create the matrix whenever creating a matrix it is helpful to provide the number of rows and the number of columns to ensure that you're creating the precise matrix you expect you can do this using the n row and n call arguments if you happen to forget to use the argument names our will try to guess what you meant it usually does this based on the order of the arguments for the matrix function if we specify the number of rows before the number of columns we get the same type of result you can also experiment with leaving off one of the arguments notice that if I only include the number of columns I need to specify the N call argument name if I want to get the same matrix that I got before the matrix function is very handy in that well you might specify the complete set of data for the matrix right up front you don't always have to do this if parts of the matrix will repeat here's the matrix with all zeros we only need to specify a single zero for the entire matrix we can also specify a partial vector that can be used to fill in the entire matrix let's create a 3 by 4 matrix with values 11 12 and 13 filled in in the entire matrix in this example the vector which had length 3 was recycled until the 3 by 4 matrix was filled up notice that the vector runs down the columns rather than across the rows if we had wanted to make it run across the rows we can add a fourth argument to the matrix function by row equals true we also sometimes want to learn more about a matrix we might start using the DIMM function to learn the dimensions of the matrix here the output of dim is a vector of length 2 the first values the number of rows in the matrix and the second is the number of columns we can also apply the length head and tail functions to a matrix the length will return the number of elements in the entire matrix and the head and tail functions will provide up to six rows from the top and bottom of the matrix if we want we can specify a second argument in the head or tail function take it a different number of rows back one last matrix topic to consider is how does like a one or more elements of the matrix let's return to the matrix that we had at the beginning of the video here it's just values 1 through 12 in the matrix that has three rows and four columns like with vectors we can subset a matrix to select one or more parts of the matrix but since a matrix is twodimensional we need to specify two dimensions in the brackets for example if we use 2 comma 4 we will get the element in the second row in the fourth column if we leave the column entry blank we'll get all of the columns and if we leave the rows blank we get all of the rows just like with vectors you can use vectors of length greater than 1 inside the sub setting to return more than one value using vectors with lengths greater than 1 to get both rows and columns may produce a slightly surprising result another matrix let's consider the matrix where we specify the rows 1 and 2 and the columns 3 and 4 doing so gives us back a sub matrix specified by these dimensions finally before moving on one final word on matrix sub setting if you forget the comma R will still return a value each matrix is stored in R as a vector with extra dimensions so if we request the third element of the matrix it counts down the first column and returns the third element if we specify the fifth element our runs out in the first column and so goes the second column as it keeps counting I wanted to highlight this not because subset in this way is a good idea but just to make clear that it can be accidentally done and so it's something you need to watch out for using the row column subsidy notation is the preferred in the next video we'll take a look back at the first six videos and also how to access help files for functions inside of our functions are special our objects have taken other objects as arguments and produce something in many cases the person who wrote the function provides default values for some or even all of the arguments we've now seen a couple important functions and techniques first we saw the concatenate function that was easy to create vectors and we saw we could create vectors that are sequences of integers using the integer colon integer notation we use the length head and tail functions to learn more about vectors we also saw character vectors the letters object is a builtin vector of letters inside of our and we wanted we could examine a subset of the letters we also saw how to construct matrices using the matrix function as well as how to specify the number of rows and columns for a matrix Susan the second and third arguments the dim function provided a way to check the dimensions of a matrix and we could again use brackets to examine a subset of the matrix except that we specified both rows and columns or just one videos are great but they're no stand in for documentation thankfully most functions an hour are very well documented to access the help file for a function just type a question work the function name and then hit return here's the help file for the sequence function at the top of the file is a description of the sequence function and other related functions described in this help file the next section shows the sequence function and its variants and arguments section provides details for what type of inputs are reasonable and how to specify additional options the next sections of particular interest are the see also and examples sections it's a good idea to take a look at the example section early on when you're exploring a new function on OS X it's also easy to run examples from the help file by highlighting the example text holding down command and then hitting return congratulations you've completed the first section of our videos take some time to try out what you've learned and when R gives you an air check for typing mistakes which are common after you finished experimenting fuel up and start section 2 welcome to section 2 R is a powerful tool for data analysis and the first step to working with data in R is to get the data into R suppose I have a CSV file on my computer and I want to load into R since I'm running R on OS X I could use the command V trick to change my working directory to the folder with the file but it's also helpful to know how to navigate using the get WD and set WD functions will also make use of the list files function which lists the files and folders in the current working directory I want to get into my Google Drive folder so I'm going to specify that in a set WD function next I'm going to print out the folders in this Google Drive folder and navigate to projects next I'm going to navigate to the top secret folder and since I know there's a data folder there I'm just going to add this folder into my set delete command alright I've arrived and I can now see the dataset of interest in my current working directory the state dot CSV data set since I'll be saving this code I might as well save my current working directory in a set WD command at the top of my script this way I won't need to set the directory in the future unless I changed the working directory of my project files now that I'm ready to go I'll load in the state CSV file using the read CSV function specifying the name with the file in quotation marks when you're reading a CSV file in DAR it's stored as a data matrix it is more formally called a data frame in are just like with the regular matrix I can use the DIMM function to see how many rows and columns are in the data set there are 51 rows representing all US states in Washington DC and 12 different columns representing the 12 different variables recorded for each state I'll use the head function to print out the first two rows of the state data set just like I could do with a regular matrix however if I apply the length function R we'll just return the number of variables in the data set which are represented by the columns data frames are one of the most common objects for holding data inside of our meagan subset on them in ways similar to how I might subset a matrix this is fine but they're actually better ways with data frames a new function for data frames worth remembering is the names function which is used to access the variable names once you know the names of the variables it's easy to extract out the entire variable using the dataset name followed by dollar sign then followed by the variable name let's take a look at the smoke variable the smoke variable is a numerical variable representing the percentage of people who smoke in each state if I wanted I could apply some standard functions like the mean or standard deviation function to get some summary information about this variable in addition to substudy with brackets I can make use of the subset function here I'm gonna examine only states with smoking rates higher than 25% if I wanted I could also specify that I only want to select a small number of columns next I'll take a look at the party that won each state in the 2012 presidential election this is in the press 12 variable note that the press 12 variable isn't numerical yet it was stored the smoke variable which was a numerical object in the state data frame data frames can hold a different type of variable in each column while a matrix can only hold a single data type for the entire matrix notice also that the output doesn't look like a regular string output which generally has quotation marks when it is printed out additionally there's a listing at the bottom that indicates there are two levels output like this indicates that this is a factor variable or a factor object a factor object is a special kind of object that's sort of a blend between character and numerical variables if you ever have substantial trouble working with factors in our you can just convert the factor to string with the Eze character function R will generally convert a character variable back into a factor variable when it is appropriate to do so however we know R does do this conversion it may notify you with Orion just read your warnings carefully and make sure that that's all that's happening in the next video we'll talk about ways to take a quick look at a data object inside of our and we'll also take a look at data objects there are two other functions I'll consider that provide a brief overview of a data frame but first I'll load in data set this time stock market data I've already navigated to the proper folder and I can see the file in my current working directory if I use the list files function this particular data set is saved as a tab delimited text file so to import it into R I'm going to use the read the limb function in the last video we saw how to load in CSV files and in this video we've seen now how to load and tab delimited files if you aren't sure how to load in your particular data set Google your question there are many online resources about loading data in tar likely to be very useful all right back to the data set I'll take a look at the first in the last three rows I can also get a better overview of the data set by using the STR function that provides a breakdown of the objects structure here I can see that stocks is an object with over 70,000 rows and eight variables I can also see each of the names of each of the variables and the first several observations get a sense of what each contains note that observations for factor variables may look like numerical variables another helpful function to get an alternative look at an object is the summary function in the case of a data frame the summary object returns a summary of each column notice that there's n/a values represented in some of the columns in our na means that there's a missing observation and here it lists the number of missing observations for each of these columns note that the STR and summary functions are not specific to data frames they can be applied to any other object to get a quick peek about the object and its characteristics you might have noticed that one of the variables in the stock data set is a date I'm going to take a closer look at the date and printout the first 20 values if I look carefully I can see there's also levels attribute associated with these dates that means that R has interpreted this field as being a factor it'd be much more useful to keep this as an actual date object in this case the dates are formatted as day month and year and in such cases I want to examines variables a date object using the as date function I also need to specify the format of the date there are many different ways to format dates so you may need to look up how to specify the date format so you run into for this purpose you'll probably want to look an STR P time function help file you can do this by typing question mark STR PE time and hitting Enter I'm gonna save the formatted dates and then the object called s date while having this date object is helpful I really would like to replace the original date object with this one in fact it actually would've been much easier had I just skipped the step of creating a state and is saved the modified version over the date object right from the start now if I look at the stock objects again with the head function I can see that the date variable is now formatted a standard way starting with all four digits of the year than the next two digits for the month and then the last two digits being the days you might wonder why go to all this trouble to format the date why not just leave it as a factor or decided as a character first you might like to examine the differences of dates to learn the proximity of two observations to each other second if you generate a time series plot that makes use of the date object R will do its part to help make the plot look nice for example here I'll plot the time series of the stock price for Google I'm specifying the data's variable for the horizontal axis and since this is formatted as a date hour we'll use this information and plot the years all along the axes had I not converted the date over to a date object the plot wouldn't have looked nearly as nice there are several other reasons to properly process and format dates in R but the general reason is that doing so communicates the data structure accurately and this will make it easier for you and others to use and reuse your code in the next video we'll talk about if statements and also the which function in this video I'll cover two important structures in any language the if statement and logical operators I'll also introduce the ifelse and which functions I'm going to occasionally rely on the stock data used in the last video but to keep things simple I'm also going to omit any rows that have an na value as these represent missing observations in the data an if statement is used to execute some section of code on the condition that a particular statement is true in this setup the code inside the braces will run if the condition is true for example suppose I want to check whether the first entry in the stock data was up or down if it was up I want to create a variable called status that takes the value up it would also be informative to label the statuses down if the stock is down so I'll add an else statement the code in the second set of braces will execute if the condition is false however this still isn't quite right what if the stock opens and closes at the same price I can add a condition for the second set of code using a second if statement after the else command then I'll add another else command at the end that labels status with a value of flat if the stock is flat for the day I also want to briefly mention the ifelse function which could be used in this context to create an up down flat vector for all the elements in the stocks data in just a few lines of code the ifelse function takes three arguments a vector of length 1 or more that contains true and false values a value to take for each true instance and a value to take for each false instance though this still isn't quite right because I need to return a value of down if the close is lower than the open I can do this by creating the second condition and I need one more if else command here I've done something subtle I've provided the status argument for those cases where the close is not lower than the open I've exploited a special feature of the ifelse function which is that when a vector of length greater than 1 is provided in the second or arguments ifelse will be performed element wise for that argument I'll leave it to you to verify that this code works and why it works you should think about each possible case a stock can be updown or flat and I strongly recommend you create some test data and work your way through each step of the code next I want to talk about logical operators I'm going to create a vector with ten random integers between negative 1 and 13 and a second vector in the same way I'd like to know whether all the elements in X are greater than 0 I might intuitively start by using the command X greater than 0 however as our does in many other scenarios it also performs this check element wise here you can see I have a vector of true and false values but I can use the all function around X greater than 0 to answer the question as to whether all of the values of X are greater than 0 we can also check other things such as do any elements of X line up with those in Y this again returns a vector of true and false but this time I can use the any function to check whether any of the values are equal we can also do other checks that relate x and y for example consider the separate commands X greater than 0 and y greater than 0 if I wanted to check in which elements this was true in both vectors I could use a single ampersand between the commands here the single ampersand means to check whether both the first and the second condition are true on the element wise basis there's a similar or command using a pipe or a vertical line character that creates an elementwise basis on whether one statement or the other statement is true are like other languages also has a double ampersand and double pipe notation though I'm going to move on if you're interested in this you should check out the help file for X or the last topic I wanted to cover in this video is the which function you use to identify which elements or observations satisfy a particular condition for example I'd like to know which observations had a big intraday fluctuation to begin I'll create an object called fluctuation that gives the raw intraday fluctuation I can scale the fluctuation by dividing the difference by the opening share price of the day next I'll create a condition for whether the fluctuation was greater than say 25 percent this is a boolean vector of true and false values that report whether each row in the data frame satisfied or did not satisfy this big fluctuation condition if I wanted a vector reporting just those rows that satisfy the condition I can use the which function these rows are present observations where the stock price fluctuated by more than 25 percent in a day if I wanted I could examine each of these rows in the original data set in the next video I'll talk about for loops a second key programming tool is the for loop a for loop is a structure used to execute a set of code repeatedly the for loop statements specifiers an index over which the loop is computed for example here I'll execute a for loop using an index called I the object I will start the loop by taking the first value in the 1 through 10 vector that is to start I will equal 1 next the for loop will execute then I will take the next value in this vector which is 2 and loop will execute again this will continue until I is taken the last value in the vector 10 and the code executes one last time in this set of code the value I squared will be appended to vector X using the append function here I got an error I'll take a closer look I can see that X never actually existed so there is no way to pend anything onto the first iteration to fix this I'll just initialize X as an empty vector using the concatenate function but leaving the arguments empty okay this runs well look at X in each iteration value of I squared was appended to the end of X so the first element was created when I was 1 the second when I was 2 and so on okay I've done something pretty cool here I've done ten calculations using a for loop and it wouldn't be hard to do many more with the same set of code for example I could easily go from 1 to 100 rather than just 1 to 10 while there are other better ways to do this particular calculation there are instances where for loop is very useful all right one more look at the stock data to calculate the smallest and largest values for each stock in the stock data set I'm going to start by creating an object called the tickers that is just a list of the unique stock tickers in the data since for loops can iterate over any vector I will write a for loop to iterate over the object that I've called the tickers it's sometimes helpful to also give a meaningful name to the index so I'm going to change the index I to ticker now I need to create code for the general case for a given ticker calculate with the low and the high value I'll start by identifying which rows are of interest in the stocks data set the vector called look at is a boolean vector indicating which observations represent the ticker for the given iteration next I can create two statements calculus to low and highest high of these observations finally I need to store these values somehow I can start by initializing two objects lows and highs next I can use an append command to append a value on to the end of the vector alright I can run the code and print the results but something's wrong well I'd want to spot check some of my data anyways something bad has happened a value of na in R means that a value is missing and more generally oftentimes functions will return na if any of the observations are missing if I took a look through our data set I'd find that there are several observations with missing na values here I've checked how many entries in the column lo of the stocks data set are missing in many functions such as min and Max there's an optional extra argument that is useful for ignoring missing data the narn argument which I'll set to true in the min and Max functions now when I rerun the code I get sensible results I'd want to look at the data more carefully to see why some observations are missing but I'll leave this as a topic for another set of videos one final word even in this example there are other better functions that could have been used to get the same results much more quickly this would be important for code that should be implemented efficiently and I'll get to these functions in the future however for the beginning our programmer it's sometimes easier and clearer to simply implement a for loop lists are a special type of object that hold other objects I can initialize a list by simply using the list function I can create items in the list by providing arguments to the list function what is important to understand is that a list can hold objects of all different types in this example the first object is a numerical vector of length 5 second objects is a character vector of length 1 and a third object is a boolean vector of length 1 if I wanted to access an item I use the subset in a double bracket I can also add on new items even providing the character name for the item when a list has named objects those objects can be accessed using a special dollar sign notation but is reminiscent of the same notation for data frame Liss also aren't restrained to holding just vectors they can also hold matrices data frames and even other lists lists are so powerful since you create helpful ways to organize diverse sets of data or results oftentimes I have many groups of data and would be helpful to calculate statistics reach I might organize these statistics using a list I'm going to load it in the stock data just as we have in the last couple of videos my goal will be to create a summary of the prices for each stock I'm going to do this using a for loop the first line in the for loop will identify the rows of interest the second line will calculate the summary and start an object called stock summary I also shouldn't forget to initialize a stock summary object here as a list finally I can take a look at the results not surprisingly there's a lot to look at if I wanted I could look at a specific summary for a particular stock say Google's stock what I've done here in just six lines of code is very powerful I've calculated summaries for every stock in data set and this code works regardless of if I have five stocks or five thousand stocks in other instances I might choose to do something even more complex like fit a linear model to the data for each stock separately even in that complex case a list can be used to store the result I noted in the last video that is a become more familiar with our you'll find out that there are more helpful functions to do operations commonly done in for loops this is also true with this example which could have been written much more compactly using some additional functions some of these functions we'll encounter in the next section like the function is buy and apply great work on making it through the second section of videos take a short coffee break practice what you've seen and then get started on the third section writing your code into our scripts is valuable for managing or organizing our objects but sometimes you may wish to clear some objects from your workspace to get a look at what objects exist in your current workspace use the LS function if you want to remove an object use the remove function with the argument name as the object to be removed if you want to remove all the objects in a workspace you can use the list argument in the remove function and specify all the objects in the workspace using the LS function it's also helpful to be able to easily convert between objects of different types will consider three functions for converting objects to numerical character and factor object types for instance we can apply each of these functions to the object X applying the as character and the as factor functions back to the outcome had I wanted to actually change X to say a factor I could have assigned the new result tax one special note here if you have a factor variable that also looks numeric always convert it to a character before converting it to numerical value there are other comparable functions that you may occasionally find useful such as as matrix as data frame and as list one last functional considering this video is the unlist function in the usual process of data analysis I might create a list to hold summary results of an experiment here I'll construct a list manually for four groups in this example you can think of the first number for grouped represent its corresponding sample size the second number might represent the average response for that group and the third value might represent the standard deviation for the group just a side note worth mentioning I typically perform these types of calculations in an automated way which would make it easier for the code to be scaled to an arbitrary number of groups if you need to refresh her on this topic look back to the fifth video in section two all right so the results are stored in a list where each list item represents the results for a single group if I unlist this object I get a vector of the unlisted results it would actually more useful to hold this object as a matrix or as a data frame so I'll form these unlisted results into matrix if I'd prefer a data frame I could use the as data frame function applied to this matrix if I wanted I could also adjust the column names of the data frame using the names or the column names function in the next video we'll explore the family of apply functions which are helpful for applying a function across the rows or columns of matrix or across the elements of a list the apply function and its variants are useful for applying a function across an hour object we'll consider two variants of these special class of functions apply and T apply and we'll also look at the by function I'm going to start by loading in a new dataset website revenue for the month of March for ten businesses I've used the argument header equals false because there are no call names stored in this comma separated values file the data in this data matrix have been stored in a slightly unorthodox way each business is represented as a column and each row represents a day in order of March 1st through March 31st so for example on March 3rd the 10th business made $23.98 it might be helpful for me to take a quick look at how the businesses are doing by taking a look at their total revenue I could take the sum for each column using a for loop and store that result in a vector but this would actually be inefficient instead I should use the apply function which will be more compact and also run faster with larger data sets the apply function is useful for applying a function across the rows or columns of a data matrix that is I might want to apply a function across each row separately or across each column separately the first argument is the data matrix itself the second argument is the dimension number over which to apply the function rows are represented by number one and columns by number two think of the second argument as specifying the dimension that you actually want to retain the last argument is the function to be applied in a similar way we can also compute the total revenue for all the companies on each day of the month by applying the sum function over each of the rows notice that there are some missing observations if we would look into the data more carefully we would find that there are two missing values each in the third column if we know that it's okay to omit these data we can tell the sum function to ignore the missing observations using n/a remove equals true the apply function passes this argument on to the sum function generally any extra arguments to apply will be passed to the function you specify in the third argument in this particular use case we probably should want to investigate the missing observations rather than simply ignore them also just a technical note for this application of apply I could have used either their call sums or row sums functions all right onwards the second function T apply to help explain this new function I'm going to load in a second data set that summarises eBay auctions for the Mario Kart video game for the Wii this is a tab delimited text file of the data so I'm going to read it in using read elimb to keep things simple let's focus on three variables wheels conditions and total price the t apply function is similar to the apply function in that it helps aggregate data efficiently for instance we could examine the sum of all the total prices of auctions that were new and used separately by providing the vector for the total price as the first argument the vector for the conditions is a second and then the sum function as the third just like an apply the third argument for the t apply function is another function to be applied across the data however in this case the function is applied to each group where the groups are specified by the second argument which in this case is the condition of the game I'm going to modify this command a little bit since it makes more sense to look at the average price of the game as you might have anticipated the games that are new tend to sell for more than the games that are used here the difference is about ten dollars there's a second important variable in this application that relates the price the number of steering wheels that come with the game in the auction these steering wheels are game accessory that make playing Mario Kart a bit more fun let's look at the average price of the auctions with different numbers of wheels included as you might expect we again see a steady increase in price associated with having more wheels included in the auction about six to ten dollars per wheel now there's something interesting to think about here if I consider the influence of both price and the number of wheels simultaneously what will this do to the estimated cost of a new game versus a used game and also the cost of an extra wheel a table to look at the average price across each of the combinations of condition and wheels can be made using the T apply function to do this I'm going to provide the data frame with just the condition in the wheels columns as the second argument some of these numbers will look a little bit surprising for instance going from no wheels to one wheel doesn't seem to influence the price and then the game is new if we dig in a little more here using length function in place of the mean function I can see that one of the groups had very few observations and so this average is probably less reliable and this might explain the difference if I was going to continue this analysis I'd probably look into this some more one last function before we wrap up the buy function is a variant of the T apply function but by default it returns a vector of the results note that when it is printed it won't really look like a vector that you could access the elements just as if it was a vector in the next video we'll take a look at three functions with within and aggregate in this video I'll take a look at three functions with within and aggragate to explore these functions I'm going to load in the Mario Kart data set the width function can be used to access variables in a data frame with ease this is especially important when the name of the data frame is long and multiple variables are being accessed for a calculation I can read this command as with Mario Kart compute the total price minus the shipping price the width in function is similar to with except that it's easy to create new columns and merge them with the original data set for instance here I'll add an auction closing price to the data frame and store the result in a new data frame called m'kay notice that the commands to generate the new variables goes inside braces as the second argument if I had wanted I could have added multiple variables by creating more variables inside of the braces as you can probably guess the width function is useful for oneoff calculations well within is useful for expanding a dataset to include new variables when I want to aggregate or summarize results I often use the aggregate function here I'll aggregate cross the number of wheels and the condition variables the first argument is a formula the dot on the left side of the tilde means keep all the variables for the output and the variables on the right side separated by a plus sign indicate which variables to aggregate across the second argument is a data frame and the third argument is how to a great the variables had I only wanted to aggregate across one variable say the total price I could have replaced the dot with the total price variable notice the similarities between what the aggregate and t apply functions produce which you should use depends on what you will use the output for congratulations you finish section three the next section will introduce how to write your own functions building functions in hours a key skill that we'll cover in this section of videos in this first video the basic structural function will be introduced in the context of reporting both the mean and the standard error of a data set I'm going to start by creating a test dataset called D here D is a sample of 25 observations from a Poisson distribution with 8 degrees of freedom next I'd like to ensure that my test dataset is stable so if I rerun my code I'll get the same kind of results I'm going to do this using a set seed function now if I regenerate my data and multiple times I get the same test data set now on to the general structure of a function I'll start by carefully choosing a function name here I've thought about this ahead of time I'm going to call it get mean and standard error next I'll assign a function object to this name using the function declaration I've provided a generic argument X to represent the data and I'll use braces to contain the code to be executed using the arguments I'll compute the mean the length of the data set and the standard error of the mean inside of these braces presently the function identifies the mean and it's standard error however the variables m and se only exist in the scope of the function so when I run the function I don't actually get any results what I need to do is add a return statement now whenever you run the function the mean and the standard error will be returned this new function can be helpful however its present output isn't actually ideal it would be nice to make explicitly clear what each of the outputs is from the function in the next video I'll expand the function and take a look at this challenge the function in the last video is used to report the mean and the standard error suppose I wanted to also report a 95% confidence interval for the mean here L can start a confidence interval the Qt function is used to identify the ninetyseven point fifth quantile of the T distribution with n minus 1 degrees of freedom there might be some temptation to concatenate the confidence interval with the current results being reported from the function in some instances this might be fine but it isn't a very clear way to organize the results for example what if another user mistakenly thought the first two values with the confidence interval and last two were the mean and the standard error that could be disastrous when multiple objects are being returned from a function it's usually helpful to return them in a list but even now things might still be a little bit unclear for this reason it's useful to add names to each element of the list and before I forget I should update the name of the function I'm going to name it get CI for get confidence interval there's one more change I want to make before moving on making the function slightly more general by allowing for a different confidence level I'm going to do this using a second argument called level sense the 95% confidence level is so commonly used I'll so spy 0.95 confidence level as the default next I need to make some slight adjustments the body of the function to make use of this new argument I can compute the upper percentile for the confidence interval then provide this as a substitute for 0.975 now I can run the function without specifying the level to get a standard 95% confidence level or if I want a different confidence level say 99% I can easily make that request suppose the user input a value for a level of 99 rather than 0.99 for the level argument in this application it would be nice if the function failed elegantly and communicated why there was an error rather than simply reporting a warning this will be the topic of the next video providing clear feedback to users is one part of building great functions I'm going to take a look at the function from the last video that was used to compute a confidence interval for the mean using the sample of data what if a user provided a percentage instead of a proportion for the confidence level currently the user simply gets a warning and the reason behind the warning isn't going to be obvious to new our users instead it'd be helpful to stop the execution of the function and clearly communicate what is wrong I'll do this by stopping the function if the level of the argument takes value less than zero or greater than one to stop the execution of a function and return an error use the stop function the argument if the stop function is a character string to communicate why the air was generated here I'll communicate that the level variable should have been represented by a proportion between 0 and 1 now when a user inputs a level value that is invalid it stops and returns an error I'm also a little concerned that a user might provide a level that takes value like 0.05 or 0.1 they might think they are supposed to provide a significance level rather than a confidence level if the confidence level is smaller than 0.5 I'd like to warn the user that they should rethink their input I can do this using the warning function in the next video I'll introduce how to pass an arbitrary number of arguments to a function in this video I'll cover how to pass arguments to existing functions inside of functions you are creating to do so I'll use the website Revenue data highlighted in the last section I'd like to create a function that summarizes the revenue and other objects like it I'll call the function Rev summary it'll take just one argument that should be a data frame or a matrix where the rows represent days columns represent different websites and the entries represent revenue for the websites on each day I'll build in a simple check to make sure that the data object comes in in a form of a matrix or a data frame if it doesn't then I'll provide a suitable air next I'll calculate to summaries the average revenue per company and the average revenue per day for the companies in a previous video I use the apply function for this but here I'll use two functions and are specifically built for taking the mean across rows and columns row means and call means I'll return those results in a list with two items that we returned at the close of the function mean revenue per company and mean revenue per day finally I'll apply my new function to the revenue data when I execute the function I get a list back as expected however there are some n/a values that indicate that some data are missing here al dente' Phi which observations in the revenue data are missing using is n/a function together with a which function and an additional argument array index equals true the first is for the 12th day and the third company the second is for the 13th day and the third company it's possible that some end users of this function including myself may occasionally want to have such observations omitted from the calculations in the functions using an n/a argument similar to how we've seen this argument used with other functions however this n/a remove argument would need to be passed to both row means and call means this is fine but it's actually a little bit more generalizable to accept an arbitrary number of arguments we pass to these functions I can do this using an ellipsis in rev summaries declaration this allows the Rev summary function to accept extra arguments not specified in the function declaration next I indicate which functions should receive these X arguments since my intention here is to allow users to pass the n/a a remove argument to row means and call means I will add an ellipsis to the end of each of these functions now if I pass any remove equals true into the rev summary function this argument we passed the row means and call means functions which will then remove the any values from the calculations note that if you want you may access the arguments from the ellipsis in your function using the list function with an ellipsis as its argument in this way you may also write functions that allow for an arbitrary number of arguments and then access all of those arguments and list what's been covered in this video is how to easily pass additional arguments inside your functions and how to access those extra arguments using the list function in the next video I'll show how to hide function output that might flood a user's screen and we'll also cover a useful tool for building recursive functions which are functions that call themselves in this video I'll show how to make output invisible which is helpful when I'll function is a large output and I'll also cover how to use a function recursively if your function returns a lot of results it might be a bit obnoxious when a person forgets to assign the output to an R object if you think your output is likely to be annoying when it's printed out you can use the invisible function in place of the return function then when user fails to save the result to an R object their console will not be flooded with output and if they do assign the output to an object the object will store the result that said invisible output can confuse users so use this trick with caution it's also worth noting that using classes and methods inside of R is another way to address this challenge however classes and methods aren't topic I'll cover in this video and one more tip before we move on to recursive functions if you happen to flood your console screen or if you simply want to clear the console if you're on a Mac use command Alltel or if you on windows control l which will clear your console screen all right on to recursive functions a recursive function is a function that may call itself for example I can create a function called log me that takes the log of a value if the value is larger than 1 and keeps doing this until it gets a value that's less than 1 if the value is less than 1 then the function simply returns the result the way the code is written works but what if I happen to change the functions name I would still want the function to call itself to make sure it does I should use the function called recall which automatically calls the function it's in in general using recalls the preferred way to build recursive functions in our in the next video we'll look at how to use a custom function with the apply function in the last section I talked a bit about the apply family of functions these are very powerful functions for applying the same function across many sets of data they're even more powerful when combined with custom functions to begin I'm going to create a sample object X that's a matrix with 1000 rows and 10 columns containing 10,000 random draws from a Poisson distribution with 8 degrees of freedom if you recall I could easily to apply a function across each row or column here I've calculated the mean for each column if I wanted I could also create a custom function on the fly that calculates the standard error of the mean using each column separately note that here I've omitted the prices for the function declaration I did this since the function can fit on one line but I could include braces if I liked this inline use of functions is very useful since it allows you to apply simple custom functions on the fly it's also common to make complex functions and use them in a third argument of apply here I'm going to first load in the get CI function then I'm going to call it inside of apply you might recall that the get CI function actually returned the list the apply function adapts its output to accommodate complex outputs by the function being applied sometimes they'll return a vector other times the matrix and other times the list here since get CI outputs a list the best way to represent many outputs of that function is to contain them in a sort of super list this completes the fourth section of videos take some time to try out what you've learned in these first four sections of video browse online for some data or acts some of these datasets that are already present in your accession
