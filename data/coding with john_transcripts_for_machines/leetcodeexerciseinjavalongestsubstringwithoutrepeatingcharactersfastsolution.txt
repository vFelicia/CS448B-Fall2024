today we're going to be solving another lead code coding exercise this is going to be an interesting one to find a fast solution for and I'm also going to talk a little bit about the thought process behind coming up with the solutions for these sorts of problems but first thanks to mailgun for sponsoring this video mailgun is how modern companies work with email mailgun is easy to use has amazing 24 7 customer support and simple but powerful apis that smart developers can use to reach their customers at scale so their organizations can grow faster you can use mailguns API to send an email with just a few lines of code with whatever language you're using of course including Java it really couldn't be easier today mailgun is used by over a hundred thousand companies and top brands around the world to provide personal connected experiences through email and drive smart results you can send and track transactional and marketing messages remove invalid emails from your list or prevent fake signups in the first place easily mailgun also has an awesome send time optimization feature that automatically finds the perfect time to send to each and every individual on your list at the exact time that they're most likely to engage they also have a team of email experts ready to work with you to improve your email deliverability and also Drive higher conversion rates with its intuitive email Marketing Solutions and Powerful API mailgun Works through the whole email lifecycle from predevelopment all the way to the inbox for more than 240 billion emails a year for companies like Wikipedia DHL toast Lyft and Microsoft helping them solve complex communication problems and build connected experiences through email so thanks again to mailgun for sponsoring this video try mailgun today by using my link which you can find down in the description mailgun.com John now let's get to it so this is lead code problem number three and it's a medium difficulty problem it's called longest substring without repeating characters so basically we're going to be given some string we'll call it s and our task will be to to find the length of the longest substring within that string that doesn't repeat any characters so they've got a few examples here so if our input string is a b c a b c b b well the longest substring within this string that doesn't repeat any characters is just ABC so if we were looking through this string we would go okay A B C all right we haven't repeated any characters yet and so far we've got a substring length of three but if we were to try and add the next character well that's an A and we already have an A so that's not a valid solution so the longest substring without repeating characters in this example is ABC and that has a length of 3 and so our output would be three one thing to note about this example is that technically the solution could have been BCA also or c a b those are also substrings that don't repeat any characters but they also just have a max length of three anyway so it doesn't change what our output is still the longest substring that doesn't repeat any characters in this string is just three so if we scroll down to the bottom here we can see that we have a couple of constraints on the string input that we're going to receive so one thing is that it'll only consist of English letters digits symbols and spaces that just means there's nothing really crazy for us to deal with as far as the characters go and it also says that the length of our string is going to be greater than or equal to zero so we won't have a negative number of characters in our string and the length of the string will be less than or equal to 5 times 10 to the fourth okay Elite code you're trying to be real fancy there with the scientific notation this is just fifty thousand ten to the fourth is ten thousand times five is fifty thousand and that really shouldn't be big enough to cause any sort of problem with any kind of solution that we might come up with as far as memory goes or anything like that so let's start thinking about the solution for this problem so with a lot of these leak code problems there's often like a Brute Force solution that most people come up with first and then often there's a more clever answer that's a little bit more tricky to come up with but leads to a much more efficient and fast solution now the same thing is the case here so to start let's look at an example string that we might be given and talk about what our Brute Force solution to this problem will look like basically we're just going to Loop through every single possible substring of this string until each of those substrings repeats a character and then keep a running maximum of the largest substring that we find that doesn't repeat any characters that might sound a little bit confusing so let's just walk through a quick example of what it's going to look like so what we'll do is start by looking at all the substrings of this string that start with the first letter A of course just the letter A by itself has no repeating characters so as of right now the maximum substring that we found that doesn't repeat any characters is of length one and then we say okay we haven't run into any repeating characters yet let's add the next character to our substring and the next character is B so now our substring that we're looking at is a b and so we say okay we're adding B does B already exist anywhere in our substring no it doesn't so there's still no repeating characters so now the maximum substring that we found that doesn't repeat any characters is of length two next we go ahead and add the C to our substring the C already exists anywhere in our substring no so we still don't have any repeating characters in this substring so our new maximum is three so next we look at the next character which is a does a re exist in our substring yes it does so now this substring contains repeating characters and so it doesn't count as a valid substring that we're looking for so now that we've run into a substring that has a repeating character we know that the largest substring that starts with this first a that doesn't repeat any characters is just a b c you know that has a length of 3. so next we have to look at all the substrings that start with the second letter of our string b b by itself doesn't contain any repeating characters but it's only of length one which is not greater than three so our maximum is still three and then we move this over to include c b c also doesn't contain any repeating characters but it only has a length of two so it's not bigger than the maximum we already have so we move over and look at BCA it also doesn't have any repeating characters but just has a length of three so there's no need to change our maximum and then when we move this over to include B now we have repeating characters and this isn't a valid substring anymore so then we move the beginning of the substring that we're looking at over to the C and do the same thing all over again so that would eventually get to c a b with no repeating characters which is still just a length of three and then when we add on the next C it now has a repeating character but then we will move on to starting with this a and this can proceed all the way to the end of our string without repeating any characters a b c d has a length of four and doesn't repeat any characters so when our program sees that it will update this maximum to four and then it'll Loop through all the rest of these characters in exactly the same way but it won't find any nonrepeating substring that's any longer than four which is this a b c d and so we'll find that the solution is four so next let's go ahead and copy this over to IntelliJ so we can do our coding there and let's get to implementing that Brute Force algorithm so first a good thing to have is just going to be an INT variable a max length that we're going to use to keep the maximum length of the nonrepeating substring that we've identified so we'll eventually return that as our solution and we'll initialize it to zero next we're going to want a loop that will look through each individual character of our input string and use each character as the start of the substring that we're looking at and we'll just keep that simple and use a for Loop this will be a pretty simple for Loop so for INT I equals zero we're going to keep looping while I is less than s dot length and each iteration through the loop we're going to increment I but now nested within that as We're looping through each character in our string being the start of each substring that we want to look at we then have to have an inner loop that adds on each subsequent character to our substring and you know keeps doing that and adding characters until we find one that repeats so in order to do that we're actually going to need a nested for Loop within this one or int J we'll call it and we'll actually start it not at zero but we'll initialize it to I because we don't necessarily want to start our inner loop at the very beginning of the entire string we want to start it at the beginning of the substring that we're looking at and that will always start with the ith character we will still Loop while J is less than s dot length we'll go to the end of the string with our inner loop as well and in the Inner Loop we will increment J each time but actually just within our outer loop we want to create something that we can use to build our substring something that for each iteration of our inner loop we can add to in order to build the substring that starts with a certain character now there's a bunch of potential ways you could do this but one decent way is with a string Builder now string Builder if you've never used it before is kind of what the name of it says it's an object that you can use to build strings and often we'll use it in situations like this where we want to add to a string in iterations through a loop so here we'll create a string Builder and call it let's say current substring we'll just initialize it to a new string Builder so now what we're going to do is in each iteration of this inner for loop we're going to be adding each subsequent character to the substring that we're building and along the way as we're building the substrings as long as the current substring we are looking at doesn't have any repeated characters we're going to be seeing if it exceeds our current max length and if it does we will update the max length to be the current large substring that we're looking at and we're going to keep looping through adding the next character to the substring that we're looking at until we find a repeated character and then once we find a repeated character we're going to break out of this inner for Loop and then start looking at every substring that starts with the next character in the string so for example as the outer loop is looking at this first character a our inner loop is going to be looping through each subsequent character after that a adding it to the substring that it's building that string Builder that we created it and it's going to do that until it adds a character that it identifies as being a repeat and so when we do find a character that repeats like that the outer loop is going to increment by one and we are going to start looking at all substrings that start with the next letter of our string and then our inner for Loop is going to do the same thing it's going to use that string Builder to add on each subsequent character in our string onto the string Builder until it identifies a repeat character so here's how we're going to implement that functionality into our inner for Loop first we're going to check whether the next character that we're about to add on our substring already appears in our current substring and if it does well we have a repeated character and we want to break out of our inner loop to do that we can say if so what we'd like to do is take our current substring and see if it already contains the next character that we're about to add to it but unfortunately string Builder doesn't actually have a contains method that just returns a simple Boolean so what we have to do is instead we have to call the index of method on it so the next character that we would add to the substring is the character that's at the jth position in our original string and so to get that we can just call s dot Char at and then pass in the index we're looking for J now again unfortunately this index of method can't take a character you have to pass in a string but luckily it's easy to convert a string to a character all we have to do is call string dot value of and then pass in our character like this so now what this index of call will return is it will return the position of this next character that we're about to add in the current substring if it already exists there and if it doesn't already exist there it it'll return a negative one when it returns a negative one that's its way of telling us I didn't find that character in this string Builder what that means is if the index of this character is anything except for negative one that means that that character already exists in our substring and we have a repeated character and as we said once we find a repeated character we want to break out of our inner for Loop so that is accounting for the situation where you know we're adding more things to our substring making sure there are no repeated characters but then once we do that and we're about to add a character that would be a repeat so in this situation when we're about to add an A but we already have an A that would break out of our inner for Loop and then it would start looking for substrings that start with the next character in the original string however if it gets past this point then we know that the next character that it's about to add is not already in the current substring that we're looking at so in that case great let's go ahead and add it to the current substring that we're building and to do that we just call current substring dot append and we want to append that same character at the jth position of our string so all this append method does is take the character that we're passing in and add it onto the end of our current substring so now we know that the current substring that we're looking at doesn't have any repeated characters so what we want to do is if that current substrings length is greater than the current maximum length nonrepeated substring that we found so far then we want to set our max length to be the length of our current substring current substring dot length kind of a cooler way to do this though instead of having to okay let's check to see if the length is greater than the max length and if it is then we'll set the max length to be that one that works just fine but if you want to be really cool about it instead you can do something like Max length equals math dot Max and then pass in as the two parameters the current max length and also the length of the current substring and then you can get rid of this because this line of code is doing the exact same thing this math.max method will just return whichever one of these two parameters is larger so what that means is if the maximum length is already larger than the current substrings length it'll just get set to that max length again but if our current substrings length is larger then it will set max length to be that instead so it's just a little bit more of a concise way to do the same thing so then after all of that after it does all those Loops through all the possible substrings and maintaining that maximum length of the nonrepeated substring that it finds at the very end of this method we actually have to return that maximum length that we found I think that should do it let's go ahead and copy this solution and paste it back over here into leak code and submit it and see what happens okay here we go alright so we see that our program is successful awesome right well yes but let's look at some of these facts here so our run time was a 433 milliseconds which says it's faster than 5.94 of all Java submissions for this problem that's not great right that means that 94 of all Java submissions for this problem were faster we're more efficient than our solution from the last leak code video I heard that a lot of people struggled with techniques for coming up with a faster more efficient solution to these sorts of problems now what should I consider what kind of things should I know how should I even start thinking about it so first let's talk about why our current solution is probably so slow so what we're doing in our solution is We're looping through each character in the string and then within that Loop We're looping through each subsequent character in the string so to do that that meant that in our algorithm we had to use a nested for Loop to do that so that means that the time complexity the Big O complexity of our algorithm is going to be Big O of N squared usually when you have in your algorithm a nested for Loop that Loops through your data set in both of those Loops usually that means that you have a quadratic time complexity a big O of N squared so literally like the bigger that this string s is that gets put into our program so as that s gets larger and larger with just a little bit of increase to the size of our input our program will take dramatically longer to run so what we want to do to try and make this run faster is to of course just lower the time complexity of our solution now that could mean a couple of things there could be various ways to do that but the main thing in this situation what we want to do is get rid of this inner for Loop one way or another if at all possible so if we can accomplish our task just by looping through our string one time then that's what we want to do but then of course we have to think well how can we do that there are a few things that you can keep in mind when you're trying to come up with that sort of a solution a big part of what you want to keep in mind is just the different types of data structures that you have available to you so that could be things like lists cues sets Maps trees and and knowing how each of them work what they're all useful for and the properties of each of those helps you to know what could be helpful to use in various situations but honestly a lot of it is just doing a whole lot of these challenges coming up with your own Solutions and when you struggle look up what other people's Solutions are and what they came up with see which ones are faster and try and understand why but for this specific problem what do we need to do in order to be able to get the solution with one pass through our string well we need to know the whole substring that we're looking at at any given moment but we also need some way to determine at each character in our Loop whether that character already exists in our substring but we want to do that without looping through all of the other characters in our substring because then we'll be right back in the situation where we have that inner loop now one way I can think to do that is with a hash map and we actually did use a hash map in kind of a similar situation in the last leak code video in this situation we can use a hash map to remember the index that we last found each character that we run into in our string so it'll be a map where the keys are the characters that we find in our string and the value associated with each of those keys with each of those characters is going to be an integer that represents the last position that we encountered that character here's what I think we can do let's walk through an example so in this case we'll actually use two pointers don't worry we're not going to use two for Loops but we are going to use two pointers a left pointer and a right pointer and we're going to start with both of those pointers pointing to the first character in our string so right now our substring is just the Single Character a we look at that character and we say okay does that character exist in our map yet and of course our map is empty we haven't done anything with it yet so no it doesn't so that tells us that there's no repeats in our current substring so what we can do is we check the length of that substring which happens to be just one there's just one character and then we go ahead and set our Max to one but then before we proceed we add that character we add that a to our map so what we're saying in our map is the last time I saw the letter A it was at position zero so a is the a key in our map and 0 is the value so what this means is later if we encounter the letter A again we can just look it up in our map and say oh the last time that an a appeared was at position zero and then we don't have to Loop through the entire string to find that out we can just do a constant time lookup in our map so that map is going to be the key here the map is going to be how we're going to essentially get rid of our inner for Loop and improve the time complexity of our algorithm so after we add the a to our map we then go to the next iteration of our Loop but we don't move the left pointer we only move the right pointer so that increments to the next character in our string so what we do first is we look up B in our map does it exist in our map no it doesn't so that's cool that means we don't have any repeated characters so we look at the length of our current substring which is 2 so we can update our maximum substring length to B2 and then we want to do the same thing we did before and we want to add B to our map now so we'll say okay the last time that we encountered the letter B it was at index one and then we moved to the next iteration of our Loop and the same thing goes for C is C in our map no it's not so we update our maximum to 3 because that's the current length of our substring and we add that to our map as well the last time we saw C was at index two and then we move on to the next iteration of our Loop and we look up a in our map does a already exist in our map yes it does so that means yes we've seen it before but another thing that we do want to check is did we see it before inside the current substring that we're looking at and we can know that pretty easily just by checking the index where we've seen it before so in our map we look up a and we say oh that a was last encountered at index 0. and we can see that judging by our left and right pointers our left pointer is at position 0 and our right pointer is at position three and that means this a at index 0 is within our current substring so because of that we know that we definitely have a repeating character inside our current substring so we have to fix that before we move on we have to set our substring to be something that doesn't contain a repeating character and we actually fix that by moving our left pointer so this is the situation where we do move our left pointer so we're looking at an a currently with our right pointer and we can see okay the last time we saw an a was at index 0. so in order for our current substring to no longer contain that repeating character we're going to move our left pointer to be one past where we last saw that letter so we'll just do this so now we've shifted that substring that we're looking at to where we now know that it no longer has that repeating character now before we move on we still want to update our map because now the last time that we encountered the character a was not at index 0 and now we last encountered it at index three now as before we move on to the next iteration of our Loop which means moving the right pointer one character over so now we're looking at the letter b and we look that up in our map to see when we last encountered it and we last encountered it at the index one and one is within our current substring also so that means okay our current substring has repeating characters and so what we want to do is move again our left pointer to one past where we last found that character so our left pointer will move over here and then again same as before we still have to update our map to show that the last time we encountered B was at index four now in the next iteration of our loop we're looking at the letter c c does already exist in our map and it's in index of 2 is within our current substring so we want to move our left pointer to one past that to make sure there's not a duplicate and update our map to show that the last time we encountered a c was at index 5. and then we'll iterate through our loop again to uh for our right pointer to point to the letter D does d exist anywhere in our map no it does not so we know that our the current substring that's contained within our left and right pointers does not have any repeating characters and it has a length of four which is bigger than our current Max so we can update our Max to be four and it will go ahead and add that D to its map also it'll say okay the last time we encountered a d was at index six but at that point the right pointer has reached the end of our string and so our Loop finishes and our program finishes and we get the solution that the maximum was for one thing to notice about this particular solution is that it as it's going through the string there's always a particular section a particular window that we care about at any given time and it kind of slides right and grows and shrinks as it processes the string and there's actually a name for that kind of algorithm called a sliding window algorithm that's why if you're looking up solutions for this problem you'll see a lot of things about a sliding window algorithm and also notice that even though we do have two pointers we only have one Loop through the string and that makes this algorithm a linear time algorithm or a big O of N and also since we'll be using a hash map to do the lookups for the last time we encountered each character those lookups will actually be in constant time so they won't affect the linear time complexity of our algorithm so now let's go ahead and implement this sliding window hashmap algorithm and see how much faster it is all right so we're going to get rid of a lot of this but we are going to keep our max length variable declaration and our outer loop we still need that but we are are going to change a couple of things about this Loop to make our code a little bit easier to read with how our algorithm will now work so instead of just calling this variable I let's call it right because it's going to represent the right pointer in our algorithm so we'll change I to right in each of those places and also if we want we can go ahead and declare our left pointer here also and have it start at index 0. but remember we'll only be changing our left pointer if we find repeats while we're processing substring we only want to increment the right pointer in every iteration of our Loop now remember as a part of the solution we need to have a map that will hold the last position that we saw each character so let's create a map and remember this is going to be a map where the keys are characters and the values are integers we'll call it I don't know visiting did characters that's not my favorite name for a variable that I've ever come up with but let me know if you have a better one in the comments we're going to initialize that to a new hash map so now inside our for Loop where We're looping that right pointer through the string we want to check whether the character at that right pointer is already in our map so we can do that with if visited characters dot contains key and then passing in the character that's found at our right pointer so that's just s dot Char at right one thing to remember though is that even if we find the character that we're looking at is already in our map it doesn't necessarily mean that that character is within the current substring that we're looking at so once we find it in the map we still have to check whether the index that we found it in the map is actually a part of our current substring but luckily that's not too complicated to add so we just want to add another condition to to our if so yes we've already found that it's in the map but we also want to get the index where we last encountered that character so we'll get s dot Char at right and we can know if it's a part of our current substring if the last place that we found it is greater than or equal to our left pointer and if this whole condition is met if the result of this whole thing is true that means yes we saw this character before and it's within our current substring so our current substring has a repeated character and remember if that's the case then we need to move our left pointer to be one past where that repeated character is we can do that just by setting our left pointer to be the position where we last encountered that character so visited characters dot get s dot Char at right and we want it to be one more than that so we get just past that repeated character so we just add one now one thing I'm noticing as I'm writing this algorithm is that I'm using this s dot Char at right three times and it's kind of starting to look a little verbose so I think what I might do is create a variable for this so I'll go ahead and create a Char variable we'll just call it current character and we'll set it equal to that s dot Char at right and then we'll go ahead and replace everywhere we're making that call with that variable there we go so now it's a little bit easier to read and also might perform just a little bit better because it doesn't have to do this lookup three different times so at this point in the algorithm we know that either the substring that we're looking at either didn't contain any repeat characters so it didn't have to adjust the left pointer or if it did contain repeat characters it did adjust the left pointer so that it no longer has any repeated characters so now what we can do is update our max length and we can do that in the good old fancy way again by using a math dot Max and we'll take the maximum of either the current max length or the length of our current substring and we can get the length of the current substring that we're looking at by using our left and right pointers so what we can do is take right minus left and then add 1 to get the current length of our substring adding one might seem a little bit weird but it makes sense if you think about it because let's say right and left were both pointing to the same index they were both pointing to an index of zero the very first character well that of course has a length of one but if you took 0 minus zero you'd have zero and that's not correct so you have to add one to right minus left in order to get the correct length of the substring that you're looking at now the only other thing that we have to do is we don't currently have anything that's actually putting the characters that we encounter onto the map we still have to do that so after all this processing we want to put on the map okay here's the last place that I saw this current character so we'll just call visited characters dot put to put a thing on the map and the key that we're putting on the map is going to be the current character and then the value is going to be the position where we're encountering that current character and that's just the right pointer okay so after our for Loop exits we'll just return the max length that doesn't change from our last algorithm I think that should be it so let's go ahead and copy this over paste it into lead code and we'll see if this is any faster so here we go okay so uh we have 12 milliseconds so we went down from what was it 400 something milliseconds down to 12. that is a dramatic difference it's a huge difference and that's probably largely because the complexity of our algorithm went from quadratic to linear and we also use quite a bit less memory maybe less than half of the memory that we were using before however you might notice that it looks like there's still some room for improvement of our algorithm of course we're way faster than what we were before but we're only faster than about twothirds of other entries there are still plenty of entries that are faster than this one so that was kind of bothering me that you know a third of solutions were faster than this one so I was looking up other potential Solutions and one that I found that did end up being faster than this really caught my eye and I wanted to share it now remember back in our code we're using uh this map of visited characters to look up when we last encountered a certain character now this other solution that ends up being faster is structured in a very similar way except it doesn't use a map at all and so of course without that map all this other code that uses that map doesn't really apply anymore but then of course you might ask okay well how are they doing that look up to see when we last encountered the the current character that we're looking at and actually it's done in a very simple way let's just call it this is an awful name but location of first appearance in substring so all they're doing with this is looking for the index of that current character that the right pointer is looking at so s dot Char at right but they're not searching through the entire string to see where that character first appeared they have it start at the left pointer and that makes sense right you only need to know if that character already existed just in your current substring not in the entire string and I guess a better name for this might be just index of first appearance in substring okay so now we know where this particular character that we're now looking at first appears in the substring that we're looking at and so all we have to do is say Okay if that index where that character is is different from the right pointer it exists somewhere already in the substring because of course it exists where the right pointer is pointing at right now but if it appears any other time then that means we now have a repeated character and so if we do have a repeated character we essentially do what we did in our other algorithm which is just move the left pointer to be one past where that repeat character was found so we'll set left to be the index of the first appearance and the substring plus one and other than that the algorithm is all the same we still set the max length the same way as we did before and return it at the end of the algorithm and that's it but let's go ahead and copy this and put put it into leap code and see what our performance is like here we go five milliseconds and that's better than almost 95 percent of all Java submissions so it's just about twice as fast as the other solution and of course if you submit this a few times you do get a little a little bit of variability in the amount of time that it takes so at that time it took four milliseconds better than 97.75 percent of all Java submissions um so that's really interesting it was it was faster than our map based solution so that really got me wondering why that might be and I'm interested um what you all think in the comments of why this particular solution is faster than the map based one the reason I think that's interesting is because our map should give us a constant time look up to see where that character last appeared in our substring but the way that they have it doing the lookup here in this solution is it has to use an index of and I believe index of just has to Loop through each individual character in the particular substring that it's told to look at to see if that character exists anywhere in there so I would think at a glance that that should give you a worse time complexity than the map solution but it performs much faster two three times faster than the map solution the only thing that I could think of is that even though the time complexity might not be as good technically as the map solution perhaps given the particular strings that leap code uses to test the algorithms it could be that just index of performs way better than Maps do for just for that particular input even though the time complexity isn't as good there are definitely situations and some algorithms where certain inputs could perform better on algorithms that technically have worse time complexity so this could definitely be one of those situations so even though I didn't come up with this particular solution I wanted to share it because I thought it was so interesting so as always let me know what you think if you like this video learn something want to see more things like this let me know and give the video a thumbs up and of course if you're interested go check out my full Java course which you can find in the link down in the description it's a great way that you can support the channel and get a ton of value and Java knowledge in return so thank you all so much as always for watching and I'll see you next time