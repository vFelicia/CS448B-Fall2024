hey everybody it's john from coding with john today we're going to go over something that i've seen bite so many developers and development teams that i've personally worked with something that probably all of you have used if you've worked with dates in java before is simple date format it seems to be just a very nice simple way to deal with dates and getting them from strings and turning dates back into strings and it is it works great in normal small single threaded circumstances but so i what i've worked with them uh we we're usually working on web applications which are multithreaded environments by default you can take in a bunch of different web service calls at a time so you have to it's by default running in a multithreaded environment so the simple day format class explodes in completely crazy unpredictable ways when you are in a multithreaded environment and we're going to go over the example of that here here's what you what we've got we've got a just a simple class simple date format is unsafe with a shared date format object uh a simple date format and here's the format year your year your monthly white this is whatever there's a format if you've done this before it should look familiar even if you haven't it should be pretty simple to see okay i've got a date formatting thing um excuse me object is going to format a date like this or taken a date that looks like this as a string and give you a date so awesome perfect um so now we start our main method and we're going to what's actually going to happen here is we're going to take this string of a date of an actual date and we're going to run 10 threads at a time just parsing that date just i want to parse this date a bunch of times but do it in a multithreaded way so i'm trying to do all of those at the same time i'm trying to parse this date 10 times at the same time in parallel so if you haven't worked with too much multithreaded stuff in java yet that's okay but but just briefly what we're doing here is this executive service is going to be used to offer those 10 threads to us to use so we're we're creating a new fixed thread pool of 10 so this is a pool of 10 threads that we can grab from and this is this runnable that we're defining here with this public void run method is just saying when i run this runnable here's what i want you to do and here we're going through a loop and 10 times running this runnable so all of that to say what this program will do is 10 times it's going to uh trigger this method in a new thread and so those 10 threads are going to be running in parallel in kind of unpredictable ways so but all it's going to be doing is parsing the this exact same date string 10 times and just printing it out it parses this date string as a date prints it out if there's an exception it goes oh no there's an exception and prints out the exception and so that's it you can just think of it as it's parsing this date in this format 10 times all at the same time but all using this one date format object not using separate ones all of them are using this same object this date format object so let's run it and see what output we get so cool at first glance it looks like this one may have worked okay look at it there's no exceptions it parsed out dates and printed them but if you look there's some really strange behavior so the first one looked great yeah as you can see this is you know um october 17 2020 at 12 30 4 51 and this first one is great saturday october 17th 2020 12 30 4 51 cool and it also goes like that for a while here and it's fine and then all of a sudden it says it's wednesday october 17th in 5100 and then it's and then these are all okay let's run a few more times but that you wouldn't expect that to happen right so let's run a few more times oh now we get an exception this time for an input string of something bizarre uh the ones that worked oh those seem to look okay but kind of as you can see each time we run it we get different behavior so this one everyone seemed to work okay so if you if this would have been our first run we might have thought everything's great but i'm going to keep running it mind you all all it's trying to do is print out the date that it creates from this date string and this one is even stranger there's an exception it's oh here's it successfully parsed it but now it's trying to take an input string of the empty string and it somehow came up with the year 17 here and it's saturday and it's monday and it's sunday and it's a different time it's obvious you get completely unpredictable behavior here and the reason for that is simple date format is not thread safe you can't use it a shared simple date format object across multiple threads that are using at the same time and have them be guaranteed to work properly the reason for that is due to some intricate weird old junkiness in the way simple date format parses dates as it's trying to figure out what the date is in this format it's it's taking individual things that it comes up with and populating them in instance variables inside this date format so what that means is essentially it's like once it decides oh this is the year i'll put it in the year thing in the in this date format object but in the meantime some other thread is also parsing that date using using this same date format object and messing up the calculations happening for the other running instance for the other thread so they're all stepping on each other's toes and tearing each other up because we're all sharing the same object for many kinds of classes if you have one same object like this that you're using across multiple threads they're coded in such a way to be thread safe that they don't step on each other's toes but simple date format is old enough it's been around since god knows when in java so it's not fred's safe you can't do it like this so what can you do to get around this hidden danger of thread safety and simple labor well to begin with this is such a it's such a dangerous kind of bug because it's so quiet there's nothing on here that that calls out there oh my gosh there's a problem and and unless you're you know if you're just running one or two or three threads at a time you probably wouldn't run this into this very much so for example if we change this to only do this three times we probably have a lot less of an opportunity to run into problems although we're still running into it pretty many times here but sometimes it seems to be okay but just gives you wacky dates so you could like be running this in real code in production just every once in a while you see some just wacky dates and you don't really know why it might be because of something like this whenever you see a shared simple date format object that isn't just created used once and thrown away flag it it's a terrible idea it's going to blow stuff up and it's going to cause you a lot of pain so now let's go over what we can actually do to get around that so number one a symbol change is just to instead of using a shared symbol date format object just instantiate a new simple date format object every time you need to use it so instead of having this private static final simple date format here at the top just create a new one here whenever you want do it so it's creating its own simple date format here and it's never going to step on anything else's toes always using its own simple date format it's only it's going to be operating in its own little tent so now if we run it as you can see they're all perfect and i can run it a whole bunch of times and we don't get any issues at all but um somebody might say that well that's a lot more like work for java to have to create that each time and that's that's it's false and it's true like it's in the big world of java this probably isn't that big of a deal to create this object nobody's probably ever going to notice that performance difference but still people are going to be like oh come on that just looks bad why are you creating that each time so what you can do instead is there's other classes that are offered that are thread safe that are pretty much interchangeable one of them is called fast date format so if we just want to change to use that fast date format and that's offered by um it's offered by apache common lang 3 so you're going to have to add that jar to your project or if you're using maven add it to your dependencies go online you can download that jar put it in your project and you'll be able to use fast date format the only little difference with it is instead of saying new fast date format this is not a valid constructor doesn't work so you have to do fast date format dot get instance and then give it that pattern that's the only difference there is and so now we've got this date format and we've got to change this code back so now it's the same it's all using the shared fast state format object but fast date format is thread safe so now let's go ahead and organize imports and give this a shot oh and we'll also go back to hitting it hard with 10 threads at a time and if you look we i can keep running it every time and perfect results each and every time no exceptions no weird dates so that's another great way to get around the problems with simple date format and multithreaded environment so if you were if you happen to work in a company and see somebody using a simple date format in an environment that's multithreaded maybe a web application maybe just some other kind of complex application that does multiple things at a time if you ever see anybody using a shared simple date format object red flags call them out on it you'll be the savior and if you happen to see any really weird behavior with dates keep an eye out for people using simple date format look around in the code that you're working with and see if anybody is using simple date format in a shared way like that if something is perhaps using a class level simple date format that's probably a good candidate for what could be causing your hidden problems so yeah thanks for watching if you like this video give me a thumbs up if you got some value out of it give me a thumbs down if not and tell me what you'd like to see in the future so until next time this is john with coding with john thanks for watching see you next time