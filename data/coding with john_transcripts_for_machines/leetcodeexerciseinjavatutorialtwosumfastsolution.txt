hey everybody so today's video is going to be uh just a little bit different we're going to be doing a leet code coding exercise i wanted to do this for a couple of reasons first uh programming exercises are just really cool and a lot of fun and second i think this is a great way that we can apply and solidify any of the java knowledge that you've been learning on your own or in my youtube videos or in my java course which as you know you can find down in the description below so go check it out okay so let's get right to it we're going to be starting with the very first lead code problem called twosum what i want to show in this video is the initial solution that you would probably come up with for this problem and how to do it but after that we're going to talk about a much faster solution that uses a different technique and a way of coming up with the answer to our problem and we'll see exactly how much faster it is and talk about why so the description of our problem is given an array of integers called nums and an integer called target we're supposed to return the indices of the two numbers in that array such that they add up to the given target and so literally over here in the code we are going to implement this two sum method and then as parameters to that method we're going to receive an int array called nums and an int called target and we're just supposed to find the two ins inside this array that add up to the target now there's a couple of restrictions and assumptions that they give us here we can assume that each input will have exactly one solution so that means we should always be able to actually find a solution there will never be an instance where we don't have two numbers in this array that add up to the target but also that we won't have two separate solutions and there's a rule that we can't use the exact same element in the array twice now our solution here will be returned as this int array return type so once we find the indices of the two numbers in our array that add up to the target we're supposed to return an array containing those two indices remember not the two numbers that add up to the target but the indices or the indexes of those two numbers in the array so they provide an example here of this being the nums array that's passed in so we have 2 7 11 and 15 with a target of 9. so the goal of our code is to find the two numbers or the indexes the indices of the two numbers in this array that add up to nine so of course we can see that in this array two plus seven equals nine so those are the two numbers that add up to nine but our output should be zero and one because those are the indices of two and seven in our array two is at the index zero it's the zeroth the first element in the array and a 7 is at position 1 in our array so we return an array of 0 and 1. now i like coding in intellij a lot more than i like coding in a browser so i'm going to go ahead and copy this over to intellij so that we can do all our coding and problem solving here and then once we have a solution we're going to submit it just go ahead and paste it into the browser and submit it there i'm also going to go ahead and paste in one example problem just so we can have something to visualize and talk about the way that we're coding the solution so probably the first the most intuitive way that you might come up with a solution the first one that i came up with is just a simple nested for loop so first in the outer for loop we would just loop through all the elements in our nums array and we can just do it like this so for int i equals zero we'll go while i is less than nums dot length and then increment i each time with i plus plus so here in our example problem our input array is 5 2 and 4 and our target number is 6. so this for loop that we've just made would start at the zeroth element of this input array and then just loop one by one through each element in the array until it reaches the end but now inside this for loop we want to have a nested for loop so here's what i think we can do we start with our i at zero the zeroth index of our array which is five so what we can do is loop through each number that's after that five in our array and then add it to five and see if we get the target number so first we could say okay let's take five plus two does that equal six no it does not so five plus two doesn't work next we try five plus four does 5 plus 4 equal 6 no now 4 is the last number of our array and so that inner loop will end and then we will increment in the outer loop so instead of starting with 5 in this next iteration of our loop we will start with two does two plus four equal six yes it does so we have reached our solution we know there is only exactly one solution so now that we have that solution remember that we have to return the indices of those two numbers not those numbers themselves so we won't return two and four will actually return one and two so with that said let's go ahead and implement our inner for loop here now usually in an inner for loop instead of using i you just use int j now what do we want to initialize j to here we don't want to initialize it to zero like we did for i and that's because we don't want to start by adding the first number to itself and we're not allowed to use the same element twice in our solution so instead of starting with the zeroth element in the array like our outer loop does let's start with whatever the current index that we're looking at in our outer loop plus one so for example in the outer loop if we're currently looking at the value here at index zero in our inner loop we want to be looking at the number at index one so we can do that by just saying i plus 1. however the next part is pretty much the same we do want to keep iterating while j is less than nums dot length so we're starting at one number past the number that we're looking at but then comparing that first number to every other element in the array all the way until the end and then to iterate in our inner for loop well we do the same thing with just j plus plus okay so now inside our inner for loop we have the two values that we want to add up to see if they equal our target so all we have to do at this point is just add the two numbers that we're looking at together check to see if it equals our target and if so return the indices of those two numbers so that's a pretty simple if condition so if the value at index i plus the value at index j equals our target number then we know that we have the solution that we're looking for and we just need to now return those indices and we want to return them as a new int array so we just say return new int array and the two elements of that inter array are going to be our two indices that we're looking at so that would just be i and j so that's pretty much the algorithm now you might notice that we are getting an error over here that we are missing a return statement and that's because uh it's technically possible that we would get to the end of our method here where we say that we're going to return an int array and if we don't happen to find a solution it won't return anything so we have to return something now according to the rules of this leak code problem it's always going to have exactly one solution so in this situation it doesn't matter a whole lot what we return it just has to be some int array so what we can do if we want is just return this nums array that's passed in so let's go ahead and copy and paste our code back over here into lead code and submit it and see what happens okay here we go and okay so uh it succeeded but the runtime was 140 milliseconds which is faster than just about seven percent of all the java submissions for this problem so this isn't a very fast or efficient solution now sometimes with leak code you can submit it another time or two and see if it just happens to run faster in subsequent calls yeah so in this case it took 113 milliseconds which is now about 14 but it's still not very good there's still a lot of people who are submitting a faster solution than this so let's see if we can come up with a better way of doing this that's faster so first of all the reason that this solution is so slow is because it has a big o time complexity of n squared so what exactly do i mean by that well any time you have a nested for loop in your algorithm where both the outer for loop and the inner for loop loop over all the items in your array most of the time that's going to give you a quadratic time complexity so that which means a big o of n squared now for small data sets like we have in the problem examples that we've been looking at that time doesn't really matter but once you have thousands or tens of thousands or millions of objects in the array that you're supposed to do your calculation on that kind of time complexity starts to really really matter so even though the operation that it's doing on those two numbers is simple you know it's just adding them up and then comparing them to another number the problem is that it's having to do that comparison you know hundreds of thousands millions or billions of times so what if we could come up with the solution where instead of doing that we could just loop through our array one time and get rid of our nested for loop and to do that we have to come up with a little bit more clever of a solution so let's hop back over to intellij and try and work this out so here's the idea for this faster solution we are going to use a map specifically we're going to be using a hash map now if you want a good refresher on maps or hash maps generally go and check out my video on that but as a quick reminder all a map is is just a collection of key value pairs so when you add a thing to the map you add some search and key and then you also add some value that it maps to and then later what you can do is give the map some certain key and it will retrieve the value that it has stored for that key and the way that the hashmap does that lookup it's super fast it's in what's called constant time so what we're going to do is we're going to loop through our array one time and each iteration through that loop we're going to add something to our map so as we're iterating through our array for each number that we look at what we're actually going to store is the number that we would have to add to this number to get to our target that will be the key that we add to our map so for example let's say we're looping through our array and we start at index zero which is the number five we say okay what would we have to add to five in order to get our target six of course it's one one in this case is known mathematically as the complement which doesn't matter a whole lot but it gives us a good name to talk about it so that complement will be stored as the key that we're going to add to our hashmap and then the value we're going to be storing at that key is the index of that number that we were looking at so as we're looking at the number 5 we know that 1 is the complement 5 plus 1 gives us our target 6 and the index of this first number that we're looking at is just 0. so we would add to our map a key of 1 which maps to a value of 0. but here's the really crucial part to this algorithm why is this information so useful well the reason is now as we keep iterating through this array we know that if we encounter the number one anywhere along this array we know that we can add that to this number to get our target number so that might take just a minute to sync in but that's the most important part of this algorithm so basically what we're going to do is loop through each number in our array and first we're going to check whether that number already exists as a key in our map and if it does then we know that we've found our match and in that case we just need to return the indices of those two numbers so one of them is the index of the current number that we're looping through and then the index of the other number that we need to return is just going to be stored at that location in our map so let's walk through how the algorithm is going to work for this set of numbers so we just have one for loop that's iterating through this array so first we're looking at the number five now what would we have to add to five to get to six one and we can calculate that by just taking our target minus the current number that we're looking at of course five plus one equals six so in this case one is our complement and this number is index zero in our array so we would add an entry to our map which has a key of 1 the complement and a value of 0 which is the index of that number so then we move on to the next element in the array 2. first actually what we do is check to see if 2 already exists as a key in our map so in this case the number 2 doesn't yet exist in our map so then we say okay what number would we have to add to 2 to get to 6 which is 4. so 4 is our complement here so we add that 4 as a key onto our map and the value that we associate with that key is the index of the number that we were looking at which here is 1. so next we move on to the next element in the array which is 4. now first we ask okay does 4 exist as a key in our map yes it does right here so now that we've found that we know that we have a match we know the indexes of the two numbers that add up to our target but how do we know that well right now in our loop we're looking at the number four right so what we've done is gone and look up in our current existing hash map whether we have the number four as a key and we do and the value associated with that key is one now remember this index is where we can find a number that we have to add four to to get to six and now that we have a 4 we know that we can add that to the number at this index to get our target so in this case our answer is first the index of the number we're looking at which is 0 1 two index two and the index that we find when we look up that number in the map so we look up four as the key in our map and we get the index one so we return two and one now i promise if you give it a little bit of time maybe rewatch that last section a couple of times it'll all sink in and make sense so with that let's go ahead and actually implement that solution so first let's go ahead and get rid of our inner for loop here because we know that we don't want to use any nested for loops but our outer for loop is still going to do the same thing we're going to loop through all the numbers in our array but before this for loop we want to actually create the hashmap that we're going to be storing all of that information in so to create our map we can just say map now we have to tell java what types that we want to use for our keys and values in our map in this map the keys are just going to be those complements that we calculate so those can just be integers and the values associated with those keys are just going to be the indices of those complements which are also just integers one thing to keep in mind is that you might try to use ins here instead of integers but you're not allowed to use primitive types here so you have to use their wrapper classes so instead of int just make sure you use integer now we need a name for this map variable so because it's going to contain the complements that we store and the indices of those complements we'll just call it complements and then we need to initialize that as a new hash map we just have to open and close the angle brackets here open and close parentheses and there we go okay so now inside our for loop for every number that we're looking at as we loop through our array we first want to see if that number already exists as a key in our complements map so to see if the value that we're looking at already exists in that map or not we can just call a method on that map called dot get and so here as the parameter to this get call we want to pass in the number in the array that we're currently looking at so that's not going to be i because i is the index of the current number that we're looking at the number at that index is nums of i so if the number that we're looking at exists as a key in this array this will retrieve it for us and if it doesn't exist it will just return null so what we can do is store that value in a variable so integer let's just call it complement and then we'll set that equal to the result of this call but actually looking at this because when we get the value that's stored at this key in the array the actual value that it's giving us is the index of the number that has that complement and not the complement itself so a better name for this might be a complement index so now if this complement index is not null we know that we've found a match so we can just say if that complement index is not equal to null then we know that we have a match and we just need to return our two indices so we can just say return new int array now what are the two indices that we want to return so the first index is just i the index of the number that we're currently looping through in our array now next is the index of the number that we can add to that number to get our target which we know is stored at the complement index okay so we know that if we find a hit and our map then we have a match and we can just return the indices but if we don't then we have to calculate the complement and add it to our map so to add an element to a map you just call that map so complements dot put now this put method takes two parameters the key as the first parameter and the value as the second parameter now in this case we said that for the key we wanted it to be the complement of the number that we're looking at which is the number that we have to add to that number to get our target and we can do that just with simple subtraction so we can take our target minus the number that we're currently looking at in our array which is just nums of i and then for our second parameter for the value that we want to store at that key remember we just want it to be the index that we're currently at so that's just i okay so i think that should just about do it so i'm going to go ahead and copy this and then go back over to leak code and paste it in and we'll go ahead and submit it and see how it goes okay okay so it also succeeded but way way faster than our last solution just two milliseconds so it says here that's faster than 94.58 of java submissions for this problem so that's way way faster that's like more than 50 times faster than our previous solution it's an insane difference and the reason for that drastic difference is now we're only having to loop through our array exactly one time so now instead of having a time complexity of big o of n squared it's just big o of n which we call a linear time complexity one thing to note about our newer solution though is that it does at least theoretically take up just a little bit more space a little bit more memory and that's because it has to create and manage this hash map so for example in our last few runs so the first run of our initial algorithm was 45.1 megabytes and then 45 megabytes and then the memory taken up by our current solution is now 46.2 megabytes and there could be a lot of variance even within different runs here on leak code so if i submit it again i might get a different uh runtime and memory let's see so yeah this time we get a three millisecond runtime and 46 megabytes of memory so it's not really that big of a difference in memory but it is something to note there could be some algorithms that you can make a whole lot faster with a lot more memory and then you might have to weigh the pros and cons of using that much memory but in this case it's it's so dramatically faster it's not even close and the amount of memory taken up is just negligibly different so it doesn't even matter this is just a way better solution now if you're kind of newer to java or newer to programming in general you might have thought man i never would have thought of that kind of a solution even if you know i maybe i know what a map is and how it works but i never would have thought to use a map to do this kind of look up to avoid having to do all these calculations now i'll just tell you that's totally okay the the more of these kinds of problems that you do and you know you figure out the solutions for or even you watch a video or you look up the solution you kind of learn oh that's a technique i don't really think i would have thought about and then you just stash that away in your head and your arsenal of potential tools for figuring out clever solutions for these kinds of problems just grows and grows so i want to encourage you to just keep at it keep creating things that you enjoy making and if you like try these kinds of programming challenges as well the more you do them the better you're going to get at them i'm really curious what all of you think about videos like this would you like to see more programming challenges do you like doing things like leak code or do you have suggestions for others i would like to be able to come up with some kind of content that i can deliver to you more regularly and something like a coding challenge i think enables me to do that but if you have ideas for other things you'd like to see me do on a more regular basis i would love to hear them so just let me know down in the comments what you think or if you have a way to make this even faster let me know down in the comments too i would love to see that so as always of course like subscribe comment you know the youtube trifecta thank you all so much for watching i really appreciate you being here with me and i'll see you next time