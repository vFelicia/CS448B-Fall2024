have you ever found yourself frustrated by just how much memory management you have to deal with in your Java programs nope you haven't that's because Java takes care of it for you automatically like magic without you even having to know that it's happening like your coding Fairy Godmother we'll go over the basics of what Java does behind the scenes to manage memory so you don't have to my name is John and I'm a lead Java software engineer and I also have a full Java course available in a link down in the description there you'll find over 8 hours of videos exclusive to the course that cover dozens of java topics so if you haven't yet go check it out now this is just a super simple program I whipped up that we can use to illustrate how Java manages memory behind the scenes so here's the main method all it does is call this do cat stuff method down here which just makes a new cat and makes that cat meow then after that back up here it prints out I'm done doing cat stuff as you may already know or at least you probably heard Java is what is called a garbage collected language and no that doesn't mean that a truck comes by at 630 every Monday morning throws Java in the back and rides off to a landfill although some commenters I've seen would apparently love that what it means is there are a lot of aspects of memory management that Java just takes care of for you without you having to worry about it you can still cause yourself problems if you try hard enough but you have to work really hard to do it overall the function of garbage collection is to just delete objects from memory that your program doesn't need anymore without some mechanism for doing that your program would just accumulate more and more objects in memory over time and so you'd quickly run out of memory and your program would come crashing down in a fiery blaze of incompetence but how exactly does it figure out what objects in memory your program doesn't need anymore so we can get rid of them well at a high level it's pretty simple so in Java when you create and instantiate a new variable like this so cat my cat equals new cat well so what you actually end up with behind the scenes is this very iable my cat that acts as a reference or a pointer to this new cat object that I've created out here in memory just need some whiskers there we go essentially how it works is that if some part of our program either a variable or some other object has a reference to this object in memory it won't be a target for Java's garbage collection as long as we can still access it it's not going anywhere and that makes sense right Java doesn't want to get rid of something we could potentially need and can still access back to our code though at some point in this program this mycat variable is just going to be out of scope now in this case our mycat variable is declared inside this do cat stuff method that means the scope of that variable is only within that method so after our program calls my cat. meow and then returns back to this line where it called that method well after that this myat variable just doesn't exist anymore it's now out of scope so even if we wanted to do something like call my cat. meow up here well we couldn't because my cat wasn't declared in this scope it just doesn't exist here so here's what happens we had this my cat variable with a reference to our cat object in memory but now since we're outside the scope where this mycat variable was created that variable doesn't exist anymore and when the variable goes away so does its reference to this cat object in memory now what we have is this poor Lonely Cat object floating all by itself out in memory and absolutely nothing in our program knows where it is or has any way to access it ever again all it's doing is taking up space in memory this is what Java's garbage collector is on the lookout for stray forgotten objects that no longer serve any purpose to our program now it's important to note that a variable going out of scope like this isn't the only way that an object could become unreachable in memory so for example if we went back to our code and we took our my cat variable and set it equal to another new cat object well what that's going to do is create a whole new cat object in memory beautiful as always and now instead of referencing that old cat object in memory it now references this new cat object our original cat has no references to it anymore more and thus becomes a target of Java's garbage collection to get cleaned up now another way that could happen is instead of mapping my cat to a new object you could instead just set it to null so let's say back in our code we just said instead of my cat equals new cat we could say my cat equals null well pretty much what that does is just gets rid of this old reference and now my cat isn't referencing any object at all but just the same this poor old cat object in memory now has no references to it and Java's garbage collector we'll need to clean it up but how does Java actually go about doing this garbage collection behind the scenes so quietly that you never even notice it actually Java has a whole bunch of different garbage collection options most of the time you can just let Java use its default garbage collector settings and it'll work just fine now it gets way more complicated than this but here's just a basic explanation of how the garbage collector works by default all right so let's just say your program is chugging along you know it's creating cats in memory calculating student GPA or the average cost of a Big Mac in Guatemala whatever and the whole time it's creating these new objects in memory whenever it needs to and to begin with all of these new objects that get created go into What's called the Young Generation Heap young gen the Young Generation as its name kind of suggests holds all objects that were created very recently all new objects start out here then at some point the Java garbage collector goes eh this Heap is starting to get sort of full I think I better take a look at this and start to get rid of some things that we don't need anymore and at that point it does what is called a mark and sweep basically all that means is that Java will check each of these items to see if they still have any references to them and if they do Java will mark them as still in use so let's say it marks this one and this one as still having references and all the other ones don't so once it's done that it then does the sweep step and that's when it removes anything that wasn't marked freeing up more memory space for additional objects to be created in the future but here's something else cool that it does to try and reduce the overall time that it has to spend doing this garbage collection the garbage collector starts to notice hm you know some of these objects have been around here for a long time they don't seem to be going anywhere every time I go to check these objects always still have references so they're probably pretty important to this program and I can expect them to stay around for a while so what it does is it takes those objects that have survived so long in the Young Generation and moves them over to an old generation Heap so it says all right you've been around here for a while you've been around here for a while let's move you over here now the reason that helps is because Java will do a mark and sweep of this old generation Heap way less often which makes sense right for two reasons first it's just going to fill up more slowly and second it's full of objects that have already survived previous rounds of garbage collection now it's still going to be doing multiple Mark and sweeps of the Young Generation pretty often as it continues to fill up with new objects that your program creates but because it took the time to move these long lived objects over to the old generation Heap it doesn't have to waste all its time checking all of these really long lived objects that are very unlikely to be cleaned up anyway so it's able to do the Young Generation Mark and sweeps much faster now this is a very simplified explanation of this whole process in reality all the little details of Java's garbage collection algorithms are ridiculously complicated but this just gives you an understanding of the fundamentals and you can now kind of start to code with that in mind for example that's one of the reasons it's recommended that you create variables in the smallest scope that they're needed because then as soon as you don't need that variable anymore it becomes eligible to be cleaned up by the garbage CL C and you can free up some memory and if you're all interested in seeing it in another video we'll go over some additional simple ways that you can start to code with the garbage collector in mind as always thank you so much for watching I really do appreciate you being here with me and I'll see you next time