in this video we're going to implement the binary search algorithm in Java binary search sounds like it could be really complicated but it's really not so bad once you understand how it works it's also a great algorithm to learn to write for a beginner I'll also show you how you can do a binary search with just one line of code using Java's builtin libraries as always my full Java course is available in the link down in the description there you'll find over 8 hours of exclusive Java lessons covering dozens of topics so go check it out you can also find the full source code for this video in a link down in the description so go grab it first let's just talk about what exactly a binary search is and why it is better than a regular search binary search is just a way that you can check whether a specific value is present inside a sorted array so let's say we had some array of integers for example that was 1 2 4 5 7 9 and 11. all any search algorithm does is just take some number that you give the algorithm let's say we gave it the number nine and it just tells you whether or not that value exists anywhere in the array so normally if you didn't have an algorithm like binary search if you wanted to check whether a given value was in your array you could just iterate through every item in the array checking its value until you found the value that you were looking for now that's totally fine and it does work but the problem is if you have an enormous array of integers it can start to become kind of slow because it has to check every single value in the array until it finds the one that it's looking for but if you know that the array that you're looking at is sorted in order so in the case of integers they go from smallest to largest like we have here then you can instead use the binary search algorithm to get your result much faster than you could with a regular iterative search now it is very important for your binary search to work at all that the values that you're giving it have to be in order that's very important if you're working with an array that is not currently in order you're going to want to sort it in order first and you can do that in any number of ways I've got lots of videos about sorting algorithms so go check them out but I just want to make it clear that it is important your array has to be in order for binary search to work all right so here's how binary search works now instead of just starting at the very beginning of the array and checking every value what we're going to do is first check the value at the very center of the array the middle value of the array the array here has seven elements and so our middle element here is the number five so now that we've selected the middle element in our array what we do is compare it to the number that we're looking for in this case we're looking for the number nine so first we check is this the number that we're looking for and if it is great we're done and we found it but in this case it's not 9 does not equal 5 so we have to continue so what we do is say okay is 9 greater than 5 or less than 5. here 9 is greater than five so what does that mean because we know that our array is sorted in order from smallest to largest we know that if the number nine is in this array it is going to be to the right of the number five now the important part of what that means is that we can completely eliminate looking in that entire half of the array that is less than five that is the key to how a binary search is so much faster than a regular iterative search the next step in binary search is basically just to redo the binary search in just that half of the array that might contain the value that we're looking for so basically we're going to do a binary search for the number nine here with just these three values and we're going to do that exactly the same way as we did before so first we're going to choose the the middle element of our array and check its value so here that is now the number nine now we compare that number to the number that we're looking for is nine nine yes it is so we found the number that we were searching for now after the algorithm finds that number all it returns is the index of that number in the entire array so here that 9 is at index so this is 0 1 2 3 4 and 5. so our binary search algorithm would return the number five because that is the index where we found the number that we're looking for but if that hadn't been the number we were looking for let's say instead of that we were looking for the number seven well we would just continue doing the exact same steps we did before we would have compared 7 with 9 and said okay 7 isn't equal to 9 okay is it less than 9 or greater than 9 well 7 is less than nine so that means that again because our array is in sorted order from smallest to largest we can complete greatly eliminate the entire right half of that sub array we don't have to look there we know it's not there so then we can repeat that binary search algorithm on just the one small part of the array that's left and then of course we see okay 7 equals 7 so we found our value there so you might be thinking all right well what do you do if the value that you're searching for actually isn't in the array so let's say instead of nine or seven we were looking for the number six well up until this point of the search things would have gone exactly the same way but now we're comparing okay is six equal to 7 well no it's not but the problem is there's nothing else left in the array so we know that it is not present in our array how we handle that usually in a search algorithm we don't throw an exception or anything like that but instead we just return a negative one we know that negative one is not a valid index of the array so we return negative 1 as a way of just saying sorry I didn't find the element that you were looking for in the array so maybe this gives you a glimpse at why the binary search algorithm is so much faster than a regular iterative search let's say that you had an array of like a million items in it now a regular iterative search would just start at the beginning and say okay I've got to check all these million items and see if it's in here but a binary search can start in the middle and say okay is the thing I'm looking for greater than or equal to this and then it can immediately completely remove half of the entire array so in just one step the binary search algorithm reduces the problem that it's dealing with by half I think that's enough of this let's jump right into the code all right so to implement our binary search algorithm first instead of writing our algorithm right there in the main method let's go ahead and create a separate private method that will do the binary search that we will call from our main method so we'll go ahead and make a new method here a private static now the return type of our method is going to be an INT because we want to return the index of the value that we find if we find it we'll call it binary search pretty creative name now our binary search algorithm has to take in two parameters first it has to take in the actual array of ins that it's searching in we'll just call that numbers and then it also has to take in the value that it's searching for so we'll call that one number two find so here's how I think we're going to do this in the code so I think we're going to use two pointers we're going to have one that's at the very first element in our array and one at the very last element in our array and what we're going to do is find the middle value between those two pointers and then we check whether the number that we're looking for is equal to that value or if it's greater than or less than that value let's say that we find that the number that we're looking for is less than that middle value we're going to take that pointer that's currently at the end of our ra and we're going to move it just to the left of that middle number and then we're going to repeat our binary search algorithm with just that half of the array that's contained within our two pointers now if the number that we were looking for happened to be larger than that middle number we would instead take our low pointer and move it just to the right of that middle number and we continue our binary search with just that half of the array so you can kind of see how it works right what we're going to do is keep dividing what we're looking at in half by moving our pointers until we zero in on that one number that we're looking for and then we can return the index of that number so first let's go ahead and create those two pointers that we need they'll just be ins we'll just call these pointers low and high so first we'll create our low pointer so into low equals zero because we want to start it at the very beginning the very first element of our array and we also need another int we'll call it high and we want to start that at the very last index of the array now we can get that index by calling just numbers dot length and then subtracting 1. so the next part of our algorithm is kind of going to be the the main part of it which is actually going to be a while loop now our while loop is basically going to keep looping until our two pointers you know cutting off half of the array as they get closer and closer to each other until our two pointers cross each other so the condition in our while loop is going to be while low is less than or equal to high now that we have all this set up the the first step in this meaty part of the binary search is we have to identify the index of the middle item in the array that we're searching in right now so let's go ahead and create that we'll say int like middle position now that middle position is basically the average of our low and high indices so we can get the average of low and high just by taking low plus high and dividing by two next we need to identify what the value is at that index what actual number is at that spot in the array so we'll use another variable for that we'll call it int middle number and we'll set that equal to the value of our numbers array at that middle position so now what we want to do is check whether the number that we're looking for our number to find is equal to that number or less than or greater than that number first let's check if it is equal to that number so we can say if the number to find is equal to this middle number then that means that our search is done we have found the number that we're looking for so all we have to do is return the index where we found that number and that index X is our middle position variable so all we have to do in this case is return middle position but if this wasn't exactly the number that we're looking for we have to deal with that situation so what if the number that we were looking for our number to find is less than our middle number so in that case remember what we want to do is we want to take our high pointer and move it just to the left of our middle pointer our middle position because we know that the number that we're looking for is less than this middle number right now so to do that we can just take our high pointer and set it equal to the middle position minus one so that'll make it just to the left of that middle position index so now we know that the number that we're looking for is not equal to the middle number we know that it's also not less than the middle number so at this point in the algorithm we know for sure if we put in an else here we know that our number is greater than the middle number so we don't even need to add another if condition if we don't want to you can if you want you can add okay if number to find is greater than middle number if that makes you feel nicer it just makes more sense in your head to have it you totally can but in at this point in the algorithm we just don't really need it because because the way the logic works we know it's not equal because it would have returned already we know that it's not less because it it would hit this if so in this else we know that it is greater now since we know that we can take our low pointer and set it just to the right of that middle position so to do that we'll take low and set it equal to Middle position plus one so now what this while loop will keep doing is moving those high and low pointers closer and closer together each iteration until they meet and eventually find that number that they're looking for or eventually the low pointer will be set to one higher than the high pointer so what that means is our high and low pointers move closer and closer to each other until they met at one single number and then they still didn't find the number that they were looking for and so they crossed each other so at that point it will kick out of this while loop so what that means is outside of this while loop we know that we didn't find the number that we were looking for it wasn't present in the array so all we have to do in that case is report our failure by returning just the number negative one to indicate sorry we didn't find it that is everything we need I think this is a complete binary search algorithm all we need is some code that calls it to do some testing so first we're going to need an array of integers to pass into our search algorithm to start to find some stuff in so we'll just call this interray ins and we'll just go ahead and give it some values let's use the same array that we did in the Whiteboard thing there so that was just one two four five seven nine and eleven so now what we want to do is call the binary search method that we implemented down here and we have to pass in first the array that we want to do the search in so that would just be ins and then we want to put in the number that we're looking for so let's say we want to search for the number nine and then we'll go ahead and print out our results otherwise we'll never know what the result was okay there we go now let's go ahead and run this and see what happens here we go across your fingers okay so it returned five it's saying that the number nine is at index five in our array so let's check to make sure that's right so that'd be zero one two three four and five so that's right it returned the correct value all right so that's one test that is successful but let's head a little bit harder with some more values to make sure that it Returns the right result every time so let's say we were looking for a number that did not exist in our array so let's look for the number eight so if we go ahead and run that we get negative one which is exactly what we're looking for because 8 didn't exist in the array the algorithm should report that by returning negative one so let's try some other like edge cases let's say we wanted to look for like the very first thing in the array so let's say we were looking for the number one it should return an index of zero and it does awesome and let's look for the highest element in our array which is 11. and it returns 6 which is correct zero one two three four five six looks good as a quick side note if you want you can change this algorithm to uh instead of using a while loop you can change it to be a recursive algorithm with just a couple of pretty small tweaks now I think I'll leave that as a small exercise for you to figure that out if you're curious I do have an entire video on recursion if you want to go check that out to learn about recursion generally but I'll also link to my recursive solution for this algorithm in the description below so if you get stuck go ahead and check that out now I also mentioned at the beginning of this video that you can do a binary search with just one line of code using Java's builtin libraries so here's how you can do that so what you can do is call arrays dot binary search that is a method provided to you automatically in Java and that's in the java.util.arrays package that's where you can find this class and call this mess method and then you can just pass into this binary search method exactly the same parameters that we passed into our binary search which is first the array that you want to search in so in this case it's ins and the value that you want to search for so again let's go ahead and search for the number nine and let's go ahead and change this to look for the number nine two just so we can compare the results and we also have to go ahead and actually print out the result of our Java Library call so I think that's it let's go ahead and run it and hopefully we get the same output from both of these calls and yes we do we get five from both of them so like so many things Java doesn't force you to reinvent the wheel if you don't want to if you don't want to write your own binary search algorithm you can just use its builtin one just like it has sorting algorithms and stuff built in you just call a sort method and it does it really really well same as for binary search but it's still a really good thing for you to know how to do and understand how it works to code on your own if you enjoyed this video or learned something of course let me know by hitting the like button and be sure to comment let me know what else you'd like to see and of course subscribe so you can see all of that awesome stuff in the future as always thanks so much for watching really do appreciate you being here with me I'll see you next time