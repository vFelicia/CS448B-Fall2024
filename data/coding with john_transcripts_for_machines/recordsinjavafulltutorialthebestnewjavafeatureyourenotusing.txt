records are a relatively new addition to java that you can use to avoid a ton of boilerplate code in certain types of classes in this video we'll talk about exactly what records are how they can simplify your code and when and how you can implement them into your java programs my name is john and i'm a lead java software engineer i also have a full java course available and a link down in the description so go check it out to understand why records are so useful it helps to know what programmers had to do before they existed which is probably what you are still doing if you're not using records yet let's say you wanted to make a very simple java class that all it contained was a bunch of fields to carry data about something these kinds of classes are super common in the java world like for example if you had an employee class that carried the employee's name and their employee number maybe that employee info exists in some database and all this class has to do is hold that employee info and return it to the user so before records existed here's everything you had to do let's give it two private fields a string employee name and an int employee number let's also go ahead and make these final so they can't be modified after the employee object is created so because these two fields are final we want to be able to set them right when we create an employee object so we have to add them to a constructor so maybe our constructor is just public employee class and that takes in the string name and the int employee number as parameters then all it does is just set this dot name equals name and this dot employee number equals employee number then let's go ahead and generate some getter methods for these two fields so they can be accessed from outside the class next you also want a good tostring implementation that returns all the data in the class in a nice readable string format something like this next you're going to want to override the hashcode method with a good implementation as well now we're almost done but not yet you're also going to want a good equals method implementation to check whether one instance of this class is equal to another so now finally after all of that we can come back here to our main method and create a new employee class object we'll just call it employee equals new employee class and we pass in a name and employee number here in the constructor and there you go but that was a whole lot of code that's almost 50 lines of code for a class that does something so simple like hold two pieces of data but that's how you have to do it with a traditional java class now to compare let's show how to do the exact same thing but using a record we just say public record we'll call it employee record it has a string name and an int employee number open and close the curly brackets and that's it this single line of code gives us the equivalent of everything we just created in this employee class so now with just that we can go back here to our main method and create an employee record object in the exact same way that we created the employee class object so we'll call this employee record equals new employee record and pass in the name of kramer and kramer is employee number 54321 so now let's break it down a bit to create a record first we say public record instead of public class that's because a record is a certain special type of class kind of like an enum is also a special type of class next we just give it a name here we're calling it employee record next in parentheses we list out all the components that we want to hold inside our record in a way that looks a lot like the parameters to a method so this is just all the different data elements that you want to hold in your record so here we have a string name and employee number so with just that java gives us a whole ton of other stuff for free first it generates private fields for all the components that we listed here just like we did over here in our employee class these will also be generated as final fields by default just like we did in our class so that they can't be changed after an employee record object is created it also generates public getter methods for each of these components similar to the getters that we created here the only difference is that the getters that it automatically generates for a record don't have get in their method name they just have the name of that field so just to demonstrate that back over here in our main method if we wanted to print out this employee class object's name we would just call employee.getname but to do the exact same thing with our employee record object we would just have to call employee record dot name without the get but if we go ahead and run our program we can see that the functionality is the same next it will also generate for you a certain type of constructor now you might know that when you create a normal java class what it automatically creates for you behind the scenes even if you don't make any constructor at all is a no args constructor like this that doesn't take any parameters when you create a record however it works a bit differently instead what it creates is a constructor like this one that takes in as parameters all of the different components that you listed up here in the record declaration then it sets all of that records fields with the values in those parameters just like we did over here in our employee class constructor that we made this type of constructor that is automatically generated when you create a record is known as a canonical constructor even though we didn't explicitly create any constructor over here in our record we were still in our main class able to call a new constructor and pass in our two component values and that's because that constructor was automatically generated behind the scenes there's also some really cool things that you can do with constructors only in records that you can't do in any other type of java class that we'll talk about in just a little bit finally it'll also automatically generate implementations of the tostring equals and hash code methods very similar to the ones that we created over here in our class so the tostring method will give you the name of the record class and then the name and value of all of its components and we can actually test out that automatically generated tostring method just by passing in the actual object to the system.out.printline method because when you pass in an object that isn't a string to system out print line it automatically calls the tostring method to get the string representation of that object so if we go ahead and run our code we can see that it prints out the contents of these objects in a very readable way so we can see that the record automatically created a tostring that has the name of the record and then the value of each of its components and it will generate equals and hash code methods that will consider two objects of that record class equal if all of their components are equal to each other these three methods can be somewhat tedious to write and so often programmers will just skip implementing them and even if they do bother to do it they can be really easy to mess up especially the equals and hashcode methods so with records you don't have to worry about them at all it will automatically create them for you you are allowed to override those methods with implementations of your own but most of the time there's just no reason to do it one thing to note is that it does not generate any setter methods one of the main features of a record and one of the main reasons to use a record is that they are immutable by default that just means that a record object cannot be changed once it's created once your employee record object is created with a certain name and employee number you can no longer change this employee record's name or employee number to anything else so it really wouldn't make sense to have any setters created anyway there are a few other things that you'll have to know if you're going to be using records first like any other class you can create instance methods if you want so for example you might have some method a public string name in uppercase and maybe all that does is just return name dot to uppercase and so you can call this method on an employee record object just like you would any other type of object so over here we can call employee record dot name in uppercase and if we run it we can see that we get the employee name in uppercase you can also create your own static methods as well so like public static void print whatever and that can just print whatever of course to call a static method you should call it using the name of the class itself and not a certain instance of that class so over here we would just call employee record with capital e capital r dot print whatever and of course that will just print whatever you can also create static fields like you could in any other class for example you could have a public static final string default employee name equals george however you cannot define your own nonstatic instance fields so something like private string something you are not allowed to do this you'll get an error that says instance field is not allowed in record any instance fields like this that you want have to be defined up here in your list of components another thing is that records cannot extend any other class so up here if you try to do something like extends employee class you would get an error that says no extends clause allowed for record all java records implicitly extend the record class kind of like all enums implicitly extend the enum class so because java doesn't allow multiple inheritance your record can't be a child of any other class records are also implicitly final classes which means that they can't be extended by any other class either you are allowed to put final in your record declaration but it's redundant to do so because it's already automatically going to be final however you are allowed to implement interfaces in records so to do that right up here after your record declaration like any other class you can just put in implements whatever interface you want so if you want you can implement the runnable interface it would probably be kind of weird for a record to be runnable but if you want to do it you can do it you just have to implement this run method like you would for any other runnable i mentioned before that we'd talk a little bit more about constructors in records remember that for records java will automatically create this canonical constructor that takes in all of the components and just sets all of those fields based on those components that are passed in so the idea is once you use that canonical constructor to create an object of that record class all of its fields will be set and can never be changed the record only exists to carry that collection of data through your program however you can also define your own constructors first even though it gives you that canonical constructor for free you can override it with your own implementation if you want so if i want i can create public employee record which takes in a string name and an int employee number so to override that default constructor it has to take in the exact same parameters in the exact same order one reason you might want to override the default constructor is just to do some sort of validation on the values being set like maybe it doesn't make sense for an employee number to be negative so you might do something like if the employee number is less than zero throw a new illegal argument exception employee number cannot be negative after that though you still have to set your records fields using the values passed in like this so this dot name equals name and this dot employee number equals employee number however with records there's a really cool little shortcut you can use to override your canonical constructor if you want and that's called a compact constructor this is something that is unique only to records all a compact constructor is is this exact same constructor except with the parameters removed and these assignments removed it will automatically add these same parameters in the same order and at the end of this constructor it will automatically set all of this records fields with those parameters you can also have additional regular constructors that take in different sets of parameters if you want and for those all the normal constructor rules apply you can learn a ton more about java constructors in this video here i think the ability to create this kind of compact constructor is really cool and it really serves to illustrate exactly why records exist records are just a super simple and fast way to create a certain type of class that we have to use all the time in the java world and that's a class that just holds data now remember we didn't even need any of this extra stuff we added so just this is all that we needed to create a fullfeatured class whose purpose is to just hold and carry this data and if you ask me that's a whole lot better than having to write out all of this to do exactly the same thing if you enjoyed this video or learned something please let me know by leaving a like be sure to subscribe for more java tutorials and for my full java course just check out the link down in the description thank you so much for watching i'll see you next time