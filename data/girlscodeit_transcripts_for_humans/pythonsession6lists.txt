With timestamps:

00:00 - um i will um just
00:03 - um just go over the agenda um and also
00:06 - just brief back into indexing and then
00:09 - we'll
00:10 - come back to where we were before so
00:14 - um our agenda today is back on the list
00:17 - um also introductions uh because we are
00:20 - recording right now in fact um
00:22 - so uh if you have um
00:25 - uh so so just as a heads up this will be
00:28 - listed on a youtube later
00:31 - um so we'll be covering next things
00:32 - licensing list functions
00:34 - and also a demo at the end um
00:37 - i'm not sure when we arrived but i'll
00:39 - just go over this really quick
00:40 - um and that's you index uh you index
00:44 - uh you next starting at zero
00:47 - um you can't index out of the array
00:50 - although i still throw a
00:52 - list error i'll show an example all that
00:55 - so you can exit you start indexing zero
00:57 - the first element in
00:58 - uh one in this case you try to index out
01:02 - but if you'll throw
01:03 - an indexer you can index from the back
01:06 - as well
01:07 - negative one being this element right
01:10 - here
01:10 - essentially uh one from the back or
01:13 - in this case it is the one for from the
01:16 - back
01:16 - and then you can do that for as much as
01:18 - you like as well and then you can also
01:21 - run into index areas if you try to index
01:24 - out from the back
01:25 - so if you have any questions or the
01:27 - people who came late then please
01:29 - come and ask questions
01:34 - um
01:38 - yeah so you can do some
01:42 - uh setting of the actual values itself
01:45 - during this uh
01:46 - mutability um
01:50 - yeah earning one inverse list yeah
01:51 - that's absolutely correct um
01:53 - the reason why that is is because the
01:55 - the the the two optional parameters that
01:57 - you're passing in
01:59 - um for the first option uh
02:02 - is zero because uh the default is zero
02:04 - and it starts to zero
02:06 - uh the next optional parameter um or a
02:09 - default parameter
02:10 - is the end of the list or the language
02:12 - list so essentially
02:14 - you try to go
02:17 - from the the end of the list to the
02:20 - beginning of the list
02:20 - indexing backwards or using a
02:24 - negative one step in there or it will go
02:25 - backwards
02:29 - so more on slicing that's more exciting
02:34 - so the question was why does this
02:38 - example not include
02:42 - zero or not include one
02:48 - you can see that you know it goes from
02:50 - five four three and two and it doesn't
02:52 - do one the reason why that is is because
02:55 - the end operator
02:57 - uh or the end parameter um does not
03:00 - include uh it is inc conclusive
03:04 - so it is sort of the same idea once you
03:06 - go from zero to four
03:08 - it doesn't include this five because the
03:11 - last element is not
03:12 - um it's not included so if you
03:16 - go from four to zero zero is not
03:18 - included so therefore one won't be
03:19 - printed
03:25 - so uh
03:32 - um yeah so this is what i was talking
03:34 - about with regards to
03:35 - uh the default parameters uh the digital
03:38 - default
03:39 - parameter of this was is a negative one
03:42 - i believe so
03:43 - um actually sorry it's not it's not
03:45 - exactly negative one but it's
03:46 - essentially to the end of the list
03:48 - so therefore you start at zero and two
03:49 - three and then it goes
03:51 - uh it's zero
03:55 - one two three yeah to four and then it
03:58 - goes to the end of the list
03:59 - the actual counter of this being the end
04:01 - of the list
04:02 - might be it's not exactly that it's not
04:05 - exactly the blank slate
04:12 - actually yeah the the the optional
04:14 - parameter in this case would be
04:15 - the end of the list and then if you try
04:16 - to index out to the end of the list
04:18 - uh normally it'll throw an index error
04:20 - but if you want to include that left
04:22 - element you go one
04:23 - above what you can usually um index
04:30 - um in this case the optional parameter
04:34 - is not the
04:35 - end parameter but the first parameter
04:36 - that being the beginning that lifts so
04:38 - you
04:38 - go from zero one two and then not
04:41 - include
04:42 - into three so that would be zero one two
04:45 - not including three
04:46 - which would be the four in this case so
04:48 - one two three
04:52 - and then um in this case um here i'll
04:55 - make it even better
04:57 - um the optional parameter is the
04:58 - beginning of the list the end of the
05:00 - list and
05:01 - negative one is the error that you put
05:04 - in for the step so therefore
05:06 - it would then reverse the list
05:09 - so you're going from uh not quite the
05:12 - beginning of the list because then
05:13 - uh uh if you try to do do this
05:17 - and this
05:20 - i believe i lost my mistake
05:24 - it does pretty empty but it's something
05:27 - close to you know the end of the list
05:31 - and that way you're able to reverse it
05:36 - so as far as what is a print you know
05:39 - you have no start parameter you have no
05:41 - end parameter
05:42 - so therefore the optional parameters or
05:44 - the default
05:46 - parameters of those uh is the beginning
05:48 - of the list to the end of the list so
05:49 - therefore this
05:50 - prints out the entire list this
05:53 - is just an example in which you um do
05:56 - the exact same thing except you have a
05:57 - step of two
05:59 - so it'd be one three and
06:02 - possibly including five i think it does
06:04 - include five yeah
06:08 - and then this is an example of what
06:10 - camilo had said before about this
06:12 - reversing list
06:13 - so good
06:20 - all right cool so um we sort of had this
06:23 - list
06:24 - uh data structure we've been interacting
06:26 - with it through slicing
06:28 - and initialization as well as
06:32 - um indexing as well
06:35 - but there are also just a variety of
06:38 - other functions that you can
06:40 - use with a list in order to modify or
06:43 - uh or to sort of work with what is
06:46 - the actual contents of the list um and
06:50 - this is by no means an exhaustive um
06:54 - account of all the list functions in
06:56 - fact in order to get that you might want
06:58 - to
06:58 - google python three lists functions over
07:01 - here
07:02 - the python box you can see that there is
07:04 - quite a lot
07:06 - but we'll just be covering perhaps the
07:08 - most important ones
07:15 - so um let's see
07:18 - you begin with this initialized list of
07:21 - one two three two
07:22 - um this is something that we've seen
07:24 - before
07:25 - and then what happens when you use the
07:29 - pen method with the element that you
07:31 - want to append to it
07:32 - you place it at the end of the list
07:36 - over here and not only do you do that
07:38 - you modify
07:39 - the list itself so it doesn't sort of it
07:41 - doesn't return
07:43 - a copy of the list it is you know the
07:45 - mutable data structure itself
07:47 - so when you do that you get one two
07:50 - three two four
07:52 - because four has just been intended to
07:54 - do that
07:56 - um let's see i'm gonna
07:59 - make this not just i'm not i'm not gonna
08:02 - make it pop too
08:03 - because most common use cases of pop
08:07 - is that um it removes the last element
08:10 - which i should be working this
08:18 - it removes the last element the
08:23 - last index um and then returns that
08:27 - element as well
08:28 - so you have initialized as one two three
08:31 - and two you first printed a
08:32 - so that should just be one two three and
08:34 - two and then when you
08:35 - pop it it will return the two because it
08:38 - removes the element at the last
08:40 - list and then when you print again the
08:43 - list should have been
08:45 - modified such that the last element of
08:47 - the list is
08:48 - no longer there so you can see that you
08:50 - know you
08:51 - start with your original data structure
08:54 - you pop it
08:54 - it returns to and then you print it
08:57 - again and then it
08:58 - no longer has two at the end and then
09:00 - you can pass some parameters as well
09:04 - such that you remove things in the
09:07 - middle
09:08 - of the actual data structure as well
09:10 - although um i would advise you actually
09:12 - to not do this for reasons i won't get
09:16 - into now but essentially
09:17 - there are certain operations in python
09:21 - that's uh for list specifically that
09:24 - runs slower than others because of the
09:26 - way that the lists are implemented
09:27 - actually
09:29 - in the in the depths of the language
09:36 - so the difference between
09:39 - pop and remove is that uh you can see
09:43 - that um when when we try to pop the
09:46 - the index at two it returns the three
09:48 - and then it modifies it such that
09:50 - you have your one two two list
09:52 - afterwards and in this case
09:54 - actually removes the first two yeah so
09:55 - actually remove doesn't remove the
09:57 - actual
09:58 - um index but
10:01 - remove the first case of what you passed
10:04 - in here
10:04 - and this is an example of a function
10:07 - that may run slower if you have like a
10:11 - longer list but we don't want to get
10:14 - into that right now
10:16 - and also when you do that it doesn't uh
10:19 - return to as well
10:20 - so you can see it best most likely this
10:22 - will print a none
10:24 - and then this is different from when you
10:26 - popped it it actually did return the
10:28 - value
10:31 - and then finally insert another example
10:33 - of something that
10:35 - most likely you probably don't want to
10:37 - do too often or you have a very long
10:38 - list because they'll run
10:40 - slowly um is um
10:43 - insert um let's see inserts
10:48 - index two right so the first parameter
10:50 - is the index you want to insert that so
10:52 - in that case it'd be
10:53 - zero one and then two over here
10:58 - the inserts sort of before so
11:01 - this it would be um index two
11:04 - if you got inserted um uh once you have
11:07 - inserted it
11:08 - so you can see that is the case that you
11:11 - have
11:11 - uh next arrow index one and the next two
11:15 - and because you inserted index two ten
11:17 - is now there
11:19 - um see if i can show an example of
11:24 - why you don't want to
11:27 - pop or insert or you want to pop it a
11:30 - space for index and
11:32 - i'll show you why that may be
11:35 - so we're going to create a very large
11:36 - list of say a million elements
11:43 - um i'm not going to print a but we're
11:47 - going to just
11:48 - see how long it takes for these
11:50 - functions to run
11:52 - so see
11:56 - let's uh pop right here
12:00 - is that so pop will be very quick with
12:03 - an insert which should be
12:05 - very slow if you try to insert and like
12:07 - the middle
12:08 - of the actual
12:12 - so pop is very quick and then
12:16 - see how long it takes to get to here
12:24 - it was all right so maybe we'll add
12:26 - another zero
12:31 - search 10 and next two oh wait yeah
12:33 - insert
12:34 - 10 i think um
12:39 - generally these their structures are
12:40 - quite efficient um from a clear sense
12:42 - perspective
12:43 - um this operation should take a little
12:45 - bit longer
12:47 - but uh
12:57 - so an example of why you may not want to
13:01 - insert is because
13:03 - generally if you
13:06 - insert see if you do this and just
13:10 - comment out the actual insert
13:12 - this will be pretty quick i believe
13:19 - yeah this should be pretty quick but
13:20 - then this itself should be
13:22 - relatively slow when comparing the two
13:24 - although still not
13:25 - super slow um if we can use the timing
13:28 - function and get more into that then i
13:31 - would but it's a little bit slow let's
13:33 - see
13:34 - i'll start your interrupt i only see
13:35 - half your shirt screen i don't see the
13:36 - console
13:40 - so let me get to this question first can
13:43 - you do with the strings through the list
13:45 - yes um and the reason why that is is
13:48 - actually so i'm not sure by it um you
13:51 - can do indexing and slicing
13:53 - of a string but because
13:56 - what it does is that it converts a
13:58 - string
13:59 - into a list prior to doing that once you
14:02 - try to use any sort of
14:03 - indexing or spacing operations on it
14:06 - but and then and you can see like an
14:08 - example that
14:10 - here i will show you
14:17 - okay this should be fine so rather than
14:20 - oh
14:21 - god it should really be working
14:28 - so rather than this being a list now
14:30 - it's string
14:31 - a b c d e f g
14:35 - i'm indexing works
14:39 - as you might expect you have to try to
14:41 - get the character as
14:42 - index zero um
14:46 - it's a slicing works but perhaps not in
14:49 - the way that you may expect so for
14:51 - example you want to slice from zero to
14:52 - two
14:53 - you might think that okay it's a b right
14:55 - zero one
14:56 - but then when you do that um actually
14:59 - it does work the way that you expect um
15:03 - see if this works as well
15:08 - yeah so uh slide slicing works with the
15:10 - list as well
15:11 - um but then because
15:14 - a streaming is an immutable type when
15:17 - you try to append something
15:18 - not only will not recognize that
15:21 - function because
15:22 - string object has no uh and its list
15:25 - um list has that uh
15:31 - as that function against two lists first
15:33 - then you would be able to then see
15:35 - this this is now a valid operation
15:40 - just kind of a to the end of it um
15:43 - but uh yeah um because append is
15:46 - something that modifies the actual
15:49 - immutable uh data structure list
15:52 - and the string is an immutable data
15:55 - structure
15:57 - you won't be able to append to it and in
15:59 - fact when you do
16:00 - things like
16:04 - string edition
16:10 - a is equal to a plus another string
16:12 - let's add a to the end of that
16:20 - it's creates a um it creates a new
16:24 - string actually it doesn't append to the
16:25 - end of it
16:26 - um the details of which you might learn
16:29 - in computer science class regarding
16:31 - data functions and algorithms but
16:33 - essentially
16:34 - rather than just adding a to the end of
16:37 - the string
16:38 - what it does is that it copies the
16:40 - entire thing
16:42 - as an a at it and then it says so
16:45 - it's much slower operation which might
16:47 - come into play
16:50 - if you um
16:53 - if you sort of work with long strings or
16:56 - long lists
16:57 - or long screens as opposed to long lists
17:01 - so this is sort of a interesting
17:04 - demo of what the capabilities of the
17:07 - list are sort of combining everything
17:08 - that we had just seen
17:10 - in addition to what we had learned last
17:12 - week in regards to infinite loops and
17:15 - um what happened here
17:23 - anyways i'll just ignore that i guess
17:26 - hopefully the invitation is not okay
17:37 - big list
17:40 - if envelope syntax
17:46 - line 38 i see okay somebody
17:49 - over here i guess
17:53 - i'm a little bit confused about which
17:54 - one i should be using let's
18:02 - so um there's a few configs that you can
18:04 - set um first it runs through this
18:07 - infinite wild true loop um it prints out
18:11 - this cursor for you to sort of
18:14 - type into and then it waits for your
18:16 - input
18:18 - um in this case if we type exit it will
18:21 - just um
18:24 - let's go here oh yeah i think you'll run
18:26 - this one again so actually
18:28 - i will start this again
18:34 - i won't exit i should actually exit the
18:36 - terminal um
18:37 - because you just input exit it reads
18:39 - configuration and
18:42 - um if you do it again try to set a
18:44 - config like
18:46 - screen just
18:49 - just initialize this list um
18:53 - all right yeah so uh you're trying to
18:55 - set
18:56 - one under configs but it has to be in
18:58 - the format of config is equal to the
19:00 - value
19:00 - say like 100 and then afterwards that
19:04 - contact is set
19:05 - so therefore when you exit it should
19:12 - um
19:17 - actually kind of confused about what
19:19 - this example is because i didn't quite
19:20 - i was the one who wrote it um all right
19:24 - yes
19:24 - let's print.config list once we actually
19:26 - exit
19:33 - screen brightness
19:36 - to 100 and then when you exit out it
19:38 - should print out you know your
19:39 - list of screen rightness and now how
19:41 - that does that is that
19:43 - um it takes your input um it splits
19:46 - uh this parameter or the string you just
19:48 - put it into two parts so the extreme
19:50 - brightness part and the
19:52 - and the actual um integer part it checks
19:56 - if um it's
19:59 - in the configs that that being said
20:02 - right here
20:03 - and then once you exit it out it will
20:04 - just print out how it was
20:07 - so um yeah that's like so something that
20:10 - you can do
20:10 - with liz you can write command line
20:13 - operations
20:13 - although this is by all means sort of
20:18 - um it's uh like a small part of what
20:23 - lists are used for in actual computer
20:25 - science or software development context
20:32 - yes camille says you can always convert
20:34 - a string
20:35 - to a list um yes that
20:38 - that's true um the difference being that
20:41 - uh when you do so it then becomes list
20:44 - which is sort of
20:45 - immutable data structure and then in
20:46 - order to get it back into a string
20:48 - you have to use the the the join
20:51 - function
20:52 - um which i can actually i think this is
20:55 - quite a useful list function so i will
20:57 - sort of demonstrate that as well to go
21:00 - back to that point
21:06 - so you have your string as as before
21:08 - abcde
21:10 - abc um if you print
21:14 - the list is going to also then you
21:16 - convert it into the list itself
21:18 - you can see that you know it's not
21:26 - the string itself but rather it's the
21:29 - list of the individual charge of the
21:31 - string
21:32 - um and then once you have that in that
21:33 - format you can convert it back into a
21:35 - string by using the join function
21:38 - which you take all the elements
21:41 - inside of this list
21:44 - and then you put it together with
21:48 - the separator over here so when you do
21:51 - that it becomes acde again
21:53 - if you change the separator to a dash
21:56 - it'll print out a
22:01 - so as i said before
22:04 - this is all the things that you can do
22:06 - or all the functions that were
22:07 - list in fact that itself was
22:11 - a stream function that took a list in as
22:13 - a parameter
22:14 - so there's even more things that you can
22:16 - do with the lists that
22:18 - we can't possibly get through um in all
22:20 - the time today
22:21 - so now we're under 505 which is in which
22:25 - you the audience answers five questions
22:28 - in five
22:29 - minutes and i believe that emily will be
22:31 - taking over
22:32 - for this uh
22:35 - yeah so let's start the five under five
22:39 - okay that's perfect
22:42 - let's start with the first question so
22:45 - as you can see we have
22:46 - a section of the code on the screen so
22:49 - can anyone tell me what the output would
22:51 - be for this code
22:55 - okay so here is the answer so as you can
22:59 - see the output
23:00 - is actually four cat and one
23:03 - so the reason for this is because um
23:06 - the first start option is not given
23:10 - and the second stop option is also not
23:13 - given
23:13 - which means that it will start at the
23:15 - beginning of the string
23:17 - and it will move all the way until the
23:19 - end of the string
23:20 - note the negative in the steps that's
23:23 - moving backwards
23:24 - so it'll start at four which is the
23:27 - first
23:27 - index um in a string that is going
23:31 - backwards and then
23:32 - yeah yep perfect if everyone understands
23:36 - that
23:36 - then you can see how the output would be
23:39 - four cat and one
23:40 - so let's move on to the next slide
23:46 - hey so what is the output of this code
23:51 - okay perfect so as you can see yep the
23:53 - answer is boop
23:55 - that is correct and just as
23:58 - a reminder of something you might have
24:00 - learned before since
24:01 - the first if statement is an and uses an
24:05 - and expression the statement will only
24:08 - evaluate the first part
24:10 - so it will evaluate if a is smaller than
24:12 - 10 and if the first condition is false
24:15 - it won't even check the second part
24:16 - which is
24:17 - four in a and it'll just skip to the
24:20 - else statement and print boop
24:22 - and it's similar to an or expression
24:24 - where if the first condition
24:26 - in the expression is already true the
24:28 - second one won't be checked at all
24:30 - so it will like the program will try and
24:33 - save the time and just
24:34 - skip checking something that doesn't
24:36 - need to be checked
24:39 - next question
24:43 - question number three now you have this
24:46 - piece of code what do you think it will
24:48 - output
24:48 - this one's actually quite tricky so
24:52 - you guys are actually correct it will be
24:54 - an empty list
24:55 - because it starts from the negative
24:57 - indexing and it's
24:59 - trying to go all the way back to the
25:00 - beginning but since a list
25:02 - can't yeah
25:05 - well you were correct in guessing it was
25:07 - an empty list actually
25:09 - because of how the indexing works it
25:12 - won't be able to
25:13 - access the earlier indexes in the code
25:16 - so it'll just produce an empty set
25:23 - okay fourth question
25:29 - so here is an example of a piece of
25:32 - code and you guys will have to try and
25:36 - spot
25:36 - the problem in it so let's go in
25:40 - to the answer slide and that is correct
25:45 - as you can see in the second line
25:48 - it uses two different types of quotation
25:50 - marks
25:51 - and that doesn't really work in python
25:55 - so you should only use
25:56 - one set of quotation marks yes it is
25:59 - it's super hard to
26:00 - spot these problems but it's great for
26:04 - debugging that you can actually
26:06 - see where the problems in the code is so
26:09 - yeah just remember that each pair of
26:11 - quotation marks
26:12 - should be only used to either use the
26:14 - double or just the single
26:15 - when you're you trying to identify
26:18 - something as a string
26:24 - [Music]
26:26 - okay everyone last question it's
26:29 - another kind of error that could
26:32 - happen when writing your code see what
26:35 - the answer is
26:39 - it's all good it's all good so as you
26:42 - can see
26:44 - these the problem with using true
26:47 - is true equals false is in the first
26:50 - line
26:51 - because we aren't able to use keywords
26:53 - as variables or identifiers
26:56 - so since at the beginning in the first
26:58 - line they're trying to use
27:00 - true as a variable but in
27:03 - the loop they're trying to use true
27:06 - for it um as like a boolean
27:10 - and that is impossible so it's just
27:14 - you try and avoid using keywords such as
27:17 - true false and or not
27:20 - these kind of terms as variables because
27:23 - they're actually used as
27:25 - identifiers in the in programming
27:28 - already
27:29 - so just avoid using these words as
27:32 - variables
27:34 - okay cool i think that is the
27:38 - end of the five under five all right
27:40 - great thank you very much emily
27:42 - even though i can hear you the entire
27:43 - time it seems like we've got some great
27:45 - participation
27:47 - so i guess i'm going to skip the
27:49 - workshop because this is very similar to
27:51 - that example that we had before
27:52 - regarding system preferences and
27:55 - configs so um because we're coming up on
27:59 - time i know that people have to leave
28:00 - soon but
28:02 - if you're able to sort of attempt this
28:04 - challenge problem
28:05 - then this would be very good for your
28:07 - understanding of lists and how to use
28:09 - them
28:10 - in fact in this problem uh you may have
28:13 - to even look up some documentation about
28:15 - how to do certain things
28:17 - uh using a python list python or using
28:19 - separate data structures to make it
28:21 - uh faster so the challenge problems is
28:25 - in
28:25 - uh itself find the first missing
28:28 - positive number
28:29 - in the list so for example um
28:32 - zero itself is not a missing positive
28:34 - number um so
28:36 - let's check out one one is not missing
28:37 - because it's in the list
28:39 - two is not listing uh because it's in
28:41 - the list
28:42 - and three is not listing uh missing
28:44 - these lists so therefore the first
28:46 - missing positive number is four
28:48 - uh it should do the same thing with this
28:50 - next list
28:51 - uh one is in the list two is in the list
28:54 - but the first one missing positive
28:55 - number is three
28:56 - um regardless of whatever this is so
29:01 - the first challenge is to
29:05 - do so without certain
29:08 - you can do it in sort of a slow way
29:11 - without using any extra
29:14 - data structures um because this was
29:16 - originally a
29:18 - set stand lists
29:21 - lessons so we sort of have some remnants
29:24 - of that um
29:27 - the next challenge is to do it with
29:29 - using a set
29:30 - um you may have to do some googling on
29:32 - how to exactly use that but
29:34 - the applications here are is pretty
29:36 - straightforward
29:37 - um and then finally uh the challenge is
29:39 - to do it both in a way that scales very
29:42 - well um it scales such that when you run
29:45 - this algorithm it it goes
29:49 - pretty fast regardless of how long the
29:51 - list itself is
29:53 - and also you have to do it without using
29:56 - any extra
29:57 - space or any new
30:00 - data structures or converting your
30:02 - existing
30:04 - data structure into something else i'll
30:07 - go over
30:08 - the answer and this function or this
30:11 - function itself essentially what it does
30:13 - is that it just times
30:15 - how long a function takes so we have
30:17 - three solutions here
30:18 - one with the new data structure
30:22 - that you haven't learned yet this uses a
30:23 - set um
30:25 - and it uses extra space as well so
30:28 - uh this is sort of a fast but a little
30:31 - bit
30:32 - cheaty way because or actually it's not
30:33 - like cheap but it just doesn't
30:35 - fulfill the um
30:39 - the actual
30:42 - stipulations of the challenge itself
30:44 - this one does but it is quite slow and
30:46 - we can see exactly how slow
30:48 - uh later and this one is the version
30:50 - that uses no extra data structures or
30:53 - extra space
30:54 - and it uses everything that we learned
30:56 - in
30:57 - this lesson in addition to the previous
30:59 - lessons regarding for loops
31:02 - and also it runs in a relatively quick
31:05 - way so i'll just give sort of a quick
31:07 - um a quick overview if people are still
31:10 - in this call
31:11 - um let's see so regarding extra space
31:15 - um it uses something called the set what
31:17 - we do is that you know we take
31:19 - everything
31:20 - um that's uh in the array and then we
31:22 - cast it
31:23 - or convert it into a set and what a set
31:25 - allows you to do
31:26 - is that allows you to look up whether or
31:28 - not something is in the set or it's not
31:30 - in the descent
31:31 - in a very fast time it's not sort of a
31:34 - search through the entire array
31:36 - it is just in we call it a constant time
31:38 - operation or
31:39 - or one operation so then you
31:44 - go from one starting at one you know the
31:46 - first positive number to the last
31:48 - possible
31:48 - positive number that which would be the
31:50 - length of the array because
31:52 - um if you consider that you know you
31:53 - have all these elements in this ring
31:56 - and if you have uh and all of them are
31:58 - there then the last possible one
32:00 - is the is the last element or the actual
32:02 - length of the
32:03 - ring so if you run
32:06 - uh this function um it checks if it's
32:10 - uh if if when you're going through from
32:12 - all the possible positive numbers
32:14 - um checks if it's in the set itself
32:18 - and then if it's not there you return
32:22 - that number otherwise you return one
32:24 - above it which is
32:25 - all the possible elements that could be
32:28 - there are in
32:29 - the original array and then therefore
32:31 - you want to return one over that which
32:32 - is the first
32:33 - possible um uh missing positive element
32:37 - this one is slower and it looks very
32:39 - very similar but essentially what you do
32:41 - is that you don't ever
32:42 - create this new set you don't use extra
32:44 - space and you don't use the
32:47 - the data structure set um
32:51 - at all but rather what you do is that
32:54 - you do
32:55 - uh you you check if and it's not in the
32:57 - array
32:58 - in fact this keyword is exactly the same
33:00 - but because
33:01 - the array is an ordered uh data
33:03 - structure
33:04 - you can do a search very quickly for the
33:06 - actual like what is inside
33:08 - of the array or this little list
33:12 - so therefore it'll run very very slowly
33:15 - when it starts to get
33:16 - to larger um larger elements
33:20 - and then i can show you and then this i
33:23 - can get into later but
33:24 - i'll just just show you that it took 12
33:27 - seconds
33:28 - for a list of 10 000 elements
33:31 - for the slow first amazing to run which
33:33 - was what i had said for the brings low
33:36 - and then for the one that didn't fulfill
33:38 - the challenges
33:40 - stipulations it took just uh 0.25
33:43 - uh milliseconds which is two orders of
33:46 - magnitude
33:47 - probably three orders of magnitude
33:50 - faster than the slow
33:52 - function um but
33:55 - uh you can see that my implementation
33:58 - which
33:59 - fulfills the challenge because it
34:00 - doesn't use any stats or any extra space
34:03 - it still runs in a reasonably quick
34:05 - amount of time even though it's ten
34:06 - thousand you know it's a matter of
34:09 - two uh orders of magnitude it's not that
34:12 - much slower than
34:13 - using extra space so we'll see how we
34:15 - did that
34:17 - so the idea is um and this would make
34:19 - more sense
34:20 - if you sort of knew what sets were
34:24 - again this lesson used to be about both
34:26 - lists and success but essentially what
34:28 - you do is that you sort of use your
34:29 - existing array
34:31 - as a way to check whether or not
34:34 - that element is already existent in the
34:37 - original array
34:39 - you use this sort of as
34:43 - itself so you use the initiative array
34:47 - as the way to check if the number is
34:48 - already in the original array
34:50 - for example if uh you're trying to find
34:53 - like the first
34:53 - positive missing number and
34:57 - you want to check if one two and three
34:59 - are in an array
35:00 - we then can use in x1 and index three
35:04 - and we can set it as negative to
35:06 - indicate that yes it is there so
35:07 - therefore we
35:08 - sort of change the search operation from
35:11 - scanning the entire array to just
35:15 - an o of one index access and in reality
35:18 - because we're not trying to we're trying
35:19 - to
35:20 - conserve space here we use the next zero
35:21 - into this index answer
35:24 - and the idea is that for every single
35:27 - one
35:28 - of the numbers that are not going to be
35:31 - in that set
35:32 - of uh of numbers that will be
35:36 - um sort of impossible uh
35:39 - answers for the first missing positive
35:41 - you you set that to a number that
35:44 - that won't interfere with what we're
35:46 - going to be doing next
35:47 - and what we're going to be doing next is
35:49 - specifically that if
35:50 - the number is in the
35:53 - set of possible missing numbers you set
35:57 - it to
35:58 - a negative
36:01 - and what this does essentially is that
36:03 - if you had already said that before
36:05 - if you had have copies of the same
36:08 - element
36:08 - in this first set of possible first
36:11 - missing positive numbers in the actual
36:13 - array itself
36:14 - then it won't set it to a negative again
36:16 - thus making it positive it'll just
36:18 - keep making it negative so therefore
36:21 - when you actually
36:23 - iterate through the actual array itself
36:24 - the first missing positive is actually
36:26 - the first uh positive number um
36:29 - that is uh that is
36:34 - that is positive in the array because we
36:37 - had set everything
36:38 - from uh prior to that already as
36:42 - negative to indicate that it is
36:43 - integrated so we return the actual index
36:45 - itself
36:46 - so that is how you do the challenge
36:48 - problem

Cleaned transcript:

um i will um just um just go over the agenda um and also just brief back into indexing and then we'll come back to where we were before so um our agenda today is back on the list um also introductions uh because we are recording right now in fact um so uh if you have um uh so so just as a heads up this will be listed on a youtube later um so we'll be covering next things licensing list functions and also a demo at the end um i'm not sure when we arrived but i'll just go over this really quick um and that's you index uh you index uh you next starting at zero um you can't index out of the array although i still throw a list error i'll show an example all that so you can exit you start indexing zero the first element in uh one in this case you try to index out but if you'll throw an indexer you can index from the back as well negative one being this element right here essentially uh one from the back or in this case it is the one for from the back and then you can do that for as much as you like as well and then you can also run into index areas if you try to index out from the back so if you have any questions or the people who came late then please come and ask questions um yeah so you can do some uh setting of the actual values itself during this uh mutability um yeah earning one inverse list yeah that's absolutely correct um the reason why that is is because the the the the two optional parameters that you're passing in um for the first option uh is zero because uh the default is zero and it starts to zero uh the next optional parameter um or a default parameter is the end of the list or the language list so essentially you try to go from the the end of the list to the beginning of the list indexing backwards or using a negative one step in there or it will go backwards so more on slicing that's more exciting so the question was why does this example not include zero or not include one you can see that you know it goes from five four three and two and it doesn't do one the reason why that is is because the end operator uh or the end parameter um does not include uh it is inc conclusive so it is sort of the same idea once you go from zero to four it doesn't include this five because the last element is not um it's not included so if you go from four to zero zero is not included so therefore one won't be printed so uh um yeah so this is what i was talking about with regards to uh the default parameters uh the digital default parameter of this was is a negative one i believe so um actually sorry it's not it's not exactly negative one but it's essentially to the end of the list so therefore you start at zero and two three and then it goes uh it's zero one two three yeah to four and then it goes to the end of the list the actual counter of this being the end of the list might be it's not exactly that it's not exactly the blank slate actually yeah the the the optional parameter in this case would be the end of the list and then if you try to index out to the end of the list uh normally it'll throw an index error but if you want to include that left element you go one above what you can usually um index um in this case the optional parameter is not the end parameter but the first parameter that being the beginning that lifts so you go from zero one two and then not include into three so that would be zero one two not including three which would be the four in this case so one two three and then um in this case um here i'll make it even better um the optional parameter is the beginning of the list the end of the list and negative one is the error that you put in for the step so therefore it would then reverse the list so you're going from uh not quite the beginning of the list because then uh uh if you try to do do this and this i believe i lost my mistake it does pretty empty but it's something close to you know the end of the list and that way you're able to reverse it so as far as what is a print you know you have no start parameter you have no end parameter so therefore the optional parameters or the default parameters of those uh is the beginning of the list to the end of the list so therefore this prints out the entire list this is just an example in which you um do the exact same thing except you have a step of two so it'd be one three and possibly including five i think it does include five yeah and then this is an example of what camilo had said before about this reversing list so good all right cool so um we sort of had this list uh data structure we've been interacting with it through slicing and initialization as well as um indexing as well but there are also just a variety of other functions that you can use with a list in order to modify or uh or to sort of work with what is the actual contents of the list um and this is by no means an exhaustive um account of all the list functions in fact in order to get that you might want to google python three lists functions over here the python box you can see that there is quite a lot but we'll just be covering perhaps the most important ones so um let's see you begin with this initialized list of one two three two um this is something that we've seen before and then what happens when you use the pen method with the element that you want to append to it you place it at the end of the list over here and not only do you do that you modify the list itself so it doesn't sort of it doesn't return a copy of the list it is you know the mutable data structure itself so when you do that you get one two three two four because four has just been intended to do that um let's see i'm gonna make this not just i'm not i'm not gonna make it pop too because most common use cases of pop is that um it removes the last element which i should be working this it removes the last element the last index um and then returns that element as well so you have initialized as one two three and two you first printed a so that should just be one two three and two and then when you pop it it will return the two because it removes the element at the last list and then when you print again the list should have been modified such that the last element of the list is no longer there so you can see that you know you start with your original data structure you pop it it returns to and then you print it again and then it no longer has two at the end and then you can pass some parameters as well such that you remove things in the middle of the actual data structure as well although um i would advise you actually to not do this for reasons i won't get into now but essentially there are certain operations in python that's uh for list specifically that runs slower than others because of the way that the lists are implemented actually in the in the depths of the language so the difference between pop and remove is that uh you can see that um when when we try to pop the the index at two it returns the three and then it modifies it such that you have your one two two list afterwards and in this case actually removes the first two yeah so actually remove doesn't remove the actual um index but remove the first case of what you passed in here and this is an example of a function that may run slower if you have like a longer list but we don't want to get into that right now and also when you do that it doesn't uh return to as well so you can see it best most likely this will print a none and then this is different from when you popped it it actually did return the value and then finally insert another example of something that most likely you probably don't want to do too often or you have a very long list because they'll run slowly um is um insert um let's see inserts index two right so the first parameter is the index you want to insert that so in that case it'd be zero one and then two over here the inserts sort of before so this it would be um index two if you got inserted um uh once you have inserted it so you can see that is the case that you have uh next arrow index one and the next two and because you inserted index two ten is now there um see if i can show an example of why you don't want to pop or insert or you want to pop it a space for index and i'll show you why that may be so we're going to create a very large list of say a million elements um i'm not going to print a but we're going to just see how long it takes for these functions to run so see let's uh pop right here is that so pop will be very quick with an insert which should be very slow if you try to insert and like the middle of the actual so pop is very quick and then see how long it takes to get to here it was all right so maybe we'll add another zero search 10 and next two oh wait yeah insert 10 i think um generally these their structures are quite efficient um from a clear sense perspective um this operation should take a little bit longer but uh so an example of why you may not want to insert is because generally if you insert see if you do this and just comment out the actual insert this will be pretty quick i believe yeah this should be pretty quick but then this itself should be relatively slow when comparing the two although still not super slow um if we can use the timing function and get more into that then i would but it's a little bit slow let's see i'll start your interrupt i only see half your shirt screen i don't see the console so let me get to this question first can you do with the strings through the list yes um and the reason why that is is actually so i'm not sure by it um you can do indexing and slicing of a string but because what it does is that it converts a string into a list prior to doing that once you try to use any sort of indexing or spacing operations on it but and then and you can see like an example that here i will show you okay this should be fine so rather than oh god it should really be working so rather than this being a list now it's string a b c d e f g i'm indexing works as you might expect you have to try to get the character as index zero um it's a slicing works but perhaps not in the way that you may expect so for example you want to slice from zero to two you might think that okay it's a b right zero one but then when you do that um actually it does work the way that you expect um see if this works as well yeah so uh slide slicing works with the list as well um but then because a streaming is an immutable type when you try to append something not only will not recognize that function because string object has no uh and its list um list has that uh as that function against two lists first then you would be able to then see this this is now a valid operation just kind of a to the end of it um but uh yeah um because append is something that modifies the actual immutable uh data structure list and the string is an immutable data structure you won't be able to append to it and in fact when you do things like string edition a is equal to a plus another string let's add a to the end of that it's creates a um it creates a new string actually it doesn't append to the end of it um the details of which you might learn in computer science class regarding data functions and algorithms but essentially rather than just adding a to the end of the string what it does is that it copies the entire thing as an a at it and then it says so it's much slower operation which might come into play if you um if you sort of work with long strings or long lists or long screens as opposed to long lists so this is sort of a interesting demo of what the capabilities of the list are sort of combining everything that we had just seen in addition to what we had learned last week in regards to infinite loops and um what happened here anyways i'll just ignore that i guess hopefully the invitation is not okay big list if envelope syntax line 38 i see okay somebody over here i guess i'm a little bit confused about which one i should be using let's so um there's a few configs that you can set um first it runs through this infinite wild true loop um it prints out this cursor for you to sort of type into and then it waits for your input um in this case if we type exit it will just um let's go here oh yeah i think you'll run this one again so actually i will start this again i won't exit i should actually exit the terminal um because you just input exit it reads configuration and um if you do it again try to set a config like screen just just initialize this list um all right yeah so uh you're trying to set one under configs but it has to be in the format of config is equal to the value say like 100 and then afterwards that contact is set so therefore when you exit it should um actually kind of confused about what this example is because i didn't quite i was the one who wrote it um all right yes let's print.config list once we actually exit screen brightness to 100 and then when you exit out it should print out you know your list of screen rightness and now how that does that is that um it takes your input um it splits uh this parameter or the string you just put it into two parts so the extreme brightness part and the and the actual um integer part it checks if um it's in the configs that that being said right here and then once you exit it out it will just print out how it was so um yeah that's like so something that you can do with liz you can write command line operations although this is by all means sort of um it's uh like a small part of what lists are used for in actual computer science or software development context yes camille says you can always convert a string to a list um yes that that's true um the difference being that uh when you do so it then becomes list which is sort of immutable data structure and then in order to get it back into a string you have to use the the the join function um which i can actually i think this is quite a useful list function so i will sort of demonstrate that as well to go back to that point so you have your string as as before abcde abc um if you print the list is going to also then you convert it into the list itself you can see that you know it's not the string itself but rather it's the list of the individual charge of the string um and then once you have that in that format you can convert it back into a string by using the join function which you take all the elements inside of this list and then you put it together with the separator over here so when you do that it becomes acde again if you change the separator to a dash it'll print out a so as i said before this is all the things that you can do or all the functions that were list in fact that itself was a stream function that took a list in as a parameter so there's even more things that you can do with the lists that we can't possibly get through um in all the time today so now we're under 505 which is in which you the audience answers five questions in five minutes and i believe that emily will be taking over for this uh yeah so let's start the five under five okay that's perfect let's start with the first question so as you can see we have a section of the code on the screen so can anyone tell me what the output would be for this code okay so here is the answer so as you can see the output is actually four cat and one so the reason for this is because um the first start option is not given and the second stop option is also not given which means that it will start at the beginning of the string and it will move all the way until the end of the string note the negative in the steps that's moving backwards so it'll start at four which is the first index um in a string that is going backwards and then yeah yep perfect if everyone understands that then you can see how the output would be four cat and one so let's move on to the next slide hey so what is the output of this code okay perfect so as you can see yep the answer is boop that is correct and just as a reminder of something you might have learned before since the first if statement is an and uses an and expression the statement will only evaluate the first part so it will evaluate if a is smaller than 10 and if the first condition is false it won't even check the second part which is four in a and it'll just skip to the else statement and print boop and it's similar to an or expression where if the first condition in the expression is already true the second one won't be checked at all so it will like the program will try and save the time and just skip checking something that doesn't need to be checked next question question number three now you have this piece of code what do you think it will output this one's actually quite tricky so you guys are actually correct it will be an empty list because it starts from the negative indexing and it's trying to go all the way back to the beginning but since a list can't yeah well you were correct in guessing it was an empty list actually because of how the indexing works it won't be able to access the earlier indexes in the code so it'll just produce an empty set okay fourth question so here is an example of a piece of code and you guys will have to try and spot the problem in it so let's go in to the answer slide and that is correct as you can see in the second line it uses two different types of quotation marks and that doesn't really work in python so you should only use one set of quotation marks yes it is it's super hard to spot these problems but it's great for debugging that you can actually see where the problems in the code is so yeah just remember that each pair of quotation marks should be only used to either use the double or just the single when you're you trying to identify something as a string okay everyone last question it's another kind of error that could happen when writing your code see what the answer is it's all good it's all good so as you can see these the problem with using true is true equals false is in the first line because we aren't able to use keywords as variables or identifiers so since at the beginning in the first line they're trying to use true as a variable but in the loop they're trying to use true for it um as like a boolean and that is impossible so it's just you try and avoid using keywords such as true false and or not these kind of terms as variables because they're actually used as identifiers in the in programming already so just avoid using these words as variables okay cool i think that is the end of the five under five all right great thank you very much emily even though i can hear you the entire time it seems like we've got some great participation so i guess i'm going to skip the workshop because this is very similar to that example that we had before regarding system preferences and configs so um because we're coming up on time i know that people have to leave soon but if you're able to sort of attempt this challenge problem then this would be very good for your understanding of lists and how to use them in fact in this problem uh you may have to even look up some documentation about how to do certain things uh using a python list python or using separate data structures to make it uh faster so the challenge problems is in uh itself find the first missing positive number in the list so for example um zero itself is not a missing positive number um so let's check out one one is not missing because it's in the list two is not listing uh because it's in the list and three is not listing uh missing these lists so therefore the first missing positive number is four uh it should do the same thing with this next list uh one is in the list two is in the list but the first one missing positive number is three um regardless of whatever this is so the first challenge is to do so without certain you can do it in sort of a slow way without using any extra data structures um because this was originally a set stand lists lessons so we sort of have some remnants of that um the next challenge is to do it with using a set um you may have to do some googling on how to exactly use that but the applications here are is pretty straightforward um and then finally uh the challenge is to do it both in a way that scales very well um it scales such that when you run this algorithm it it goes pretty fast regardless of how long the list itself is and also you have to do it without using any extra space or any new data structures or converting your existing data structure into something else i'll go over the answer and this function or this function itself essentially what it does is that it just times how long a function takes so we have three solutions here one with the new data structure that you haven't learned yet this uses a set um and it uses extra space as well so uh this is sort of a fast but a little bit cheaty way because or actually it's not like cheap but it just doesn't fulfill the um the actual stipulations of the challenge itself this one does but it is quite slow and we can see exactly how slow uh later and this one is the version that uses no extra data structures or extra space and it uses everything that we learned in this lesson in addition to the previous lessons regarding for loops and also it runs in a relatively quick way so i'll just give sort of a quick um a quick overview if people are still in this call um let's see so regarding extra space um it uses something called the set what we do is that you know we take everything um that's uh in the array and then we cast it or convert it into a set and what a set allows you to do is that allows you to look up whether or not something is in the set or it's not in the descent in a very fast time it's not sort of a search through the entire array it is just in we call it a constant time operation or or one operation so then you go from one starting at one you know the first positive number to the last possible positive number that which would be the length of the array because um if you consider that you know you have all these elements in this ring and if you have uh and all of them are there then the last possible one is the is the last element or the actual length of the ring so if you run uh this function um it checks if it's uh if if when you're going through from all the possible positive numbers um checks if it's in the set itself and then if it's not there you return that number otherwise you return one above it which is all the possible elements that could be there are in the original array and then therefore you want to return one over that which is the first possible um uh missing positive element this one is slower and it looks very very similar but essentially what you do is that you don't ever create this new set you don't use extra space and you don't use the the data structure set um at all but rather what you do is that you do uh you you check if and it's not in the array in fact this keyword is exactly the same but because the array is an ordered uh data structure you can do a search very quickly for the actual like what is inside of the array or this little list so therefore it'll run very very slowly when it starts to get to larger um larger elements and then i can show you and then this i can get into later but i'll just just show you that it took 12 seconds for a list of 10 000 elements for the slow first amazing to run which was what i had said for the brings low and then for the one that didn't fulfill the challenges stipulations it took just uh 0.25 uh milliseconds which is two orders of magnitude probably three orders of magnitude faster than the slow function um but uh you can see that my implementation which fulfills the challenge because it doesn't use any stats or any extra space it still runs in a reasonably quick amount of time even though it's ten thousand you know it's a matter of two uh orders of magnitude it's not that much slower than using extra space so we'll see how we did that so the idea is um and this would make more sense if you sort of knew what sets were again this lesson used to be about both lists and success but essentially what you do is that you sort of use your existing array as a way to check whether or not that element is already existent in the original array you use this sort of as itself so you use the initiative array as the way to check if the number is already in the original array for example if uh you're trying to find like the first positive missing number and you want to check if one two and three are in an array we then can use in x1 and index three and we can set it as negative to indicate that yes it is there so therefore we sort of change the search operation from scanning the entire array to just an o of one index access and in reality because we're not trying to we're trying to conserve space here we use the next zero into this index answer and the idea is that for every single one of the numbers that are not going to be in that set of uh of numbers that will be um sort of impossible uh answers for the first missing positive you you set that to a number that that won't interfere with what we're going to be doing next and what we're going to be doing next is specifically that if the number is in the set of possible missing numbers you set it to a negative and what this does essentially is that if you had already said that before if you had have copies of the same element in this first set of possible first missing positive numbers in the actual array itself then it won't set it to a negative again thus making it positive it'll just keep making it negative so therefore when you actually iterate through the actual array itself the first missing positive is actually the first uh positive number um that is uh that is that is positive in the array because we had set everything from uh prior to that already as negative to indicate that it is integrated so we return the actual index itself so that is how you do the challenge problem
