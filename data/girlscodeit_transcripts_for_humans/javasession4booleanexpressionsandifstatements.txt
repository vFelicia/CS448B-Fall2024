With timestamps:

00:00 - all right so hey guys my name is jessica
00:03 - and i'm a senior cs major from
00:05 - university of maryland college park
00:07 - um today we're just gonna be talking
00:10 - about
00:11 - um booleans and boolean expressions and
00:13 - things like if statements
00:16 - so um first like we'll just be going
00:20 - over like what's a boolean
00:21 - um any operators that you'll be like
00:24 - you have to use with booleans and any
00:27 - operations that
00:28 - deal with like that can return like a
00:30 - true or false
00:32 - um next we'll be talking about things
00:33 - like if else statements elsif
00:36 - um switch statements these are just
00:37 - things um
00:39 - these are just conditionals that you can
00:40 - use with booleans and then
00:43 - um i'll give you like resources and
00:46 - if you want to we can go for a workshop
00:48 - otherwise like
00:49 - we can just ask questions or like i'll
00:51 - try to give you guys
00:52 - um trick questions or something like
00:54 - that um
00:56 - again like if you guys have any
00:59 - questions
01:00 - um feel free to just either interrupt me
01:02 - and you if you're comfortable
01:04 - or um just drop a question in chat and
01:06 - i'll try to answer as quickly as
01:07 - possible
01:09 - um if you guys like feel free to let me
01:11 - know if you want like
01:13 - me to go over slide or just slow down or
01:16 - speed up
01:16 - anything like that
01:21 - all right so
01:24 - um first off i'm just gonna go over what
01:26 - is a boolean
01:27 - a boolean is basically a data type um if
01:31 - you remember the
01:32 - primitive types we went over for the
01:34 - second lesson
01:35 - um this was one of the types of
01:37 - variables we covered
01:38 - um it only holds two values true or
01:41 - false
01:42 - and um just like any other non-constant
01:45 - variable
01:46 - its value can change like depending on
01:49 - um its value can basically change
01:53 - during the course of your code and
01:55 - basically just reflect like the change
01:56 - in the condition
01:58 - so um basically it's just
02:01 - a variable that can hold a true or false
02:03 - value
02:05 - um these are just two examples of
02:06 - boolean so one is like
02:09 - light on which can be true or cloudy
02:11 - which is false
02:14 - [Music]
02:16 - so first i'm just going to go over
02:19 - boolean operators
02:20 - so these are operations you can do on a
02:22 - boolean
02:23 - um the first one is this exclamation
02:26 - point
02:26 - which means not um two ands
02:30 - mean and and then these two straight
02:32 - lines they're called pipes
02:34 - this means or um these are just like
02:37 - little operations you can
02:39 - um you'll have to memorize with a
02:40 - boolean any questions about these
02:47 - sweet so i'm just gonna show you guys a
02:50 - demo
02:51 - using um these three operators
02:56 - i'm gonna see if i can share it
02:58 - [Music]
03:00 - and i'll just drop the link in chat
03:04 - so um basically this is just a demo
03:08 - showing you guys
03:09 - how these operations work so um i have
03:12 - this program
03:13 - where a equals true and b equals false
03:17 - um and basically if i do
03:20 - a or b um this should print true
03:24 - because a is true and
03:28 - even though b is false um
03:31 - something else is a and b which open
03:33 - false because b is false
03:36 - and then finally not b which would be
03:39 - true
03:40 - um do you guys kind of get how this
03:42 - works
03:44 - so basically or is if both statements
03:47 - or if both statements are false then or
03:50 - will be false but if one
03:52 - or the other statement is true then it
03:54 - will be true
03:56 - and as they either have to they have to
03:58 - be both true
03:59 - to be true if one of the statements is
04:02 - false
04:02 - then a return false completely and then
04:05 - finally not is just the opposite
04:07 - so if we run this this should print true
04:10 - false then true
04:15 - [Music]
04:16 - and then just something to um to note
04:20 - so basically um a fun fact is that
04:24 - computers are very lazy they want to
04:27 - they want to do the least work possible
04:29 - so basically how um something like an or
04:32 - statement can work
04:34 - is if a is true then
04:37 - the statement is just confirmed true
04:39 - right i don't even have to check the sec
04:41 - if the second statement is true so if a
04:43 - is true
04:44 - then um java will basically exit this
04:47 - statement
04:48 - and be like this statement is true um
04:51 - but if this is false then i'll have to
04:53 - check the second statement um
04:56 - for another example is like if um a is
04:59 - false over here
05:00 - then the rest of the statement no matter
05:03 - like what the rest of the statement is
05:05 - this and expression is just completely
05:07 - false
05:08 - so if a is false then b will not be
05:11 - checked
05:12 - so b just um basically java just won't
05:16 - even compute b
05:18 - so um but if like a is true
05:21 - then java will have to check if b is
05:23 - false
05:25 - so this can be really helpful if you
05:27 - want to
05:29 - do like little tricky um basically do
05:32 - some tricky programming in java
05:34 - just remember that computers are lazy
05:37 - and for or statements if the first
05:40 - statement is true
05:41 - the second statement won't be checked
05:43 - and for
05:44 - and statements if the first statement is
05:47 - false
05:48 - the second one won't be checked um any
05:52 - questions about this
05:57 - [Music]
05:58 - all right sweet
06:02 - so next i'm just going to talk about
06:05 - operators
06:06 - that don't necessarily involve booleans
06:09 - but return of boolean so things like if
06:12 - you're checking
06:13 - an equals like if two
06:16 - variables are equal to each other um you
06:20 - can't
06:20 - it hi about this these don't necessarily
06:24 - involve booleans
06:25 - like you can check if one equals two but
06:28 - one and two aren't boolean types
06:30 - but it will return a boolean so a true
06:32 - or false so the first one
06:35 - is we have this double equals and this
06:37 - compares physical equality
06:39 - so do the two variables hold the same
06:42 - value
06:43 - in memory and then the second one is a
06:46 - dot equals
06:47 - so an equals method and this compares
06:50 - content equality
06:51 - so are the contents of these two
06:54 - variables the same
06:56 - um then we have like greater greater
06:59 - than less than
07:00 - greater than or equal to less than or
07:02 - equal to um i think these last four are
07:04 - self-explanatory
07:06 - but um to go further into the double
07:08 - equals versus
07:09 - um dot equals um double equals
07:13 - um compares if these variables hold the
07:15 - same value in memory
07:17 - and that equals compares the content so
07:20 - if you remember
07:21 - um in last lesson when we talked about
07:25 - um about reference types reference types
07:29 - um are actually variables that hold
07:31 - addresses right
07:32 - they basically point to the object
07:34 - instead of
07:35 - containing the value of the object
07:40 - so when you have
07:43 - when you have something like that um
07:46 - basically
07:48 - basically um your like
07:51 - the physical memory and content and
07:54 - whatever content
07:55 - that your object has can be different
07:57 - right so you can have two strings
08:00 - that both have like a b c d but they can
08:02 - be in different places in memory
08:04 - so that's why we have this equals equals
08:07 - but
08:08 - a dot equals method so um
08:12 - i think this might be better explained
08:14 - if i show you the demo
08:17 - so if i have um
08:20 - something like if i have if i create two
08:24 - strings
08:25 - and they're both called high so if i
08:28 - have
08:28 - um like this one string
08:32 - will be in one place in memory and then
08:34 - two string will be in a different place
08:35 - in memory
08:36 - so if i compare one string equals equals
08:38 - two string
08:40 - um these two variables are pointing to
08:42 - different places in memory so this would
08:44 - return
08:44 - false because they're technically
08:48 - not the same object right however if i
08:51 - do one string
08:52 - that equals to string this would return
08:54 - true
08:55 - because the content of these these two
08:57 - strings are true
08:59 - are the same all right
09:02 - um and we can also just look at
09:05 - examples of the other
09:09 - the other operators so actually let me
09:11 - just
09:13 - so um the other examples are just like
09:16 - if you have integer a equals 10 b equals
09:19 - 7
09:20 - um if you do like a um is a
09:23 - equals a double equals b plus 3
09:26 - then this will return true because 10
09:28 - equals 7 plus 10 or
09:30 - 7 plus 3. um same
09:33 - same idea for this so like is a less
09:36 - than 10
09:36 - is 10 less than 10 not not really so
09:40 - it will return false but if i do like is
09:43 - a less than or equal to 10
09:44 - um you kind of get the idea that like
09:48 - these are basically the same same idea
09:51 - as like
09:52 - in math basically um
09:55 - oh yeah something else about the dot
09:57 - equals um
09:59 - something else to know about the dot
10:00 - equals method is that all objects have
10:02 - this dot equals method
10:04 - and the general rule is unless you're
10:07 - actually checking
10:08 - that like um like the physical
10:12 - equality like are these two objects
10:14 - exactly the same object
10:16 - in like the physical memory space
10:19 - then like you should generally always
10:22 - use the dot equals method
10:26 - um we also have some we also can do like
10:31 - like different um we can also use these
10:34 - same operators with like other
10:36 - primitives
10:37 - so like you have um chart
10:40 - a or symbol one equals a symbol two was
10:44 - b
10:45 - um we can also do like a symbol one less
10:48 - than or equals to symbol two
10:51 - so why would you think this this would
10:54 - print true
10:56 - so how can we basically
11:00 - basically um tell if this character a
11:05 - is less than b um the general idea is
11:09 - just that like
11:10 - like we talked about in the primitives
11:12 - lecture you can basically convert
11:14 - any symbol like abcd
11:17 - yeah exactly so um according to
11:21 - the ascii table yeah according to the
11:24 - ascii table
11:26 - these characters can be converted into
11:28 - numbers
11:29 - so i think a is like 63 or something and
11:31 - then b is 64.
11:33 - so um that's why symbol 1 is less than
11:36 - symbol 2.
11:37 - and then same idea for this so this
11:40 - would print false because
11:42 - 63 is not greater or equal to 6
11:45 - um 64. 64. yeah
11:49 - however like if you if you try to use
11:52 - like this less than or equal to
11:55 - with like booleans that wouldn't work
11:57 - because um
11:59 - because java will basically be like you
12:02 - can't use this on a boolean
12:04 - um that would it would just throw a
12:05 - compiler error
12:07 - so just be aware of that like even
12:09 - though you can convert
12:11 - characters into numbers um you can't
12:13 - really do the same thing
12:15 - with um booleans
12:19 - any questions about this
12:24 - all right so
12:28 - next um we're just going to talk about
12:30 - um basically
12:32 - if um conditionals basically
12:36 - so things like if statements um is if
12:39 - else if
12:40 - um and then these fancy things called
12:43 - switch statements
12:46 - so the first one is just if else
12:48 - statements
12:49 - um these are just these are base the
12:52 - most basic form of conditionals so like
12:55 - if this is true then we do this action
12:58 - else we do another action um the else is
13:01 - completely optional you can just have
13:03 - one if statement um else is just for
13:06 - like
13:07 - if you want to do something different if
13:10 - the um
13:11 - if the statement isn't true so
13:14 - um yeah this is basically like
13:18 - you would just type it like this so like
13:19 - if parentheses
13:21 - boolean statement um make sure you have
13:23 - these curly brackets
13:25 - and then else curly brackets other
13:28 - action
13:29 - all right so um i'm just gonna go
13:32 - through a basic demo so
13:35 - let me share the code first and then we
13:38 - can talk about
13:40 - what's happening with this
13:46 - so basically in this example code i have
13:49 - um
13:51 - i have a
13:54 - basically a scanner that takes in user
13:56 - input and then we have this
13:58 - um boolean called is hungry um
14:02 - once the user types in like a yes or no
14:05 - after
14:05 - um so like first we'll ask like are you
14:08 - hungry
14:09 - if they use their types in yes or no
14:11 - it'll
14:12 - put basically put the statement into
14:16 - is hungry so we'll basically check
14:19 - against like
14:20 - if user input equals yes then
14:24 - um is hungry will be true so if
14:27 - if the user is hungry um we'll just say
14:30 - let's eat
14:31 - pizza and that otherwise will just print
14:33 - out like go play animal crossing
14:36 - so basically if you um
14:40 - someone's already writing this but
14:42 - hopefully it's not a future
14:44 - so basically we have this program that
14:46 - prince are you hungry
14:48 - if we type in yes
14:50 - [Music]
14:53 - seems like we have a bug so why do you
14:55 - think this code
14:56 - wouldn't be working then
15:00 - if we're checking while it's hung user
15:02 - input
15:03 - equals no or yes
15:07 - so right now like our code if i type in
15:10 - like
15:11 - this you'll always type in
15:14 - that so
15:17 - let's basically look at um this loop and
15:20 - see what's up
15:22 - so basically the idea for this loop is
15:24 - that while the user
15:27 - hasn't typed in no or yes
15:30 - in all caps um we'll basically continue
15:34 - printing this
15:35 - until they type in one of these strings
15:41 - however if i type in like yes even if i
15:44 - type in capital yes
15:46 - it won't work and
15:49 - the idea is basically like again
15:52 - we can't have this doubles equals
15:56 - in this um at
15:59 - like as a content equality check
16:04 - so basically um let me just fork this
16:07 - because
16:08 - i think another teacher is using it
16:09 - [Music]
16:12 - yeah there's a function to turn all the
16:14 - use user input to all caps
16:17 - so over here i've actually put a line
16:20 - that's like
16:20 - user input that you uppercase so that
16:23 - basically will if i just type in like
16:26 - lowercase yes
16:27 - it will turn everything into all caps
16:29 - and then it should check against
16:32 - this however
16:35 - for some reason it isn't doing that
16:40 - and let me just work this so the other i
16:43 - won't mess up the other teacher's code
16:46 - but there's the issue basically
16:50 - in this conditional check
16:53 - where for some reason this will always
16:56 - return false is it because of it not
17:05 - um not exactly so the idea with this
17:09 - loop is
17:10 - while the user has it typed in um
17:14 - no or yes then
17:17 - it will ask are you hungry and you'll
17:20 - like take in the user input
17:22 - so the like
17:26 - in basic english terms it's like while
17:29 - the user input
17:30 - is not um valid i'll continue printing
17:33 - this prompt
17:35 - put the dot equals method instead of
17:37 - equals equals exactly
17:39 - so what's happening right here is um
17:42 - java is like is this user input exactly
17:46 - this no string or exactly this yes
17:49 - string
17:49 - so like as like as in they're literally
17:52 - the same object
17:53 - however if i like scan this line
17:57 - um they can't they aren't exactly the
17:59 - same object they're the same string
18:01 - like they're the same it's the same word
18:05 - it's not the same object basically so
18:08 - that's why it's always returning like
18:11 - this
18:12 - is always returning like invalid input
18:15 - basically
18:16 - so if i actually change this to like
18:18 - user input
18:19 - equals
18:25 - and then
18:28 - if i change these onto that equals
18:31 - methods
18:32 - instead of um instead of the double
18:35 - equals
18:36 - then this should run um
18:40 - correctly so i should be able to even
18:42 - type in like a lowercase yes
18:45 - and they'll say let's eat pizza or um if
18:48 - i'm not hungry
18:49 - i can type in like lowercase no
18:53 - i go play animal crossing but if i type
18:56 - in something like
18:59 - abc it'll like continue
19:03 - i'm asking until i say yes
19:06 - so that's the general gist and i'm
19:09 - actually gonna sh
19:10 - i'm actually gonna share this corrected
19:12 - code
19:13 - [Music]
19:15 - just so you guys have reference to like
19:17 - what's the
19:18 - actual working code inside the buggy one
19:22 - so that's the basic idea of like this
19:25 - um if else so like if
19:29 - if this like boolean statement in here
19:31 - is
19:32 - true it'll run like whatever code
19:35 - dies in this um in this code block
19:39 - otherwise else it will run whatever is
19:42 - in here
19:44 - and then we've also got a sneak peek on
19:46 - like looping and
19:48 - all that
19:51 - so any questions about um
19:54 - the code we just looked at
20:04 - sweet
20:06 - so next i'm going to talk about um
20:10 - it we've called it else if statements
20:12 - but it's actually if
20:13 - else if so this is basically
20:16 - if you want to like check multiple
20:18 - conditions
20:20 - or not exactly check multiple conditions
20:22 - but like
20:23 - if um this is true then do this
20:26 - otherwise if this other thing is true
20:29 - then do this other thing
20:30 - and then else whatever so um
20:35 - basically it's kind of like if i wanna
20:40 - yeah if i wanna sort of check against a
20:43 - bunch of different stuff
20:45 - like if i wanna if like
20:48 - if or maybe i could just use this
20:51 - example so like
20:52 - if i'm hungry then i eat pizza otherwise
20:55 - if i'm tired then i'll take it now um
20:58 - if ever if both of these aren't true
21:01 - then i'll go play animal crossing
21:03 - so that's the general idea of if else if
21:06 - statements
21:07 - um i kind of say else if is kind
21:11 - is inaccurate because you have to have
21:13 - that first if statement
21:16 - in order to have an ounce of statement
21:18 - and you can chain like a bunch of outfit
21:20 - else if statements together so like
21:23 - if i'm tired or if i'm hungry i'll eat
21:25 - pizza else
21:26 - if i'm tired i'll take a nap else if i'm
21:29 - bored i'll
21:30 - play a game else um i'll go outside or
21:33 - something like that
21:35 - so you can have as many else of state or
21:37 - else
21:38 - if statements and then even like even
21:41 - then like this
21:42 - again this final else statement is
21:44 - optional
21:45 - so it can be like if if this is true
21:48 - then this else if this other thing is
21:51 - true then this
21:52 - and it can just stop right there
21:54 - [Music]
21:56 - so
22:02 - i'll just um show you guys this demo
22:07 - it's a little hard to click with the ego
22:09 - slides thing getting in the way
22:14 - so um again
22:17 - um this is the same code from the first
22:20 - demo
22:21 - but um i've sort of built something
22:23 - extra on it
22:24 - so again we have this wow statement like
22:28 - um that will ask like if you're hungry
22:30 - are you hungry and then if you type in
22:32 - nowhere yes
22:33 - it'll um it'll store everything in is
22:36 - hungry
22:37 - but i've added this extra layer so we
22:40 - have
22:41 - yet another boolean that is is higher
22:44 - and
22:44 - it will do the same thing it'll keep on
22:46 - asking are you tired until you type in
22:48 - nowhere yes
22:49 - and then it'll store it'll basically
22:51 - store that
22:52 - in is hired so if i'm
22:56 - if you type yes then i'll store it true
22:58 - if you type no
22:59 - no it will store false and then we also
23:03 - have
23:04 - finally have this um if else if
23:06 - statement
23:08 - so if you're hungry um we'll reply like
23:11 - let's eat pizza else if you're tired
23:15 - then you'll just print sleep and then
23:17 - finally
23:18 - if you're not either either of those um
23:22 - type go plate animal crossing so
23:25 - um we can first try running this so
23:30 - so first um are you hungry let's say
23:33 - no are you tired yes
23:37 - i know just type in sleep um
23:41 - just be like just be aware that
23:45 - these else if statements i want to say
23:49 - they're kind of like
23:51 - they're kind of independent or not
23:53 - independent they're dependent on each
23:54 - other
23:55 - so basically um if i run this again
23:58 - and i say like
24:03 - hopefully this will come out basically
24:05 - if i type in yes for is hungry and no
24:08 - for is tired
24:10 - it'll go into this this block
24:13 - so like the first if block um because
24:16 - it's hungry is true
24:17 - it'll print out like let's eat pizza and
24:20 - then it'll exit the program
24:21 - so well it won't be able to like
24:24 - um run any of the code after this
24:28 - that are in like different elf
24:29 - statements
24:31 - are you hungry yes tired no
24:35 - i never won't run anything else um even
24:38 - if i
24:39 - do something like if i type in yes for
24:42 - both
24:42 - is hungry and is tired um it will only
24:45 - run this
24:46 - first if statement because basically
24:49 - you'll just
24:50 - enter this block and then it'll exit
24:52 - this entire
24:53 - um if else if chain basically
25:01 - so um if you want something to basically
25:05 - run no matter what
25:07 - you'll have to be you have to um put it
25:10 - outside of the
25:11 - if else if else chain any questions
25:14 - about this code
25:18 - i would highly recommend that like after
25:21 - like on your own time um just like
25:25 - go into this go into all of these demos
25:28 - and sort of like pick them apart if you
25:30 - have any questions like
25:32 - outside like outside of class time feel
25:34 - free to like ask in the girls code
25:36 - discord or um i think
25:39 - you can like contact us through our
25:41 - through our website
25:42 - but this is basically um
25:46 - in general how if else if elsa of
25:49 - statements work
25:50 - [Music]
25:54 - so if no one has any questions um we'll
25:57 - just move on to
26:00 - our final our final like conditional
26:03 - statement
26:05 - [Music]
26:07 - so the last one we're going to talk
26:08 - about is switch statements
26:11 - and switch statements i would say
26:13 - they're
26:14 - fancier if else if statements
26:17 - but they're like 10 times more readable
26:20 - so um basically
26:23 - they're um they're
26:27 - a giant like if else if chain that can
26:30 - only check
26:30 - a single value so like
26:36 - i put this like if you were trying to
26:38 - like
26:39 - roll a dice or something and you wanted
26:42 - to like do something different
26:44 - for each value of the dice um
26:49 - it would be really messy and really
26:52 - unreadable
26:53 - to like have like if um that value
26:57 - equals one
26:58 - like do this else if a equals six do
27:01 - that
27:02 - um a easier way would just to put it all
27:05 - in a switch statement
27:06 - to make it more readable and the
27:09 - basic anatomy of a switch statement is
27:11 - you have this
27:12 - switch um switch keyword
27:16 - and then in parentheses you'll have
27:18 - whatever like
27:19 - value you're checking so like
27:22 - if i have a string i'll put it like in
27:25 - here
27:26 - um if i'm checking against like
27:29 - the numbers on a die then i'll put like
27:33 - a die value in this
27:36 - parentheses and then i'll have like
27:38 - these
27:39 - curly braces then inside the curly
27:42 - brackets
27:43 - i'll have um my first line will be like
27:46 - case and then whatever value that i'm
27:50 - checking against so like
27:52 - if i'm like in this ice cream example if
27:55 - i'm checking
27:56 - if ice cream is equal to chocolate then
27:59 - my first case could be chocolate and
28:02 - then i have
28:03 - the colons and then inside i'll have
28:05 - like i'll do whoever i want
28:07 - basically this is like sort of the
28:09 - inside of my if statement
28:11 - and make sure generally you have like
28:14 - a break statement which will break you
28:17 - out of the switch statement
28:19 - um we'll explain why you need that later
28:21 - but
28:22 - just make sure in general um
28:25 - make sure you put a break at the end of
28:27 - your cases
28:29 - and then i'll have my second case and my
28:31 - third case in however many cases i want
28:34 - um i think
28:37 - like this is the general anatomy like
28:41 - how you would write a switch statement
28:43 - um and then i'll show you example
28:47 - just so it's a little more clear um this
28:50 - is just another example of like
28:51 - if i'm checking against um a month
28:55 - then i can i can have like um i'll put
28:58 - month in the parentheses out like my
29:00 - case one two three four because month is
29:02 - an integer
29:03 - um and then i'll just
29:08 - move on to the demo any questions about
29:11 - like
29:11 - what i've talked about so far
29:20 - all right so um
29:25 - i know like switch statements can be a
29:26 - little weird because they can't
29:28 - they don't really translate into english
29:30 - like if else if and stuff like that
29:32 - so um maybe it'll be better explained
29:35 - in this demo like why you want to use a
29:38 - switch statement
29:39 - and how you can use the switch statement
29:42 - so
29:42 - in this demo we basically have a random
29:45 - number generator
29:46 - that will um pick between random
29:49 - integers one through six
29:51 - and then we have a scanner the scanner
29:54 - is kind of
29:55 - kind of my cheesy method of um of just
29:59 - rolling a guy basically so
30:02 - um basically how this program will run
30:05 - is let's say you're in a dnd campaign
30:08 - and we have this like situation where
30:11 - your character is like stuck in the
30:12 - woods at night
30:13 - and you have to like row one through six
30:16 - for like
30:16 - what's the outcome um so let's say
30:23 - i think it's so compiling so
30:26 - basically it'll just print out like um
30:28 - your character is stuck in the woods at
30:30 - night um press
30:30 - enter to find out what happens um
30:34 - this is secretly a scan next line which
30:36 - is just like
30:37 - you're rolling your die um it will gener
30:40 - you
30:40 - the rng will basically generate an
30:43 - integer
30:44 - one through six and then depending on
30:47 - like
30:47 - what um guy value you row
30:51 - um a random impact will occur so like
30:53 - you get attacked by a bear or like
30:55 - nothing happens or you find a nice cabin
30:58 - in the woods
30:59 - [Music]
31:01 - so each time i run this this should be
31:03 - random and the general idea is like
31:06 - for each um number in on the die
31:10 - i basically want a unique situation to
31:13 - happen
31:14 - but like you can't really tell from this
31:15 - right because it's so messy
31:18 - so um i have like if di rho equals one
31:21 - else if di rho equals two else f else if
31:24 - f left
31:25 - um this is basically pretty unreadable
31:28 - if you look at this at first it's hard
31:30 - to really tell like
31:32 - what exactly this code is doing
31:34 - [Music]
31:35 - so um a better way to do this
31:38 - if i comment all of this out
31:45 - or i'll actually fork this first
31:53 - so a better way to do this is if i put
31:55 - everything into a switch statement
31:58 - so i happen to have a really nicely
32:01 - written switch statement
32:04 - right under my giant if else if chain
32:12 - so if you look at um this first if else
32:16 - if statement
32:19 - it's kind of just hard to tell like what
32:21 - exactly this does
32:23 - um first off this is just like a lot of
32:25 - words it's the giant block of text
32:28 - i don't know exactly what happened
32:29 - what's happening in here
32:31 - however if i compare that to like a
32:33 - switch statement
32:34 - this is like 10 times more readable so
32:37 - basically the same is saying like hey
32:40 - i'm gonna
32:41 - check my um a bunch of cases
32:44 - against this one um variable die roll
32:48 - and these are the six cases that can
32:50 - happen so case one
32:53 - like if diver equals one you get
32:55 - attacked by an armbear
32:57 - if the roll equals two you get attacked
32:59 - by unarmed bear
33:01 - so and then all of these different cases
33:04 - all the way down to um k6
33:07 - so notice that for each case i put a
33:10 - break statement
33:12 - and i have the case keyword the code
33:14 - semicolon
33:16 - do whatever i want in here and then the
33:18 - break statement so this is just
33:20 - generally how you write a switch
33:22 - statement
33:23 - so if i
33:27 - comment this ugly elsa statement out
33:31 - this will basically run the same but um
33:34 - this is just generally more readable
33:38 - [Music]
33:40 - so um what the powerpoint didn't talk
33:43 - about
33:44 - but i kind of want to note is just that
33:46 - there's a special case called a default
33:48 - case
33:49 - and that's kind of like the else at the
33:52 - very end of your if else if
33:54 - statement so this is what happens if
33:57 - like
33:58 - say i happen to roll a seven on the die
34:01 - or something like that um this it will
34:04 - basically
34:05 - check against like oh this die isn't
34:07 - equal to one two three four five or six
34:10 - so i'll just refer to a default case and
34:13 - print out the end
34:14 - [Music]
34:15 - um technically like the code
34:18 - won't be able to reach the statement but
34:21 - this
34:21 - is there just in case so
34:25 - um let's go back to when i said
34:29 - you technically don't when i said like
34:32 - break is kind of an interesting case so
34:36 - when i said you need the great keyword
34:38 - at the end of each case
34:40 - i kind of i kind of lied so basically
34:44 - the reason you want to have a break
34:46 - keyword at the end of each case
34:48 - statement
34:49 - is that it breaks you out of the switch
34:50 - statement so
34:52 - if i don't have this break so let's say
34:54 - a comment
34:56 - all my breaks out over here
35:05 - [Music]
35:11 - i'll just choose my changes
35:12 - [Music]
35:14 - and hopefully that doesn't break any
35:16 - code
35:17 - [Music]
35:21 - so let's say i comment all my breaks out
35:23 - of this case
35:25 - um this will actually compile java
35:27 - actually has no problem
35:28 - if you don't put freak at the end of
35:29 - your case however let's see what happens
35:32 - once i um click enter
35:37 - so you'll see that i've happened to
35:41 - wrote kind of the worst case
35:45 - for um for this example but basically
35:48 - i wrote a six however i've also printed
35:53 - instead of like just printing this
35:56 - like the code or the sentence that was
36:00 - meant for case six i've also printed the
36:02 - default
36:03 - which is technically unreachable code
36:07 - or unreachable code so basically what
36:10 - this break does
36:11 - is like i said it will break you up the
36:13 - switch thing and what i meant by that
36:15 - it was it will exit the switch statement
36:17 - instead of
36:18 - running all the like all the rest of the
36:20 - code
36:21 - so what happened was java went to was
36:24 - like
36:25 - it went through the switch statement it
36:26 - was like all right die row equals six
36:29 - so i'll just hop to k6 i'll run this
36:33 - and then i'll run all the code that's
36:35 - under six
36:37 - so let me run this again and hopefully
36:40 - i'll get like
36:41 - a better example
36:50 - there we go so in this case i
36:54 - rode a one you got attacked by
36:57 - or i wrote it to you get attacked by
36:59 - unarmed bear
37:00 - so what java did is it over here it was
37:04 - like
37:04 - all right guy row equals two so i'll go
37:07 - to this case
37:08 - two and i'll print literally i'll run
37:11 - the code
37:12 - that's at all the code that's after two
37:15 - but because basically i didn't add the
37:18 - break
37:19 - it didn't exit the switch statement when
37:21 - i reached the end of the case
37:23 - so it just ran everything under it
37:26 - that's kind of the difference between
37:28 - the switch and else
37:30 - is if you don't add the break it can run
37:33 - code that's
37:34 - in different cases basically any
37:37 - questions about this
37:43 - so you can change the case number to an
37:45 - outfit or a string
37:46 - yeah so anything that you can compare
37:49 - basically
37:50 - um this switch statement like dybro only
37:53 - happens to be an integer um it could be
37:56 - like a character
37:57 - it could be um it could be a string
38:01 - um any like basic like primitive type
38:05 - or string
38:08 - so yeah it could be like
38:11 - it could be a letter it could be a
38:13 - string um the only thing it can't do is
38:16 - it can't be like
38:17 - i can't have a case of if um
38:20 - dyro i can't i can't do a thing where
38:24 - it's like
38:25 - di less than or equal to
38:28 - four so this is invalid in java
38:32 - um switch statements aren't just a java
38:35 - thing
38:36 - so like there are languages that support
38:39 - state
38:39 - switch statements that can be like if
38:42 - that wrote less than or equal to five
38:44 - or le if diro is greater or
38:47 - even like that greater or equal to two
38:50 - less than equal to five
38:51 - um this is
38:55 - invalid for java but
38:58 - can be valid for other languages
39:05 - um but java will basically only support
39:08 - like strict equality so like case
39:12 - one or like case hello world
39:15 - or things like case a so only if
39:19 - um the variable is equal to the case
39:21 - value
39:23 - um just a reminder for like of your demo
39:26 - code just make sure
39:27 - you fork um by pressing like up here
39:31 - these three dots and then fork before
39:33 - like
39:34 - you change your code just so um not
39:38 - like when you change stuff other people
39:40 - won't be affected by the changes
39:41 - [Music]
39:47 - all right so actually let's actually do
39:50 - this quiz then
39:52 - so um first number one what does
39:55 - this if statement mean let's do
39:58 - let's do this first example together so
40:01 - um
40:03 - yeah so basically the translation of
40:06 - number one
40:07 - is if x is equal to some d2
40:13 - so that's correct all right
40:17 - so let's do number two then
40:20 - what does this statement mean correct
40:24 - so the statement means if x is less than
40:27 - 20 and x is greater than 40.
40:31 - so let's say in this case for number two
40:33 - x
40:34 - is x is
40:37 - 13. will this second statement
40:41 - run yeah so
40:44 - 13 is greater than 40 would be false
40:47 - um but it would still run so
40:50 - basically what i mean is let's say
40:53 - in number two x was 13. so
40:57 - i'll actually just type out
41:01 - the code in my notes
41:06 - so let's say um
41:09 - over here
41:14 - um if we're number two i had code like
41:17 - in
41:17 - x equals 13 and then in some like
41:25 - and then in some other part of the code
41:26 - i have like if
41:28 - x less than 20
41:31 - and 40.
41:38 - so basically um
41:41 - once i get to this if statement java
41:43 - will first check like
41:45 - if it will first evaluate this first
41:47 - expression
41:48 - so x less than 20 and then we'll return
41:51 - true because 13 is less than 20.
41:55 - once it returns true um basically
41:59 - like i said before um computers are very
42:02 - lazy
42:03 - so they want to do the least work
42:06 - possible
42:06 - however in this case if this was true
42:09 - there's still a possibility
42:11 - that this second statement is false and
42:13 - this entire truth
42:14 - like and statement will be false
42:17 - so it will run this it will see that's
42:20 - true
42:21 - and then it will go to the second
42:23 - statement and it'll have to check
42:25 - if um x is greater than 40. so it's 13
42:29 - greater than 40
42:30 - no so the entire statement will return
42:33 - false
42:35 - however like if over here i said
42:38 - x is let's say x equals
42:41 - 30. so if i go
42:44 - if i hit this if statement um
42:48 - 30 is less than 20. so this will return
42:50 - false
42:51 - um because job um computers are just
42:54 - lazy
42:55 - basically what happened is if this first
42:58 - statement is false
42:59 - no matter like what this second
43:01 - statement is if it's like
43:03 - if it's true if it's false if even if it
43:06 - like returns a runtime error
43:09 - um this entire statement will be false
43:11 - no matter what
43:12 - so there's no point in really like
43:14 - evaluating the second statement
43:16 - so um what happens is java will actually
43:19 - just
43:19 - skip the second statement it won't even
43:21 - like it won't even
43:23 - evaluate this expression basically and
43:25 - it'll just
43:26 - um skip this entire like it'll just say
43:29 - like
43:30 - this and statement is entirely false it
43:33 - doesn't matter what the second
43:34 - the second statement is then this entire
43:37 - statement is still false no matter what
43:42 - is that like does that clear
43:45 - so when is the second statement used the
43:47 - second statement is
43:48 - only used when um
43:51 - basically this first statement is true
43:54 - so basically like let's say i have x
43:58 - equals 30 here
43:59 - um but somewhere in my code um x will be
44:02 - equal to
44:04 - 10 and then
44:08 - so let's say like somewhere along the
44:10 - way x gets um
44:12 - it gets reassigned a value and the value
44:14 - is 10.
44:16 - then over here um java will be like
44:20 - all right is 10 less than 20 that's true
44:23 - then it will have to evaluate
44:25 - this second statement
44:28 - is that is that a little clear
44:35 - so basically for um for and statements
44:39 - if this first statement is false no
44:42 - matter
44:42 - like what the second statement is um
44:47 - but we've turned true despite the second
44:49 - part
44:55 - not exactly so like for and statements
44:58 - remember that
45:00 - that for the double and
45:03 - it has to be that the first statement is
45:05 - true and so is the second statement
45:08 - or is where um so
45:14 - yeah so basically for and statements
45:18 - both um the first part and the second
45:20 - part both have to be true
45:22 - so that's why if this first part is true
45:27 - then like then the second part matters
45:35 - um for x equals 10 so technically like
45:38 - for this entire statement this will
45:40 - return false because 10 is
45:41 - not greater than 40. however what
45:44 - happens is that
45:45 - it'll first evaluate this first
45:47 - statement yep
45:49 - yeah so i'm just saying like for
45:51 - strictly
45:52 - this part it'll be true so strictly
45:55 - speaking
45:56 - is 10 is less than 20. so that's why um
46:00 - java has to go through and it has to
46:02 - check the statement
46:03 - this is very important if like if like
46:06 - let's say
46:08 - um because once you get into more
46:10 - complicated code um
46:12 - it won't just be like oh it's 10 less
46:14 - than 20 or oh
46:15 - is this like is this number less than or
46:18 - equal to this number
46:19 - these can be super complicated like um
46:23 - these can be super complicated
46:24 - expressions once you get into like
46:26 - more complex code so what can happen is
46:29 - like
46:30 - let's say i have code over here that
46:32 - like returns a runtime error
46:34 - so i have like i have
46:37 - some invalid and let's say like whenever
46:41 - this invalid code runs
46:43 - it will just return a runtime error what
46:45 - can happen is you can have hidden bugs
46:48 - that will basically be like
46:51 - let me delete this part that'll
46:54 - basically be like
46:56 - if i will happen like in this case
46:59 - is x or java will just be like
47:03 - oh so 30 is less than 20.
47:06 - or it's not less than 20. so this entire
47:08 - and statement is false
47:09 - and you'll just miss this bug over here
47:12 - so that's like why
47:13 - i want you guys to sort of keep this in
47:16 - mind because
47:17 - um once you get into more more complex
47:20 - coding
47:21 - these little bugs can happen just
47:23 - because um
47:25 - java and other languages evaluate
47:29 - um boolean expressions in very like
47:33 - in very uh hacky ways basically
47:39 - and then again um there like
47:42 - there's a same sort of treatment with um
47:46 - with or statements so like if x
48:02 - so similar thing um
48:05 - kind of so in the case of or
48:09 - um only one of these expressions has to
48:11 - be true for the entire or statement to
48:13 - be true right
48:15 - so um if this ends up being true
48:18 - so if
48:23 - and then if this evaluates as true
48:26 - java will again like do like few
48:29 - shortcuts
48:30 - and they won't evaluate the second
48:32 - expression
48:34 - so just remember for and statements
48:37 - if the first statement is false then
48:39 - java won't evaluate the second statement
48:41 - and for or statements if the first
48:43 - statement is true then java won't
48:45 - evaluate the second statement
48:47 - and this goes across um differently
48:50 - multiple languages
48:51 - so python will do the same thing um
48:54 - basically all languages
48:55 - will treat um ands and words the same
48:58 - way as java does
48:59 - in these cases any other questions about
49:03 - this
49:03 - or like anything else in the lesson
49:06 - all right so i saw that some people
49:09 - wanted to um
49:11 - wanted to do the
49:14 - do the um workshop so
49:18 - let me see if i can actually share this
49:22 - okay i'm gonna
49:26 - copy this link and hopefully
49:29 - there we go so
49:32 - here's a link to the workshop again
49:34 - remember to fork before
49:37 - before you um you edit the rebel
49:41 - um basically the idea is we're trying to
49:44 - check if you remember
49:46 - the lesson from last week so like
49:49 - um review how like
49:52 - how do you create a scanner um how like
49:56 - which library do you have to import to
49:58 - um be able to make a scanner object
50:01 - and then um how can you store like
50:05 - how can you store a string something
50:07 - like that
50:08 - and then um basically
50:12 - this program is just like a basic
50:15 - program of
50:16 - we want to be able to um take in say
50:18 - like an ice cream flavor
50:20 - and then we in the end we want to check
50:22 - if this ice cream flavor
50:24 - is in like specific stores so
50:28 - um we have like these two strings called
50:30 - flavors that you can
50:32 - um you can initialize to whatever flavor
50:34 - you want
50:36 - and then you have to find some way to
50:39 - basically take in like your friend's
50:41 - favorite ice cream flavor
50:43 - and then check against these two flavors
50:46 - from two different stores
50:47 - [Music]
50:49 - and then we'll finally like just
50:52 - print out something
50:57 - um that's like based off of if
51:01 - if your ice cream is in like store one
51:03 - or store two or if it's not in any
51:06 - stores
51:09 - so right now um
51:12 - i think it's 304 pacific standard time
51:16 - [Music]
51:20 - um
51:24 - you

Cleaned transcript:

all right so hey guys my name is jessica and i'm a senior cs major from university of maryland college park um today we're just gonna be talking about um booleans and boolean expressions and things like if statements so um first like we'll just be going over like what's a boolean um any operators that you'll be like you have to use with booleans and any operations that deal with like that can return like a true or false um next we'll be talking about things like if else statements elsif um switch statements these are just things um these are just conditionals that you can use with booleans and then um i'll give you like resources and if you want to we can go for a workshop otherwise like we can just ask questions or like i'll try to give you guys um trick questions or something like that um again like if you guys have any questions um feel free to just either interrupt me and you if you're comfortable or um just drop a question in chat and i'll try to answer as quickly as possible um if you guys like feel free to let me know if you want like me to go over slide or just slow down or speed up anything like that all right so um first off i'm just gonna go over what is a boolean a boolean is basically a data type um if you remember the primitive types we went over for the second lesson um this was one of the types of variables we covered um it only holds two values true or false and um just like any other nonconstant variable its value can change like depending on um its value can basically change during the course of your code and basically just reflect like the change in the condition so um basically it's just a variable that can hold a true or false value um these are just two examples of boolean so one is like light on which can be true or cloudy which is false so first i'm just going to go over boolean operators so these are operations you can do on a boolean um the first one is this exclamation point which means not um two ands mean and and then these two straight lines they're called pipes this means or um these are just like little operations you can um you'll have to memorize with a boolean any questions about these sweet so i'm just gonna show you guys a demo using um these three operators i'm gonna see if i can share it and i'll just drop the link in chat so um basically this is just a demo showing you guys how these operations work so um i have this program where a equals true and b equals false um and basically if i do a or b um this should print true because a is true and even though b is false um something else is a and b which open false because b is false and then finally not b which would be true um do you guys kind of get how this works so basically or is if both statements or if both statements are false then or will be false but if one or the other statement is true then it will be true and as they either have to they have to be both true to be true if one of the statements is false then a return false completely and then finally not is just the opposite so if we run this this should print true false then true and then just something to um to note so basically um a fun fact is that computers are very lazy they want to they want to do the least work possible so basically how um something like an or statement can work is if a is true then the statement is just confirmed true right i don't even have to check the sec if the second statement is true so if a is true then um java will basically exit this statement and be like this statement is true um but if this is false then i'll have to check the second statement um for another example is like if um a is false over here then the rest of the statement no matter like what the rest of the statement is this and expression is just completely false so if a is false then b will not be checked so b just um basically java just won't even compute b so um but if like a is true then java will have to check if b is false so this can be really helpful if you want to do like little tricky um basically do some tricky programming in java just remember that computers are lazy and for or statements if the first statement is true the second statement won't be checked and for and statements if the first statement is false the second one won't be checked um any questions about this all right sweet so next i'm just going to talk about operators that don't necessarily involve booleans but return of boolean so things like if you're checking an equals like if two variables are equal to each other um you can't it hi about this these don't necessarily involve booleans like you can check if one equals two but one and two aren't boolean types but it will return a boolean so a true or false so the first one is we have this double equals and this compares physical equality so do the two variables hold the same value in memory and then the second one is a dot equals so an equals method and this compares content equality so are the contents of these two variables the same um then we have like greater greater than less than greater than or equal to less than or equal to um i think these last four are selfexplanatory but um to go further into the double equals versus um dot equals um double equals um compares if these variables hold the same value in memory and that equals compares the content so if you remember um in last lesson when we talked about um about reference types reference types um are actually variables that hold addresses right they basically point to the object instead of containing the value of the object so when you have when you have something like that um basically basically um your like the physical memory and content and whatever content that your object has can be different right so you can have two strings that both have like a b c d but they can be in different places in memory so that's why we have this equals equals but a dot equals method so um i think this might be better explained if i show you the demo so if i have um something like if i have if i create two strings and they're both called high so if i have um like this one string will be in one place in memory and then two string will be in a different place in memory so if i compare one string equals equals two string um these two variables are pointing to different places in memory so this would return false because they're technically not the same object right however if i do one string that equals to string this would return true because the content of these these two strings are true are the same all right um and we can also just look at examples of the other the other operators so actually let me just so um the other examples are just like if you have integer a equals 10 b equals 7 um if you do like a um is a equals a double equals b plus 3 then this will return true because 10 equals 7 plus 10 or 7 plus 3. um same same idea for this so like is a less than 10 is 10 less than 10 not not really so it will return false but if i do like is a less than or equal to 10 um you kind of get the idea that like these are basically the same same idea as like in math basically um oh yeah something else about the dot equals um something else to know about the dot equals method is that all objects have this dot equals method and the general rule is unless you're actually checking that like um like the physical equality like are these two objects exactly the same object in like the physical memory space then like you should generally always use the dot equals method um we also have some we also can do like like different um we can also use these same operators with like other primitives so like you have um chart a or symbol one equals a symbol two was b um we can also do like a symbol one less than or equals to symbol two so why would you think this this would print true so how can we basically basically um tell if this character a is less than b um the general idea is just that like like we talked about in the primitives lecture you can basically convert any symbol like abcd yeah exactly so um according to the ascii table yeah according to the ascii table these characters can be converted into numbers so i think a is like 63 or something and then b is 64. so um that's why symbol 1 is less than symbol 2. and then same idea for this so this would print false because 63 is not greater or equal to 6 um 64. 64. yeah however like if you if you try to use like this less than or equal to with like booleans that wouldn't work because um because java will basically be like you can't use this on a boolean um that would it would just throw a compiler error so just be aware of that like even though you can convert characters into numbers um you can't really do the same thing with um booleans any questions about this all right so next um we're just going to talk about um basically if um conditionals basically so things like if statements um is if else if um and then these fancy things called switch statements so the first one is just if else statements um these are just these are base the most basic form of conditionals so like if this is true then we do this action else we do another action um the else is completely optional you can just have one if statement um else is just for like if you want to do something different if the um if the statement isn't true so um yeah this is basically like you would just type it like this so like if parentheses boolean statement um make sure you have these curly brackets and then else curly brackets other action all right so um i'm just gonna go through a basic demo so let me share the code first and then we can talk about what's happening with this so basically in this example code i have um i have a basically a scanner that takes in user input and then we have this um boolean called is hungry um once the user types in like a yes or no after um so like first we'll ask like are you hungry if they use their types in yes or no it'll put basically put the statement into is hungry so we'll basically check against like if user input equals yes then um is hungry will be true so if if the user is hungry um we'll just say let's eat pizza and that otherwise will just print out like go play animal crossing so basically if you um someone's already writing this but hopefully it's not a future so basically we have this program that prince are you hungry if we type in yes seems like we have a bug so why do you think this code wouldn't be working then if we're checking while it's hung user input equals no or yes so right now like our code if i type in like this you'll always type in that so let's basically look at um this loop and see what's up so basically the idea for this loop is that while the user hasn't typed in no or yes in all caps um we'll basically continue printing this until they type in one of these strings however if i type in like yes even if i type in capital yes it won't work and the idea is basically like again we can't have this doubles equals in this um at like as a content equality check so basically um let me just fork this because i think another teacher is using it yeah there's a function to turn all the use user input to all caps so over here i've actually put a line that's like user input that you uppercase so that basically will if i just type in like lowercase yes it will turn everything into all caps and then it should check against this however for some reason it isn't doing that and let me just work this so the other i won't mess up the other teacher's code but there's the issue basically in this conditional check where for some reason this will always return false is it because of it not um not exactly so the idea with this loop is while the user has it typed in um no or yes then it will ask are you hungry and you'll like take in the user input so the like in basic english terms it's like while the user input is not um valid i'll continue printing this prompt put the dot equals method instead of equals equals exactly so what's happening right here is um java is like is this user input exactly this no string or exactly this yes string so like as like as in they're literally the same object however if i like scan this line um they can't they aren't exactly the same object they're the same string like they're the same it's the same word it's not the same object basically so that's why it's always returning like this is always returning like invalid input basically so if i actually change this to like user input equals and then if i change these onto that equals methods instead of um instead of the double equals then this should run um correctly so i should be able to even type in like a lowercase yes and they'll say let's eat pizza or um if i'm not hungry i can type in like lowercase no i go play animal crossing but if i type in something like abc it'll like continue i'm asking until i say yes so that's the general gist and i'm actually gonna sh i'm actually gonna share this corrected code just so you guys have reference to like what's the actual working code inside the buggy one so that's the basic idea of like this um if else so like if if this like boolean statement in here is true it'll run like whatever code dies in this um in this code block otherwise else it will run whatever is in here and then we've also got a sneak peek on like looping and all that so any questions about um the code we just looked at sweet so next i'm going to talk about um it we've called it else if statements but it's actually if else if so this is basically if you want to like check multiple conditions or not exactly check multiple conditions but like if um this is true then do this otherwise if this other thing is true then do this other thing and then else whatever so um basically it's kind of like if i wanna yeah if i wanna sort of check against a bunch of different stuff like if i wanna if like if or maybe i could just use this example so like if i'm hungry then i eat pizza otherwise if i'm tired then i'll take it now um if ever if both of these aren't true then i'll go play animal crossing so that's the general idea of if else if statements um i kind of say else if is kind is inaccurate because you have to have that first if statement in order to have an ounce of statement and you can chain like a bunch of outfit else if statements together so like if i'm tired or if i'm hungry i'll eat pizza else if i'm tired i'll take a nap else if i'm bored i'll play a game else um i'll go outside or something like that so you can have as many else of state or else if statements and then even like even then like this again this final else statement is optional so it can be like if if this is true then this else if this other thing is true then this and it can just stop right there so i'll just um show you guys this demo it's a little hard to click with the ego slides thing getting in the way so um again um this is the same code from the first demo but um i've sort of built something extra on it so again we have this wow statement like um that will ask like if you're hungry are you hungry and then if you type in nowhere yes it'll um it'll store everything in is hungry but i've added this extra layer so we have yet another boolean that is is higher and it will do the same thing it'll keep on asking are you tired until you type in nowhere yes and then it'll store it'll basically store that in is hired so if i'm if you type yes then i'll store it true if you type no no it will store false and then we also have finally have this um if else if statement so if you're hungry um we'll reply like let's eat pizza else if you're tired then you'll just print sleep and then finally if you're not either either of those um type go plate animal crossing so um we can first try running this so so first um are you hungry let's say no are you tired yes i know just type in sleep um just be like just be aware that these else if statements i want to say they're kind of like they're kind of independent or not independent they're dependent on each other so basically um if i run this again and i say like hopefully this will come out basically if i type in yes for is hungry and no for is tired it'll go into this this block so like the first if block um because it's hungry is true it'll print out like let's eat pizza and then it'll exit the program so well it won't be able to like um run any of the code after this that are in like different elf statements are you hungry yes tired no i never won't run anything else um even if i do something like if i type in yes for both is hungry and is tired um it will only run this first if statement because basically you'll just enter this block and then it'll exit this entire um if else if chain basically so um if you want something to basically run no matter what you'll have to be you have to um put it outside of the if else if else chain any questions about this code i would highly recommend that like after like on your own time um just like go into this go into all of these demos and sort of like pick them apart if you have any questions like outside like outside of class time feel free to like ask in the girls code discord or um i think you can like contact us through our through our website but this is basically um in general how if else if elsa of statements work so if no one has any questions um we'll just move on to our final our final like conditional statement so the last one we're going to talk about is switch statements and switch statements i would say they're fancier if else if statements but they're like 10 times more readable so um basically they're um they're a giant like if else if chain that can only check a single value so like i put this like if you were trying to like roll a dice or something and you wanted to like do something different for each value of the dice um it would be really messy and really unreadable to like have like if um that value equals one like do this else if a equals six do that um a easier way would just to put it all in a switch statement to make it more readable and the basic anatomy of a switch statement is you have this switch um switch keyword and then in parentheses you'll have whatever like value you're checking so like if i have a string i'll put it like in here um if i'm checking against like the numbers on a die then i'll put like a die value in this parentheses and then i'll have like these curly braces then inside the curly brackets i'll have um my first line will be like case and then whatever value that i'm checking against so like if i'm like in this ice cream example if i'm checking if ice cream is equal to chocolate then my first case could be chocolate and then i have the colons and then inside i'll have like i'll do whoever i want basically this is like sort of the inside of my if statement and make sure generally you have like a break statement which will break you out of the switch statement um we'll explain why you need that later but just make sure in general um make sure you put a break at the end of your cases and then i'll have my second case and my third case in however many cases i want um i think like this is the general anatomy like how you would write a switch statement um and then i'll show you example just so it's a little more clear um this is just another example of like if i'm checking against um a month then i can i can have like um i'll put month in the parentheses out like my case one two three four because month is an integer um and then i'll just move on to the demo any questions about like what i've talked about so far all right so um i know like switch statements can be a little weird because they can't they don't really translate into english like if else if and stuff like that so um maybe it'll be better explained in this demo like why you want to use a switch statement and how you can use the switch statement so in this demo we basically have a random number generator that will um pick between random integers one through six and then we have a scanner the scanner is kind of kind of my cheesy method of um of just rolling a guy basically so um basically how this program will run is let's say you're in a dnd campaign and we have this like situation where your character is like stuck in the woods at night and you have to like row one through six for like what's the outcome um so let's say i think it's so compiling so basically it'll just print out like um your character is stuck in the woods at night um press enter to find out what happens um this is secretly a scan next line which is just like you're rolling your die um it will gener you the rng will basically generate an integer one through six and then depending on like what um guy value you row um a random impact will occur so like you get attacked by a bear or like nothing happens or you find a nice cabin in the woods so each time i run this this should be random and the general idea is like for each um number in on the die i basically want a unique situation to happen but like you can't really tell from this right because it's so messy so um i have like if di rho equals one else if di rho equals two else f else if f left um this is basically pretty unreadable if you look at this at first it's hard to really tell like what exactly this code is doing so um a better way to do this if i comment all of this out or i'll actually fork this first so a better way to do this is if i put everything into a switch statement so i happen to have a really nicely written switch statement right under my giant if else if chain so if you look at um this first if else if statement it's kind of just hard to tell like what exactly this does um first off this is just like a lot of words it's the giant block of text i don't know exactly what happened what's happening in here however if i compare that to like a switch statement this is like 10 times more readable so basically the same is saying like hey i'm gonna check my um a bunch of cases against this one um variable die roll and these are the six cases that can happen so case one like if diver equals one you get attacked by an armbear if the roll equals two you get attacked by unarmed bear so and then all of these different cases all the way down to um k6 so notice that for each case i put a break statement and i have the case keyword the code semicolon do whatever i want in here and then the break statement so this is just generally how you write a switch statement so if i comment this ugly elsa statement out this will basically run the same but um this is just generally more readable so um what the powerpoint didn't talk about but i kind of want to note is just that there's a special case called a default case and that's kind of like the else at the very end of your if else if statement so this is what happens if like say i happen to roll a seven on the die or something like that um this it will basically check against like oh this die isn't equal to one two three four five or six so i'll just refer to a default case and print out the end um technically like the code won't be able to reach the statement but this is there just in case so um let's go back to when i said you technically don't when i said like break is kind of an interesting case so when i said you need the great keyword at the end of each case i kind of i kind of lied so basically the reason you want to have a break keyword at the end of each case statement is that it breaks you out of the switch statement so if i don't have this break so let's say a comment all my breaks out over here i'll just choose my changes and hopefully that doesn't break any code so let's say i comment all my breaks out of this case um this will actually compile java actually has no problem if you don't put freak at the end of your case however let's see what happens once i um click enter so you'll see that i've happened to wrote kind of the worst case for um for this example but basically i wrote a six however i've also printed instead of like just printing this like the code or the sentence that was meant for case six i've also printed the default which is technically unreachable code or unreachable code so basically what this break does is like i said it will break you up the switch thing and what i meant by that it was it will exit the switch statement instead of running all the like all the rest of the code so what happened was java went to was like it went through the switch statement it was like all right die row equals six so i'll just hop to k6 i'll run this and then i'll run all the code that's under six so let me run this again and hopefully i'll get like a better example there we go so in this case i rode a one you got attacked by or i wrote it to you get attacked by unarmed bear so what java did is it over here it was like all right guy row equals two so i'll go to this case two and i'll print literally i'll run the code that's at all the code that's after two but because basically i didn't add the break it didn't exit the switch statement when i reached the end of the case so it just ran everything under it that's kind of the difference between the switch and else is if you don't add the break it can run code that's in different cases basically any questions about this so you can change the case number to an outfit or a string yeah so anything that you can compare basically um this switch statement like dybro only happens to be an integer um it could be like a character it could be um it could be a string um any like basic like primitive type or string so yeah it could be like it could be a letter it could be a string um the only thing it can't do is it can't be like i can't have a case of if um dyro i can't i can't do a thing where it's like di less than or equal to four so this is invalid in java um switch statements aren't just a java thing so like there are languages that support state switch statements that can be like if that wrote less than or equal to five or le if diro is greater or even like that greater or equal to two less than equal to five um this is invalid for java but can be valid for other languages um but java will basically only support like strict equality so like case one or like case hello world or things like case a so only if um the variable is equal to the case value um just a reminder for like of your demo code just make sure you fork um by pressing like up here these three dots and then fork before like you change your code just so um not like when you change stuff other people won't be affected by the changes all right so actually let's actually do this quiz then so um first number one what does this if statement mean let's do let's do this first example together so um yeah so basically the translation of number one is if x is equal to some d2 so that's correct all right so let's do number two then what does this statement mean correct so the statement means if x is less than 20 and x is greater than 40. so let's say in this case for number two x is x is 13. will this second statement run yeah so 13 is greater than 40 would be false um but it would still run so basically what i mean is let's say in number two x was 13. so i'll actually just type out the code in my notes so let's say um over here um if we're number two i had code like in x equals 13 and then in some like and then in some other part of the code i have like if x less than 20 and 40. so basically um once i get to this if statement java will first check like if it will first evaluate this first expression so x less than 20 and then we'll return true because 13 is less than 20. once it returns true um basically like i said before um computers are very lazy so they want to do the least work possible however in this case if this was true there's still a possibility that this second statement is false and this entire truth like and statement will be false so it will run this it will see that's true and then it will go to the second statement and it'll have to check if um x is greater than 40. so it's 13 greater than 40 no so the entire statement will return false however like if over here i said x is let's say x equals 30. so if i go if i hit this if statement um 30 is less than 20. so this will return false um because job um computers are just lazy basically what happened is if this first statement is false no matter like what this second statement is if it's like if it's true if it's false if even if it like returns a runtime error um this entire statement will be false no matter what so there's no point in really like evaluating the second statement so um what happens is java will actually just skip the second statement it won't even like it won't even evaluate this expression basically and it'll just um skip this entire like it'll just say like this and statement is entirely false it doesn't matter what the second the second statement is then this entire statement is still false no matter what is that like does that clear so when is the second statement used the second statement is only used when um basically this first statement is true so basically like let's say i have x equals 30 here um but somewhere in my code um x will be equal to 10 and then so let's say like somewhere along the way x gets um it gets reassigned a value and the value is 10. then over here um java will be like all right is 10 less than 20 that's true then it will have to evaluate this second statement is that is that a little clear so basically for um for and statements if this first statement is false no matter like what the second statement is um but we've turned true despite the second part not exactly so like for and statements remember that that for the double and it has to be that the first statement is true and so is the second statement or is where um so yeah so basically for and statements both um the first part and the second part both have to be true so that's why if this first part is true then like then the second part matters um for x equals 10 so technically like for this entire statement this will return false because 10 is not greater than 40. however what happens is that it'll first evaluate this first statement yep yeah so i'm just saying like for strictly this part it'll be true so strictly speaking is 10 is less than 20. so that's why um java has to go through and it has to check the statement this is very important if like if like let's say um because once you get into more complicated code um it won't just be like oh it's 10 less than 20 or oh is this like is this number less than or equal to this number these can be super complicated like um these can be super complicated expressions once you get into like more complex code so what can happen is like let's say i have code over here that like returns a runtime error so i have like i have some invalid and let's say like whenever this invalid code runs it will just return a runtime error what can happen is you can have hidden bugs that will basically be like let me delete this part that'll basically be like if i will happen like in this case is x or java will just be like oh so 30 is less than 20. or it's not less than 20. so this entire and statement is false and you'll just miss this bug over here so that's like why i want you guys to sort of keep this in mind because um once you get into more more complex coding these little bugs can happen just because um java and other languages evaluate um boolean expressions in very like in very uh hacky ways basically and then again um there like there's a same sort of treatment with um with or statements so like if x so similar thing um kind of so in the case of or um only one of these expressions has to be true for the entire or statement to be true right so um if this ends up being true so if and then if this evaluates as true java will again like do like few shortcuts and they won't evaluate the second expression so just remember for and statements if the first statement is false then java won't evaluate the second statement and for or statements if the first statement is true then java won't evaluate the second statement and this goes across um differently multiple languages so python will do the same thing um basically all languages will treat um ands and words the same way as java does in these cases any other questions about this or like anything else in the lesson all right so i saw that some people wanted to um wanted to do the do the um workshop so let me see if i can actually share this okay i'm gonna copy this link and hopefully there we go so here's a link to the workshop again remember to fork before before you um you edit the rebel um basically the idea is we're trying to check if you remember the lesson from last week so like um review how like how do you create a scanner um how like which library do you have to import to um be able to make a scanner object and then um how can you store like how can you store a string something like that and then um basically this program is just like a basic program of we want to be able to um take in say like an ice cream flavor and then we in the end we want to check if this ice cream flavor is in like specific stores so um we have like these two strings called flavors that you can um you can initialize to whatever flavor you want and then you have to find some way to basically take in like your friend's favorite ice cream flavor and then check against these two flavors from two different stores and then we'll finally like just print out something um that's like based off of if if your ice cream is in like store one or store two or if it's not in any stores so right now um i think it's 304 pacific standard time um you
