00:00 - hey everyone so today we'll be talking
00:02 - about Pi game in Python that is
00:05 - basically used for working with video
00:07 - games creating video games in Python but
00:10 - before that we need some prerequisites
00:13 - that are
00:15 - your knowledge in Python you should
00:18 - already be acquainted with some basic
00:20 - idea of python
00:22 - then you should
00:24 - have in Python installed in your system
00:27 - if not I'll just guide you through some
00:30 - quick steps we'd be working on BS code
00:32 - so we we need vs code we need uh python
00:37 - installed in your systems plus we'd need
00:39 - the pi game module so let's quickly see
00:43 - how we can get all these
00:47 - and we'll find you'll find this download
00:51 - pythonpython.org it's the official
00:52 - website if you need any documentation
00:55 - related help
00:57 - uh from python uh well python then you
01:00 - can search it over here so you're gonna
01:02 - click on this link okay and you can
01:05 - easily download it like it starts right
01:08 - away and then you have to set the
01:11 - environment variable which is not a big
01:14 - deal and for downloading vs code you
01:18 - write download vs code
01:22 - and there we are
01:25 - we download vs code
01:28 - and it should start right away uh you
01:31 - just have to wait for some time
01:34 - okay so as you launch vs code this is
01:37 - what we get this is the interface that
01:39 - we see
01:41 - uh this is where you open all the
01:43 - folders this is where you search for
01:45 - your files and this is where you
01:48 - download your extensions so since if we
01:52 - are working
01:54 - maybe you're working with python for the
01:56 - first time you have downloaded it for
01:58 - the first time you have to write python
02:01 - and download the extension so that you
02:04 - can work with vs code and python
02:09 - here I am getting this disabled and
02:11 - installed uh icons because I've already
02:14 - installed this extension but if you have
02:16 - not you'll get an install button over
02:19 - here so you click on it and then once it
02:22 - is installed you'll get a Reload button
02:24 - so you reload it so that you can work
02:26 - with python on vs code so I need to open
02:30 - a folder
02:32 - and
02:35 - so I open a folder here uh which I've
02:40 - named as python it's an empty folder I
02:43 - made on the desktop a very simple one it
02:45 - contains nothing and it'll get opened
02:49 - uh soon as I click on this
02:51 - and then
02:55 - we will add a new file this is how we
02:58 - add a new file name it first
03:01 - p y
03:04 - you always need to give extensions dot
03:06 - py is the extension for a python file
03:08 - you tell vs code that you're going to
03:11 - work with
03:13 - python you might
03:15 - you might say that you will only have
03:17 - python extension so why do we need to
03:19 - mention dot py but maybe when you learn
03:24 - a lot of languages you have a lot of
03:25 - extensions then it would be a confusion
03:28 - for vs code
03:29 - what
03:31 - file you're working with so you need to
03:34 - mention the extension you need to
03:37 - mention dot py for HTML V Dot we do dot
03:41 - HTML so
03:43 - yeah
03:44 - let's
03:46 - try to print something we'll print hello
03:50 - let's see let's run this let's see if it
03:53 - runs
03:58 - and we have our hello printed cool
04:02 - this is what we needed
04:04 - now we'll install
04:07 - pie game
04:11 - so to install Pi game you need to write
04:15 - on the command prompt on the terminal
04:17 - that okay please open command prompt
04:21 - while you're doing this
04:22 - do not work on Powershell
04:25 - yes you should see something like this
04:27 - and you'll write pip install
04:32 - ID
04:37 - I already have five games so I don't
04:39 - need to install it separately but uh
04:42 - just on the just to be on the safer side
04:44 - just run this command and see that you
04:47 - have buy a game or install this this is
04:50 - the only command that you need to run
04:51 - there are no extra commands that you
04:53 - need to run for downloading Pi game it's
04:55 - really simple
04:57 - now we'll move on to the coding and
05:01 - introduction part of pie game so let's
05:05 - get to it
05:08 - so I have made this little code for you
05:13 - so that you can understand how we work
05:16 - with pi game
05:17 - first of all the introduction of Pi game
05:19 - it is a python module that is for
05:24 - creating video games you can create a
05:26 - new number of video games like mistake
05:29 - game tic-tac-toe you can make any space
05:32 - shooter game you can visualize moving
05:37 - objects you can draw
05:40 - shapes and you can do a lot of stuff
05:43 - with like it has a lot of functions a
05:45 - lot of methods it works really
05:48 - efficiently with the latest version of
05:50 - by python
05:52 - what I have done is
05:54 - that I have divided any by game code
05:59 - into three basic steps that is importing
06:03 - buying initializing Pi D it was one
06:06 - setting up the screen on which we would
06:09 - see the output and running the game Loop
06:12 - okay so you might not get the idea of
06:15 - setting up the screen and the game Loop
06:17 - we'll get to it slowly
06:20 - so first of all importing or importing a
06:22 - module
06:24 - this is how we do it in Python you write
06:27 - import and then you write the name of
06:30 - the module that you want to import
06:31 - then we have this initialization part
06:37 - that is spygen.it don't worry about from
06:40 - pygame.locals it's another
06:44 - method of ID we'll talk about it later
06:48 - then we write Pi game dot edit we always
06:51 - write it because we want to call all the
06:53 - functionalities of Pi game
06:56 - and want to work with it
06:58 - like display is one of them dot display
07:03 - we then set up a screen the second point
07:07 - uh This is how we do it we call onto Pi
07:10 - game we get into display this is one
07:15 - module in inside Pi game
07:19 - and then we write dot set mode to set
07:23 - the screen and this is the size of the
07:25 - screen that we give the x-axis on the
07:27 - y-axis okay
07:29 - so
07:32 - okay so then we have
07:35 - the game Loop which is an infinite Loop
07:38 - and inside it we are first writing
07:41 - screen dot fill with a color code I hope
07:44 - you get that this is an RGB color code
07:47 - if you don't uh don't worry I'll refer
07:49 - you to a website
07:51 - and you can read about it there and we
07:53 - talk about the RGB colors
07:56 - more in the next video
07:59 - and this fill is a method that helps you
08:03 - color the background with this color
08:04 - okay then comes the for look for the
08:08 - event of the fighting
08:10 - and uh
08:13 - we talk about this in some time
08:17 - when we'd
08:19 - get some more knowledge about
08:23 - what is happening in this code
08:28 - but for right now just
08:31 - all that you just need to know is there
08:34 - are three basic steps
08:36 - the importing then initializing setting
08:38 - up the screen and having a game Loop
08:41 - okay and please set up yourself with
08:45 - python and vs code if you have if you
08:48 - don't already have them then install Pi
08:50 - game and we'll be talking about a lot
08:52 - more uh terminologies and by game and
08:57 - there's a lot to learn
08:58 - Fire game is a very vast module and
09:01 - uh
09:03 - you'll get a really good Hands-On to it
09:05 - if you follow this tutorial
09:08 - uh just uh to get an example let's run
09:12 - this this is very simple code in buy
09:15 - game this is a very simple code and Pie
09:17 - game I have done literally nothing in
09:19 - this it's just display of screen
09:22 - just so you do not get like overwhelmed
09:25 - with with what is happening I'll just
09:27 - run this and see what we get
09:30 - we get a window
09:32 - that is red in color that we specified
09:35 - 200 comma 0 comma zero
09:37 - and that's all let's begin
09:40 - okay we click cross and uh we can change
09:44 - the
09:46 - size of this window let's see let's do
09:49 - this 200 and 200. let's run this now
09:53 - let's see what we get
09:56 - we get a smaller window size
09:59 - you can even see that the maximized icon
10:03 - has been disabled because we cannot
10:06 - maximize this we have already specified
10:08 - the size of this screen and it is 200 by
10:12 - 200. so
10:15 - yes this is a live demo of Pi game and
10:19 - we'd be doing a lot lot more advanced
10:21 - stuff than just displaying the screen
10:24 - with the color with a basic color
10:27 - would be seeing different uh the screen
10:30 - changing colors and a lot more making
10:34 - video games and various stuff and biking
10:37 - till then get to your systems ready for
10:41 - working with python hey everyone in
10:44 - today's video we will be discussing some
10:46 - basic terms and methods in pi game
10:48 - module also we'll see some related
10:50 - examples
10:51 - so let's get started first up we have
10:55 - initialization of the module so we write
10:57 - import Pi game and then we initialize it
11:00 - by writing pygame.it
11:03 - we can also
11:05 - initialize a module in pi game
11:07 - separately like here I have written
11:11 - pygame.display.init we have separately
11:13 - called upon display we have separated
11:15 - initialized display module
11:18 - um but if we do this you would not be
11:21 - able to work with other sub modules you
11:23 - have to
11:24 - initialize them separately then so that
11:28 - would be a little bit tedious rather we
11:31 - do this by game dot init this
11:34 - initializes all the subclasses and sub
11:37 - modules of biking okay
11:39 - now to quit or uninitialize any module
11:44 - we use dot quit method we have already
11:47 - used it in a game Loop
11:51 - once we are done with working with pi
11:54 - game we do this spygame dot quit and
11:57 - this is how it is uninitialized and we
11:59 - can move out of Pi game okay
12:02 - then I hope you remember in the first
12:05 - video I told you that any bi game code
12:08 - would be divided into three parts and
12:11 - that is initializing
12:13 - setting up the screen
12:15 - and the game looped in so the second
12:18 - part we have that is
12:21 - setting up the screen so the setting up
12:24 - of screen is done using the display
12:27 - module okay so please listen carefully
12:31 - display module creates a new Surface
12:35 - object which helps us visualize whatever
12:37 - we have created a text a drawing or an
12:41 - image it can be anything okay
12:45 - um and display method helps us visualize
12:50 - what we have created on the screen we
12:53 - set using the set mode okay so this 600
12:56 - comma 600 is the size of the screen okay
12:58 - last time also we saw this and uh
13:03 - it is not just confined to setting up
13:05 - the screen giving sizes
13:08 - it has methods like get in it get in it
13:12 - gives us a Boolean response returns a
13:15 - Boolean response which tells us if the
13:18 - display
13:18 - module is initialized or not it has quit
13:22 - of course
13:24 - it has in it to initialize and it has
13:28 - get surface method which gives reference
13:32 - to the current window window okay so if
13:35 - you don't get this right now it's all
13:37 - right because uh we have not seen any
13:39 - example related once we see that you'd
13:42 - be a little bit clear with it
13:44 - we have flip and update there is a
13:48 - difference between flip and update
13:49 - although they are a little bit similar
13:53 - what does flip do it updates the entire
13:56 - video a window okay but update
14:01 - updates only portions of the window okay
14:06 - uh which are specified and uh whereas
14:10 - flip doesn't do it so you can say that a
14:13 - date is an optimized version of flip so
14:15 - we usually use update so that less
14:18 - memory is used okay
14:19 - then we have fill method which fills up
14:22 - the screen with some color okay
14:25 - so
14:27 - we are done with the second step let's
14:29 - move on to the third part that would be
14:34 - um
14:34 - correct like I would discuss a direct
14:38 - module
14:42 - direct class and thigh game is used to
14:45 - manipulate rectangular surfaces and
14:47 - store those objects
14:49 - we can make copies of those objects move
14:51 - them across the screen and do a lot of
14:54 - things
14:55 - to manipulate them edit them okay we
14:58 - always you use direct if you want to
15:01 - work with something that requires
15:02 - another surface earlier while writing a
15:05 - text while working with an image for
15:08 - example here we are working with an
15:10 - image okay I have loaded the image
15:13 - okay
15:14 - don't worry this is another subclass
15:16 - image is another subclass in biking and
15:19 - I have loaded it okay uh simple and then
15:22 - what I have done is I've made another
15:25 - variable which is
15:27 - been declared
15:30 - a direct class object okay ball dot
15:34 - catch right this is how I have declared
15:36 - it as a red class object and what it
15:39 - does it
15:40 - is it
15:43 - loads this image on a rectangular
15:46 - surface okay so that we can view it on
15:48 - the screen fine
15:51 - so this is one functionality of correct
15:54 - uh red class okay we can even copy uh
15:59 - this
16:01 - object ball object or ball wrecked and
16:06 - use it otherwise we can move it we can
16:09 - move it in place we can change the size
16:12 - by using a plate we can update its
16:15 - positions we can change it's where it is
16:18 - located on the screen
16:20 - we can clip it we can crop it we can
16:23 - resize it and uh much more erect
16:27 - involves much more functionalities but
16:30 - these are some basic ones so
16:33 - which we would require right now okay so
16:36 - yeah let's move on to the very important
16:39 - part of Pi game code that is the gaming
16:43 - Loop okay and the gaming Loop involves
16:45 - events
16:47 - every action and Pi game is named
16:50 - through a queue okay
16:51 - a queue is list which follows uh first
16:55 - in and first out principle uh I don't
16:59 - know if you know about Q or not it's a
17:01 - data structure and it follows first and
17:03 - then first out principle and um
17:08 - it's it's just a simple list where
17:10 - insertion and deletion are done from
17:13 - different ends okay so just treat it
17:15 - like a list and um
17:18 - all the events are stored into a queue
17:21 - Okay so
17:23 - every time we call if Pi game dot event
17:25 - uh
17:27 - an action or an event from the queue is
17:30 - popped out and been carried out okay it
17:32 - has been handled
17:33 - the instructions have been carried out
17:36 - so that we do not face any loss of event
17:39 - as the queue might get filled over uh
17:43 - over time okay
17:45 - and
17:47 - following this
17:48 - an event can also be an input from the
17:52 - keyboard
17:53 - so to deal with keyboard inputs we have
17:57 - a different subclass that is key okay
18:00 - so
18:02 - whenever we call the spygen.key down and
18:05 - key key up
18:07 - whenever a key is pressed these are
18:10 - automatically called okay
18:12 - and uh
18:17 - this then helps by game dot event to
18:20 - carry out the definite or whatever
18:24 - event is said to be carried out for
18:26 - example I have written down a little bit
18:28 - of code for you
18:30 - which is
18:32 - talking about how key down and key up
18:36 - works so here
18:40 - um I have just written pygame dot key
18:42 - down because key down and key up are
18:46 - simultaneous processes as you
18:49 - press a key first key down is called and
18:52 - then you release it then key up is
18:54 - called okay
18:55 - so you don't need to write it uh like
18:58 - separately pygame dot key down or key up
19:00 - I have just written key down okay and if
19:04 - the event of key event dot key okay is K
19:09 - a this is the way of the uh telling that
19:12 - the key pressed is a okay and this is
19:16 - the way of telling that the key press to
19:18 - zero you can have it for all the
19:22 - keys on the keyboard okay so or else if
19:27 - not something else is pressed you output
19:30 - a keywords press so let's run this and
19:33 - let's see how it works
19:35 - run this and yeah uh so now I press a so
19:40 - a will press it outputs a was pressed I
19:43 - hope you can see it
19:45 - okay then
19:48 - when I when I press 0 it shows 0 is
19:51 - pressed if I press e a key is pressed
19:54 - because I did not mention anything for E
19:56 - okay so yeah let's
19:59 - stop this and let's go back to our
20:02 - initial
20:04 - page
20:05 - oh this is how we work with keys and
20:09 - keys have a lot of other methods uh like
20:11 - get focus is there if we uh to check if
20:15 - we are receiving keyword inputs properly
20:18 - from the system
20:19 - we have get pressed like to get the
20:22 - state of all the keyboard buttons then
20:25 - we have name each of these Keys have
20:28 - an identifier so uh we get that
20:31 - identifier from this we get the key code
20:34 - we can get the key code from the name
20:35 - this takes an argument and from the name
20:38 - we can get the identifier okay
20:41 - and so and so we have in other methods
20:44 - also
20:45 - we'd see them once we use them in
20:49 - further examples okay
20:52 - uh so coming back to the game code
20:56 - um
20:57 - that was
20:59 - we had initialized the ball uh image and
21:04 - then we have we are
21:07 - working with
21:09 - getting it on the
21:12 - the next class okay right now we have
21:14 - got it on a red class object and I have
21:18 - mentioned the speed
21:20 - which is one comma one it works as an
21:22 - argument of wrecked class uh method move
21:26 - okay
21:28 - so what I've done is I've given it I've
21:31 - given speed as an argument so it shows
21:34 - that
21:35 - the x axis with respect to the x axis
21:38 - the object would be moving one
21:41 - um
21:42 - uh one unit and with y-axis it would be
21:47 - also moving one okay so
21:50 - so rectangle would always have on on a
21:53 - plane it would always have four points
21:56 - the Left Right top and bottom I hope you
21:58 - can imagine it and when the left
22:02 - point is less than zero the speed is uh
22:07 - the zeroth coordinate like this one is
22:10 - changed to minus one because we need to
22:13 - oppose the motion now okay
22:15 - or even when uh this happens when it's
22:18 - to the extreme right like it is more
22:21 - than the size of the screen
22:23 - similarly uh for top and bottom we are
22:26 - changing the y-axis okay motion out the
22:28 - y-axis and we will fill the screen with
22:31 - some color that is white right now and
22:34 - we'll do
22:36 - blit which is
22:40 - loading the ball object ball variable
22:43 - the image on the ball rect okay uh and
22:47 - then we are displaying it and updating
22:51 - the complete thing okay complete screen
22:55 - let's see how this works
23:02 - three this is a random motion if we uh
23:07 - make 0 comma 1 so it should only move
23:10 - along the y axis let's see if it does so
23:14 - yeah it is moving along the y-axis okay
23:16 - it's not traveling anymore
23:18 - and what if we make this
23:22 - happen
23:24 - it should just move along the y-axis but
23:26 - with more speed
23:27 - yeah it does
23:31 - Okay so
23:34 - that's pretty much it
23:41 - so next up we have some
23:43 - more definitions uh or more subclasses
23:49 - the first one is font uh we'll be
23:51 - discussing these in very brief because
23:53 - we'll be working with them further and
23:56 - we'll be discussing them more deeply in
23:59 - the next upcoming videos we have font
24:02 - when we'd be working with text uh
24:04 - printing getting a text on the screen
24:07 - would work with font we can like see
24:13 - what the default font is what all fonts
24:16 - are there we can create a new object
24:17 - from a file we can uh change the
24:23 - edit the
24:25 - text the style of the text we can style
24:27 - it we can make it bold we can make it
24:30 - italic we can underline it we can see
24:32 - what the size is we can see the ascent
24:34 - and Descent of the text
24:36 - and we can do a lot more
24:38 - then when we'd be working with images we
24:41 - would be uh using this image class and
24:45 - image module and we can load and unload
24:48 - an image we can change its format we can
24:50 - save the image we can crop it then we
24:54 - have time we can keep a track of for how
24:57 - long the program has been running we can
25:00 - change the frame rates then we have
25:03 - music uh module to work with
25:07 - audios and we can rewind we can stop we
25:11 - can play the new audio and we have
25:16 - even the draw module to draw shapes like
25:19 - circles polygons we can even draw a line
25:22 - and curves
25:23 - and so this is pretty much about the
25:27 - very basic uh and startup
25:32 - things and the startup modules that are
25:35 - available in pi game
25:37 - hey everyone in the last video we
25:39 - discussed about some High game modules
25:42 - in brief now it's time we put that to
25:44 - use we would try displaying some text on
25:47 - pie game window
25:48 - let's get started I have initialized Pi
25:51 - game as usual set up the screen and then
25:54 - is the new part
25:56 - I have used font module by pie game we
25:59 - have used sys font then
26:01 - which takes in attributes like the font
26:03 - style size of font mentioning about the
26:06 - italics and bowls it is an option here
26:08 - if you are mentioning about italics in
26:11 - bolts but you have to mention the font
26:14 - style and the size of font otherwise
26:16 - you'll get an error from sysband
26:19 - if you do not mention about the talexin
26:21 - bowls they are false by default
26:23 - we have a lot of system fonts let's take
26:26 - a look at them if you run this piece of
26:28 - code
26:29 - pygame.fort dot get fonts you will get a
26:34 - list of all the fonts that are available
26:35 - in the system
26:37 - here it is you can use any of these
26:40 - fonts to design your text
26:44 - firstly I'll just walk you through the
26:46 - basic code after that we'll add some
26:48 - more functionalities
26:50 - so after creating a font object I
26:54 - declared a text variable which would
26:56 - create a new Surface with given text
26:58 - rendered on it I hope you get this
27:01 - it would create a new Surface with given
27:04 - text rendered on it then we call Direct
27:06 - class object to see the text on pycam
27:09 - window
27:10 - last time we discussed direct class in
27:13 - detail I hope you can understand what is
27:16 - happening over here then as the infinite
27:19 - Loop
27:20 - you will fill the screen with some
27:22 - random color use lit from surface class
27:25 - to get the text and text checked on the
27:27 - window that is to short text on text act
27:31 - okay
27:32 - after that we have event in pi game dot
27:35 - events which updates and runs the given
27:37 - command until we quit okay
27:40 - so let's run this and see what we get
27:43 - so on running this code this is what we
27:46 - get we have the text at the extreme left
27:48 - of the screen but what if I need it in
27:51 - the center of the screen so
27:55 - let me change a little bit of it
27:58 - and
28:00 - and see if I can bring the text in the
28:04 - center
28:06 - for that we have text direct Dot Center
28:09 - so I brought the rectangle surface to
28:12 - the center by using this method and I
28:15 - have specified the coordinates as the
28:17 - center of the screen I this is the size
28:20 - of the screen is 500 by 500 so I've
28:22 - divided it by 2 and we get to the center
28:25 - let's run this now and see what we get
28:30 - voila we have the text at the center
28:35 - now let's see what else we can do we can
28:38 - set a caption to the buy game window
28:41 - we use spygame.display.set caption
28:45 - we can also underline the text that we
28:48 - have by font.set underscore underline as
28:52 - true
28:54 - and let's run it and see what we get
29:01 - we have an underlying text and we have
29:04 - the caption pygame text cool
29:10 - uh this was one program now let's try
29:14 - and move this text along the different
29:16 - axes on the window for that I have
29:18 - written helpful code first I have
29:20 - initialized pygame then the screen with
29:22 - size 500 comma 500 then I have declared
29:25 - the font object with style Times New
29:27 - Roman and size 30.
29:29 - variable letter is used to render the so
29:32 - created font object
29:34 - then I have declared a variable I that
29:36 - decides the speed of the text how fast
29:38 - the text changes its coordinates please
29:40 - note that right now I am moving the word
29:42 - long x axis only
29:45 - so entering the game Loop now
29:48 - there is a condition if I is greater
29:51 - than 500 that is the length of the
29:53 - screen please see that the length of the
29:56 - screen is 500 when I is greater than 500
29:59 - I is equal to 0 we make I equal to 0
30:03 - this means once the text has traversed
30:06 - complete length of the screen we want to
30:08 - see it appearing from left again and the
30:10 - time gap between this action is of 5
30:13 - milliseconds I have done this using the
30:15 - time module of python
30:17 - so bygame.time.weight 500
30:21 - gives a gap of 5 milliseconds between
30:24 - these two actions
30:27 - then comes the win dot fill so I have
30:30 - colored the background white with fill
30:33 - now comes the tricky part uh rather not
30:36 - tricky part but you would need to
30:38 - visualize it a little
30:40 - so here in blit we have used the font
30:44 - object unwrecked class object always
30:47 - but this time I have taken no rect class
30:50 - object as you can see but I have given
30:53 - coordinates
30:54 - I comma 0.
30:56 - which shows the origin because I is
30:59 - equal to 0 for right now
31:01 - um so that gives me the origin the
31:05 - extreme left upper corner of the screen
31:08 - once this runs I is increased by 80 so
31:12 - you must infer that larger I gives more
31:16 - speed as this is what is giving the
31:18 - difference between two consecutive spots
31:20 - of the text okay
31:22 - please try to visualize this
31:25 - and again
31:28 - there is a weight of 5 milliseconds
31:30 - after we run this event Loop
31:33 - between the appearance of the text at
31:36 - two consecutive positions there is a
31:38 - weight of five milliseconds uh I have
31:41 - given a weight otherwise we won't be
31:44 - able to visualize the text moving it
31:46 - would move in a Flash so let's see this
31:48 - running uh let's see what we get and how
31:51 - this text moves across the screen along
31:54 - x-axis so now let's run this and see how
31:58 - the text moves along the x-axis
32:01 - yes so this is how it moves along the
32:04 - x-axis we can also move it along the
32:06 - y-axis for that I need to Interchange
32:09 - these two coordinates
32:11 - I would make it 0 comma I now so it
32:14 - would move along the left side of the
32:18 - screen so let's run it and see if it
32:19 - moves along the left side
32:24 - so yeah it does run okay cool
32:28 - now you can even think about how we can
32:31 - make this text move along the bottom of
32:33 - the screen or along the right side of
32:35 - the screen for that you might need to
32:37 - change the zero to something else uh
32:40 - maybe the size of the screen the wire or
32:43 - the x-axis so think about it
32:46 - hey everyone this video is going to be
32:48 - about image handling in pi game we would
32:51 - load an image see it scrolling across
32:54 - the screen rotate it and scale it and
32:56 - also we would talk about the transform
32:58 - module which is readily used with images
33:00 - in biking so let's start with normal
33:03 - image loading I have initialized Pi game
33:06 - declared the screen and in the fourth
33:08 - line I have used the load function from
33:10 - image module by pi game to load the
33:12 - image
33:13 - it takes one argument that is the name
33:15 - of the file or path let's keep it simple
33:18 - for now just use the file name this is
33:20 - the image we would work with
33:22 - then is our normal game loop I have
33:25 - colored the screen white with fill used
33:28 - plit to get the image at the provided
33:30 - coordinates we can also use the right
33:32 - object we would do that in a minute and
33:35 - then there's our regular events Loop so
33:37 - let's run this code and see if the image
33:39 - is loaded on the screen so yeah it is up
33:42 - and running but what if I needed the
33:44 - image at the center of the screen we
33:46 - would just repeat what we did last time
33:48 - to bring this text at the center
33:50 - there we have the font object here we
33:53 - have the image object we would get it on
33:55 - the rectangle by declaring a erect
33:57 - object and assign its Center the center
34:00 - coordinates of the screen let's run this
34:03 - now see if our image is at the center
34:10 - so yeah we have our image at the center
34:13 - of the screen cool
34:15 - what if I want to move this image across
34:17 - the screen for that we would repeat
34:19 - exactly what we did for scrolling the
34:22 - text
34:23 - you can see here I have taken the speed
34:25 - determining I variable put up a
34:28 - condition given a weight of 5
34:29 - milliseconds incremented I by 80 it's
34:34 - exactly the same it's just that last
34:36 - time we had text object now we have
34:39 - image object
34:40 - so let's see how it moves
34:44 - here you can see the picture moving
34:47 - across the x-axis you can also try it
34:50 - moving across the extreme left you can
34:54 - try moving it in the bottom along the
34:57 - bottom
34:58 - and along the right side too
35:01 - just like we did for the text
35:07 - now let's try to rotate a still picture
35:10 - for this we would use the transform
35:12 - module as you can see I have loaded the
35:14 - image in the seventh line
35:18 - then I have used rotate function by
35:20 - transform
35:21 - it takes two arguments the object you
35:24 - want to rotate and the angle by which
35:25 - you want to rotate the positive angles
35:28 - rotate anti-clockwise and please note
35:30 - the angles are in degrees
35:32 - and after that we have our simple game
35:35 - loop with no new things you will fill a
35:38 - color get the image object on the given
35:40 - position then run the events Loop so
35:43 - without wasting any time let's run it
35:45 - and see if the image is rotated
35:47 - yeah we have our image rotated
35:50 - clockwise by 90 degrees since I gave an
35:53 - argument of minus 90. cool
35:59 - now let's try to scale the same image
36:01 - for that we would use the scale function
36:03 - by transform scaling is just resizing
36:06 - the surface to a new size
36:08 - the second argument here is of the new
36:11 - size that you want for the image
36:14 - and then it's our normal game Loop so
36:16 - let's run it and see if we have new
36:18 - sized image yes we do have a new sized
36:21 - image the original image squeezes into
36:25 - the size we have provided that is 200 by
36:28 - 200.
36:32 - in the last two programs we use
36:34 - transform module this module has some
36:37 - more functionalities let's look at them
36:39 - so I have loaded an image
36:42 - it's the same program as of the first
36:44 - one
36:45 - and use the flip function Now by
36:47 - transform so it takes in three arguments
36:50 - the surface you want to flip and the ax
36:53 - is about which you want to flip I have
36:55 - flipped it about x axis as the second
36:58 - argument is true and the third one is
37:00 - false
37:02 - if I run it my picture is flipped about
37:04 - x axis you can do this for y-axis as
37:07 - well then you can even set both the of
37:10 - the arguments as true then the image
37:13 - would be flipped about both the axis
37:17 - next up we have Toronto Zoom which is a
37:21 - combination of rotation and zooming in
37:23 - the image
37:25 - of course the function itself the name
37:27 - of the function itself explains it it
37:30 - takes three arguments as well the
37:31 - surface you want to work with then the
37:33 - angle of rotation and then the zoom in
37:36 - factor which takes a flow data type so
37:39 - you can given arguments like 1.5 2.5 and
37:43 - 2.25 Etc
37:45 - you can given a float data type
37:48 - it is not just confined to integers
37:50 - let's run it and see what we get
37:54 - so we have our picture zoomed in by 1.5
37:57 - and it is even rotated by 90 degrees you
38:00 - can even rotate it by 180 degrees not a
38:03 - problem
38:04 - or by 360 then you'd get the same image
38:06 - again
38:11 - now if you want to picture double the
38:14 - original size you can use the scale 2x
38:16 - function
38:19 - if you are using this function you do
38:21 - not need to mention the zoom in factor
38:24 - it's automatically to
38:25 - we get a picture which is double the
38:27 - size of its original size
38:29 - so let's run it and see if we have what
38:32 - we are expecting
38:34 - so yeah the image is double the slides
38:37 - of its original one
38:40 - transform also has this average color
38:42 - function which gives you the average
38:44 - color of the mentioned surface now if I
38:47 - print this
38:49 - for the current image it comes out to be
38:51 - this color there's a color this is an
38:55 - RGB
38:57 - format so yeah this is one color that we
39:00 - get
39:02 - it is the average color of the given
39:04 - image so in this video we worked with
39:06 - the image and transform module next time
39:09 - we would work with the music module in
39:11 - pi game hope this video helped you thank
39:13 - you
39:15 - hey everyone so today we'll be talking
39:18 - about the music and mixer module in pi
39:20 - game they go very hand in hand the mixer
39:23 - module has many modules like music sound
39:27 - channel today we'll be talking about
39:29 - only the music module I could have
39:33 - use the sum module as well but the music
39:36 - module is more versatile
39:39 - they eventually turn out to be similar
39:41 - although the way they work is different
39:42 - so what the mixer module does is it
39:46 - helps to control playback of the
39:47 - streamed music
39:49 - we won't do anything tedious today we
39:51 - would just learn some functions by music
39:54 - module and write a code to understand
39:56 - how they work
39:58 - so the first function we have in music
40:00 - module is load
40:02 - as we hard load an image module just
40:05 - like that here the load function loads
40:08 - the music file and prepares it for
40:10 - playing it doesn't play the music please
40:12 - note it doesn't play the music if music
40:15 - is already playing the load function
40:17 - would stop playing it and restart
40:19 - everything
40:21 - then next we have the unload function to
40:25 - unload the currently loaded music file
40:27 - and free up space and variable
40:30 - then we have the play function which is
40:33 - used to play the music once loaded so it
40:37 - takes in three arguments they are not
40:39 - mandatory but you can give at most three
40:42 - arguments so the first one is how many
40:45 - times you want to repeat the music
40:47 - which is called as Loop it should be an
40:49 - integer then we have start position
40:51 - which should be a float from where the
40:54 - music should start that's what it
40:56 - mentions then we have fade underscore Ms
41:00 - the time for which the music should Fade
41:02 - to volume zero in milliseconds please be
41:05 - careful while giving the arguments in pi
41:07 - game as there are many units of time in
41:11 - biking
41:13 - then we have the rewind function which
41:16 - plays the audio file from the beginning
41:18 - it's very simple if audio is passed it
41:21 - remains paused if unpassed the music
41:24 - starts from the beginning
41:26 - now we have the stop function which
41:28 - stops the music
41:30 - please note that stop and unload are not
41:33 - the same
41:34 - then we have the pause function to
41:36 - temporarily stop the music then we have
41:39 - the unpause function to
41:42 - resume the music after it is paused
41:46 - then we have this Fade Out function it
41:49 - takes time argument for which music
41:51 - should Fade Out in milliseconds cool
41:55 - then we have some methods like the set
41:57 - volume get volume get busy set position
42:00 - get position let's discuss them one by
42:02 - one we have the set volume method which
42:06 - is used to set the volume of the audio
42:09 - we can know the current volume of the
42:12 - audio by checking the get volume
42:15 - we can know if the player is busy or Not
42:20 - by using the get busy method it returns
42:23 - a Boolean
42:26 - which is true when music is playing
42:29 - then we have the set position method
42:32 - to set from to set the point from which
42:36 - playback should start playing then we
42:39 - have get position to get the time for
42:41 - how long the music has been playing
42:43 - then we have this queue function to
42:45 - enqueue a song to the current one
42:48 - once the current song is done playing
42:51 - the Q function
42:53 - would play the next song
42:55 - automatically we can only enqueue one
42:58 - song at a time
43:00 - so I don't want to write pygame dot
43:03 - mixer dot music over and over again
43:05 - so what I did is I wrote from PI game
43:09 - import mixer I initialize the Nixon
43:12 - module loaded the song then I used the
43:14 - played Funk play function to play it
43:17 - now we would see other functions later
43:19 - let's do the basic music streaming first
43:22 - then I have printed the Boolean get busy
43:25 - to check whether the player is busy or
43:27 - playing or playing something or not
43:29 - then I have a loop a loop is not
43:32 - necessary because we don't have the
43:34 - screen displaying something or not here
43:36 - we don't have any events
43:38 - just to make the program more functional
43:40 - like an audio player I have done this I
43:44 - have taken an input
43:45 - like for p
43:48 - pause U to unpause R to rewind as to
43:52 - exit
43:53 - then I have these conditions
43:56 - to pause and pause rewind and exit
43:59 - accordingly according to the input
44:02 - so if I run it now you would hear an
44:05 - audio
44:06 - and
44:08 - it's the song dot MP3 it's right here in
44:12 - the python folder so let's run this code
44:14 - and see if we hear an audio
44:20 - [Music]
44:34 - so I press p and I get the answer as
44:39 - false as player is no more streaming and
44:43 - it's no longer busy as I have paused the
44:47 - audio if I unpause it you'll see that
44:51 - the get busy function
44:53 - returns true
45:03 - so I've stopped the function and it
45:07 - returns false the capacity method
45:10 - returns false as the player is no longer
45:13 - playing
45:14 - the music
45:16 - now let's try using this cat volume
45:18 - method to get the current volume of the
45:20 - audio then I'd be setting the
45:23 - volume to 0.8 by using set volume method
45:27 - and check it again if the volume was set
45:29 - properly
45:31 - now let's run this
45:35 - so we have the volume to 0.9 which is
45:38 - almost 1.
45:43 - and then we have set the volume to 0.8
45:46 - so the volume comes out to be 0.8 so
45:50 - yeah things are working as we want it to
45:52 - be now let's try getting the position
45:54 - for how long the audio has been playing
45:59 - [Music]
46:03 - [Laughter]
46:05 - [Music]
46:09 - so the audio has been playing
46:12 - from one milliseconds
46:14 - the output is one millisecond if most
46:17 - functions are being called out the time
46:18 - would increase
46:20 - now let's try doing the Fade Out
46:22 - function
46:24 - so I have written
46:26 - mixer.music.fadeout and written 10 000
46:29 - in the argument so I have given the
46:32 - argument of 10 seconds that is after 10
46:35 - seconds the music should start fade away
46:38 - and stop
46:40 - since one second has thousand
46:42 - milliseconds so I've multiplied ten by a
46:45 - thousand so let's check if the music
46:48 - Fades away after 10 seconds
46:59 - foreign
47:03 - [Music]
47:07 - so yeah the music did fade away after 10
47:10 - seconds and if I check for
47:12 - unpause now
47:15 - or let me check for rewind if I check
47:17 - rewind now it comes out to be false
47:19 - because the Fade Out function completely
47:21 - stops the audio
47:24 - player and
47:27 - hence the player is no longer busy now
47:30 - let's try the set position function I
47:33 - have given the argument as 120 seconds
47:35 - so I want the music to start from two
47:39 - minutes
47:40 - from the position two minutes let's see
47:43 - if the music starts Midway let me run
47:46 - this
47:49 - [Music]
47:53 - so yeah the music starts Midway that is
47:56 - from governance
47:58 - now let's use the Q function uh I'd be
48:02 - writing
48:04 - mixer.music.q and I've mentioned this
48:07 - next song.mp3 it's also in the python
48:10 - folder you can see it over here
48:13 - I don't want to wait for like two
48:16 - minutes to listen to the entire song
48:19 - then I'd check if the song is cute and
48:22 - it has been played automatically so I'd
48:25 - set position as 170 seconds
48:29 - so that the song starts from the
48:31 - position 170 seconds
48:34 - so that I can skip this one okay so let
48:37 - me play this and see if the song has
48:40 - been queued
48:43 - [Music]
49:03 - foreign
49:13 - gets uncued and it has been
49:16 - automatically played without any
49:18 - indication
49:21 - this was all about the music module
49:26 - I hope you understood what always
49:28 - explained
49:30 - thank you
49:31 - hey everyone
49:32 - so till now we have talked about the
49:34 - font music and image module in buy game
49:37 - it's time we get a little bit inclined
49:39 - towards the video game creation part of
49:42 - Pi game in this video we won't be
49:44 - creating a video game but yeah we would
49:46 - be doing something related
49:49 - we would try to see a snowfall we would
49:51 - try to create our own snowfall on the
49:53 - bike game screen
49:55 - so if I'm talking about snow falling
49:57 - then it should make sense to you that we
50:00 - would do something related to the moving
50:02 - text or moving image but along the
50:06 - y-axis
50:07 - and uh
50:09 - if it makes sense to you if you're able
50:11 - to think about that then yeah you're on
50:13 - the right path and you have
50:15 - actually understood what has happened
50:17 - till now
50:19 - and a little bit prerequisite for this
50:21 - video would be the knowledge of the
50:23 - random module if you don't know about it
50:25 - it's all right I'd be telling you about
50:28 - random module moreover we would just be
50:31 - using a function from random module
50:35 - um I would need random module just think
50:37 - about it why would I need random module
50:39 - because I want snow on random spots of
50:42 - the screen okay so that's why I'd be
50:44 - using the random module
50:46 - so that I can have random coordinates
50:48 - all right
50:51 - so let's get to the code right away it's
50:53 - going to be very easy
50:55 - so first we have the basic three steps
50:59 - I hope you remember the first step is
51:02 - initializing Pi game I have done so then
51:05 - I have imported random module just so I
51:08 - can take random spots random coordinates
51:10 - then I have the step two setting up the
51:13 - screen then I have taken up a list
51:18 - snow so what I do is I had append some
51:23 - coordinates in snow which at which I
51:27 - would need the snow at the at which I
51:31 - would draw the circles okay
51:34 - so I have run this for Loop okay for
51:38 - range 50
51:39 - the length of the list would be 50 and
51:44 - uh
51:45 - then I have picked up
51:47 - a random number this is what Rand range
51:51 - does in random module it picks up a
51:54 - random number from the given range
51:57 - and similarly for Y X Y also y
52:00 - coordinate also and then I'd be
52:03 - appending the list
52:05 - to the smallest
52:07 - so snow becomes a 2d list just like this
52:12 - I hope you get it and uh
52:15 - so we have list that has some random
52:18 - continents okay
52:19 - then I have set up this clock object
52:22 - from the time module so that I can work
52:25 - with the frame rate later
52:27 - you'd get the purpose of this later I'll
52:30 - tell you later at the end of the program
52:33 - now is our third step the game Loop
52:37 - so then we have our events loop as usual
52:41 - I have fill the screen with white color
52:43 - you can also take black color and white
52:46 - color snow doesn't matter now is the
52:48 - main part
52:50 - for ice in range length snow now we
52:53 - would be traversing each
52:55 - element of snow
52:57 - and draw a circle at that coordinate
53:01 - okay so for that I have written pygame
53:04 - dot draw I have used the draw module and
53:06 - use the Tross and use the circle
53:08 - function from draw
53:11 - so this is the screen the surface on
53:13 - which we want to draw then we have I've
53:15 - mentioned the color I want blue circles
53:18 - and then the coordinate would be given
53:21 - by snow ice okay and the radius would be
53:26 - 2 pixels
53:28 - since I want the snow to fall along
53:32 - y-axis I'd be increasing the y-axis
53:36 - you can see like the y-axis would be
53:39 - given
53:41 - by the ice elements
53:43 - first
53:46 - element okay this might be a little
53:49 - jumbling how do you access a to-do list
53:51 - you go to the
53:54 - first number like I go to the ice
53:57 - element ice element and then go to the
54:01 - first element inside that list so this
54:04 - becomes
54:06 - the y coordinate of the random
54:09 - y coordinate of the random Point Okay
54:12 - cool so I'd be increasing that by one
54:15 - each time okay because I want the next
54:18 - part to be just below it I do not change
54:20 - the x axis but I change the y axis
54:23 - because I want the snow to fall down
54:27 - now there is this corner case that if
54:32 - the snow if the coordinate now becomes
54:34 - greater than the screen size which is
54:35 - 400 right now then what I do is I'd pick
54:39 - any random
54:40 - number again I had completely changed
54:43 - the coordinate I'd pick any random
54:45 - number from minus 50 to minus 10 because
54:48 - I want the drop I want the snow to fall
54:52 - from the top and not from any random
54:54 - point and not from in between so that's
54:57 - why I've taken this negative range
54:59 - and I'll reassign the value of the x
55:02 - coordinate also since it's I is and zero
55:05 - and square brackets
55:07 - then I update
55:10 - the display you can also use flip here
55:13 - not problem then I have used this clock
55:15 - object and use the tick function so that
55:19 - I can set up the frame rate by default
55:21 - it's 0 if it's if you do not mention
55:23 - this the
55:25 - snow would fall
55:27 - in a Flash like it's it would look like
55:29 - it's running the snow is running it
55:31 - won't make any sense so the larger the
55:34 - frame rate is the slower is the snowfall
55:37 - okay so let's check it out how this
55:40 - works
55:45 - so we have our snow falling very
55:48 - properly just randomly from anywhere as
55:51 - snowfall is you can also take up
55:53 - different colors like let me change the
55:56 - color here
55:57 - let me do Black
56:00 - and make this circle of white color
56:05 - so let's run this
56:09 - this also looks nice you can try either
56:11 - one you can even have any combination of
56:15 - colors so that's pretty much it about
56:18 - this video
56:19 - hope you understood the program
56:23 - we'll do more in the next videos in the
56:25 - upcoming videos
56:26 - thank you
56:33 - hey everyone in the last video we made
56:37 - our own snowfall and tried to use the
56:39 - basic concepts to make something better
56:41 - this time we would again move an object
56:44 - around but the movement would be user
56:46 - controlled
56:47 - last time if you remember it was
56:49 - pre-programmed
56:51 - so if I say user control that means we
56:54 - would take the
56:55 - keyboard inputs
56:57 - and move our figure around the screen
57:00 - according to those inputs I hope you
57:03 - remember the key module we talked about
57:05 - in the second video now it's time we put
57:07 - that to use
57:09 - let's get to the code right away we
57:12 - would go stepwise initializing Pi game
57:14 - setting up a screen the screen size I
57:16 - have taken it to be 500 by 500 you can
57:18 - take any screen size not a problem I
57:21 - have also set up a caption which is
57:23 - moving the given object
57:26 - then we have declared the initial
57:27 - position of the object as X comma y it
57:30 - is 100 comma 100 it is the position on
57:33 - screen we would find our object right
57:36 - after we run the code good
57:39 - then we have to set up the speed
57:41 - the speed by which the object would move
57:44 - the speed by which we want the object to
57:46 - move
57:47 - so it is set up to 3 which means the
57:50 - object should be displayed by three
57:52 - units along the given axis on pressing
57:54 - the respective key once
57:58 - then we have the size of the object I
58:00 - have tried to make a man figure with a
58:02 - circle and rectangle it's my object
58:04 - that's what I want to move around
58:06 - so this width and height is for that
58:09 - rectangle if you didn't understand you
58:12 - would get it when I draw the figure
58:14 - okay
58:15 - so then we have our game Loop the
58:18 - regular one
58:19 - I have given a time delay of 10
58:22 - milliseconds so that object doesn't run
58:24 - and we can observe the defined speed
58:27 - properly
58:28 - neela is used to pause the program and
58:30 - so we have a refreshed screen after that
58:34 - then we have our events Loop
58:37 - used for handling events and quit the
58:40 - program if asked to do so
58:42 - then I have taken a key variable that
58:46 - would contain a list or sequence of the
58:48 - status of all the keys on the keyboard
58:51 - key is a list of booleans that can be
58:54 - accessed like this
58:56 - we just access it like a normal list but
58:59 - the indexing is done using the key
59:01 - constants so this is done with the help
59:03 - of
59:04 - unders get underscore pressed method
59:08 - the one key that is pressed its state is
59:12 - true other Keys have a false state
59:15 - so I have these four conditions my
59:18 - object can move around in only four
59:21 - directions
59:23 - left right up and down so accordingly I
59:26 - have these four conditions when I press
59:29 - the left Arrow key I will reduce the
59:31 - speed units
59:33 - from current x coordinate
59:36 - when the right arrow key is pressed
59:38 - I will increment the x coordinate by
59:41 - speed units and similarly for going up
59:44 - and down I decrease or increase the y
59:47 - coordinate respectively
59:49 - I would print what Arrow key I have
59:51 - pressed or
59:53 - so that it is it is easy for you to
59:55 - understand and there is no confusion
59:58 - this x greater than 0 and x less than
60:01 - 500 minus width then y greater than 0 y
60:04 - less than 500 minus height these all
60:07 - conditions are used to keep the object
60:10 - within the screen so that the object
60:11 - doesn't run out of the screen
60:14 - so that should be easy to understand
60:17 - now this is the code for making my man
60:20 - flicker so it's just a circle on a
60:22 - rectangle
60:23 - so you use the rect function in draw to
60:27 - draw a rectangle here x comma y are the
60:31 - coordinates or position of the rectangle
60:33 - and width and height are for the size
60:36 - then there is a circle
60:38 - now to place the circle right on top
60:41 - middle of the rectangle
60:43 - I found the mid of the width and also
60:46 - reduced Y axis by 5 so that there is
60:49 - just an overlap of two units between
60:52 - rectangle and the circle
60:54 - I hope you understand the height of the
60:57 - rectangle with 7
60:59 - and if I reduce the y-axis this 7 by 5
61:03 - there is an overlap of only two units
61:06 - hope you can visualize it
61:08 - then we update the program
61:11 - and let's run it
61:18 - okay so this is what we get when we run
61:22 - this code
61:23 - we find our object at the
61:26 - initialized position it's 100 comma 100
61:29 - it's that coordinates 100 comma hundred
61:31 - now if I press the right arrow key I
61:34 - should see right arrow key printed and
61:37 - the object should also move right cool
61:39 - let's do it once
61:41 - the object move right
61:43 - and right arrow key was also printed let
61:47 - me press the down arrow key so it should
61:50 - move down
61:52 - it moved down the object moved down now
61:55 - let's try for left Arrow key we have
61:58 - left auto key printed and it also moved
62:01 - left
62:02 - let me press left Arrow key again
62:04 - so yeah it's going left again I'm gonna
62:07 - press left Arrow key yeah so let me take
62:10 - it to the origin
62:12 - cool
62:14 - in the next video we would try to make
62:16 - the snake game we would try to create
62:19 - that on our own a video game a live
62:21 - working video game
62:24 - for that this moving object program
62:26 - would be very important if you
62:29 - understood this moving object program
62:31 - then the Snake Game program would be
62:33 - very easy for you
62:35 - and
62:38 - from the next video onwards we would put
62:40 - to use all that we have learned till now
62:42 - all the basics that we have learned now
62:45 - and things are going to be very
62:47 - interesting
62:48 - so from now on we would look at the real
62:52 - application of Pi game module which is
62:55 - video game creation things are going to
62:57 - be very fun and easy
63:00 - I hope you're understanding what all I
63:02 - have explained till now everything that
63:05 - I have taught you
63:06 - thank you
63:08 - hey everyone in this video we will make
63:11 - our first video game the snake game if
63:14 - you haven't heard of it then it's a game
63:16 - where there's a snake you move it around
63:18 - the screen in order to eat the food you
63:21 - should not bite yourself
63:23 - while going in several directions and
63:25 - also you should not collide with the
63:27 - boundaries simple
63:29 - let us think through how we would carry
63:32 - out all this and try to write an
63:33 - algorithm
63:34 - so I have this list of steps that we
63:37 - would need to carry out
63:39 - to make the slaking okay cool
63:43 - our snake must have an initial position
63:45 - you get that right it should it should
63:48 - have a start position so let's define
63:49 - that it should also have a body it can
63:53 - be done using a list basically
63:55 - it would be a few rectangles at
63:57 - consecutive coordinates I hope you can
63:59 - imagine that the body of the snake would
64:01 - be nothing but a few rectangles arranged
64:04 - in line
64:06 - one after the other we would also Define
64:08 - the food position which would be
64:10 - randomly picked every time the snake
64:12 - eats the food cool
64:14 - so for random picking of the spot we
64:16 - would also read the random module
64:19 - then we would also keep track of the
64:21 - score and increase the size of the snake
64:23 - whenever it eats the food fine
64:25 - we would Define a game over function
64:27 - whenever the snake touches the
64:28 - boundaries or bites itself we would show
64:31 - game over on the screen
64:33 - also we would need to handle the
64:35 - movements of the snake by key inputs we
64:37 - would use the key module here cool
64:40 - so these are the seven parts we would
64:43 - need to build and then we would put them
64:45 - together to make the Snake Game work so
64:47 - first we will initialize the snake's
64:49 - start position initial position also let
64:52 - me Define the rate at which the snake
64:54 - moves the refresh rate fine
64:57 - then this is the clock object that we
65:00 - would use for the frame rate
65:03 - now according to the second point of the
65:05 - algorithm let the snake have a body we
65:08 - would need a body for the snake
65:10 - basically the snake's body would be
65:12 - consecutively arranged rectangles on the
65:14 - same line as I said before
65:15 - I have initially taken two rectangles
65:18 - you can take more
65:19 - a smaller initial size would help you
65:22 - notice the increase in size of the snake
65:24 - after it eats the food
65:26 - for the food we have this random
65:28 - coordinates taken
65:30 - then they are multiplied by 10 because
65:33 - we want
65:35 - no overlapping with the edges so that
65:37 - the snake doesn't go very close to the
65:39 - edges
65:40 - as we're gonna set a condition of the
65:42 - game over if the snake touches the edges
65:47 - I have taken this food Boolean so that I
65:50 - can decide when to increase the size of
65:52 - the snake
65:53 - you will understand this when we make
65:55 - use of it
65:58 - and then this core variable is set to
66:00 - zero now I have this find a function for
66:03 - displaying the score on screen just like
66:06 - with a split text on screen created a
66:08 - font rendered it used red to get the
66:12 - text on Surface then used to it
66:14 - this was just getting the text but the
66:17 - main part is in the game Loop
66:19 - that is incrementing the score every
66:21 - time the snake uh eats the food
66:24 - after this I have the game over function
66:27 - I have defined the game over function
66:29 - this 2 is just for getting the text in
66:31 - the mid screen once the game is over
66:35 - once the game over conditions are mapped
66:38 - they are also defined in the game Loop
66:40 - cool
66:41 - the Stein dot sleeve is used to pause
66:43 - the program for two seconds and quit
66:45 - automatically once the game is over
66:48 - according to the next step in the algo
66:50 - we need to handle movements of the snake
66:52 - for that I have taken two variables the
66:55 - IR which decides what direction to move
66:58 - in presently let it have an initial
67:01 - Direction
67:02 - and bir underscore next which keeps the
67:06 - track of the input given
67:09 - now we have the game Loop the events
67:11 - Loop we saw the little program of the
67:13 - key module in the second video for
67:15 - example
67:16 - that event slope is pretty similar to
67:19 - this one
67:21 - I have set the variable next underscore
67:24 - dir as the
67:26 - pressed Arrow key
67:28 - so when I press up
67:30 - the next dir becomes up and similarly
67:35 - for left it becomes left
67:38 - and now I have two sets of conditions
67:42 - now this set of condition updates the
67:44 - current direction if the current one
67:47 - isn't a complementary Arrow key please
67:50 - understand
67:51 - this means if the arrow key press is
67:54 - down while the snake is going up no
67:57 - changes will occur as right now while
67:59 - traveling along the y-axis the only next
68:01 - possible move can be in the X directions
68:04 - same with the rest of the directions
68:06 - like if you are traveling in the extra
68:09 - Direction
68:10 - okay in the x-axis you cannot
68:14 - reverse your direction cool
68:18 - and this condition now is for moving the
68:22 - snake just as we move the object in the
68:24 - last video depending upon the key
68:26 - pressed the coordinate of the snake's
68:28 - position is changed
68:30 - then we would try to increase the length
68:33 - of the snake every time it eats the food
68:35 - so I would insert every coordinate the
68:38 - snake travels through and pop all except
68:41 - the time when the food and snakes
68:43 - coordinates overlap okay I hope you got
68:45 - that
68:46 - this time I will change food to false so
68:50 - that I can pick a new spot for drawing
68:52 - once I have done that then again I set
68:55 - food to true also when snake and food
68:58 - coordinates overlap the snake eats the
69:02 - food I will increase the score
69:06 - great we are almost done here all I am
69:09 - left with is the drawing my is drawing
69:12 - my figures and setting up the game over
69:15 - conditions let me draw the snake it is
69:19 - quite obvious we would repeatedly draw
69:20 - the rectangles using a for Loop and this
69:24 - is to draw the fool
69:26 - now there are three game over conditions
69:28 - touching boundaries along x-axis that is
69:31 - going Beyond zero to 600 minus 10. I
69:35 - have written 600 minus 10 so that you
69:38 - can understand that it is the size of
69:40 - the screen minus the size of one block
69:42 - of the snake's body okay similarly for
69:45 - the y-axis it's the second condition and
69:47 - the third condition is when snake bites
69:50 - its own body okay it's same like
69:52 - overlapping with the food coordinates
69:53 - here
69:55 - it's just that
69:57 - we have taken a for Loop and the game
70:00 - over function will be called if the
70:02 - snake's first block overlaps with any of
70:04 - its rest of the body coordinates okay
70:06 - that's why I have started with the I
70:09 - started with a first position not the
70:11 - zeroth position of of the list okay cool
70:17 - now the show score is called all the
70:19 - time I want to see the score a score on
70:21 - the screen all the time
70:23 - and then we have updated it
70:26 - use the dot update and use the tick to
70:30 - set the frame rate cool
70:33 - let's run this program and check if
70:35 - everything works fine what all we need
70:37 - to check is if the snake moves freely
70:40 - then if the fruit is re-spotted once
70:43 - eaten at a random spot also we would
70:46 - check that the game conditions
70:48 - game over conditions are working fine
70:52 - we would also check that the snake's
70:55 - size increases every time it eats the
70:57 - food so let's run this and check out
71:00 - this four or five conditions
71:07 - so now if I run this I can see my snake
71:10 - moving in several directions eating the
71:12 - food food is getting re-spotted
71:14 - cool and yeah the score is also getting
71:18 - updated
71:19 - and let me see if it gets bumped into a
71:23 - wall the game should be over before that
71:25 - you can see that the snake is longer in
71:28 - size than it was before
71:32 - so let me pump it into a one wall
71:35 - yeah the game is over cool
71:38 - and the screen also went away after my
71:41 - game was over so this game can be more
71:45 - enhanced you can print why the game was
71:47 - over or you can put in some music when
71:49 - the game is over using the mixer module
71:52 - make a different function and call it in
71:54 - the game over function this was the very
71:57 - basic snake game made by pie game thank
72:00 - you
72:09 - hey everyone in the last video we made
72:12 - the Snake Game it comprised of various
72:14 - modules by pie game this time we would
72:17 - make the tic-tac-toe it would be a
72:19 - little bit more complex than the snake
72:21 - game but don't worry if you are clear
72:23 - with the basic modules of Fire game you
72:24 - won't have a problem dealing with this
72:27 - let me discuss what all functionalities
72:29 - we need to put in to make this tic tac
72:32 - toe
72:33 - so you need to draw a board right you
72:36 - know tic-tac-toe is played on a three by
72:38 - three grid so for that you need to draw
72:41 - that board you also need to get the
72:43 - images loaded
72:44 - what images I'm talking about I'm
72:46 - talking about X and O symbols we won't
72:48 - be sketching anything manually we would
72:51 - just be rendering the images of X and O
72:53 - symbols at the place we want to we would
72:55 - also need to print the results on the
72:57 - screen
72:57 - we would also need to check which row or
73:00 - column has similar symbols so that we
73:03 - can strike that out and declare a win
73:06 - okay we would also need to declare a
73:09 - function where we can get the
73:10 - coordinates
73:11 - of our Mouse click and put our picture
73:15 - over there paste our picture over there
73:17 - so to get all this I have defined five
73:19 - functions and we would put them together
73:22 - to make this tic-tac-toe cool so what
73:25 - the five functions are we would draw the
73:26 - board one
73:28 - we would get the results printed too we
73:31 - would check the winning cases we would
73:33 - check all the rows and columns if there
73:35 - is a win
73:36 - we would also need to get the
73:38 - coordinates of the mouse click we would
73:40 - use the mouse module that's a new thing
73:41 - for you
73:42 - and we would put the pictures at these
73:45 - coordinate that would be the measure
73:46 - engineering part cool let's get to the
73:48 - code
73:49 - so I'd be importing Pi game initializing
73:52 - it then I'd be declaring some basic
73:54 - variables okay so don't worry if you
73:57 - don't understand their purpose you would
74:01 - understand it once we start manipulating
74:03 - them in the code further cool so I have
74:06 - this XO it will hold the current value
74:09 - of the symbols whatever symbol we are
74:12 - working on whoever whose ever turn it is
74:14 - okay then we have a winner it would
74:18 - store the winner X or o and declare
74:21 - unprint the message then we have draw it
74:24 - is initialized to none right now but if
74:26 - it is a draw it would be
74:28 - true okay it's a Boolean basically then
74:31 - I have this board it's initialized as a
74:34 - 2d Matrix with no values none values and
74:38 - it's a based Matrix basically
74:41 - of 3 cross 3 of size 3 cross 3 then we
74:45 - have this clock object
74:47 - and then I have the screen then I have
74:51 - set the caption
74:52 - then I have rendered the images I have
74:55 - this in the tic-tac-toe files so
74:57 - accordingly I have
74:59 - mentioned the path okay
75:02 - then I have scaled the images because I
75:05 - want them in a block okay we have this
75:08 - nine these nine blocks and I want it in
75:11 - the same shape okay I want it in the
75:14 - same size basically of the block
75:17 - okay then we have our first function the
75:20 - draw grid we would be drawing the board
75:21 - with lines I'll fill the screen with
75:23 - some color then I have drawn the lines I
75:26 - would need two two vertical and two
75:28 - horizontal lines I hope you can get that
75:30 - because I need to draw
75:32 - three parts okay
75:35 - so I'd be drawing the vertical lines
75:36 - first so I have used the line function
75:39 - by draw module the screen is the surface
75:42 - I would need to make this make this
75:45 - lines on then I have given the color of
75:48 - the line then I have the start and the
75:50 - end positions okay so the start and end
75:53 - positions need to be visualized by you
75:55 - uh just like you would visualize the
75:57 - point on a coordinate axis okay so 400
76:01 - by 3 comma 0 would be your point on the
76:03 - x-axis right so 400 by 3 by 400 by 3
76:07 - it's because I am making three parts of
76:09 - the complete board and what is the
76:12 - length of my
76:13 - um screen that is 400 and by 3 gives you
76:17 - the one one third part of it okay
76:19 - similarly 400 by 3 comma 400 gives you
76:22 - the last Point okay
76:25 - on the x-axis but at the bottom cool and
76:28 - six is the size of the line similarly
76:31 - for the second line I've multiplied the
76:33 - same thing by two so that
76:34 - is just an interval ahead of the
76:38 - previous line okay
76:39 - hope that makes sense to you then to
76:42 - draw the horizontal lines I have just
76:44 - flip the coordinates because now I'd be
76:46 - taking coordinates on the y-axis just
76:49 - like I took coordinates on the x-axis to
76:51 - draw the vertical line I take points on
76:54 - the y-axis to draw the horizontal lines
76:56 - okay it should not be
76:58 - problematic at all if you can visualize
77:00 - a coordinate plane cool
77:03 - then I'd be
77:04 - defining the result function just for
77:07 - printing the result of the screen so I
77:10 - have made the draw and winner variables
77:13 - global
77:14 - so that I can work with the same
77:15 - variables throughout
77:17 - now if I have a winner xro a message
77:20 - would be printed like I would have a
77:22 - message that would be a string and that
77:24 - would would be the Winner's name and one
77:27 - okay similarly if draw is true my
77:30 - message will be game Draw now just like
77:32 - we would display a simple text on the
77:34 - screen I have done that I want my
77:37 - message to be rendered on the screen to
77:39 - be displayed on the screen it's the same
77:41 - code that we used in the display text
77:44 - nothing is different then I have this
77:47 - wind cases function to check if all the
77:49 - symbols along a row or column are same
77:51 - okay we would check it nine times right
77:54 - after every image is rendered okay now
77:57 - just as I said we will check along all
78:00 - the rows the columns and the diagonals
78:02 - so to take a longer row we would run a
78:05 - for Loop so that we can change the value
78:08 - of the row 0 1 and 2 and we would check
78:12 - if all the symbols along that row are
78:14 - same that's what the if condition does
78:16 - and the element we are checking should
78:18 - not be none okay if it's not so and all
78:22 - these symbols are same then we would
78:24 - Anna we would assign the winner to be
78:26 - that element okay and we would draw a
78:30 - line across that true however do that
78:35 - we will use the line function from the
78:37 - draw module
78:38 - and since we want to draw a horizontal
78:41 - line
78:42 - please note that we would need to take
78:45 - coordinates of the y-axis so we have the
78:48 - start point to be 0 comma rho plus 1
78:50 - into 400 by 3 minus 400 by 6. now rho
78:54 - plus 1 is because
78:56 - the indexing starts from 0 and we cannot
78:58 - take 0 to be something and I have
79:02 - subtracted it by 400 with 400 by 6
79:05 - because I want the line to be the half
79:09 - of it okay half of the block
79:11 - and so is the case with the end point
79:13 - okay
79:14 - and then I'd call to the result function
79:16 - because I wanna if there is a winner
79:18 - then I want to call the result function
79:20 - so that the result is printed and no for
79:23 - third game has been played okay
79:25 - similarly for the column
79:27 - I will have a loop to Traverse through
79:29 - all the columns and I'll check
79:31 - accordingly if along a column the
79:34 - symbols are same then I had assigned
79:36 - that value that element to the winner
79:39 - variable and then I draw the line along
79:42 - that column since I want a vertical line
79:44 - now I would be taking points on the x
79:47 - coordinate okay x axis side
79:50 - and this start and end point again
79:53 - should make sense to you
79:55 - just as we did above I want the line to
79:58 - be at the half of the block
80:01 - again there is a factor of 400 by 6
80:03 - subtracted from that value cool then
80:06 - again I'd be calling out to the result
80:08 - because I wanted to want the results to
80:10 - be printed if there is a winner and I'd
80:12 - break this Loop cool
80:14 - then to check along the diagonals I
80:16 - would have two diagonals in a matrix
80:18 - there are two diagonals the principal
80:20 - diagonal and the other diagonal the
80:22 - principal diagram runs from left to
80:24 - right whereas the other diagonal runs
80:26 - from right to left
80:28 - and uh
80:30 - it's the conditions are very similar you
80:32 - check
80:33 - along the principal diagonal if the
80:36 - symbols are same
80:37 - if they are assigned winner that value
80:40 - that symbol and draw a line along it
80:43 - and call on to the result function again
80:46 - to print the result similarly for the
80:48 - other diagonal that runs from right to
80:50 - left
80:51 - now if there is a draw then how would
80:54 - you check that for all rows
80:56 - if all is true that means all the blocks
81:00 - are filled now and the winner is still
81:02 - none then it's a drop okay the draw
81:04 - Boolean is now true and you'd call on to
81:07 - the result function what the result
81:09 - function would do is it would check the
81:11 - condition for draw and the message will
81:13 - become game Draw and the
81:15 - text displayed on the screen would be
81:18 - true cool now I have this get image
81:21 - function which takes an argument's row
81:23 - and column but you would not understand
81:25 - this until you understand this input to
81:27 - block function so let's get to the input
81:30 - block function
81:31 - what it does is it gives you the
81:33 - position of the coordinates you clicked
81:36 - so basically it has to find out which
81:39 - block is clicked on board there are
81:41 - several blocks and
81:43 - once you have clicked inside that block
81:45 - you would get the row and column as a
81:48 - result of this function cool then to get
81:51 - the coordinates of the mouse click we
81:53 - have this mouse function
81:55 - by taking you have this mouse module by
81:58 - pie game that has a function get
81:59 - position
82:00 - we get the X and Y coordinates of that
82:03 - Mouse click and if the x coordinate is
82:07 - less than 4 by 400 by 3 the first
82:10 - vertical line the first part then it is
82:12 - column one
82:13 - else if the value of the x coordinate is
82:17 - less than 400 by 3 into 2 that means
82:20 - it's less than the second partition but
82:22 - greater than the first partition the
82:24 - first vertical line then it would be
82:27 - column two please note that I have used
82:29 - the else of condition for doing the same
82:31 - thing and not if because
82:35 - I want to check the second condition
82:36 - only if the first one is not satisfied
82:39 - and then there's another elsif that is
82:42 - the x coordinate is less than 400 which
82:45 - would be the last column the third
82:47 - column cool similarly for assigning the
82:50 - row I have checked the Y coordinates
82:52 - accordingly
82:53 - now if the row and column are assigned
82:56 - some value and that word position is
82:59 - empty it's none I would call on to the
83:02 - get image function
83:04 - please see to the indexing part row and
83:06 - column are normal numberings
83:09 - when you're using them for indexing you
83:12 - need to decrease them by one cool now
83:14 - let's check out what the get image
83:16 - function does so I'll pass on the row
83:18 - and columns I got from here
83:20 - and use them to get my image rendered at
83:23 - that position but there is a problem
83:25 - to render my image I would use the BLT
83:27 - function but the blit function does not
83:30 - identify the row and column positions
83:32 - but it identifies the destination
83:35 - coordinates so we again need to convert
83:37 - this row and column to a position okay
83:40 - to a coordinate
83:43 - these coordinates would be same for all
83:46 - the images for all the positions clicked
83:48 - to have a uniformity I would need to
83:51 - again convert this Row one column to a
83:54 - single position
83:55 - the mouse coordinates would be very
83:58 - random and I don't want my images to be
84:00 - overlapping and that's why I have to do
84:03 - this I have to declare another function
84:06 - to get the coordinates from Row one
84:08 - column okay so if the row is one row
84:11 - number is one I want a margin of 30 so
84:14 - the quarter would be 30 export in it
84:17 - would be 30. and similar if the
84:19 - similarly if the column is one the
84:22 - position y would be 13. I want a margin
84:24 - of 30. if it is Row 2 then I'd be adding
84:28 - 30 the margin of 30 with 400 by 3
84:31 - because I want the
84:33 - image to be rendered right after the
84:35 - second line with a margin of 30 okay 30
84:38 - units cool
84:40 - and similarly there are conditions for
84:42 - the third row and the third column
84:44 - now I would assign the current symbol
84:47 - stored by XO to the board position that
84:50 - we got from the input to block function
84:52 - and if XO was X
84:55 - I would change XO to O because the turn
84:58 - should be changed now to O and I and
85:01 - before that I had render the image at
85:03 - the given position the X image and if I
85:07 - have XO as O then there is this vice
85:10 - versa condition I would be pasting O's
85:13 - picture and now XO would be changed to X
85:17 - now after calling the get image function
85:20 - in the input to block function I would
85:22 - call onto the wind cases function which
85:25 - which would check if the there is an
85:29 - even in any row or column or along any
85:32 - diagonal
85:33 - so you should get that after pasting or
85:36 - rendering each image we would check if
85:38 - there is any win case okay now we are
85:41 - done with the five basic functions the
85:43 - five parts of the tic-tac-toe game
85:46 - now we can move on to the main part of
85:48 - the program I'd be calling the draw grid
85:51 - function and then I'll have my game Loop
85:54 - cool in the game loop I have the events
85:56 - Loop where one event is to quit and the
86:00 - other event is to check if there has
86:03 - been any click on the mouse for that we
86:05 - have the mouse button down method
86:08 - if there has been a click on the mouse
86:10 - then I'd call onto the input to block
86:12 - function
86:13 - don't worry we will just get to the flow
86:15 - of the program if you don't understand
86:19 - how the program is interconnected
86:22 - and then I would be updating the entire
86:25 - display
86:26 - and I've set up the refresh rate using
86:29 - the clock clock object
86:31 - now let's quickly see how the program
86:34 - flows into each other I have just called
86:36 - on to the draw grid function in the main
86:38 - part so if I call onto the draw grid
86:41 - function what I'll see is I'd say a word
86:45 - getting rendered okay I'd see a board
86:48 - with lines
86:49 - and if I click onto the mouse I would
86:52 - call onto the input to block function
86:54 - which would give me the row and column
86:57 - and call onto the get image function
87:00 - which would help me paste my picture and
87:02 - then I would call onto the win cases
87:04 - which would check if there is any win
87:06 - along any row or column or diagonal and
87:09 - then add from the win cases function I'd
87:11 - call on to the result function which
87:13 - would print my result if it is a draw or
87:16 - a win if there is no such win if there
87:19 - if no win cases are satisfied my
87:22 - tic-tac-toe game would taken inputs
87:25 - until all the blocks are filled with
87:27 - some image so now if I run this I play
87:32 - it twice
87:33 - just so I can check both the cases for X
87:36 - then or O's when and to check a draw
87:47 - so this game is a draw
87:50 - and if I play it again
87:57 - I have X1 message printed
88:00 - so everything is working fine and if I
88:03 - quit the screen simply goes away cool
88:06 - everything worked as we wanted it to
88:08 - work
88:09 - and this was all about the tic-tac-toe
88:12 - game hope you understood whatever we did
88:14 - in this program in the program thank you
88:20 - hey everyone we have covered two video
88:22 - games in pie game The Snake Game and
88:25 - tic-tac-toe tic-tac-toe included a lot
88:27 - of functions and was a little complex so
88:30 - this time we are gonna do something
88:31 - simple and easy
88:34 - so see this video more like a practice
88:36 - session than a tutorial because it's
88:38 - just the new idea that would be we'd be
88:40 - implementing the modules and code are
88:43 - similar unknown okay
88:45 - making a program in pi game is all about
88:49 - working with various modules together
88:51 - and going about those three basic steps
88:53 - I hope you understand that by now in
88:56 - this video we would be making a color
88:58 - Breeze we would see a shade of color
89:01 - gradually changing to the other and that
89:04 - color too would be randomly bit
89:07 - it is going to be a simple program
89:09 - because after two video games I wanted
89:11 - to give a pause
89:13 - so that things don't get too much to
89:15 - handle okay
89:18 - okay so a color Breeze basically means
89:20 - rendering different colors on screen
89:22 - so we initialize Pi game get the screen
89:24 - declare the clock object we've got C1
89:28 - c21 C3 we which we would be
89:32 - randomly picking from the rain 0 to 255
89:36 - you can use the random range function or
89:39 - random int there is just a little
89:41 - difference random int includes both the
89:44 - end points whereas random range just
89:47 - excludes the end point it does not
89:49 - include the end point but right now it
89:52 - would be better if you use run in so
89:54 - that 255 number is also included because
89:58 - there are components of RGB that uses
90:02 - 255 there are colors in RGB that uses
90:05 - the 255 number
90:07 - so basically C1 C2 and C3 are the red
90:10 - green and blue components that would set
90:12 - up the screen color
90:14 - then is our while loop and then the
90:16 - events Loop in it
90:18 - now these conditions are to change the
90:20 - color let us get different colors and we
90:23 - would only change value of any one
90:25 - component that is C1 C2 or C3 because we
90:28 - want something like a breeze and not
90:30 - colors just popping out of nowhere the
90:32 - screen's color should change like a
90:34 - shade change very smooth okay
90:37 - so for that if the value of C1 is within
90:40 - 255 I hope you know about RGB colors a
90:43 - component can't can't have a value up up
90:45 - to 55. so if the value is within 0 to
90:48 - 255 we add 1 to the existing value else
90:52 - if it's greater than 255 you decrease
90:54 - its value by 255 to make it within the
90:57 - given range and if it goes negative or 0
91:01 - you can increase value by 3.
91:04 - and then you given these three
91:06 - components as fill functions arguments
91:13 - now if I run this the screen gets
91:16 - various colors great and the color
91:18 - transition is smooth as I wanted but
91:20 - after some time this starts what if I
91:23 - want to see this again or maybe restart
91:24 - the function but I don't want to run
91:27 - this again I want to use the mouse and
91:29 - reset this whole thing this would not
91:31 - set up the pi game window over and over
91:33 - and would let you start from a new color
91:35 - let you see a new color Breeze just by a
91:38 - mouse click we use the mouse module last
91:41 - time so let me Define a function reset
91:44 - what reset would do is it would simply
91:47 - reset the C1 C2 C3 variables so let me
91:49 - declare C1 C2 and C3 to be Global
91:52 - variables and reset them just like this
91:54 - okay
91:55 - and if I want this function to be called
91:58 - on a mouse click
92:00 - I would check for an event called Mouse
92:02 - button down and call this functions so
92:04 - whenever I click on Mouse the program
92:06 - restarts let me print Mouse clicked here
92:09 - whenever I click on Mouse you would see
92:11 - this message printed
92:13 - now if I run this I see the color Breeze
92:16 - and if I now click on the mouse I get
92:19 - this message printed Mouse click and the
92:21 - color breeze it's a new color altogether
92:25 - I can see a new color on the screen
92:27 - whenever I click on the mouse so the
92:30 - reset function is working quite fine you
92:32 - can try to work with some more
92:34 - functionalities just like we introduced
92:36 - reset you can add in some more
92:38 - functionalities like you can try doing
92:40 - this with a text if the text color can
92:44 - be changed like a grease or you can add
92:46 - in some music and Rewind the music as in
92:51 - we as soon as we reset the
92:53 - color breeze so please try to work with
92:57 - some more functionalities think of some
92:59 - more functionalities so that you are
93:01 - comfortable with working with all these
93:03 - party modules
93:05 - I hope you understood what we did here
93:07 - thank you
93:10 - hey everyone we have covered a lot in pi
93:13 - game by now but there are some modules
93:15 - that are useful and are yet not
93:17 - discussed
93:19 - so in this video first we would see some
93:21 - examples of draw module we haven't used
93:23 - the polygon and Arc function yet and
93:26 - then we will talk about the cursor
93:28 - module we will also discuss a program
93:30 - that will be a base requirement in some
93:33 - of the video games
93:34 - so let's get started with the draw
93:36 - module
93:37 - I have this regular code a very basic
93:39 - one and if I want to draw a polygon the
93:42 - coordinates of the polygons vertices are
93:44 - required these coordinates make a
93:47 - regular pentagon
93:48 - here the screen is the surface you want
93:50 - to draw on and green is the color of the
93:52 - shape
93:53 - you can give as many coordinates as you
93:56 - want and it is not necessary that the
93:58 - shape should be regular
94:01 - then to draw an ellipse you will give in
94:04 - the rectangles Dimension and coordinates
94:06 - around which you want to draw the
94:07 - ellipse
94:08 - in case you specify a Square's dimension
94:11 - in place of a rectangle you will end up
94:13 - getting a circle this is basic maths you
94:16 - can also draw an arc using the draw
94:17 - module for that you have to specify the
94:19 - rectangle's dimension basically an arc
94:22 - is from an ellipse or a circle so to
94:25 - draw an ellipse we specify the base
94:27 - rectangles dimensions
94:29 - and hence to get its Arc we will do the
94:31 - same cool
94:33 - along with this we also need to specify
94:36 - the starting and ending angles these
94:37 - angles are in radians it is 90 degree to
94:40 - 180 degree please be careful while
94:43 - working with the units while rotating an
94:46 - image the arguments of angles were in
94:50 - degrees okay please don't get confused
94:54 - now we have used the line function in
94:56 - tic-tac-toe but this is the lines
94:58 - function it allows you to draw
95:00 - continuous lines deviated or undeviated
95:02 - processing through these mentioned
95:04 - points
95:05 - five here is the thickness of the line
95:07 - This false here is used for not getting
95:11 - a closed figure if I make this true I
95:14 - would have a closed figure if possible
95:16 - now let's
95:18 - run this and see if we get the desired
95:21 - shapes
95:24 - so yeah I have my polygon
95:28 - I have the Pentagon
95:30 - I have this zigzag lines made by the
95:33 - lines function I also have my ellipse
95:36 - and I also have my arc you just need to
95:38 - know that the Arc was taken in an
95:40 - anti-clockwise direction from 90 to 180
95:43 - degrees
95:44 - and yeah that's pretty much it
95:46 - now let's move on to the cursor module
95:50 - so we have three types of cursors the
95:53 - system cursor bitmap cursors and color
95:55 - cursors the system cursors are constants
95:58 - available in the module we can have
96:00 - cursor hand cursor no Arrow Crosshair
96:03 - and a lot more there's a complete list
96:05 - of it and this is how you create a
96:08 - system cursor
96:09 - to create a bitmap cursor you specify
96:13 - pygame.cursor.arrow or dot broken
96:15 - underscore X or Diamond this would be a
96:19 - black and white cursor that uses the
96:20 - bitmask arrays
96:22 - and to create a colored cursor you need
96:25 - a surface so we have a surface of size
96:28 - 10 comma 10 we fill the color of the
96:30 - surface with sky blue or any color you
96:32 - like it's the color of the cursor and
96:35 - then you use the cursor class you may
96:38 - note that this cursor class of cursor's
96:40 - module is a good example of object
96:42 - oriented programming
96:45 - this 5 comma 5 is the hot spot of the
96:48 - cursor and needs to be within the
96:49 - surface cool
96:52 - I have initialized the system cursor and
96:55 - this is just a way to see both the
96:56 - cursors if I click on the mouse I would
96:59 - see the bitmap cursor and if I input
97:01 - alphabet C from the keyboard I get to
97:04 - see the colored cursor so this was the
97:06 - courses module it was pretty simple
97:08 - let's run this and see the three cursors
97:13 - so initially I can see my hand cursor if
97:16 - I click on the mouse I see this broken X
97:19 - which is a bitmap cursor and if I input
97:22 - C from the keyboard I see my colored
97:25 - cursor cool
97:27 - so these were the type of cursors and
97:30 - now let's see the program I was talking
97:33 - about in the beginning of the video
97:40 - so this program lets you move a picture
97:43 - along your cursor and it is very useful
97:46 - when you want to move a figure in a
97:48 - video game using Mouse
97:49 - so for that you would need to load the
97:52 - image we have done this many times now
97:54 - it should be easy to understand and then
97:56 - I have my rectangular object for my
97:58 - image I have this moving Boolean to save
98:01 - the cursor state
98:03 - now in the events Loop if my event type
98:05 - is mouse button up like I have released
98:08 - the mouse
98:10 - moving becomes false if it is mouse
98:13 - button down then moving is true and I
98:15 - would check if the events position my
98:17 - cursorance is inside the image surface
98:19 - that is the rect object
98:22 - and if the mouse touch is in motion and
98:26 - moving is true I would move my
98:28 - rectangular surface along with my cursor
98:30 - or mouse that is my event
98:32 - so if I run this I should see an image
98:34 - that would go that would move along my
98:37 - cursor let's see if that happens
98:41 - so yeah I see my image moving along with
98:44 - my cursor as I move the cursor the image
98:47 - moves along with it
98:49 - and this is very similar to the moving
98:51 - object program that we did but that time
98:54 - we took inputs from the keyboard This
98:56 - Time It's the mouse we are using
98:59 - and that time we used a figure we made
99:01 - our own figure
99:03 - using the draw module
99:05 - this time we are moving an image and we
99:08 - have loaded an image
99:10 - so this was pretty much about this video
99:13 - thank you
99:16 - hey everyone we have seen several
99:18 - applications of the pi game module by
99:20 - now
99:21 - in this video we'll try to make designs
99:24 - on screen using the keys
99:26 - the arrow keys from now on we would make
99:29 - programs that are simple and quick but
99:32 - will help us get a better idea of the pi
99:34 - game module
99:35 - the more you practice the more you see
99:38 - the applications of the pi K module the
99:40 - more you'll get comfortable with it
99:43 - so let's get started
99:46 - I'll import the piking module I'll write
99:49 - import by game and then I'll initialize
99:52 - it
99:54 - then I'll set up the screen
99:56 - I'll write Pi
99:58 - game.display.set mode and I'll set up
100:01 - this screen size to be 500 comma 500 it
100:04 - fits perfectly in my window and then
100:06 - I'll also set up a caption the caption
100:08 - would be designed since I'm drawing
100:12 - a design
100:14 - using the arrow keys I'll do set caption
100:17 - and write designs
100:20 - then I'll write the while loop don't
100:24 - worry I'll get to the main code later
100:28 - I really like to set up the basic
100:30 - structure first then get to the main
100:33 - code so while true I'll do the for Loop
100:36 - then for events
100:39 - in pie game dot event
100:42 - dot get I access the queue like this the
100:46 - events queue then I'll set up the
100:48 - condition if event type events DOT type
100:52 - equals Spy game quit
100:55 - and I'll call the pi game quit function
100:58 - and also fit
101:02 - so this was the basic structure the main
101:04 - three basic steps that we write in any
101:07 - PI game program now I'll get to the
101:09 - basic code the main code
101:12 - so if I'm saying I want to use the arrow
101:15 - keys to draw a design while I move an
101:17 - object so it should be it should make
101:19 - sense to you that I'll be using the code
101:21 - I'll I'll be writing something similar
101:23 - to the moving object code okay so if I'm
101:26 - saying I want to move an object that
101:28 - would leave a trail and that would draw
101:31 - the designs
101:32 - so I need to describe my figures so I'll
101:35 - set up the initial position
101:37 - so let me take X by two variables and
101:40 - set up the initial position to be 100
101:42 - comma 100
101:43 - you can take any position you can take
101:45 - 50 comma 50 or 10 comma 10 then I'll set
101:48 - up the
101:50 - width and height it's I'll describe the
101:53 - size
101:55 - the width and height can be a height can
101:58 - be 10 comma 10. then I'll set up the
102:01 - speed by which the figure should
102:03 - displace each time we press an arrow key
102:07 - so let it be 10.
102:09 - I'll also give in a delay I'll write Pi
102:12 - game Dot
102:14 - time
102:15 - dot delay of 10 milliseconds in the
102:18 - while true Loop so that we can observe
102:21 - our object moving properly and it does
102:23 - not rush
102:25 - I hope you can recall this code as we
102:27 - are writing it
102:29 - and you're on the same page as I am then
102:33 - we'll describe a variable key which
102:36 - would be a list it would be a sequence
102:38 - of booleans that would keep the state of
102:40 - all the keys on the keyboard so how do I
102:43 - do that I tried pygame dot key dot get
102:47 - pressed and this would be a sequence of
102:49 - all the states
102:51 - of the keys on the keyboard
102:55 - and this is how I'd know which key is
102:57 - pressed and accordingly I'll use it for
103:00 - the further setup so if now I'll set up
103:04 - my conditions if I press the
103:07 - up Arrow key I'll write key Pi game
103:11 - dot k underscore up
103:14 - so that would give me the state of the
103:17 - up button and I'll also write since I am
103:21 - going up I'll write y should always be
103:26 - greater than zero okay and I'll
103:31 - increment I'll decrement y
103:34 - by the speed value since I am going up
103:36 - okay similarly for
103:40 - down button I'll write Pi game
103:44 - dot k underscore down
103:49 - and Y should be less than the screen
103:52 - size that is 500 minus the height
103:56 - I'll increment y now since I'm going
103:59 - down I'll increment y by speed units now
104:02 - I'll do the same thing for the right and
104:05 - left Key by game Dot
104:08 - okay underscore left
104:14 - and X now I'll talk about X because I'm
104:18 - pressing the left key
104:21 - X should be
104:23 - greater than 0 always and I'll
104:27 - decrement X by speed units
104:31 - I'll do the same thing for the right key
104:34 - I'll write by game
104:37 - dot k underscore right
104:43 - and X should be less than 500 my screen
104:47 - size minus the width
104:50 - then I'll increment X by square units
104:53 - since I'm going right okay I hope you
104:56 - remember how we accessed that key list
104:58 - we use the constants
105:00 - the key constants okay
105:02 - and yeah I hope you remember this I hope
105:06 - you can recall all this then I'll draw
105:08 - my figure I'll do buy game dot draw
105:13 - dot rect I'll take a simple rectangle
105:17 - screen is the surface I'm going to draw
105:18 - on then the color would be white it
105:21 - looks good on black background and then
105:24 - the rect values would be the initial
105:27 - coordinates and it says width
105:31 - and height
105:36 - then I'll update this complete thing so
105:48 - fine we are done with the code now you
105:51 - might notice I haven't used the screen
105:53 - fill thing why haven't I used it because
105:57 - I don't want any single color on my
106:00 - screen always as my object moves it
106:03 - should leave a trail now okay if I it is
106:07 - the only difference between the moving
106:09 - object code and the design code okay
106:11 - so I hope you get this I don't want any
106:14 - single color on my screen that's why I'm
106:16 - not using screen fill color it's green
106:18 - fill function cool
106:20 - let's run this and see if it works as
106:24 - you want it to so yeah if I now run this
106:27 - I can see
106:29 - the object and if I press the right
106:32 - button it goes right I press down it
106:35 - goes down but press left it goes left
106:38 - and it's working very fine
106:41 - it gives us various patterns as I'm
106:43 - pressing the arrow keys it goes it moves
106:46 - accordingly
106:47 - and this is very useful when we are
106:50 - making maze kind of video game it helps
106:53 - you track your object I hope you got
106:56 - whatever we did in the program you were
106:59 - I hope you were able to recall the
107:01 - things
107:02 - thank you
107:04 - hey everyone so today we're gonna do
107:07 - something new
107:08 - we're gonna display the text that the
107:10 - user inputs so basically whatever we
107:12 - type in we're gonna see that on the
107:14 - pycam window we won't use any new module
107:17 - it's just the utilization of the
107:18 - available modules whatever we have
107:20 - learned till now as per the programs
107:23 - requirements so let's get started
107:26 - so I'll import file game first
107:29 - I'll write import buy game then Pi game
107:32 - dot init to initialize it
107:34 - then I'll have my screen
107:37 - I'll write
107:39 - packing.display.set mode
107:41 - and that would be 500 comma 500 then
107:44 - I'll also set up a caption my caption
107:46 - would be user input so I'll write by
107:49 - game dot display.set caption user input
107:53 - okay
107:53 - then I'll do the file true Loop the game
107:56 - loop I told you last time that I'll like
108:00 - to
108:01 - make the basic structure first then do
108:05 - the rest of the code then write the rest
108:07 - of the code
108:08 - then I'll have my events Loop I'll write
108:11 - for events in pie game dot event dot get
108:15 - if events type is equal to Pi game dot
108:19 - quit
108:19 - I'll check the condition then I'll quit
108:21 - I'll call the quit function of biking
108:24 - yeah then I'll update this entire thing
108:28 - I'll write pi game.display.date
108:32 - so yeah that's the basic code that's the
108:35 - basic three steps of any PI game program
108:39 - now since I'm saying I want a user
108:42 - inputs I should of course have an empty
108:43 - string to which I'll concatenate
108:45 - whatever the user inputs so let's let me
108:48 - take this user underscore IP as the
108:51 - variable as the empty string
108:53 - then I'll have my font because of course
108:57 - we need to take a font we are working
108:59 - with text and Pi game
109:01 - so please remember how we display text
109:04 - on screen it would be similar to that so
109:06 - I'll write font equals spycame dot font
109:09 - dot sys font and you can take any font
109:12 - you like you can take Georgia a real
109:15 - calibery
109:17 - I have taken friend script right now and
109:20 - the font size would be 40.
109:22 - cool then since I want
109:26 - a rectangular box in which I'll input
109:29 - the text I will initialize this text box
109:33 - since I want to manipulate this later in
109:37 - the code I'll do the spiking dot I'll
109:40 - use this rect module I'll write pi
109:42 - game.rec and
109:45 - I'll given the arguments the initial
109:47 - position that would be 75 of 75
109:50 - and the size of the Box let it be 100
109:53 - comma 40 so the width is 100 and height
109:56 - is 40 fine
109:58 - okay let's not keep this 40 let's make
110:00 - it 50 because I want a margin of 10
110:04 - of 5 each at above and below the text
110:09 - so that
110:11 - things don't overlap and don't seem to
110:13 - be clumsy cool
110:15 - then I'll have this active Boolean that
110:19 - will tell me if I can start writing if I
110:21 - can start typing in the text box and
110:23 - what will indicate me this is this color
110:26 - variable so initially this would be
110:29 - purple
110:30 - but when active is true I'll switch this
110:33 - color to Red so that it I can know that
110:36 - I can now start typing
110:38 - wherever I take my cursor to inside the
110:41 - text box I'll see I'll make this active
110:44 - to be true so how I do this I'll do this
110:46 - in the while true Loop
110:48 - and in the for Loop I'll check if my
110:51 - events type is mouse button down
110:53 - then if I'll I'll check if I have
110:56 - clicked my mouse inside that text box
110:59 - okay so I'll write if text box dot
111:02 - Collide point and event start position
111:05 - is is true so I'll make active equals
111:10 - true cool
111:13 - otherwise I'll make active equals false
111:16 - maybe you have clicked outside the
111:18 - screen or outside the box so then active
111:22 - should remain false otherwise it should
111:24 - be made true if my cursor is within the
111:28 - text box
111:29 - fine and now if I've started typing so
111:33 - I'll write if
111:34 - events.type equals spykem.edown
111:37 - and if active is true maybe it can be
111:39 - the case that you have clicked inside
111:42 - the box and then clicked outside and
111:44 - then started typing so that would not
111:46 - work then you should not get any text
111:49 - displayed
111:51 - so I'll check if active is true
111:55 - and then I'll have these two other
111:57 - conditions if I press backspace so I'll
112:00 - write if events.key equals Pi cam dot
112:03 - claib underscore backspace I'll slice
112:06 - this string okay I hope you know about
112:07 - list uh list and string slicing in
112:11 - Python so what I'll do is I'll
112:15 - make user the string this user
112:18 - underscore IP string
112:20 - as a sliced string
112:23 - I'll slice the last character out of the
112:25 - string and how do we do that we mention
112:28 - the stop index to be minus one
112:31 - so the last character is removed now
112:34 - else if we do not press backspace we
112:39 - write a week if any keyboard input we
112:42 - concatenate that Unicode Okay so
112:46 - I don't need to make several cases for
112:48 - this that if I press this key I should
112:51 - append this or concatenate this to the
112:53 - string I would just write event start
112:56 - Unicode so it is very convenient
112:59 - then I'll spill my screen with the color
113:02 - you can take any color I'll write screen
113:04 - dot fill I'll take pink
113:08 - and now it's time I
113:10 - set up the color and get my indications
113:13 - that I can start writing or not so I'll
113:15 - say if active is true I'll
113:19 - take the color I'll assign the color
113:21 - variable the color red
113:23 - and if it is not if activist false I'll
113:29 - write else color is equals to Pi
113:31 - buy game dot Color Purple
113:36 - then I'll draw my rectangle so I need to
113:39 - see a box I need to visualize the box so
113:41 - I'll write pygame.traw.rect
113:44 - and I want this screen to be the surface
113:48 - on which I draw and then I'll have this
113:51 - color variable the color of the box then
113:55 - the
113:57 - parameters of this rectangular box are
113:59 - given by text box cool and you of course
114:02 - need to mention the split otherwise
114:04 - you'll see the entire box to be of the
114:07 - purple or red color according to the
114:08 - situation I don't want that I just want
114:11 - the border to be of some color
114:13 - fine then I'll have this surface
114:17 - on which I render my text so you can see
114:20 - I have not rendered it here above but
114:23 - I'll render it in the while loop because
114:25 - every time the user gives an input I
114:28 - want that text on
114:30 - the screen so I've rendered it here and
114:33 - not above outside the while true Loop
114:36 - so I'll write surface surf equals to
114:39 - font dot render and what is my message
114:42 - what do I want to output on the screen
114:45 - it's the user underscore IP variable
114:47 - that's string I want anti-aliasing to be
114:50 - true and the color of my text I'll take
114:52 - it to be orange you can take any color
114:55 - fine
114:56 - now let me get this surface surf
115:00 - variable on to the text box so I'll do
115:03 - screen dot lit and what I want to get on
115:07 - which surface I want to get surf this
115:10 - text on my text box and I'll have a
115:13 - margin of 5 units so that things don't
115:17 - overlap
115:18 - so I'll write text box dot X so I've
115:22 - accessed the
115:24 - initial X position
115:28 - x coordinate and added 5 to it and then
115:31 - I'll write textbox.y so I'll increase
115:35 - the y coordinate by 5.
115:39 - to have a margin of 5 units and then
115:42 - yeah then I'll also do this thing let me
115:45 - write the code first then you might
115:47 - understand I'll write textbox.w so I've
115:50 - accessed the width and I'll take the
115:53 - maximum of 100 my default width and the
115:57 - search variables bit so surf is my
116:00 - Surface the text surface and I'll use
116:03 - the get with method to get my current
116:07 - width of the text and add 10 to it again
116:10 - to have a margin and so that things
116:12 - don't overlap so what I have done is
116:15 - Maybe
116:17 - whatever the default size of my text box
116:19 - is you outgrow that maybe whatever the
116:22 - text you have input that's longer than
116:25 - your default box size
116:28 - so if my text is smaller than the width
116:31 - default width fine no problem
116:34 - and if it is greater than the default
116:37 - bit it'll take the width of the text
116:40 - cool and then I'll update this I've
116:44 - already written this and
116:46 - then I'll set up the frame rate since
116:49 - I've taken the
116:51 - clock object already I'll write
116:52 - clock.tick and 50. fine
116:57 - so if I run this now I see a purple
117:00 - outline box and if I click I take my
117:03 - cursor Inside the Box
117:05 - I see the border to change its color and
117:07 - become red and I can start typing now I
117:10 - can type in anything
117:13 - and
117:15 - you can see after a certain length when
117:17 - the width of my text increases the width
117:22 - of the text box also increases so that's
117:24 - what it does this Max function on the
117:27 - 38th line it lets you decide when to
117:31 - increase the box size
117:33 - a rectangular box size so everything is
117:37 - working as we want it to we can type in
117:39 - easily
117:41 - and yeah that's pretty much it about
117:44 - this program I hope you understood
117:46 - whatever the code was whatever we wrote
117:50 - hey everyone today we're gonna create a
117:53 - button in pi game let's first think what
117:55 - a button does so that you have the basic
117:57 - idea what we'll be doing in the program
118:00 - how would it be coding
118:02 - so whenever you click a button click on
118:05 - a button
118:06 - a certain task is performed a function
118:08 - is called
118:09 - so here this function is going to be
118:11 - quit function by pi game to keep it
118:13 - simple and easy whenever I click on that
118:16 - rectangular button on the screen the
118:19 - program should stop and the pi game
118:21 - window should go away
118:22 - also I'd like to add in a functionality
118:25 - whenever I hover over that rectangular
118:27 - box over the button there should be a
118:30 - shade change there should be a slight
118:31 - color change so that I can know the user
118:35 - can know
118:36 - that right now the cursor is over the
118:38 - button cool so let's start coding as
118:41 - usual I would
118:43 - Write the basic steps first and then get
118:46 - to the main code
118:47 - so let's import Pi game I'll write
118:50 - import buy game
118:53 - I'll initialize it right by game dot
118:56 - init
118:57 - then I'll set up the screen I'll write I
119:00 - came dot display.setmode 500 comma 500.
119:04 - is this queen size then I'll also set up
119:07 - a caption so my caption would be Pi game
119:10 - button
119:12 - and then I'll have my game Loop I'll
119:15 - write while true
119:18 - province in pie game.even dot get
119:21 - if events.type equals spygame dot quit
119:25 - I'll call the quit function
119:27 - and then I'll update this entire thing
119:30 - I'll write Pi game dot display dot
119:33 - update
119:34 - so this was the basic code now let's get
119:37 - to the main code since I want a quit
119:40 - button I should have
119:42 - quit written over that rectangular box
119:45 - that would be my button so for that I'll
119:48 - use the font module of course
119:50 - I need to display the text width so for
119:53 - that I'll write font equals
119:55 - spygame.font.sys font
119:57 - and let me take the phone charger
120:01 - and the font size to be 40. let's keep
120:03 - it bold
120:05 - and then I'll render this over the
120:08 - surface so I have the surf variable I'll
120:10 - write font dot render and my message and
120:13 - my text would be quit and I want
120:16 - anti-alias to be true
120:19 - and then the color of this text let it
120:22 - be white fine
120:25 - then I'll have this button that would
120:27 - act as the rectangular box that that
120:30 - would be my button so I'll initialize
120:34 - its initial position and its size so
120:37 - I'll write Pi game dot direct that it's
120:40 - initial Position will be 200 comma 200.
120:42 - kind of in the middle of the screen
120:45 - and its size be 110
120:49 - comma 16 so its width is 110 and its
120:52 - height is 65.
120:54 - then I'll fill my screen with some color
120:58 - you can take any color I have taken pink
121:01 - then
121:03 - inside this for Loop I'll put in this
121:06 - mouse button function functionality I'll
121:09 - I'll check if my events type is mouse
121:11 - button down if I'm using my mouse
121:14 - and check that my cursor is inside this
121:18 - button this rectangular box okay and how
121:22 - would I do that I'll write if button dot
121:24 - Collide point
121:26 - in Brackets the argument would be event
121:28 - start position
121:30 - and then I'll call the quit function
121:31 - I'll write Pi game dot quit fine
121:35 - so this is how I checked if my
121:39 - cursor is within this rectangular box is
121:41 - over the button and if it is so if it
121:45 - has been clicked then I'll call the pi
121:47 - game quit function fine now since I
121:50 - wanted to add that
121:52 - color change functionality that hovering
121:55 - and shading functionality I'll get my
121:58 - mouse position I'll get my mouse
122:00 - coordinates the cursor's coordinates so
122:02 - I'll write a comma b equals spygame dot
122:06 - mouse dot get position so a would be the
122:09 - x coordinate and B would be the y
122:10 - coordinate to avoid confusion I have
122:13 - taken a and b because we'd be already
122:15 - using the X and Y coordinates of my
122:18 - button that rectangular box
122:20 - so let's not have any confusion so my
122:24 - mouse coordinates the x coordinate of my
122:26 - mouse is a and the y coordinate of my
122:28 - mouse is B fine now I'll check if this
122:34 - mouse coordinates if these Mouse
122:36 - coordinates are within my box
122:38 - so for that I'll write if button dot X
122:41 - the x coordinate of my rectangular box
122:44 - is less than equal to a the x coordinate
122:47 - of my cursor is less than equal to
122:51 - button dot X
122:53 - which is the exponent of my rectangular
122:56 - box plus 110 that is the size of my
122:58 - rectangular box that button fine and
123:02 - also I want the button dot y the y
123:06 - coordinate of my rectangular box
123:09 - to be less than or equal to B the y
123:12 - coordinate of my mouse
123:14 - of my cursor
123:16 - to be less than or equal to button dot y
123:19 - plus 60 so the y coordinate of
123:23 - my rectangular box plus 60 because
123:25 - that's the height okay I hope you can
123:29 - visualize this you understand this
123:32 - and then if it is so
123:34 - I'll draw a rectangle I'll do I'll write
123:38 - packing.shaw.rect
123:40 - and screen is the surface I'm gonna draw
123:42 - on I'll given this color this is a
123:45 - lighter shade of gray
123:47 - and the rect value is given by button
123:49 - fine and else if it is not so if the
123:53 - cursor is outside this button then I'll
123:56 - given this color a darker shade of gray
123:59 - that's the default color okay
124:02 - and then I'll get my text on the surface
124:06 - button
124:07 - by using blitz so I'll write screen dot
124:09 - BLT
124:11 - surf is the surface of the text and this
124:15 - is for having margins for I've done plus
124:18 - five with the
124:20 - buttons initial coordinates so that I
124:23 - have a margin and things don't overlap
124:25 - the text doesn't overlap with the
124:27 - borders
124:28 - okay then I'll update
124:32 - so I've already written that let's run
124:34 - this and see if my button works
124:44 - so now if I run this I can see my quit
124:47 - button and if I hover over this button I
124:51 - see a shade change it's a lighter shade
124:53 - of gray whenever I hover over this my
124:56 - cursor is over this button and if my
124:59 - cursor is outside
125:01 - somewhere not on this button then it's a
125:04 - darker shade of gray cool so if I click
125:07 - on this button
125:09 - the program should stop let's see if
125:11 - that happens
125:13 - yeah so the window went away and uh the
125:17 - program stopped so I called the quit
125:20 - function using this button you can call
125:22 - any other function you can call in the
125:25 - function to play a song you can call in
125:28 - the function to display a text
125:30 - so
125:31 - this was all of it and I hope you
125:35 - understood how to create a button by a
125:37 - game
125:38 - thank you
125:42 - hey everyone by now we have seen several
125:45 - applications of paying we have practiced
125:48 - a lot we made designs using the arrow
125:50 - keys displayed user inputs on screen we
125:53 - also made buttons in pi game in the last
125:55 - video
125:56 - today we will program an animated Circle
125:59 - so the circle would move around on the
126:01 - piking window
126:03 - let's write the code for it
126:05 - I'll import Pi game
126:09 - initialize it then I'll write Pi game
126:12 - dot init
126:13 - then I'll set up the screen
126:16 - right screen equals buy game dot display
126:19 - dot set mode let the screen size be 500
126:22 - comma 500 then I'll also given a caption
126:25 - I'll write Pi game dot display dot set
126:28 - caption
126:30 - let the caption be animated Circle
126:34 - and then I'll go to my game Loop I'll
126:37 - write while true you should be very
126:39 - comfortable doing all this because by
126:41 - now we have written this a lot of times
126:44 - and then I'll have my for Loop I'll
126:47 - write four events
126:48 - in pi game dot event dot get
126:53 - I'll check if events type equals Spy
126:57 - game dot quit
126:59 - then I'll quit
127:01 - we'll call the quad function by biking
127:03 - and I'll put
127:05 - it I'll update the screen right by game
127:08 - dot display dot update
127:12 - that's the basic framework let's get to
127:15 - the main code since I want my circle to
127:17 - move around I'll need its initial
127:19 - position let that initial position be 5
127:21 - x comma Y and equal to 200 comma 200 you
127:27 - can take any starting position I have
127:28 - taken 200 comma 200
127:30 - then I also need to set up the speed
127:34 - along both the directions so along X
127:37 - Direction let it be XP and let x v be
127:41 - equal to 5. and along y direction Let It
127:45 - Be y v and equal to minus 5. so what is
127:48 - this Clause of plus and minus if you're
127:51 - giving the speed along the X direction
127:53 - as positive it should your object should
127:56 - go towards right otherwise it should go
127:59 - to left if the speed is negative
128:01 - similarly for y direction if you are
128:04 - giving the speed to be negative it
128:05 - should go upwards and if it is positive
128:08 - the speed is positive the object will go
128:11 - downwards okay
128:12 - so the speed would tell you how much the
128:15 - displacement would be at a time then
128:18 - I'll have my clock object I'll write
128:19 - clock equals Spy game dot time dot clock
128:23 - to set up the framework frame rate later
128:26 - now I'll have a screen color I'll write
128:29 - screen
128:31 - dot fill
128:33 - so let me fill my screen with color sky
128:35 - blue
128:38 - then I'll also need to draw
128:41 - the circle I need I need to move around
128:44 - so
128:45 - I'll write pygame.show dot Circle
128:49 - and screen is the surface I'm gonna draw
128:51 - on then the color let it be orange
128:57 - then the center coordinates are given by
128:59 - X and Y X comma y
129:01 - then this radius let it be 10 units okay
129:05 - now after this for Loop outside this
129:08 - I'll increment the X and Y coordinates
129:12 - so that I can see my circle moving on
129:16 - the screen so I'll write X plus equals
129:21 - x v I've incremented x coordinate with X
129:25 - Cube V units by XP units and similarly
129:28 - for y I'll write y plus equals yv
129:33 - and to keep these x coordinates X and Y
129:36 - coordinates within the boundaries within
129:39 - the screen
129:40 - I'll write if x is greater than 490 or X
129:44 - is less than 10
129:48 - I'll change the direction okay how do I
129:51 - do that I'll change the sign okay I'll
129:54 - change the sign of the speed you can
129:56 - even relocate the position but that
129:59 - would look like the circle is appearing
130:02 - out of nowhere at a sudden position that
130:06 - won't look nice so I want the motion to
130:09 - be regular and fine
130:11 - so that's why I'll be changing the
130:13 - direction rather than relocating that
130:15 - coordinates okay
130:17 - similarly for y I'll write if Y is
130:20 - greater than 490 I'm keeping a margin of
130:23 - 10 units or Y is less than 10
130:28 - I'll change the y d
130:30 - cool now after that I'll update
130:34 - and
130:35 - have my clock object I'll write
130:38 - clock.tick
130:40 - let the frame rate be 50.
130:42 - let's run it and see if we get what we
130:45 - really want to see
130:47 - if we can see our Circle moving
130:48 - uniformly
130:50 - let's run this
130:53 - now if I run this I can see my circle
130:56 - moving around in various directions
130:57 - changing its direction as it hits the
131:00 - boundaries
131:02 - and everything works fine if I quit the
131:05 - screen goes away so this motion of the
131:08 - circle is not defined
131:10 - in the next video we will Define this
131:13 - motion of the circle
131:15 - the path along which the circle moves
131:17 - would be some function so
131:20 - this was pretty much it for this video
131:23 - I hope you understood whatever we did
131:25 - thank you
131:28 - hey everyone as I told you in the last
131:31 - video we would animate the circle along
131:33 - the graph of a function
131:35 - that's what we are gonna do in this
131:37 - video
131:37 - we will try that our Circle Moves In A
131:40 - Sign pattern the function I've picked a
131:42 - sign if you don't know how a sine wave
131:44 - looks like this is what a sine wave
131:45 - looks like
131:47 - you can see that along the x-axis you
131:50 - have the Angles and along the Y it is
131:52 - the sine value of these angles
131:54 - and it looks like a suicidal wave so you
131:58 - need to given these angles in the sine
132:00 - function and you can easily find the Y
132:02 - code in it for the sine function we will
132:04 - use the mark module
132:06 - and we'll give in these X and Y
132:08 - coordinates as the argument while we
132:10 - draw the circle so that will put our
132:12 - circle at the required position and the
132:14 - output motion would look like a sign
132:16 - pattern fine
132:18 - let's write the program now I'll import
132:21 - Pi game I'll write import Pi game
132:25 - then I'll initialize it I'll write Pi
132:28 - game
132:29 - dot init
132:34 - then I'll set up the screen
132:36 - right by game dot display
132:41 - dot set mode
132:45 - and I'll given the screen size to be
132:47 - 1000 comma 500 I've taken such a large
132:50 - width so that I can see a number of
132:53 - waves
132:54 - and I can easily observe that sign
132:56 - pattern
132:58 - formed by the ball
133:00 - then I'll start by while true Loop I'll
133:03 - get to the game Loop I'll write while
133:05 - true
133:07 - for events in pie game dot event dot get
133:15 - if events.type equals spygame dot quit
133:19 - so I'll check in the condition I'll call
133:22 - the quid function
133:26 - by game dot quit
133:29 - and I'll quit
133:31 - and then I'll update this I'll write buy
133:35 - game dot display dot update
133:39 - cool so this was the basic code
133:42 - let's get to the main code now
133:45 - since I said I'd be using the math
133:48 - module I'll write import math I'll
133:50 - import math
133:51 - I'll import the math module
133:54 - now I should think that from where we
133:56 - will given the inputs from where we
133:58 - should find the x coordinate
134:01 - y coordinate we can easily find the y
134:03 - coordinate because that's just the sine
134:05 - function of the x value
134:07 - so where we will get the x value from we
134:11 - will get it from the time okay
134:13 - but you might say that if we get the
134:16 - running time of the program then it will
134:19 - exceed continuously and we won't see our
134:23 - ball once it has passed our screen for
134:25 - that I'll use the modulo operator I'll
134:29 - find
134:32 - the Times modulo by thousand this is how
134:35 - I write it so the get ticks method gets
134:39 - me the amount of time
134:41 - for which the program has been running
134:43 - right after initializing Pi game
134:45 - otherwise this won't work if you haven't
134:47 - initialized by game this won't work
134:50 - okay and I'll also divided by a number
134:53 - I'll divide it by three so that I can
134:57 - get a slower speed the ball doesn't run
135:00 - away and I can notice that the ball
135:04 - moves in a sign pattern fine then let me
135:07 - put this x equal to T okay
135:10 - and for y I will put it into the sine
135:13 - function
135:14 - so I'll write math DOT sign
135:18 - T by 50 in 200 plus 200 okay so the I've
135:23 - divided it by 50 for the wavelength so I
135:27 - want to keep shorter wavelength so that
135:29 - I can see many waves and I can easily
135:32 - observe the sign pattern
135:35 - now if you increase this you can
135:37 - increase this to 150 then the wavelength
135:40 - would be increased and you'll see less
135:42 - number of waves
135:44 - this 100 is for
135:46 - defining the amplitude if you increase
135:49 - this the amplitude would increase and if
135:52 - you decrease this the amplitude will
135:54 - decrease 100 defines the amplitude so
135:56 - 100 is the amplitude of my wave and I've
135:59 - added it with 200
136:01 - so that I can see my wave in the middle
136:03 - of the screen
136:05 - and not add some Corner otherwise the
136:08 - Sangre will overlap with the boundaries
136:11 - okay
136:12 - then I'll fill my screen with some color
136:15 - and I'll draw my circle
136:18 - let the screen full color be
136:21 - pink
136:22 - and
136:24 - I'll use the draw module to
136:27 - make the circle
136:30 - so screen is the surface I want to draw
136:32 - on I'll give it a color
136:34 - then X and Y are my coordinates
136:37 - and then be the radius of the circle
136:40 - then I'll update I have already written
136:43 - this so let's run this and see if we
136:46 - observe our Circle in a sign pattern
136:53 - so yeah I can see my ball or Circle
136:56 - moving in a sign pattern
136:59 - it's very similar to the graph I showed
137:01 - you before now if you can't observe it
137:03 - what you can do is you can wrap this
137:05 - line screen dot fill just to observe for
137:08 - once the assign pattern of the ball
137:11 - you can rub in this line screen dot fill
137:14 - I hope you remember we did the same
137:16 - thing while we wanted to draw patterns
137:18 - using our object using the arrow keys we
137:21 - wanted to see the trail of our object
137:23 - drawn
137:24 - here too the trail that is the sign
137:26 - pattern
137:28 - to see that you can rub in this line and
137:31 - now if I run this you can actually see
137:33 - the sine graph and so yeah our ball
137:37 - moves in a sign pattern
137:39 - now you can use other functions also
137:42 - like a sign or tangent
137:45 - from the math module
137:47 - so this is it for this video thank you
137:52 - hey everyone today we're gonna do
137:55 - something different we would use classes
137:57 - in order to make a pi game program
137:59 - rather a game so I would try to build a
138:02 - collision game I would have this bag and
138:04 - if he hits the bricks falling from above
138:07 - the game is over simple okay so in pie
138:10 - game we have a Sprite module for working
138:11 - with classes strikes are objects if you
138:15 - don't have much idea about classes and
138:17 - objects in 5 game basically they are a
138:19 - convenient way of dropping data and code
138:21 - into a single entity Sprite module is a
138:24 - very good way of working with classes in
138:26 - biking
138:27 - so for the regard them what I would do
138:29 - is I would first have a man class that
138:32 - would be of this Sprite type and I will
138:35 - also have a brick class now both of them
138:38 - must have the init function where I load
138:41 - these images and get their tangler
138:43 - surfaces then we would have the move
138:46 - function in both the classes we would
138:48 - move the man by giving key inputs from
138:51 - arrow keys and the movement of bricks
138:54 - would be programmed on the initial
138:56 - position of the bricks would be randomly
138:57 - picked by the random module
139:01 - Now using the stripe module I would
139:04 - check in the game Loop if there is a
139:06 - collision between these two image
139:07 - objects
139:09 - if there is I would display the text
139:11 - came over okay now let's start writing
139:13 - the code for it
139:15 - so let me write the basic code quickly
139:18 - I'll import file game
139:21 - then I'll initialize it I'll write Pi
139:23 - game dot init
139:25 - then I'll set up my screen
139:28 - light screen
139:30 - equals Spy game
139:32 - dot display dot set mode and the screen
139:37 - size is 500 comma 500
139:40 - then I'll set the caption I'll write by
139:43 - game dot display not set caption and the
139:47 - caption Let It Be Collision game
139:51 - okay
139:52 - now for the while loop I'll write while
139:55 - true
139:57 - for events in pie game dot event dot get
140:03 - get
140:05 - if events DOT type
140:10 - equals spygame dot quit
140:14 - I'll call the quit function by pi game
140:17 - I'll fill my screen with some color all
140:20 - right screen dot fill White
140:24 - and I'll update this
140:27 - let me use the flip function
140:32 - I'll write pi
140:33 - game.display.flip and I'll
140:36 - yeah that's a basic code now let's write
140:40 - the main code let's get to the main
140:41 - functions of
140:43 - our game
140:44 - now since I said I'd be working with
140:46 - random modules because I need the bricks
140:49 - to be following from randomly falling
140:52 - from anywhere so I'll import random
140:54 - module 2 I'll write import random
141:00 - then
141:01 - I'll have my clock object
141:04 - I'll write clock equals
141:06 - spygame.time.clock
141:08 - that's my clock object to set up the
141:10 - frame rate later
141:13 - and
141:15 - I would need to set up the speed
141:16 - variable for the movement of bricks
141:22 - this is just the initialization we'll
141:24 - use this later you will get an idea why
141:26 - we have initialized it here
141:28 - and I also need to display that text
141:32 - game over so I set up the font I'll
141:35 - write font equals Pi game dot font dot
141:39 - sys font and let it be Georgia and 60 as
141:42 - the font size
141:47 - cool so I have these variables
141:49 - initialized so let's get to the two
141:52 - classes I talked about the brick and the
141:54 - man class
141:55 - so let me Define the brick class first
141:58 - I'll write class brick so that's how you
142:01 - define a class in pi python
142:05 - and since I want to inherit the Sprite
142:08 - class I'll write Pi game dot Sprite
142:11 - Which is the module dot Sprite Which is
142:13 - the class okay
142:16 - Sprite is the class in this Sprite
142:18 - module okay so it might be confusing in
142:21 - the beginning but just try to think and
142:24 - understand you'll get a hold of it okay
142:27 - now
142:29 - I'll have this init function I'll Define
142:31 - init I'll write def underscore
142:36 - underscore net underscore underscore
142:39 - and self
142:41 - okay
142:43 - so I'll inherit this Sprite class so
142:45 - I'll write super dot in it
142:48 - super dot in it it's away in Python how
142:52 - we inherit the classes
142:55 - base classes okay so now I'll load my
142:59 - image I'll write self dot image equals
143:01 - spygame.ms.load
143:04 - you should have a little basic idea of
143:07 - classes in Python otherwise it might be
143:11 - too much for you to handle for now
143:13 - because we are already working with pi
143:15 - games that is new for you and then we
143:17 - are
143:18 - again having a new thing that is classes
143:21 - so you might not get comfortable with it
143:24 - so please try to understand the classes
143:28 - first and then get to the pi game code
143:31 - fine so I'll write self dot image equals
143:35 - spygame Dot image.load
143:38 - so my image is in Collision folder it's
143:41 - just how we displayed an image in pi
143:44 - game earlier just the difference is that
143:47 - right now we are doing this in a
143:49 - function
143:49 - inside a class
143:51 - okay
143:52 - then I'll Transform I'll scale this
143:56 - image of mine I'll write self dot image
143:59 - equals spygame dot transform dot scale
144:03 - self image what I need to transform what
144:06 - I need to scale is the self image and I
144:10 - need to scale it to size 40 comma 40.
144:13 - okay then I need to get the rectangle so
144:16 - I'll write self.rect these are just
144:18 - variables but of per class
144:20 - so that's how you write it I'll write
144:23 - self.rect equals self dot image dot get
144:26 - right I got the rectangular surface and
144:29 - I need to define the center
144:31 - so my Center would be randomly picked
144:34 - for these bricks falling from above
144:38 - so I've used random.randint
144:41 - 40 comma 500 minus 40 I have kept margin
144:44 - of 40 either side just so
144:48 - the boundaries and the bricks don't
144:50 - Collide they don't overlap okay
144:53 - and yeah
144:56 - then I'll Define the move function for
144:59 - the movement of the bricks how they have
145:03 - a motion right they are falling from
145:04 - above so I'll do it I'll write self.rec
145:07 - dot move in place
145:09 - and the arguments are zero comma speed
145:12 - so my speed was 5 and I'm just giving a
145:16 - speed in the y direction because I want
145:18 - it to fall from above and there should
145:21 - not be any movement along the x-axis the
145:23 - brick is just falling from above
145:24 - directly
145:26 - towards the ground and move in place
145:29 - what is move in place does is from an
145:33 - object's coordinates it moves it with
145:36 - respect to that position uh what the
145:38 - speed we have mentioned okay so like if
145:40 - the coordinates right now are 400 comma
145:42 - 400 and I've mentioned 0 comma speed as
145:46 - the move in place arguments
145:49 - after this function is called
145:51 - the final coordinates would be 400 comma
145:55 - 405 okay I hope you get what I'm trying
145:57 - to say
145:58 - and I'll put in some conditions that
146:01 - once the brick has traveled the entire
146:04 - screen and not hit the man okay then
146:09 - what should what should happen I'll
146:11 - write if self.rec dot top is greater
146:15 - than 500
146:16 - now I just quickly wanted to show you
146:18 - what this wrecked top and Dot Center
146:21 - means
146:22 - which coordinate of the entire rectangle
146:25 - I am talking about you can see it in
146:27 - this
146:28 - picture
146:30 - so I hope you get the idea what is dot
146:34 - top which coordinate I am talking about
146:36 - and what is Dot Center there are two
146:38 - different coordinates of the rectangle
146:39 - okay
146:40 - now if it is so
146:43 - if the rectangle stop coordinate is
146:46 - greater than 500 that is it is out of
146:48 - the screen now now I should reallocate
146:50 - this top coordinate to 0 and the center
146:53 - should be randomly picked again okay
146:56 - again I have kept a margin of 30 and 100
146:59 - over here so that things don't overlap
147:01 - okay
147:03 - cool I'll have my man class again I'll
147:06 - write class man
147:08 - very similar to the above class and Pi
147:11 - game dot Sprite dot Sprite
147:14 - okay then I'll have my init function
147:16 - again I'll write self in the argument
147:20 - with the super keyword I'll inherit the
147:23 - Sprite paste class
147:26 - and again load the images but I'll load
147:28 - that image of scared man now
147:31 - it is in the Collision folder so
147:33 - accordingly I've mentioned the path then
147:35 - I'll scale this
147:37 - right I came dot transform dot scale
147:41 - self-image
147:43 - 100 comma 150 okay
147:47 - I'll write self.rec equals cell dot
147:50 - image dot capture to get the rectangular
147:52 - surface and Define its Center is this
147:55 - the initial coordinates of the image
147:58 - that I have loaded of the scared man
148:01 - let it be 200 comma 420 okay
148:04 - and then I'll Define the move function
148:06 - how my how the man moves okay so since
148:11 - I'll be taking inputs from Keys the
148:13 - arrow keys from the keyboard I'll again
148:16 - write Keys equals to Pi game dot key dot
148:18 - get pressed so I hope you remember this
148:21 - was a sequence this was a Boolean
148:22 - sequence that contained the state of all
148:26 - the keys on the keyboard if it is true
148:29 - then that key is being pressed now I'll
148:31 - check if Keys dot k underscore left
148:36 - then I'll write self.track dot move in
148:39 - place minus 5 comma 0 so I want to move
148:42 - it towards the left okay so I'm
148:45 - subtracting we discussed this earlier in
148:48 - earlier programs that if we want to move
148:50 - left we'll decrease it it decrease its
148:53 - coordinates okay
148:54 - so I'll decrease it by 5 and if Keys Pi
148:58 - game dot k underscore right
149:00 - cell dot Shrek dot move IEP
149:04 - 5 comma six okay so if it is if I if I
149:08 - press the right key if the user has
149:10 - pressed the right key
149:12 - the man will move towards right with
149:14 - five by five units okay
149:16 - now I'll declare objects of this man and
149:19 - brick class M1 I'll write M1 equals Mal
149:23 - and B1 is equals to Brick so this is how
149:27 - we declare objects in Python
149:29 - of a class so these are my two objects
149:32 - okay and now I'll have a variable bricks
149:36 - I'll write equals spycam dot Sprite dot
149:38 - group so I'll declare this bricks to be
149:42 - a group okay so what a group is it's a
149:45 - Sprite module functionality it's a
149:48 - container class to hold and manage
149:51 - multiple Sprite objects okay now to this
149:54 - group I'll add B1 Okay so
149:58 - this is a brick scrub okay and to that
150:01 - I've added P1 that object that brick
150:04 - object okay
150:05 - now I'll have another class in which
150:08 - I'll put everything all the objects that
150:10 - I've declared okay now all Stripes
150:13 - equals spygame dot Sprite dot group
150:15 - again this is another container class
150:18 - okay and I'll add M1 and B1
150:22 - to the script
150:24 - you'll get it in a minute why I have
150:26 - declared these groups okay bricks and
150:29 - all Sprites
150:30 - now let's get to the while true Loop
150:33 - now for entity in all Sprites
150:38 - screen dot plate entity dot image comma
150:42 - entity.rect
150:44 - entity dot move okay what I have done is
150:47 - I'll Traverse all that is there in the
150:50 - all Sprites group that is why I've
150:52 - declared all Sprites variable because I
150:55 - need to put each of those objects on the
150:58 - screen so that is how I've done it I'll
151:01 - write screen dot BLT entity dot image
151:05 - entity.rect so I've got that image on
151:07 - that rectangular position on this screen
151:09 - okay now ndd.move I've called on to that
151:13 - move function in the respective classes
151:16 - and according to the move function my
151:19 - objects would move my images would move
151:22 - and I'll also now is the main part I'll
151:25 - check if that Sprite objects collide
151:29 - with any of
151:31 - the other object okay so I'll write if
151:34 - Pi game dot Sprite because it is a
151:36 - Sprite module um
151:38 - function dot Sprite Collide any it's a
151:42 - simple test if a Sprite in a sex
151:45 - anything in a group okay so M1 comma
151:49 - breaks okay M1 is the man we have only
151:52 - one man but we'll have a number of
151:54 - bricks okay
151:56 - and then if it is so if this returns
152:00 - true then I'll render
152:02 - the font that I declared above I'll
152:05 - write text equals font dot render
152:08 - what is my message it is game over I
152:11 - want anti-aliers to be true
152:14 - and the color let it be orange
152:18 - fine
152:19 - then I'll get this on the rectangle so
152:22 - text direct equals text Dot get tracked
152:24 - Center
152:26 - that would be 500 double flat two
152:31 - okay so I got this text at the center of
152:35 - the screen and I'll use blit again
152:39 - to get this text on the rectangle
152:42 - I'll use dot flip function so that I can
152:46 - take this
152:47 - and just so I can visualize this effect
152:50 - I can see this text that the game is
152:53 - over I'll use this time module I'll
152:56 - write time dot sleep
152:58 - for two seconds so that I can see that
153:01 - the game is over and then I'll quit okay
153:04 - otherwise you'll just see the game over
153:06 - text is blinking and going away and the
153:10 - screen goes away okay that wouldn't look
153:12 - good so I also need to import time
153:14 - module
153:15 - I'll write import
153:18 - time
153:20 - yeah that's it
153:22 - so I'll also need to set up the frame
153:24 - rates I'll write clock.tick and 40 let
153:28 - the frame rate be 40. okay
153:31 - now let's play this game and let's see
153:35 - if everything works properly as we have
153:37 - defined
153:45 - now when I run this I can actually see
153:48 - the bricks falling from above
153:50 - I can move the man using the left and
153:54 - right arrow keys
153:56 - I guess the speed is a little slow so
153:59 - let me change the frame rate to 60 so
154:01 - that it the game becomes a little fun to
154:04 - play and a little complex
154:06 - so the bricks are now falling faster
154:09 - and
154:11 - when the man and the brick collides the
154:14 - game is over I have this text and the
154:18 - screen goes away automatically after two
154:20 - seconds cool
154:22 - so this was it for this program
154:25 - and you can also think about how you'd
154:28 - gradually increase the speed so you can
154:30 - think of levels
154:32 - for that you might need to declare some
154:34 - user events uh please think about it
154:37 - please look for what you can do
154:40 - and this was it for the program thank
154:43 - you
154:46 - hey everyone today we're gonna talk
154:49 - about another General function of a
154:51 - character in a video game if you have a
154:53 - player in the video game you might need
154:54 - to add the jump function you might need
154:56 - your player to jump so that's what we
154:58 - are going to program today let me
155:00 - discuss first what we will do in the
155:02 - program we will have this rectangle made
155:04 - by the draw module then we would use the
155:06 - key module to move the rectangle up down
155:09 - left and right and we will have one more
155:11 - key that we would use to jump ladaki B
155:14 - spacebar so let's code all this I'll
155:18 - import Pi game I'll write and pour it by
155:20 - game
155:21 - I'll initialize it
155:26 - and I'll set up the screen I'll write
155:28 - screen equals spygame dot display dot
155:31 - set mode and the screen size is 500
155:34 - comma 500. I'll given the caption I'll
155:37 - write by game dot display dot set
155:40 - caption
155:41 - and let the caption be jump
155:44 - then I'll do my while loop I'll write
155:47 - while true
155:49 - for events
155:51 - in pie game dot event dot get
155:56 - if events
155:58 - DOT type equals spygame dot quit then
156:02 - I'll call the quit function by pi game
156:05 - and I'll quit
156:07 - I will also set up my screen
156:09 - with some color right screen dot fill
156:14 - this is a lighter shade of green
156:17 - and then I'll update this I'll write
156:20 - 5game.display.update
156:23 - and I'm done with the basic frame
156:25 - structure
156:27 - now I would need to set up the basic
156:29 - variables that I would use in the
156:31 - program so one would be the size height
156:36 - width and the initial position of the
156:38 - rectangle I would move around so you can
156:41 - use the right class or you can
156:44 - initialize the parameters
156:46 - just by taking variables
156:48 - and so I've used the right class I'll
156:51 - write my erect
156:53 - equals spygame dot Direct
156:58 - let the initial position be 200 comma
157:01 - 200
157:03 - and the size the width V10 and height
157:06 - B20 you can even take a larger rectangle
157:09 - then I'll do I'll have the speed
157:12 - variable
157:14 - let it be five
157:15 - the amount of distance the rectangle
157:18 - travels at once
157:20 - and I'll have this jumped variable which
157:23 - would be a Boolean
157:24 - I'll set it up to false so that I can
157:26 - know when the object has to jump or not
157:29 - you'll get the use of it later in the
157:32 - code
157:33 - then you have this jumpsuit variable
157:35 - which is equal to 10 I'll put this equal
157:38 - to 10 this is the jump speed the amount
157:40 - of distance a travel travels at once
157:43 - when you jump or you will click the
157:45 - space bar
157:46 - so we will use this later in the code
157:50 - now inside this while loop
157:53 - I will Define the movement of the
157:56 - rectangle drawn I'll write keys
158:00 - equals spygame dot key dot get pressed
158:06 - so here's the Boolean sequence as we
158:10 - have discussed a lot of times by now it
158:13 - stores the states of the keys on the
158:14 - keyboard as true or false if the key is
158:17 - pressed its state is true now
158:20 - accordingly I will check in which
158:22 - direction the object should move this is
158:24 - exactly the same thing as we did in
158:27 - moving an object so try to write this
158:28 - piece of code yourself it would help you
158:30 - practice
158:31 - I'll check for the left Arrow key if the
158:34 - left Arrow key is pressed I'll write if
158:38 - keys
158:40 - in square brackets by game dot k left
158:45 - so this is how we access the state of
158:47 - the left Arrow key and
158:50 - my underscore rec.x so this is the x
158:54 - coordinate of
158:55 - my rectangle the object is greater than
158:58 - zero then I will decrease the x
159:02 - coordinate of the rectangle by speed
159:04 - units so I'll write my right
159:08 - dot X
159:10 - I have access to x coordinate minus
159:13 - equals speed
159:15 - okay I hope you remember if you need to
159:17 - go towards left side then we decrease
159:20 - the exponent now for the right arrow key
159:23 - I'll write if
159:26 - keys
159:28 - pygame dot k right I have accessed the
159:31 - writer okay and my rectangle dot X is
159:36 - less than 500 minus direct dot fifth
159:39 - dot w would access your width
159:42 - this is just for keeping the rectangle
159:45 - complete rectangle within the boundaries
159:47 - I will increase the x coordinate by
159:50 - speed units so I'll write my erect
159:52 - dot X plus equals
159:56 - speed
159:58 - fine
160:00 - now check for the up key
160:03 - so I'll write F if Keys Pi game Dot K
160:09 - underscore up
160:12 - is
160:15 - greater than zero
160:18 - I'll access the y coordinate now since I
160:20 - am talking about vertical motion
160:22 - I'll write my erect dot y
160:25 - minus equals speed okay
160:29 - this is the normal motion of the
160:32 - rectangle okay I also need to talk about
160:34 - the down key
160:36 - if Keys Pi game dot k down
160:40 - and my react dot y the y coordinate is
160:44 - less than 500 minus my red dot h
160:48 - since we are talking about the vertical
160:49 - motion I have accessed the height not
160:52 - the width here
160:54 - my rec.y plus equal speed since we are
160:58 - moving downwards okay
161:00 - okay fine
161:03 - so this was something we had already
161:05 - done but now we'll move on to the jump
161:08 - function part
161:10 - so I'll write if jump equals false I'll
161:13 - check if jump is equals to false this is
161:16 - the initial condition right now and then
161:18 - I'll check if keys and basically I have
161:22 - pressed the space bar I'll write if Keys
161:25 - Pi Kim dot k underscore space I'll
161:28 - access this state of the space bar
161:31 - if it has been pressed I'll make jump
161:34 - equals to true now okay I'll reassign
161:36 - its value
161:38 - so if you actually analyze what would
161:40 - happen when the rectangle jumps it would
161:43 - cover a lot of distance vertically above
161:46 - more than it normally covers when we
161:48 - press an arrow key
161:50 - so I'll put this in the else condition
161:53 - let me write it first if jump C is
161:55 - greater than equal to minus 10
161:58 - I'll check if the object is back at its
162:02 - place
162:03 - my rect.y
162:05 - minus equals jump C
162:09 - into absolute jump C into 0.5
162:15 - jumps C minus equals 1.
162:19 - so let me explain now uh you should get
162:22 - that if the rectangle is jumping we will
162:24 - decrease the y coordinate just like the
162:26 - up Arrow key but by a larger value so
162:30 - that value is product of jump C into
162:32 - absolute jump C and 0.5 and after each
162:36 - decrement of y coordinate I will
162:38 - recommend the jump C by 1.
162:41 - jumpsuit keeps the count how many times
162:44 - the there would be this kind of y
162:46 - coordinate decrement now you can think
162:49 - once the jump C value decreases and
162:51 - reaches zero you need the wreck to come
162:54 - back to its original position
162:57 - but for that you will increment the same
162:59 - that you decremented to the y coordinate
163:01 - so here is the role of this absolute
163:04 - function since jump C is negative if you
163:07 - don't use the absolute function you will
163:10 - end up decrementing more and the
163:11 - rectangle will not come back to its
163:13 - original position so all this will
163:16 - basically run a loop till the jump C
163:18 - becomes minus 10.
163:20 - as you went up 10 times you need to come
163:22 - back the same amount of times okay
163:25 - now else
163:28 - I will write jump C equals 10.
163:32 - I'll reassign jump C and jump equals
163:35 - false
163:37 - so I have reassigned these two variables
163:39 - just in case you click on the space bar
163:42 - again the space bar is pressed again the
163:45 - values are reassigned okay
163:47 - now I'll fill the screen with some color
163:50 - and I'll draw the rectangle now that
163:53 - would be moving around
163:54 - so I'll write Pi game dot draw dot rate
163:58 - screen
164:00 - and I'll given some color let it be
164:03 - purple
164:04 - and my rec.x
164:08 - myrec dot y
164:11 - rek dot w on my vect.its
164:15 - okay so these were the parameters x y w
164:19 - and H with the parameters of the
164:21 - rectangle I would draw
164:24 - okay now this is it for this
164:27 - program let's run this and see if the
164:30 - rectangle jumps
164:37 - so here is the rectangle I made
164:40 - and I'll press the space bar first
164:43 - okay so rectangle jumps very well and
164:47 - the forward backward and down and above
164:50 - keys were fine left right up and down
164:53 - Keys work fine
164:54 - now you can even combine the two keys if
164:58 - you press the space bar and the left or
165:01 - right arrow key the there is a combined
165:05 - motion you can see like this
165:07 - it's a kind of a parabolic motion okay
165:12 - so yeah this was it for the program
165:16 - and
165:17 - I hope you understood whatever was done
165:19 - thank you
165:25 - hey everyone today we're gonna again
165:27 - display text on Pi game window but on
165:30 - several lines so that would make use of
165:32 - some basic python but with pi game so
165:35 - that's going to be a little different
165:37 - than what we usually do to display text
165:40 - on screen let's get to the code right
165:42 - away I'll import Pi again
165:45 - I'll initialize it
165:47 - right by game dot in it
165:51 - then I'll set up the screen I'll write
165:53 - screen equals spygame dot display dot
165:56 - set mode and let the screen size be 800
165:58 - comma 500. then I'll given the caption
166:01 - I'll write by
166:03 - game.display.set caption
166:05 - let the caption be text
166:09 - then I'll get to the while loop I'll
166:10 - write while true
166:14 - for events
166:16 - and buy game dot event dot get
166:21 - if
166:23 - events DOT type equals spygame dot quit
166:28 - then I'll call the quit function by pi
166:30 - game and I'll quit
166:33 - then I'll fill the screen with some
166:35 - color I'll write screen dot fill
166:40 - and let it be pink
166:44 - and then I'll update I'll write by again
166:47 - dot display dot update
166:50 - so we're done with the basic structure
166:53 - let's get to the main code now since I
166:56 - want to display some text I need to
166:57 - Define that so let me take this variable
167:00 - text
167:02 - let it be equal to a string
167:05 - I will write hello everyone
167:11 - slash n so I need to indicate that there
167:14 - is a new line beginning
167:16 - we are trying
167:19 - to display
167:23 - text on Pi game window
167:28 - okay so that's my text that's that is
167:32 - what I want to display on the screen
167:35 - since I want to display the text like
167:38 - usual I'll have this font variable I'll
167:42 - write by game dot font
167:45 - dots is font
167:47 - and let the font be ink free
167:51 - you can take any font and the font size
167:54 - b60 you can take any font size
167:58 - now just think what would be different
168:01 - while rendering text in different lines
168:04 - how would it be different from just
168:06 - displaying text on screen
168:07 - so when we display text on screen
168:09 - usually you might have noticed if the
168:12 - sentence is a bit long it runs out of
168:15 - the screen and it is not visible so we
168:18 - need to check after rendering each word
168:20 - on screen if the screen is ending here
168:22 - if not we can print the next word in the
168:25 - same line else we would move to the next
168:28 - line okay so for that I would need to
168:31 - Define this display text function I'll
168:34 - write def display
168:38 - text
168:39 - and I'll given the argument surface on
168:42 - the surface on which I want my text then
168:45 - the text the message I want to see on
168:47 - the screen the position POS
168:51 - the starting position of my text from
168:53 - where I want my text to start
168:56 - the font of the text and the color okay
169:00 - so in this function I would get the word
169:03 - separately in a list and render them one
169:06 - by one while checking the screen's ends
169:08 - okay so for that I'll have this
169:10 - collection
169:12 - variable I'll write collection equals
169:15 - for word
169:17 - in text Dot split lines
169:24 - so what I have done is this text Dot
169:26 - split lines would split this text the
169:30 - message you have passed in to the
169:32 - argument
169:33 - into several lines into several elements
169:36 - of a list so hello everyone would be one
169:39 - element of the list and we are trying to
169:41 - display text on Pi game window would be
169:43 - another element of that list that's what
169:45 - we have and we would be traversing this
169:48 - list so it has two elements right now
169:51 - and then to get each word here what I'll
169:54 - do is word
169:56 - dot split
169:59 - has given the argument as the space
170:03 - and I'll put this entire thing in a in
170:06 - square brackets so that it becomes a
170:09 - list so basically this would be a 2d
170:12 - list as the text split lines would
170:14 - already give you a list and in that list
170:16 - you further use the split method that
170:19 - makes another list of words for each
170:21 - sentence okay now to given space between
170:25 - different words
170:27 - I will have the space variable I'll
170:30 - write space equals font dot size
170:33 - I'll given this space as argument and
170:37 - zero so font dot size and any character
170:41 - in the argument would give you a tuple
170:43 - which has the width and height of that
170:46 - character you get that right for a font
170:49 - two characters would not possibly have
170:51 - the same width and height so 0 would
170:54 - give you the the zeroth element of that
170:57 - Tuple would give you the width and the
170:59 - first element of that Tuple would give
171:01 - you the height right now I am just
171:03 - working with the height because that is
171:05 - the amount of space I want to leave
171:06 - between in between two words while
171:09 - rendering two words
171:11 - okay then I have this x comma y equals
171:16 - position so this X and Y would keep a
171:20 - track of current position and it would
171:22 - be used for checking if the screen has
171:24 - ended and to move to the next line okay
171:27 - now we'll uh Traverse this collection 2D
171:30 - list I'll write four lines in collection
171:36 - and forwards in lines
171:41 - now I will render the text I'll write
171:44 - word underscore surface
171:47 - equals font
171:49 - dot render
171:51 - words comma true eventually asking to be
171:55 - true and the color that I passed
171:57 - in the argument for this function that
172:00 - will be passed here
172:02 - so I have rendered this text the word
172:06 - I am accessing each word now and I have
172:09 - rendered this word
172:10 - on a text on a surface on a rectangular
172:14 - surface
172:15 - now after rendering we use split usually
172:18 - but before that I need to check if there
172:21 - is still space or the word would be
172:23 - rendered in a new line okay
172:25 - so for that I'll get the width and
172:28 - height of the surface I just rendered
172:31 - I'll write word underscore with
172:34 - word underscore height equals word
172:38 - surface cat size
172:41 - so this would give me two variables the
172:43 - width and height of the rectangular
172:46 - surface that was just declared and I'll
172:50 - check if there is a need to go on to the
172:51 - next line so I'll write if
172:55 - X Plus word width
173:00 - is greater than equal to 800
173:03 - so X was my initial position from where
173:06 - I wanted to start the text and adding
173:09 - that to the word width would be like the
173:12 - entire width of the text if it is
173:15 - greater than or equal to 800 now that
173:18 - position
173:19 - that x coordinate if it is greater than
173:21 - equal to 800 the width of my screen okay
173:24 - then what I'll do is I'll reassign X
173:28 - I'll write x equals position 0
173:33 - the x coordinate of the first word
173:36 - and for y since I want to go to the next
173:39 - line I'll increment y by the word height
173:42 - okay I hope you get it that to move on
173:45 - to the next line there is no such thing
173:47 - while rendering text on Pi game any
173:50 - lines no lines are there so I'll
173:52 - increment y by word height so that will
173:55 - give me a new line okay now after
173:58 - checking the condition I can use the
174:00 - blit function I'll write surface
174:03 - dot Blitz
174:04 - word surface
174:07 - comma X comma y so X comma y would be
174:09 - the position where I want this
174:11 - rectangular surface this word surface to
174:13 - be there
174:14 - and so I got the rectangular surface on
174:17 - the screen and to update X every time
174:21 - I will increment it by the word bit and
174:25 - space that was the width of this space
174:27 - okay
174:29 - so let me write this down I'll write X
174:32 - plus equals word width
174:36 - plus space
174:38 - okay
174:39 - now I outside this inner for Loop I'll
174:43 - reassign X if the line is finished but
174:46 - there is still space then you need to go
174:49 - to the next line okay that's what a new
174:51 - line means
174:53 - so I'll reassign X I'll write X is
174:56 - equals to position 0. and I'll increment
174:59 - y by word height just what we did when
175:03 - the screen ended okay
175:06 - that was our function display text
175:08 - function
175:09 - so inside this while shoe Loop I'll call
175:12 - on to this function after screen dot
175:14 - fill I'll write display
175:17 - underscore text I'll pass in the
175:21 - arguments screen is the surface I want
175:23 - my text on I have the message I want to
175:26 - print as text variable
175:28 - so text would be that message
175:31 - and I'll start from 20 comma 20 that
175:34 - position
175:36 - then I have also declared the font
175:38 - variable
175:39 - and let the color be purple for the text
175:43 - okay so this was it for this program
175:46 - let's run this and see if we get the
175:50 - text in two different lines
175:55 - so you can see that we have our text in
175:58 - two different lines
176:00 - so after hello everyone there is still
176:02 - space but since I have a new line
176:06 - so the next line was printed onto a
176:09 - different line okay
176:10 - quotes so we got the text as we wanted
176:13 - it to
176:15 - now what if you don't have just two
176:18 - lines but a complete paragraph and you
176:20 - are out of lines
176:22 - the screen height is completely filled
176:25 - here we managed to get the text on a new
176:27 - line when we were out of screen width
176:30 - but what if we run out of height you
176:32 - might think of resizing the screen think
176:35 - about this try to write a program to
176:37 - solve this problem I hope you understood
176:40 - whatever we did in this program thank
176:43 - you
176:45 - hey everyone today we're gonna discuss
176:48 - making custom user events sometimes
176:51 - while making a video game with pi game
176:53 - you might need to create a custom event
176:55 - so we're gonna make two easier events
176:57 - one that is initiated by the user and
176:59 - one that works automatically
177:01 - so I'll have a rectangular object that
177:04 - will inflate to a certain size when I
177:06 - hover over it and the other event would
177:09 - be the screen changing its color
177:10 - alternatively let's write the code for
177:13 - it now I'll import Pi game
177:18 - I'll initialize it
177:22 - I'll set up the screen
177:24 - equals spygame dot display dot set mode
177:27 - screen size that if I wanted comma 500
177:30 - and then I'll also given the caption
177:33 - I'll write by game dot display dot set
177:35 - caption
177:36 - and let the caption be custom
177:39 - events
177:43 - then I'll get to the while true Loop
177:45 - I'll write while true
177:47 - for events in biking dot event
177:52 - dot get
177:54 - if events
177:56 - DOT type equals spygame Dot equipped
178:01 - I'll call the quit function by piking
178:04 - and I will quit
178:08 - I won't write screen dot fill right now
178:11 - I will do that later there is a clause
178:14 - to it I'll get to that later and then
178:16 - I'll update this I'll write
178:19 - bygame.display.update okay
178:22 - now outside this my true Loop let's get
178:25 - to the main code now let me Define the
178:28 - two user events two custom events
178:31 - so let the color changing event be
178:33 - called color I'll write color
178:38 - equals spygame dot user event in capital
178:43 - and plus one so that is how you define a
178:48 - custom event
178:49 - then I'll have another event the Box
178:52 - crew Event I'll write box
178:55 - underscore grow
178:57 - equals spygame dot user event plus two
179:02 - so that's the second event so I've done
179:04 - plus two okay
179:06 - now I'll set up the background color to
179:09 - white to check the next color of the
179:12 - screen what color needs to be filled
179:14 - next it will be used later in the color
179:17 - user event when we Define it
179:20 - and I'll have this
179:22 - grow variable of Boolean type to know
179:25 - when the cursor is hovering so that
179:27 - accordingly the rectangle can inflate
179:30 - and deflate this also would be used in
179:32 - the Box scroll function
179:34 - since I told you I'll be having
179:37 - a rectangle so let me Define it I'll use
179:41 - direct class again I'll write box
179:44 - equals
179:46 - Pi game dot correct
179:49 - let the initial position be 255 comma
179:52 - 255
179:54 - and the size before T comma 40
179:59 - now here I'll be filling in the screen
180:02 - color okay so I'll write screen dot fill
180:05 - and let the color be white initially
180:10 - so this is like I have just initialized
180:13 - the screen color because in one of my
180:15 - events that color changing event I would
180:18 - alternatively change colors of screen if
180:21 - I put this in the while loop it would
180:23 - render a single color regularly okay
180:25 - because there is a loop
180:27 - okay then I'll have my clock object to
180:30 - set up the frame rate later I'll write
180:32 - clock
180:33 - equals spygame dot time dot clock
180:38 - then I'll call on to the color change in
180:40 - function because it would be automatic
180:42 - so I'll make use of the set timer method
180:45 - by the time module I'll write my game
180:47 - dot time dot set timer
180:50 - the event would be color and comma 500
180:55 - milliseconds so that would be the
180:57 - interval
180:58 - okay
181:00 - in what interval I want to call on to
181:02 - this event
181:04 - now in this events Loop
181:07 - I will Define these events that I
181:10 - initialized up above
181:13 - so I'll write I'll check if events dot
181:17 - time equals color
181:20 - if background color this variable this
181:24 - which was initially white if PhD
181:27 - underscore color equals pink
181:32 - then I'll fill in the screen with pink
181:35 - color
181:36 - and I'll make the PG color equals White
181:44 - and else if background color is white
181:48 - I'll fill the screen with white color
181:51 - and I'll reassign background color value
181:54 - I'll make it Pink
181:56 - so that would help me to alternatively
181:58 - change the colors of the screen okay
182:02 - then I'll check in for the Box scroll
182:06 - event I'll write if events.type
182:10 - equals box underscore row
182:15 - I'll check this Boolean grow if it is
182:18 - true I'll inflate the Box in place we
182:22 - discussed the concept of in place
182:24 - earlier
182:26 - so I'll write box dot inflate in place
182:29 - let us inflate it by 4 comma four
182:33 - the X and Y coordinates with the same
182:35 - amount same units
182:38 - since I said I would grow the rectangle
182:40 - to a certain size I would check the box
182:43 - width if it is less than 80 you can take
182:45 - a larger size if it is not I will let
182:49 - grow to be true else if the box is
182:51 - larger than the size I will make row
182:54 - false I won't use a nested if I would
182:58 - simply write
182:59 - grow equals box dot width is less than
183:03 - 80. I'll check if box width is less than
183:06 - 80 and accordingly grow will have that
183:09 - true all false okay
183:12 - now for the else condition if grow is
183:16 - false I'll deflate the box so there's no
183:20 - such function for deflating but we can
183:23 - inflate but with the negative
183:27 - units so what I'll write is I'll write
183:29 - box dot inflate in place
183:33 - minus 4 comma minus 4 so we'll be
183:36 - subtracting this uh four units from the
183:41 - x coordinate
183:43 - and I'll write grow equals box dot width
183:46 - is less than 40. now if the Box
183:50 - decreases to a size of 40 or less grow
183:53 - will become true again okay
183:56 - now since the Box scroll event should
183:59 - only be called when I hover over the
184:02 - rectangle I'll write outside this for
184:05 - Loop I'll write if box dot Collide point
184:09 - I can write this for rectangle class
184:12 - pygame.mouse dot get position in the
184:15 - arguments this would be checking for
184:18 - the cursor's position
184:22 - so basically I am checking if the cursor
184:25 - is over the rectangle
184:26 - what I'll do is I'll call on to this box
184:29 - grow event
184:30 - I'll write Pi game dot event dot post
184:35 - by game dot event dot event
184:38 - and I'll call on to Pork screw
184:42 - okay
184:43 - after that I'll draw my rectangle I'll
184:46 - write five game Dot draw.rect
184:50 - and in arguments screen orange let the
184:54 - Box color be orange
184:56 - and box but with my rectangle
185:00 - and after this update function I'll call
185:04 - on to the tech function to set up the
185:06 - frame rate let the frame rate be 40.
185:09 - now let's run this code and see if we
185:13 - could really create some custom events
185:22 - so the screen changes its color or
185:24 - automatically alternatively
185:27 - and when I hover over this rectangle it
185:30 - changes its size as we have defined
185:32 - it inflates under flights accordingly
185:35 - so everything is working fine we could
185:38 - actually make custom events
185:41 - so that was it for defining custom
185:44 - events
185:46 - I hope you understood how we refine
185:48 - custom events thank you