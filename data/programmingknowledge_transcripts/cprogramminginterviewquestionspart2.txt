00:00 - today we are going to take a look at the
00:03 - free interview questions so let's start
00:07 - first question is how can you use printf
00:11 - statement without the semicolon and C as
00:14 - we know that semicolon is a statement
00:16 - terminator so writing any statement
00:20 - without the semicolon will cause an
00:23 - error so this question that how can you
00:26 - use printf without semicolon is a bit
00:29 - tricky one
00:29 - well the answer is you can just put the
00:34 - printf statement inside the if condition
00:38 - suppose here we write hash include' f e
00:42 - di u dot H which is the header file then
00:45 - int main which is the main function the
00:50 - starting point of any C program after
00:53 - that we write if statement and within
00:57 - the parent pieces we write printf hello
01:01 - world this is valid because printf hello
01:04 - world is going to print hello world on
01:08 - the output screen so if will be executed
01:12 - and since within the body of the if
01:14 - status in the braces we have not passed
01:18 - anything so no statement will be
01:21 - executed and the printf statement will
01:24 - print hello world on the output screen
01:28 - next question what our basic data types
01:32 - that are supported in free programming
01:34 - language we all know that in C there are
01:38 - different types of data types that are
01:40 - being coded now let us look at some of
01:43 - the basic data right there sighs and
01:46 - they range
01:48 - so first is short it occupies one byte
01:53 - of size now 1 byte is equal to 8 bits of
01:57 - data this means short will occupy 8 bits
02:01 - of data and it ranges from minus 128 to
02:05 - 127
02:07 - thus we can store signed values into it
02:11 - Tartus oh the
02:12 - negatives and the positives are possible
02:15 - to be stored in short datatype similar
02:18 - the shot is unsigned short which is
02:22 - having the same size as short but it
02:26 - will only store positive integers from 0
02:30 - to 255 next is care that is used to
02:34 - store character values whose size is
02:37 - also one byte and grain juice - 128 to
02:40 - 127 the difference between short and
02:44 - care is that short is used to store
02:46 - integer values ranging from minus 128 to
02:49 - 127 while on the other hand care will be
02:52 - used to store the character values whose
02:55 - ask I can't live from minus 128 to 127
03:00 - in the same way unsigned care which is
03:03 - also a one byte size will store values
03:07 - from 0 to 255
03:09 - Battersby asked I values from 0 to 255
03:13 - next we have integer which will occupy a
03:17 - size of 2 bytes and its range will be
03:20 - from minus 32,768 to positive 32767 it
03:30 - will be used to store integer values
03:33 - within this range similarly we have
03:37 - unsigned integer whose size is similar
03:40 - to that of the integer that is 2 bytes
03:43 - it will also be used to store the
03:46 - integer values but since it is unsigned
03:49 - integer so its range will be from 0 to
03:54 - 65,535 next we have long long is nothing
03:58 - but an extension of integer integer is
04:02 - used to store a definite range of values
04:05 - but if we are using a long data type
04:07 - then in that case the range will be
04:11 - extended and we will be able to store
04:13 - large integer values in log so the size
04:17 - of the log is also double the size of
04:20 - integer that is 4 by
04:22 - and it's range is minus two one four
04:27 - seven four eight three six four eight
04:31 - you positive you one four seven four
04:37 - eight three six four seven in the same
04:41 - way we have another data type that is
04:44 - unsigned long with is nothing but an
04:47 - unsigned version of log having the same
04:50 - size as four bytes and it's range is
04:53 - from zero to four to nine for nine six
04:58 - seven two nine five the next leader type
05:03 - that we have is float that is used to
05:07 - store decimal values in it if size is
05:11 - four bytes and its range is from 3.4 e
05:17 - -38 to 3.4 e + 38 that means that from
05:26 - three point 4 into 10 to the power minus
05:29 - thirty eight to three points 4 into 10
05:34 - to the power positive 38 is what is the
05:38 - range of this float data type double in
05:42 - the same way is simply an extension four
05:45 - Sloat its size is a bite and its range
05:50 - is one point seven e - 3 0 8 - 1.7 e + 3
06:00 - 0 8 in the same way we have another data
06:04 - type such as long double who sizes 10
06:09 - bytes and it is used to store again the
06:13 - decimal values but do even a higher
06:16 - precision than double its range is from
06:20 - 3.4 e - 4 9 3 2 - 1 point 1 e + 4 9 3 2
06:30 - that is - a very high level of precision
06:34 - so these are the basic data types that
06:37 - are supported in the sweet programming
06:40 - language next question how can you make
06:44 - an infinite loop in C so what is an
06:48 - infinite loop an infinite loop is one
06:51 - that keeps on executing up till the
06:54 - infinite number of possibilities
06:56 - it never stops its execution so here we
07:02 - are seeing an example that how can we
07:04 - make a for loop infinite loop in C so to
07:09 - make a for loop an infinite loop the
07:12 - omission of the condition statement
07:14 - because if there is no condition or if
07:18 - the condition is provided in such a way
07:20 - that it never evaluates to be false and
07:23 - is always true so the loop will continue
07:26 - till infinite possibilities so this is
07:30 - what we have done we have taken a perdu
07:33 - and simply written its syntax without
07:37 - passing any initialization condition
07:39 - without any condition and without any
07:44 - updation and inside the body of the for
07:47 - loop we have written a printf statement
07:49 - in which we have printed infinite loop
07:52 - so this message infinite loop will be
07:56 - printed in finite time on the computer
07:58 - screen
08:00 - next question name the storage classes
08:03 - in C so there are four storage classes
08:07 - in C these classes are or to register
08:11 - static and extern next question can a C
08:18 - program become wild or executed in the
08:22 - absence of a main function so as we know
08:26 - that main is the starting point of every
08:29 - C program the program will be compiled
08:33 - if there is no main function but it will
08:37 - not be executed to execute any C program
08:42 - or mains
08:43 - is required as the control will not know
08:46 - from where to start the execution
08:48 - because means is the starting point of
08:52 - every C program next question what is a
08:58 - free token
09:01 - free tokens are the smallest building
09:04 - block or smallest unit of a C program
09:08 - the compiler breaks a program into the
09:12 - smallest possible units which is called
09:16 - a token keywords constants special
09:21 - symbols operators and identify O's used
09:25 - in the C program I refer to us three
09:29 - tokens for example if we take int a
09:34 - equals 210 and then semicolon it is a
09:38 - valid C statement here int is a keyword
09:41 - which is token number 1 e is an
09:45 - identifier which is a variable name so
09:49 - it is another token equals is the
09:52 - assignment operator which comes under
09:55 - the category of operators so it's
09:57 - another token 10 is an integer value
10:01 - with a constant so it is also a token
10:05 - and semicolon which is kind of a special
10:08 - symbol that is the statement terminator
10:10 - so it is also a token so in this
10:15 - statement there are five C tokens which
10:19 - are the smallest unit and cannot be
10:22 - broken
10:22 - further next question what is the main
10:27 - difference between the compiler and the
10:29 - interpreter the answer is first we look
10:33 - at compiler it is used in C language it
10:37 - translates the complete code into the
10:40 - machine code in one go so whatever the
10:43 - source code is fed into the compiler in
10:46 - one go it translates the whole post code
10:49 - into the machine code
10:51 - the compliation process is faster next
10:55 - interpreter interpreter is using Java
10:59 - and other high-level programming
11:00 - languages it is designed to compile the
11:04 - code in a line-by-line fashion the
11:07 - process is slower than compilation so
11:11 - both compiler and interpreter are used
11:14 - to compile the source code into the
11:17 - machine code but the striking difference
11:19 - will start compiler translates whole
11:22 - code into one but the interpreter does
11:26 - the same process in a line-by-line
11:28 - fashion next question
11:31 - differentiate between clicks pH and
11:34 - gates vietri the answer is both the
11:37 - functions are designed to read
11:38 - characters from the keyboard but the
11:42 - main differences for guess pH it reads
11:46 - the characters from the keyboard but it
11:49 - does not use any buffers
11:53 - hence the data is not displayed on the
11:57 - screen so whenever the get finish
11:59 - function is being used it reads the
12:02 - character from the keyboard but since no
12:06 - buffer is used so the data will not be
12:08 - displayed on the computer screen
12:11 - next is the get create a function that
12:14 - Suites the characters from the keyboard
12:17 - and along with that it uses a buffer to
12:21 - store those characters so the data that
12:25 - is being entered into the gate Phe
12:27 - function will be displayed on the screen
12:30 - let us understand this with the help of
12:33 - an example here first of all we have
12:36 - declared a character type of variable
12:40 - then there is a printf statement please
12:43 - enter a character so this will be
12:46 - printed as it is on the output screen on
12:49 - the right side you can see the output as
12:51 - well please enter a character will be
12:54 - printed on the screen then there is a
12:57 - gate pH a statement since the gate pH
13:00 - does not users or offer
13:02 - so whatever the character
13:04 - we entered by the user will not be
13:06 - displayed on the screen instead the next
13:09 - printer statement will be executed which
13:11 - is your interval character is and the
13:14 - value of pH will be printed suppose in
13:17 - this case the user enters capital S so
13:21 - the message that would be printed on the
13:23 - output screen is your in DOS character
13:27 - is capital e next there is another
13:31 - printer statement please enter another
13:34 - character this time exp H E is used to
13:39 - accept the input and still uses a memory
13:43 - buffer so the character that is being
13:47 - entered by the user is displayed on the
13:50 - output screen here the user enters
13:53 - capital B and this capital B is printed
13:57 - on the output screen has a time of its
14:00 - entry after this the next printf
14:03 - statement your new character is is
14:07 - executed and the final output on the
14:10 - screen will be your new character is
14:13 - capital B so this is the difference
14:17 - between SCH and gate vhe in the C
14:21 - programming language next question is
14:25 - how can we store a negative integer in C
14:29 - so to store a negative integer the two's
14:33 - complement of that number is calculated
14:37 - first and then whatever the value is
14:41 - found it is stored inside the variable
14:44 - for example if we want to store minus 5
14:48 - then in that case the binary value of -5
14:53 - will be 1 0 1 1 so we need to find the
14:59 - ones complement of 5 the ones complement
15:03 - of 5 will be 1 0 1 0 after that one will
15:11 - be added to the ones complement of 5
15:14 - giving 1 0 1 1 which is nothing but the
15:22 - binary value of -5 next question what do
15:28 - you mean by downlink pointer variable in
15:30 - free programming so first of all we look
15:34 - that what is a pointer a pointer in free
15:38 - programming is used to point to the
15:40 - memory location of an existing variable
15:44 - if that particular variable is deleted
15:48 - but the pointer is still pointing to the
15:52 - same memory location then that
15:55 - particular point of variable is known as
15:58 - a dangling pointer variable so that's
16:03 - all