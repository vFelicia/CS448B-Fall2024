00:00 - okay so uh now we will
00:03 - jump right into with starting with
00:05 - kotlin so uh in this training uh we will
00:08 - like mostly structure this as we will uh
00:12 - study first about kotlin we will master
00:14 - kotlin and then we will
00:17 - go to the android studio and build some
00:19 - app
00:20 - okay so
00:22 - what is a program
00:24 - let's let's go to the basics
00:28 - so you can think of a program as a
00:30 - series of instruction
00:32 - for the system to perform some action
00:35 - okay so i give some instruction a series
00:39 - of instruction
00:40 - such as a is equals to this b is equals
00:42 - to this and then perform a plus b
00:45 - and then print what is a plus b so this
00:47 - is a program for example you could write
00:50 - a program that creates a birthday card
00:52 - in the program you could write an
00:54 - instruction to print congratulatory text
00:57 - or calculate someone's age from their
00:58 - birth year
01:00 - okay so that is a program
01:03 - what is a programming language
01:06 - just like you use human language to
01:08 - communicate with another person you use
01:10 - programming language to communicate with
01:12 - the operating system of the computer
01:14 - fortunately programming language are
01:16 - less complex than human languages and
01:19 - quite logical
01:20 - so you might be thinking that english or
01:22 - hindi is very easy why do we need to
01:24 - study c plus plus or kotlin or java
01:28 - they are
01:29 - not
01:30 - they are very typical so they are not
01:32 - typical when we will end this
01:35 - uh
01:36 - journey of our kotlin you you will be
01:39 - very you will be master in kotlin
01:42 - so
01:44 - and they are logical
01:46 - like when i say is equals to 5
01:48 - that means a is equals to 5 that does
01:50 - not mean anything else okay so android
01:53 - apps are written in kotlin programming
01:55 - language scotland is a modern
01:57 - language created to develop
01:59 - created to help developers write code
02:01 - efficiently with
02:03 - a few errors as possible
02:05 - okay so that's why we have choose kotlin
02:08 - so what was the creation of hotline why
02:10 - was
02:11 - uh you might have seen in the previous
02:14 - video
02:14 - that in 2019 the kotlin the kotlin was
02:18 - made as a
02:19 - official language
02:21 - for the app development
02:22 - so how the kotlin was created kotlin was
02:25 - invented to solve a developer's
02:26 - challenge of chat trend
02:29 - they needed a simpler tool than java to
02:32 - work with their main product called
02:34 - intellij idea
02:36 - totally written in it the guys
02:38 - investigated the alternatives stayed
02:40 - unsatisfied and decided to invent their
02:44 - own language so
02:46 - at the start
02:48 - the android apps were made in c plus
02:52 - and then they moved to java and they
02:54 - were pretty comfortable in java but what
02:56 - was the problem was the problem was the
02:58 - main problem was the java code in java
03:01 - was very redundant and there are many
03:02 - problems so
03:04 - one day google called
03:06 - zed brains
03:07 - that they should look into the matter
03:10 - so what jetbrains does did
03:13 - they invented their own language
03:16 - so cotwin was invented to solve
03:18 - developer challenge of jetbrains
03:21 - they needed a simpler tool than java to
03:23 - work with their main product called
03:25 - intellij idea
03:26 - the guys investigated the alternative so
03:29 - they invented their own language okay
03:33 - so the main key features of kotlin are
03:36 - the kotlin offer a number of advantage
03:39 - in using or learning it okay question
03:42 - programmers have access to all java
03:44 - frameworks and libraries while having
03:46 - the ability to write more clear and
03:50 - concise code so portland is like just a
03:52 - kid of java
03:54 - so it has all the frameworks all the
03:56 - libraries of java
03:58 - and it has a mod it is a modern language
04:00 - so it is a it has a less
04:03 - a clear and concise code
04:05 - they can use both languages while
04:07 - building a mobile solution
04:09 - and easily migrate their projects if
04:11 - needed so
04:12 - if i am writing a code
04:15 - in particularly in kotlin like i am
04:17 - building a
04:18 - mobile app
04:20 - uh so i can build a mobile app while
04:23 - using kotlin and java both
04:24 - simultaneously
04:26 - i can write one code in java
04:28 - another code in kotlin and mix matches
04:30 - if if needed
04:32 - okay so why
04:34 - are we using kotlin
04:37 - so the main
04:38 - reasons are
04:40 - kotlin is java based kotlin has a
04:43 - familiar program kotlin has string
04:45 - insertion
04:47 - kotlin uses autocast
04:50 - kotlin has arguments and equals
04:53 - kotlin has expression and property so
04:56 - i'll be explaining each of them what uh
04:57 - what does java base mean kotlin
04:59 - programming language line programming
05:01 - language is a
05:04 - is
05:06 - uh more recognizably uh like
05:09 - it has a
05:11 - java based
05:13 - programming language
05:15 - so
05:17 - it is more usable like java is a very
05:20 - old programming language and
05:22 - java environment and platform in kotlin
05:25 - basically runs on java environment and
05:27 - platform
05:28 - okay
05:29 - this means that existing
05:31 - java based project can seamlessly run on
05:33 - this language
05:36 - okay so what is familiar program so the
05:39 - syntax or and the basic structure of
05:41 - this programming language
05:42 - are extremely easy and familiar
05:46 - the reason being kotlin is java based
05:48 - programming language and the syntax
05:51 - makes use of
05:54 - domain object oriented programming
05:55 - domain
05:57 - okay these are the most familiar syntax
05:59 - and language of coding
06:02 - so
06:02 - what is string insertion view we will be
06:04 - looking into it in the
06:07 - next videos but i'll cover it
06:12 - so uh
06:15 - like
06:16 - um
06:18 - the string used in kotlin is same as
06:20 - java and very simple and familiar way of
06:23 - making changes in coding
06:26 - okay so the other three we will be
06:29 - looking into it in a while
06:31 - so just hang on
06:34 - okay so the features of kotlin
06:38 - okay huh
06:39 - we have
06:40 - uh
06:41 - learned we have studied the
06:45 - definition of kotlin or we have studied
06:48 - kotlin in the uh second video or the
06:51 - third video
06:52 - okay so it has very um much more
06:56 - technical terms like kotlin is a cross
06:58 - platform statistically typed general
07:00 - purpose programming language with type
07:02 - inference
07:03 - okay so we will be looking into these
07:05 - terms now
07:06 - so what is a cross platform language
07:09 - so a cross platform language can be used
07:12 - in any operating system so the code
07:14 - written in kotlin on windows can be
07:15 - executed on mac os as well as linux as
07:18 - well as
07:20 - any other operating system and vice
07:22 - versa
07:23 - okay
07:24 - and there is
07:25 - statistically type so what is a
07:27 - statistically typed
07:28 - language
07:30 - so a statically typed language is a
07:33 - language
07:34 - where variables variable types are known
07:37 - at the compile time such as java c or c
07:39 - plus plus in most of these languages
07:42 - type must be expressed in expressively
07:45 - indicated by the programmer
07:47 - okay so before compiling the code uh the
07:51 - we have we know the
07:53 - variables variable type use
07:56 - okay so this means that the language is
07:58 - able to tell the data type of any
08:00 - variable during the compile time and
08:02 - does not allow a variable to have
08:04 - values of different data types in a
08:06 - simple program
08:08 - so
08:09 - i have defined an integer a is equals to
08:12 - five
08:13 - so before compiling the program the
08:15 - compiler knows that a is an integer that
08:18 - simply means that
08:20 - okay so what is type inference
08:22 - this means that the language can
08:24 - automatically detect the data type
08:26 - so when i define any variable a is
08:29 - equals to 5 the language is able to
08:33 - able to detect the data type such as
08:36 - the data type of a is an integer
08:38 - okay what is a jvm java virtual machine
08:42 - so jvm is an extract machine
08:45 - it is a specification that provides
08:47 - runtime environment in which java byte
08:49 - code can be executed so we will be
08:51 - looking more into it in a while
08:54 - but
08:56 - overall
08:57 - jvm is a virtual machine an abstract
09:00 - machine
09:01 - that provides a runtime environment for
09:03 - java so java x java code is executed in
09:06 - it
09:07 - by it
09:10 - so that it enables
09:12 - the computer to run java programs or
09:14 - similar language such as kotlin that are
09:16 - also compiled by java bytecode so it
09:18 - helps run the program
09:21 - jvm are available for many hardware and
09:23 - software platform
09:26 - that is jvm platform dependent jvm is
09:28 - platform dependent
09:30 - okay
09:31 - so what are the operations of jvm the
09:33 - jvm loads code
09:35 - like i have written the code in the
09:36 - compiler what now the jvm loads the code
09:39 - the it verifies the code it executes the
09:41 - code and it provides the runtime
09:43 - environment
09:45 - okay so that's all for this video stay
09:47 - tuned
09:48 - where do we write code in the kotlin
09:49 - language
09:51 - so i have told you that we use the ide
09:54 - as the android studio for development of
09:56 - android apps that is xml and kotlin both
09:59 - work simultaneously on android studio
10:02 - and now
10:05 - we have to focus only on kotlin
10:07 - so therefore we need an another ide for
10:11 - writing only hotline code and that id is
10:14 - intellij idea
10:16 - so what is intelligent idea used for
10:18 - intellij idea is an integrated
10:21 - integrated development environment ide
10:24 - or jvm languages
10:26 - including java kotlin designed to
10:28 - maximize developers productivity
10:31 - okay
10:32 - so just like android studio uses sdk
10:36 - software development kit similarly
10:38 - intellij idea uses jdk java development
10:40 - kit or
10:42 - that we
10:43 - we will be installing in the next video
10:47 - and i'll be explaining what jdk is in
10:50 - the next video so now let's move
10:52 - to install intellij idea and for linux
10:55 - and mac users
10:56 - just note that after opening the
10:58 - installer all steps would be the same
11:01 - okay
11:02 - so
11:03 - just go to the
11:05 - google
11:10 - and
11:14 - type intellij idea
11:20 - intelligent idea download
11:23 - click the first link
11:25 - download intellij idea
11:30 - and
11:31 - download the community version for mac
11:33 - os and linux user
11:36 - continue from here and for windows user
11:38 - download the community version
11:41 - okay
11:42 - so we will wait for it to download
11:48 - okay so
11:49 - the installer is
11:51 - downloaded for the
11:54 - intellij idea we will open it
11:58 - the exe file
12:04 - the setup is loading
12:10 - okay click yes
12:21 - click next
12:23 - next
12:26 - uh here click intelligent idea community
12:29 - edition
12:31 - and here click dot kt
12:36 - and then click next
12:38 - install
12:41 - so we will wait for the
12:44 - intellij idea to install
12:47 - ok so the
12:49 - ide has been installed
12:51 - here click on run
12:53 - and then finish
12:55 - so now we will just wait for
12:58 - the
12:59 - intelligent idea to run
13:07 - so here is the
13:08 - intellij idea community edition
13:12 - you can see my version here 2021.3 is my
13:15 - version
13:17 - and
13:18 - jetblin is the company
13:20 - for developing it
13:23 - so here it is already
13:26 - loading my project
13:31 - okay so what you have to do is
13:35 - you have to
13:36 - create on file
13:42 - you have to create on file
13:45 - and new
13:46 - and project
13:51 - so you might be looking at a screen like
13:53 - this
13:54 - so what you have to do is
13:56 - you just have to
13:58 - go to
14:00 - kotlin
14:02 - and then
14:04 - you have to choose a
14:07 - any uh folder
14:12 - okay
14:25 - so
14:25 - i have to choose any
14:28 - folder here
14:30 - i've just made a new folder kotlin
14:34 - and i choose this folder
14:37 - okay
14:38 - and i'll name my project as project one
14:41 - or new
14:42 - project new project
14:50 - and just
14:51 - click on next
14:54 - finish
15:01 - and the gradle is
15:03 - finishing
15:04 - up the process and
15:08 - it loaded our new project
15:12 - okay so it has already load a
15:14 - load of file
15:16 - with the function of hello world
15:20 - so what i'll do is i'll just remove it
15:22 - and here you have the main.kt file where
15:25 - you can write the code
15:27 - okay so we will be writing the code
15:30 - uh
15:31 - in next of our videos right now we have
15:34 - not installed the
15:36 - jdk in our system so
15:40 - if we have
15:42 - since if we have if we would run the
15:45 - code itself it will not be running
15:48 - okay
15:50 - and
15:50 - let the gradle
15:52 - build all the files
15:55 - okay then you can close the
15:57 - intellij idea thank you for watching
15:59 - this video
16:00 - so in this in the previous video
16:03 - we have seen that we have to write code
16:05 - in kotlin and
16:07 - we have installed intellij idea
16:10 - but
16:11 - as i said
16:12 - we require
16:14 - just as just like we require
16:16 - uh sdk for android studio we require jdk
16:19 - for
16:20 - um
16:22 - intelligent idea so what is jdk
16:25 - jdk or the java development kit is a
16:27 - cross platform software development
16:29 - environment that that offers a
16:31 - collection of tools and library is
16:33 - necessary for developing java based
16:34 - software application and applets so i'll
16:38 - explain in its basic words
16:41 - so i have given you an analogy for sdk
16:44 - if you remember
16:46 - like just like we
16:48 - need groceries so
16:51 - you can think of jdk or sdk as grocery
16:54 - store
16:55 - and you can think of the intellij idea
16:58 - or the ide as
16:59 - kitchen
17:01 - so we need groceries from the grocery
17:03 - store to prepare food in the kitchen
17:06 - similarly we need
17:08 - some libraries or some tools from the
17:10 - jdk or the sdk to prepare code in here
17:14 - to develop
17:15 - here to run a code in
17:18 - the ide
17:19 - okay so the jdk is one of the three core
17:22 - technology package used in java
17:24 - programming
17:25 - along with jvm and jre jvm is the java
17:29 - virtual machine jre is the java runtime
17:31 - environment
17:32 - okay
17:34 - so the jvm
17:37 - is the java platform component that
17:39 - executes program
17:42 - okay so jvm is is the uh rupees player
17:46 - plays role in the execution of program
17:48 - the jre is the on disk part of java that
17:52 - creates the jvm
17:54 - okay so basically the jvm jre
17:57 - jvm is a part of jre
17:59 - and the jdk allows developer to create
18:01 - java programs that can be executive and
18:04 - run by the jvm and jre
18:07 - so you will be
18:08 - it will be more pretty clear by this the
18:11 - jdk contains the gre and some
18:13 - development tools the gre contains the
18:15 - jvm and some library classes and the jvm
18:21 - executes the code
18:24 - the distinction between jdk and jre is
18:26 - that jdk is a package of tool for
18:28 - developing java based software whereas
18:30 - jre is a package of tool for running
18:33 - java code
18:34 - so the jdk is a tools for developing the
18:37 - java based
18:38 - software and jre is for running
18:42 - okay
18:43 - the jdk requires gre because running
18:45 - java program is a part of developing
18:47 - them so now we will be proceeding
18:50 - to install the
18:53 - jdk before installing the jdk
18:56 - go to
18:57 - this pc or my computer click on
18:59 - properties
19:00 - and we are just seeing if your operating
19:03 - system is a 64-bit or a 32-bit so my
19:06 - operating system is a 64-bit operating
19:09 - system if you are is yours is a 34
19:11 - 32-bit please note that
19:13 - now we will go to google
19:16 - and we will type
19:19 - java
19:22 - sorry jdk
19:24 - for
19:26 - windows
19:28 - okay
19:29 - so we will click the link of java
19:31 - downloads by oracle
19:33 - and if you are using linux or mac os
19:36 - please download from here for windows
19:38 - user please go to windows tab and
19:41 - for 64 installer download the 64
19:44 - installer
19:45 - and here it is downloading
19:48 - so
19:50 - while
19:51 - that downloads for mac os users please
19:54 - download from here
19:55 - and for linux users
19:58 - install the
20:00 - jdk from here
20:02 - so as it is installed
20:04 - open the jdk
20:15 - click on yes
20:23 - wait for the installer to open
20:29 - click on next
20:31 - click on next
20:33 - and the
20:36 - java is installing on your
20:38 - device
20:40 - so now as java is installed successfully
20:43 - we have to close this
20:44 - close the
20:46 - close this also so now we what we have
20:49 - to do is
20:51 - we have to check where java is and on is
20:53 - in our system or not so what we'll do is
20:55 - we will go to the run and type cmd here
20:59 - okay and we will type the command java c
21:04 - so it is directly
21:05 - installed in my
21:08 - computer but if you are not seeing this
21:10 - if you are saying that it is not a
21:12 - recognizable command then what you what
21:14 - you do is
21:15 - you will go to this pc or my computer
21:19 - okay you will
21:20 - go to windows c
21:23 - you will go to the program files
21:26 - and find java in it
21:29 - click on the jdk
21:31 - click on the bin folder
21:33 - copy the path from here
21:34 - ctrl c click on the above part and ctrl
21:37 - c
21:38 - okay go to this pc again
21:42 - go to the properties
21:45 - and here go to advanced system settings
21:50 - in advanced system settings go to
21:51 - environment variables
21:54 - so
21:55 - if you are not seeing it
21:59 - it must be not in your environment
22:01 - variable so what you
22:03 - want to do is
22:05 - in the user variables click new and here
22:09 - create java and give the variable value
22:12 - this
22:12 - okay then click ok
22:15 - and then click ok and ok
22:18 - and now we will when will you when you
22:20 - will type
22:21 - in the cmd command
22:23 - java c
22:24 - then it will be showing this
22:27 - okay in this video we are going to
22:30 - write our first program which is hello
22:33 - world
22:35 - program
22:36 - and
22:37 - uh
22:39 - so we have opened intellij idea for that
22:41 - and
22:42 - well
22:43 - the first the program structure goes
22:45 - like function one main
22:48 - i'll be explaining the program to you in
22:50 - a while
22:52 - parent allen
22:54 - is a command for printing a statement
22:57 - and hello world
23:00 - okay so when i run this program
23:04 - this
23:05 - gives me okay so you can run a program
23:07 - form here and here also so i prefer
23:10 - running program from here
23:12 - okay so this gives me an output as hello
23:15 - world
23:17 - okay so what it does is
23:19 - like uh
23:20 - what i will be under explaining you the
23:24 - part of the program so what is the fun
23:26 - the fun is a word in kotlin programming
23:29 - language or many programming language
23:31 - and fun stands for function
23:34 - a function is a section of program that
23:37 - performs a specific
23:38 - task so i can create another function in
23:41 - the same program so
23:44 - this is of the fund represents a
23:45 - function
23:46 - and main main is the name of this
23:49 - function this particular function has a
23:51 - name main
23:53 - function have names so they can be
23:55 - distinguished from each other the
23:57 - function is called main because it is
24:00 - the first or the main function
24:02 - that is called when you run the program
24:03 - so when i whenever i run the program
24:06 - uh it search for the main function and
24:08 - that is run
24:10 - every time you
24:12 - run the the fund main
24:15 - is
24:17 - the function mean function
24:20 - okay the function name is always
24:22 - followed by a parenthesis this is the
24:24 - parenthesis open and close parenthesis
24:26 - inside the parenthesis you can put uh
24:28 - information
24:30 - for the function to use
24:32 - okay so whatever information the
24:34 - function is using you can put it there
24:37 - now
24:38 - there are curly braces
24:39 - outside this fundament
24:41 - so these curly braces
24:43 - inside these curly braces we are we
24:46 - write the task we have to perform
24:50 - now
24:51 - this
24:52 - line prints the
24:54 - text hello world
24:56 - okay print talents tells the system to
24:59 - print a line of text
25:01 - inside the parenthesis these parentheses
25:05 - okay
25:07 - you put the text to be printed notice
25:10 - that the text we printed is surrounded
25:12 - by quotes these are the codes
25:14 - this tells the system that everything
25:16 - inside the quotation mark should be
25:18 - these this should be everything inside
25:20 - the quotation marks will be printed
25:22 - exactly as it is
25:25 - so to actually print the text the whole
25:27 - printer instruction has to be inside the
25:30 - main function okay
25:31 - so so far that is clear
25:35 - now
25:37 - we will be learning more about the print
25:39 - function what about
25:41 - we don't write
25:42 - ln here when what what happens when we
25:45 - run this program
25:46 - so when we run this program the we will
25:49 - find that the output is same to same
25:51 - there is no change in the output
25:53 - so what is the difference between print
25:54 - and print ln
25:56 - when i add one more line here and that's
26:00 - a print
26:03 - hi
26:05 - and
26:06 - when i run this program
26:07 - you can you will find the difference
26:11 - so
26:13 - this
26:14 - this
26:16 - high is printed just right after the
26:18 - hello world even if i have
26:20 - wrote and then wrote it in the next line
26:23 - and when i
26:25 - give the command print ln here then what
26:27 - will happen
26:30 - so i have run this program
26:33 - and
26:34 - we will let it compile
26:36 - now you can see that high is printed on
26:38 - the next line so we can conclude that
26:40 - the ln
26:41 - in the println stands for uh next line
26:45 - or we can say
26:46 - when we use println the
26:49 - the the text inside the quotation mark
26:51 - is printed in the next line
26:55 - so for this you can
26:57 - also use the
26:59 - black backslash n or the escape sequence
27:03 - so
27:04 - i'll be demonstrating that so in this
27:07 - code under this quotation mark when i
27:10 - use black
27:11 - backslash and here
27:12 - and run this program
27:16 - so
27:16 - here we can find that
27:18 - again the high is under the hello world
27:22 - so what this backslash n command tells
27:24 - you or the escape sequence tells the
27:26 - program when i enter into the print
27:29 - hello world and then this backslash n
27:31 - tells me to go to the next line and then
27:34 - print hi
27:35 - okay so that that's about the backslash
27:37 - n command
27:39 - now we will talk about some comments in
27:41 - kotlin so
27:43 - i have to write here that this is
27:46 - my first
27:49 - code
27:51 - so how i write here and
27:53 - when i write the this thing here this
27:56 - text here this has no effect on the code
28:00 - so
28:01 - after using this to slash
28:07 - this program this this sentence is not a
28:09 - part of code so the symbol slash slash
28:14 - represents a single line command which
28:16 - tells the compiler to ignore everything
28:18 - from this symbol to the end of the line
28:21 - okay typically signal time single line
28:23 - comment is used to make a quick comment
28:25 - about a single line of code
28:27 - so
28:28 - comments are very important in any code
28:30 - because after some time after one month
28:33 - two month or three month when i will be
28:35 - looking in the code i will not be
28:36 - recognizing anything in it
28:39 - or i can say that when i
28:41 - when me and my friend are working on a
28:43 - project
28:45 - and i have to share my codes code with
28:47 - him
28:48 - so
28:49 - he also should understand the
28:52 - thing which i have used in code and why
28:53 - i am used use that in code so that's why
28:57 - these are important comment okay so what
29:00 - if i have to
29:01 - write a multi-line command
29:04 - such that i have to
29:05 - write
29:06 - three four lines of command
29:09 - so i have you i will use this this
29:15 - symbol
29:16 - and this pair of symbols denotes a
29:18 - multi-line comment
29:20 - so it tells the compiler that everything
29:22 - that comes under this and this
29:25 - symbol should be ignored
29:28 - okay
29:30 - so these are about the
29:32 - comment in the last video we have
29:35 - write our first program and printed
29:38 - hello world
29:39 - so
29:40 - now what we are going to going to do we
29:42 - are going to
29:44 - study how to initialize a variable
29:47 - or a value in kotlin
29:49 - so
29:49 - now we are going to create a new file so
29:51 - we are going to file
29:53 - and then go on new
29:55 - then go on kotlin class comma file slash
29:58 - file
29:59 - click on that
30:00 - click on file
30:02 - i am going to name this as variable
30:06 - and then hit enter
30:08 - okay
30:09 - so
30:10 - firstly i am going to
30:12 - write a program fun main
30:16 - where a
30:17 - is equals to
30:19 - 20
30:21 - okay so uh i have mentioned in the last
30:23 - video that i prefer to run program from
30:26 - here not here so what happens when i run
30:30 - the program from here
30:32 - so when i run program from here
30:34 - um just let it build
30:37 - yeah so when i run program from here uh
30:40 - please note that the last program we
30:42 - wrote gets executed
30:44 - the hello world program
30:46 - and when i run program from here
30:48 - so the variable kt program runs and
30:52 - process finished and exited with code 0.
30:55 - so
30:56 - now we will discuss how to declare a
30:58 - variable in kotlin
30:59 - so to declare a variable in kotlin
31:02 - either where or val keyword is used so
31:06 - i have wrote where keyword and now i'll
31:09 - use
31:10 - val keyword
31:13 - okay
31:15 - so these are two ways
31:17 - for declaring a variable
31:21 - so uh by a while mentioning
31:25 - a kotlin or starting with kotlin i have
31:27 - mentioned that kotlin is a statically
31:29 - typed language and it has a type
31:31 - inference so what does what did i mean
31:34 - by statically typed so before running
31:36 - the program
31:37 - before compiling the program
31:39 - uh the type of
31:41 - the variable is
31:43 - explicitly known by the compiler
31:47 - so
31:48 - when i compile the program the type of
31:50 - the variable is known by the compiler so
31:51 - the type of this is end i will be
31:53 - explaining that in a while
31:56 - and
31:57 - kotlin has a type inference so what does
31:59 - that mean
32:01 - so when i hover over
32:03 - a
32:04 - so it tells me variable a is int
32:08 - so in kotlin
32:11 - the variable automatically
32:13 - tells its types that what type it is
32:15 - variable or value
32:18 - okay so
32:21 - now what is the difference between where
32:24 - and well
32:25 - so val has an immutable reference so
32:28 - when i declare a
32:30 - val value so
32:32 - when i go and change the value of b to
32:35 - 13
32:37 - okay
32:38 - so
32:38 - it gives it
32:40 - underlines it by
32:42 - red and gives an error
32:45 - so what it even hour over it and it says
32:48 - that well cannot be reassigned
32:50 - so i am going to come to that and hit
32:54 - alt plus enter
32:56 - and when i hit alt plus enter it gives a
32:59 - give us a number of choices
33:01 - to proceed with and i click enter so
33:04 - what it does is it
33:06 - converts val to where so that i can
33:10 - reassign the value
33:12 - okay
33:13 - so we have
33:16 - now discovered what is where and well
33:18 - difference
33:20 - so where vary where variable has a
33:22 - mutable reference so the variable
33:24 - declared using where keyword can be
33:27 - changed later in the program
33:30 - and the variable declared using val
33:32 - keyword cannot be changed and
33:36 - it is similar to final variable in java
33:38 - if some of you might have
33:40 - learned java
33:42 - okay
33:43 - so uh
33:45 - what if i don't
33:47 - know the initial value of the variable
33:50 - so here i have initialized the variable
33:52 - a with some value but what if i don't
33:55 - know its value so
33:57 - if i have a variable
34:00 - name
34:01 - okay and i don't know what its value is
34:04 - but i do know it holds a string
34:07 - so i'll
34:08 - mention a colon
34:10 - and then type string
34:13 - so here we have created a variable with
34:15 - a type string
34:17 - that can be defined later at any point
34:20 - so now i want that the name should have
34:23 - a value
34:26 - pk
34:28 - so i'll give that give that the value
34:31 - okay
34:32 - so it now you can see that it is
34:34 - underlining is played by
34:36 - yellow so
34:38 - let's see what it is telling so now we
34:41 - are going to hit alt plus enter
34:43 - and it's saying that
34:46 - uh
34:46 - created to value because it is not going
34:49 - to change so it is
34:52 - uh
34:53 - saying that it we can create two value
34:55 - also
34:55 - uh
34:56 - now when i hit alt plus enter on going
34:58 - to the name it
35:00 - created the initialization
35:02 - initialization within itself
35:04 - why did it do that because
35:09 - the name was assigned just after the
35:13 - variable declaration so it don't have a
35:16 - sense and it makes the course code of
35:18 - more line
35:20 - okay
35:22 - so
35:24 - now we have understood that how to
35:26 - declare a variable
35:28 - there are two ways well and where
35:30 - keyword
35:31 - and uh how to declare it beforehand and
35:34 - not initialize it
35:36 - okay so how does that this code work so
35:38 - we are going to under a function which
35:40 - is which is has a name main
35:43 - okay so when i go to this where a equals
35:47 - to 20 so it creates a variable
35:50 - and a is the identifier by which this
35:53 - value has been identified
35:55 - okay so uh it is uh like a common uh
36:00 - nomenclature we follow
36:02 - for naming
36:04 - the identifiers so what we do is
36:06 - like
36:07 - when a
36:09 - variable has a short reference like in a
36:12 - function
36:13 - where the variable is used and at the
36:15 - end of function the variable is
36:17 - destroyed so we we can use their short
36:19 - variable such as a b c i
36:22 - yeah in for loop we use a variable and
36:25 - it is destroyed after the for loop is
36:27 - concluded so we can use short variable
36:30 - sort identifier there but
36:32 - when we
36:34 - make a large code so we
36:38 - we should it is a common practice that
36:40 - we should name the variable that uh such
36:44 - that we should name the identifier such
36:46 - that uh when we come after three or four
36:49 - months through the code three or four
36:51 - months when we wrote the code
36:53 - so we should know that uh why why we
36:55 - created that variable and what the what
36:58 - that variables variable hold
37:02 - so uh i'll just introduce some common
37:05 - practice such that
37:07 - i have a application
37:10 - that stores a stores the mobile number
37:14 - so
37:15 - what i can do is i can
37:18 - create a identifier such as
37:20 - mobile number mobile
37:24 - number
37:28 - in from application
37:34 - okay so it is a string that initially
37:36 - holds
37:37 - a number
37:38 - 99999 okay so uh
37:42 - what i did here is
37:43 - i
37:44 - started with a
37:46 - small letter
37:48 - and then
37:49 - after every word i created a capital
37:52 - letter
37:53 - okay
37:54 - so it's just a common practice we
37:56 - recommend you to
37:58 - make your identifiers in this way okay
38:00 - otherwise that's fine you can use
38:02 - underscore
38:03 - so
38:05 - your
38:06 - variable identifier should start with a
38:10 - small case letter and it should not
38:13 - contain
38:14 - any other special letters under then
38:18 - any other special letters
38:20 - other than
38:21 - underscore
38:23 - so again you only use underscore and
38:25 - your variable identifier cannot start
38:28 - with an underscore
38:30 - okay so i hope that you like this video
38:33 - in the next video we are going to cover
38:35 - the data types
38:36 - and then we will proceed further thank
38:38 - you
38:42 - in the last video we have discussed
38:44 - about the variables in kotlin
38:47 - so now we are going to move further and
38:50 - discuss the data types
38:52 - in kotlin
38:56 - okay
38:57 - so
38:59 - as i have already mentioned quarterly is
39:01 - a statically typed language
39:04 - that is the variable of
39:07 - the variable is
39:08 - already known during the compile time
39:14 - so
39:15 - there are
39:16 - a few type of
39:18 - variables in kotlin so i'll just
39:22 - start a function
39:23 - so when i uh so there are
39:27 - four mainly four types there are numbers
39:30 - there are characters
39:33 - there are booleans
39:35 - and there are
39:37 - arrays
39:39 - i'll cover them one by one
39:42 - so firstly i'll go to the number type so
39:46 - number in kotlin are similar to java and
39:48 - any other programming knowledge a
39:50 - programming language
39:51 - so there are six built-in types
39:53 - representing number so so the six are
39:56 - byte short and
39:59 - long
40:00 - float and double
40:01 - so out of them middling we were we will
40:04 - be using int and double
40:07 - most of the time
40:10 - so what is byte
40:12 - so i can create one
40:16 - byte for you so i'll create a val
40:19 - range
40:22 - and i'll mention it's type byte
40:26 - i'll mention it as 112.
40:29 - so
40:31 - the byte is a
40:32 - is one byte is eight bits you might
40:35 - already know that so
40:37 - there are totally eight bit
40:40 - and eight sign bit to two's complement
40:43 - integer
40:44 - so byte data can have values from minus
40:47 - 128 to 127.
40:50 - so when i uh have a
40:53 - concise
40:54 - data
40:55 - and it has a concise value between 0 to
40:58 - 100 or such that then i use byte so what
41:01 - it does is instead of using an integer
41:03 - or a long end or a double so it
41:07 - it concise the code in very small space
41:10 - it requires a very less space
41:13 - so uh when i assign it a value of 200
41:18 - so it gives it shows and red underline
41:20 - and when i hover over it it says that
41:23 - the integer lateral does not conform
41:26 - the expect to the expected type byte so
41:28 - what it says basically it is uh it is
41:31 - out of the range out of the bound so
41:33 - when i go and
41:35 - print
41:37 - the
41:38 - range
41:40 - so it will be
41:44 - printing 1 2 as we expect so
41:53 - yeah it prints 112
41:56 - okay so we will move on and next is
41:58 - short under the number the short is a
42:01 - data type having a 16 so i'll mention
42:05 - here
42:05 - it is having
42:07 - eight eight bit eight bit one bit is
42:11 - eight one byte is eight bit
42:13 - so the short is having
42:16 - uh
42:18 - the
42:19 - the values can be assigned to a 16-bit
42:22 - 16-bit signed
42:24 - uh
42:26 - signed complement integer two's
42:28 - complement integer so the the data as
42:31 - short data type can have values from
42:33 - minus 3 2 7 6 8 2 3 2 7 6 7 we don't
42:38 - have to remember that or know that just
42:41 - for knowledge sake i am telling you this
42:43 - so the short has a
42:46 - capacity
42:47 - or we can say
42:49 - it uses 16 bit data
42:52 - okay
42:53 - so
42:54 - next we will move to enter so end is a
42:57 - 32-bit signed two's complement integer
43:01 - and mainly we will be using in
43:04 - uh most of our codes
43:06 - so in data type can have values from
43:08 - minus to the power 31
43:10 - to 2 to the power 30 with 1 minus 1
43:13 - okay so any
43:15 - value i assigned to
43:17 - a
43:19 - is by default stored as an int and i
43:22 - hover over a it shows that it is an int
43:25 - okay so it is also a default
43:27 - value
43:30 - so
43:32 - next is long
43:34 - so what happens when i have a integer
43:37 - of value more than 2 to the power 31
43:40 - so we can store it in
43:42 - long so basically long has a 64
43:46 - bit signed two's complement integer
43:49 - okay so when i have a long integer we
43:52 - will store it as long so the keyword
43:55 - used for it is i'll just mention
43:59 - one value
44:02 - say longint
44:05 - and
44:06 - i'll mention it as long
44:10 - and it can have any value okay
44:14 - so
44:14 - moving on we have double
44:17 - so double is a
44:20 - data type with double precision
44:22 - of 64-bit floating point
44:27 - so whenever i define any
44:31 - decimal as a
44:34 - value
44:35 - suppose 1.23 so it automatically
44:39 - is defined as a
44:42 - double
44:44 - okay as we can see here
44:47 - so
44:48 - if i print decimal it will be printing
44:51 - one point two three
44:53 - now what is float
44:55 - we have seen about double the double is
44:57 - also 64 bit so float data type is a
45:01 - single precision 32-bit floating point
45:05 - okay
45:06 - so
45:08 - there was end that was getting by
45:10 - default assigned and there was byte and
45:12 - short
45:14 - that concise the storage so whenever we
45:18 - want to
45:19 - acquire it less storage we can use float
45:22 - so how to define float
45:24 - so we can define
45:26 - it as
45:27 - well
45:29 - decimal
45:32 - float
45:37 - in this way also
45:43 - okay
45:44 - but
45:46 - so we could have uh
45:48 - by
45:49 - the
45:50 - uh
45:51 - by the
45:52 - thing we are going to
45:54 - be seeing
45:55 - like we
45:56 - define it in this way but it is not true
46:00 - so what i what if i have to define a
46:03 - float so what i do is i just
46:06 - define it as decimal and then put f
46:13 - so what it does is it convert it convert
46:16 - it to float so it is now a float
46:19 - so when i print
46:24 - decimal
46:26 - float so what it does is it will be
46:29 - printing 1.23 when
46:32 - only 1.123 and not the f
46:35 - so
46:36 - what it says is it is
46:38 - a float
46:39 - okay and nothing else
46:42 - so
46:45 - we have used
46:47 - 1.123 f instead of 1.123
46:50 - in the above in the program it is
46:52 - because
46:54 - 1.123 is a double literal and you cannot
46:57 - assign double value inside a type of
46:59 - float
47:01 - okay so i can
47:03 - now i can here mention float
47:06 - so it will not giving any error
47:09 - okay
47:12 - so
47:13 - what if i am not sure about the
47:16 - uh
47:16 - the
47:18 - what if i am not sure about what number
47:20 - value
47:22 - a variable will assign in the program so
47:24 - i can what i can do is i can use
47:26 - a number
47:27 - data type
47:29 - so
47:30 - i will
47:31 - define where test
47:33 - and assign it number data type
47:37 - okay so i can
47:39 - put anything into like i can put a
47:42 - string
47:43 - into
47:44 - the okay sorry i can put a string into
47:47 - test
47:51 - i can put a integer into text
47:54 - oh sorry number so i can put an integer
47:56 - into test i can put a decimal into test
47:59 - i can put anything into test if i have
48:01 - design defined it data type as number
48:04 - so now we have completed our numbers
48:06 - data type now we will move on to
48:08 - characters
48:10 - to represent character and kotlin
48:12 - uh care data types are used so
48:16 - uh what i'll do is i'll just create a
48:18 - letter where
48:21 - letter
48:22 - and
48:24 - what i do is i define its
48:27 - value as scale
48:29 - so the character type is used
48:31 - so i can assign it any
48:35 - character so please note that the
48:37 - character will be in single quotation
48:39 - marks
48:41 - okay
48:44 - so i have defined a character now the
48:46 - next data type is booleans so what
48:49 - booleans are booleans are simply
48:52 - either true either false they have only
48:54 - two possible values
48:56 - so uh when i define a boolean variable
49:01 - boolean
49:05 - so i'll name it as flag
49:08 - and it has a data types boolean
49:11 - so i can either
49:14 - give flag value
49:16 - a true true e2
49:19 - okay
49:20 - or a
49:21 - false
49:22 - okay
49:24 - so it has only two values
49:27 - so booleans are used generally used in
49:29 - decision making statement that we will
49:31 - be using in our later discussion
49:34 - okay then further we have arrays
49:38 - so we will be discussing areas in a
49:40 - separate topic but just to define
49:42 - it an array is a container that hold
49:45 - value of
49:46 - of one single type for example you can
49:48 - create an array that can hold 100 values
49:51 - of end time
49:52 - okay then we have string
49:54 - so just for defining purpose i will
49:56 - define a string like val
49:59 - name i have already defined it but okay
50:03 - so
50:04 - this is
50:05 - my name
50:07 - okay so please note that the string must
50:10 - be in double quotation mark
50:13 - okay thank you for watching this video
50:15 - we have now covered the data types in
50:17 - kotlin
50:20 - in this video we are going to cover the
50:23 - operators in kotlin
50:27 - so i have already listed the type of
50:29 - operators and the operators
50:32 - here so the first type of operators are
50:35 - arithmetic operators
50:38 - so here is the list of arithmetic
50:39 - operators the first one is the addition
50:43 - so whenever i use the plus sign uh we
50:46 - are going to use it for addition so the
50:49 - addition can be of two integers or it
50:52 - can be of
50:53 - two strings also it is known as string
50:56 - uh consent concat concatenation and we
50:59 - will be uh knowing about it in a while
51:02 - so the another arithmetic operator is
51:05 - the minus sign or the subtraction
51:08 - so it is a subtraction of subtraction
51:09 - operator
51:10 - when i
51:12 - use it it generally subtract one integer
51:15 - from other or one variable from other
51:17 - okay other is the multiplication
51:20 - operator
51:21 - okay it is self-explanatory so when i
51:24 - use it it is used to multiply the
51:28 - data type the other is
51:30 - division data type so
51:32 - whenever i use the division operator so
51:35 - whenever i use the
51:37 - slash
51:38 - so it generally means that we have to
51:41 - define we have to divide
51:43 - one variable from other so here
51:45 - interesting part is the
51:47 - the percentage sign or the modulus
51:50 - operator
51:51 - so the modulus operator retains uh
51:54 - returns the
51:56 - remainder
51:57 - so i'll just make a function and explain
52:01 - all this to you
52:03 - so
52:04 - i will create a value
52:08 - a
52:08 - equals to 15
52:11 - and
52:12 - b equals to
52:15 - 5
52:17 - okay so
52:19 - i'll just print
52:21 - all these
52:23 - the result of all these operators so a
52:26 - plus b
52:28 - and i'll just
52:30 - copy it
52:36 - okay
52:38 - so
52:40 - plus minus
52:43 - multiplication
52:45 - division
52:46 - and the modulus operator
52:49 - so you can already
52:51 - guess the result and
52:53 - we will be seeing it in a while so the
52:56 - result of this will be
52:58 - 20 the result of this will be 10 the
53:00 - result of this will be 15 into 5 the
53:03 - result of this will be 15 divided by 5
53:05 - that is 3 what will be the result of
53:07 - this
53:07 - the result of this will be 0 so it
53:10 - returns the
53:13 - the
53:14 - remainder when a is divided by v
53:18 - so
53:19 - i'll just
53:21 - so these are explainable what i'll do is
53:24 - i'll
53:25 - make it 17 here and run the program
53:27 - again
53:29 - so now what will be the
53:31 - uh well the result the printed so it is
53:34 - 2 so when 17 is divided by 5
53:38 - it is 3 times 5 plus 2 so the remainder
53:41 - is 2 so the result of the modulus
53:43 - operator is 2
53:44 - okay i hope it is clear so moving on we
53:48 - have
53:49 - comparison operators
53:54 - so okay before that
53:57 - okay
53:58 - so uh we have comparison operators
54:02 - so the first one is
54:04 - uh we
54:05 - the
54:07 - the
54:09 - less than sign
54:11 - so whenever
54:12 - uh a
54:13 - is less than b so i'll just make
54:18 - so can you guess what will be the result
54:21 - of n comparison operator
54:24 - it will be a boolean
54:27 - so whenever i'll compare
54:29 - a less than b
54:33 - okay so when i run this program
54:36 - what will be the result
54:38 - is a is less than b no so the result
54:41 - will be false okay so mostly the result
54:45 - of the comparison operator is a boolean
54:48 - so first is less than operator second is
54:49 - the greater than operator third is the
54:52 - less than or equals to operator okay
54:54 - fourth is the greater than or equal to
54:56 - operator this is the equal to equal to
54:58 - operator so it's check whether a is
55:01 - equals to b or not is equal to operator
55:02 - this is this is is not equal to operator
55:05 - so
55:06 - when i define both as 5 and 5
55:12 - and
55:13 - when i
55:15 - do this println a is equals to equals to
55:17 - b so what will be the result what will
55:19 - be the output so the output would be
55:21 - true as a is equals to b
55:24 - okay
55:25 - so these are the comparison operators
55:29 - now we will move on to the
55:32 - assignment operator
55:34 - so we have already used assignment
55:36 - operator here
55:37 - okay
55:39 - so the assignment operator used here is
55:41 - the
55:42 - equal to operator
55:44 - okay we have also plus equal to minus
55:46 - equal to into equal to divided by equal
55:49 - to and
55:50 - modulus equal to
55:53 - okay so what are the
55:56 - basic functionality of this
55:58 - so i'll explain that
56:00 - so what if i
56:02 - create a variable x which is equals to
56:07 - uh
56:08 - a
56:10 - which is
56:11 - equals to a okay so i can do that
56:15 - now i'll print the value of
56:19 - println
56:20 - x
56:22 - okay
56:24 - now what i i will do is i'll
56:27 - assign x as
56:29 - x
56:30 - plus equals to a
56:32 - and now i'll
56:34 - print the value of x what i'll do is now
56:36 - i'll assign x as x minus equals to a
56:41 - and now i'll print the value of x
56:44 - now x
56:46 - into equals to
56:48 - a
56:50 - and now print the value of x now x
56:53 - divided by equals to
56:55 - a
57:04 - okay so
57:05 - you can guess the result or we will see
57:08 - them and then i'll explain them to you
57:12 - so the results are 5 10 5 5 25 5 0 okay
57:16 - so first was
57:18 - x equals to eighth of an integral and x
57:20 - so the value of a was five basically
57:23 - so here x is equals to five
57:25 - okay so here the value of x was 5
57:33 - so what i did is i did x plus equals to
57:36 - a so this basically means means that x
57:40 - should be equal to
57:41 - x plus a
57:48 - okay
57:49 - so
57:49 - the value of x was 5 and i assigned
57:52 - reassigned the value of x as x plus a
57:55 - so the value of x here would be
57:58 - 10
58:00 - okay i hope it was clear to you so the
58:03 - basically the meaning of x plus equals
58:05 - to a is x equals to x plus a okay so the
58:08 - value of x was already 5 and i here
58:11 - reassigned the value of x as x plus a so
58:14 - 5 plus 5 that is 10
58:16 - now here the value of x is 10
58:19 - and
58:20 - this implies that x should be equals to
58:23 - x minus a
58:25 - okay
58:26 - so x was 10
58:28 - and x was 10 and a was 5 so i i
58:32 - reassigned the value of x is 10-5 so
58:35 - here the value of x should be 5
58:38 - okay and we can check that also
58:41 - so here the value of x is 5 and i
58:45 - uh
58:46 - create reassign the value of x such that
58:48 - x is x should be equal to x into a
58:50 - so x is 5 a is 5 so here the
58:54 - reassign value of x should be 25
58:57 - okay so it is pretty easy and
58:59 - interesting and i hope that should be
59:02 - clear to you
59:03 - so here
59:05 - the value of reassigned
59:07 - value of x should be x divided by a
59:10 - so x was 25
59:12 - a was
59:14 - 5
59:14 - so x the new value of x should again be
59:18 - 5
59:19 - okay and
59:20 - we are also seeing that it is true
59:24 - now it means that
59:26 - the reassign value of x should be the
59:28 - remainder
59:30 - when x is divided by a
59:33 - so now x is 5 a is also 5 if the
59:35 - remainder is 0 when x is divided by a so
59:38 - here the reassigned value of a is 0.
59:41 - okay
59:42 - so we have now completed the arithmetic
59:45 - comparison and assignment operator now
59:47 - we will move on to the
59:49 - increment and the decrement operator
59:51 - so
59:52 - what i do i will do is i'll just
59:56 - so here what is the value of x x is 0
60:01 - okay
60:03 - so now what i'll do is i'll just
60:07 - increase
60:08 - the value of x as x plus
60:11 - okay
60:12 - and then i'll print the value of x and
60:14 - then i'll do x minus minus and then
60:16 - again print the value of x
60:19 - okay so uh when i have to comment this
60:23 - all out
60:25 - okay no problem
60:27 - when if i have to comment all this out
60:30 - so what i can do is i can just press
60:33 - ctrl and the slash button
60:35 - so it it is all commented out
60:37 - okay so
60:39 - the value of x is a and it is 5 so value
60:42 - of x is 5 when i run this program
60:46 - when i run this program
60:48 - so the output is
60:52 - output is 6 and 5. so here the value of
60:55 - x was 5 and i did x plus plus the in i
60:58 - incremented the value of x and then
60:59 - printed it so it is 6 and then i
61:03 - decremented the value of f x and then
61:05 - printed it so it is 5
61:08 - okay
61:08 - so i hope
61:10 - that all is clear to you and
61:13 - before the video ends i like you to
61:16 - make a program
61:22 - that
61:24 - that
61:25 - prints
61:27 - the sum of two number
61:30 - okay i hope that would be easy and you
61:33 - will do it
61:35 - some of the
61:37 - that prints the
61:39 - sum of two numbers
61:41 - okay thank you for watching this video i
61:43 - hope you enjoyed and learned
61:45 - thank you
61:47 - in the previous video we have discussed
61:49 - about various operators in kotlin
61:52 - so
61:53 - now we will discuss about
61:55 - what happens if
61:57 - one or more than one two or more than
62:00 - two operators
62:02 - occur simultaneously in the same
62:04 - statement
62:06 - what i mean to say is
62:09 - like i'll just mention
62:12 - a
62:13 - function
62:15 - having val variable
62:19 - or value
62:20 - x
62:21 - as having 20
62:24 - value y having
62:27 - 30
62:28 - and variable z having a value of 40.
62:33 - so
62:35 - i am asking you that what happens when
62:41 - okay i'll just make it square
62:43 - what happens when i'll assign reassign x
62:47 - plus equals to
62:49 - z
62:51 - into y
62:53 - what happens then
62:55 - and i'll then print l
63:00 - so what would be the output of this
63:02 - particular
63:03 - function
63:04 - how can we decide that
63:06 - there are two
63:08 - equa
63:10 - two operators simultaneously like we are
63:13 - assigning the value of x as x plus
63:18 - z into
63:20 - y so we cannot say that we here use the
63:24 - uh bird mass okay
63:26 - so what we do here how we determine the
63:30 - output so we there is a order of
63:34 - precedence
63:35 - so we can treat it like the preference
63:37 - order
63:38 - so the postfix has the most preference
63:42 - order
63:43 - so i'll just uh quickly explain to you
63:46 - what is postfix and prefix so we have
63:48 - discussed about the increment and the
63:50 - decrement operator right the plus plus
63:52 - and the minus minus operator that
63:54 - increase or decrease the value by one
63:56 - so the post phase and the prefix
63:58 - increment and decrement of operator
64:01 - are a plus plus and plus plus a
64:04 - so a plus plus is the postfix and plus
64:07 - plus a is the prefix increment operator
64:10 - okay so the original value of a is
64:12 - returned at first and then a is
64:14 - incremented by one
64:16 - so just read it out
64:18 - and i'll be explaining it in more detail
64:21 - at later part of this video okay so i'll
64:24 - just continue with this so the higher
64:27 - highest preference is of the most fixed
64:30 - uh
64:32 - operator and the second highest
64:35 - preference is of prefix
64:37 - operator the multiplicative operator is
64:40 - the into the divide and the modulus okay
64:43 - it has the third most
64:46 - or
64:48 - preference okay
64:50 - and then comes the additive operator of
64:51 - the plus and the minus and then comes
64:53 - the comparison operator when we do the
64:55 - comparison and all and then comes the
64:58 - equality operator and at last there are
65:01 - the assignment operators
65:03 - okay so this has the least priority
65:07 - okay
65:09 - so
65:10 - here your body mass logic would be true
65:12 - but
65:13 - if it would be into equals to and z plus
65:17 - y it won't be true so i'll just quickly
65:21 - run the program
65:22 - and
65:24 - till then we will discuss
65:27 - what would be the value of x
65:30 - so
65:31 - as we can see that the multiplicative
65:34 - operator has the higher preference
65:36 - so the
65:38 - okay so the output is 10 20 120 okay so
65:42 - we can see that the multiplicative
65:45 - operator has the higher preference so uh
65:47 - firstly the multiplication would happen
65:52 - and the code would look will look like x
65:54 - plus equals to z into y what is z into y
65:57 - it is uh 120 1200
66:00 - okay so x
66:02 - plus equals to
66:05 - 1 1200 so the reassigned value of x
66:08 - should be the
66:10 - previous value of x plus the 1200 and
66:12 - what is the previous value of x the
66:14 - previous value of x is 20. so the
66:16 - reassigned value of x is 120 as we saw
66:19 - in the output
66:21 - okay
66:23 - so it is i guess it is clear to all of
66:25 - you so we will just work on one more
66:30 - uh such example
66:33 - where variable a is 40 variable b is
66:36 - also 40.0 okay so it is a double type
66:40 - and
66:42 - there is a value c that is equals to
66:45 - plus plus a
66:47 - minus minus minus b
66:51 - okay so now what is b
66:54 - so now we will discuss first and then we
66:56 - will see the
66:58 - output so here is 40 b is 40.0 a is 40.0
67:03 - now
67:04 - we can see that the prefix
67:06 - operator has the most uh
67:10 - the highest order
67:11 - okay also we have seen here that in the
67:14 - prefix the value of a is incremented by
67:18 - 1 and then it returns the value okay in
67:21 - the post fit
67:22 - postfix the value of a is written the
67:25 - first and then the a is incremented by
67:29 - one so
67:30 - ah what i am saying trying to say here
67:32 - is
67:32 - uh that
67:34 - here the
67:35 - the plus plus a returns the incremented
67:38 - value okay so the plus plus a is the
67:41 - incremented value
67:44 - so
67:45 - it has the highest
67:47 - order of precedence
67:50 - so
67:51 - like i can say that c is equals to plus
67:54 - plus a will be 41.0
67:57 - and minus minus b would be
68:00 - 39.0
68:03 - so when i run this program
68:06 - i should be able to see the output as
68:09 - 2.0
68:11 - okay
68:12 - and here it is
68:13 - so we were right
68:15 - so
68:16 - we can conclude the order of precedence
68:19 - and we can say that it's just a
68:21 - preference order by which the operators
68:24 - are designed this decided okay
68:26 - now we will come to this
68:28 - increment and
68:30 - decrement operator
68:34 - and what is the what is the meaning of
68:36 - prefix or postfix operator so
68:39 - when i define
68:42 - a variable
68:45 - alpha
68:47 - and
68:48 - assign its value as 23
68:50 - okay
68:51 - and what i'll do is i'll just
68:54 - print ln
68:56 - and
68:57 - a plus plus
68:59 - sorry alpha plus plus
69:02 - so what result do you expect so mostly
69:06 - you would be expecting
69:09 - 24
69:11 - but that's not true
69:13 - the
69:13 - output
69:15 - is 23
69:16 - isn't that shocking so what i mentioned
69:19 - about the postfix operator was that the
69:22 - original value of a is written at first
69:24 - so when i uh run this program the
69:28 - alpha plus plus returns the original
69:30 - value of alpha
69:31 - but at the end of this line or at the
69:34 - starting of the next line the value of
69:36 - alpha is incremented by 1 so
69:39 - when i print the value of alpha here
69:43 - what will happen is so here it at line
69:47 - 36 the the output would be 30 24 23 and
69:52 - here at line 37 the output would be 24
69:57 - okay that's just because the prefix and
69:59 - the postfix
70:01 - so
70:02 - what would happen
70:03 - if instead of alpha plus plus i'll print
70:07 - the value of plus plus alpha
70:12 - okay so
70:15 - the prefix operator increases the
70:18 - value instantly by 1 and then returns
70:21 - the value so the output of this would be
70:25 - 24 only
70:27 - okay because it is a
70:29 - prefix operator
70:30 - okay it is 25 because after that the
70:33 - alpha of
70:34 - the value of alpha
70:36 - is changed to 24 and then we have
70:39 - increased it one more time so it is 25
70:42 - okay so you can note here that it is
70:45 - implemented and then written and in the
70:48 - postfix it is written and then
70:50 - incremented
70:52 - okay now we will move to the
70:54 - type conversion so what do you mean by
70:56 - type conversion basically if uh i know
70:59 - nothing about uh kotlin i just know
71:02 - english so what what one should mean by
71:04 - type conversion one should one would
71:06 - mean that we have to convert the type
71:09 - okay so uh what i what will happen if i
71:14 - have to convert like i have a is as 40
71:17 - and i have to convert it into an integer
71:20 - so how will i do so so i'll con
71:25 - create a variable
71:27 - and
71:28 - name it as a int
71:31 - okay
71:32 - and
71:34 - give it a value of
71:36 - a
71:36 - which is the original operator and add
71:41 - two int function to it
71:43 - okay so what it did what it what it did
71:46 - is
71:47 - it
71:48 - created the
71:50 - value of a
71:51 - into two int
71:53 - so it just transferred the value of a to
71:56 - int
71:56 - so now the a int variable is of integer
71:59 - type
72:01 - okay so when i print the value of
72:06 - a and
72:11 - okay just i'll just hide this code
72:14 - and when i print the value of a int it
72:17 - should be
72:18 - 40 instead of 40.0
72:21 - okay
72:22 - so uh
72:25 - the it it is used many times so when i
72:28 - suppose i have a someone's phone number
72:31 - uh stored
72:32 - uh like an integer
72:34 - phone number
72:37 - as integer
72:41 - okay so now what i have to do is i have
72:44 - to store this integer
72:47 - store this integer
72:49 - as a string because um
72:53 - but just i have to do so so what i'll do
72:56 - is i'll just
72:59 - create a
73:00 - another variable
73:02 - which is phone string
73:06 - and
73:07 - what i'll do is i'll just give it a
73:09 - value of phone number dot to string
73:13 - okay and i'll just when i hover over it
73:15 - and it has the data type of string
73:18 - so
73:19 - you might all have
73:22 - somewhat somewhere heard about the sky
73:24 - values
73:27 - a s e i sky values
73:30 - if you haven't heard about it just
73:32 - google it and then resume the video okay
73:36 - so what
73:37 - what if i have a character
73:39 - any character i have
73:42 - any character and i want its sky value
73:45 - what will i do
73:49 - so
73:50 - i have a character suppose a
73:52 - and i want its sky value so what i'll do
73:54 - is i'll just print ln
73:57 - and
73:58 - a
73:59 - dot oh sorry
74:00 - character dot to int
74:03 - so
74:10 - it will
74:11 - when i run this program
74:14 - it will just show the
74:16 - sky value of a
74:19 - okay so the sky value of a is 97 when i
74:22 - want the sky value of exclamation mark
74:25 - i'll run the program and the sky value
74:27 - of exclamation mark is
74:31 - 33
74:32 - okay
74:33 - so that's all for this video guys thank
74:35 - you for watching this video and stay
74:37 - tuned for more
74:40 - in the previous two videos we have
74:41 - covered
74:42 - uh operators and
74:44 - the data type conversion so in this
74:47 - video uh we will be covering the string
74:50 - and the string templates
74:52 - so what is basically a string so a
74:54 - string is a sequence of characters
74:58 - okay
74:59 - uh so i'll go ahead and
75:02 - make a function
75:04 - in which
75:06 - i'll
75:07 - mention a
75:08 - variable a
75:10 - and
75:12 - give it a value this is a
75:17 - coder exclamation mark okay so
75:21 - this is a coder and with three spaces
75:24 - and an exclamation mark comprises
75:27 - uh the these all character comprises a
75:30 - string okay so remember string is always
75:34 - quoted in double quotes
75:36 - okay
75:37 - and
75:38 - the space and the punctuation are also
75:41 - characters which are part of the uh
75:44 - string
75:46 - so uh
75:48 - the first
75:50 - character in the string has an index
75:52 - zero okay so in this string the t has a
75:56 - character zero that has an index zero
75:58 - okay so as we move forward with the
76:01 - string so this is a coder uh the index
76:04 - increases by one okay and each and every
76:07 - space and each and every punctuation
76:10 - mark has its own index
76:12 - okay so when i mention the index and the
76:15 - string
76:16 - just one above the other and mention it
76:19 - in a table so that is called an index
76:21 - table
76:23 - okay so i have just mentioned the part
76:25 - of index table here
76:27 - okay so uh it's it says that which
76:31 - character has what index okay
76:34 - so
76:35 - in this the c character has a index of
76:38 - 10
76:39 - okay
76:41 - so this is the basic about string we
76:44 - know we already know how to initialize a
76:46 - string okay so there is also a
76:49 - second method here second we can say
76:52 - that it is a second
76:54 - uh
76:54 - method to initialize a string we can do
76:57 - that string variable b string we we will
77:00 - mention the data type of that string
77:03 - beforehand
77:04 - okay we can do that also
77:07 - so we can define the string in two ways
77:10 - okay
77:11 - so uh we will be covering
77:14 - most of the string functions in the
77:16 - later part of video but i'll be
77:18 - mentioning one string function in this
77:20 - video uh that is the length function so
77:24 - uh remember
77:26 - this a string having index from 0 to 15
77:30 - has a length of 16 okay it has 16
77:33 - characters in it
77:35 - including 0 okay so uh what if i have to
77:38 - uh
77:39 - like i have a value
77:41 - i that stores the uh
77:44 - the store the length of
77:46 - string a
77:48 - so
77:49 - i'll just mention a dot length
77:53 - okay
77:54 - and this
77:56 - this length function measures the length
77:58 - of any string
78:00 - so i'll go ahead go ahead and print the
78:03 - value of
78:05 - i
78:07 - so when i run this program i expect the
78:10 - result to expect the output to be 16
78:15 - okay
78:20 - so
78:22 - yeah
78:23 - so the output is 16 so the length of
78:26 - string a is 16
78:28 - okay so what if i have to uh mention i
78:32 - have to uh get
78:34 - the output as the
78:37 - length
78:39 - of the
78:41 - string
78:43 - is
78:45 - 16 okay so i have to print this
78:48 - statement
78:49 - and
78:52 - that
78:53 - value here is i
78:54 - so what i can do is i can uh go ahead
78:57 - and write a print statement which
79:00 - contains a string that
79:03 - the string is
79:04 - the value of string is okay the value of
79:07 - the length of string is
79:09 - so i'll just go ahead and print this
79:12 - okay the length of string and then what
79:15 - i can do is i can in the next line i
79:18 - will mention a println statement and
79:20 - that contains i
79:23 - okay
79:25 - so when i go ahead and run this program
79:28 - what i will find in the output is
79:31 - the output will be the length of string
79:33 - is 16 but it but don't you think it's a
79:37 - little bit lengthier
79:38 - and there must be a shorter way so you
79:41 - are thinking right
79:42 - so what i'll do here is i can use
79:46 - string
79:47 - function string template here so string
79:49 - template is nothing but a dollar sign
79:51 - okay so what is a string template so
79:55 - while
79:56 - mentioning a string
79:59 - what i can do is
80:01 - i can so i will just mention it print ln
80:05 - yeah so after the uh mention after the
80:09 - uh
80:10 - the string
80:11 - i have to put inside the string the
80:13 - value of i
80:14 - so what i can do is i can just put the
80:17 - dollar sign and i
80:18 - okay when i hover over it
80:20 - it says
80:23 - valley very value i int
80:25 - okay
80:27 - so it has the value of i so when i go
80:30 - through this line it will print the
80:32 - string the length of the string is and
80:35 - inside the string it has the value i
80:38 - so before
80:39 - so it does not print the length of the
80:41 - string is dollar i dollar sign i it does
80:44 - not print that what it print is we will
80:46 - see when i run this program
80:48 - okay
80:49 - so
80:50 - uh
80:52 - yeah it prints the the length of string
80:55 - is
80:56 - and instead of dollar i it puts just the
80:59 - value of i
81:00 - okay
81:01 - so what if i have to uh
81:04 - print i have i have not defined of any
81:07 - value i okay
81:09 - and i have to print the
81:11 - length so i have not defined i'll just
81:14 - make this go
81:16 - and
81:17 - yeah
81:18 - so now what i will do
81:20 - i have a string and i have to print its
81:23 - value
81:24 - and inside the string
81:27 - i have a
81:29 - i can i can do one thing i can just go
81:32 - and
81:33 - instead of
81:35 - print ln i'll do here print and in the
81:38 - next line what i can do is i can go
81:40 - print ln and
81:42 - here put i can put a dot length
81:45 - okay so when i run this program it will
81:48 - be giving an output the length of string
81:50 - is a dot length and which is 16
81:53 - okay
81:55 - so it is correct but now
81:57 - here also it is uh redundant and uh
82:01 - more of code
82:02 - like more lines are used it is redundant
82:04 - because we are using the print function
82:06 - twice
82:07 - so in cotline we don't do that so what i
82:09 - will do is
82:11 - i can
82:12 - use the string template here also but
82:15 - but when i use the string template
82:18 - without any
82:20 - something
82:21 - so what happens is i'll mention just a
82:24 - dot length so it automatically
82:27 - insert it into curly braces okay so i
82:31 - was trying to establish my point here
82:33 - the point was that
82:36 - whenever there is an expression
82:38 - in a string template we put it inside a
82:41 - curly brace okay so when i run this
82:43 - program
82:44 - it automatically puts the length of
82:48 - string a inside this
82:50 - template and we have the output as the
82:54 - length of string is 16
82:57 - okay
82:57 - so that's all for this video in the next
83:00 - video we will be covering uh the various
83:02 - type of string functions that are
83:03 - available in kotlin
83:05 - thank you very much
83:09 - in the previous video we have covered
83:11 - about string and string function in this
83:14 - video we are going to
83:16 - learn about more string functions such
83:18 - as the length function we discussed
83:20 - about in the previous video okay so uh
83:23 - the string functions are the function
83:25 - which will be implemented on string as
83:27 - the name suggest
83:29 - so the first function is the length
83:31 - function i have discussed it in the last
83:33 - video but still i will discuss it in
83:36 - this video also so i'll
83:38 - go ahead and
83:40 - create a function main
83:42 - in which i'll define a
83:46 - string of value a is equals to
83:51 - hello
83:55 - okay
83:58 - i'll not leave space
84:00 - and
84:01 - value b is equals to
84:05 - this
84:06 - is a
84:08 - coder
84:10 - and i'll define another
84:14 - value c
84:17 - and another string with a
84:21 - value and my
84:24 - age is
84:25 - and i'll define another value
84:28 - d and
84:30 - it is an integer which is with the value
84:32 - of 90 okay
84:34 - so i have
84:36 - three strings and a
84:38 - integer
84:40 - so uh firstly i am going to discuss the
84:42 - length function okay
84:44 - so uh
84:46 - what about what if i have to uh get the
84:49 - length of
84:51 - the the
84:52 - value of the
84:54 - string b or the string a
84:56 - okay
84:57 - so i'll just go ahead and write the
84:59 - print statement
85:01 - okay
85:02 - so the value
85:05 - the
85:08 - length of
85:12 - a is
85:14 - and i have discussed about the uh string
85:17 - uh
85:18 - template in the previous video so i i am
85:20 - going to use that here okay and the
85:23 - length of a is a dot length
85:27 - okay
85:28 - so
85:29 - the length function is used here as a
85:31 - dot length so whatever i have to
85:35 - see the length of b whatever i have to
85:37 - see the length of c
85:38 - so just i am going to
85:44 - copy this
85:46 - and paste and instead of b
85:48 - i'll do c so
85:50 - when i run this program
85:52 - i should find the length of a b and c
85:57 - as the output
86:00 - okay
86:01 - so this is the use of the length
86:03 - function
86:04 - so as in the output we can see the
86:06 - length of a is 5 the length of a is 15
86:08 - okay so i here did not change the
86:13 - values okay so length of a is 5 the
86:15 - length of b is 15
86:18 - and the length of c is 13
86:20 - we can verify from here also but
86:24 - uh yeah
86:25 - i guess you are you have now a clarity
86:28 - about the length function the second
86:30 - function we are going to talk about is
86:32 - the get index function so get index
86:34 - function returns the character at the
86:36 - specific index within the bracket
86:39 - now
86:40 - i have already told about you the index
86:43 - so in this hello string i'll just
86:46 - mention
86:47 - h e
86:48 - l l o so uh the h here has an index zero
86:53 - the e has index one the l has a index
86:55 - two and another hell has a has index
86:58 - three and the o has an index four
87:01 - okay so what the get index function does
87:05 - it returns the character at a specific
87:08 - at a specific index specified within the
87:11 - bracket
87:12 - so uh i'll just
87:15 - mention a print function and i have to
87:18 - get what is the
87:20 - character at
87:21 - index 4 of
87:24 - b
87:25 - string
87:27 - so
87:28 - the
87:28 - character
87:31 - the character at
87:33 - index
87:35 - 4
87:36 - of b is what i'll do is i'll just go b
87:40 - uh
87:41 - okay so i'll first use string template
87:43 - and the
87:46 - the function is get in bracket index so
87:49 - i'll use the string template
87:51 - and i'll just mention the string that is
87:54 - b
87:54 - and
87:55 - the function that is get index
87:59 - okay and then the index so i have to
88:01 - find the index at four okay
88:05 - so when i run this program
88:07 - what is the expected output so at four
88:11 - it has a space
88:13 - okay so it gives a space
88:16 - so i'll just go ahead and change it to 5
88:20 - and when i run this program
88:23 - we can see that
88:26 - the output is the character at index 4
88:28 - of b is
88:30 - index 5 of b is
88:32 - i
88:33 - so
88:34 - yeah it
88:35 - is pretty clear from here that
88:38 - the index at index 4
88:41 - of string b
88:42 - is i so
88:45 - here it is underlined by a
88:48 - yellow line so what i'll do is i'll go
88:50 - here and hit alt plus enter
88:53 - and it suggests that replace get
88:55 - call with indexing operator so what is
88:57 - an indexing operator
88:59 - so i'll just show you that
89:02 - okay so instead of doing this what i can
89:05 - do is i can just
89:07 - mention b and that and then in the
89:10 - bracket i'll square bracket i'll mention
89:13 - five
89:14 - okay so when i run this program i'll get
89:17 - the same output
89:19 - so instead of using get function or a
89:21 - bigger code i'll just do is what is what
89:26 - b square bracket and the index okay it
89:28 - gives us the same result so i guess
89:32 - the get index function is also pretty
89:34 - clear
89:35 - now what about the subsequence so as the
89:37 - name suggests it provides a sequence
89:40 - which is a part of the mainstream
89:43 - okay so the
89:45 - the function
89:46 - goes like sub sequence start index and n
89:49 - index so between start index and end
89:51 - index it prints all the the string okay
89:54 - so it returns the sub string between the
89:57 - start index and the end index but
89:59 - excluding the index and n index it is a
90:01 - main point one of the main point okay so
90:04 - it excludes the end index so uh what if
90:07 - i uh
90:08 - i go
90:09 - and say uh put the
90:12 - print the sub string from 1 2 3
90:16 - of a so i have to mention one two four
90:20 - okay because it excludes the end index
90:24 - so i'll just go ahead and print for the
90:27 - better understanding
90:29 - so println
90:31 - the sub string
90:35 - is
90:36 - i'll
90:37 - go with the string template
90:39 - and
90:41 - for a i have to mention
90:44 - and the function is sub sequence
90:46 - and the start index is
90:50 - 1
90:51 - and the end index is 4
90:54 - okay
90:55 - so what happens when i run this program
90:58 - what will be the
91:00 - output so when i run this program it
91:03 - gives e l
91:05 - but at the fourth index there is o
91:09 - so why is all the is why o is not
91:12 - printed because it excludes the
91:15 - excludes the character at the index last
91:18 - index mentioned here okay so keeping
91:20 - that in mind
91:22 - just
91:24 - predict the result
91:26 - after pausing the video of
91:28 - the substring
91:32 - of b
91:33 - 2 to 7
91:35 - okay
91:36 - so what will be the substring of b
91:39 - dot subsequence
91:42 - 2 comma 7 just pause the video and
91:46 - think about it and write it on a paper
91:48 - or something ok and then now you can
91:50 - play the video and check so it is is
91:54 - space is
91:56 - now we will go ahead and check
91:58 - so uh
92:00 - this so the second is here second uh
92:04 - index is here okay third index is here
92:06 - and fourth fifth sixth seventh so
92:09 - seventh is a space so
92:11 - it is not clearly visible here but the
92:13 - space is not printed here okay it
92:15 - stopped at the
92:17 - s
92:18 - okay i'll just go ahead and make that
92:20 - nine
92:21 - so it would be more clear
92:23 - okay so not nine i'll make that 11
92:31 - so
92:32 - we can see that at the 11th index the
92:36 - letter the character o is there but in
92:39 - the output we cannot see oh because the
92:41 - uh
92:42 - last index is not printed there so i
92:44 - hope the subsequence uh function is also
92:47 - clear to you
92:49 - okay so we have now till now covered the
92:51 - three
92:52 - functions which are mostly usable now uh
92:55 - we will we will be moving to some less
92:57 - usable function okay so there is a
92:59 - compare to function so the comparative
93:01 - function compares
93:03 - the object
93:05 - with the specified object of order
93:08 - okay
93:09 - so it just compare two strings it
93:12 - returns zero if the object is equal it
93:14 - returns a negative number if it is less
93:16 - than the other okay so like what will be
93:20 - the um
93:22 - i have to compare
93:23 - the okay what will be what will it be
93:26 - comparing it will be comparing the
93:27 - length of the two strings
93:29 - so uh
93:31 - what i'll do is i'll just print ln and
93:34 - print
93:35 - a dot compared to b
93:38 - okay so i am comparing here a to b
93:43 - so
93:43 - uh
93:44 - like it is the specified other object is
93:47 - b here the specified other object is b
93:49 - and the object our main object is
93:53 - a
93:54 - okay so
93:55 - if it is less than the other it gives a
93:58 - negative number and if it is greater
94:00 - than the other it gives a positive
94:01 - number so you can guess the output here
94:04 - and
94:05 - while i run the program
94:06 - [Music]
94:07 - so
94:08 - when a is compared to b it provides a
94:10 - negative number that means that a is
94:13 - lesser than a smaller than b okay it is
94:16 - pretty clear from here that b is a
94:19 - larger string
94:21 - so i will just go ahead and compare
94:24 - also compare
94:27 - b from
94:31 - c
94:33 - okay
94:34 - so you can guess the
94:36 - output here
94:38 - as
94:39 - b is a larger string so it gives a
94:41 - positive
94:43 - okay and
94:45 - what i'll do is i'll just create for
94:48 - uh
94:49 - the sake of just come comparing the
94:51 - function uh
94:53 - a variable a value
94:56 - f and
94:57 - just change some characters in it
95:01 - and
95:05 - okay and now
95:06 - i'll
95:08 - do is what i'll do is i'll just compare
95:13 - c
95:14 - compared to
95:16 - f
95:18 - and now i'll run the program
95:19 - and the expected output is 0 because the
95:22 - two strings are of equal length
95:28 - okay
95:32 - but it gives a
95:34 - positive number why so
95:37 - because it it just not
95:40 - compares the length okay
95:42 - it compares the
95:43 - object specified within the
95:46 - string
95:48 - so
95:49 - the object the object f is
95:51 - [Music]
95:53 - greater than the object c
95:56 - okay
95:58 - so uh if i have the same string here
96:01 - then it will be 0 but if i have the
96:04 - purpose of me stating that was just that
96:08 - if i have the same string then only it
96:10 - will be zero if i don't have the same
96:12 - string then the output could be z uh
96:15 - positive or negative we cannot define
96:17 - that as per as of now okay so thank you
96:20 - for watching this video in the next
96:21 - video we will be covering more string
96:23 - temp string functions okay
96:27 - in the previous video we were discussing
96:29 - about string functions and in this video
96:32 - we are going to continue with the
96:33 - discussion
96:34 - okay so uh in the previous video we have
96:36 - discussed about the
96:40 - the
96:41 - the length function the get index
96:43 - function the subsequence function and
96:44 - the compare to function okay
96:46 - so uh
96:48 - in
96:49 - i think
96:50 - that should be clear to you
96:53 - okay so
96:55 - now next is the equals function so the
96:58 - equal function it indicates whether some
97:01 - object is equal to the other object or
97:05 - not okay
97:07 - so
97:08 - it is just like the comparison operator
97:11 - equals to equals to okay
97:13 - so
97:14 - what i'll do is i'll just
97:19 - okay so you can guess the written type
97:21 - of the
97:22 - the function is boolean okay
97:24 - because it returns that whether it is
97:26 - equal to or not
97:28 - so when i
97:30 - say a
97:32 - equals to equals okay so it is equals
97:36 - and i say b
97:40 - b
97:43 - and
97:44 - when i
97:46 - when i
97:48 - run this
97:49 - so you can guess the output the output
97:52 - is
97:54 - false
97:55 - because they are not equal
98:08 - okay so as you can see here the output
98:09 - is false
98:11 - because they are not equal and when i do
98:14 - c
98:15 - nd
98:18 - c
98:19 - and i compare it with d
98:22 - and again when i
98:24 - run the program
98:27 - now the output must be true because they
98:29 - are equal
98:31 - okay
98:32 - no it is false why it is false
98:36 - okay
98:37 - so i have done some
98:39 - mistake i have to compare
98:43 - c with f okay sorry
98:48 - so yeah when i compared c with the d the
98:51 - data type is only not same
98:53 - one is string and other isn't so there
98:55 - is no chance of
98:57 - them being equal so it is true now what
98:59 - happens when i
99:01 - change one index
99:03 - in the string
99:09 - so you can see the output is false so it
99:11 - is only true when both string are equal
99:14 - in each and every manner possible now it
99:17 - is having some suggestion now we will go
99:19 - to it and plus press alt plus enter it
99:22 - is suggesting that we should replace it
99:23 - with equals to equals to sign as i
99:26 - already mentioned that it is nothing but
99:28 - the comparison operator equal to equal
99:30 - to
99:31 - okay moving on to hash code the hash
99:34 - code returns a hash code value
99:37 - for the object okay so you might be
99:39 - wondering what uh what the hashcode is
99:41 - i'll suggest just go to the google type
99:44 - hashcode of a string and you will get to
99:46 - know
99:47 - okay so uh i want the hashcode of
99:52 - let's say string
99:55 - c
99:56 - so
99:57 - so i'll just type c dot hash code
100:01 - okay and when i run this program i'll
100:03 - get the hash code for c string
100:06 - so as you can see in the output screen
100:09 - the hash code for c
100:10 - string is this okay then as let's say i
100:13 - want hash code for all the strings
100:15 - possible
100:16 - okay so i'll just
100:19 - mention all the strings
100:22 - a b c and f we have four strings
100:27 - a
100:29 - b
100:31 - c
100:32 - and
100:33 - [Music]
100:35 - f okay
100:36 - so when i run this program
100:47 - it gives the hash code for
100:49 - all these string
100:51 - now if you note uh
100:54 - that these two values are negative and
100:57 - these two values are positive so why is
100:59 - that the hash code could be positive
101:01 - negative or any value
101:03 - okay it's just a representation
101:05 - okay so
101:07 - now next is the plus operator plus
101:09 - function
101:10 - so what the plus function does is
101:14 - okay when i use the plus function
101:17 - let's say uh
101:19 - i have
101:20 - print ln
101:23 - uh a
101:25 - plus
101:27 - b
101:28 - now
101:29 - the a plus b is another string
101:33 - okay
101:33 - so i can
101:36 - make another function used on this
101:38 - string also so i can use the plus
101:41 - function again also
101:42 - okay
101:43 - and
101:44 - it's the plus function is not restricted
101:47 - to string only so i can use the plus
101:49 - function and use any data type you can i
101:52 - can use here d also
101:54 - okay so when i
101:55 - run this program
101:57 - so you can see the addition of all this
102:00 - a b c
102:01 - and d
102:05 - so it gives like hello this is a coder
102:09 - and my age is 19. okay so what there is
102:12 - a mistake that there is no space given
102:14 - because i have not given any spaces here
102:17 - here or here if i give spaces here then
102:20 - it would be a perfect code
102:23 - so
102:24 - that was all about the plus function now
102:27 - instead of using dot plus i can also do
102:30 - that
102:30 - i just
102:32 - i can just do a plus b
102:36 - plus
102:37 - c okay
102:40 - and when i run this program
102:44 - i can find
102:45 - that
102:46 - it gives hello this is a coder and my
102:48 - edge now this is string con
102:52 - concatenation okay
102:54 - it is nothing but uh it just
102:57 - contained the string it means that it
103:00 - puts three two or three string or many
103:02 - string together and make it a new string
103:06 - okay so plus function returns a string
103:08 - obtained by
103:09 - concatenating the string with the string
103:12 - representation of the given other object
103:14 - okay
103:16 - so that was all about the plus function
103:17 - next is the two string function so we
103:20 - have already uh
103:21 - talked about the the two string or two
103:24 - end or two all the data type conversion
103:26 - function so it is nothing but suppose i
103:29 - have a
103:31 - i have a
103:34 - integer
103:39 - uh that has a value that is a phone
103:41 - number okay
103:43 - so
103:46 - okay a is already defined
103:49 - i'll just give it name as phone
103:51 - okay so i want to store this in a string
103:56 - so what i can do is i can just
103:58 - write phone and then dot tostring
104:03 - to string
104:07 - so what it does is it
104:09 - converts the phone
104:11 - this into a string
104:13 - so when i print this when i go ahead and
104:17 - print
104:18 - this
104:20 - [Music]
104:21 - then
104:22 - you can expect the result it is a string
104:24 - so you you can see nothing in the result
104:27 - the result would be same the output is
104:29 - just the number itself but it is a
104:31 - string
104:32 - okay so tostring function
104:36 - returns a string representation of any
104:38 - object
104:39 - okay then there is last index function
104:42 - the last index function returns the
104:43 - index of the last character
104:46 - in the uh character sequence
104:48 - and minus one if it is empty so i have
104:51 - here like
104:53 - like
104:54 - in these two string i'll try c and f
104:56 - so what i'll do is uh
104:59 - i'll just to go to the end and yeah so
105:03 - i'll print the
105:06 - last index of c first okay so i'll just
105:09 - type c dot
105:11 - last index
105:13 - okay and i'll also print the
105:17 - last index of
105:19 - f
105:22 - and now i'll run this program meanwhile
105:25 - i'll go to the c and f
105:27 - strings
105:27 - [Music]
105:29 - now as we can see in the output the
105:33 - first one is 13 and the second one is 12
105:36 - so
105:38 - the last index which is this
105:41 - so
105:43 - this is 0 then 1 2 3 4 5 6 7 8 9 10 11
105:48 - 12 and 13 so the index of the last
105:51 - character is 13 in this string and the
105:53 - index of last character is 12 in this
105:56 - string
105:57 - f so it just returns the
106:00 - index of the last character okay so
106:04 - now you must have no doubt in
106:07 - the
106:09 - last index
106:10 - function okay the next is index of
106:13 - function
106:14 - so the index of function returns the
106:16 - index
106:18 - within its string of first occurrence
106:20 - occurrence of a specified character
106:22 - starting from the specified start index
106:25 - okay so index of
106:28 - function has three parameters basically
106:31 - uh the first is the string
106:33 - so that is a b or c whichever string i
106:35 - am providing it second is the start
106:38 - index okay so from which index i should
106:40 - be looking for the character
106:42 - so suppose i'll just explain it and
106:44 - third is the ignore case uh just ignore
106:47 - that so it is just telling the uh
106:50 - it should be false okay so
106:54 - okay it is a boolean you know case is
106:55 - boolean so the basically what is in
106:58 - index of so i i'll say that index of i
107:03 - and
107:04 - string in string b
107:07 - okay uh and starting start index is zero
107:11 - so it will give the third eye
107:14 - okay and when i'll
107:16 - give the start index of three value
107:19 - three so it will give me this i okay so
107:22 - i'll just go ahead and
107:24 - use the function
107:26 - so i'll
107:27 - print
107:31 - in string
107:32 - b i can do
107:35 - what was that
107:38 - index of
107:41 - okay and now i'll mention the character
107:42 - which uh which are of which index i am
107:45 - finding so i'll mention the character as
107:47 - i
107:48 - okay and then i'll mention the uh
107:52 - start index okay so uh note that it is
107:55 - giving a red i in red so why is that
107:58 - because i
107:59 - i haven't mentioned the character in
108:01 - single quote okay so i should
108:03 - only mention the character or character
108:06 - in single code and string in double
108:07 - quotes okay so then i'll mention the
108:11 - string
108:12 - start index so i'll mention the start
108:14 - index at zero at first and the ignore
108:17 - case as false
108:18 - okay
108:19 - so now i now i'll go ahead and run this
108:22 - program
108:24 - so the output of this is
108:26 - 2
108:27 - so i'll i'll go to the b string
108:30 - and uh so it's at 0 1 2 at index 2 there
108:34 - is an i
108:36 - okay so now what if i start with an
108:39 - index 3 and see what is the output okay
108:42 - i'll start with index
108:44 - 3. and run this program
108:47 - so i can see in the output
108:50 - that
108:52 - the result is the output is 5 so i
108:55 - started with this this index and this is
108:59 - the third index then fourth index is
109:01 - empty and then fifth index is has an i
109:04 - so the answer is i uh the the i is at
109:08 - the fifth index starting from the third
109:10 - index okay so it just found the first i
109:13 - from the start index and ignore the rest
109:15 - of it so i'll just
109:17 - find d
109:18 - from any index okay
109:20 - so
109:21 - finding d from n index doesn't change
109:23 - anything okay
109:25 - because d is only mentioned one time it
109:28 - it matters when d is uh when the start
109:31 - index is after uh 11 okay
109:34 - after 12 because d is at the 12th index
109:38 - so the index of just gives the index of
109:41 - the mentioned character from any index
109:44 - okay so i hope all the functions should
109:47 - be clear to you by now okay
109:50 - so thank you for watching this video in
109:52 - the next video we will be covering
109:54 - functions
109:55 - thank you
109:58 - till now we have discussed about string
110:00 - string function operator now we will
110:02 - discuss about functions in kotlin so we
110:05 - have already used a function named for a
110:08 - main function okay in each of our each
110:11 - and every code okay
110:13 - this is the main function that we have
110:15 - used so what is a function function is a
110:17 - collection of code that returns some
110:20 - result okay so despite of the main
110:23 - function we are talking about other
110:24 - functions okay
110:26 - so uh we will firstly discuss about the
110:29 - syntax of the
110:31 - function of any function so
110:33 - the syntax of any function is given by
110:35 - fun
110:36 - that is the key word for declaring any
110:38 - function then comes the function name
110:40 - the function name should be same as the
110:43 - identifiers uh defined by me
110:46 - in at the starting of variables okay so
110:49 - the same thing should be used and
110:53 - the function name should be
110:54 - self-explanatory so after two or three
110:57 - months when you look at the code you
110:59 - should know that
111:02 - why is the function named like this okay
111:05 - then comes argument one type one comma
111:09 - argument two colon type two comma and so
111:12 - on okay so what is an argument arguments
111:15 - are the
111:16 - data
111:17 - that a function needs to use so suppose
111:20 - there is a function
111:22 - which
111:23 - takes two input
111:24 - to integer and provides its sums so
111:28 - there is a function which provides the
111:29 - sum of two integers
111:32 - so the function name should be sum of
111:35 - two number okay with s small o capital s
111:38 - um small o capital f small uh n capital
111:43 - and uh everything small okay so that is
111:46 - the
111:48 - best way of naming it and then comes the
111:50 - argument so it provides the sum of two
111:53 - integer
111:54 - so the argument one should be a or any
111:57 - name of the
111:58 - argument of the variable and the type is
112:02 - integer so it is a column integer and
112:06 - comma comma b colon integer
112:09 - so that's the argument and then comes
112:11 - the return type so we have to mention
112:13 - the written type the written type is
112:15 - nothing but expected
112:18 - data type of the result
112:20 - okay so
112:21 - when i
112:22 - write the code
112:24 - when i write a function to
112:28 - give the result as some of the two
112:30 - numbers so the written type is also in
112:33 - so here i mean here i will mention the
112:34 - written type that is end
112:37 - okay then comes the lines of code and
112:39 - then
112:40 - it there is written
112:42 - result okay so here we use the written
112:46 - keyword and
112:48 - give the result what is the result okay
112:50 - so i'll go ahead and
112:54 - so every function is every new function
112:57 - is
112:58 - made is coded outside the main function
113:01 - okay so i'll go ahead and
113:04 - make a function
113:07 - i'll name it as
113:09 - new function
113:13 - okay now
113:15 - i want this function to print
113:18 - and statement so what are the argument
113:21 - given to him given to the
113:24 - function so
113:26 - uh there is no argument given
113:28 - uh when i have to
113:30 - print the
113:32 - the uh
113:34 - any lines so i'll just keep it empty so
113:38 - when there is no written type so the uh
113:42 - the function is just printing
113:44 - it is not returning anything so
113:47 - then the
113:49 - the written type is mentioned as unit
113:52 - okay and then i'll
113:54 - open the function and i'll just write
113:57 - println
114:00 - i am a new
114:02 - function
114:04 - okay so here we have defined a new
114:06 - function which prints i am a new
114:07 - function
114:08 - so
114:09 - the
114:10 - function is defined as per the syntax
114:12 - now what if we have to call the function
114:15 - so as you might know the
114:17 - main function is only executed
114:19 - so we have to call the function to the
114:21 - main function
114:22 - so what i'll do is i'll just name the
114:24 - function here which is new function and
114:27 - just keep it empty if there were any
114:29 - arguments so i'll mention the arguments
114:31 - here
114:32 - okay so i'll go ahead and
114:35 - just run
114:37 - the
114:37 - function
114:39 - the code r code
114:42 - so
114:48 - as you can see in the output screen we
114:50 - have successfully printed a function
114:52 - which says i am a new function okay
114:55 - so we have now a function
114:57 - we are now capable of uh
114:59 - making a function which prints
115:01 - something okay so as no arguments are
115:04 - used so no data is used by the function
115:07 - okay so it is kept blank
115:10 - okay so no written type is there but
115:13 - therefore the unit is used so when i
115:15 - hover over unit so it says that the type
115:18 - with only one value the unit object okay
115:21 - this corresponds to void type in java
115:24 - okay
115:25 - so the written statement is never used
115:27 - because we are not returning anything in
115:29 - this function you might notice that we
115:31 - have not used any written
115:33 - the written
115:35 - keyword is not used
115:36 - okay so what is a unit unit is used when
115:39 - a fun does not written return any
115:42 - meaningful result
115:43 - so it is it
115:45 - we might call it as the default data
115:47 - type of in any function
115:49 - okay so uh till now we have discussed
115:52 - what is a function what is the syntax of
115:54 - function okay so this is a block body of
115:58 - the syntax okay there is also expression
116:00 - body which we will discuss later
116:03 - so we have discussed the syntax we have
116:05 - made a function that prints
116:07 - that i am a new function
116:09 - and that's all for the video we will
116:11 - continue with functions in later videos
116:13 - thank you
116:18 - in the last video we have discussed
116:20 - about the
116:21 - functions
116:22 - and
116:24 - what is a function the block body syntax
116:26 - of a function and we have also created a
116:29 - new function that prints
116:32 - a string okay and we have also called
116:34 - the that function okay so in this video
116:37 - we are going to
116:39 - create a
116:40 - function that
116:44 - that prints
116:46 - the double of that that returns the
116:48 - double of an integer
116:50 - okay so function
116:54 - that doubles an integer
116:56 - okay so uh
116:58 - we are going to
116:59 - use the
117:01 - uh
117:02 - block body as of now so what was in the
117:05 - block body so we have first
117:08 - use we have to use the fun keyword
117:11 - and then we have to name the function
117:13 - such that when we refer it after a long
117:16 - time it should be clear to me that why i
117:19 - named the function and what the function
117:22 - does so as the function doubles an
117:24 - integer so i can name it as
117:27 - double
117:29 - and
117:31 - integer
117:33 - okay and then i have to
117:36 - pass the argument in the open and close
117:39 - parenthesis
117:41 - so uh
117:43 - like
117:44 - i have to pass
117:45 - pass an argument and then it's type so
117:48 - i'll name the argument as a and it type
117:50 - its type is hint
117:53 - okay and next i have to mention the
117:56 - written type so the written type of an
117:58 - integer would
117:59 - the written type of and double of an
118:01 - integer would be also int
118:04 - so
118:05 - i am going to mention int
118:07 - now
118:08 - we have to open the function and
118:12 - write the code
118:13 - okay
118:14 - so
118:15 - we have a
118:16 - now what we have to do
118:18 - we have to just multiply a by two so i
118:21 - have i can write a is equals to
118:24 - a into two
118:28 - okay
118:29 - and then
118:31 - i could written
118:33 - a
118:35 - okay
118:37 - so now it is showing
118:39 - a red underline
118:42 - inside a
118:44 - and it is showing that val cannot be
118:46 - reassigned so
118:48 - what the problem is like when i define a
118:50 - function
118:51 - the variable or the argument
118:55 - that i define is a value parameter not a
118:58 - variable parameter okay so i cannot uh
119:02 - multiply and reassign it okay
119:05 - so what i can do is i can just written a
119:09 - into
119:10 - two here
119:12 - okay
119:13 - so
119:14 - when it enters a function double an
119:16 - integer
119:17 - it is passed in argument an integer and
119:21 - the return type is an integer and the
119:23 - function returns a into two so i am just
119:26 - going to go into the main function and
119:30 - call the
119:31 - double and integer function so i am
119:34 - going to write double an integer and
119:36 - pass the
119:38 - integer in it so
119:40 - let's say i have passed equals to 4
119:44 - now
119:46 - when i run this program
119:48 - i am not going i am not i will not be
119:51 - able to print anything
119:54 - because
119:55 - i have i have not used print statement
119:57 - anywhere
119:59 - okay
120:01 - so
120:02 - let me just
120:07 - so yeah when i will run this program
120:10 - it is not going to print anything
120:11 - because
120:12 - i have never used the print statement
120:14 - anywhere so what i am going to do is i
120:16 - am going to just add print ln here
120:20 - and
120:21 - what it will do is it will print the
120:24 - output of that function okay so
120:28 - when i run this program
120:30 - we can see that the output is 8
120:34 - so we have made a function that doubles
120:37 - an integer
120:38 - now we will move ahead
120:40 - and see what expression body is
120:42 - expression body is another syntax for
120:45 - writing a function so when i write a
120:48 - function it's just written
120:50 - double of an integer it is quite a long
120:53 - syntax okay so instead of these this
120:56 - block body expression body is used for
120:59 - these type of
121:01 - syntaxes
121:02 - so what is expression body is
121:06 - so
121:06 - in expression body also we will uh
121:09 - firstly use the keyword fun
121:11 - and then we will give the function name
121:15 - and then we will pass the argument and
121:17 - then we will pass the return type so
121:21 - starting is a
121:23 - similar to the block body
121:25 - and after passing the return type
121:28 - instead of
121:29 - opening curly braces we will just
121:32 - write equals to and then the expression
121:35 - so
121:36 - i'll just write the function
121:39 - double integer
121:42 - in
121:43 - expression body so i'll pass argument x
121:48 - as an integer
121:50 - and the written type would be also an
121:53 - integer
121:54 - and now instead of
121:57 - opening and closing of curly braces i'll
122:00 - just write equals to
122:02 - and then
122:03 - i'll just write x
122:05 - into
122:06 - 2
122:07 - okay and now i'll go ahead in the main
122:10 - function and
122:12 - write println
122:15 - and
122:17 - double integer and then i'll give value
122:21 - 46
122:23 - now
122:24 - when i run this program
122:28 - it gives output as 8 and 92. so the
122:32 - program works just fine
122:34 - so what expression body did is it
122:38 - it reduced the length of the code
122:42 - and it
122:43 - made the code much easier to read
122:47 - okay
122:48 - so now calling and invoking of a
122:50 - function
122:52 - what is calling an invoking of a
122:53 - function so
122:55 - when i called the function here double
122:57 - an integer
122:59 - okay it is called the calling of a
123:00 - function
123:02 - so calling the new function inside the
123:04 - main function is the calling of a
123:06 - function
123:08 - and
123:10 - uh how
123:11 - how can i do that
123:13 - we have to just write the function name
123:16 - and pass the argument in the parenthesis
123:19 - okay
123:21 - so
123:22 - i guess now we have completed the
123:24 - function in the previous videos we have
123:27 - learned about functions in gotham
123:30 - so before proceeding further i would
123:32 - like you to solve
123:34 - the problem this this problem which says
123:37 - that write a function which compares two
123:38 - numbers and return the maximum of two so
123:42 - one way of doing this is
123:44 - using if else statement
123:46 - and the control statements
123:48 - so we don't know that for now so what we
123:52 - will do is we will use a
123:54 - function max in
123:57 - kotlin.math.max library
123:59 - so how to access this library and this
124:02 - function
124:03 - so for accessing this library and this
124:05 - function what we will do is we will
124:08 - import the library
124:10 - so i'll use the keyword import
124:13 - and then
124:14 - write the name of the library
124:16 - kotlin.math.max
124:21 - now
124:23 - the library is successfully imported so
124:26 - what this max function does is it
124:29 - takes input of two integers and returns
124:32 - the
124:33 - maximum of the two
124:35 - okay so i'll just go ahead and create a
124:38 - main function
124:40 - and then outside the main function i'll
124:42 - just create
124:44 - a function and name it as maximum
124:48 - now what would be the input of this
124:50 - maximum function the input must be two
124:53 - integers
124:55 - so i'll name the integer one as a and
124:58 - the integer two as b
125:00 - so i have
125:02 - provided two input to this maximum
125:05 - function now
125:07 - what would be the return type of this
125:09 - function
125:10 - so the max function provides the maximum
125:13 - integer out of two integer so the return
125:16 - type would also be an integer
125:18 - now i'll just use the math max function
125:21 - which is max of a comma b
125:24 - okay so inside the main function i'll go
125:27 - ahead and
125:29 - print
125:30 - the
125:31 - maximum
125:33 - and maximum of 13 and 25
125:37 - okay so when i run this
125:40 - program
125:42 - what i will find is it prints the
125:44 - maximum of 13 and 25 which is 25
125:47 - okay
125:48 - so
125:49 - kotlin has many such libraries which
125:52 - would
125:53 - be used further
125:55 - and
125:56 - it would make our task very easy
125:59 - instead of
126:01 - using long
126:02 - codes i just used
126:04 - library and its function and it become
126:08 - it became very easy
126:10 - okay
126:11 - so the
126:13 - code is compiling
126:16 - and it is starting
126:18 - okay
126:19 - so i have run my previous code
126:22 - just a second i'll run test dot kt
126:27 - and yeah it prints 25 which is the
126:29 - maximum of 13 and 25
126:32 - okay moving further
126:34 - just i'll comment it out
126:36 - okay moving further in this video we are
126:38 - going to particularly particularly focus
126:40 - on arrays
126:42 - so uh
126:44 - arrays in kotlin
126:46 - are
126:47 - mutable but have fixed sizes
126:50 - so uh suppose i declared an array of
126:54 - let's say four elements
126:57 - so it
126:58 - it is going to be of four elements at
127:01 - every time
127:02 - we cannot
127:04 - add or
127:05 - delete an element from it
127:07 - although we can
127:09 - change the element
127:12 - change any element from an array
127:14 - so a
127:16 - data structure that contains a group of
127:18 - elements mostly of same data type are
127:21 - arrays okay so it is not a foundation
127:24 - that the the data the elements must have
127:28 - same data type but yeah mostly the
127:31 - elements have the same data type
127:34 - commonly used to organize data so why
127:36 - are arrays used basically
127:38 - when i have
127:39 - 20 integers suppose let's say
127:42 - so i have to store 20 integers in one
127:44 - variable so what i'll do is i'll create
127:47 - an array so in that way the data is more
127:49 - organized
127:51 - now
127:52 - the string is in is a collection of
127:55 - characters
127:56 - or we can say that it is an array of
127:59 - characters
128:01 - okay so it is different characters
128:04 - and they are combined together
128:06 - so it can be also called as an
128:09 - array of characters so what is the
128:10 - syntax of
128:12 - creating an array so just like we create
128:15 - any variable
128:16 - we use the var or val keyword and then
128:19 - we will give the name of array
128:21 - and naming
128:23 - array is same as naming a function or a
128:25 - variable
128:26 - okay then we will write the func keyword
128:29 - array off and we will specify the type
128:32 - if any
128:33 - and then we will write the elements okay
128:36 - so now let's just go ahead
128:39 - and
128:40 - create an error
128:42 - so
128:43 - i'll write by where
128:46 - array1
128:47 - and
128:49 - i'll write the keyword array off
128:53 - now
128:55 - suppose i have to
128:58 - create an array of characters
129:00 - so i'll
129:02 - provide the
129:03 - type care and now i'll provide the
129:06 - elements so i'll provide a
129:11 - b
129:13 - c
129:15 - d
129:17 - e
129:18 - okay
129:19 - so we have now successfully created an
129:22 - array which contains five elements and
129:24 - all the five are
129:26 - the letters a b c d and e
129:30 - okay so uh what if i have to create an
129:33 - array which contains
129:34 - uh integer a character
129:37 - and a string and
129:39 - uh
129:40 - and a boolean
129:41 - so
129:42 - i'll just go ahead and create an
129:45 - array
129:47 - of all type
129:50 - of all type
129:53 - so i have named it and i'll just
129:56 - use the
129:58 - function array off
130:00 - and
130:01 - i'll just
130:02 - so it contains an integer
130:05 - and
130:05 - double
130:07 - and boolean
130:09 - character
130:11 - and
130:15 - a string
130:19 - so
130:20 - the variable array of all type is an
130:23 - array which contains an integer and
130:26 - and
130:27 - a
130:28 - float point number
130:29 - a boolean character and a string
130:32 - okay
130:34 - so uh
130:36 - now we have now we can successfully
130:38 - create any array moving forward in
130:40 - kotlin once you declare any array you
130:42 - can only change the content of the array
130:45 - and not the size as i mentioned earlier
130:47 - so the size of this is fixed until and
130:50 - unless i change the size from here
130:52 - okay the size is fixed i can change
130:55 - the elements of an array however but i
130:58 - cannot change the size of the array
131:01 - okay so now let's just copy this code
131:06 - and
131:08 - just understand that
131:12 - okay
131:13 - so the code says that
131:17 - there is a variable array1 that is an
131:19 - array of abcd and e
131:23 - okay and there is an array 2
131:26 - which is a value
131:27 - and that is a array of e f g h and i
131:31 - ok so when i do array 1 is equals to
131:33 - array 2
131:34 - so array 1 is a variable
131:37 - and that can be
131:39 - reassigned
131:41 - so
131:41 - that that that is reassigned a value of
131:45 - array 2 so that can be done but this
131:47 - this line shows an error why this line
131:50 - shows an error because array 2 is in
131:52 - value so we cannot reassign a value
131:57 - okay so that's why it shows an error
132:00 - moving forward
132:03 - so yeah
132:04 - there is a value array 2
132:07 - and which contains
132:09 - the elements e f g h and i
132:12 - so however we cannot reassign the
132:15 - array 2 we can change the elements of
132:18 - array two this is a major point to note
132:22 - okay
132:24 - so we have already understood array with
132:26 - different data types
132:28 - okay so arrays are mutable but have
132:30 - fixed sizes as i already said
132:34 - and
132:36 - so
132:37 - what if i have to
132:39 - print any element of an array
132:41 - so suppose i have to
132:43 - print
132:45 - the third element of array
132:48 - one
132:49 - so uh what i mean by third element is
132:52 - the the first element
132:54 - the a is the zeroth element
132:57 - okay as as we done the indexing in the
133:00 - string similarly the indexing is done in
133:03 - the arrays
133:06 - so when i have to print the
133:09 - third element of array1 what i'll do is
133:12 - i'll just write
133:14 - array1
133:15 - and open a square bracket and write 3
133:18 - here
133:19 - and when i run this code
133:22 - we can see that
133:25 - the
133:26 - third element
133:28 - of array1 is printed
133:32 - okay
133:36 - there is a problem okay
133:40 - so
133:42 - when i run this program
133:48 - we can see that the third element of
133:51 - array one so what what happened here is
133:54 - i reassigned the array one as array two
133:57 - so the third element of array two is
133:59 - printed here e is the zeroth f is the
134:01 - first g is the second and h is the third
134:04 - so i'll just delete this code
134:08 - and
134:09 - again run this code
134:10 - so i'll find the third
134:14 - element of array one that is d
134:17 - okay
134:18 - so now what if i have to reassign
134:22 - the
134:23 - the third element of array two
134:25 - so we will try it on array 2 because
134:28 - error 2 is a value
134:30 - so i will just
134:32 - type array
134:33 - 2
134:35 - so i will just reassign the 0th element
134:37 - of array 2 as a string
134:40 - 3
134:43 - assigned
134:46 - now it shows an error
134:48 - so what error does it show that
134:51 - there is a type mismatch
134:52 - so it was an uh
134:56 - it was in character and now we are
134:58 - reassigning it as a string
135:01 - so that is not possible in kotlin so
135:03 - what i'll do is i'll just reassign it
135:05 - with the character
135:07 - and now i'll
135:10 - print
135:12 - the
135:14 - first element
135:16 - of array the zeroth element of array two
135:20 - so now when i run this program
135:24 - i can see that
135:26 - r is printed
135:28 - so
135:29 - even in a value
135:31 - even in a value
135:33 - of an array
135:35 - the the
135:37 - the element of an array can be
135:39 - reassigned even if it is a value not a
135:41 - variable
135:43 - okay so that's all for this video stay
135:45 - tuned for
135:48 - in the previous video we have discussed
135:50 - about arrays in kotlin and in this
135:53 - particular video we are going to uh
135:56 - learn about
135:57 - areas of string
135:59 - okay or an area of strings
136:02 - so uh i'll just go ahead and create a
136:05 - main function
136:07 - and inside the main function i will just
136:11 - create a variable
136:13 - string named string array
136:16 - and
136:18 - so uh if you remember for creating an
136:21 - array we have to use
136:22 - array of function and
136:25 - if
136:27 - we have to
136:28 - specify the data types we will use the
136:31 - less than and greater than sign and then
136:34 - we will use the open and close
136:35 - parenthesis and inside the open close
136:37 - parenthesis
136:38 - uh we will
136:40 - use the
136:44 - the the things that we have to add to
136:46 - this
136:47 - okay so uh i'll just create a string uh
136:50 - the array of string
136:53 - containing some strings so i'll just
136:55 - write hi
136:57 - this
136:58 - and again string
137:00 - is
137:02 - and again string
137:05 - programming
137:09 - knowledge
137:11 - okay
137:12 - so uh it is a string
137:16 - it is an area of string containing four
137:18 - strings
137:21 - okay
137:22 - so specifically it is called an array of
137:24 - strings
137:25 - so what if i have to get a particular
137:31 - at a particular index
137:33 - so what if i have to get the string at a
137:35 - particular index so i can use a
137:37 - function
137:40 - that is
137:41 - the name of string that is string array
137:44 - and then dot
137:47 - get
137:49 - and then open and close parenthesis and
137:51 - then zero
137:53 - okay
137:54 - so what this function get does it does
137:58 - that
137:59 - it just
138:01 - gets the
138:03 - particular string at the particular
138:05 - index mentioned
138:07 - so when it shows a green line so when i
138:12 - go to it and hit alt plus enter
138:15 - it
138:15 - shows that replace get call with
138:17 - indexing operator and when i hit enter
138:20 - it
138:22 - chooses the
138:23 - open and close square box
138:26 - square bracket
138:27 - so the get function is the same as the
138:30 - square bracket that we used in the
138:32 - previous video
138:33 - okay so now if i just skip that
138:37 - and
138:40 - okay
138:42 - and
138:44 - so what if i have to change the
138:48 - change the string at a particular index
138:50 - so as i mentioned in the previous video
138:53 - what i have to do is
138:55 - write the name of the string
138:57 - that is
138:59 - write the name of the array
139:00 - and then
139:02 - use the square bracket
139:04 - and
139:05 - if i have to change the
139:08 - string at the zero index
139:11 - so i'll just
139:14 - write here
139:16 - hola
139:18 - okay so uh it changes the
139:23 - string at the zeroth index okay
139:26 - so when i
139:28 - print
139:32 - the array
139:35 - what it does is
139:38 - so what happens when i print the whole
139:42 - array instead of printing a particular
139:45 - particular
139:46 - index of the array so it prints the this
139:49 - thing
139:50 - it prints l java lang string
139:54 - semicolon and this is an address
139:57 - so when i string when i print a
139:58 - particular array
140:00 - it it
140:01 - it shows that it is an array
140:04 - of containing strings and it shows its
140:06 - address
140:07 - that at this address the string is
140:09 - stored
140:10 - but it does not print that array
140:13 - so i'll just go ahead and print the
140:16 - zeroth element
140:18 - or the a string get element
140:20 - at index 0
140:23 - so we can see that
140:25 - the
140:26 - string at particular index
140:28 - has changed now what if i have to
140:32 - get the
140:34 - size of an particular array so for
140:36 - getting the size of a particular array
140:38 - is
140:39 - we use the function
140:40 - dot size
140:42 - so i will
140:43 - print write the print statement
140:46 - and then i'll write the string name
140:49 - sorry the array name and
140:51 - i'll just write dot size
140:55 - now when i run this
140:57 - program
140:58 - this the seventh line
141:01 - prints the size of an array
141:04 - okay and we can see that the size of an
141:06 - array is
141:09 - size of this array is four
141:13 - so that's correct
141:15 - now
141:16 - what if i have to
141:18 - make a whole string from an array of
141:21 - string
141:22 - like i have to
141:24 - make this a particular string
141:27 - so i'll just
141:28 - name a value
141:30 - that should be
141:32 - string
141:34 - and
141:35 - make that equal to so i'll just write
141:37 - the
141:40 - array name
141:41 - and
141:42 - i'll just
141:45 - type the
141:46 - function that is content to string
141:50 - now
141:51 - the string
141:53 - variable
141:54 - is a string that contains the
141:58 - the
141:59 - the content of the string array convert
142:02 - it to a string
142:04 - okay so content to string is a function
142:07 - that converts
142:08 - an array to an string
142:11 - now let's go ahead and print this
142:15 - string
142:18 - okay so when i run this function
142:26 - it prints hola this is programming
142:28 - knowledge but it shows that as an array
142:32 - why
142:34 - because we have converted it to string
142:36 - and string should be
142:37 - the value string should be n string
142:41 - so it isn't string but
142:43 - when i print this and also we can note
142:46 - that
142:47 - i have left spaces here so it also left
142:49 - leaves spaces here
142:51 - so whatever i not leave spaces here
142:54 - so it automatically detects that
142:57 - that it should be a string with four
142:59 - different words or four different string
143:03 - so it automatically leaves the
143:06 - spaces out of there
143:07 - so when i
143:09 - want to print a particular string
143:11 - particular area of string
143:14 - so i'll just
143:16 - instead of doing all this i'll just
143:20 - write the print statement
143:23 - and in the print statement i'll write
143:24 - the string name and then content to
143:27 - string
143:28 - so when i write
143:30 - only the string array
143:32 - it does not print the array it prints
143:35 - that this is an array and it contains it
143:37 - contains string and the location of the
143:40 - array is this the location at which the
143:42 - error is stored is this
143:44 - so for printing the whole string array
143:47 - we use this
143:49 - okay so that's all for this video stay
143:51 - tuned
143:54 - in this video we are going to cover
143:56 - the if else statements in kotlin
144:00 - so
144:01 - if you don't have any particular idea
144:03 - about if else statement what an if
144:05 - statement does is
144:07 - it checks and
144:09 - it checks in condition that if this
144:12 - condition is true then it goes to the
144:14 - particular
144:15 - body and then performs some operation
144:18 - and if that condition is not true it
144:19 - just skips the whole body and
144:23 - goes to the else statement
144:25 - and then it performs the operation
144:27 - mentioned in the else statement so it
144:29 - basically is
144:31 - like if this is true then this then do
144:33 - this and if else do this okay so
144:38 - we will just go through the syntax of
144:40 - the
144:41 - if else statement so it is the block
144:43 - body of an fl statement
144:45 - so uh when i write if some condition
144:49 - and then i'll uh so i'll write if is a
144:52 - keyword
144:54 - and then i'll
144:56 - open a parenthesis and write condition
144:58 - in there and i'll close this parenthesis
145:01 - and i'll open curly braces and i'll
145:04 - write function or we can say the
145:06 - operation we have to perform there and
145:08 - we will write we will close the curly
145:10 - brace and we will write the
145:13 - the keyword else
145:14 - and then we will open the braces and
145:19 - then i'll mention the operation or the
145:22 - function or the code that i have to
145:24 - perform
145:25 - and then i
145:27 - close the
145:29 - braces okay
145:30 - so this is the block body
145:33 - now i'll go ahead
145:35 - and
145:36 - create a main function
145:39 - and outside the main function
145:41 - i will create a
145:42 - function named block body
145:45 - because there are three types in which i
145:48 - can
145:48 - determine the effects
145:50 - statements so i'll just go one by one
145:54 - so for block body
145:57 - so we will take an example of finding a
146:00 - maximum from a and b okay
146:04 - so
146:04 - we will have to give
146:06 - the input
146:07 - a integer and
146:10 - b
146:14 - integer
146:16 - and
146:17 - the output the written type of this
146:20 - would also be an end because it returns
146:21 - the maximum
146:26 - so
146:26 - moving forward
146:29 - so i'll write the block body of fels
146:32 - statement here so if a is greater than b
146:37 - okay
146:38 - then what happens is so i'll just create
146:41 - a
146:42 - variable also here
146:44 - that is called max value
146:49 - okay
146:52 - so when a is greater than b
146:55 - what happens is
147:01 - when a is greater than b the maximum
147:03 - value is
147:08 - a
147:10 - okay
147:11 - and else
147:14 - when so else b would be greater than a
147:17 - so the maximum value would be
147:20 - b
147:23 - and we would return
147:27 - the maximum value which is max value
147:30 - okay so when i go in the main function
147:33 - and call the
147:36 - a block body function
147:38 - and
147:39 - [Music]
147:40 - find try to find the maximum of 23 and
147:43 - 45 and run this function
147:45 - so it should be printing the
147:49 - so it should not print anything because
147:51 - i haven't mentioned the print function
147:54 - so when i mention the print function
147:56 - here also
147:58 - and
147:59 - run the function again
148:02 - so it should mention here 45
148:05 - okay and it is correct so
148:08 - this might have give you this might have
148:10 - given you the basic understanding of the
148:12 - if else
148:13 - working okay so if a is greater than b
148:17 - then the max value should be equals to a
148:20 - and else if a is not greater than b else
148:24 - the max value should be equals to v
148:26 - okay
148:27 - so now i'll go ahead and
148:30 - give you the idea of expression body
148:34 - so
148:37 - what is expression body
148:41 - so also in this i'll be printing the
148:43 - maximum of
148:45 - the two
148:46 - so i'll just
148:49 - mention
148:51 - the a and b integer and the return type
148:53 - as end
148:55 - now in the expression body i mention the
148:58 - value
149:00 - variable
149:01 - max value
149:04 - and
149:05 - give it a
149:07 - value of if
149:08 - so here only i start from a function
149:12 - so if a is greater than b
149:15 - then the max value is e
149:18 - and
149:19 - okay
149:20 - a
149:21 - and else
149:24 - the max value is b
149:27 - now we can see that
149:30 - okay i have to also return the max value
149:36 - so now now we can see that we have
149:38 - assigned we have defined a variable
149:40 - named max value
149:42 - that is equals to if a is greater than b
149:45 - that is equals to a and else that is
149:47 - equals to b
149:48 - so this is called the expression body
149:51 - so now if i replace the block body with
149:53 - the x
149:55 - pression body
149:57 - and run this again
150:00 - so it should be working fine and it
150:02 - should print 45
150:04 - so yeah it is working fine
150:07 - so
150:09 - if if you see this type of code written
150:12 - anywhere it is also an fl statement
150:15 - now there is another type of fl
150:17 - statement that is a also short shorter
150:20 - than this and it is also called short
150:24 - so now i'll just mention a function
150:26 - short
150:27 - it will also be uh
150:30 - comparing two integers
150:32 - so i'll just
150:35 - initialize the function
150:38 - now
150:39 - it should be equals to
150:42 - no
150:42 - before that okay i should open it and
150:45 - i'll just return already
150:48 - written if
150:50 - a is greater than b
150:54 - if a is greater than b
151:02 - okay
151:03 - if a is greater than b then return a
151:07 - and else
151:09 - written b
151:12 - so now we can see that
151:14 - we have directly mentioned the written
151:16 - function and
151:17 - written a if a is greater than b and
151:20 - written b if a is not written in b so
151:23 - what it it it means that
151:25 - okay
151:26 - so instead of expression body when i
151:28 - mention
151:30 - short
151:32 - and i run this
151:34 - function
151:35 - around this code
151:37 - i can see that
151:39 - the answer is again 45
151:41 - so in this video we have learned about
151:43 - the block body the expression body and
151:45 - the short
151:47 - of if else expression and we have
151:51 - a pretty
151:53 - thorough idea about the if else
151:54 - statement
151:56 - okay thank you
152:00 - and in the previous video we have
152:02 - we have seen that
152:04 - what happens if we use an apple
152:07 - statement
152:08 - so
152:09 - if we have some condition we use an if
152:11 - else statement
152:13 - so what about if i have multiple
152:15 - conditions like
152:18 - if condition 1 is true then i have to
152:20 - execute particular code and then if
152:22 - condition 2 is true then i have to
152:24 - execute a particular code and then if
152:26 - condition 3 is true and then i have to
152:29 - execute a particular block of code
152:31 - so
152:32 - this can be
152:34 - this could be
152:36 - done via an elsif uh
152:40 - keyword okay
152:42 - so what i'll do is i'll just create a
152:44 - main function and inside the main
152:47 - function
152:48 - i'll
152:49 - create a variable that is equals to
152:52 - 5
152:55 - and
152:56 - what i'll do is
152:58 - i will create some
152:59 - conditions
153:02 - such as if
153:05 - i is equals to 5
153:08 - then i have to
153:11 - print
153:14 - that
153:15 - i is
153:17 - 5
153:19 - okay
153:20 - and then again
153:23 - uh else if i'll use the keyword else if
153:26 - and then pass the
153:29 - condition if i is equals to 4
153:32 - else if i is equals to 4
153:34 - i have to
153:36 - print
153:39 - i
153:40 - is
153:40 - 4
153:42 - ok
153:44 - so i can do that and
153:46 - there could be as many number of if else
153:49 - block as required
153:51 - so i can
153:53 - use like here
153:56 - as many if else block i required
153:59 - else if the block i required
154:03 - so i'll just
154:06 - make that
154:09 - i is three
154:11 - okay then again
154:12 - i'll use the keyword else if
154:15 - i
154:16 - is equals to 2 then i have to
154:20 - print that
154:23 - i is 2
154:25 - then again
154:27 - else if
154:39 - is
154:40 - one
154:41 - okay so at the end of the
154:43 - if else
154:45 - block or else if block
154:49 - we should must end with end it with the
154:53 - else statement so like what i am trying
154:56 - to say is else block is optional
154:58 - as
154:59 - said for fl statement so we can skip the
155:02 - else block in fl statement as well as
155:05 - when we use the effels ladder or
155:08 - the lzip blocks okay so i can here
155:11 - include the else statement
155:15 - or i can choose to skip that
155:18 - print
155:19 - i can
155:20 - choose the else statement like print
155:22 - i is not in
155:26 - not in one to five
155:30 - okay
155:32 - so
155:33 - i'll just
155:36 - change the value of i26 and then
155:39 - run this program
155:48 - so the
156:07 - so we can see here
156:08 - that
156:10 - the output is i is not in 1 to 5
156:12 - as mentioned in the else statement so
156:14 - when i
156:16 - change the value to 5 it will print that
156:19 - i is 5
156:21 - so the conditions are evaluated
156:23 - sequentially from top to bottom
156:25 - and if a condition is evaluated as false
156:28 - the condition the execution continues
156:30 - with the evaluation of subsequent
156:32 - condition
156:34 - okay so from here the
156:37 - the we enter in this code
156:39 - and we enter in this effects letter
156:42 - so the first condition is evaluated and
156:45 - if the first condition is true then we
156:47 - get out of the if else ladder
156:50 - and if the first condition is false
156:52 - we evaluate with the subsequent and this
156:54 - or the second condition
156:57 - okay and if the second condition if the
156:59 - uh and if any condition is true
157:02 - the corresponding block
157:04 - against the statement
157:06 - is executed and
157:08 - we are out of the if else letter
157:10 - and if none of the conditions evaluate
157:12 - to true
157:13 - runtime minutes runtime executes else
157:16 - block and
157:19 - that too if else block is present so as
157:22 - i'm i change the value of i to 6 the
157:25 - else box else block get gets executed
157:28 - because
157:30 - every condition is false in that
157:32 - particular case
157:34 - so that was if else ladder kotlin if
157:38 - else ladder
157:39 - so we can see here that the id is
157:41 - underlining this with a green
157:45 - so uh what it's what it is saying when i
157:47 - hover over it it's saying that cascade
157:49 - if should be replaced with when
157:52 - so don't you think that this code is a
157:54 - little bit of redundant like we are
157:57 - using lc pulse of lc a lot of times and
158:01 - suppose that i have 20 conditions
158:03 - so then
158:04 - i have to repeat 20 if else else if
158:07 - blocks
158:09 - so when i go to
158:13 - if uh statement and it shows that
158:17 - we should use when
158:18 - so now we will move on and study the
158:22 - keyword then
158:24 - so instead of
158:26 - doing this i'll just comment it out
158:29 - what i can do is i can
158:32 - use the keyword when
158:34 - and then uh
158:37 - and then
158:38 - what to check so like i'll just open
158:41 - paranthesis
158:43 - and
158:44 - write the variable that i have to check
158:47 - okay
158:48 - so when i okay
158:50 - and then
158:52 - i'll
158:53 - open this
158:56 - code
158:57 - and
159:00 - then i'll provide the values of i
159:02 - and
159:04 - if i is 1 okay so then i'll
159:07 - just use hyphen and
159:09 - greater than same
159:11 - and
159:12 - then i'll
159:14 - open a
159:16 - code block and then i'll write
159:19 - println
159:23 - i is one
159:25 - okay so what this when block does is
159:29 - when i went enter this when block when
159:32 - still when statement
159:34 - uh
159:34 - it assigns
159:36 - a condition that when i is 1 okay
159:40 - so when i write
159:43 - below that
159:44 - 2
159:45 - and then i open a code block
159:49 - okay so what whatever what it will do is
159:53 - it will
159:56 - pass the
159:57 - pass it will execute this statement when
160:00 - i is 2
160:02 - okay so
160:03 - like this is just one liner code so i
160:06 - have to write just print code so i will
160:09 - not use the
160:10 - curly braces i'll just
160:14 - type that when i is 3 println i is 3
160:17 - okay when i is 4
160:20 - println i is
160:23 - 4
160:23 - and when i is 5
160:28 - println i is
160:30 - 5
160:31 - ok so after all of this
160:34 - what i can do is
160:36 - i can
160:37 - just use an else statement so what if
160:41 - any of this is not true like i is not
160:43 - equal to one two three or four or five
160:46 - okay so i'll just use else statement and
160:49 - i'll i'll also have to use the hyphen
160:51 - and the greater than sign for that
160:53 - okay and i can use the curly braces if i
160:55 - want
160:57 - and
160:58 - i can
160:59 - write that
161:01 - i is
161:03 - not in
161:04 - is
161:05 - not in 1 to 5
161:08 - ok so when i execute this code
161:11 - when i execute this code
161:13 - so i is 5
161:15 - and then
161:16 - we enter this
161:18 - when i co block and then it checks that
161:21 - whether i is 1 or not then whether i is
161:24 - 2 or not then whether i is 3 or not so
161:27 - after checking and getting this is false
161:30 - it's exactly whether i is 5 or not so i
161:33 - is 5 in this case and then it prints
161:35 - that i is 5 and then it gets out of this
161:38 - when um
161:39 - [Music]
161:40 - when for function or when keyword okay
161:44 - so when i provide that i is equals to 6
161:48 - okay
161:50 - and then this
161:53 - so
161:53 - i have not mentioned here what to print
161:56 - when is 6 but i have mentioned that what
161:59 - to print when i is not in 1 to 5 which
162:01 - is the else statement
162:03 - so
162:04 - that prints that but what happens when i
162:07 - doesn't i don't don't use the else else
162:09 - keyword
162:11 - okay so
162:13 - when i don't use the else keyword and
162:16 - the i is six
162:19 - what happens is the codes get executed
162:22 - and
162:24 - it is it does not print anything so
162:26 - when
162:27 - else
162:28 - keyword is not required so i don't have
162:31 - to mention else keyword and it is not
162:33 - necessary but it is a good practice as
162:37 - if the condition is not to if any
162:39 - condition is not true there is something
162:41 - to execute
162:43 - otherwise
162:44 - nothing will be executed
162:46 - okay
162:47 - so after that
162:50 - we have nested effects
162:52 - so what happens if i have
162:56 - condition 1
162:57 - and condition 2 so
162:59 - i have like
163:02 - if condition 1 is true then i have to
163:04 - check second condition
163:07 - so in that case
163:09 - we use nested effects
163:11 - we can nest an fl statement inside
163:14 - another fl statement
163:16 - when when we say if
163:18 - else in this context it could be if
163:21 - statement or if else statement or if
163:24 - else if statement
163:25 - okay
163:27 - so
163:28 - i'll just use an example
163:31 - for this
163:32 - nested
163:34 - defense uh so if
163:38 - uh
163:39 - i is
163:41 - five
163:42 - okay
163:43 - uh i'll use two
163:46 - okay if i is five and then i have to
163:48 - check that if i is odd or not
163:50 - so that doesn't make sense but for
163:53 - understanding purpose it should make
163:54 - sense so if i is
163:57 - divisible by
163:58 - if
163:59 - if i is divisible by 2 i have to check
164:01 - that so if i
164:03 - divided by 2
164:05 - is 0
164:06 - so then i is even
164:09 - so i have to print
164:11 - ln that
164:13 - i is
164:14 - 5 and
164:17 - even
164:19 - okay
164:20 - and i can just do that also but uh
164:24 - as i mentioned that using an else
164:26 - statement is a good practice
164:28 - so else
164:30 - print again
164:32 - i
164:34 - is
164:35 - file and odd
164:38 - and i can again use an else statement
164:40 - here that
164:44 - print helen
164:46 - i is not equal to
164:51 - five
164:53 - okay so when i run this
164:56 - function
164:57 - or run this code
164:59 - what i'll find is
165:01 - it prints the statement i is not equal
165:03 - to 5 because i have mentioned that i is
165:05 - equals to 6 i'll just go ahead and
165:07 - change the variable i is equals to i
165:10 - and then again run this statement
165:13 - okay so i can find the output is
165:16 - i is five and odd because i is five are
165:18 - not okay
165:20 - so uh
165:22 - here you can see that i have nested an
165:24 - excel statement
165:26 - under an fl statement okay so if this is
165:28 - the case then i have to check that if
165:30 - this is the case or not and if this is
165:33 - not the case then i have to print this
165:35 - okay
165:36 - so this is the example for
165:38 - nested if else
165:40 - and in this video we have covered what
165:42 - is nested apple's what is apple's ladder
165:45 - and when to use when keyword thank you
165:47 - for watching this video
167:01 - and in this video
167:02 - we are going to
167:03 - use the logical operator with if else
167:07 - so
167:08 - what are logical operators logical
167:10 - operators help us make logical decision
167:13 - so logical operators are basically of
167:16 - three types logical or logical not or
167:19 - logic and logical and
167:22 - so
167:24 - the result of any logical operator
167:27 - is always
167:28 - an boolean value
167:31 - okay and
167:32 - logical operators are mostly used to
167:34 - evaluate two conditions
167:38 - so
167:39 - i'll just mention
167:42 - the logical or
167:45 - operator so we will use this sign for
167:47 - logical or operators
167:49 - and for logical and operators we will
167:53 - use
167:54 - the ampersand two times
167:57 - and we will use the this sign for
167:59 - logical and operators and for logical
168:01 - not operator
168:02 - i'll use the exclamation mark
168:07 - so let's just go ahead and understand
168:10 - about
168:11 - these operators
168:13 - so
168:15 - i'll just create a
168:17 - main function and then inside the main
168:19 - function
168:20 - uh i'll
168:22 - create a if if
168:23 - if block so
168:25 - i have to
168:27 - evaluate a condition
168:29 - like if this is true or that is true
168:32 - okay so if i is equals to 5
168:36 - before that i have to just mention the
168:39 - variable i
168:40 - is equals to 3 okay so if i is equals to
168:43 - 5
168:44 - or
168:47 - i is equals to
168:49 - 3
168:50 - okay in that case
168:52 - i'll
168:54 - print
168:55 - that i is
168:58 - i
169:00 - is either
169:02 - five or
169:04 - three
169:05 - okay
169:06 - so that is the basic meaning of an or
169:09 - operator
169:11 - okay so when i use an or operator
169:14 - um what it does is
169:17 - it checks the first condition
169:19 - and it takes the second condition also
169:21 - that's let's say that first condition is
169:22 - i equals to five and second condition is
169:24 - i is equals to three so when i use the
169:27 - or logical or operator if the first
169:29 - condition is true
169:31 - and the second condition is true
169:33 - then the output is also true
169:36 - and
169:37 - if the first condition is true and the
169:40 - second condition is false then also the
169:42 - output is true if the first condition is
169:44 - true and if this first condition is
169:46 - false and the second condition is false
169:49 - then also the output is
169:52 - true
169:53 - and
169:54 - only in the case when both the condition
169:56 - are false then only the output is false
170:00 - okay
170:00 - so let's just go ahead and
170:03 - run this
170:05 - program and get a better understanding
170:07 - of what i said okay
170:09 - so
170:11 - here i is three so this is true and but
170:14 - this is not true
170:16 - but you we can see that
170:18 - the
170:19 - output of this this condition this
170:22 - condition as in whole is true
170:25 - so i'll just go ahead and change the
170:27 - value of is4
170:30 - now
170:31 - i can see that both of the conditions
170:33 - are false
170:35 - so it's just it does not go into the if
170:38 - block and just skips that
170:40 - it is because that the both conditions
170:43 - are false then only
170:45 - the
170:48 - the code does not get executed okay so
170:50 - i'll just go ahead and create a new
170:52 - variable
170:54 - a
170:55 - and give it that value as five
170:58 - now
170:59 - uh i'll use the end operator and logical
171:02 - operator
171:03 - okay
171:05 - so
171:05 - if i is 5 and a is
171:09 - 5
171:10 - then print
171:12 - i is
171:14 - 5 and a is 3.
171:18 - okay
171:20 - now uh
171:21 - just we will just understand this so
171:23 - what is and logical operator
171:26 - so it it it should say that um
171:30 - my condition 1 should be true and my
171:32 - condition 2 should be true
171:35 - okay
171:35 - so
171:37 - here my condition 1 is i is 5 and my
171:40 - condition 2 is a is 5 so when both
171:42 - conditions are true
171:44 - then only the output is true
171:46 - now suppose any one of my condition is
171:48 - false and the another condition is true
171:52 - then
171:53 - the output of this is false because
171:57 - when i check this that you know i is
172:00 - equals i should be equal to five and a
172:02 - should be equals to five but when i is
172:05 - not five and a is five
172:06 - uh the if block is not executed because
172:10 - it
172:11 - when i use the end operator if block is
172:14 - only executed when both conditions are
172:16 - true okay and if both conditions are
172:18 - false then then also it will not get
172:21 - executed so when i run this program
172:25 - i can i can predict that
172:28 - it does not get into the if if let it
172:31 - block and yes it does not get into the
172:33 - if block
172:35 - so i'll just change the value of i is
172:38 - five
172:42 - and
172:43 - i can see that okay so my bad
172:46 - and yes
172:48 - the if block gets executed when both
172:51 - conditions are true
172:52 - so that was about the end logical
172:55 - operator now what about the not logical
172:57 - operator
172:58 - so
172:59 - when i use the
173:02 - logical operator like
173:05 - you you can remember when i was
173:09 - covering operators
173:11 - i used
173:12 - exclamation mark equal to that
173:13 - represents not equal to okay
173:16 - so when i use i
173:18 - not equal to 5 and i change here i7
173:24 - the if block will get executed here
173:27 - because i is not equal to 5
173:29 - as simple as that
173:31 - okay so the logical not is used to
173:36 - negate the condition whenever the
173:37 - condition is true the output is false
173:40 - and whenever the condition is
173:42 - false the output is true
173:44 - okay
173:46 - so
173:50 - like till now we have covered
173:52 - the
173:53 - logical operators in
173:55 - f else
173:57 - and
173:59 - the
174:01 - if else ladder the
174:03 - nested effects
174:05 - okay
174:06 - in the next video we will
174:08 - cover
174:10 - another topic
174:13 - and in this video we are going to learn
174:16 - about the in operator in kotlin language
174:19 - so to study the inoperator
174:23 - we i would like to consider that the
174:25 - example to declare a variable and check
174:28 - if it is it lies within a specific range
174:32 - okay so i have a main function
174:37 - and inside the main function i will
174:39 - create a value
174:41 - n is equals to 5
174:44 - and i have to check that
174:46 - if the values lie in 1 to 10 or if the
174:49 - values lies in 2 11 to 20
174:53 - so i'll just create a
174:55 - if statement
174:56 - if n is greater than 0
175:00 - uh or i can say that greater than equals
175:04 - to 1
175:06 - and
175:07 - so i'll
175:08 - just introduce the logical operator and
175:13 - and
175:15 - n should be less than or equal to 10
175:17 - okay so if that's the case
175:20 - uh
175:21 - then i should
175:23 - print
175:25 - that
175:27 - n is in 1 to 10
175:31 - okay
175:32 - and
175:33 - else if
175:36 - um
175:37 - n is
175:38 - less than n is greater than equals to
175:41 - 11
175:42 - and
175:44 - n is
175:47 - less than equal to
175:49 - 20
175:51 - so i have to
175:53 - print
175:54 - that
175:56 - and is in
175:59 - is in
176:00 - 11 to
176:01 - 20.
176:04 - or i can
176:06 - introduce an else statement as well
176:09 - which
176:10 - prints
176:11 - that
176:12 - n
176:13 - is not in
176:16 - 1 to 20
176:18 - okay so when i go ahead and run this
176:21 - function or this code
176:24 - what i'll find is uh the
176:27 - the function checks
176:29 - if the variable lies within a specific
176:32 - range
176:34 - okay so our our variable
176:36 - or the value n was equals to five
176:39 - and
176:40 - it lies in 1 to 10
176:42 - so just
176:44 - if we let the
176:47 - code to finish
176:48 - okay so it prints that analyzing n is in
176:52 - 1 to 10. okay
176:55 - so uh when i see the code it
176:58 - underlines this with a line okay so when
177:01 - i hover over it and hit alt plus enter
177:05 - it says that convert to a range check
177:08 - okay so when i click on that
177:10 - it it prints n in 1.10
177:15 - okay
177:16 - so
177:17 - the in operator this is the in operator
177:20 - we are going to study okay so instead of
177:24 - uh this whole thing n is greater than 11
177:27 - and
177:28 - our logical operator and n is less than
177:30 - equals to 20 what we can do is we can
177:33 - use the in operator
177:36 - okay so what in operator does is
177:38 - in the in operator
177:39 - uh
177:41 - iterates or i can say
177:45 - checks the
177:47 - in the range okay so what i can do here
177:49 - is i can just write n in
177:52 - 11.20
177:55 - so
177:56 - it automatically
177:59 - introduce this signs
178:01 - and
178:02 - it states that
178:05 - and
178:06 - we will check n in 11 to 20 and both
178:10 - will include
178:12 - the
178:12 - uh equal to sign okay so instead of
178:15 - using now when i see the if statement
178:19 - it also
178:22 - is underlined so when i hover over it it
178:24 - shows that cascade if should be replaced
178:27 - with when and when i go uh on it and hit
178:30 - alt plus enter it shows replace if with
178:33 - when and then i hit enter
178:36 - it replaces it with the when statement
178:39 - okay
178:40 - so the kotlin or the i can say the
178:43 - intellij idea is very useful and it's
178:47 - just most of the things
178:49 - to make the code easier and readable and
178:52 - less redundant
178:54 - okay
178:55 - so that was it for this video stay tuned
179:02 - in this video we are going to study
179:04 - about the loops in kotlin
179:07 - so before studying the loops the first
179:10 - question that should arise is
179:12 - why are the loops used or
179:15 - why should we use the loop
179:18 - so
179:19 - when i have to print uh the numbers from
179:23 - 1 to 10
179:25 - or i have to print
179:28 - a variable
179:30 - that is i and increase the variable
179:32 - after each print statement so
179:35 - what i can do is i can write a variable
179:38 - that is equals to 1
179:40 - okay and then i can write a print
179:42 - statement
179:44 - to print i
179:46 - and then i can increase the i okay
179:49 - and
179:51 - i can
179:52 - repeat the same block of code
179:54 - again and again to
179:58 - execute the statement
179:59 - okay so if i said if i said i have to
180:03 - print all the natural numbers from 1 to
180:06 - 10
180:07 - so firstly i have to
180:09 - repeat the particular block of code
180:11 - again and again and
180:13 - i cannot know where to stop
180:16 - or i have to manually
180:19 - count the number of iterations
180:22 - so
180:23 - like i have here you written the code
180:26 - and it prints all the natural numbers
180:27 - from one to five so this is
180:30 - a redundant code and uh it requires a
180:33 - lot of
180:36 - lot of
180:39 - like
180:39 - i have to count the uh
180:42 - the the number of iterations and it is a
180:44 - redundant code so
180:46 - what could we do
180:47 - to make it less redundant
180:50 - and
180:51 - short code and organized code so we can
180:54 - use
180:55 - loops instead of repeating the same
180:56 - block of code again and again
180:59 - so what is a loop a loop is something
181:02 - repeating itself okay so when you listen
181:05 - to song you put them on loop so what it
181:08 - does it it
181:10 - it repeats the song
181:12 - after the song is completed
181:15 - okay so there are three types of looping
181:17 - loops in kotlin for loop while loop and
181:20 - do while loop
181:22 - so
181:23 - let's say we want to print all the
181:26 - natural numbers from 1 to 10
181:29 - okay
181:30 - so firstly
181:33 - we can see
181:34 - what is the syntax
181:36 - for for loop
181:38 - so the syntax is
181:42 - uh for and here is the condition
181:45 - and then the loop starts
181:48 - okay
181:49 - and
181:50 - then the code ends
181:53 - and
181:54 - between this
181:56 - there is a particular
181:57 - code sequence
182:00 - that got that gets repeated in each
182:03 - iteration
182:04 - okay so we use the keyword for and then
182:07 - we introduced some parameters that
182:09 - uh checks the
182:11 - the condition and increase the iterator
182:14 - and initialize the iterator okay and
182:17 - then at the end we close the curly
182:20 - braces and
182:21 - the code inside the curly braces gets
182:24 - repeated
182:25 - at each iteration
182:28 - okay so
182:30 - uh
182:31 - let's say we want to fill uh print all
182:34 - the natural numbers from 1 to 10 okay so
182:37 - we know that loop repeats a particular
182:39 - code sequence
182:40 - now we also need something to count from
182:43 - 1 to 10 hence a counter is needed
182:46 - that must be incremented incremented at
182:49 - each iteration
182:51 - okay
182:52 - so
182:54 - as we have already discussed the syntax
182:55 - for for loop let's go ahead and
182:58 - make a code to print all the natural
183:00 - numbers from one to ten okay so i'll
183:03 - write for
183:04 - now
183:06 - remember we have learned about the ins
183:08 - in
183:09 - in
183:10 - statement in kotlin
183:12 - so i will uh introduce the iterator here
183:16 - okay so for
183:19 - uh the iterator
183:21 - must
183:22 - like
183:23 - if it not if it is not initialized
183:26 - outside the for loop it is okay
183:28 - so i'll initial i'll initialize i here
183:31 - and use the in operator
183:33 - okay so i in now 1 to 10
183:36 - okay
183:37 - as i mentioned if i have to
183:42 - for particular condition 1 to 10 i use
183:44 - the inoperator and the two dots okay so
183:46 - for i in 1 to 10
183:49 - okay and then i have to just go ahead
183:52 - and print i
183:54 - okay
183:55 - so when i
183:57 - run this
183:58 - function
183:59 - or on this particular block of code
184:02 - i can see that
184:04 - it prints all the natural numbers from 1
184:07 - to ten
184:08 - okay
184:10 - so uh
184:13 - there are some points that i would like
184:14 - to point out
184:16 - like for in the for loop there is no
184:18 - need to initialize the iterator as i
184:20 - already mentioned
184:22 - and there is no need to increase the
184:24 - operator in for loop okay so you can see
184:27 - that i haven't have not write the
184:30 - i plus plus here
184:32 - okay because
184:34 - when i write i plus plus here we can
184:35 - show we can see that there is a
184:39 - error and it shows that well cannot be
184:41 - reassigned
184:42 - so whenever i enter in the for loop
184:45 - i vary value i is created and it is
184:48 - assigned the particular
184:51 - number that
184:53 - that the loop is giving going on okay so
184:56 - it is a value not a variable
184:58 - in for loop
185:00 - the i although its value changes after
185:02 - each iteration but it is a value not a
185:05 - variable okay so the default increment
185:07 - of an iterator is
185:09 - ah one
185:11 - so as you uh might have seen that
185:15 - iterator after each iteration increase
185:17 - by 1 not by 2 naught by 3. so whatever i
185:20 - have to
185:20 - print all the odd numbers in 1 to 20
185:24 - so then i have to
185:26 - iterate i in 1 to 20
185:29 - and i have to also increase the
185:31 - iterator by two so for increasing the
185:34 - iterator by two
185:35 - we need to use the step function so i'll
185:38 - just write here step two
185:40 - now what the step function does is it
185:42 - increases the iterator by two so when i
185:44 - go ahead and run this function
185:47 - we can see that after each iteration the
185:50 - iterator increases by 2 and hence prints
185:52 - all the odd numbers from 1 to 20.
185:56 - okay
185:57 - now whatever i have to
186:01 - print all the natural numbers from 10 to
186:04 - 1
186:05 - not from 1 to 10
186:06 - so you might think that
186:09 - i can write here
186:10 - 10.1
186:12 - okay
186:14 - so when i go ahead and
186:16 - run this
186:17 - function
186:23 - you can see that
186:25 - it just exits it just exits with
186:30 - code zero okay why why why it happens
186:33 - because
186:34 - at the particular point when it enters
186:37 - the for loop it is assigned the
186:40 - it is checked that if it isn't 10 or 10
186:43 - to 1 okay
186:44 - it must be greater than or equal to 10
186:48 - and less than or equal to 1 so there is
186:51 - no integer that is greater than equal to
186:53 - 10 or less than equal to 1
186:55 - okay and i would like to mention one
186:57 - thing also
186:58 - whenever i define
187:00 - anything like this okay i just mentioned
187:02 - it 11. so whenever i defined anything
187:04 - like this the by default um
187:07 - value assigned to i is the first value
187:10 - here okay so in this case the by default
187:13 - value assigned to i is 10 now
187:17 - getting back to our original question
187:18 - that what if i have to
187:20 - print all the statement from 10 tool so
187:23 - i will use the down 2 function
187:25 - so for out i in 1
187:30 - i in 10
187:31 - i in
187:32 - 10
187:34 - instead of the two dots i'll use down 2
187:37 - and one
187:38 - so
187:39 - in this we can see that the i should be
187:43 - less than equals to 10 and greater than
187:45 - equals to one so now when i go ahead and
187:49 - print this
187:52 - we can see that it prints all the
187:55 - natural numbers from 10 to 1
187:58 - so that is about the
187:59 - down to function
188:01 - okay
188:04 - so uh in the next video we will see
188:08 - about
188:09 - the wide and the dual loops and cotton
188:11 - this is all for this video thank you
188:15 - in this video uh we are going to discuss
188:17 - about the while and the do while loop in
188:19 - kotlin okay so in the previous video we
188:22 - discussed about the for loop and cotton
188:23 - and the basic idea of loop so loop is
188:26 - used in programming to repeat a specific
188:28 - block of code until certain condition is
188:30 - met
188:31 - okay
188:32 - so loops are what makes computer
188:35 - interesting machine imagine you need to
188:37 - print a sentence 50 times on your screen
188:40 - you can do it by using a
188:43 - print statement 50 times
188:45 - or you can use loops
188:48 - so
188:49 - we will start with the while loop
188:51 - and
188:52 - firstly we will discuss the syntax of
188:55 - the while loop
188:56 - okay so for while loop we will first
189:00 - write the keyword while and
189:04 - inside and open a parenthesis and inside
189:07 - the parenthesis
189:08 - we will write the text expression or i
189:11 - can say the
189:13 - condition okay so when the condition is
189:16 - true uh it enters the
189:19 - the code block
189:21 - and
189:22 - there is a code sequence
189:25 - and
189:26 - after this there is a we close the
189:29 - parenthesis okay so
189:31 - the curly braces okay so
189:35 - whenever the text expression is true
189:38 - it enters into the code sequence and the
189:40 - particular code sequence is repeated
189:43 - okay so test expression inside the
189:45 - parenthesis is a boolean expression if
189:47 - the test expression is evaluated to true
189:50 - statement inside the while loop are
189:52 - executed then the test expression is
189:55 - evaluated again this process goes on
189:58 - until the test expression is evaluated
190:00 - to false
190:01 - if the test expression is evaluated to
190:03 - false while loop is terminated okay
190:07 - so
190:08 - now we will
190:10 - take an example of while loop in which
190:13 - we will print
190:15 - um
190:17 - line five times
190:19 - or ten times okay
190:21 - so
190:22 - uh
190:23 - i'll in the main function i'll just
190:25 - introduce a variable
190:28 - so unlike a for loop
190:31 - we have to initialize and increment the
190:33 - variable in while okay then i'll use the
190:37 - while keyboard and
190:39 - while i is
190:40 - less than or equal to 10 okay
190:43 - i have to
190:45 - print
190:47 - i
190:48 - and at the end of the loop i have to
190:50 - increase i also
190:53 - okay i have to increment the value of i
190:56 - if i have not incremented the value of i
190:59 - the
191:00 - the y loop couldn't have ended
191:03 - okay
191:04 - so
191:05 - when i run the program the output is
191:18 - okay so when i run the program the
191:20 - output is
191:21 - okay instead of i is 5 i have to make i
191:25 - is 1
191:28 - and when i run the program the output is
191:33 - 1 2 3 4 5 6 7 8 and 10 okay
191:37 - so
191:38 - notice that plus plus i statement yeah
191:40 - or i plus plus statement inside the
191:42 - while loop
191:44 - okay so we have incremented i
191:46 - at the end of i loop after 10 iteration
191:49 - i will be incremented to 11 okay so if i
191:53 - uh
191:54 - print the value of i here
191:58 - so i would be equal to 11 at this
192:00 - particular case okay
192:02 - so it goes back to the test rate stress
192:05 - test statement and the condition i is
192:08 - less than equals to 10 is
192:10 - false okay
192:12 - so therefore the loop terminates
192:15 - so if the body of loop has only one
192:17 - statement
192:19 - it is not necessary to use a curly brace
192:22 - as we did in the
192:24 - if and the
192:25 - when
192:26 - statements
192:29 - so
192:30 - now we will move forward to the do while
192:32 - loop
192:34 - so
192:36 - the syntax for the
192:38 - do by loop is
192:42 - there is a
192:46 - we will firstly write the
192:48 - do
192:50 - okay i'll just remove this we will
192:52 - firstly write the do keyword and then
192:57 - and then write a code sequence
193:00 - and
193:02 - after this we will end this
193:04 - and
193:05 - after this code sequence i'll write
193:07 - while
193:09 - while keyword and then here i will write
193:11 - the
193:12 - test expression
193:16 - okay
193:18 - so
193:20 - we will first
193:21 - discuss the that how do while loop work
193:24 - so
193:25 - the code inside the body of do construct
193:28 - is executed once without checking the
193:31 - test expression then the test expression
193:33 - is checked if the test expression is so
193:36 - the code is
193:37 - executed once and then the text
193:39 - expression is checked okay so if the
193:41 - test expression is evaluated to true
193:43 - code inside the body
193:45 - of the loops are executed once again
193:49 - okay and the test expression is
193:50 - evaluated again the process goes on and
193:53 - on until the test test expression is
193:56 - evaluated to false okay so when the test
193:59 - expression is evaluated to false do
194:01 - while loop terminates so what is the
194:03 - main difference between while and the do
194:05 - while loop is
194:07 - in do while loop the
194:09 - code sequence is executed at least one
194:11 - time
194:13 - and
194:13 - even if the test expression is false
194:17 - okay
194:18 - as not in the while loop because in
194:21 - while loop it will first check the
194:23 - condition and if the test expression is
194:26 - false it will just go on to the it will
194:28 - just terminate the loop okay it will not
194:30 - go on in the body of the loop
194:33 - so
194:34 - now we will um
194:36 - go ahead and try the same with the do
194:39 - while loop and
194:41 - print the
194:43 - in natural numbers from one to ten so
194:46 - i'll
194:47 - write do and then in the code sequence
194:49 - i'll write
194:50 - print statement and
194:53 - before writing the print statement i
194:54 - have also
194:55 - i have to also initialize a variable
194:59 - that is i
195:00 - and then inside the print statement i
195:02 - have to print the variable and
195:04 - increment the
195:06 - variable because if i had not
195:08 - incremented the variable the loop will
195:11 - go on and on and on and
195:13 - will not stop
195:15 - okay so then i'll use the while keyword
195:17 - and inside the while keyword i'll write
195:19 - i is less than equals to 10
195:21 - okay and then when i run this
195:24 - program
195:26 - i can find that the output is
195:31 - 1 to 10 okay
195:33 - so
195:34 - now what if i had not incremented this
195:38 - and i had just used the print statement
195:40 - as i mentioned the loop will go on and
195:43 - on and on and it will not stop on its
195:45 - own so now what to do if the loops goes
195:47 - on and on so in the command prompt you
195:50 - will just
195:51 - do control plus c
195:53 - okay or you can do is
195:55 - terminate the loop from here the stop
196:00 - okay
196:01 - so take care
196:03 - in mind that um the loop will not
196:05 - continue to infinite
196:08 - and
196:09 - mention the increment statement here
196:11 - so till now we have covered about about
196:14 - the loops and basic
196:16 - example not i i will not say example we
196:19 - have just learned the syntax from here
196:21 - okay so you might have a pretty good
196:24 - understanding of loops
196:26 - okay thank you
196:28 - and in this video we are going to learn
196:31 - about the break expression in cotton
196:34 - okay
196:35 - so
196:36 - suppose you are working with loops and
196:39 - it is sometimes desirable to terminate
196:41 - the loop immediately without checking
196:43 - the test expression
196:45 - okay
196:46 - so i have to terminate the loop at some
196:48 - point
196:50 - so what i can do is in such cases i can
196:52 - use the break statement
196:54 - okay so i'll just
196:56 - go with the random example
196:58 - like i i started a loop and
197:02 - if
197:03 - the something occurs then i have to
197:05 - break the loop okay
197:06 - so then i have to use the break
197:08 - statement for terminating the loop
197:11 - without checking the test expression
197:15 - okay
197:16 - so the break statement terminates the
197:19 - nearest and closing loop when
197:20 - encountered without checking the test
197:23 - expression
197:24 - okay so how break works it uh it is
197:27 - almost always
197:29 - used with if else statement
197:32 - okay
197:33 - so uh
197:35 - i'll just
197:37 - introduce you with the syntax of
197:41 - this break
197:42 - so what what what i will do is uh in the
197:45 - for there is a for loop
197:47 - okay in which
197:48 - there is a for loop in which if
197:51 - there is some
197:53 - test expression
197:57 - if there is some test expression then i
197:59 - have to
198:01 - break the loop
198:03 - i have to terminate the loop so i will
198:05 - use the break statement
198:06 - okay
198:09 - and
198:10 - i'll use
198:12 - okay
198:13 - so if test expression is evaluated to
198:16 - true break is executed which terminates
198:19 - the for loop
198:21 - okay
198:23 - so uh
198:24 - now i'll go
198:26 - explain you with an example
198:28 - so i'll create a main function and
198:30 - inside the main function
198:31 - i'll create a for loop
198:34 - which iterates from
198:36 - 1 to 10
198:38 - okay
198:39 - and
198:40 - in this if i is equals to 5
198:43 - if
198:44 - i is equals to 5 then i have to
198:47 - terminate the loop
198:48 - okay so i'll use just
198:50 - the break statement here
198:53 - and i'll
198:54 - print ln
198:56 - i
198:57 - just to know that what is happening in
199:00 - the loop so when i go ahead and run this
199:03 - function
199:04 - what i can see is
199:08 - the the what i can see is 1 to 4 is
199:11 - printed
199:12 - so uh when the value of i is equals to 5
199:15 - okay so we enter in the for loop i is
199:18 - assigned value equals to 1
199:20 - and then
199:21 - it checks whether the i is 5 or not so i
199:24 - is not 5 then it prints i and then in it
199:27 - increases i equals to 2 and then it
199:29 - again checks that if i is equals to true
199:31 - or to 5 or not
199:33 - so it is not equals to 5 and then again
199:36 - it prints the
199:37 - value 2 as soon as the
199:40 - i as soon as i becomes 5 in the for loop
199:46 - inside if is evaluated to true
199:49 - and break is executed this terminates
199:52 - the
199:52 - for loop
199:55 - okay
199:56 - so
200:00 - uh
200:02 - what is a label so we will move ahead
200:05 - and
200:07 - learn about labeled break in kotlin
200:10 - so what we have learned till now is an
200:13 - unlabeled from form of brick which
200:15 - terminates the nearest and closing loop
200:17 - there is another way to a way break can
200:20 - be used to terminate desired loop okay
200:23 - or i can say the to terminate an outer
200:25 - loop
200:26 - so
200:27 - how does a label break works
200:30 - okay
200:33 - so there is a
200:35 - there is a
200:37 - while loop in in a while loop and there
200:39 - is a
200:40 - so there are basically two loops
200:43 - okay
200:45 - so label in quarterly starts with an
200:47 - identifier which is followed by an at
200:50 - the rate
200:51 - okay so here
200:53 - when i
200:57 - okay i can make a
201:01 - code for that syntax okay so i can make
201:04 - test
201:05 - at the red
201:06 - while
201:08 - and there is some test expression
201:15 - and inside this while loop
201:18 - there is some codes
201:25 - and inside
201:26 - this with the codes there is another
201:28 - while loop
201:30 - which contains
201:31 - another test expression
201:39 - and
201:40 - this while loops contains
201:42 - some
201:44 - codes
201:45 - and with this code it contains an if
201:48 - statement
201:49 - and there is a condition
201:53 - condition
201:55 - to
201:56 - break
201:59 - in this uh
202:00 - if statement
202:01 - and if this condition is true
202:03 - uh
202:04 - what it does it it will break
202:07 - and i'll use the m percent sign
202:09 - and then i'll write test okay
202:12 - so now i will go ahead and close all the
202:15 - parentheses
202:18 - now here is one and
202:22 - here is another
202:25 - okay
202:26 - so
202:27 - now we will understand the syntax
202:31 - so here test at the rate is a label
202:34 - marked
202:35 - at the outer while loop okay so this is
202:37 - the outer value and test at the rate is
202:40 - a label marked at the outer while loop
202:43 - okay so now by using break with a label
202:47 - test at the rate break at the red test
202:49 - in this case you can break a specific
202:51 - loop
202:52 - so
202:54 - as soon as my condition to break is true
202:56 - inside the vial this while in a while
203:00 - it will break the test uh this outer
203:03 - loop okay so what if i had not used the
203:06 - test
203:07 - test
203:09 - so it will break this while loop okay it
203:11 - wouldn't have break the outer while loop
203:14 - okay so
203:15 - it would be more clear with an example
203:16 - if it is not clear till now
203:19 - i'll
203:20 - use first
203:22 - as an identifier
203:24 - for a for loop
203:28 - which iterates in one two four
203:31 - one two four
203:34 - and inside this for loop there is
203:36 - a another for loop and
203:38 - i'll
203:40 - just i identify whether
203:43 - s e c
203:45 - o nd second
203:46 - and i'll use at the right and
203:49 - there is there will be another for loop
203:52 - and i'll iterate
203:54 - it in one two two
203:59 - so inside this second for loop i'll
204:01 - write a print statement just to know
204:04 - that
204:06 - what is the
204:08 - status of the loop
204:10 - so
204:12 - you must remember about the
204:14 - um the string templates okay so i i am
204:17 - going to use everything i have said till
204:20 - now okay so i is equals to i'll use the
204:23 - ampersand sign a dollar sign and use i
204:25 - so this prints the value of i okay
204:28 - and then
204:29 - semicolon
204:34 - semicolon
204:37 - j
204:38 - is equals to
204:43 - dollar j okay so the semicolon is going
204:45 - to print and i is equals to the value of
204:47 - i and j is equals to the value of j so i
204:49 - am just going to
204:50 - print the
204:52 - value okay so if the value of i
204:56 - is 2 then i have to
204:58 - break the first loop okay
205:01 - so i will use the break statement
205:04 - and use the add the rate and mention
205:07 - first
205:08 - now
205:09 - if i run this
205:10 - code
205:17 - okay i can see that i is equals to 1 and
205:20 - then j is equals to 1 then i zig for is
205:22 - equals to 1 there is equals to 2 okay
205:25 - so let's just see what is happening
205:27 - right okay so we first enter the for
205:30 - loop the first for loop okay so there i
205:32 - is assigned the value 1
205:34 - then
205:35 - we enter the second for loop and there j
205:38 - is assigned the value 1
205:40 - okay then the print statement is
205:42 - executed and inj both with the value 1
205:44 - is printed
205:46 - and
205:48 - the statement if i is equals to 2 is
205:50 - executed and as i is not equal to 2 it
205:52 - is 1 it is false and then it continues
205:55 - with the second for loop
205:57 - okay for i is equals to 1 this loop is
205:59 - executed two times because j iterates in
206:02 - one to two
206:03 - okay then
206:05 - for i is equals to 2
206:07 - okay
206:08 - so
206:10 - when this xz this is executed two times
206:12 - we reach the end of this loop the first
206:14 - loop and then i is incremented and i is
206:17 - equals i becomes 2
206:19 - now
206:21 - it enters the second for loop and for
206:24 - the i equals to 2 j is assigned the
206:26 - value 1
206:28 - and then the print statement is executed
206:30 - and
206:31 - value of i is equals to 2 and j is
206:33 - equals to 1 is printed and after that
206:37 - the if statement is executed and
206:40 - when i is equals to 2x expression is
206:42 - evaluated to true break at the rate
206:45 - first is executed which terminates the
206:47 - loop marked with label at the rate first
206:51 - okay or first at the right
206:53 - so it terminates the first loop now uh
206:56 - what if
206:57 - what if i have to
206:59 - break the loop as soon as i become two
207:02 - and not when
207:04 - after printing j okay so i i have to
207:07 - just remove this statement
207:09 - so i can just
207:11 - copy and cut and paste it before the
207:14 - print statement so before the print
207:16 - statement
207:17 - the first loop is going to be terminated
207:20 - and hence
207:23 - the
207:24 - third print statement is not executed so
207:27 - i can just do a little variation in this
207:31 - program okay in the previous program
207:33 - so instead of break at the rate first
207:36 - i'll do break at the rate
207:40 - second
207:44 - now
207:46 - when i run this program
207:49 - okay
207:53 - when i run this program
208:01 - i can see that
208:02 - i is equals to 1 is equal to j is equals
208:04 - to 1 so the whole loop is executed
208:09 - no
208:10 - the whole lip is not executed since
208:12 - break statement is used to terminate the
208:15 - innermost loop of program
208:17 - okay
208:18 - so the second loop of program i have
208:21 - broke so when i i was 2
208:24 - when i was 2
208:26 - j was 1 ok so that was printed i was 2j
208:29 - was 1 and then the condition was
208:31 - evaluated and the second loop was bred
208:34 - so it it reached the end it reached to
208:36 - the end okay and at the end of this uh
208:40 - the the the iterator for first loop that
208:43 - is i
208:44 - is executed okay
208:47 - so uh if i have to um
208:50 - like code for this
208:52 - i need not write first at the red or
208:54 - second at the red because um
209:01 - okay because the break statement as it
209:04 - is is for
209:06 - terminating the innermost loop okay so
209:09 - if i had not write
209:11 - at the rate at any point
209:13 - it gives me the
209:15 - same output
209:18 - okay so that was it for this video thank
209:20 - you
209:23 - in this video uh we will see what is uh
209:27 - continue in kotlin continue in kotlin
209:29 - and then we will see an example uh to
209:33 - calculate the sum of n natural number
209:36 - using for loop okay
209:39 - so
209:40 - what is continue
209:43 - and
209:44 - in which cases continue is used
209:47 - so suppose you are working with loops
209:49 - and
209:50 - sometimes you want to skip
209:53 - the current iteration of the loop okay
209:56 - so in such case continue is used the
209:58 - continue construct skips the current
210:01 - iteration of the enclosing loop and
210:04 - the control of program jumps to
210:07 - the end body of the loop
210:08 - okay
210:10 - so let us now see that how continue
210:13 - works
210:15 - so
210:16 - yeah
210:17 - uh it is almost
210:19 - always used with if else construct
210:22 - so for example there is a
210:25 - file
210:26 - some x test expression
210:33 - and test expression one i can say and
210:36 - then there is a loop which has some code
210:39 - this one
210:41 - okay
210:42 - and then after some set of code there is
210:44 - a if statement
210:46 - that if test expression
210:50 - 2 is true okay
210:53 - then i have to
210:55 - i i'll say i have to continue
210:58 - and
211:01 - i'll just end the loop here and then the
211:03 - f statement here and there is some
211:05 - another block of code say code two
211:09 - okay
211:10 - so what is happening here okay i'll just
211:14 - end my
211:16 - while loop okay so what is happening
211:17 - here is uh if the test expression 2 is
211:21 - evaluated to if the text expression 2 is
211:23 - evaluated to true
211:25 - continuous executed which skips all the
211:28 - codes inside the while loop after the
211:30 - iteration which is the code two block
211:32 - okay
211:34 - so uh
211:36 - like
211:37 - there is some code one that is going to
211:39 - be executed after the while statement
211:42 - and then
211:44 - if the test expression two is true then
211:46 - it is going to go to the end of this
211:48 - while block
211:50 - and skip the code too
211:52 - okay so uh
211:56 - and if uh there is something with
211:59 - uh the
212:01 - if there is a do uh do while loop okay
212:04 - so there would be a while loop like do
212:07 - code one if
212:09 - a test expression two is true
212:11 - continue and then there is another set
212:13 - of code and there is a then there is a
212:16 - while statement
212:17 - while
212:19 - test
212:20 - expression
212:22 - one
212:23 - so uh now what what happens when when
212:26 - the test expression do is true
212:29 - that
212:30 - the the continuum is going to be called
212:33 - and
212:34 - then it is going to be skipped to the
212:36 - while statement and then the test
212:38 - expression one is going to be checked
212:40 - and then it if it holds true then it
212:42 - will go to the uh do loop okay so let us
212:46 - go through the
212:48 - uh jump to the example of continuing
212:51 - kotlin
212:52 - all right okay
212:54 - so uh suppose there is a for loop
212:58 - uh from one to five
213:01 - and uh
213:03 - i is
213:06 - if i is greater than 1 or less than 5
213:09 - yeah if i is greater than 1 and less
213:11 - than 5 we have to continue
213:14 - okay so i'll just
213:16 - uh
213:18 - writes the code
213:21 - one main
213:27 - for
213:28 - i in
213:32 - for
213:34 - i in one two five
213:39 - and then if
213:42 - uh okay
213:44 - i i'll include println
213:53 - i
213:55 - always
213:58 - printed
214:02 - okay
214:03 - then
214:04 - if
214:09 - i is greater than one
214:14 - and
214:18 - i is less than
214:20 - 5
214:22 - okay which is equal in
214:24 - all case except when i is one and five
214:27 - okay
214:30 - so in this case i'll say that continue
214:35 - continue okay
214:37 - and then i'll
214:39 - again write a print statement which says
214:43 - println
214:47 - dollar
214:48 - i
214:49 - not
214:50 - always
214:52 - printed
214:53 - okay so when i go ahead and
214:57 - run this program
215:02 - what i can see is when when we run the
215:05 - program
215:18 - okay so when we can when we run this
215:19 - program it says that one always printed
215:22 - one not always printed two always
215:24 - printed three always printed four always
215:25 - printed five always printed and then
215:28 - five not always printed
215:30 - okay so
215:32 - when the value of i is greater than one
215:34 - and less than five continue is executed
215:37 - which skips the execution of this this
215:40 - this code println i is not always
215:43 - printed okay however the statement this
215:47 - this statement println i is always
215:49 - printed is executed in each iteration of
215:51 - the loop because this this statement
215:54 - this this statement exists before the uh
215:57 - continue construct
215:58 - okay
216:00 - so uh now now we will see a some
216:04 - like life example of it so let's say i
216:07 - have to
216:09 - i have to calculate
216:12 - the sum
216:14 - of
216:16 - positive numbers only
216:23 - so uh before that
216:25 - we will
216:26 - calculate
216:28 - the sum of
216:31 - first and natural numbers
216:37 - okay so for calculating the sum of first
216:39 - and natural numbers
216:41 - uh
216:42 - the the what we can do is
216:45 - we can
216:46 - use a for loop or any kind of loop okay
216:49 - so uh let's say i i have to make a
216:52 - program using the for loop so i'll write
216:55 - the code and explain
216:57 - okay so let's say uh i i'll i have i am
217:01 - declaring
217:02 - the variable num
217:05 - and i am giving the value of 100 okay so
217:08 - i have to calculate the sum of first 100
217:10 - natural numbers okay so there is a value
217:13 - and uh let's say there is a variable sum
217:16 - which is initialized as 0 for the in the
217:19 - starting
217:20 - okay
217:22 - so for
217:24 - i in
217:26 - 1 to num
217:28 - ok so i in one to num now what what uh
217:32 - what are we going to do is i'll i am
217:33 - going to
217:35 - do sum is equals to sum
217:37 - plus i okay so i am going to add i in
217:40 - sum and equate it
217:42 - with it so uh in order to write the code
217:45 - of it sum plus equals to
217:48 - i
217:50 - so this is the
217:52 - sum equals to sum plus i
217:54 - so now whenever the loop iterates
217:57 - every time
217:59 - the particular number is going to add
218:00 - with the sum okay
218:03 - so at the end
218:04 - i'll
218:05 - print
218:07 - print the sum
218:09 - so
218:11 - i'll print
218:12 - [Music]
218:15 - sum is equals to
218:19 - sum
218:20 - now when i run this program
218:23 - i should see
218:24 - the sum of first
218:27 - hundred natural numbers
218:29 - so the sum of first under natural number
218:31 - is uh five zero five zero
218:35 - okay
218:36 - so uh now
218:38 - i have to calculate the sum of
218:41 - only positive numbers from 1 to 100
218:44 - so now i have to do make some changes
218:47 - with in this program so what i will do
218:49 - is
218:52 - i'll
218:54 - this this block of code is fine okay so
218:58 - there is some integer
219:02 - and
219:08 - okay
219:10 - so
219:11 - uh
219:14 - from 0 to 100 i have to calculate
219:17 - the sum of
219:18 - positive numbers only
219:20 - so if before uh including the sum
219:24 - if
219:25 - the
219:26 - number is uh
219:29 - okay sorry
219:30 - i have to mention here odd
219:33 - okay my bad
219:34 - i have to calculate the sum of odd
219:36 - numbers only so from 1 to 100 i have to
219:38 - calculate the sum of odd odd numbers so
219:41 - if the number is even
219:43 - i have to
219:44 - continue okay i have no i have to skip
219:47 - the list of code so what is the
219:50 - condition for for a number to be even so
219:52 - the condition is number
219:55 - must be
219:56 - uh
219:58 - when the number is divided by two the
220:00 - remainder must be zero
220:02 - okay so when the number is even
220:04 - i should continue
220:11 - and now when i run this program
220:24 - okay so if i if i
220:26 - should be even then i uh when divided by
220:29 - two the remainder should be zero okay
220:32 - so
220:33 - when i divided by 2 and i is even we
220:36 - should continue and when i is not even
220:38 - that is odd we will skip to this
220:41 - block of code and calculate the sum so
220:43 - when i run this program i can see that
220:45 - the sum of odd numbers from 1 to 100 is
220:48 - 2500
220:50 - okay so that's all for this video stay
220:53 - tuned
220:54 - in this video firstly we are going to
220:57 - see what is the scope of a variable and
221:00 - then we we will cover some uh few
221:03 - examples which which will help you get a
221:06 - better clarity of all this all those
221:08 - concept that we have learned in the
221:10 - particular playlist of
221:12 - introduction to kotlin okay
221:14 - so what is scope of a variable a scope
221:17 - of a variable is
221:19 - its visibility or a visibility of a
221:21 - particular variable within a piece of
221:23 - code
221:24 - so uh let us understand with it with uh
221:27 - this with the example okay so suppose uh
221:31 - this is a block one block of code one
221:33 - okay
221:35 - so
221:37 - and
221:38 - then there is a for loop and then in
221:40 - between inside the for loop there is a
221:43 - block of
221:44 - code 2 so
221:46 - as the variable a is defined in the main
221:49 - function outside the for loop
221:52 - so the
221:53 - variable a is visible to code one as
221:56 - well as the code two okay so the code
221:58 - one is this thing and the code two is
222:01 - particularly this thing okay or i can
222:03 - say the code one includes this also so
222:06 - basically the code two is the for loop
222:09 - and
222:12 - because the variable b
222:14 - is
222:15 - initialized in the for loop
222:18 - inside the loop body
222:21 - and
222:22 - so it is visible to visible only to the
222:26 - code b and not the code one and hence it
222:29 - should be used by
222:31 - this loop body only okay
222:35 - so the variable b cannot be used outside
222:38 - so i cannot use
222:40 - b is equals to 20 here
222:43 - okay when i uh
222:45 - do so it shows an error here because
222:48 - the b variable is not visible to outside
222:52 - the loop
222:53 - okay similarly
222:55 - when i define a function okay a function
222:58 - outside the main function
223:00 - and i uh use some variables in the uh
223:04 - the other function so the the variables
223:07 - which i have used in the other function
223:08 - are not visible to the main function
223:11 - and the body and the
223:12 - and the body of the main function okay
223:15 - so this is about the
223:17 - uh scope of a variable okay so uh now
223:20 - moving forward
223:21 - we will
223:23 - write a kotlin program to
223:26 - find a
223:28 - factorial of a particular number of a of
223:30 - a particular number okay
223:32 - so
223:33 - kotlin
223:35 - program to
223:38 - find
223:40 - factorial
223:45 - of a
223:47 - number
223:49 - so in this program you will learn to
223:51 - find the factorial of a number using for
223:54 - loop or you can use while loop also
223:58 - and
223:59 - okay so what is a factorial so a
224:01 - factorial of a number n can be given by
224:04 - n factorial
224:06 - and it it is equals to
224:08 - 1 into 2
224:10 - into 3
224:12 - into
224:13 - 4
224:14 - and so on till
224:17 - n
224:18 - okay
224:20 - so uh now we have to think that how
224:23 - should we proceed in this particular
224:26 - question so uh up for thinking this uh i
224:30 - firstly i should think that
224:32 - one loop is required okay we cannot
224:34 - manually multiply the number with two
224:37 - and three and four okay also uh
224:40 - the the particular factor should be
224:42 - multiply with the i with the in
224:46 - incrementer
224:47 - okay
224:49 - so
224:50 - in this program we should we should use
224:53 - loop
224:55 - to loop through all the numbers between
224:57 - 1 to the given number
224:58 - okay
224:59 - whichever number has been given and
225:02 - the product of each number till the
225:05 - number
225:06 - is stored within a variable it must be
225:08 - stored within the variable
225:10 - okay so as we did in the uh
225:13 - as we did for finally finding the sum
225:16 - so uh initially i i'll declare the main
225:18 - function
225:20 - okay inside the main function uh there
225:23 - is a value
225:24 - num
225:25 - and that is defined so i have to find
225:27 - the
225:28 - factorial for the particular number 10
225:32 - now i should define a particular
225:36 - variable
225:37 - let's say factorial okay
225:40 - variable let's say factorial in which
225:43 - the factorial is going to be
225:45 - stored
225:48 - okay
225:49 - now this factorial
225:52 - uh okay instead of 10 i i'll do it five
225:56 - okay so this factorial uh
225:59 - should be
226:01 - equals to one on in the starting because
226:04 - this is multiplication if this is if
226:06 - this was a sum as we did in the sum of n
226:08 - natural numbers we would have
226:09 - initialized it with 0 because uh it we
226:12 - would be adding something to it now we
226:14 - we would be multiplying something to it
226:16 - so we have initially initialized it as 1
226:19 - because anything multiplied to one is
226:21 - the particular thing
226:23 - okay similarly anything added to the
226:25 - zero is the particular number
226:28 - okay now after declaring a factorial
226:31 - variable uh we should declare we should
226:34 - use the for loop okay so for now
226:37 - from where we have to iterate so i have
226:39 - to iterate from
226:41 - one to
226:43 - the number particular okay
226:46 - so from i to the number
226:49 - uh
226:50 - the factorial okay
226:52 - the factorial
226:54 - is equals to
226:55 - the
226:56 - factorial into number
227:00 - okay so
227:02 - uh from starting we can see that
227:05 - what is 2 factorial
227:07 - or what is 1 factorial i'll say 1
227:09 - factorial 1 factorial is
227:12 - 1
227:12 - okay now what is 2 factorial
227:15 - 2 factorial is
227:17 - 2 into 1 factorial
227:21 - and what is 3 factorial
227:24 - 3 factorial is 3 into 2 into 1 and 2
227:27 - into 1 is
227:29 - any basically 2 factorial now what is 4
227:31 - factorial
227:33 - 4 factorial is
227:35 - 4 into 3 into 2 into 1
227:37 - now what is 4 into 3 into 2 into 1 4 4
227:40 - into 3 into 2 into 1 so what is 3 into 2
227:42 - into 1 3 into 2 into 1 is 3 factorial
227:46 - okay so i can see that i can say that
227:48 - the factorial
227:50 - is equals to the previous factorial into
227:52 - the current number
227:54 - or instead of number i should have said
227:56 - here i
227:57 - okay that was my fault
227:59 - so what i can do here is i can just
228:02 - write factorial
228:05 - into equals to
228:07 - i
228:09 - okay clear
228:12 - and
228:13 - at the end
228:15 - i should write the print function
228:18 - so println
228:22 - factorial
228:27 - of
228:29 - the number
228:34 - is equals to
228:38 - factorial so the factorial variable
228:43 - now
228:45 - what i should do is i should run this
228:47 - program
228:49 - okay
228:51 - so what is 5 factorial 5 factorial is
228:53 - basically 120 for factorial is 24 okay
228:56 - so
228:57 - this program gives that factorial of 5
228:59 - is 120 so we have successfully
229:04 - made a program which prints the
229:06 - factorial of a particular number okay so
229:08 - that that is all for this video stay
229:10 - tuned
229:14 - in this video uh we would do some
229:17 - examples on the uh on the things we have
229:21 - learned okay so what i would recommend
229:24 - is uh you just watch the video when i uh
229:27 - announce the
229:29 - problem statement and then do it by your
229:31 - yourself
229:32 - and then you can play it again and check
229:35 - the solution okay so we would continue
229:38 - with our first example
229:40 - to
229:42 - count
229:43 - number of digits
229:47 - in an integer
229:52 - okay so uh
229:54 - like
229:56 - uh there is some integer or a number
229:58 - given okay suppose one two three four
230:01 - so
230:03 - i have to count
230:04 - the number of digits in the
230:06 - number
230:08 - so
230:09 - let's
230:11 - code for that
230:13 - so i'll write the main function
230:16 - and inside the main function
230:18 - uh there is a number
230:25 - and suppose that number is one two three
230:27 - four five six seven
230:29 - okay
230:30 - now uh i'll declare a count i'll declare
230:34 - a count and in at every loop i'll
230:36 - increase the count by one okay
230:40 - so count is equals to zero at the start
230:44 - so uh
230:47 - what is the basic logic behind this
230:50 - like we have to use loop
230:52 - and i trade the loop
230:54 - until
230:56 - uh some some condition or something is
230:58 - evaluated to false okay so
231:02 - i i can use while loop i can use any
231:04 - loop in this but
231:06 - i'll use while loop okay
231:08 - so uh and
231:10 - counting of digit okay so at every tens
231:13 - place there is a new digit every ten
231:15 - hundred place so when i divide the
231:17 - number by ten
231:21 - so the number of digits get reduced by
231:23 - one
231:25 - okay
231:26 - and
231:27 - um
231:30 - when i divide by 10 divided by 10 uh
231:33 - there is no decimal
231:35 - uh
231:36 - anything taking place because the number
231:38 - is integer okay so when i divide 1 2 3 4
231:41 - 5 6 7
231:42 - by
231:43 - 10 the answer is one two three four five
231:45 - six not one two three five six point
231:47 - five seven
231:48 - okay
231:49 - so i'll use while loop
231:52 - and the condition would be
231:54 - number uh not equal to zero
231:56 - okay so while the number is not equal to
231:59 - 0
232:00 - i'll
232:02 - i'll divide the number by 10
232:05 - and store it in number
232:07 - or num
232:08 - and i'll increase the
232:10 - count
232:14 - okay
232:15 - so uh
232:17 - what happens here is after first
232:19 - iteration num will be divided by 10 and
232:21 - its value will be uh one two three four
232:24 - five six then the count is incremented
232:27 - to one after the second iteration
232:30 - the
232:31 - value num would be um one two three four
232:34 - five
232:35 - and
232:36 - the
232:37 - that is incremented to
232:39 - after the third iteration the number
232:41 - would be incremented to one two three
232:42 - four and so on so after the
232:45 - seventh iteration the number would be
232:46 - increment after the sixth iteration
232:48 - number would be incremented to one
232:49 - number would be uh one and the count is
232:53 - incremented to
232:54 - um six
232:56 - and again at the seventh iteration
233:00 - the encounter is incremented to seven
233:02 - and the num becomes zero so again women
233:04 - when uh then then the test expression is
233:07 - evaluated to false and the loop
233:09 - terminates okay
233:11 - so i can write a print statement here
233:18 - number of digits
233:34 - is
233:36 - count
233:38 - okay so when i run this program
233:42 - the answer the order output should be
233:46 - 7
233:48 - so let's see
234:08 - [Music]
234:10 - okay so the number of digits in zero now
234:14 - why it is showing zero here because we
234:16 - have
234:17 - done all the calculation and we have
234:19 - divided num by 10 and so on and then
234:21 - becomes zero so what i'll do is i'll
234:24 - change here
234:27 - i'll
234:29 - take a value
234:30 - number that would be equal to one two
234:33 - three four five six seven it is the
234:35 - input
234:36 - and then
234:38 - i'll
234:40 - introduce a variable num that would be
234:42 - equal to our number
234:45 - okay
234:46 - and now here i can do number
234:49 - now when i run this program
234:54 - i can see that
234:56 - it works on pretty well the number of
234:58 - digit is one two three five six seven is
235:00 - seven
235:01 - okay moving forward
235:09 - in the next example
235:10 - we would write a kotlin program to
235:13 - reverse a number
235:18 - okay
235:19 - so
235:20 - what i should do for reversing a number
235:25 - for reversing a number
235:27 - i can do
235:29 - is what i can do is i can
235:33 - introduce a lot of variables okay
235:36 - so it is not a
235:38 - right choice because we don't know
235:41 - the
235:44 - uh
235:45 - count of count uh the the number of
235:47 - digits in the in the integer okay
235:49 - so uh what would we do is uh
235:53 - we would first
235:55 - like when we divide the number by ten
235:59 - okay so the remainder
236:02 - the remainder we get is like when we
236:04 - divide one two three four five six seven
236:05 - by ten so the remainder is seven here
236:09 - let me divide it
236:12 - so
236:14 - like this is the this must be this would
236:16 - be the first digit of the reverse number
236:21 - so let's go ahead and think as we code
236:24 - so there is a variable number this which
236:26 - is the output which is the input let's
236:29 - say it's one two three four okay so then
236:32 - i'll increa introduce a variable num
236:36 - which is equals to the number
236:39 - now
236:40 - uh i'll increase a variable reversed
236:45 - and
236:46 - for now it is zero
236:48 - okay
236:49 - so i'll introduce a while loop
236:51 - while
236:53 - num is
236:55 - not equal to
236:56 - zero
236:57 - okay
236:58 - now uh
237:02 - i'll introduce a value a variable digit
237:08 - okay
237:09 - and digit this digit is equals to
237:13 - uh num
237:14 - uh this is equals to the remainder when
237:17 - num is divided by 10
237:19 - okay
237:20 - now
237:22 - this is the
237:23 - last digit or the
237:25 - four in in the first iteration
237:28 - so
237:30 - the reverse number
237:33 - the reversed number
237:36 - would be equals to the old reverse
237:38 - number which is 0 for now
237:40 - okay into 10
237:43 - into 10
237:45 - and plus the digit
237:49 - so now when we come to the second
237:51 - iteration
237:52 - so the old reverse number is multiplied
237:54 - to 10
237:55 - and shifted one bit uh left side and
237:59 - then the digit is added okay so
238:02 - from this the number could be reversed
238:04 - and
238:05 - at the end i divide the number by 10
238:08 - okay
238:09 - so it helps in like when
238:12 - in the next situation okay
238:15 - so i'll just explain this code once
238:16 - again
238:17 - uh in this program while loop is used to
238:20 - reverse a number as given
238:23 - as
238:24 - i'll say
238:26 - first the remainder of num divided by 10
238:29 - is stored in the variable digit
238:31 - now digit contains the last digit of num
238:34 - that is 4
238:36 - then the digit is added
238:40 - to the variable reversed after
238:41 - multiplying it by 10 so multiplication
238:44 - by 10 adds a new place in the reverse
238:47 - number
238:48 - one place multiplied by 10 gives you
238:50 - 10th place okay so 10th plus gives you
238:53 - 100 and so on so in this case
238:56 - reversed contains 0 into 10 plus 4
238:59 - equals to 4
239:01 - so num is then divided by 10
239:04 - so that now it contains the first three
239:07 - digit that is 1 2 3
239:08 - after second iteration digit equals to 3
239:11 - reverse equals to 4 into 10 plus 3 43
239:15 - and num is equals to 12 after third
239:17 - iteration the digit equals to 2
239:20 - okay
239:21 - and reverse equals to 43 into 10 plus 2
239:24 - that is 432 and num is equals to 1 and
239:28 - after the fourth iteration
239:30 - the digit equals to 1
239:31 - reverse equals to 4 and 432 into 10 plus
239:34 - 1 that is 4 3 2 1 and num is equal to 0
239:37 - now as num equals to 0 the test
239:39 - expression fails and while loop exists
239:42 - exits and reverse reverse already
239:44 - contains the reverse number that is 4 2
239:47 - 3 1 okay so before running this program
239:51 - i'll write a print statement
239:54 - print
239:59 - the
240:00 - reversed
240:01 - number is
240:08 - okay
240:09 - now i run this program
240:15 - i can see that the reverse number is
240:17 - 4231 okay so this is all for this video
240:20 - stay connected
240:24 - and in this video uh we are going to uh
240:27 - do some example uh
240:29 - so in this in the in the example we will
240:31 - we are going to calculate uh
240:34 - power of a number using the using the
240:37 - power function and without using the
240:38 - power function so we will calculate
240:43 - the
240:44 - power of a number
240:50 - so uh
240:52 - like uh so through this video uh what we
240:54 - will do is uh we will practice some
240:56 - concepts and
240:58 - also uh i'll mention some things that i
241:01 - have missed or some new functions that
241:04 - are useful okay so
241:07 - there is a power function that i will
241:08 - introduce in the later part of this
241:10 - video okay
241:12 - so how to calculate a power of a number
241:14 - okay so suppose there is 3 to the power
241:16 - 4 so
241:18 - 3 to the power 4 is 3 into 3 into 3 into
241:21 - 3 4 times
241:22 - okay so 3 is the base in 3 to the power
241:25 - 4 and 4 is the exponent so i'll go ahead
241:27 - and in the main function i'll
241:31 - create a value base and give it a value
241:34 - 3 and a variable
241:37 - exponent
241:38 - [Music]
241:41 - and give it a value 4.
241:43 - okay
241:44 - and i'll make a result because uh
241:47 - we have to multiply something in the
241:49 - result uh i'll make a variable result
241:54 - and make it equals to 1 okay
241:58 - if i had to sum it up i i will make it
242:00 - as zero okay now we have to multiply
242:04 - three four times okay
242:06 - so uh
242:08 - i'll use a while loop okay we have to
242:10 - use a loop that's clear okay so i'll use
242:13 - a while loop and
242:14 - till exponent
242:16 - exponent is not equal to zero
242:19 - okay i'll what i'll do is in each loop
242:22 - i'll decrease the
242:24 - exponent
242:25 - okay so till exponent is not equal to 0
242:28 - i'll
242:30 - what i'll do is i'll make result
242:33 - equals to the
242:35 - previous result
242:38 - into
242:39 - the base value
242:42 - okay i think that's clear and i'll make
242:46 - it
242:48 - [Music]
242:50 - into equals to okay
242:51 - now
242:52 - i'll decrease the exponent
242:56 - and
242:58 - okay now i think that's it okay yeah
243:00 - that's it and i'll just print
243:04 - ellen the
243:08 - green talent though
243:10 - answer
243:14 - is equals to
243:15 - the result
243:17 - so
243:18 - dollar sign
243:19 - and result
243:21 - now when i run this program
243:25 - i expect my result to be 81
243:31 - and
243:33 - yeah we can see that answer is that so
243:35 - in this program base and exponent are
243:38 - assigned values 3 and 4 respectively
243:40 - okay
243:41 - using the while loop we keep on
243:43 - multiplying result by base until
243:45 - exponent becomes 0 in this case we will
243:48 - multiply
243:50 - we multiply result
243:51 - by
243:53 - base four times in total okay so result
243:55 - is equals to 1 into 3 into 3 into 3 into
243:58 - 3 that is equals to 81 okay
244:02 - so
244:03 - there is also a pow power function
244:07 - so we don't have to do do this all thing
244:10 - we can just use the power function
244:13 - instead of this while loop and
244:15 - this result i can directly
244:20 - i can directly
244:22 - write the result as value result equals
244:25 - to
244:26 - there is a math library
244:27 - in which there is a power function
244:30 - okay now we can see that there is two
244:32 - double
244:34 - okay so the input that has been given is
244:36 - con
244:38 - has to be converted to double okay
244:41 - then if then only it will take it as an
244:44 - input okay so i'll have to convert the
244:47 - base
244:48 - to
244:49 - double
244:52 - and i'll have to also convert the
244:55 - exponent
244:57 - to
244:58 - double
245:00 - okay
245:01 - now i have the
245:03 - power function and then base and then
245:05 - exponent so it will calculate 3 to the
245:07 - power 4
245:08 - okay now when i run this program
245:16 - i can see the answer is 81.0 now uh i
245:19 - can use i can use whatever the base and
245:23 - exponent i want i can use negative base
245:25 - as well as negative exponent as well as
245:27 - decimal base as well as decimal exponent
245:29 - so we will go ahead and try that
245:32 - okay so let's say i have to
245:35 - calculate 3 to the power minus 4
245:39 - so is that possible
245:41 - yes it is possible ok suppose uh i have
245:44 - to calculate three to the power minus
245:46 - four point two five three four three
245:47 - four five okay now uh it is double only
245:50 - okay the exponent is double whenever
245:53 - when i hover over it it says double so i
245:55 - can go ahead and remove this two double
245:58 - part
245:59 - now when i run this
246:07 - okay i can see my answer and it must be
246:09 - right
246:10 - so
246:11 - this is the use of the power function
246:13 - okay so in this program we used standard
246:16 - library function math dot power to
246:19 - calculate power of base okay we also
246:22 - need to convert base and exponent to
246:23 - double because the power function or the
246:26 - power
246:27 - of power function only exp accepts
246:30 - double parameters
246:32 - okay so
246:34 - in this video we have covered how to
246:36 - calculate
246:37 - the power of a function using the power
246:39 - function and without the power function
246:41 - okay
246:49 - in this video we will write a kotlin
246:51 - program to convert binary number to
246:52 - decimal and vice versa okay
246:56 - convert
246:57 - binary
247:00 - to
247:01 - decimal
247:02 - and
247:03 - device
247:06 - okay so uh if you don't know
247:09 - uh binary is the uh the language that we
247:12 - talk to computers about and decimal is
247:15 - the like is the number system we
247:17 - generally use okay so uh the binaries
247:20 - are the are is the number system of
247:22 - zeros and ones
247:24 - okay
247:25 - so in this program you will learn to
247:27 - convert binary number to a decimal
247:28 - number
247:30 - so firstly
247:31 - we will write a program to convert
247:33 - binary to decimal now
247:35 - let me create a main function
247:39 - now what we have to do when we have to
247:41 - convert a
247:42 - binary number to decimal number so
247:44 - binary number let's say there is one one
247:47 - so
247:48 - the one at the uh
247:51 - least significant bit as the power to
247:53 - keep power to this power zero and at the
247:56 - most significant bit has two to the
247:57 - power one so it is two to the power one
248:00 - into one plus two to the power zero into
248:02 - one
248:03 - and it is equals to 3 okay
248:06 - so
248:07 - let's say i have a binary number
248:10 - i will declare a binary number
248:14 - num
248:15 - and
248:17 - i'll declare its data type as long
248:19 - because it could be as long as one one
248:22 - zero one one zero one one one
248:25 - okay
248:26 - now i'll decrease a decimal number
248:29 - so i'll declare a value decimal
248:31 - and
248:32 - what i'll do is
248:35 - before this
248:36 - i'll
248:38 - instead of doing all the calculations
248:40 - here
248:41 - outside the main function i'll make a
248:44 - function
248:45 - which
248:46 - to convert
248:47 - a binary
248:49 - binary
248:54 - to
248:55 - decimal
249:00 - okay
249:00 - now uh this function has to
249:03 - take something as an input okay so let's
249:06 - say it's it takes input
249:08 - num and its data type is long
249:11 - okay now after that we have to declare
249:13 - its output output is end
249:15 - okay
249:17 - output type now we start the code block
249:20 - okay now uh
249:22 - inside the code block
249:24 - we have to
249:25 - what convert the binary to the decimal
249:28 - okay
249:29 - now uh
249:32 - so we have to use loop
249:34 - okay and
249:37 - like we have to
249:44 - okay so
249:45 - the decimal
249:47 - base 10
249:48 - and number system has possible value 0
249:50 - to 9 for each place value okay in
249:53 - contrast the binary base two number
249:55 - system has uh two possible values zero
249:58 - and one okay
250:00 - so uh
250:02 - how to con so for converting this
250:06 - converting decimal to binary is like i
250:09 - have okay i have to show
250:11 - like this okay i have 1 1 0 1 1 0 1 1 ok
250:20 - so the least significant bit here is
250:23 - this
250:25 - the most significant bit here is the
250:27 - first one and this is the least
250:28 - significant pair significant bit so the
250:30 - least significant bit holds 2 to the
250:32 - power 0 to the power 0 is 1 okay and
250:35 - then the next bit holds the value 2 okay
250:38 - and again the next bit holds the value
250:41 - of 4
250:42 - okay
250:43 - and so on it holds the value 8
250:47 - now it holds the value
250:50 - 16.
250:52 - okay
250:57 - and
250:59 - this bit holds the value 32 this bit
251:01 - holds the value
251:03 - 64. so for calculating so for converting
251:07 - this into
251:08 - the decimal i have to multiply these two
251:11 - so i have to multiply 1 into 1
251:13 - and then multiply 2 into 1 and then
251:16 - multiply 4 into 1 and then multiply 8
251:18 - into 0 and then multiply 16 into 1 and
251:21 - then add the whole thing okay so i i
251:24 - guess this is pretty clear how to
251:26 - convert a
251:27 - decimal number to binary okay
251:30 - so now we will move forward to how to
251:32 - write the code okay
251:34 - so
251:36 - firstly i'll declare declare the
251:39 - variable
251:41 - num which is equals to the num input
251:43 - that we have uh introduced okay
251:46 - now i have i i'll declare a decimal
251:48 - number which will be our output
251:51 - decimal
251:52 - number
251:54 - and for starting we will declare it as 0
251:57 - because we have to add all the numbers
252:00 - okay i have uh
252:02 - introduced early that when we have to
252:04 - add all those number we will initialize
252:05 - it as zero and we have when we have to
252:07 - multiply all
252:08 - all some numbers we will initialize it
252:10 - as one okay
252:12 - now uh i'll
252:15 - introduce an iterator
252:17 - and
252:17 - that would be zero for starting
252:20 - now i'll introduce a variable remainder
252:30 - remainder
252:33 - and
252:36 - it data type as its data type is log
252:42 - okay
252:55 - okay just a second
253:01 - so continuing with the
253:04 - the problem for converting binary okay
253:07 - so it is clear that how to how we can
253:09 - convert um
253:12 - binary to decimal okay
253:14 - so uh after
253:16 - declaring the remainder uh i i will run
253:20 - a loop okay so
253:23 - running
253:24 - okay
253:26 - a while loop so while
253:29 - now
253:30 - the number the number is binary okay
253:34 - so
253:37 - uh okay so number is long okay so i'll
253:39 - convert the
253:41 - long to end
253:43 - and then i'll
253:47 - num to end
253:49 - and then when it is not equal to zero
253:51 - till then i have to run this loop
253:54 - now inside this loop
253:56 - so i have i'll divide the the uh
253:59 - the binary number by 10 okay so what
254:02 - will happen is
254:04 - no yeah and the remainder
254:06 - uh that will be
254:10 - so when i divide this number by 10 the
254:12 - remainder is the last digit
254:14 - okay
254:15 - so i i'll uh
254:17 - collect the last digit by dividing this
254:20 - number okay so
254:23 - the remainder
254:30 - is equals to
254:32 - the
254:34 - remainder when the number is divided to
254:37 - 10 okay
254:38 - so now we have the last digit
254:40 - and
254:41 - uh for continuation
254:43 - i'll
254:45 - divide the num and
254:46 - provide it
254:48 - to the
254:49 - okay so as we did in the previous video
254:51 - we will do or and the decimal number
254:54 - decimal number would now be equal to
254:57 - uh the old decimal number
255:00 - so i'll equal i'll
255:02 - give it plus equals to and it will be
255:05 - equal to old decimal number plus
255:06 - remainder
255:09 - remainder
255:11 - into
255:14 - into uh
255:15 - math dot power
255:20 - i'll have to
255:21 - do the power
255:22 - and
255:23 - power of 2 2 is the base
255:26 - 2.0
255:27 - and the iterator
255:30 - what is happening okay and the iterator
255:34 - that is i
255:36 - and i'll convert it to double
255:43 - [Music]
255:47 - two double and
255:49 - then
255:51 - i have to convert this whole to end
255:52 - because the decimal number is an integer
255:55 - so to end
255:58 - now i have to increase the iterator
256:03 - and then at the end of this
256:05 - loop i have to return the
256:10 - decimal number
256:13 - okay so uh what we did in this
256:17 - part of code is
256:18 - uh
256:19 - while the
256:21 - the decim the binary number
256:24 - is not equal to 0 because we have we are
256:26 - dividing the binary number by 10 in
256:29 - every iteration okay so while this is
256:31 - not equal to zero uh the number
256:34 - the remainder is calculated and the
256:36 - remainder into uh 2 to the power
256:40 - 0 to the power 1 to the power 2
256:42 - is then calculated and then multiplied
256:45 - to the remainder
256:46 - and then added to the decimal number
256:48 - okay
256:50 - so as i have explained this how to con
256:52 - the conversion of this
256:54 - and then i have to call this function
256:56 - okay so
256:57 - uh calling this function i i'll
257:00 - introduce a value
257:01 - decimal
257:04 - decimal uh that would be equals to
257:07 - convert
257:10 - convert
257:15 - binary
257:18 - to
257:18 - [Music]
257:20 - the
257:24 - decimal
257:25 - and then the input would be num
257:33 - okay
257:35 - what happened here is
257:46 - okay
257:49 - now it is it would be correct yeah
257:51 - okay
257:53 - and then i i'll print
257:58 - print
257:59 - that
258:02 - number
258:04 - in
258:06 - binary
258:08 - is equals to
258:11 - decimal
258:15 - in
258:16 - this
258:21 - okay so when i go ahead and run this
258:23 - program
258:26 - oh i can see the output
258:30 - okay the grid is building
258:48 - so i can see here the output is
258:50 - one one zero one one zero one one in
258:52 - binary is 439 in uh decimal okay so you
258:57 - can also check that this is correct
258:59 - now uh instead of doing this whole thing
259:02 - there is uh there is a
259:04 - integer to binary string method to
259:06 - convert a decimal number into binary
259:08 - okay
259:10 - so what we can do is inside the main
259:12 - function uh
259:16 - for converting decimal to binary okay so
259:18 - binary decimal uh this is only the way
259:20 - okay
259:21 - so if if i have to convert
259:25 - decimal to binary
259:27 - i'll create a main function
259:30 - and then inside the main function there
259:33 - would be a
259:34 - number
259:35 - let's say 19
259:37 - and then
259:38 - i l
259:40 - converting
259:41 - decimal
259:44 - to
259:45 - binary
259:47 - now
259:49 - value
259:50 - binary
259:52 - is equals to
259:54 - integer
259:57 - dot
259:58 - to
259:59 - binary string
260:01 - and then i'll
260:02 - place here num
260:04 - okay now if i print
260:09 - that
260:13 - num
260:14 - in
260:14 - decimal
260:19 - is equals to
260:20 - binary
260:22 - in binary
260:25 - okay so when i run this program
260:36 - i can see that 19 decimal is 1 0 0 1 in
260:39 - binary
260:40 - ok so that is all for this video
260:43 - stay tuned
260:45 - in this video we will learn about
260:48 - multi dimensional arrays
260:50 - or
260:51 - we will learn it by an example of
260:55 - writing a quarterly program to add two
260:57 - metrics using multi-dimensional arrays
261:01 - okay
261:02 - so
261:04 - let's say there is a main function
261:09 - and inside the main function
261:11 - there is
261:12 - a
261:13 - value
261:14 - of rows
261:16 - let's say it is 2 and value of
261:20 - columns
261:23 - let's say it is 3
261:26 - now there is a value
261:28 - and i have to
261:29 - define a
261:31 - array okay so i hope you remember how to
261:34 - define an array
261:36 - now
261:37 - the value
261:39 - first
261:41 - matrix
261:43 - and it is an
261:46 - array of
261:50 - now array of two small errors okay so uh
261:55 - it is an array of two arrays
261:58 - okay so this is the multi-dimensional
262:00 - array okay so i'll just define int
262:02 - array
262:04 - of
262:06 - now
262:07 - let's say 2 3 4. now this is a
262:10 - multi-dimensional array because there
262:12 - are
262:13 - arrays
262:15 - there is an array of different arrays
262:17 - okay there is two errors two three four
262:19 - and uh let's say
262:21 - five two three okay i i i learned
262:23 - another array
262:26 - let's say five two three so the first
262:29 - matrix is an array of two different
262:32 - matrix two int matrix
262:34 - okay similarly
262:36 - let's say i have a
262:39 - second matrix
262:42 - c c
262:44 - o n d
262:46 - matrix
262:48 - okay so let's say it is an array
262:51 - of
262:53 - uh
262:54 - inter
262:57 - minus
262:58 - four 5
263:01 - 3
263:02 - and
263:03 - let's say int array
263:05 - of
263:07 - 5 6
263:09 - and 3 okay so we have two
263:11 - multi-dimensional arrays
263:13 - first matrix and second metrics now
263:16 - we have to write a program to add these
263:18 - two metrics
263:20 - okay
263:21 - so
263:22 - for
263:23 - adding
263:25 - these
263:26 - two matrices
263:31 - uh what i'll do is
263:33 - uh
263:34 - so what is adding of two matrices if you
263:37 - remember in mathematics the adding if
263:39 - there is a matrix one two three ok ok i
263:43 - have to comment it out
263:50 - okay so if there is a matrix one
263:52 - two
263:53 - three and
263:55 - four two three four so i i have to add
263:58 - this matrix within a matrix with a
264:00 - matrix let's say five six seven
264:03 - and uh let's say
264:06 - uh seven
264:08 - seven eight nine
264:13 - okay
264:15 - now um
264:17 - what what i will do is i'll add one with
264:20 - five
264:21 - okay two with six
264:23 - 3 with 7 2 with 7 3 with 8 and 4 with 9
264:26 - respectively okay so this is the
264:28 - addition of matrix now for adding these
264:30 - two metrics what i can do is i can
264:33 - introduce a variable sum which is equals
264:36 - to
264:37 - the
264:39 - array
264:42 - array
264:46 - rows of the
264:49 - end
264:53 - just a second rows of
264:56 - int
264:58 - array
265:00 - and
265:01 - then
265:02 - columns okay so what i did here is
265:09 - firstly
265:10 - the two metrics are stored in a 2d array
265:13 - namely first matrix and second matrix we
265:15 - have also defined defined the number of
265:17 - rows and columns and stored them in
265:18 - variable rows and columns respectively
265:21 - then we initialized a new array
265:24 - uh then we can then we will initialize a
265:26 - new array
265:27 - of the given rows and columns called sum
265:31 - okay so the sum is
265:33 - the
265:34 - given rows and the columns of
265:37 - uh
265:38 - this the two and three which is defined
265:41 - okay
265:42 - so the sum is basically int uh array
265:45 - rows
265:46 - and indirect columns
265:49 - okay because uh these array this array
265:52 - has two rows okay
265:53 - and
265:55 - inside these two in inside this there is
265:57 - a two entires and each entire risk
266:00 - contains the number of columns which is
266:02 - 3
266:03 - okay so i have defined the sum here
266:05 - which is
266:06 - 2 comma 3
266:07 - let's say so
266:09 - for
266:12 - i
266:14 - in
266:15 - 0
266:16 - to
266:18 - rows
266:20 - minus 1
266:22 - okay
266:25 - and inside this
266:29 - so uh
266:31 - like
266:32 - we look through each index of both
266:35 - arrays to add
266:37 - stone add store the result add and store
266:40 - the result okay
266:41 - so for
266:42 - uh going through each area so we will go
266:45 - through the first array for this
266:47 - and inside this i'll introduce another
266:49 - for loop
266:52 - for the columns so for j in
266:54 - 0 to
266:56 - columns minus 1
266:59 - okay
267:01 - so by this we can iterate in the whole
267:03 - array or whole matrix i can say so some
267:08 - i
267:08 - and j
267:12 - okay because sum is what sum is
267:14 - basically this thing
267:16 - so some i j
267:17 - is equals to
267:19 - first matrix
267:21 - of i j
267:23 - i and first matrix j and
267:26 - then
267:28 - sum of uh first matrix and
267:30 - second matrix
267:33 - so what is happening here i can i'll
267:34 - explain it again to
267:37 - make it
267:38 - very much clear for you
267:40 - okay
267:41 - so
267:43 - let's see here okay so the first matrix
267:46 - let's see here okay
267:52 - yeah so the one here i can call the one
267:55 - as first matrix one one okay i can call
267:58 - it as first matrix one two so for
268:00 - hydrating in i j
268:02 - so i have introdu introduced two
268:05 - uh for loops and the first is called
268:07 - zero
268:08 - zeroth element second is called the
268:09 - second element third is called the third
268:11 - element that's why it is row minus one
268:12 - and column minus one okay so the sum
268:15 - will be the addition of two matrixes
268:17 - will be pretty clear for you
268:20 - okay so finally we loop through each
268:22 - element in the sum
268:24 - some array using uh for
268:26 - loop to print uh so yeah so for printing
268:30 - or displaying the result
268:32 - uh we have to display the result also
268:34 - right
268:36 - display the
268:38 - result
268:39 - so for displaying the result i'll
268:42 - print
268:44 - the
268:46 - firstly
268:47 - sum
268:48 - of the
268:50 - two
268:52 - matrices
268:54 - is
268:56 - okay now what is the sum
268:59 - so for printing the sum we have again
269:02 - use again we have we again have to use
269:04 - the loops so for row in sum
269:09 - okay
269:10 - and inside this i have to
269:13 - again introduce a for loop for column
269:16 - and sum
269:22 - i have to
269:23 - print
269:26 - not println i have to print the value of
269:28 - column
269:34 - and then some spaces
269:38 - okay
269:39 - so i have printed the column and then
269:40 - again iterated and then again print
269:42 - another column
269:44 - okay and then
269:47 - print ln
269:49 - okay so when i go ahead and
269:57 - run this
270:03 - okay there is some problem with it
270:07 - let me see what is
270:14 - okay yeah so
270:16 - when i uh
270:18 - run this program
270:20 - i can see that the sum of two matrices
270:22 - uh is minus two eight seven ten eight
270:26 - six
270:26 - oh all right i can cross check it also
270:29 - now with
270:30 - this two minus four
270:33 - three plus five four plus three two plus
270:36 - five plus five two plus six and three
270:38 - plus three okay so this is correct
270:40 - uh so
270:41 - in this video we have learned about the
270:43 - multi-dimensional arrays and uh how to
270:45 - add two matrices we have coded the
270:49 - uh code in content okay so thank you for
270:51 - watching this video stay tuned
270:54 - this video we are going to calculate uh
270:57 - we are going to write a program
271:02 - uh to find out
271:04 - to
271:05 - find
271:06 - transpose of a matrix
271:12 - as you should be aware
271:14 - about what is a transpose of a matrix
271:18 - so
271:19 - like if there is a
271:22 - if there is a matrix
271:25 - uh just let me
271:27 - comment
271:30 - if there is a matrix let's say
271:35 - a b
271:36 - c and
271:39 - a b c
271:42 - and then d e f okay
271:46 - and so the transpose of this
271:50 - transposed matrix so transpose of this
271:53 - given matrix would be
271:54 - uh
271:55 - a b
271:57 - c
271:59 - and
272:00 - then
272:01 - here
272:04 - d
272:05 - e
272:07 - f okay
272:08 - so uh we are going to write the program
272:11 - for doing the same
272:13 - okay
272:14 - so uh firstly uh
272:18 - i would
272:20 - initialize the main function
272:22 - and
272:24 - inside the main function
272:26 - i'll declare the columns
272:29 - and rows so
272:31 - row is equals to 2
272:33 - and
272:34 - value
272:36 - column
272:37 - is equals to
272:40 - col
272:42 - column is equals to 3 okay
272:45 - now
272:46 - i'll take a matrix let's say the matrix
272:49 - is
272:51 - array
272:52 - of
272:58 - array of
272:59 - end array
273:01 - two three four
273:04 - and
273:05 - again entire
273:07 - of
273:08 - let's say five four
273:10 - five six four okay
273:13 - now
273:14 - uh firstly we will display the current
273:17 - matrix
273:19 - also for displaying the
273:22 - current matrix
273:24 - uh instead of using the for loop or the
273:28 - loops that we used in the last
273:30 - video uh we will just use the
273:33 - keyword display and then i'll pass the
273:36 - matrix okay
273:38 - so
273:41 - in the program display function is
273:43 - only used to
273:45 - print contents of a matrix okay
273:48 - and
273:49 - now
273:50 - i'll initialize the
273:53 - the display function
273:55 - okay
273:58 - okay
273:59 - so
274:01 - now uh inside the display function
274:03 - what i'll do is i have to print the
274:06 - display function okay so as we did in
274:09 - the
274:10 - last
274:11 - video
274:12 - i'll
274:13 - print ln
274:17 - the
274:18 - matrixes
274:21 - and then colon
274:24 - okay and then for
274:27 - rowan matrix
274:32 - and
274:33 - then
274:35 - for
274:37 - column
274:42 - in matrix
274:47 - now
274:48 - i have to
274:50 - print
274:54 - i have to print
274:58 - [Music]
275:04 - column
275:06 - and then some spaces
275:09 - now
275:10 - outside this
275:12 - first for loop
275:13 - i will
275:14 - print ln
275:16 - okay
275:17 - so this is the code to display the
275:19 - matrix as we did in the last video
275:22 - so we have displayed the particular
275:24 - matrix
275:26 - now what we can do is
275:28 - uh we can
275:29 - what we will do is we will transpose the
275:31 - matrix
275:32 - so
275:34 - for trans posing the matrix
275:39 - what we have to do is we have to uh
275:42 - like i can introduce another uh
275:46 - matrix uh called transpose
275:49 - and
275:52 - let it be equals to the
275:54 - array column
276:01 - and then
276:03 - entire
276:05 - row
276:07 - so what this particular line means is
276:10 - the column
276:11 - in the transpose
276:13 - is equals to the column in the array
276:15 - okay
276:17 - so
276:19 - end
276:21 - so when i hover over it
276:23 - it's a well column end okay and when i
276:25 - hover over this this is the array and
276:28 - then this is size
276:31 - and then this is in it and then there is
276:32 - an end okay
276:34 - so it it what it does is it
276:38 - decides the size of the particular uh
276:41 - array okay
276:42 - also sorry a matrix so for
276:46 - uh
276:47 - i in
276:49 - 0 to
276:51 - row minus 1
276:57 - and
276:58 - inside this i'll
277:01 - take another
277:04 - for statement for i in 0 to
277:06 - column -1
277:09 - and inside this
277:10 - what i'll do is
277:12 - i'll make transpose
277:15 - the uh one the transpose one one okay
277:19 - transpose
277:22 - so i'll do j i in here because
277:29 - sorry
277:30 - here would be j
277:31 - because um
277:33 - the transpose 1 1 is equals to the
277:36 - transpose of 1 1 is equal to 1 and the
277:38 - transpose of 2 1 is 1 2 okay so the
277:40 - transpose of 2 1 is matrix of 1 2
277:43 - so i can here do i
277:45 - and then j
277:48 - okay
277:54 - now we have transpose the matrix so
277:58 - finally we have to display the transpose
278:00 - okay so this
278:03 - display
278:05 - transpose
278:09 - and i have already declared the display
278:12 - function
278:13 - so i'll display the transpose
278:15 - and i'll go ahead and run this
278:22 - okay
278:29 - okay there is again some problem
278:33 - okay here uh it should be a
278:35 - column in row not
278:38 - column and matrix so when i
278:41 - run this
278:48 - yeah i can see that this is the matrix
278:52 - in the starting and this is the
278:54 - transpose matrix okay so in this video
278:56 - we have
278:57 - basically
279:00 - transposed a matrix
279:03 - okay so that's all for this video stay
279:04 - tuned and in this video we are going to
279:07 - cover uh lists um
279:10 - so
279:12 - what are lists basically in kotlin okay
279:14 - so what what are what were areas arrays
279:16 - are mutable
279:18 - but it cannot take a new entry okay so
279:21 - if there is an array i defined an array
279:23 - of let's say 10 entries so let's say the
279:25 - entries in an array is one two three
279:27 - four five six seven nine ten
279:28 - respectively and uh so what i can do is
279:31 - i can change the
279:32 - value 2 to 15 okay but i cannot add a
279:36 - new entry let's say 11 to at the end
279:38 - okay
279:39 - so uh the problem of
279:42 - fixed arrays is solved by lists okay so
279:45 - in lists we can
279:48 - add
279:51 - new entries okay
279:53 - so
279:55 - arrays had a problem
279:58 - that
280:00 - mutable
280:01 - that these are mutable
280:04 - but
280:04 - not
280:06 - but cannot
280:09 - take
280:11 - a new entry
280:14 - now uh
280:17 - these this problem
280:19 - solved was solved by
280:24 - lists
280:26 - so now what is a list a list can store
280:28 - many items of same or the different data
280:31 - types just like errors okay so just like
280:34 - arrays
280:39 - okay it can store
280:41 - any items of
280:42 - same or different data types so
280:45 - there are two types of
280:48 - list one is mutable
280:50 - and
280:52 - another is immutable
280:56 - so
280:57 - immutable as the name suggests it it
281:00 - it it it is for of fixed sized uh and
281:04 - fixed values okay so uh and so why why
281:08 - we why do we use immutable list
281:11 - we use the immutable list because um
281:14 - when we work with a lot of data
281:17 - and
281:18 - by chance some data
281:21 - gets changed
281:23 - by a programmer and
281:25 - it passes the same program to another
281:27 - programmer so uh this whole thing
281:30 - becomes a flaw okay and
281:33 - when we debug
281:35 - when we debug that it would take a lot
281:37 - of time in understanding that where was
281:40 - the root of the problem so
281:42 - that's why we use immutable list
281:44 - whenever
281:46 - the the data is not required to be muted
281:49 - okay because
281:50 - to avoid errors
281:53 - so uh the second is mutable list as the
281:55 - name suggests the element can be added
281:57 - as well as altered
281:59 - okay
282:00 - so uh
282:02 - firstly in this video we will uh cover
282:04 - the immutable list
282:06 - okay
282:07 - so uh immutable lists are defined using
282:09 - the
282:11 - immutable lists
282:15 - are defined using the list
282:17 - of
282:19 - keyword okay
282:21 - so uh
282:23 - let's see the syntax i'll declare a from
282:25 - main function and then inside the main
282:27 - function
282:28 - i'll declare a list so
282:31 - i can declare it as value or a variable
282:34 - it doesn't matter it is an immutable
282:35 - list so i i i'll declare it as a
282:37 - variable for now now the name of the
282:39 - list so let's say i'll name it as
282:43 - immutable
282:45 - list
282:46 - one okay now uh i'll use the list of
282:53 - data type okay now uh this uh inside
282:57 - this greater than and less than sign
282:59 - i have to mention the data type of the
283:01 - particular list so
283:03 - and we can skip this also okay if i not
283:06 - mention if i will not mention this there
283:07 - is no problem okay so
283:10 - i can mention this hi
283:14 - this
283:20 - is
283:21 - so i'll mention a character here
283:23 - a
283:24 - okay
283:25 - i'll mention two or three characters
283:27 - here b
283:29 - and then also
283:32 - some numbers okay
283:33 - so uh it is an immutable list
283:38 - okay
283:40 - so uh
283:42 - what happens when
283:44 - uh
283:45 - i'll do immutable list one
283:49 - number one
283:50 - is equals to
283:52 - uh
283:53 - hello
283:57 - okay
283:58 - instead of this i'll say 0
284:01 - so what happens is the parenthesis in is
284:03 - in red it's frozen error
284:06 - [Music]
284:08 - so yeah
284:09 - it's it it makes it red and when i hover
284:13 - over it it says unresolved reference
284:16 - and none of this following candidate is
284:18 - applicable because the receiver type
284:20 - mismatch okay so it basically says that
284:22 - uh it is an immutable list so we cannot
284:25 - mutate it okay
284:27 - so this is not possible
284:29 - not
284:31 - possible
284:32 - okay
284:34 - now uh there are some basic commands in
284:36 - list uh same as the strings or the
284:41 - uh the array so one is the get index
284:45 - uh immutable list one dot get index
284:50 - uh sorry get index to get in record
284:52 - index is zero
284:53 - okay
284:55 - and i'll just
284:59 - print lm this
285:15 - okay
285:16 - and what happens when i print the list
285:18 - also we can see here
285:25 - okay so when i run this program we will
285:27 - see that in the first line we have the
285:29 - list
285:30 - and in the second line we have the uh
285:33 - at index zero what we have is
285:36 - okay so we can see here it this this is
285:40 - the list
285:41 - and this is the zeroth index okay the
285:44 - another command
285:45 - commonly used is the index of element
285:47 - command okay
285:49 - as you might remember or if not i'll
285:52 - i'll explain it the index
285:54 - of
285:56 - and then i'll mention a particular
285:58 - element let's say
285:59 - a
286:02 - okay
286:04 - immutable list dot
286:08 - okay
286:08 - so in immutable list i will check the
286:11 - index of a
286:12 - so when i
286:13 - run this program
286:15 - it will print me that what is the index
286:17 - of this particular element okay so the
286:20 - answer is three
286:21 - zero one two three okay the another
286:24 - command is the last index of element
286:27 - okay
286:28 - so
286:30 - uh
286:31 - when i mention the last index of and
286:33 - then one
286:35 - okay
286:36 - and then run this program so what it
286:38 - will do is uh it will
286:40 - mention the index last index whenever
286:43 - the one is available so if i uh mention
286:46 - one two
286:49 - three one two two or three more times so
286:51 - it will mention the index of the last
286:54 - one available
286:55 - okay
286:57 - and there is a last index last sub list
287:00 - size okay there is
287:02 - these many commands okay so one or two
287:05 - i'll mention and uh
287:08 - i'll mention all of them and i would
287:11 - recommend you to go through the google
287:14 - and check about all these commands
287:17 - because as i already mentioned the
287:18 - google is best friend of any programmer
287:20 - so the size uh
287:22 - the dot size mentions the size of an um
287:26 - list or um
287:29 - any anything
287:30 - string or a array okay
287:33 - another is the last index
287:35 - okay
287:37 - so when i mention the last
287:39 - index
287:42 - and i run this program so it will
287:44 - just mention whatever thing is present
287:47 - at the last index of the um
287:52 - the list or an array okay
287:55 - so uh email lists are generally used to
287:58 - store static inform information in a
288:01 - program okay as i already mentioned uh
288:03 - it is generally used to store static in
288:07 - formation why is it so because uh we
288:10 - don't we cannot uh change the data
288:14 - okay
288:17 - so uh
288:18 - that is all for this video in the next
288:20 - video uh we will cover the mutable list
288:24 - and
288:25 - some problems or some examples upon that
288:27 - so stay tuned