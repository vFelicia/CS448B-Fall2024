00:00 - hello everyone welcome to programming
00:02 - knowledge I am going to start a lecture
00:05 - series on python socket programming well
00:09 - some of you might be wondering about
00:11 - what are you going to learn here
00:15 - well if you learned programming you must
00:18 - have wondered okay we know programming
00:21 - but what to do with it what's its
00:24 - practical implementation of after all no
00:28 - one is going to give you an stack or
00:31 - cues and will ask you to pop it post it
00:35 - right
00:37 - real world problems that are solved by
00:39 - programming are different and
00:41 - complicated
00:43 - well in this lecture series you will
00:47 - come across some awesome practical
00:49 - implementation of
00:51 - python socket programming
00:55 - let's discuss course outline
01:00 - we start with the basic of networking
01:04 - which include code networking concept
01:07 - like IP addresses
01:09 - TCP
01:11 - UDP
01:13 - HTTP protocols
01:16 - email protocols like SMTP
01:19 - file transfer protocol FTP and Internet
01:23 - Protocol
01:25 - the best part of this lecture series is
01:28 - that
01:30 - here we only not cover the basics Theory
01:34 - but we also see how to work with these
01:38 - protocols in Python
01:42 - one point here is to note that we are
01:45 - considering the viewer have some
01:48 - understanding of computer network and
01:51 - all of these protocols
01:55 - here in this lecture series we will not
01:59 - cover the in-depth theory of computer
02:01 - networking
02:03 - but we cover some key concept of
02:05 - networking
02:07 - such that you are all able to follow the
02:10 - tutorial easily
02:14 - after the understanding of basic of
02:17 - networking
02:18 - we will see the socket programming
02:23 - in this topic we will see basics of
02:26 - socket
02:28 - and then we will cover
02:33 - working with TCP and UDP socket for
02:37 - writing low level applications
02:41 - thereafter
02:43 - we will look at writing client and
02:47 - server program
02:49 - for socket based communication
02:56 - no
02:58 - here is the requirement for the lecture
03:00 - series
03:02 - in this lecture series I am using window
03:05 - operating system
03:07 - but all these are also applicable
03:10 - for Linux or Ubuntu
03:14 - in this lecture series I am using python
03:17 - 3.
03:18 - for the coding or implementation
03:20 - purposes
03:24 - and
03:25 - of course all the implementation or
03:28 - coding part of the video require
03:31 - internet connections
03:34 - so make sure all these are satisfied
03:37 - before starting this lecture series
03:40 - okay
03:42 - okay
03:44 - let's so let's get started with
03:48 - something you are likely to be familiar
03:50 - with
03:51 - that is IP addresses
03:54 - they are typically look like this
03:57 - [Music]
03:58 - they are actually a single 32-bit number
04:03 - but though
04:05 - they are usually written just like the
04:07 - number shown here
04:10 - they are written in the form of four
04:12 - decimal number that are separated by
04:15 - dots
04:17 - the number are sometimes called octet or
04:21 - bytes
04:23 - because
04:25 - each one represent 8 bit of the 32-bit
04:29 - number
04:31 - such each octet
04:34 - can only take value from 0 to 225 okay
04:39 - so valid IP address ranges from
04:42 - 0.0.0.0 to 255 to 55 255 250.
04:50 - this way of writing IP address is called
04:53 - dot decimal notation
04:56 - okay
04:58 - basically
05:01 - IP address performed two main function
05:06 - IP address uniquely
05:09 - address each devices that is connected
05:13 - to a network
05:16 - and
05:18 - it helps the traffic to be rooted
05:21 - between the network
05:24 - you may have noticed that the network
05:26 - connected devices that you use have IP
05:30 - address assigned to them
05:35 - the important point to note here is that
05:37 - each IP address that is assigned to a
05:40 - network device is unique
05:43 - and node 2 devices can share an IP
05:46 - address
05:48 - okay
05:53 - you can find out what IP address have
05:56 - been assigned to your computer by
05:58 - writing just
06:00 - ipconfig slash all on window
06:05 - if you want a same on Linux system then
06:09 - just type ipaddr
06:13 - okay
06:14 - IP address can be assigned to a device
06:17 - by a network administrator
06:19 - in one of two ways
06:22 - statistically
06:24 - where the device operating system is
06:27 - manually configured with the IP address
06:30 - or dynamically where the device
06:32 - operating system
06:34 - is configured by using the DHCP protocol
06:38 - that is
06:40 - Dynamic host configuration protocol
06:44 - when using DHCP
06:47 - as soon as the device first connect to a
06:49 - network
06:51 - it is automatically allocate an address
06:54 - by a dscp server from a predefined pool
07:00 - some network devices such as home
07:03 - broadband router
07:06 - provide a DHCP server service
07:10 - otherwise
07:11 - here dscp server must be set up by a
07:15 - network administrator
07:18 - DHCP is widely deployed and it is
07:21 - particularly useful
07:23 - for Network where different devices May
07:27 - frequently connect and disconnect
07:34 - such networks are like public Wi-Fi
07:38 - hotspot
07:39 - mobile networks
07:42 - Etc
07:45 - basically the internet is a huge
07:49 - the internet is a huge IP network
07:53 - and every device that send data over it
07:56 - is assigned an IP address
08:00 - the IP address space is managed by an
08:04 - organization called Iana that is
08:08 - internet assigned number Authority
08:12 - i a n a decide the global allocation of
08:16 - IP address
08:17 - ranges and assign block of address to
08:21 - rirs Regional internet registries
08:27 - address block to countries and
08:29 - organization
08:33 - there are some special IP address ranges
08:37 - Iana has defined
08:42 - that ranges is called private addresses
08:46 - this range will never be assigned to any
08:49 - organization
08:51 - and as such these are available for
08:54 - anyone to use for their Network
08:58 - the private ranges are here as follows
09:04 - 10.0.02
09:06 - 10.255 to 55 to 55. 172.16
09:13 - to 0 0 to 172.31.255.255.
09:20 - as
09:23 - 192.168.0.02 192.168.255.255.
09:30 - you may be thinking that if anybody can
09:33 - use them
09:34 - then wouldn't that mean that device on
09:37 - the internet will end up using the same
09:40 - address
09:41 - thereby breaking the IP's unique address
09:44 - property
09:46 - yeah if you are thinking like that then
09:50 - that is a good question
09:53 - and this problem has been avoided by
09:57 - forwarding traffic from
10:00 - private addresses from rooted over the
10:03 - public network okay
10:05 - wherever in
10:07 - wherever in network using private
10:10 - addresses needs to communicate with
10:13 - public internet a technique called
10:16 - Network address translation is used
10:20 - which essentially makes the traffic from
10:24 - the private Network appear to be coming
10:27 - from a single valid public internet
10:30 - addresses
10:32 - and this effectively hide the private
10:35 - addresses from the internet now
10:39 - we will start with the socket series
10:43 - in this socket series we will cover
10:46 - the background of socket programming
10:50 - socket API overview
10:52 - and after that we will start working
10:55 - with TCP and UDP sockets
10:59 - as we know python provides
11:03 - a good coverage on the low level Network
11:06 - King interface
11:09 - so you can assume that python has a
11:12 - socket module
11:13 - that gives you the necessary
11:16 - functionality to work with socket
11:19 - interface
11:21 - if you have ever done socket programming
11:23 - in any other language like C C plus plus
11:26 - Java
11:28 - then of course you will love the python
11:31 - socket module because it is very easy
11:36 - in this lecture series we will explore
11:38 - the socket module by creating a diverse
11:42 - range of python size scripts okay
11:46 - so Network programming
11:50 - in any programming language
11:53 - begins with socket as we all know
11:57 - so the question comes in mind
12:01 - what is socket
12:04 - so if we Define in a simple word not in
12:08 - a very technical the
12:11 - so in simple word it Network socket is a
12:15 - virtual endpoint
12:17 - where entities can perform inter-process
12:20 - communication
12:22 - let's take an example to understand it
12:25 - clearly
12:28 - for example
12:31 - one process sitting in a computer
12:34 - okay exchange data with another process
12:37 - sitting on the same or another computer
12:42 - we typically label the first process
12:46 - we have already
12:48 - cover the process and the ports how it
12:53 - communicate in the previous lecture when
12:55 - I am discussing TCP and UDP
12:58 - so
13:00 - we typically label the first process
13:02 - which initiate the communication
13:06 - as the client it is very important point
13:09 - which initiate the communication is
13:11 - referred to as a client
13:13 - and later on as a server
13:17 - okay
13:20 - so
13:23 - python has a quite an easy way to start
13:26 - with socket interface
13:29 - in order to understand this better
13:33 - let's see the big picture first
13:38 - let's see a following diagram in this
13:41 - diagram
13:43 - if flow of client server interaction is
13:46 - shown
13:47 - let's understand it very deeply
13:50 - this will give you an idea of how to use
13:54 - socket API
13:57 - so
14:00 - in the interaction between typical
14:02 - client and a server
14:05 - the server processes has to work a bit
14:08 - more
14:10 - means there is a confusion that only
14:13 - client have to work mode but the reality
14:16 - is the server has to work more than a
14:20 - client we will see how
14:24 - so
14:25 - let's see here
14:28 - after creating a socket object
14:32 - first let's see Server part
14:35 - so when we create a socket object
14:39 - the server process binds that socket to
14:43 - a particular IP address and port
14:48 - so this is much like a telephone
14:50 - connection with an extension number
14:55 - so in a corporate office after a new
14:58 - employee has been allocated with his
15:00 - desk phone
15:02 - usually he or C will be assigned to a
15:06 - new extension number
15:08 - so if anybody makes a phone call to this
15:11 - employee
15:12 - the connection can be established using
15:15 - his phone number
15:17 - and extension number okay same thing is
15:21 - like IP address and port
15:25 - so after the successful binding
15:30 - the server process will start listening
15:35 - for a new client connection okay
15:39 - no
15:41 - for a valid client session the process
15:45 - can accept the request of the client
15:48 - process
15:51 - at this point we can say that
15:54 - the connection between client and the
15:57 - server has been established
16:00 - okay this is a very important point when
16:03 - the connection between client and the
16:06 - server will be established
16:09 - okay
16:12 - then
16:13 - the client or server
16:17 - enters into request response Loop
16:21 - the client process sends data to the
16:25 - server process
16:27 - and the server process says
16:30 - the data and returned a response to the
16:34 - client
16:35 - when the client processes
16:39 - finishes
16:41 - it exceed by closing down the connection
16:44 - okay
16:46 - at that moment the server process
16:49 - probably goes back to the listening
16:52 - state
16:52 - okay
16:54 - the L have interaction between client
16:57 - and server
17:00 - is very simplified representation of
17:02 - actual reality
17:04 - it is only for understanding purpose
17:08 - in practice any production server
17:11 - processes process
17:14 - any production server process has
17:17 - multiple thread or sub process to handle
17:20 - concurrent connection from thousands of
17:23 - client over respective virtual channels
17:27 - so it is very very simple simplified
17:30 - diagram
17:31 - to start with okay
17:38 - so
17:40 - in this lecture we have covered
17:44 - some beautiful point about what is
17:47 - Socket how we visualize the socket and
17:51 - we have also seen a diagram which you
17:54 - which is helps you to clarify the socket
18:00 - API overview
18:02 - which you clarify the socket how socket
18:04 - API works but as I have said earlier
18:07 - that this diagram is very simplified
18:10 - version of the actual client server
18:13 - interaction this is for the
18:15 - understanding purpose till now we have
18:19 - completed
18:20 - the basic of sockets and we have also
18:23 - seen that what is socket and we have
18:26 - seen simple uh interaction diagram
18:30 - between client and server using socket
18:34 - that is we have seen a socket API how
18:37 - socket API works
18:39 - now
18:41 - today we are going to start working with
18:44 - TCP socket
18:46 - [Music]
18:48 - so creating a socket object in Python is
18:53 - very straightforward
18:55 - I think you all know that you just need
18:57 - to import the socket module
19:00 - and call the socket class
19:04 - so open up your
19:07 - ID ID I am using pi charm here
19:12 - or
19:13 - even you may use another ID which you
19:17 - means love to use so
19:21 - if you want to import or import all the
19:24 - things from the socket module then just
19:27 - write from socket import Star
19:32 - or you can
19:35 - simply import import socket okay
19:41 - now
19:44 - let's create
19:45 - TCP socket
19:48 - for creating TCP socket
19:54 - um you have to write
19:57 - s is equal to
19:59 - socket dot socket
20:03 - and here
20:06 - the class this class takes plenty of
20:09 - parameter okay
20:10 - so the important one I am using here
20:14 - if you want you can refer to the
20:17 - documentation of socket
20:21 - so some important parameters are
20:24 - first one is Socket family
20:28 - the socket family is the domain of
20:30 - socket the example of the domain of
20:33 - socket is like
20:35 - AFI net
20:38 - approximately 90 percent of the Circuit
20:40 - of the internet
20:42 - fall under this category okay
20:45 - and there is also one family's AF Unix
20:50 - which is uh sometimes used as well
20:55 - in Python 3
20:57 - you can also create a Bluetooth socket
20:59 - yeah this is very interesting point you
21:02 - have to just write AF underscore
21:05 - Bluetooth
21:08 - now
21:10 - the second parameter is socket type
21:16 - depending on your need you have to
21:18 - provide the socket type socket type is
21:20 - what you want to work for if if you want
21:24 - to work for TCP socket then you have to
21:26 - provide sock underscore
21:29 - stream
21:32 - and if you want to work with UDP socket
21:36 - then
21:37 - you have to provide here type is equal
21:40 - to
21:41 - sock
21:43 - underscore
21:45 - D gram
21:49 - okay now there is third parameter
21:53 - but it is also not very important
21:57 - but this specifies the variation of
22:00 - protocol within a socket family and type
22:03 - okay
22:05 - usually we left it as zero
22:10 - okay
22:12 - now
22:15 - for many reason means uh there are
22:17 - various reason
22:20 - which leads to socket operation
22:22 - unsuccessful
22:25 - for example if we take an example
22:29 - if you don't have permission to access a
22:32 - particular Port as a normal user
22:36 - then you are not able to bind to a
22:39 - socket right
22:41 - so this is why it is a good idea
22:45 - to do proper error handling when
22:48 - creating a socket or doing some Network
22:50 - bound communication
22:53 - okay
22:56 - so
22:58 - let's try to connect a client socket to
23:02 - a server process with proper error
23:06 - handling
23:09 - again I am repeating here I am using TCP
23:12 - client socket
23:14 - so
23:16 - here A type is Socket underscore stream
23:20 - okay
23:21 - so let's start
23:23 - as I said
23:25 - just import socket
23:29 - and I am also importing one module which
23:33 - is sys module which is system module in
23:36 - Python
23:39 - no
23:41 - let's start with Drive
23:44 - and try
23:46 - we have to write a reference variable I
23:50 - am taking as a sock is equal to
23:55 - socket dot socket
23:57 - and in that we have already discussed
24:00 - the parameters
24:02 - here I am using socket
24:05 - dot AF underscore init if you want to
24:08 - use Unix then it is up to you
24:12 - and I am that's I am making a TCP client
24:17 - socket that's why I am providing socket
24:21 - dot sock underscore
24:24 - history
24:26 - no
24:28 - if the socket is not able to
24:31 - created
24:33 - then what we will do
24:36 - then we will use accept Block in accept
24:40 - block
24:43 - just write socket
24:45 - dot error
24:48 - as err
24:50 - or and here just I am printing uh
24:54 - socket is failed to create
24:58 - and the reason is uh error the reason is
25:02 - stored is in err so we are printing also
25:05 - that
25:07 - if accept block will not execute it then
25:12 - the socket is created right so also I am
25:14 - predicting that
25:15 - let's socket created
25:20 - now
25:22 - I have to reach to the server process so
25:26 - I have to provide Target host and Target
25:29 - Port number as I have already discussed
25:32 - that telephone number and extension both
25:36 - are required
25:37 - so here Target host
25:41 - let's take a input by a user
25:45 - so Target underscore host is equal to
25:49 - input of let's say enter the target host
25:53 - name to connect
25:57 - Target Port is equal to
26:00 - input of enter the Target Port number
26:05 - okay
26:08 - now again I am defining in a drive lock
26:12 - and accept block it is a very good
26:16 - programming practice
26:18 - so try to do like this only
26:23 - it will create it will make your
26:27 - program very effective
26:30 - so
26:33 - in try block just try to connect to the
26:36 - Target host
26:39 - and
26:41 - since Target hose is is in string so I
26:44 - am providing directly like that and
26:47 - Target Port have to be integer so I have
26:51 - to convert it into integer so in Python
26:54 - you have typecasting is just like intent
26:58 - uh in that I have to provide the string
27:01 - right
27:04 - and after that uh let's print that
27:06 - socket connected
27:08 - and also print
27:11 - Target host in which it is connected and
27:14 - uh
27:16 - and also the port number let's print it
27:18 - out
27:19 - okay now after connection
27:23 - let's close it also sock dot shutdown
27:29 - okay
27:30 - here I am providing two
27:34 - now if it is not gets connected
27:39 - then
27:41 - print uh fail to connect and also
27:45 - provide Target host and Target Port that
27:47 - this is the target which we are not able
27:50 - to connect
27:51 - right
27:52 - and also we are able to
27:56 - um
27:57 - print the reason so in accept
28:00 - Justified socket dot error as err and
28:04 - printed it because after printing error
28:09 - it will show you why it is why what
28:12 - error has happened
28:14 - so let's run this code
28:19 - yeah and now
28:22 - enter the target host name
28:25 - so I am connecting to
28:29 - www.python.org Let's suppose
28:32 - and obviously Target Port is 80 it is
28:35 - standard
28:37 - so yeah
28:41 - it is showing socket connected to
28:45 - www.python.org on port number 80.
28:50 - but
28:52 - however
28:53 - if socket creation has failed for some
28:55 - reason such as invalid if you provide
28:58 - invalid DNS an output similar to the
29:05 - um
29:06 - so output is very similar but socket
29:09 - will be created but it is not able to
29:12 - connect right so let's uh
29:15 - if you provide invalid DNS if you
29:18 - provide invalid host the suppose
29:21 - www.abc dot invalid and the port number
29:24 - let's say 80.
29:27 - so here you see that
29:30 - it is failed to connect on port number
29:33 - this and the reason is reason here is
29:35 - important
29:36 - name or service are not known
29:42 - so I think that
29:45 - you are able to understand how to use
29:48 - socket interface of python
29:51 - to connect to a client to connect to a
29:54 - server process
29:56 - using a TCP client socket
29:59 - in the previous lecture we have seen
30:02 - that how to use socket module
30:05 - and also
30:07 - we have written the TCP client program
30:09 - to connect to the server process
30:13 - now
30:14 - in this lecture
30:16 - we are going to see
30:18 - the TCP client server interaction using
30:22 - socket module of python
30:26 - in the previous to previous lecture
30:29 - we have seen
30:31 - the client server interaction diagram in
30:35 - detail
30:36 - and in that diagram we have understood
30:40 - that
30:41 - the server process needs to carry out a
30:44 - bit of extrovert right
30:47 - so what extrovert work
30:51 - so it needs to bind to socket address
30:55 - and also
30:57 - listen for incoming connections
31:04 - now
31:05 - let's write code to understand it
31:08 - clearly
31:11 - let's start with writing TCP server
31:14 - program
31:15 - which sends the data to the client
31:18 - and also receive data from the client
31:24 - so
31:26 - open your ID
31:31 - I am using pycharm here
31:34 - so we are going to write TCP server
31:37 - program here
31:38 - so
31:42 - let's start
31:44 - as you all know
31:46 - that we have to first import the socket
31:49 - module
31:50 - so import socket
31:55 - now
31:57 - let's create a socket object
32:01 - so
32:03 - Let's uh
32:05 - server underscore socket
32:10 - is equal to socket dot socket
32:15 - and here
32:17 - we have to pass the required parameters
32:20 - as we have seen in the previous video
32:22 - also the first parameter is AF
32:25 - underscore init
32:28 - and second one is sock underscore stream
32:33 - as we have seen also that AF underscore
32:35 - init referred to address family of ipv4
32:40 - and sock underscore stream means
32:42 - connection oriented TCP protocol
32:45 - right
32:49 - now
32:52 - let's see interaction diagram to
32:55 - visualize it clearly
32:58 - as you see here
33:00 - that server first bind the socket to a
33:04 - specific IP and port
33:08 - so that it can listen to incoming
33:11 - request on that type people and port
33:15 - so to do this thing server has a bind
33:18 - method
33:20 - which bind it to a specific IP and port
33:24 - and server has a listen method which
33:27 - puts the server into the listen mode
33:32 - so first let's bind it so server
33:35 - underscore socket
33:38 - dot bind
33:40 - here
33:42 - we have to pass the server address
33:47 - so server address as we have seen that
33:50 - server addresses IP address as well as
33:52 - port number
33:55 - so I am using localhost here that's why
33:59 - I am passing 127.0.0.1
34:05 - and port number as we have seen in the
34:09 - previous videos that Port should be an
34:12 - integer and ranging from 1 to
34:16 - 65535 right
34:18 - and also zero is reserved
34:23 - so let's suppose I am using port number
34:27 - one two three four five which is in the
34:30 - range of this
34:31 - range
34:32 - okay
34:35 - now
34:37 - Let's uh listen now
34:40 - server started to listening after
34:43 - binding so server underscore socket
34:47 - Dot listen here
34:51 - listen takes a backlog parameter so
34:54 - suppose I am passing
34:56 - file
34:59 - so 5 here means that
35:03 - five connection are keep waiting if the
35:07 - server is busy
35:10 - and if a sixth socket try to connect
35:12 - then the server then the connection is
35:16 - refused
35:18 - okay
35:22 - now
35:24 - at last we make a while loop
35:28 - and start to accept all incoming
35:31 - connection
35:34 - so I am you I am writing uh why uh of
35:39 - infinite look
35:40 - so while true
35:43 - here
35:44 - I am printing uh server waiting for
35:48 - connection
35:52 - now
35:55 - as we have seen in the interaction
35:57 - diagram now we have to accept
36:00 - so in Python socket module there is an
36:04 - accept method
36:06 - the acceptor method initiate a
36:08 - connection with the client as we have
36:10 - seen
36:11 - so
36:15 - uh
36:16 - here the accept method basically
36:20 - return to thin it written a new socket
36:23 - object
36:25 - representing the connection
36:28 - and Tuple holding the address of the
36:32 - client
36:33 - so let's uh client underscore socket
36:39 - comma address is equal to
36:43 - server underscore socket
36:46 - dot accept so here the object will we go
36:51 - into the client underscore socket and
36:53 - the address will go under a DDR address
36:56 - right so let's print this address
36:59 - so let's print client connected from
37:04 - addr
37:07 - let's write another info infinite while
37:10 - loop to get the data and send the data
37:14 - to the client
37:17 - so while true
37:23 - let's receive the data by the client
37:26 - using rdcv method of the Python socket
37:29 - module
37:32 - this method will receive at most 1024
37:36 - bytes
37:38 - so data is equal to
37:41 - client underscore socket
37:45 - Dot
37:47 - Rec we receive and one zero two four it
37:51 - takes at most one zero to four
37:55 - now if data is not received
37:58 - or if data is end
38:03 - we have to break
38:05 - so if all the data is received then we
38:07 - have to break this while loop so let's
38:10 - break it and also we are printing that
38:12 - uh
38:13 - data
38:15 - so
38:16 - and also we have to uh you all know that
38:19 - we have to decode this into utf-8 string
38:22 - right so
38:25 - print receive from client
38:29 - data dot decode and we have to convert
38:32 - decoding D decode into utf-8
38:37 - now
38:40 - let's send
38:42 - data to the client also so here I am
38:46 - putting this send operation send method
38:49 - into the try and accept block
38:52 - so if it is not able to send
38:56 - then it will
38:58 - or if we do a keyword interrupt then it
39:03 - will exited
39:05 - so try uh client socket dot send
39:12 - uh
39:13 - here
39:15 - the string will not be sent here the is
39:18 - the type of the
39:23 - here
39:24 - the type is bytes not a string so we
39:28 - have to convert the string into byte in
39:30 - utf-8 so bytes
39:34 - suppose I am sending the message hey
39:36 - client
39:37 - so hey client and we have to convert
39:40 - into a decode into U at tf8
39:43 - so let's do that
39:45 - or accept
39:49 - if keyword is interrupt keyword
39:51 - interrupted then print
39:54 - exited by the
39:56 - user
40:00 - okay now at the end
40:04 - we have to close the connection between
40:05 - server and client
40:07 - so let's climb the client underscore saw
40:12 - kit Dot close
40:14 - and server underscore socket
40:17 - Dot close
40:19 - okay
40:21 - so let's run this code
40:24 - now as you see here it is showing server
40:27 - is waiting for the connection in this
40:30 - video we have seen that how to write TCP
40:33 - server program which sends the data to
40:35 - the client as well as receive the data
40:37 - from the client so in the previous video
40:39 - we have seen the TCP server program
40:43 - and now in this lecture let's write TCP
40:48 - client program
40:50 - such that we are able to
40:53 - see the interaction between
40:56 - client and server
41:00 - we are going to write the program
41:02 - according to the interaction diagram
41:04 - which we have seen previously
41:07 - by doing this it will give you a clear
41:09 - picture in terms of theoretical as well
41:13 - as practical knowledge
41:16 - so let's look at a diagram again
41:20 - I have also followed this diagram to
41:23 - write the server program as well
41:28 - so
41:30 - as you see here
41:33 - first we will create socket object
41:36 - and then we will connect to the server
41:39 - using IP address and port number
41:44 - and then we will send and receives the
41:46 - data between client and server
41:50 - so
41:51 - let's begin
41:53 - open your ID to start coding I am using
41:58 - pycharm to do
42:00 - coding
42:02 - so
42:05 - as we now all know that we have to
42:08 - import the socket module so let's import
42:11 - import socket
42:15 - and then
42:21 - we make a socket object as we have seen
42:24 - previously like
42:25 - I am defining reference variable as
42:28 - client underscore socket
42:30 - is equal to
42:32 - and let's create object socket dot
42:35 - socket
42:36 - and in same here I am passing the
42:40 - argument like socket Dot
42:43 - AF undergoes underscore init
42:46 - which is belongs to ipv4 family
42:50 - and socket dot sock underscore stream
42:57 - which is a TCP which signifies the TCP
43:00 - protocol
43:01 - right
43:03 - now
43:05 - now
43:06 - we have to connect to the Local Host on
43:09 - port number one two three four five
43:13 - so this port number as we have seen in
43:15 - the previous lecture we have taken the
43:17 - port number as one two three four five
43:19 - in the server program right
43:21 - so here we have to provide the same port
43:24 - number on which the server program is
43:26 - running
43:30 - Okay so
43:33 - client underscore socket
43:37 - dot connect as we have we know already
43:41 - that now it takes a tuple of
43:45 - Port IP address as well as port number
43:49 - so here I am connecting to the Local
43:51 - Host that's why I am passing IP address
43:53 - as 127.0.0.1
43:58 - and the port number one two three four
44:01 - five
44:02 - now
44:05 - now
44:06 - let's try to send the data to the server
44:09 - and also receive some data from the
44:11 - server
44:12 - so I am defining a variable named
44:16 - payload and I am assigning a message
44:20 - payload is just a message so I am just
44:23 - assigning payload as his server
44:26 - so
44:29 - we are going to write the send message
44:32 - method and try and accept block
44:36 - so let's write try and here we have to
44:41 - write in a infinite Loop so as we have
44:44 - seen in a interaction diagram we go
44:46 - repeatedly in a receive and send method
44:49 - so while true
44:52 - now
44:54 - as we already know in a previous lecture
44:57 - that we have to use send method to send
45:00 - any payload or message
45:02 - so
45:04 - basically send method in Python socket
45:07 - module takes argument up payload or
45:09 - message which is in a utf-8 string
45:13 - format so
45:15 - let's write client underscore
45:18 - socket dot send
45:22 - and you have to pass a payload dot
45:25 - encode into utf-8s ring so you have to
45:28 - pass a utf-8
45:30 - okay
45:32 - and now again let's receive the data as
45:35 - well from the server using receive
45:37 - method we have seen also this method in
45:39 - the previous video
45:40 - so data is equal to
45:43 - client sock underscore socket
45:46 - dot receive means rdcv and we have to
45:50 - here remember we have to pass here the
45:53 - buffer size right so it takes at most
45:56 - one zero to four
45:57 - so let's pass it
46:01 - and let's print the data so print Str
46:06 - data
46:09 - so
46:11 - again let's play little bit with this
46:15 - program
46:16 - so let's take a user input also to make
46:19 - a more interactive so let's take a user
46:21 - input to send the data to the server as
46:23 - well so
46:25 - Let's uh mode is equal to
46:28 - input of 1 to send more data to the
46:32 - server
46:33 - and if users say yes then we will we
46:38 - will take our input and if you say no
46:40 - then we will break so
46:42 - if uh more dot uh lowered
46:46 - just uh convert into lower
46:49 - so more dot lower is equal to equal to y
46:52 - or yes
46:54 - then payload is equal to just take a
46:57 - input into the payload
46:59 - so or else
47:03 - break
47:06 - and in accept block
47:09 - let's take a keyword input to break to
47:13 - get out of it and let's print that
47:17 - exited by the user
47:20 - and as we have seen that in an
47:25 - interaction diagram we have to also
47:26 - close so
47:28 - client underscore socket Dot close right
47:35 - so let's run this program
47:39 - okay
47:42 - as we have already just see we have
47:46 - already written the program of the
47:48 - server
47:49 - so when you run the program of the
47:51 - server so it is writing server waiting
47:54 - for the
47:55 - response right
47:57 - now
47:59 - waiting for a connection
48:01 - so now let's run the client program
48:06 - so here
48:08 - as you see
48:09 - that
48:13 - it says
48:16 - hey client that means that it receives
48:20 - the data from a server so as you see in
48:26 - a server program I am sending the data
48:29 - hey client to the client
48:32 - and
48:34 - if you see the server then you get here
48:39 - that received from the client Haze
48:46 - server right as you see here
48:50 - thank you
48:52 - and if you go into uh
48:56 - client part then it is also saying want
48:59 - to send more data to the server
49:02 - if you say yes
49:03 - yes I want to send then it says enter
49:06 - payload so suppose I am writing my name
49:09 - let's suppose Mohan
49:14 - so if you run it then again it comes hey
49:17 - client and want to send more data and if
49:21 - you see the server then you get okay
49:23 - received from the
49:25 - so as you see here the interaction
49:28 - between uh client as well as server it
49:30 - is in a local machine both the program
49:33 - is running in a local machine that's why
49:35 - I'm using the user uses this uh local IP
49:39 - address
49:39 - but you can
49:41 - do this and also you are able to play
49:44 - with this program
49:46 - so try this program and
49:50 - experiment with this program
49:52 - we are going to work on UDP socket
49:56 - before going to the coding part let's
49:58 - understood the client server interaction
50:00 - diagram of UDP socket
50:03 - as we have seen in the basic of
50:05 - networking tag UDP is connectionless
50:08 - protocol right that is the client does
50:12 - not form a connection with the server
50:16 - like in TCP and instead just it sends a
50:21 - datagram
50:22 - and the server did not accept a
50:25 - connection and it just waits for data
50:29 - grab to arrive
50:33 - and datagram contains the address of
50:36 - sender
50:37 - which the server used to send the data
50:40 - to the correct client
50:44 - we also know that UTP does not
50:47 - check for error in the exchanged diagram
50:52 - right
50:54 - so that's why it gives that is why it
50:58 - gives very fast communication
51:01 - now as you see in the interaction
51:03 - diagram
51:05 - it is very similar to TCP but there are
51:09 - various major changes
51:12 - in UDP
51:13 - after creating a socket object
51:16 - in UDP after creating a socket object
51:20 - the server process bind that socket to a
51:23 - particular IP address and port number
51:27 - after successful winding
51:30 - the server process will start waiting
51:33 - until datagram packet arrive from client
51:38 - in TCP we have seen the concept of
51:41 - listen and accept which makes the TCP
51:44 - connection oriented protocol
51:47 - but in UDP
51:50 - there is no such thing
51:52 - that's why it is a connectionless
51:54 - protocol
51:58 - now after binding
52:02 - the client server enters into the
52:05 - request response and finite Loop
52:09 - when the client process finishes it
52:11 - exits from the exit by closing down the
52:15 - connection
52:16 - and at that moment the server process
52:19 - probably goes back to the waiting state
52:24 - I am again repeating here that the this
52:27 - interaction diagram is a very simplified
52:30 - representation of the actual reality
52:33 - in practice any production server
52:35 - processor has multiple threads or sub
52:39 - processes to handle concurrent
52:42 - connection from thousands of client over
52:45 - respective virtual channels
52:49 - now
52:51 - let's jump to the coding part
52:53 - I am using pycharm IDE for coding
52:57 - let's create UDP server first
53:00 - as we all now know that first we have to
53:04 - import the socket module
53:08 - now let's create socket object
53:12 - so socket sock is equal to socket dot
53:17 - socket here we have to pass an argument
53:19 - to argument
53:22 - in this
53:23 - the first argument we all know is socket
53:27 - dot AF underscore init which belongs to
53:31 - ipv for family
53:33 - and the second argument we have to pass
53:36 - here is Socket dot sock underscore D Raw
53:43 - here means that the connection lists UDP
53:46 - protocol
53:50 - as we have seen in the interaction
53:52 - diagram we now have to bind the socket
53:55 - with IP address and port number
53:59 - so there is a method called bind as we
54:02 - have seen already
54:04 - here in bind
54:06 - we have to pass
54:08 - to our one Tuple and the Tuple
54:12 - consisting of IP address and port number
54:15 - here again as an in previous lecture I
54:18 - am providing localhost and port number
54:23 - is nothing but 127.0.0.1
54:29 - and port number let's suppose one two
54:31 - three four five
54:35 - okay
54:37 - now let's write in finite Loop for
54:39 - sending and receiving data
54:43 - so while true
54:46 - for sending the data
54:49 - usually to send the data using UDP
54:53 - protocol we use
54:55 - rdcv from method of socket module
55:00 - so
55:02 - rdcv from returns to thin that is data
55:06 - as well as address that is very
55:09 - important Point here
55:11 - so let's write first the data
55:14 - comma address
55:16 - is equal to
55:18 - Sock Dot rdcv from
55:22 - now
55:24 - in TCP
55:28 - here why we are not using rdcv method
55:32 - which we have used in TCP
55:34 - because in TCP once the connection gets
55:38 - established the address information does
55:40 - not change
55:42 - right
55:43 - but in another another hand in UDP
55:48 - UDP is a connectionless protocol
55:51 - so here we have to also receive the
55:54 - address
55:56 - so that we want to send the data back
56:01 - so that's why in racv from there are two
56:05 - things data as well as address but in
56:07 - recb method we only have data part
56:10 - because the connection is established
56:13 - here the connection is not established
56:15 - if you want to send back the data to the
56:18 - correct client we want address as well
56:22 - right
56:24 - and in rdcv from we have to pass an
56:27 - integer and this integer represent the
56:30 - number of byte you want to accept
56:33 - so here we are trying to provide Enough
56:36 - by to cover the entire message because
56:38 - we have seen in the background of
56:42 - networking that
56:44 - the packet of UDP message should be
56:49 - equal to the message the message size of
56:52 - the UDP should be equal to the packet
56:54 - side right
56:56 - so here we are trying to provide enough
56:59 - uh bytes so let's I am providing here
57:03 - let's say 4096 bytes
57:08 - now
57:10 - let's say we have to also send the data
57:15 - to the client
57:17 - so let's define messages hello
57:21 - IM udb server
57:25 - here there are also one important point
57:27 - is here we use send to Method here for
57:30 - the UDP the logic is same why we are
57:33 - using another method because
57:36 - we have to send the data to a particular
57:39 - address
57:40 - and in UDP there is no connection
57:42 - established that's why we have to
57:44 - specifically provide the address so
57:46 - that's why there is another method sent
57:48 - to
57:49 - so let's write sock dot send to
57:52 - its take to argument
57:55 - one is message
57:58 - and another one is address
58:02 - and also let's print the data
58:05 - that we have received from the client
58:08 - from that is received from let's print
58:11 - the data print
58:12 - data
58:16 - okay
58:19 - now
58:23 - and also the masses should be in bytes
58:27 - here it is in a string but we have to
58:29 - send the message should be invite so
58:32 - let's convert into bytes so bytes of
58:35 - hello okay and also we have to encode
58:38 - this message right
58:39 - so
58:41 - dot in code in utf-8 history
58:46 - okay
58:51 - no
58:56 - now let's write a simple client program
58:59 - which is able to interact with this
59:02 - server program
59:04 - all things are similar somewhat similar
59:06 - so I am copying from the server program
59:08 - up to this part right
59:12 - now I want to send a message to the
59:16 - server so let's define a message
59:21 - hello UDP server
59:23 - again we know to send message here we
59:26 - have to provide we have to use send to
59:28 - Method so client underscore socket
59:34 - dot send to
59:36 - and we have to encode the message as we
59:38 - all know
59:40 - into utf-8
59:44 - and
59:47 - we have to
59:50 - forward this we have to send the message
59:53 - into the localhost the address so I am
59:57 - providing
59:58 - 127.0.0.1 and the port number is one two
60:01 - three four five right
60:07 - and also if the server send so we have
60:10 - to receive that so data comma
60:14 - address is equal to client underscore
60:17 - socket dot receive from and also here
60:19 - I'm providing 4096.
60:23 - and let's say print server says
60:26 - and again print the data so print
60:30 - Str data
60:33 - and after that we have to close the
60:35 - connection
60:37 - now let's run the code
60:39 - so first we will run the code of the
60:41 - server
60:45 - and now let's run the code of the client
60:53 - as you see here it says hello I am a UDP
60:56 - server
60:58 - and now if we go to the server output we
61:01 - will see it prints hello UDP server
61:06 - so in this lecture we have seen the
61:09 - message successfully receive and send
61:11 - between the server and the client
61:14 - and we also able to get a knowledge
61:18 - about how UDP socket works till now we
61:21 - have completed up to working with UDP
61:23 - socket today we will going to see
61:27 - handling with handling multiple
61:30 - connection between client and server
61:35 - we have worked with TCP and UDP client
61:38 - server program in the previous lecture
61:42 - the this uh client server program have
61:45 - many limitations like as we have seen
61:48 - that server only serves one client and
61:52 - then exit right
61:55 - and the same limitation is of client
61:58 - also
61:59 - and also there is an one additional
62:01 - problem
62:03 - in the previous client server program
62:05 - that when the client call method which
62:09 - res dot we have seen receive method
62:14 - then it is possible that the receive
62:16 - method will only return one byte
62:20 - that is
62:22 - as we have seen that we are passing
62:25 - argument one zero two four right so
62:30 - as we have seen uh one zero to four is
62:33 - the buffer size argument which is the
62:36 - maximum amount of data to be received at
62:38 - once
62:40 - that means it does not means that the
62:43 - receive method will return exactly one
62:45 - zero to forward it is a maximum amount
62:47 - of white
62:49 - right
62:50 - and also
62:53 - send also behave this way OK the same
62:57 - way
62:58 - send method
63:01 - send Returns the number of bytes sent
63:03 - which may be less than the size of data
63:05 - passed in
63:06 - so it means that we are responsible for
63:09 - checking this and calling send as many
63:11 - as time as needed to send all the data
63:15 - so
63:17 - if we summarize the
63:20 - then we have two problem at this point
63:24 - the first one is how do we handle
63:26 - multiple client connections correct
63:29 - concurrently
63:30 - and the second one is uh that we need to
63:34 - call send and receive until all the data
63:37 - is sent or received right
63:39 - so
63:41 - in this lecture
63:46 - we are going to deal with these problems
63:49 - so what can we do to solve this problem
63:53 - so to solve the problem of concurrency
63:58 - there are many approaches
64:01 - as we all know that the traditional
64:03 - choice is to use thread to deal
64:05 - concurrency right and the mode recently
64:09 - a popular approach is to use
64:11 - asynchronous IO
64:13 - okay it is uh made basically inter
64:16 - introduced as a standard library in
64:19 - Python 3.4 to deal with concurrency
64:24 - let's see the traditional method first
64:27 - that is we will see the handling
64:30 - multiple connect connections using
64:33 - thread module in Python
64:36 - I hope
64:38 - you all know about threading we will
64:40 - going to write code of multi-threading
64:42 - server
64:43 - which can work with multiple clients
64:48 - so we will write the code of one
64:50 - multi-threaded server and two client
64:54 - in this set of lectures
64:58 - so let's start coding open your IDE
65:02 - firstly I am going to write the server
65:05 - program multi 3D server program
65:08 - and I am using pycharm form coding okay
65:13 - so as we all know now that first we have
65:16 - to import the socket module of python so
65:20 - import socket
65:23 - and also here we have to import another
65:26 - module that is thread library for
65:29 - multi-threading so all right from
65:33 - underscore thread import Star so I have
65:37 - imported all the method
65:40 - now
65:41 - let's create a socket object using
65:44 - socket
65:45 - method of socket Library so server
65:49 - socket
65:50 - is equal to
65:52 - socket dot socket right
65:57 - let's declare
65:59 - host and port
66:01 - on which we need to communicate with
66:03 - client
66:04 - so let's declare some variable so host
66:07 - is equal to let's say I am going to
66:10 - connect uh 127 that is local machine
66:15 - that 127.0.0.1
66:19 - and Port say which is in the range uh we
66:22 - already know so let's say one two three
66:25 - three
66:26 - yeah
66:28 - and also
66:30 - we have to declare one more variable
66:32 - that is a thread count which tracks the
66:35 - number of thread running we will see
66:38 - what this variable is used let's first
66:41 - declare so thread count is equal to zero
66:44 - okay
66:46 - now
66:48 - let's bind the host and port to the
66:51 - socket server we created ever in the
66:53 - program
66:54 - so if it binds successfully then it
66:57 - start waiting for the client otherwise
67:00 - it just returned the error that occurred
67:03 - while establishing a connection
67:05 - we have seen this in the previous
67:07 - lecture
67:08 - so I hope you are all able to understand
67:11 - this concept very easily so
67:14 - try and we are going to write in the try
67:18 - and accept block right so try
67:22 - server socket dot bind
67:27 - host
67:28 - comma port
67:30 - and except we will print error if any
67:33 - error occurred so accept socket Dot
67:37 - error as e
67:40 - print that error E
67:43 - and
67:45 - now let's start listening so server
67:50 - socket Dot listen and here we have seen
67:54 - that we have to pass some argument so
67:56 - let's say five
67:59 - and here let's say I am printing here
68:01 - waiting for connections
68:03 - okay
68:06 - now
68:08 - here we need to support handling
68:11 - multiple clients
68:14 - or thread at the same time
68:16 - simultaneously
68:18 - so for that we need to create a function
68:20 - that handles requit from Individual
68:22 - client by a thread right so let's define
68:25 - a new function named client let's say
68:29 - client underscore thread
68:31 - which connect to each individual current
68:34 - client on different addresses given by
68:37 - the server all right
68:40 - so
68:43 - in this function we are going to use
68:45 - receive function to get data from each
68:47 - client independently
68:49 - and then we will simply return the reply
68:53 - to the particular client with the same
68:54 - message right with a string connected
68:58 - says hello I am server
69:01 - in the beginning right so let's write
69:03 - this function
69:05 - we have already seen the use of receive
69:07 - method and send method in the previous
69:09 - lecture
69:11 - so
69:14 - so to do write this function we have to
69:18 - receive to do this uh
69:20 - reply and send this event send we have
69:25 - to you we have to take a argument a
69:28 - connection object right
69:30 - so such that it is able to send and
69:33 - receive the data from the client so
69:35 - let's define in such a way like this so
69:38 - Define client underscore thread and here
69:42 - I have to accept an object so connection
69:47 - and now let's say I'm going to send so
69:51 - connection dot send
69:55 - and suppose I am going to send a welcome
69:58 - to the server to the client so
70:01 - Str dot encode
70:04 - and message is welcome to the server
70:08 - now
70:10 - uh
70:15 - now let's uh start uh
70:19 - and finite Loop in that infinite Loop we
70:22 - are going to
70:24 - uh
70:25 - receiver data from a client in this
70:28 - infinite Loop so data is equal to
70:31 - connection dot or rdcv method here I am
70:35 - passing 2048 this is the maximum byte
70:38 - which it can receive
70:39 - and let's say I have to also reply
70:43 - to that
70:45 - client so reply is equal to hello IM
70:48 - server and then I am passing the same
70:51 - hello M server and data dot which I have
70:54 - received the data I am again forwarding
70:56 - it again sending that data so Plus data
71:00 - dot decode and we have already seen this
71:03 - and we have to decode into utf-8 string
71:06 - format
71:08 - now if not data then we have to
71:11 - break this infinite Loop so if not data
71:16 - break
71:18 - and
71:21 - we have to send this reply to
71:26 - the servers through sorry to the client
71:29 - so connection Dot and here we are using
71:32 - send all function which try to send all
71:35 - the reply or to the client
71:40 - so connection dot send all Str dot
71:43 - encode
71:44 - here I am passing reply and and lastly
71:48 - we have to close the connection so
71:51 - connection Dot close
71:53 - these things we have already seen in the
71:55 - previous lecture so if you are facing
71:57 - any problem here how I have done all
72:00 - this thing so please refer to the
72:02 - previous lecture and again come to this
72:05 - video and we're going to start from here
72:08 - so now
72:11 - we have to now accept the client socket
72:14 - connection right
72:15 - so since run server runs all the time
72:19 - which means that we don't want to make
72:21 - that our server got stopped right so for
72:25 - that we need to use again the infinite
72:27 - while loop to make it run server
72:29 - endlessly until we manually stop the
72:32 - server
72:34 - so
72:36 - let's write a infinite Loop while true
72:41 - here I am accepting the connection
72:43 - so client comma address as we already
72:47 - know that accept method
72:51 - gives to
72:54 - returns two things that is a client
72:57 - object
72:59 - and address and address contains uh
73:03 - i p address as well as port number so
73:06 - let's also print it out so print
73:10 - connected to address 0 that is IP
73:13 - address and address one which is port
73:16 - number so I have to convert into string
73:18 - so Str
73:20 - address 1 okay now here
73:24 - there is a difference so here I have to
73:27 - call start new thread function right
73:32 - to generate a new thread
73:35 - here we have to pass that
73:39 - function which we have defined that
73:42 - threaded client
73:44 - and
73:46 - that client object which we have to pass
73:48 - in that function okay right so we have a
73:51 - client
73:52 - object as well as a function which we
73:55 - have to generate a new thread so let's
73:58 - pass it and after generating new thread
74:02 - we have to increment the increment the
74:04 - thread count so thread count plus is
74:07 - equal to 1.
74:09 - and here we are printing the thread
74:12 - count how many thread is running so
74:13 - let's print it also so print thread
74:17 - number plus Str thread count right and
74:21 - right yeah
74:22 - and after that we have to
74:25 - just close this connection of the server
74:28 - socket so server socket Dot close right
74:33 - so now
74:34 - we have completed the
74:37 - multi-threaded server socket
74:42 - so
74:43 - program so
74:46 - in the previous lecture we had seen the
74:49 - code of multi-threaded server which
74:51 - accept or handle multiple clients
74:54 - simultaneously
74:56 - now in this video we are going to see
75:00 - client program and we will also see the
75:04 - interaction between
75:06 - multi-threaded server and the two
75:08 - clients
75:10 - so when multiple clients can connect to
75:14 - the server and each time a client
75:17 - connect to a corresponding thread
75:21 - which is created for handling client
75:23 - requests
75:25 - so let's write the source code for the
75:29 - client side so that the client can
75:32 - connect to the multi-threaded server so
75:35 - open up your ID
75:36 - and I am using pycharm here for coding
75:43 - firstly as we all know that we have to
75:46 - import socket module of python so let's
75:49 - import
75:51 - socket
75:54 - now let's create client socket object
75:59 - so client
76:02 - socket is equal to
76:05 - socket dot socket right
76:10 - now what we need is to assign same host
76:14 - and port number to the client as we
76:17 - defined in the server right
76:20 - if otherwise it will not able to make
76:24 - the connection between server and the
76:26 - client as we have already seen in the
76:29 - previous to previous lectures
76:31 - so let's copy from there so let's copy
76:37 - from the server so
76:41 - host is as we know host is a
76:46 - 127.0.0.1 and Port is let's say one two
76:49 - three three which is in the valid range
76:53 - now
76:56 - we want to set up a connection right so
77:00 - we use connect method of python socket
77:03 - Library
77:05 - we have already seen that connect method
77:07 - establishes a connection with the server
77:09 - using host and the port number right
77:13 - so let's uh and we know that this always
77:16 - we in a try and catch block try and
77:20 - accept block sorry
77:21 - so try
77:24 - client socket
77:26 - dot connect and here we have to pass the
77:29 - Tuple
77:30 - so host comma Port okay
77:35 - and if it is not able to connect then it
77:37 - will print an error so accept socket
77:41 - dot error as e
77:45 - print Str of e and also yeah here we I
77:50 - am writing a print waiting for
77:52 - connection
77:54 - okay
77:58 - here
78:02 - so
78:16 - now what we want is to make sure that
78:19 - client keeps running as the server is
78:22 - running right so for that we need to use
78:24 - a infinite while loop
78:28 - huh
78:30 - so let's say while
78:33 - true
78:35 - and also let's provide input option to
78:39 - the client so that it can send data back
78:41 - to the server and along with this we
78:44 - also use receive function to receive the
78:46 - data from the server side right so let's
78:49 - put all these things into this infinite
78:52 - Loop
78:53 - so let's input is equal to
78:57 - input let's say say something right I am
79:01 - taking an input from the user
79:03 - and let's send this so client socket dot
79:07 - send and here we have to encode
79:10 - Str dot encode here I have to pass input
79:13 - right
79:14 - and also let's take a response from the
79:16 - server so response is equal to
79:20 - client socket dot receive here I am
79:23 - passing maximum brightness
79:25 - 1024 and also I am printing the response
79:28 - here so print response 30 code
79:32 - utf-8 right and also let's remember that
79:36 - remember that uh
79:38 - from the server side we are passing
79:41 - welcome to the server so let's also
79:44 - print out outside of the infinite look
79:47 - so that we are also able to print that
79:49 - message also so let's print it here
79:53 - response is equal to client socket dot
79:56 - receive one zero two four
79:58 - maximum byte right and here let's say
80:01 - print response dot decode utf-8
80:06 - yeah
80:09 - so yeah now the code is completed so
80:12 - let's run the code
80:14 - so firstly we have to run the server
80:18 - and as you see here
80:22 - that let's let's run the code right and
80:27 - let's run the code and firstly we have
80:30 - to run the server code
80:32 - so let's run it
80:34 - so after running server code let's see
80:37 - as you see here that it says print
80:39 - waiting for connection now now let's run
80:43 - the client code
80:46 - yeah client code runs successfully as
80:49 - you see here the output we are getting
80:50 - is waiting for new connection okay and
80:54 - yeah welcome to the server
80:56 - and it is saying say something
80:59 - again let's see the server output again
81:02 - so as you see here it is saying that
81:04 - connected to this specified IP address
81:07 - and port and here says you see that it
81:10 - prints thread count is equal to one so
81:12 - yeah first client is successfully
81:15 - connected to the server
81:16 - now let's again come back to the client
81:19 - output and here I am giving input as
81:22 - hello server
81:26 - so yeah so we get the output as hello I
81:30 - am server hello server so yeah it is
81:32 - working fine
81:34 - and we are successfully interacting with
81:38 - the multi-threaded server
81:40 - so let's see it's support multipliant or
81:45 - not so again I am making one more client
81:48 - I am not going to write the
81:51 - whole code again just copying the code
81:55 - of the client and this client and paste
81:58 - it in another another file
82:00 - so let's run so let's do this okay
82:06 - yeah so let's run this second client
82:10 - so yeah
82:13 - so let's see the output of the server
82:15 - again so as you see here that throughout
82:17 - thread count
82:19 - becomes 2 right so connection it means
82:24 - that connection gets stabbed with the
82:26 - second client also here you see
82:27 - connected to and this this IP address
82:29 - and port number
82:31 - so yeah
82:34 - server is able to interact with the
82:36 - multiple client so we have successfully
82:39 - designed the multiple threaded server as
82:41 - well as multi clients two clients
82:45 - so I hope you all enjoyed the lecture
82:48 - series of python socket programming
82:50 - and your level to understand this
82:53 - lecture
82:54 - so thank you very much guys
82:56 - thank you