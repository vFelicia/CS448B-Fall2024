00:00 - we will see some of the object-oriented
00:03 - aspects of Java and first of all we will
00:07 - see what are classes and how we can
00:11 - declare classes in Java and how we can
00:14 - use classes in Java so first of all what
00:18 - is a class you may have noticed that
00:22 - whenever we have created our first
00:24 - program it was a class and inside this
00:30 - class we were calling this main method
00:32 - so every Java project has at least one
00:36 - class and one main method and class is
00:40 - basically a data structure or type in
00:43 - side which you can define some variables
00:48 - which are called member variables and
00:52 - methods which are called member methods
00:56 - and the most important property of
01:00 - classes are you can create instance or
01:04 - object from class so you can maintain
01:07 - different states of a class using these
01:11 - instances or objects so let's see how we
01:15 - can define a class which will be a new
01:19 - class and how we can use it with our
01:23 - main laws which is my class so for
01:27 - example we want to make some student
01:31 - data structure and for that we will make
01:36 - a class so just go to your project if
01:39 - you are using eclipse and go to the
01:43 - package you have made we have made a
01:45 - lesson one package at the starting of
01:47 - this video series go to that package
01:50 - inside which you will be having a class
01:54 - my class in my case just go to the
01:58 - package right click the same package and
02:01 - go to new and create a new class and
02:06 - this class name we will name it as
02:10 - student
02:13 - okay and leave everything as default and
02:18 - click finish
02:19 - and now we have this student class
02:23 - inside our lesson 1 package so we have
02:27 - two classes now my class is the first
02:29 - class which we were working on and the
02:32 - second class is called student dot Java
02:35 - and this is the second class we have
02:38 - created now now this class can have its
02:43 - member variables and methods so for
02:46 - example what can be the traits of the
02:49 - student student can have his ID
02:52 - so ID is integer values I declare a
02:57 - variable called ID student can have name
03:01 - so I declare a variable called name and
03:05 - student can have age his age so I have
03:11 - declare student age okay so this is
03:15 - basically you have created a class and
03:18 - it can have member variables it can also
03:21 - have member methods that we will see in
03:25 - a moment but let's consider this is a
03:28 - basic student class which contains three
03:31 - variables ID name and age okay now to
03:37 - call this class in your main method in
03:41 - my my class you can just create an
03:45 - instance of or object of the class so
03:49 - how you can do it you can just call the
03:52 - same name student last name just copy
03:55 - this name here and then give the name to
04:01 - your instance so as we have we give any
04:05 - name to our variables for example age
04:08 - name or something here also you can give
04:11 - the name to the students variable okay
04:15 - so for example the name is mark we are
04:20 - making the data structure for mark is
04:23 - equal to new
04:29 - student okay
04:31 - and this basically we have created an
04:34 - instance of student class which we named
04:39 - as Mark so this is Mark instance so mark
04:45 - here mark here is called object okay or
04:56 - some people also call it as instance
05:01 - okay instance so mark is here called the
05:08 - object or instance and this object we
05:10 - can use to you know assign values to the
05:14 - member variables of the student class
05:17 - for example marks ID is so whenever you
05:21 - call this instance called mark and
05:24 - whenever you use this dot separator it
05:27 - will give you the options which is
05:31 - provided by eclipse to you so the
05:35 - student class contain age ID and name so
05:38 - we will choose ID student ID is equal to
05:42 - for example one mark is our first
05:46 - student and in the same way you can call
05:51 - mark dot name should be mark dot name is
06:00 - equal to name is mark we already know
06:04 - and
06:05 - the age so mark dot age is equal to and
06:14 - he is fifteen-year-old for example so
06:20 - what we have done is we have created an
06:22 - instance of student class and we name it
06:25 - as Mark and then to this instance we
06:29 - have created or we have assigned some
06:31 - values and these values we can you know
06:35 - access these values with the same name
06:38 - small dot ID mild or name
06:40 - man aid so you can just right sis Oh
06:44 - control shift and then you can just
06:48 - right mark dot name is a so you use plus
07:02 - or concatenation operator is and then
07:07 - plus and then mark dot age so we will
07:11 - print mark is whatever his age is years
07:15 - old okay years old
07:21 - okay and when we run this program it
07:26 - will print mark is 15 years old okay in
07:30 - a similar way we can create different
07:34 - instances of our classes and so what we
07:39 - can do is we I will just copy the same
07:42 - mark student class and we will create a
07:46 - new object called this time we call it
07:49 - Tom okay so here tom is the second
07:54 - instance of the student class okay
07:57 - and his ID is to name is Tom itself and
08:04 - the age is for example 14 okay so in
08:12 - here we can once again make the copy of
08:17 - this print line method and this time we
08:22 - will just replace mark by Tom and now
08:26 - you can see it prints Tom is 14 years
08:31 - old and is there something wrong here
08:36 - yeah here we haven't changed this
08:39 - instance name here okay once again we
08:43 - will run the program and it says mark is
08:46 - 15 years old and Tom is 14 years old
08:50 - okay so you
08:53 - using a class we can define different
08:56 - object and we can define these object
09:01 - values of object member variable values
09:05 - which are independent of each other so
09:08 - this instance values which are ID'd toms
09:12 - ID Tom's name and Tom's age is
09:14 - independent of marks ID marks name and
09:17 - marks age okay
09:19 - so this is a very important property of
09:23 - object that it can store its own state
09:26 - and it's independent of the other
09:29 - instance right now in you know in Java
09:37 - programming or programming in general we
09:41 - never use or this kind of usage direct
09:46 - usage of variables are discouraged and
09:49 - why it's discouraged because any other
09:53 - person or whoever is whoever is using
09:57 - your code can modify these values so we
10:01 - use some you know some methods or some
10:08 - functions which can get or set these
10:11 - values okay
10:13 - so what I mean by getting and setting
10:16 - these values is I can go to this class
10:24 - called student and in here I can just
10:28 - use I can just go to the source tab and
10:33 - in here I can go to so we will go to the
10:40 - source and just go to generate getters
10:43 - and setters here and here we can see
10:48 - operation is not applicable in current
10:50 - plus okay and in here we will just use
10:57 - this and click once again getters and
11:00 - setters so just click one variable name
11:05 - or variable then only
11:07 - this will work so go to source once
11:09 - again and create getters and setters and
11:12 - in here select all so we are basically
11:16 - making getter and setter method for
11:20 - every value because we don't want to use
11:23 - or we don't want to access these
11:27 - variables directly we just create
11:29 - getters and setters for all of them and
11:32 - whenever we click OK you can see here
11:36 - Java has created us these kettles and
11:39 - setters for all these values ok and what
11:44 - this is basically doing is it has we
11:49 - whenever we want to
11:50 - you know assign some value to the ID we
11:54 - will use set ID method and whenever we
11:58 - want to get the value of ID we will use
12:01 - get method and this is called
12:04 - encapsulation of a variable and this is
12:08 - important because we don't want to give
12:10 - access to our variables to some other
12:14 - user which is unknown to us right and so
12:19 - now what we are going to do is we have
12:24 - generated these getters and setters in
12:26 - between our variables so we can just cut
12:30 - these values and paste it here and these
12:38 - cutters and setters we have generated
12:40 - for all the values right so now when we
12:45 - want to assign some value to the mark
12:48 - instance instead of this mark dot ID we
12:52 - will just use mark dot set ID was set ID
13:01 - and then we can give any ID to to mark
13:06 - and this value assignment is we are not
13:10 - going to use in the same way we will use
13:12 - marks dot set name and this name we will
13:20 - gave to mark and in the same way we'll
13:26 - assign age to mark so mark dot set age
13:32 - okay age is 15 right and in the same way
13:39 - we will do something with Tom's instance
13:44 - also so tom dot said ID tom dot set name
13:49 - so tom dot set name we will assign this
13:59 - name to Tom and Tom dot set age same
14:05 - thing here so basically what we have
14:11 - done we have used instead of direct
14:15 - assignment we are assigning values using
14:18 - these skaters and setters and this
14:20 - protects your data from corrupting if
14:23 - you somebody wants to corrupt or you're
14:25 - not or something like this okay and to
14:29 - get these value you just call mark dot
14:32 - get name and mark dot get age okay and
14:44 - same we will do with our Tom instance
14:49 - and whenever we run the program result
14:53 - will be same but this is more preferred
14:57 - while you are accessing or assigning the
15:01 - values to the member variables so this
15:05 - is how classes works in Java how to use
15:10 - a class constructor and what is a class
15:14 - constructor so first of all we will
15:17 - start our tutorial by making a new class
15:21 - so I will go to my package and I will
15:24 - right-click and go to new and I will
15:26 - create a class and I will name my class
15:29 - as cube by this cube class
15:33 - I'm going to you know get or I'm going
15:37 - to calculate the volume of a cube using
15:41 - different length breadth and height so
15:44 - I'm going to declare three variables in
15:47 - length and breadth and in height so that
15:51 - I can calculate the volume using all
15:55 - these three variables and then I will
15:59 - declare method which will return int and
16:06 - I will name it as get cube volume and
16:14 - this will take nothing else parameter
16:19 - and what this method will do is I'm
16:23 - going to just return the length of the
16:29 - product of length into breadth
16:36 - multiplied by height okay so this is the
16:40 - volume of the cube right length into
16:43 - breadth into height okay and this was
16:47 - get cube volume right so I have declared
16:58 - this class now I'm going to initialize
17:01 - an instance of the class so I will
17:03 - create a cube and I will name my cube
17:09 - instance as cube 1 is equal to new cube
17:16 - right and this cube with the round
17:23 - bracket is called the constructor of
17:26 - your cube clause and the most basic
17:31 - property of constructor is even if you
17:35 - don't define a constructor Java will
17:38 - create a default constructor for you
17:41 - whenever you create a class so we
17:44 - haven't created this kind
17:47 - destructor method explicitly anywhere
17:50 - here in our class but this is default
17:54 - constructor which is provided by Java
17:57 - from us and we can also define a
18:01 - constructor for us and the constructor
18:06 - name is always same as exactly the same
18:11 - as that last name
18:12 - so for defining a constructor
18:15 - you can just write cube and it for
18:23 - default constructor I'm not going to
18:25 - pass any values right now but it can
18:28 - take values okay or parameters so here
18:32 - you can provide parameters as you can do
18:35 - it with the method but the most
18:39 - important property of constructor is it
18:41 - has the same name as class and it never
18:45 - returns any value so constructor never
18:48 - returns any value so you cannot return
18:50 - like this in constructor okay now what
18:57 - I'm going to do is this constructor let
19:00 - me print something so 6o and I'm going
19:09 - to print we are in constructor okay and
19:16 - in our main class in our main method we
19:19 - have just defined the instance of this
19:22 - cube class and nothing else and when we
19:25 - run the program it prints we are in
19:28 - constructor that means whenever you
19:32 - create an instance of a class
19:34 - the first method which is called or
19:38 - which is initialized is the constructor
19:41 - of the class okay so you can define a
19:44 - constructor and if you want to
19:46 - initialize something you can do it with
19:48 - the constructor because it's the first
19:50 - method which will be executed right so
19:55 - constructors are generally used to
19:58 - initialize values
20:01 - in a class so what I'm going to do is
20:04 - I'm going to initialize some value like
20:09 - length is equal to ten variable web
20:18 - breadth is equal to for example 20 and
20:26 - variable height is equal to 30 for
20:32 - example okay so this is the default
20:37 - constructor we have defined and in here
20:40 - we have defined the value of length
20:43 - breadth and height so that if user even
20:47 - don't initialize this length breadth and
20:49 - height we are going to initialize or
20:53 - Java will initialize this value for us
20:56 - using this default constructor so now
21:00 - what we can do is we have initialized
21:03 - the instance of the constructor and
21:04 - using this constructor we can print or
21:09 - we can call get queue volume method okay
21:14 - so not here but here cube which is the
21:17 - instance of this cube class dot get cube
21:22 - volume and this will return us the
21:26 - product of 10 into 20 in 200 which we
21:32 - have initialized these values as right
21:35 - now you can provide multiple
21:40 - constructors of constructor overloading
21:44 - to the class so you can provide this
21:48 - constructor which we can consider as
21:51 - default constructor and in here we are
21:54 - going to provide 3 parameter int L comma
21:59 - int B comma int H okay and this
22:10 - parameter will pass to our
22:14 - bread and height okay so this is called
22:19 - constructor overloading so we can define
22:22 - two constructor at the same time both
22:25 - with different pair of arguments and
22:28 - this we will call it as default
22:31 - constructor and whenever you want to
22:33 - provide some values by yourself you can
22:36 - use this constructor right so what we
22:40 - are going to do is we are going to
22:43 - define second instance of cube class
22:46 - cube cube - which is second instance is
22:53 - equal to new cube right
22:58 - and now we can just call the same method
23:04 - gap cube volume but using cube to
23:09 - instance and here we will define length
23:14 - breadth and height for example 20 comma
23:18 - 20 comma 20 okay so Java is intelligent
23:23 - enough to understand that this
23:25 - constructor is this one and whenever you
23:30 - don't provide any argument
23:32 - whenever you hover over your constructor
23:36 - and just control click it it will go to
23:39 - the default constructor here right so
23:43 - now when we run the program one will
23:47 - give us the product of these values 10
23:50 - into 20 into 30 with just 6,000 and
23:54 - other will give us the value of our
23:59 - product of these value 20 into 20 into
24:02 - 20 which is 8,000 so we can define
24:06 - multiple constructor with different
24:09 - arguments as we require with our class
24:14 - ok so this is all about constructor I
24:19 - think and once again I am going to
24:22 - review what our constructor constructor
24:25 - are the member method in a class which
24:28 - the same name as your class exactly the
24:32 - same constructor never returns any value
24:37 - constructor can take parameter or they
24:40 - cannot I mean you can it's totally on
24:43 - you if you want to provide any parameter
24:45 - to a constructor or not you can define
24:48 - multiple constructor and use them with
24:51 - the class so I have defined constructor
24:55 - with no parameter so I can define it
24:57 - like this and I have defined a
24:59 - constructor with three parameter length
25:02 - breadth and height so I can define it by
25:04 - like this okay in this video we will
25:08 - learn about method overloading in the
25:12 - last videos I have shown you how to use
25:15 - a method now method overloading is same
25:20 - as declaring method but the main thing
25:25 - is you can define different method with
25:29 - the same name so two method you can
25:33 - define with the same name which can
25:35 - perform two different you know different
25:39 - logic so for example I want to add two
25:44 - values and I want to declare some method
25:47 - for this so I will declare a function
25:50 - called public static and it will return
26:01 - integer value and I will name it as ad
26:08 - okay and what it's going to do is it's
26:12 - going to add two values okay and it will
26:16 - return these two values and then I will
26:19 - pass in a comma int B as the parameters
26:26 - and I will return the sum of these two
26:33 - values right a plus B and I can call it
26:39 - in here right but
26:42 - in real-world programming the situation
26:47 - may occur that you want to add not only
26:52 - to integer values you may want to add to
26:56 - double values or decimal values or you
27:00 - may want to add to strings because Plus
27:05 - you can be used as a concatenation
27:07 - operators also so what you can do in
27:11 - Java is you can define the method to
27:15 - different method with the same name but
27:17 - for example different parameters and
27:25 - different values ok so you can define
27:29 - add something like this
27:32 - or you can define add something like
27:36 - this and this is called method
27:44 - overloading whenever you define
27:47 - different method with the same name
27:49 - which performs some different logic but
27:53 - they have I mean the same name they can
27:58 - perform mostly a same logic but you know
28:03 - data type you want to use them or
28:05 - parameter you want to pass them can be
28:08 - different and whenever you will call
28:12 - these method for example something like
28:16 - this you want to add two values you can
28:20 - just call add to integer 1 comma 36 so
28:28 - it will by default Java knows that
28:32 - whenever you pass two integers here in a
28:35 - method you are calling this method
28:38 - because you are passing two integers in
28:41 - a same way whenever you pass to a double
28:45 - values for example 5 point something and
28:53 - 40 point something
28:56 - than your Java program knows that you
28:59 - are calling this video so Java is
29:01 - intelligent enough to deduce your method
29:06 - by your initialization of the method in
29:11 - the same way you can pass whenever you
29:15 - want to pass two names for example hello
29:21 - and second parameter as world then also
29:29 - it you know it can know that you are
29:35 - calling this function because it takes
29:37 - string values and whenever you run the
29:40 - program it will give you different
29:42 - result
29:43 - then so in the first case this ad is
29:47 - calling this function in the second case
29:50 - this ad function is calling this
29:53 - function and in the third case this ad
29:56 - is calling this function so the method
30:00 - overloading or the basic logic of method
30:03 - overloading is you can define different
30:07 - method with the same name to perform
30:11 - different operations okay but logically
30:15 - they will be doing some same kind of
30:18 - work and in this video we will see what
30:21 - does the static keyword do in a class so
30:26 - in the last videos which I have been
30:30 - showing you you may have seen the usage
30:33 - of this keyword static with some member
30:36 - method or member variables of a class
30:39 - and you may be curious what is the
30:42 - meaning of this this is not you know
30:44 - just we are putting like this it has
30:48 - some meaning so the meaning behind the
30:51 - static keyword is whenever you declare
30:55 - your member as static the static member
31:00 - belongs to the class instance instead of
31:04 - some specific instance of a class
31:08 - so let
31:09 - me give you an example and then we will
31:11 - see it once again so I have a class
31:15 - called hollow and which contains two
31:17 - method one is a static method and other
31:21 - is a non static method
31:23 - static method means I have added static
31:26 - keyword to this and this method is not
31:28 - doing much it's just taking string as an
31:32 - argument and it's returning this string
31:34 - in whatever we pass back and the same
31:40 - method we are using here it has a
31:44 - different name which is do something
31:46 - else and this does not have any static
31:50 - keyword in it okay so whenever we
31:54 - declare the instance of a class for
31:59 - example hello hello is equal to new
32:06 - hello the static member is shared by so
32:13 - whenever you create an instance you can
32:16 - create many instance so for example
32:21 - hello hello one hello to the static
32:25 - member method will be shared by every
32:29 - instance okay and the static member only
32:34 - belongs to the class not to the instance
32:37 - so it will not belong to the instance of
32:40 - a class but it will only belong to the
32:44 - class itself so if you want to do
32:48 - something like this say dot do something
32:54 - which is a static method and we want to
32:58 - pass some message hi YouTube for example
33:06 - it it will work and it will work fine
33:11 - but it will give some warning here and
33:13 - the warning is the static method do
33:17 - something from the type hello should not
33:20 - be exact
33:22 - accessed
33:22 - in static way okay so you cannot access
33:30 - or you can access this but it's a wrong
33:32 - way of accessing this method which is
33:35 - declared as static method so for
33:39 - accessing your static method whatever
33:42 - you define as static you can access this
33:46 - method directly from a class like hello
33:49 - dot do something and this is the right
33:51 - way and once you do this you're warning
33:56 - message will be gone okay but a
34:00 - non-static method when you try to access
34:03 - so this hello is my class name dot do
34:08 - something is not something else is not
34:11 - available in this class right so this
34:15 - method is not available on cannot be
34:19 - accessed directly with the class name
34:22 - but whenever you add a static before
34:26 - your method name or variable name it's
34:30 - accessed from the class itself so do
34:33 - something is exist from the class and do
34:37 - something else which is not a static
34:40 - method cannot be accessed by directly by
34:44 - this class you can you see there is no
34:47 - do something else but this non-static
34:53 - method is available through the instance
34:58 - of a class ok so basically the
35:02 - non-static methods are available or can
35:04 - be accessed using the instance of a
35:07 - class and the static method should be
35:10 - accessed using the class itself not the
35:15 - instance ok so this is the correct way
35:22 - of using a static class or static method
35:28 - and this is the correct way of using
35:31 - non-static method you can even declare
35:34 - some variable as
35:36 - take for example public static int age
35:46 - for example and then whenever you want
35:50 - to access by this instance you can just
35:54 - for example hello dot dot age whenever
36:02 - you want to assign some value to the age
36:05 - let's see what happens
36:07 - so it's okay right now but it's once
36:11 - again showing that warning that the
36:13 - static field hello it should be accessed
36:16 - statically right
36:18 - once again we define a different
36:23 - instance of this class hello hello 1 and
36:28 - we assign some different value here for
36:32 - example 20 or 50 right and we will print
36:41 - hello age once again so safes oh and we
36:47 - will print this hello age here and we
36:52 - will print this hello age here also with
36:55 - this instance okay and for now let's
36:59 - comment this these two and when we run
37:03 - the program it gives you the same I mean
37:07 - the answer but it's preferred because
37:13 - it's a instance or not the instance but
37:17 - it's the X member of the class you need
37:23 - to use it like this not by instance but
37:27 - using the class itself okay so whenever
37:35 - you want to declare a variable or method
37:40 - static just access them using a class
37:45 - and whenever you are using non-static
37:48 - method or variable access them with the
37:51 - instance of a class now in this video
37:54 - I'm going to give one more example so
37:57 - this meaning of static will be more
38:01 - clear to you so for example I have a
38:04 - class called student and in this class I
38:08 - have two member variables one is the
38:11 - name of the student which is a string
38:13 - and one is the age of the student which
38:17 - is an integer and I have made the getter
38:22 - and setter functions of this class
38:28 - variables okay so if you don't know how
38:31 - to make it make these getter and setter
38:34 - function they can be made automatically
38:37 - so just go to your class and go to
38:41 - source and then source you will be able
38:44 - to see here generate getter and setter
38:46 - and in here
38:48 - just select all and click OK and your
38:51 - Keter and setter method for age and name
38:55 - will be generated automatically by
38:58 - eclipse for you ok so now what I want to
39:04 - do is I will declare a static member
39:08 - variable which will be int and this
39:12 - variable name I will say is the number
39:16 - of students okay and whose value is I
39:25 - will initialize it as 0 ok and I want to
39:30 - keep the record of number of students
39:33 - and I will make it as or I will declare
39:37 - this as static so that it can be shared
39:44 - by all the instances okay
39:47 - still stick so it's a static member okay
39:53 - and now I'm going to define our
39:55 - constructor which is same as the name of
39:59 - your class student
40:01 - and here whenever this constructor is
40:07 - called I want to increase the value of
40:10 - number of student by one so whenever
40:14 - somebody makes or initialize student
40:18 - class I want to increase the value by
40:21 - one so that we can keep the track of
40:25 - number of students right and for this we
40:30 - are going to make a function to get the
40:34 - value of number of student okay so we
40:38 - are going to make a public function
40:42 - public int and I will say get number of
40:54 - students and this basically is going to
40:58 - return the number of student which is
41:02 - this variable right so number of
41:06 - students return okay so whenever we call
41:14 - this function let's define this function
41:18 - also as static function so that we don't
41:22 - need to call it by any instance we can
41:27 - call it by the class itself okay now we
41:30 - go to the main class and in here we are
41:33 - going to define some instances of this
41:38 - student class student
41:40 - for example mark is equal to new student
41:46 - and once again student tom is equal to
41:54 - new student right
42:00 - and now we are going to call our get
42:06 - number of students because whenever this
42:08 - constructor is called we are increasing
42:11 - the number of student by one right so
42:13 - now we will just write seis all control
42:18 - shift and in here we will call the
42:23 - student class itself because it's a
42:27 - static member function this missive so
42:31 - we can directly call it with that class
42:34 - itself we don't need to use any instance
42:38 - right you can use instance but it's not
42:41 - necessary okay
42:42 - and when we run the program you see the
42:48 - answer is two right
42:50 - so it's shared by your instances so this
42:58 - member variable can be shared by your
43:02 - instances and two you know
43:06 - verify this we can call these this
43:14 - member function using instances also
43:17 - okay so for example when we add mark
43:20 - instance and when we call this get
43:23 - number of student by Tom instance then
43:25 - what is the value of the the number of
43:30 - students right so run the program and it
43:35 - says first time when we add first
43:38 - student its value is one that's right
43:42 - because when we added the first student
43:46 - the number of student will be one and
43:48 - when we added second student the number
43:51 - student will be 2 so this member
43:55 - variable which was static was shared by
43:59 - both the instances and also this can be
44:04 - called by the class itself right so this
44:08 - is the very basic and important property
44:12 - of static member that
44:14 - it can be shared by the instances also
44:17 - and you can call it using your class
44:22 - itself in this video we will see what
44:26 - are access modifiers and how we can use
44:31 - access modifiers in Java so you may have
44:36 - seen the use of public whenever I define
44:40 - some class or some method in a class and
44:44 - this public or private or this can be
44:49 - protected these are called access
44:52 - modifier and what access modifier mean
44:57 - is it basically allows you to you know
45:02 - access this method or whatever class in
45:06 - a package depending upon the keyword or
45:10 - access modifier we can access it inside
45:13 - the class or inside our package or
45:16 - inside whatever inside our project so
45:22 - how we can grant the access and what
45:25 - keyword means what we will see now okay
45:30 - so basically we have three kinds of
45:34 - access modifier one is called public
45:37 - other is called protected and third one
45:41 - is called private and if you don't give
45:44 - any access modifier for example I
45:47 - haven't given any access modifier to
45:51 - this string name and integer age this
45:56 - will be visible or we can use these
46:02 - variable inside the package and inside
46:06 - the class so because my class which is
46:10 - this one and student class are in the
46:14 - same package I can use these inside here
46:19 - so let me delete these we don't need
46:22 - them anymore so my class and student
46:25 - class are in the same package
46:28 - here in lesson 1 we have my class and
46:31 - student class right so if you provide no
46:34 - access modifier public private or
46:37 - protected they are visible in the class
46:41 - itself and the package so package inside
46:45 - the package we have this class also so
46:47 - we can define I an instance of the class
46:51 - for example student s tu is equal to new
46:58 - student right new student ok and
47:04 - whenever we want to access this s tu dot
47:09 - and this name is available name and age
47:12 - both are available in this class also
47:15 - right because my class which is this
47:20 - class and this class student class are
47:24 - in the same package ok so basically this
47:30 - is what we are doing here or we mean
47:34 - here ok and name should be some string
47:41 - so something like this right and when we
47:45 - compile the program we will not get any
47:48 - error right so whenever we give public
47:53 - access modifier before any variables for
47:56 - example I give public before my name and
48:01 - the age variable it's very visible
48:05 - everywhere in your class in your package
48:08 - in your sub class sub classes we will
48:11 - see when we see how inheritance work in
48:14 - Java and basically if you define a
48:18 - variable as public its visible as
48:21 - everywhere right but it's a good
48:25 - practice to you know not give or not
48:30 - give access to your variables to you
48:34 - know outside your package or even
48:36 - outside your class okay so the good
48:40 - practice is always
48:42 - declare your member variable as private
48:46 - or protected and the basic logic behind
48:49 - this is you don't want that your
48:54 - variable should be affected by any other
48:58 - user okay so you give in direct access
49:02 - to your variable using getter and setter
49:06 - functions okay
49:08 - so whenever you add this private access
49:11 - modifier before your your variable name
49:16 - it's only accessible through your class
49:21 - itself so outside your class outside the
49:24 - student class you cannot access if this
49:28 - member variable is private right so now
49:32 - whenever I try to run the program I will
49:35 - get an error and the error will be I
49:39 - will go to the error and it says the
49:42 - field student name is not visible it's
49:46 - not visible because we have declared
49:49 - this name as a private member of the
49:53 - class and whenever we declare private
49:55 - member of the class
49:56 - it only is very visible inside the class
50:00 - and not in the package not in the
50:02 - subclass not anywhere else okay
50:05 - so there is other keyword called
50:10 - protected which we will see when we
50:13 - learn about inheritance and other things
50:16 - but protected also restricts the
50:20 - visibility of your variable in the class
50:24 - itself package and subclass okay so
50:28 - right now we are not going to discuss
50:31 - more about protected because this
50:34 - protected we will use whenever we are
50:37 - going to learn inheritance and
50:39 - polymorphism right so right now just
50:43 - remember this table or memorize this
50:47 - table whenever you declare your variable
50:49 - as public it's visible everywhere in
50:52 - your class package subclass or anywhere
50:55 - if you declare your variable as private
50:59 - it's only with them in your class and
51:04 - nowhere else okay and means no here and
51:08 - Y means yes here okay and it's a good
51:13 - practice to make your variable private
51:16 - so that anybody else should not have the
51:19 - direct access to your variable and now
51:22 - so we cannot access this name directly
51:27 - from here so how we can allow the user
51:32 - to you know set the name of the student
51:35 - it's easy by using setter and getter
51:38 - function so go inside your class just
51:42 - click anywhere inside your class and
51:43 - then go to source and click generate
51:48 - getter and setter ok generate getter and
51:51 - setter and Java will automatically
51:55 - generate getter and setter for you
51:57 - whatever you check you know if you want
52:01 - to get a want getter and setter for name
52:04 - if you want getter and setter for age
52:06 - you can check both of these so I select
52:09 - all like this I can deselect all and for
52:14 - now I'm selecting all and click OK and
52:16 - it's created four methods for me one
52:23 - first one is get name which just returns
52:27 - the value of name so indirectly we are
52:31 - accessing the value of name but not
52:33 - directly right and set name allows you
52:38 - to set the name but not directly but
52:41 - using the copy use right and in the same
52:47 - way we have define the getter and setter
52:49 - for the Aged and by the way if you are
52:52 - wondering what is this keyword mean here
52:56 - so whenever you see this name and this
53:02 - name is similar and whenever you define
53:05 - any variable inside a function for
53:09 - this name this name will be preferred so
53:12 - whenever you want to do something like
53:14 - this Java may get confused this name is
53:18 - this name itself or this name which you
53:22 - define in the class this keyword this
53:28 - keywords tells Java that it's a member
53:32 - of the class which is this one so this
53:35 - indicates class itself so this means
53:39 - whatever class we are in okay so student
53:44 - dot name which is this variable not this
53:48 - variable right so basically you need to
53:53 - use or you can use this of a keyword
53:59 - here whenever you have two variable with
54:02 - the same name and you want to
54:04 - differentiate between them this dot
54:07 - whatever is the member of the class
54:10 - which is this one and the variable which
54:13 - doesn't have this is the local variables
54:17 - like so this the name here is the local
54:22 - variable this one and this name which is
54:27 - preceded by this is the member variable
54:31 - this one so this is what this means this
54:35 - means that last itself
54:37 - student dot name indirectly you can say
54:40 - instead of this you can just imagine it
54:44 - like student dot name okay but this
54:47 - keyboard indicates the class itself and
54:51 - now if you want to set the name what you
54:56 - can do is instead of directly setting
54:58 - the name you can just write two dot set
55:03 - name and then you can set name like this
55:09 - okay and whenever you want to get the
55:12 - name you can just do something like this
55:17 - instance of a class
55:20 - dot get name okay so this will allow you
55:28 - the access to this variable name but
55:31 - indirectly okay so just remember this
55:38 - table if you can memorize public grants
55:43 - you access to everywhere private grants
55:45 - you access only in the class itself and
55:48 - it's always the better practice to make
55:50 - your variables private unless and until
55:54 - you have the strong reason to make them
55:56 - you know public and used getter and
56:00 - setter to access these member variables
56:04 - okay and the meaning of this is the
56:08 - class itself so if you add this keyword
56:12 - before any variable it means the member
56:14 - of the class and whenever you don't have
56:18 - this here then it means it's a local
56:21 - variable so you can avoid conflicts
56:25 - between two similar variable names in
56:29 - this video we will see what does final
56:32 - keyword do in Java so for example I have
56:36 - a class called hello and I define a
56:40 - variable public final int number and I
56:45 - have added final to the variable
56:49 - declaration what does this final
56:53 - declaration do in front of any variable
56:57 - declaration or in front of class
57:00 - declaration or even in front of method
57:03 - declaration they have different meaning
57:05 - whenever you add it with the variable or
57:08 - a method or a class so let's see what
57:12 - does this keyboard mean so that final
57:16 - keyword has numerous way to use when we
57:20 - use final keyword with a class this
57:23 - class cannot be subclassed when you use
57:28 - final with a method this method cannot
57:32 - be overridden
57:33 - by a subclass and when you use final
57:37 - with a variable it can only be
57:40 - initialized once okay
57:43 - so first of all we will see this point
57:48 - that if you declare a variable as final
57:51 - it can only be initialized once okay so
57:55 - I have declared a member variable which
58:00 - is public final int number and what here
58:06 - written it can only be initialized once
58:08 - right so for example I declare a
58:12 - constructor with the same name and I'm
58:17 - going to initialize this value in my
58:22 - constructor so number is equal to 10
58:26 - okay so we I have initialized it only
58:31 - once right now I will create an instance
58:35 - of this class in my main method hello is
58:39 - equal to or hello a chi l is equal to
58:45 - new hello and what I'm going to do is
58:50 - I'm trying I will try to assign the
58:54 - value to this number hello dot number
58:57 - once again right so for example 20 okay
59:02 - and when I run the program or compile
59:06 - the program it gives me error and the
59:08 - error says the final field hello dot
59:11 - number cannot be assigned right so once
59:15 - I assign this variable which is final
59:20 - then I cannot initialize it once again
59:24 - okay so if i comment this this will
59:29 - compile perfectly fine so it has
59:32 - compiled perfectly fine but if I try to
59:36 - reinitialize or reassign a value to a
59:39 - final variable then it's not allowed so
59:44 - generally you whatever
59:47 - of value of whatever variable you want
59:50 - to declare it as a constant
59:53 - you can add final keyboard keyboard
59:56 - before this okay now the first point the
60:03 - final class cannot be subclassed when we
60:06 - will learn about inheritance we will
60:10 - also learn about what is sub classing
60:13 - and what the sub classing means is you
60:17 - can have the properties of one class
60:20 - into another class by the means of
60:24 - inheritance so for example I have the
60:27 - student class which whose property I
60:31 - want to use it or property or member
60:33 - variables or member method inside my
60:36 - hello class I can use it like extends
60:40 - and then student class not this one but
60:45 - [Music]
60:48 - student not this but this student right
60:53 - and this is totally fine if you write
60:58 - extend student this means that we are
61:00 - inheriting from student class to hello
61:03 - class and this inheritance we will learn
61:06 - in the further video but I want to show
61:09 - you what this final keyboard mean right
61:11 - and when we compile the program it will
61:15 - give us the error and what is their
61:18 - final cannot be initialized let's
61:22 - comment this and then once again compile
61:27 - the program and it compiles totally fine
61:29 - right because student class is not final
61:34 - right so if you add this final keyword
61:38 - before the Declaration of a class for
61:41 - example I will write public class
61:44 - student instead of public law student I
61:46 - write public final class student final
61:49 - class student so I have made this class
61:53 - as final right so if I made this class
61:58 - as final now see what happens
62:01 - it shows whenever I compile the program
62:03 - it will show error and what is the error
62:06 - here the type hello cannot subclass the
62:10 - final class student okay so whenever you
62:14 - declare a class as final you cannot
62:18 - subtract it from it yeah okay so you
62:22 - cannot extend from that class okay and
62:30 - the point in the middle that the final
62:33 - method cannot be overridden by the
62:37 - subclass this we will learn when we
62:40 - learn how to use inheritance and how to
62:44 - use overriding in class okay
62:48 - so just remember these three key key
62:53 - sentences and you will be good to go and
62:55 - in this video we will see what is class
62:57 - inheritance in Java and how to use class
63:01 - inheritance in Java so classes in Java
63:05 - can be extended and how they can be
63:08 - extended by creating new classes which
63:12 - can retain the character sticks of the
63:16 - base class and base class I mean here is
63:20 - the class from which we are inheriting
63:24 - now understand it fully I have a little
63:31 - diagram to explain now for example I
63:36 - want to make a class which can calculate
63:40 - the area of some shapes so it can be
63:47 - rectangle square circle or triangle or
63:51 - anything right so I can make a class
63:56 - called polygon because they share
63:59 - rectangle and triangle shares a similar
64:02 - property and what is this property they
64:05 - both have width and height
64:08 - right so I can define two variables in
64:12 - my polygon class and I can set these
64:16 - width and height of these value in this
64:21 - polygon class using a method set value
64:24 - and in this rectangle or and triangles
64:27 - laws I can create two methods which can
64:32 - calculate the area of triangle and area
64:36 - of rectangle so the common properties
64:40 - which they both share which is height
64:43 - and width we can not we don't need to
64:46 - define it in separate places in
64:49 - rectangle also and triangle also we can
64:53 - define them at the single place and we
64:57 - can use them using the inheritance
65:00 - property and how you can know that these
65:06 - shapes or whatever classes you are going
65:10 - to make shares inheritance property so
65:15 - if the classes you are making have is a
65:22 - relationship is our means what I mean to
65:26 - say it is is our relationship like this
65:31 - so rectangle is a polygon right and
65:34 - triangle is a prop polygon so this share
65:38 - is a property in between them so this
65:45 - relationship whenever some class
65:49 - inherits from some other class the share
65:52 - is a property or in a relationship so
65:56 - rectangle is a polygon and triangle is a
65:59 - polygon right so let's go towards the
66:03 - code part of it so what we are going to
66:06 - do is we are going to make three classes
66:09 - so we will go to the package one class
66:12 - first class we are going to make and I
66:14 - recall as as
66:17 - Poli gone right and I will I'm going to
66:26 - make two more classes one is rectangle
66:29 - and one is triangle so I will say this
66:35 - is rectangle plus and I'm going to make
66:42 - one more class which is going to be the
66:46 - triangle triangle okay now in my polygon
66:54 - class I have what property in common
66:59 - both rectangle and triangle can have
67:02 - width and height so I will define two
67:08 - variable which will be protected and why
67:11 - they are protected I have shown you and
67:14 - I have shown you what is the meaning of
67:18 - access modifier so protected and then in
67:29 - height and in the same way I will
67:33 - declare one more variable which will
67:36 - also be protected which will be weight
67:41 - okay and I will define a method which
67:44 - will be public and which will return the
67:50 - area so for example we will return area
67:55 - in double right and so this in here
68:04 - let's try to set the values off width
68:08 - and height for rectangle and triangle
68:10 - okay so this will be wide set values and
68:21 - in here we will define int a comma int B
68:27 - and whatever user will pass the value of
68:33 - a we will just say height is equal to e
68:41 - and width is equal to width is equal to
68:50 - B okay so by this method we are going to
68:55 - set the values okay now in my rectangle
69:00 - class how we can inherit from this
69:03 - polygon class we can inherit from
69:07 - polygon class in my rectangle class by
69:11 - using keyword extends okay just use the
69:17 - keyword extend and then use the class
69:21 - from which you are extending okay so
69:25 - rectangle class is inheriting from your
69:29 - polygon class and polygon class is in
69:34 - here it's called derived class and
69:38 - rectangle class here is a class which is
69:42 - deriving right so this can be called
69:45 - base class and this can be called the
69:49 - cloud class which is deriving okay in
69:52 - the same way I will extend in the
69:55 - triangle class also from polygon because
70:00 - polygon is my base class from which I am
70:02 - inheriting and now in my rectangle class
70:07 - I'm just going to calculate the area
70:12 - noun 1 whenever or if you are inheriting
70:17 - from a base loss to the right class then
70:21 - all its protected members and public
70:26 - members are accessible in your derived
70:31 - class okay so these member height and
70:35 - width and set values are accessed can be
70:39 - accessed by this rectangle class because
70:42 - we are extending from it okay if this
70:46 - was these variables and this methods
70:49 - watch private then we can not
70:53 - you know use them in other classes but
70:56 - because they are protected and public
70:58 - protected and public method can be used
71:01 - in subclasses so this is a subclass and
71:05 - this is a big plus so we can just define
71:08 - a method public and this will be the
71:14 - area so double area and what this method
71:21 - is going to do it will just return the
71:26 - area so return height into width and
71:38 - which height and which width we are
71:41 - talking about here because we haven't
71:44 - declared width and height inside this
71:49 - class in this rectangle class right
71:51 - but whenever you hover over and click on
71:55 - this height you will go to the height in
71:59 - polygon class okay so this height in
72:04 - polygon class is accessible in this
72:08 - rectangle class also okay and bit also
72:12 - from polygon class is acceptable in the
72:15 - rectangle class also okay in a similar
72:19 - way the area of the triangle is half so
72:25 - height into width divided by 2 right so
72:31 - we will just divide it by two okay
72:35 - so we have everything we have the area
72:39 - of triangle we have area of rectangle
72:44 - and we are setting these value by this
72:48 - polygon class now what we can do in our
72:52 - main method we can use or we can create
72:55 - the instance of rectangle class so
72:58 - rectangle are easy for rectangle
73:02 - new rectangle and we are going to create
73:08 - the instance of our triangle class also
73:12 - so triangle TR t RI is equal to new
73:20 - triangle and then for calculating the
73:26 - area we first need to set the value so
73:28 - we will set the value of the first
73:31 - rectangle so we will use instance of
73:34 - rectangle class dot set because we are
73:38 - inheriting from the polygons loss in
73:42 - rectangle class this set value method is
73:46 - also accessible in the rectangle class
73:50 - via its instance okay that's why we can
73:55 - access set when you method wire this
74:00 - rectangle instance for example we have
74:04 - done in the same way we can access set
74:13 - value method from our triangle
74:17 - and this for example is also seen then
74:25 - now we just need to call the area so we
74:30 - can just write this from rectangle class
74:36 - we can call its area method top area and
74:43 - in the same way we can call the area
74:51 - and now when we run the program we will
74:57 - get the answer first is the area of
75:01 - rectangle and second is the area of
75:04 - practice we can just modify this
75:21 - Plus right in the same way
75:33 - an area of rectangle and triangle are
75:36 - displayed like radial rectangle is 100
75:39 - which is 10 into 10 into and any of
75:44 - triangle a is equal to 10 into 10
75:47 - divided by 2 right so once again
75:53 - whenever we use inheritance all the
75:58 - property of the best loss in our J's
76:00 - polygon class is available in your
76:05 - derived class our case these are
76:08 - rectangle and triangle slots so all the
76:12 - method which are protected or public are
76:15 - accessible inside our rectangle or
76:19 - triangle okay so you can use the method
76:24 - inside polygon class if you derive it in
76:29 - rectangle in class you can use this
76:31 - height and width we have derived it here
76:34 - using
76:37 - this technique because we are extending
76:41 - from so in this way you can extend the
76:46 - property of polygon class to the
76:49 - rectangle class and same is for tracking
76:53 - class and in this video we will discuss
76:56 - what is polymorphism in Java and how we
77:00 - can use polymorphism in Java by an
77:05 - example so what is polymorphism
77:10 - polymorphism is the ability of an object
77:14 - to have different form so polymorphism
77:20 - literally means the word polymorphism
77:23 - means having different forms and
77:26 - whenever you define an object class
77:29 - object I should say and its property or
77:34 - its quality of having many forms is
77:37 - called polymorphism and how we can make
77:41 - our classes polymorphism or how you can
77:44 - define an object which follows
77:47 - polymorphism I'm going to give an
77:49 - example so I have four classes define
77:55 - one is called the danc'd loss which will
78:01 - be my base class okay so there is a bank
78:07 - class which is my base class and this
78:10 - contains three or a one method and this
78:15 - method just gives the rate of interest
78:19 - so I defined this method as get interest
78:23 - rate and because it sort of base class I
78:26 - return I'm returning zero as an interest
78:29 - rate okay I also have defined Bank
78:34 - underscore ABC class Bank underscore de
78:38 - F class and Bank underscore XYZ class
78:42 - okay
78:44 - so if you don't know how to make a class
78:47 - just right click new and go to class
78:51 - in here gave the name of the class so
78:53 - this is how I have created these classes
78:55 - okay so one is called bang class which
78:59 - will be my main class second class is
79:02 - called banked underscore ABC which
79:06 - extends from bang class because Bangkok
79:09 - class is our base loss and Bank ABC is
79:13 - our derived class and this also contains
79:17 - the same method and but this returns the
79:22 - rate of interest or this Bank has the
79:25 - rate of interest is equal to five
79:27 - percent for example okay
79:29 - Bank d EF which also extends from bang
79:34 - class have the rate of interest 6% so I
79:37 - have defined a method here which returns
79:41 - six simply okay and Bank class XYZ which
79:46 - is also extending from Bank so this is a
79:50 - derived class and this is a base class
79:52 - also have the same method get interest
79:57 - rate and the interest rate in this Bank
80:00 - is 10% so I have the same method in all
80:04 - the four classes yet interest rate and
80:07 - the only difference between these
80:10 - dysfunction is the rate of interest
80:13 - banks Bank itself has zero Bank ABC has
80:19 - 5% interest rate manga here has 6%
80:23 - interest rate and Bang XYZ has 10%
80:27 - interest rate now there is a property in
80:33 - Java called polymorphism by which you
80:36 - can define the reference or you can
80:40 - point the reference to a base class to
80:45 - any object of the derived class so what
80:50 - I mean by that is so when reference
80:54 - object or reference of parent class
80:58 - points to the object of the subclass
81:01 - it's called a casting
81:04 - and this is the basic you know extract
81:10 - of polymorphism so our we will define
81:14 - the reference of our bang class so we
81:17 - will just define bank b1 is equal to or
81:23 - Bank ABC
81:28 - is equal to so this is the reference of
81:32 - bank last which will point to the object
81:36 - of bank ABC which is a child class right
81:41 - like this
81:44 - and this is what we call polymorphism
81:48 - when our object can have different form
81:54 - so here the object of bang class is
81:56 - having the form of Bank ABC right so the
82:02 - reference of bang class is pointing to
82:05 - the object of Bank ABC plus in the same
82:11 - way we can define
82:13 - different objects so here we can define
82:18 - Bank
82:21 - d e f and here also Bank d e f and Bank
82:27 - X Y Z and Bank
82:34 - x y e okay so and let's see if it has
82:41 - the same name or not yeah
82:45 - and Bank XYZ it should be underscore
82:50 - right
82:53 - okay so we have defined three references
82:57 - of Bank class itself which points to the
83:01 - subclasses or an object of subclasses
83:05 - reference ABC points to the object of a
83:08 - Bank ABC class reference de F points to
83:11 - the reference or object of de F class
83:14 - and reference XY their coins to the
83:18 - object of XYZ class
83:22 - and I can call all these method get'
83:25 - interest rate from all these references
83:27 - right so I can just write this for
83:31 - control shift and in the same way I will
83:37 - do it three times and first time I will
83:41 - take ABC as my object and I will just
83:46 - call get interest rate and in the second
83:51 - statement I will paste de F dot get
83:56 - interest rate and third time I will
84:00 - paste XY that as my instance and I will
84:05 - call get interest rate okay and when I
84:08 - crunch up rogram
84:10 - I get five six and ten so this type of
84:18 - reference defining reference from the
84:21 - object of subclasses is called
84:23 - polymorphism and all the you know member
84:28 - function are available through this
84:31 - reference so this get instant interest
84:34 - rate are available in here in this class
84:38 - also in this class also in this class
84:39 - also and this Bank ABC gives us five
84:44 - percent interest rates which returns
84:46 - five Bank de F gives us six percent
84:49 - interest rate so it returns ten and Bank
84:52 - XYZ gives us ten percent interest rate
84:55 - so it returns stem but the interesting
84:59 - thing here here is all are the object of
85:03 - Bank yeah all or all references are
85:07 - pointing to different objects but all
85:12 - objects are from Bank class right and in
85:17 - this video we will see what is method
85:20 - overriding and how it's different from
85:24 - method overloading so in the last video
85:27 - I have shown you how and what is
85:30 - polymorphism and how we can use it right
85:33 - so we have defined a superclass which we
85:38 - call it as Bank and it was having one
85:42 - method called get interest rate which
85:47 - returns the interest rate of the bank
85:50 - okay and we have defined a subclass
85:54 - which we call it as Bank ABC which
85:59 - extends from Bank class and let's say
86:03 - for now it doesn't have anything so it
86:05 - doesn't have any implementation and now
86:09 - whenever we create the instance or the
86:14 - object of class ABC using the reference
86:19 - of Bank ABC or using the reference of
86:23 - Bank last we
86:24 - our superclass then what happens let's
86:28 - see so it returns you zero right because
86:32 - here in the superclass it has the method
86:37 - get' interest rate and which returns
86:40 - zero and here there is no implementation
86:43 - of cat interest rate right so whenever
86:46 - we define a reference which points to
86:48 - the object of the subclass within our
86:51 - case this is Bank ABC and when we call
86:55 - this get interest rate function it
87:02 - refers to this function which is in the
87:07 - superclass right now for example we
87:10 - introduced a function which has the same
87:13 - name and the same return type and same
87:17 - number of arguments as in black bass or
87:22 - superclass ok so I have the same
87:26 - implementation in my subclass also the
87:29 - only difference is it's returning 5 and
87:32 - our superclass was returning zero
87:35 - interest okay and now earlier the the
87:40 - interest rate returns was zero and now
87:44 - when we run the program it returns five
87:47 - and this phenomena is called a method
87:50 - overriding and method overriding is
87:54 - nothing but the changing of the
87:58 - implementation of the method okay
88:02 - so earlier the method which we were
88:07 - using for getting the interest was this
88:11 - one get interest rate from the base
88:13 - class but as soon as we introduced a new
88:17 - method in a subclass which is same and
88:21 - it's returning different you know
88:25 - interest rate and we define the object
88:30 - of the subclass as a reference then you
88:34 - see it's returning five right
88:38 - so your base glass or your object will
88:44 - always take the latest or the most
88:47 - recent method which is defined so this
88:52 - is the most recent method and it
88:54 - happened it's happening at the runtime
88:56 - that's why it's returning five so this
88:59 - is called method overriding now there
89:02 - are some rules for method overriding the
89:05 - rule of method overriding is you must
89:09 - have same number of arguments same name
89:13 - and same return data type for overriding
89:19 - a method so for example this kitten get
89:21 - interest method was returning integer
89:23 - and it doesn't take any argument in here
89:27 - also we have to whenever we want to
89:30 - override the method which was there in
89:33 - the superclass we have to define the
89:38 - integer return type and with no argument
89:41 - if you do it something like this and for
89:47 - example this thing this will be called
89:49 - method overloading and this will not be
89:53 - called method overriding so this takes
89:58 - us to what is the difference between
90:02 - method overloading and method overriding
90:04 - right
90:05 - so generally method over loading we use
90:10 - in a same class right so in this if we
90:16 - want to do it we can do it something
90:18 - like this and we can return in ABC
90:22 - something like this okay and this to
90:27 - method are called the method overloading
90:31 - so this method is overloading of a
90:34 - previous method right so this generally
90:38 - happens in the same class and whenever
90:40 - you do the method overloading this
90:43 - return type can be different the
90:47 - arguments can be different but the only
90:50 - same thing
90:51 - here is the method name so in method
90:54 - overloading only method name should be
90:57 - same but you can change the return type
91:00 - or number of argument also but in the
91:03 - method overriding you cannot change the
91:06 - return type or the number of argument
91:09 - okay so this is the main difference
91:12 - between method overloading and method
91:15 - overriding I hope you have understood
91:17 - the basic concept of map method
91:20 - overriding and what is the difference
91:22 - between method overloading and method
91:24 - overriding and in this video we will see
91:27 - what is an abstract class and why and
91:31 - where we will use abstract classes in
91:35 - Java so what is an abstract class an
91:40 - abstract class is a class which cannot
91:43 - be instantiated so for example if you
91:49 - make some class as an abstract class you
91:53 - cannot make an object of this class and
91:58 - what is the reason behind this is for
92:03 - example I have been showing you this
92:06 - Bank class in the last two videos for
92:11 - showing the polymorphism example so I
92:15 - have the superclass called base a Bank
92:18 - which is my super class which contains a
92:21 - method and I have a subclass which
92:26 - extends from my super class which is
92:28 - inheriting the super class and it also
92:31 - contains a method okay which is get
92:35 - interest rate now a bank is abstract in
92:42 - a bay that Bank is a general term or we
92:47 - can say Bank itself is very abstract
92:51 - word because we cannot you know deduce
92:55 - which Bank we are talking about from
92:58 - this class bank but we have Bank ABC
93:03 - which have some name
93:05 - and this can you know give you some
93:08 - interest rates or whatever other
93:13 - facilities which can be related to the
93:16 - bank right so in a way this bank class
93:20 - is serving as an abstract for other
93:26 - classes so it's just facilitating to the
93:32 - other classes it's method on member
93:35 - variables okay so for example we don't
93:40 - want this class to be instantiate that
93:43 - we just want that this class should be
93:46 - used by the other classes to have its
93:52 - functionality for example we can add
93:54 - some more function to the abstract bank
93:58 - and we can add those method or when e be
94:02 - can use those method using the
94:05 - inheritance property in our subclasses
94:09 - okay so Bank is a very abstract class
94:13 - and these kind of class sometimes we
94:17 - don't want the other user to make and
94:22 - you know make the instance of this class
94:25 - because whenever you make the instance
94:27 - of the class the interest rate here for
94:32 - example we are returning zero which
94:35 - means no interest right so whenever we
94:38 - make an instance of this class like this
94:41 - and when we run the program it gives us
94:44 - zero which doesn't really mean anything
94:49 - right so if we define this class and
94:53 - abstract so how to define a class and as
94:55 - an abstract class you just need to write
95:00 - abstract keyword before your class so
95:04 - this keyword when you add to a class it
95:07 - makes your class abstract and abs as
95:10 - soon as you add this keyword to your
95:13 - superclass which is a bank you see here
95:17 - this object creation is not possible
95:22 - anymore because this is the basic
95:25 - property of EFT abstract class that you
95:28 - cannot create any object from the
95:32 - abstract class but you can create a
95:36 - reference from its subclasses okay so
95:40 - you can create a reference which points
95:43 - to the sub classes because Bank ABC is
95:47 - not an abstract class so you can use
95:50 - this Bank ABC like this okay and this
95:55 - error will be gone okay so you can make
95:58 - an reference which points to the class
96:00 - which is not abstract but indirectly
96:04 - this Bank class is an abstract class
96:07 - which cannot be instantiated or we
96:11 - cannot make an object so indirectly we
96:13 - are restricting the access to this class
96:17 - from other users now we don't even have
96:24 - or we not only have a fractal assets but
96:29 - we also have xx abstract methods and
96:33 - abstract method whenever you define a
96:35 - method as abstract this method should be
96:40 - implemented by the subclasses which is
96:45 - inheriting the class okay so there are
96:50 - two conditions to make a method abstract
96:54 - one is the method wherever it's present
97:00 - so this method is present in my bank los
97:03 - this class should be abstract to make
97:06 - this method abstract so we can make this
97:09 - method abstract and whenever you make an
97:12 - a method abstract you don't need its
97:16 - instantiation or definition so but the
97:21 - most basic condition is the class in
97:25 - which this abstract method is present
97:27 - this should be also abstract so
97:31 - should be abstract then only you can
97:33 - make a method abstract and whenever you
97:36 - make an method abstract you need to give
97:41 - the implementation of this method in
97:44 - your sub classes because Bank class is
97:49 - our superclass and Bank ABC is
97:53 - inheriting from our superclass we need
97:56 - to give the implementation of all the
98:00 - abstract method which are present in our
98:03 - abstract class so we need to give the
98:07 - definition of this method in here so
98:13 - whatever classes which are inheriting
98:15 - from this you need to give the
98:18 - definition here here and here
98:20 - for example I just comment this in the
98:28 - this method Bank ABC method which is
98:31 - extending from the bang class then this
98:35 - class will give the error that the type
98:38 - Bank ABC must implement the inherited
98:43 - abstract method right so you cannot
98:46 - compile a program if you don't implement
98:50 - the effect method in the subclass okay
98:55 - so if you make any method abstract you
98:59 - need to implement it in your subclasses
99:02 - if you are inheriting from this loss so
99:07 - this is how abstract classes and
99:11 - abstract method works the other thing is
99:15 - you may encounter a keyword called
99:18 - concrete and the concrete class is
99:23 - literally or almost opposite to the
99:28 - abstract class so if the abstract class
99:33 - cannot be instantiated the concrete
99:36 - class can be instantiated and so this
99:42 - class which is inheriting
99:44 - the effect last week haven't added
99:47 - abstract keyword here but we don't even
99:50 - need to give concrete keyword in order
99:53 - to make it concrete you just need to you
99:57 - know you don't need to give anything you
99:59 - just need to give public or a private or
100:04 - whatever class you want to declare and
100:06 - this makes your class app concrete so if
100:11 - you don't add abstract keyword before
100:15 - class its concrete because it's it can
100:19 - be instantiated and if you add a keyword
100:23 - effect before a class it makes the class
100:26 - abstract which cannot be instantiated so
100:29 - I hope you have understood the basic
100:30 - concept of abstract and concrete classes
100:32 - and in this video you will see what are
100:36 - interfaces and how we can use interfaces
100:40 - in Java so an interface is same as an
100:46 - abstract class as abstract class cannot
100:52 - be instantiated and instead interface
100:55 - also cannot be incident an instantiated
100:59 - so for making an interface for example
101:04 - we have been seeing this example from
101:06 - our last videos and we have a bang class
101:12 - which is our superclass and when we
101:15 - define this class as an abstract class
101:18 - this bang class cannot be instantiated
101:21 - we have seen in the last video now in
101:24 - place of doing so many things like
101:29 - declaring abstract public class we can
101:33 - just use a keyword called public
101:37 - interface and then it makes your
101:42 - interface something like this and all
101:48 - the method inside an interface are
101:54 - abstract by nature okay so you don't
101:57 - need
101:58 - to add a keyword abstract in any member
102:02 - method of the interface like this all
102:05 - the method or all the members of the
102:07 - interface are abstract by nature so in
102:12 - the last video we have seen if the
102:15 - methods are abstract then we need to
102:19 - implement this in the subclass in which
102:24 - we are inheriting right now let's start
102:30 - from the beginning
102:31 - so I'm going to delete all the classes
102:34 - which I made earlier and then I'm going
102:39 - to make an interface okay so in Eclipse
102:48 - you can make interface by just going to
102:52 - the package in which your main loss is
102:56 - or main method is and just right-click
102:59 - it and you can just go to new and click
103:03 - interface here and you can give the name
103:06 - to your interface for example we will
103:08 - give the name to our interface as Bank
103:11 - as we have given in the last video to
103:15 - our abstract superclass okay so this is
103:20 - the basic definition of interface and
103:22 - whatever method you define inside the
103:25 - interface like get interest rate it's
103:33 - automatically abstract by nature okay so
103:41 - whenever you want to inherit from the
103:46 - interface so interface only can be
103:49 - implemented not can be extended so when
103:54 - we define a class for example we will
103:56 - define a new class for Bank interface
104:00 - and this class we will name it as Bank
104:06 - ABC for example
104:10 - and we want to inherit from the
104:15 - interface this interface because this is
104:18 - an interface there is no class keyword
104:21 - in here in the bank interface right so
104:24 - you cannot extend from a interface in a
104:30 - class you need to implement the
104:32 - interface so you need to use the keyword
104:35 - implement implements something like this
104:42 - okay and then you can implement your
104:44 - bank interface and you will be good to
104:48 - go now
104:50 - because we have this get interface or
104:54 - get interest rate method inside our
104:56 - interface we need to define or give the
105:01 - definition of this get interest rate in
105:05 - our subclass also because all the
105:09 - methods inside our interface are
105:11 - abstract by nature right so you need to
105:14 - give definition something like this and
105:19 - wait on some interest rate and then your
105:24 - definition will be okay now it says you
105:30 - cannot reduce the visibility let's say
105:34 - by because this should be public by
105:37 - nature so we just need to add public
105:40 - keyword and then it's okay so whenever
105:45 - you want to inherit from the interface
105:48 - use the keyword implement rather than
105:52 - extends okay and whenever you want to
105:57 - inherit from the interface to an
106:00 - interface you can use the keyword extent
106:03 - so just bear in mind whenever you to
106:09 - class you have two classes class and
106:14 - class
106:16 - and both are you know you want to
106:19 - inherit one class from another then you
106:22 - use extends okay if you have interface
106:29 - as a base class and you have class as
106:35 - sub class you need to use implement
106:41 - implement and if you have two interfaces
106:48 - interfaces and interfaces interface and
106:53 - interface then you can use extend okay
106:58 - so simple rule is if the both subclass
107:02 - and superclass our classes or interface
107:07 - themselves both are same you use extend
107:10 - and if the super classes interface and
107:14 - subclass is your class then you use
107:17 - implement keyword here okay so this is
107:22 - how you can use interface or and
107:24 - interfaces are abstract by nature so
107:27 - they also cannot be instantiated so if
107:30 - you want to instantiate Bank Bank
107:34 - something like this is equal to new Bank
107:39 - it's not possible because it's just an
107:42 - interface and in interfaces are abstract
107:45 - by nature okay so this is how we can use
107:48 - interface in Java I hope you have
107:50 - enjoyed this video please rate comment
107:52 - and subscribe and bye for now