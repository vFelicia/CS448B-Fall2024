00:00 - in this video we'll be making our second
00:02 - programming project which is going to be
00:03 - this
00:04 - the snake game so i'm sure everybody
00:06 - knows how to play this game you have a
00:08 - snake which grows on eating the food
00:10 - and the objective is to grow the snake
00:12 - as long as possible without hurting
00:14 - yourself or hitting one of them so if
00:16 - you do any of those you lose this game
00:19 - well there are different variations of
00:20 - this game some have teleportable walls
00:22 - that is
00:23 - if you go through this wall you end up
00:25 - coming from there
00:26 - and some versions even have obstacles in
00:29 - between them
00:30 - instead of this free space but we're not
00:32 - going to do any of those we are just
00:34 - going to stick to the simple version
00:35 - with four concrete walls
00:37 - and uh empty space in between right
00:40 - so let's get started let's create a new
00:43 - project it's going to be a console
00:44 - application
00:46 - and the language is c plus plus project
00:50 - title let's say snake
00:52 - and these things remain as it is right
00:55 - and now let's first start by defining
00:59 - the board
01:01 - so if you remember from our previous
01:03 - project where we made our detector game
01:05 - we had defined a 2d array or a matrix to
01:08 - hold the board right
01:09 - but here if you see you don't need that
01:12 - why
01:13 - well in the previous game where we made
01:15 - a tic-tac-toe game the board only had
01:17 - nine elements
01:18 - and we were concerned about all the nine
01:21 - elements of the board right so we were
01:23 - concerned about what all the board
01:25 - contained
01:26 - but here you don't have to actually be
01:29 - concerned about all the elements of the
01:31 - board
01:32 - here the board just acts as a background
01:34 - the only things you are concerned about
01:36 - are the position of the snake the
01:38 - position of the fruit
01:40 - and the position of the wall so other
01:43 - than that you don't need to
01:44 - keep track of other things so here we
01:47 - are just going to print the board just
01:49 - like
01:50 - we print something on the console so
01:52 - let's define a function for that
01:55 - let's say void board
01:58 - and here we are going to draw the board
02:00 - so uh let's first define the dimensions
02:03 - of the board the width and height
02:04 - so let's say uh the width is going to be
02:07 - somewhere around
02:08 - 50 characters so since we are working on
02:11 - the console you are going to see
02:12 - everything in terms of
02:13 - characters or this is basically a
02:16 - substitute for pixels if you are
02:17 - familiar with graphics
02:19 - and the height is going to be somewhere
02:22 - around let's say 25 characters
02:25 - now these two things are constant right
02:28 - so the these won't change throughout the
02:30 - project
02:30 - so if you want to make them as constant
02:32 - so you can just say
02:33 - const over here so this keyword will
02:36 - make these things as constant
02:38 - and now i would like to introduce you
02:41 - the concepts of
02:42 - macros so macros let me write it down
02:46 - here
02:46 - macros these are nothing but one-liner
02:49 - code
02:50 - right so let's say you want to define
02:53 - a function to calculate the square so
02:55 - what you do typically is you write
02:57 - something like this right so in
02:59 - skew and this will return x into x right
03:03 - so
03:03 - this is how you define a small function
03:06 - but what you can do is instead of
03:08 - defining it as a function you can define
03:11 - it
03:11 - as a symbol so when i pin symbol
03:15 - what i mean is if i type that particular
03:17 - symbol then this operation should be
03:19 - performed so that is what a macro does
03:21 - so
03:21 - the way you define macro is you put hash
03:24 - define
03:25 - and then you put the symbol so let's say
03:27 - sq over here and inside this whatever
03:29 - parameters you want to pass without any
03:31 - data type so this is basically a symbol
03:34 - and here you want to uh define the
03:37 - operations
03:38 - so here our operation is x into x so
03:41 - that is basically going to return as the
03:43 - square of a number
03:44 - so here you don't have any assignment
03:48 - operators or written operators
03:49 - all this means is whenever i say sq of x
03:53 - it should do this particular operation
03:55 - so if you say something like
03:57 - sq of 5 and here
04:00 - if you run this you should be getting
04:02 - the output as 25
04:04 - so that's how you use macros and you can
04:06 - do the same with
04:08 - these two variables also so the way you
04:10 - define it as
04:11 - hash defined width is 50
04:15 - and hash define
04:19 - height 25 so
04:22 - now whenever i save width i mean 50 and
04:25 - whenever i say height
04:26 - i mean 25 so now you can remove this you
04:29 - don't need this anymore
04:30 - so now the board is going to be two
04:32 - loops the first
04:34 - loop or the outer loop is going to
04:36 - control the number of rows
04:37 - so here the number of rows is defined by
04:39 - height right because height is basically
04:41 - how down you go
04:42 - so that is how many rows you have in
04:45 - your board
04:46 - so i is less than the height of the
04:48 - board
04:49 - and i plus plus and inside this you will
04:51 - control the width so
04:53 - enter in let's say j
04:59 - and inside this you are going to print
05:01 - something so here if you observe this
05:03 - board
05:04 - for every row there are two wall pieces
05:06 - right so every row starts with one wall
05:09 - and then ends with
05:10 - one bolt so since that default you can
05:12 - subtract two here and then put those two
05:14 - characters so you have one ball
05:16 - in the beginning of a row and
05:20 - one wall at the end of the row
05:23 - and then you go to the new line
05:26 - and inside this basically if the
05:29 - row number is 1 or the row number
05:33 - is height minus 1 that is
05:36 - if you are printing this row or this row
05:40 - then you need to print all walls so here
05:42 - we are just going to print out
05:44 - these hashes or else
05:48 - you need to print out the empty space
05:50 - which is basically this
05:51 - space right so now if you call
05:54 - your board function that should print a
05:57 - board for us
05:59 - so here we have the bowl
06:02 - now this board looks pretty squished to
06:05 - the left so
06:06 - you can take care of that by adding a
06:08 - couple of tabs
06:10 - and that will center the board
06:14 - so now let's see how to animate things
06:18 - on the console
06:19 - so if you are familiar with graphics or
06:22 - even if you have heard about animation
06:24 - you might know that animation is nothing
06:26 - but just
06:27 - fast moving pictures right so here if
06:30 - you want to animate something on the
06:31 - board
06:32 - let's say you have some object on the
06:34 - board
06:35 - then the video animators you will
06:37 - quickly move the position of that object
06:39 - and it will appear as moving
06:41 - so to move something on the board or to
06:44 - place something on the board you need to
06:46 - know about the coordinate system which
06:47 - the computer uses
06:49 - so let's talk about that quickly so you
06:51 - might have come across this cartesian
06:53 - coordinate system in your math class
06:54 - right so you have
06:56 - a coordinate system where if you go
06:59 - right the x
07:00 - coordinate increases and if you go
07:02 - vertically upwards
07:03 - your y coordinate increases and this
07:06 - will
07:07 - position basically which is the
07:09 - intersection of these two
07:11 - axis this is the origin which is defined
07:14 - by this
07:14 - zero zero coordinate right so this is
07:17 - the coordinate system you all have come
07:19 - across in your math class
07:21 - now what happens in a computer is this
07:24 - origin is shifted to this top left
07:26 - corner so let me just clear this thing
07:31 - so in a computer your access are defined
07:33 - as follows so
07:35 - if this is the top left corner of the
07:37 - screen that is
07:38 - this position where i'm pointing my
07:40 - cursor that position
07:42 - is basically your zero zero position so
07:44 - this is your origin in a computer
07:47 - and as you go right your x coordinate
07:50 - increases
07:51 - and as you go down your y coordinate
07:54 - increases
07:55 - so basically your y is flipped in case
07:58 - of a computer and
07:59 - x remains the same so as you go up
08:03 - your y is decreasing
08:07 - and as you go left your x-coordinate
08:10 - decreases
08:11 - so that's how the coordinate system in a
08:13 - computer is defined
08:14 - you can use this coordinate system to
08:16 - move objects in your
08:18 - screen or even place objects in your
08:20 - screen so
08:21 - every object is defined by x coordinate
08:24 - and y coordinate so if you
08:26 - put some point here so it has some
08:29 - x coordinate that is how much it has
08:31 - moved from the origin in the horizontal
08:34 - direction
08:35 - and some y coordinate that is how much
08:37 - it has moved from the vertical direction
08:39 - right so this is how the coordinate
08:41 - system of the computer is defined and we
08:43 - will be using this system
08:44 - to operate on our board right so
08:47 - let's define an arbitrary object
08:50 - somewhere so let's say
08:52 - our int x which is the x coordinate is
08:55 - going to be somewhere around 10
08:57 - characters
08:58 - and y is also 10 so that means that this
09:01 - is
09:01 - 10 characters from the left and then 10
09:04 - characters down
09:05 - so it it will be in some arbitrary
09:07 - position somewhere let
09:08 - let's just see where it is so if i here
09:11 - if i
09:12 - print that particular object that is
09:14 - pretty simple to print so if the
09:16 - coordinates match you are going to print
09:17 - that object
09:18 - so how do you do that well i is
09:20 - controlling the height right so height
09:22 - defines how
09:23 - deep you are on the board so that is
09:25 - basically the y axis so you need to
09:27 - compare i
09:27 - with y and j with x so
09:31 - if you if these two coordinates are
09:33 - equal then
09:34 - you can say that your object is at that
09:36 - particular position and you can print
09:38 - something so let's
09:39 - go with this zero for now so that is
09:42 - going to be our object
09:44 - now if i try to print this board you
09:46 - will be getting your object here so
09:49 - and this is 10 characters from the left
09:51 - and 10 characters towards
09:52 - the bottom but if you see this position
09:55 - is exactly
09:55 - not as square as expected uh that is
09:58 - because in console the
10:01 - next line has some gap if you see over
10:04 - here so
10:04 - this gap is much bigger than this gap
10:07 - that is why
10:08 - it doesn't end up as a square but if
10:11 - you're using some graphics library
10:13 - then this will work so it will exactly
10:16 - be as a square so
10:18 - it will end up somewhere over here so
10:19 - this could be the 10 comma 10 point
10:22 - but here since we are working on the
10:24 - console uh
10:25 - the y-axis is much wider or i should say
10:29 - much
10:29 - deeper than the x-axis so uh even when
10:33 - you animate your snake
10:34 - it's going to move faster on the
10:36 - vertical direction than on the
10:37 - horizontal direction
10:38 - that's actually not a logical error
10:40 - that's because of the property of
10:42 - console you cannot do anything about
10:43 - that right
10:44 - so if you're using any graphics library
10:47 - then
10:47 - that problem won't be there so now let's
10:50 - see how to animate this
10:51 - animating is very easy you just need to
10:53 - move the board right
10:55 - so uh let's say i will create an
10:58 - infinite loop here
11:00 - and inside this we will first call the
11:02 - board and every time
11:04 - this loop runs we will just increment
11:06 - the x coordinate so
11:07 - when you increase the x coordinate from
11:09 - this coordinate system your object is
11:11 - going to move towards the right right so
11:14 - now if you run this program you should
11:15 - be getting some kind of movement
11:17 - so here you can see that this o is
11:19 - moving towards the right but
11:20 - uh you cannot actually see it as a
11:22 - movement this is basically it
11:24 - is just printing the board again and
11:25 - again so if you have some way
11:29 - to update the board then you can see the
11:32 - movement
11:33 - so one way you can update us you can use
11:35 - your console command so if i pull up my
11:37 - console over here this is basically a
11:39 - powershell
11:40 - but in windows or if you're using this
11:44 - code blocks in windows it's going to
11:46 - use the use your cmd as your default
11:49 - console right
11:50 - so in cmd the command for clearing the
11:53 - screen
11:54 - is cls so if i type something over here
11:56 - under type cls
11:57 - that thing is cleared right
12:00 - and if i were linux the command for
12:03 - clearing the cler
12:04 - and the way you pass in such shell
12:07 - commands or such console commands are
12:09 - you include another library called
12:14 - cstdlib which stands for c standard
12:16 - library you might have come across this
12:18 - while making a tic-tac-toe game this is
12:21 - the library which had our random
12:22 - function
12:23 - and we will be using that random
12:25 - function in our code as well
12:26 - right so here to send commands to the
12:30 - console you use
12:32 - system and inside this you write the
12:34 - command so
12:35 - in in my case it is the windows
12:37 - operating system so i write cls
12:39 - and in case you're on linux you need to
12:41 - write clear
12:42 - right so let me just comment distance if
12:44 - you're on linux you need to write clear
12:46 - and i forgot the semicolon and now if i
12:50 - run this
12:51 - i should be getting a movement but if
12:53 - you see here
12:54 - it kind of flickers on my screen right
12:56 - so this
12:57 - board is up getting updated but it is
13:00 - annoying to see so uh this you
13:04 - cannot actually control so more
13:06 - technically
13:07 - if you know about the fps or the refresh
13:10 - rate
13:11 - so you cannot control these things of a
13:14 - console console is not a property of the
13:16 - language or just
13:17 - id right it is a property of the
13:20 - operating system so you cannot control
13:24 - something
13:24 - from an external source which belongs to
13:28 - the operating system
13:29 - so one way you can take care of this
13:31 - flickering
13:32 - is instead of clearing the screen this
13:35 - is happening because
13:36 - it is doing two processes right first it
13:38 - is clearing the screen and then again it
13:40 - is drawing the board
13:41 - so if you just overwrite the board as we
13:44 - used to do
13:44 - with our normal line so if you remember
13:47 - from our escape sequences video
13:49 - we had talked about an escape sequence
13:51 - called slash
13:52 - r right so if you write something over
13:54 - here let's say
13:56 - hello world and um here if i put slash
14:01 - r and i type something else so as is
14:05 - then the first four characters which are
14:07 - these four characters are going to be
14:09 - replaced by the word asas
14:11 - so now if i run this i should be saying
14:13 - iso over
14:15 - so that is because he ll has been
14:17 - replaced by this
14:18 - that is because this slash r will take
14:21 - the
14:22 - cursor from the end of the line and
14:24 - place it in the beginning
14:25 - but we cannot use the slash r over here
14:28 - that is because we are using multiple
14:30 - lines right so
14:31 - you are printing around let's say 25
14:33 - lines because the height is 25 so you're
14:35 - printing 25 lines
14:37 - and there is no escape sequence to get
14:39 - your cursor back a line so
14:41 - slash n will move your cursor down a
14:44 - line but you cannot go up a line
14:46 - right so for that i'm going to
14:49 - tell you a solution but this is going to
14:51 - work only if you're on windows so let me
14:53 - write it down here
14:54 - this is only for windows and for linux
14:57 - you need to find out a library which
14:59 - tested
15:00 - so basically what we are going to do is
15:03 - we are going to pick up this cursor
15:05 - from the end of the screen and we are
15:07 - going to go all the way
15:09 - up to the origin and place it back so if
15:11 - you do that instead of clearing the
15:13 - screen you are moving the cursor and
15:15 - when you print your data again
15:17 - it's going to be overwritten on the
15:18 - console so it looks like
15:20 - it has been cleared but actually it has
15:23 - been overwritten instead of clearing
15:25 - so this solution what i am going to give
15:28 - you in this particular video will work
15:30 - only if you are on windows so if you are
15:31 - on linux you need to find out some
15:33 - library which will do that for you
15:35 - right so if you are on windows you need
15:36 - to include a library called windows
15:38 - starter which will basically allow you
15:40 - to control the cursor's position on your
15:43 - console
15:44 - and here what you need to do is instead
15:46 - of system clear
15:49 - you can do set
15:52 - console cursor position
15:55 - and here you need to give some handle
15:57 - which is
15:58 - get htd handle inserted
16:02 - std output handle so if you don't
16:05 - understand what this means it's okay
16:08 - it's just you can think of it as it's
16:10 - going to pick up the cursor from the end
16:12 - and it's going to put it back on the
16:14 - origin
16:14 - and to put it back on the origin or any
16:17 - specific coordinate you need to
16:19 - pass in a coordinate data structure
16:22 - well coordinate is basically a simple
16:24 - data structure which is already defined
16:26 - in windows.h and we'll be using this so
16:28 - if you're on linux and you're using some
16:30 - other library to achieve this you need
16:31 - to define this
16:33 - uh structure to follow along with this
16:35 - tutorial which is basically a simple
16:36 - structure
16:37 - it is something like in x and
16:41 - y so this is the structure which is
16:44 - defined in windows so i'm not going to
16:45 - define this again
16:46 - it's there in this windows.h and that's
16:49 - what we are using over here to
16:51 - send the position to our handle
16:55 - which will basically take the cursor
16:58 - from this position and then put it back
16:59 - to the origin
17:00 - so the origins coordinate are basically
17:02 - 0 zero so you need to pass that
17:04 - in and now if you see you won't have any
17:08 - flickering screen you will have a
17:09 - neat animation going on on your screen
17:12 - so as you can see there is no flickering
17:14 - although you can see that
17:15 - cursor update somewhere but this is much
17:17 - better right
17:18 - instead of the flickering screen so
17:20 - again this
17:21 - solution is only for windows users so if
17:23 - you're in linux you have some
17:25 - other libraries like you have n cursors
17:29 - and
17:29 - many other libraries simple google
17:31 - search will get you what you want
17:33 - right now uh let us remove all these
17:36 - things
17:37 - we have now understood how to do
17:38 - animation and here
17:41 - what we are going to do is we are first
17:43 - going to define our snake
17:45 - so go to file new and clash
17:51 - and the name of the class is snake and
17:54 - you can remove all these things right it
17:56 - doesn't really matter
17:57 - you don't need destructor on all these
18:00 - things we'll create
18:01 - if we want to right and here just click
18:05 - ok and in snake dot h
18:08 - we have this template code so again i
18:11 - prefer
18:12 - private to be on the top so if you want
18:15 - that you can follow this
18:16 - or if you if you're okay with the
18:18 - structure it has given
18:20 - before you can follow that it doesn't
18:22 - really matter
18:24 - and here first of all we are going to
18:26 - decide what is going to be private and
18:28 - what is going to be public
18:29 - so what are the features that we need
18:32 - our snake to have
18:33 - first of all it will have a position
18:35 - right the position of the head to be
18:36 - places
18:37 - and next it should have a length
18:41 - to define how long the snake is and
18:44 - you also need a direction and
18:47 - you also need a velocity or you can say
18:50 - speed of the snake so how fast it goes
18:52 - so here in case of velocity or speed we
18:54 - are going to talk
18:56 - in terms of number of characters so let
18:59 - me write it down here
19:00 - that is basically it is going to move
19:02 - two characters at a time three
19:03 - characters at a time and so on
19:05 - so in case you are working with some
19:06 - graphics library that
19:08 - the same thing you do with pixels so you
19:10 - say three pixels at the time or five
19:12 - pixels at a time
19:13 - and since here we are on console we are
19:15 - going to
19:16 - talk everything in terms of number of
19:18 - characters
19:19 - right so uh here let me define the
19:22 - private variables first in this you are
19:24 - having
19:24 - to have a position so it's going to be
19:27 - quad position so again
19:28 - if you are in linux you need to define
19:30 - the structure and uh
19:32 - for using the squad you need to include
19:34 - windows started
19:35 - right so this is because this is a
19:37 - separate file that snake.h is a separate
19:40 - file so even if you are
19:41 - included in main you need to include it
19:44 - again but you can
19:45 - exclude this over here because once we
19:48 - actually include this file you are going
19:50 - to include all these things it doesn't
19:52 - matter even if you keep it
19:54 - twice because of this guard block as i
19:55 - had explained before
19:57 - this guard block what it does is it
19:59 - takes care of
20:00 - multiple initialization so here i have
20:02 - already included windows.h
20:04 - now i when i do hash include snake dot h
20:08 - it will take care of the fact that i
20:10 - have already included windows started so
20:12 - i don't need to include it again
20:13 - but here if you want to use these things
20:16 - you need to definitely specify that you
20:18 - are using windows. or else you cannot
20:20 - use this and will throw you an
20:21 - error right and here you need
20:25 - a length of the snake and you have a
20:28 - velocity so
20:29 - in well and you have a direction so
20:31 - let's say card direction
20:34 - and in the public section we need to
20:36 - define constructor first and this
20:38 - is going to take a position that is the
20:40 - initial position
20:42 - and uh initial velocity for our snake so
20:45 - let's define this constructor and
20:47 - dot cpp and um here
20:50 - we talk and specify those things so
20:53 - called
20:54 - position and velocity and here you don't
20:57 - have to include windows attached that is
20:59 - because again you are including snake
21:01 - dot h which
21:02 - comes with windows started so you don't
21:04 - have to include it again
21:05 - and uh here you need to set the position
21:09 - and velocity so
21:10 - since i'm using the same name for both
21:12 - the variables
21:13 - i need to use this pointer so if you are
21:16 - not using the same name it's okay
21:18 - but if you are using the same name you
21:20 - need to use this pointer and
21:22 - the velocity also goes the same way
21:26 - and initially the length is going to be
21:29 - one
21:29 - that is because you have one head right
21:32 - so
21:32 - without the length cannot be zero
21:34 - because you always have a head
21:36 - for the snake so the length is going to
21:40 - be
21:40 - one initially and the direction
21:44 - so the direction you can say uh
21:47 - something like
21:48 - none right because the snake is not
21:50 - moving now
21:51 - and um we'll have a method to
21:54 - change the direction of the snake so
21:56 - let's say on
21:58 - change dir which will change the
22:00 - direction it will take some
22:01 - direction to change and here
22:05 - let's define that method it's void snake
22:09 - change dir
22:13 - and what you need to do is direction
22:15 - equal to there
22:16 - basically i'm just setting the direction
22:18 - of a snake and um
22:21 - for moving the snake let's create a move
22:24 - method
22:25 - or move snake well move is basically a
22:28 - defined method in c
22:29 - so it's not preferable to overwrite it
22:32 - you can overwrite it you can define
22:34 - something like this but
22:35 - it's preferable not to overwrite any
22:39 - default method so let's say move snake
22:42 - and this is not going to take any
22:43 - parameter
22:44 - because it's just going to perform
22:45 - something so void does
22:47 - make more snake and here what you need
22:51 - to do is you need to switch
22:53 - the direction that is basically you need
22:55 - to move the snake in that particular
22:56 - direction
22:57 - so switch direction and here you need to
23:00 - put different cases so
23:02 - in case it is going up then what you
23:05 - need to do refer to this coordinate
23:06 - system
23:07 - you need to decrease the y coordinate so
23:10 - what we're going to do is
23:11 - cos dot capital y minus
23:14 - equal to the speed so basically if i say
23:17 - that my snake is moving two characters
23:19 - per second or two characters per
23:21 - iteration then
23:23 - i need to subtract those many characters
23:24 - right to move to appear to be moving in
23:27 - that
23:27 - much speed so that is why we are going
23:29 - to subtract the velocity over here or
23:31 - speed you can name it whatever you want
23:34 - and here the break is mandatory
23:37 - and this will be true for all the four
23:40 - directions so let me just copy it down
23:42 - four times and uh
23:43 - it's going to up down left and right
23:46 - right is you need to increase your
23:48 - velocity left test you need to decrease
23:51 - your velocity
23:53 - and um for down you need to increase
23:55 - your velocity on the y
23:57 - coordinate so this will move your snake
23:59 - in your preferred direction
24:00 - and that should be it so now you have a
24:03 - snake you have initialized it with some
24:06 - initial position and velocity and you
24:09 - have a method to change the direction of
24:11 - a snake
24:11 - and now you even have a method to move
24:14 - the snake
24:15 - and here since we need the position of
24:18 - the snake to
24:19 - draw it on the board you also need
24:22 - a method to get the position so let's
24:25 - say
24:26 - uh get
24:29 - pause which will return the position of
24:30 - the snake
24:32 - and uh this is going to be return
24:36 - first and uh i forgot to mention slate
24:39 - here this
24:39 - will be declared as normal function if i
24:42 - forgot to
24:43 - mention this this basically means that
24:45 - uh
24:46 - this get pass function is related only
24:48 - to the snake class right
24:50 - i'm sure everybody knows this and uh
24:52 - here
24:54 - we'll quickly define a prototype for
24:55 - that let's quad
24:57 - uh get pause and done
25:01 - so now you have four methods let's go
25:04 - very quickly one is a constructor which
25:06 - will initialize our variables
25:08 - one is a method to change our direction
25:11 - so change
25:15 - direction of the snake and one
25:18 - is to move the snake
25:21 - in that particular direction and one
25:25 - is to get the position of the snake
25:28 - or i should say get the current position
25:31 - so now let's
25:32 - use this thing in our main file so you
25:35 - here as i told you you can remove this
25:37 - windows storage because it is going to
25:39 - be included with snake dot h
25:41 - and uh here let us first create a snake
25:43 - so snake s
25:44 - and let's sneak and inside this let's
25:47 - see
25:49 - it's going to be initially in the middle
25:52 - of the board
25:52 - so that's basically 50 by 2 and 25 by 2
25:55 - or
25:56 - you can say bit by 2 and height by 2
25:57 - that makes more sense right
25:59 - so width over 2 and height over 2 that
26:02 - is basically the center of the board
26:04 - and velocity let's say it's going to be
26:06 - 1 that is one character
26:08 - at a time and here you instead of y
26:12 - and x you need to capture the position
26:15 - of the snake so
26:15 - called the snake boss you can see equal
26:19 - to
26:19 - um snake dot get position
26:24 - and here instead of why you need to say
26:27 - snake
26:28 - pause dot y and instead of j
26:31 - you need to say snake poss dot
26:34 - x so so far so good we have created a
26:38 - snake which
26:39 - is going to be on the middle of the
26:40 - board and which is going to
26:42 - move at a speed of one character at a
26:44 - time
26:45 - and here um let us just clear all these
26:48 - comments
26:49 - and now let's see how to get input so
26:53 - that
26:54 - we can control the snake so you need to
26:56 - move the snake only when you press
26:57 - something right
26:58 - so here how do you capture that
27:00 - keystrokes well you have a library to do
27:03 - that
27:03 - so that is called corneo or i should say
27:06 - console input output
27:08 - and here you can just do the following
27:11 - so if you say
27:12 - if kb hid so kb hit stands for keyboard
27:15 - hit so
27:16 - it will be true if you hit a key on your
27:18 - keyboard
27:19 - not necessarily enter key you can hit
27:21 - any key on your keyboard and this is
27:23 - going to evaluate to true
27:24 - and to capture your key you need to say
27:27 - gets yet so
27:28 - get ch will basically give you the key
27:30 - which you
27:32 - just pressed so uh we will capture this
27:35 - and instead of capturing this we can
27:36 - switch this so that
27:38 - we don't have to write a couple of if
27:40 - statements we can just say switch
27:42 - get ch which will basically give us the
27:45 - key
27:46 - and here you can control it so let's say
27:48 - up
27:50 - so i'm not going to do it for the arrow
27:53 - keys because i don't
27:54 - really remember the ascii values of the
27:56 - arrow keys so if you want
27:58 - arrow keys you need to give the ascii
27:59 - value so let's say 132 is the ascii
28:02 - value of upper key it is not the case
28:03 - i'm just saying
28:05 - but if 132 is the ascii value for the up
28:08 - key then you need to give something like
28:09 - this but uh i'm just going to go with
28:12 - wsd for now
28:13 - so case w then um what you need to do
28:16 - you need to move the snake
28:17 - upwards right so snake dog change their
28:21 - double up sorry u
28:24 - and then break and you need to do this
28:27 - for
28:27 - all the four directions so control c v b
28:30 - w a s d and uh
28:35 - d is basically go to right s is
28:38 - down and this is left for now
28:42 - this will more snake in our preferred
28:44 - direction and to move the snake you just
28:46 - call snake dot move
28:47 - snake which will move a snake and now if
28:50 - you run this you will be getting
28:52 - a snake which can move on your command
28:55 - so now you can see that it is not moving
28:58 - because initially we had set
29:00 - the snake's direction to be n right so
29:02 - we did not
29:03 - have any case which will uh move the
29:06 - position for
29:07 - n so it doesn't move for any iteration
29:10 - and now once i press w you can see that
29:12 - it started moving up
29:14 - a it started moving left yes it started
29:16 - moving down
29:17 - and d it started moving to the right so
29:20 - now i can control this little character
29:22 - and
29:23 - keeps moving right so that is how the
29:25 - snake game is different
29:26 - so once you press a key it will keep
29:28 - moving in that particular direction
29:30 - until you change the direction
29:31 - so this is what we needed and we got a
29:34 - moving
29:35 - character on our board so now let's see
29:39 - how to first uh generate the food and
29:42 - calculate the points and then we will
29:44 - talk about how to increase the
29:45 - snakes length once it eats the food
29:47 - right so
29:49 - now let us just close this and talk
29:51 - about the food so again you need to
29:53 - create another
29:55 - class for generating the food so it's
29:57 - going to be
29:59 - it's a food and again you don't need the
30:03 - getter center
30:04 - or the destructor created yes
30:09 - okay and uh here you have food dot h
30:13 - and again i don't need these things so
30:16 - here in the private section what we're
30:18 - going to do is we are going to have a
30:20 - position of the full
30:22 - right so that is mandatory you you
30:24 - cannot have any object without a
30:25 - position right
30:26 - so for the position you again need to
30:28 - include windows
30:30 - windows.h and uh
30:33 - it's going to be called pause and uh you
30:36 - do need a velocity well you don't need
30:38 - anything else you don't need velocity
30:40 - you don't need any
30:41 - uh direction for that foot it's just
30:43 - going to be a point
30:45 - where if you go over to that point and
30:47 - then eat that fool you're just going to
30:49 - generate another form
30:50 - so basically you don't need anything
30:52 - else and uh
30:54 - in the public section the public section
30:57 - we have a constructor basically
30:59 - well you don't have to pass anything to
31:01 - the constructor it's basically going to
31:03 - initialize this position with some
31:05 - random value but
31:06 - if you see this game always this would
31:09 - start at this possible position
31:11 - if you want something like that then you
31:14 - need to define
31:16 - a initial starting position so as we did
31:19 - for our snakes you need to do something
31:21 - like this but we are going to
31:23 - go with random initialization right from
31:25 - beginning itself
31:26 - so again for random function to work you
31:29 - need to
31:30 - include cstdlib and
31:34 - we are going to define a function called
31:36 - gen
31:37 - this is basically going to generate
31:39 - output and this is going to be void
31:42 - and we also need a function to return a
31:46 - supposition so it's going to be get
31:49 - so this will return our position so
31:51 - let's define these functions
31:53 - uh inside this what we're going to do is
31:56 - just generate food it first time it's
31:59 - just going to
32:00 - generate the food once you create it and
32:03 - uh for generating the food
32:05 - sorry snake sorry food
32:10 - gentle and what this is going to do is
32:14 - it's just going to generate two
32:16 - different
32:17 - random numbers in the in some range so
32:19 - if you remember the
32:21 - formula for generating a random numbers
32:23 - in the ring that is u2l
32:25 - it was basically rand mod
32:29 - u minus l plus 1
32:32 - u minus l plus 1 plus l
32:36 - so this was the formula for generating a
32:38 - random number in a range
32:39 - so here our upper limit is going to be
32:42 - for the x axis is going to be width
32:44 - and the lower limit is zero right so uh
32:48 - here you just need to say rand
32:51 - mod and then u minus l plus one plus l
32:54 - so
32:55 - for us the u is basically with
32:59 - minus the lower limit now lower limit if
33:01 - you keep zero then the food
33:03 - will have a chance of getting generated
33:06 - on the walls of support
33:08 - so you don't want that to happen so it's
33:09 - going to be one and plus one so these
33:12 - two cancel out so you just need to say
33:13 - random
33:14 - width and then plus l which is one
33:19 - again for uh the y
33:22 - axis the upper limit is going to be
33:25 - height and the lower limit is again
33:27 - going to be one
33:28 - so this will generate a random position
33:31 - for our food
33:32 - which will be on the board
33:36 - and for getting position it's very
33:38 - simple you just need to say
33:40 - for the word
33:44 - get position so we did not define that
33:48 - well we did quad get position and here
33:50 - you
33:51 - need to say return pause so this will
33:54 - return the
33:54 - position of the current flow and
33:58 - that's it for food so you need to
34:00 - include that also over here
34:02 - um now main file so here we need to say
34:06 - hash include food dot h
34:09 - and here we don't need cst database
34:12 - again because
34:13 - we have defined it inside this food dot
34:16 - it so that gets included automatically
34:19 - and here we need to create a food object
34:23 - so
34:24 - below the snake let's create a food so
34:27 - it's going to be good
34:28 - and as a constructor doesn't need
34:31 - anything so you can just put it like
34:33 - this
34:34 - and here we need to
34:37 - check whether the snake has eaten the
34:39 - food or not so
34:40 - for that what you can do is you can have
34:43 - a
34:43 - function inside the snake which will
34:46 - check whether
34:47 - its coordinates have matched the
34:49 - coordinates of food or not
34:50 - so what you can do is you can inside the
34:53 - snake dot h you can define another
34:55 - function
34:56 - called boolean let's say
35:00 - eaton this will basically say whether
35:03 - the food has been eaten by the snake or
35:05 - not so you can just pass in some
35:06 - coordinates
35:07 - inside this that is the coordinates of
35:09 - the food so coordinate food
35:12 - it's a food pass and we'll define it
35:16 - inside snake dot cpp it's basically
35:19 - um snake
35:22 - eaten and this will return true
35:27 - if the coordinates match so if i say uh
35:30 - if
35:31 - put password i did not capture it over
35:33 - here so it's
35:35 - called put pause and if
35:38 - put pause dot x is equal to pause dot x
35:42 - and uh put pause dot y
35:45 - is equal to positive y that is basically
35:48 - if
35:48 - the position of the head and position of
35:51 - the
35:52 - food are equal then it means that the
35:54 - food has been eaten by the snake so then
35:56 - you need to return
35:57 - to else you just return false so this
36:01 - means that
36:01 - uh if you eat the food it will return
36:03 - true and if it didn't eat
36:06 - return false and in main you can use
36:09 - that over here so if you can say snake
36:11 - dot eaten
36:13 - and you can get the foods equations of
36:15 - food dot
36:16 - um get pause and this will
36:20 - give you the position of the food which
36:22 - you can pass into the snake
36:24 - and if the snake has eaten then you need
36:27 - to generate another force so you can say
36:28 - full
36:29 - dot gen food and
36:32 - you also need to increase the length so
36:34 - you you can say snake dot length
36:36 - well length is a private variable so
36:37 - let's say snake dot grow and we will
36:40 - define a function
36:41 - to grow the snake so you can see void
36:45 - grow and we define it
36:48 - as a void
36:55 - bro which is landlessness
36:58 - and this should grow our snake and that
37:01 - should be it so now
37:02 - you have the logic for eating a food
37:05 - and then growing the snake well we are
37:07 - not going to see the snake grow but
37:10 - it is just going to grow in numbers we
37:12 - won't be seeing that visually
37:14 - we will see how to deal with showing
37:17 - that
37:18 - visually right and here we forgot to
37:21 - draw the food so here you need to
37:23 - put that else if our i is equal to food
37:28 - cos dot y and
37:31 - uh j is equal to
37:34 - food pause dot x well i did not capture
37:37 - that
37:38 - so quad foot
37:41 - cos equal to four dot
37:44 - get pass then
37:47 - for for the let's say the star
37:51 - right the star works well
37:54 - now if you run this
37:57 - um we have an error what does it say it
37:59 - says that
38:01 - width and height were not declared in
38:03 - the scope now that is because in
38:06 - food.hedge we did not define the width
38:09 - and height right we had defined it in
38:10 - the main.cpp
38:12 - so you need to copy these two lines here
38:14 - so ctrl
38:15 - c and put it inside food.h that is
38:18 - because we are using those two right
38:20 - we're not
38:20 - uh we did not define it in food dot x
38:23 - that is why it was give me an error
38:25 - and now if you run this you have another
38:28 - it says has no member y that is because
38:32 - this is
38:32 - a capital y and um
38:36 - here you have the snake and the food so
38:39 - here you can see the food so if i eat
38:41 - that food
38:42 - it's going to generate another food in
38:44 - some random position so you can see that
38:46 - generated over there
38:47 - and here we did not write the
38:51 - logic for collision so we'll take care
38:53 - of that afterwards
38:55 - well it's going to be in the same places
38:57 - that is because we did not
38:59 - see the random function so if you uh
39:01 - have seen the
39:02 - previous video where we made the
39:04 - tic-tac-toe game you know what is
39:05 - serious
39:06 - well to see the random function what we
39:09 - are going to do here is
39:11 - we are just going to say the main
39:13 - function so to see
39:14 - the random function what we are going to
39:16 - do is hash include
39:17 - c time and here in the main function we
39:22 - will see
39:22 - is time
39:27 - right so now when you run it you will
39:29 - have a snake
39:30 - and food and uh this food will be
39:33 - generated once you eat it so here
39:35 - i ate that food now you can see that
39:37 - another one has been generated and then
39:39 - another one has been generated
39:41 - so we did not write the collision logic
39:43 - so if you go through the wall you will
39:45 - come
39:45 - you won't come back and that will take
39:48 - care now so
39:49 - to do that what we are going to do is we
39:51 - are going to write another function
39:54 - so its going to save cool collided
39:58 - and it's property of the snake so snake
40:00 - collided
40:02 - and then this is going to just return to
40:05 - our fall so this is going to return true
40:07 - if our position of x is
40:11 - less than let's say one that is because
40:14 - at the zeroth position you have the wall
40:16 - right so if it is
40:17 - less than one you mean it means that you
40:20 - cross
40:21 - the position of one and you cross the
40:24 - wall
40:25 - and uh in case your x is really greater
40:28 - than height
40:29 - then it means the width then it means
40:31 - that
40:32 - you have crossed the other wall also and
40:34 - similarly for the y you need to say
40:37 - it is less than one or position dot y
40:40 - is greater than the height then you need
40:43 - to return
40:44 - true it means that you have collided
40:46 - with the wall or else you return
40:48 - false all here so
40:51 - uh we forgot to define the prototype so
40:54 - here it is going to be
40:56 - bool collided
41:00 - and in main function instead of true we
41:03 - are just going to maintain a
41:04 - variable called game over
41:07 - which will track whether the game is
41:09 - over or not so
41:11 - in the beginning game over is false and
41:14 - while true you will change it to while
41:17 - game over
41:18 - or while not game over you need to run
41:21 - all these things
41:22 - and if the snake collided so if the
41:24 - snare
41:26 - collided then you will just say game
41:29 - over equal to true and this will stop
41:32 - executing the loop
41:33 - right now if you run this
41:37 - we got an error does it say again the
41:40 - width and height are not defined in
41:41 - snake dot h
41:43 - so we need to copy those two things
41:46 - from here and put it over here
41:52 - right now if you run this you don't have
41:55 - any errors hopefully
41:56 - and here you can see that the snake
41:58 - moves and if i
41:59 - go and hit the wall it ended the process
42:03 - so
42:04 - now the game ends successfully once i
42:06 - hit the wall
42:07 - and uh we have taken care of the food
42:09 - also so
42:10 - i think that the video has become long
42:12 - enough it has been an hour
42:14 - so the next video will see how to
42:17 - increase the snake's length and show it
42:19 - visually well we are increasing the
42:21 - snakes length over here
42:22 - but we are not showing the increase in
42:25 - its body right so if we are just moving
42:27 - the head and we are eating
42:28 - and we made quite a progress right so
42:30 - let's see what we have made
42:32 - we have made this board and then we
42:35 - have updated the port without causing
42:37 - any flickering and that's a great
42:39 - improvement
42:40 - and we also animated this character
42:42 - which can eat the food and we also
42:44 - written the
42:45 - logic for the food to appear at
42:46 - different random locations right
42:48 - in this video we will complete this game
42:50 - by adding the body for the snake
42:53 - well you know that the snake is growing
42:56 - by letting the food but it's just
42:57 - growing in numbers right we're not
42:59 - showing it visually
43:00 - so we will be showing that and also
43:02 - before that let's
43:04 - just fix some logical errors
43:07 - so let's see what are those errors so
43:10 - let's just drive
43:11 - one of the other pops up but i'm telling
43:13 - you i'm lucky but just to
43:14 - save the time and just ending this game
43:16 - here and let's first talk about the
43:19 - most obvious logical order so
43:22 - in the definition of food what we have
43:25 - said is
43:26 - once a food is created i want the random
43:29 - location on the board
43:31 - which will be the location where all
43:34 - food is placed right that's what we said
43:36 - when we
43:37 - are calling this generate food function
43:39 - inside the constructor
43:40 - right but what is happening here if you
43:42 - run this program again and again so
43:44 - let's
43:44 - run this once again so here you will be
43:46 - seeing that the first code is over here
43:49 - and if i close that again you will be
43:51 - seeing that the second time also
43:53 - the food is over there but the
43:56 - consequent foods are getting randomized
43:59 - so if you say the second food is
44:00 - somewhere over there
44:01 - and if we start this game again and try
44:04 - to eat that
44:05 - you see that the second food has been
44:07 - generated at some random location right
44:09 - the first one was somewhere over there
44:11 - so to fix this well you can go with
44:14 - it it's not actually an error it is
44:17 - actually not what we wanted right
44:19 - it's basically what i did not want but
44:21 - if you wanted that the first
44:23 - should be generated like that you can go
44:26 - ahead with this and
44:27 - skip this portion but since we
44:30 - wanted to generate the food at a random
44:34 - position right from the beginning
44:36 - what we are doing wrong is here first we
44:38 - are generating the food object
44:40 - and then we are shading the random
44:42 - function right
44:43 - so if we were introduced to the random
44:45 - function and the seeding function
44:48 - or back in the detector video right so
44:50 - if you remember the seeding function is
44:52 - a kind of
44:53 - controller to the random number
44:55 - generator well the random number
44:57 - generator
44:57 - will generate some random number it will
44:59 - do some calculation give you a number
45:02 - when the program is loaded onto the
45:04 - memory right
45:05 - so if you want a different random number
45:07 - what you need to do is you need to close
45:09 - everything and then open it again
45:11 - but we don't want to do that right we
45:13 - want random numbers right when we are in
45:15 - the memory so what we do is we change
45:17 - the seed
45:18 - so seed is like a starting point of the
45:20 - algorithm
45:21 - and what we do is we seed it with some
45:23 - number every time we want to generate a
45:25 - new number
45:26 - so what is the thing which is changing
45:28 - constantly well
45:29 - time is changing constantly so what we
45:31 - do is we just
45:32 - seed it with the time so this one will
45:37 - take the time it will take the time as
45:39 - an integer
45:40 - and then make the random number
45:42 - generated start from that particular
45:44 - term
45:45 - that is why you get different numbers
45:47 - after feeding
45:48 - it but what is happening here is we are
45:50 - calling the random function
45:52 - before seeding it right for the first
45:54 - time from the next time onwards one
45:56 - the food is heated the logic is over
45:58 - here right which is after the seeding
46:00 - function
46:01 - that is why you are getting randomized
46:02 - locations for the consequent foods
46:04 - but not for the first one so to fix that
46:07 - it is very simple what you can do is
46:09 - you can get rid of the constructor well
46:11 - i don't know why i define this
46:12 - constructive basically when we define a
46:15 - constructor
46:16 - what we actually see is we need the
46:18 - constructor to do something
46:20 - which the default constructor with a
46:22 - compiler will construct for this class
46:25 - can't do it but what the default
46:27 - constructor does it will basically
46:29 - create the memory required for this
46:32 - particular class right for loading this
46:35 - class onto the memory you need
46:37 - some amount of memory which is
46:38 - calculated by the constructor
46:40 - well we wanted the constructor to do
46:43 - something extra that is called this
46:45 - function on the creation
46:46 - and it did not work out as we expected
46:48 - that is why we can just get rid of the
46:50 - constructor and then call the function
46:52 - manually
46:53 - well if you want to keep the working of
46:57 - the program
46:58 - just like before then you can skip this
47:00 - step as i told you it's just preference
47:02 - right i prefer that
47:04 - would be generated at a random location
47:07 - right from the starting
47:09 - so you can go there and after seeding
47:12 - the function
47:13 - what we can do is we can now call the
47:15 - generate food method
47:16 - so this is the one line which we wanted
47:19 - to skip
47:20 - by using the constructor which was
47:22 - actually worthless right
47:24 - so creating a constructor was more good
47:27 - and at least for this kind of a game
47:30 - where we want the first element to be
47:32 - randomized so
47:33 - it basically get rid of the constructor
47:36 - and that will solve the issue now if you
47:37 - run this you will be getting
47:39 - the foods at different locations so one
47:42 - has been generated over here
47:44 - close that open that again so the other
47:46 - one has been generated but this is the
47:48 - problem actually which i wanted to show
47:51 - you in the beginning right
47:52 - well uh when i was eating the food i
47:54 - actually knew that at some point this
47:56 - would happen that is we won't see any
47:58 - food on the pool
47:59 - that is a major logical issue with this
48:03 - program which we made in the previous
48:04 - video and we will be fixing that right
48:06 - now
48:07 - so here if you see there is no food on
48:08 - the board but actually it has been
48:10 - generated we will see why that's
48:11 - happening
48:12 - okay so close that and now we fix the
48:15 - most obvious now let's go on to the
48:17 - issue which we just saw
48:18 - that the food is not yet getting
48:20 - generated well
48:22 - what we're doing in the generate food
48:24 - method
48:25 - here we are saying that we want some
48:28 - random number
48:29 - in the range of one to with minus one
48:31 - why uh we told that uh
48:33 - one the first character is basically
48:35 - reserved for the first wall
48:37 - and the last character is reserved for
48:39 - the last one so basically you want
48:41 - numbers from one to with minus one
48:44 - leaving those two characters
48:45 - it sounds reasonable right but if you
48:47 - forgot the math it is going to tell you
48:49 - a totally different story so let's see
48:51 - what the math is let me pull up my
48:53 - paint over here and now let's first talk
48:56 - about one of these
48:57 - width or height both of them are going
48:59 - to go with the same logic so
49:01 - we can talk about only one of them right
49:03 - so here
49:04 - let's say i draw the height so what is
49:06 - the height height was something like 25
49:09 - right
49:09 - so the whole thing is actually 25
49:12 - characters right
49:14 - and what we're saying we are saying that
49:15 - the first character
49:17 - and the last character are designed
49:20 - for the calls so from a computer's
49:23 - perspective what are these numbers going
49:25 - to be
49:25 - the computer starts complete from zero
49:28 - right so 25 characters
49:30 - is basically 0 to 24 for the computer
49:33 - and what we are saying is we are saying
49:36 - that
49:36 - this 0 and this 24 is not required in
49:39 - our range
49:40 - so basically we want numbers from 1 to
49:43 - 23
49:44 - we don't want 0 we don't want the last
49:46 - character which is 24
49:48 - right so this range becomes 1 to
49:51 - 23 well to get a number in the state
49:54 - what you can do is plug it into the
49:55 - formula so
49:56 - what is the formula for random number
49:58 - generation it is
50:00 - if you want a number from sorry n
50:03 - that is a lower limit to u which is the
50:06 - upper limit
50:07 - and lower limit is included and upper
50:10 - limit
50:10 - is not included right so you will be
50:12 - getting some
50:14 - numbers till u minus 1 so if you want
50:17 - numbers in this range that is l
50:19 - inclusive and u not inclusive you won't
50:21 - get the u
50:22 - then the formula is you need to plug in
50:25 - rand mod
50:27 - it was u minus
50:31 - l plus 1
50:34 - plus l right so this is a formula you
50:37 - can plug it
50:38 - into this formula you can even see
50:40 - logically
50:42 - basically both of them are going to give
50:43 - you the same result and
50:45 - we'll just use the formula for
50:47 - simplicity purposes over here what we
50:49 - can do is just plug it into this formula
50:51 - so what it becomes let me just write it
50:54 - as r
50:54 - this is basically the random function r
50:56 - 1
50:57 - and u is over here 24 right because we
51:00 - want 23 to be included
51:02 - and in this formula this particular u is
51:05 - not included
51:06 - in this random number generation
51:09 - so we'll just increase this by one
51:11 - number that is 24
51:12 - and that will become 24 minus l plus one
51:16 - that is one plus one the lower limit is
51:18 - one which is included that's why we
51:20 - don't have to do anything to it
51:22 - and a plus one so what this becomes is
51:25 - i mod 22
51:28 - plus one and what is 22 it is basically
51:31 - 25
51:31 - minus 3 right so this is the
51:35 - number which we wanted to generate
51:38 - actually
51:38 - but what we did is we basically went by
51:41 - our intuition
51:42 - and messed up the logic right so to
51:46 - correct this what we need to do is using
51:49 - this particular
51:50 - formula this becomes minus three and
51:52 - this will become plus three and the same
51:54 - will
51:54 - go with height also we talked about
51:56 - height the same thing will go with the
51:58 - width also
51:59 - so if you draw a similar kind of analogy
52:02 - you will be seeing that
52:03 - the same logic will work for the width
52:05 - also right
52:06 - so let me just clear that and here it is
52:09 - minus three and
52:10 - this is plus one now this will
52:14 - fix the disappearance of the foot and
52:17 - there is another
52:19 - major flaw in our looping right so
52:22 - where are we looking we are looking over
52:24 - here with the board where we are
52:26 - displaying
52:26 - there is a major flaw in that and
52:28 - believe me if you have been able to
52:30 - identify that particular error you are
52:32 - going to be a great programmer
52:34 - right so let's see what the error is
52:37 - it is basically lying within the inner
52:40 - loop
52:40 - what we are doing well for the outer
52:43 - loop it is pretty straightforward we are
52:44 - going
52:47 - which is basically how the computer sees
52:49 - numbers from zero
52:50 - to n minus one and for the fifth we are
52:54 - doing something different right
52:55 - so what are we doing here we are saying
52:57 - that
52:58 - we are going from zero to with minus two
53:01 - and we had a reason that
53:03 - these two characters which are basically
53:05 - the walls are constant for all the rows
53:07 - so instead of including them
53:09 - inside the loop why not just explode
53:11 - them and run the loop only for the width
53:13 - minus two number of
53:15 - characters so that's what we did and
53:17 - that sounded reasonable
53:19 - but here is the problem what happens is
53:21 - let's say
53:22 - my uh generated x-axis which is
53:26 - basically the width
53:28 - is going to be 28 right sorry what is
53:32 - the maximum range is 50 right and what
53:34 - you can do
53:35 - if this is 50 the maximum number you can
53:38 - generate
53:38 - leaving 0 and 49
53:41 - is 48 right so this is the maximum
53:45 - number you can generate and let's say
53:46 - that that is our x coordinate that is
53:49 - the value of your width
53:51 - now what happens here well if you see
53:54 - here
53:54 - j is running from zero to
53:58 - which minus two what is with minus two
54:00 - it is basically forty eight and it's not
54:02 - reaching forty it's just
54:03 - going till forty eight which means going
54:05 - till forty seven only
54:07 - right now if you see this you
54:10 - don't have a way to actually display
54:13 - this coordinate in this loop at all
54:15 - because it is out of
54:16 - bounds of this particular loop this loop
54:18 - will run only till
54:20 - 47 and you are asking it to show
54:23 - something which is on the 48th
54:24 - coordinate which is not possible by this
54:26 - loop right
54:27 - so how do i fix this
54:30 - well we can draw an analogy over here so
54:34 - if you draw the quantity which is js
54:36 - perspective
54:39 - w is basically the original width of
54:41 - output so say this
54:43 - when w is 0 j is not undefined
54:46 - why is that well let me just create this
54:49 - thing so that we can
54:50 - see this is the leftmost corner of our
54:55 - board
54:56 - and this is 25 right 25 characters or 25
54:59 - pixels
55:00 - and here what we're doing is we are
55:02 - saying this is our character
55:04 - the width character and we are
55:07 - saying that the inner loop should run
55:10 - from 0 to 47
55:12 - and we are including another character
55:14 - and that total makes it
55:16 - 50 it's 0 to 47 is 48 characters plus 1
55:19 - plus 150
55:20 - and this is the other one now what is
55:23 - happening is
55:24 - let's say my coordinate is 0 right
55:28 - when the x coordinate is 0 it basically
55:31 - means
55:31 - this particular position where the wall
55:33 - is there right but what is happening
55:35 - here
55:36 - our zero is starting from one step to
55:38 - the right because of
55:39 - this particular looping and this
55:41 - particular character before the loop so
55:43 - what is happening
55:44 - our loop which is starting is starting
55:46 - one step towards the right
55:48 - and that is why we are missing out our
55:51 - coordinates so what happens is if j is
55:55 - sorry if w which is our original x axis
55:58 - is zero j is not returned defined it is
56:01 - not there at all
56:02 - and when does j equal to zero start when
56:04 - with equal to one
56:06 - and so on this will continue when 50
56:08 - equal to 48
56:09 - j equal to 47 as we just saw and with
56:12 - just 49
56:14 - it is not present right so
56:17 - this is the reason why we were not
56:19 - getting anything on the board not
56:21 - this is not the complete reason the
56:22 - actual reason was because we were
56:25 - messing up the formula the random number
56:27 - generation i feel
56:42 - to fix this what we can do is by
56:44 - comparing the coordinates we need to add
56:46 - one to this right so if 0 we don't
56:49 - care about the zero or the 49th
56:52 - coordinate right we don't want these two
56:54 - things
56:54 - because we're not going to generate
56:56 - those two they
57:03 - you need to compare only these things
57:06 - right
57:06 - you need to compare only these things
57:09 - and to compare that what we can do is we
57:12 - can add
57:13 - one to the j before comparing it with
57:15 - the x coordinate
57:16 - so to fix this what we are going to do
57:18 - here is when we need to
57:20 - canvas let me just leave this and
57:24 - here uh in
57:28 - place of k it's going to be j plus 1
57:31 - and that should hopefully fix all the
57:33 - logical errors which you'll need so save
57:35 - that run that again
57:37 - and here we have our first fruit if you
57:39 - eat that the second food is getting
57:41 - generated
57:42 - and hopefully it should not stop
57:44 - generating it should be generating
57:46 - till we play this game and it should
57:48 - stay within the range of board and it
57:49 - should be visible to the player
57:51 - right so when if you say this is visible
57:53 - and trust me it's going to work
57:55 - and there are no kind of mistakes in
57:58 - this program
57:59 - and this is completely fixed now well
58:01 - we'll fix one more thing that is if i
58:03 - go to this particular wall i will crash
58:05 - before actually crashing so if you see
58:07 - this i
58:07 - i have not yet crashed the one but it's
58:09 - in that uh i have crashed this one
58:11 - that means i need to go inside the one
58:13 - so to fix that i mean
58:15 - it's the coordinate issue and also a
58:17 - placement of movement so let's first fix
58:19 - the coordinate if you go
58:31 - greater than with -1 so going by the
58:33 - same logic
58:34 - with minus 1 is going to be 49 because
58:37 - with this 15
58:39 - so with minus 1 is going to be 49 so
58:41 - what you want you want
58:43 - something greater than 48 not 49
58:46 - so it's going to be with -2 and that
58:48 - should fix the
58:49 - issue and um for the other one which i
58:52 - just showed you there for the
58:54 - rightmost one what is happening is we
58:56 - are first drawing the board
58:58 - we are moving we are actually changing
59:00 - the direction of this tape
59:01 - we are moving the snake
59:31 - getting updated before the speed so that
59:34 - is why you are not seeing
59:35 - whether the snake has been collided or
59:36 - not so you can just move this thing to
59:38 - the end of
59:39 - this thing to start basically the same
59:42 - thing right before the
59:43 - next loop the starting point is to the
59:45 - end of this one so
59:47 - they mean the same thing so just move
59:49 - this to the end of that
59:51 - now this should fix that issue that
59:54 - you're not seeing the snake colliding
59:57 - and now you should see that the snake
59:59 - actually collides with the wall
60:01 - before playing this game right so it
60:03 - went inside the wall and the game needed
60:05 - and now everything is pretty much fixed
60:07 - and now let's
60:08 - proceed to making this game real sneaky
60:12 - what is that we need to include the
60:14 - snake's body we are just growing the
60:16 - snake which is basically just increasing
60:18 - the length right so
60:19 - here you can see it's just increasing in
60:21 - length so how can we store this
60:23 - neat volume well what is your body
60:27 - it's just a collection of body parts and
60:29 - that collection must have triggered
60:30 - something inside you
60:32 - well they are going to use something
60:34 - like an array
60:35 - which is a collection a vector which is
60:38 - also a collection which was
60:40 - seen in the pointless video and the
60:42 - other thing is
60:43 - list right so these are three options
60:46 - available
60:47 - to us as of now and we'll use one of
60:50 - this
60:50 - now let's unless what we need to use
60:52 - over here so i think
60:54 - when
60:59 - and how do we know the fixed size of
61:01 - this name
61:02 - well if a player like me is going to
61:04 - play he's probably going to get defeated
61:07 - in let's say 5 or ten points right
61:10 - because i have a very bad player
61:12 - and maybe a pro player comes in and
61:15 - he can make a score as big as 1000 or 10
61:19 - 000 right well you cannot restrict the
61:21 - players or you cannot estimate the
61:23 - player's capacity by just
61:25 - uh keeping a fixed number what if the
61:27 - player is better than what you thought
61:29 - he should be
61:30 - right so here what you can do is well
61:33 - in this particular board you can
61:34 - actually fix it to some big number so
61:36 - let's say
61:43 - see that it is 50 and height is 25 right
61:46 - so the maximum number of characters
61:47 - possible is this thing 50 times 25 out
61:50 - of which you're
61:51 - using the borders so that is the only
61:53 - number of characters so if you
61:55 - make the snake as big as that after that
61:58 - there is no possibility of waiting
61:59 - because
62:00 - the snake has to collide right because
62:02 - the maximum free space has been
62:19 - limitations right so that is why you
62:21 - have uh such uh
62:23 - teleportable walls and all to take care
62:25 - of this issue but
62:26 - uh for this particular game uh we won't
62:28 - be talking about the teleportable ones
62:30 - but in the end i'll show you how to
62:32 - create teleportable walls if you want to
62:34 - and
62:35 - here basically the array is a very bad
62:38 - option because you are restricting the
62:40 - player's capacity
62:41 - and if you talk about vectors well it is
62:45 - dynamic but again it is going to take up
62:48 - some more
62:49 - extra space by defining so if you
62:51 - remember how vector work is first define
62:53 - some
62:53 - amount of space and once it gets filled
62:56 - up it will define a bigger space
62:58 - and then copy all the elements to this
63:00 - and get rid of this particular space
63:02 - so this one could be used this could
63:05 - work
63:06 - but again there is some extra space
63:08 - which is getting wasted
63:09 - so basically the best option here is
63:12 - going to be list so
63:13 - if you remember from our video on the
63:16 - pointers where we first discussed when
63:18 - to use vectors versus 20 useless
63:21 - you saw that list can be used whenever
63:24 - you have
63:25 - a data structure where you won't be
63:28 - accessing the middle elements more
63:29 - frequently you are just going to access
63:31 - the first and last image
63:32 - that is the case here also right we are
63:34 - not going to access the middle elements
63:37 - which is basically
63:37 - these body parts we are not going to
63:39 - access it we are just only concerned
63:41 - about the head which is on the front of
63:42 - the
63:43 - data structure and then right so we will
63:45 - talk about how to
63:47 - uh actually manage the head and tie with
63:49 - the short one but for now
63:51 - the head is at the beginning and the
63:53 - tail is at the end and they're only
63:54 - bothered about these two things we're
63:56 - not causing a protective
64:11 - of being able to pick some random
64:13 - element from
64:14 - in between well in a vector we can do
64:17 - that very simply because
64:18 - it is a continuous collection but in a
64:20 - list you if you remember it was
64:22 - something like this right your pointer
64:24 - you have pointed to something and then
64:25 - you have another pointer which points to
64:27 - this
64:28 - and so on if you want to pick this thing
64:31 - you need to power all this way but in a
64:34 - vector or in an array you can just pick
64:36 - that up using the index
64:37 - it is basically the starting position
64:39 - plus the number of steps you need to
64:40 - determine
64:41 - so in this case a list would be
64:45 - the best implement but to keep this
64:47 - tutorial simple
64:49 - i'm using vectors for this particular
64:51 - demonstration
64:52 - so i would totally encourage you to go
64:54 - with
64:55 - list not with vectors as we are going to
64:58 - see in this video
64:59 - and just showing with vectors because
65:01 - it's easier to relate than this right
65:03 - but once you're comfortable by
65:05 - implementing this
65:07 - particular project in a vector please go
65:09 - on to try it with a list
65:11 - list is the most preferred option for
65:13 - such games where
65:14 - you don't have to control the capacity
65:16 - of the user
65:18 - vector is not going to control but
65:19 - basically the extra space
65:28 - [Music]
65:31 - and how do we define the body well it's
65:34 - really simple so let's say i have two
65:37 - body parts
65:37 - basically a tail and the head i have
65:40 - this head over here
65:41 - and the snake has to move to the right
65:43 - so what can i do
65:44 - well what if i just remove this tail
65:48 - and then put another head over here and
65:50 - make this as a tail so for the let's
65:53 - just say this
65:53 - x mark over here that dino city now if
65:56 - you see that
65:57 - the snake has pulled one step to the
65:59 - right right and if i do that again so i
66:01 - take out this tail i include the head
66:04 - and i'm doing this head as the tail
66:07 - let's take a smooth again
66:08 - and let's say we are eating the food at
66:10 - some location so let's start with
66:12 - another snake so this is the snake we
66:14 - have
66:15 - and the food it is going to eat this
66:17 - particular food
66:18 - so it has eaten in the next iteration
66:20 - what i will do is
66:22 - i won't take off this table i will keep
66:24 - the stain
66:25 - and this is what happened right so i
66:29 - add the head i want to remove
66:36 - and that basically looks like the snake
66:38 - has grown right
66:39 - from two body parts it has grown into
66:41 - three body parts and that's what we want
66:43 - right
66:44 - so this is the logic we are going to
66:46 - implement and we are going to do that
66:48 - in vectors again list is the most
66:50 - preferred option
66:51 - please try it with the list not with the
66:53 - vector after you're comfortable
66:54 - basically
66:55 - so let's let's go to our sneak.h and
66:58 - quickly create a body definition
67:00 - so we need vector obviously so hash will
67:02 - close vector
67:03 - which is going to do it with the list
67:05 - you know right as include list
67:07 - and well since vector is a standard
67:10 - scope element you need to specify the
67:12 - scope so using name space
67:14 - std like we did in the main function and
67:17 - here you can just say vector
67:21 - body sorry vector and what is the data
67:25 - depth it's going to be coordinates
67:26 - basically so chord and then body
67:29 - and this defines the body of the victim
67:32 - now they have two changes we need to
67:33 - make what is that
67:34 - first of all we need to include the head
67:36 - to the body
67:38 - once we create a new snake so in this
67:41 - snake point
67:42 - constructed what we're going to do we're
67:45 - just going to say
67:46 - body dot push back which is basically
67:49 - pushing back the elements inside a
67:50 - vector and what we need to push back we
67:52 - need to push back the position which is
67:54 - basically the
67:55 - position of the head of the snake right
67:57 - we can just body not push back that
67:59 - particular position
68:00 - and while moving the snake following
68:03 - that logic which we just discussed what
68:04 - we're going to do is
68:05 - first pushing the head of the snake to
68:08 - the end of the list
68:09 - or end of the vector so how we do that
68:12 - we do not push back the new position
68:15 - which has been updated after all these
68:16 - things
68:17 - a new position and now what we'll do is
68:21 - if the body size
68:24 - is greater than the length of the snake
68:26 - what is the length of the snake that is
68:28 - the
68:28 - thing we are growing when the snake is
68:31 - actually eating the food right so that
68:32 - is the thing we are manipulating over
68:34 - here
68:34 - so this length integer if the body is
68:38 - size which basically the number of
68:40 - elements in the vector
68:41 - is greater than the length then what you
68:43 - do you just
68:44 - take out the element from the body so
68:47 - how do you do that you just say body dot
68:50 - and if i actually confused with what
68:53 - function you need to use
68:54 - the best thing i would suggest is not
68:56 - just eliminate the function but just use
68:58 - the resources so
68:59 - uh you can just go to your web and then
69:02 - search something like ctp vectors
69:06 - documentation and you'll
69:09 - get a lot of resources and c plus plus
69:12 - dot com
69:13 - is the best one among them well i think
69:16 - that
69:16 - this is the best one where you can find
69:18 - short descriptions of all the functions
69:21 - and here you should be seeing some
69:23 - function like pop
69:24 - back what does it say it says that
69:27 - removes the last element in the vector
69:29 - effectively reducing the container size
69:31 - by one but we actually don't
69:33 - want this well why is that
69:36 - if you see but technically the tail
69:39 - should be at the end of the body
69:41 - but if you look at the structure what
69:44 - we're doing is
69:44 - we're actually pushing back the head one
69:47 - step to the
69:48 - right right so this is what two step
69:50 - does so basically our head is over here
69:52 - and your tail is over here
69:54 - and what we need to do we need to remove
69:55 - the first element so how can we remove
69:57 - that
69:58 - you can just check out the functions
70:00 - over here but
70:01 - to save the time i'm just going to show
70:04 - you the function which is basically
70:06 - clear or areas right so you will find
70:08 - this one
70:09 - this is basically going to remove from
70:12 - the vector
70:13 - either a single element or a range of
70:15 - elements so here we just need to
70:17 - remove a single element but the position
70:20 - is not an integer
70:21 - it's a pointer so here you can see it
70:23 - says the definitions
70:24 - iterator position and iterate to first
70:26 - unit
70:27 - well you can go with any of this
70:31 - the only difference is that it has a
70:32 - quantity but you don't have to know at
70:35 - this stage right
70:36 - you can you can just go and search what
70:39 - these two things are
70:40 - basically the same thing and how they
70:43 - use that
70:44 - you can see an example over here it says
70:47 - dot is
70:48 - my vector dot begin plus five so plus y
70:50 - is basically
70:52 - going five steps away from the first
70:54 - element which is basically the sixth
70:56 - element
70:57 - and that's uh how you use this areas
71:00 - function has also
71:02 - shown an example to delete a range well
71:05 - we are not quite interested in the
71:06 - regime we just want to erase a single
71:08 - element which is going to be our first
71:10 - element because our first element is the
71:12 - tail
71:13 - and what we can do we can just say my
71:15 - vector and begin plus 0
71:17 - that is the first implement or we can
71:20 - just omit the zero and just say my
71:21 - vector
71:22 - that is going to erase the first angle
71:24 - so let's implement that what we're going
71:27 - to say
71:27 - i'm going to say body dot it is and what
71:30 - we're
71:31 - going to do is we're going to erase the
71:32 - first element which we can get from body
71:34 - dots again this is the pointer for the
71:36 - first
71:37 - item first position right so this
71:40 - will basically erase the first element
71:43 - from our list
71:44 - and before proceeding let's first see
71:47 - whether this is working or not
71:49 - and we need to create another function
71:53 - let us keep this function alone then
71:55 - create another function just in case
71:57 - something goes wrong
71:58 - so vector and it is going to be
72:01 - coordinated
72:02 - you need a coordinate vector to be
72:03 - written well basically you are going to
72:05 - return this next body
72:06 - so snake and then let's say get body
72:11 - and inside this we can say return body
72:16 - and in the snake dot h
72:20 - you can just create that function
72:22 - definition which is basically the
72:24 - vector sorry
72:27 - what does that get body right so
72:31 - now we have different snakes definition
72:33 - now we'll just update the board
72:35 - and what we need we first need a vector
72:37 - to capture the
72:39 - snake's body so vector quant
72:42 - let's say snake body
72:45 - equal to snake dot get body
72:50 - and inside this what we're going to do
72:53 - we'll
72:53 - just remove this else and we'll place
72:56 - this
72:56 - afterwards what we're going to do is
72:58 - inside the edge we are first going to
73:01 - loop through snake's body and see
73:03 - whether any coordinate matches or not
73:05 - so uh what we can do is we can just say
73:08 - this
73:08 - body part which will stay
73:12 - false in the beginning right we'll
73:13 - change that in the loop and what you can
73:15 - say is
73:15 - for in
73:26 - and k plus plus what we are going to do
73:28 - here is inside this loop
73:30 - we will say if i coordinate which is
73:34 - basically going to control the y
73:35 - coordinate
73:36 - is equal to the snake body of the kth
73:40 - index
73:41 - dot x sorry dot y
73:44 - and j plus one well remember that's the
73:49 - logic we were missing up
73:50 - equal to snake body dot solution
73:54 - body of that particular index dot
73:57 - x if these things match up
74:01 - then what we need to do you need to
74:03 - display a body part so
74:04 - let's just go with the small o for now
74:06 - this is our body part
74:08 - and this body part becomes true equal to
74:11 - true
74:13 - and what else well we don't want to run
74:15 - this thing right because
74:17 - at an instant a particular body part can
74:20 - stay on there at a particular location
74:22 - so if that location is occupied
74:24 - it is pretty obvious that any other body
74:26 - part won't occupy the location
74:27 - so you can safely break out of this loop
74:29 - you can end this loop
74:31 - and in the end what you can say is if it
74:33 - is not body part
74:35 - if not body part then obviously it is
74:38 - going to be
74:39 - just an empty space
74:43 - and here another thing is here we are
74:45 - going to report it on size but remember
74:47 - body includes the head right so what we
74:50 - can do is we can just say body dot size
74:52 - -1
74:53 - which will basically leave at the last
74:55 - input and now
74:56 - this should work i mean let's try to
75:00 - implement this so f9 and here you can
75:03 - see that the snake has grown so the
75:05 - other fold is over here
75:06 - so well i ate that and the third food is
75:09 - over here
75:10 - well you can see that the snake is
75:11 - growing right so here
75:13 - you have four body parts of the snake
75:16 - and now if i eat that
75:18 - here now you have five right so now we
75:21 - have
75:21 - a working snake game right so now you
75:24 - have working snake game and this works
75:26 - pretty fine right so
75:27 - now the you can see that the animation
75:29 - also works pretty fine the body
75:31 - parts seem to follow the head and so on
75:34 - right
75:34 - so this concludes our game well
75:52 - i will just keep it global so that you
75:54 - can use it on the board function also
75:56 - so here you can just see in score
76:00 - which is going to be zero in the
76:02 - beginning and uh well you can just set
76:04 - this to zero
76:05 - in case you want to uh say play again
76:08 - something like that what you can do is
76:10 - instead of main you can just say
76:11 - game and this is going to avoid game
76:13 - because i'm not going to do that
76:15 - you can do that right so if if i want to
76:18 - play again
76:18 - you can ask a question do you want to
76:20 - play again or not
76:22 - something like that and if i press yes
76:24 - then you can call this function again
76:26 - and then you can set this thing as zero
76:28 - so
76:28 - equal to zero before the beginning of
76:30 - the new game and
76:32 - here what you can do is you can just say
76:34 - score
76:36 - plus plus very simple and if you want to
76:38 - give 10 points or something like that
76:40 - you can just do that score
76:42 - equal to square plus 10 or any short
76:44 - hands if you know scored plus equal to
76:46 - 10 or something like that
76:47 - you can do that over here and here
76:50 - before
76:50 - starting to print out the board what we
76:52 - can do is we can just say c
76:54 - out our score so score
77:00 - is our school current school and just
77:04 - add a couple of new lines so that looks
77:06 - neat and that should equal well
77:08 - now i have one redundant function over
77:10 - here that is this food
77:12 - sorry the snake pause which is actually
77:14 - getting the position of the head and we
77:16 - are also getting the position of the
77:17 - body
77:18 - right and we did not define the
77:19 - collision of the sleeve right
77:21 - so we'll do that those things first of
77:23 - all let's just see whether this thing
77:25 - works or not so now you have this
77:26 - particular snake
77:28 - and i hate that the school is 10 now i
77:30 - hate that school is 20
77:33 - i ate that school is 30 and so on so
77:35 - it's working pretty fine
77:37 - so you can close that and
77:40 - to take care of the collision where you
77:42 - might have figured it out by now
77:43 - what we need to do well what you need to
77:46 - do here is
77:47 - you need to say else
77:50 - and you need to check whether it
77:52 - collided or not
77:53 - how do i check that well you don't need
77:55 - an electron you can directly
78:04 - is less than the body dot size well it's
78:07 - inside this nature i don't have to call
78:09 - that again just
78:10 - length minus 1 because i don't want the
78:12 - head
78:13 - and it's going to be i plus plus right
78:16 - and what we need to check
78:18 - if our snake's head head is basically
78:21 - positive right
78:22 - so if cos dot x is equal to
78:26 - any of this new body will be the
78:27 - substrate body is just body
78:30 - body of i dot x
78:33 - and the y coordinate is also same
78:37 - positive y is equal to
78:38 - bodies i don't
78:41 - y if these two thing match up just say
78:44 - return true yes you collided
78:46 - if these two things don't satisfy the
78:48 - end just say written false
78:51 - so they should take care of the
78:52 - collision so let's just try that out
78:54 - f9 to build and combine this and here
78:57 - you have this
78:58 - snake and the food and let's first go
79:01 - for our first food we have grown
79:03 - and the score has also increased and the
79:05 - second fruit but it's going to take a
79:06 - while if i go like that
79:08 - it's just going one body particularly so
79:10 - what i can do is i'll just write up
79:11 - equivalent
79:12 - well how can i collect well i'm going
79:14 - left now right so if i just press
79:16 - right i'm just going to pull it with my
79:17 - neck so basically i collected and
79:20 - now you can see that the process has
79:22 - stopped basically all
79:23 - collision algorithm is working so
79:27 - that basically ends this game
79:30 - and if you want to make a teleportable
79:33 - wall it's
79:34 - really simple what you need to do is i
79:36 - i'm sure many of you must have figured
79:38 - it out right now
79:40 - well you just need to play with the
79:41 - coordinates so if here if you see
79:44 - in the snake moves me what you do is
79:47 - if you want to change the location of
79:49 - this wave you will just say
79:52 - here if this particular thing
79:56 - if position dot x is greater than
79:59 - the width minus 2
80:02 - then what you do you just say position
80:04 - dot x equal to zero
80:06 - so simple and again what you do if you
80:08 - say
80:09 - if position dot y or position dot x
80:13 - is less than one then what you do is
80:16 - just have position dot
80:18 - x equal to the width
80:21 - minus three sorry about that it for
80:23 - random function we need to use with
80:25 - minus three because
80:26 - uh for generating the random numbers in
80:29 - that range
80:30 - it's basically with minus two and this
80:32 - will make the side walls teleportable so
80:34 - if you just save that
80:36 - and now if you run this you should be
80:38 - going through the sidewall and coming
80:40 - from the other one
80:42 - and now if i go through my side wall i
80:45 - should be appearing from the other one
80:46 - so you can see that
80:47 - it has been kind of teleportation now if
80:50 - i eat that our tray will also follow
80:52 - our steps right so if it goes from there
80:55 - you appear from there
80:56 - right so it works good that is how you
80:59 - make data portable walls
81:00 - and uh once you get to know about file
81:03 - handling basically how to
81:05 - write files what you can do is you can
81:07 - even have a high score option
81:08 - so you can write down a particular high
81:11 - score on the
81:12 - file so let's say i open this game right
81:14 - now and i scored about 10 points and you
81:17 - scored about thousand points
81:18 - that's pretty reasonable i'm not a very
81:20 - good player but yeah
81:22 - so uh you scored a thousand points and
81:24 - that is a high score right
81:25 - so here if you run this program again
81:27 - that high school gets lost
81:29 - so instead of just writing it on the
81:31 - memory for that particular
81:33 - kind of run what you can do is you can
81:36 - have a file where you can write down all
81:38 - your high scores
81:39 - and then whenever you load this game you
81:41 - don't get along with the file
81:43 - so inside that file you have all the
81:45 - high school lists and if you want you
81:46 - can just
81:47 - have names also so some games provide
81:49 - that right so you have the name
81:51 - and the high school sometimes you can
81:53 - design everything
81:55 - and we'll come back to this by
81:57 - discussing files right so because
81:59 - uh traditionally what we do is we just
82:01 - write files about students and all the
82:03 - stuff but
82:04 - we'll come back here and then try to
82:07 - work on this game
82:08 - more and trying to create a file and
82:10 - again
82:12 - this is the total working game and if
82:14 - you want to
82:16 - implement this and if you are
82:17 - comfortable with implementing this with
82:19 - this kind of vector well i have made
82:21 - some rejected functions like this is
82:23 - completely solid this one is completely
82:25 - unnecessary because i'm getting the head
82:26 - along with the body
82:28 - so you can take care of that and again i
82:31 - will advise you
82:31 - not to use a vector using this and here
82:34 - if you
82:36 - want to include another teleportable
82:38 - wall inside this one
82:40 - you can do that again with a similar
82:42 - kind of logic for y-axis right so you
82:44 - make
82:44 - basically all four four of them all
82:46 - still reportable
82:48 - so uh when i i had actually implemented
82:50 - this game
82:52 - in python and if you use a graphics
82:54 - library you will be getting results like
82:56 - that
82:56 - so if we go to our
83:00 - python one so here i have my game
83:03 - it is basically written in two files one
83:05 - has the classes and one has the script
83:07 - and it has various images so what i have
83:10 - is the snake
83:11 - in patch so here you can see body
83:13 - horizontal
83:14 - tail up so whenever that snake is going
83:17 - in that particular direction you
83:19 - show that image and now where you can
83:22 - run this thing
83:23 - right over here you can see
83:26 - this game this is what you can make with
83:29 - a graphics library well this is pretty
83:31 - far
83:31 - but this is what you can make with the
83:33 - graphics library and you can see how
83:35 - smooth it is
83:36 - and it doesn't have any uh kind of
83:38 - issues like
83:39 - moving down faster in the vertical
83:43 - direction moving slower in the
83:44 - horizontal direction
83:46 - it has kind of same speed because you
83:48 - can control it
83:49 - you can basically control the number of
83:51 - pixels and all and if you see it is
83:53 - really portable on both sides if i go
83:55 - from
83:55 - the bottom from coming from the top and
83:58 - if i go from the sides i end up coming
84:00 - from there
84:01 - so this is how you can implement your
84:03 - games
84:04 - and this is basically the same project
84:06 - which i've implemented except that i
84:07 - have some additional functions handling
84:09 - the graphics of this game right
84:11 - nothing more than that it is basically
84:12 - the same exact logic which were talked
84:16 - but when you use a graphics library you
84:18 - get results like that
84:20 - so once you're comfortable when
84:22 - programming this
84:23 - particular game on the console i would
84:25 - advise you to
84:26 - look up some graphics library which is
84:29 - available in safe space there are many
84:31 - so see what you're comfortable with and
84:34 - try to implement
84:35 - such games on graphics even the tick
84:37 - factor game can be implemented on the
84:39 - graphics network
84:40 - and that really looks good instead of
84:42 - the concern
84:49 - is the best way or the best platform to
84:52 - actually
84:52 - put down our ideas in a very fast way
84:55 - well if i want to do
84:56 - the same thing in a graphics library it
84:58 - will take a really
84:59 - long time i need to initiate the
85:01 - graphics library i need to do a lot of
85:03 - things before getting all these things
85:04 - right
85:05 - so if you're coming up with an idea i
85:07 - would
85:08 - rather recommend you not to go to a
85:11 - graphics library but
85:12 - first thing and then put up a dirty kind
85:15 - of
85:15 - working prototype on your console and
85:18 - then you can beautify it on the graphics
85:20 - library
85:20 - so that's it for this particular video
85:22 - hope you enjoyed this
85:24 - and
85:30 - you know making it faster on the x and
85:33 - slower on the way or something like that
85:34 - i didn't do that i just
85:36 - went with a very simple approach but i'm
85:39 - sure you can do that
85:40 - and in the next video we'll start with
85:42 - inheritance
85:43 - till then happy coding