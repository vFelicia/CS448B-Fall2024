00:00 - hey guys welcome to the Python thread
00:02 - tutorial for beginners so first of all
00:05 - what is a thread so a thread is an
00:08 - individual and separate unit of
00:10 - execution that is the part of a process
00:13 - now what is a process a process is
00:17 - simply our running program so for
00:21 - example if you run a browser it's a
00:23 - process if you run a video game it's a
00:26 - process now inside this process multiple
00:30 - threads
00:31 - can work together to accomplish a common
00:35 - goal and threads allows the program to
00:38 - run in parallel that is the single most
00:41 - important benefit of using threads so
00:47 - let me give you an example so when you
00:50 - play a video game it has to handle few
00:52 - tasks for example it has to handle the
00:55 - graphics and the user interface and if
00:58 - you are playing the multiplayer game it
01:01 - has to handle the networking and all
01:04 - those things it has to handle in
01:07 - parallel because it has to remain
01:10 - responsive at all the times so how does
01:14 - this videogame handles those parallel
01:17 - tasks the simple answer is threads it
01:21 - can assign one thread for graphics one
01:24 - thread for user interface and other
01:27 - thread for networking so by using
01:30 - threads the beauty game can always
01:32 - remain responsive and it can run the
01:36 - task in a parallel way now let me
01:40 - explain threads using this diagram so
01:44 - you can see this whole blue box here is
01:47 - a process and the threads exists inside
01:52 - this process so in this process you can
01:56 - see three threads now inside those
02:00 - threads you can see there is a code and
02:04 - local variable so a thread is a
02:08 - light-weight process that exists inside
02:12 - the
02:13 - process also a thread is a sequence of
02:17 - control flow the difference between the
02:20 - thread and the process is that the tread
02:24 - exists entirely inside the process and
02:28 - share its resources so let's say inside
02:31 - this gray box we have the global
02:34 - variables that each tread will be able
02:37 - to share those global variables and in
02:41 - addition each thread can have its own
02:45 - local variables and its own control flow
02:49 - to work with those local and global
02:53 - variables now a single process may have
02:56 - multiple threads of execution and as I
03:00 - already said that threads are useful
03:03 - when an application wants to perform
03:05 - many concurrent tasks on a shared data
03:10 - now let me give you one more example so
03:13 - think about a browser it has to handle
03:17 - the landing pages or the animations or
03:20 - if you want to open multiple website on
03:24 - different tabs and you want to run video
03:28 - in one tab and if you want to do another
03:32 - task in other tab most of the time the
03:35 - browser always remains responsive and
03:39 - the browser can handle multiple tasks at
03:41 - the same time so it uses threads to
03:45 - always remain responsive now there are
03:48 - two different kinds of threads one is a
03:51 - kernel thread and other is a user space
03:55 - thread or a user thread now kernel
03:59 - threads are the part of operating system
04:03 - while userspace threads are not
04:06 - implemented in kernel the userspace
04:09 - threads can be seen as an extension of
04:12 - function concepts in programming
04:15 - languages now each process have at least
04:19 - one thread and that is the main thread
04:23 - so if you don't even create a thread
04:27 - inside a
04:28 - process it has at least one thread and
04:30 - that is process itself now let's talk
04:34 - about the advantages of using threading
04:37 - so the first advantage is multi-threaded
04:40 - programs can run faster on computer
04:42 - systems with multiple CPUs because these
04:46 - threads can be truly concurrent on
04:49 - multiple CPU computer systems the second
04:53 - advantage is the program can remain
04:55 - responsive to input at all the times
04:58 - this is true both for single and
05:02 - multiple CPU computer systems now the
05:06 - third advantage is threading allows to
05:10 - do something else while a thread is
05:13 - waiting for IO tasks or any other tasks
05:17 - to complete so it always remains
05:21 - responsive the next advantage is some
05:24 - programs are easy to Express using
05:27 - concurrency which leads to elegant
05:30 - solution and as a result they are easier
05:33 - to maintain and debug so some programs
05:36 - or some processes are inherently
05:39 - concurrent in nature and the next
05:42 - advantage is threads of process can
05:45 - share the memory of global variable so
05:49 - as I have already shown you in the
05:51 - diagram previously that multiple threads
05:54 - can share the memory of the global
05:56 - variables at the same time so if a
05:59 - global variable is changed in one thread
06:02 - this change is valid for all the threads
06:06 - a thread can have local variables also
06:10 - as we have seen in the diagram now let's
06:14 - talk about some of the issues or
06:15 - challenges you will face while
06:18 - programming threads for a program the
06:21 - first challenge is the scheduling so to
06:25 - execute a threaded program it must
06:28 - rapidly switch between threads so a
06:31 - program should be able to switch between
06:33 - threads efficiently and conveniently the
06:37 - second issue or challenge is the
06:40 - resource
06:41 - shirring so as I told you that multiple
06:44 - threads can share the same memory of the
06:49 - global variables so since threads share
06:53 - this memory and other resources it must
06:56 - be careful because operation performed
06:59 - in one thread could cause problem in
07:02 - another thread the next challenge you
07:05 - could face is of synchronizing of the
07:09 - threads so threads often need to
07:11 - coordinate their actions and as a
07:14 - software developer you may have heard
07:17 - about race condition of threads which
07:21 - means the outcome depends on the order
07:23 - of thread execution and often for
07:26 - synchronization we use locking
07:29 - primitives now that was the general
07:32 - description about threads now let's talk
07:35 - about the threads in item so in Python a
07:39 - thread is an object like any other
07:42 - object that can hold data this object
07:45 - can also be used to run with methods the
07:48 - object also can be stored in the data
07:51 - structures and this object can also be
07:54 - passed as a parameters to the methods
07:58 - also in Python our thread can also be
08:01 - executed as a process and during the
08:05 - lifetime of a thread it can have various
08:07 - states now in Python there are two
08:10 - modules which supports the usage of
08:12 - threads and these two modules are thread
08:15 - module and treading module now there is
08:18 - one thing to note here is that the tread
08:22 - module has been considered as deprecated
08:26 - for quite a long time so often users are
08:29 - encouraged to use that threading module
08:32 - instead of the thread module so if you
08:35 - will see in Python 3 that thread module
08:38 - is directly not available but indirectly
08:41 - you can use underscore thread to use the
08:45 - thread module and this is to remain
08:47 - backward compatible with the previous
08:50 - versions of the Python now the
08:52 - difference between the thread module and
08:55 - reading module is that the tread module
08:58 - treats the tread as the function while
09:01 - the module threading is implemented in
09:04 - an object-oriented way so in the next
09:06 - videos I will show you how to use these
09:09 - two modules in Python to create threads
09:12 - and handle threads in Python in the last
09:16 - video I have given you a brief
09:17 - introduction about threads and threads
09:20 - in Python in this video we will discuss
09:23 - about a module called thread module now
09:28 - if you remember in the last video I have
09:30 - told you that thread module is
09:33 - considered as deprecated in Python 3 but
09:38 - if we want to use thread module in
09:40 - Python 3
09:41 - we can still use thread module using
09:45 - module called underscore thread and this
09:49 - is for backward compatibility so I just
09:53 - want to give you a brief demo about
09:56 - thread module in Python 3 so you will
09:59 - have some idea about thread module in
10:02 - Python 3 so let's get started so first
10:05 - of all in order to use thread module you
10:10 - need to import it and then generally you
10:13 - will write thread but in order to use
10:17 - the thread module in Python 3 you need
10:19 - to use the underscore thread here okay
10:23 - so thread module is not directly
10:25 - available but it's available using this
10:28 - underscore thread module and for
10:32 - printing and giving some delay to our
10:35 - functions we are going to import a
10:38 - module called time now using thread
10:41 - module it's possible to use functions in
10:44 - separate threads so we are going to
10:47 - create a function and then we are going
10:50 - to execute this function in separate
10:53 - threads so let's define our functions
10:56 - and I'm going to name my function as
10:58 - print underscore epoch and if you don't
11:03 - know what is a pape it pork is the start
11:06 - of January first
11:09 - 1970 and we are going to try to print
11:13 - the number of seconds from apoc till now
11:16 - and inside this function we are going to
11:19 - provide two arguments first is the name
11:24 - of your thread so I'm going to just
11:27 - write name of thread and the second
11:32 - argument we are going to give is the
11:34 - delay okay so this is your custom
11:39 - function you can provide any name here
11:41 - and any number of arguments here and now
11:45 - inside this function first of all I'm
11:47 - going to create a counter so I'm going
11:50 - to just write count and I'm going to
11:53 - initialize this count with 0 now inside
11:57 - this function what I'm going to do is
11:59 - I'm going to loop around and inside the
12:03 - loop I'm going to provide some delay so
12:06 - we will be able to see the thread
12:08 - execution so let me just provide the
12:11 - while loop here and we are going to just
12:14 - check whether this count is less than 3
12:17 - and inside this while loop we are going
12:19 - to sleep for some time using that time
12:23 - module so I'm going to just write time
12:26 - dot sleep and we are going to just pass
12:30 - this delay argument inside this sleep
12:32 - function so I'm going to just write
12:34 - delay here which will be the delay in
12:37 - seconds so for example if I provide the
12:40 - delay of 1 then our while loop will
12:44 - sleep for one second now after this we
12:47 - are going to increment our counter so
12:50 - I'm going to just write count and then
12:52 - plus equals 1 which is going to
12:55 - increment the value of counter by 1 now
12:59 - after this in order to see whether our
13:01 - thread is working or not we are going to
13:05 - print something so let's print something
13:08 - using the print function so what we want
13:10 - to print so let's say we want to print
13:13 - the name of the thread whatever name we
13:15 - will provide for the thread and then I'm
13:19 - going to just give some indication
13:23 - here let's say this is some line and
13:25 - then we are going to print that time
13:27 - since epoch so in order to print time
13:31 - since epoch we will use this time module
13:34 - and then we just need to use the time
13:38 - function inside the time module
13:40 - so using this print function we will
13:42 - know which thread is executed and at
13:46 - what time it's executed so now we have
13:49 - our function and now this function we
13:52 - want to execute inside the thread so in
13:56 - order to execute this function inside
13:57 - the thread first of all I'm going to use
13:59 - this thread module and there is a
14:01 - special function inside this tread
14:04 - module which is called a start new
14:07 - thread function so I'm going to use that
14:09 - function so let's just call this
14:12 - function which is thought underscore new
14:15 - underscore thread now if you hover over
14:18 - this function and when I press ctrl on
14:21 - Windows or command on Mac and then I
14:25 - hover over this function you will be
14:28 - able to see the signature for this
14:30 - function so this function takes 3
14:32 - arguments 1st argument is the function
14:35 - which we want to execute inside the
14:37 - thread second argument is args which we
14:41 - provide to our function as tuples so 2nd
14:45 - argument we need to provide as tuple and
14:48 - inside this tuple we will provide the
14:50 - number of argument which we want to
14:52 - provide to our function and third
14:55 - argument is that kW adds option and this
14:58 - kwr is an optional dictionary for the
15:02 - keyword arguments so let's provide the
15:05 - function name first of all and our
15:07 - function name which we want to execute
15:09 - is print underscore epoch and you need
15:13 - to remember that you need to provide
15:15 - this function name without any
15:17 - parentheses okay so just provide the
15:20 - function name as the first argument
15:23 - second is the number of arguments so we
15:27 - have provided two arguments for this
15:30 - print a pop function so we need to give
15:32 - these two argument in the form of tuples
15:35 - so first argument
15:37 - let's say is the name of the thread so
15:40 - we are going to just say that this is
15:42 - the thread 1 which will be the name of
15:45 - this thread and the second argument is
15:48 - the delay in seconds so let's say I want
15:51 - to provide 1 second delay in the while
15:55 - loop so it will sleep for one second
15:58 - this delay we are providing in order to
16:01 - see the thread execution because thread
16:04 - execution is so fast that it will be
16:07 - difficult to see the execution of
16:08 - threads without this delay now I told
16:12 - you that the third argument is the
16:14 - optional argument so we will not provide
16:16 - the third argument to the start new
16:19 - thread so this statement is going to
16:21 - create a new thread and it's going to
16:24 - execute this function inside this new
16:27 - thread so till now we only have one
16:29 - thread so let's create the second thread
16:31 - and to create the second thread you need
16:34 - to repeat this function which is start
16:37 - new thread and then you need to give the
16:39 - name to your thread so I'm going to give
16:41 - the name thread too and let's just
16:44 - change the delay so here I am going to
16:47 - provide the delay of 3 second to the
16:49 - thread 2 so now we have created two
16:52 - threads and this function will be
16:55 - executed in both that threads so let's
16:58 - see if this code works or not so I'm
17:01 - going to just run the script and you
17:04 - will see as soon as I run the script it
17:07 - exists without printing anything and
17:10 - this is because thread takes some time
17:12 - to be created and we need to wait for
17:16 - the thread creation so we need to
17:18 - provide some mechanism to wait for that
17:22 - thread creation and this wait we can
17:24 - provide in two ways one is we can just
17:28 - provide the blank input function which
17:31 - waits for the input
17:32 - so using this input function we will
17:34 - wait for some time until these threads
17:37 - are created and now we will see if this
17:41 - works or not so let's run this script
17:43 - once again and let's see what happens so
17:45 - you can see now you will be able to see
17:48 - these print State
17:51 - and you will see that first of all
17:53 - thread one is executed and then thread
17:56 - one is executed once again because we
17:59 - have provided only one second delay
18:01 - between the loop inside this thread so
18:06 - thread one will be executed faster than
18:08 - thread two so first of all thread one is
18:11 - executed and the ik bak time is printed
18:14 - and once again this thread one is
18:16 - executed because the delay time is less
18:19 - and then thread two is executed and the
18:22 - Epoque time is printed here and then
18:24 - thread one is executed once again and at
18:28 - the end you will see that thread two is
18:29 - executed two times because you can see
18:32 - that here we have the counter limit
18:35 - which is less than three so let's try to
18:38 - increase this limit to five and let's
18:41 - see how many times this print statement
18:43 - is printed so let's run the program once
18:47 - again and let's see what happens so once
18:49 - again this thread one is executed two
18:53 - times and then thread two and then
18:55 - thread one is executed three times once
18:58 - again and then tried to comes and you
19:00 - can see rest of the threads are executed
19:03 - then so here you can see thread one is
19:06 - executed one two three four five times
19:09 - and thread two is executed also five
19:12 - times so in this way you can start
19:14 - multiple threads and execute different
19:17 - functions inside those threads now I
19:21 - told you there is another way of waiting
19:24 - and this is by providing the while loop
19:28 - so I'm going to just provide wild one
19:31 - and inside this while loop I'm going to
19:34 - wait forever so I'm going to just say
19:38 - pass and this is an infinite loop which
19:41 - is like waiting so I'm going to just
19:45 - close this script first of all and then
19:48 - run the script once again and then you
19:51 - will see the same effect which you have
19:53 - seen in the case of input function also
19:56 - now here one more thing to consider is
19:59 - the return of this function so if this
20:03 - function which
20:04 - you want to execute inside the thread
20:06 - returns successfully the thread will
20:10 - silently exit but when your function
20:12 - terminate unexpectedly then unhandled
20:16 - exception will be thrown and thus track
20:19 - trace of that exception will be printed
20:22 - on the terminal so if this function
20:25 - throws then strike trace will be printed
20:28 - and this will be an unhandled exception
20:31 - so in order to avoid this unhandled
20:34 - exception
20:35 - you can also provide the try catch block
20:39 - here so here you can provide try and
20:41 - then i'm going to provide some space
20:43 - here and here also and after this code
20:47 - I'm going to just write accept and
20:50 - inside the accept you can provide any
20:53 - error so you can print that this is an
20:56 - error so inside this print function you
20:59 - can just write that this is and or
21:03 - anything which you want to write inside
21:06 - this accept block you can write using
21:09 - the print function or whatever you want
21:10 - to do in order to handle this exception
21:13 - you can do inside that accept block so
21:17 - let's run this script once again and
21:18 - let's change the delay here so I'm going
21:21 - to provide the delay of two seconds and
21:23 - here I'm going to provide the delay of
21:26 - let's say four seconds and let's run the
21:29 - script once again and this script runs
21:32 - and you can see after two seconds the
21:35 - thread one print statement is executed
21:37 - and then after four second thread two
21:40 - print statement is executed and this
21:43 - tried execution you will be able to see
21:46 - in those intervals so this is how you
21:49 - can use thread module in Python 3 in the
21:52 - last video we have seen how to use
21:54 - thread module in Python now in this
21:57 - video I'm going to show you how to use
21:59 - threading module in Python and I'm going
22:02 - to give you some introduction about
22:04 - threading module how to create threads
22:07 - using threading modules and how to use
22:10 - threading module now threading module is
22:13 - more powerful and it has more higher
22:17 - level support
22:18 - for creating threads in Python so let's
22:22 - see how to use threading module in
22:24 - Python so in order to use threading
22:27 - module first of all we need to import it
22:30 - so I'm going to just import threading
22:33 - module and once threading module is
22:36 - imported we will be able to use
22:38 - threading module the second module which
22:41 - I am going to import here is the time
22:43 - module which we have also seen in the
22:45 - last video because we are going to
22:48 - create the same function and we are
22:50 - going to use this function using the
22:53 - threading module which we have seen in
22:55 - the last video now I'm going to create
22:58 - the same method which I have created in
22:59 - the last video also which is print a box
23:02 - so I'm going to just copy this method in
23:06 - order to save time and then I'm going to
23:09 - just paste it here so now we have our
23:12 - function which we want to call using the
23:14 - threading module and we want to create
23:17 - some threads using this threading module
23:20 - and call this function inside those
23:22 - threads so first of all I'm going to
23:24 - write this condition which is for the
23:27 - main method which is if name is equal to
23:32 - underscore underscore main underscore
23:34 - underscore and under this condition what
23:38 - I'm going to do is I'm going to create
23:39 - two variables let's say first variable
23:43 - name is t1 for thread 1 and then I'm
23:46 - going to call the threading module to
23:48 - create a thread now inside the threading
23:51 - module there is a class called thread
23:53 - which we will use to create threads so
23:56 - just call the thread class here and
23:59 - constructor of this class takes several
24:02 - argument when you hover over here inside
24:05 - the parentheses you will see the
24:08 - signature of this thread class so it can
24:11 - take the target it can take the name of
24:13 - the thread and arguments also it can
24:16 - take in the form of tupple and it can
24:18 - also take the keyword argument in the
24:21 - form of dictionary so for our purpose we
24:24 - need to call the function which is print
24:28 - Apoc so we need to provide a target so
24:31 - in order to provide
24:32 - target we are going to just write target
24:36 - equals and the name of the function so
24:39 - the name of the function is print epoch
24:42 - which we are going to call and this you
24:46 - need to give without the parentheses so
24:48 - just remove the parentheses in front of
24:51 - this method when you use it as the
24:54 - argument in front of target the second
24:57 - argument which we want to give here is
24:59 - the arguments which this function takes
25:02 - so this argument we can give using the
25:05 - odds parameter so I am going to just
25:08 - write as equals
25:11 - and then in the form of couple I'm going
25:13 - to give the name of the thread and that
25:16 - delay to the thread so let's give the
25:19 - name to the thread let's say this is
25:22 - thread 1 and the delay which we want to
25:25 - give here is 1 so this statement is
25:27 - going to create one thread and let me
25:30 - create one more thread in order to
25:32 - create multiple threads and instead of T
25:35 - 1 I'm going to change the name to T 2 so
25:37 - we have T 1 variable and T 2 variable
25:40 - and in the arcs I'm going to change the
25:43 - name of the thread which is thread 2 and
25:46 - let's say I want to give this delay of 2
25:48 - seconds to the function using the thread
25:51 - 2 so now we have two variables T 1 and T
25:55 - 2 which is an instance of that thread
25:58 - class now using T 1 and T 2 we can call
26:02 - a method called
26:04 - start in order to start the thread so
26:07 - I'm going to just call T 1 variable and
26:10 - then call a method called start which is
26:13 - going to start the thread T 1 similarly
26:16 - I am going to call the instance T 2 and
26:20 - I'm going to call the method start on
26:22 - this instance T 2 also so start method
26:26 - we use to start that threads now if you
26:30 - remember in the last video when we have
26:32 - created the thread using the thread
26:35 - module we have given this condition
26:37 - which is the infinite loop and this
26:40 - infinite loop we have used to wait until
26:43 - the execution of thread is completed
26:46 - now in the trading module which is the
26:48 - new module this facility is available
26:51 - using a method called join so on T one
26:56 - instance I can call a method called join
27:00 - and on T two instance also I can call a
27:04 - method called join and this join method
27:07 - waits until thread one and tried to is
27:11 - completed its execution and then at the
27:15 - end we can print something let's say we
27:18 - are going to print that everything is
27:20 - done so I'm going to print done here so
27:24 - let's rewind what we have done inside
27:26 - this script we have an imported
27:28 - threading module and time module and
27:30 - then we have created the function which
27:33 - we want to call using that threads now
27:36 - in order to create the thread using
27:38 - threading module we need to call the
27:41 - class called thread inside the threading
27:44 - module now this class constructor takes
27:47 - several arguments and right now we have
27:51 - given two arguments to this thread
27:54 - constructor which is the target which
27:56 - takes the name of the function which we
27:59 - want to execute using this thread and
28:01 - second argument we have given here is
28:03 - the args which is the argument which we
28:07 - want to give to the function which we
28:09 - want to execute same we have done for
28:12 - the thread two also now the start method
28:14 - on these instances is going to start the
28:18 - thread for T 1 and T 2 and the join
28:21 - method we have used to wait until thread
28:24 - 1 and thread 2 is completed their
28:27 - execution so let's run this script and
28:30 - let's see what happens so I'm going to
28:33 - right click and then run the threading
28:36 - example Python script and you can see
28:39 - straight away that this output is
28:42 - printed here similar output we have seen
28:45 - in the case of thread module also so in
28:49 - this output thread 1 is printed and the
28:51 - Epoque time is printed and then thread 2
28:54 - is printed printed using the
28:57 - thread 2 so this output is printed
29:00 - using the thread 1 and thread 2 output
29:02 - is printed using the thread 2 and
29:04 - because we have given different
29:06 - intervals for a thread 1 and thread -
29:09 - that's why we can see that thread 1 is
29:12 - printed and then thread 2 and then
29:14 - thread 1 is printed two times and then
29:17 - thread 2 is printed and then thread 1 is
29:20 - printed once again two times and then
29:23 - rest of the thread two outputs are
29:26 - printed now let's take one more example
29:28 - and what we are going to do at this
29:31 - example is we are going to create two
29:33 - different functions and we are going to
29:35 - try to call these two functions using
29:38 - these two threads so the first function
29:40 - I'm going to create here is the print
29:43 - underscore a cube which is going to
29:46 - print the value of cube of the number
29:48 - which we will provide as the argument to
29:52 - this function so I'm going to just write
29:55 - print here and then using this print
29:58 - statement I'm going to print the value
30:00 - of cube of the number so here I'm going
30:03 - to just write cube and then I'm going to
30:06 - provide these curly brackets and then
30:08 - I'm going to call the format method
30:11 - after this string so let's call the
30:15 - format method which we use in order to
30:18 - format a string now inside the string we
30:22 - want the cube of the number so we will
30:25 - just multiply this number three times so
30:27 - num Astrix num Asterix num which is
30:31 - going to print the cube of the number
30:34 - once again let me just copy this
30:38 - function and then I'm going to create
30:41 - one more function and this time I'm
30:43 - going to name my function as print
30:46 - square so I'm going to just write print
30:49 - square here and then I'm going to just
30:51 - write square is equal to and here I'm
30:54 - going to just print the square of the
30:56 - number now in this statement where we
30:59 - have created t1 and t2 instances the
31:02 - target we can change which is the name
31:04 - of the function so now our target is
31:07 - print cube and print square without the
31:12 - parenthesis we
31:13 - to give the name of this function so
31:16 - print cube and print square and
31:19 - arguments have also changed so earlier
31:22 - print epoch used to take two argument
31:24 - and now we just want to give one
31:27 - argument to the function and let's say
31:29 - it's two and also the print queue
31:32 - function takes one argument and let's
31:34 - say it's two also now let's run this
31:37 - script and let's see what happens so you
31:40 - will see that there is an exception here
31:44 - which is some kind of a weird exception
31:47 - which says that exception in thread two
31:51 - and this exception is this print square
31:55 - argument afters Asterix must be
31:59 - iterative all right so the problem here
32:02 - is we need to give a comma here which
32:06 - tells this parenthesis that this is a
32:10 - couple value okay that's why it's giving
32:14 - the exception so if your function takes
32:16 - one argument then you need to give the
32:19 - value of that argument and then give the
32:21 - comma so that it's able to understand
32:24 - that it's a tuple and then once again
32:26 - when you run this script you will see
32:29 - the value of cube is printed which is
32:32 - eight and square is printed which is 4
32:35 - so this cube value is printed using
32:37 - thread 1 and square value is printed
32:40 - using the threaded 2 so in this way you
32:43 - can also call a multiple function using
32:47 - multiple thread instances using
32:50 - threading module so this was a brief
32:53 - introduction about reading module in the
32:56 - last video we have seen how to use
32:57 - treading module to create threads in
33:00 - Python now in this video also we are
33:03 - going to see how to create threads using
33:05 - threading module but we are going to see
33:08 - in this video how to subclass from the
33:11 - thread class which is available inside
33:14 - the threading module and then create
33:16 - threads out of that class instance so to
33:21 - start with I have the same method which
33:24 - is print
33:25 - Apoc which I want to
33:27 - inside that's Fred so now here after
33:31 - this method what I want to do is I want
33:34 - to create a class so I'm going to create
33:36 - a class and the name of the class I'm
33:39 - going to give the name as my thread for
33:44 - example and one thing we need to do here
33:47 - is we need to subclass from the thread a
33:51 - class from the threading module so we
33:54 - are going to just call first of all
33:57 - threading dot thread so we are sub
34:01 - classing from the threaded laws now
34:04 - inside this my class first of all we are
34:07 - going to define the init method so let's
34:10 - define this init method and in this init
34:14 - method we are going to pass two
34:15 - arguments same as this print
34:19 - Apoc function so first argument will be
34:22 - the name of the thread and the second
34:24 - argument will be the delay so let's
34:27 - provide these two arguments first is the
34:30 - name and second is the delay now after
34:35 - this inside this init method we need to
34:39 - call the parents init method which is
34:42 - threading dot red dot in it so we are
34:45 - going to just call threading dot thread
34:49 - dot underscore underscore init method
34:53 - which is going to call the parent init
34:56 - method which is treading dot treaded
35:00 - right now once you have done that we can
35:03 - just simply define some local member
35:07 - variable for the name so first of all
35:10 - self dot name is equal to name and self
35:15 - dot delay is equal to delay so now once
35:20 - we have our member variables what we
35:23 - need to do next is we need to override a
35:26 - method called
35:28 - run which is available inside the thread
35:31 - class in a threading module so I'm going
35:34 - to just define run method and we are
35:38 - going to overwrite this so first of all
35:40 - what
35:41 - this one method do so the run method is
35:45 - the entry point for the thread now in
35:48 - the previous video if you remember we
35:50 - have called the start method on the
35:53 - thread class right so the start method
35:57 - starts the thread by calling this run
36:00 - method so under the hood start method
36:02 - calls this run method so if we override
36:06 - this run method that means when we call
36:10 - the start method from the thread class
36:12 - this run method is going to be called so
36:17 - now we can do some logging here so what
36:19 - I'm going to do is I'm going to print
36:21 - first of all start thread and then I'm
36:27 - going to print and thread now between
36:31 - the start thread and and thread logging
36:34 - I'm going to call the print a pork
36:38 - function and this print epoch function
36:41 - is going to take two arguments which is
36:44 - name so I'm going to just pass the self
36:46 - dot name which we have assigned to the
36:51 - member variable and second is the self
36:53 - dot delay so once again when we call the
36:59 - start method on the instance of this my
37:02 - thread class this run method is going to
37:05 - be called by the start method
37:08 - automatically because we are sub
37:10 - classing from the threading dot thread
37:13 - class now once we have I would run the
37:17 - method and we have created the init
37:20 - method we can create some instances of
37:22 - my class so I'm going to create some
37:25 - instances for example t1 is equal to my
37:29 - thread and then we are going to pass
37:32 - those two argument first is the name so
37:35 - let's say the name is thread one and the
37:40 - delay we want to provide here is let's
37:42 - say one second because this delay is
37:44 - going to go to the print a pork method
37:48 - which is this one right once again we
37:50 - are going to create the second instance
37:53 - let's say t2
37:55 - and once again we are going to call the
37:57 - my thread class which we have subclassed
37:59 - from the thread class and once again we
38:02 - are going to give these two argument
38:05 - first is the thread so this time I'm
38:08 - going to name it as thread two and the
38:11 - delay I'm going to give here is two
38:13 - second let's say and now after the
38:15 - instance is created we can call the
38:19 - start method and the join method on
38:21 - these two instances so let me just call
38:23 - t1 dot start and then we are going to
38:28 - call the t2 dot start and once we have
38:33 - the start which is going to start the
38:35 - threads we are going to just call the
38:38 - join method and by now you already know
38:42 - what this join method do which is to
38:45 - wait for the thread to be completed so
38:49 - I'm going to just call the join method
38:52 - on t2 also and let's run the script and
38:56 - let's see what happens so I'm going to
38:58 - run the script and you can see first of
39:00 - all start thread has been called which
39:03 - is from the logging of this print method
39:07 - and then thread one is printed and the
39:10 - Apoc time is printed and then thread 2
39:13 - is printed and the Epoque time is
39:15 - printed because we have given the one
39:17 - second delay for the thread 1 so thread
39:20 - one will be iterated faster than thread
39:23 - two because we have provided the delay
39:26 - of 2 seconds four three two and one
39:28 - second quartz red one as soon as the
39:31 - thread ends we can see this print
39:33 - statement which is n thread and after
39:36 - the end of the thread two we can see
39:38 - this print statement which is and thread
39:41 - two we can also print here so let's
39:44 - print some more things here so we can
39:47 - print the name of the thread so I'm
39:49 - going to just write self dot name and we
39:56 - are going to do the same for the end
39:58 - thread also so I'm going to just print
40:02 - here also self dot name so we will know
40:06 - which thread is starting and we
40:08 - tread is ending once again I'm going to
40:11 - run the program and now you can see
40:13 - start tread thread 1 so 21 is started
40:17 - and then tried to is started and you can
40:20 - see first of all thread 1 is ended and
40:23 - at last thread 2 is ended so this is how
40:27 - you can subclass from the thread class
40:29 - which is available inside the threading
40:32 - module now inside the threading module
40:35 - there are some special methods which we
40:38 - are going to see now so the first method
40:41 - is so let me just go after this start of
40:46 - the threads so here what I'm going to do
40:50 - is first of all I'm going to use the
40:52 - print function and inside this print
40:54 - function I'm going to call the threading
40:56 - module and there are some special
40:58 - methods for example first of all we are
41:02 - going to see what is the active count of
41:05 - threads so what are the number of
41:08 - threads which are there inside this
41:10 - program this is going to print the
41:13 - number of threads now the second method
41:16 - which I'm going to show you is the
41:19 - threading first of all let me just call
41:22 - the threading dot we are going to call
41:24 - the current thread so this is going to
41:28 - print the current thread which is active
41:31 - right now and third match third which I
41:34 - want to show here is threading dot
41:38 - enumerate and this enumerate method is
41:42 - going to enumerate the number of threads
41:44 - which are active so let's run this
41:47 - program once again and let's see what
41:49 - happens so I'm going to just run this
41:52 - program and first of all you will see 3
41:56 - is printed using this print statement
41:58 - which is threading dot active count so
42:03 - active count is going to give you the
42:05 - number of threads and you already know
42:07 - that we have created two threads and one
42:10 - main thread is already available so
42:13 - total number of threads are three here
42:16 - which is printed now the current thread
42:18 - here this print statement prints this
42:22 - output which is the main thread so right
42:25 - now at the time of this print statement
42:28 - main thread is active now this enumerate
42:32 - method as I said is going to enumerate
42:35 - over all the threads which are available
42:38 - so main thread is available and then we
42:41 - have created thread one which is this
42:43 - one this is the name of the thread one
42:45 - and then when I scroll here you can see
42:49 - thread two is available so total three
42:52 - threads are available main thread thread
42:55 - one and thread
42:57 - - so these method you can use to just
42:59 - find out how many threads are there what
43:03 - is the current thread thread and you can
43:05 - also a numerate over all the threads
43:07 - there is one more method so I'm going to
43:11 - call this method here and I'm going to
43:14 - print it inside the print function and
43:17 - this time I'm going to use the instances
43:20 - so T 1 dot and there is a method of
43:25 - available here which is get name which
43:28 - comes from the thread class and because
43:30 - we are sub classing from the thread
43:33 - class this marm
43:35 - and because we are sub classing from the
43:37 - thread class this get name is available
43:40 - inside the my thread class also and same
43:45 - we are going to do here also so print
43:47 - and then T 2 dot get name so this is
43:53 - going to give you the name of the thread
43:55 - by default so I'm going to just run this
43:59 - script once again and you can see this
44:02 - is going to print thread 1 and this is
44:05 - going to print thread 2 now you might
44:07 - wonder why this name is thread 1 hasn't
44:09 - tried to because this get name method is
44:14 - going to give the value of self dot name
44:18 - which we have assigned using this name
44:21 - argument so this name is overwritten in
44:25 - the subclass which is my thread class
44:27 - and that's why it's giving us thread 1
44:30 - and thread 2 name which we have provided
44:33 - if we change this name let's
44:35 - say t1 and t2 and once again we run the
44:40 - code you can see the name also changes
44:43 - to t1 and t2 so this is how you can
44:47 - subclass from the thread class which is
44:50 - available inside the training module and
44:52 - we have also seen some of the method
44:54 - which are available inside the threading
44:57 - module which are useful to us in this
45:01 - video we will see how thread
45:03 - synchronization works in the case of
45:06 - multi-threading in Python and we will
45:09 - talk about how to use locks in the case
45:12 - of thread synchronization so first of
45:15 - all what is thread synchronization so
45:18 - thread synchronization is defined as the
45:21 - mechanism which ensures that whenever
45:24 - two or more threads are executed in
45:28 - parallel or concurrently and if they are
45:32 - sharing the same resource in that case
45:35 - all the thread should not work
45:38 - simultaneously or parallely on the same
45:42 - resource so let me explain the thread
45:45 - synchronization problem with the diagram
45:48 - so in this diagram you can see there are
45:51 - three threads and all these threads are
45:54 - sharing the same resource it can be a
45:57 - global variable for example so as long
46:00 - as all these threads are accessing this
46:03 - shared resource one by one not at the
46:06 - same time everything will work fine but
46:10 - the problem arises when two or more
46:12 - threads try to access the same global
46:15 - variable or shared resource at a
46:18 - particular time and this kind of
46:21 - situation is called the race condition
46:24 - so a race condition occurs when two or
46:28 - more threads can access the same shared
46:31 - data and they try to change the value of
46:35 - this same shared data at the same time
46:38 - and whenever this kind of race condition
46:41 - occurs the value of the variables may be
46:45 - unpredictable because if two threads
46:49 - working on the same global variable at
46:51 - the same time you will never know which
46:54 - thread has worked on this variable so
46:57 - the result is the unpredictable value of
47:00 - a variable now let me explain this
47:03 - problem with an example so I have this
47:06 - sample code in which in the first line
47:08 - I'm importing threading module and in
47:11 - the second line I am just declaring a
47:14 - global variable now I have two functions
47:17 - here one is thread tasks and other is
47:20 - mean task now inside this thread task
47:23 - function I want to increment the value
47:25 - of X every time by 1 so this is the code
47:29 - for this and I want to increment this
47:32 - value by 1 10 times so that's why I have
47:35 - used this for loop in the range 0 to 9
47:39 - so it's going to increment the value of
47:42 - X 10 times inside this loop now because
47:45 - this X is a global variable I have just
47:48 - added this global keyword in front of X
47:52 - so our function knows that this X is not
47:56 - a local variable it's a global variable
47:58 - so this function is simple enough it
48:02 - just increments the value of x 10 times
48:05 - inside the loop and this X is this
48:09 - global variable which we have declared
48:12 - outside this function now in the main
48:15 - task what I'm doing is I'm creating two
48:18 - instances using the threading module
48:20 - with the help of thread class this we
48:23 - have already seen in the last video how
48:25 - to create threads using threading module
48:28 - so nothing new in this I have created
48:31 - two instances t1 and t2 and I'm passing
48:35 - the target is equal to the function name
48:37 - which is this function which is try to
48:40 - task
48:41 - so both the threads will call the same
48:44 - function try task and then I'm just
48:46 - starting both the threads with the help
48:49 - of start function and then I'm just
48:52 - using the join methods on both of the
48:55 - instances now here inside our main if
48:58 - condition I'm just calling our main task
49:02 - in
49:03 - which our threads are created and
49:05 - executed and then at last I want to
49:08 - print the value of x when all the thread
49:10 - execution has been completed so let's
49:13 - run this script and let's see what
49:15 - happens so you can see here the result
49:17 - here is 20 which is expected because we
49:20 - are incrementing the value of x 10 times
49:23 - using two threads so the value of X will
49:26 - be incremented ten times by thread t1
49:30 - and ten times by 22 and as a result the
49:34 - value of X becomes 20 but as soon as I
49:39 - increment the value of this range let's
49:42 - say this is 10000 and I want to just
49:45 - execute this program once again there is
49:48 - no problem until now we can just run
49:52 - this program again I mean again we will
49:54 - not see this problem because we are
49:57 - incrementing the value of x 10,000 times
50:01 - with a single thread so we have two
50:04 - threads and the result is 20,000 which
50:07 - is absolutely fine now let's increment
50:10 - the value of range once again 200
50:13 - thousand and now I want to show you the
50:16 - problem so as soon as you do this you
50:19 - can see that the thread synchronization
50:22 - problem occurs so here you can see the
50:25 - result is not 200 thousand which we were
50:28 - expecting because for such large value
50:32 - this scenario of thread synchronization
50:34 - is happening so the two threads try to
50:39 - work on the same variable at the same
50:42 - time and as a result the value of X is
50:46 - unpredictable so this thread
50:48 - synchronization problem you will see
50:50 - when you try to work on a same variable
50:53 - multiple number of times so in this case
50:56 - we have a hundred thousand iterations
50:59 - and both the threads try to iterate over
51:03 - the same variable using two threads and
51:07 - the result is unpredictable let's try to
51:10 - execute this once again so you can see
51:13 - the result is always different every
51:15 - time I
51:16 - cute this program because the result is
51:20 - unpredictable so how to solve this
51:22 - problem so one way of solving this
51:25 - problem is by using the locks so first
51:28 - of all let me just change this program
51:30 - and try to use locks in this Python
51:34 - script so to use locks what you can do
51:37 - is you can declare a local variable here
51:40 - for example lock is equal to threading
51:44 - dot class called lock so this is going
51:49 - to give you an instance of lock now this
51:52 - lock class have two method one is
51:54 - acquire and other is release now acquire
51:58 - method is used to lock and release
52:01 - method is used to release the lock so
52:05 - let me just complete this script and
52:08 - then I will explain what does these
52:11 - functions do so what I'm going to do is
52:13 - I'm going to pass this lock instance as
52:16 - an argument of the thread task function
52:18 - so I'm going to just write as is equal
52:22 - to and then we will just pass our lock
52:25 - instance as an argument of this credit
52:29 - task same we will do for the second
52:33 - thread and because we have passed this
52:35 - argument we need to add this argument
52:38 - here also so I'm going to just pass the
52:40 - lock instance as an argument of this
52:42 - function and now at last what we are
52:46 - going to do is just before we change the
52:50 - value of the global or the shed data we
52:54 - use this lock variable and call the
52:58 - method called acquires and just after
53:01 - you finished changing the resource or
53:04 - the shared data you use a method called
53:08 - lock dot release so once again we have
53:11 - passed this lot instance which we got
53:14 - from this lock class as an argument of
53:17 - this function so this is the lock
53:20 - instance and there are two main method
53:23 - inside this lock class which are acquire
53:26 - and release this acquire method you use
53:29 - two
53:30 - acquire the lock this lock can be
53:32 - blocking or non blocking so this acquire
53:36 - method takes one argument which is true
53:39 - or false by default the value of
53:42 - argument is true which means that this
53:46 - acquire is blocking by default so what
53:50 - does this lock dot acquire will do it
53:53 - locks the access of the shared variable
53:56 - in our case this is X and at this time
54:00 - only one thread can work on this
54:03 - variable whatever thread have the access
54:06 - to this function at a particular time so
54:11 - until and unless one thread execution is
54:14 - completed on this variable after that
54:17 - this lock is released that means that
54:20 - the other thread can work on this
54:23 - variable using the lock once again
54:26 - so whenever second thread wants to try
54:29 - to access this variable it will just
54:31 - lock the access to this variable first
54:34 - of all and then work on this variable
54:36 - whatever you want to do you want to
54:39 - increment the value or change the value
54:41 - of x and then release the lock and
54:43 - releasing means that we once again want
54:47 - to allow the other thread to work on
54:50 - this shared resource so this mechanism
54:54 - will allow only one thread to access
54:56 - this shared resource at a particular
55:00 - time so the Treader synchronization
55:02 - problem will not occur so now let's just
55:05 - run the program once again and let's see
55:08 - what's the result so you can see this
55:10 - problem and this problem is coming most
55:12 - likely because of this problem because
55:17 - we haven't provided args as the tuples
55:21 - so we need to provide this AAG as our
55:23 - tupple so always remember whenever you
55:25 - want to pass any argument using this
55:28 - args keyword you need to pass them as
55:30 - tupple so once again i'm going to just
55:33 - try to run this program and you can see
55:36 - the result is whatever we expected so
55:40 - because we are incrementing the value of
55:43 - x
55:44 - hundred thousand times and there are two
55:46 - threads which are working on the same
55:48 - variable so we get the two hundred
55:50 - thousand result which is expected now
55:53 - let me run this program again and again
55:56 - and you can see every time now we get
55:59 - the expected result which is two hundred
56:03 - thousand so this is how you can solve
56:06 - the thread synchronization problem using
56:10 - locks so this is how you can use locks
56:14 - to synchronize your threads in Python I
56:18 - hope you have enjoyed this video and I
56:20 - will see you in the next video