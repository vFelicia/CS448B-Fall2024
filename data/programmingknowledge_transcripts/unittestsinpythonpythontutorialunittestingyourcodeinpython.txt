00:00 - so first of all what is unit testing so
00:03 - according to Wikipedia unit testing is a
00:05 - software testing method by which
00:08 - individual units of source code are
00:12 - tested to determine whether they are fit
00:15 - to use or not so in unit testing we
00:18 - perform the lowest level of testing that
00:22 - is individual units of software are
00:25 - tested that means units like functions
00:29 - subroutines and classes are tested to
00:32 - verify if they are giving the desired
00:35 - result or not
00:36 - now let's discuss why should be unit
00:39 - test our code so when you write unit
00:41 - tests they reduces bug in the new
00:45 - features and existing features so let's
00:48 - say if you are writing a new feature in
00:50 - your code unit tests can help you to
00:53 - reduce the bugs which may appears during
00:57 - the execution of your code now if you
01:00 - write good unit tests this serves as a
01:02 - good documentation for the person who is
01:07 - using your code so because in unit test
01:10 - we are actually using the functions or
01:14 - the classes and testing them so if the
01:17 - person who wants to use your code he
01:20 - reads the test he will be able to
01:22 - understand how to use your code also
01:26 - when you write tests for your code it
01:28 - reduces the cost of the change in the
01:32 - production so if some code goes to
01:35 - production without testing and you find
01:39 - the bug in the production stage then
01:42 - it's much costlier than fixing your code
01:46 - when you are developing your code next
01:50 - unit test helps in faster debugging and
01:53 - faster development of your program also
01:57 - because you have the idea of what should
02:00 - be the desired result that means you can
02:03 - develop your code in a manner which is
02:06 - perfect for your tests and at last but
02:10 - not the least unit tests help
02:12 - us to better design our program now
02:16 - let's talk about the unit testing
02:18 - frameworks which are available in Python
02:21 - so I have listed here three top most
02:24 - unit testing frameworks which we can use
02:26 - to write our unit tests so first module
02:30 - is unit test module and this unit tests
02:34 - module is present in your Python
02:36 - standard library so you don't need to
02:39 - install any extra module in order to use
02:43 - this unit test module the next module is
02:45 - the nose module which is not there in
02:48 - the standard library but it's simpler to
02:52 - use than the unit test framework and at
02:56 - last you can use the PI test framework
02:58 - which is not in the Python standard
03:01 - library but it's one of the most popular
03:04 - unit testing framework for Python so we
03:08 - are going to use PI test for the unit
03:10 - testing of our python code so let's see
03:13 - how we can install PI test package on
03:15 - our operating system on which we are
03:18 - working on so you can install PI test
03:21 - using pip so we are going to just write
03:24 - pip install PI test and then press ENTER
03:28 - which is going to install this PI test
03:31 - package on our operating system so you
03:34 - can see PI test is now installed on my
03:36 - operating system so I'm going to give
03:38 - CLS command to clear a terminal and then
03:41 - first of all I can give this PI test
03:44 - command and then - H in order to get the
03:47 - help about PI test so just press Enter
03:50 - which is going to give you all the flags
03:53 - or the commands which you can use with
03:57 - the PI test so the usage is given here
04:00 - you just need to use the PI test keyword
04:03 - and then you can give the options which
04:05 - are listed below and you can give the
04:07 - file or directory' name or the list of
04:10 - files or directories so for example the
04:13 - general options are given here so when
04:15 - you give this flag - K or - K it's going
04:19 - to match the substring or the regular
04:21 - expression which you provide after this
04:24 - flag and when you use -
04:26 - em this means that it's going to test
04:29 - the functions which have the name
04:31 - assigned directly to them that means
04:34 - only run the tests which have a given
04:37 - mark expression so I'm going to try to
04:40 - show you all these options one by one
04:43 - but let's see how we can write the test
04:45 - to use them using PI tests so in here I
04:49 - have a Python script called math
04:51 - underscore func dot py file and inside
04:55 - this script I have two functions one is
04:58 - a simple add function which adds two
05:01 - values and other is the product function
05:04 - which returns the value of the
05:06 - multiplication of two values now in
05:09 - order to write the unit tests for these
05:11 - functions I can create a new file so let
05:14 - me create a new Python file and I'm
05:16 - going to name it as test underscore math
05:20 - underscore func
05:22 - so I have added this extra prefix here
05:25 - which is test underscore in front of the
05:28 - name of my file which is math func so
05:32 - I'm going to just create this file so
05:33 - this test underscore prefix which I have
05:36 - added in front of my Python script name
05:39 - will help pi test to recognize that this
05:43 - is the file in which the unit testing
05:45 - functions are written so it's going to
05:48 - go to that file and here we can first of
05:51 - all import the math func Python script
05:55 - and then we can define the test
05:58 - functions so the test function you can
06:01 - define simply as you define any other
06:03 - function in your Python script so you
06:06 - can write def and then just start the
06:08 - test name with the test prefix so test
06:12 - underscore and then whatever name you
06:14 - want to give to your test so first of
06:17 - all I want to test the add function here
06:19 - so I'm going to just write test
06:21 - underscore add and this function is not
06:23 - going to take any parameter and inside
06:25 - this function I can provide some
06:27 - assertion for my functions so I can use
06:31 - a special keyword which is assert and
06:34 - then you can call your function in your
06:37 - Python script so Matt func
06:39 - thought
06:40 - function and here as an argument I'm
06:43 - going to provide two numbers let's say
06:44 - seven and three which is going to give
06:47 - us the result ten so we are going to
06:49 - just check whether this function is
06:52 - returning 10 or not and this is called
06:54 - assertion assertion means you want to
06:57 - assert that the function is returning
07:01 - the desired result so we are expecting
07:04 - the result 10 when we provide 7 and 3 as
07:07 - an argument to this add function you can
07:11 - also provide multiple asserts here so
07:13 - let's say I just want to provide for
07:16 - example 7 here you can see that Y is
07:20 - equal to 2 is the default value of y so
07:24 - here in the assert I can only give one
07:26 - argument and the value of second
07:28 - argument which is Y will be taken from
07:31 - the default value which is 2 so 7 plus 2
07:34 - is 9 so we can just say whenever you
07:37 - provide 7 here it's going to give us 9
07:40 - once again whenever you provide 5 here
07:44 - it's going to give us 7 so in this way
07:47 - you can provide multiple asserts inside
07:50 - your function whatever you think will
07:53 - come as an expected result of your
07:57 - function so I'm going to define the
08:00 - second function which is test product
08:02 - and once again I'm going to pass no
08:04 - argument here and once again I can just
08:07 - use this assert keyboard and then the
08:10 - name of my library which is math func
08:13 - dot the function this time we are going
08:16 - to test the product function and let's
08:18 - say we just want to check the product of
08:20 - 5 and 5 and the expected result will be
08:25 - 25 in a same way whenever you provide
08:29 - here for example only one argument the
08:33 - default value of y is 2 right so when we
08:37 - provide only one argument which is 5
08:39 - here we will be expecting 10 here in a
08:42 - similar way when I provide let's say 7
08:45 - here we are expecting the result 14 here
08:47 - so once we have written our unit tests
08:50 - let's try to run these tests using PI
08:53 - test
08:54 - so first of all I need to go to the
08:56 - directory where this test script is
08:59 - there so I'm going to just copy the path
09:01 - and then go to the terminal and I'm
09:03 - going to CD to this path which I have
09:06 - copied and let me just remove the script
09:09 - name from here and then press Enter
09:11 - so now I'm in the folder where my mat
09:13 - func dot py is there and test underscore
09:17 - math underscore func dot py file is
09:20 - there
09:21 - so in order to run your unit test file
09:23 - you just need to give this command PI
09:25 - test and the name of your test file
09:28 - which is test underscore math underscore
09:31 - func dot py in my case and then I'm
09:35 - going to press ENTER and you can see
09:38 - it's going to give me two passed in
09:40 - whatever time it took to execute these
09:44 - two tests so because we have written two
09:47 - tests here for two functions it's going
09:50 - to show us this result which is two
09:53 - passed let's say we are going to expect
09:55 - some unexpected values so here we have
09:58 - written some wrong value which we are
10:01 - expecting and now when we run our test
10:04 - is going to fail you can see one passed
10:07 - and one failed and PI tests will also
10:10 - give you the information about the
10:12 - assertion failure so the assertion
10:15 - failure is happened at this assertion
10:18 - where you are just testing 10 is equal
10:22 - to 18 which is wrong here so once again
10:26 - we are going to correct this all so
10:28 - let's say some developer has changed the
10:31 - function which you are testing so
10:33 - instead of returning the addition now
10:36 - I'm going to return the subtraction
10:39 - which is going to break that test now so
10:41 - I'm going to run the test once again and
10:43 - once again it's going to give you the
10:46 - error and this time it's going to show
10:48 - us that the result is 4 but we are
10:51 - expecting 10 as the result and that's
10:54 - why it's failing so once again I'm going
10:57 - to just fix my code and then once again
10:59 - I'm going to run my test and once again
11:02 - the test will pass so let me just clear
11:06 - the terminal using CLS command
11:08 - and you can also give a flag called - V
11:12 - which stands for verbose in order to get
11:16 - the more detailed result so I'm going to
11:19 - press ENTER and you can see it's going
11:21 - to give us this flag passed or failed in
11:24 - front of your tests and both tests are
11:28 - right now passing that's why it's
11:30 - written passed in green here let's break
11:33 - the test once again so I'm going to just
11:35 - say - here and once again run the code
11:39 - and now it will say this test is passing
11:43 - but that test ad is failing due to this
11:46 - assertion so I'm going to once again fix
11:49 - the code and come to the terminal once
11:52 - again I'm going to just clear the
11:54 - terminal and you can also run your test
11:57 - using this command so you just need to
11:59 - write PI dot test without giving any
12:03 - name in front of this PI dot test and
12:06 - then + enter which is going to
12:09 - automatically recognize the test file
12:12 - because we have given the special prefix
12:14 - here test underscore this is how your PI
12:18 - test will recognize that this is the
12:21 - testing file so it's going to just run
12:23 - the test inside that file and once again
12:26 - you can see it runs and two tests are
12:29 - passing you can also give the verbose
12:33 - flag here which is going to give you the
12:35 - more information about your tests now
12:38 - let's say we are going to remove this
12:40 - prefix from our tests so let's say we
12:43 - just write tes underscore add so there
12:47 - is no test prefix in front of your
12:49 - function and once again I'm going to
12:51 - give the same command and you will see
12:54 - only one test is recognized which is
12:57 - test underscore product and this is
12:59 - because we haven't provided that test
13:02 - prefix in front of the function so in
13:05 - order to recognize this function as a
13:07 - unit test you need to give the test
13:09 - keyword as the prefix of your unit test
13:12 - function also whenever you change the
13:15 - name of your test file so let's say I'm
13:17 - going to refactor the name and I'm going
13:20 - to just remove the
13:22 - t from test and then once again I'm
13:25 - going to press refactor which is going
13:27 - to change the name of this test file and
13:30 - now this test file name is tes
13:32 - underscore math underscore func and once
13:36 - again I'm going to try to run my test
13:39 - and it's going to say no test run in
13:42 - this much amount of time so again
13:45 - whenever you don't give the test keyword
13:48 - in front of your file name then PI test
13:52 - will not be able to recognize that this
13:54 - is your unit testing file let's go to
13:57 - the terminal and I'm going to just give
13:59 - the CLS command in order to clear the
14:01 - terminal and let's give the second
14:04 - command now which we have used for
14:06 - running the test which is the PI test
14:10 - command and the name of the file so now
14:12 - my file name is tes underscore math
14:15 - underscore py and now I'm going to press
14:18 - enter and you will see now it's going to
14:22 - recognize because we are specifically
14:24 - giving the filename in which our tests
14:29 - are there so if you want to run your
14:31 - test inside some file which doesn't have
14:34 - the test prefix in front of it you can
14:37 - just use PI test command and then give
14:40 - the name of the file and PI test is
14:42 - going to recognize that this is the file
14:44 - in which your unit tests are there and
14:47 - it will run all the unit tests in this
14:50 - file so in the last video we have
14:52 - written two test functions for our ad
14:56 - and product functions which were able to
14:58 - test those functions using these numbers
15:01 - now additionally I have added two more
15:05 - test functions here and these two test
15:08 - functions I have added to test the
15:10 - strings with the add function and the
15:14 - product function
15:15 - so using this plus operator we can also
15:18 - add two strings right so I have added
15:22 - the string test for the add function and
15:25 - the product function here now the first
15:28 - thing I want to show here is you can add
15:30 - any comparison operator here so it's not
15:34 - necessary that you need to you
15:35 - this equal to operator here you can also
15:38 - write for example greater than operator
15:41 - or greater than equals to operator or
15:43 - the less than operator or less than
15:46 - equals to operator or not equals to
15:49 - operator so you can use all these
15:50 - comparison operator with your assert
15:53 - statement additionally you can use this
15:56 - is keyword to test whether something is
16:00 - something so using this is keyword I am
16:03 - testing here that the result which I got
16:06 - using this ad function over the strings
16:10 - is it a string or not
16:13 - so using this type I am just finding out
16:15 - the type of the result and I'm checking
16:18 - if this result is a string or not you
16:21 - can also use in operator or not in
16:24 - operator so using this not in keyword we
16:28 - are checking whether the string is
16:30 - inside our result or not so this string
16:34 - or let's say this string is not inside
16:37 - our result
16:38 - so this assert is going to pass because
16:40 - this string is not present in our result
16:43 - additionally you can also use this in
16:46 - keyword and you can check whether some
16:50 - string is inside your result or not so i
16:53 - can also write hello in result which
16:56 - will check if this keyword is inside our
16:58 - result or not now the next thing which i
17:00 - want to show here is let's say you just
17:03 - want to run one test from here which is
17:07 - test ad and you don't want to run any
17:09 - other tests how you can do it using
17:12 - command line so you can just write by
17:15 - test command and the name of your test
17:19 - file which is test underscore math
17:21 - underscore func
17:23 - in my case and then you can add double
17:26 - colon here and then give the name of
17:28 - your test so let's say I just want to
17:31 - run that test ad so I'm going to just
17:34 - run this test and you can see it's going
17:37 - to only run the first test
17:40 - let me just add minus V here which is
17:43 - going to show which test has passed and
17:46 - you can see this test has been
17:49 - past which is test ad and let me just
17:52 - clear the terminal now the next option
17:54 - which I want to show here is - key so
17:58 - once again I'm going to just write PI
18:01 - test here and we will once again add the
18:05 - - V for Bobo's and you can use a special
18:09 - option which is - k and then you can
18:13 - give any expression which you want to
18:16 - match using this - K option so let's say
18:20 - we only want to run the ad test so we
18:24 - have to add test one is test underscore
18:27 - ad and other is test underscore ad
18:30 - underscore string so I just want to run
18:34 - the test for the add a function so here
18:38 - inside the double quotes I can just
18:42 - write ad and then press ENTER and it's
18:45 - going to run the test which contains add
18:48 - keyword or add string so you can see it
18:52 - ran test underscore ad and test
18:55 - underscore ad underscore string you can
18:58 - also use or operator here so let's say
19:02 - you want to run the test which contains
19:04 - ad or which contains string keyword and
19:09 - when I am going to run the test it's
19:12 - going to run all those tests which
19:14 - contains either add or the string
19:17 - keyword so there are three tests which
19:20 - fulfills this condition and all those
19:22 - three tests are performed and other
19:25 - tests will be deselected so you can see
19:27 - for item and one item is d selected here
19:31 - also you can use the and instead of or
19:34 - so I'm going to just write end and then
19:36 - press ENTER and it's going to run only
19:39 - those tests which contains ad and string
19:43 - both so there is only one test name
19:47 - which contains ad and string both which
19:50 - is this one so only this will be
19:53 - executed and the other three test will
19:55 - be deselected let me once again clear
19:58 - the terminal now the next option which I
20:00 - want to show here is the
20:01 - - Emma option so once again I'm going to
20:06 - just write here - M and after this - M
20:10 - you can provide any mark expression so
20:15 - let me go to my code and here I just
20:18 - need to import the PI test first of all
20:22 - so let me import PI test and here you
20:25 - will see that it's showing me the
20:28 - squiggly line because of my IDE which is
20:31 - PI charm so because I have installed a
20:34 - PI test using pip on the command line
20:37 - which is not recognized by my PyCharm
20:40 - IDE that's why it's showing me the
20:42 - squiggly line but I am running my tests
20:45 - using command line so this will work so
20:48 - don't worry about this squiggly line the
20:50 - import will work and after that what I
20:53 - can do here is I can add a decorator so
20:56 - I can just write PI test dot mark dot
21:00 - any expression which you want to give
21:02 - here so this test add and test product
21:05 - is for the numbers so we can write
21:08 - number here and also we can add the same
21:12 - decorator for the test product and for
21:16 - the other two tests we can just write
21:19 - that these tests are for the strings so
21:22 - this expression is upon you so you can
21:25 - give any expression here which you want
21:28 - to match later using - M option so I'm
21:31 - going to also add this decorator over
21:34 - the other string function also so we
21:37 - have two markers now one is number and
21:40 - other is the string so now after - M you
21:45 - can give the mark expression name so
21:47 - let's say I'm going to just write number
21:50 - here and then press ENTER and it's going
21:53 - to run all the tests which have the mark
21:55 - number which is the test add and test
21:59 - product now let's run the test which
22:02 - have the mark string so I'm going to
22:05 - just write string and then press ENTER
22:07 - and it's showing me for D selected
22:10 - because I forgot this s after the string
22:14 - so let me just
22:15 - this s and then versa I can enter again
22:18 - and you can see it runs only those tests
22:21 - which have string mark on top of them so
22:24 - this is the string and this is the
22:27 - string mark so those two tests were
22:29 - executed and other two tests were D
22:32 - selected let me just clear the terminal
22:34 - once again now the next option which I
22:37 - want to show here is - X option so once
22:41 - again I'm going to just write PI test -
22:44 - V and then - X now this - X means exists
22:49 - first
22:50 - so whenever first failure occurs in your
22:53 - test the PI test will exit from the
22:56 - execution of your test so let's just add
23:00 - some failure assertion here so I'm going
23:04 - to add the failure here so let's say I'm
23:08 - just checking the failed assertion here
23:12 - just to check whether this - X works or
23:15 - not so I'm going to just press ENTER now
23:18 - and you can see first test was run which
23:22 - was passed but the other test failed so
23:25 - it has shown us the stack trace of the
23:29 - failed test and after that the text
23:32 - execution was stopped so after two tests
23:35 - because the failure occurred the other
23:38 - two tests which was supposed to be
23:41 - executed are not executed because of
23:44 - this - X option so as soon as the first
23:48 - failure occurs your test will exit now
23:52 - let's say you don't want to see this
23:54 - tech trace after the failure of your
23:57 - test so this is all the information
24:00 - which is given to you about what
24:03 - assertion has failed or not so let's say
24:06 - we don't want to see this so how to just
24:09 - skip that stack trace you can add - - TB
24:15 - is equal to no and this is going to
24:18 - disable the stack trace and then press
24:21 - Enter and you can see now this text
24:24 - trace is not printed only the success or
24:28 - the failure
24:29 - we'll be printed but not the stack trace
24:32 - let me clear the terminal once again and
24:35 - this time I want to show one more option
24:37 - which is max fail so here you can just
24:41 - write - - max fail option and then gave
24:47 - the number in front of it after the
24:49 - equals - symbol so let's say we just
24:52 - write max fail to here then it's going
24:55 - to wait for the maximum number of
24:58 - failure and then it will exit so let me
25:01 - just run this test so you can see all
25:03 - four tests has been executed because
25:05 - maximum failure we were expecting is two
25:09 - that's why all four were executed
25:12 - because there was only one failure let's
25:15 - say I just make it one so now the value
25:19 - of max fail is 1 and then I press ENTER
25:22 - and you will see after the first failure
25:25 - it's going to exit because we have
25:28 - provided max fail 1 and this is the
25:31 - number of failures which we are
25:32 - expecting after that your test will be
25:35 - exited so let me just clear the terminal
25:37 - once again and let me show you one more
25:40 - option so this time I want to show you
25:43 - the Skip option so let's say I just
25:46 - remove all these markers from here and
25:49 - and now I want to add a mark which is
25:53 - skip so just add this decorator on top
25:56 - of your test which is at the rate test
25:59 - dot mark dot skip and then inside the
26:03 - parenthesis you can give the reason for
26:06 - the skip so here you can just write
26:09 - reason equals and whatever reason you
26:13 - want to give here so I'm going to just
26:14 - write do not run number add test ok so
26:19 - this is the reason which will be printed
26:21 - and when I will just execute my test
26:25 - once again with - V you can see this
26:29 - first test is kept so it's not executed
26:32 - it skipped and all the other three tests
26:35 - were executed let me just fix this
26:38 - second test so it's going to pass and
26:41 - once again let me
26:43 - run this test and you can see all other
26:47 - tests were passed and the first test is
26:50 - skipped because we have added this skip
26:53 - decorator on top of the test ad function
27:01 - also there is a skip if option available
27:05 - so here instead of skip you can just
27:08 - write skip if so this skip if is going
27:12 - to check for some condition so let's say
27:15 - I'm going to import the sis module here
27:20 - which is going to give me the
27:22 - information about the Python version I'm
27:24 - running and then as a first argument I
27:27 - can
27:27 - first of all give some conditions so I'm
27:30 - going to just write sis dot version info
27:33 - which is going to give me the version of
27:35 - Python available and I'm going to check
27:37 - if this version is less than let's say
27:41 - 3.3 then I want to skip this test so I'm
27:45 - going to once again let me clear the
27:47 - terminal and once again run the test and
27:50 - I see some failure here which is here I
27:54 - added dot instead of comma so you need
27:58 - to separate this major and minor version
28:00 - using comma so this means 3.3 Python
28:05 - version and once again I'm going to run
28:07 - the test and then press ENTER and now
28:09 - you can see all four tests were executed
28:12 - because this condition was not matte
28:16 - now let's say I want to just give the
28:19 - opposite condition of that which means I
28:22 - want to skip if I have the Python
28:25 - version greater than 3.3 which I have I
28:28 - have the python version 3.7 let's check
28:32 - it using Python command so I'm going to
28:35 - just write Python - - version and then
28:39 - press Enter
28:40 - and you can see I have 3.7.0 version and
28:43 - let's run the test once again and now
28:46 - you can see this test is skipped because
28:49 - this condition is met now the next
28:53 - option I want to show here is - as
28:55 - options so let me just make
28:57 - this condition like this so this test
29:00 - will not be skipped and the next option
29:02 - we are going to see is the hyphen s
29:05 - option so let me clear the terminal and
29:08 - let's see which option I am talking
29:11 - about which is - s and this option you
29:15 - can use to print any output which you
29:18 - want to print using let's say print
29:21 - function so let's say I want to add a
29:24 - print statement here so I'm going to
29:27 - just add print and then let's say I want
29:30 - to just print the addition of seven and
29:35 - three and four
29:37 - just knowing whether this print
29:39 - statement has been executed I'm going to
29:42 - add this string here so we know that
29:45 - this print statement has been executed
29:47 - so now when I execute my PI test without
29:50 - the hyphen s option first you will see
29:54 - there is no print statement which is
29:56 - executed now if I just add - s here
30:00 - which will allow this print statement to
30:03 - be executed and now you will see that
30:07 - this print statement has been executed
30:09 - and this line is printed using this
30:13 - print statement so if you want to print
30:16 - all the print statements then use hyphen
30:19 - s option or you can also use the option
30:23 - which is - - capture is equal to no and
30:27 - then press ENTER which is also going to
30:29 - do the same so either you can use hyphen
30:33 - s or you can use - - capture is equal to
30:37 - no so let me clear this terminal one
30:40 - last time and the last option which I
30:42 - want to show here is the - queue option
30:46 - which is the white mode so let me just
30:49 - execute this by test once again and you
30:52 - can see all this information is printed
30:54 - and when I add - queue here which is the
30:58 - quiet mode you can see no information is
31:02 - printed here about the test which test
31:05 - is passed only the important information
31:08 - is printed which is for test passed in
31:10 - this
31:10 - amount of seconds if I remove the - V
31:14 - here from here you will see all the
31:17 - other output is gone and only four
31:19 - passed in whatever amount of seconds is
31:22 - printed so this is the quiet mode which
31:25 - will not print unnecessary information
31:27 - it's going to just show you how many
31:29 - tests passed and how many tests failed
31:33 - so this is how you can use some options
31:35 - with PI test command in this video I'm
31:38 - going to show you how to use a special
31:40 - decorator which is parameterize so here
31:44 - I have on the left hand side a simple
31:47 - function which is add and on the right
31:50 - hand side I have written that test for
31:52 - this function and I have written three
31:55 - test function for the add function the
31:59 - first test function here tests the add
32:02 - function using the integer values the
32:06 - second test function I have written for
32:08 - the string values and the third test
32:11 - function I have written for the float
32:14 - values which I provided to the add
32:17 - function now one thing which you will
32:20 - notice here is I'm using the same add
32:23 - function three times here in all these
32:27 - three tests and there has to be a better
32:30 - way in which we just need to call this
32:33 - add function only once now you can say
32:37 - that why we need three functions I can
32:40 - just write three assert into the same
32:44 - function and I can just remove these two
32:47 - other test functions this is okay but
32:49 - still I have to call this add function
32:52 - three times to test it with numbers
32:55 - strings and the float values and in
32:59 - those type of situations you can use a
33:02 - special decorator which is parameterize
33:04 - in which you need to call a same
33:07 - function to test it with the different
33:11 - type of values so here I have imported
33:14 - this PI test module and then above my
33:19 - test function I will just call PI tests
33:22 - first of all that
33:24 - dot mark dot parameterize so we are
33:28 - testing this ad function which takes two
33:30 - arguments so here in the parameter rise
33:33 - we just need to give the name of these
33:37 - two arguments you can just say that
33:40 - these two arguments will be X comma Y
33:43 - because I have given X comma Y here so I
33:46 - can just write into the single quotes X
33:48 - and then single quotes Y which will be
33:52 - the name of these two arguments so this
33:56 - name depends upon you you can say this
33:59 - is num1 and the y is let's say num2 or
34:06 - you can say this is r1 or r2 so these
34:10 - arguments names are user defined names
34:13 - you can give any names which you want to
34:16 - pass to your function so the number one
34:20 - variable name will be passed as the
34:23 - first argument and the number two
34:25 - variable name will be passed as the
34:27 - second argument now once again when you
34:29 - look closely to this assert you will see
34:33 - the variable values here our first
34:36 - argument second argument and the result
34:38 - so the same three values you need to
34:41 - give here so number one number two and
34:44 - the result so I'm going to just say that
34:46 - the third argument is result here and
34:50 - then as the fourth argument you give
34:52 - that iterate able list so the fourth
34:55 - argument will be a it ratable list where
34:59 - you can provide the values of argument 1
35:03 - argument 2 and the result so inside this
35:07 - list we are going to give this argument
35:10 - 1 2 and the result values using a tuple
35:14 - so here in the first test I have given 7
35:18 - and 3 and the result is 10 we can give
35:21 - the same values here so 7 comma 3 and
35:25 - the result we are expecting is 10 so the
35:29 - 7 will be passed to the number one
35:32 - argument 3 will be passed to the number
35:35 - 2 argument and
35:36 - then we'll be passed to the result in a
35:39 - same way we can define multiple couple
35:41 - values here so the second test is for
35:44 - the string values so the first argument
35:48 - is hello second argument is world and
35:51 - the expected value is this one which is
35:55 - result and the third test case or test
36:00 - scenario is ten point five for the
36:03 - floating values comma twenty five point
36:06 - five and the expected value is 36 now
36:11 - once you have defined this parameterize
36:13 - decorator you don't need to call this
36:16 - add function multiple times what you
36:19 - need is you just need to define the same
36:22 - variable names which you have defined
36:24 - here in the parameterize so the first
36:28 - argument will be num1 the second
36:31 - argument will be num2 and the third
36:34 - argument will be the result and then you
36:39 - just need to pass these values to the
36:42 - add function so the first number is the
36:44 - first argument the num2 is the second
36:47 - argument and the result is the third
36:50 - argument now what's going to happen when
36:53 - you run the test is this list which you
36:56 - have given here will be iterated over by
37:00 - your parameterize function and these
37:03 - values one by one will be assigned to
37:06 - number one number two and the result and
37:09 - the same value will be passed here as
37:13 - the first argument and the second
37:15 - argument and as the result for this
37:19 - assert statement and one last thing
37:22 - which I'm doing wrong here is I think
37:24 - you need to give these arguments name as
37:29 - the string separated by commas so you
37:33 - just need to give the string separated
37:35 - by these commas so the first argument of
37:38 - this parameter is a string in which you
37:41 - define the arguments which are taken by
37:44 - your function to test so num1 and num2
37:47 - and the result
37:49 - and these arguments are separated by
37:52 - commas and all these values are inside
37:56 - the string so this thing you need to
37:58 - keep in mind that this is a one argument
38:01 - string and inside the string you define
38:04 - those values separated by comma so let's
38:07 - run the code and let's see what happens
38:09 - so you can see now that three tests were
38:13 - run and this first test was with the
38:17 - value 7 and 3 and the expected result
38:21 - was 10 and it passed second you will
38:25 - also see which arguments were passed so
38:27 - in the second test hello and world were
38:30 - passed and the expected result was hello
38:33 - world and in the third test case ten
38:35 - point five and twenty five point five
38:37 - was passed as the arguments and the
38:41 - expected result was 36 so by using this
38:45 - parameterize decorator you can just use
38:49 - or call your function which you want to
38:51 - test once and then pass different type
38:55 - of parameters into it using this
38:58 - parameterize decorator so that hey guys
39:02 - welcome to the next video on Python unit
39:04 - testing too tall for beginners using PI
39:05 - tests in this video I'm going to show
39:08 - you how to use fixtures with PI tests so
39:11 - let's get started so to start with on
39:14 - the left hand side I have this student
39:17 - DB tell us now as you can see here in
39:20 - the init method I am just initializing a
39:22 - member variable which is data is equal
39:25 - to none and then it has two methods one
39:29 - is connect method and other is get data
39:32 - method now this connect method takes one
39:35 - argument which is data file now if you
39:38 - can see on the right hand side I have
39:41 - written two tests for this student DB
39:45 - and I have first of all imported this
39:49 - class and then I have initialized this
39:52 - class student DB and then I'm calling
39:54 - the connect method here now in the
39:58 - connect method argument I'm giving it
40:00 - this data dot JSON
40:03 - as an argument so let me show you what
40:06 - this data dot jason contains so this
40:10 - data dot jason contains the data of the
40:13 - student so it has this element called
40:16 - students which contains this array which
40:20 - contains different data about different
40:23 - students so right now i have two student
40:27 - data here one is ID one scott pass and
40:32 - other is ID to mark and fail
40:35 - so using this connect method i am just
40:38 - opening this data dot JSON file and then
40:42 - I'm just loading this JSON file as the
40:47 - dictionary so as you can see here I'm
40:50 - using the JSON module which I have
40:52 - imported at the top and whenever I call
40:55 - Jason dot load it's going to convert
40:57 - this JSON dot file into the dictionary
41:01 - and then I have this method called get
41:03 - data which takes one argument which is
41:06 - the name of the student now this name
41:09 - I'm going to search in the dictionary
41:11 - which I got using the connect method and
41:15 - if this name which is provided as an
41:18 - argument is contained in the students
41:21 - data then I'm going to just return this
41:25 - student dictionary so once again as you
41:28 - can see here I'm just importing the
41:30 - student dot DB class and then I'm just
41:33 - initializing the student DB and then I'm
41:36 - just calling the method called connect
41:39 - and in the connect method I'm giving the
41:41 - data dot jason as an argument which is
41:44 - this file which contains the student
41:46 - data and in the next step i am just
41:49 - calling the get data method from the
41:53 - student DB class and i'm giving the name
41:56 - of the students here so you can see the
41:59 - name of the student is caught that's why
42:02 - I am giving Scott here and in the next
42:04 - test I am giving the mark name which is
42:06 - the second name here and then using
42:09 - these assert statement I am just
42:11 - checking whether this ID which I got
42:15 - using the Scott date
42:17 - is equal to the ID which is there in the
42:21 - JSON file or not same assert I have
42:24 - written for the students name and the
42:26 - students result and similar tests I have
42:30 - written for the second name or second
42:34 - student which is mark now as you have
42:37 - already seen to make things simpler I
42:40 - have just used this JSON file as the
42:44 - database file but in real-life
42:47 - situations you might be having some
42:49 - other databases like MySQL or PostgreSQL
42:52 - or MongoDB or any other database and you
42:56 - might want to test your database so the
42:58 - same approach you can use whenever you
43:01 - are trying to use the real database so
43:05 - let's first of all run these tests and
43:07 - let's see what's the result here so I'm
43:10 - going to just run these tests and you
43:12 - can see both tests passed here now let's
43:15 - talk about the problems with these two
43:18 - test cases now you might have already
43:21 - guessed that we are repeating ourselves
43:24 - so we are initializing this database
43:26 - twice for the two tests but let's say we
43:30 - have thousands and thousands of tests
43:33 - then you have to initialize this
43:35 - database thousand times so the first
43:38 - problem is the code repetition the
43:41 - second problem is whenever you want to
43:44 - initialize your database for example
43:46 - thousand time these initializations are
43:49 - resource intensive so they will be
43:52 - costlier to your system on which you are
43:55 - running these test cases because they
43:58 - are consuming your resources so what can
44:02 - be the solution here so you can use two
44:04 - type of solutions in these type of cases
44:07 - the first approach is by using the setup
44:11 - and teardown methods now this setup and
44:14 - teardown method falls into the category
44:17 - of classic xunit style setup if you are
44:21 - familiar with other testing frameworks
44:24 - like unit tests or knows these methods
44:28 - might be family
44:30 - to you so first of all we will see how
44:33 - to solve this problem using the setup
44:35 - and teardown methods and then we will
44:39 - see how to solve this problem using PI
44:41 - test fixtures so we already know the
44:45 - problem so to solve this there is a
44:48 - method called a setup and the teardown
44:51 - module method so I'm going to just write
44:54 - setup underscore module and this takes
44:59 - one argument which is module and then
45:03 - here inside this method you can
45:06 - initialize your resources so let me
45:09 - define a global DB variable and I'm
45:14 - going to initialize it with none and
45:16 - then I'm going to just use this
45:20 - initialization inside this setup module
45:23 - so whenever you write the setup module
45:26 - as it is then PI test is going to
45:28 - understand that this is a setup method
45:32 - and it's going to execute this code
45:35 - before executing your tests so what I
45:38 - have done is I have defined the global
45:40 - DB variable that means I need to
45:44 - indicate inside the setup method that
45:47 - this is the global variable and that
45:50 - means now inside this DB we have our
45:54 - database instance so we don't need this
45:57 - initialization in these two test cases
46:00 - now and now we can use this DB instance
46:03 - to call the get data method to get the
46:06 - data about particular student so this is
46:10 - the setup module method there is also a
46:12 - teardown method which we can define here
46:15 - so just write the EF teardown underscore
46:18 - module and then inside the parentheses
46:22 - you give the module as an argument and
46:25 - inside the staredown module you can
46:28 - close your connections or free your
46:31 - resources whatever you want to do after
46:33 - your test you can do in that teardown
46:37 - module so I don't have any closed method
46:40 - inside this database class
46:43 - so let me create some dummy clothes
46:46 - method here so I'm going to just say
46:49 - deaf clothes and then I'm going to just
46:54 - use pass here so it's just a blank
46:57 - method and let me just provide the
47:00 - parentheses here so let's say we want to
47:02 - use this clothes method to free our
47:04 - resources or close the connection with
47:06 - the database you can do this by just
47:09 - calling this method so DB dot close and
47:12 - this is going to free your resources and
47:15 - let's just print something yes so we
47:19 - know that these two methods are called
47:22 - so here I'm going to just say that this
47:26 - is a setup method and then inside the
47:31 - teardown module method we are going to
47:34 - just replace this set up by teardown so
47:37 - we know that when this set up method is
47:40 - called and when this teardown method is
47:43 - called so once again this setup module
47:46 - and teardown module will be recognized
47:49 - automatically by your PI test and then
47:52 - this code will be called at the starting
47:55 - of your PI tests and this code will be
47:58 - called at the end after all your tests
48:01 - have been passed or failed then this
48:04 - teardown module test will be called so
48:07 - let's run the test once again and you
48:10 - will be able to see that this setup
48:13 - method is called first and after the
48:16 - execution of the tests this teardown
48:19 - method is called and we can recognize it
48:22 - by using this print statement now if you
48:25 - haven't already recognized I have used
48:27 - this - s or hyphen s option to allow the
48:31 - print method to execute this print
48:33 - statements so if you want to allow your
48:36 - print statements to be printed on the
48:39 - console you need to use this - s flag to
48:44 - be more clear I'm going to just remove
48:46 - the - B from here so it will be more
48:49 - clear so you can see it's setup is
48:51 - called first and then you will see two
48:54 - dots here which means two tests has
48:57 - being executed and at the end the
49:00 - staredown method has been called to free
49:02 - any of the resources which you might
49:04 - want to free or close that connection
49:06 - with the database so this is called the
49:09 - setup and teardown method now let's talk
49:12 - about the Python fixtures so instead of
49:16 - using the setup and teardown methods PI
49:19 - test allows us to write the Python
49:22 - fixtures which will automatically be
49:25 - called at the starting and the end of
49:28 - your tests so instead of writing all
49:31 - this code what I can do here is I have
49:34 - first of all imported this PI test and
49:36 - then I'm going to define a method which
49:40 - I will call a DB because as you can see
49:43 - here all these tests are just using that
49:47 - DB instance so we want to somehow pass
49:50 - this DB instance to our tests and then
49:54 - I'm going to provide these parentheses
49:55 - and inside this method I want to do the
49:57 - same so I will just call this setup code
50:00 - here and let me just remove all this
50:05 - code from here and at the end what I
50:08 - want to do here is I want to just return
50:09 - this DB instance which I got from the
50:13 - student DB class I don't need this
50:16 - global declaration here because there is
50:19 - no global variable and for now let's
50:22 - just comment this code so to declare a
50:24 - fixture you just need to add this
50:27 - decorator at the top of your method
50:31 - which is PI test dot fixture and now
50:34 - what I want to do here is I want to pass
50:36 - this DB instance as an argument of both
50:40 - these test cases so now what will happen
50:42 - is PI tests will recognize that this is
50:46 - your fixture and then whatever you
50:49 - returned from your fixture will be
50:52 - passed using this argument to your test
50:55 - cases so let's run our test and let's
50:58 - see what will happen when we run those
51:02 - tests so you can see both these tests
51:05 - has been passed but you will also
51:07 - observe one more thing and
51:10 - is that this setup is called twice which
51:13 - is a problem as we have discussed we
51:16 - don't want to call this setup twice we
51:18 - just want to call this setup at the
51:21 - beginning of our tests so how to solve
51:24 - this problem so to solve this problem we
51:26 - can tell PI test that this is a module
51:29 - wide fixture so we just want to call
51:32 - this fixture once at the starting so to
51:36 - do this we just need to write scope is
51:39 - equal to and then just write module here
51:43 - and then we are going to just run our
51:46 - test once again let's see what happens
51:48 - so now you can see the setup is called
51:51 - only once and that's what we wanted
51:55 - right
51:55 - we just wanted to call this setup at the
51:58 - beginning of our test and not at the
52:01 - beginning of each of the tests now let's
52:04 - see how we can add the teardown
52:06 - functionality so I'm going to just use
52:09 - this code after this return and then I'm
52:13 - going to uncomment this code and then
52:17 - let's remove this commented code and to
52:20 - call this teardown code which is written
52:23 - here at the end of your tests what you
52:26 - can do here is you can replace this
52:29 - return by yield so when your test will
52:32 - start it's going to execute the code
52:34 - until yield and at the end of your test
52:38 - this code will be executed so let's see
52:42 - what will happen when we run the code
52:44 - once again so let's just call the PI
52:48 - test once again and you can see setup
52:51 - has been called and at the end of your
52:53 - tests teardown has been called so let me
52:58 - just clear the terminal and let's run
53:00 - this PI test command once again without
53:03 - - vivo burst so we will be more clear
53:07 - and you can see first of all setup has
53:09 - been called and then your test has been
53:12 - executed which are indicated by these
53:14 - two dots and after your tests this
53:17 - teardown code has been executed so this
53:20 - is how you can use fixtures and setup
53:23 - and
53:24 - gear down methods with your PI test test
53:27 - cases hey guys welcome to the next video
53:30 - on Python unit testing tutorial for
53:32 - beginners using PI test now in this
53:35 - video I'm going to show you how you can
53:38 - run your tests which you have written
53:40 - using PI test
53:42 - inside your PyCharm ide so till now we
53:47 - have been running our tests which we
53:50 - have written using pi test on the
53:52 - command prompt or the terminal but using
53:55 - PyCharm ide also we can run these tests
53:59 - inside the PyCharm ide so let's see how
54:03 - we can run those tests which we have
54:06 - written using pi test using the PyCharm
54:10 - ide so as you can see here on the left
54:13 - hand side i have a class and on the
54:16 - right hand side i have written some
54:19 - tests which are related to this class
54:22 - now I want to run these tests which I
54:26 - have written here using the PI test
54:29 - inside the pycharm ide so for doing this
54:33 - what I need to do is first of all I need
54:36 - to install PI test package inside the
54:40 - pycharm ide so you can see here when I
54:43 - try to import PI test inside the PyCharm
54:47 - ide first of all it will give me this
54:50 - red squiggly line which means that PI
54:53 - charm is not recognizing this pi test
54:56 - package till now so let's first of all
54:59 - install this package so just click on
55:02 - file and then click on settings and then
55:05 - go to the section which says project and
55:09 - then your project names so project colon
55:12 - project name so I'm going to click on
55:14 - this and then go to the project
55:17 - interpreter now as you can see here
55:19 - there are some packages which are
55:21 - already here and we want to install a
55:24 - new package which is PI test so I'm
55:27 - going to click on this install or this
55:30 - plus icon here and then I will just
55:33 - search for PI test and
55:36 - first option you will see here is PI
55:38 - test and you can see this will be the
55:41 - version which will be installed on our
55:43 - PyCharm ide so what I'm going to do is
55:46 - I'm going to just click on this button
55:49 - let me just move it a little bit above
55:51 - so you can see this button so I'm going
55:54 - to click on this install package button
55:56 - which is going to install PI test
55:58 - package inside my PyCharm ide and once
56:02 - this pi test package is installed you
56:04 - will see this message which says package
56:07 - PI test installed successfully with the
56:09 - green highlighted text that means PI
56:13 - test is installed so you can close this
56:16 - windows I'm going to close this window
56:17 - and you will be able to see this pi test
56:20 - now is added to your project interpreter
56:24 - so now when I click on OK and I will
56:29 - wait for some time till this process is
56:32 - has been finished and then after some
56:35 - time you will see this red squiggly line
56:37 - under this PI test is gone so now our
56:41 - pycharm ide recognizes this pi test
56:44 - package and now we want to tell the PI
56:46 - CIAM ide that we want to run the pi
56:49 - tests so for doing that once again i
56:53 - will click on file and then go to the
56:56 - settings and then this time i will go to
56:58 - that tools so just click on Tools option
57:01 - and when you scroll down you will be
57:04 - able to see this option which says
57:06 - python integrated tools so just click on
57:10 - this and on the right hand side you will
57:13 - be able to see under testing that
57:15 - default test Runner by default is unit
57:18 - tests so we need to change this to PI
57:21 - test ok
57:23 - so just change this default test Runner
57:26 - to PI test and then apply and then click
57:29 - OK which is going to tell pycharm IDE
57:33 - that we want to run the PI tests now as
57:37 - soon as you are finished with the
57:39 - setting of pi test on your PI charm IDE
57:42 - what you can do now is you can right
57:45 - click on the file where you want to run
57:49 - PI test so this
57:50 - my tests underscore Matt underscore funk
57:53 - dot py file where all my tests are there
57:58 - so just right click on this file and
58:00 - then you will be able to see this option
58:02 - which says run PI test in the file you
58:05 - want to run the PI test so just click on
58:08 - this option which says run PI test in
58:10 - the file and as soon as you do this you
58:14 - will be able to see this window which is
58:17 - for the PI test and you will be able to
58:20 - see all the tests which have been passed
58:22 - on the left-hand side and the terminal
58:27 - output on the right-hand side so let me
58:30 - just maximize this window here and on
58:33 - the right-hand side you will be able to
58:35 - see the output so we have run the test
58:39 - on this file and because I have some
58:42 - output which is a print output as you
58:44 - can see here print statement here which
58:48 - is responsible for printing this line
58:51 - and also I have this print statement for
58:54 - teardown so this teardown is printed
58:58 - using this print statement also you will
59:01 - be able to see two dots here which means
59:02 - we have a two tests inside this file
59:06 - which ran successfully so let's add this
59:10 - verbose flag inside our PI tests using
59:14 - PyCharm ide so once you ran your a pi
59:18 - test using PyCharm ide you will be able
59:21 - to see this drop down menu here it says
59:24 - pi test in whatever file you are running
59:28 - your PI test on and just click on this
59:31 - file you will be able to see this added
59:33 - configuration option right away after
59:37 - first run of your test so just click on
59:41 - this option which says added
59:43 - configuration and then you can add the
59:46 - arguments which are additional arguments
59:49 - like verbose or - s or whatever option
59:53 - you want to provide here using this
59:55 - additional arguments option so let's say
59:58 - I want to provide this - V option which
60:02 - is for mobiles
60:03 - and then I will say apply and then I
60:06 - will say okay and then I'm going to run
60:09 - that test once again either clicking on
60:12 - this button or right away from this
60:15 - button so let me click on this button
60:17 - and once you ran your test you will be
60:20 - able to see the verbose output on the
60:23 - right hand side let me just remove these
60:26 - print statements because they are just
60:29 - not looking good on the tests so I'm
60:32 - going to just remove the setup and
60:35 - teardown print statements from here and
60:38 - I'm going to run the tests once again
60:40 - and then you will be able to see the
60:43 - correct verbose output here now if you
60:46 - want to see all these tests which are
60:48 - passed or failed on the left hand side
60:51 - using these green or red circles then
60:54 - you can click on this green circle at
60:57 - the top here so once click on this green
61:00 - circle and you will be able to see the
61:03 - list of all tests which are there inside
61:06 - your file so this is the script name
61:09 - which is test underscore math underscore
61:11 - func and these are the two tests which
61:14 - are there inside this test script so you
61:18 - can see the first test is test core data
61:21 - which is this one and the second test is
61:23 - test mark data which is the second test
61:26 - here you can also run these tests
61:29 - individually so you can right click and
61:31 - then you can just say run test which is
61:34 - going to run only one test which you
61:37 - want to run them so once you ran this
61:40 - only one test you will be able to see on
61:42 - the top that only this tests has been
61:46 - running so in order to run the whole
61:49 - Python script for the test you can once
61:52 - again select this option which is PI
61:55 - test in whatever test script you have so
61:59 - just choose that and then run it once
62:01 - again it will run your all the tests
62:04 - once again and you will be able to see
62:06 - all the tests here so in order to run
62:09 - individual tests you can just right
62:11 - click and then run those tests but
62:13 - remember that you need to change this
62:16 - option
62:17 - from here also if you want to run the
62:19 - test by just hovering over the test so
62:22 - this is the test let's say I want to run
62:24 - only this test so you can just hover
62:26 - over this test and then right click and
62:29 - then just click on this option run by
62:33 - test for this test which is going to run
62:36 - only that test once again I'm going to
62:39 - select this option for the whole file
62:41 - which is going to run all the tests once
62:43 - again for the PI test using PyCharm ide
62:48 - so this is how you can run your tests
62:50 - which you have written using PI tests
62:52 - using PI charm