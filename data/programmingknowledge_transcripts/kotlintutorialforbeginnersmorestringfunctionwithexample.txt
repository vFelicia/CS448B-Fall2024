00:00 - in the previous video we were discussing
00:02 - about string functions and in this video
00:04 - we are going to continue with the
00:06 - discussion
00:07 - okay so uh in the previous video we have
00:09 - discussed about the
00:11 - uh
00:12 - the
00:14 - the length function the get index
00:15 - function the subsequence function and
00:17 - the compare to function okay
00:19 - so
00:20 - in
00:22 - i think
00:23 - that should be clear to you
00:26 - okay so
00:27 - now next is the equals function so the
00:31 - equal function it indicates whether some
00:34 - object is equal to the other object or
00:37 - not okay
00:39 - so
00:41 - it is just like the comparison operator
00:43 - equals to equals to okay
00:45 - so
00:46 - what i'll do is i'll just
00:51 - okay so you can guess the written type
00:53 - of the
00:54 - the function is boolean okay because it
00:57 - returns that whether it is equal to or
00:59 - not
01:00 - so when i
01:01 - uh
01:02 - say a
01:04 - equals to equals okay so it is equals
01:09 - and i say b
01:13 - b
01:15 - and
01:16 - when i
01:19 - when i
01:20 - run this
01:22 - so you can guess the output the output
01:24 - is
01:26 - false
01:27 - because they are not equal
01:40 - okay so as you can see here the output
01:42 - is false
01:43 - because they are not equal and when i do
01:47 - c nd
01:50 - c
01:52 - and i compare it with d
01:54 - and again when i
01:56 - run the program
01:59 - now the output must be true because they
02:02 - are equal
02:03 - ok
02:04 - no it is false why it is false
02:09 - okay
02:10 - so i have done some
02:11 - mistake i have to compare
02:15 - c with f okay sorry
02:21 - so yeah when i compared c with d the
02:23 - data type is only not same
02:26 - one is string and other isn't so there
02:28 - is no chance of
02:29 - them being equal so it is true now what
02:32 - happens when i uh
02:34 - change one index
02:36 - in the string
02:41 - so you can see the output is false so it
02:43 - is only true when both string are equal
02:46 - in each and every manner possible now it
02:49 - is having some suggestion now we will go
02:51 - to it and plus press alt plus enter it
02:54 - is suggesting that we should replace it
02:56 - with equals to equals to sign as i
02:58 - already mentioned that it is nothing but
03:01 - the comparison operator equal to equal
03:02 - to okay moving on to hash code
03:06 - the hash code returns a hash code value
03:09 - for the object okay so you might be
03:11 - wondering what uh what the hashcode is
03:14 - i'll suggest just go to the google type
03:16 - hashcode of a string and you will get to
03:19 - know
03:20 - okay so
03:21 - i want the hash code of
03:25 - let's say
03:26 - string
03:28 - c
03:29 - so
03:30 - so i'll just type c dot
03:32 - core
03:33 - okay and when i run this program i'll
03:35 - get the hash code for c string
03:39 - so as you can see in the output screen
03:41 - the hash code for c string is this okay
03:44 - then as let's say i want hash code for
03:47 - all the strings possible
03:49 - okay so i'll just
03:51 - mention all the strings
03:54 - a b c and f we have four strings
03:59 - a
04:02 - b
04:03 - c
04:04 - and
04:05 - [Music]
04:07 - f okay
04:09 - so when i run this program
04:19 - it gives the hash code for
04:22 - all these string
04:23 - now if you note
04:27 - that these two values are negative and
04:29 - these two values are positive so why is
04:31 - that the hash code could be positive
04:33 - negative or any value
04:35 - okay it's just a representation
04:38 - okay so
04:39 - now next is the plus operator plus
04:41 - function
04:42 - so what the plus function does is
04:46 - okay when i use the plus function
04:50 - let's say
04:52 - i have
04:53 - print ln
04:56 - a
04:57 - plus
04:59 - b
05:00 - now
05:01 - the a plus b is another string
05:05 - okay
05:06 - so i can
05:08 - make another function used on this
05:11 - string also so i can use the plus
05:13 - function again also
05:15 - okay
05:15 - and
05:17 - it's the plus function is not restricted
05:19 - to string only so i can use the plus
05:22 - function and use any data type you can i
05:24 - can use here d also
05:26 - okay so when i
05:28 - run this program
05:30 - so you can see the addition of all this
05:33 - a b c
05:34 - and d
05:37 - so it gives like hello this is a coder
05:41 - and my age is 19. okay so what there is
05:44 - a mistake that there is no space given
05:47 - because i have not given any spaces here
05:50 - here or here if i give spaces here then
05:53 - it would be a perfect code
05:56 - so
05:57 - that was all about the plus function now
05:59 - instead of using dot plus i can also do
06:02 - that
06:03 - i just
06:05 - i can just do a plus b
06:08 - plus
06:10 - c
06:11 - okay
06:13 - and when i run this program
06:16 - i can find
06:18 - that it gives hello this is a coder and
06:21 - my edge now this is string con
06:24 - concatenation okay
06:26 - it it is nothing but uh it just
06:29 - contained the string it means that it
06:33 - puts three two or three string or many
06:34 - string together and make it a new string
06:38 - okay so plus function returns a string
06:40 - obtained by concat concatenating the
06:43 - string with the string representation of
06:45 - the given other object okay
06:48 - so that was all about the plus function
06:50 - next is the two string function so we
06:52 - have already uh
06:54 - talked about the the two string or two
06:56 - end or two all the data type conversion
06:59 - function so it is nothing but suppose i
07:01 - have a
07:04 - i have a
07:07 - integer
07:11 - that has a value that is a phone number
07:14 - okay
07:16 - so
07:18 - okay okay a is already defined
07:21 - i'll just give it name as phone
07:24 - okay so i want to store this in a string
07:28 - so what i can do is i can just
07:30 - write phone and then
07:33 - dot tostring
07:36 - to string
07:39 - so what it does is it
07:41 - converts the phone
07:43 - this into a string
07:45 - so when i print this when i go ahead and
07:50 - print
07:51 - this
07:52 - [Music]
07:53 - then
07:54 - you can expect the result it is a string
07:57 - so you you can see nothing in the result
07:59 - the result would be same the output is
08:01 - just the number itself but it is a
08:04 - string
08:05 - okay so two string function
08:07 - uh
08:08 - returns a string representation of any
08:10 - object okay then there is last index
08:13 - function the last index function returns
08:15 - the index of the last character
08:18 - in the
08:19 - character sequence and minus one if it
08:21 - is empty so i have here like
08:25 - like i in these two string i'll try c
08:28 - and f
08:29 - so what i'll do is
08:32 - i'll just
08:33 - go to the end and yeah so i'll print the
08:38 - last index of c first okay so i'll just
08:41 - type c dot
08:43 - last index
08:46 - okay and i'll also print the
08:50 - last index of
08:51 - f
08:55 - and now i'll run this program meanwhile
08:57 - i'll go to the c and f
08:59 - strings
09:00 - [Music]
09:01 - now
09:02 - as we can see in the output the
09:06 - first one is 13 and the second one is 12
09:09 - so
09:10 - the last index which is this
09:14 - so
09:15 - this is 0 then 1 2 3 4 5 6 7 8 9 10 11
09:20 - 12 and 13 so the index of the last
09:23 - character is 13 in this string and the
09:26 - index of last character is 12 in this
09:28 - string
09:29 - f
09:30 - so it just returns the
09:32 - index of the last character okay so
09:37 - now you must have no doubt in
09:39 - the
09:41 - last index
09:43 - function okay the next is index of
09:45 - function
09:47 - so the index of function returns the
09:49 - index within its string of first
09:52 - occurrence occurrence of a specified
09:53 - character starting from the specified
09:56 - start index
09:58 - okay so index of
10:00 - function has three parameters basically
10:04 - the first is the string
10:05 - so that is a b or c whichever string i
10:07 - am providing it second is the start
10:10 - index okay so from which index i should
10:12 - be looking for the character
10:15 - so suppose i will just explain it and
10:17 - third is the ignore case uh just ignore
10:20 - that so it is just telling the uh
10:22 - it should be false okay so
10:25 - uh
10:26 - okay it is a boolean you know case is
10:28 - brilliant so the basically what is in
10:31 - index of so i i'll say that index of i
10:36 - and
10:36 - string in string b
10:39 - okay
10:41 - and starting start index is 0 so it will
10:44 - give the third eye
10:47 - okay and when i'll
10:48 - give the start index of three value
10:52 - three so it will give me this i okay so
10:55 - i'll just go ahead and
10:56 - use the function
10:58 - so i'll print
11:03 - in string
11:04 - b i can do
11:07 - what was that
11:10 - index of
11:13 - okay and now i'll mention the character
11:15 - which uh which are of which index i am
11:17 - finding so i'll mention the character as
11:19 - i
11:20 - okay and then i'll mention the uh
11:24 - start index okay so
11:26 - note that it is giving a red i in red so
11:30 - why is that because i i haven't
11:32 - mentioned the character in single quote
11:34 - okay so i should
11:36 - only mention the character or character
11:38 - in single code and string in double
11:40 - quotes okay so then i'll mention the
11:44 - string
11:45 - start index so i'll mention the start
11:46 - index at zero at first and the ignore
11:49 - case as false
11:51 - okay
11:52 - so now i now i'll go ahead and run this
11:54 - program
11:56 - so the output of this is
11:59 - 2
12:00 - so i'll go to the b string and
12:03 - so at
12:05 - 0 1 2 at index 2 there is an i
12:08 - ok so now what if i start with an index
12:11 - three and see what is the output okay
12:15 - i'll start with index three
12:18 - and run this program
12:19 - so i can see in the output
12:22 - that
12:24 - the result is the output is five so i
12:28 - started with this this index and this is
12:31 - the
12:32 - third index then fourth index is empty
12:34 - and then fifth index is has an i
12:36 - so the answer is
12:39 - the i is at the fifth index starting
12:42 - from the third index okay so it just
12:44 - found the first i from the start index
12:46 - and ignore the rest of it so i'll just
12:49 - find d
12:51 - from any index okay
12:52 - so
12:53 - finding d from n index doesn't change
12:56 - anything okay
12:57 - because d is only mentioned one time it
13:00 - it matters when d is uh when the start
13:03 - index is after 11 okay
13:06 - after 12 because d is at the 12th index
13:10 - so the index of just gives the index of
13:13 - the mentioned character from any index
13:16 - okay so i hope all the functions should
13:19 - be clear to you by now okay
13:22 - so thank you for watching this video in
13:24 - the next video we will be covering
13:26 - functions
13:27 - thank you