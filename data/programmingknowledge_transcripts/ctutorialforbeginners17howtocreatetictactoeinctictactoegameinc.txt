00:00 - hey guys welcome to programming
00:01 - knowledge in this video we'll be making
00:04 - our first programming project which is
00:07 - essentially going to be a console based
00:09 - tic-tac-toe game so in case you're not
00:11 - familiar with the game let me just
00:13 - quickly walk you through the game the
00:15 - game has a 3 cross 3 port and two
00:17 - players who play alternatively so the
00:20 - objective of the players is that they
00:23 - need to fill one of the rows or columns
00:26 - or the diagonals with the marker so if I
00:28 - just start the game with a computer you
00:30 - can see that we are playing
00:31 - alternatively and our goal is to just
00:34 - fill up one of the rows or columns or
00:37 - diagonals with our marker so here if you
00:39 - see the computer has managed to fill the
00:41 - room with its marker so it gets to win
00:44 - the game so we are going to implement
00:46 - this game on the console and well we
00:49 - won't be implementing such a
00:50 - sophisticated system where the computer
00:52 - can play although I will be giving the
00:54 - intuition required for building such a
00:57 - system towards the end but what we'll be
00:59 - implementing is a two-player game so if
01:02 - you go over here and then change this
01:03 - mode to play against a friend you can
01:06 - see that you make both the moves by
01:08 - yourself so we will be implementing this
01:10 - but I will also be giving you the
01:13 - intuition required to implement a system
01:15 - which can think and then make moves
01:18 - towards the end right so let's get
01:20 - started so first create a new project
01:25 - naming tic-tac-toe so the project title
01:28 - tic-tac-toe and let me just save it in
01:31 - my desktop and then click Next finish so
01:35 - now we have our project with our source
01:37 - file right so let me just make the text
01:40 - a little bit bigger now we'll start off
01:43 - by creating the board so there are
01:46 - different ways to implement this board
01:48 - you can think of this as an array of 9
01:50 - elements and then three of them are
01:53 - stacked together as a row or you can
01:56 - even think of this as a 3 cross 3 matrix
01:58 - well I will be implementing just
02:01 - particular board as a 3 cross 3 matrix
02:03 - because we can understand rows and
02:06 - columns better by looking at the indexes
02:08 - rather than the slots but you're free to
02:12 - implement it as a 1d array
02:14 - that is by creating nine elements and
02:16 - then striking three three vertically all
02:19 - right so I have managed to draw this
02:21 - implementation over here so what will be
02:24 - essentially building is a 3 cross 3 ID
02:26 - like this and then these are the indexes
02:30 - and since we cannot detect mouse clicks
02:33 - on our console will be numbering or
02:36 - slots so let's say the user wants to
02:38 - enter his marker over here so the user
02:41 - can press 5 and then we will remove this
02:44 - 5 and then put marker over here let's
02:46 - say X so the Phi goes and then we put X
02:50 - over here so that's all we are going to
02:52 - implement it but there are other
02:53 - libraries which I encourage you to look
02:56 - up which support mouse clicks on
02:58 - consoles too so in case you're
03:00 - interested to implement such a system
03:02 - where you can click on the area and then
03:05 - your marker appear so you can check out
03:07 - those libraries well discussing those
03:10 - libraries are well beyond the scope of
03:12 - this course so we are not going to do
03:14 - that so for now we'll be implementing
03:16 - this particular system right so let's
03:20 - start off by creating the ball it is a
03:22 - two-dimensional character array so let's
03:25 - call this a yes board and then this is
03:27 - going to be two-dimensional and every
03:30 - dimension will have 3 3 elements so this
03:34 - is a 3 cross 3 ball let me just put it
03:36 - over here so even if you don't put it it
03:39 - doesn't matter I'm just putting it so
03:40 - that we be clear with our implementation
03:43 - so let me just name the slot so 1 2 3
03:47 - and then 4 5 6 7 8 9 so notice that I am
03:51 - numbering the slots as characters
03:53 - because if you put characters over there
03:55 - it will take it as an ASCII value I'm
03:57 - sure you know just right now let us
04:01 - quickly make a function to draw the ball
04:03 - so let's say void draw board and what
04:08 - this function is going to do is that it
04:11 - is going to draw the board neatly for us
04:13 - so something like this so these two
04:16 - vertical lines and then these two
04:18 - horizontal lines separate the rows and
04:19 - columns we'll be drawing that over here
04:22 - so you can use a looper since there are
04:25 - only nine elements let's just hard-coded
04:27 - so bored zero zero let us give a space
04:30 - before both zero zero so that it doesn't
04:33 - get scratched up to the left correct
04:35 - both zero zero and then we have a space
04:38 - vertical line and then would a zero one
04:43 - space vertical line and then board zero
04:47 - two and then we have the next line
04:50 - because we just completed the rule what
04:52 - we did is we just printed this row with
04:54 - these two vertical bars now we need to
04:56 - put a horizontal bar so let us just put
05:00 - that so your horizontal wire is just
05:03 - going to be lines this is all completely
05:05 - designing you can do it as you want
05:07 - right and these steps continue for the
05:12 - next two rows to so control CBB and for
05:16 - the last row we don't need the
05:17 - horizontal lines and here you just need
05:23 - to change the road number so this
05:24 - becomes 2 this becomes 1 1 1 over here
05:31 - 2 & 2 so now if we call this particular
05:36 - function let's just remove this and call
05:40 - the drop or null surrenders of you'll be
05:44 - getting our booth so well the horizontal
05:47 - lines became extraordinary actors are
05:50 - more so let us just remove those three
05:52 - characters over here and then over here
05:58 - so this pod looks much better right so
06:02 - we have our port ready now how do we put
06:06 - data inside this hood so let's make
06:09 - another function to do that let's say
06:11 - void place marker which is going to take
06:18 - a slot number right because the user is
06:20 - going to enter the slot number now ask
06:22 - us to convert the slot number into the
06:26 - row and column number right if you are
06:28 - using a bind I mention array that is
06:29 - pretty easy you just need to do slot -
06:32 - one two and insert that into the
06:34 - particular position right so suppose you
06:37 - want to insert it into this particular
06:38 - position and if you are using a winder
06:41 - this is the fourth position read because
06:43 - array index starts from zero so zero one
06:45 - two three fold and you just need to do
06:48 - slot -1 but since we are using a two
06:51 - dimensional array we need to find out a
06:53 - way by which we can convert this slot
06:57 - number into a row and column number so
07:00 - what we can do to find the phone number
07:02 - is that we can use an observation that
07:06 - all the rows start from a number which
07:08 - is just one greater than the previous
07:11 - multiple of three so the observer over
07:13 - here 1 is nothing but 0 times 3 plus 1 4
07:17 - is 1 times 3 plus 1 and then 7 is 2
07:19 - times 3 plus 1 so what you can do is you
07:23 - can get the rule numbers by dividing
07:25 - this slot number by 3 but then again if
07:28 - the slot number itself is a multiple of
07:31 - 3 then you need to subtract 1 from the
07:33 - slot number that is if you take example
07:36 - of 6 so if you do 6 over 3 is this 2
07:39 - right but we need it in slot number 1 so
07:42 - we need to subtract 1 from that so what
07:44 - I mean is if this particular slot
07:50 - percentile 3 equal to 0 that is if that
07:54 - slot is a multiple of 3 then slot equal
07:58 - to slot over 3 so this is this and then
08:03 - minus 1 so this will give us the slot
08:05 - number else slot is directly slot over
08:08 - thing so this should give us the
08:11 - particular row number sorry let us take
08:14 - a variable just at least changing the
08:16 - slot so if slot percentile 3 is 0 then
08:20 - row is going to be this particular value
08:25 - or else Row is going to be this value
08:28 - now let us just see whether our row
08:31 - works correctly or not and let us just
08:34 - on it with place marker let's say 8
08:38 - right now if we run this you should be
08:41 - getting 2 which is correct right because
08:43 - 8 is in row number 2 now to get the
08:47 - column number you can do something
08:49 - similar to that
08:50 - so to observe the columns these are
08:53 - nothing but two remain
08:54 - which you get after dividing by three
08:56 - right so you can do the same thing so
08:58 - let's take another variable to store the
09:01 - column and column is nothing but slot
09:07 - modulus three so this should give us the
09:09 - remainder so if you look over here let
09:12 - me just pull up that image now if you
09:16 - say 3 then our row is going to be 3 over
09:20 - 3 and since 3 is a multiple of 3 so it
09:23 - is going to be 3 over 3 minus 1 which is
09:25 - equal to 0 and then our column is going
09:30 - to be 3 modulus 3 which is going to be 0
09:35 - but that is not our column we need to so
09:38 - what essentially we need to do is if it
09:41 - is a multiple of 3 if the slot is a
09:43 - multiple of 3 we need to put it in the
09:47 - end or else that particular logic will
09:49 - work all right
09:51 - over here what you need to do is if this
09:54 - particular slot is again a multiple of 3
09:59 - and column is going to be 200 every time
10:05 - when the value is a multiple of 3 you're
10:07 - going to put that in the last column and
10:10 - then you can divide this slot number by
10:13 - 3 and then get the reminder that is
10:15 - going to be your column number and I'll
10:17 - get the reminder and then subtract one
10:20 - from that that is because we are not
10:21 - considering the multiples of 3 right
10:24 - we're leaving the multiples of 3 so we
10:27 - need to subtract one let's say 4 so 4
10:29 - divided by 3 you get a remainder 1 and
10:31 - then 1 minus 0 is 0 which is the column
10:34 - number of 4 so this is how you get the
10:37 - column number so let us just quickly
10:40 - rewrite this with fewer conditions so
10:44 - true is going to be this particular
10:46 - value right irrespective of whether slot
10:49 - is going to be a multiple of 3 or not if
10:51 - it is a multiple of 3 we can just
10:53 - subtract 1 from this value so this Lord
10:55 - modulus 3 is equal to 0 then row becomes
10:59 - row minus 1 and then column becomes 2
11:05 - right this is 1
11:07 - the slot which you're giving is a
11:10 - multiple of three audence or let us
11:13 - define the column before using it or
11:18 - else what happens is columns become slot
11:21 - modulus three minus one
11:23 - so our first way performs north modulus
11:26 - three and then we subtract one from that
11:28 - all right so this is how we can get the
11:31 - to one column from a slot number if you
11:33 - know check out the row and come over
11:37 - here and call him and then let us call
11:40 - with E
11:41 - we should be getting 2 comma 1 which is
11:44 - what we got right because 8 is in the
11:46 - second row first column we can try it
11:48 - with some multiple of three let's say
11:50 - nine and then try to run this we should
11:53 - be good in - comma - well now why did
11:55 - that happen
11:56 - well that is because we are trying to
11:58 - modify the column even after it is
12:00 - getting modified over here tonight we
12:02 - are modifying the column when slot
12:04 - modulus 3 is equal to 0 and then again
12:06 - we are modifying it over here so we need
12:08 - to put it in the else but right now it
12:11 - should work fine learn it as this close
12:13 - this and try again
12:14 - if I press f9 so here you can see it
12:18 - gave us 2 comma 2 which is correct so
12:20 - now we know that our logic for getting
12:24 - the row and column is correct we can
12:26 - proceed by putting our marker into the
12:27 - board so how do you track which multiple
12:30 - to put so let us create a global
12:32 - variable for tracking the marker let's
12:35 - say parents marker and let us sit this
12:38 - to some my laurels will set it while we
12:41 - are asking will be elected while they
12:43 - are asking the user to choose the marker
12:45 - and we will also have a current cleared
12:47 - way so we need to even are trying to
12:49 - current here to check which player is
12:52 - playing it so we have one marker and
12:57 - unclear know what we are going to do is
12:59 - we need to just put
13:00 - board off this particular row and then
13:03 - this particular column is going to be
13:04 - the current marker so now we have
13:08 - successfully placed it let's place a
13:10 - marker over here and then try to draw
13:12 - the board and we'll draw a board over
13:16 - here too so draw would
13:18 - then we'll put a new line so that we
13:20 - don't get confused between the two boats
13:22 - so let's just say that current marker is
13:25 - X for long and if we try to run this
13:28 - you'll be seeing that in place of NIDA
13:32 - now there is an X right so now we know
13:35 - that this particular function works we
13:36 - can place our marker on the board now
13:39 - let us make a function to determine who
13:43 - won the game so let's call this function
13:45 - of win or winner something like this and
13:50 - we'll put the datatype to care how we
13:53 - just explain why we are putting the data
13:55 - type of care right now so this this is
13:58 - not going to take anything this is going
13:59 - to work on the global board variable
14:03 - which is this which is an array right so
14:05 - what we're going to do is we are going
14:07 - to check all the rules of the columns
14:09 - and the diagonals and see whether those
14:12 - have the same value of marker right so
14:15 - in case there are numbers they are going
14:17 - to be different to nobody one and in
14:19 - case they have this XS are all stacked
14:23 - up horizontally vertically or diagonally
14:25 - it means that that particular player one
14:28 - right now since we are getting the
14:30 - winner we can either put it true or
14:32 - false to determine whether the game is
14:35 - won or not but to determine who won the
14:37 - game we need to again check whether that
14:40 - particular marker is an X or all right
14:43 - so what we are going to do in this
14:45 - function is instead of checking twice we
14:47 - will directly return the marker of the
14:49 - winners so by marker we can identify
14:51 - which player one and then we can come
14:54 - back let him or her right that is pretty
14:56 - easy so to do that let us quickly run a
14:59 - for loop so int I equals zero is less
15:02 - than three I plus plus and inside this
15:05 - we are going to check for most ways so
15:08 - if this particular goal of I and then
15:13 - zero is equal to four
15:16 - i won and would I 1 is equal to board I
15:21 - 2 then return the current marker right
15:26 - because we are going to check whether
15:28 - the player wins
15:30 - immediately after replaces the might
15:32 - card so if this particular condition is
15:36 - satisfied then it means that one of the
15:38 - rules has been occupied by this current
15:40 - player so he's the winner and you can
15:43 - also check for the columns in the same
15:45 - loop so what you need to do for the
15:48 - columns is the same thing but just the
15:50 - eyes get shifted to the second dimension
15:52 - so since I am checking the rules I am
15:55 - just putting I in the first dimension
15:57 - four columns what we need to do is we
16:00 - need to remove the eye and place it over
16:02 - here so let me just cut and paste it and
16:07 - this goes over here and this goes over
16:14 - here so now we have successfully checked
16:17 - whether the rows or columns of friends
16:20 - or diagonals you can just hard-coded
16:22 - since there are only two diagonals so if
16:23 - board of 0 0 equal to board of 1 1 and
16:30 - wood of one bun this is put to code of 1
16:35 - what you are doing this we are
16:37 - essentially checking whether this value
16:39 - is equal to this value and then this
16:42 - value equal to this value if these two
16:44 - conditions are true it means that these
16:46 - 3 values are equal and it means that the
16:49 - clearest one so these two you
16:51 - if this condition turns out true then a
16:54 - current is one current layer of mark oh
16:57 - since I'm using the player as a integer
17:01 - I need to return in not care to over
17:04 - here it is not current marker currently
17:07 - you can return either of them right you
17:09 - can return current marker current plate
17:11 - it just depends upon so now we need to
17:15 - check this condition for the second
17:16 - diagonals so this goes and then for the
17:19 - second diagonal so coordinate or 0 to 1
17:22 - 1 & 2 0 so 0 to 1 man remains the same
17:27 - and 1 1 is equal to 2 0 then you return
17:30 - the current player right - no what if
17:35 - nobody won so you need to return
17:38 - something so what will return as we will
17:40 - just return 0 0 means nobody won and if
17:44 - it is either
17:44 - - it means that player -1 or player 2's
17:47 - 1 so now we have the winner let's just
17:50 - create an arbitrary board and then check
17:52 - 400 so let's place these markers right
17:56 - place marker at 9 8 & 7 so it means that
18:00 - X s 1 so 9 7 and then place marker at 8
18:04 - and our current player is going to be 1
18:13 - right now if you run this ok the
18:18 - spelling is wrong current player and if
18:22 - I try to run this so here you can see I
18:25 - have placed 3 XS over here now if I try
18:28 - to call this function which is winner
18:33 - and try to print the data over here so
18:37 - you can see that it has outputted 1 1 is
18:40 - the current player where I just put 3 XS
18:43 - in a row so it works for row let's just
18:46 - check for column column is let's say 0
18:49 - sorry 104 and 7th so this is the first
18:54 - column and we'll run this so it has
18:58 - written 1 again and let's check for the
19:01 - diagonal so that is 1 5 9 so now you see
19:07 - that doesn't work for diagonals that is
19:10 - because we messed up the logic somewhere
19:11 - let's take that out oh it is not 1 2 it
19:15 - is 2 toward this right so that's a small
19:18 - mistake I made
19:19 - oh no I'm sure I can run this this
19:24 - should work no so here you can see it
19:27 - has outputted 1 and let's keep some
19:30 - arbitrary place let's say 1 6 9 so this
19:34 - shouldn't result in a win so this should
19:37 - give us 0 which it gives so now we can
19:40 - see that our winner function is pretty
19:43 - much validated and it works right so now
19:46 - let us quickly make the interface we
19:48 - need so let's call the synth of this
19:50 - game all right
19:52 - and in this let us define our current
19:55 - player and markers so we will give a
19:57 - choice
19:58 - for the player bun to choose a smart
20:00 - girl and player to automatically get
20:02 - another marker so what we're basically
20:04 - trying to do is if the player the first
20:08 - player has a choice of playing X or an O
20:11 - right so that's what we are going to do
20:14 - so clear bun let's say choose your mitre
20:19 - and you can come up with your own
20:22 - sentences over here it doesn't really
20:24 - matter so this will enter our current
20:28 - marker okay let's just keep a player 1
20:32 - marker let's create a character which is
20:35 - marker marker of player 1 so we are
20:39 - going to get this particular marker so
20:42 - much your word now our current player is
20:47 - going to be 1 and then the current
20:50 - marker is going to be the marker which
20:53 - supplier when chose right now if you
20:56 - observe this game right they can be at
20:59 - most nine moves for the skill to end up
21:03 - in a tie right so in case somebody wins
21:05 - it's going to be less than nine moves
21:07 - but if it is going for a tie
21:10 - it's going to be nine motion code so
21:13 - what you can do is you can run a loop
21:15 - till nine moves so int a equal to zero
21:17 - is less than nine and then I plus plus
21:19 - and inside this what you need to do is
21:23 - let's first draw the pool or what we can
21:26 - do is we can first take input from the
21:28 - user and then draw a good so for the
21:30 - first time let us just draw the board
21:32 - outside loop and then for the subsequent
21:36 - moves will draw the board after the slot
21:38 - is entered so we'll ask the player to
21:42 - enter the slot so see how it's clear and
21:47 - then which player is that current
21:50 - players current players let's say turn
21:56 - so enter your spot
21:59 - and now we are going to get a slot so in
22:02 - slot see in slot and you know what to do
22:06 - you just need to place the marker so
22:07 - place marker in this particular slot and
22:10 - then we will draw the booth to drop so
22:14 - now if you run this particular board
22:15 - we'll just call the function game to
22:18 - play a game right so we'll just remove
22:22 - all this and then just say game over
22:24 - here so now if you run this it will be a
22:30 - getting is player 1 chose a marker it is
22:32 - going to be X and then it's my turn so
22:36 - let's it - now you see that the player
22:38 - is not changing that's because we did
22:40 - not write code to change the player and
22:43 - the marker we need to swap the players
22:46 - and markers it because the players and
22:48 - martha's are going to change
22:49 - alternatively and here you can see that
22:52 - the slot has been accepted perfectly and
22:55 - then the X has come in place of 2 so
22:58 - here you can see that it works and then
23:00 - if I've been somewhere it is not going
23:03 - to stop and then its onion going to
23:05 - continue right so this game is never
23:07 - going to stop so we need fix all these
23:09 - issues so we will do that one by one
23:12 - first let's take care of the issue where
23:13 - the player and markers are not changing
23:15 - so that's great
23:17 - function quickly which slaps appear and
23:20 - Michael let's avoid a slap layer and
23:27 - marker so this is the name of a function
23:29 - so what it does is pretty simple if the
23:33 - current player the current mark is X
23:36 - then change the marker to Oh
23:39 - current marker becomes o or else you
23:43 - just change the current marker to X this
23:46 - is just slapping the mic rest and the
23:48 - same was replaced so if the current
23:51 - player this one then current player
23:55 - becomes 2 or elles current player
24:02 - remains 1 so here we have successfully
24:07 - swapped the player marker so once
24:10 - everything is done what we do is before
24:12 - drawing the board we
24:13 - the player it's a slap player and Markel
24:16 - and they should do the job knowledge
24:18 - test is horrendous
24:20 - or let's choose X now it's asking clear
24:24 - one Stern integers Lord let's say one
24:26 - unknown player to stern
24:29 - enter your slot if I enter key you can
24:31 - see that two is occupied by an Ono so
24:34 - now we have successfully created a
24:37 - system where the players are changing
24:40 - and the markers are also changing and
24:42 - now we need to take care of the issue
24:44 - that once they are winning
24:45 - it is not stopping right so we need to
24:48 - check whether somebody won or not so
24:50 - over here not within do is we can create
24:53 - a variable or storing the value which
24:57 - this particular function returns right
24:58 - this winner function returns it's going
25:01 - to return a value in the range of 0 1 2
25:04 - right it's not going to return any other
25:05 - value so let's just create variables
25:09 - with choice of winners so let's say a
25:11 - layer 1 this is the integer value and
25:16 - what we need to do is after placing the
25:19 - marker we need to check whether he won
25:21 - or not so player 1 equal to this
25:23 - particular winner right
25:25 - and now here if this particular value
25:29 - which is player 1 is equal to 1 it means
25:32 - that player 1 1 right so see how the
25:36 - player 1 1 and then let's say
25:40 - congratulations and what you need to do
25:43 - is just break out of the loop because we
25:45 - don't need to continue the game after
25:47 - somebody has moderate so you can just
25:49 - break out of this loop and over here the
25:52 - same thing goes with you if player 1 is
25:56 - equal to 2 then you say is RC out the
26:03 - same message yes we need to change the
26:05 - player 2 and all these things remain the
26:07 - same so ctrl-c and ctrl-v and over here
26:12 - instead of 1 we just need to put 2 so in
26:16 - case nobody won it either means that the
26:20 - game can go on or if it has reach 9
26:23 - moves it means that it's a tie right
26:24 - automatically if your
26:26 - playing four nine moves and you make the
26:29 - ninth move and still nobody wins it's
26:31 - going to be a tie so what you need is if
26:34 - this particular winner condition which
26:38 - is player 1 is equal to 0 after
26:41 - completing this game then we need to say
26:44 - that nobody wins or let's say that is a
26:49 - tie game right so what this will do is
26:54 - it in case nobody wins
26:56 - even after 9 moves and this comes out of
26:59 - the loop it will then say that it is a
27:01 - tie game it also suppose a player 1 1
27:04 - and then it broke order to do then if
27:08 - you just put this particular thing
27:10 - without the safe condition what will
27:12 - happen is it will print both the
27:13 - messages at once right so it will say
27:15 - pair 1 1 and then again it will say that
27:18 - is a tie game we don't want that to
27:20 - happen that's why we have put a if
27:21 - condition to check whether it's a tie or
27:23 - not and then we will say it was a tie
27:26 - game right that will take care of all
27:28 - the issues hopefully so let's just try
27:31 - with all this time and it's player once
27:35 - done so let's enter 1 2 3 so you can see
27:39 - it's filling alternatively and 4 5 6 7
27:43 - and it says player 1 1 congratulation
27:47 - but we cannot see what happened over
27:49 - here that is because we are not drawing
27:51 - the board immediately right so what
27:54 - we'll do is we will ship this draw both
27:56 - function before this particular winning
28:01 - condition red so what will happen is
28:03 - once I place this marker I will just
28:06 - draw the board so now if I run this
28:09 - let's say X and then 1 2 3 4 5 6 7 and
28:15 - now you see that player 1 has won that
28:17 - is because this particular diagonals
28:20 - which I'm highlighting has been filled
28:21 - up by X's so player 1 1 in case you fill
28:24 - it up with oh it means that player 2's 1
28:27 - and in case you don't fill it up let's
28:30 - take a draw keys let's say we play for 9
28:34 - moves for X or let's just with you put
28:37 - the numbers 1 2 3 so ok
28:40 - so draw we need to put five and then
28:42 - four six and a seven nine right so now
28:49 - you can see that nobody has won even
28:52 - after nine moves so it's just that is a
28:54 - tie game and the ball is printed so our
28:57 - game works perfectly for now right so
29:00 - there's a minor bug in this game forward
29:02 - what we did is so let's see I put my
29:06 - Michael in the first slot right and now
29:09 - it is clear to stand and what I will do
29:12 - is I will again press one so what will
29:15 - happen now is if you have to do though
29:17 - except on and then go has taken its
29:19 - place it means I will just over return
29:21 - your tray we won't we don't want that to
29:24 - happen we don't want to move the markers
29:26 - away from their places so to fix that
29:28 - what we need to do is we need to check
29:31 - whether that slot is empty or not it is
29:33 - if that slot contains some character
29:35 - which is not an integer it means that it
29:38 - is a marker right and we don't want the
29:40 - things that might fit so what we do is
29:42 - we are placing the marker here what we
29:45 - need to do is we need to put this only
29:47 - when that particular row and column is
29:49 - not filled up so if that board and
29:52 - column board of this column is not equal
30:00 - in eggs and it is also not equal to an O
30:05 - so board of row and column is not equal
30:11 - to o then you will be filling it up with
30:15 - this particular marker or else you won't
30:17 - fill it up right so let us return to or
30:19 - false over here and then we'll print the
30:21 - message over there so we make this
30:24 - boolean or booth and over here if this
30:28 - is the case then now you first place the
30:31 - marker and then return true saying that
30:34 - this operation was completed
30:37 - successfully
30:38 - or else what you need to do this you can
30:41 - fals over here and here once you are
30:45 - placing the marker where did be plated
30:48 - before placing it over here right so
30:50 - let's say boolean status
30:53 - or you can directly put this in the if
30:55 - statement all right so if this
30:57 - particular condition is true then we
31:01 - don't have to do anything we want to
31:02 - print a message only when it is false so
31:04 - this button not over here so if not play
31:07 - small kind of slot that is if this
31:09 - condition is not true then we need to
31:12 - see something so let's say and that slot
31:16 - is occupied and then I'll try another
31:19 - slot so this particular message will
31:24 - print and then we need to decrease I by
31:27 - 1 that is because we need to give them a
31:30 - player another chance right we can just
31:32 - switch the players right there so it
31:35 - leaves I by 1 and then we just put
31:37 - continue so that all the statements are
31:40 - skipped and then it goes back to the
31:42 - executions neatly against this Indian
31:46 - this code so we print the message we
31:49 - decrease I so that the value of I
31:52 - remains same
31:53 - once continuous in conflict right
31:55 - because if it is decreed decreased over
31:57 - here it will go back and it will
31:59 - increase over here so effectively the
32:01 - value of I remains same and it should
32:04 - work now and another thing is let's say
32:08 - the player entered some pretty big slot
32:11 - right let's say hundred or something so
32:13 - we need to take care of that too so if
32:15 - slot is less than 9
32:17 - less than 1 and if slot this saree or
32:22 - slot is greater than 9 we should not
32:24 - accept it so we need to do the same
32:27 - thing just a message changes ctrl C and
32:30 - then control B and here you need to say
32:35 - that it's an invalid salat right so that
32:37 - slot this in value and then you try
32:42 - another slot and we just put continue so
32:45 - that the player doesn't change so this
32:48 - will do for us now if you execute this
32:51 - you will be having a functional
32:53 - tic-tac-toe game over here too it's
32:55 - asking clear once in C Michael's going
32:57 - to play X and now it's player ones turn
32:59 - so 1 2 3 4 5 6 7 so now player 1 man
33:06 - that's because of this
33:07 - diagonal and let's make clear to also
33:11 - win so let's try it once again so let's
33:13 - say X again so now it is going to be one
33:17 - two three and then five four and then
33:22 - what is that state now you can see
33:25 - player 2 won congratulation that is
33:27 - because I have filled up this particular
33:28 - column with OHS right so in case you
33:32 - wanted to implement it AI kind of a
33:35 - thing there the computer place you can
33:38 - do that well we are just going to
33:40 - implement a pseudo AI not the original
33:42 - one so this is not going to think much
33:45 - it is just going to randomly place it so
33:47 - in case you want to generate random slot
33:49 - what you new clothes you need to include
33:51 - another header file called HD b li d
33:54 - which are standard library you can
33:56 - include this one also see STD li b which
33:59 - is the C++ version of the speech c
34:01 - standard library so these libraries are
34:04 - nothing but that they are from C
34:05 - language so in case you're using it in
34:09 - C++ you just add a C over here to
34:12 - indicate that that this is C library
34:14 - right now to generate random numbers 4
34:17 - to 5 is you have a function called rank
34:20 - which will directly give you a random
34:22 - number right it's printer and over here
34:24 - and here you can see it just printed 41
34:28 - on to the screen now if I execute it
34:31 - again you will see that the same 41 is
34:33 - over here if you close this whole
34:35 - program and then rerun it is this going
34:38 - to give you a different number but again
34:41 - till you don't remove this whole quote
34:44 - from the memory it's going to be the
34:45 - same number again and again negative so
34:47 - to take care of that what you have is
34:50 - something called as a speed
34:51 - so for seeding the random function
34:54 - leading this basically you will be
34:55 - giving different starting points to that
34:58 - random function to generate different
35:01 - numbers every time you call it so to see
35:03 - if the random number you call the
35:05 - function SRAM and inside this you put
35:08 - some number which constantly keeps
35:11 - changing rate let's say 1 over let's say
35:14 - 10 over here and then if I try to run
35:16 - this you will be getting some other
35:18 - number let's just 71 over here
35:20 - and if I put some other number little
35:22 - one over here now and then try to run
35:24 - you'll be getting another number which
35:25 - is 41 but we can't change this again and
35:28 - again right we need a way to change this
35:31 - particular number which will generate
35:33 - different numbers every time so to do
35:37 - that we can use time right so time is
35:41 - constantly changing it is not constant
35:43 - so what you can do is if you pass in
35:46 - time over here as an integer it will
35:48 - give you different random numbers
35:50 - without you having to change this
35:52 - manually so to do that we need to
35:54 - include another header file which is
35:55 - called time right so see time right the
36:01 - same reason why we are using over here
36:02 - it is time dot H or C time both us in
36:06 - and you go over here and then what you
36:09 - do is instead of one you just pass in
36:11 - time and then personal as a parameter
36:13 - will go over this null when we are
36:15 - discussing pointers but for now just
36:17 - remember this is the syntax and this is
36:20 - how we call the function for time right
36:23 - for getting time as an integer now if we
36:25 - run this you will be getting different
36:28 - numbers over here every time so this is
36:30 - nine one seven zero if I execute it
36:32 - again you will be getting some other
36:34 - number nine minutes into it so to
36:36 - generate random numbers in a range we
36:39 - want it in a range rate we want random
36:41 - numbers between one and nine so to do
36:44 - that what you can do is you have to use
36:47 - a formula there is no direct way to get
36:49 - random numbers in C++ in a particular
36:53 - genes but what you can do is you can use
36:55 - the formula which states that if you
36:59 - want the random numbers in the range u2l
37:02 - it which is sorry it to you
37:05 - it's just nothing but lower range to
37:09 - upper range what if one ran numbers in
37:12 - this range what you do is run mod u
37:15 - minus l plus 1 and then the whole thing
37:20 - plus n well this formula does look
37:24 - pretty clumsy I know that but if you try
37:28 - to reduce this you will see that it
37:30 - mathematically means the same that the
37:33 - lowest number
37:34 - be held and then the highest number will
37:36 - be you right so you just remember this
37:39 - formula to generate random numbers
37:40 - within a range so in our case what it's
37:44 - going to be an upper range is 10 and
37:46 - then the lower range is 1 right upper
37:49 - range is not included so sorry for this
37:51 - notation it is mathematically this which
37:54 - means that the last number is not
37:56 - included but the number till the
37:57 - previous one is included so it becomes
38:01 - 10 minus 1 plus 1 and over here the
38:03 - upper is just 1 right so now if you do
38:06 - this over here if I try to print this
38:08 - value over here you will be getting
38:12 - numbers which are in the range of 1 to 9
38:14 - right it is put a semicolon in the end
38:17 - and we don't need this we'll just remove
38:19 - this so every time you execute we'll be
38:21 - getting some random numbers which is in
38:24 - the range of 1 to 900 so here you can
38:27 - see that it's giving us different
38:29 - numbers in the range of 1 to 9 so now
38:32 - what we can do is we can use this and
38:35 - instead of the second player what we'll
38:38 - do is we'll just ask the computer to
38:41 - generate some random slot number and
38:42 - then place our marker over there and
38:45 - then instead of 9 now the loop will run
38:48 - only for 4 times it is because the
38:51 - number of times the loop should run is
38:54 - half-dried we are not going to take in
38:55 - inputs for 9 times we are going to take
38:57 - it inputs for 4 times so we need to just
39:01 - run it for 9 over 2 times which is 4 as
39:04 - an integer division if you want to
39:07 - implement this really sophisticated
39:09 - system like the one which Google uses
39:11 - right this one which can think so if you
39:14 - take us this impossible level in this
39:17 - particular game and then try to play
39:21 - with Google you can say that you can
39:23 - never win right it will either end up in
39:26 - a draw or you lose right there is no
39:29 - other outcome in this particular you
39:30 - cannot win that is for sure so to
39:32 - implement such a system there is an
39:35 - algorithm called as minimax algorithm so
39:38 - you can try to study about this minimax
39:43 - algorithm so sorry
39:44 - it does make max algorithm
39:48 - right so you have this particular
39:51 - algorithm so what this essentially does
39:53 - is it will take combinations of games
39:57 - right it will play the game with itself
40:00 - and it will score every game so let's
40:02 - say we have an arbitrary game so let us
40:04 - just clear this let's say we have an
40:06 - arbitrary bhutesu I have an x over here
40:08 - and over here and then another X over
40:12 - here and over here and then the computer
40:15 - is playing X so it has to make the next
40:17 - one
40:18 - so what it will do is it will try out
40:21 - all the possible boxes which are
40:22 - unfilled right and there are different
40:25 - outcomes for that so one of the outcomes
40:27 - is let's say I start off with this board
40:29 - so let's change the color so let's say I
40:32 - put an x over here now there are
40:34 - different ways to put o I can either put
40:36 - one over here one over here it is up to
40:39 - me right so every possibility will
40:41 - generate a new set of both which the
40:45 - computer will play itself right in the
40:47 - memory and then it will score its
40:49 - outcomes so let's say in in case it put
40:53 - x over here and then for the first case
40:56 - you put over here and then it turns out
40:59 - that after playing such combinations it
41:01 - turns out that if you put x over here
41:05 - you have let's say ten combinations out
41:08 - of which you won five combinations right
41:11 - but this is one of the slots now what it
41:13 - will do is it will keep the statistics
41:15 - and again played with the next slot
41:17 - which is empty so what you do is it will
41:20 - just remove these things and then it
41:22 - will play with let's say this particular
41:25 - column so it will put an x over here and
41:27 - then again repeat the same process it
41:28 - will see all the combinations possible
41:30 - and then let's say in this particular
41:33 - column which I marked with red there are
41:36 - again a let's say ten possible outcomes
41:39 - and then it one or seven of them right
41:42 - and let's say laid over here let's take
41:46 - some other color let's say this one so
41:49 - it played over here and then in this
41:51 - again there are ten possible outcomes
41:53 - and out of which it could have been only
41:56 - two right and you have another possible
42:00 - two over here
42:01 - in which ten possible outcomes it could
42:05 - not win anyone rate it lost all of them
42:08 - so it 1-0 now what can do is it will see
42:13 - all the scores so here it has 70 percent
42:15 - probability right so if you are winning
42:17 - seven games out of ten it means you have
42:19 - 70 percent probability of winning and
42:21 - here you have fifty here your zero
42:23 - percent probability and here you have
42:26 - twenty percent probability so it will
42:28 - take the one with the most probability
42:31 - or the most core so if you take in total
42:33 - if we talk in terms of numbers here you
42:35 - have five here your seven zero and two
42:38 - right so it will take the number which
42:39 - is maximum that is this one so it will
42:42 - say that if I put my marker in this
42:45 - particular place I have more chances of
42:48 - winning so if you place it over there so
42:50 - for every mole to calculate all the
42:52 - possibilities and then place the best
42:54 - move and that is how this particular
42:56 - Google is using that particular
43:01 - algorithm to make its decision so that
43:04 - algorithm even though it is called
43:07 - something else it is actually the
43:10 - equation so if you look at the
43:11 - implementation it is basically recursion
43:14 - which is being implemented rate so
43:16 - tic-tac-toe if we just a search for that
43:19 - you will have many different resources
43:23 - to check that out so you are check that
43:25 - from one of these resources so what you
43:27 - will see is it is basically implementing
43:30 - recursion it will just go over the boots
43:32 - and then try to implement and then you
43:35 - have a scoring method so I think they
43:38 - are used blessed and as a school we have
43:41 - used plus one over here right where if
43:43 - you won you just put one over here if
43:46 - you don't when you just put minus one it
43:48 - means that you one and minus one means
43:50 - that you do so and you don't want
43:52 - negative scores right we just want
43:53 - positive scores so this is a bit of
43:56 - complicated stuff you don't understand I
43:59 - don't expect you to understand I just
44:01 - staged but I would definitely recommend
44:03 - you to check that out and try to
44:05 - implement and this one you can try to
44:07 - implement by reducing the number of
44:10 - loops over here and then creating
44:12 - another function so that the AI to
44:15 - what slot to put a marker in so hope you
44:18 - enjoyed this video in the next video
44:19 - will be starting pointers