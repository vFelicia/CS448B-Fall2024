00:00 - welcome to programming knowledge so in
00:02 - this tutorial we will start with the
00:04 - basics of
00:05 - dart dart is the official programming
00:08 - language
00:08 - that the flutter framework uses i will
00:11 - be using
00:12 - dart pad to write all my darts code
00:18 - so every dot program's basic requirement
00:21 - is a main method main method is the
00:24 - entry point of every dot program we can
00:27 - write the main method like this
00:29 - main followed by a parenthesis set of
00:31 - parentheses
00:32 - then curly braces and over here we write
00:35 - our
00:35 - code we can also add a void over here if
00:40 - needed
00:41 - void basically specifies that a method
00:44 - or
00:44 - function will not return anything we
00:47 - will study about functions
00:49 - in details later in this tutorial
00:52 - so after main method we
00:56 - let us discuss about print so to print
00:58 - anything on the console we use the
01:01 - keyword
01:02 - print and then the parentheses then
01:04 - single quotes
01:06 - and then we can write the sentence that
01:09 - we want to be printed
01:11 - on the console so for this case i am
01:13 - writing
01:16 - programming knowledge
01:20 - and then followed by a semicolon now if
01:23 - i run this program
01:25 - in my console i would be able to see
01:27 - programming knowledge
01:30 - so you can see programming knowledge is
01:32 - visible in my
01:34 - console now if i change the text over
01:37 - here
01:37 - the output in the console will also
01:40 - change
01:43 - suppose i write my own name and then
01:46 - click on run
01:48 - so now the console is showing my name
01:53 - like python we can also use double
01:55 - quotes and triple quotes to print blocks
01:57 - of statements
01:59 - after print let's discuss about data
02:02 - types
02:03 - so there are five to six primitive data
02:05 - types
02:06 - namely int for storing integer values
02:10 - float and double for storing decimal
02:13 - values
02:13 - care for storing character string for
02:16 - storing
02:17 - group of characters and bool for storing
02:20 - boolean values that is true
02:22 - and false now in dart there are four
02:26 - types of variable declaration
02:28 - the first type is static declaration
02:32 - in static declaration we write the data
02:35 - type
02:37 - for followed by the variable name let's
02:40 - call it
02:40 - v and then a semicolon
02:44 - we can store values to this variables by
02:47 - writing v
02:49 - is equal to and inside quotes rishabh
02:54 - over here we have written string that
02:56 - means the variable v
02:57 - can only store string values now let's
03:00 - try printing it
03:02 - so to print i'll write print v
03:05 - followed by a semicolon and now let's
03:06 - try running it
03:09 - so it is showing rishabh we can merge
03:12 - these two statements together
03:15 - so to merge we will write
03:20 - now again if i try running the program
03:23 - we will get the same output
03:25 - but over here it has changed from
03:27 - variable declaration to variable
03:30 - definition
03:31 - the basic difference between variable
03:33 - declaration and variable definition
03:36 - is that in variable declaration we tell
03:38 - the compiler
03:39 - that the program will have a variable v
03:42 - of string type but in variable
03:45 - definition
03:46 - we tell the compiler that the program
03:48 - will have a variable v of string type
03:51 - and rishabh will be stored in it
03:57 - after static declaration we have dynamic
04:00 - declaration
04:01 - over here dynamic refers to the data
04:03 - types
04:04 - that is a variable can store values of
04:07 - different data types
04:09 - we declare a dynamic variable by writing
04:12 - v a var v and then the values
04:15 - so in the first variable i am storing a
04:18 - string
04:19 - in the second variable i am storing an
04:22 - integer
04:23 - and in the third variable
04:26 - i am storing a decimal
04:29 - okay now i'll try printing them so i'll
04:32 - write print
04:36 - v then print to v1
04:41 - then print v2
04:46 - now if i click on run i'll get i am
04:50 - getting the output as
04:51 - rishabh 10 69.69
04:55 - over here var automatically changes to
04:58 - type of data stored in it
05:00 - and memory to the variables are
05:02 - allocated during the compile time
05:05 - and to check if i select v over here in
05:08 - the documentation i
05:10 - get string if i select v1
05:13 - i get integer and if i select v2
05:16 - i get double okay
05:19 - so after the static declaration and
05:23 - dynamic declaration the third type of
05:25 - declaration is
05:26 - constant declaration as the name
05:29 - suggests
05:30 - variable declared constants cannot be
05:33 - changed
05:35 - so to so to declare a constant value
05:39 - we write c o n s t const
05:42 - c is equal to 10.
05:46 - now we can print the constant values
05:51 - if i click on run it will give me 10 as
05:54 - the output
05:55 - and now if i try changing the values
05:58 - if i write c is equal to c plus 1
06:02 - and then if i print it
06:08 - it is giving me an error error this is
06:12 - compilation failed that is because i
06:14 - have tried
06:15 - to change the value of a constant
06:17 - variable
06:18 - over here okay so
06:22 - after this the last type of declaration
06:25 - is
06:25 - again dynamic declaration over here
06:28 - dynamic refers to
06:30 - a location of memory during runtime
06:33 - for example suppose we want to show the
06:36 - exact
06:37 - time when the program is executed then
06:40 - if we use
06:41 - where or string to store time then the
06:44 - value will be the time
06:46 - at which the program was compiled and
06:48 - not
06:49 - the time when the program was executed
06:52 - so in such cases we use dynamic
06:55 - variables
06:56 - so to you create a dynamic variable we
06:58 - write
07:00 - dynamic and then the variable v
07:03 - and then we can add the value as and
07:06 - when
07:07 - required
07:10 - okay so this was about variables
07:14 - i hope everything was clear so today we
07:16 - will learn about
07:17 - type conversion so first
07:22 - let us try about converting string to
07:25 - integer but before that i would like to
07:27 - tell you
07:28 - one thing that for writing comments we
07:31 - can use
07:32 - double slashes and write an
07:36 - inline comment and we can also
07:39 - use slash followed by a star
07:43 - and then again star followed by space
07:47 - and then over here we can write blocks
07:49 - of code
07:54 - and then the final one is three slashes
07:57 - and over here we can write the
08:00 - documentation okay so
08:03 - back in the program let's try converting
08:07 - string to integer
08:11 - so to convert string to integer we write
08:14 - we create a variable where one and then
08:18 - i will write
08:19 - int dot parse and inside this will be my
08:23 - string value
08:24 - so suppose i enter 1
08:29 - now to check if one has
08:32 - an integer value so we will write assert
08:37 - 1 equals
08:40 - digit one uh assert is a
08:44 - built-in function to verify that
08:47 - the thing is as required or not okay so
08:51 - now let's try adding some value to one
08:53 - if it is an integer it will add without
08:57 - any
09:06 - problems
09:12 - over here i have written the wrong
09:14 - spelling it will be assert
09:17 - now if i try to run the program
09:21 - you can see 11 is the output so
09:24 - over here you can see we have given one
09:27 - as a string
09:28 - input then it has been converted to
09:30 - integer
09:31 - and then i have added 10 to it and then
09:33 - printed
09:34 - so 10 plus 1 is 11 now we will try to
09:38 - convert
09:39 - integer to string
09:47 - integer to string so for that i'll
09:49 - create a variable to store
09:53 - i'll write 1
09:56 - is equal to 1 which is an integer dot
09:59 - 2 string
10:02 - okay now if i add some values it should
10:05 - be concatenated
10:07 - to the end of the variable so i will
10:08 - write 1
10:12 - plus plus equal to
10:17 - fish off and now if i try printing it
10:32 - the output is one reshaft
10:35 - that means this integer one is converted
10:38 - to string
10:39 - and then ratio is added at the end of
10:42 - the string one
10:44 - so this is how we convert an integer to
10:47 - string
10:48 - now to convert our decimal to string
10:54 - we have two methods
11:00 - first is the one similar to which we
11:03 - have seen just now where
11:05 - 1 is equal to 3.1234
11:10 - that is the decimal or double value
11:14 - dot tostring
11:17 - and the other method is where
11:21 - 1d is equal to
11:26 - 3.1234
11:28 - dot 2 string
11:32 - as fixed
11:36 - 2 so this basically means that
11:39 - the string will have only two decimal
11:42 - places
11:43 - so let's check that and you know to
11:45 - check that we use
11:46 - a cert keyword and then we will write
11:51 - 1d is equal to
11:55 - so as we have converted it to string we
11:58 - will keep it inside
11:59 - quotes 3.12
12:02 - and now then we will try printing
12:05 - so we'll write one d
12:09 - now if i click on run the output should
12:11 - be 3.12
12:13 - so you can see the output is 3.12
12:16 - so this is how we convert an integer to
12:20 - string
12:20 - string to integer decimal to string and
12:23 - also how to trim the decimal places
12:29 - after type conversion let's discuss
12:31 - about operators
12:33 - so let's start with unary operators
12:36 - so first i'll create a variable a and
12:39 - store
12:40 - 10 in it now to
12:43 - add some value to a we can write a is
12:46 - equal to
12:47 - a plus 10 so what this will basically do
12:51 - is
12:52 - add a 10 to a and then again store it
12:54 - inside the variable
12:56 - a let's check it by printing it
13:05 - so the output is 20. similarly we can do
13:08 - for minus
13:12 - the output is 0 and it will be same for
13:16 - multiplication
13:17 - as well as division
13:20 - so we can reduce the length of the code
13:23 - if we want so to reduce we will write a
13:25 - is equal to a plus
13:29 - equal to 10 so this will also do the
13:32 - same purpose
13:33 - that is to add 10 to a and then again
13:36 - store in it
13:38 - so if i run this the output should be 20
13:42 - similarly for minus for multiplication
13:45 - and for division
13:49 - next type of operators is increment and
13:53 - decrement operator so if i write
13:56 - print a plus plus
14:00 - and then again print a
14:05 - the output will be 10
14:08 - and 11 that means first
14:11 - this statement got executed then the
14:15 - value of a was
14:16 - incremented by 1 and then is value
14:19 - became 11 and it got printed here
14:22 - but if i give the plus plus before
14:26 - a and then if i click on run the output
14:29 - will be 11
14:30 - and 11 that means before the execution
14:32 - of the statement
14:33 - a got incremented by one as you can see
14:36 - in the console
14:38 - similarly for mine decrementing we can
14:41 - use minus minus
14:42 - now if i click on run
14:46 - the output will be 10 and 9 that means
14:49 - first the statement got executed
14:52 - then the value was decremented and now
14:54 - similarly if i put minus minus before a
14:58 - and run it then the value will get
15:00 - decremented
15:01 - first and then the statement will be
15:04 - executed after unary operators we have
15:08 - relational operator
15:10 - so to learn about relational operator
15:13 - i'll create
15:14 - two more variables where b
15:17 - is equal to 5
15:20 - where c is equal to 15
15:23 - and one more variable where d
15:27 - is equal to 10 so to check equality
15:30 - between
15:31 - any two variables we write if
15:36 - a is equal to equal to d
15:40 - that means if a equals d then print
15:46 - true
15:52 - so the output is true and now if i
15:55 - change
15:56 - this d to b and then click on run
16:03 - now there is no output because we don't
16:06 - have an
16:06 - else condition so i'll write else
16:11 - print
16:15 - false now if i click on run the output
16:19 - should be
16:20 - false we will learn about if and else in
16:24 - details
16:25 - in the for future tutorials
16:31 - we will learn about fl's in details
16:34 - later in this course
16:37 - so after checking equality there is an
16:40 - operator
16:40 - that checks for greater than equal to
16:43 - case
16:44 - so i if i write if
16:50 - a is greater than equal to
16:54 - b then the output should be
16:58 - print true
17:05 - else print
17:10 - false now if i run this the output
17:13 - should be true
17:15 - that is because the b has 5 stone
17:18 - stored in it and a has 10 stored in it
17:21 - so as 10 is greater than 5
17:24 - this condition is true and now if i
17:27 - change to
17:28 - d then again the output will be
17:32 - true because a has 10 stored in it
17:35 - and d has 10 stored in it so a is equal
17:38 - to
17:38 - d so the condition is true and now if i
17:42 - change it to c
17:44 - the output will be false because 15 is
17:47 - neither greater than
17:48 - nor equal to 10. now
17:51 - after this we have less than equal to
17:56 - and if we run this the output will be
18:00 - true that means 10 is less than
18:03 - 15 which is true and now if i
18:07 - change it to c
18:10 - itself then also the output will be true
18:13 - that is because 15 is equal to 15
18:17 - now after this we also have only less
18:20 - than
18:21 - that means 15 we have to check if 15 is
18:24 - less than 15
18:25 - so the output should be false as 15 is
18:29 - equal to 15 but not less than 15 and now
18:32 - if i change it to
18:34 - d the output will be true as 10 is
18:38 - less than 15 and if now i change it to
18:42 - greater than that the output will again
18:43 - be false
18:45 - as 10 is not greater than
18:48 - 15. so this is how we use
18:51 - relational operators
18:55 - now another type of operators is logical
18:58 - operators
18:59 - so there are three types of logical
19:01 - operators the first one is logical and
19:04 - and its symbol is
19:08 - and and it checks and it returns true
19:12 - if both the conditions are true
19:14 - otherwise it will return
19:17 - false so let's check if b
19:20 - is d is greater than b
19:23 - so if this is the condition let's see
19:26 - what is the
19:27 - output so the output is false
19:31 - as you can see d is less than c that
19:34 - means
19:34 - 10 is less than c that means this
19:37 - condition is false
19:38 - and this condition is true and as i told
19:42 - you
19:42 - and returns true only when both the
19:44 - conditions are true
19:46 - as one of the condition is false it
19:48 - returns false and the
19:50 - else statement gets executed and now if
19:52 - i change it to greater than that means
19:54 - now
19:55 - both the condition will be true and if i
19:58 - try to run it
19:59 - the output should be true and as you can
20:02 - see the output is
20:03 - true now the next type of logical
20:05 - operator is
20:06 - or operator and the sign is
20:09 - this now or operator returns true
20:13 - if any of the condition is true so
20:16 - suppose
20:16 - and if both the conditions is true it
20:19 - will always give
20:20 - true as the result so now if i run the
20:23 - output will be true
20:25 - and now if even if i make one of the
20:27 - condition false
20:29 - the output will still be true
20:32 - that means if one of the condition is
20:36 - also true the output is true
20:37 - and now if i make both the conditions
20:40 - false then the output will be
20:42 - false and then the final type of
20:45 - operator is not so
20:49 - over here if i write a is not equal to
20:53 - 10 then the output should be
20:57 - false but as you know the is having 10
21:01 - stored in it so the output is
21:03 - false because 10 is equal to 10 and
21:06 - not not equal to 10 i hope are you and
21:09 - you are understanding
21:11 - so this was about operators in this
21:14 - tutorial we will continue with
21:16 - operators so the next type of operators
21:20 - are called null aware operators
21:27 - so for explaining this i will create a
21:29 - class
21:32 - num and it will have a variable
21:36 - or you can also call data members num
21:39 - and it will have a value of
21:41 - 10. we will learn about class in greater
21:44 - detail later in this course
21:48 - now after that over here i'll create
21:52 - a variable n and to initialize a class
21:54 - we just write
21:55 - num that is the class name followed by
21:58 - parentheses
21:59 - this is also called constructor
22:02 - then after that we'll create an integer
22:05 - variable no
22:08 - and now we will check if
22:14 - n is not equal to null
22:17 - null stands for empty reference
22:22 - then n o is equal to
22:25 - n dot num that means to get the
22:29 - data member num from the object
22:32 - n where n is an object of class num
22:36 - and then we will print
22:39 - n
22:48 - so now you can see when i print n it is
22:51 - showing
22:52 - instance of num and if i print no
22:55 - it should show 10 so you can see
22:59 - 10 is the output now
23:02 - suppose we have not initialized this
23:06 - and then if we try running then it will
23:08 - show
23:09 - null that means that no value is
23:13 - stored in n so now instead of
23:16 - if else we can use the null of a null
23:19 - aware operator
23:21 - so for that we will write
23:25 - n o is equal to n
23:28 - question mark dot num
23:32 - and try running it
23:36 - the output is again null but we over
23:38 - here we don't have to write the
23:40 - if else what it basically does is it
23:43 - checks
23:43 - that n is null or not if n is not null
23:47 - then it extracts the value from data
23:50 - member num
23:51 - and stores it inside no so now let's try
23:54 - see the difference by initializing n
23:57 - over here i'll write
23:58 - num now if i run this the output should
24:02 - be
24:03 - 10 so you can see the output is 10
24:06 - now we will see another type of null
24:10 - aware operator
24:12 - so now i'll change it back to
24:16 - null and now
24:20 - along with this i'll add two question
24:22 - marks
24:23 - and give a zero and now if i try running
24:26 - this
24:27 - the output will be zero this means that
24:31 - if
24:31 - n is null then this will be the default
24:34 - value
24:35 - and if i again write num that means call
24:39 - the constructor
24:40 - and try running then the value will be
24:44 - 10. and then the
24:48 - final type of null aware operator
24:51 - is this
24:55 - it is written by two question marks and
24:58 - then an
24:59 - equal to so for that i'll remove this
25:02 - class i don't need it anymore
25:04 - i'll create a integer variable no
25:09 - and not initialize it and now over here
25:12 - i'll write
25:13 - print and no
25:16 - double question mark equal to 100
25:22 - what this basically does is if no is
25:25 - null then it will
25:26 - store hundred in it and now let's try
25:29 - running this
25:32 - so you can see hundred is stored in no
25:36 - now the last type of operators are
25:39 - ternary operator
25:41 - so i'll create a main method
25:46 - and i'll create an integer variable
25:50 - 5 and another
25:53 - integer variable
25:57 - 6 and now for the ternary operator
26:02 - i'll create a boolean value bool
26:05 - ans is equal to
26:09 - no greater than no1
26:13 - so this is the condition and if the
26:15 - condition is true
26:17 - we will set the value to true
26:20 - else the value will be false and now
26:23 - let's try printing
26:25 - the answer
26:33 - okay sorry the t will be small
26:44 - so you can see the output is false that
26:47 - means
26:48 - 5 is not greater than 6 this type of
26:51 - expression
26:52 - is called ternary operator where three
26:54 - operators
26:56 - are used over here the operators are a n
26:58 - s
26:59 - n o and n zero one the functioning is
27:02 - this is a condition and if the condition
27:04 - is true then this part is executed
27:07 - else this part is executed
27:10 - so this was about operators
27:14 - after operators now we will move to
27:16 - conditional statements
27:18 - so in dot there are two types of
27:20 - conditional statements
27:22 - one is if else and the other one is
27:24 - switch case
27:26 - so to study about
27:29 - if else i'll create an integer variable
27:32 - you know and store 100 in it
27:34 - and i want to print even if the number
27:38 - is even
27:39 - otherwise i want to print odd so for
27:42 - that i can use an
27:43 - if else so inside the if i'll try to
27:46 - divide it by 2
27:48 - and get the remainder
27:51 - and if the remainder is 0 that means it
27:54 - is completely divided by 2
27:56 - that means it is an even number so i
27:58 - should print
28:01 - even
28:04 - otherwise i should print
28:10 - odd
28:15 - or should be inside quotes and now if i
28:18 - run the program
28:20 - the answer should be even and now if i
28:22 - change it to 1001
28:25 - the output will be odd and now
28:28 - if i want to have more than one
28:30 - condition
28:32 - then over here i can write else if
28:35 - so for that i'll write else if
28:39 - no divided by 3 and the remainder is
28:44 - equal to 0 then i will print
28:51 - divisible by 3
28:57 - else
29:01 - print odd
29:06 - so now if i change the number to
29:09 - 99 which is divisible by 3 you will see
29:12 - the output is
29:14 - divisible by 3 so if i run it
29:17 - the answer is divisible by 3 so this is
29:21 - how we use
29:22 - if else for checking some conditions
29:25 - you can add as many elsif blocks
29:28 - you want but if and else
29:32 - block can only be used once
29:37 - after if else we have switch case so in
29:40 - switch case we use the keyword switch
29:45 - and then we need to pass a number or
29:47 - character that will be checked
29:50 - so i will be using number in this case
29:53 - and then we will check the case in case
29:55 - 0 that means if
29:57 - no is equal to 0
30:00 - then i want to print
30:04 - 0 0 should be inside
30:08 - quotes
30:11 - followed by a break
30:16 - break brings the control outside of the
30:20 - switch case
30:21 - now after that i'll check for another
30:23 - case
30:24 - case 100
30:28 - that then print
30:34 - 100
30:37 - and then again a break
30:41 - and then finally we can have default
30:48 - and there we can print
30:51 - not 0 not 100
30:55 - and we don't need to give a break
30:58 - because
30:59 - we are as it is at the end of the
31:02 - switch case so now let's try running
31:05 - this program
31:06 - as the number is 99 the default case
31:09 - should be executed
31:14 - so if i run this the output is not 0 not
31:17 - 100
31:18 - and now if i change it to 100 the output
31:21 - should be
31:22 - 100 and if i
31:26 - change it to 0
31:32 - the output is zero so this is how we use
31:35 - conditional statements in dot so the
31:38 - next
31:39 - thing that we will study in dart is
31:42 - loops so basically there are five types
31:45 - of loop
31:46 - the first loop is for loop
31:52 - so the syntax of for loop is
31:55 - very much same as in other programming
31:58 - languages we have the keyword for
32:01 - and then we create a variable where i
32:04 - is equal to 0 that is initializing a
32:07 - variable
32:08 - then setting the range i is less than
32:12 - 10 and then increment or
32:15 - decrement and then inside this we write
32:17 - the code
32:18 - that we want to execute
32:21 - so for right now i will be printing
32:27 - programming knowledge
32:33 - and now if i click on run programming
32:36 - knowledge should be printed 10 times
32:39 - so you can see it has been printed 10
32:42 - times
32:43 - so this is how we use for loop another
32:47 - possible way to use for loop is
32:50 - setting this value to 10 and
32:54 - checking that i is greater than
32:58 - zero and instead of incrementing
33:00 - decrementing the operators
33:02 - and now if i run this code the output
33:06 - will be exactly same
33:07 - so these are the two methods in which we
33:10 - can use
33:11 - for loop the next type of
33:14 - loop is called for in loop
33:18 - so i'll just remove this
33:26 - so for in loop is basically used in
33:30 - collections
33:31 - we will study about collections later in
33:33 - this course but
33:35 - for now i'll just create a list
33:38 - and store one two three in it
33:42 - list is a type of collection that stores
33:45 - more than one values under the same name
33:49 - and now to run i'll write for
33:56 - where x where x is a variable that i
33:59 - have created
34:00 - in n that means x will have the
34:05 - have 1 2 3 every time the loop runs
34:08 - so now if i print x
34:12 - 1 2 3 should be printed
34:17 - so you can see the output is one two
34:20 - three now the next type of loop is
34:24 - for each loop for each loop is also used
34:28 - on collections so just for example
34:31 - i'll write no that is the variable that
34:35 - we have created
34:36 - dot for each
34:40 - that is a method and inside
34:43 - that it returns and that is
34:47 - each value inside the no list and
34:50 - then it should perform some tasks so to
34:53 - write
34:54 - which task to perform we first given
34:56 - equal to
34:57 - then a right arrow and then we write the
35:01 - statement print n in this case
35:05 - so now if i click on run 1 2
35:08 - 3 should again be the output
35:11 - now suppose we want to call another
35:13 - function so for that i'll write void
35:18 - print num it takes a
35:21 - value num and then prints it to the
35:25 - console
35:28 - so now instead of this print statement
35:31 - i'll
35:31 - replace it with my method name that is
35:34 - print num
35:35 - and it takes a value num which is
35:39 - nothing else then n so now if i try to
35:42 - try to run this i will get the same
35:45 - output
35:48 - now the next type of loop is while loop
35:51 - so for that i don't need this function
36:00 - now i'll create a variable integer type
36:03 - variable
36:04 - num and initialize it to 5 and
36:08 - now i want to run a loop while
36:12 - num is greater than
36:16 - 0 so to run a while loop the keyword is
36:19 - while and now over here i will just
36:22 - simply print the number
36:26 - and then decrement the number by one
36:30 - and now if i run the loop i'll get the
36:33 - output
36:34 - five four three two one so this is how
36:37 - we use a
36:38 - while loop now the next type of loop is
36:41 - do while loop so for do while
36:45 - we first try to do and then inside
36:48 - that the code that every time the
36:51 - condition is
36:52 - true should be executed so i'll just
36:54 - print the number
36:56 - then num minus minus
37:00 - and then after do we have while
37:04 - num greater than zero
37:08 - and now if we run the code we will get
37:10 - the same
37:11 - output now the benefit of do while over
37:14 - while is that even if the condition is
37:17 - true
37:18 - even if the condition is false the loop
37:21 - gets executed
37:22 - once suppose the condition is suppose
37:25 - the number is -1 that
37:27 - is already less than zero so
37:30 - now if i run the loop will get at least
37:33 - executed
37:34 - once so the output is -1 but
37:37 - if we use while instead of do while
37:41 - this will not get executed
37:50 - now if i click on run the console will
37:53 - be empty
37:56 - so this is the difference between while
37:59 - and do while now another thing that is
38:02 - important while
38:04 - studying loops is break and
38:07 - continue we have seen break in
38:11 - switch cases and now we will see that
38:14 - in a more elaborate way the basic
38:16 - concept of break is that wherever
38:18 - break statement is executed the control
38:21 - comes
38:22 - out of the loop so suppose i have number
38:25 - 10
38:25 - and i want to print only till 5 but my
38:29 - while loop has the condition till check
38:32 - still zero
38:33 - so what i'll basically do is i'll check
38:35 - if
38:37 - num is equal to equal to five
38:40 - then break
38:44 - and the print statement will also be
38:47 - there
38:49 - and the decrement statement also
38:52 - so now if i click on run it should only
38:55 - print till
38:56 - 6 i guess yes so you can see the
38:59 - output only till 6 is printed because as
39:02 - soon as num value became 5
39:04 - this condition became true and break was
39:07 - executed so as soon as break was
39:09 - executed
39:10 - it came out of the loop
39:14 - so that was about loops in this tutorial
39:17 - we are going to discuss about
39:19 - collections in dart
39:20 - there are basically three built-in
39:22 - collections that ships with
39:24 - dart one of them is list list is very
39:28 - similar to
39:29 - arrays that we have in most of the other
39:31 - programming languages
39:33 - we can define a list by writing the
39:36 - keyword list
39:37 - and then the name that we want to give
39:39 - to the list and a
39:40 - pair of square brackets so in this
39:43 - manner we have created a
39:45 - variable of list which has a name name
39:49 - and it has been initialized and it has
39:52 - no values in it and suppose if i want to
39:54 - initialize with certain values inside it
39:56 - then i can simply write them
39:58 - inside the square brackets and to add
40:01 - more than one value we can just
40:02 - separate them by a comma
40:07 - so over here i have a list name which
40:10 - has two values stored in it
40:12 - rishabh and ram so
40:15 - list also follows the basic indexing
40:18 - concept that we have in most of the
40:20 - programming languages
40:21 - except pascal photon etc
40:25 - that is the indexing starts at zero that
40:28 - means
40:28 - this reshop is stored at an index zero
40:32 - and ramesh is stored at index one
40:35 - so to print the values at a certain
40:37 - index we just need to write it inside
40:40 - the
40:41 - print statement and followed with a
40:44 - square brackets and inside square
40:46 - brackets we need to write the
40:47 - index and now if i click on run
40:51 - reshuffle should be printed and now if i
40:54 - change the index from 0 to 1
40:57 - ramesh should be printed
41:00 - and over here i can also change this
41:03 - list to var and it should not give us
41:07 - any error
41:08 - this is because the dart with the help
41:11 - of
41:12 - type inference automatically converts
41:16 - this variable name
41:17 - to a type or to a list type which has
41:20 - strings values stored in it
41:22 - now we can have values of more than one
41:26 - data type stored in the
41:28 - stored in the list so to do so if i
41:30 - write 100
41:32 - which is an integer and if i also try to
41:34 - add a
41:35 - double value then this will work and it
41:39 - will not give us any
41:40 - error so if i click on run 100 should be
41:43 - the output
41:44 - now suppose i want to loop through each
41:47 - of the values then the most
41:49 - easiest way is to use a for each loop
41:52 - so for that i write where i
41:58 - in name and then inside this
42:02 - i'll just print i
42:05 - and then i should be able to see all the
42:07 - values that i have inside the
42:10 - list and now if i want i can also change
42:14 - the
42:14 - values at a certain index in the list
42:17 - so if i want to change the
42:21 - value at index 1 in the list
42:24 - name then i can just simply change it to
42:28 - suresh and this should work
42:34 - and i can and it is not necessary to
42:37 - change a
42:38 - string value to another string value
42:40 - only we can give it a
42:42 - integer value also and now if i click on
42:45 - run one two three should be displayed
42:46 - instead of
42:47 - suresh so it is working fine and now
42:51 - suppose we
42:52 - want to have a list that only stores
42:55 - string then what we can do is we can
42:57 - change this
42:59 - where to list and after that inside
43:02 - angular brackets
43:03 - i will define the data type that means
43:06 - only string values
43:08 - should be there so you can see the red
43:11 - line below this
43:12 - integer and float values it is basically
43:15 - there because
43:17 - we have defined the list as a string
43:20 - values
43:21 - container list and it cannot store
43:23 - integer and double so if i remove this
43:27 - then it will not be a problem
43:30 - now if i click on run rishab and ramesh
43:34 - should be printed
43:38 - now let me change it back to var
43:42 - and i'll remove this comment and then
43:45 - i want to change the value at index 1
43:49 - from ramesh2 123 and then if i click on
43:52 - run
43:53 - then it is changing okay and now suppose
43:56 - i want i don't want to change the value
43:59 - at runtime so what i can basically do is
44:01 - i can put a const over here which makes
44:04 - the values stored inside the variable
44:06 - name
44:07 - as a constant so now you can see
44:10 - over here i am declaring the variable
44:12 - name as a constant and after that i am
44:14 - trying to
44:15 - change a value so if i run this it
44:18 - should give me an
44:19 - error so over here you can see
44:22 - uncaught error unsupported operation
44:26 - indexed set and now if i
44:29 - comment this again and try to run this
44:32 - then this should not be an error
44:37 - now after that suppose i want to copy
44:40 - this list
44:41 - to another variable so for that i'll
44:43 - create a new variable n
44:45 - and i'll just simply write name and over
44:47 - here in the loop i'll change this name
44:50 - to n and now if i click on run
44:53 - the output will be same okay but
44:57 - now if i change the value of name
45:00 - means any value of the list name
45:06 - then the values in list n will also
45:08 - change
45:12 - okay so it is giving me an error because
45:14 - i have a const over here so i'll just
45:16 - remove the const for
45:18 - now for the explanation purpose
45:21 - so now if i click on run it is still
45:23 - giving me an error
45:28 - it is because i have missed a semicolon
45:30 - over here so now if i give the semicolon
45:32 - and run this again
45:35 - so over here you can see that if we
45:37 - change the values stored in the variable
45:40 - name then the values stored in variable
45:43 - n is
45:43 - also changing so basically over here it
45:46 - doesn't copy the set of values but
45:49 - both the list variables point at the
45:51 - same location
45:53 - that is the location of the data in the
45:55 - memory
45:56 - so to avoid this we have a special
45:58 - function
45:59 - that is prefabricated in dart
46:02 - known as spread operator
46:06 - javascript developers might be familiar
46:09 - with this
46:09 - so over here what we basically do is we
46:12 - surround the variable name with square
46:14 - brackets
46:15 - and before writing the variable name we
46:17 - just simply give three simple dots
46:20 - and now after assigning if we change the
46:22 - value of
46:23 - the previous list or the original list
46:26 - then it will not be reflected in the new
46:30 - list
46:30 - so now if i click on run the output
46:33 - should be rishabh
46:34 - and ramesh so this is how we get
46:37 - the two different copies of a list
46:41 - in the last tutorial we discussed about
46:43 - lists
46:44 - and in this tutorial we are going to
46:46 - discuss about another
46:48 - collection that is called set so suppose
46:51 - i want to define a set of elements
46:53 - so i will write elements and to
46:56 - initialize a set we give a pair
46:58 - of curly braces and inside suppose i
47:02 - have
47:02 - two values for instance hydrogen
47:06 - and oxygen
47:10 - okay so now over here i have defined a
47:12 - set elements that has two values
47:14 - hydrogen and
47:15 - oxygen and to iterate through each value
47:18 - we can simply use the for each loop so
47:20 - for that we write
47:22 - for where x in halogens
47:28 - then simply for now let's print the
47:31 - value
47:32 - okay now if i run this hydrogen and
47:35 - oxygen
47:36 - should be printed in the screen okay my
47:38 - mistake instead of elements i have
47:40 - written
47:41 - halogens over here
47:44 - so now if i run this hydrogen and oxygen
47:48 - should be printed okay
47:49 - so another feature of set is that if we
47:52 - have duplicate values then it gets
47:55 - removed automatically
47:58 - so for instance suppose i add another
48:02 - hydrogen okay and now if i try to run
48:05 - this
48:06 - we will get a single hydrogen printed on
48:08 - the console
48:09 - okay so this is a feature of set that we
48:12 - use
48:14 - while programming in flutter okay so the
48:16 - next
48:17 - thing about set is that to
48:20 - initialize a set if we write something
48:24 - like this
48:25 - which is correct according to the basic
48:27 - convention okay now if i try printing
48:29 - its runtime
48:30 - type so first of all to print the
48:33 - runtime type
48:35 - we write element dot
48:39 - runtime type
48:42 - and a semicolon over here and now if i
48:46 - run this so it is giving me an error
48:49 - because
48:50 - an s is missing right over here
48:53 - and now if i run this the output is
48:57 - hash map but our task was or our
49:00 - assumption was that this will initialize
49:02 - a set so this is a common mistake that
49:06 - everyone does
49:07 - okay so the curly curly braces stand for
49:12 - a hash map and if you want to initialize
49:15 - a set
49:16 - then we can just add our data type over
49:19 - here or the data type
49:23 - of the values which we are going to
49:24 - store and now if i run this
49:26 - this should change from hash map to hash
49:29 - set
49:30 - okay and yet another method is
49:33 - we can write instead of where we write a
49:37 - set over here okay now if i run this the
49:40 - output will be again hash
49:42 - set okay and i can also
49:45 - pre-define the data type that will be
49:48 - stored in that
49:49 - set by writing
49:52 - like this and now if i run this it again
49:56 - says hash set but instead of dynamic now
50:00 - it has string over here which means it
50:02 - can only store
50:03 - string values okay so
50:07 - moving on this was about set the next
50:10 - thing that we are going to discuss
50:12 - is map that is yet another collection
50:14 - provided by dart and it is
50:16 - very much similar to dictionaries in
50:18 - python and
50:20 - hashmap in java and for different
50:23 - languages there is also some reference
50:25 - to this type of collection okay so you
50:28 - understand that how much
50:29 - important this map collection is okay so
50:33 - to create a map whereas
50:36 - for suppose say i create a map student
50:39 - okay that
50:40 - has a key value pair okay so the key is
50:43 - name
50:45 - and the value is my name
50:49 - okay then a comma then the another value
50:52 - that is another key
50:54 - that is h and the value is 20
50:58 - so mark over here i can store different
51:01 - data types as my key and as my value
51:05 - let's say the third value is email
51:08 - okay and the answer is my email
51:16 - okay so now over here i have a student
51:19 - map that has
51:20 - three key value pair the key is name the
51:23 - value is rishabh
51:24 - key is age the value corresponding to
51:27 - that is
51:27 - 20 the key is email and the value
51:30 - corresponding to it is
51:32 - my email okay and now suppose i want to
51:35 - print a particular value
51:37 - so that can be done using the key okay
51:40 - so suppose if i want to print my name so
51:42 - inside print
51:44 - i'll first write the map name and then
51:46 - inside
51:47 - square brackets i'll write the key name
51:51 - mark over here i have my key as a string
51:53 - so the key over here is also a string
51:57 - okay and now if i run this reshafts
52:00 - should be the output
52:04 - okay so this was about map
52:07 - and over here we finished the
52:09 - collections now moving forward the next
52:12 - thing that we are going to discuss
52:14 - is functions
52:18 - or you can also call them methods if
52:20 - they are inside a class
52:22 - so over here this void main is
52:25 - itself a method itself a function the
52:28 - most important function in any dart
52:30 - program
52:31 - this is where the compiler will start
52:34 - executing the code from
52:36 - okay so now suppose i create another
52:38 - function
52:40 - a very basic function called
52:43 - sum okay i am writing dynamic before
52:46 - that that defines the return type
52:48 - and dynamic stands for the value will be
52:51 - assigned the data type will be assigned
52:53 - during runtime
52:54 - okay so the return type will be
52:58 - dependent on the inputs that we give
53:01 - okay so if i write where n1
53:04 - comma n2 okay
53:07 - now simply i just return their sum
53:10 - so i write n1 plus n2
53:14 - and now over here i call this method and
53:17 - since it is returning some values so i
53:19 - need to store it in a variable
53:21 - or a shorthand of a shorthand method
53:24 - will be i directly surround it with a
53:26 - print statement
53:27 - so that the return value directly gets
53:29 - printed
53:31 - and then sum i'll pass two values
53:34 - one comma two and now if i run this
53:37 - three should be the output
53:39 - okay and similarly as i have dynamic
53:42 - over here it is not confined
53:44 - to integer only i can also pass a
53:47 - decimal value which will be
53:51 - considered as float over here and i get
53:53 - a float output
53:55 - and i can also pass a string over here
53:59 - so suppose i pass two strings
54:03 - shove and kumar and if i run this rish
54:07 - of kumar will be
54:07 - the output that means string
54:09 - concatenation has
54:11 - taken place okay now the another feature
54:14 - about functions in
54:16 - dart is that if we have a single line
54:18 - function
54:19 - then instead of writing it like this we
54:21 - can use the
54:23 - shorthand method that dot provides
54:26 - that is giving an equal to sign then a
54:29 - right
54:29 - angle sign and then just writing the
54:33 - operation that we want to provide and in
54:35 - this case it is n1 plus
54:38 - n2 and we don't need to write a return
54:40 - statement over here and now if i run
54:42 - this the output will be the same
54:44 - okay and let's again check it with an
54:47 - integer
54:48 - if i write 1 comma 2
54:54 - sorry now let's run this and you can see
54:57 - 3 is the
54:59 - output so this type of function is
55:02 - common in all types of programming
55:04 - language and this type of function is
55:06 - called
55:07 - positional functions that means the
55:10 - first
55:11 - parameter will be stored in the first
55:13 - variable
55:14 - defined inside the parenthesis and the
55:17 - second parameter will be stored in the
55:19 - second variable decided in the
55:20 - parentheses
55:22 - okay and the next type of
55:26 - arguments are called named arguments
55:29 - where we don't
55:30 - need to worry about the order
55:33 - okay so to make it a named argument i'll
55:36 - just put curly braces
55:39 - in between the parentheses and the
55:42 - variable names
55:43 - okay and now i can pass any value as per
55:46 - my choice okay so i
55:48 - i want to pass the n1 value so i'll just
55:50 - write the key name
55:51 - give a colon and the value comma
55:54 - similarly for the other parameter i'll
55:55 - write n2 that is the key name
55:58 - and a value okay now similarly if i run
56:01 - this
56:02 - the output will be three again okay and
56:05 - now the
56:05 - basic flexible flexibility that it
56:08 - provides over here is
56:10 - that i can change the order in which i
56:13 - want my value to pass
56:14 - okay so suppose i want to pass n2 as
56:19 - rishabh and n1s
56:24 - kumar so now my output will be kumar
56:26 - rishabh
56:27 - okay but if we would have gone by the
56:31 - positional method then rishabh kumar
56:34 - should have been printed but because we
56:36 - are using named arguments we are getting
56:38 - this flexibility to change the order of
56:40 - parameters
56:42 - that will give as an input to any method
56:45 - okay
56:46 - in this video we are going to discuss
56:48 - about class and objects
56:49 - in dart okay so if you don't know what
56:52 - is class and object you can refer to
56:54 - this
56:55 - website it has explained beautifully
56:57 - over here you can see we have a class
56:59 - car okay and then these objects are
57:02 - derived from this class
57:04 - okay so generally till now whatever we
57:07 - have done like whenever we wanted
57:09 - to store some value we created a
57:11 - variable and then that variable
57:13 - generally had some primitive data type
57:16 - like string
57:17 - integer and more like that okay but
57:19 - suppose
57:20 - if i want to have a collection of these
57:23 - primitive data types
57:25 - and refer to them as a single object
57:28 - then we use this class and objects okay
57:30 - so you can read more about this
57:33 - okay so back in our dot pad to create
57:36 - a class we have a keyword class
57:40 - okay and then we write the class name
57:43 - over here i am writing point that is a
57:45 - very
57:45 - common problem that we see okay means a
57:48 - common
57:49 - competitive coding question okay so i'll
57:52 - have two
57:54 - variables inside this in text and into i
57:57 - okay both are primitive data type and
58:01 - any variable that is declared inside a
58:03 - class
58:04 - is called as data members okay
58:07 - so now uh it is
58:10 - recommended that whenever we create a
58:12 - class and have some data members then we
58:15 - should
58:15 - initialize it okay and to initialize
58:19 - we have a special function inside a
58:22 - class
58:23 - called constructor which is used for
58:25 - initializing
58:26 - all the data members inside a class okay
58:30 - so now this constructor doesn't have any
58:33 - return type and it has the same
58:35 - name as we have of the class okay so
58:37 - over here the class name is point
58:40 - then the constructor name will also be
58:42 - point
58:43 - okay then we have created this
58:46 - method now inside this method what i'm
58:48 - going to do is i am going to
58:50 - initialize my data members okay so for
58:52 - that i will write
58:53 - x is equal to 0
58:56 - and y is equal to 0
59:00 - ok so this is done now to create a
59:04 - object of this class over here i'll
59:06 - simply write the class name
59:08 - and then p means that is the object name
59:11 - which is very similar to
59:12 - how we created any other variable like
59:15 - int
59:16 - x so that means we have created a
59:18 - variable x of type and
59:20 - okay and over here if we give var that
59:23 - means
59:24 - that was also correct and so is the case
59:27 - over here even if we write v
59:29 - a r over here this will also work this
59:31 - is absolutely fine
59:33 - but for the time being i am gonna use
59:36 - point okay so that it is
59:39 - clearer to understand okay so now to
59:42 - access
59:42 - any data members we simply write print
59:47 - p dot x okay and let's try printing it
59:51 - so zero should be printed
59:57 - okay so you can see we got an error over
60:00 - here
60:00 - and the error is because we have just
60:04 - created the object but we have not
60:07 - initialized it
60:08 - okay so to initialize any object we need
60:11 - to
60:12 - write the
60:15 - class name and then parentheses which is
60:18 - basically calling this constructor okay
60:20 - that means as soon as this point p will
60:23 - be created then this
60:24 - point method will be called which is
60:26 - nothing but our constructor
60:28 - so then our values will be initialized
60:31 - and the
60:31 - error will be not there so you can see
60:33 - the error is also null error that means
60:35 - the value is not
60:37 - assigned some proper quantity like this
60:40 - x and y
60:41 - are null they don't have any value
60:42 - stored in them then we are that's why
60:44 - the compiler is not able to print the
60:46 - values
60:47 - okay so let's try running this now
60:52 - so now you can see the output is 0 for x
60:56 - as we have stored 0 in x
60:58 - okay so now if i change it to 10 then
61:00 - the output should be 10
61:06 - and you can see that okay so now i'll
61:07 - remove this function for now
61:10 - we don't need function right now okay
61:13 - so this is one type of constructor now
61:16 - we can
61:17 - have some parameters assigned also
61:20 - like suppose i am giving it a value in
61:24 - 8 okay and now over here when i call
61:26 - this constructor now i need to pass this
61:29 - value a
61:30 - okay so let's say i pass 200
61:33 - okay so now over here what will happen
61:36 - that
61:37 - i am assigning the received value at a
61:40 - to this variable x so now if i print x i
61:44 - should be able to see the value that i
61:46 - have sent from here
61:47 - so let's see
61:50 - and you can see 200 is being printed
61:53 - similarly you can try
61:54 - for print
61:57 - p dot y
62:02 - now if i run this i should be able to
62:04 - see 200
62:05 - and 0 okay now the next thing that we
62:09 - are going to see
62:10 - is uh like suppose i have the
62:13 - data members as x and y and the
62:16 - parameters i am taking is also
62:18 - x and y okay so like for first i need to
62:21 - give here another parameter because over
62:23 - here i am expecting two parameters
62:26 - so now if i write if i want to assign
62:29 - this x value to this
62:31 - x conventionally i should write x is
62:34 - equal to
62:35 - x and same goes for y i should write y
62:39 - is equal to y so now at this point the
62:42 - compiler will be confused
62:44 - as to which x refers to which type of
62:48 - data like
62:48 - is this x the data member or the
62:51 - positional argument that we have over
62:53 - here and the same for this x
62:55 - that whether it is the positioner
62:57 - argument that we get over here
62:59 - or the data members okay so in
63:02 - such scenarios we have a special keyword
63:06 - called
63:07 - this okay so if i write this dot x
63:10 - and this dot y so that
63:13 - means if it is written this dot x that
63:16 - means i am referring to that data member
63:18 - of this class okay so if i write this
63:22 - inside this point class that means my
63:24 - this is referring to this class
63:26 - and this has a variable y
63:29 - has our data member x which is this one
63:32 - so
63:32 - in this data member this positional
63:36 - argument will be stored
63:37 - okay so now let's try removing this and
63:40 - see what is the
63:42 - error
63:48 - and you can see the it is showing null
63:50 - that means no value is assigned
63:52 - because over here these both are
63:54 - referred as the
63:57 - positional arguments okay so if i add
64:00 - this dot y then the error should be gone
64:03 - okay i should be able to see 200 and 100
64:07 - okay so you can see that so this is when
64:11 - this keyword comes to play okay so now
64:14 - this is one method to create a
64:15 - constructor there is
64:17 - a simpler method that a dot provides
64:20 - okay i'll remove this and i'll simply
64:23 - write
64:24 - point okay and then inside this this
64:27 - dot x comma this dot y
64:30 - and then a semicolon okay so this means
64:33 - that when we call the constructor the
64:35 - value that we store
64:36 - over here will be stored in the
64:39 - parameter
64:40 - in the named argument that we have over
64:42 - here and which is eventually a
64:44 - data member so the value received over
64:47 - here will be directly saved in this
64:49 - data member okay so now if i run this we
64:52 - will not see any error and the
64:54 - answer will also be the same but you can
64:56 - see the lines of code has reduced and it
64:59 - is a
65:00 - much more simpler way okay so
65:03 - this is it now after that the next
65:07 - thing that we have in a class is a
65:09 - function okay so our class generally
65:11 - comprises of three things
65:13 - uh data members constructor and
65:16 - some functions and the functions which
65:18 - are inside a class are called
65:19 - member functions and sometimes we also
65:22 - have a destructor
65:23 - okay so if you don't know about
65:25 - destructor then
65:27 - as we have constructor which is called
65:29 - at a star as soon as the
65:31 - object is initialized destructor is
65:33 - called as soon
65:34 - as the execution of that
65:37 - object ends okay so we are not gonna
65:40 - discuss about the destructor because
65:42 - that
65:42 - is not used a lot but if you want to
65:45 - learn you can go to the
65:47 - official documentation of that okay so
65:49 - now we are going to create a
65:51 - member function okay so i'll first
65:54 - simply create a simple member function
65:56 - that will simply print some data
65:58 - again it will have it will not return
66:00 - anything so the return type is void
66:02 - and the method name is print data
66:05 - and since it is a one liner function
66:08 - i'll write it like this
66:09 - print and then i'll use string
66:12 - interpolation
66:15 - okay and quite so now if i run this i
66:19 - should be able to see
66:21 - 100 plus 200 200 plus 100 i'm sorry
66:26 - okay so
66:29 - you can see the output is not as we
66:32 - expected and that is
66:33 - because over here i have not called the
66:36 - method that is my mistake
66:38 - okay so to call any member function we
66:40 - first need to write the object name
66:42 - a dot and then that member function
66:45 - okay so now let's try running this and
66:48 - then we should be able to get to the
66:50 - output
66:51 - okay and you can see the first two print
66:55 - statements give these two output and the
66:57 - last is this
67:00 - statement which is executing this
67:02 - function and over here we have this
67:04 - print statement
67:05 - x plus y so we are getting the value of
67:07 - x plus the value of
67:09 - y okay so this were the basics about
67:13 - class and objects so in this tutorial we
67:16 - are going to continue
67:17 - our discussion on class and objects in
67:20 - dart
67:21 - okay so now we are going to discuss
67:22 - about named constructors
67:24 - okay so sometimes we need to have more
67:27 - than one
67:28 - constructor such as one which takes two
67:31 - input values and the other one which
67:32 - takes a map okay so that may vary
67:35 - according to your requirement okay so in
67:38 - those
67:38 - places what our what we do in any other
67:41 - programming language was to create
67:43 - another constructor with the same name
67:45 - and over here the
67:48 - parameter will vary okay so that was the
67:50 - normal case that we had in java
67:53 - c or java or c plus plus okay but in dot
67:56 - this will give us an error okay so
68:00 - the way to have more than one
68:02 - constructor in a same class in dart
68:05 - is by using the named constructor okay
68:07 - that means the constructor will have an
68:09 - additional name to it okay so to create
68:12 - a cons
68:13 - named constructor we first write our
68:15 - construct
68:16 - class name okay and then the
68:20 - additional name so let's say from map
68:22 - okay and as the name suggests
68:24 - that this will take a map of type string
68:27 - and i'll call it map and then
68:30 - i'll store the value in this map to my
68:33 - data members
68:34 - okay so for that i'll write this dot x
68:37 - is equal to
68:39 - map and map will have a x value okay
68:42 - this
68:42 - dot y and then map will have a
68:46 - y value okay so this is done
68:50 - now let's try creating a point object
68:52 - using this constructor
68:54 - okay so for that over here i'll first
68:57 - instantiate an object point p1
68:59 - and then to call this named constructor
69:02 - we write point
69:03 - dot from mac
69:07 - okay and then over here as you can see
69:09 - over here we are expecting a map so we
69:11 - need to pass a map
69:13 - okay so for that i'll open curly braces
69:16 - and then the first value is x and
69:18 - let's say 10 and then the next value is
69:22 - y
69:22 - and i'll pass 20. okay then i'll close
69:26 - this bracket over here
69:28 - now over here you can see the type has
69:30 - been mentioned
69:31 - so it would be better if we mention the
69:33 - type over here also
69:35 - this is referred as a good practice okay
69:37 - so string
69:39 - and okay that means in this map the key
69:42 - will always be
69:43 - of string type and the value will always
69:44 - be of integer type any other data type
69:47 - will give us an error
69:48 - okay so now let's try calling this
69:50 - function on this p1
69:51 - object okay so for that i'll write p1
69:54 - dot
69:55 - print data
69:59 - so now let's try running this and we
70:00 - should get 10 plus 20 as the output and
70:03 - you can see that
70:04 - so this is how we have more than one
70:06 - constructor
70:08 - in the same class by using the named
70:11 - constructor
70:12 - okay so now over here you can see this
70:15 - is
70:16 - how we create a named constructor but
70:19 - this is not the
70:21 - best way actually there is another way
70:23 - and that is called
70:26 - initializer list okay so for that
70:29 - i'll remove this from here okay and
70:31 - let's see how we use an initializer list
70:35 - okay so suppose my con con named
70:37 - constructor is same
70:39 - dot from map okay and it
70:42 - takes a map of type
70:46 - string and int
70:49 - and i call it map okay now instead of
70:52 - giving curly braces
70:54 - what i'm going to do is i'll give a
70:57 - colon
70:58 - okay and then i'll initialize the values
71:00 - so i'll write x
71:01 - is equal to map x
71:05 - okay and y
71:08 - is equal to map
71:12 - y okay and then over here only we can
71:16 - call this print data method
71:18 - okay so let's see what happens print
71:22 - data okay so this means
71:26 - this method will be called after the
71:28 - value is
71:29 - stored okay so let's try running this
71:31 - i'll just remove this print data from
71:33 - here we should get the
71:34 - same output let's see
71:39 - and you can see we get the same output
71:41 - so over here you can see
71:43 - our lines of code are less and
71:46 - the work is also optimized that means
71:49 - uh before the code inside this
71:51 - constructor starts running our data
71:54 - members are initialized okay so this is
71:57 - where initializer list comes to play
72:00 - okay and we don't use initial
72:02 - initializer list
72:04 - just to initialize but for other cases
72:06 - also
72:07 - like assert
72:10 - assert x greater than zero okay so that
72:14 - means it will check if x value is
72:17 - greater than zero and if it is not
72:19 - then this constructor will not run okay
72:21 - so assert is a
72:23 - special keyword that we have in that
72:26 - okay and the code will not pass from
72:28 - here until this condition is true
72:30 - okay if this condition is false then the
72:32 - execution will stop over here
72:34 - okay so this is done
72:38 - yes so now let's try running this i hope
72:39 - there are no errors
72:42 - okay and you can see there is an error
72:47 - okay so let's see what has happened
72:50 - okay so the error over here is that x
72:52 - and y
72:53 - are not getting initialized okay so
72:55 - instead of writing it over here i'll
72:58 - write it i'll cut it from here
73:01 - remove this okay and over here i'll
73:05 - write the same thing
73:06 - okay now let's try running this and i
73:08 - think the error should be gone by now
73:11 - and the error still exists because we
73:14 - are calling this and this is
73:15 - not valid so now let's run this again
73:23 - okay so now you can see we get the
73:25 - output
73:26 - now the next thing that we are going to
73:28 - discuss
73:29 - in class is getters and setters we can
73:32 - use the same type of getters and setters
73:35 - that we use in
73:36 - any other object oriented programming
73:38 - language along with
73:39 - that there is another procedure that
73:44 - that provides okay so to get a value
73:47 - we simply write the return type of the
73:51 - value and then the keyword get
73:54 - and then the name point x okay so
73:57 - suppose
73:58 - if i call point x i want the value of
74:01 - value stored in this data member okay so
74:04 - then simply i'll write
74:08 - this dot x okay so that means over here
74:11 - return keyword is applied implicitly
74:15 - okay so now let's try running this so
74:17 - i'll write print
74:20 - p dot point x
74:24 - okay so as i told in the previous video
74:26 - we
74:27 - call all the methods inside the class
74:30 - using the
74:30 - object of that class okay so now let's
74:32 - try running this
74:33 - and 200 should be printed below this
74:37 - and you can see that okay similarly we
74:40 - can write for
74:41 - y and get
74:45 - point y okay
74:48 - and then this returns this dot y
74:51 - now similarly over here i'll print this
74:54 - print
74:55 - p dot get y
75:03 - sorry p dot point one
75:08 - now let's run this and i should get
75:10 - hundred over here
75:12 - and you can see that now this getter
75:16 - is not only used for getting the data
75:18 - members we can use
75:19 - return customized answers also okay so
75:22 - suppose if i want to return a map of
75:24 - type string
75:26 - and and i'll call it
75:30 - get map okay then this should return
75:34 - a map of type string and
75:38 - okay and the values will be x and that
75:42 - will have the value stored in the data
75:44 - number x
75:45 - okay and then it will have a value y
75:49 - okay and that will return the value
75:51 - stored in the data member y
75:54 - okay then i'll close this over here and
75:56 - as i said the return keyword is applied
75:58 - in these
75:59 - both implicitly okay so then again i'll
76:02 - call this method
76:03 - point p dot get
76:06 - mapped okay and now let's try running
76:09 - this
76:12 - okay so it is giving us an error and
76:14 - that is because instead of print over
76:16 - here i have written
76:17 - point so now let's try running this
76:23 - and there we get the result it returns a
76:25 - map where x has value
76:27 - 200 stored in it and y has a value 100
76:30 - stored in it
76:31 - that is same as we have passed in our
76:34 - constructor
76:35 - okay so this is how we use the getters
76:37 - in
76:38 - dot okay now talking about setters
76:42 - for setters also there's a different
76:44 - method that is provided by this
76:46 - dot so we simply write set that is a
76:48 - keyword in dot
76:50 - and then point x
76:53 - okay point capital x okay so now
76:57 - let's not give it uh give the same name
76:59 - i'll write set x
77:01 - okay and then it expects an integer
77:03 - value i'll call it x
77:05 - and then as we know how to differentiate
77:07 - this dot x refers to the data member
77:10 - and this refers to the parameter that we
77:13 - get over here
77:14 - okay so now let's try calling this i'll
77:16 - call
77:17 - p dot set x
77:21 - okay and then it returns expects a value
77:24 - i'll give
77:25 - 500 to it okay and then simply p dot
77:29 - print data
77:36 - okay now let's try running this
77:43 - okay so over here you can see we got an
77:44 - error so the error was
77:46 - instead of passing it as a parameter i
77:49 - pass it with an equal to sign
77:51 - okay so now let's try running this
77:54 - and you can see instead of 200 the value
77:57 - has now changed
77:58 - to 500 similarly we can set x
78:01 - set y for the y parameter and then
78:04 - similarly we can take a map
78:06 - and then map it to our data members like
78:08 - we did in the named constructor part
78:11 - okay so this was about getters and
78:13 - setters and by this we complete the
78:15 - basics
78:15 - of class and objects in that
78:21 - okay so the next thing that i want to
78:23 - discuss is about
78:24 - enums okay so enum is a special type of
78:28 - class
78:28 - that represents fixed number of constant
78:31 - values
78:32 - okay so to create and enum okay so now
78:36 - suppose we have a payment status
78:38 - okay like the payment status will have
78:41 - three values and
78:42 - those three need to be fixed values okay
78:45 - so in those cl
78:46 - those cases we use an enum okay so for
78:49 - enum we write the keyword
78:51 - enum and then let's say payment status
78:54 - that is the example scenario that we
78:56 - have taken
78:58 - payment status okay and then this has
79:01 - three values
79:02 - first one is not
79:05 - paid then otp
79:08 - sent and then paid
79:13 - okay so this can be the three members
79:15 - i'll give a semicolon over here
79:18 - comma over here
79:22 - okay i think we don't need a semicolon
79:24 - over here yes we don't need it
79:26 - so we have an enum over here that has
79:28 - three values not paid otp sent
79:30 - and paid okay so over here we can create
79:34 - a
79:36 - object of this enum okay so for that
79:38 - i'll add
79:39 - final status and to store any value from
79:43 - this enum we first write
79:45 - the enum name that is payment status
79:51 - dot not sent not
79:54 - paid okay so now
79:57 - we have a status which will have a data
80:00 - type of payment status and it has a
80:02 - value
80:03 - you can see in a payment status if i
80:05 - click on this also
80:07 - we will get the same thing that is
80:09 - payment status status
80:11 - okay so the status right now is not paid
80:13 - now to check
80:14 - so this is actually used widely when we
80:18 - use a switch case okay so in smith case
80:20 - i have a status
80:22 - okay and then i'll i'm sorry
80:26 - in such case we have a status and then
80:29 - over here the first
80:30 - case is case payment
80:34 - status dot not
80:37 - paid and if that is true then we want
80:41 - to do something
80:45 - and then similarly for the other two
80:47 - statuses
80:48 - okay so now you might be thinking that
80:50 - why do we use
80:51 - uh enum even when we can simply write it
80:55 - uh use it as a string or as an integer
80:58 - okay so enum is used for standardizing
81:01 - the
81:02 - values okay so now suppose over here if
81:05 - you have the
81:06 - stay
81:12 - santos
81:25 - okay so now suppose over here the status
81:28 - is
81:29 - not paid okay and
81:33 - in the switch case we are checking
81:35 - switch
81:36 - and then case and the case is
81:39 - not paid okay so you can see
81:43 - this is a common mistake that we can do
81:46 - like over here we have a capital p over
81:48 - here we have a small
81:49 - p and using enum we can avoid all these
81:53 - types of mistake also so that is another
81:56 - benefit of using enum
81:58 - so in this video we are going to discuss
82:00 - about error handling in dart
82:03 - and you might be thinking why we are
82:05 - using this editor instead of the dart
82:07 - pad
82:08 - and the reason is that in dot pad it
82:10 - automatically handles the
82:12 - exception okay and as we are discussing
82:15 - about error handling so we need
82:17 - to see the errors okay not all the
82:20 - errors but maximum errors in the dart
82:22 - pad
82:22 - is handled by itself okay so the concept
82:25 - of error handling is same as in any
82:27 - other object oriented programming
82:29 - language
82:30 - okay we have a try and then we have a
82:34 - catch
82:36 - okay and then this catch block takes an
82:38 - exception
82:39 - okay and if you don't know what is an
82:41 - exception so that means that is a
82:44 - technical term used for errors
82:46 - okay so in your program if there is an
82:48 - error then it is referred
82:49 - to an exception okay so and in the catch
82:53 - block
82:54 - we deal with the exception
82:58 - okay so now let's try creating an error
83:01 - okay and without this try and catch
83:03 - block
83:04 - so i'll use the most popular example for
83:07 - errors
83:08 - for creating errors that is division by
83:10 - zero
83:11 - okay so i'll create a variable a 10
83:14 - sorry it should be 10 and then
83:21 - and then another variable b that is 0
83:25 - and then in variable c i'll
83:28 - store the quotient
83:31 - so a by b okay and then i'll print
83:35 - c so now let's try running this and see
83:38 - what is the answer
83:42 - and you can see we are getting infinity
83:44 - as the answer
83:45 - okay so that is because whenever we
83:48 - divide
83:48 - by zero in that it automatically gets
83:51 - converted
83:52 - to a double value okay and in the double
83:56 - data type
83:56 - in dot we have a certain value for
83:59 - infinity
84:00 - so as this will give an output of
84:03 - infinity so it is automatically
84:05 - converted
84:05 - into double and the infinity value is
84:08 - assigned
84:09 - to this variable c that is why we are
84:11 - getting infinity as the output
84:13 - okay so to prevent from the changing of
84:16 - data types
84:17 - we need to add our tilde symbol over
84:20 - here
84:21 - so now let's try running this again okay
84:23 - and now since the
84:24 - it is not being converted we should get
84:26 - an error okay and you can see
84:28 - we are getting an error and as i told
84:31 - error is referred as exception so there
84:33 - is an
84:34 - unhandled exception and that is
84:37 - integer division 0 exception okay that
84:40 - means it is very much understanding that
84:42 - we have divided by 0 and that is why we
84:44 - are getting this exception
84:46 - okay but now suppose this exception is
84:49 - in an
84:49 - app and the user sees this error message
84:53 - so he might not be able to understand
84:55 - what this
84:56 - means okay so at that places what we do
84:59 - is
85:00 - we surround them with a try and catch
85:02 - block
85:04 - okay so over here a try and every try
85:07 - block needs to be followed by a catch
85:09 - block
85:10 - okay and then it takes an e that is the
85:12 - extra
85:13 - exception and that will be an object of
85:16 - this exception
85:17 - okay and then instead of printing these
85:21 - things i'll simply print
85:25 - division by zero
85:29 - is not possible
85:33 - okay and now let's try running this
85:34 - again
85:39 - and you can see that the catch block
85:42 - has been executed and it is printing
85:44 - division by zero is not possible
85:47 - okay so this is what happens normally in
85:49 - try and catch block
85:51 - the we keep the code where we expect
85:54 - it to find some error inside the try
85:56 - block okay
85:57 - and if some error is found then that
86:00 - terminate
86:00 - execution is terminated then and there
86:03 - and the
86:04 - catch block is executed instead
86:07 - okay so this is the use of try and catch
86:09 - block and this is how we generally use
86:11 - try and catch block in most of the
86:13 - programming languages
86:15 - okay so now in dart there is another
86:18 - thing that it provides us
86:19 - okay and that is for specific exception
86:23 - handling that means
86:24 - if it is a division by zero exception
86:27 - then we will handle it differently
86:29 - otherwise we will handle it
86:31 - differently
86:34 - okay so for that what i'll write over
86:37 - here
86:37 - is on okay so on is a keyword in
86:41 - dot and then the exception name integer
86:47 - division by
86:51 - exception okay so if this is the case
86:54 - that means integer division by
86:56 - zero exception is the case then we will
86:58 - then this
86:59 - statement will be printed so let's try
87:02 - running this
87:05 - and you can see division by zero is not
87:08 - possible that is inside our this on
87:10 - block
87:11 - okay now along with this let's try to
87:14 - let's try and check if we can have
87:16 - another catch block or not
87:18 - okay so now inside this i'll simply
87:20 - print
87:23 - another catch block
87:26 - and let's run this and see what happens
87:31 - okay so you can see
87:33 - only the on block is being printed and
87:36 - not the
87:36 - catch block means if the exception
87:39 - is of this type then only this block
87:41 - will be executed
87:42 - and not the catch block and if the
87:45 - exception is
87:46 - not of this type then only catch block
87:49 - will be executed
87:50 - okay so now let's create another
87:52 - exception i'll comment this
87:54 - out for now
87:57 - and i'll create a list let's say
88:00 - s is equal to one comma two comma three
88:04 - comma four
88:05 - and i try to print the value
88:08 - out of index okay so that means s4
88:12 - where the list has index only till three
88:16 - zero one two and three so let's try
88:18 - executing this and see
88:25 - and now you can see it is giving me some
88:27 - different type of errors which is not
88:29 - actually an error but it isn't warning
88:31 - and that is because over here i have
88:33 - forgot to give the data type now let's
88:35 - try running this again
88:38 - and you can see the error has been
88:41 - created over here
88:42 - and since it was not of this type so
88:43 - this block is not executed
88:45 - instead the catch block is executed
88:49 - okay so this is how we handle error
88:51 - specifically means
88:53 - handle error for specific exception in a
88:56 - specific way
88:57 - okay and suppose if we want to get an
89:00 - object over here also
89:01 - so after this what we need to do is
89:04 - simply write
89:05 - catch e okay so that means
89:08 - when this is the exception then the
89:10 - exception will be catched over here and
89:13 - then inside this we can do whatever we
89:14 - want to do with
89:16 - this e block okay
89:19 - so this was about to try catch and this
89:22 - specific error handling now the next
89:25 - thing that
89:26 - we generally discuss in error handling
89:28 - is a
89:29 - finally block okay so that means
89:32 - whether the try block is executed
89:34 - completely
89:35 - or if there is some exception and a
89:37 - catch block is
89:39 - executed no matter what is the case
89:42 - after this whole part is over
89:45 - finally block will always be executed
89:49 - okay so let's see print
89:54 - always executed
89:57 - okay and now let's try running this
90:03 - and you can see the catch block has been
90:05 - printed means the statement inside the
90:08 - catch block has been printed
90:10 - and the finally block has also been
90:12 - executed
90:13 - okay so this was the case when there is
90:15 - an error
90:16 - now let's see if there is not an error
90:20 - okay then as i said this try block
90:23 - should be executed and then the finally
90:26 - block
90:27 - because that is always executed okay so
90:30 - this was about
90:31 - finally blocked okay so the last
90:34 - thing about exception that we need to
90:37 - discuss is creating a custom
90:39 - exception okay so for that i'll create a
90:42 - custom
90:43 - exception class okay since we are
90:45 - studying an
90:46 - object oriented programming languages
90:48 - most
90:49 - of our working will be done via
90:52 - class okay so i'll create a class
90:56 - age exception okay which will throw an
90:59 - error when the ages below zero which is
91:02 - not technically possible
91:04 - so class age exception implements
91:08 - okay so this is the way of inheriting
91:11 - another class properties okay or
91:13 - abstract class to be more specific
91:16 - implements exception okay so we have an
91:19 - exception
91:20 - class already inside that okay now
91:23 - inside this all we need to do is create
91:25 - a define our method string
91:29 - er msg or you can name it
91:32 - as and how you like okay so
91:36 - what it basically does is by
91:38 - implementing this
91:39 - exception we are basically able to throw
91:42 - this type of exception okay and whatever
91:44 - we do
91:44 - inside this doesn't matter with the
91:47 - throwing of exception okay this is our
91:50 - custom choice what we want to do with it
91:52 - okay so over here this will simply
91:55 - return
91:56 - h cannot be zero
92:00 - it cannot be less than zero
92:05 - okay so now over here
92:09 - let's see i'll remove this
92:14 - thing from here and now
92:17 - over here i'll create a variable
92:21 - a v r a is equal to
92:24 - minus 10. okay so that means
92:27 - if a stands for h so i'll check if
92:31 - a is less than
92:35 - 0 then i want to call this exception
92:38 - okay so to call this
92:40 - exception there is another keyword throw
92:42 - which creates an exception and
92:44 - throws it to the catch block if it has
92:46 - any or to the user if we don't surround
92:49 - it with a try and catch block
92:51 - so throw and then we write
92:54 - age exception
92:58 - okay so now let's see what happens
93:07 - and you can see we got an exception the
93:10 - exception was thrown over here that's
93:12 - why the catch block got executed
93:15 - and the finally always gets executed
93:18 - so in this video we are going to discuss
93:20 - about asynchronous operations
93:22 - in dot okay so the question that arises
93:26 - is why asynchronous operations
93:29 - so the answer to that would be a
93:31 - synchronous operations
93:33 - let your program keep running while
93:35 - waiting for another
93:37 - operation to finish okay so let's say
93:40 - for example
93:42 - we want to store data in our server
93:45 - so this type of operation doesn't
93:47 - execute instantly but might
93:49 - take some time depending upon the
93:51 - internet speed or
93:52 - size of data etc so if we don't use
93:56 - asynchronous operation user will
93:58 - have to wait until our program is
94:01 - interacting with the server which will
94:03 - create
94:04 - a bad user experience so to prevent that
94:08 - we use
94:08 - asynchronous operations and for this
94:11 - purpose
94:12 - that provides us three special keywords
94:14 - to use
94:16 - they are future a sink and a weight
94:20 - so first we are going to discuss about
94:24 - future okay so a future represents the
94:27 - result of an
94:28 - asynchronous operation and can have two
94:31 - states only
94:33 - either uncompleted state or completed
94:36 - state
94:37 - so how this works is when we call an
94:40 - asynchronous function
94:42 - it returns a uncompleted future
94:46 - and then future is waiting for the
94:48 - functions
94:49 - asynchronous operation to finish or
94:52 - throw an error
94:53 - and soon as it finishes or throws error
94:57 - the future state
94:59 - changes from uncompleted to completed
95:03 - okay so let's take an example
95:06 - and the keyword future we have capital f
95:10 - in it okay so let's say we have a future
95:13 - method
95:14 - a future function we call it
95:17 - fetch user data
95:25 - and what it basically does is return
95:32 - future dot delayed
95:35 - okay so this means that using this
95:37 - delayed
95:38 - method we can delay the process for some
95:41 - times that
95:42 - is equivalent to sleep in
95:45 - multi-threading in java
95:46 - or in any other common programming
95:48 - language
95:50 - i mean object oriented programming
95:51 - language
95:53 - okay so then we have another class
95:55 - called duration
95:56 - and it takes all the time parameters
96:00 - that is seconds minutes hours days
96:03 - okay so for now suppose we assume that
96:06 - our
96:08 - program will take two seconds to
96:10 - interact with the server so
96:12 - i'll give it a seconds
96:16 - and that is to that means i this
96:19 - will wait for two seconds and then start
96:22 - executing okay and
96:24 - we are doing this because we have
96:26 - assumed two seconds to be the time
96:29 - of our program to be interacting with
96:31 - the server
96:32 - okay so after this we have an unnamed
96:35 - function
96:36 - which contains the code that will be
96:38 - executed after
96:39 - this delay of duration two seconds
96:44 - and simply i wanna print data
96:48 - okay so this is our function now we can
96:51 - also
96:52 - specify the return type of the future
96:55 - okay
96:56 - now over here in this fetch user data i
96:59 - have a return keyword but it is not
97:01 - actually returning any data it is simply
97:03 - printing the
97:04 - word data that means i am not returning
97:08 - anything
97:08 - and if i am not returning anything then
97:10 - we all know the keyword which is
97:12 - void which means this function will not
97:15 - return
97:15 - any data now i'll comment this out for
97:19 - now okay now after that i'll call this
97:23 - method
97:24 - fetch user data
97:30 - and after that i can say have a print
97:34 - statement
97:37 - switching user data
97:40 - okay so now let's try running this
97:47 - okay so now you can see we have fetching
97:50 - user data first
97:51 - and then data but actually according to
97:55 - the convention we have first called
97:57 - fetch user data which is this method so
97:59 - this
98:00 - should be printed first so that means
98:02 - our
98:03 - delay function is working fine and that
98:06 - is
98:06 - how uh the asynchronous functions work
98:10 - that means over here if there is a delay
98:12 - of two seconds it will not wait
98:15 - for two seconds to execute the rest of
98:17 - the code
98:18 - it will directly start executing the
98:21 - rest of the code and
98:22 - as soon as this finishes
98:25 - the future states become completed and
98:28 - it hardly affects the
98:31 - rest of the execution of the program so
98:34 - then this function is called an
98:36 - asynchronous function okay that means
98:38 - our program is still running
98:42 - and not caring about the completion of
98:44 - this function
98:46 - means the completion of execution of
98:48 - this function
98:50 - okay so this is how we use futures
98:54 - okay so the next thing that we are going
98:56 - to discuss is async and
98:58 - await so these keywords provide a
99:01 - declarative way to define a sync
99:03 - function
99:04 - and use the result okay so let's say
99:07 - this function remains same and instead
99:10 - of printing data now it actually returns
99:13 - something and which is eventually a
99:16 - string
99:16 - okay so means after two seconds data
99:19 - will be returned
99:20 - okay and now if it is returning string i
99:22 - need to change this to
99:24 - string okay and now
99:28 - after that over here i'll create another
99:31 - method which is
99:33 - string and i'll call it user message
99:40 - okay anything that we like
99:43 - and then what it basically does is where
99:46 - data
99:48 - is equal to fetch
99:51 - [Music]
99:53 - user data means we are calling this
99:56 - method
99:59 - okay and then i am simply printing this
100:03 - uh simply returning a string because we
100:06 - have a string return type here
100:08 - return data
100:12 - and now in our main method all we do is
100:15 - we remove all these
100:17 - thing and we write print
100:22 - user
100:23 - [Music]
100:26 - msg okay now over here you can see it is
100:29 - giving us an error so all we can do is
100:32 - surround it inside quotes and do string
100:35 - interpolation
100:36 - okay so now uh dart will infer that it
100:39 - is a string
100:40 - so now let's try running this and see
100:43 - what is the output
100:49 - okay so as according to the convention
100:53 - the output should be data but instead of
100:55 - that we are getting a
100:56 - future of string that means as i earlier
101:00 - said if we execute a future it returns
101:03 - a future and that is in
101:06 - uncompleted state and it is expecting to
101:09 - be completed or thrown error
101:11 - okay so now over here you can see
101:15 - what basically happened was that this
101:17 - function was executed
101:18 - and as this is a synchronous operation
101:21 - it didn't wait for this function to
101:23 - finish
101:24 - and returned the data and why
101:27 - and since this this was not yet finished
101:30 - it returned the uncomplete state of
101:33 - future and that is why we are getting
101:36 - such type of output okay so this is what
101:39 - we call a
101:40 - uncompleted future okay and completed
101:43 - future
101:44 - has a proper accurate value okay
101:48 - so i hope you are understanding what i
101:50 - am trying to say and now to prevent such
101:53 - type of error what we need to do is we
101:55 - will use the async
101:56 - and await keyword okay so what a weight
102:00 - keyword basically does is
102:02 - that it will wait for this function
102:05 - to execute or basically it will wait for
102:09 - this function's future to be of
102:12 - completed state
102:14 - okay and then this await function is
102:17 - giving an error over here and that is
102:18 - because
102:19 - a weight function never goes without
102:22 - a sync function okay a sync end of it
102:24 - always go together
102:26 - okay if we write a wait and don't write
102:29 - a sync
102:29 - it will give us an error however vice
102:32 - versa will not
102:33 - give an error and that is because a sink
102:36 - is
102:37 - just allowing that function to use a
102:40 - weight and then if we don't use a weight
102:42 - then that is not a problem
102:44 - but if we use a weight and we have not
102:46 - allowed that function to use of it
102:49 - then that thing will give us a problem
102:52 - okay i hope you are understanding these
102:55 - things
102:56 - now as you can see this is now a
102:58 - asynchronous function
103:00 - and over here also you have seen a
103:02 - synchronous function but
103:04 - the difference between these two
103:05 - asynchronous functions were
103:07 - this asynchronous functions a function
103:10 - returns a future
103:11 - while this asynchronous function is
103:13 - returning a string
103:15 - and that is why we are getting error
103:17 - over here
103:20 - because asynchronous functions always
103:23 - return a future
103:25 - okay so instead of string this will now
103:27 - be
103:28 - future string
103:40 - so now it is a future string and
103:43 - since it also will now return over here
103:47 - uh uncompleted state of future
103:50 - and we want a completed state of future
103:53 - that means we want some actual
103:55 - result we will use a weight over here
103:57 - also
103:58 - and now since this is using a weight we
104:01 - need to give
104:02 - a sink over here keep in mind async is
104:05 - always after the ending parentheses
104:08 - and before the opening
104:11 - curly braces okay so now let's try
104:14 - running this program and now
104:16 - instead of getting this instance we
104:19 - should
104:20 - be able to see this data being printed
104:24 - so let's see
104:28 - and you can see as soon as the execution
104:31 - is completed
104:32 - it waits for two second and then data is
104:34 - being printed
104:35 - so it is waiting for 2 second because
104:37 - over here we have used a weight which is
104:39 - making
104:40 - the program stop for 2 seconds until
104:42 - this
104:43 - has a completed state of future and the
104:46 - same goes
104:47 - over here so this were
104:50 - all the basics about future async and
104:53 - await
104:54 - okay so i hope everything was clear
104:56 - thank you