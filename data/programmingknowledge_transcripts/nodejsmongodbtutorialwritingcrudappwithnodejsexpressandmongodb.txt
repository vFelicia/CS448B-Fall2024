00:00 - hi in this video we are going to learn
00:02 - about mongodb
00:04 - so before getting started with mongodb
00:07 - we have to know what is mongodb
00:10 - well mongodb is a general purpose
00:13 - document based distributed database
00:16 - built for modern application developers
00:19 - and for the cloud era
00:22 - and the data that is being here stored
00:27 - is stored as a like documents
00:31 - and it's called as a non-sql database
00:35 - there is no schema there is no structure
00:38 - here
00:39 - so it's very flexible compared to as the
00:43 - sql database
00:45 - so let's start with uh
00:48 - signing up here or registering here
00:53 - so we are going to click on the try free
00:56 - button and here you can
01:01 - get started free after signing up
01:04 - you will go to the atlas space
01:08 - cloud atlas space server
01:11 - because we are going to use as a live
01:14 - as a production deployment basis
01:21 - so when you start free you have
01:25 - already signed up and after signing up
01:29 - after signing signing up you will go to
01:32 - this space where you
01:33 - have to create a new project
01:37 - so let's say our project name is
01:42 - tv demo
01:47 - after that you will be redirected to the
01:52 - this space which called give remember
01:55 - that's
01:55 - not necessary we can create here create
01:59 - project
02:03 - after that you will be on this page
02:05 - where you have to select builder cluster
02:08 - here we are going to use create a
02:10 - cluster that is a free
02:14 - and we are going to use this cloud
02:17 - provider
02:18 - aws and wherever you are
02:22 - select the nearest server
02:28 - after that in the cluster tier we are
02:30 - going to use
02:31 - free forever and there is no need
02:36 - you can change the name of your cluster
02:38 - if you want to
02:39 - now we are going to create a cluster
02:45 - it will take some time to create the
02:47 - cluster
02:49 - so now we are okay and now we are going
02:52 - to see how can we get started with
02:54 - the mongodb in our app well
02:57 - for app we have to use the mongodb
02:59 - driver that
03:00 - is pre-built and that is being used here
03:07 - so in here we are going to use mongodb
03:10 - driver
03:10 - so let's open our project
03:17 - now we are going to create a new project
03:19 - let's say
03:26 - let's say mongodb demo now we're going
03:28 - to go to this
03:30 - mongodb demo folder
03:34 - one sec
03:37 - yeah db demo now we are going to
03:42 - initialize the npm using npmany that's
03:45 - what
03:50 - and now we are going to open our editor
03:54 - the visual studio code
04:01 - so for uh using the mongodb
04:04 - here we are going to install two things
04:10 - first one is mongodb
04:16 - express
04:22 - here you can see that the mongodb and
04:24 - express has been installed here
04:27 - so for starting this starting the
04:30 - project we are going to use
04:31 - npm node node
04:35 - app the file that i have not created
04:38 - right now
04:40 - and for their part we are going to
04:42 - create we are going to use nodemon
04:46 - nodemon app
04:49 - so for nodemon we are going to install
04:52 - it
04:55 - in the dev dependency part
04:58 - using
04:59 - [Music]
05:02 - nbm install test test save
05:06 - test the save dash dev node
05:11 - now here we can see that in this space
05:14 - the
05:14 - connection has been made so for
05:16 - connecting it into
05:18 - our app we are going to click on the
05:22 - connect
05:24 - and here you will see
05:27 - that there are some connection
05:30 - requirements are needed so first of all
05:33 - we are going to go to the database
05:36 - access
05:39 - here we are going to create a new user
05:42 - let's say instrument
05:46 - and let's also generate a secured
05:50 - password
05:51 - and we are going to select read and
05:52 - write to any database
05:57 - now we are going to select the network
05:59 - access
06:01 - here we are going to add the ip address
06:04 - which is either add current diapers
06:07 - which is
06:08 - help to give the secure
06:12 - authentication
06:16 - now if we go to our cluster
06:20 - section now we are going to
06:24 - connect now we are going to connect to
06:28 - the
06:28 - cluster so for connection we are going
06:31 - to use the connector application
06:35 - here we are going to use this connection
06:37 - string
06:40 - so let's copy it let's copy it
06:45 - after copying it we are going to
06:50 - now into our app we are going to create
06:52 - a new file
06:53 - let's say app.js
06:57 - in here we are create the express module
07:02 - or take the express module from the
07:06 - express
07:09 - and we are going to use the app
07:15 - and requiring the express
07:18 - as a function
07:21 - and it will listen to the port 3000
07:26 - for installing the server so
07:29 - it's complete the server can be started
07:34 - but here we are going to use
07:37 - how to get started with the tv
07:41 - so we are going to let's say
07:44 - we are going to create a new folder
07:46 - let's say utils
07:50 - in here we are going to create a new
07:52 - file let's say
07:54 - db dot js
07:59 - in here we have installed the mongodb
08:02 - driver into our project
08:04 - so we are going to require it from the
08:07 - mongodb
08:09 - and say mongodb
08:13 - is equal to require
08:18 - mongodb in here there is some called
08:21 -  client
08:23 - which we are going to require from it
08:27 - which is a
08:31 - which is a property of it which is a
08:34 - file of it which is a field of it
08:38 - so in here
08:43 - we are going to connect to it as a
08:46 - client
08:47 - for connecting we are going to use
08:49 - client
08:50 - dot connect in here we are going to
08:54 - pass the url
08:58 - so for passing it here
09:01 - we have used the password but
09:04 - as i have forgotten the password we have
09:07 - to
09:09 - again require the password for requiring
09:13 - it here
09:15 - we are going to edit it
09:18 - and edit the password here we are
09:21 - going to auto generate it from here
09:25 - and we are going to require it from here
09:31 - and let's update the user
09:35 - now in here there will be the url
09:40 - so let's see here is the password and
09:43 - we are going to
09:47 - get a srv string from the connection
09:52 - so here we are going to again copying it
09:58 - and let's say here const
10:01 - url is equal to
10:05 - this one so here we are going to
10:08 - cut from here and paste into it here the
10:12 - password
10:15 - after doing this we are going to use the
10:18 - url as a parameter here
10:22 - and that's it
10:28 - we are going to connect from here
10:33 - it will take a callback function and it
10:36 - will take two arguments
10:38 - first one is error if there is
10:42 - and second one is the client
10:48 - and now if we
10:51 - say if there is error
10:54 - then return if there is no error
10:59 - let's console out the client base
11:02 - client
11:05 - now that's it if we start here from
11:09 - npm run dev
11:15 - so if we run it it will say nothing it
11:18 - gives nothing
11:20 - that's because we have started the app
11:24 - file but
11:25 - we haven't connected with the dvd.js
11:28 - file
11:29 - so for connecting it we have to like
11:34 - say all the code is here so
11:38 - before cutting or pasting it from here
11:41 - to here
11:42 - we can do this like we are going to
11:44 - require it
11:47 - from dot utils
11:52 - and get a db file
11:56 - so if we run this
11:59 - now we can see that it will give the
12:03 - client back
12:06 - so here it returns the client
12:10 - all the things all the fills that are
12:12 - here
12:15 - now here we are going to see how can we
12:17 - deploy the operation
12:18 - that is create re update
12:22 - and delete so for
12:25 - doing the crud operation
12:28 - we are going to you we are going to use
12:30 - the client
12:33 - and by client means we are going to
12:36 - create a new const tv
12:41 - which take the client
12:44 - and db and let's say our
12:48 - database name is the test
12:52 - so test is a database for the collection
12:56 - means for a table in the sqlize
12:59 - database where here we are going to use
13:01 - the collection
13:03 - as a table so let's say the name is user
13:09 - users in here we are going to first
13:13 - use the insert means create how can we
13:16 - create a
13:18 - document in the collection
13:21 - so let's see if we are clear going to
13:23 - create a one
13:25 - document we are going to use the insert
13:27 - one method
13:30 - in this we are going to give an
13:33 - object let's say name
13:36 - anseman is
13:41 - 21.
13:45 - after that this returns a promise
13:48 - so for handling the promise we are going
13:50 - to use a 10
13:53 - which takes a result which gives a
13:56 - result
13:57 - and we are going to console.log
14:01 - the objective we have sent using result
14:05 - rest.ops and if there is an error
14:08 - you can see it from here like e
14:12 - console dot log error
14:18 - now if we save it
14:23 - and see that there is one
14:26 - document that we have inserted that is
14:29 - this one
14:30 - and if we sing to our
14:34 - more atlas we are going to see in the
14:37 - collection
14:41 - and here we are going to see that there
14:43 - is a database that is called test
14:45 - and the document
14:49 - or a collection that is called users
14:55 - one docs instrument instruments
14:59 - so we can also use how can we
15:02 - insert more than one
15:06 - document we can do that by using another
15:09 - method
15:10 - let's say you can do this by using db
15:13 - dot collection
15:16 - users
15:21 - users dot insert
15:25 - many here we are going to
15:29 - use the array because we are sending
15:32 - more than one
15:33 - document so by doing this
15:37 - we can send more than one document let's
15:40 - say here
15:43 - renee
15:47 - is 21
15:51 - or let's say 27
15:54 - and another user let's say
15:59 - ankur
16:02 - is 25
16:07 - so it will be a number so
16:10 - here also will be number
16:13 - so we have inserted two documents here
16:17 - now it's a promise so we have to use the
16:21 - promise
16:22 - sequence we are going to use 10
16:26 - and console.log
16:29 - the result that we have sent using
16:33 - response start ops
16:36 - and also we can case the error by using
16:39 - catch method and see if there isn't any
16:42 - error
16:42 - we can console it now if we send it back
16:49 - we will see
16:53 - that we have sent two documents vinay
16:56 - and ankur
16:58 - now if we refresh it
17:01 - we will see that there is two documents
17:04 - vinay and ankur
17:09 - now we are going to see
17:12 - how can we find or read
17:16 - any data
17:19 - so for reading a document we can do so
17:22 - by
17:25 - using another method that is used
17:29 - it is tv dot collection
17:33 - users dot find
17:37 - if we are going to find one means we are
17:39 - going to find only one document
17:41 - we have to use find one method and lets
17:44 - say we are going to find
17:47 - we are going to filter out the document
17:49 - that we are going to use
17:51 - let's say s will be the 27 that means we
17:54 - are going to find the
17:56 - document that is vinay
18:00 - now let's take a call back so we can use
18:03 - the dollar
18:04 - 10 response and it will
18:08 - log out the result
18:11 - by using response
18:15 - and if also if there is an error we can
18:17 - catch it
18:18 - using console
18:22 - dot log editor now if we save it and
18:28 - use it you can see that we have we have
18:30 - been returned
18:31 - with the name binay and the s27
18:35 - now we can also
18:38 - find all the documents by using
18:42 - another method that's called
18:47 - db.collection users
18:51 - dot find well fine is being is
18:56 - different from other methods well it's
18:59 - uh
19:00 - it gives a pointer so it gives a
19:04 - cursor back so we are going to use
19:10 - to array means it will return
19:14 - the file as an array and now we can use
19:17 - the response
19:24 - and response back
19:27 - and if there is an error we can
19:31 - error it by using console
19:35 - dot log error
19:38 - now if we save it we will see it returns
19:42 - all the documents because we have same
19:44 - nothing
19:45 - so it returns all the answer and we need
19:48 - occur
19:50 - now if i send like something called is
19:53 - is equal to 25
19:56 - or 24 here we see there is no documents
20:01 - like this
20:02 - now if we save this it will not give an
20:05 - error
20:06 - it will just send back an array means
20:09 - it's an error
20:11 - so it's not an error if you send the
20:14 - send out of filter value that is not
20:16 - being there
20:17 - in a collection
20:21 - so the our operation is completed
20:24 - now we are going to see how can we use
20:27 - the
20:28 - you operation it is update
20:31 - so for updating our document
20:37 - we are going to use update 1
20:40 - and update menu update is being
20:44 - duplicated from the
20:45 - newer version so we are going to use
20:48 - update 1
20:48 - and update menu for updating only one
20:52 - document we are going to use update 1
20:56 - by sending one parameter that is the
21:01 - is 21 and updating
21:04 - it with some value
21:08 - and it's also is a different from
21:13 - how can we set it so for setting it we
21:16 - are going to use dollar set
21:20 - and we are going to send back
21:23 - the updates and value as is
21:28 - 59
21:31 - now it's complete now it's a promise
21:36 - so we are going to send dot 10
21:40 - response and if we see
21:43 - and if we console it into our command
21:46 - prompt
21:47 - we will see that it returns a very big
21:51 - heavy object and
21:58 - let's save it
22:01 - and we will see that it gives a heavy
22:04 - object
22:05 - now if we see that we have
22:09 - updated the value of the s21
22:14 - that is
22:17 - that is unsure so if we see here
22:21 - and if we refresh it here
22:27 - we will see that the s is different
22:31 - as is 59 so that's how update is done
22:37 - and here gives the response gives a very
22:39 - big heavy
22:41 - load and we only want
22:44 - two main fields like matched count and
22:47 - modified count
22:50 - so for updating more than one file
22:53 - we can use like we are going to use
22:56 - another method that's called
22:57 - that is jb dot collection
23:01 - users dot update many
23:05 - and if we send it here like nothing
23:08 - so it will be updated all in all the
23:11 - documents
23:12 - so let's say we are going to
23:15 - increment all the a's
23:21 - by one so if for it we are going to use
23:24 - one that means we are going to increment
23:26 - by plus one
23:28 - or if we are going to decrease we can
23:30 - use minus one
23:32 - so we are going to use plus one
23:36 - so it's an response it's sensory it's a
23:39 - promise
23:41 - so we are going to also again using use
23:43 - the dot gain method
23:46 - and it's going to send the
23:49 - response and we are going to use only
23:52 - one thing that is called modified count
23:56 - and if there is an error we can use
23:59 - catch method
24:02 - and we are going to console it here
24:06 - now if we see it and if we save it in
24:09 - and we will see that all the
24:12 - documents are being modified and the
24:14 - modified count is three
24:17 - now if we refresh sitting down into our
24:19 - cloud service base
24:20 - mongodb we will see that
24:24 - ulnsman is is 16
24:27 - we need age is 28 and cruz is 26.
24:33 - now you have or we have
24:36 - done the new operation that is update
24:40 - operation
24:41 - now we are going to see how can we use
24:44 - the
24:44 - last operation d that is delete
24:49 - so for deleting any document we can use
24:54 - tv dot collection dot
24:58 - delete one or many
25:01 - so if we use delete one it will
25:04 - take out the filter that we are going to
25:06 - use let's say we are going to delete the
25:09 - document
25:10 - instrument so we can use the edge method
25:16 - or we can use the name method let's say
25:18 - here is unsure
25:22 - now for deleting here
25:26 - that's it now if we it's a promise
25:30 - then if we response is back it will give
25:32 - the
25:33 - document that we have deleted
25:39 - now if we response back and if there is
25:41 - an error
25:42 - we can see it in here
25:48 - and sorry that will be e
25:56 - and if we save it here we will see that
25:59 - [Music]
26:01 - oh it will give hold the document
26:04 - because i haven't used it
26:05 - response dot delete count but it
26:08 - if we see here in our
26:11 - mongodb database we will see that
26:15 - unsman document has been deleted
26:19 - now if we are going to delete whole file
26:22 - this whole document we can use
26:25 - the method that's called that is called
26:32 - delete many
26:35 - and it's very easy so delete many we are
26:39 - going to send the
26:41 - empty error empty object now if we dot
26:45 - 10 and response
26:49 - back and we are going to see
26:52 - how many
26:56 - how many documents have been deleted so
26:58 - we're going to use deleted count
27:01 - and if there is an error we can use
27:03 - catch method
27:08 - and it will give the error if there
27:10 - isn't now we have saved it
27:13 - now if we see in here
27:17 - it will give that only one
27:20 - has been predicted oh story now because
27:23 - we have used only delete
27:24 - one if we use delete many you can see in
27:27 - here now it will not give the
27:31 - required thing that we want
27:34 - but it will it will be true
27:42 - so yeah that's it how to build the rest
27:45 - api
27:47 - so before building the rest api we have
27:49 - to download
27:50 - one or two things that is first we have
27:53 - to download the postman
27:56 - postman you can download it from here
27:57 - and the second one is the compress
28:00 - mongodb compass from here choose the
28:03 - platform that you
28:04 - have and the version that is the stable
28:06 - one
28:07 - and after that we can go to our project
28:10 - in here that
28:12 - project is already been
28:15 - given and i have only added one
28:19 - property this password and it will be
28:22 - there in the description
28:24 - the repo link of this
28:28 - project so now we are going to build the
28:30 - rest api so
28:32 - before building a rest api we are going
28:34 - to i'm going to show how can we
28:37 - uh how does it look like so
28:40 - let's say app.get the request that we
28:44 - are given
28:44 - and the part and there is one callback
28:47 - function in which
28:48 - two parameters are there it is request
28:50 - and response
28:52 - in this we can response back with
28:55 - response.send let's say testing and
28:59 - if we write testing here and after that
29:02 - thing we are going to run this
29:05 - file and then again we go to our browser
29:08 - and
29:09 - let's see localhost return we can
29:13 - so let's now begin to build our
29:18 - rest api so before building the rest api
29:21 - in our tv.js we are going to export
29:26 - this line so for
29:29 - exporting this line we are going to use
29:31 - more module
29:34 - module sorry module
29:38 - dot exports equal to user
29:43 - and after that we are going to
29:47 - require it from here so for requiring it
29:50 - from
29:51 - the db file
29:54 - we are going to use user and require it
30:00 - from the utils utils file
30:04 - utils folder and then dv now we have
30:07 - required the user
30:09 - now if we are going to
30:11 - [Music]
30:13 - like create a user here so for creating
30:16 - a user we are going to use the post
30:18 - request so
30:20 - we are going to use post request in
30:22 - which we are going to send
30:26 - get the write the part as a slash users
30:31 - and we are going to use with
30:33 - asynchronous process here
30:35 - so we are going to use async await
30:38 - methods so async
30:42 - await so async request
30:48 - response
30:52 - and what the data can we get from here
30:56 - so let's say console it from console.log
31:02 - request dot party
31:10 - so now i have run the
31:13 - file but how can we see the request here
31:17 - so that's why we are going to use the
31:19 - post menu
31:20 - postman is like a browser request sender
31:25 - or anything that the browser can do for
31:28 - sending any request to the server
31:30 - it can do the same thing firstly
31:34 - so let's say we are going to create a
31:36 - new collection
31:38 - so let's say for new collection
31:41 - let's say mango mongoose
31:44 - demo and in here we are going to
31:52 - create a new get request or a post
31:55 - request so add a request here
31:57 - let's say for create user
32:00 - so in here it's a
32:04 - i'm going to close it down all the
32:06 - requests that are here
32:09 - these are all the previous one that i
32:10 - have used for
32:13 - another project
32:16 - so in here we are going to
32:21 - so now it's a post request so we are
32:24 - going to send the post
32:26 - and it's it's going to be a local host
32:29 - 3000
32:30 - users and now
32:33 - we are going to use the body
32:36 - and in here we are going to select raw
32:39 - and we are going to
32:40 - send back back the get as a json file
32:44 - so in here if we send like name
32:49 - is like john
32:50 - [Music]
32:52 - doe and ace is
32:57 - 21 now if we send it
33:00 - back to the
33:04 - change here and now if we go to our
33:11 - here you can see that the undefined
33:14 - is getting console log out here so the
33:18 - problem is here
33:19 - that the request dot body that we get
33:23 - is not specified of which type so
33:26 - here we are going to use a new
33:28 - middleware
33:29 - app.use express.json
33:34 - and what it will do that it will parse
33:37 - the
33:38 - request dot body that is a json type
33:42 - and it will not pass any other type of
33:46 - request so now if we send
33:49 - back again the same request
33:53 - we can see the console
33:56 - log output so now if we
33:59 - again send it back
34:03 - now you will see that it will send the
34:05 - request that is named
34:06 - john joe and estimate now now we are
34:09 - going to
34:12 - build a api so we are going to use async
34:17 - await
34:17 - asynchronous process so
34:20 - it's a very very useful process a useful
34:24 - tool that the javascript gives us
34:28 - so here the user
34:32 - for saving the user we are going to use
34:34 - await function which is a
34:36 - asynchronous process so user dot
34:39 - save because for saving we can use
34:43 - user.save
34:44 - and in here we are going to just send
34:48 - back a request dot party
34:52 - now if there is an error so for catching
34:55 - an error we are going to
34:57 - use try and catch block here
35:00 - so for an error it will use like this
35:04 - so we are going to
35:07 - use a try block here and if any error
35:11 - then responds
35:12 - back with an status code of
35:15 - 400 and sent back
35:18 - with nothing or e dot message
35:23 - and if user is being saved successfully
35:26 - we are going to use
35:27 - your response or here we are going to
35:31 - use
35:31 - also something called const because
35:35 - here we are going to create a new user
35:37 - so here we are going to
35:40 - use the const user
35:45 - is equal to new user
35:52 - request dot
35:55 - body and here we are going to simply
35:59 - write
36:02 - user dot
36:06 - save now it's being saved and
36:10 - in here we are going to respond back
36:12 - with status code of 201
36:15 - which is a code for creating a any
36:19 - collection or a document so we are going
36:22 - to send
36:23 - back with a user so
36:26 - [Music]
36:27 - let's say if we save it
36:31 - now and if we again
36:35 - send back with the proper
36:40 - properties let's say name is given as is
36:43 - given we also have to
36:47 - write for email so let's say
36:51 - john at gmail.com
36:55 - and again password
36:59 - and for password we can type like
37:04 - one two three and now if we send
37:07 - back
37:11 - here you will see that a new user is
37:13 - being created here
37:15 - now how can we see in the u in the
37:19 - mongodb collection so for that for this
37:22 - we
37:22 - have we have also downloaded the
37:25 - mongodb compass so
37:29 - in here we are going to just copy and
37:32 - paste the
37:33 - url that is the connection url
37:35 - connection string url
37:37 - so let's say let's just copy and paste
37:40 - copy from here
37:44 - and paste it
37:47 - and paste it here so if we paste it here
37:51 - and now if we connect it
37:56 - we will see that the new user is being
37:58 - created
37:59 - in here if we go to the paste in users
38:07 - yeah you can see that a new user has
38:09 - been created
38:11 - now we can also
38:16 - see if there is any if there is any
38:19 - failure in creating a new user so let's
38:22 - say the
38:23 - password here is of
38:26 - length 3 and which is
38:29 - required like you can see that in the
38:32 - message it is
38:33 - written that user validation file
38:35 - because the password is sorted and the
38:36 - minimum
38:37 - length is allowed it is 5 so
38:40 - the new user will not be created and it
38:42 - will go to the catch block
38:44 - so now we are going to
38:48 - see how can we get all the users so for
38:51 - getting the users we are going to create
38:53 - the new
38:54 - parts that is which is the same part but
38:57 - only the request is different it is gate
38:59 - request
39:00 - now it will also take the request and
39:02 - response
39:03 - and in here we are going to use a try
39:07 - and catch block
39:09 - and try and catch clock
39:12 - if you know let's say if there isn't any
39:16 - server side of error so we can use
39:20 - 500 of error and send it back
39:24 - with nothing on it now
39:28 - we can use await here and the
39:31 - user dot we are going to find
39:34 - all the
39:38 - find all the users so for finding we can
39:40 - use find user.find
39:43 - and here we can pass any filter out
39:48 - but we can simply right here like give
39:51 - any
39:54 - an empty object now if it
39:58 - give a users back so
40:01 - for this we can get the users and if
40:04 - there is no users here like
40:07 - no users are being there so we can use
40:09 - if not users
40:10 - then it will return back from here
40:13 - response dot
40:14 - status of 404
40:18 - and stand back with nothing on it and if
40:21 - there is
40:22 - if it is successful then we can send
40:24 - status of
40:26 - 200 and send back with users
40:30 - so let's check it out if it is right or
40:35 - if there is any mistake in here so
40:38 - in here we are going to create a new
40:42 - request here so we can create it from
40:45 - add a request
40:47 - and from here like we can i get
40:50 - users and save to mongodb
40:58 - now first of all we are going to like
41:00 - create more users here
41:01 - so let's say if it is running or not oh
41:04 - there is some error here
41:06 - i wait oh yeah we are going to use a
41:08 - weight so we
41:09 - it is compulsory to add a sink in the
41:12 - function below
41:13 - so now if we
41:17 - go to uh go to our postman and create a
41:20 - new user let's say
41:23 - jessica
41:27 - and here like s21 is right and like
41:31 - let's say jessica
41:35 - and let's see here j1236
41:41 - now if we send the request
41:44 - of post we will see our new user is
41:48 - being created here
41:49 - and if we refresh it here you can see
41:53 - the
41:53 - new user is being created now in the
41:56 - gate users we are going to fetch all
41:58 - users that has been created here
42:01 - so we are going to use localhost three
42:03 - thousand plus users
42:05 - that is the path and it's a gate request
42:08 - so now if we send the request we can see
42:11 - that all the users is being created here
42:15 - so now now we are going to see how can
42:18 - you fetch
42:20 - how can we fetch only one user
42:24 - so it's a get request and it will also
42:27 - go to the users
42:29 - part but here the id
42:33 - of the user can be different can be
42:35 - anything
42:36 - so here we can use column id
42:40 - and here it's a async process also
42:43 - so we are going to use async request
42:46 - response and
42:49 - if we and also it is it is going to be
42:52 - in a
42:53 - try and catch block now if it is an
42:56 - if there is an error we can send the
42:58 - error back
43:00 - and response dot send
43:03 - like 500 and sorry
43:07 - response dot status
43:11 - 500.
43:14 - e dot message
43:18 - now how can we use the
43:22 - id so first of all we are going to see
43:27 - what we can do here so it's a parameter
43:30 - so it's a it's going to the request dot
43:34 - parents
43:36 - here so now if we consolidate
43:41 - console.log what's in here console.log
43:45 - request of parents
43:47 - and for right now we are going to just
43:50 - comment it out here and now if we
43:54 - save it
43:57 - and go to our
44:01 - yeah go to our this block and we send
44:04 - like we get it from here
44:10 - and send back
44:14 - here and if we see it and if we
44:17 - go to our
44:21 - project we can see that it will give the
44:24 - iron object requested pattern that is
44:26 - the object
44:29 - so now we are going to use the triangle
44:34 - catch block so let's come in uncommented
44:37 - out
44:37 - and now if we you know we are going to
44:40 - cons
44:41 - user find by id
44:45 - because we are finding it by id sorry
44:48 - await and user
44:52 - dot find by id
44:56 - and for finding by id we can just send
44:59 - the
45:00 - uh give the request.params
45:03 - dot id here
45:06 - and now uh if there is a user of
45:11 - the request then it will send back the
45:15 - 200
45:19 - and if it is not if it is null we can
45:22 - check it from here like if not user you
45:25 - can return
45:26 - back like we did the same thing in here
45:31 - so it will return back with the response
45:33 - of status
45:36 - 404 and send back it nothing
45:41 - and if it is true and then we can send
45:43 - response
45:44 - dot status of 200
45:48 - and send back the user
45:55 - now if we save it and now
45:59 - we can go to our first name
46:03 - and if we again run this
46:07 - thing you can see
46:10 - the user is being called out and we can
46:13 - get the
46:15 - user now we are going to see
46:18 - something called for how can we do the
46:20 - update so for updating
46:23 - any user we can use update dot patch
46:26 - request
46:27 - which is an updating request and in here
46:30 - we are going to use also slash users and
46:33 - also we are going to use the parameter
46:35 - here
46:37 - and it will be a sync function
46:41 - and request a response
46:44 - and now it all and for
46:47 - uh updating something we also need a
46:50 - body
46:50 - because the browser or the client will
46:53 - set anything that you want to so it will
46:56 - be
46:57 - resetting in the body part so
47:01 - here from here we are going to use the
47:04 - try and catch block
47:06 - try and catch block inventory
47:11 - if there is an error we can say response
47:13 - dot
47:14 - status of 500
47:18 - dot send e dot
47:23 - message so now if
47:26 - we can also use cons user because there
47:29 - is only one user of that
47:31 - id that is being decided
47:34 - we are going to use await and here we
47:37 - are going to use user
47:39 - dot find by id and we are going to use
47:43 - this function find by id and update
47:46 - so here first it will take the
47:50 - request dot params
47:55 - dot id and next one it will take
48:01 - the update we are going to do so request
48:05 - dot body
48:08 - that's it and if there is
48:11 - user of that type if there is a user
48:14 - then it will return
48:16 - if sorry if it is no there is no user of
48:19 - it
48:20 - of it then it will return off
48:23 - return back this return dot response
48:26 - obvious status of
48:28 - 404.844 because there is no problem
48:33 - dot send nothing
48:37 - and everything responds back
48:41 - with the new update
48:45 - value so status of 200
48:48 - dot stand of user
48:52 - but it will not work properly because
48:57 - it will it will it will not check if
48:59 - there is any variation or not so there
49:02 - is
49:02 - optional properties required that is
49:06 - it will give the new user and it will
49:10 - set to
49:10 - true and it will check for validation
49:16 - for running validator we are going to
49:17 - use run
49:20 - validator in here
49:23 - which is look like this this one
49:26 - will run the new and run validator
49:30 - and now if we save it
49:34 - and we can go to the postman
49:38 - and then here we are going to create a
49:41 - new collect
49:42 - new request that is
49:45 - an update user
49:48 - so we are going to update the user and
49:51 - then we are going to save
49:53 - to the mongodb and now if we are going
49:56 - to
49:56 - patch it here and localhost 3000
50:02 - and we are going to use the
50:07 - this one this pattern
50:11 - and we are going to send back with
50:15 - body and we are going to select the raw
50:18 - and i'll just select the json
50:21 - and now let's say we are going to say uh
50:25 - update the a's of this user
50:29 - so it will like 34
50:32 - now if we send it back
50:37 - we can see that the user is being
50:40 - updated
50:41 - and as it's 34 and if we refresh it here
50:46 - we can see that the asus repo
50:49 - now we are going to see the last one
50:52 - that is
50:53 - app dot delete how can we delete
50:57 - a user so for deleting we can use
50:59 - app.delete
51:01 - users as well as id
51:05 - and it will be a sync process
51:08 - and we are going to use request and
51:10 - response
51:12 - now we are going to use try and catch
51:14 - block here also
51:18 - and now we are going to see
51:22 - that if there is a user that is
51:25 - right then await
51:28 - it will give the user the await
51:32 - user dot
51:35 - find by id and relate
51:39 - and here we are going to pass the
51:42 - patterns
51:45 - of id so the same thing that we have
51:49 - done in
51:50 - the previous request that if there is a
51:52 - user then it is
51:55 - good and if it is not then we can send
51:58 - 404 message so
52:01 - in here we can also respond back with a
52:04 - message
52:07 - so so now if we
52:11 - if we save it
52:18 - now if we save it and
52:21 - go to our postman
52:24 - and create a new or just say we are
52:27 - going to
52:28 - select the light here and we are going
52:31 - to delete
52:33 - this one and there is no watch required
52:36 - here
52:37 - so now if we send it
52:42 - we can see that you it will give the
52:44 - user and if we
52:46 - refresh it here we can see that the
52:51 - john doe user is being deleted
52:54 - so that's how the rest api works here
52:58 - we are going to look into a tool that is
53:00 - called
53:01 - mongoose well when we are using the
53:04 - mongodb library
53:07 - we are using for the current operation
53:10 - but for using other functionality like
53:14 - validation type casting is a bit
53:17 - difficult
53:18 - in this so we are using a new library
53:22 - that is called
53:23 - mongoose mongoose is a npm library that
53:26 - is used
53:27 - for validation typecasting and also the
53:31 - other
53:32 - grid operation that we perform into it
53:35 - so let's start with our new project
53:40 - let's say we are going to create
53:44 - a new project name called
53:48 - mongoose demo
53:53 - we go into new project
53:56 - mongoose demo
53:59 - now we are going to initialize the npm
54:02 - and it
54:03 - by using npm any test y
54:14 - after that we are going to
54:17 - go to this project by using code
54:20 - space start
54:26 - now in this project we are going to
54:30 - initialize
54:31 - how are we going to start the script
54:35 - so for production purpose we are using
54:38 - node
54:41 - app and for dev purpose we are going to
54:45 - use
54:47 - node mod app
54:52 - now let's create a new file let's call
54:55 - app.js
54:59 - now here again we are going to
55:04 - install new libraries first we are going
55:08 - to install
55:09 - node mode library for installing it npm
55:13 - installed
55:14 - test as save day step
55:19 - not one now we are going to install
55:23 - npm express and
55:27 - mongoose for installing it we are going
55:31 - to use
55:31 - npm dash express
55:35 - space
55:41 - in the meantime we are going to
55:44 - use all the configuration that is needed
55:46 - here
55:48 - let's same cons express
55:51 - is equal to require
55:55 - express and
56:01 - and we are going to use the app
56:04 - that is going to get required from
56:06 - express as a function
56:09 - and we are going to listen to a port
56:11 - number let's say
56:14 - 3000
56:25 - now for using mongoose into our project
56:27 - we are going to
56:29 - create a new folder let's say utils
56:33 - in this folder we are going to
56:37 - create a new file let's say db dot js
56:41 - in this file we are going to create a
56:43 - new const
56:45 - mongoose and we are going to require it
56:49 - from
56:52 - mongols
56:55 - after requiring it we are going to
56:58 - connect our mongodb to our
57:02 - the current project
57:06 - so for connecting it we are using
57:10 - connect function that we have used in
57:12 - the
57:14 - mongodb driver so
57:19 - we are going to require the
57:24 - server means we are going to require the
57:27 - connection string that is here
57:30 - now let's copy it from here and we are
57:33 - going to paste it
57:34 - into the connect function
57:39 - in here we are going to replace the
57:41 - password
57:43 - that is given here
57:48 - and pasting it into the password
57:52 - field after pasting it
57:55 - we are going to use
57:58 - optional options that is given here
58:02 - like use
58:05 - unified topology to true
58:10 - and use new url parse33
58:16 - after that it
58:20 - is using if we are using the dan
58:24 - function here
58:25 - like it returns a promise and if we used
58:29 - then it will give the
58:34 - successful result and if it is error
58:38 - it will give an error
58:49 - now for
58:52 - starting this file we are going to
58:56 - use the this file using
58:59 - requiring it from the file using this
59:02 - thing
59:03 - using required dot dot slash
59:08 - dot slash utils flash tv
59:15 - and now if we run this project by using
59:17 - npm run dev
59:21 - we can see that the connection is
59:23 - established now
59:25 - we are going to use the mongoose in our
59:28 - file
59:29 - so we are going to remove this one
59:31 - because there is no need of
59:32 - it now we are going to create the model
59:36 - of our of a user
59:38 - so for creating a model we are going to
59:41 - use a term that's called
59:42 - schema so
59:46 - for this so for using schema we are
59:49 - going to require it from the
59:51 - mongoose so let's say schema
59:55 - cons schema
59:58 - mongoose dot schema
60:02 - after that we are going to create a new
60:04 - schema of user
60:06 - so for creating it we are going to use
60:09 - any
60:10 - user schema variable and after that
60:15 - we are going to construct
60:18 - or use new operator
60:22 - and using the schema and here we are
60:25 - going to define the
60:27 - user scheme so what are the information
60:31 - needed in the user schema
60:32 - so let's say we are using name so which
60:36 - type it will be
60:37 - it will be a type of string so we are
60:39 - using a string
60:41 - and it's required so we are using a
60:43 - required property of it
60:46 - that's it's a boolean so we are going to
60:48 - use true
60:51 - and if there is any like species
60:55 - before the name or after the name we are
60:58 - going to trim it
61:00 - so it will it give a trim
61:03 - properties so we are going to using
61:06 - dream is to true
61:10 - and after that we are going to
61:13 - create a new document let's say
61:17 - is and in the ace we are
61:20 - going to deliver like what type is it
61:23 - so it's a type of number
61:27 - and it's also required into our project
61:34 - so after that we are
61:38 - also like that's it
61:41 - now it's a model so for creating a new
61:45 - model we are going to use cons
61:47 - product user and we are going to create
61:51 - a new model for
61:52 - creating a new model we are going to use
61:54 - mongoose
61:55 - dot model and we
61:58 - we can give any name that's a string so
62:01 - let's say user
62:03 - and in here we are going to provide a
62:05 - schema that we have used
62:08 - so we are going to use user schema
62:12 - now we are going to instantiate a new
62:14 - user into our project
62:16 - so for instance setting in the new user
62:20 - we are going to use a new user one
62:22 - and after that we are going to use new
62:24 - creator
62:25 - constructor and then we are going to use
62:27 - new user
62:29 - and in here we are going to perform
62:34 - now let's say we have provide a new name
62:36 - let's say
62:38 - john center
62:42 - and its age is let's say
62:46 - 21. after this
62:49 - we are going to save it
62:52 - for saving it we are going to use user
62:54 - dot save that is given by the mongoose
62:57 - and it's an promise so we are going to
63:00 - use
63:01 - 10 and after that we can see that if
63:04 - it is saved or not using console.log
63:07 - repress
63:08 - and if it's an error then we can perform
63:12 - an error operation and obviously we can
63:15 - see what's going on there
63:22 - now here you can see that it gives
63:25 - the user and it automatically give the
63:29 - id
63:30 - and the name and the is and the version
63:33 - of the
63:33 - document that is zero now if we see into
63:37 - our project
63:39 - we will see that it has been saved
63:42 - into our mongodb so for
63:46 - saying we can go to the collection
63:51 - and here you will see that the user has
63:55 - been saved
63:57 - and the user collects the name
64:00 - is also given to it
64:03 - so now we are going to see how can we
64:07 - provide the validation here so if we
64:10 - want to validate that the is will be
64:13 - like only greater than 18 or let's say
64:17 - we validate that the error that the a's
64:20 - will be
64:21 - will not be less than zero or it's not a
64:24 - negative
64:25 - so for doing this we can use a method or
64:28 - a function called validate
64:30 - into it and in this if we provide like
64:33 - if value
64:37 - is less than zero it will throw an
64:40 - error so for throwing the error we can
64:43 - use throw
64:46 - new throw new
64:49 - error and let's say
64:53 - is must not be
64:57 - less negative so
65:00 - if we save it no first we have to change
65:04 - the value of
65:04 - it so let's say if i write like minus 20
65:09 - and now if i save it
65:13 - you will see that it gives an error that
65:15 - say s must not be negative
65:17 - so mongoose can be used for performing
65:20 - like any validation that we require
65:23 - now if we add one more property let's
65:26 - say email
65:28 - so how can we check that an email is
65:31 - right or wrong
65:33 - so it will be an string
65:37 - and it's also required into our
65:41 - collection
65:45 - and for validation purpose there is a
65:50 - new there is a npm library
65:53 - it's called validator so we are going to
65:55 - install it
65:58 - for installing npm i
66:02 - validated
66:05 - so in the meantime we are going to use
66:07 - the
66:10 - how can we like we can see here like if
66:12 - we perf
66:13 - if we don't display or don't initialize
66:18 - is in here and if we save it
66:21 - you will see it also gives an error here
66:28 - it says that is required
66:33 - and p part is is required and the
66:36 - message
66:37 - it's an error so
66:41 - so now we are going to use a new library
66:44 - called validator
66:48 - and in here we are going to require it
66:51 - from validator
66:54 - now in here
66:58 - we are going to use validator
67:01 - validate function
67:06 - and the value that we provide and in
67:10 - here
67:10 - if validator
67:14 - dot is email
67:17 - value
67:20 - it will throw an error
67:28 - let's say it should be an email
67:33 - but validated. is email if it is right
67:36 - it will perform a
67:37 - true so in here we are going to use
67:41 - not operator so
67:44 - now if we provide like
67:48 - is can be 20 and if we provide like
67:53 - email to be
67:56 - john gmail.com
68:02 - and if we save it
68:06 - now we can see that it should be an
68:08 - email so
68:09 - it gives an error so that's how
68:13 - we can use so that's how can we use
68:16 - the mongoose library into our folder in
68:19 - this video we are going to add
68:21 - new security rules and authenticate the
68:23 - user
68:25 - so for now the password field is filled
68:28 - with a plain text
68:29 - so we are going to change it into the
68:32 - random set of values
68:34 - for doing this we are going to use a new
68:37 - library
68:38 - that is called npm that is called big
68:41 - clip js
68:42 - so i have already installed it using
68:44 - nbmi
68:46 - big crypt js
68:50 - big crypt js
68:53 - and here i have also used the big crypt
68:57 - is equal to require bigribjs so in here
69:00 - we are
69:01 - going to use the schema method that
69:04 - it provide mongoose provide that is user
69:06 - schema
69:08 - dot free it means that and whenever a
69:11 - new
69:12 - method is to be called it will be called
69:15 - before it that is whenever
69:16 - we use the save method it will be called
69:19 - before it
69:20 - and it's a synchronous process so we are
69:22 - going to use async process
69:25 - and it uses a es
69:28 - before es6 function syntax so we are
69:35 - going
69:35 - to use async function and in here we are
69:37 - going to
69:39 - use the parameter next which is
69:43 - called whenever the upper whenever the
69:47 - upper functionality will be done
69:51 - so in here we are going to use the cons
69:54 - user is equal to this it this provides
69:58 - the document
69:59 - that is going to be saved in here
70:02 - so in here the user has a password
70:05 - so whenever a user password is being
70:08 - changed
70:09 - then we are going to run this if
70:12 - statement
70:13 - so in here if user dot is modified
70:18 - in in here we are going to just
70:21 - say the field that is password
70:25 - and here we are going to use the big
70:27 - crypt
70:28 - so what's being changed that is the
70:30 - password being changed so user dot
70:34 - password is equal to it's an
70:36 - asynchronous process so it will be
70:38 - going to use await and
70:41 - in here we are going to use pcrypt
70:44 - method
70:45 - that is hash
70:48 - and in here the string that is the
70:52 - request.password
70:54 - that we are going to change and how many
70:57 - times we are going to run this algorithm
70:59 - that is like
71:00 - it's a stable that is we are we are
71:03 - going to use
71:04 - eight times so now
71:07 - that's it by doing this we can see if
71:11 - the password is being
71:12 - saved as a random set of values so for
71:16 - looking for seeing this we are going to
71:20 - use the postman in here and we are going
71:23 - to create
71:23 - a new uh new fire profile
71:27 - that is the jessica phone and now if we
71:30 - run this
71:31 - file we can see in here that the
71:34 - password is being
71:35 - stored as a random set of values
71:39 - now that's been done now we have to log
71:42 - in with the
71:43 - credentials that has been given like
71:46 - email and password and now we are going
71:48 - to login with this
71:50 - email and password but the password is
71:53 - being
71:54 - as a random set of values that has been
71:56 - provided by the
71:57 - bankruptcy so for doing this we are
72:00 - going to create a new
72:02 - endpoint uh in here in
72:06 - app.js
72:08 - so in here we are going to create a new
72:10 - endpoint
72:11 - and here app.post because we are sending
72:15 - the
72:16 - user's party in here users
72:20 - and login
72:23 - and it's going to be asynchronous
72:25 - process
72:26 - and we're going to use request.js
72:28 - response
72:31 - and now in here we are going to create
72:35 - our
72:36 - own with your undefined user defined
72:39 - method in here so for this we are going
72:41 - to use
72:43 - uh const user means first we are going
72:46 - to use its asynchronous process so
72:48 - await we are going to perform on the
72:51 - user matter
72:54 - and also the method that we are going to
72:56 - call it's a predefined method
72:58 - and we are you sorry user defined method
72:59 - and we are going to define it
73:01 - let's say find by credentials
73:05 - and in here we are going to use two
73:08 - thing that is request
73:10 - dot body dot email
73:15 - and also the request
73:18 - dot body the password
73:23 - so what it will return it will return a
73:26 - user so we are going to use the same
73:28 - thing for user and
73:33 - in here and that's it and then we're
73:36 - going to create a catch block
73:39 - and provide the response
73:43 - let's response dot status
73:48 - 400 dot sent
73:53 - so now we have to define this new
73:55 - function
73:56 - or a method so in here we are in the
73:59 - dvd.js
74:00 - we are going to define it so
74:03 - in here user schema as we are defining
74:07 - it into a model or an schema
74:11 - so we have to use the statics
74:14 - and the method name that is find
74:19 - by credentials
74:24 - and in here it's an asynchronous process
74:27 - so
74:28 - we are going to use async and in here we
74:31 - are going to provide email
74:34 - and password
74:38 - and now we are going to define it so
74:41 - in here we are going to find the user
74:45 - by the find one method
74:48 - so we are going to use try and catch
74:49 - block so in here when you use
74:52 - const user await
74:59 - user dot
75:03 - find one
75:07 - and the object that is email
75:10 - means the condition so now if there is a
75:13 - user
75:14 - if no if there is no user then we are
75:17 - going to throw an error
75:20 - throw an error through new
75:24 - error and if
75:27 - there is and like if there is an
75:31 - user we are simply going to
75:34 - check or compare the password that is
75:37 - given by the user with the
75:39 - password that is being stored in the
75:42 - right
75:42 - in the normal tv so in here we are going
75:46 - to use
75:48 - the following it's an asynchronous
75:52 - function that is await the
75:55 - crypt dot verify
75:58 - no dot compare
76:01 - and in here we are going to provide the
76:03 - request
76:05 - sorry password
76:08 - and the user
76:12 - dot password for one thing more that
76:16 - yeah that's it and user.password
76:21 - and in here it's provide it's written a
76:24 - true and false so it's a boolean so is
76:28 - match
76:32 - so if it is not match if not is match
76:38 - then we are again going to draw an error
76:46 - and if if it is uh if it is
76:49 - it is being messed then we are going to
76:51 - return
76:52 - the user so
76:56 - in here in the catch block we are going
76:58 - to simply write
77:00 - a watch an error
77:04 - it is return
77:08 - enable
77:12 - to login
77:17 - in this file we are going to simply like
77:19 - response
77:21 - back response
77:24 - back with the status 200 and the user
77:30 - that is the user
77:34 - and yeah that's it now we are going to
77:38 - check
77:38 - our function so let's move on to the
77:42 - postman and we are going to create a new
77:47 - request in here we can create a new
77:50 - request add request
77:52 - in here login user
77:56 - and it's going to be saving for
77:58 - mongoose gamer
78:01 - and it's it is going to be a post
78:04 - request so
78:05 - we are going to provide post and it's
78:08 - the local host
78:10 - 3000 users login
78:13 - and we are going to simply copy it from
78:15 - here
78:17 - and sorry copy it from here
78:21 - email and password
78:24 - and just paste into our party
78:29 - we're going to select the raw and also
78:31 - the json
78:33 - and in here we're going to provide the
78:35 - email and password
78:37 - now let's look that we are going to get
78:42 - the user back or not yeah you can see
78:46 - that we have got the
78:47 - user back now if we like if we
78:52 - run out our incorrect our password now
78:55 - if we send
78:56 - back we can see unable to login so
78:59 - it's very easy to do but there is a
79:03 - caveat in this
79:04 - that is in here in the postman if we
79:07 - like create the user
79:08 - with the same email we can see that it
79:11 - will
79:12 - it is going to create the same user but
79:16 - it will also give the
79:17 - message oh once again maybe
79:22 - yeah tb.js
79:27 - in email
79:32 - yeah it will handle the if we save the
79:35 - user with the same email
79:37 - then it will be handled by the mongodb
79:39 - that will
79:40 - give the error so it's like it's very
79:43 - helpful or a handful so now we are going
79:46 - to
79:47 - see once one thing that is called jwt
79:50 - that is json web broken
79:52 - so now in here for uh getting the
79:55 - profile
79:56 - or it will be changed with the getting
79:58 - the profile
79:59 - so whenever the user is going going to
80:02 - like
80:02 - create a user or logging in with the
80:05 - user then they can see the
80:08 - their profile not like whenever we click
80:12 - on whenever we
80:13 - like click on this endpoint hit on this
80:16 - endpoint then
80:17 - they can see it or yeah this
80:21 - functionality is going to be changed in
80:23 - here
80:24 - so for using this or for understanding a
80:26 - whole point of this video
80:28 - we are going to install npm install
80:33 - json wave token
80:36 - so what it will do like whenever we like
80:40 - uh
80:42 - whenever we create a user it is going to
80:44 - be
80:45 - like save a token it will be saved
80:49 - a token in the mongodb
80:53 - and it will be sent back to the client
80:55 - and
80:56 - whenever the client is going to
80:59 - use any functionality then they are
81:02 - going to use the
81:03 - same token that is being there in the
81:06 - client side
81:07 - and get authenticated to perform any
81:10 - functionality
81:12 - so for understanding this whole thing we
81:15 - are going to like
81:17 - uh see how it can be done
81:20 - so now as the tokens is going to be
81:25 - saved into our model so we are going to
81:27 - create a new
81:29 - uh property that is tokens and it's
81:32 - going to be a
81:33 - array type because a user can
81:37 - get more than one token at the
81:41 - different point of time or whenever they
81:44 - use
81:45 - different devices so it's in
81:48 - token or tokens of an array and it's
81:51 - going to be in
81:52 - token and in here it's going to be like
81:56 - type of string
82:01 - and it is required
82:11 - so now in here whenever we save it like
82:14 - uh
82:15 - now we are going to use an like for this
82:18 - user only
82:19 - a new method or a user different method
82:23 - we are going to
82:24 - create it is like any any name that you
82:27 - can
82:28 - like generate art token in here in this
82:31 - function we are going to generate
82:33 - a new token for this particular user
82:36 - so i am going to copy this name from
82:39 - here
82:40 - and we are going to define it into our
82:43 - db.js so
82:46 - in here let's say here i am going to
82:48 - create it
82:49 - so like user schema but we are not going
82:53 - to use the schema method or a statics
82:56 - we are going to use for that particular
82:58 - user
82:59 - so in here we have given the user schema
83:02 - dot
83:03 - methods and the name
83:07 - generator token and it's going to be an
83:11 - asynchronous process
83:15 - and now we can define it here
83:19 - so in here we are going to take the user
83:22 - that is const user is equal to this
83:26 - it provides a document that we are going
83:28 - to perform the
83:29 - functionality and now we are going to
83:32 - use the big
83:34 - in the json web token so in here we are
83:38 - going to create
83:39 - a new cost let's say jwt
83:42 - and we are going to require it
83:45 - from json token
83:50 - and now we are going to define uh
83:53 - we are going to use the method of
83:54 - jsonwave token
83:56 - so await it's a asynchronous process so
83:59 - away
84:00 - jwt and we are going to sign
84:03 - because this method will provide the
84:06 - token
84:08 - so jwt dot sign
84:11 - and it need uh to
84:14 - order like arguments parameters first
84:18 - parameter is the payload
84:20 - so the payload will be the
84:23 - id so the id of the user
84:26 - so we can get from the user
84:30 - dot id
84:33 - but the user.id is an object id so we
84:36 - are going to change it
84:38 - and convert into the to a string method
84:45 - now the second parameter will be the
84:49 - yeah once again
84:52 - yeah the second parameter will be the
84:54 - secret of private key
84:56 - can be anything but i'm going to use
84:58 - this is it
84:59 - is going to be like it is going to be a
85:01 - private 14 here i'm going to simply
85:04 - write it
85:05 - this is my new course
85:10 - so the next argument can be the expires
85:14 - in
85:21 - yeah that's it so now it's going to
85:24 - return a token
85:27 - so let's write into this format like
85:31 - it's going to return a token now
85:34 - in here we are going to save it or
85:37 - concatenate in the user.tokens
85:41 - so user.tokens user.tokens.concat
85:50 - the token
85:54 - and now just we are going to the user in
85:56 - here so
85:57 - the await user dot save
86:04 - and return the token because that is
86:07 - going to be like
86:08 - response back to the client side
86:11 - so that's it yeah this function is
86:14 - completely
86:16 - it is right but we are going to look
86:18 - into it
86:20 - so in here it's going to like uh
86:24 - return a token so cons token
86:28 - await and in here we are going to
86:31 - perform our
86:32 - response back with two things that is
86:34 - user
86:36 - and token
86:39 - yeah now let's see that in action
86:44 - so in here we are going to see login
86:48 - create user and now if
86:51 - we use jessica and
86:54 - our we are going to change the uh
86:58 - email to jessica to alex and name to
87:00 - alex
87:03 - now if we save it
87:07 - yeah it's giving an error because now we
87:10 - have changed the model in here
87:12 - so in here first we have to like delete
87:15 - our
87:16 - user in here from here then we can
87:19 - see that it is giving the required
87:23 - result
87:24 - you can see now that the user
87:27 - is being saved with the tokens and we
87:30 - are going to uh
87:32 - give back to the the token
87:35 - token also now same thing we are going
87:38 - to provide to the
87:40 - login also because in here also the
87:42 - token will be generated and sent back to
87:45 - the client
87:46 - so in here we are going to use const
87:48 - token
87:49 - is equal to await
87:52 - and we are going to use in the user
87:56 - user dot generate auth token
88:01 - and we are sending back with user
88:05 - and token
88:11 - now if we log in with this email and
88:13 - password
88:15 - so we can see in the action in action
88:19 - so in here we are going to provide email
88:21 - and faster
88:23 - now if we send it back we are
88:26 - going to see that two tokens is being
88:29 - generated in here
88:32 - and and the latest token that is
88:36 - this one is going to send back to the
88:39 - client side
88:41 - now one thing is here that we are giving
88:44 - the client
88:45 - so much information here we are going to
88:47 - provide like
88:48 - password and the tokens of all the
88:51 - tokens that are being
88:53 - there in the mongodb so we are going to
88:56 - like
88:56 - uh sorting the like hide the values or
89:00 - hide the
89:01 - information from the user because
89:05 - it's for the security purpose so for
89:06 - doing this
89:08 - we are going to use another method but
89:10 - it is a predefined
89:12 - we can say because in here we are going
89:15 - to use the user
89:16 - schema dot methods because we are going
89:20 - to
89:21 - use the method into a particular user
89:25 - and that's how the writing that i'm
89:27 - going to use
89:28 - the same thing you have to use to add to
89:31 - json
89:33 - because this means that whenever
89:36 - we respond back to the client
89:40 - in here it is being converted into
89:44 - json.stringify
89:46 - so in here we are just going to like
89:49 - perform an additional functionality in
89:52 - here
89:52 - because it is same as json stringify
89:55 - but we are adding some more
89:57 - functionality into this
90:00 - so for using this we are going to just
90:04 - use the following that is user
90:07 - means function
90:10 - or shift uh user function
90:16 - and now in here
90:19 - we are going to just say const
90:22 - user is equal to this dot
90:26 - we are going to change into an object so
90:29 - for doing this
90:30 - user this dot to object
90:33 - and in here we're going to delete delete
90:37 - user dot password because that that
90:40 - don't really need it
90:41 - and also delete the tokens
90:48 - and and just return the user
90:54 - yeah now if we
90:57 - go into our postman and
91:01 - run it again this end point
91:05 - we can see that it's going to like just
91:08 - like
91:09 - give the user's name as an email
91:13 - and latest token that has been generated
91:17 - now we are going to use the tokens that
91:19 - are being saved in the mongodb and use
91:22 - into the another endpoints like in here
91:25 - users start users and phone but
91:29 - the user don't want to see another user
91:31 - profile so
91:33 - it's going to be a user profile method
91:36 - so we are going to change the end point
91:38 - to users slash
91:39 - me and now
91:43 - for looking into a user's profile we are
91:46 - going to use that
91:48 - token specifically so
91:51 - we are going to use a term that is
91:53 - called the middleware
91:56 - so that means that let's say the new
92:00 - function or method that we named art
92:04 - is going to run before this
92:08 - functionality so for doing this we are
92:11 - going to create a new
92:14 - like folder again we are going to create
92:16 - a new folder
92:18 - let's say middleware
92:21 - and in here we are going to create a new
92:24 - file let's say art
92:27 - touches so in here what can we do
92:34 - so let's say we're going to create a
92:36 - const art
92:39 - and it's going to be an asynchronous
92:41 - process
92:43 - and also we are going to export back
92:45 - with the file
92:46 - so we are going to use module dot
92:50 - exports the odd function
92:55 - and we are going to use in the
92:59 - this file so we are going
93:02 - to use const art
93:06 - it's equal to require required from
93:09 - charge charge
93:13 - dot slash middleware
93:16 - and art yeah
93:20 - so what's to be done in this
93:23 - method so now in here
93:27 - it's a middleware but it's used same
93:30 - functionality as the request response
93:34 - and also the next because the next is
93:36 - used for like
93:37 - for going to the another endpoint yeah
93:41 - now in here first we are going to
93:45 - get the token from here so for getting a
93:48 - token we are going to use cons
93:50 - token and it's going to be
93:53 - in the request dot header
93:58 - and we are going to talk about this
94:00 - later authorization
94:04 - and also one thing called replace
94:07 - because
94:07 - thought radiation is being used as
94:11 - a string so we are going to replace
94:14 - a barrier bearer space string
94:19 - with nothing yeah
94:22 - that's it the token is being generated
94:25 - here
94:27 - now we are going to verify this token
94:30 - verify this token and generate the id
94:34 - so const decode
94:39 - and in here we are going to use the
94:44 - jwt method so we are going to require it
94:47 - from jwt
94:50 - require it from json web token
94:55 - so in here jwt verify
95:01 - verify and token that is a token
95:06 - and also the segregator public key that
95:08 - is this is my
95:13 - new course now
95:18 - in this decode there is the id of the
95:21 - user
95:22 - so from here we can see if there is a
95:26 - user
95:26 - not so for looking into the user we are
95:30 - going to simply say like
95:32 - we are going to use await method and
95:35 - also we are going to use the model so
95:37 - for this again we are going to
95:42 - use the user model or
95:45 - import it from the db file
95:48 - so require it from
95:52 - require it from dots list
95:58 - dot dot slash
96:03 - utils db
96:06 - yeah now we get the user
96:09 - and after getting user we can use find
96:12 - one method
96:13 - in here we are going to provide the id
96:16 - that is id is to
96:21 - the token decode
96:25 - dot id and also we are going to verify
96:30 - with the tokens that is being there in
96:32 - the mongoose
96:34 - mongodb so for that we are going to use
96:37 - tokens
96:41 - dot token
96:44 - and token
96:48 - yeah that's it now if there is a user
96:53 - then it will perform the operations or
96:56 - return back with the user
97:00 - now if there is no user
97:03 - and we are say safely to say like
97:06 - this is going to be a throw an error
97:10 - and throw new error
97:14 - so request dot user is equal to
97:19 - user
97:22 - now there will be a catch block and here
97:25 - we are going to response
97:27 - back response back with status
97:35 - 404
97:41 - and send back
97:44 - with
97:47 - error obtain
97:50 - error in editing authentication
98:02 - it's going to be in a string so we are
98:04 - going to save it like this
98:06 - now if it is run then we are going to
98:08 - use the next method
98:11 - so it will go to the end point after
98:13 - that
98:15 - so now in here in app.js
98:20 - in here the all in this one
98:25 - we are getting the user if it is right
98:29 - so there's no need of this we are going
98:32 - to simply
98:32 - like write request
98:37 - dot user yeah that's it
98:45 - now if we go to our postman
98:50 - we are going to use the
98:54 - end point of this gate users
98:58 - but also we are going to use it uses the
99:00 - profile that we
99:01 - want to so let's say we are going to use
99:04 - case
99:05 - so in headers there is
99:08 - one thing called authorization that the
99:10 - same thing that we have written in the
99:11 - code
99:12 - that in this key there is a value
99:16 - so the value will be the
99:21 - new one that we have used latest one
99:24 - like request this token is going to be
99:27 - used in here
99:30 - and it's going to be written for bearer
99:34 - and like this that's why we have used
99:38 - that to replace the bearer with
99:40 - nothing at all so now if we run this
99:45 - we are going to get back the users or a
99:48 - profile
99:50 - so finger cross yeah
99:53 - we get the profile back yeah that's it
99:57 - that's how we can do the getting the
100:00 - profile of
100:01 - an user so now one more thing
100:05 - remaining that is how can we log out
100:08 - from a system so for logging out we are
100:11 - going to
100:12 - create a new
100:15 - new
100:19 - new endpoint that is users
100:23 - and logout
100:27 - so in here we are going to use request
100:30 - and response and also we are going to
100:31 - use the art middleware
100:33 - because after authenticating then we are
100:36 - going to
100:37 - remove it from the from the
100:41 - they can be log out from the devices
100:44 - so in here we are going to see how it
100:47 - can be done
100:48 - so for this it's going to return
100:52 - a token so that they can be logged out
100:55 - from the
100:56 - system so for this we are
101:00 - also going to request dot
101:04 - token is equal to token
101:08 - so now in here we are going to see how
101:12 - it can be done
101:13 - so in here we are going to simply say
101:16 - like request no
101:18 - first thing we are going to also
101:22 - use the try and catch block
101:25 - and in here if it is right then it is
101:28 - say like response dot
101:30 - status of 500
101:33 - and send back
101:36 - so in here we are going to use request
101:39 - dot users
101:41 - or user dot tokens
101:46 - and now we are going to use request dot
101:50 - user
101:52 - dot tokens dot
101:56 - filter because it's an array
101:59 - and it's going to take token
102:02 - serialize and if we're going to see
102:06 - a token dot token is not
102:11 - equal to the request
102:14 - or token
102:18 - then it's going to return all the tokens
102:20 - that is not
102:21 - in the request.token now we are going to
102:25 - save it again
102:26 - using request await request sorry await
102:30 - request dot user
102:36 - dot save
102:40 - and response back with the status of 200
102:46 - and send back
102:50 - with request dot user
102:53 - yeah that's it
102:58 - i have already created the new log out
103:00 - user
103:01 - get endpoint and you can see that i have
103:04 - provided the
103:05 - authorization and also we can see that
103:07 - we can get the
103:08 - lx gmail.com like the user that we are
103:12 - going to get and we can see in here in
103:15 - our mongoose
103:16 - that first we have to refresh it
103:20 - and now you can see it only few objects
103:24 - are there
103:25 - now if we run again this file
103:28 - and we have to also change this token
103:32 - so let's say i'm going to take this
103:35 - token from here
103:38 - and just a sec yeah
103:42 - now if i
103:46 - copy it from here and paste it
103:50 - in here and again send it back
103:56 - we get the user and if we refresh it
104:00 - here
104:00 - again you can see that
104:04 - we will get only one object yeah
104:07 - that's how we can log out from any uh
104:11 - devices you can also uh use the like
104:15 - netflix users like if you want to
104:18 - log out from different devices we can
104:21 - simply write in here
104:24 - the same thing but we can change
104:27 - here like request
104:30 - dot user dot
104:33 - tokens is equal to an array
104:36 - so it will do the same thing but it will
104:40 - uh
104:40 - log out from all the devices yeah so
104:43 - that's it
104:44 - in this video in this video we have seen
104:47 - how can we
104:48 - add the security and also authenticate
104:52 - the user
104:53 - and how can we see that any other
104:56 - functionality can be
104:57 - done only through the authentication in
105:00 - this video we are going to learn
105:01 - how relationship between two models are
105:04 - done
105:05 - so in previous video we have already
105:08 - done the users model
105:10 - and we have written all the methods
105:14 - static methods of usual model
105:17 - and i am added one more model in here
105:21 - that is a task
105:22 - model in here the user has the task
105:26 - so the user can give can create a task
105:30 - for them
105:31 - so this is the task model
105:34 - and i have created this project in a
105:38 - systematic way
105:39 - that is this is a folder of models and
105:42 - in here two files
105:44 - are there task model and user model
105:47 - and i have also separated the connection
105:51 - so this is the db model db folder
105:55 - in here that is the our middleweight
105:58 - middleware folder
106:00 - and here is the router the thing that we
106:03 - have
106:04 - learned about mini express so
106:07 - in here we are just like in here
106:10 - we have we we are here not written like
106:14 - the app express we have written the
106:17 - router
106:18 - which we get from expresso browser
106:22 - and we just export it module.export
106:25 - equal to router
106:27 - the same thing we have done for the task
106:29 - router also
106:31 - in here the router of task means task
106:34 - router uh have some
106:37 - api endpoints that is creating a task
106:41 - getting the task getting the task by id
106:46 - updating the task deleting a task
106:50 - by id so we have exported
106:53 - it also and in here
106:56 - the main file is index.js
107:00 - we are just importing it from these two
107:03 - files
107:04 - and we are using app.use user router
107:08 - and classified router that's it
107:12 - so now in here we are going to learn
107:16 - how can like how can we relate these
107:20 - two tasks and user model
107:23 - to each other related so if
107:26 - a task is being created
107:31 - so the task is being created by an owner
107:34 - that means an honor means a user
107:37 - you have to we have to create a honor
107:40 - filter in here
107:42 - and in honor field the type will be the
107:46 - id of the user so the type will be
107:51 - that we get from the mongoose
107:55 - dot schema dot types
107:59 - dot object id
108:02 - it is also required so we can give
108:06 - true
108:09 - and yeah that's it we
108:13 - now if we go to our
108:16 - uh task router
108:19 - in here in here
108:22 - we have to like when we are creating
108:25 - when we are creating a task
108:28 - we have also to like authenticate that
108:30 - the task
108:31 - is being created by a user that is being
108:34 - logged in
108:36 - so for that we have also imported out
108:40 - and just we have to write in here art
108:44 - means if it is uh like it is a
108:48 - authenticate its the endpoint is being
108:51 - authenticated
108:52 - now the user can now this task can be
108:56 - created in here so in here this
109:00 - is going to be this is the
109:05 - spread out operator so the all the
109:08 - objects
109:09 - all the fills that are in here requested
109:11 - body is going to spread out
109:15 - and in here we are going to just and
109:17 - write the field
109:19 - under and we can get the request dot
109:23 - user
109:25 - dot id yeah
109:28 - that's it now if we save it
109:34 - and go to our postman
109:40 - and for now i have created like i have
109:45 - just say i am going to log in with this
109:48 - alex user
109:53 - oh sorry i haven't like i haven't
109:56 - run the localhost 3000 so i'm going to
110:00 - run it
110:03 - so we just we have to write like
110:07 - not mon or we can just simplify npm run
110:10 - dev
110:14 - now it's running
110:17 - now if we go to the postman
110:21 - and again we logged in with
110:26 - okay sorry logged in with so we are
110:29 - going to log
110:29 - in with this user
110:33 - so now if we log in
110:36 - we can get the token
110:39 - now for creating a task
110:42 - we are going to go to the create task
110:45 - and authorization is needed here
110:49 - we are just going to create
110:50 - authorization
110:53 - bearer the token value
110:59 - and the body so in body we are going to
111:03 - just create like
111:05 - the json file is needed
111:09 - so we are going to see what's in the
111:13 - dark source name and is completed
111:18 - so name
111:21 - let's say no.js course
111:27 - and is completed
111:33 - this is not right we have to write like
111:35 - a json format
111:37 - yeah this is right
111:40 - it's completed
111:47 - it is false so we have to just write
111:49 - false
111:50 - yeah that's it now if we send it
111:55 - we can see that the new task has been
111:58 - created
112:00 - and the honor for honor id is being
112:03 - there
112:04 - so if we go to our memo db a compass
112:08 - and if we replace it
112:12 - we can see new task is being created
112:15 - with the object id of the alex owner
112:20 - now if we want to like
112:26 - get the honor on the description all the
112:28 - information about the owner
112:31 - we can do it if we i'm going to swing to
112:34 - the in the
112:36 - index.js
112:39 - so first like my function
112:46 - that's how we can call this and in here
112:50 - let's say const my function
112:56 - is an async value
113:03 - and now you are just going to get the
113:07 - user
113:07 - get the task we can
113:11 - do like first we have to like import the
113:13 - task model also in here
113:16 - so cost task is equal to
113:21 - require it from tv
113:26 - models less task
113:31 - yeah so task
113:34 - dot find
113:40 - one
113:43 - and oh you can like find by id
113:48 - and the id will be
113:51 - this one
114:00 - so from here we can get the task so if
114:03 - you want to
114:04 - console log the
114:07 - dot honor if we console it
114:12 - in here
114:19 - we get undefined
114:23 - oh we have to like await it from because
114:26 - it's an asynchronous process
114:28 - now if we again run again rerun again
114:31 - you can get the id
114:34 - but we don't get the whole information
114:37 - about the
114:41 - user so for getting all the information
114:44 - about the user
114:44 - we can do by like this now for creating
114:48 - for getting all information about the
114:50 - user we have to like
114:51 - uh give one more
114:56 - reference ref
114:59 - uh ref field in here the model name is
115:03 - given
115:04 - so the model name will be this one
115:09 - this one users
115:12 - so in here we're just going to write
115:14 - users
115:17 - now if we again
115:21 - run here like a weight
115:26 - task dot populate this is the function
115:30 - that we are needed here
115:32 - populate we are going to populate
115:36 - the field of honor and we are going
115:39 - to execute it by using it populate
115:46 - now if we just like console it
115:50 - and we can see that all the information
115:52 - about the owner is being
115:54 - written in here everything
115:58 - so yeah that's how the we can get
116:01 - the we can populate any field
116:06 - of another user of another collection
116:09 - so i'm going to comment it out from here
116:14 - now we are going to see now
116:17 - here we are going to see how can a user
116:20 - from user
116:21 - model we can get the tasks so
116:24 - for getting the task i'm going to rerun
116:27 - the same function in here
116:30 - so in here we are going to need
116:33 - the user model so we are just going to
116:36 - acquire it
116:38 - from the tv model
116:45 - and users and now in here we don't need
116:49 - this one
116:54 - and also we don't need this one so in
116:57 - here we are going to get the user
117:01 - user is equal to await
117:06 - users dot find
117:10 - by id and we are going to use the
117:14 - id of our user that is this one
117:22 - we can get it from here
117:30 - just to say i have acquired the
117:34 - id num id number now we can just console
117:38 - it
117:39 - console.log user dot
117:43 - tasks but we haven't made the
117:46 - task failed so in here in the user model
117:51 - we can do the we can do simply like
117:54 - creating a new field
117:55 - and the same thing that we have done
117:57 - reference but
117:59 - the tasks will be more than one so it
118:02 - will be an error
118:04 - so there is one another thing that the
118:06 - mongoose gave us that is a virtual field
118:09 - that is we are not going to write the
118:11 - field in the
118:12 - model but we are going to create a
118:14 - virtual field in here
118:16 - so for creating a virtual field we are
118:18 - going to write user
118:20 - schema dot virtual
118:23 - and the field name that we have given
118:25 - there task
118:28 - and also and model here like
118:32 - what it's referring to so
118:35 - it is referring to the
118:39 - tasks dot js this one
118:43 - so we are going to write dots
118:47 - and we are going to use the local field
118:52 - local field of this model that is id
118:58 - and we are going to use the foreign
119:00 - field
119:05 - foreign field of
119:09 - tasks model that is honor
119:17 - yeah that's it now if we
119:21 - go to our index.js
119:24 - and run again no first we have to like
119:29 - await it so we are going to await
119:33 - user dot populate
119:37 - the name tasks
119:40 - and also execute it and now if we
119:44 - run again we can see
119:48 - we can see that we have get the
119:53 - user is completed false and node.js
119:57 - so that's how we can
120:00 - there are two methods to doing the
120:02 - relationship between two models
120:06 - so now if we go to our task such as
120:12 - here the thing is already done so in
120:15 - here the task starts router
120:18 - there are few things remaining it is
120:20 - because you are
120:21 - going to authenticate all the things in
120:23 - here
120:25 - so in here we also use the
120:28 - getting all the tasks we are going to
120:30 - use auth method here
120:34 - and because the user
120:37 - because the one that the user wants user
120:40 - is authenticated with
120:42 - is going to get the fills
120:46 - so in here find
120:50 - by the owner field is
120:54 - honor is to request
120:58 - dot user dot id
121:03 - that's how can we get the task
121:08 - in here also the art major is given
121:12 - but it's going to be find one
121:17 - so find one
121:21 - and we are going to find one by
121:25 - using
121:29 - id is to request start parents
121:35 - dot id
121:38 - and also the order method is also needed
121:41 - honor field
121:42 - so request dot user
121:46 - dot id
121:51 - now in here art matter these things will
121:54 - be there
121:56 - but in here we are going to use find one
122:00 - method also
122:03 - and this is going to be
122:07 - id
122:10 - and the same thing honor
122:15 - is to request dot
122:19 - user dot id
122:28 - and yeah that's it we can do
122:32 - this by this now in here the delete also
122:36 - we can do
122:38 - by find one and so i'm going to just
122:41 - copy it from here
122:52 - and that's how we can do
122:56 - now one thing is there that if we
123:00 - like delete the user from the database
123:04 - so
123:05 - the database will be deleted
123:08 - from the user mode also and the last
123:11 - module also
123:13 - so for doing this we are going to use
123:15 - the same thing
123:16 - we are going to use a free method
123:20 - so we can do this by user schema
123:24 - dot pre and we are going looking for
123:29 - remove method
123:33 - and async async function
123:42 - and now we are just going to create
123:47 - this the const user
123:50 - is equal to this and we also needed here
123:53 - the task model also
123:54 - so we are just going to acquire it
123:58 - from cons task
124:03 - is equal to require dots list
124:08 - task now
124:11 - so we are going to await it
124:16 - await task
124:20 - dot find we are going to find
124:24 - by honor
124:30 - and the id will be request dot user
124:35 - dot ib
124:40 - and we are going to use the next
124:43 - function also
124:50 - and
124:53 - we are going to use the remove function
124:56 - remove function in here
124:58 - and just we are going to write the next
124:59 - here
125:01 - so that's how we can use
125:04 - two models in your users in class
125:07 - and yeah that's how it's being done
125:11 - in this video we are going to learn
125:12 - three things that are
125:14 - filtered pagination and sorting
125:17 - so whenever we hit this end point we
125:20 - have we get on the task
125:22 - but we want just one task like
125:25 - you want the tasks that are completed or
125:28 - not completed so for
125:30 - going for getting this type of
125:32 - functionality
125:33 - we have to use the filter functionality
125:36 - so in here we're just going to modify
125:39 - here
125:40 - and let's say the part the part will be
125:43 - the task
125:44 - because in this class
125:47 - in this where we are going to modify the
125:50 - values
125:52 - and the match this field is where we
125:54 - have to like
125:56 - what you have to match it with so it's
125:59 - completed
126:00 - let's see it will be a true value
126:04 - and now if we save it and run it
126:07 - here you will get only the two values
126:10 - and if we just use the false
126:15 - we can get only the false values
126:19 - now this is not dynamically so
126:22 - we have to write some code in here so
126:25 - in here let's create a const match
126:31 - and we are just going to use a query
126:34 - because in here the filter will be
126:36 - requested query dot is completed
126:40 - if this is the object is given
126:44 - then we are going to simply write
126:48 - match dot is completed is equal to
126:53 - request dot query
126:56 - dot is completed is equal to
126:59 - 3 this is because this value will be a
127:03 - string
127:05 - so whenever we use the
127:08 - use compare it with the true value we
127:11 - can get
127:12 - the value with that will be assigned to
127:15 - the mail stock
127:16 - is completed now if it's
127:19 - uh
127:23 - it will be assigned here if it is a
127:25 - false value it will be assigned
127:28 - and it will compare with the true string
127:30 - and then it will be assigned will match
127:31 - out this completely now just we have to
127:34 - remove this
127:36 - and we are going to save it here
127:40 - and now if we run it again but first we
127:43 - have to like
127:45 - give it what we have to know let's say
127:48 - we started it's completely equally true
127:52 - now if we run it again you will see that
127:55 - we can get the true values
127:57 - and if we use false here
128:02 - we can get the false one now
128:05 - there is one thing is called pagination
128:10 - so in pagination there is two things
128:14 - it is a limit and escape
128:18 - in limit this is what we call like
128:22 - what the amount of data that we want but
128:24 - what amount of data that we are going to
128:26 - limit to
128:28 - and escape is the value that is what are
128:31 - the
128:32 - next next value next
128:35 - after the next skip value that the
128:38 - values that we want that means if it is
128:41 - a
128:42 - 10 value it means that we need the set
128:44 - of
128:45 - another 10 values after the first 10
128:48 - values
128:50 - so for getting this we just have to use
128:54 - a options field
128:58 - and it's an object in here we just have
129:01 - to give
129:02 - limit integer value
129:06 - and skip an integer value
129:09 - so if we are going to use dynamically
129:12 - but it is a
129:15 - it it will be a parsing because the
129:18 - value that we get
129:19 - from postman it will be a string so
129:22 - just we have to convert it into a into
129:25 - an
129:26 - integer we are just going to use
129:28 - request.query
129:30 - dot limit any
129:34 - in here the parts end
129:37 - we are just going to use
129:40 - parsing request dot
129:43 - query dot skip
129:47 - now if we save it and
129:51 - in here first we are going to see all
129:55 - tasks here all the tasks are here
129:58 - wall two now if we want to get only this
130:02 - this task we are just going
130:05 - to limit it
130:09 - to a one
130:13 - we get only one task and if we skip
130:18 - sql to one that means we are going to
130:20 - skip this task
130:22 - and go to the next second task
130:25 - then we get this second task
130:29 - and if you are going to use two you will
130:32 - get the third task
130:34 - so this is how limit and skip works
130:38 - now next is starting so
130:42 - in here stalking is done by the next
130:47 - another in options where there is
130:49 - something called short
130:50 - filled in here this is a
130:54 - this requires uh an object
130:57 - so in what way we are going to start it
131:01 - so if we again like run it here so in
131:05 - what we
131:05 - are going to start it let's say we are
131:08 - going to sort it according to the
131:10 - created add so
131:13 - if we use created at here so we have to
131:16 - send it like
131:17 - created at
131:20 - is equal is minus because this
131:24 - is a it requires an integer value and it
131:27 - only takes
131:28 - minus one and one
131:31 - minus one is for descending and one is
131:34 - for
131:34 - ascending so if we say -1
131:40 - and now here we're just going to save it
131:44 - here
131:46 - and now if we look into in the created
131:48 - add
131:50 - and if we run it here minus one
131:54 - the task is upside down means the tax
131:57 - that is in the bottom it goes up that
132:00 - means this
132:01 - task is at a descending rate it means
132:04 - this stock
132:05 - has come at the last this
132:08 - task has been created the last so it is
132:11 - in a descending
132:12 - order so it will come first
132:16 - now if we save it as a one
132:20 - and save it and run it
132:23 - we can get the first task that is
132:25 - created first
132:26 - will be in here now if we start it
132:30 - according to the is completed
132:35 - so it's completed
132:38 - yeah no now if you want to like
132:42 - convert into a way that is
132:47 - that will be upgraded to
132:52 - will be dynamically so for doing this
132:54 - like is completed
132:57 - for doing this we just have to like
133:00 - create the new
133:02 - const
133:05 - match is equal to send empty object
133:09 - right now
133:10 - now in here
133:13 - we are just going to use like sort
133:18 - by
133:21 - now created at
133:30 - created at extending
133:34 - we can write any way like if you want to
133:37 - like
133:39 - use another symbol any symbol that you
133:41 - want i am going to use
133:43 - column symbol here so if you want to use
133:46 - like this
133:48 - like create it at a descending way
133:52 - or ascending way if this type of things
133:55 - we want
133:56 - so we have to like use here if request
134:02 - dot query dot
134:05 - sort by
134:08 - is there so we are just going to
134:13 - use to like sort
134:18 - so what will we get you will get
134:21 - this value here created at
134:24 - this ascending or descending so we have
134:27 - to split this
134:28 - string so for splitting it we are just
134:32 - going to use
134:33 - const string is equal to
134:37 - request dot query dot
134:40 - sort by and we are going to split
134:44 - using the split method
134:48 - and we are going to split according to
134:51 - this column so for doing this we just
134:55 - have to use column here
134:57 - so we can we will get two string here
135:01 - in an array now we are just going to
135:06 - start
135:08 - and we are going because it is assigned
135:10 - to a variable we are going to use sort
135:12 - str is equal to
135:18 - so if str one
135:24 - is equal to dsc
135:28 - we are going to use ternary operator
135:30 - here it is this then we are going to
135:33 - assign to minus one if it is not we are
135:36 - going to assign it one
135:39 - yeah that's it
135:43 - now if we just remove it and you start
135:45 - here
135:49 - and save it here
135:53 - and if we run it again you will get
135:56 - false structure value in ascending way
136:00 - and if we use true here
136:07 - we will get
136:12 - you will get the value as a descending
136:17 - so yeah that's it so this
136:20 - is how the three things filter
136:23 - designation
136:23 - and sorting works in mongoose
136:27 - and nodejs thank you