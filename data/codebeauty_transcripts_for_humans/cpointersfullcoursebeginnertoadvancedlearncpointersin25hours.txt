With timestamps:

00:00 - hi and welcome to my channel this video
00:03 - is beginner to advanced c plus pointers
00:06 - course
00:07 - so in this video you are going to learn
00:09 - about all of the important topics
00:11 - related to pointers
00:12 - but before i start with the lessons i
00:14 - want to give you a few tips
00:16 - so if you need captions or subtitles for
00:19 - this video
00:21 - i want to say that youtube sometimes
00:22 - does not allow captions on videos that
00:25 - are very long
00:26 - but if you really need them i'm going to
00:28 - link here and in the description
00:31 - a playlist that contains all of the
00:33 - individual lessons from this video
00:35 - and those lessons contain captions so if
00:38 - you really need them make sure to check
00:40 - that out
00:41 - tip number two is that all of the
00:42 - chapters will also be linked in the
00:44 - description so that you can navigate
00:46 - yourself through the lessons
00:48 - but my recommendation is to watch the
00:51 - entire video because it is going to be
00:52 - much easier
00:54 - and better for you if you don't skip
00:55 - anything and learn
00:57 - step by step and if you want to learn
00:59 - about other topics like
01:01 - object oriented programming data
01:03 - structures algorithms
01:04 - or programming in general i have a lot
01:07 - more tutorials for you
01:08 - and i will also link them in the
01:10 - description
01:12 - and one of the most important topics
01:14 - that you should definitely check out
01:15 - is creating graphical user interface
01:18 - applications with c plus one of my most
01:22 - popular videos
01:23 - is this one where i explain the fastest
01:26 - and the easiest way to build user
01:29 - interface applications
01:30 - i will link that video in the
01:32 - description and i will also link a tool
01:35 - that i use in order to create
01:37 - ui applications it is called c
01:40 - plus builder and you can download it and
01:43 - try it out for free
01:44 - using the link in the description and
01:47 - please follow that
01:48 - tutorial in order to learn more about
01:50 - building your own
01:51 - ui applications and in that tutorial you
01:55 - will see
01:55 - how c plus builder makes it very easy to
01:58 - create
01:59 - user interfaces so after you watch that
02:02 - tutorial you will understand
02:04 - how to create your own user interface
02:07 - applications
02:08 - so that any idea that you have you will
02:10 - be able to translate that idea
02:12 - into an app very fast so those are the
02:16 - topics that i covered so far on my
02:18 - channel
02:18 - and if you have any other topics that
02:21 - you would like to see in the future
02:22 - feel free to write me in the comment
02:24 - section and before i start i also want
02:27 - to ask you to please give this video a
02:30 - thumbs up for the youtube algorithm
02:32 - and also if you want to support me and
02:34 - my channel
02:35 - and all of the hard work that i put in
02:37 - in order to make these videos
02:39 - and thank you very much if you do that
02:42 - so now i'm going to start with the
02:45 - lessons
02:46 - good luck with learning and feel free to
02:48 - let me know how it goes
02:50 - in the comments
02:51 - [Music]
03:01 - in this video i want to talk about
03:03 - pointers so i will go
03:04 - straight to the point pointers are very
03:07 - important concept in c
03:09 - plus and they have many uses in z plus
03:11 - plus now
03:12 - pointers are not limited only to c plus
03:15 - they exist in other programming
03:17 - languages as well
03:18 - but in most of those programming
03:20 - languages they are really hidden they
03:21 - work behind the scenes
03:23 - so you cannot see them and you cannot
03:25 - use them yourself
03:27 - but at c plus you can use them and you
03:29 - can create your own pointers
03:31 - and they can be pretty powerful if you
03:33 - know how to use them but
03:35 - they can get quite confusing as well if
03:38 - you don't understand them well
03:40 - so the first thing that i want to
03:41 - explain is what
03:43 - are pointers so we already have
03:46 - explained the concept of a variable
03:48 - and you should be familiar with that so
03:51 - we said
03:52 - that a variable is just a container so a
03:54 - container
03:55 - that stores certain value now a pointer
03:58 - is container as well but
04:00 - instead of storing value pointer stores
04:03 - an
04:03 - address so a memory location and
04:06 - let me show you how pointers work in
04:09 - visual studio
04:11 - let's create a variable of type int and
04:14 - i'm going to call it
04:15 - n and assign it a value of 5 and
04:18 - let's write out this n
04:22 - like this so nothing new here we are
04:25 - already familiar with this
04:27 - and if i run my program as you can see
04:30 - we get this value of 5. so that was
04:32 - expected
04:33 - now as i already said this n is a
04:37 - variable and
04:38 - that means that it is a container which
04:40 - is storing certain value
04:42 - now because it is a container that means
04:45 - that
04:45 - it has its address inside memory so it
04:48 - has its physical
04:49 - location so how can we get that location
04:52 - how can
04:53 - how can we check which address this n
04:55 - has so in order to do that
04:57 - you use this ampersand symbol like this
05:01 - so you put it before your variable name
05:04 - and that should give you
05:05 - the address of that variable so if i run
05:07 - my program now
05:10 - as you can see now we have an address
05:13 - um and this is the address of our n
05:17 - variable so this is its physical address
05:20 - where this value of five is stored
05:22 - and because this is pretty hard for
05:24 - humans to remember
05:25 - this is just a random numbers and
05:29 - characters because of that we use
05:31 - meaningful names
05:32 - and we access these values that we store
05:35 - in our memory
05:36 - using these meaningful names which are
05:38 - our variables
05:39 - so i'm going to close this now and what
05:42 - i want to show you here is
05:44 - i want to show you how can you create a
05:46 - pointer that is going to hold
05:48 - this address of our n variable so
05:51 - in order to create a pointer you give it
05:53 - a type first
05:55 - so you say int and then in order to
05:57 - indicate that you are creating a pointer
05:59 - you use this
06:01 - star symbol and then you give it a name
06:03 - so let's call it
06:04 - ptr pointer and i'm going to assign it
06:09 - the address of our n variable so i'm
06:12 - going to copy this
06:13 - and paste it here okay
06:16 - now our pointer is holding the address
06:19 - of our n variable and in order to prove
06:21 - that
06:22 - i'm going to write out the value of my
06:25 - pointer
06:28 - like this
06:32 - so as expected we have this first line
06:35 - here which is writing out the address of
06:37 - our n variable
06:38 - and then this second line of code is
06:41 - this
06:42 - line here and as you can see we have
06:44 - written out the value of our pointer
06:46 - and that is the same address as this one
06:49 - here
06:50 - which means that our pointer really is
06:52 - storing the address of our n
06:54 - variable now you may ask how can i
06:58 - access or can i access the value that is
07:01 - stored on that
07:02 - address using pointers and the answer to
07:04 - that question is yes
07:06 - you can and in order to do that in order
07:09 - to access the value that is stored
07:11 - on this address that your pointer is
07:13 - holding you have to de-reference your
07:15 - pointer
07:16 - so how do you do that well let me copy
07:18 - this
07:20 - so as you already have seen this line of
07:23 - code here
07:24 - is going to write out the address and in
07:27 - order to write out the value on that
07:29 - address you
07:30 - dereference the pointer and in order to
07:32 - do that you add
07:33 - this star symbol before your pointer's
07:36 - name
07:36 - so if i run my program now as you can
07:40 - see
07:40 - in this last line of code we have the
07:43 - value of 5
07:44 - which is actually the value that is
07:46 - stored on this address here
07:48 - so let me show you one more thing what i
07:51 - want to do is i want to change
07:53 - the value that is stored on this ptr
07:55 - address so on this address that our ptr
07:58 - pointer is storing
08:00 - so how am i going to do that i'm going
08:02 - to say again
08:03 - star symbol and then ptr and this here
08:06 - means
08:07 - please access this memory location so
08:10 - whatever i'm going to assign
08:12 - here is going to be stored on that
08:14 - memory location and what i want to
08:16 - assign
08:16 - is for example value of 10 like this
08:20 - so now if i copy this line of code and
08:23 - then paste it here
08:25 - and if i run my program again we have
08:28 - this
08:29 - value of 10 stored on this address here
08:32 - and one interesting thing as well is
08:34 - that
08:35 - if we try to write out the value that
08:37 - our n holds now like this
08:41 - if i run my program as you can see
08:44 - our n holds the value of 10 as well
08:47 - even though we have never said that n
08:50 - has the value of 10
08:52 - but we have stored the address of our n
08:55 - in our pointer and then we have
08:57 - dereferenced our pointer meaning we have
08:59 - changed
09:00 - the value on that address here in this
09:03 - 11th line of code
09:04 - here so that's why our n holds value of
09:07 - 10
09:08 - now one very important thing to keep in
09:11 - mind
09:11 - is that your pointer has to be of the
09:13 - same type like the variable that it is
09:16 - pointing to
09:17 - so let's close this so as i said
09:20 - this integer pointer is pointing to an
09:23 - integer
09:24 - variable so rn is of int type
09:27 - and the same way would be if we created
09:29 - a float pointer it would have to point
09:31 - to a float
09:32 - variable and then char pointer can point
09:35 - only to a char variable
09:36 - double bool uh and so on so
09:40 - pointer and the variable that that
09:41 - pointer is pointing to
09:43 - have to be of the same type okay so
09:47 - that means that if i try to change the
09:49 - type of this n variable
09:50 - to float for example
09:53 - like this so if i say float immediately
09:57 - we get
09:57 - an error here and the error says
10:01 - a value of type float pointer cannot be
10:03 - used to initialize
10:05 - an entity of type endpointer meaning
10:08 - you cannot assign address of a float
10:12 - type to pointer of int
10:15 - type okay so that is the error that we
10:18 - have here
10:19 - and i'm going to return this to int
10:22 - okay and as you can see that error has
10:26 - disappeared because now our pointer is
10:28 - pointing to the same type so to the
10:30 - variable of the same type
10:32 - that that pointer has so int
10:35 - pointer pointing to an int variable
10:38 - one thing that beginners very often try
10:41 - to do is
10:42 - the following so they say okay let's
10:45 - create a pointer
10:46 - so int let's give it a name ptr2
10:49 - so pointer like this so i have created a
10:52 - pointer
10:53 - right so let's dereference this pointer
10:56 - and assign it a value so i'm going to
10:58 - say please dereference ptr
11:00 - 2 and assign it a value of
11:03 - 7 for example now this code here has a
11:07 - problem
11:07 - problem and if i run it if i say build
11:11 - solution actually
11:12 - as you can see it says uninitialized
11:14 - local variable ptr2 used
11:16 - this means that this ptr2 so this
11:20 - pointer 2 does not have an address so
11:23 - where should it store this value of 7 if
11:25 - it does not have
11:26 - an address and the easiest way right now
11:29 - to solve this problem is going to be
11:31 - to create a variable and to give the
11:34 - address of that variable to our ptr2
11:37 - pointer so i'm going to say int v
11:41 - this variable has to be of the same type
11:43 - as our pointer as we already said
11:45 - and then i'm going to say here our ptr2
11:48 - is going to hold
11:49 - the address of our v
11:53 - variable like this and now we shouldn't
11:56 - have this problem anymore so if i build
11:58 - my code again
12:00 - as you can see one succeeded so the
12:02 - problem has disappeared
12:04 - and let me write out the value of this
12:08 - v variable so i'm going to say v is
12:10 - equal to
12:11 - and then let's write out the value
12:14 - of this v and if i run my program
12:19 - as you can see it says that v has the
12:22 - value
12:22 - of 7 because we have assigned it here by
12:25 - dereferencing our pointer that is
12:27 - holding the address of
12:29 - our v so you may say now okay salina i
12:32 - understand this but this seems a little
12:35 - bit too much why would i create a
12:37 - pointer
12:38 - just to assign a value to a variable and
12:41 - the answer to that question
12:43 - is you don't this is not the type of
12:45 - problem for which pointers were created
12:47 - in c
12:48 - plus plus so there are different
12:50 - problems that pointers solve in c
12:52 - plus plus and this here is just a
12:54 - demonstration of what
12:56 - are pointers and how can you create your
12:58 - own pointers
12:59 - now examples of some of these other
13:02 - problems that pointers solve
13:03 - is you can use pointers in order to pass
13:07 - values by a reference to a function and
13:10 - then you can use them to return multiple
13:12 - values from a function which is an
13:14 - interesting one
13:15 - you can use pointers in combination with
13:17 - arrays as well
13:19 - you can use them for dynamic memory
13:21 - allocation and then if you're familiar
13:23 - with oop
13:24 - object-oriented programming you can use
13:26 - a pointer of a base class
13:28 - in order to access a object of derived
13:32 - class
13:33 - and then there is this concept of smart
13:35 - pointers which we are going to cover
13:37 - in the future so stay tuned subscribe to
13:40 - my channel
13:41 - um hit that bell icon as well so that
13:43 - you are notified when i publish my next
13:45 - video
13:46 - and if you like this one give it a
13:48 - thumbs up
13:49 - thank you for watching and i'm going to
13:51 - see you in my next video where we will
13:53 - be talking about pointers
13:55 - bye in this video i want to talk about
13:58 - void pointers
13:59 - now in the previous video of this
14:00 - playlist i introduced you to pointers in
14:03 - general so
14:04 - i explained what are pointers and how
14:06 - you can create your own pointers
14:08 - and i said that a pointer is a special
14:11 - variable
14:11 - that can hold an address and i said as
14:14 - well that
14:15 - a pointer can hold only the address of a
14:18 - variable that is
14:19 - of the same type as that pointer which
14:21 - means
14:22 - an integer pointer can hold the address
14:24 - of an integer variable and then a
14:26 - character pointer holds the address of a
14:28 - character variable
14:29 - flow pointer of a float variable and so
14:31 - on but
14:33 - there is an exception to that rule and
14:36 - that is
14:36 - a void pointer and a void pointer is a
14:39 - special type of pointer
14:41 - that can hold the address of a variable
14:43 - of
14:44 - any other data type so avoid pointer can
14:46 - hold the address
14:47 - of a float variable or an end variable
14:50 - or a
14:50 - char bool struct whichever one you pass
14:54 - to that void pointer
14:55 - but a void pointer has a limitation as
14:58 - well
14:59 - and that limitation is that you cannot
15:01 - directly
15:02 - dereference a void pointer so in order
15:05 - to demonstrate
15:06 - this i'm going to create an example with
15:08 - the knowledge that we already have so
15:10 - using only integer and character and
15:13 - float pointers that we are already
15:14 - familiar with
15:16 - and then i want to introduce a void
15:18 - pointer in order to solve that problem
15:20 - so that you can see
15:21 - how void pointers are used so
15:24 - let's jump into our visual studio here
15:27 - i want to create a variable um and let's
15:30 - make it of int data type so i'm going to
15:33 - say
15:34 - int and let's call it number like this
15:37 - and i'm going to assign it a value of 5
15:40 - for example
15:42 - now what i want to do with this number
15:44 - variable
15:45 - is i just want to write it out and
15:47 - because we are working with pointers
15:49 - let's play with pointers
15:51 - some more so i want to write out this
15:53 - variable
15:54 - using a function that receives a pointer
15:57 - let's do that
15:58 - so that function is going to be of
16:01 - return type
16:02 - void and let's call it print number
16:06 - like this and then here this function
16:09 - is going to receive an integer pointer
16:12 - and we are going to call it uh number
16:15 - ptr so number pointer
16:18 - okay now what this function
16:22 - here should do is it should just print
16:24 - out the value
16:25 - that this number pointer is storing so
16:27 - actually the value that is stored on the
16:29 - address
16:30 - that this number pointer is holding so
16:33 - in order to do that
16:34 - we have to dereference this pointer so
16:37 - i'm going to say star symbol
16:38 - and then put the name of this number
16:41 - pointer and let's add an
16:43 - end line as well now
16:46 - this function is finished and it is
16:49 - writing out
16:50 - the value that is stored on the address
16:52 - that we passed to it
16:53 - and we have to pass it the address of an
16:56 - integer
16:57 - variable so if i invoke this print
17:00 - number function let's say print number
17:03 - as i said
17:04 - since it is receiving a pointer we have
17:06 - to pass it an
17:07 - address and that is going to be the
17:09 - address of this
17:10 - number variable so let's say ampersand
17:14 - number so this here is going to give us
17:16 - the address of this
17:17 - number variable okay
17:21 - and now if i run this program as you can
17:24 - see
17:24 - this function here has printed out value
17:26 - of
17:27 - 5 which is the value of our number
17:30 - okay now what happens if i want to
17:33 - create a character variable and then
17:35 - print out a character variable as well
17:37 - so let's do that i'm going to say char
17:40 - let's call it
17:41 - letter and
17:44 - let's assign it a value of letter a
17:48 - okay and now in order to print out this
17:51 - character
17:51 - using this same approach i will have to
17:54 - create another function because this one
17:56 - here
17:56 - receives an integer pointer and in order
17:59 - to print out
18:00 - a character we would have to create a
18:02 - function that receives a character
18:04 - pointer so let's
18:05 - copy this function here and i'm going to
18:08 - call it
18:09 - print letter
18:12 - like this and then this function is
18:14 - going to receive a character pointer
18:17 - okay and that pointer is going to be
18:19 - called
18:20 - char ptr and then here
18:24 - i just want to write out the reference
18:26 - value of that
18:27 - char ptr so let's invoke this
18:30 - print letter function
18:34 - let's pass it the address of this letter
18:37 - variable that we have created here
18:40 - and now if i run this program as you can
18:43 - see
18:44 - we have 5 for this first function and
18:47 - then
18:48 - a for this second function which means
18:51 - that
18:51 - these two functions are doing its job
18:54 - but
18:54 - what happens if i want to print out a
18:56 - floating point number
18:58 - and then a double and then a boolean
18:59 - value and a struct value
19:01 - in order to do each one of those i would
19:03 - have to create a function
19:05 - that receives that specific data type
19:08 - pointer
19:09 - but we can solve that same problem using
19:12 - a void pointer because
19:13 - as we already said a void pointer can
19:16 - point to a variable of
19:18 - any data type so let's do that let's
19:21 - create a function that is going to print
19:23 - out any data type so that function is
19:26 - going to be of return type
19:27 - void and let's give it a name print
19:31 - because it is generic it is going to
19:33 - work with all data types
19:35 - i'm going to give it name of print and
19:37 - as we said
19:38 - that function is going to receive void
19:41 - pointer and let's call that pointer ptr
19:44 - okay now because this
19:47 - void pointer can point to a variable of
19:50 - any data type
19:51 - we will have to keep track of which data
19:54 - type we have passed inside this
19:56 - void pointer and in order to do that i'm
19:59 - going to use another parameter here
20:01 - and that parameter is going to be of
20:03 - type char and i'm going to call it
20:06 - type so how this type
20:09 - parameter is going to be used well in a
20:11 - situation
20:12 - where we pass an integer pointer to this
20:15 - print function
20:16 - here this type parameter is going to
20:18 - have a value of
20:20 - i in a situation when we pass a
20:22 - character pointer to this
20:24 - void pointer here in this type parameter
20:27 - we are going to pass a value of
20:29 - c and then if we pass a float pointer
20:32 - here here we are going to store an f
20:34 - and then if we pass a double pointer
20:37 - here
20:37 - this type variable should store a letter
20:39 - d so that we can know
20:41 - how we are going to dereference this ptr
20:45 - pointer so the first thing that we have
20:47 - to do is we have to check
20:49 - what this type variable is holding so
20:52 - in order to do that i'm going to use
20:54 - switch case
20:56 - like this you can use if else as well if
20:59 - you want
21:00 - so here i'm going to switch on this type
21:03 - variable like this and what i want to do
21:07 - here is i want to say
21:09 - indicates that this type variable is
21:12 - holding
21:13 - the value of i that means
21:16 - that this here is an integer pointer so
21:19 - here i'm just
21:20 - going to leave a comment for now so i'm
21:22 - going to say
21:23 - handle int pointer like this
21:27 - and then the other situation is going to
21:29 - be
21:30 - indicates that this type variable
21:33 - is holding the value of c that means
21:37 - that here
21:38 - we have passed a character pointer so
21:40 - i'm going to leave
21:41 - another comment as well so here i i'm
21:44 - going to say
21:45 - handle char pointer okay
21:49 - now let's explain how we are going to
21:51 - handle
21:52 - this integer pointer and then this
21:54 - character pointer as well
21:56 - well as we already said since avoid
21:59 - pointer cannot be dereferenced directly
22:01 - but we first have to cast it into a
22:03 - specific
22:04 - data type so into an integer pointer or
22:07 - into a character pointer in this
22:08 - particular situation
22:10 - i'm going to do that so here i'm going
22:13 - to say
22:14 - in the case that our user has passed an
22:16 - integer pointer here
22:18 - i will have to cast this void pointer
22:21 - into an integer pointer first
22:23 - so how do you do that well you say
22:26 - please
22:26 - this pointer here so this ptr
22:30 - casts that into an integer
22:33 - pointer so this expression here
22:36 - is going to cast this void pointer into
22:39 - an integer
22:40 - pointer so in these parentheses here we
22:43 - are going to have
22:45 - an integer pointer and in order to
22:47 - access
22:48 - to the address that an integer pointer
22:50 - is storing and write out the value that
22:52 - is stored
22:53 - on that address we dereference that
22:56 - pointer and for that we use this star
22:59 - symbol so now here we have the value
23:02 - that is stored on this integer pointer
23:06 - and i'm going to write out that value
23:09 - like this
23:09 - and let's add end line as well
23:13 - so this here writes out the value of an
23:16 - integer pointer so let's copy that and
23:19 - then paste it here
23:21 - and here what i want to do in this c
23:23 - situation is i want to cast
23:25 - this void pointer into a character
23:28 - pointer so char
23:30 - pointer and then after i have character
23:32 - pointer here id
23:34 - reference and then this line is going to
23:37 - write out the value of our character
23:40 - okay so now if i invoke this print
23:43 - function
23:44 - i should get the value of this number
23:47 - and then of this
23:48 - letter as well using only this print
23:50 - function
23:51 - so let's comment these two for now
23:55 - and let's invoke our print function so
23:58 - i'm going to say print
24:00 - and then the first thing that it
24:01 - receives is going to be
24:03 - the address and in this particular
24:05 - situation considering that
24:07 - this is a void pointer we can pass it
24:09 - the address of
24:10 - any data type so we can pass it the
24:13 - address of
24:14 - a integer variable or of a character
24:16 - variable or of a
24:18 - floating point variable and in this
24:20 - situation we have
24:21 - integer variable and then character
24:23 - variable so let's use
24:25 - these two so let's pass here the address
24:28 - of our number that oh that is going to
24:32 - be the first parameter
24:33 - and then the second parameter is going
24:35 - to be the type and considering that we
24:37 - have passed the address of an integer
24:40 - let's pass the value of i
24:43 - as our second parameter here okay
24:46 - and then i'm going to copy this function
24:48 - one more time and
24:50 - this time i want to pass it the address
24:53 - of our letter variable and considering
24:56 - that
24:56 - that is a character here as a second
25:00 - parameter i'm going to pass
25:01 - c now i've just noticed that something
25:04 - is missing from our switch case
25:06 - and before i say what it is please write
25:09 - your idea write your answer
25:11 - in the comments down below so what we
25:13 - are missing in these two
25:15 - cases is break at the end so here i'm
25:18 - missing a break
25:20 - like this and then here as well
25:24 - okay so now we have completed our switch
25:28 - case
25:28 - and if i run my program now
25:33 - as you can see for this first line we
25:36 - get the value of
25:37 - 5 which is our integer so this print
25:39 - function has printed
25:40 - the value of our integer and then in
25:43 - this second line
25:44 - we have printed out the value of a
25:46 - character and we have done that
25:48 - using this print function which
25:52 - receives a void pointer and then it
25:55 - receives
25:56 - a char variable which is called
25:59 - type and we use that char variable in
26:01 - order to differentiate
26:02 - which data type we are storing inside
26:05 - this
26:05 - void pointer because as i already said a
26:08 - void pointer can point to a variable of
26:11 - any data type but it cannot be
26:13 - dereferenced
26:14 - directly so for that we are using this
26:18 - type parameter to check which data type
26:21 - is stored inside this pointer here
26:25 - so now you have an idea on how to use
26:27 - void pointers but i would actually
26:30 - advise you to be
26:31 - very careful when using void pointers
26:33 - why
26:34 - because your compiler in this particular
26:37 - situation
26:38 - does not have a way to tell you hey you
26:41 - are trying to cast
26:42 - a void pointer which is actually an end
26:44 - pointer into a character or
26:46 - vice versa if you are doing that your
26:48 - compiler
26:49 - in this situation here does not have a
26:52 - way
26:53 - to know if you are making an error or
26:55 - not because
26:56 - inside a void pointer you can store the
26:59 - address
26:59 - of any variable so of a variable of any
27:02 - data type and then you can try to cast
27:04 - that void pointer into a pointer of any
27:07 - other data type
27:09 - which means for example in this
27:11 - particular situation
27:12 - here we are passing an integer so this
27:15 - number here
27:16 - is an integer which means that here for
27:19 - this line of code
27:20 - we are receiving an integer pointer okay
27:24 - and then in this case here we are trying
27:26 - to cast
27:27 - that into an integer pointer and that is
27:29 - okay but
27:31 - if we accidentally make a mistake here
27:33 - and we try to cast that into a character
27:35 - pointer for example
27:37 - like this our compiler now does not have
27:40 - a way
27:41 - to know that we are making a mistake
27:44 - here and if we run our program
27:48 - look at this we get this undefined
27:51 - symbol here which is
27:52 - what is this you know this is not the
27:55 - expected
27:56 - behavior of our program and we did not
27:58 - get a compile-time
28:00 - error which means that this here
28:03 - is completely valid so your compiler is
28:06 - not going to tell you that this here is
28:08 - an error
28:08 - but it actually is a logical error and
28:12 - those type of errors so logical errors
28:14 - are much harder to
28:16 - find inside programs and this here is a
28:19 - small program
28:20 - and it is kind of easy to find an error
28:23 - in a program that has
28:24 - 20 lines of code but if you had a
28:26 - logical error in a program that has
28:29 - 20 000 lies of lines of code for example
28:32 - you would have a very very big problem
28:34 - so again i strongly advise you to be
28:38 - very careful when you are using void
28:40 - pointers because as you see
28:42 - compiler is not uh reporting an error
28:45 - for this situation here but
28:47 - but this actually is an error so i'm
28:49 - going to return this
28:50 - to an integer pointer okay
28:53 - so i hope that you enjoyed this video
28:56 - and uh that you learned something new
28:58 - and if you did give it a thumbs up
29:00 - subscribe to my channel and
29:02 - thank you for watching i'm going to see
29:03 - you in my next video bye
29:06 - hi everyone welcome to my channel in
29:08 - this video i want to talk about
29:10 - pointers and arrays and if you watched
29:13 - the first video of this playlist
29:15 - you remember that i said that one of the
29:17 - common uses of pointers
29:19 - is using them with arrays so in this
29:21 - video i want to demonstrate how that
29:23 - works so let's jump straight to our
29:26 - visual studio
29:27 - and let's create an array of type end
29:31 - and i'm going to call that array lucky
29:33 - numbers
29:37 - like this and let's say that i have five
29:40 - lucky numbers for example and
29:42 - those are two three five seven
29:45 - nine oh that's five numbers already okay
29:49 - so these here are my lucky numbers
29:53 - and now i want to show you one thing so
29:56 - what is going to happen if i say for
29:58 - example c out
30:00 - lucky numbers and let's add a line
30:03 - so what is going to be written out if i
30:06 - write
30:06 - out just the name of my array let's
30:09 - check that
30:10 - if i run this program as you can see
30:14 - we get an address but what is this
30:17 - address this address here so
30:20 - the name of our array is actually the
30:22 - address of the first element of that
30:25 - array and in order to prove that let's
30:28 - write out the address of the first
30:30 - element of this
30:31 - array to check if these two are going to
30:34 - be the same so here
30:35 - i want to write out the address of the
30:38 - first
30:39 - element which is the element with index
30:42 - 0. so now if i'm telling the truth
30:46 - these two should be the same so if i run
30:49 - my
30:50 - program as you can see indeed we get
30:53 - the same address which means again
30:57 - the name of the array is the address
31:00 - of the first element of that array
31:03 - now that means that this
31:06 - lucky number's name behaves as a pointer
31:10 - and these square brackets here are
31:12 - behaving as
31:13 - a operator for dereferencing so
31:16 - if i say for example c out lucky numbers
31:20 - of 2 i'm going to get
31:24 - the element that has index 2. so this
31:27 - here is going to be
31:28 - the first address and then it is going
31:31 - to add two more addresses
31:33 - to that element and we are going to get
31:36 - the value that is stored
31:37 - there so lucky numbers name is the
31:40 - address of the first element
31:42 - it is going to add two more addresses to
31:45 - that
31:46 - so one two so this line of code here is
31:50 - going to give us the value of
31:52 - five let's add end line and run our
31:54 - program in order to demonstrate that
31:58 - and as you can see indeed we get the
32:00 - value
32:01 - of five now there is another way to do
32:04 - this same thing
32:05 - here and that is going to be the
32:07 - following way so i can say c
32:09 - out please write out
32:12 - this lucky numbers which as we already
32:15 - demonstrated
32:16 - is the address of this first element so
32:18 - i'm going to put that here
32:20 - and then i can use arithmetic operators
32:22 - on this so i can say
32:24 - please add to this lucky numbers
32:27 - two more address spaces and then
32:30 - dereference
32:31 - this so we use star symbol for that
32:35 - and then i'm going to add a line and
32:38 - these two lines of code
32:40 - so this one here and this one here
32:43 - should behave
32:44 - the same so if i run my program now as
32:47 - you can see
32:48 - we get the same value so these two lines
32:51 - of code are doing the same thing
32:53 - which means that this line of code here
32:56 - is using these square brackets in order
32:58 - to
32:59 - dereferentiate the element with that
33:02 - index which is index
33:03 - 2 and we know that the indexing starts
33:06 - with 0
33:06 - so 0 1 2 and we get the value of 5
33:10 - and then this second line of code here
33:13 - uses
33:14 - this star symbol in order to
33:15 - dereferentiate this expression here
33:18 - and what this expression here says it
33:20 - says
33:21 - lucky numbers which is the address of
33:23 - the first element as we demonstrated
33:26 - here so please use the address of the
33:29 - first
33:29 - element and then add two more address
33:33 - spaces to that
33:34 - so the address of the first element if i
33:37 - add two more to that it's going to be
33:39 - the address of
33:40 - one two so the address of this one
33:43 - here and then if i dereferentiate that i
33:46 - get
33:47 - this value which is stored on that
33:49 - address so
33:50 - these two lines of code are writing out
33:53 - the same thing
33:54 - so let me very quickly show you how you
33:57 - can
33:58 - enter the values for this array and then
34:00 - write them out
34:01 - because here we have hard-coded values
34:04 - so i'm going to
34:05 - delete this and
34:09 - i'm going to comment these two lines of
34:10 - code as well no actually i'm going to
34:12 - comment
34:13 - all of these because we don't need them
34:15 - anymore but i'm going to leave them for
34:17 - you
34:17 - so that you can see how these are used
34:21 - in order to dereferentiate
34:23 - your array so as i said we want to enter
34:26 - values for our array now so in order to
34:29 - do that i'm going to use
34:30 - for loop so i will say
34:33 - and then our for loop starts with i
34:37 - equal to 0 because that is the index of
34:40 - our first element and then considering
34:42 - that our array has 5
34:44 - elements and the last one has index of 4
34:47 - we are going to run our for loop while i
34:50 - is less than or equal to four
34:53 - and in each iteration we are going to
34:55 - increment the value of our
34:57 - i okay and in order to enter
35:01 - values for our array let's write out a
35:03 - message so i'm going to say see
35:05 - out number so please enter a number
35:08 - that is going to be the message for our
35:10 - user and then i'm going to
35:12 - input a value from my console
35:16 - into lucky numbers of i
35:19 - so this here means please enter the
35:22 - value
35:23 - into our lucky numbers array to element
35:26 - that has the same index that our i holds
35:30 - in that
35:30 - iteration so in the first iteration
35:33 - index 0 in the second iteration index 1
35:35 - and then in the third iteration index 2
35:38 - and so on
35:39 - so this for loop here is going to help
35:42 - us
35:43 - to enter the values into our lucky
35:45 - numbers array
35:46 - and in order to show that i'm going to
35:49 - put here a breakpoint
35:50 - and that means that our program is going
35:53 - to stop its execution when it comes to
35:55 - this line here
35:56 - so if i run my program
36:00 - as you can see it asks me to enter a
36:02 - number so i'm going to say
36:03 - 2 5 7 9
36:07 - and 13. so those were five numbers that
36:10 - we had to enter for our lucky numbers
36:12 - array
36:13 - and if i press enter one more time as
36:15 - you can see
36:17 - our program has been stopped in this
36:19 - line of code here
36:20 - and if i hover over my lucky numbers
36:23 - here we have
36:24 - values that we have entered for our
36:26 - array so value of
36:28 - 2 5 7 9 and 13 which
36:31 - are the values that we have entered here
36:34 - so i'm going to stop my program now
36:38 - please stop okay
36:41 - and now what i want to do is i want to
36:43 - use this other approach
36:45 - to write out the numbers that this lucky
36:49 - numbers array is holding
36:50 - so let's use another for loop i'm going
36:53 - to copy this one
36:55 - okay and then what this second for loop
36:58 - is going to do
36:59 - it is just going to write out these
37:01 - numbers
37:02 - but okay let's use this approach for now
37:05 - so i'm going to just
37:06 - change this to c out and then
37:09 - use these other redirection signs and
37:12 - after each
37:13 - number i'm going to add an empty space
37:17 - okay like this and instead of using
37:21 - this approach here so instead of using
37:24 - these square brackets in order to
37:25 - differentiate
37:27 - the element on that position let's use
37:29 - this approach
37:31 - here so i'm going to say please
37:34 - use lucky numbers so which is the
37:37 - address
37:38 - of the first element and then to that
37:41 - i want to add the value of my i so
37:44 - plus i like this and
37:47 - this is going to move okay
37:50 - so this expression here is going to help
37:53 - us to access
37:54 - all of the elements of this lucky
37:56 - numbers array so from the one that has
37:59 - index 0 until we come to the one that
38:02 - has index
38:03 - four and because we don't want to write
38:05 - out addresses because this here is going
38:07 - to give us the address
38:09 - but we want to write out the values that
38:11 - are stored on those addresses we will
38:13 - have to de-reference
38:14 - this expression here so for that i will
38:17 - use
38:18 - star symbol and i'm going to remove this
38:21 - breakpoint now
38:22 - and i'm going to start my program to see
38:24 - what is going to happen
38:28 - okay and let's enter 2 3
38:31 - 5 7 19 and as you can see
38:35 - we get values of 2 3 5 7 and 19 which we
38:38 - have entered
38:39 - okay let's stop this program now and
38:42 - there is one more thing that i want to
38:44 - show you
38:45 - what is going to happen if i change this
38:48 - max value from 4 to 5
38:51 - like this so what is going to happen in
38:53 - this particular situation
38:55 - let's run our program
38:58 - and enter numbers again so 2 5 7
39:01 - 13 15. okay
39:04 - as you can see now here we have
39:07 - these five numbers that we have entered
39:09 - so 2 5 7
39:10 - 13 15 those are the ones here and then
39:14 - the last one is something that we do not
39:16 - recognize what is this this is some
39:18 - junk number that we definitely have not
39:21 - entered here
39:22 - so this number here is something that
39:25 - does not
39:25 - belong to our lucky numbers array and
39:28 - here
39:29 - we have accessed someone else's memory
39:32 - space
39:33 - so we have this result because we change
39:36 - the max value
39:37 - from 4 to 5 here and as we already know
39:41 - our lucky numbers has five elements the
39:43 - last one having the index
39:45 - of four which is this one here and then
39:48 - here we added one more iteration
39:50 - so now we are trying to access the
39:53 - element with index
39:54 - five and that element with index 5 does
39:57 - not belong
39:58 - or does not exist in our lucky numbers
40:01 - array so this element here
40:04 - this is memory location that belongs to
40:07 - someone else and we
40:09 - accessed that trying to dereferentiate
40:12 - the pointer to the element that is
40:15 - sixth element so we have five elements
40:19 - in our lucky numbers array and then if
40:21 - we add
40:22 - one more address space to that we get
40:25 - this here which is memory location that
40:28 - belongs to someone else
40:30 - and if we just randomly change and
40:33 - access memory locations that do not
40:34 - belong
40:35 - to us we can cause very very big
40:38 - problems so
40:39 - i advise you to be very careful when
40:42 - iterating through your
40:44 - arrays and to access only memory
40:46 - locations that
40:47 - belong to that array that you are
40:49 - iterating so
40:51 - indicates that your array has five
40:53 - elements that those are going to be
40:54 - from zero to four so indexes from zero
40:57 - to four
40:58 - in the case that your array has ten
41:00 - elements for example those are going to
41:02 - be indexes
41:03 - zero to nine and so on so
41:06 - again be very very careful to not access
41:10 - memory locations
41:11 - that do not belong to you so i hope that
41:14 - now you have an idea on how
41:16 - pointers and arrays go together and as
41:19 - well we have
41:20 - seen some of the potential problems that
41:21 - can happen if you are not
41:23 - careful enough when working with
41:25 - pointers and arrays
41:27 - so again i advise you to be very careful
41:30 - uh when working with pointers and arrays
41:32 - and not access memory locations memory
41:35 - addresses that do not
41:36 - belong to you so thank you for watching
41:39 - and i'm going to see you in my next
41:41 - video
41:41 - bye in this video i want to explain how
41:44 - you can use
41:45 - pointers in order to return multiple
41:48 - values from a function
41:50 - so i said in the first video of this
41:52 - playlist that
41:53 - using pointers to return multiple values
41:55 - from a function is a very common use for
41:58 - pointers so in this video i want to
42:00 - demonstrate how that works so here we
42:03 - are going to create
42:05 - an array of numbers and then first i
42:07 - want to create
42:08 - two functions and one of those two is
42:10 - going to return me
42:11 - the smallest number in that array and
42:14 - then the other one is going to return me
42:16 - the largest number in that array and
42:18 - then in the second part of this video i
42:20 - want to show you how you can use
42:22 - pointers in order to get both smallest
42:25 - and largest number using one function
42:28 - only so you can return
42:30 - both of these numbers so min number and
42:33 - max number using only
42:34 - one function and that is going to be
42:37 - with the help of
42:38 - pointers so let's start with this
42:40 - example
42:42 - as i already said i'm going to create
42:45 - an array of numbers so um
42:48 - those are going to be numbers of type
42:49 - int and let's call this
42:51 - array numbers like this and it is going
42:54 - to be array of five
42:56 - numbers and let's assign them
42:59 - values of for example 5
43:02 - 4 minus 2
43:06 - 29 and 6 for example
43:09 - so those are going to be my numbers
43:13 - okay and now let's create a function
43:16 - that is going to return
43:18 - the smallest number of this array so i'm
43:20 - going to create that function here
43:23 - and let's give it the return type of end
43:26 - and i'm going to call it get min
43:30 - like this and what i will need to pass
43:32 - to this function
43:33 - is going to be array so this array here
43:37 - so
43:37 - i'm going to say int numbers
43:41 - array so this is going to be the first
43:44 - argument and then the second one is
43:46 - going to be the size of this
43:48 - array so i'm going to say int size and
43:51 - we will use
43:52 - this second parameter here so that we
43:55 - know how many iterations we have to make
43:57 - in order to go through all of the
44:00 - elements of this
44:01 - array so let's define this function the
44:04 - first thing
44:04 - that i want to do is i want to create a
44:07 - variable
44:09 - of type int and that variable is going
44:12 - to be called
44:13 - min so this is going to be the variable
44:16 - that is going to hold
44:17 - the minimal value so the smallest number
44:20 - in this
44:21 - array and initially i want to assign to
44:24 - this variable
44:25 - the first element of this array so i'm
44:27 - going to say that the smallest element
44:29 - initially is going to be
44:30 - the first one so i'm going to say
44:32 - numbers of
44:34 - zero and then we are going to iterate
44:37 - through
44:37 - all of the other elements and each time
44:40 - that we find
44:40 - an element that is smaller than the
44:43 - current value of our min
44:44 - we are going to store that value in our
44:47 - min
44:48 - so let's do that so i'm going to say 4
44:52 - and since we have already stored the
44:54 - value of our first element in our min
44:56 - we do not need to iterate through that
44:59 - so i'm going to say that my int
45:01 - initially has the value of one
45:04 - okay oh and i is equal to one
45:08 - like this and then our for loop is going
45:10 - to iterate
45:11 - while our i is less than the size of
45:14 - this
45:15 - array so in this particular situation
45:18 - while our i is less than
45:19 - 5 and in each iteration we want to
45:22 - increment
45:23 - our i like this so as i already said
45:28 - if we find a number on a specific
45:32 - position which is in this current
45:34 - situation uh the position with the index
45:37 - of
45:37 - i if we determine that that number is
45:40 - smaller
45:41 - than our min number like this
45:44 - we are going to store that number in our
45:48 - min
45:48 - variable so i'm going to say min is
45:50 - equal to
45:52 - numbers of i so that
45:55 - at the end of this for loop in our min
45:58 - variable is going to be the smallest
46:00 - number of this
46:01 - array so at the end of this for loop
46:05 - here
46:05 - we can return our min like this
46:09 - okay so now in order to test this
46:11 - function here i'm going to invoke it
46:14 - let's say get actually i'm going to
46:16 - write it out i'm going to say see out
46:18 - min is like this and then
46:21 - let's invoke it let's say get min like
46:25 - this
46:26 - and this get main function receives
46:29 - array so let's pass it numbers array
46:33 - and then it receives the size of this
46:35 - array
46:36 - and this array has one two three four
46:38 - five elements and you can check that
46:40 - here as well so we are going to pass
46:43 - five here okay and if i run this program
46:49 - as you can see it says min is minus two
46:52 - which really is
46:53 - the smallest number in our array
46:57 - so that is going to be the first
46:58 - function and then the second function
47:01 - that i want to create is going to be the
47:02 - one
47:03 - that is going to return the largest
47:06 - number in our array so let's copy this
47:08 - function
47:09 - i'm going to copy it and then just
47:11 - modify it a little bit
47:13 - so the name of that other function is
47:16 - going to be
47:16 - get max like this and then
47:19 - that function as well will receive
47:22 - numbers array
47:23 - and the size but here we are going to
47:26 - have
47:26 - variable which is called max instead of
47:30 - min and again we will assign it
47:33 - the value of our first element so then
47:36 - we iterate through all of these elements
47:39 - so
47:39 - starting with the second element because
47:42 - first the value of the first one we
47:43 - already have inside this variable so we
47:45 - do not need to check that
47:47 - but if we find in these remaining
47:50 - elements if we find
47:52 - element that is larger
47:56 - so bigger than our max let's copy this
47:59 - here
48:00 - we are going to store the value of that
48:03 - element in our max variable
48:06 - like this and then at the end we
48:09 - will return our max variable
48:13 - okay so now in order to test this
48:16 - function
48:16 - i will invoke it as we did with this
48:19 - previous one i'm i will just say
48:21 - max is and then invoke get
48:25 - max like this and i'm going to add
48:29 - two end lines here
48:32 - so that we have output which is
48:34 - formatted nicely
48:35 - and if i run my program now as you can
48:38 - see
48:39 - it says min is minus 2 and then max is
48:42 - 29 which is correct
48:46 - so let's explain one more time the
48:47 - algorithm that we are using
48:49 - here in order to determine the biggest
48:51 - number of our array
48:53 - so here in this first line i say
48:56 - that the biggest number is the one with
48:58 - the index zero so the first one
49:01 - and then here we iterate through all of
49:04 - the remaining
49:04 - elements and that is from the one with
49:08 - index
49:08 - one until the last one and if we find
49:12 - that
49:12 - any of those remaining numbers is
49:15 - greater
49:16 - than our max number then we say that our
49:19 - max number
49:20 - is equal to that number so at the end of
49:23 - this for loop
49:24 - we will have in our max variable
49:27 - the largest number of this array here
49:31 - okay and we have accomplished to get our
49:34 - min number and then our max number
49:36 - using these two functions
49:40 - oh i'm sorry so using this get min and
49:43 - then
49:44 - get max function as well so now what i
49:47 - want to show you
49:48 - is how you can use one function only to
49:51 - get
49:52 - both min and max number
49:55 - so let's do that let's create a function
49:57 - which we will name
49:59 - void get min
50:02 - and max like this
50:05 - and this function is going to receive
50:08 - like these two previous functions
50:10 - our numbers array and the size
50:14 - of the array and then considering that
50:16 - we want to return two values from our
50:19 - function
50:20 - we will have to pass those two values by
50:23 - a reference which means
50:24 - we will have to pass the addresses of
50:27 - the two values and then
50:28 - this function here is going to change
50:30 - the value that is stored on those two
50:33 - addresses
50:34 - and this function here our main function
50:37 - is going to have the access to those two
50:39 - addresses as well
50:41 - so once this function here assigns the
50:44 - value of min
50:45 - and max numbers to those two addresses
50:48 - our main function is going to be able to
50:50 - access
50:51 - those values so as i said let's pass to
50:55 - this function as well
50:56 - int min like this
51:00 - and then int max so
51:03 - we are receiving here pointer to a min
51:06 - number and then
51:07 - pointer to a max number
51:10 - okay so the job of this function will be
51:13 - very similar to the jobs
51:15 - of the two functions that we just
51:17 - created so
51:18 - i will just copy this and then paste it
51:21 - here
51:22 - and once more we are iterating through
51:25 - all of the numbers of our numbers
51:27 - array and then here we say if you find
51:31 - any number which is greater than our max
51:34 - number
51:35 - and here we have an error which says
51:37 - operand types are incompatible so
51:40 - int and int pointer which means that
51:42 - here we have to dereference this pointer
51:45 - using the star symbol
51:47 - so if you find any number which is
51:50 - greater than our current max please
51:53 - store that number inside our max
51:57 - like this and then i'm going to copy
51:59 - this code
52:00 - one more time for our min number so i
52:03 - will say
52:04 - if you find any number which is smaller
52:07 - than our min number like this
52:11 - please assign that number to
52:14 - my min number like this
52:17 - so this is going to be the work that
52:19 - this function
52:20 - will do and considering that this
52:24 - function is receiving
52:25 - these two so min and max as pointers
52:28 - this means that this function is
52:30 - directly going to modify the values
52:33 - that are stored on these addresses
52:36 - and those same addresses are going to be
52:39 - available in our main function
52:41 - which means that once this function
52:43 - changes the values that are stored
52:45 - on our max and our min address this main
52:49 - function here
52:50 - will be able to access those changed
52:52 - values
52:53 - and using pointers in that way
52:56 - we have achieved to return multiple
52:59 - values
53:00 - from our function so let's invoke
53:03 - this get min and max in order to test
53:06 - what i just
53:07 - said so i'm going to comment these two
53:10 - lines of code because we do not need
53:12 - them anymore
53:13 - and because here we have to pass min
53:17 - and max we will have to create those two
53:19 - variables here as well so i will say
53:22 - int min and as we did before
53:25 - i'm going to assign to this min the
53:28 - value
53:28 - of my first element like this
53:32 - okay and then i will create max
53:36 - variable as well and assign to my max
53:38 - variable
53:39 - value of my first element as well and
53:42 - now let's invoke this get min and max
53:46 - function
53:47 - so let's say get min and max
53:50 - and let's pass it parameters that it
53:53 - needs so the first one is numbers array
53:56 - so i will say numbers and then second
53:59 - parameter is
54:00 - size of that array so five
54:03 - and then it expects to receive two
54:06 - pointers so min and max and we will have
54:09 - to pass
54:11 - addresses of our main and then address
54:14 - of our max as well like this
54:18 - and this here is called passing
54:21 - a parameter using a reference so that
54:24 - means
54:25 - pass an address of a variable
54:28 - to your function rather than passing
54:30 - variable itself
54:32 - because then if you don't pass an
54:34 - address your function is going to create
54:36 - a copy
54:37 - and whatever changes your function makes
54:39 - with that copy
54:40 - you will not be able to see those
54:42 - changes in your main
54:44 - function so in this way we are passing
54:47 - addresses which means that this function
54:49 - here
54:50 - is operating on the original addresses
54:53 - which this function here is accessing as
54:56 - well so
54:57 - when this function here changes the
54:59 - values that are stored on those
55:01 - addresses
55:02 - this function here will know so that
55:05 - means
55:05 - that now if i try to write out oh i will
55:08 - need to
55:09 - add semi-column here at the end okay
55:12 - so that means now if we try to write out
55:16 - our min like this min
55:19 - is and then min
55:24 - and then if we try to write out our max
55:27 - as well max
55:31 - we will get values of
55:34 - -2 and 29 at least we expect
55:37 - to get those two values if this function
55:39 - is working
55:40 - correctly so if i run my program
55:44 - as you can see we really have values of
55:48 - minus two
55:49 - let me just um collapse this
55:52 - so we really have values of -2 and
55:55 - 29 as the smallest and the largest
55:58 - number in our array and we have achieved
56:01 - that
56:02 - using this pass by a reference so by
56:05 - passing
56:06 - addresses of our variables to our
56:08 - function
56:09 - which our function then changes the
56:11 - values that are stored on those
56:13 - addresses
56:14 - and since this main function as well has
56:16 - the access to those same addresses
56:18 - that means that our main function can
56:20 - see the changes that have been made
56:22 - on those addresses so i hope that now
56:26 - you have an
56:26 - idea how to return multiple values from
56:29 - a function
56:30 - using pointers so if you enjoyed this
56:32 - video if you learned something new give
56:34 - it a thumbs up and also subscribe to my
56:36 - channel
56:37 - press the bell icon as well thank you
56:39 - for watching and
56:40 - i'm going to see you in my next video
56:42 - bye
56:52 - in this video i want to talk about
56:54 - dynamic arrays
56:56 - so you should already be familiar with
56:58 - the idea of
56:59 - arrays and the concept of fixed arrays
57:01 - from my previous videos
57:03 - but for those of you that really want to
57:05 - understand the need for dynamic arrays
57:07 - i will go through some of the advantages
57:10 - and disadvantages of fixed arrays
57:12 - so that you can really understand where
57:14 - the need
57:15 - for dynamic arrays arised
57:18 - so we said that an array is type of
57:21 - collection which stores elements in
57:23 - continuous
57:24 - memory now that means that it stores
57:27 - elements
57:28 - one after the other so if i do this for
57:31 - example if i say
57:32 - let's create an integer array of
57:35 - five elements and let's call that array
57:39 - my array like this your computer in the
57:43 - background will do the following
57:44 - it will give to this array here five
57:48 - containers of type int and those
57:50 - containers will be one
57:52 - after the other in memory so that means
57:55 - because the array stores data in a
57:58 - continuous memory so one after the other
58:00 - accessing that data will be very very
58:03 - fast
58:04 - so because the name of the array is the
58:06 - address of the first element
58:08 - of that array when you specify the name
58:10 - of the array
58:11 - and then you give it the index of the
58:14 - element that you want to access
58:16 - it is going to be very fast to move from
58:18 - that first
58:19 - element until that position they choose
58:21 - specified so until the element that has
58:23 - a debt
58:24 - index whereas if you use some other
58:26 - collection type like
58:28 - linked list for example which stores
58:30 - data
58:31 - in non-continuous memory which means in
58:34 - a random
58:35 - places and memory and then each element
58:37 - contains a pointer to the previous one
58:39 - and to the next one accessing elements
58:42 - in those type of collections
58:43 - would be much slower so if you wanted to
58:46 - access fifth element of
58:47 - linked list you would have to traverse
58:50 - the first four
58:51 - elements and then get to the fifth one
58:54 - because they are stored
58:55 - in non-continuous memory meaning they
58:57 - are randomly
58:58 - in your memory so as i already said
59:01 - accessing elements of an array is
59:04 - a very very fast operation but
59:07 - because your array stores data in
59:09 - continuous memory this has
59:10 - certain disadvantages as well so what
59:13 - happens if you want to
59:15 - insert or delete an element in the
59:17 - middle of the array for example
59:19 - so how can you insert or delete an
59:21 - element in the middle of the array
59:23 - without breaking that continuousness if
59:26 - i can say it like that so you get a
59:28 - point
59:29 - that means that the operation of
59:31 - inserting and deleting elements in an
59:33 - array
59:34 - is going to be much slower than
59:35 - inserting elements in a linked list for
59:38 - example
59:38 - and if you want me to do a video which
59:40 - is related to differences between linked
59:42 - lists
59:42 - and arrays for example write it in the
59:44 - comments down below and
59:46 - i will make it in the future when i find
59:48 - time so
59:49 - again if you are not familiar with the
59:51 - basics of arrays i recommend you to
59:53 - watch my first video
59:54 - which is related to arrays and pointers
59:57 - which i will link here and then you come
59:59 - back to this one
60:00 - so those were some advantages and
60:02 - disadvantages of
60:03 - arrays and it will be up to you to
60:05 - decide which collection you want to use
60:08 - however here i want to give you the
60:10 - biggest disadvantage or the biggest
60:12 - obstacle that we encountered so far when
60:15 - working with arrays
60:16 - and that is the following so the size of
60:20 - the array
60:21 - had to be constant which means that the
60:23 - size of the array had to be known before
60:25 - we even started our program so
60:28 - we always kind of wanted to do this so
60:31 - we wanted to say
60:32 - int size and then we wanted to ask our
60:36 - user
60:36 - to enter the size so please enter the
60:39 - size for the array
60:41 - and then after our user enters the size
60:44 - for the array
60:46 - we wanted to create the array that is
60:49 - of that size that our user specified
60:52 - however
60:53 - we get the error as you can see here it
60:55 - says expression
60:56 - must have a constant value which
60:59 - confirms what i just said which is
61:01 - that the size of the array had to be
61:04 - known at
61:04 - compile time so the size of the array
61:07 - could not be
61:08 - changed once we declared and we had to
61:10 - declare it before we even started
61:12 - our program so this problem was without
61:15 - solution so far
61:16 - but surprise surprise if you know how to
61:19 - work with dynamic arrays
61:21 - and dynamic memory you can very easily
61:24 - create an array and
61:25 - runtime so in c plus plus there are two
61:28 - keywords or two
61:30 - commands which allow you to allocate and
61:32 - deallocate
61:33 - dynamic memory which means to get
61:36 - yourself dynamic memory when you need it
61:38 - and then free that memory once you don't
61:41 - so that it can be
61:42 - reused that is what allocate and
61:44 - deallocate
61:45 - means and those two commands are new
61:49 - and delete so new allocates memory as
61:52 - you may guess
61:53 - and then delete deallocates that memory
61:56 - or
61:57 - freeze it once you don't need it so
61:59 - let's see how we can use this
62:01 - information that i just gave you on
62:03 - our example so instead of doing this
62:06 - here i will comment it because we do not
62:08 - need it
62:09 - instead of doing this what i will do is
62:11 - i will create
62:13 - a pointer like this and let's call that
62:16 - pointer my
62:17 - array and what i want to assign to this
62:20 - pointer will be the following i will say
62:23 - please make this pointer point to
62:26 - new integer array
62:29 - and the size of that array will be the
62:32 - size that our user
62:33 - entered like this okay
62:36 - and as you can see our compiler is
62:39 - fine with this expression here we do not
62:42 - have
62:42 - an error so this new keyword
62:46 - has allocated an array of this size that
62:50 - our user
62:51 - has specified and that array
62:54 - the address of the first element of that
62:56 - array is stored
62:57 - in this my array pointer so
63:00 - if i build this code
63:04 - as you can see we do not have compile
63:06 - time errors
63:08 - so what i want to show you now is how we
63:10 - can enter
63:11 - elements for this array and then how we
63:13 - can write them out
63:14 - and this is array again this is array
63:18 - which is
63:19 - created at runtime so our user will
63:21 - specify the size of this
63:23 - array which is something that we were
63:25 - not able to do
63:27 - before we learned how to use dynamic
63:30 - arrays
63:30 - so in order to enter elements for this
63:34 - array here
63:35 - as we already know we will be using for
63:38 - loop so i will say four
63:40 - please iterate from the element which
63:43 - has
63:44 - index zero until you come to the element
63:48 - that has the index of this size
63:51 - okay and then in each iteration increase
63:54 - our counter by one and what i want to do
63:58 - is i want to write out a message for my
64:00 - user so i will say
64:02 - array and then let's add
64:05 - index of the current element index that
64:08 - our user is entering
64:10 - so i like this
64:13 - okay and then what i want to do is i
64:16 - just want to
64:17 - enter an element
64:21 - on that position that we are currently
64:24 - iterating
64:25 - so i will say my array of
64:28 - i like this so using this code here we
64:32 - should be able to enter
64:34 - elements in this array here and then in
64:37 - order to write these elements out
64:39 - what i will do is i will use another for
64:42 - loop so i will just copy this one
64:44 - and then paste it here and in this
64:46 - particular situation i just want to
64:48 - write
64:49 - out so i will use c out command
64:53 - and then these other redirection signs
64:55 - so i just want to write
64:57 - out all the elements of the array and i
64:59 - will add
65:01 - a few empty spaces after each element so
65:03 - that
65:04 - we have a nicely formatted output
65:07 - so this loop here should write out the
65:09 - elements of
65:10 - our array and if i start this program
65:13 - now
65:14 - as you can see it asks us to enter the
65:16 - size of the array so let's say
65:19 - 5 for example and now we are
65:22 - we are entering element with index 0 so
65:24 - let's say 2
65:26 - 5 7 9 and let's say 11
65:30 - okay and as you can see here we have the
65:33 - elements
65:34 - of our array written out and
65:37 - we wouldn't be able to do this if we
65:40 - didn't know how to work with dynamic
65:43 - arrays so let's stop this program
65:46 - and there is one more thing that i want
65:48 - to mention and that is following
65:50 - these square brackets here are only one
65:53 - way to dereference your array
65:55 - another way to dereference the array or
65:57 - to to access the element on a specific
66:00 - position
66:01 - is the following so so the other way
66:05 - to access the element on a specific
66:07 - position would be
66:08 - using this asterisk symbol and then here
66:12 - you say my array plus i
66:15 - now because the name of the array is the
66:18 - address of the first element here you
66:20 - have the address of the first element
66:22 - and then when you add a certain number
66:24 - to that
66:25 - it will move that many spaces in memory
66:28 - and then
66:28 - access the element on that position and
66:32 - when you dereference that you will get
66:34 - the value of that
66:35 - element instead of its address so
66:38 - here is one way to dereference your
66:40 - array and then
66:41 - here is another way to dereference your
66:44 - array and you can use whichever one you
66:46 - prefer
66:47 - and if i run this program again just to
66:49 - demonstrate that it works the same
66:51 - let's say three and then one five ten
66:55 - okay we get one five ten as the elements
66:58 - of
66:59 - our array one very important thing that
67:02 - i mentioned at the beginning
67:03 - is that we have two commands for working
67:06 - with dynamic
67:07 - memory and one of those two commands is
67:10 - new so we said that new is a command
67:13 - which will
67:14 - allocate memory for us when we need it
67:17 - and then another one is going to be
67:19 - delete and
67:20 - delete is a command which will
67:22 - deallocate that
67:24 - memory when we do not need it so that it
67:26 - can be
67:27 - reused now using dynamic memory
67:30 - comes with a responsibility and that
67:32 - responsibility is the following
67:35 - each time that you allocate memory when
67:37 - you need it
67:38 - you will have to deallocate that memory
67:40 - once you don't
67:42 - so that that memory can be reused so
67:45 - that means that each time that you write
67:47 - new command
67:48 - you will have to write the lead command
67:51 - once you don't need
67:52 - that memory anymore so i will
67:54 - demonstrate how can you deallocate the
67:57 - memory that we have
67:58 - allocated for this my array so let's say
68:02 - that here
68:03 - in this line of code we do not need our
68:06 - array anymore so
68:07 - how can i deallocate the memory that i
68:10 - allocated for this array
68:12 - while using delete keyword
68:15 - and i will say please delete the memory
68:18 - that i
68:18 - allocated for my array which is called
68:22 - my array like this and
68:25 - you have to specify these square
68:27 - brackets because that is the way that
68:28 - you allocated memory so here
68:30 - you said i want new array and then here
68:34 - you have to say please
68:36 - delete that array and a good practice is
68:39 - to do the following as well so you can
68:41 - say
68:42 - my array is equal to null
68:46 - like this and let me collapse this
68:49 - so this here is going to assign the
68:51 - value of null to your array so your
68:53 - array will not point
68:55 - to anything to any address at this line
68:57 - of code
68:58 - so why do we do this because in the
69:01 - previous line of code we have
69:03 - deallocated
69:04 - this array here and now in this line of
69:07 - code here your array will point
69:09 - to a location in memory which does not
69:11 - belong to you
69:13 - so it does not belong to your program
69:15 - and because of that because we do not
69:17 - want
69:17 - to cause some accidental crashes or
69:20 - problems in our program
69:21 - by having this array pointing to memory
69:24 - locations which are not ours
69:25 - anymore it is a good practice to say
69:28 - that
69:29 - our array is now equal to null which
69:31 - means that it is not pointing
69:33 - to anything so as i already said and i
69:37 - repeat
69:37 - again when you use dynamic memory each
69:40 - time that you write
69:41 - new you will have to write delete that
69:44 - corresponds to that
69:45 - new so here i have allocated an array
69:48 - and here i am
69:49 - deallocating that array so i hope that
69:53 - this video was helpful
69:54 - and that this video helped you
69:56 - understand what are dynamic arrays and
69:58 - how they work
69:59 - and now that i have explained this it
70:02 - opened the whole world of new
70:04 - possibilities
70:04 - and new things that you can do with
70:06 - dynamic arrays
70:08 - and i will leave to you to play and
70:11 - discover those new things
70:12 - until my next video of course so thank
70:15 - you for watching this video
70:17 - give it a thumbs up if you liked it
70:19 - subscribe to my channel
70:20 - click the bell icon as well and i'm
70:22 - going to see you in my next video
70:24 - bye in this video i want to talk about a
70:27 - topic that
70:28 - confuses many students and that is the
70:31 - topic of
70:32 - multi-dimensional dynamic arrays and the
70:35 - topics like this
70:36 - one are the reason why many people step
70:39 - away from learning c plus and they
70:42 - believe that learning c plus plus is
70:44 - hard
70:44 - but what i think is that many of those
70:46 - people never actually had the
70:48 - opportunity to have
70:49 - this explained in a very simple way so
70:53 - that is what i will try to do in this
70:55 - video so with the help of
70:57 - excel i will try to draw what are
70:59 - multi-dimensional dynamic arrays and how
71:02 - they work
71:03 - and i hope that at the end of this video
71:05 - you will have it pretty clear and you
71:06 - will be able to create
71:08 - and work with your own multi-dimensional
71:10 - dynamic arrays
71:12 - so what a multi-dimensional array is in
71:14 - simple words
71:15 - it is array of arrays and in this video
71:19 - you will learn how to create
71:20 - two-dimensional dynamic arrays and in
71:23 - order to be able to understand
71:25 - this topic you should be familiar with
71:27 - the topic of
71:28 - dynamic arrays which is a video that i
71:31 - already did on my channel
71:32 - and i will link it here so make sure to
71:35 - watch that video before
71:36 - watching this one so i will very quickly
71:39 - remind us
71:40 - all of how dynamic arrays work and then
71:43 - we will see how we can use that
71:45 - knowledge to understand
71:46 - multi-dimensional dynamic arrays so
71:49 - let's create a visual representation
71:51 - of a dynamic array in our excel sheet
71:55 - so let's say that it will be array of
71:57 - four elements
71:58 - like this this is our array and the
72:01 - indexes of these elements
72:03 - start with zero and then one two three
72:06 - so these are the indexes and then the
72:09 - address of this
72:10 - first element will be for example 0
72:13 - 0 0 0 a a like this
72:17 - and this address here it is the address
72:20 - of the first element but it is the
72:22 - address of the array itself as well and
72:24 - you should be familiar with that
72:26 - so this here is our dynamic memory
72:30 - and then on our stack which will be here
72:32 - let's
72:33 - create our stack so this here will be
72:36 - our static memory
72:37 - here we will have to create a pointer
72:40 - variable which will hold
72:41 - the address to this element here
72:44 - or actually the address to the array
72:46 - itself
72:47 - so i will create a variable let's call
72:49 - it ptr1
72:51 - so this is going going to be our pointer
72:53 - one and as we already said
72:55 - that pointer will hold the address of
72:58 - the first element of this
73:00 - array let's copy that address
73:03 - like this and then we will store that
73:06 - address in our ptr
73:07 - one now if we wanted to create more
73:10 - arrays
73:11 - by the knowledge that we have so far we
73:13 - would have to copy this
73:15 - and then let's paste it here and let's
73:17 - create one more array
73:18 - like this so now we have three dynamic
73:21 - arrays
73:22 - and the first element of the first array
73:25 - has the address of 0 0
73:26 - 0 0 a a and then this one here
73:30 - let's say that it has the address of bb
73:32 - for example
73:33 - and then this one here has the address
73:35 - of 0 0
73:36 - 0 0 cc and to be able to access
73:40 - these arrays we would have to create on
73:43 - our stack
73:44 - two more pointers so let's do that
73:48 - okay so our pointer two will hold
73:51 - the address of the second array which is
73:54 - zero zero zero zero db and then our
73:57 - pointer three
73:58 - would hold the address of our third
74:00 - array which is
74:01 - 0 0 0 0 cc like this
74:06 - now with this we have created three
74:09 - dynamic
74:09 - arrays and in order to create those
74:12 - three dynamic arrays
74:13 - we had to create three pointers so
74:16 - those are these three here and this is
74:19 - something that you should already be
74:21 - familiar with so you should already know
74:23 - from my previous video how to create a
74:26 - dynamic array
74:27 - now one thing that i see here and that
74:30 - is a problem
74:31 - is that if we wanted to create four or
74:33 - five or a hundred
74:34 - of these dynamic arrays we would have to
74:37 - create
74:37 - that number of pointers on our stack
74:40 - which means that this part here is not
74:43 - dynamic only this part here is dynamic
74:46 - because here our user determines
74:48 - how many elements this dynamic array
74:51 - will have
74:52 - but for each of these dynamic arrays we
74:55 - have to manually create
74:57 - a pointer on our stack which will hold
74:59 - the address of that
75:00 - array okay now what happens if i want to
75:04 - move
75:05 - this part here to our dynamic memory as
75:07 - well so let's do that
75:09 - let me cut it from here and then i will
75:12 - paste it here
75:13 - for example so now i have moved
75:17 - this part to dynamic memory as well and
75:20 - as you can see here
75:22 - this kind of looks like an array as well
75:25 - so that means that this first element if
75:27 - we look at this as an array the first
75:30 - element will have index of
75:32 - zero and then second we'll have index of
75:35 - one
75:35 - and then third will have oh this won't
75:38 - move
75:39 - third we'll have index of two okay
75:43 - so this is an array that has three
75:46 - elements and the first element
75:49 - for example has the address of 0 0
75:53 - e e e e like this
75:56 - so now this part here is dynamic and
75:59 - then this part here
76:00 - is dynamic and in order to be able to
76:03 - access
76:03 - this array here what we have to do is on
76:06 - our stack
76:07 - which is this part here we will have to
76:11 - create
76:11 - a pointer which will hold the address of
76:14 - this
76:15 - first element so let's do that let me
76:18 - just
76:19 - okay now as i already said on our stack
76:23 - we will have to create a pointer which
76:25 - will hold the address of this
76:27 - first element so let's call that pointer
76:31 - table for example and this table
76:34 - will hold the address of this element
76:37 - here
76:37 - which is 0 0 ee
76:42 - and this table because it holds the
76:45 - address
76:46 - it should be a pointer but one thing to
76:49 - keep in mind
76:50 - is that this variable here is not a
76:53 - simple variable but this here is a
76:55 - pointer as well
76:56 - which means that this table will not be
76:58 - a simple pointer but it will be a
77:00 - pointer to a pointer
77:02 - and you indicate that using two
77:05 - asterisk symbols because one is just a
77:08 - pointer and then
77:09 - two mean a pointer to a pointer why
77:12 - because
77:12 - this table holds the address of the
77:15 - element which is this one
77:17 - here and that element is pointer as well
77:21 - okay now if we look at this
77:24 - here as you can see we have one array
77:28 - that represents the number of rows that
77:31 - our table
77:32 - will have okay so one two
77:35 - three and then for each one of the
77:37 - elements of this array here
77:39 - we create a separate dynamic array
77:42 - like this so this here will be our table
77:46 - that has the number of rows that our
77:48 - user defines
77:49 - and then however many columns our user
77:51 - defines as well and in this particular
77:53 - situation
77:54 - it is a table that has three rows
77:58 - so these are three rows and then four
78:01 - columns so let's now translate this to
78:04 - our c plus plus code
78:05 - and because we said that now our user
78:08 - defines how many
78:09 - rows this table will have and then how
78:11 - many columns as well
78:13 - that is the first thing that i will do
78:15 - so i will create two variables
78:17 - let's call them inch rows and
78:20 - columns and then i will ask my user
78:24 - to enter how many rows and how many
78:28 - columns he wants
78:29 - this table to have so let's do that see
78:32 - in
78:34 - rows o and then
78:37 - columns like this okay
78:40 - now after our user has entered how many
78:43 - rows and columns he wants
78:45 - what i want to do now is this part here
78:48 - so this part here this is our first step
78:51 - and then
78:51 - this here is going to be our second step
78:53 - and this part here will be
78:55 - the third step so this part here
78:59 - will be the following when translated to
79:01 - c plus code
79:02 - so here as i already said i create a
79:05 - pointer to a pointer which i will call
79:08 - table so i will say please create an
79:11 - integer pointer to a pointer because
79:14 - here we will store
79:15 - integer values you can create a
79:17 - character or double or float whichever
79:20 - one you want i want to create
79:21 - integer pointer to a pointer and call
79:24 - that
79:24 - table like this okay so we
79:28 - are done with this first part here
79:31 - and then what this table pointer to a
79:33 - pointer will point to
79:35 - is going to be this array here so i will
79:37 - say please create a new
79:39 - integer array that has
79:43 - this many elements so the number that
79:45 - our user
79:46 - has entered for this rows variable
79:49 - because this rows variable holds how
79:52 - many elements
79:53 - this array here will have but as you can
79:56 - see here we have an
79:57 - error and that error is happening
79:59 - because this here
80:00 - which is this array here is not just a
80:03 - simple
80:04 - integer array but it is array of
80:08 - pointers so here you will have to
80:10 - indicate that so you will have to say
80:11 - please
80:12 - create an integer array of
80:15 - pointers and as you can see now our
80:17 - error has
80:18 - disappeared and with this line of code
80:21 - here we have created
80:22 - this array here now our third step
80:26 - is going to be that for each element of
80:29 - this
80:29 - array here we would have to create a
80:32 - separate
80:33 - dynamic array so this first element
80:36 - will hold the address of this dynamic
80:39 - array and then the second element
80:41 - holds the address of this array and then
80:43 - disturbed the address of this array here
80:46 - so what i will have to do is i will have
80:48 - to iterate
80:49 - through all the elements of this array
80:52 - and for each one i will have to create a
80:54 - separate
80:55 - dynamic array so let's do that so i will
80:58 - say
80:59 - 4 and i is equal to 0
81:02 - and then i is less than the number of
81:04 - rows that our user
81:06 - entered and in each iteration increment
81:09 - i
81:10 - so in this particular situation our
81:12 - number of rows is equal to three but you
81:15 - can have as many as you want
81:17 - so what i want to do in each of these
81:19 - iterations
81:20 - is i want to create for each one of
81:23 - these
81:23 - elements a separate dynamic array so i
81:26 - will say
81:27 - table of i is equal to
81:31 - new integer array
81:34 - that has this many elements and that is
81:37 - the number that we stored in our columns
81:40 - variable like this and with this code
81:43 - here we have successfully created
81:45 - these dynamic arrays now
81:49 - how do you access elements on a specific
81:51 - position
81:52 - of this table here for example this one
81:55 - or this one or this one
81:57 - so in order to do that let's say for
82:00 - example
82:00 - table of row one and then
82:04 - column two will have the value of 88.
82:08 - now what this code here what this line
82:11 - here will do
82:12 - is the following so this part here it
82:14 - says please
82:15 - give me the table variable which is this
82:18 - one here
82:19 - and it is a pointer to a pointer which
82:22 - holds
82:22 - this address here so 0 0 e e e
82:26 - and that address is the address of this
82:28 - element
82:29 - here so the address of this array and
82:32 - here we say please give me the element
82:34 - of that array that has
82:36 - index 1 which is this element here so
82:39 - it is the element that stores the
82:42 - address of 0 0
82:43 - 0 0 bb which is the address of
82:46 - this array here and this
82:49 - second part says please give me the
82:52 - element of that array that has the index
82:54 - of 2
82:55 - which is this element here so
82:58 - here we will store the value of
83:02 - 88 so that is what this line of code
83:05 - here will do
83:06 - it will store number 88 to this
83:09 - position here so this line of code here
83:12 - will store this number at the element
83:15 - that has
83:16 - row index 1 and column index 2
83:19 - of this table so this here is a row with
83:22 - index 0
83:23 - this here 0 with index 1 and then 2 so
83:26 - we are storing at this row
83:28 - and then column index 2 is this one here
83:31 - so here we store number
83:33 - 88 one thing that we said as well in my
83:36 - previous video is that each time that
83:38 - you allocate
83:38 - dynamic memory you have the
83:40 - responsibility to deallocate that memory
83:43 - when you don't need it which means
83:45 - each time that you use new keyword you
83:48 - will have to use
83:49 - delete keyword when you don't need that
83:51 - memory anymore so now is the question
83:54 - how do we deallocate all of this memory
83:56 - that we have
83:57 - taken so in order to do that what i want
84:00 - to do
84:01 - is i want to show you something if for
84:04 - some reason
84:05 - we lose this address here so the value
84:07 - that is stored in this
84:09 - table pointer to a pointer we will never
84:12 - be able to access
84:13 - all of these elements that we have
84:15 - created in our dynamic memory
84:17 - so that means that we will not be
84:19 - deallocating
84:20 - this first and then if we for some
84:23 - reason
84:23 - lost this the value of our zero zero
84:26 - zero zero a
84:27 - a for example that means that we would
84:31 - never be able to access
84:32 - this array here so we would never be
84:34 - able to de-allocate this memory
84:36 - so that means that this is not going to
84:39 - be deallocated first as well
84:41 - now a location of this memory here went
84:44 - as follows
84:45 - this was the first step so this was the
84:47 - first thing that we allocated and
84:49 - it is this code here and then we
84:53 - allocated
84:54 - this so that corresponds to this part
84:58 - here and then the last thing to allocate
85:00 - was
85:01 - these arrays here and that corresponds
85:04 - to this part of the code
85:06 - and the allocation of this memory will
85:09 - go the other way around which means that
85:12 - first we will de-allocate
85:14 - this and then we will de-allocate this
85:17 - and then this will be the last thing
85:19 - that we will have to worry about
85:21 - now in order to deallocate this the
85:24 - process will be
85:25 - almost the same as the one when we
85:27 - allocated it so i will copy this for
85:29 - loop
85:31 - and then paste it here but what i want
85:34 - to do in this particular situation so
85:36 - when
85:36 - d allocating is instead of creating a
85:40 - new dynamic
85:40 - array for each table of i is i want to
85:44 - delete
85:44 - that array so for each element
85:48 - of this array here i want to delete the
85:50 - corresponding
85:51 - dynamic array so i want to delete
85:55 - these three arrays and in order to do
85:57 - that i will say please
85:59 - delete the array that my table
86:03 - of i is pointing to
86:06 - now what this code here will do is
86:09 - for this element here it will deallocate
86:13 - this array here so let's delete that
86:17 - and then for this element here it will
86:19 - deallocate
86:20 - this array and then for this one it will
86:24 - be allocate
86:24 - this array here so now we have
86:28 - successfully freed
86:30 - this memory that we have taken here now
86:33 - after we have done this after we have
86:36 - successfully deallocated
86:37 - our first step which was here this part
86:40 - here will be our second
86:42 - thing to deallocate so here i will say
86:45 - please delete the array that my table
86:49 - variable is pointing to so this line of
86:52 - code here
86:53 - will deallocate this part here so i will
86:57 - say please
86:58 - delete that we do not need it anymore
87:01 - okay
87:02 - and then our third step which is the
87:04 - last one will be
87:05 - to null this value here why because we
87:08 - have just freed the memory that was here
87:11 - so we have deallocated that now someone
87:13 - else might be using
87:14 - this memory here and we really shouldn't
87:18 - keep the address of someone else's
87:20 - memory so
87:21 - we should make this a null
87:24 - value like this and in order to do this
87:27 - in our code i will just say
87:29 - now my table will hold the value of
87:32 - null like this and this will prevent
87:36 - some potential crashes and problems in
87:38 - your application
87:39 - so i hope that this video helped you
87:41 - understand multi-dimensional dynamic
87:44 - arrays a bit better and if it did
87:46 - please give it a thumbs up and subscribe
87:48 - to my channel because
87:50 - that helps me to reach more people and
87:52 - hopefully make programming a little bit
87:54 - easier for them as well
87:56 - thank you very much for watching and i'm
87:58 - going to see you in my next video
88:00 - bye so i get a lot of messages a lot of
88:03 - questions on my instagram
88:05 - on twitter and then here on youtube as
88:07 - well in the comments
88:08 - where you ask me for an opinion or for
88:10 - advice
88:11 - on certain errors that happen to you in
88:13 - programming
88:14 - and i try to answer as many of those as
88:17 - possible
88:18 - but it's just not possible to answer to
88:20 - all of you and i'm very very sorry
88:23 - but i thought that it would be a good
88:25 - idea to make a video related to that
88:27 - so that all of you can see it so here i
88:29 - am i'm making that video right now
88:31 - so in this video i will be reviewing
88:33 - some code and we will see some errors
88:35 - that can happen and that do happen very
88:37 - often
88:38 - and i'm going to do that both manually
88:40 - and then i want to show you a very cool
88:42 - tool which is called
88:43 - pvs studio i'm going to leave details in
88:46 - the description down below so that you
88:47 - can check it out for yourself
88:49 - but what pvs studio is it is static code
88:53 - analyzer so it is basically a tool that
88:56 - reviews your code and helps you detect
88:58 - bugs and errors and security weaknesses
89:01 - in your code
89:02 - so in the case that you need another
89:03 - pair of eyes to look at your code and
89:05 - give you a few tips and recommendations
89:08 - it is a great tool to use and you can
89:10 - get it as
89:11 - a team license for teams up to nine
89:13 - people or you can get an enterprise
89:15 - license
89:16 - for bigger companies bigger departments
89:18 - or you can even request a free license
89:20 - if you are a student if you are working
89:22 - on some private projects or on some open
89:25 - source projects
89:26 - and then one very cool thing is that it
89:28 - is not only used to analyze c
89:30 - plus code but you can use it for c and
89:33 - then c
89:33 - sharp and java as well uh and i am
89:36 - wondering guys which team
89:38 - are you in are you team c plus plus or
89:40 - are you team c
89:41 - sharp or java or c um i'm very curious
89:44 - to read your answers so please
89:46 - write me in the comments down below and
89:48 - if you ask me i'm definitely team c
89:50 - plus plus and then team c sharp those
89:52 - are just
89:53 - two of my favorite languages ever but i
89:56 - am
89:57 - very curious to read what you will
89:59 - answer to this question
90:00 - so um i'm going to leave all the details
90:02 - about pvstudio
90:04 - in the description of this video so that
90:06 - you can check it out for yourself
90:08 - and let's jump into the coding part
90:10 - right now because i
90:11 - am very very excited to do this here i
90:14 - have created a new project
90:16 - and i have this program that does
90:18 - basically nothing
90:20 - so what i want to do is i want to check
90:22 - if everything is okay with this code so
90:24 - far
90:25 - so if we have made any errors so far so
90:28 - i'm going to click on extensions
90:30 - and then pvstudio and here you have
90:31 - multiple options you can check your
90:33 - current file
90:34 - you can check open files or you can
90:36 - check your
90:37 - project selected items solution i'm
90:40 - going to select this first option so i'm
90:41 - going to check this current
90:43 - file and you get this window here
90:46 - and as you can see we have one error and
90:49 - that error is that my license will
90:51 - expire in five days okay so that is not
90:53 - here which is related
90:54 - to our code so we are just going to
90:56 - ignore it so we don't have code errors
90:58 - so far
90:59 - and let me show you how you can install
91:01 - this tool very quickly so you click on
91:03 - extensions
91:05 - and then manage extensions okay
91:08 - and then here you can search for pvs
91:11 - studio like this okay great it
91:16 - is this one here so pbs studio is a tool
91:19 - for detecting bugs and security
91:20 - weaknesses and so on
91:22 - okay so you will click download here and
91:26 - your download should begin i'm not going
91:28 - to do that right now because i already
91:29 - have it
91:30 - but once it is downloaded the
91:32 - installation is pretty simple so it's
91:34 - basically
91:35 - next next next finish installation so
91:37 - that should be
91:38 - simple okay now let's close this window
91:41 - here
91:42 - and as you could see we don't have any
91:44 - errors with this code so far so let's
91:47 - write some code and let's create some
91:49 - errors now
91:50 - so let's create an array of type int and
91:53 - i will call it saved money
91:57 - and that will be array of five elements
92:00 - and i want to initialize those elements
92:02 - here so the purpose of this array is
92:04 - following
92:05 - let's say that i want to save some money
92:07 - each month and i want to store that data
92:09 - in this
92:10 - array here so i'm going to save money
92:12 - for five months and i will store how
92:14 - much money i have saved
92:15 - each month inside this array here so for
92:18 - example the first month i have saved
92:20 - 100 or euros or whatever
92:24 - and then second month i have saved 200
92:27 - and then
92:27 - 300 and 400 and 500
92:31 - fifth month okay so this is our array
92:34 - now what i want to do with this data
92:36 - here is i want to sum it
92:38 - after five months i want to know how
92:40 - much money i have
92:41 - saved in total so i'm going to create a
92:44 - variable
92:44 - of type int and i will call it total
92:48 - like this and i will initially give it a
92:51 - value of
92:51 - 0 and then i will iterate through this
92:54 - array here so i will say
92:56 - 4 and i is equal to 0
93:00 - and then i is less than or equal to 5
93:03 - and then i plus plus and what i will do
93:07 - inside this for loop is i will say
93:09 - that my total will hold whatever my
93:12 - total was previously holding
93:15 - plus current value of
93:18 - how much money i have saved in that
93:20 - month so save money
93:22 - off i okay now after i have done this
93:26 - i will just write out how much money i
93:28 - have in total so i will say
93:30 - total and then
93:34 - this value that is stored inside this
93:36 - variable here
93:37 - okay now if i run this program
93:41 - let's see what will happen well it says
93:44 - that in total i have minus 8
93:47 - billion something very very big number
93:49 - so i have tried to save each month and
93:51 - then at the end
93:53 - i have minus 8 billion dollars you know
93:56 - so that does not make any sense so here
93:58 - we have a logical
94:00 - error okay so let's see what is this
94:03 - error that is happening
94:04 - so let's click on extensions and pvs
94:07 - studio check current file
94:09 - to see what kind of error pvstudio sees
94:12 - and it says array over run as possible
94:15 - the value of i index could reach
94:18 - five and if i double click on that it
94:21 - will take me here
94:23 - and this part of code here is underlined
94:25 - and this is actually our compiler
94:27 - our compiler is underlying this and it
94:29 - says
94:30 - that okay it says index five is out of
94:33 - valid index range of zero to four
94:37 - so this here this situation here says
94:40 - that this i is out of range of valid
94:43 - indexes
94:44 - that this array here can have and if you
94:46 - are familiar with arrays you know that
94:48 - indexing of an array starts with zero
94:51 - so the first element has index of zero
94:54 - and then
94:54 - one two three and four so valid indexes
94:58 - for this array here are
95:00 - from 0 to 4 and here we have
95:03 - accidentally
95:04 - written that this i is less than or
95:06 - equal to
95:07 - 5 and that is making a problem so if i
95:10 - delete
95:11 - this part here so if i say that my i
95:14 - is just less than 5 this error should
95:17 - disappear so
95:18 - if i click on pvs studio and then check
95:21 - current file
95:24 - the error should disappear okay it has
95:26 - disappeared now so if i run my program
95:31 - this program is behaving as expected so
95:34 - this is one thing that very often
95:37 - happens you can accidentally write
95:39 - less than or equal to and then you can
95:41 - get a very very big
95:43 - logical error another thing that can
95:45 - happen is
95:46 - if you are typing very quickly and if
95:48 - you lose concentration for a moment
95:50 - and here instead of incrementing you
95:52 - decrement this counter so you say i
95:55 - minus minus you should get an error as
95:58 - well so
95:59 - if i try to build this program let's see
96:01 - what our compiler
96:03 - will tell us so here in this error list
96:06 - it says
96:06 - ill defined for loop counts down from
96:09 - minimum so
96:10 - that's kind of helpful information
96:13 - and then another let's read this other
96:15 - warning it says
96:16 - reading invalid data from saved memory
96:18 - the readable size
96:20 - is 20 bytes but minus 4 bytes maybe a
96:22 - read so
96:23 - this is not really helpful for someone
96:25 - who is just starting and then
96:27 - this third message it says index minus 2
96:30 - billion something is out of valid index
96:32 - range 0 to 4.
96:34 - again this is not really helpful for
96:36 - someone who is just starting so
96:39 - let's see what our pvs studio has to say
96:41 - so i'm going to click extensions pbs
96:43 - studio check current file
96:46 - okay and this first
96:50 - error here says the condition i
96:53 - less than 5 of for loop is always
96:56 - true so this is actually a helpful
96:58 - message and
96:59 - if i click on this i will be taken here
97:02 - and it says that this condition here i
97:05 - is less than five
97:06 - is always true but why is it always true
97:09 - because
97:09 - we have started counting at zero and
97:12 - then we
97:13 - try to decrement that value in each
97:15 - iteration and
97:17 - uh doing that we can never reach this
97:19 - condition here
97:20 - this condition here will never become
97:22 - false so that means that here we have
97:24 - created
97:25 - an infinite loop and here our previous
97:28 - studio says consider inspecting
97:30 - this for operators so consider
97:32 - inspecting this for loop here because
97:34 - it will not be executed at all or it can
97:37 - be executed incorrectly and in this
97:39 - particular situation
97:41 - it is going to be executed incorrectly
97:43 - so it is going to
97:44 - be an infinite loop which we don't want
97:47 - in this particular situation
97:48 - so i'm going to correct this error here
97:51 - so i'm going to return it to i
97:53 - plus plus but that is sort of a help
97:55 - that you can get from
97:56 - pvs studio and this here is a pretty
97:59 - simple program
98:00 - because it has just a few lines of code
98:02 - where all the bugs can potentially
98:04 - happen but
98:05 - imagine working on a very very big
98:07 - project
98:08 - and then something like this happens so
98:10 - imagine something like this happening
98:13 - on a program that a bank uses so you are
98:15 - trying to save money for a couple of
98:16 - months and then the program says that
98:18 - you are in debt
98:19 - that your balance is minus 2 000 or 20
98:23 - 000
98:24 - or something like this so this can
98:26 - create very very big issues and in this
98:28 - particular situation if
98:30 - you have a bug like this you will want
98:32 - to have
98:33 - all the help that you can get and
98:35 - sometimes that
98:37 - can be just the help that you get from
98:39 - your compiler or if you have a very very
98:41 - big problem
98:42 - you will definitely benefit from tools
98:44 - like pvs studio which will give you some
98:46 - additional information
98:47 - on that situation that is happening and
98:49 - on that problem that you are having
98:51 - and then there are other situations
98:52 - where you can have very very big
98:54 - problems
98:55 - but your compiler will not be helpful at
98:58 - all because your compiler will not be
98:59 - able
99:00 - to see those potential bugs that you are
99:02 - creating inside your code
99:04 - so in order to demonstrate that let's
99:06 - delete all of this code here
99:08 - because i will not need it anymore and
99:11 - what i do need
99:12 - is to create a function here so let's
99:15 - create a function of return type
99:17 - void and i'm going to call it my
99:20 - function like this
99:24 - okay and what i want to do inside this
99:27 - function is i want to create
99:28 - an integer pointer ptr
99:32 - so if you are not familiar with the
99:33 - topic of pointers make sure to watch
99:35 - the playlist that i will link here it is
99:37 - a playlist where i explain
99:39 - pointers in c plus because it is one of
99:41 - the most important topics in c
99:42 - plus plus and it is the example that i
99:45 - will be using here
99:46 - so i have created an integer pointer
99:50 - and i'm going to say now you will point
99:53 - to
99:53 - a new array of integers and that array
99:57 - will have
99:58 - five elements like this now what do i
100:01 - want to do
100:02 - with this array well let's do something
100:04 - very simple let's say
100:06 - ptr of 2 will hold the value
100:10 - okay it will hold the value of 10 like
100:13 - this and then let's just write out
100:15 - something let's say
100:16 - hi i am
100:20 - equal to and then ptr of two
100:24 - okay so this here is pretty simple
100:27 - example that does basically nothing
100:29 - important nothing useful but i will use
100:31 - it to demonstrate a very very big
100:33 - issue that can happen in this situation
100:36 - so
100:37 - i'm going to invoke this function here
100:39 - so i'm going to say
100:40 - my function like this and
100:44 - i have successfully invoked this
100:46 - function so if i run this program
100:52 - it says hi i am 10. so
100:55 - nothing unexpected happened or did it
101:00 - okay if i inspect my errors list
101:04 - it says that i don't have any errors so
101:07 - if you ask a compiler it will tell you
101:09 - that
101:09 - everything is perfectly fine so let's
101:12 - now ask pbs studio here it has already
101:14 - detected two potential issues
101:16 - but you can click pdf studio and then
101:19 - check current file just to be sure
101:22 - okay and it says
101:25 - visibility scope of the ptr pointer was
101:28 - exited without
101:29 - releasing the memory a memory leak is
101:33 - possible so what we have done here in
101:35 - this program is we have created
101:37 - memory leak where
101:41 - here so here we have said please
101:44 - give me in my dynamic memory give me
101:47 - array of five
101:49 - integers and this is going to be done in
101:52 - dynamic
101:53 - memory so once this function is finished
101:56 - once this function ends
101:57 - we are going to lose this ptr so we are
102:00 - going to lose
102:01 - the address of the first element of this
102:04 - array here so
102:05 - here if i try to do something like ptr
102:08 - i cannot access this variable here
102:11 - anymore
102:12 - this variable has its scope and that
102:14 - scope is inside
102:15 - this function here and once this
102:17 - function
102:18 - exits we are going to lose the address
102:21 - of this
102:21 - array here which means that we will not
102:24 - be able to deallocate this memory here
102:27 - now let's delete this okay
102:30 - here as you can see this memory leak is
102:32 - not a big
102:33 - memory leak here we are leaking five
102:36 - integers so we are leaking an array of
102:38 - five integers and that is not
102:40 - very big problem but usually what
102:42 - happens in real life is that you are not
102:44 - creating
102:45 - an array of five integers usually you
102:47 - are creating things that require
102:49 - much more memory than just an integer
102:52 - array of five
102:53 - elements so here as i said we are
102:55 - leaking five integers but imagine a
102:57 - situation where you're
102:59 - creating an array of 5000 or 50 000
103:03 - and not integers but objects of type
103:06 - user like this and this user has
103:10 - some pretty heavy data in it for example
103:12 - it has some images and things like that
103:14 - so here you are creating 50 000 users
103:18 - and to make things worse imagine not
103:20 - invoking this function only once but
103:23 - imagine invoking this function in a for
103:26 - loop for example so invoking it
103:28 - 100 times or 1000 times or 100 000 times
103:32 - that is going to be a huge memory leak
103:35 - so what this line of code here does is
103:38 - it asks your operating system for
103:40 - dynamic memory so it says
103:42 - please can you give me new memory so can
103:45 - you give me dynamic memory that i need
103:48 - to store this data here and your
103:51 - operating system gives that memory
103:53 - to your program so it allocates that
103:55 - memory for your program
103:57 - and then once this function here
103:59 - finishes
104:00 - you will lose all the variables that you
104:03 - have created inside that function
104:05 - and that is this ptr variable here so
104:07 - that means that the address
104:09 - of this array here which was stored
104:12 - inside this
104:13 - ptr variable is lost now and now you
104:16 - will not be able to deallocate
104:18 - this memory here which means that you
104:20 - will not be able
104:22 - to say okay now i am done with this
104:25 - memory which is a lot of memory and now
104:27 - i'm going to return that
104:28 - back to my operating system because i
104:31 - don't have unlimited amounts of memory
104:33 - and my operating
104:34 - system maybe would like to give that
104:36 - memory to some other program
104:38 - so once this function here ends and you
104:40 - don't
104:41 - de-allocate this memory here you are
104:44 - leaking
104:45 - that memory and that is exactly the
104:48 - error that you have here it says a
104:49 - memory leak is
104:51 - possible whereas your compiler here
104:54 - said expected a type specifier which is
104:56 - uh
104:57 - error that we have here because it does
104:58 - not know what is this user so i'm going
105:00 - to return this back to int
105:02 - okay now that error has disappeared but
105:05 - your compiler does not know that you are
105:07 - leaking memory here whereas your
105:09 - previous studio
105:10 - analyzer here says that a memory leak
105:13 - is happening so how do you fix
105:16 - this error here well for
105:19 - each new you need to have delete
105:23 - again you need to watch my c plus
105:25 - pointers playlist in order to understand
105:27 - pointers if you don't understand this
105:29 - already
105:30 - so as i said for each new you need to
105:32 - have delete so i'm going to say
105:35 - delete and let's delete this ptr let's
105:38 - see what is going to happen
105:39 - now so if i click extensions and then
105:41 - pvstudio check current file
105:44 - it says the memory was allocated using
105:46 - new
105:47 - array type operator but it was released
105:50 - using
105:50 - delete operator and then it gives you a
105:53 - recommendation here it says
105:55 - use delete array pointer etc instead
105:58 - so here we are trying to allocate memory
106:01 - for an array but we are not deleting
106:03 - that entire array so here we are leaking
106:06 - memory again
106:07 - so here i'm going to use these square
106:09 - brackets in order to indicate that i
106:11 - want to delete
106:12 - this entire array that i have allocated
106:15 - in this line of code here so now we
106:18 - shouldn't be
106:18 - leaking memory anymore so let's check
106:21 - that out i'm going to say
106:22 - pbs studio chat current file and
106:26 - let's see we have that error that we
106:29 - previously had which is your license
106:31 - will expire in five days but we do not
106:33 - have
106:33 - memory leaks anymore which is great so
106:36 - errors like this
106:37 - memory leaks are very common when you
106:39 - work with pointers in c
106:41 - plus and these memory leaks can create
106:43 - huge problems if you have them
106:45 - in your code and as you could already
106:47 - see in most cases you cannot really
106:49 - count on your compiler
106:51 - to tell you that you are leaking memory
106:53 - because in most cases it will not even
106:55 - be able
106:55 - to see that so tools like pvs studio can
106:59 - be
106:59 - very helpful in those situations you
107:01 - could see all those
107:03 - little tips and recommendations that we
107:05 - had from pvstudio that helped us
107:08 - to fix issues that we had related to
107:11 - leaking memory so those were some topics
107:13 - that i wanted to address in this video
107:15 - because many people when working with
107:17 - pointers will come across
107:19 - problems that they will not be able to
107:21 - fix or they will not even be aware that
107:23 - they have those problems
107:25 - that they have memory leaks until it
107:27 - gets to the point where it is
107:29 - unmanageable and they have very big
107:32 - problem they have huge problem
107:33 - so if you have any more questions that
107:37 - you would like me to make
107:38 - video on please leave those in the
107:40 - comments down below and if you like this
107:42 - type of video please
107:43 - give this video a thumbs up so that i
107:45 - can know and i will make more videos
107:47 - like this in the future if you want me
107:49 - to so
107:50 - thank you very much for watching this
107:52 - video and i am going to see you in my
107:54 - next video
107:54 - bye hi everyone and welcome to my
107:57 - channel
107:58 - in this video i want to teach you about
108:00 - function pointers in c
108:01 - plus plus many beginners think that
108:04 - function pointers are extremely hard to
108:06 - understand
108:07 - and to be honest um the syntax is
108:10 - one of the ugliest things that you are
108:12 - going to see in c plus language
108:14 - but in this video i decided to simplify
108:16 - it
108:17 - and to make it understandable for every
108:19 - single beginner so in this video you are
108:21 - going to learn
108:22 - how to use function pointers and why
108:24 - they exist what is their purpose
108:26 - the first thing that i want to explain
108:28 - related to function pointers is
108:30 - what are function pointers and then
108:32 - later in the video i'm going to explain
108:34 - what is their purpose why do they exist
108:37 - and i'm also going to leave timestamps
108:39 - in the description that you can use
108:41 - in order to navigate yourself to the
108:43 - desired part of the video but
108:45 - i highly recommend you to watch the
108:46 - entire video if you really want to
108:48 - understand
108:49 - what are function pointers so
108:52 - um in order to understand what are
108:54 - function pointers you first need to
108:56 - understand what is
108:57 - a pointer and in the beginning of this
109:00 - playlist in the first video we already
109:02 - said
109:02 - that a pointer is a special type of
109:05 - variable that is used
109:06 - in order to store the address of another
109:10 - variable now a function pointer is
109:13 - very similar but instead of storing the
109:16 - address of
109:16 - a variable a function pointer stores the
109:19 - address of
109:20 - a function so let's demonstrate how that
109:23 - works
109:24 - in visual studio so let's create a
109:27 - function of return type
109:29 - int let's call it get number
109:33 - and from this function i just want to
109:36 - return
109:37 - number five like this and it is very
109:40 - easy to predict
109:42 - what is going to happen if i say get
109:45 - number and then i run my program
109:49 - okay we get the value of five written in
109:52 - our console
109:53 - okay now one question that i have for
109:55 - you
109:56 - is what is going to happen if i remove
110:00 - these parentheses so what kind of output
110:03 - do you
110:03 - expect to get in the console write me in
110:06 - the comments
110:07 - so if i run my program now as you can
110:11 - see
110:11 - we get an address so what kind of
110:15 - address this is this is the address
110:18 - of our function and now that we learned
110:22 - that the name of the function will give
110:25 - you its address
110:26 - what we can do is we can create a
110:29 - function pointer and then we can assign
110:32 - the address of that function to a
110:34 - function
110:35 - pointer so let's stop our program and
110:37 - let's do that
110:39 - i am going to remove this line of code i
110:42 - don't need it anymore
110:43 - and now i'm going to show you how you
110:45 - can create a function
110:47 - pointer the syntax is pretty hard so pay
110:49 - attention
110:50 - the first thing that you need to do in
110:52 - order to create a function pointer is
110:55 - use these parentheses and then inside
110:57 - parentheses you will put
110:59 - asterix symbol and you will give the
111:03 - name to your function pointer so
111:05 - let's call it func ptr
111:09 - so function pointer that is the first
111:12 - part
111:12 - the second part is to put the return
111:15 - type of your function
111:16 - in front of the name so here since i
111:20 - want to point to this function here the
111:22 - return type
111:23 - is int so i'm going to put int
111:26 - here and then the third part is to put
111:29 - the parameters that your function
111:31 - receives after
111:33 - the name of your function pointer and
111:35 - that is
111:36 - here so you are going to put parentheses
111:39 - and inside these parentheses you would
111:42 - put
111:42 - the list of parameters that your
111:45 - function receives
111:46 - but since this function here does not
111:49 - receive
111:49 - any parameter these parentheses are
111:51 - going to be
111:52 - empty okay and with
111:56 - this we have successfully created
111:59 - a function pointer that can point to any
112:02 - function that
112:03 - returns int and it does not receive
112:07 - any parameter and that is for example
112:10 - this function here so what i can do now
112:13 - is i can say that my function pointer
112:17 - will point to get number
112:20 - function and as we already saw
112:24 - this getnumber function will give us the
112:26 - address of this
112:27 - function here so what i can do now is
112:31 - i can use this function pointer in order
112:34 - to invoke
112:35 - this function so i can say c
112:38 - out func ptr
112:42 - like this so the approach is absolutely
112:45 - the same
112:45 - as invoking that function directly but
112:48 - instead of using
112:49 - the name of the function you just use
112:51 - the name of the function
112:53 - pointer so if i run the program
112:57 - as you can see we are going to get the
112:59 - value of five
113:00 - but we have invoked this getnumber
113:03 - function by using a function
113:05 - pointer okay so let me show you
113:09 - one more time how you can create a
113:11 - function pointer
113:12 - but this time i want to show you how you
113:14 - can do that
113:15 - for a function that actually receives
113:18 - parameters
113:19 - so let's delete all of this code
113:23 - like this and let's create another
113:25 - function so let's create a function that
113:28 - returns
113:28 - int let's call it add and this function
113:32 - will receive
113:33 - int a and then int b
113:36 - and the task of this function will be to
113:39 - sum
113:40 - these two numbers and then to return the
113:42 - result so i'm going to say
113:44 - return a plus b
113:47 - like this so how can we invoke this
113:50 - function by using a function
113:52 - pointer well let's again repeat how we
113:55 - can create a function pointer
113:57 - so one more time you use parentheses and
114:01 - then inside parentheses you are going to
114:03 - put
114:03 - asterisk symbol to indicate that you
114:05 - want to create a pointer
114:07 - and then you will give a name to your
114:09 - pointer you will call it
114:10 - func ptr for example and then
114:14 - two more things the first one is to put
114:16 - the return type of your function
114:18 - in front so end because we want to point
114:21 - to this function here
114:23 - and then the second part is to put
114:25 - parameters
114:26 - after the name of your function pointer
114:28 - so here
114:30 - and here inside these parentheses i will
114:33 - put
114:34 - int and then int because this
114:37 - add function receives two parameters and
114:39 - those are
114:40 - integer and integer so now we have
114:43 - created a function pointer that can
114:45 - point to
114:45 - any function that returns integer and
114:49 - receives two integers and that is
114:52 - this function here so i can now say
114:55 - that my function pointer will hold the
114:58 - address
114:59 - of add function and if i want to
115:03 - invoke this function there are two ways
115:06 - to do that so i can either say
115:08 - c out add and then let's pass two
115:12 - numbers let's say for example two
115:14 - and three let's add end line
115:18 - and then second way to invoke this same
115:20 - function is by using this
115:22 - function pointer so i can say c out and
115:25 - then
115:26 - func ptr and here i'm going to use the
115:29 - same approach
115:30 - of passing parameters like i did here so
115:33 - i'm going to say for example
115:35 - three and four and let's add
115:38 - end line here as well so if i run my
115:41 - program let's see what is going to
115:43 - happen
115:44 - okay for this first line we get the
115:46 - result of five so two plus three is five
115:48 - and then
115:49 - for this second line we get the result
115:52 - of
115:52 - seven so three plus four is seven so
115:55 - this is how you can create a function
115:58 - pointer and then this is how you can
115:59 - invoke
116:00 - that function by using its function
116:02 - pointer
116:04 - okay now that you have seen and
116:06 - understood what i just explained
116:08 - your question might be salvina why would
116:11 - anyone
116:12 - want to create a function pointer just
116:15 - to be able to invoke
116:16 - that function because it is so much
116:19 - easier to do
116:20 - that directly and the answer to your
116:23 - question is
116:24 - you are absolutely right but this
116:27 - is not the purpose of function pointers
116:30 - this is not
116:30 - the reason why function pointers exist
116:34 - so let's talk about the real purpose of
116:37 - function pointers
116:38 - why they exist and when we can use
116:40 - function pointers
116:43 - one of the most common uses of function
116:45 - pointers
116:46 - is we use a function pointer in order to
116:50 - be able to pass
116:52 - a function as an argument or as a
116:55 - parameter to
116:56 - another function and we do this in order
116:59 - to
116:59 - optimize our code so in order to make
117:02 - our code
117:03 - reusable so what i want to do now
117:06 - is i will delete all of this code
117:10 - and then i'm going to type a code that i
117:12 - want to show you in order to demonstrate
117:14 - something amazing that we can do with
117:16 - function pointers so after i type that
117:18 - code i will be
117:20 - back so here i have created a couple of
117:23 - functions
117:23 - and let's now explain what every single
117:26 - one of these
117:27 - is doing so the first one is ascending
117:31 - compare and it is very simple function
117:33 - that just compares two numbers
117:36 - so that the first one is smaller than
117:39 - the second one and then it returns if
117:41 - that is true
117:42 - or not and then descending compare again
117:46 - very simple function and again it
117:48 - compares two numbers but in this
117:49 - situation
117:50 - the first number needs to be greater
117:53 - than
117:54 - the second number okay these two are
117:56 - very simple
117:58 - let's see what is happening inside this
117:59 - sort ascending function
118:02 - so if i open that function you will
118:05 - notice that this here
118:06 - is a sorting algorithm now the goal
118:09 - of this video is not for you to
118:11 - understand how this sorting algorithm
118:13 - works
118:14 - we are going to explain that in a whole
118:16 - another video of c
118:18 - plus sorting algorithms which i'm going
118:20 - to make in the future
118:21 - but for now the goal is that you
118:24 - understand that
118:25 - the job of this function here is to sort
118:28 - a vector of numbers in an ascending
118:31 - order
118:32 - and one very important thing is that
118:34 - since we are using
118:35 - vector you will need to include that
118:39 - vector because otherwise you are going
118:41 - to get an error
118:42 - so that is the job of sort
118:46 - ascending now if we take a look at sort
118:50 - descending let me move this
118:54 - code okay you will notice that sort
118:57 - descending function is almost identical
119:01 - to sort ascending function and the only
119:04 - thing that is different
119:05 - is this part here and this
119:09 - part here so our sort ascending which is
119:12 - sorting numbers in an ascending order
119:15 - is invoking ascending compare function
119:18 - and then our sort descending is invoking
119:22 - descending compare function and those
119:25 - are the functions that i
119:26 - explained in the beginning okay
119:29 - so the next thing that i want to do is i
119:32 - just want to demonstrate how these two
119:34 - functions work
119:35 - i want to test these two functions and
119:38 - then i am going to show you how we can
119:40 - optimize this code here so
119:44 - what i want to do is i want to create
119:47 - a vector of integers
119:50 - and let's call it my numbers
119:54 - like this and i want to assign numbers
119:58 - of
119:58 - two and then five one three
120:02 - six and four okay
120:06 - and what i want to do now is i want to
120:08 - invoke
120:09 - sort ascending and then i will print
120:12 - those numbers in order to be able to see
120:15 - if those numbers have been
120:16 - sorted in an ascending order and for
120:19 - printing numbers we will use
120:21 - this function here which is very simple
120:24 - function that will just
120:25 - iterate through this numbers vector and
120:28 - write out every single number of that
120:31 - vector
120:32 - so let's do what i just explained let's
120:35 - invoke
120:36 - sort ascending like this
120:40 - and let's pass my numbers vector to that
120:44 - function and after i have sorted
120:47 - those numbers in an ascending order
120:50 - let's say
120:51 - print numbers and i will pass
120:55 - my numbers vector like this
120:58 - so if i run my program let's see what is
121:01 - going to happen
121:02 - as you can see this vector here has been
121:05 - sorted
121:06 - in an ascending order so one two three
121:09 - four five
121:10 - six okay so that means that our sword
121:13 - ascending function works as it should
121:16 - and let's now test this sort descending
121:19 - so here i'm going to invoke
121:21 - sort descending function everything else
121:24 - stays the same so let's run our program
121:26 - again
121:28 - okay so six five four three two one
121:31 - which means that our sword
121:32 - descending works as it should as well
121:35 - okay
121:36 - perfect again all of this code will be
121:38 - in the description for those of you who
121:40 - want to analyze how this
121:41 - sort descending and then sort ascending
121:44 - functions
121:45 - work but for now it's enough for you to
121:47 - understand that this one is sorting
121:48 - numbers in an ascending order and then
121:51 - this one in descending order and that
121:54 - the only difference between these two
121:57 - functions
121:58 - is in this part here so
122:01 - this one is invoking ascending compare
122:04 - and then
122:04 - this one is invoking the sending compare
122:08 - so the next thing that i want to show
122:10 - you is how we can optimize this code
122:12 - here
122:13 - so that we can create one function that
122:15 - will be called
122:16 - custom sort and we can use that function
122:19 - in order to
122:21 - sort numbers in both ascending and
122:23 - descending
122:24 - order and the general idea is for that
122:27 - function to receive
122:29 - numbers vector and then we are going to
122:32 - pass
122:33 - another function to our custom sort and
122:36 - that function can be either
122:38 - this one or this one because that
122:41 - is the only difference between these
122:44 - two functions so let me show you how we
122:48 - can do
122:49 - that the first thing that i want to do
122:51 - is i want to change the name of this
122:53 - function here so
122:54 - instead of calling it sort ascending
122:56 - let's call it
122:57 - custom sort like this
123:01 - and that custom sort function as i
123:03 - already said
123:04 - will receive numbers vector and then it
123:07 - will receive
123:08 - a function pointer so it will receive a
123:12 - function pointer to one of these
123:14 - two functions so let's add that
123:17 - function pointer here as a parameter one
123:20 - more time
123:21 - how can we create a function pointer
123:23 - well
123:25 - inside these parentheses you are going
123:28 - to put
123:29 - asterix symbol and then you will give
123:32 - the name to your function pointer
123:34 - let's call it um compare
123:38 - func ptr so compare
123:41 - function pointer let's just call it func
123:44 - instead of
123:44 - fun okay so that is the first part
123:48 - the second part is to put the return
123:51 - type of your function
123:52 - in front so here i will say bool
123:55 - because that is the return type of both
123:57 - this function and
123:59 - this function here and then the last
124:01 - step is to put
124:02 - parameters that the function receives
124:05 - inside
124:06 - parentheses after the name of your
124:09 - function
124:10 - pointer so here and the parameters that
124:13 - these two functions receive are int and
124:16 - in so two integers so here i'm going to
124:18 - put int
124:20 - and then int okay so with this
124:23 - we have created a function pointer
124:25 - called
124:26 - compare func ptr which can
124:29 - point to either this function here
124:32 - or this function here so it can point to
124:35 - any function that
124:37 - returns bool and receives two
124:40 - integers so what we can do with our
124:43 - compare function pointer is we can use
124:46 - it to pass
124:47 - either this function or this function
124:50 - to our custom sort so
124:53 - since this part here was the only
124:56 - difference between
124:57 - sort ascending and sort descending
125:00 - if i change this with my compare
125:03 - function
125:04 - pointer that means that whichever
125:07 - one of these two is passed as
125:11 - argument to our custom sort that one is
125:14 - going to be
125:15 - invoked here so that means that now we
125:18 - can use
125:20 - custom sword in order to do both
125:22 - ascending and
125:23 - descending sort of this vector
125:27 - here so that means as well that now
125:30 - we can delete sort descending so
125:34 - let's test this function here
125:37 - so i am going to delete this part here
125:40 - and what i want to do first is i want to
125:43 - create
125:44 - this function pointer in my main
125:47 - function so i
125:48 - will do it here again inside
125:51 - parentheses you put asterisk symbol and
125:54 - then you give the name to your function
125:55 - pointer
125:56 - let's call it func ptr and then
126:00 - you put the return type of that function
126:03 - here since we want to point to one of
126:05 - these two functions
126:06 - the return type is bull and then they
126:09 - receive
126:10 - two integers so the return type
126:13 - goes here bull and then the parameters
126:16 - go here inside parentheses and those are
126:19 - two integers like this so
126:22 - we have created a function pointer that
126:25 - can point to
126:26 - any function that returns bull and
126:28 - receives
126:29 - two integers so the first one that i
126:32 - want to assign here
126:34 - will be ascending compare
126:38 - like this so now i'm going to invoke my
126:42 - custom sort
126:43 - function here and i am going to pass
126:47 - two parameters to that function the
126:49 - first parameter is
126:51 - numbers vector so my numbers
126:55 - okay and then the second parameter is a
126:58 - function pointer to a function that
127:01 - returns bull and receives two integers
127:04 - and that will be
127:05 - this function pointer here okay
127:09 - perfect so now if i run my program what
127:12 - do you expect to happen
127:14 - write me in the comment section so let's
127:16 - run the program
127:19 - okay and as you can see the numbers of
127:22 - my vector
127:23 - have been sorted in the ascending order
127:26 - so one two three four five
127:28 - six and for that we have used custom
127:31 - sort
127:32 - function and we have passed our vector
127:34 - and
127:35 - a function pointer so we have passed
127:37 - ascending
127:38 - compare to our custom sort so we have
127:42 - basically used
127:43 - a function pointer in order to pass one
127:47 - function
127:48 - as an argument to another function
127:51 - and let's now test this with descending
127:55 - compare so i'm going to say
127:56 - descending compare here and that is the
127:59 - only thing that you need to change
128:01 - and now this descending compare will be
128:04 - passed
128:05 - as an argument to our custom sort
128:09 - so if i run my program now let's see
128:12 - what is going to happen
128:13 - perfect now our numbers have been sorted
128:16 - in the
128:16 - descending order so six five four three
128:20 - two
128:20 - one and we have achieved that
128:24 - by using a by using a function
128:27 - pointer okay so i hope that
128:30 - this video was helpful i hope that you
128:32 - understood
128:33 - what is the purpose of function pointers
128:35 - and how you can create and use function
128:38 - pointers
128:39 - all of this code will be in the
128:41 - description
128:42 - again you don't really have to bother
128:44 - with understanding
128:45 - what these functions are doing except
128:48 - for the part of how you can
128:50 - use a function pointer in order to pass
128:53 - one function as an argument to
128:56 - another function so i hope that you
128:59 - enjoyed this video if you did please
129:02 - give it a thumbs up for the youtube
129:03 - algorithm that helps me a lot to reach
129:06 - more people
129:06 - and then share it with someone else who
129:08 - would also like to learn programming
129:09 - because
129:10 - the topic of function pointers is not
129:12 - very beginner friendly so
129:14 - if you found this video helpful you
129:16 - might make a very big
129:18 - difference in someone else's life and
129:20 - you might help that person to learn
129:22 - programming much
129:23 - faster so thank you very much for
129:25 - watching and
129:26 - i am going to see you in some other
129:28 - video bye
129:29 - hi everyone and welcome to my channel in
129:32 - this video i will teach you about smart
129:34 - pointers in c
129:35 - plus and the first thing that i want to
129:37 - explain is what are smart pointers
129:40 - a smart pointer is a container or a
129:43 - wrapper
129:44 - for a raw pointer and one advantage that
129:47 - smart pointers have
129:48 - is that they de-allocate memory
129:51 - automatically which means that
129:53 - you don't have to worry about potential
129:55 - memory leaks
129:56 - in your program there are three
129:59 - different types of smart pointers in c
130:01 - plus unique pointer shared pointer and
130:04 - weak
130:04 - pointer and in this video i'm going to
130:06 - teach you about every single one
130:08 - so in order to use any one of these
130:10 - three the first thing that you need to
130:12 - do
130:12 - is you need to include memory so i will
130:15 - say
130:16 - include memory like this
130:20 - and the first type of smart pointers
130:22 - that i want to talk about
130:23 - are unique pointers so
130:27 - the syntax of creating a unique pointer
130:29 - is a little bit different if you are
130:31 - used to raw pointers
130:32 - so i'm going to show you now how you can
130:34 - create a unique
130:35 - pointer so you say
130:39 - unique ptr and then you specify the type
130:43 - so what kind of
130:44 - data type is going to be stored on the
130:46 - address that you want to point to
130:48 - so let's say for example integer so
130:51 - please make a unique pointer to
130:53 - integer and let's call that pointer
130:57 - u n p t r one so unique pointer one
131:01 - okay and then there are few different
131:04 - ways to create a unique pointer
131:06 - and the one that i use most often is
131:09 - make
131:09 - unique method so i'm going to say make
131:13 - unique so please make a unique pointer
131:17 - of integer type and to that address i
131:22 - want to store a value of
131:24 - 25 for example okay
131:27 - so with this i have successfully created
131:30 - a unique pointer
131:31 - to an integer and i have assigned the
131:34 - value of 25 to that address that
131:37 - my unique pointer 1 is pointing to
131:41 - so now the question is how do you use
131:43 - this pointer
131:44 - and as you already know pointers store
131:47 - address
131:48 - and in order to access the value that is
131:50 - stored on that address you need to
131:52 - dereference that
131:53 - pointer so how do you dereference a
131:56 - smart pointer
131:57 - the answer is by using asterix symbol or
132:00 - that little star symbol
132:02 - let me show you so
132:05 - if i say c out and then u n p
132:08 - t r one like this so if i
132:12 - write out this unique pointer one let's
132:15 - see what is going to happen
132:19 - okay as you can see we have an address
132:22 - because
132:22 - pointers store addresses now in order to
132:26 - access the value that is stored on this
132:28 - address you need to de-reference
132:30 - that pointer so let's do that
132:33 - and in order to dereference this pointer
132:36 - you put
132:37 - asterisk symbol before it okay so if i
132:40 - run my program now
132:43 - as you can see here we have the address
132:46 - that our pointer is pointing to
132:48 - and then this is the value stored on
132:50 - that address
132:51 - there is one very important thing
132:53 - related to unique pointers and that is
132:55 - that they cannot be
132:57 - shared so in order to demonstrate what
133:00 - i'm talking about
133:01 - let's delete this code here and let's
133:04 - create another unique pointer let's say
133:07 - unique ptr of int
133:10 - like this and let's call it unique ptr
133:14 - 2 like this okay so what is going to
133:18 - happen
133:18 - if i try to assign to this unique
133:21 - pointer to
133:22 - the same location that my unique pointer
133:26 - one is
133:27 - storing so if i do that
133:30 - as you can see we get an error and that
133:34 - means that
133:34 - you cannot share unique pointers
133:38 - okay now one thing that you can do is
133:41 - you can move
133:42 - the ownership of a unique pointer so
133:45 - what you can do
133:46 - is you can say that your unique pointer
133:49 - two
133:49 - is equal to please move the
133:52 - ownership of my unique ptr one
133:56 - like this and now our unique pointer 2
134:00 - becomes the owner of this memory address
134:04 - here so if i try to write out
134:08 - the value that is stored on
134:11 - this address here let's see what we are
134:13 - going to get
134:15 - okay so i am writing out the referenced
134:19 - unique pointer to let's run our program
134:23 - okay as you can see we get the value of
134:26 - 25.
134:28 - okay now one very important thing is
134:31 - that once you move the ownership
134:34 - of a pointer the previous owner which is
134:37 - this one
134:38 - becomes null pointer and that means if
134:41 - you try to access the value of your
134:43 - pointer that was previous owner you are
134:45 - going to get null pointer exception
134:48 - so let's demonstrate that let's say
134:51 - please write out the referenced value of
134:54 - my unique pointer one
134:57 - and let's see what is going to happen
134:59 - and as you can see
135:00 - we get an exception because now our
135:03 - unique pointer one
135:05 - is empty it is no pointer and if you are
135:08 - not familiar with exceptions if you
135:10 - don't know how to work with exceptions
135:12 - you can watch the video that i will link
135:14 - here and i will also link it in the
135:16 - description it's called
135:17 - exception handling and there i explain
135:20 - everything that you need to know in
135:21 - order to work with
135:22 - exceptions in c plus another important
135:25 - thing that i mentioned
135:26 - about smart pointers is that the memory
135:28 - is deallocated automatically which means
135:31 - that you don't have to worry about
135:33 - the allocating the memory or causing
135:34 - memory leaks
135:36 - and what i want to do now is i want to
135:38 - demonstrate that
135:40 - so basically i want to create a class
135:42 - and inside that class i want to create a
135:44 - constructor and
135:46 - destructor if you don't know a
135:48 - constructor is a special type of method
135:51 - that is invoked when an object is
135:53 - constructed or created
135:55 - and then a destructor is also a special
135:57 - type of method
135:58 - that is invoked when an object is being
136:01 - destroyed
136:02 - so if you are not familiar with the
136:04 - concept of objects classes constructors
136:07 - destructors
136:08 - and so on i am going to link a playlist
136:11 - here which
136:12 - is c plus plus object oriented
136:14 - programming
136:15 - and i will also put it in the
136:16 - description so c plus plus oop
136:18 - or c plus plus object-oriented
136:20 - programming you can watch that playlist
136:22 - in order to understand in more detail
136:24 - what i'm talking about
136:26 - so as i said what i want to do now is i
136:29 - want to create
136:30 - a class let's call that
136:33 - class my class
136:37 - okay and inside this class i will create
136:40 - a constructor and
136:42 - destructor so let's first create a
136:44 - public constructor so i will say
136:46 - public and then my
136:50 - class okay this
136:53 - is a constructor and inside constructor
136:56 - the only thing that i want to do is i
136:57 - just want to say
136:58 - constructor invoked so i will say see
137:01 - out and let's say constructor
137:06 - invoked like this
137:13 - okay and i also want to create a
137:16 - destructor
137:17 - so i will copy my constructor i will put
137:21 - squiggly before it i believe this is
137:22 - called squiggly or
137:24 - tilde sign and i will write out here
137:28 - that
137:29 - the structure is invoked
137:32 - okay i hope that i didn't make any typo
137:34 - here okay
137:35 - so i have created a class called my
137:38 - class
137:39 - and inside it i have a constructor which
137:41 - as i already said
137:43 - will be invoked when an object is
137:45 - created
137:46 - and then i also have a destructor which
137:48 - will be invoked
137:49 - at the end of the life of that object
137:51 - which means uh when that object is being
137:54 - destroyed so what i want to do now is
137:57 - let's delete everything from our main
137:58 - function because we don't need it
138:00 - and what i want to do is i want to
138:02 - create a pointer to an object of
138:04 - this class here so let's create a unique
138:08 - pointer like this
138:11 - of my class and let's again call it
138:15 - unique ptr1
138:18 - and i will make unique
138:21 - pointer of my class
138:25 - like this okay so let's see
138:28 - what is going to happen if i run my
138:30 - program now
138:31 - as you know already constructor is
138:34 - invoked when an
138:36 - object of this type is created and then
138:39 - the structure will be invoked when that
138:41 - object is being destroyed
138:43 - so if i run this program let's see what
138:45 - is going to happen
138:47 - okay as you can see we only have this
138:50 - constructor invoked so
138:54 - when is this pointer here being
138:57 - destroyed the answer is that this
139:00 - unique pointer will be destroyed at the
139:02 - end of
139:03 - the scope and the scope of this pointer
139:07 - here
139:07 - begins at this curly bracket and then it
139:10 - ends at this
139:11 - curly bracket here so at this curly
139:14 - bracket here
139:15 - this unique pointer will be destroyed
139:18 - and since this is the end of our program
139:21 - we
139:21 - don't see that destructor is invoked
139:25 - so what i can do to demonstrate that is
139:27 - i can create an additional scope so
139:30 - let's
139:30 - do that let's create an additional scope
139:35 - like this okay so now this is
139:38 - another scope and if i run my program
139:41 - now let's see what is going to happen
139:44 - as you can see now we have constructor
139:46 - invoked and then
139:47 - destructor invoked which means that here
139:50 - at this 18th line of code our
139:53 - constructor
139:54 - was invoked for myclass object and then
139:57 - at this
139:58 - 19th line of code so at the end of its
140:01 - scope the structure has been invoked
140:03 - which means that
140:04 - our unique pointer has been deallocated
140:07 - so we don't have memory leak
140:10 - so one more time this unique pointer
140:13 - will be destroyed it will be d
140:15 - allocated at the end of its scope which
140:18 - is
140:18 - here okay so that is related to unique
140:22 - pointers and now i want to explain
140:24 - what are shared pointers so as the name
140:28 - itself says
140:29 - a shared pointer can be shared unlike
140:32 - unique pointer a shared pointer can be
140:35 - shared between multiple owners
140:37 - and that means that you can assign one
140:40 - raw pointer to multiple owners
140:43 - so let's demonstrate how that works so
140:46 - let's
140:46 - delete everything from our main function
140:48 - because i don't need it anymore
140:51 - and the first thing that i want to show
140:52 - you is how to create a shared pointer
140:55 - so let's say shared ptr
141:00 - that is the keyword and then you specify
141:02 - the type so the type will be
141:04 - my class so the class that we created
141:08 - here
141:08 - and then let's give the name to our
141:10 - shared pointer let's call it
141:13 - shptr1 so sharedpointer1
141:16 - and now i want to use a method called
141:18 - make shared in order to make a shared
141:20 - pointer so i will say
141:23 - make shared of
141:26 - my class like this
141:30 - okay so with this we have created a
141:32 - shared
141:33 - pointer now one very interesting thing
141:35 - related to shared pointers is that
141:37 - since you can share a shared pointer
141:40 - it has the count of all of the owners so
141:44 - it has the count of all of the
141:46 - references to that
141:48 - pointer so how can you access that count
141:51 - well there is a method called use count
141:54 - so what i want to do now is i will show
141:56 - you
141:57 - that so i want to write out the number
142:00 - of
142:00 - owners of this pointer here so i'm going
142:03 - to say
142:05 - see out and then let's say shared
142:08 - count like this
142:12 - and let's say shptr1
142:16 - and then i will use a method called use
142:20 - count like this and
142:23 - this use count method as i already said
142:27 - will give me the number of owners of
142:30 - this location here so
142:33 - if i run my program let's see what is
142:36 - going to happen
142:37 - okay as you can see constructor has been
142:40 - invoked and then
142:41 - the number of owners of this memory
142:44 - location
142:44 - is one because we have only one pointer
142:47 - pointing to that
142:48 - memory location okay let's close
142:52 - this and what i want to do now is i want
142:55 - to share this pointer so i want to
142:57 - create
142:58 - an additional owner to that same memory
143:00 - location
143:01 - so let's create another shared
143:04 - pointer of my class
143:08 - and let's call it shptr2
143:12 - okay and what i want to do now is i want
143:15 - to assign to this
143:17 - shared pointer to the same memory
143:20 - location that this
143:22 - shared pointer one is holding
143:25 - like this and i also want to write out
143:28 - the number of
143:29 - owners of that memory location after i
143:32 - have shared
143:33 - that pointer so if i run my program now
143:37 - as you can see in this first line it
143:40 - says that
143:41 - the number of owners is one and then in
143:44 - this second line the number of owners or
143:46 - shared count
143:48 - is two okay one question that you might
143:51 - have now is
143:53 - when will this memory location
143:55 - automatically be
143:56 - deallocated and the answer to that
143:58 - question is
144:00 - the memory location will automatically
144:02 - be deallocated
144:03 - when there are no more pointers pointing
144:06 - to that memory location
144:08 - now since that memory location has
144:11 - multiple owners
144:12 - every single owner will be destroyed at
144:15 - the end of
144:16 - its scope and when there are no more
144:19 - owners
144:19 - the memory location itself will be
144:22 - deallocated which means that
144:23 - that memory will be free for other
144:26 - programs and other applications to use
144:29 - so let's demonstrate that as well what i
144:32 - want to do now is i want to put
144:34 - this here into an additional
144:37 - scope so let's do that let's create an
144:40 - additional scope
144:42 - like this and what i want to do now is
144:45 - after this scope
144:47 - i want to write out the count of the
144:50 - owners
144:50 - of this memory location so let's run our
144:53 - program and let's see what is going to
144:55 - happen
144:56 - let me know what you expect to happen in
144:58 - the comment section before i run the
145:00 - program
145:01 - okay so
145:04 - as you can see this first line
145:07 - says that there is one owner of this
145:11 - memory location and then we entered
145:14 - inside
145:14 - this scope here and it says that there
145:17 - are
145:18 - two owners and then after we have left
145:21 - this scope this third line this third
145:24 - print
145:25 - says that there is again only
145:28 - one owner of this memory location which
145:32 - means that
145:33 - this shared pointer so this owner has
145:35 - been destroyed
145:36 - at the end of its scope which is this
145:40 - line here now another thing that i said
145:43 - is that the memory location itself is
145:45 - going to be deallocated when there are
145:47 - no more pointers pointing to that
145:49 - location
145:50 - so in order to demonstrate that let's
145:52 - put all of this
145:54 - code inside a scope so i will put
145:58 - the beginning of that scope here and
146:00 - then the scope will end
146:02 - here and what i expect to happen is that
146:06 - this memory location is going to be
146:08 - destroyed
146:09 - at the end of the scope of its last
146:12 - owner
146:13 - so if i run my program
146:17 - as you can see okay let's move this as
146:19 - you can see
146:20 - our constructor has been invoked and
146:22 - that happened in
146:24 - this line of code here so the line where
146:26 - we made
146:27 - our pointer and then the first output
146:30 - says that there is only one owner and
146:32 - that
146:33 - is this 19th line which says shared
146:35 - count and then
146:36 - we have written out the count and then
146:39 - when we entered inside disco we created
146:42 - an additional owner so
146:43 - this second output here says that
146:47 - there are now two owners and then when
146:50 - we left
146:50 - that scope and we printed the output for
146:53 - the third time
146:55 - we get this line here which says that
146:57 - again
146:58 - we have only one owner of that memory
147:01 - location
147:02 - and then when we left this scope here
147:06 - which is the scope
147:07 - of that last owner we are going to
147:10 - destroy that
147:11 - memory location which means that we are
147:13 - going to deallocate that
147:15 - memory so that other programs and other
147:17 - applications can
147:19 - use it so that was related to shared
147:21 - pointers in c
147:22 - plus plus and now i'm going to teach you
147:24 - about weak pointers
147:26 - so the main difference between a weak
147:29 - pointer and a shared pointer is the
147:31 - following
147:32 - as you already saw when you assign a
147:35 - specific memory location to a shared
147:37 - pointer
147:38 - that is going to increase the number of
147:40 - owners of that
147:41 - memory location but if you assign that
147:45 - same memory location to a weak pointer
147:48 - that will not increase the number of its
147:51 - owners and that means that we use
147:55 - weak pointers in order to observe
147:58 - objects in memory but a weak pointer
148:00 - will not keep that object alive
148:03 - so we use weak pointers in order to
148:07 - locate a specific object in memory but a
148:10 - weak pointer will not keep that
148:12 - object alive if nothing else needs it
148:15 - whereas a shared pointer will keep that
148:18 - object
148:19 - alive so let's demonstrate what i just
148:22 - explained
148:23 - so let's delete all of this code i don't
148:26 - need it anymore
148:27 - by the way the leading code is my
148:29 - favorite part
148:30 - of coding so the first thing that i want
148:33 - to do
148:34 - is let's create a weak pointer let's say
148:37 - week ptr of let's say for example
148:41 - end so let's create a weak pointer to
148:44 - integer and let's call it
148:46 - we ptr1 wii ptr
148:49 - okay so another thing that i want to do
148:53 - is
148:54 - i want to create an additional scope
148:56 - like this
148:57 - and inside this scope i will create a
149:00 - shared pointer
149:02 - so let's say shared ptr
149:05 - of int and let's call it shptr
149:09 - one so shared pointer one and let's make
149:13 - one shared pointer so i'm going to use
149:15 - method make
149:17 - shared so please make sure pointer of
149:20 - int and let's assign the value of 25
149:24 - again okay so after i have created
149:28 - a shared pointer what i want to do is i
149:31 - want to assign
149:32 - this same memory location to my
149:35 - weak pointer so let's do that let's say
149:38 - that
149:38 - week pointer one is equal to
149:42 - shared pointer one like this
149:46 - okay so let's see what is going to
149:49 - happen
149:50 - if i run this program i'm going to put a
149:53 - break point here so
149:54 - at the first line of my main function
149:57 - and
149:57 - if i run this program let's see what is
150:00 - going to happen so now we are
150:02 - debugging this program okay so in this
150:05 - first line we are going to create a weak
150:08 - pointer and it is still not pointing to
150:11 - anything
150:12 - as you can see it is empty we just
150:14 - created it we didn't assign any
150:17 - location to that pointer okay and then
150:20 - after we have created that weak pointer
150:22 - we are going to enter
150:23 - into this scope here and inside this
150:26 - scope
150:27 - the first thing that happens is we
150:29 - create a shared pointer
150:31 - and then we assign the number 25 to that
150:34 - memory location that our shared pointer
150:36 - is
150:37 - holding so let's do that okay
150:40 - and if i hover over my shared pointer
150:43 - as you can see it is pointing to a
150:46 - memory location that has
150:47 - one strong reference and on that memory
150:50 - location we are storing the value of
150:53 - 25 okay now
150:56 - in this second line of code we will
150:58 - assign
150:59 - this shared pointer to our weak pointer
151:02 - so
151:03 - if i execute that line of code
151:06 - let's hover over our weak pointer and as
151:09 - you can see
151:10 - now our weak pointer as well is also
151:13 - pointing to the same memory location
151:16 - and that memory location stores the
151:18 - value of 25
151:19 - and it has one strong reference
151:22 - but one thing that will happen when i
151:25 - leave this scope here is following
151:29 - please write me in the comment section
151:31 - what do you expect to happen
151:33 - after i leave this scope here so
151:37 - if i press f10 and leave this scope and
151:40 - if i hover over my weak pointer here
151:43 - or here there are two things that you
151:45 - can notice
151:46 - the first thing is that it says that
151:49 - there is only
151:50 - one weak reference to this memory
151:53 - location so there are no more strong
151:55 - references and then another thing is
151:58 - that it
151:58 - has expired so all of the owners all of
152:03 - these strong
152:04 - references to this memory location have
152:06 - been
152:07 - destroyed and now we have just a
152:10 - reference we just have
152:11 - the address of a memory location that
152:14 - has been
152:15 - deallocated and that is exactly what
152:17 - i've been talking about
152:18 - which is that a weak pointer will not
152:21 - keep an object alive whereas a shared
152:25 - pointer
152:25 - will so this memory location has
152:29 - expired it was deallocated when its
152:32 - last strong reference so when its last
152:35 - shared pointer or
152:36 - when its last owner left its scope
152:40 - and that happened on this line of code
152:42 - here
152:43 - so i hope that this video was helpful if
152:46 - it was please give it a thumbs up
152:48 - for the youtube algorithm and also share
152:50 - it with someone who would like to learn
152:51 - programming because
152:53 - many people would like to learn
152:54 - programming but they just don't know
152:56 - where to start so you can be the one who
152:58 - helps them and makes the difference
153:00 - and also if you have any questions you
153:02 - can leave those in the comments section
153:04 - and please let me know what kind of
153:05 - videos you would like to see
153:07 - in the future so thank you very much for
153:10 - watching and i
153:11 - am going to see you in some other video
153:13 - bye

Cleaned transcript:

hi and welcome to my channel this video is beginner to advanced c plus pointers course so in this video you are going to learn about all of the important topics related to pointers but before i start with the lessons i want to give you a few tips so if you need captions or subtitles for this video i want to say that youtube sometimes does not allow captions on videos that are very long but if you really need them i'm going to link here and in the description a playlist that contains all of the individual lessons from this video and those lessons contain captions so if you really need them make sure to check that out tip number two is that all of the chapters will also be linked in the description so that you can navigate yourself through the lessons but my recommendation is to watch the entire video because it is going to be much easier and better for you if you don't skip anything and learn step by step and if you want to learn about other topics like object oriented programming data structures algorithms or programming in general i have a lot more tutorials for you and i will also link them in the description and one of the most important topics that you should definitely check out is creating graphical user interface applications with c plus one of my most popular videos is this one where i explain the fastest and the easiest way to build user interface applications i will link that video in the description and i will also link a tool that i use in order to create ui applications it is called c plus builder and you can download it and try it out for free using the link in the description and please follow that tutorial in order to learn more about building your own ui applications and in that tutorial you will see how c plus builder makes it very easy to create user interfaces so after you watch that tutorial you will understand how to create your own user interface applications so that any idea that you have you will be able to translate that idea into an app very fast so those are the topics that i covered so far on my channel and if you have any other topics that you would like to see in the future feel free to write me in the comment section and before i start i also want to ask you to please give this video a thumbs up for the youtube algorithm and also if you want to support me and my channel and all of the hard work that i put in in order to make these videos and thank you very much if you do that so now i'm going to start with the lessons good luck with learning and feel free to let me know how it goes in the comments in this video i want to talk about pointers so i will go straight to the point pointers are very important concept in c plus and they have many uses in z plus plus now pointers are not limited only to c plus they exist in other programming languages as well but in most of those programming languages they are really hidden they work behind the scenes so you cannot see them and you cannot use them yourself but at c plus you can use them and you can create your own pointers and they can be pretty powerful if you know how to use them but they can get quite confusing as well if you don't understand them well so the first thing that i want to explain is what are pointers so we already have explained the concept of a variable and you should be familiar with that so we said that a variable is just a container so a container that stores certain value now a pointer is container as well but instead of storing value pointer stores an address so a memory location and let me show you how pointers work in visual studio let's create a variable of type int and i'm going to call it n and assign it a value of 5 and let's write out this n like this so nothing new here we are already familiar with this and if i run my program as you can see we get this value of 5. so that was expected now as i already said this n is a variable and that means that it is a container which is storing certain value now because it is a container that means that it has its address inside memory so it has its physical location so how can we get that location how can how can we check which address this n has so in order to do that you use this ampersand symbol like this so you put it before your variable name and that should give you the address of that variable so if i run my program now as you can see now we have an address um and this is the address of our n variable so this is its physical address where this value of five is stored and because this is pretty hard for humans to remember this is just a random numbers and characters because of that we use meaningful names and we access these values that we store in our memory using these meaningful names which are our variables so i'm going to close this now and what i want to show you here is i want to show you how can you create a pointer that is going to hold this address of our n variable so in order to create a pointer you give it a type first so you say int and then in order to indicate that you are creating a pointer you use this star symbol and then you give it a name so let's call it ptr pointer and i'm going to assign it the address of our n variable so i'm going to copy this and paste it here okay now our pointer is holding the address of our n variable and in order to prove that i'm going to write out the value of my pointer like this so as expected we have this first line here which is writing out the address of our n variable and then this second line of code is this line here and as you can see we have written out the value of our pointer and that is the same address as this one here which means that our pointer really is storing the address of our n variable now you may ask how can i access or can i access the value that is stored on that address using pointers and the answer to that question is yes you can and in order to do that in order to access the value that is stored on this address that your pointer is holding you have to dereference your pointer so how do you do that well let me copy this so as you already have seen this line of code here is going to write out the address and in order to write out the value on that address you dereference the pointer and in order to do that you add this star symbol before your pointer's name so if i run my program now as you can see in this last line of code we have the value of 5 which is actually the value that is stored on this address here so let me show you one more thing what i want to do is i want to change the value that is stored on this ptr address so on this address that our ptr pointer is storing so how am i going to do that i'm going to say again star symbol and then ptr and this here means please access this memory location so whatever i'm going to assign here is going to be stored on that memory location and what i want to assign is for example value of 10 like this so now if i copy this line of code and then paste it here and if i run my program again we have this value of 10 stored on this address here and one interesting thing as well is that if we try to write out the value that our n holds now like this if i run my program as you can see our n holds the value of 10 as well even though we have never said that n has the value of 10 but we have stored the address of our n in our pointer and then we have dereferenced our pointer meaning we have changed the value on that address here in this 11th line of code here so that's why our n holds value of 10 now one very important thing to keep in mind is that your pointer has to be of the same type like the variable that it is pointing to so let's close this so as i said this integer pointer is pointing to an integer variable so rn is of int type and the same way would be if we created a float pointer it would have to point to a float variable and then char pointer can point only to a char variable double bool uh and so on so pointer and the variable that that pointer is pointing to have to be of the same type okay so that means that if i try to change the type of this n variable to float for example like this so if i say float immediately we get an error here and the error says a value of type float pointer cannot be used to initialize an entity of type endpointer meaning you cannot assign address of a float type to pointer of int type okay so that is the error that we have here and i'm going to return this to int okay and as you can see that error has disappeared because now our pointer is pointing to the same type so to the variable of the same type that that pointer has so int pointer pointing to an int variable one thing that beginners very often try to do is the following so they say okay let's create a pointer so int let's give it a name ptr2 so pointer like this so i have created a pointer right so let's dereference this pointer and assign it a value so i'm going to say please dereference ptr 2 and assign it a value of 7 for example now this code here has a problem problem and if i run it if i say build solution actually as you can see it says uninitialized local variable ptr2 used this means that this ptr2 so this pointer 2 does not have an address so where should it store this value of 7 if it does not have an address and the easiest way right now to solve this problem is going to be to create a variable and to give the address of that variable to our ptr2 pointer so i'm going to say int v this variable has to be of the same type as our pointer as we already said and then i'm going to say here our ptr2 is going to hold the address of our v variable like this and now we shouldn't have this problem anymore so if i build my code again as you can see one succeeded so the problem has disappeared and let me write out the value of this v variable so i'm going to say v is equal to and then let's write out the value of this v and if i run my program as you can see it says that v has the value of 7 because we have assigned it here by dereferencing our pointer that is holding the address of our v so you may say now okay salina i understand this but this seems a little bit too much why would i create a pointer just to assign a value to a variable and the answer to that question is you don't this is not the type of problem for which pointers were created in c plus plus so there are different problems that pointers solve in c plus plus and this here is just a demonstration of what are pointers and how can you create your own pointers now examples of some of these other problems that pointers solve is you can use pointers in order to pass values by a reference to a function and then you can use them to return multiple values from a function which is an interesting one you can use pointers in combination with arrays as well you can use them for dynamic memory allocation and then if you're familiar with oop objectoriented programming you can use a pointer of a base class in order to access a object of derived class and then there is this concept of smart pointers which we are going to cover in the future so stay tuned subscribe to my channel um hit that bell icon as well so that you are notified when i publish my next video and if you like this one give it a thumbs up thank you for watching and i'm going to see you in my next video where we will be talking about pointers bye in this video i want to talk about void pointers now in the previous video of this playlist i introduced you to pointers in general so i explained what are pointers and how you can create your own pointers and i said that a pointer is a special variable that can hold an address and i said as well that a pointer can hold only the address of a variable that is of the same type as that pointer which means an integer pointer can hold the address of an integer variable and then a character pointer holds the address of a character variable flow pointer of a float variable and so on but there is an exception to that rule and that is a void pointer and a void pointer is a special type of pointer that can hold the address of a variable of any other data type so avoid pointer can hold the address of a float variable or an end variable or a char bool struct whichever one you pass to that void pointer but a void pointer has a limitation as well and that limitation is that you cannot directly dereference a void pointer so in order to demonstrate this i'm going to create an example with the knowledge that we already have so using only integer and character and float pointers that we are already familiar with and then i want to introduce a void pointer in order to solve that problem so that you can see how void pointers are used so let's jump into our visual studio here i want to create a variable um and let's make it of int data type so i'm going to say int and let's call it number like this and i'm going to assign it a value of 5 for example now what i want to do with this number variable is i just want to write it out and because we are working with pointers let's play with pointers some more so i want to write out this variable using a function that receives a pointer let's do that so that function is going to be of return type void and let's call it print number like this and then here this function is going to receive an integer pointer and we are going to call it uh number ptr so number pointer okay now what this function here should do is it should just print out the value that this number pointer is storing so actually the value that is stored on the address that this number pointer is holding so in order to do that we have to dereference this pointer so i'm going to say star symbol and then put the name of this number pointer and let's add an end line as well now this function is finished and it is writing out the value that is stored on the address that we passed to it and we have to pass it the address of an integer variable so if i invoke this print number function let's say print number as i said since it is receiving a pointer we have to pass it an address and that is going to be the address of this number variable so let's say ampersand number so this here is going to give us the address of this number variable okay and now if i run this program as you can see this function here has printed out value of 5 which is the value of our number okay now what happens if i want to create a character variable and then print out a character variable as well so let's do that i'm going to say char let's call it letter and let's assign it a value of letter a okay and now in order to print out this character using this same approach i will have to create another function because this one here receives an integer pointer and in order to print out a character we would have to create a function that receives a character pointer so let's copy this function here and i'm going to call it print letter like this and then this function is going to receive a character pointer okay and that pointer is going to be called char ptr and then here i just want to write out the reference value of that char ptr so let's invoke this print letter function let's pass it the address of this letter variable that we have created here and now if i run this program as you can see we have 5 for this first function and then a for this second function which means that these two functions are doing its job but what happens if i want to print out a floating point number and then a double and then a boolean value and a struct value in order to do each one of those i would have to create a function that receives that specific data type pointer but we can solve that same problem using a void pointer because as we already said a void pointer can point to a variable of any data type so let's do that let's create a function that is going to print out any data type so that function is going to be of return type void and let's give it a name print because it is generic it is going to work with all data types i'm going to give it name of print and as we said that function is going to receive void pointer and let's call that pointer ptr okay now because this void pointer can point to a variable of any data type we will have to keep track of which data type we have passed inside this void pointer and in order to do that i'm going to use another parameter here and that parameter is going to be of type char and i'm going to call it type so how this type parameter is going to be used well in a situation where we pass an integer pointer to this print function here this type parameter is going to have a value of i in a situation when we pass a character pointer to this void pointer here in this type parameter we are going to pass a value of c and then if we pass a float pointer here here we are going to store an f and then if we pass a double pointer here this type variable should store a letter d so that we can know how we are going to dereference this ptr pointer so the first thing that we have to do is we have to check what this type variable is holding so in order to do that i'm going to use switch case like this you can use if else as well if you want so here i'm going to switch on this type variable like this and what i want to do here is i want to say indicates that this type variable is holding the value of i that means that this here is an integer pointer so here i'm just going to leave a comment for now so i'm going to say handle int pointer like this and then the other situation is going to be indicates that this type variable is holding the value of c that means that here we have passed a character pointer so i'm going to leave another comment as well so here i i'm going to say handle char pointer okay now let's explain how we are going to handle this integer pointer and then this character pointer as well well as we already said since avoid pointer cannot be dereferenced directly but we first have to cast it into a specific data type so into an integer pointer or into a character pointer in this particular situation i'm going to do that so here i'm going to say in the case that our user has passed an integer pointer here i will have to cast this void pointer into an integer pointer first so how do you do that well you say please this pointer here so this ptr casts that into an integer pointer so this expression here is going to cast this void pointer into an integer pointer so in these parentheses here we are going to have an integer pointer and in order to access to the address that an integer pointer is storing and write out the value that is stored on that address we dereference that pointer and for that we use this star symbol so now here we have the value that is stored on this integer pointer and i'm going to write out that value like this and let's add end line as well so this here writes out the value of an integer pointer so let's copy that and then paste it here and here what i want to do in this c situation is i want to cast this void pointer into a character pointer so char pointer and then after i have character pointer here id reference and then this line is going to write out the value of our character okay so now if i invoke this print function i should get the value of this number and then of this letter as well using only this print function so let's comment these two for now and let's invoke our print function so i'm going to say print and then the first thing that it receives is going to be the address and in this particular situation considering that this is a void pointer we can pass it the address of any data type so we can pass it the address of a integer variable or of a character variable or of a floating point variable and in this situation we have integer variable and then character variable so let's use these two so let's pass here the address of our number that oh that is going to be the first parameter and then the second parameter is going to be the type and considering that we have passed the address of an integer let's pass the value of i as our second parameter here okay and then i'm going to copy this function one more time and this time i want to pass it the address of our letter variable and considering that that is a character here as a second parameter i'm going to pass c now i've just noticed that something is missing from our switch case and before i say what it is please write your idea write your answer in the comments down below so what we are missing in these two cases is break at the end so here i'm missing a break like this and then here as well okay so now we have completed our switch case and if i run my program now as you can see for this first line we get the value of 5 which is our integer so this print function has printed the value of our integer and then in this second line we have printed out the value of a character and we have done that using this print function which receives a void pointer and then it receives a char variable which is called type and we use that char variable in order to differentiate which data type we are storing inside this void pointer because as i already said a void pointer can point to a variable of any data type but it cannot be dereferenced directly so for that we are using this type parameter to check which data type is stored inside this pointer here so now you have an idea on how to use void pointers but i would actually advise you to be very careful when using void pointers why because your compiler in this particular situation does not have a way to tell you hey you are trying to cast a void pointer which is actually an end pointer into a character or vice versa if you are doing that your compiler in this situation here does not have a way to know if you are making an error or not because inside a void pointer you can store the address of any variable so of a variable of any data type and then you can try to cast that void pointer into a pointer of any other data type which means for example in this particular situation here we are passing an integer so this number here is an integer which means that here for this line of code we are receiving an integer pointer okay and then in this case here we are trying to cast that into an integer pointer and that is okay but if we accidentally make a mistake here and we try to cast that into a character pointer for example like this our compiler now does not have a way to know that we are making a mistake here and if we run our program look at this we get this undefined symbol here which is what is this you know this is not the expected behavior of our program and we did not get a compiletime error which means that this here is completely valid so your compiler is not going to tell you that this here is an error but it actually is a logical error and those type of errors so logical errors are much harder to find inside programs and this here is a small program and it is kind of easy to find an error in a program that has 20 lines of code but if you had a logical error in a program that has 20 000 lies of lines of code for example you would have a very very big problem so again i strongly advise you to be very careful when you are using void pointers because as you see compiler is not uh reporting an error for this situation here but but this actually is an error so i'm going to return this to an integer pointer okay so i hope that you enjoyed this video and uh that you learned something new and if you did give it a thumbs up subscribe to my channel and thank you for watching i'm going to see you in my next video bye hi everyone welcome to my channel in this video i want to talk about pointers and arrays and if you watched the first video of this playlist you remember that i said that one of the common uses of pointers is using them with arrays so in this video i want to demonstrate how that works so let's jump straight to our visual studio and let's create an array of type end and i'm going to call that array lucky numbers like this and let's say that i have five lucky numbers for example and those are two three five seven nine oh that's five numbers already okay so these here are my lucky numbers and now i want to show you one thing so what is going to happen if i say for example c out lucky numbers and let's add a line so what is going to be written out if i write out just the name of my array let's check that if i run this program as you can see we get an address but what is this address this address here so the name of our array is actually the address of the first element of that array and in order to prove that let's write out the address of the first element of this array to check if these two are going to be the same so here i want to write out the address of the first element which is the element with index 0. so now if i'm telling the truth these two should be the same so if i run my program as you can see indeed we get the same address which means again the name of the array is the address of the first element of that array now that means that this lucky number's name behaves as a pointer and these square brackets here are behaving as a operator for dereferencing so if i say for example c out lucky numbers of 2 i'm going to get the element that has index 2. so this here is going to be the first address and then it is going to add two more addresses to that element and we are going to get the value that is stored there so lucky numbers name is the address of the first element it is going to add two more addresses to that so one two so this line of code here is going to give us the value of five let's add end line and run our program in order to demonstrate that and as you can see indeed we get the value of five now there is another way to do this same thing here and that is going to be the following way so i can say c out please write out this lucky numbers which as we already demonstrated is the address of this first element so i'm going to put that here and then i can use arithmetic operators on this so i can say please add to this lucky numbers two more address spaces and then dereference this so we use star symbol for that and then i'm going to add a line and these two lines of code so this one here and this one here should behave the same so if i run my program now as you can see we get the same value so these two lines of code are doing the same thing which means that this line of code here is using these square brackets in order to dereferentiate the element with that index which is index 2 and we know that the indexing starts with 0 so 0 1 2 and we get the value of 5 and then this second line of code here uses this star symbol in order to dereferentiate this expression here and what this expression here says it says lucky numbers which is the address of the first element as we demonstrated here so please use the address of the first element and then add two more address spaces to that so the address of the first element if i add two more to that it's going to be the address of one two so the address of this one here and then if i dereferentiate that i get this value which is stored on that address so these two lines of code are writing out the same thing so let me very quickly show you how you can enter the values for this array and then write them out because here we have hardcoded values so i'm going to delete this and i'm going to comment these two lines of code as well no actually i'm going to comment all of these because we don't need them anymore but i'm going to leave them for you so that you can see how these are used in order to dereferentiate your array so as i said we want to enter values for our array now so in order to do that i'm going to use for loop so i will say and then our for loop starts with i equal to 0 because that is the index of our first element and then considering that our array has 5 elements and the last one has index of 4 we are going to run our for loop while i is less than or equal to four and in each iteration we are going to increment the value of our i okay and in order to enter values for our array let's write out a message so i'm going to say see out number so please enter a number that is going to be the message for our user and then i'm going to input a value from my console into lucky numbers of i so this here means please enter the value into our lucky numbers array to element that has the same index that our i holds in that iteration so in the first iteration index 0 in the second iteration index 1 and then in the third iteration index 2 and so on so this for loop here is going to help us to enter the values into our lucky numbers array and in order to show that i'm going to put here a breakpoint and that means that our program is going to stop its execution when it comes to this line here so if i run my program as you can see it asks me to enter a number so i'm going to say 2 5 7 9 and 13. so those were five numbers that we had to enter for our lucky numbers array and if i press enter one more time as you can see our program has been stopped in this line of code here and if i hover over my lucky numbers here we have values that we have entered for our array so value of 2 5 7 9 and 13 which are the values that we have entered here so i'm going to stop my program now please stop okay and now what i want to do is i want to use this other approach to write out the numbers that this lucky numbers array is holding so let's use another for loop i'm going to copy this one okay and then what this second for loop is going to do it is just going to write out these numbers but okay let's use this approach for now so i'm going to just change this to c out and then use these other redirection signs and after each number i'm going to add an empty space okay like this and instead of using this approach here so instead of using these square brackets in order to differentiate the element on that position let's use this approach here so i'm going to say please use lucky numbers so which is the address of the first element and then to that i want to add the value of my i so plus i like this and this is going to move okay so this expression here is going to help us to access all of the elements of this lucky numbers array so from the one that has index 0 until we come to the one that has index four and because we don't want to write out addresses because this here is going to give us the address but we want to write out the values that are stored on those addresses we will have to dereference this expression here so for that i will use star symbol and i'm going to remove this breakpoint now and i'm going to start my program to see what is going to happen okay and let's enter 2 3 5 7 19 and as you can see we get values of 2 3 5 7 and 19 which we have entered okay let's stop this program now and there is one more thing that i want to show you what is going to happen if i change this max value from 4 to 5 like this so what is going to happen in this particular situation let's run our program and enter numbers again so 2 5 7 13 15. okay as you can see now here we have these five numbers that we have entered so 2 5 7 13 15 those are the ones here and then the last one is something that we do not recognize what is this this is some junk number that we definitely have not entered here so this number here is something that does not belong to our lucky numbers array and here we have accessed someone else's memory space so we have this result because we change the max value from 4 to 5 here and as we already know our lucky numbers has five elements the last one having the index of four which is this one here and then here we added one more iteration so now we are trying to access the element with index five and that element with index 5 does not belong or does not exist in our lucky numbers array so this element here this is memory location that belongs to someone else and we accessed that trying to dereferentiate the pointer to the element that is sixth element so we have five elements in our lucky numbers array and then if we add one more address space to that we get this here which is memory location that belongs to someone else and if we just randomly change and access memory locations that do not belong to us we can cause very very big problems so i advise you to be very careful when iterating through your arrays and to access only memory locations that belong to that array that you are iterating so indicates that your array has five elements that those are going to be from zero to four so indexes from zero to four in the case that your array has ten elements for example those are going to be indexes zero to nine and so on so again be very very careful to not access memory locations that do not belong to you so i hope that now you have an idea on how pointers and arrays go together and as well we have seen some of the potential problems that can happen if you are not careful enough when working with pointers and arrays so again i advise you to be very careful uh when working with pointers and arrays and not access memory locations memory addresses that do not belong to you so thank you for watching and i'm going to see you in my next video bye in this video i want to explain how you can use pointers in order to return multiple values from a function so i said in the first video of this playlist that using pointers to return multiple values from a function is a very common use for pointers so in this video i want to demonstrate how that works so here we are going to create an array of numbers and then first i want to create two functions and one of those two is going to return me the smallest number in that array and then the other one is going to return me the largest number in that array and then in the second part of this video i want to show you how you can use pointers in order to get both smallest and largest number using one function only so you can return both of these numbers so min number and max number using only one function and that is going to be with the help of pointers so let's start with this example as i already said i'm going to create an array of numbers so um those are going to be numbers of type int and let's call this array numbers like this and it is going to be array of five numbers and let's assign them values of for example 5 4 minus 2 29 and 6 for example so those are going to be my numbers okay and now let's create a function that is going to return the smallest number of this array so i'm going to create that function here and let's give it the return type of end and i'm going to call it get min like this and what i will need to pass to this function is going to be array so this array here so i'm going to say int numbers array so this is going to be the first argument and then the second one is going to be the size of this array so i'm going to say int size and we will use this second parameter here so that we know how many iterations we have to make in order to go through all of the elements of this array so let's define this function the first thing that i want to do is i want to create a variable of type int and that variable is going to be called min so this is going to be the variable that is going to hold the minimal value so the smallest number in this array and initially i want to assign to this variable the first element of this array so i'm going to say that the smallest element initially is going to be the first one so i'm going to say numbers of zero and then we are going to iterate through all of the other elements and each time that we find an element that is smaller than the current value of our min we are going to store that value in our min so let's do that so i'm going to say 4 and since we have already stored the value of our first element in our min we do not need to iterate through that so i'm going to say that my int initially has the value of one okay oh and i is equal to one like this and then our for loop is going to iterate while our i is less than the size of this array so in this particular situation while our i is less than 5 and in each iteration we want to increment our i like this so as i already said if we find a number on a specific position which is in this current situation uh the position with the index of i if we determine that that number is smaller than our min number like this we are going to store that number in our min variable so i'm going to say min is equal to numbers of i so that at the end of this for loop in our min variable is going to be the smallest number of this array so at the end of this for loop here we can return our min like this okay so now in order to test this function here i'm going to invoke it let's say get actually i'm going to write it out i'm going to say see out min is like this and then let's invoke it let's say get min like this and this get main function receives array so let's pass it numbers array and then it receives the size of this array and this array has one two three four five elements and you can check that here as well so we are going to pass five here okay and if i run this program as you can see it says min is minus two which really is the smallest number in our array so that is going to be the first function and then the second function that i want to create is going to be the one that is going to return the largest number in our array so let's copy this function i'm going to copy it and then just modify it a little bit so the name of that other function is going to be get max like this and then that function as well will receive numbers array and the size but here we are going to have variable which is called max instead of min and again we will assign it the value of our first element so then we iterate through all of these elements so starting with the second element because first the value of the first one we already have inside this variable so we do not need to check that but if we find in these remaining elements if we find element that is larger so bigger than our max let's copy this here we are going to store the value of that element in our max variable like this and then at the end we will return our max variable okay so now in order to test this function i will invoke it as we did with this previous one i'm i will just say max is and then invoke get max like this and i'm going to add two end lines here so that we have output which is formatted nicely and if i run my program now as you can see it says min is minus 2 and then max is 29 which is correct so let's explain one more time the algorithm that we are using here in order to determine the biggest number of our array so here in this first line i say that the biggest number is the one with the index zero so the first one and then here we iterate through all of the remaining elements and that is from the one with index one until the last one and if we find that any of those remaining numbers is greater than our max number then we say that our max number is equal to that number so at the end of this for loop we will have in our max variable the largest number of this array here okay and we have accomplished to get our min number and then our max number using these two functions oh i'm sorry so using this get min and then get max function as well so now what i want to show you is how you can use one function only to get both min and max number so let's do that let's create a function which we will name void get min and max like this and this function is going to receive like these two previous functions our numbers array and the size of the array and then considering that we want to return two values from our function we will have to pass those two values by a reference which means we will have to pass the addresses of the two values and then this function here is going to change the value that is stored on those two addresses and this function here our main function is going to have the access to those two addresses as well so once this function here assigns the value of min and max numbers to those two addresses our main function is going to be able to access those values so as i said let's pass to this function as well int min like this and then int max so we are receiving here pointer to a min number and then pointer to a max number okay so the job of this function will be very similar to the jobs of the two functions that we just created so i will just copy this and then paste it here and once more we are iterating through all of the numbers of our numbers array and then here we say if you find any number which is greater than our max number and here we have an error which says operand types are incompatible so int and int pointer which means that here we have to dereference this pointer using the star symbol so if you find any number which is greater than our current max please store that number inside our max like this and then i'm going to copy this code one more time for our min number so i will say if you find any number which is smaller than our min number like this please assign that number to my min number like this so this is going to be the work that this function will do and considering that this function is receiving these two so min and max as pointers this means that this function is directly going to modify the values that are stored on these addresses and those same addresses are going to be available in our main function which means that once this function changes the values that are stored on our max and our min address this main function here will be able to access those changed values and using pointers in that way we have achieved to return multiple values from our function so let's invoke this get min and max in order to test what i just said so i'm going to comment these two lines of code because we do not need them anymore and because here we have to pass min and max we will have to create those two variables here as well so i will say int min and as we did before i'm going to assign to this min the value of my first element like this okay and then i will create max variable as well and assign to my max variable value of my first element as well and now let's invoke this get min and max function so let's say get min and max and let's pass it parameters that it needs so the first one is numbers array so i will say numbers and then second parameter is size of that array so five and then it expects to receive two pointers so min and max and we will have to pass addresses of our main and then address of our max as well like this and this here is called passing a parameter using a reference so that means pass an address of a variable to your function rather than passing variable itself because then if you don't pass an address your function is going to create a copy and whatever changes your function makes with that copy you will not be able to see those changes in your main function so in this way we are passing addresses which means that this function here is operating on the original addresses which this function here is accessing as well so when this function here changes the values that are stored on those addresses this function here will know so that means that now if i try to write out oh i will need to add semicolumn here at the end okay so that means now if we try to write out our min like this min is and then min and then if we try to write out our max as well max we will get values of 2 and 29 at least we expect to get those two values if this function is working correctly so if i run my program as you can see we really have values of minus two let me just um collapse this so we really have values of 2 and 29 as the smallest and the largest number in our array and we have achieved that using this pass by a reference so by passing addresses of our variables to our function which our function then changes the values that are stored on those addresses and since this main function as well has the access to those same addresses that means that our main function can see the changes that have been made on those addresses so i hope that now you have an idea how to return multiple values from a function using pointers so if you enjoyed this video if you learned something new give it a thumbs up and also subscribe to my channel press the bell icon as well thank you for watching and i'm going to see you in my next video bye in this video i want to talk about dynamic arrays so you should already be familiar with the idea of arrays and the concept of fixed arrays from my previous videos but for those of you that really want to understand the need for dynamic arrays i will go through some of the advantages and disadvantages of fixed arrays so that you can really understand where the need for dynamic arrays arised so we said that an array is type of collection which stores elements in continuous memory now that means that it stores elements one after the other so if i do this for example if i say let's create an integer array of five elements and let's call that array my array like this your computer in the background will do the following it will give to this array here five containers of type int and those containers will be one after the other in memory so that means because the array stores data in a continuous memory so one after the other accessing that data will be very very fast so because the name of the array is the address of the first element of that array when you specify the name of the array and then you give it the index of the element that you want to access it is going to be very fast to move from that first element until that position they choose specified so until the element that has a debt index whereas if you use some other collection type like linked list for example which stores data in noncontinuous memory which means in a random places and memory and then each element contains a pointer to the previous one and to the next one accessing elements in those type of collections would be much slower so if you wanted to access fifth element of linked list you would have to traverse the first four elements and then get to the fifth one because they are stored in noncontinuous memory meaning they are randomly in your memory so as i already said accessing elements of an array is a very very fast operation but because your array stores data in continuous memory this has certain disadvantages as well so what happens if you want to insert or delete an element in the middle of the array for example so how can you insert or delete an element in the middle of the array without breaking that continuousness if i can say it like that so you get a point that means that the operation of inserting and deleting elements in an array is going to be much slower than inserting elements in a linked list for example and if you want me to do a video which is related to differences between linked lists and arrays for example write it in the comments down below and i will make it in the future when i find time so again if you are not familiar with the basics of arrays i recommend you to watch my first video which is related to arrays and pointers which i will link here and then you come back to this one so those were some advantages and disadvantages of arrays and it will be up to you to decide which collection you want to use however here i want to give you the biggest disadvantage or the biggest obstacle that we encountered so far when working with arrays and that is the following so the size of the array had to be constant which means that the size of the array had to be known before we even started our program so we always kind of wanted to do this so we wanted to say int size and then we wanted to ask our user to enter the size so please enter the size for the array and then after our user enters the size for the array we wanted to create the array that is of that size that our user specified however we get the error as you can see here it says expression must have a constant value which confirms what i just said which is that the size of the array had to be known at compile time so the size of the array could not be changed once we declared and we had to declare it before we even started our program so this problem was without solution so far but surprise surprise if you know how to work with dynamic arrays and dynamic memory you can very easily create an array and runtime so in c plus plus there are two keywords or two commands which allow you to allocate and deallocate dynamic memory which means to get yourself dynamic memory when you need it and then free that memory once you don't so that it can be reused that is what allocate and deallocate means and those two commands are new and delete so new allocates memory as you may guess and then delete deallocates that memory or freeze it once you don't need it so let's see how we can use this information that i just gave you on our example so instead of doing this here i will comment it because we do not need it instead of doing this what i will do is i will create a pointer like this and let's call that pointer my array and what i want to assign to this pointer will be the following i will say please make this pointer point to new integer array and the size of that array will be the size that our user entered like this okay and as you can see our compiler is fine with this expression here we do not have an error so this new keyword has allocated an array of this size that our user has specified and that array the address of the first element of that array is stored in this my array pointer so if i build this code as you can see we do not have compile time errors so what i want to show you now is how we can enter elements for this array and then how we can write them out and this is array again this is array which is created at runtime so our user will specify the size of this array which is something that we were not able to do before we learned how to use dynamic arrays so in order to enter elements for this array here as we already know we will be using for loop so i will say four please iterate from the element which has index zero until you come to the element that has the index of this size okay and then in each iteration increase our counter by one and what i want to do is i want to write out a message for my user so i will say array and then let's add index of the current element index that our user is entering so i like this okay and then what i want to do is i just want to enter an element on that position that we are currently iterating so i will say my array of i like this so using this code here we should be able to enter elements in this array here and then in order to write these elements out what i will do is i will use another for loop so i will just copy this one and then paste it here and in this particular situation i just want to write out so i will use c out command and then these other redirection signs so i just want to write out all the elements of the array and i will add a few empty spaces after each element so that we have a nicely formatted output so this loop here should write out the elements of our array and if i start this program now as you can see it asks us to enter the size of the array so let's say 5 for example and now we are we are entering element with index 0 so let's say 2 5 7 9 and let's say 11 okay and as you can see here we have the elements of our array written out and we wouldn't be able to do this if we didn't know how to work with dynamic arrays so let's stop this program and there is one more thing that i want to mention and that is following these square brackets here are only one way to dereference your array another way to dereference the array or to to access the element on a specific position is the following so so the other way to access the element on a specific position would be using this asterisk symbol and then here you say my array plus i now because the name of the array is the address of the first element here you have the address of the first element and then when you add a certain number to that it will move that many spaces in memory and then access the element on that position and when you dereference that you will get the value of that element instead of its address so here is one way to dereference your array and then here is another way to dereference your array and you can use whichever one you prefer and if i run this program again just to demonstrate that it works the same let's say three and then one five ten okay we get one five ten as the elements of our array one very important thing that i mentioned at the beginning is that we have two commands for working with dynamic memory and one of those two commands is new so we said that new is a command which will allocate memory for us when we need it and then another one is going to be delete and delete is a command which will deallocate that memory when we do not need it so that it can be reused now using dynamic memory comes with a responsibility and that responsibility is the following each time that you allocate memory when you need it you will have to deallocate that memory once you don't so that that memory can be reused so that means that each time that you write new command you will have to write the lead command once you don't need that memory anymore so i will demonstrate how can you deallocate the memory that we have allocated for this my array so let's say that here in this line of code we do not need our array anymore so how can i deallocate the memory that i allocated for this array while using delete keyword and i will say please delete the memory that i allocated for my array which is called my array like this and you have to specify these square brackets because that is the way that you allocated memory so here you said i want new array and then here you have to say please delete that array and a good practice is to do the following as well so you can say my array is equal to null like this and let me collapse this so this here is going to assign the value of null to your array so your array will not point to anything to any address at this line of code so why do we do this because in the previous line of code we have deallocated this array here and now in this line of code here your array will point to a location in memory which does not belong to you so it does not belong to your program and because of that because we do not want to cause some accidental crashes or problems in our program by having this array pointing to memory locations which are not ours anymore it is a good practice to say that our array is now equal to null which means that it is not pointing to anything so as i already said and i repeat again when you use dynamic memory each time that you write new you will have to write delete that corresponds to that new so here i have allocated an array and here i am deallocating that array so i hope that this video was helpful and that this video helped you understand what are dynamic arrays and how they work and now that i have explained this it opened the whole world of new possibilities and new things that you can do with dynamic arrays and i will leave to you to play and discover those new things until my next video of course so thank you for watching this video give it a thumbs up if you liked it subscribe to my channel click the bell icon as well and i'm going to see you in my next video bye in this video i want to talk about a topic that confuses many students and that is the topic of multidimensional dynamic arrays and the topics like this one are the reason why many people step away from learning c plus and they believe that learning c plus plus is hard but what i think is that many of those people never actually had the opportunity to have this explained in a very simple way so that is what i will try to do in this video so with the help of excel i will try to draw what are multidimensional dynamic arrays and how they work and i hope that at the end of this video you will have it pretty clear and you will be able to create and work with your own multidimensional dynamic arrays so what a multidimensional array is in simple words it is array of arrays and in this video you will learn how to create twodimensional dynamic arrays and in order to be able to understand this topic you should be familiar with the topic of dynamic arrays which is a video that i already did on my channel and i will link it here so make sure to watch that video before watching this one so i will very quickly remind us all of how dynamic arrays work and then we will see how we can use that knowledge to understand multidimensional dynamic arrays so let's create a visual representation of a dynamic array in our excel sheet so let's say that it will be array of four elements like this this is our array and the indexes of these elements start with zero and then one two three so these are the indexes and then the address of this first element will be for example 0 0 0 0 a a like this and this address here it is the address of the first element but it is the address of the array itself as well and you should be familiar with that so this here is our dynamic memory and then on our stack which will be here let's create our stack so this here will be our static memory here we will have to create a pointer variable which will hold the address to this element here or actually the address to the array itself so i will create a variable let's call it ptr1 so this is going going to be our pointer one and as we already said that pointer will hold the address of the first element of this array let's copy that address like this and then we will store that address in our ptr one now if we wanted to create more arrays by the knowledge that we have so far we would have to copy this and then let's paste it here and let's create one more array like this so now we have three dynamic arrays and the first element of the first array has the address of 0 0 0 0 a a and then this one here let's say that it has the address of bb for example and then this one here has the address of 0 0 0 0 cc and to be able to access these arrays we would have to create on our stack two more pointers so let's do that okay so our pointer two will hold the address of the second array which is zero zero zero zero db and then our pointer three would hold the address of our third array which is 0 0 0 0 cc like this now with this we have created three dynamic arrays and in order to create those three dynamic arrays we had to create three pointers so those are these three here and this is something that you should already be familiar with so you should already know from my previous video how to create a dynamic array now one thing that i see here and that is a problem is that if we wanted to create four or five or a hundred of these dynamic arrays we would have to create that number of pointers on our stack which means that this part here is not dynamic only this part here is dynamic because here our user determines how many elements this dynamic array will have but for each of these dynamic arrays we have to manually create a pointer on our stack which will hold the address of that array okay now what happens if i want to move this part here to our dynamic memory as well so let's do that let me cut it from here and then i will paste it here for example so now i have moved this part to dynamic memory as well and as you can see here this kind of looks like an array as well so that means that this first element if we look at this as an array the first element will have index of zero and then second we'll have index of one and then third will have oh this won't move third we'll have index of two okay so this is an array that has three elements and the first element for example has the address of 0 0 e e e e like this so now this part here is dynamic and then this part here is dynamic and in order to be able to access this array here what we have to do is on our stack which is this part here we will have to create a pointer which will hold the address of this first element so let's do that let me just okay now as i already said on our stack we will have to create a pointer which will hold the address of this first element so let's call that pointer table for example and this table will hold the address of this element here which is 0 0 ee and this table because it holds the address it should be a pointer but one thing to keep in mind is that this variable here is not a simple variable but this here is a pointer as well which means that this table will not be a simple pointer but it will be a pointer to a pointer and you indicate that using two asterisk symbols because one is just a pointer and then two mean a pointer to a pointer why because this table holds the address of the element which is this one here and that element is pointer as well okay now if we look at this here as you can see we have one array that represents the number of rows that our table will have okay so one two three and then for each one of the elements of this array here we create a separate dynamic array like this so this here will be our table that has the number of rows that our user defines and then however many columns our user defines as well and in this particular situation it is a table that has three rows so these are three rows and then four columns so let's now translate this to our c plus plus code and because we said that now our user defines how many rows this table will have and then how many columns as well that is the first thing that i will do so i will create two variables let's call them inch rows and columns and then i will ask my user to enter how many rows and how many columns he wants this table to have so let's do that see in rows o and then columns like this okay now after our user has entered how many rows and columns he wants what i want to do now is this part here so this part here this is our first step and then this here is going to be our second step and this part here will be the third step so this part here will be the following when translated to c plus code so here as i already said i create a pointer to a pointer which i will call table so i will say please create an integer pointer to a pointer because here we will store integer values you can create a character or double or float whichever one you want i want to create integer pointer to a pointer and call that table like this okay so we are done with this first part here and then what this table pointer to a pointer will point to is going to be this array here so i will say please create a new integer array that has this many elements so the number that our user has entered for this rows variable because this rows variable holds how many elements this array here will have but as you can see here we have an error and that error is happening because this here which is this array here is not just a simple integer array but it is array of pointers so here you will have to indicate that so you will have to say please create an integer array of pointers and as you can see now our error has disappeared and with this line of code here we have created this array here now our third step is going to be that for each element of this array here we would have to create a separate dynamic array so this first element will hold the address of this dynamic array and then the second element holds the address of this array and then disturbed the address of this array here so what i will have to do is i will have to iterate through all the elements of this array and for each one i will have to create a separate dynamic array so let's do that so i will say 4 and i is equal to 0 and then i is less than the number of rows that our user entered and in each iteration increment i so in this particular situation our number of rows is equal to three but you can have as many as you want so what i want to do in each of these iterations is i want to create for each one of these elements a separate dynamic array so i will say table of i is equal to new integer array that has this many elements and that is the number that we stored in our columns variable like this and with this code here we have successfully created these dynamic arrays now how do you access elements on a specific position of this table here for example this one or this one or this one so in order to do that let's say for example table of row one and then column two will have the value of 88. now what this code here what this line here will do is the following so this part here it says please give me the table variable which is this one here and it is a pointer to a pointer which holds this address here so 0 0 e e e and that address is the address of this element here so the address of this array and here we say please give me the element of that array that has index 1 which is this element here so it is the element that stores the address of 0 0 0 0 bb which is the address of this array here and this second part says please give me the element of that array that has the index of 2 which is this element here so here we will store the value of 88 so that is what this line of code here will do it will store number 88 to this position here so this line of code here will store this number at the element that has row index 1 and column index 2 of this table so this here is a row with index 0 this here 0 with index 1 and then 2 so we are storing at this row and then column index 2 is this one here so here we store number 88 one thing that we said as well in my previous video is that each time that you allocate dynamic memory you have the responsibility to deallocate that memory when you don't need it which means each time that you use new keyword you will have to use delete keyword when you don't need that memory anymore so now is the question how do we deallocate all of this memory that we have taken so in order to do that what i want to do is i want to show you something if for some reason we lose this address here so the value that is stored in this table pointer to a pointer we will never be able to access all of these elements that we have created in our dynamic memory so that means that we will not be deallocating this first and then if we for some reason lost this the value of our zero zero zero zero a a for example that means that we would never be able to access this array here so we would never be able to deallocate this memory so that means that this is not going to be deallocated first as well now a location of this memory here went as follows this was the first step so this was the first thing that we allocated and it is this code here and then we allocated this so that corresponds to this part here and then the last thing to allocate was these arrays here and that corresponds to this part of the code and the allocation of this memory will go the other way around which means that first we will deallocate this and then we will deallocate this and then this will be the last thing that we will have to worry about now in order to deallocate this the process will be almost the same as the one when we allocated it so i will copy this for loop and then paste it here but what i want to do in this particular situation so when d allocating is instead of creating a new dynamic array for each table of i is i want to delete that array so for each element of this array here i want to delete the corresponding dynamic array so i want to delete these three arrays and in order to do that i will say please delete the array that my table of i is pointing to now what this code here will do is for this element here it will deallocate this array here so let's delete that and then for this element here it will deallocate this array and then for this one it will be allocate this array here so now we have successfully freed this memory that we have taken here now after we have done this after we have successfully deallocated our first step which was here this part here will be our second thing to deallocate so here i will say please delete the array that my table variable is pointing to so this line of code here will deallocate this part here so i will say please delete that we do not need it anymore okay and then our third step which is the last one will be to null this value here why because we have just freed the memory that was here so we have deallocated that now someone else might be using this memory here and we really shouldn't keep the address of someone else's memory so we should make this a null value like this and in order to do this in our code i will just say now my table will hold the value of null like this and this will prevent some potential crashes and problems in your application so i hope that this video helped you understand multidimensional dynamic arrays a bit better and if it did please give it a thumbs up and subscribe to my channel because that helps me to reach more people and hopefully make programming a little bit easier for them as well thank you very much for watching and i'm going to see you in my next video bye so i get a lot of messages a lot of questions on my instagram on twitter and then here on youtube as well in the comments where you ask me for an opinion or for advice on certain errors that happen to you in programming and i try to answer as many of those as possible but it's just not possible to answer to all of you and i'm very very sorry but i thought that it would be a good idea to make a video related to that so that all of you can see it so here i am i'm making that video right now so in this video i will be reviewing some code and we will see some errors that can happen and that do happen very often and i'm going to do that both manually and then i want to show you a very cool tool which is called pvs studio i'm going to leave details in the description down below so that you can check it out for yourself but what pvs studio is it is static code analyzer so it is basically a tool that reviews your code and helps you detect bugs and errors and security weaknesses in your code so in the case that you need another pair of eyes to look at your code and give you a few tips and recommendations it is a great tool to use and you can get it as a team license for teams up to nine people or you can get an enterprise license for bigger companies bigger departments or you can even request a free license if you are a student if you are working on some private projects or on some open source projects and then one very cool thing is that it is not only used to analyze c plus code but you can use it for c and then c sharp and java as well uh and i am wondering guys which team are you in are you team c plus plus or are you team c sharp or java or c um i'm very curious to read your answers so please write me in the comments down below and if you ask me i'm definitely team c plus plus and then team c sharp those are just two of my favorite languages ever but i am very curious to read what you will answer to this question so um i'm going to leave all the details about pvstudio in the description of this video so that you can check it out for yourself and let's jump into the coding part right now because i am very very excited to do this here i have created a new project and i have this program that does basically nothing so what i want to do is i want to check if everything is okay with this code so far so if we have made any errors so far so i'm going to click on extensions and then pvstudio and here you have multiple options you can check your current file you can check open files or you can check your project selected items solution i'm going to select this first option so i'm going to check this current file and you get this window here and as you can see we have one error and that error is that my license will expire in five days okay so that is not here which is related to our code so we are just going to ignore it so we don't have code errors so far and let me show you how you can install this tool very quickly so you click on extensions and then manage extensions okay and then here you can search for pvs studio like this okay great it is this one here so pbs studio is a tool for detecting bugs and security weaknesses and so on okay so you will click download here and your download should begin i'm not going to do that right now because i already have it but once it is downloaded the installation is pretty simple so it's basically next next next finish installation so that should be simple okay now let's close this window here and as you could see we don't have any errors with this code so far so let's write some code and let's create some errors now so let's create an array of type int and i will call it saved money and that will be array of five elements and i want to initialize those elements here so the purpose of this array is following let's say that i want to save some money each month and i want to store that data in this array here so i'm going to save money for five months and i will store how much money i have saved each month inside this array here so for example the first month i have saved 100 or euros or whatever and then second month i have saved 200 and then 300 and 400 and 500 fifth month okay so this is our array now what i want to do with this data here is i want to sum it after five months i want to know how much money i have saved in total so i'm going to create a variable of type int and i will call it total like this and i will initially give it a value of 0 and then i will iterate through this array here so i will say 4 and i is equal to 0 and then i is less than or equal to 5 and then i plus plus and what i will do inside this for loop is i will say that my total will hold whatever my total was previously holding plus current value of how much money i have saved in that month so save money off i okay now after i have done this i will just write out how much money i have in total so i will say total and then this value that is stored inside this variable here okay now if i run this program let's see what will happen well it says that in total i have minus 8 billion something very very big number so i have tried to save each month and then at the end i have minus 8 billion dollars you know so that does not make any sense so here we have a logical error okay so let's see what is this error that is happening so let's click on extensions and pvs studio check current file to see what kind of error pvstudio sees and it says array over run as possible the value of i index could reach five and if i double click on that it will take me here and this part of code here is underlined and this is actually our compiler our compiler is underlying this and it says that okay it says index five is out of valid index range of zero to four so this here this situation here says that this i is out of range of valid indexes that this array here can have and if you are familiar with arrays you know that indexing of an array starts with zero so the first element has index of zero and then one two three and four so valid indexes for this array here are from 0 to 4 and here we have accidentally written that this i is less than or equal to 5 and that is making a problem so if i delete this part here so if i say that my i is just less than 5 this error should disappear so if i click on pvs studio and then check current file the error should disappear okay it has disappeared now so if i run my program this program is behaving as expected so this is one thing that very often happens you can accidentally write less than or equal to and then you can get a very very big logical error another thing that can happen is if you are typing very quickly and if you lose concentration for a moment and here instead of incrementing you decrement this counter so you say i minus minus you should get an error as well so if i try to build this program let's see what our compiler will tell us so here in this error list it says ill defined for loop counts down from minimum so that's kind of helpful information and then another let's read this other warning it says reading invalid data from saved memory the readable size is 20 bytes but minus 4 bytes maybe a read so this is not really helpful for someone who is just starting and then this third message it says index minus 2 billion something is out of valid index range 0 to 4. again this is not really helpful for someone who is just starting so let's see what our pvs studio has to say so i'm going to click extensions pbs studio check current file okay and this first error here says the condition i less than 5 of for loop is always true so this is actually a helpful message and if i click on this i will be taken here and it says that this condition here i is less than five is always true but why is it always true because we have started counting at zero and then we try to decrement that value in each iteration and uh doing that we can never reach this condition here this condition here will never become false so that means that here we have created an infinite loop and here our previous studio says consider inspecting this for operators so consider inspecting this for loop here because it will not be executed at all or it can be executed incorrectly and in this particular situation it is going to be executed incorrectly so it is going to be an infinite loop which we don't want in this particular situation so i'm going to correct this error here so i'm going to return it to i plus plus but that is sort of a help that you can get from pvs studio and this here is a pretty simple program because it has just a few lines of code where all the bugs can potentially happen but imagine working on a very very big project and then something like this happens so imagine something like this happening on a program that a bank uses so you are trying to save money for a couple of months and then the program says that you are in debt that your balance is minus 2 000 or 20 000 or something like this so this can create very very big issues and in this particular situation if you have a bug like this you will want to have all the help that you can get and sometimes that can be just the help that you get from your compiler or if you have a very very big problem you will definitely benefit from tools like pvs studio which will give you some additional information on that situation that is happening and on that problem that you are having and then there are other situations where you can have very very big problems but your compiler will not be helpful at all because your compiler will not be able to see those potential bugs that you are creating inside your code so in order to demonstrate that let's delete all of this code here because i will not need it anymore and what i do need is to create a function here so let's create a function of return type void and i'm going to call it my function like this okay and what i want to do inside this function is i want to create an integer pointer ptr so if you are not familiar with the topic of pointers make sure to watch the playlist that i will link here it is a playlist where i explain pointers in c plus because it is one of the most important topics in c plus plus and it is the example that i will be using here so i have created an integer pointer and i'm going to say now you will point to a new array of integers and that array will have five elements like this now what do i want to do with this array well let's do something very simple let's say ptr of 2 will hold the value okay it will hold the value of 10 like this and then let's just write out something let's say hi i am equal to and then ptr of two okay so this here is pretty simple example that does basically nothing important nothing useful but i will use it to demonstrate a very very big issue that can happen in this situation so i'm going to invoke this function here so i'm going to say my function like this and i have successfully invoked this function so if i run this program it says hi i am 10. so nothing unexpected happened or did it okay if i inspect my errors list it says that i don't have any errors so if you ask a compiler it will tell you that everything is perfectly fine so let's now ask pbs studio here it has already detected two potential issues but you can click pdf studio and then check current file just to be sure okay and it says visibility scope of the ptr pointer was exited without releasing the memory a memory leak is possible so what we have done here in this program is we have created memory leak where here so here we have said please give me in my dynamic memory give me array of five integers and this is going to be done in dynamic memory so once this function is finished once this function ends we are going to lose this ptr so we are going to lose the address of the first element of this array here so here if i try to do something like ptr i cannot access this variable here anymore this variable has its scope and that scope is inside this function here and once this function exits we are going to lose the address of this array here which means that we will not be able to deallocate this memory here now let's delete this okay here as you can see this memory leak is not a big memory leak here we are leaking five integers so we are leaking an array of five integers and that is not very big problem but usually what happens in real life is that you are not creating an array of five integers usually you are creating things that require much more memory than just an integer array of five elements so here as i said we are leaking five integers but imagine a situation where you're creating an array of 5000 or 50 000 and not integers but objects of type user like this and this user has some pretty heavy data in it for example it has some images and things like that so here you are creating 50 000 users and to make things worse imagine not invoking this function only once but imagine invoking this function in a for loop for example so invoking it 100 times or 1000 times or 100 000 times that is going to be a huge memory leak so what this line of code here does is it asks your operating system for dynamic memory so it says please can you give me new memory so can you give me dynamic memory that i need to store this data here and your operating system gives that memory to your program so it allocates that memory for your program and then once this function here finishes you will lose all the variables that you have created inside that function and that is this ptr variable here so that means that the address of this array here which was stored inside this ptr variable is lost now and now you will not be able to deallocate this memory here which means that you will not be able to say okay now i am done with this memory which is a lot of memory and now i'm going to return that back to my operating system because i don't have unlimited amounts of memory and my operating system maybe would like to give that memory to some other program so once this function here ends and you don't deallocate this memory here you are leaking that memory and that is exactly the error that you have here it says a memory leak is possible whereas your compiler here said expected a type specifier which is uh error that we have here because it does not know what is this user so i'm going to return this back to int okay now that error has disappeared but your compiler does not know that you are leaking memory here whereas your previous studio analyzer here says that a memory leak is happening so how do you fix this error here well for each new you need to have delete again you need to watch my c plus pointers playlist in order to understand pointers if you don't understand this already so as i said for each new you need to have delete so i'm going to say delete and let's delete this ptr let's see what is going to happen now so if i click extensions and then pvstudio check current file it says the memory was allocated using new array type operator but it was released using delete operator and then it gives you a recommendation here it says use delete array pointer etc instead so here we are trying to allocate memory for an array but we are not deleting that entire array so here we are leaking memory again so here i'm going to use these square brackets in order to indicate that i want to delete this entire array that i have allocated in this line of code here so now we shouldn't be leaking memory anymore so let's check that out i'm going to say pbs studio chat current file and let's see we have that error that we previously had which is your license will expire in five days but we do not have memory leaks anymore which is great so errors like this memory leaks are very common when you work with pointers in c plus and these memory leaks can create huge problems if you have them in your code and as you could already see in most cases you cannot really count on your compiler to tell you that you are leaking memory because in most cases it will not even be able to see that so tools like pvs studio can be very helpful in those situations you could see all those little tips and recommendations that we had from pvstudio that helped us to fix issues that we had related to leaking memory so those were some topics that i wanted to address in this video because many people when working with pointers will come across problems that they will not be able to fix or they will not even be aware that they have those problems that they have memory leaks until it gets to the point where it is unmanageable and they have very big problem they have huge problem so if you have any more questions that you would like me to make video on please leave those in the comments down below and if you like this type of video please give this video a thumbs up so that i can know and i will make more videos like this in the future if you want me to so thank you very much for watching this video and i am going to see you in my next video bye hi everyone and welcome to my channel in this video i want to teach you about function pointers in c plus plus many beginners think that function pointers are extremely hard to understand and to be honest um the syntax is one of the ugliest things that you are going to see in c plus language but in this video i decided to simplify it and to make it understandable for every single beginner so in this video you are going to learn how to use function pointers and why they exist what is their purpose the first thing that i want to explain related to function pointers is what are function pointers and then later in the video i'm going to explain what is their purpose why do they exist and i'm also going to leave timestamps in the description that you can use in order to navigate yourself to the desired part of the video but i highly recommend you to watch the entire video if you really want to understand what are function pointers so um in order to understand what are function pointers you first need to understand what is a pointer and in the beginning of this playlist in the first video we already said that a pointer is a special type of variable that is used in order to store the address of another variable now a function pointer is very similar but instead of storing the address of a variable a function pointer stores the address of a function so let's demonstrate how that works in visual studio so let's create a function of return type int let's call it get number and from this function i just want to return number five like this and it is very easy to predict what is going to happen if i say get number and then i run my program okay we get the value of five written in our console okay now one question that i have for you is what is going to happen if i remove these parentheses so what kind of output do you expect to get in the console write me in the comments so if i run my program now as you can see we get an address so what kind of address this is this is the address of our function and now that we learned that the name of the function will give you its address what we can do is we can create a function pointer and then we can assign the address of that function to a function pointer so let's stop our program and let's do that i am going to remove this line of code i don't need it anymore and now i'm going to show you how you can create a function pointer the syntax is pretty hard so pay attention the first thing that you need to do in order to create a function pointer is use these parentheses and then inside parentheses you will put asterix symbol and you will give the name to your function pointer so let's call it func ptr so function pointer that is the first part the second part is to put the return type of your function in front of the name so here since i want to point to this function here the return type is int so i'm going to put int here and then the third part is to put the parameters that your function receives after the name of your function pointer and that is here so you are going to put parentheses and inside these parentheses you would put the list of parameters that your function receives but since this function here does not receive any parameter these parentheses are going to be empty okay and with this we have successfully created a function pointer that can point to any function that returns int and it does not receive any parameter and that is for example this function here so what i can do now is i can say that my function pointer will point to get number function and as we already saw this getnumber function will give us the address of this function here so what i can do now is i can use this function pointer in order to invoke this function so i can say c out func ptr like this so the approach is absolutely the same as invoking that function directly but instead of using the name of the function you just use the name of the function pointer so if i run the program as you can see we are going to get the value of five but we have invoked this getnumber function by using a function pointer okay so let me show you one more time how you can create a function pointer but this time i want to show you how you can do that for a function that actually receives parameters so let's delete all of this code like this and let's create another function so let's create a function that returns int let's call it add and this function will receive int a and then int b and the task of this function will be to sum these two numbers and then to return the result so i'm going to say return a plus b like this so how can we invoke this function by using a function pointer well let's again repeat how we can create a function pointer so one more time you use parentheses and then inside parentheses you are going to put asterisk symbol to indicate that you want to create a pointer and then you will give a name to your pointer you will call it func ptr for example and then two more things the first one is to put the return type of your function in front so end because we want to point to this function here and then the second part is to put parameters after the name of your function pointer so here and here inside these parentheses i will put int and then int because this add function receives two parameters and those are integer and integer so now we have created a function pointer that can point to any function that returns integer and receives two integers and that is this function here so i can now say that my function pointer will hold the address of add function and if i want to invoke this function there are two ways to do that so i can either say c out add and then let's pass two numbers let's say for example two and three let's add end line and then second way to invoke this same function is by using this function pointer so i can say c out and then func ptr and here i'm going to use the same approach of passing parameters like i did here so i'm going to say for example three and four and let's add end line here as well so if i run my program let's see what is going to happen okay for this first line we get the result of five so two plus three is five and then for this second line we get the result of seven so three plus four is seven so this is how you can create a function pointer and then this is how you can invoke that function by using its function pointer okay now that you have seen and understood what i just explained your question might be salvina why would anyone want to create a function pointer just to be able to invoke that function because it is so much easier to do that directly and the answer to your question is you are absolutely right but this is not the purpose of function pointers this is not the reason why function pointers exist so let's talk about the real purpose of function pointers why they exist and when we can use function pointers one of the most common uses of function pointers is we use a function pointer in order to be able to pass a function as an argument or as a parameter to another function and we do this in order to optimize our code so in order to make our code reusable so what i want to do now is i will delete all of this code and then i'm going to type a code that i want to show you in order to demonstrate something amazing that we can do with function pointers so after i type that code i will be back so here i have created a couple of functions and let's now explain what every single one of these is doing so the first one is ascending compare and it is very simple function that just compares two numbers so that the first one is smaller than the second one and then it returns if that is true or not and then descending compare again very simple function and again it compares two numbers but in this situation the first number needs to be greater than the second number okay these two are very simple let's see what is happening inside this sort ascending function so if i open that function you will notice that this here is a sorting algorithm now the goal of this video is not for you to understand how this sorting algorithm works we are going to explain that in a whole another video of c plus sorting algorithms which i'm going to make in the future but for now the goal is that you understand that the job of this function here is to sort a vector of numbers in an ascending order and one very important thing is that since we are using vector you will need to include that vector because otherwise you are going to get an error so that is the job of sort ascending now if we take a look at sort descending let me move this code okay you will notice that sort descending function is almost identical to sort ascending function and the only thing that is different is this part here and this part here so our sort ascending which is sorting numbers in an ascending order is invoking ascending compare function and then our sort descending is invoking descending compare function and those are the functions that i explained in the beginning okay so the next thing that i want to do is i just want to demonstrate how these two functions work i want to test these two functions and then i am going to show you how we can optimize this code here so what i want to do is i want to create a vector of integers and let's call it my numbers like this and i want to assign numbers of two and then five one three six and four okay and what i want to do now is i want to invoke sort ascending and then i will print those numbers in order to be able to see if those numbers have been sorted in an ascending order and for printing numbers we will use this function here which is very simple function that will just iterate through this numbers vector and write out every single number of that vector so let's do what i just explained let's invoke sort ascending like this and let's pass my numbers vector to that function and after i have sorted those numbers in an ascending order let's say print numbers and i will pass my numbers vector like this so if i run my program let's see what is going to happen as you can see this vector here has been sorted in an ascending order so one two three four five six okay so that means that our sword ascending function works as it should and let's now test this sort descending so here i'm going to invoke sort descending function everything else stays the same so let's run our program again okay so six five four three two one which means that our sword descending works as it should as well okay perfect again all of this code will be in the description for those of you who want to analyze how this sort descending and then sort ascending functions work but for now it's enough for you to understand that this one is sorting numbers in an ascending order and then this one in descending order and that the only difference between these two functions is in this part here so this one is invoking ascending compare and then this one is invoking the sending compare so the next thing that i want to show you is how we can optimize this code here so that we can create one function that will be called custom sort and we can use that function in order to sort numbers in both ascending and descending order and the general idea is for that function to receive numbers vector and then we are going to pass another function to our custom sort and that function can be either this one or this one because that is the only difference between these two functions so let me show you how we can do that the first thing that i want to do is i want to change the name of this function here so instead of calling it sort ascending let's call it custom sort like this and that custom sort function as i already said will receive numbers vector and then it will receive a function pointer so it will receive a function pointer to one of these two functions so let's add that function pointer here as a parameter one more time how can we create a function pointer well inside these parentheses you are going to put asterix symbol and then you will give the name to your function pointer let's call it um compare func ptr so compare function pointer let's just call it func instead of fun okay so that is the first part the second part is to put the return type of your function in front so here i will say bool because that is the return type of both this function and this function here and then the last step is to put parameters that the function receives inside parentheses after the name of your function pointer so here and the parameters that these two functions receive are int and in so two integers so here i'm going to put int and then int okay so with this we have created a function pointer called compare func ptr which can point to either this function here or this function here so it can point to any function that returns bool and receives two integers so what we can do with our compare function pointer is we can use it to pass either this function or this function to our custom sort so since this part here was the only difference between sort ascending and sort descending if i change this with my compare function pointer that means that whichever one of these two is passed as argument to our custom sort that one is going to be invoked here so that means that now we can use custom sword in order to do both ascending and descending sort of this vector here so that means as well that now we can delete sort descending so let's test this function here so i am going to delete this part here and what i want to do first is i want to create this function pointer in my main function so i will do it here again inside parentheses you put asterisk symbol and then you give the name to your function pointer let's call it func ptr and then you put the return type of that function here since we want to point to one of these two functions the return type is bull and then they receive two integers so the return type goes here bull and then the parameters go here inside parentheses and those are two integers like this so we have created a function pointer that can point to any function that returns bull and receives two integers so the first one that i want to assign here will be ascending compare like this so now i'm going to invoke my custom sort function here and i am going to pass two parameters to that function the first parameter is numbers vector so my numbers okay and then the second parameter is a function pointer to a function that returns bull and receives two integers and that will be this function pointer here okay perfect so now if i run my program what do you expect to happen write me in the comment section so let's run the program okay and as you can see the numbers of my vector have been sorted in the ascending order so one two three four five six and for that we have used custom sort function and we have passed our vector and a function pointer so we have passed ascending compare to our custom sort so we have basically used a function pointer in order to pass one function as an argument to another function and let's now test this with descending compare so i'm going to say descending compare here and that is the only thing that you need to change and now this descending compare will be passed as an argument to our custom sort so if i run my program now let's see what is going to happen perfect now our numbers have been sorted in the descending order so six five four three two one and we have achieved that by using a by using a function pointer okay so i hope that this video was helpful i hope that you understood what is the purpose of function pointers and how you can create and use function pointers all of this code will be in the description again you don't really have to bother with understanding what these functions are doing except for the part of how you can use a function pointer in order to pass one function as an argument to another function so i hope that you enjoyed this video if you did please give it a thumbs up for the youtube algorithm that helps me a lot to reach more people and then share it with someone else who would also like to learn programming because the topic of function pointers is not very beginner friendly so if you found this video helpful you might make a very big difference in someone else's life and you might help that person to learn programming much faster so thank you very much for watching and i am going to see you in some other video bye hi everyone and welcome to my channel in this video i will teach you about smart pointers in c plus and the first thing that i want to explain is what are smart pointers a smart pointer is a container or a wrapper for a raw pointer and one advantage that smart pointers have is that they deallocate memory automatically which means that you don't have to worry about potential memory leaks in your program there are three different types of smart pointers in c plus unique pointer shared pointer and weak pointer and in this video i'm going to teach you about every single one so in order to use any one of these three the first thing that you need to do is you need to include memory so i will say include memory like this and the first type of smart pointers that i want to talk about are unique pointers so the syntax of creating a unique pointer is a little bit different if you are used to raw pointers so i'm going to show you now how you can create a unique pointer so you say unique ptr and then you specify the type so what kind of data type is going to be stored on the address that you want to point to so let's say for example integer so please make a unique pointer to integer and let's call that pointer u n p t r one so unique pointer one okay and then there are few different ways to create a unique pointer and the one that i use most often is make unique method so i'm going to say make unique so please make a unique pointer of integer type and to that address i want to store a value of 25 for example okay so with this i have successfully created a unique pointer to an integer and i have assigned the value of 25 to that address that my unique pointer 1 is pointing to so now the question is how do you use this pointer and as you already know pointers store address and in order to access the value that is stored on that address you need to dereference that pointer so how do you dereference a smart pointer the answer is by using asterix symbol or that little star symbol let me show you so if i say c out and then u n p t r one like this so if i write out this unique pointer one let's see what is going to happen okay as you can see we have an address because pointers store addresses now in order to access the value that is stored on this address you need to dereference that pointer so let's do that and in order to dereference this pointer you put asterisk symbol before it okay so if i run my program now as you can see here we have the address that our pointer is pointing to and then this is the value stored on that address there is one very important thing related to unique pointers and that is that they cannot be shared so in order to demonstrate what i'm talking about let's delete this code here and let's create another unique pointer let's say unique ptr of int like this and let's call it unique ptr 2 like this okay so what is going to happen if i try to assign to this unique pointer to the same location that my unique pointer one is storing so if i do that as you can see we get an error and that means that you cannot share unique pointers okay now one thing that you can do is you can move the ownership of a unique pointer so what you can do is you can say that your unique pointer two is equal to please move the ownership of my unique ptr one like this and now our unique pointer 2 becomes the owner of this memory address here so if i try to write out the value that is stored on this address here let's see what we are going to get okay so i am writing out the referenced unique pointer to let's run our program okay as you can see we get the value of 25. okay now one very important thing is that once you move the ownership of a pointer the previous owner which is this one becomes null pointer and that means if you try to access the value of your pointer that was previous owner you are going to get null pointer exception so let's demonstrate that let's say please write out the referenced value of my unique pointer one and let's see what is going to happen and as you can see we get an exception because now our unique pointer one is empty it is no pointer and if you are not familiar with exceptions if you don't know how to work with exceptions you can watch the video that i will link here and i will also link it in the description it's called exception handling and there i explain everything that you need to know in order to work with exceptions in c plus another important thing that i mentioned about smart pointers is that the memory is deallocated automatically which means that you don't have to worry about the allocating the memory or causing memory leaks and what i want to do now is i want to demonstrate that so basically i want to create a class and inside that class i want to create a constructor and destructor if you don't know a constructor is a special type of method that is invoked when an object is constructed or created and then a destructor is also a special type of method that is invoked when an object is being destroyed so if you are not familiar with the concept of objects classes constructors destructors and so on i am going to link a playlist here which is c plus plus object oriented programming and i will also put it in the description so c plus plus oop or c plus plus objectoriented programming you can watch that playlist in order to understand in more detail what i'm talking about so as i said what i want to do now is i want to create a class let's call that class my class okay and inside this class i will create a constructor and destructor so let's first create a public constructor so i will say public and then my class okay this is a constructor and inside constructor the only thing that i want to do is i just want to say constructor invoked so i will say see out and let's say constructor invoked like this okay and i also want to create a destructor so i will copy my constructor i will put squiggly before it i believe this is called squiggly or tilde sign and i will write out here that the structure is invoked okay i hope that i didn't make any typo here okay so i have created a class called my class and inside it i have a constructor which as i already said will be invoked when an object is created and then i also have a destructor which will be invoked at the end of the life of that object which means uh when that object is being destroyed so what i want to do now is let's delete everything from our main function because we don't need it and what i want to do is i want to create a pointer to an object of this class here so let's create a unique pointer like this of my class and let's again call it unique ptr1 and i will make unique pointer of my class like this okay so let's see what is going to happen if i run my program now as you know already constructor is invoked when an object of this type is created and then the structure will be invoked when that object is being destroyed so if i run this program let's see what is going to happen okay as you can see we only have this constructor invoked so when is this pointer here being destroyed the answer is that this unique pointer will be destroyed at the end of the scope and the scope of this pointer here begins at this curly bracket and then it ends at this curly bracket here so at this curly bracket here this unique pointer will be destroyed and since this is the end of our program we don't see that destructor is invoked so what i can do to demonstrate that is i can create an additional scope so let's do that let's create an additional scope like this okay so now this is another scope and if i run my program now let's see what is going to happen as you can see now we have constructor invoked and then destructor invoked which means that here at this 18th line of code our constructor was invoked for myclass object and then at this 19th line of code so at the end of its scope the structure has been invoked which means that our unique pointer has been deallocated so we don't have memory leak so one more time this unique pointer will be destroyed it will be d allocated at the end of its scope which is here okay so that is related to unique pointers and now i want to explain what are shared pointers so as the name itself says a shared pointer can be shared unlike unique pointer a shared pointer can be shared between multiple owners and that means that you can assign one raw pointer to multiple owners so let's demonstrate how that works so let's delete everything from our main function because i don't need it anymore and the first thing that i want to show you is how to create a shared pointer so let's say shared ptr that is the keyword and then you specify the type so the type will be my class so the class that we created here and then let's give the name to our shared pointer let's call it shptr1 so sharedpointer1 and now i want to use a method called make shared in order to make a shared pointer so i will say make shared of my class like this okay so with this we have created a shared pointer now one very interesting thing related to shared pointers is that since you can share a shared pointer it has the count of all of the owners so it has the count of all of the references to that pointer so how can you access that count well there is a method called use count so what i want to do now is i will show you that so i want to write out the number of owners of this pointer here so i'm going to say see out and then let's say shared count like this and let's say shptr1 and then i will use a method called use count like this and this use count method as i already said will give me the number of owners of this location here so if i run my program let's see what is going to happen okay as you can see constructor has been invoked and then the number of owners of this memory location is one because we have only one pointer pointing to that memory location okay let's close this and what i want to do now is i want to share this pointer so i want to create an additional owner to that same memory location so let's create another shared pointer of my class and let's call it shptr2 okay and what i want to do now is i want to assign to this shared pointer to the same memory location that this shared pointer one is holding like this and i also want to write out the number of owners of that memory location after i have shared that pointer so if i run my program now as you can see in this first line it says that the number of owners is one and then in this second line the number of owners or shared count is two okay one question that you might have now is when will this memory location automatically be deallocated and the answer to that question is the memory location will automatically be deallocated when there are no more pointers pointing to that memory location now since that memory location has multiple owners every single owner will be destroyed at the end of its scope and when there are no more owners the memory location itself will be deallocated which means that that memory will be free for other programs and other applications to use so let's demonstrate that as well what i want to do now is i want to put this here into an additional scope so let's do that let's create an additional scope like this and what i want to do now is after this scope i want to write out the count of the owners of this memory location so let's run our program and let's see what is going to happen let me know what you expect to happen in the comment section before i run the program okay so as you can see this first line says that there is one owner of this memory location and then we entered inside this scope here and it says that there are two owners and then after we have left this scope this third line this third print says that there is again only one owner of this memory location which means that this shared pointer so this owner has been destroyed at the end of its scope which is this line here now another thing that i said is that the memory location itself is going to be deallocated when there are no more pointers pointing to that location so in order to demonstrate that let's put all of this code inside a scope so i will put the beginning of that scope here and then the scope will end here and what i expect to happen is that this memory location is going to be destroyed at the end of the scope of its last owner so if i run my program as you can see okay let's move this as you can see our constructor has been invoked and that happened in this line of code here so the line where we made our pointer and then the first output says that there is only one owner and that is this 19th line which says shared count and then we have written out the count and then when we entered inside disco we created an additional owner so this second output here says that there are now two owners and then when we left that scope and we printed the output for the third time we get this line here which says that again we have only one owner of that memory location and then when we left this scope here which is the scope of that last owner we are going to destroy that memory location which means that we are going to deallocate that memory so that other programs and other applications can use it so that was related to shared pointers in c plus plus and now i'm going to teach you about weak pointers so the main difference between a weak pointer and a shared pointer is the following as you already saw when you assign a specific memory location to a shared pointer that is going to increase the number of owners of that memory location but if you assign that same memory location to a weak pointer that will not increase the number of its owners and that means that we use weak pointers in order to observe objects in memory but a weak pointer will not keep that object alive so we use weak pointers in order to locate a specific object in memory but a weak pointer will not keep that object alive if nothing else needs it whereas a shared pointer will keep that object alive so let's demonstrate what i just explained so let's delete all of this code i don't need it anymore by the way the leading code is my favorite part of coding so the first thing that i want to do is let's create a weak pointer let's say week ptr of let's say for example end so let's create a weak pointer to integer and let's call it we ptr1 wii ptr okay so another thing that i want to do is i want to create an additional scope like this and inside this scope i will create a shared pointer so let's say shared ptr of int and let's call it shptr one so shared pointer one and let's make one shared pointer so i'm going to use method make shared so please make sure pointer of int and let's assign the value of 25 again okay so after i have created a shared pointer what i want to do is i want to assign this same memory location to my weak pointer so let's do that let's say that week pointer one is equal to shared pointer one like this okay so let's see what is going to happen if i run this program i'm going to put a break point here so at the first line of my main function and if i run this program let's see what is going to happen so now we are debugging this program okay so in this first line we are going to create a weak pointer and it is still not pointing to anything as you can see it is empty we just created it we didn't assign any location to that pointer okay and then after we have created that weak pointer we are going to enter into this scope here and inside this scope the first thing that happens is we create a shared pointer and then we assign the number 25 to that memory location that our shared pointer is holding so let's do that okay and if i hover over my shared pointer as you can see it is pointing to a memory location that has one strong reference and on that memory location we are storing the value of 25 okay now in this second line of code we will assign this shared pointer to our weak pointer so if i execute that line of code let's hover over our weak pointer and as you can see now our weak pointer as well is also pointing to the same memory location and that memory location stores the value of 25 and it has one strong reference but one thing that will happen when i leave this scope here is following please write me in the comment section what do you expect to happen after i leave this scope here so if i press f10 and leave this scope and if i hover over my weak pointer here or here there are two things that you can notice the first thing is that it says that there is only one weak reference to this memory location so there are no more strong references and then another thing is that it has expired so all of the owners all of these strong references to this memory location have been destroyed and now we have just a reference we just have the address of a memory location that has been deallocated and that is exactly what i've been talking about which is that a weak pointer will not keep an object alive whereas a shared pointer will so this memory location has expired it was deallocated when its last strong reference so when its last shared pointer or when its last owner left its scope and that happened on this line of code here so i hope that this video was helpful if it was please give it a thumbs up for the youtube algorithm and also share it with someone who would like to learn programming because many people would like to learn programming but they just don't know where to start so you can be the one who helps them and makes the difference and also if you have any questions you can leave those in the comments section and please let me know what kind of videos you would like to see in the future so thank you very much for watching and i am going to see you in some other video bye
