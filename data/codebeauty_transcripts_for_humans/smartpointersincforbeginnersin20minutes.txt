With timestamps:

00:00 - hi everyone and welcome to my channel in
00:02 - this video i will teach you about smart
00:04 - pointers in c plus but first i want to
00:07 - say hi to everyone who's watching this
00:09 - video as a premiere
00:11 - and if you're not make sure to subscribe
00:13 - and click the bell icon because we are
00:15 - always hanging out in the chat section
00:17 - and i answer your questions during the
00:19 - premiere of the video uh and also you
00:22 - can follow me on instagram it will be
00:24 - here i post when something interesting
00:26 - happens in my life and something
00:28 - interesting did happen a few days ago
00:30 - which is that i fell
00:32 - and i almost broke my arm as you can see
00:36 - so i am 26 years old and somehow i
00:39 - managed to be clumsier than a
00:41 - six-year-old so let's talk about smart
00:43 - pointers in c plus plus and the first
00:46 - thing that i want to explain is what are
00:48 - smart pointers
00:49 - a smart pointer is a container or a
00:53 - wrapper for a raw pointer and if you're
00:56 - not familiar with raw pointers make sure
00:58 - to watch my c plus pointers playlist i
01:01 - explain everything that you need to know
01:03 - there and one advantage that smart
01:05 - pointers have is that they deallocate
01:08 - memory automatically which means that
01:10 - you don't have to worry about potential
01:13 - memory leaks in your program there are
01:16 - three different types of smart pointers
01:18 - in c plus plus unique pointer shared
01:20 - pointer and weak pointer and in this
01:23 - video i'm going to teach you about every
01:25 - single one so in order to use any one of
01:28 - these three the first thing that you
01:29 - need to do is you need to include memory
01:32 - so i will say
01:34 - include
01:35 - memory
01:36 - like this and the first type of smart
01:39 - pointers that i want to talk about are
01:41 - unique pointers so um the syntax of
01:45 - creating a unique pointer is a little
01:47 - bit different if you are used to raw
01:49 - pointers so i'm going to show you now
01:51 - how you can create a unique pointer
01:54 - so
01:55 - you say
01:56 - unique ptr and then you specify the type
02:00 - so what kind of data type is going to be
02:02 - stored on the address that you want to
02:04 - point to
02:06 - so let's say for example integer so
02:08 - please make a unique pointer to integer
02:12 - and let's call that pointer
02:14 - u n p t r one so unique pointer one
02:18 - okay
02:19 - and then there are a few different ways
02:22 - to create a unique pointer and the one
02:24 - that i use most often is make unique
02:27 - methods so i'm going to say
02:29 - make
02:30 - unique
02:32 - so please make a unique pointer
02:35 - of
02:36 - integer type
02:38 - and to that address i want to store a
02:40 - value of 25 for example
02:44 - okay so with this i have successfully
02:47 - created a unique pointer to an integer
02:51 - and i have assigned the value of 25 to
02:53 - that address that my unique pointer 1 is
02:57 - pointing to so now the question is how
03:00 - do you use this pointer and as you
03:02 - already know pointers store address and
03:06 - in order to access the value that is
03:08 - stored on that address you need to
03:09 - dereference that pointer so how do you
03:12 - dereference a smart pointer the answer
03:15 - is by using asterix symbol or that
03:18 - little star symbol let me show you
03:21 - so
03:22 - if i say c out and then u n p t r one
03:27 - like this so if i write out this unique
03:31 - pointer one let's see what is going to
03:33 - happen
03:36 - okay as you can see we have an address
03:40 - because pointers store addresses now in
03:43 - order to access the value that is stored
03:45 - on this address you need to de-reference
03:47 - that pointer so let's do that and in
03:51 - order to de-reference this pointer you
03:54 - put asterisk symbol before it okay so if
03:58 - i run my program now
04:01 - as you can see
04:02 - here we have the address that our
04:04 - pointer is pointing to and then this is
04:06 - the value stored on that address
04:09 - there is one very important thing
04:11 - related to unique pointers and that is
04:13 - that they cannot be shared so in order
04:16 - to demonstrate what i'm talking about
04:19 - let's delete this code here and let's
04:22 - create another unique pointer let's say
04:25 - unique ptr of int
04:28 - like this and let's call it
04:30 - unique ptr two like this okay so what is
04:35 - going to happen if i try to assign to
04:38 - this unique pointer to
04:40 - the same location that my unique pointer
04:43 - one is storing
04:45 - so
04:46 - if i do that
04:48 - as you can see we get an error and that
04:51 - means that you cannot share unique
04:54 - pointers okay now one thing that you can
04:58 - do is you can move the ownership of a
05:01 - unique pointer so what you can do is you
05:04 - can say that your unique pointer two is
05:07 - equal to
05:08 - please move the ownership of my unique
05:12 - ptr one
05:14 - like this and now our unique pointer two
05:18 - becomes the owner of this memory address
05:21 - here so if i try to write out the value
05:26 - that is stored on
05:29 - this address here let's see what we are
05:31 - going to get
05:33 - okay so i am writing out the referenced
05:36 - unique pointer to let's run our program
05:41 - okay as you can see we get the value of
05:43 - 25.
05:46 - okay now one very important thing is
05:49 - that once you move the ownership of a
05:52 - pointer the previous owner which is this
05:55 - one becomes null pointer and that means
05:58 - if you try to access the value of your
06:01 - pointer that was previous owner you are
06:03 - going to get now pointer exception so
06:06 - let's demonstrate that
06:08 - let's say please write out the
06:11 - referenced value of my unique pointer 1
06:14 - and let's see what is going to happen
06:17 - and as you can see we get an exception
06:20 - because now our unique pointer one is
06:23 - empty it is no pointer and if you are
06:26 - not familiar with exceptions if you
06:28 - don't know how to work with exceptions
06:30 - you can watch the video that i will link
06:32 - here and i will also link it in the
06:33 - description it's called exception
06:35 - handling and there i explain everything
06:38 - that you need to know in order to work
06:40 - with exceptions in c plus
06:42 - another important thing that i mentioned
06:44 - about smart pointers is that the memory
06:46 - is deallocated automatically which means
06:48 - that you don't have to worry about the
06:50 - allocating the memory or causing memory
06:53 - leaks and what i want to do now is i
06:55 - want to demonstrate that
06:58 - so basically i want to create a class
07:00 - and inside that class i want to create a
07:02 - constructor and destructor
07:05 - if you don't know a constructor is a
07:07 - special type of method that is invoked
07:09 - when an object is constructed or created
07:12 - and then a destructor is also a special
07:15 - type of method that is invoked when an
07:18 - object is being destroyed
07:20 - so if you are not familiar with the
07:22 - concept of objects classes constructors
07:25 - destructors and so on i am going to link
07:28 - a playlist here which is c plus plus
07:30 - object oriented programming and i will
07:33 - also put it in the description so c plus
07:35 - plus oop or c plus plus object oriented
07:37 - programming you can watch that playlist
07:39 - in order to understand in more detail
07:42 - what i'm talking about so as i said what
07:45 - i want to do now is i want to create a
07:48 - class
07:49 - um
07:50 - let's call that class my class
07:54 - okay
07:55 - and inside this class i will create a
07:58 - constructor and destructor so let's
08:01 - first create a public constructor so i
08:03 - will say public
08:05 - and then
08:06 - my
08:08 - class
08:10 - okay this is a constructor and inside
08:13 - constructor the only thing that i want
08:14 - to do is i just want to say constructor
08:17 - invoked so i will say
08:19 - see out and let's say constructor
08:24 - invoked
08:26 - like this
08:31 - okay
08:31 - and i also want to create a destructor
08:34 - so i will copy my constructor i will put
08:38 - squiggly before it i believe this is
08:40 - called squiggly or tilde sign
08:43 - um and i will write out here that the
08:46 - structure is
08:48 - invoked
08:49 - okay i hope that i didn't make any typo
08:52 - here okay so i have created a class
08:55 - called my class and inside it i have a
08:58 - constructor which as i already said will
09:01 - be invoked when an object is created and
09:04 - then i also have a destructor which will
09:06 - be invoked at the end of the life of
09:08 - that object which means
09:10 - when that object is being destroyed so
09:13 - what i want to do now is let's delete
09:15 - everything from our main function
09:16 - because we don't need it and what i want
09:18 - to do is i want to create a pointer to
09:21 - an object of this class here so let's
09:24 - create a unique pointer
09:28 - like this of my class
09:32 - and let's again call it unique
09:34 - ptr1 and
09:36 - i will make
09:38 - unique pointer of my
09:41 - class
09:42 - like this
09:43 - okay so let's see what is going to
09:46 - happen if i run my program now as you
09:49 - know already
09:51 - constructor is invoked when an object of
09:54 - this type is created and then this
09:57 - structure will be invoked when that
09:59 - object is being destroyed so if i run
10:02 - this program let's see what is going to
10:03 - happen
10:05 - okay as you can see we only have this
10:08 - constructor invoked so
10:11 - when
10:12 - is this pointer here being destroyed the
10:16 - answer is that this unique pointer will
10:19 - be destroyed at the end of the scope
10:22 - and the scope of this pointer here
10:25 - begins at this curly bracket and then it
10:28 - ends at this curly bracket here so
10:30 - at this curly bracket here
10:33 - this unique pointer will be destroyed
10:36 - and since this is the end of our program
10:38 - we don't see that destructor is invoked
10:43 - so what i can do to demonstrate that is
10:45 - i can create an additional scope so
10:47 - let's do that
10:49 - let's create an additional scope
10:52 - like this
10:54 - okay so now this is another scope and if
10:58 - i run my program now let's see what is
11:00 - going to happen
11:01 - as you can see now we have constructor
11:03 - invoked and then destructor invoked
11:06 - which means that here at this 18th line
11:10 - of code our constructor was invoked for
11:13 - my class object and then at this 19th
11:16 - line of code so at the end of its scope
11:19 - the structure has been invoked which
11:21 - means that our unique pointer has been
11:24 - deallocated so we don't have memory leak
11:28 - so one more time this unique pointer
11:31 - will be destroyed it will be deallocated
11:33 - at the end of its scope which is here
11:37 - okay so that is related to unique
11:40 - pointers and now i want to explain
11:42 - what are shared pointers so
11:44 - as the name itself says a shared pointer
11:48 - can be shared unlike unique pointer a
11:51 - shared pointer can be shared between
11:53 - multiple owners and that means that you
11:56 - can assign
11:57 - one raw pointer to multiple owners so
12:01 - let's demonstrate how that works so
12:04 - let's delete everything from our main
12:06 - function because i don't need it anymore
12:08 - and the first thing that i want to show
12:10 - you is how to create a shared pointer so
12:13 - let's say
12:14 - shared
12:16 - ptr
12:17 - that is the keyword and then you specify
12:20 - the type so the type will be
12:22 - my class so the class that we created
12:25 - here and then let's give the name to our
12:28 - shared pointer let's call it
12:31 - shptr1 so sharedpointer1 and now i want
12:34 - to use a method called make shared in
12:37 - order to make a shared pointer so i will
12:39 - say
12:40 - make
12:42 - shared
12:43 - of
12:44 - my
12:44 - class
12:46 - like this
12:47 - okay so with this we have created a
12:50 - shared pointer now one very interesting
12:53 - thing related to shared pointers is that
12:55 - since you can share a shared pointer it
12:58 - has the count of all of the owners so it
13:02 - has the count of all of the references
13:05 - to that pointer so how can you access
13:08 - that count well there is a method called
13:11 - use count so what i want to do now is i
13:13 - will show you that so i want to write
13:16 - out the number of owners of this pointer
13:20 - here so i'm going to say
13:22 - c out and then let's say
13:25 - shared
13:26 - count
13:28 - like this
13:30 - and let's say
13:31 - shptr1
13:34 - and then i will use a method called use
13:38 - count
13:39 - like this
13:40 - and
13:41 - this use count method as i already said
13:44 - will give me the number of owners of
13:48 - this location here so if i run my
13:52 - program let's see what is going to
13:53 - happen
13:55 - okay as you can see constructor has been
13:57 - invoked and then the number of owners of
14:01 - this memory location is one because we
14:03 - have only one pointer pointing to that
14:06 - memory location okay
14:08 - let's close this
14:11 - and what i want to do now is i want to
14:13 - share this pointer so i want to create
14:15 - an additional owner to that same memory
14:18 - location
14:19 - so let's create another shared pointer
14:23 - of my class and let's call it shptr2
14:30 - okay and what i want to do now is i want
14:33 - to assign to this shared pointer to
14:36 - the same memory location that this
14:39 - shared pointer one is
14:41 - holding
14:42 - like this and i also want to write out
14:45 - the number of owners of that memory
14:48 - location after i have shared that
14:51 - pointer so
14:52 - if i run my program now
14:55 - as you can see in this first line it
14:58 - says that the number of owners is one
15:01 - and then in this second line the number
15:03 - of owners or shared count is two
15:07 - okay
15:08 - one question that you might have now is
15:10 - when will this memory location
15:13 - automatically be deallocated and the
15:15 - answer to that question is the memory
15:18 - location will automatically be
15:20 - deallocated when there are no more
15:22 - pointers pointing to that memory
15:25 - location now
15:26 - since that memory location has multiple
15:29 - owners every single owner will be
15:32 - destroyed at the end of its scope and
15:35 - when there are no more owners the memory
15:37 - location itself will be deallocated
15:40 - which means that that memory will be
15:42 - free for other programs and other
15:44 - applications to use
15:47 - so let's demonstrate that as well what i
15:49 - want to do now is i want to put this
15:53 - here into an additional scope so let's
15:56 - do that let's create an additional scope
16:00 - like this and what i want to do now is
16:03 - after this scope i want to write out the
16:06 - count of the owners of this memory
16:09 - location so let's run our program and
16:12 - let's see what is going to happen uh let
16:14 - me know what you expect to happen in the
16:16 - comment section before i run the program
16:19 - okay
16:21 - so
16:22 - as you can see
16:23 - this first line says that there is one
16:27 - owner of this memory location and then
16:30 - we entered inside this scope here and it
16:34 - says that there are two owners and then
16:37 - after we have left this scope this third
16:41 - line this third print says that there is
16:44 - again only one owner of this memory
16:49 - location which means that this shared
16:51 - pointer so this owner has been destroyed
16:54 - at the end of its scope which is this
16:57 - line here now another thing that i said
17:00 - is that the memory location itself is
17:02 - going to be d allocated when there are
17:04 - no more pointers pointing to that
17:06 - location so in order to demonstrate that
17:10 - let's put all of this code inside a
17:12 - scope
17:14 - so i will put
17:16 - the beginning of that scope here and
17:18 - then the scope will end here
17:20 - and what i expect to happen is that
17:24 - this memory location is going to be
17:26 - destroyed at the end of the scope of its
17:29 - last owner so if i run my program
17:34 - as you can see okay let's move this as
17:37 - you can see our constructor has been
17:39 - invoked and that happened in this line
17:42 - of code here so the line where we made
17:45 - our pointer
17:46 - and then the first output says that
17:48 - there is only one owner and that is this
17:51 - 19th line which says shared count and
17:53 - then we have written out the count and
17:56 - then when we entered inside this scope
17:59 - we created an additional owner so this
18:02 - second output here says that there are
18:05 - now two owners and then when we left
18:08 - that scope and we printed the output for
18:11 - the third time we get this line here
18:14 - which says that again we have only one
18:17 - owner of that memory location and then
18:20 - when we left this scope here which is
18:24 - the scope of that last owner we are
18:27 - going to destroy that memory location
18:30 - which means that we are going to
18:31 - deallocate that memory so that other
18:34 - programs and other applications can use
18:37 - it so that was related to shared
18:39 - pointers in c plus and now i'm going to
18:41 - teach you about weak pointers so the
18:44 - main difference between a weak pointer
18:47 - and a shared pointer is the following as
18:50 - you already saw when you assign a
18:53 - specific memory location to a shared
18:55 - pointer that is going to increase the
18:57 - number of owners of that memory location
19:01 - but
19:02 - if you assign that same memory location
19:04 - to a weak pointer that will not increase
19:07 - the number of its owners and that means
19:11 - that we use weak pointers in order to
19:15 - observe objects in memory but a weak
19:18 - pointer will not keep that object alive
19:20 - so
19:21 - we use weak pointers in order to
19:25 - locate a specific object in memory but a
19:28 - weak pointer will not keep that object
19:30 - alive if nothing else needs it whereas a
19:34 - shared pointer will keep that object
19:37 - alive so let's demonstrate what i just
19:39 - explained so let's delete all of this
19:42 - code i don't need it anymore by the way
19:45 - the leading code is my favorite part
19:48 - of coding
19:50 - so the first thing that i want to do is
19:52 - let's create a weak pointer let's say
19:55 - week ptr of let's say for example end so
19:59 - let's create a weak pointer to
20:01 - integer and let's call it
20:04 - we
20:04 - ptr1
20:06 - wii ptr okay
20:09 - so
20:10 - another thing that i want to do is i
20:11 - want to create an additional scope like
20:14 - this and inside this scope i will create
20:18 - a shared pointer so let's say
20:21 - shared ptr of
20:23 - int and let's call it
20:26 - shptr1 so shared pointer one and let's
20:30 - make one shared pointer so i'm going to
20:32 - use method make
20:34 - shared so please make shared pointer of
20:37 - int and let's assign the value of 25
20:42 - again
20:42 - okay so
20:44 - after i have created a shared pointer
20:47 - what i want to do is i want to assign
20:50 - this same memory location to my weak
20:53 - pointer so let's do that let's say that
20:56 - week pointer one is equal to shared
21:00 - pointer one like this
21:03 - okay
21:04 - so
21:05 - let's see what is going to happen if i
21:08 - run this program i'm going to put a
21:10 - break point here so at the first line of
21:13 - my main function
21:15 - and if i run this program let's see what
21:18 - is going to happen so now we are
21:19 - debugging this program okay so in this
21:23 - first line we are going to create a weak
21:26 - pointer and it is still not pointing to
21:29 - anything as you can see it is empty we
21:32 - just created it we didn't assign any
21:34 - location to that pointer okay and then
21:37 - after we have created that weak pointer
21:39 - we are going to enter into this scope
21:42 - here and inside this scope the first
21:45 - thing that happens is we create a shared
21:48 - pointer and then we assign the number 25
21:51 - to that memory location that our shared
21:53 - pointer is holding so let's do that okay
21:58 - and if i hover over my shared pointer as
22:01 - you can see it is pointing to a memory
22:04 - location that has one strong reference
22:07 - and on that memory location we are
22:08 - storing the value of
22:10 - 25. okay
22:13 - now in this second line of code we will
22:16 - assign this shared pointer to our weak
22:19 - pointer so if i execute that line of
22:23 - code let's hover over our weak pointer
22:26 - and as you can see now our weak pointer
22:29 - as well is also pointing to the same
22:32 - memory location and that memory location
22:35 - stores the value of 25 and it has one
22:38 - strong reference but
22:41 - one thing that will happen when i leave
22:44 - this scope here is following please
22:47 - write me in the comment section what do
22:49 - you expect to happen after i leave this
22:52 - scope here so
22:55 - if i press f10 and leave this scope and
22:58 - if i hover over my weak pointer here
23:00 - or here there are two things that you
23:03 - can notice the first thing is that it
23:05 - says that there is only one weak
23:09 - reference to this memory location so
23:11 - there are no more strong references and
23:14 - then another thing is that it has
23:17 - expired so
23:19 - all of the owners all of these strong
23:21 - references to this memory location have
23:24 - been destroyed and now we have just a
23:27 - reference we just have the address of a
23:30 - memory location that has been
23:32 - deallocated and that is exactly what
23:35 - i've been talking about which is that a
23:37 - weak pointer will not keep an object
23:40 - alive whereas a shared pointer will so
23:44 - this memory location has expired it was
23:48 - deallocated when its last strong
23:51 - reference so when its last shared
23:53 - pointer or when its last owner left its
23:57 - scope and that happened on this line of
23:59 - code here
24:01 - so i hope that this video was helpful if
24:03 - it was please give it a thumbs up for
24:05 - the youtube algorithm and also share it
24:08 - with someone who would like to learn
24:09 - programming because many people would
24:11 - like to learn programming but they just
24:13 - don't know where to start so you can be
24:15 - the one who helps them and makes the
24:17 - difference and also if you have any
24:19 - questions you can leave those in the
24:21 - comments section and please let me know
24:23 - what kind of videos you would like to
24:24 - see in the future so thank you very much
24:27 - for watching and i am going to see you
24:29 - in some other video bye

Cleaned transcript:

hi everyone and welcome to my channel in this video i will teach you about smart pointers in c plus but first i want to say hi to everyone who's watching this video as a premiere and if you're not make sure to subscribe and click the bell icon because we are always hanging out in the chat section and i answer your questions during the premiere of the video uh and also you can follow me on instagram it will be here i post when something interesting happens in my life and something interesting did happen a few days ago which is that i fell and i almost broke my arm as you can see so i am 26 years old and somehow i managed to be clumsier than a sixyearold so let's talk about smart pointers in c plus plus and the first thing that i want to explain is what are smart pointers a smart pointer is a container or a wrapper for a raw pointer and if you're not familiar with raw pointers make sure to watch my c plus pointers playlist i explain everything that you need to know there and one advantage that smart pointers have is that they deallocate memory automatically which means that you don't have to worry about potential memory leaks in your program there are three different types of smart pointers in c plus plus unique pointer shared pointer and weak pointer and in this video i'm going to teach you about every single one so in order to use any one of these three the first thing that you need to do is you need to include memory so i will say include memory like this and the first type of smart pointers that i want to talk about are unique pointers so um the syntax of creating a unique pointer is a little bit different if you are used to raw pointers so i'm going to show you now how you can create a unique pointer so you say unique ptr and then you specify the type so what kind of data type is going to be stored on the address that you want to point to so let's say for example integer so please make a unique pointer to integer and let's call that pointer u n p t r one so unique pointer one okay and then there are a few different ways to create a unique pointer and the one that i use most often is make unique methods so i'm going to say make unique so please make a unique pointer of integer type and to that address i want to store a value of 25 for example okay so with this i have successfully created a unique pointer to an integer and i have assigned the value of 25 to that address that my unique pointer 1 is pointing to so now the question is how do you use this pointer and as you already know pointers store address and in order to access the value that is stored on that address you need to dereference that pointer so how do you dereference a smart pointer the answer is by using asterix symbol or that little star symbol let me show you so if i say c out and then u n p t r one like this so if i write out this unique pointer one let's see what is going to happen okay as you can see we have an address because pointers store addresses now in order to access the value that is stored on this address you need to dereference that pointer so let's do that and in order to dereference this pointer you put asterisk symbol before it okay so if i run my program now as you can see here we have the address that our pointer is pointing to and then this is the value stored on that address there is one very important thing related to unique pointers and that is that they cannot be shared so in order to demonstrate what i'm talking about let's delete this code here and let's create another unique pointer let's say unique ptr of int like this and let's call it unique ptr two like this okay so what is going to happen if i try to assign to this unique pointer to the same location that my unique pointer one is storing so if i do that as you can see we get an error and that means that you cannot share unique pointers okay now one thing that you can do is you can move the ownership of a unique pointer so what you can do is you can say that your unique pointer two is equal to please move the ownership of my unique ptr one like this and now our unique pointer two becomes the owner of this memory address here so if i try to write out the value that is stored on this address here let's see what we are going to get okay so i am writing out the referenced unique pointer to let's run our program okay as you can see we get the value of 25. okay now one very important thing is that once you move the ownership of a pointer the previous owner which is this one becomes null pointer and that means if you try to access the value of your pointer that was previous owner you are going to get now pointer exception so let's demonstrate that let's say please write out the referenced value of my unique pointer 1 and let's see what is going to happen and as you can see we get an exception because now our unique pointer one is empty it is no pointer and if you are not familiar with exceptions if you don't know how to work with exceptions you can watch the video that i will link here and i will also link it in the description it's called exception handling and there i explain everything that you need to know in order to work with exceptions in c plus another important thing that i mentioned about smart pointers is that the memory is deallocated automatically which means that you don't have to worry about the allocating the memory or causing memory leaks and what i want to do now is i want to demonstrate that so basically i want to create a class and inside that class i want to create a constructor and destructor if you don't know a constructor is a special type of method that is invoked when an object is constructed or created and then a destructor is also a special type of method that is invoked when an object is being destroyed so if you are not familiar with the concept of objects classes constructors destructors and so on i am going to link a playlist here which is c plus plus object oriented programming and i will also put it in the description so c plus plus oop or c plus plus object oriented programming you can watch that playlist in order to understand in more detail what i'm talking about so as i said what i want to do now is i want to create a class um let's call that class my class okay and inside this class i will create a constructor and destructor so let's first create a public constructor so i will say public and then my class okay this is a constructor and inside constructor the only thing that i want to do is i just want to say constructor invoked so i will say see out and let's say constructor invoked like this okay and i also want to create a destructor so i will copy my constructor i will put squiggly before it i believe this is called squiggly or tilde sign um and i will write out here that the structure is invoked okay i hope that i didn't make any typo here okay so i have created a class called my class and inside it i have a constructor which as i already said will be invoked when an object is created and then i also have a destructor which will be invoked at the end of the life of that object which means when that object is being destroyed so what i want to do now is let's delete everything from our main function because we don't need it and what i want to do is i want to create a pointer to an object of this class here so let's create a unique pointer like this of my class and let's again call it unique ptr1 and i will make unique pointer of my class like this okay so let's see what is going to happen if i run my program now as you know already constructor is invoked when an object of this type is created and then this structure will be invoked when that object is being destroyed so if i run this program let's see what is going to happen okay as you can see we only have this constructor invoked so when is this pointer here being destroyed the answer is that this unique pointer will be destroyed at the end of the scope and the scope of this pointer here begins at this curly bracket and then it ends at this curly bracket here so at this curly bracket here this unique pointer will be destroyed and since this is the end of our program we don't see that destructor is invoked so what i can do to demonstrate that is i can create an additional scope so let's do that let's create an additional scope like this okay so now this is another scope and if i run my program now let's see what is going to happen as you can see now we have constructor invoked and then destructor invoked which means that here at this 18th line of code our constructor was invoked for my class object and then at this 19th line of code so at the end of its scope the structure has been invoked which means that our unique pointer has been deallocated so we don't have memory leak so one more time this unique pointer will be destroyed it will be deallocated at the end of its scope which is here okay so that is related to unique pointers and now i want to explain what are shared pointers so as the name itself says a shared pointer can be shared unlike unique pointer a shared pointer can be shared between multiple owners and that means that you can assign one raw pointer to multiple owners so let's demonstrate how that works so let's delete everything from our main function because i don't need it anymore and the first thing that i want to show you is how to create a shared pointer so let's say shared ptr that is the keyword and then you specify the type so the type will be my class so the class that we created here and then let's give the name to our shared pointer let's call it shptr1 so sharedpointer1 and now i want to use a method called make shared in order to make a shared pointer so i will say make shared of my class like this okay so with this we have created a shared pointer now one very interesting thing related to shared pointers is that since you can share a shared pointer it has the count of all of the owners so it has the count of all of the references to that pointer so how can you access that count well there is a method called use count so what i want to do now is i will show you that so i want to write out the number of owners of this pointer here so i'm going to say c out and then let's say shared count like this and let's say shptr1 and then i will use a method called use count like this and this use count method as i already said will give me the number of owners of this location here so if i run my program let's see what is going to happen okay as you can see constructor has been invoked and then the number of owners of this memory location is one because we have only one pointer pointing to that memory location okay let's close this and what i want to do now is i want to share this pointer so i want to create an additional owner to that same memory location so let's create another shared pointer of my class and let's call it shptr2 okay and what i want to do now is i want to assign to this shared pointer to the same memory location that this shared pointer one is holding like this and i also want to write out the number of owners of that memory location after i have shared that pointer so if i run my program now as you can see in this first line it says that the number of owners is one and then in this second line the number of owners or shared count is two okay one question that you might have now is when will this memory location automatically be deallocated and the answer to that question is the memory location will automatically be deallocated when there are no more pointers pointing to that memory location now since that memory location has multiple owners every single owner will be destroyed at the end of its scope and when there are no more owners the memory location itself will be deallocated which means that that memory will be free for other programs and other applications to use so let's demonstrate that as well what i want to do now is i want to put this here into an additional scope so let's do that let's create an additional scope like this and what i want to do now is after this scope i want to write out the count of the owners of this memory location so let's run our program and let's see what is going to happen uh let me know what you expect to happen in the comment section before i run the program okay so as you can see this first line says that there is one owner of this memory location and then we entered inside this scope here and it says that there are two owners and then after we have left this scope this third line this third print says that there is again only one owner of this memory location which means that this shared pointer so this owner has been destroyed at the end of its scope which is this line here now another thing that i said is that the memory location itself is going to be d allocated when there are no more pointers pointing to that location so in order to demonstrate that let's put all of this code inside a scope so i will put the beginning of that scope here and then the scope will end here and what i expect to happen is that this memory location is going to be destroyed at the end of the scope of its last owner so if i run my program as you can see okay let's move this as you can see our constructor has been invoked and that happened in this line of code here so the line where we made our pointer and then the first output says that there is only one owner and that is this 19th line which says shared count and then we have written out the count and then when we entered inside this scope we created an additional owner so this second output here says that there are now two owners and then when we left that scope and we printed the output for the third time we get this line here which says that again we have only one owner of that memory location and then when we left this scope here which is the scope of that last owner we are going to destroy that memory location which means that we are going to deallocate that memory so that other programs and other applications can use it so that was related to shared pointers in c plus and now i'm going to teach you about weak pointers so the main difference between a weak pointer and a shared pointer is the following as you already saw when you assign a specific memory location to a shared pointer that is going to increase the number of owners of that memory location but if you assign that same memory location to a weak pointer that will not increase the number of its owners and that means that we use weak pointers in order to observe objects in memory but a weak pointer will not keep that object alive so we use weak pointers in order to locate a specific object in memory but a weak pointer will not keep that object alive if nothing else needs it whereas a shared pointer will keep that object alive so let's demonstrate what i just explained so let's delete all of this code i don't need it anymore by the way the leading code is my favorite part of coding so the first thing that i want to do is let's create a weak pointer let's say week ptr of let's say for example end so let's create a weak pointer to integer and let's call it we ptr1 wii ptr okay so another thing that i want to do is i want to create an additional scope like this and inside this scope i will create a shared pointer so let's say shared ptr of int and let's call it shptr1 so shared pointer one and let's make one shared pointer so i'm going to use method make shared so please make shared pointer of int and let's assign the value of 25 again okay so after i have created a shared pointer what i want to do is i want to assign this same memory location to my weak pointer so let's do that let's say that week pointer one is equal to shared pointer one like this okay so let's see what is going to happen if i run this program i'm going to put a break point here so at the first line of my main function and if i run this program let's see what is going to happen so now we are debugging this program okay so in this first line we are going to create a weak pointer and it is still not pointing to anything as you can see it is empty we just created it we didn't assign any location to that pointer okay and then after we have created that weak pointer we are going to enter into this scope here and inside this scope the first thing that happens is we create a shared pointer and then we assign the number 25 to that memory location that our shared pointer is holding so let's do that okay and if i hover over my shared pointer as you can see it is pointing to a memory location that has one strong reference and on that memory location we are storing the value of 25. okay now in this second line of code we will assign this shared pointer to our weak pointer so if i execute that line of code let's hover over our weak pointer and as you can see now our weak pointer as well is also pointing to the same memory location and that memory location stores the value of 25 and it has one strong reference but one thing that will happen when i leave this scope here is following please write me in the comment section what do you expect to happen after i leave this scope here so if i press f10 and leave this scope and if i hover over my weak pointer here or here there are two things that you can notice the first thing is that it says that there is only one weak reference to this memory location so there are no more strong references and then another thing is that it has expired so all of the owners all of these strong references to this memory location have been destroyed and now we have just a reference we just have the address of a memory location that has been deallocated and that is exactly what i've been talking about which is that a weak pointer will not keep an object alive whereas a shared pointer will so this memory location has expired it was deallocated when its last strong reference so when its last shared pointer or when its last owner left its scope and that happened on this line of code here so i hope that this video was helpful if it was please give it a thumbs up for the youtube algorithm and also share it with someone who would like to learn programming because many people would like to learn programming but they just don't know where to start so you can be the one who helps them and makes the difference and also if you have any questions you can leave those in the comments section and please let me know what kind of videos you would like to see in the future so thank you very much for watching and i am going to see you in some other video bye
