hey there how's it going everybody in this video we'll be creating our own database tables for our application so that we can create real posts instead of relying on dummy data and to work with these databases Jango has its own builtin ORM now if you don't know what an ORM is it stands for object relational mapper and basically it allows us to access our database and and easy to use object oriented way and the thing that I like about it most is that you can use different databases without changing your code so if you want to use an SQLite database for testing and a Postgres database for production then all you need to do is set up a different database in our settings but all of the code to query the database will still be the same and that's what we'll be doing in this series we'll use an SQLite database for development and a Postgres database for production so let's go ahead and get started so that we can see what this looks like now the great thing about the django ORM is that we can represent our database structure as classes and you'll hear those classes be called models and doing the database structure this way is actually very intuitive after you get the hang of it so within our blog app django has already created a model stop py file for us so within the blog app directory let's open up that models dot py so within our models top py file we need to think about what we actually want to save to the database so the main things that we're going to have for our blog application are going to be users and those will be the authors of our posts and then we're gonna have the posts themselves now like we saw in the previous video Django already has a builtin authentication system and already has a user model that it's created for us and we've already seen how to create some users with that so we're not going to make a new user model just yet now in a future video we'll see how to add custom fields to that user model that aren't already there but for now we are simply going to just make a post model and this will be a class that inherits from Django model class and we can see that it's already imported these models for us so let's go ahead and create our post class or our post model so I'm going to delete the comment that we have here and now let's create this post model so I'm going to say class PO and we are going to inherit from models dot model so each class is going to be its own table in the database and now we'll create some attributes and each attribute will be a different field in the database so let's add the fields that we want for a post so one field that we'll have for a post will be the title so we can say that the title is equal to models dot char field so this is going to be a character field and we can set some arguments here that will specify some restraints on these fields so I can set a max length here equal to 100 so now we have a title that will be a field of our post table in the database and that title field will be a character field that has a restriction of a max length of a hundred so now what else do we want for a post so we also want content for the post so we'll say content is equal to and we'll set this equal to models dot text field now the text field is similar to the character field but with our content here it's going to be you know possibly lines and lines and lines of text so a text field here is just unrestricted text okay and lastly for a post we're also going to want a date posted field so that we can keep track of when these posts were created so I'll say date posted is equal to models dot and this will be a date/time field okay so for our date/time field we have a few different options here now we could set an argument of Auto underscore now equal to true which means that we would update the date posted to the current date time every time the post was updated now that's not exactly what we want so that would be great for a last modified field or something like that but this is going to be when the post was actually created now we could also set an argument of Auto underscore now underscore add equal to true and that would set the date posted to the current date time only when this object is created and that sounds exactly like what we want but there's a caveat there so with that auto now now add argument you can't ever update the value of the date posted so it will have to keep the exact date time of when the post was created now maybe that's what you'll want but I like having the option of changing these dates if I want to so instead I'm going to use an argument I'm going to use neither of those Auto now arguments and instead I'm going to use an argument of default and we're going to import a Django utility for this default so here at the top I will say from Django dot utils import timezone and this will be a date time that takes our timezone settings into consideration so now for our default we can simply say default is equal to timezone dot now and also notice that we didn't put the parentheses after timezone dot now like this now this is a function but we don't actually want to execute that function at that point we just want to pass in the actual function as default value so be sure that you don't put parentheses there to execute that okay so now moving on we also need to have an author for each post and this will be the user who created the post now our user is a separate table so first we need to import the user model and Django created that in the location so up here in our imports will say from Django oops from Django dot country dot auth dot models import user so the post model and the user model are going to have a relationship since users are going to author post specifically this is going to be called a onetomany relationship because one user can have multiple posts but a post can only have one author and to do this in Django we can simply use a foreign key so I will come down here to our other field and say author is equal to models dot foreign key and then the argument that we want to pass into that foreign key is the related table and that will be user now we're also going to need a second argument here called on underscore delete so undelete and this is needed because we need to tell Django what we want to do if the user who created this post gets deleted so if a user created post and then the user was deleted then do we want to delete the post or do we want to set that author to none or what do we want to do well for this app we'll just say that if a user is deleted then we're also going to delete their posts as well so the argument we're going to pass in here is on delete is equal to oops is equal to models dot cascade and cascade is going to be all uppercase so again that's just telling Django that if a user is deleted then we want to delete their posts as well but that's only a oneway street so if you delete a post then it's not going to delete the user because you know that would be definitely a bad design okay so that does it for our post model so that is all of the information that we need so now that we've made some changes to what our Django database is going to hold now if you remember in the last video we needed to run migrations in order to update the database with any changes so let me pull up the command line here and now we need to rerun those migrations in order to get any changes to our database so if you remember in order to create those migrations we need to say python managed py make migrations so let's run that and we can see that it says that it made a migration in this location blog migrations 0 0 0 1 underscore initial dot pi now I never really touched these files myself but they are files that we can open up and look at so within our app if we go back to sublime here within my blog app I'm going to expand this migrations directory and within this migrations directory we can see this 0 0 0 1 underscore initial dot pi so let's open this up so this is what got created when we ran and make migrations and we can see a bunch of information in here about what it will do once we actually run the migrate command so the make migrations command made these files for what it will do and the migrated command will actually run these and we can see a couple of things about this migration so we can see that it says initial is set to true we can see that the name of the model that it's creating is post and we can see some that we can see all of the fields that we created here so that's a lot more information than what we put in but it created that for us ok so before we actually run the migrate command to actually create this table in our database let me show you how you can view the actual SQL code that this will run on the database now this is great if you're having issues and need to see the exact xql code or SQL code that is going to be generated whenever this is run so to do this let's pull back up our command line and the things that we're going to want to remember are the blog here which is the app name and also the migration number which is the zero zero zero one that's how we can view the SQL that's going to be run so I can take that information and say Python managed py SQL migrate and now the now the app name which is blog and then the migration number which is zero zero zero one so if I run that then this actually prints out the SQL code that it's going to run so we can see here that it does a create table of blog post and then an ID field here which we didn't specify but it does a primary key automatically that auto increments we have a title which is a varchar' of a hundred characters so it takes that simple class that we created and it writes out the SQL for all of the fields that will be compatible for the database that we're using which right now is SQL Lite so this saves us a ton of time and a lot of effort if we had to write that SQL ourselves and really it made it so that we didn't even need to know SQL to work with this database we just used that Python model class and our models not py file and it wrote this backend SQL for us so that's why these object relational mapper ZAR so convenient we don't actually have to get our hands dirty with the SQL code a lot of the time ok so now let's run the migrate command so that it runs the migration and these changes take effect on the actual database so I'm going to clear my screen here and now let's run that migrate command so I'll say Python manage py migrate so if we run that then we can see that worked and that we get an ok status there now I should also mention why migrations are so useful so migrations are useful because it allows us to make changes to our database even after it's created and has data in that database so if we didn't have a way to run migrations then we would have to run some complicated SQL code to update our database structure so that it didn't mess with the current data but with migrations we can simply make whatever changes we need run make migrations and then run migrate and it will make all of those changes for us ok so now that those changes have been added to the database let's see how we can query the database using these models now the Django ORM lets us do this through the classes as well so to illustrate this I'm going to run the Django Python shell which will allow us to work with these models interactively line by line so we can run the shell by saying python managed py and that is the shell command so if we run that then we can see that we get what looks to be a Python prompt and that's exactly what it is we can run Python code in here but we can also work with our Django objects so for example let's import both our post model and our user model so let me clear the screen here first and now to import that post model we can say from blog which is our app blog dot models we want to import post and now let's also import that user model now if you don't remember where that is that is in Django dot country dot auth dot models and we want to import user now if you were following along with the last video where we created two users in the admin page then we know that we already have two users so let's query our users table and see if we can see those so if we want to just get all of the users then we can simply say user dot objects dot all so if I run that then we can see that it returns a query set result and within that query set we have this user for core EMS and this user for test user so it returned both of the users that we created in the last video now if we just wanted to get the first user then we could access it from that list or we could use the first method that just gives you the first result so if I was instead to say user objects dot first then we can see that now we just get that first user and there is also a last method to give us the last result now we can also filter the results by using the filter method so if I was to say user objects dot filter now we can filter by a field so I can say username is equal to and I'll say username equal to core EMS now that gives me a query set as a result but the query set only has one user since the user names are unique now if that field wasn't unique then it's possible a filter could return multiple results so we could use the first method here as well just so we can Garrett grab the first result of that filter so if I run that filter again then I can do dot first and now we can see that we just get that user instead of the query set with the one user and that the query set so now let's actually take a look at this user that is getting returned so I'm going to run that same query again where we grab the first user from that filter but now I'm going to capture this in a variable so I'm going to say user is equal to user object stop filter with a user name of query MS and grab the first result of that filter so if I run that then now we have this user captured in this user variable now let me clear my screen here so that we have some more room so again we now have that user variable and now we can actually look at the attributes of this user so I can say user dot ID and see that this user has an ID of 1 now we can also use the PK attribute to get that ID which stands for primary key so if we say user piqu√© then it gets the primary key which is the same as the ID now we can actually perform a queries using that ID as well so we already saw user dot objects dot all and user dot objects not first but if we were to say you know user is equal to user dot objects dot get then we can get by an ID so I'll say ID is equal to one and if I look at that user then it's that same user that we saw had an ID of one okay so now let me clear the screen again so now we have this user variable that is equal to this user so now let's create a new post and make this user the author of this new post so first of all we shouldn't have any post right now so if I run a query on the post model and say post dot objects dot all and run that then we get an empty query set and that's how it should be because there are no posts so now let's create some post written by this user so that we can see what this looks like so I can say post underscore one is equal to post and now we can fill in the fields so I'll say title is equal to blog one and then we'll set the content equal to oops I'm sorry that content should not be in a string like that sorry about that I wanted the string to be the actual content so for the content I'll just fill in first post content with an exclamation point and now we also need to set the author so I'll say author and sorry it's going on to multiple lines there but I'll say author is equal to and I'll just pass in at that user variable so now let me run this and we can see that it doesn't give us an error so that probably worked now also notice that I didn't specify a date for this post now if we remember from our model we have a default date of the current date time so it should populate that with the current time if we don't provide it anything so now let's query our post table again so I'll hit up here a couple of times and rerun that post out objects not all and we can see that this is still an empty query set so there are still no and the reason is because we created a post object as this post underscore one variable but we didn't actually save it to our database so to do that we can say post underscore one dot save and if we run that save then now let's require our post object or our post table again so post dot objects not all if we run that then we can see now we get a query set with one post object and since our screens getting a little crowded let me clear the screen and rerun that again okay so this is good that we have one post object now this post object isn't very descriptive so if you remember when we printed out our users it showed us the usernames of the user which is nice and descriptive so in order to get this post object to be more descriptive we have to tell it what we want to see when we print it out and we can do that with the dunder STR method so I'm going to go back to our models and add this so I'm going to keep the shell open here and open our project back up I'm going to close out of the migrations file and go back to our models py where we created this post model and within our models we want to create a dunder STR method and thunder means double underscore so this is gonna be def double underscore STR double underscore and we need to take self as an argument and now we can return how we want this to be printed out so I just want a pose to be printed out by the title so I'll just say return self dot title now if anyone has seen my objectoriented series then I go into more details about these double underscore methods they're also called magic methods or special methods so if you're interested in this stuff then you can watch my objectoriented series where I go into this stuff in a lot more detail okay so with that dunder STR method in place let's open back up our command line here now in order to get those changes to take effect we're going to need to exit the shell and open it back up so I will exit out of that and now let's rerun that Python shell command so python managed type py shell and now we need to reimport our post and user models so to import the post model I'll say from blog models import post and import our user model remember that is in Django dot country dot auth dot models import user so now if we query all of our post objects again so I'm just going to grab the same query that we did before so post dot objects all if we query that again then now we can see that we get a query set and the object now says post of blog one so now it's using that blog title in order to print that out ok so now let me clear the screen here so now let's add one more post that is similar to the one that we just created now remember I exited the shell and opened it back up so I lost our user variable that we were working with so let's create that again so I will just say user is equal to user dot objects dot filter and we wanted to grab the user with the username equal to Corrie m/s you can use whatever user you created and then we'll just grab the first user that matched to that filter so now that user we can see is user query MS and now let's add one more post that is similar to our first with this user as the author so I'll say post underscore 2 is equal to post and then we'll pass in a title equal to blog two and we will pass in and I put those strings there again we could pass in the content equal to a string of second post content and let me make the screen a little smaller here so that this new line it gets pushed a little early here okay so now last time we created post we for our last item we said author oops and it looks like when I resize that messed up our text a little bit so let me just run that early and get an error and then rerun this so second post content so now the last time we created an host object we said author is equal to user but instead of setting that author equal to our user we can also use the ID as well so we can say author underscore ID is equal to user dot ID so now if I run that then we could see now we didn't get any errors there so that probably worked now remember if we actually want to save that to the database then we have to run the save method so you don't want to forget that so we can say post du dot save and run that and now let's query all of our posts again so we can say post dot objects dot all and now we can see that we have two blog posts so again my screens get a little crowded so let me clear that out and rerun that so now let me grab that first post and give that a look so I'm going to save it into a variable so I'll say post is equal to post dot objects and I'll just grab the first one so I'll say dot first and now we should be able to access all of the fields added to our model so if I say post dot content then we can see the content of that post and like I said our date posted should have been added automatically even though we didn't actually set it whenever we created that post object so let's test that to make sure that that is true so I'll say post dot date underscore posted I think is the field that we gave and we can see that that is a date time object and this is the date time that this was posted and lastly if we look at the post author so if I say post dot author then we can see that it returns that user object and that is actually the entire user object so you could even access that user objects attributes so for example if I wanted this users email address then instead of rerunning another query or anything like that I could simply say post dot author dot email and we can see that now we get that authors email address and that's a really nice feature that we're able to get that extra information from that foreign key like that okay so now let's see how we would get all of the posts that were written by a specific user so let's say that we wanted to get all of the posts that were written this user here now you might think that we need to fetch the user and then do a query on the post model filtering by posts with that user as the author and that is definitely one way to do it but Jango also adds a special query set to the user model that allows us to do this a lot more easily and the naming convention for this query set is the name of the related model then underscore set so it would look like this it would be a model name underscore set so when it comes to our user the related model is named post so we can access the post of our user variable simply by saying so let me say user so we have this user here with this username now if we wanted to get all of the posts that they have written then this is user dot post underscore set so if I run that then we can see that it returns something that isn't too readable but we can actually use that post set to run queries on the post that this user has created so if we wanted to get all of the posts then we could simply say user dot post underscore set dot all and if we run that then we can see that now we have a query set of the two posts that we've just created because this user is the author of both of those posts so let me clear the screen here and show this one more time so if we want to get all of the posts that a user has created we can use the post underscore set and that gives us something that we can run queries against so if we say post set dot all then that gives us the two posts that they offered now we can actually create a post directly using that post set so if I wanted to create a third post directly using this user then I could simply say user dot post underscore set dot create and then we can create a post I'll set a title equal to blog three and we will set the content and I keep putting that and stream for some reason then we can set content equal to third post content with an exclamation point and now I can hit enter and it will create that post now notice that we didn't specify an author for that post because Django knows that we wanted to create that post for that users post set which means that it automatically makes them the author and we don't need to run dot save or anything like that either it automatically saved that to the database so now if I query all of our posts again so I'll say post dot objects dot all then we can see that now we have three blog posts okay so I think that's a pretty good overview of the database queries that we can make now I know that that's a lot to take in so if you need to go back and rewatch that section a couple of times then it might take a while for some of that to sink in so now let me exit out of our shell here so I will exit and now let's do two more things before we finish this video so first let's use the database queries that we just learned in order to use this real data that we've added to our database instead of the dummy data that we have right now and second let's also see how we can edit this post data within the admin page of our site so first let's make some queries in order to grab this data in our database and pass it to our views so let's open up our blog views where we currently have that dummy data so within sublime text I'm going to navigate to my blog app and open the blog views and we can see here that we currently have this dummy data of these posts and we're passing in that dummy data into our context so instead of using that dummy data let's instead run a query on our post model and pass in all of that data instead so first we need to import our post model so at the top where we're doing our imports we can say from dot models now since this models is in the same directory that's why we're using that dot models and we can import post and again that dot in front of the models layer just means from the models file in the current package import our post class so now with when within our contacts down here in the home instead of passing in that dummy data let's instead query all of our posts from the database like we saw in the command line so we can simply say post dot objects dot all and as long as those dictionary keys were the same names as our database fields then we shouldn't have to change anything it should have just worked now if your database fields are different than the keys that you put here in your dummy data dictionary then you'll have to go into your templates and change those accordingly but for now mine were the same so let's open up our site and see if we're getting the blog post from our database now so I will go back to our command line and we need to run our development server so I'll say Python manage py run server and now let's run the openness in our browser so we'll run that so when I reloaded that you could see that it brought in different posts so now these are the posts from our database and not the dummy data that we had before now it might be hard to notice but there is one difference here our dates aren't the same format as they were in our dummy data and that's because it's using the date/time directly from the database without any formatting so you can see that the date/time here says August 28th 2018 to 46 a.m. so that's kind of a weird formatting for it to have on our page so really we would just want this to display the whole month the day and then the year we don't really need the exact time and the display you know unless you were doing something like a Twitter application or something where you expected tons of post then it would might be nice to have the exact time there but I'm gonna change this to where it's just the whole month the day and then the year so let's open up our homepage template and see how we can change the formatting of these dates so I'm going to go back to our application and within our blog app I'm going to open up templates and then the blog subdirectory and then the home template okay so we have our home template here where we're looping through our post so now let's find where we're printing out that date posted so that is right here where we're printing out that posted date so within our template tags there are different filters that we can use to change our data around a little bit so for dates there is a date filter so to use this we can use the vertical bar character and then the filter so I can put in a vertical bar and then use date as a filter and then after that date filter then we can put a colon and inside of a string we're going to specify how we want to format our date now in order to get the formatting codes for how you specify a certain date then you're probably going to have to look in the documentation and I have this linked in the description section below now I never remember these either and I always have to look at the docs so I have this actually pulled up in my browser so if I go back to my browser here then I have the Django date documentation pulled up here so let me make this a little bit larger so that everyone can see so I think that is good there so these are the date format characters and what they are equal to so remember we want the full month and then the day of the month and then the year so if I scroll down here a little bit then we can see the full month over here so the format character for that is capital F and then we want the day of the month after that and if we look up here then that's actually the first one here the lowercase D is the day of the month two digits with leading zeros and then we'll also want to print out the full year and if we scroll down a little bit then we can see a full year here and the format code for that is a capital y and you can use whatever formatting code you want to print out the date in any way that you want but for this application I'm going to use that capital F to do the full month lowercase D for the day and then the uppercase Y for the year so now let's go back to our template and fill in that information so I will go back to our template here and with this date filter I'm going to specify that we want this as capital F for the full month and then a space lowercase D to specify the day then I'm going to put in a comma to separate the day in the year and then a space and then a capital Y so let's save that and now with that save let's look back at our home page in our browser so if I pull the browser back up here and reload the home page then we can see that now that time is no longer there it just says August 28th 2018 okay so that's great so now we can see that those dates are formatted how we want them to be so now let's go back to our views and delete that post dummy data that we were using in previous videos because now we don't need that anymore and it's taken up a lot of room in our views so here within our views we're now using that post out objects not all for our context so we no longer need this list of dummy data dictionaries there so now we can save that okay so I know that this video is getting a little long but there is one more thing that I'd like to cover while we're on the topic of database models so we saw in a previous video how the admin panel allowed us to create update and delete different users using a GUI on the admin page now we can do that within or with this new post model but we'll have to do something first so what I mean by that is if I go to our website right now and go to our admin panel and let me make this a little bit larger so everyone can see so within our admin panel we can still see our groups and our users but where are the posts well in order to see that model here we actually have to register that with our admin page so if we look in our app directory so let me open back up our page here if we look in our blog app directory then we should be able to see an admin dot py file so that is in the same directory as your model snot py and your views top UI and things like that so let's open that blog admin dot py file and we can see that it says register your models here and we're already importing this admin class so let's get rid of that so this is where we can register our models so that they show up on our admin page so to do that we first need to import our model so here at the top I'll say from dot models import post and now to register this model with our admin site we can say admin dot site dot register and pass in that post model and save that and it's just as easy as that so now if I reload our admin page and go back to our browser and reload that now you can see that it just popped up with these post objects so now within our admin page we can go inside these posts and we can see that we have blog one blog to block three and we could you know create new posts or update these however we want so within a blog one I could say my first updated content and blog one updated and we could save that here and we can see that we were able to actually update that blog post from within our admin page and we can also change the authors of these blogs so if I was to click on this blog 3 post then if we scroll down here we can see that the author is set to Cory M s now if I wanted to change this then I could just simply click on that dropdown and we can see that test user which is our other user that we've created is an option so if I select him then I can save that and now with those changes that we made in the admin site if we go back to our main page and let me reset the size of our browser here if we go back to our main page then now we can see that our blog 1 was updated with a new title and down here at blog 3 it's now saying that test user is the author of that blog so that's awesome that's extremely powerful that right out of the box with Django we have the ability to go into the admin page and just change all of our models and all of our objects using that back in admin view and it has a nice GUI to where we can go in and change all of that stuff on the fly all right out of the box so that is perfect ok so I think that is going to do it for this video I hope that you got a good sense for how the databases work and how we can create models also how we can add data and query data and also get this hooked up to our admins in order to see and work with it in an easier way within that admin panel so in the next video we'll be learning how to create and validate a user registration form so that we can get started with creating some accounts on the front end of our website so that users who don't have access to the admin page can still have that functionality but if anyone has any questions about what we covered in this video then feel free to ask in the comment section below and I'll do my best to answer those and if you enjoy these tutorials and would like to support them then there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means you can contribute through patreon and there's a link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you