hey there how's it going everybody now this is going to be a pretty quick video and in this video we're going to be going over how we create decorators that accept arguments now several people had requested this after I put out my decorators tutorial video and in that video I go over decorators in depth but one scenario that I didn't go over was creating a decorator that takes arguments now this is something that you'll see from time to time so for example if I look at the hello world application for a flask website now if you've never used flask then it's not a big deal I just pulled down their hello world application so that we could see an example of a decorator that takes arguments now we can see here that their routes are defined using these acts route decorators and the string gets passed in is the URL path and there's an example here with the about page as well this argument is the URL path to that decorator so this is something that you'll see from time to time and it's useful to know how to do this so let's go ahead and see how it's done now I have a very simple decorator example pulled up here which is very similar to the one from the decorator tutorial video that I've done before now just a quick recap of what's going on here now what we have is this display info function that takes two arguments name and age and it's being decorated with this decorator function and up here with this decorator function we can see that it takes an argument that is the original function and then nested within our decorator function we have this wrapper function and that just takes any number of arguments or keyword arguments now within our wrapper function we are executing some code before our original function executes so in this case we're just printing out a line that said executed before original function and then we are executing our original function and saving it to this result variable and then after that we're executing some code after our original function and in this case it's just another line that says executed after the original function and then within the wrapper we are returning the result of that execution and then lastly here outside of our wrapper function now we are returning that wrapper function of waiting to be executed so if any of that was overly confusing then you might want to go back and watch that decorator tutorial just to get a refresher of what's going on okay so let's go ahead and run this code as it is now so we can see down here we ran display info twice with two different names and two different ages now every time we ran display info our decorators also added the functionality of printing out a line before and a line after that wrapped function now this is something that we've seen before in the last video so now let's go ahead and get our decorator function to accept arguments so for this example let's say that I wanted a customizable prefix to all of these print statements within the wrapper now this would be a good candidate for an argument to the decorator the argument that we pass in will be that prefix now in order to do this we're just going to add another outer layer to our decorator so I'm going to call this a function a prefix decorator and now I'm going to have this take an argument and I'm going to call that argument prefix and then I'm going to nest one more level deep and put that decorator function inside that prefix decorator now just a warning this is going to get even harder to keep track of everything and now that this is nested another level let's go ahead and see what this looks like so now everything that's nested within here has access to this prefix argument here so let's just add this prefix to the beginning of both of our print statements like we wanted so I'm going to go ahead and put that prefix in there and just put a comma there and it will add the space in automatically and now lastly since this is nested one more level now we have to do another return so this time we're going to return our decorator function uh neck's acute 'add so I know that this multiple nest of functions can get really confusing really fast but all we've done here is add one more layer to our existing decorator that accepts whatever arguments we want and then use those arguments somewhere within our decorator so now when we get radar functions we use the outside function here that takes the argument so I'm going to replace this decorator down here with prefix decorator so now we can pass in our argument to this decorator so in this case it's the prefix that we want added before our print statements here so I'll just start off by saying testing with a colon there so now if I run that then you can see that now we have that testing prefix before our print statements in our wrapper function and you can change this any time that you want so now if I want that to say log instead and then I'll rerun that then you can see that now log is that prefix ok so I think that about does it for this video now this probably isn't something that very many people will ever need to do but when you do need it it's nice to know and especially when you see it in code like you know in the flask examples and other frameworks then it'll be something nice to know at least how it works so hopefully after this video it makes sense for how you go about doing something like that but if anyone does have any questions about what we covered in the video then feel free to ask in the comment section below and I'll do my best to answer those now if you enjoy these tutorials and would like to support them there are several ways you can do that the easiest way is to simply like the video and give it a thumbs up and also it's a huge help to share these videos with anyone who you think would find them useful and if you have the means and you can contribute through patreon and there's the link to that page in the description section below be sure to subscribe for future videos and thank you all for watching you