hey how's it going everybody in this programming terms video we're gonna look at the term memoization so let's go ahead and take a look at the definition of memoization and then we'll look at a code example to see exactly what this means so according to Wikipedia memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same input occurs again so that may be a little confusing just by the definition alone so let's go ahead and look at a code example now my code example here is going to be in Python but just like my other programming term videos it's not really the language that I want you to take away from it it is the concept of the term itself so this will apply to several other programming languages as well so the first part of the memoization is this expensive function here and I made a function call it expensive func and what it does is it just comes in here and prints out that it is computing the value that we pass in then it sleeps for one second and then it just returns the square of the number so the time that sleep isn't actually computing anything but this is just kind of an artificial expensive function call so then if you look down here we're actually running this function four different times so we've run the function with a four with a ten and then a four again and then a ten again so since it sleeps for one second for every function call then this entire program should take about four seconds so if I run this you can see that it prints out that it's computing four and then prints the square then computing ten and prints out the square and so on and so on so the reason behind memoization is that if you saw here it computed four and ten the first time with the sleep and that's our artificial computing time and that's fine because the first time that it sees it it has to do that but then when we got to the second one we've already run those values once and so instead of computing those values again it would be nice if we just remembered that answer and remembering the answer is what memoization is all about we are saving that result to a cash that whenever we see that expensive function call again with the same values passed in that instead of actually computing the values again we can just return the result that we've already computed from that cache so the way that I'm going to do this in Python here is I'm going to create a dictionary up here and I'm just going to call this EF underscore cash and the EF is just for expensive function so now what I'm going to do here is write at the top of the function I'm gonna say if num which is the parameter that we're passing in is in the EF cache then I just want to return the value from that dictionary and also what I'm gonna do down here is if it misses this conditional if the number is not in the cache already then I want to go ahead and do the artificial computation here and then before I return the result I just want to add that result to the cache so actually a more clean way that I'm going to do this here is I'm just going to say result equals num time not num times num and then I'm going to copy this result here and put that in the cache and then I'm going to return the result there and save that so now if I run this code again you can see here that it finished in two seconds and the output here it only computed the for one time and gave us our answer of 16 then it computed 10 one time and gave us the answer of a hundred and then the second time through you can see that it never hit this computation step so it just automatically spit out 16 and automatically spit out a hundred now let me walk through exactly what happened here so we did this result equals expensive function and passed in r4 so whenever we passed whenever we ran this function the first time it came in and it said is 4 in our cache and it wasn't so then it skipped over this conditional and it printed the computing for it slept for a second and then returned the result after it added the result to the cache and then it did the exact same thing for the tin now the second time through when we ran these functions they came in here and right off the bat it said is our number in our cache and yes it was so we immediately returned the result that we saved right here from earlier so in the case of this simple program the memoization cut our computation time down from four seconds to two seconds now for more complicated problems than obviously this can be more or less drastic now there are some more advanced things that you can do with memoization you can set up ways to where it does memoization automatically and things like that but really the point of this video was to just let you know exactly what memorization means if you ever see that in the workplace and also maybe you can start thinking about ways that it can benefit you in the language of your choice so that about does it for this video I would recommend going out and seeing different techniques for using memoization within your programming language of choice and it's definitely a nice skill to have in your tool belt so I hope this video is useful for you all if you have any questions just ask in the comment section below be sure to subscribe for future videos and thank you all for watching