With timestamps:

00:00 - in this tutorial we'll explore how
00:01 - inheritance works in the Godot game
00:03 - engine I'm using good of three here but
00:05 - these lessons will also apply if you're
00:07 - using 2.1 still in object-oriented is a
00:12 - really powerful tool you can define a
00:14 - class that inherits from another class
00:16 - which means that it will contain the
00:18 - methods and variables of that class in
00:20 - addition to its own Godot is very
00:23 - strongly object oriented and you can use
00:25 - inheritance when defining classes in
00:27 - scripts as well as with scenes for this
00:30 - tutorial we're gonna assume we're making
00:32 - a classic top-down RPG and we'll use
00:35 - good O's inheritance capabilities to
00:36 - create two different kinds of characters
00:38 - in the game here's a preview of what
00:40 - we're making so we have two kinds of
00:43 - characters here we have NPC characters
00:45 - that you see wandering randomly around
00:48 - and then the green character there is
00:51 - controlled by the player and it's moving
00:53 - when I'm pressing the arrow keys
00:56 - starting with the project settings I've
00:59 - made the width and height I'm going to
01:02 - set those to 640 by 480 we are using 32
01:06 - by 32 tiles for that tile set so we
01:09 - don't need a really big screen for this
01:11 - and then in the input map I've also set
01:15 - up some input actions and those are
01:18 - called left right up and down and
01:22 - specifically and these are assigned to
01:24 - the arrow keys corresponding arrow keys
01:26 - but specifically they're named that for
01:29 - use in the code later it's going to make
01:31 - things easier if we have these names
01:33 - match the names of the directions that
01:36 - the player can move in and if you
01:40 - download the art from the zip file that
01:43 - I'll link in the comments below it has
01:46 - in it unzip that into your project
01:48 - folder and it's got a couple of tiles
01:51 - for the grass and the stone walls and it
01:54 - has a folder called RPG sprites that has
01:56 - spreadsheet animations for a variety of
01:59 - different little RPG style characters
02:02 - now our goal in this project is to
02:04 - create two different kinds of characters
02:06 - one controlled by the player and one
02:09 - that will be an NPC that we will walk
02:11 - around by itself
02:13 - but both of those characters are gonna
02:14 - share a number of different properties
02:17 - and functions they're each gonna have a
02:20 - sprite sheet using one of these
02:23 - different sprite sheets that are all
02:25 - arranged in the exact same way they have
02:27 - three frames of animation for each of
02:30 - the four directional movements there so
02:34 - they're each going to need an animation
02:35 - player to play those animations the game
02:40 - is going to be based on tile based
02:43 - movement which means that the characters
02:46 - when they move around will move from
02:47 - tile to tile so if they're standing on
02:49 - one tile they'll move exactly 32 pixels
02:52 - in whatever direction to go and stand on
02:56 - the next tile
02:56 - there's no fractional tile movement in
02:59 - this example and then of course they
03:02 - need to not be able to move through
03:03 - walls so they need some sort of
03:05 - collision detection so what we're gonna
03:07 - do is we're gonna create a scene that
03:09 - contains all those common features and
03:13 - all those common properties so we'll
03:15 - start by making a new scene and we're
03:18 - gonna add an area 2d area 2d is going to
03:21 - be the parent because we're going to be
03:23 - moving it via animation I'm not worried
03:26 - about kinematic collisions or things
03:28 - like that obviously you could do it that
03:30 - way too if that were the kind of thing
03:32 - you were going for but this is going to
03:34 - be a character we're going to call this
03:36 - character and save the scene now this is
03:41 - going to need a sprite child it's going
03:46 - to need a collision shape collision
03:49 - shape 2d it's going to need a tween oops
03:55 - it made that a child of the collision
03:58 - shape I'm gonna call this the move tween
04:02 - because this is gonna handle the
04:03 - movement from one tile to the next
04:05 - changing the character's position and
04:07 - then we're going to need an animation
04:09 - player to actually play the animations
04:13 - themselves and change the sprite so
04:17 - we're going to leave that sprite without
04:18 - a texture because each character will
04:21 - have a different texture we're going to
04:22 - leave a blank here but we can go ahead
04:24 - and make the collision shape since all
04:26 - of these are going to
04:27 - the same if you were doing something
04:30 - where your player character had needed a
04:33 - different hitbox than the NPC's then you
04:36 - could leave that blank and set it on the
04:37 - individual objects but we're gonna set
04:40 - it here so I'm gonna add a new rectangle
04:44 - shape and then I'm gonna click on
04:46 - rectangle here and I'm going to set the
04:48 - extents to 10 by 18 which is gonna make
04:53 - a rectangular shape that's gonna be the
04:55 - perfect size for our sprites and let me
05:00 - just lock the children and drag it out
05:03 - on the screen so we can sort of see it
05:04 - in the middle so now the animations are
05:08 - going to be based on these textures if
05:12 - you haven't done sprite animation before
05:14 - using the animation player we're
05:16 - essentially going to be changing the
05:18 - frame of the sprite so on the sprite we
05:21 - need to configure it with the number of
05:23 - frames that it has so there's an
05:25 - animation section here number of
05:29 - vertical frames never number of
05:30 - horizontal frames well we have three
05:33 - horizontal and four vertical so set that
05:37 - to three and that one to four four
05:40 - vertical frames three horizontal frames
05:42 - and then changing this property will
05:44 - step through each one I'll snap one in
05:46 - there real quick just so you can see
05:48 - what it looks like so as I move the
05:52 - frame property you'll see we're going
05:55 - through each of the frames until we get
05:57 - to the twelfth one and we'll go back to
06:00 - zero and so the animation player is
06:02 - going to change those over time to give
06:04 - the walking animation for the direction
06:06 - we want so in the animation player I
06:09 - have created four animations
06:11 - up down left and right again making sure
06:15 - that they match the same spelling I used
06:17 - in the input actions lowercase spelled
06:22 - exactly the same because they're going
06:23 - to use that name the same name in our
06:25 - variables in our script so this is the
06:27 - new animation button so I just clicked
06:30 - that four times and name them each now
06:32 - each one is going to be 0.8 in length
06:37 - that's how long we want the animations
06:39 - to be
06:40 - and you can zoom out a little bit so you
06:44 - can see we're going to have our step in
06:48 - our animation players set to 0.1 so it
06:50 - snaps each one so basically we're going
06:53 - to do a frame of animation every other
06:55 - step and for example when we're on the
06:59 - sprite when we're on frame number zero
07:01 - that's the first frame of the walking up
07:03 - animation so I'm on the up animation and
07:06 - I'm going to click the keyframe next to
07:09 - the frame property when I am on zero and
07:13 - it asked me if I want to create that yes
07:15 - now we move over to number two and we're
07:18 - going to use frame number one then we
07:21 - move over to zero point four and we're
07:24 - going to use frame number two and then
07:27 - we go to number six and we're going to
07:29 - go back to frame number one so we have 0
07:34 - 1 2 1 and if I go back to the start here
07:40 - and hit play let's see we have a little
07:42 - walking and then it gets to the end and
07:44 - we're going to stop and that's because I
07:49 - don't want this to loop because this is
07:51 - going to play one time moving one square
07:54 - so just do that same thing for each of
07:57 - the other three animations and I will
08:00 - jump ahead so I've made the other three
08:02 - animations now they're each set up and
08:05 - we'll go in whatever direction we want
08:07 - it play here you can see there's the
08:10 - walk into the right one and the last
08:12 - thing we need to add here to our
08:14 - character is the collision detection the
08:18 - nodes they're going to detect whether it
08:21 - can move into the next square so if it's
08:22 - standing on a square and we say move
08:24 - right but there's a wall there we want
08:26 - it to not move so we're going to use ray
08:29 - casts for that so if we add a ray cast
08:32 - to D and then duplicate it three more
08:35 - times we're going to name these ray
08:37 - castle left right up and down and by
08:42 - default ray casts are off so make sure
08:44 - you select all them and check it to
08:47 - enabled and we need these to point in
08:49 - the direction they're going so right
08:50 - cast left is going to point to negative
08:52 - 30 to 0
08:54 - raycast right we'll count will cast a 30
08:57 - to 0 up and down and so on let's set the
09:04 - sprites texture back to no don't
09:08 - strictly have to do this but you know
09:13 - strictly have to do this but I like to
09:14 - do that to just keep it clean this
09:17 - doesn't have any assigned texture to it
09:19 - so now let's add a script to the
09:22 - character character GD is fine and this
09:29 - script is going to contain all the code
09:33 - to make the character move so we'll
09:36 - start with a few variables tile size is
09:40 - going to be the size of our tile grid
09:43 - we're gonna have a flag called can move
09:46 - that is going to determine whether
09:48 - you're allowed to move or not if you're
09:50 - already moving that will be set to false
09:53 - so that we can't initiate a move in the
09:55 - middle of a move animation facing is
10:00 - going to be what direction we are facing
10:02 - in and then we're going to have what
10:07 - each of the movement what direction
10:08 - either each of the movement goes and
10:10 - also which ray casts match up with them
10:13 - so that's two dictionaries each using
10:16 - the directions as the keys and these are
10:20 - the four directions up down left and
10:23 - right and these are the four written the
10:25 - names of the four ray casts that we made
10:27 - over here now for our move function this
10:31 - is the function that we're going to call
10:33 - whenever a character needs to move and
10:37 - it's we're gonna pass it what direction
10:39 - we want to move in so we'll change our
10:41 - facing direction to whatever that is but
10:45 - if we're gonna check the raycast
10:49 - in that direction so ray casts facing if
10:56 - it's colliding if the Ray cast in the
11:01 - direction we're facing is colliding then
11:04 - we cannot oops I forgot a parenthesis
11:08 - there then we cannot move so we will
11:12 - return otherwise we can move so we'll
11:16 - set can move to false and we will play
11:21 - The Associated animation so we get the
11:26 - animation player and say play that
11:30 - matching animation that's why we kept
11:32 - the animation names the same so if are
11:35 - facing is right we're gonna play
11:36 - animation right so now we need to move
11:38 - and we're gonna use the Move tween for
11:41 - that and we're gonna use it's
11:42 - interpolate property method and that's
11:46 - going to allow us to change the
11:50 - character's position so we want it to
11:53 - act on our self position is the property
11:59 - that we're going to be interpolating let
12:04 - me zoom in here a bit so we could see
12:06 - everything so we're going to change it
12:09 - from its initial property or I started
12:12 - its initial value which is position and
12:14 - then we're going to change it to
12:19 - position plus whatever Direction vector
12:25 - points in that direction times the tile
12:28 - size we want it to last 0.8 seconds
12:34 - right that's the same duration as our
12:37 - animations have and then we're going to
12:40 - use the trans sign tween method and then
12:46 - we're going to use the ease in out tween
12:52 - direction now we want to start the tween
13:01 - and we're gonna return true and the
13:06 - reason we're doing that is so that
13:07 - whenever we call move we're gonna get
13:10 - back up false if we weren't able to move
13:12 - and we're gonna get back a true if we
13:14 - were and we can use that in our code
13:17 - elsewhere to determine whether the move
13:19 - was successful or not and you can see
13:22 - I've been programming in Python lately
13:24 - so I capitalized true
13:25 - and finally to allow movement again
13:28 - we're gonna connect the signal from the
13:31 - move tween between completed signal just
13:35 - connect that adds our function here and
13:40 - what this is gonna do is set can move
13:43 - back to true so that when the move is
13:48 - completed it's allowed to make another
13:50 - move and that's it that completes our
13:52 - character so now we have a character
13:54 - defined that knows how to move around on
13:57 - the grid and that's the stuff that's the
14:01 - same between the player and NPC so now
14:04 - we need to do the stuff that's different
14:06 - so we're going to make a new scene for
14:10 - our player and the new scene for the
14:12 - player is going to be based on this
14:14 - character scene so we're gonna click
14:16 - scene and instead of clicking new scene
14:18 - we're going to do new inherited scene
14:21 - when we do that it asks us to pick what
14:23 - scene so we're gonna inherit from the
14:25 - character scene okay now I have a new
14:28 - scene that's an inherited scene and you
14:32 - can tell that because it has the little
14:35 - clapper here that tells you it's
14:36 - inherited from another scene I'm gonna
14:39 - rename this to player and save it and
14:45 - now we can go and start making our
14:47 - changes to things we want to change for
14:51 - example the sprite I want to change the
14:53 - sprite I'm going to give this bright a
14:54 - texture I'm gonna use the little green
14:56 - archer guy for my player texture
15:04 - and the rest of the stuff is going to
15:09 - stay the same right I already have the
15:11 - raycast pointing in the right direction
15:12 - I have the collegian shape ready to go
15:14 - everything's good there if you had other
15:17 - things to add to your player like
15:19 - additional nodes to represent weapons or
15:21 - things like that you could just add them
15:23 - in here and they would get added on but
15:26 - what we need to do now is add some
15:29 - functionality to the script because we
15:30 - want to listen to the input actions so
15:34 - the script is currently attached to the
15:36 - player is the same one the same
15:38 - character script that we just made but I
15:40 - don't want that so I'm going to clear
15:42 - the script and add a new one and for
15:46 - this new one we're also going to inherit
15:48 - so right here what says inherits area 2d
15:50 - I'm gonna click the little folder and
15:53 - pick character so now this players
15:56 - script is going to inherit from
15:58 - character GD it create and there we go
16:02 - that's what it says up there at the top
16:04 - so now our script includes everything
16:06 - that the character script had in it and
16:09 - then we can add what additional
16:12 - functionality we want all we really want
16:15 - is to check for input actions so I'm
16:19 - going to do that in the process function
16:22 - there's two ways you could do this you
16:24 - could do this in the input function if
16:26 - you want it to only move once when you
16:27 - push the key and then you've got to push
16:29 - the key to move again by doing it in
16:31 - process I'm gonna allow you to hold the
16:35 - arrow key down and it'll continue to
16:36 - move one square at a time in that
16:40 - direction so if we can move so if the
16:46 - can be variable is true then we're going
16:48 - to check the for input actions so I'm
16:52 - just going to do a loop to do that so we
16:57 - get the keys of the moves dictionary are
17:00 - left right up and down so if input is
17:04 - action pressed and we're gonna use the
17:08 - whatever direction because we named the
17:11 - actions up down left right as well then
17:13 - we're going to move in that direction
17:15 - and you can actually
17:18 - go ahead and try it out play the scene
17:21 - and there's my character by pret hold
17:25 - down the right arrow key you see I'm
17:27 - stepping one square at a time if I just
17:29 - tap it I'll move one square and I can
17:32 - move in whatever direction I want to go
17:38 - so hopefully this inheritance concepts
17:40 - starting to make sense to you now but
17:42 - let's go ahead and make one more just to
17:45 - be clear we're gonna make another new
17:47 - inherited scene that inherits from
17:48 - character and I'm going to call this one
17:52 - NPC and so the NPC scene unlike the
17:59 - player scene is going to sort of wander
18:02 - around the screen randomly so we're
18:05 - gonna leave the texture blank we'll add
18:07 - in our script that we're gonna randomize
18:09 - that and we're gonna go ahead and add
18:12 - the script so we'll remove the one that
18:16 - was there and inherit from character for
18:20 - our script and so for our NPC one thing
18:25 - we want to do is pick a random texture
18:27 - so I'm gonna add a I'm just gonna make a
18:30 - list here you can put whatever ones you
18:32 - want in there but here's a list of a few
18:35 - of the textures that are available in
18:39 - the art folder and I want it to pick
18:41 - randomly so that I need to do that in
18:44 - the ready function so let's make sure we
18:47 - randomize and then we're going to pick a
18:52 - texture out of that list so out of that
18:56 - list we want to pick a random index so
18:58 - we pick a random number and we modulo
19:04 - with the with the textures dot length or
19:10 - sorry size talking Python again with
19:13 - length so we pick whatever texture we
19:16 - want and then we can load it
19:23 - and we'll load it from the folder it's
19:26 - in it's in the art RPG sprites actually
19:31 - I can get a bunch of this and then we'll
19:35 - use the string replacement percent s to
19:38 - stick that file name in there and then
19:47 - we tell the sprite to set its texture to
19:49 - that and we'll also set our facing to a
19:55 - random direction and we'll just take the
19:59 - keys of the move and pick a random value
20:04 - out of it now we can do the same thing
20:12 - here now that one option here is we can
20:15 - in process check if we can move and if
20:22 - we can then we'll try moving remember
20:25 - when we try moving it's going to return
20:27 - false if we were unable to so we can
20:30 - just say if not move so if we weren't
20:35 - able to move then we're gonna randomly
20:38 - change direction again so let's just
20:40 - copy and paste this in there and we'll
20:43 - pick another random direction if we
20:44 - weren't able to move and that would be
20:47 - fine
20:47 - except these NPCs are gonna wander in a
20:50 - totally straight line until they hit a
20:52 - wall and then they're gonna turn and
20:54 - what that's gonna do is make them
20:56 - eventually start clumping up on the
20:58 - walls and just walking along the walls
20:59 - so let's also add a little bit of
21:01 - randomness in here so we'll also
21:03 - randomly change direction if we randomly
21:08 - pick a number between 1 and 10 and it's
21:12 - greater than 5 so that way half the time
21:17 - as they're walking they might just
21:19 - randomly turn left or right and that
21:23 - should do it
21:24 - so now if we were to run this one we
21:29 - should see this little sprite wandering
21:31 - around there it is changing direction
21:33 - sometimes but just sort of wandering
21:37 - now the part we can't test right now is
21:40 - the walls so the last thing we need to
21:42 - do is create a little environment for
21:44 - these characters to walk around in so
21:49 - let's add a new scene and I'm going to
21:52 - just use a node call this the main scene
21:57 - and in this we're going to use a tile
22:00 - map so let's add a tile map and set its
22:05 - cell size to 32 by 32 so that it matches
22:10 - and for the tile set you can go and you
22:14 - could make one out of the grass and
22:15 - stone but I've gone ahead and in the art
22:18 - folder saved a tile set that's already
22:22 - made that makes the stone have a clusion
22:24 - shape on it and the grass not so the
22:27 - stone will be the obstacle so we'll just
22:29 - drag that into tile set and then and we
22:32 - zoom out a little bit you should be able
22:34 - to just sort of paint your world let's
22:39 - just actually put walls along the edges
22:42 - I'm holding down shift and dragging to
22:45 - get these straight lines
22:48 - we'll use the bucket fill to fill the
22:52 - inside with grass and then you can put
22:57 - some walls on the inside if you want to
23:01 - have some other kind of obstacles to go
23:06 - around alright and that's a QuickTime
23:09 - app that we can use and then we want to
23:13 - add some characters to it so let's
23:18 - instance a player in there and let's
23:21 - instance a few NPCs NPC and I'll
23:27 - duplicate it a few times now the problem
23:30 - we have is we're gonna drag these guys
23:32 - around and put them in different places
23:35 - but they're not gonna be lined up with
23:37 - the grid so if my character was right
23:39 - here for example you try to move 32 or
23:42 - if he's this far away he would move 32
23:44 - and then be sort of offset from the wall
23:46 - and it's gonna look weird we want them
23:48 - to be on the grid
23:49 - so to do that go to your snap to grid
23:54 - settings and then configure snap said to
23:57 - the 32 by 32 but also set the offset to
24:01 - 16 by 16 because we want the character
24:06 - to be placed at the center of a tile and
24:10 - then we'll also turn on the little
24:12 - magnet which is enabled snapping so now
24:14 - you see as I move around I'm snapping
24:16 - directly to the center of a tile so I
24:19 - can now put these and know that they'll
24:21 - be starting on a tile and then since I
24:26 - know they move exactly 32 pixels they
24:29 - will always end up on the next tile so
24:32 - let's hit play and see what happens now
24:41 - there we go they are detecting the walls
24:43 - you see them turning away when they hit
24:45 - a wall and so will the player if I walk
24:48 - up here I can't go through the wall if I
24:50 - keep pressing up nothing happens all
24:57 - right now some other things you could do
25:01 - and if you wanted to go for more of a
25:02 - turn-based kind of game is that you have
25:06 - the player you give the player a signal
25:08 - ah look these two sprites have moved at
25:13 - the same time and they've wound up on
25:16 - top of each other but now they're
25:17 - detecting each other as a collision so
25:19 - they can't move so one way to get around
25:22 - that is to go to the NPC and set them to
25:27 - [Music]
25:28 - set their collision just take them out
25:30 - of layer one so they won't they just
25:32 - won't see each other and then they won't
25:36 - have that problem but as I was saying
25:39 - you give the player a signal like a
25:41 - moved signal and whenever the player
25:44 - moves you emit that signal and you make
25:47 - the NPC's listen for that signal you
25:51 - connect that signal to them and they
25:53 - only call their move when they they only
25:59 - call their move when they detect that
26:00 - signal right and so so that way they
26:03 - would
26:03 - move when the player moves if you stand
26:05 - here still so today and that's how you
26:07 - would do something more turn-based and
26:10 - you can extend this in lots of ways if
26:12 - you want to start adding if you want to
26:13 - add monsters they could extend from
26:16 - character if you wanted to add pets that
26:19 - follow you around they could extend from
26:22 - character and so on so the the concept
26:25 - is pretty flexible and hopefully gives
26:26 - you some ideas of how you can apply it
26:28 - to your projects especially as your
26:31 - projects start to get bigger and bigger
26:33 - and more complex this becomes really
26:36 - necessary because if you imagine the
26:37 - alternative we hadn't done this
26:41 - inheritance then our scripts would look
26:46 - both players both the character and the
26:48 - NPC would have to have all of this code
26:50 - in it and if we then decided we wanted
26:53 - to change any aspects of how the
26:56 - movement works we would have to go and
26:58 - change it in every single individual
27:00 - script and make sure that they all match
27:03 - up and that becomes really really
27:05 - tedious especially if you have lots and
27:08 - lots of different types of characters so
27:09 - in any time you're finding yourself
27:12 - repeating code and having different
27:15 - objects that share a lot of either
27:19 - properties or nodes if their scenes are
27:22 - very similar or if their scripts are
27:23 - very similar then you probably want to
27:25 - think about using inheritance to do it
27:26 - alright thanks for watching and I'll see
27:29 - you in the next video
27:39 - you

Cleaned transcript:

in this tutorial we'll explore how inheritance works in the Godot game engine I'm using good of three here but these lessons will also apply if you're using 2.1 still in objectoriented is a really powerful tool you can define a class that inherits from another class which means that it will contain the methods and variables of that class in addition to its own Godot is very strongly object oriented and you can use inheritance when defining classes in scripts as well as with scenes for this tutorial we're gonna assume we're making a classic topdown RPG and we'll use good O's inheritance capabilities to create two different kinds of characters in the game here's a preview of what we're making so we have two kinds of characters here we have NPC characters that you see wandering randomly around and then the green character there is controlled by the player and it's moving when I'm pressing the arrow keys starting with the project settings I've made the width and height I'm going to set those to 640 by 480 we are using 32 by 32 tiles for that tile set so we don't need a really big screen for this and then in the input map I've also set up some input actions and those are called left right up and down and specifically and these are assigned to the arrow keys corresponding arrow keys but specifically they're named that for use in the code later it's going to make things easier if we have these names match the names of the directions that the player can move in and if you download the art from the zip file that I'll link in the comments below it has in it unzip that into your project folder and it's got a couple of tiles for the grass and the stone walls and it has a folder called RPG sprites that has spreadsheet animations for a variety of different little RPG style characters now our goal in this project is to create two different kinds of characters one controlled by the player and one that will be an NPC that we will walk around by itself but both of those characters are gonna share a number of different properties and functions they're each gonna have a sprite sheet using one of these different sprite sheets that are all arranged in the exact same way they have three frames of animation for each of the four directional movements there so they're each going to need an animation player to play those animations the game is going to be based on tile based movement which means that the characters when they move around will move from tile to tile so if they're standing on one tile they'll move exactly 32 pixels in whatever direction to go and stand on the next tile there's no fractional tile movement in this example and then of course they need to not be able to move through walls so they need some sort of collision detection so what we're gonna do is we're gonna create a scene that contains all those common features and all those common properties so we'll start by making a new scene and we're gonna add an area 2d area 2d is going to be the parent because we're going to be moving it via animation I'm not worried about kinematic collisions or things like that obviously you could do it that way too if that were the kind of thing you were going for but this is going to be a character we're going to call this character and save the scene now this is going to need a sprite child it's going to need a collision shape collision shape 2d it's going to need a tween oops it made that a child of the collision shape I'm gonna call this the move tween because this is gonna handle the movement from one tile to the next changing the character's position and then we're going to need an animation player to actually play the animations themselves and change the sprite so we're going to leave that sprite without a texture because each character will have a different texture we're going to leave a blank here but we can go ahead and make the collision shape since all of these are going to the same if you were doing something where your player character had needed a different hitbox than the NPC's then you could leave that blank and set it on the individual objects but we're gonna set it here so I'm gonna add a new rectangle shape and then I'm gonna click on rectangle here and I'm going to set the extents to 10 by 18 which is gonna make a rectangular shape that's gonna be the perfect size for our sprites and let me just lock the children and drag it out on the screen so we can sort of see it in the middle so now the animations are going to be based on these textures if you haven't done sprite animation before using the animation player we're essentially going to be changing the frame of the sprite so on the sprite we need to configure it with the number of frames that it has so there's an animation section here number of vertical frames never number of horizontal frames well we have three horizontal and four vertical so set that to three and that one to four four vertical frames three horizontal frames and then changing this property will step through each one I'll snap one in there real quick just so you can see what it looks like so as I move the frame property you'll see we're going through each of the frames until we get to the twelfth one and we'll go back to zero and so the animation player is going to change those over time to give the walking animation for the direction we want so in the animation player I have created four animations up down left and right again making sure that they match the same spelling I used in the input actions lowercase spelled exactly the same because they're going to use that name the same name in our variables in our script so this is the new animation button so I just clicked that four times and name them each now each one is going to be 0.8 in length that's how long we want the animations to be and you can zoom out a little bit so you can see we're going to have our step in our animation players set to 0.1 so it snaps each one so basically we're going to do a frame of animation every other step and for example when we're on the sprite when we're on frame number zero that's the first frame of the walking up animation so I'm on the up animation and I'm going to click the keyframe next to the frame property when I am on zero and it asked me if I want to create that yes now we move over to number two and we're going to use frame number one then we move over to zero point four and we're going to use frame number two and then we go to number six and we're going to go back to frame number one so we have 0 1 2 1 and if I go back to the start here and hit play let's see we have a little walking and then it gets to the end and we're going to stop and that's because I don't want this to loop because this is going to play one time moving one square so just do that same thing for each of the other three animations and I will jump ahead so I've made the other three animations now they're each set up and we'll go in whatever direction we want it play here you can see there's the walk into the right one and the last thing we need to add here to our character is the collision detection the nodes they're going to detect whether it can move into the next square so if it's standing on a square and we say move right but there's a wall there we want it to not move so we're going to use ray casts for that so if we add a ray cast to D and then duplicate it three more times we're going to name these ray castle left right up and down and by default ray casts are off so make sure you select all them and check it to enabled and we need these to point in the direction they're going so right cast left is going to point to negative 30 to 0 raycast right we'll count will cast a 30 to 0 up and down and so on let's set the sprites texture back to no don't strictly have to do this but you know strictly have to do this but I like to do that to just keep it clean this doesn't have any assigned texture to it so now let's add a script to the character character GD is fine and this script is going to contain all the code to make the character move so we'll start with a few variables tile size is going to be the size of our tile grid we're gonna have a flag called can move that is going to determine whether you're allowed to move or not if you're already moving that will be set to false so that we can't initiate a move in the middle of a move animation facing is going to be what direction we are facing in and then we're going to have what each of the movement what direction either each of the movement goes and also which ray casts match up with them so that's two dictionaries each using the directions as the keys and these are the four directions up down left and right and these are the four written the names of the four ray casts that we made over here now for our move function this is the function that we're going to call whenever a character needs to move and it's we're gonna pass it what direction we want to move in so we'll change our facing direction to whatever that is but if we're gonna check the raycast in that direction so ray casts facing if it's colliding if the Ray cast in the direction we're facing is colliding then we cannot oops I forgot a parenthesis there then we cannot move so we will return otherwise we can move so we'll set can move to false and we will play The Associated animation so we get the animation player and say play that matching animation that's why we kept the animation names the same so if are facing is right we're gonna play animation right so now we need to move and we're gonna use the Move tween for that and we're gonna use it's interpolate property method and that's going to allow us to change the character's position so we want it to act on our self position is the property that we're going to be interpolating let me zoom in here a bit so we could see everything so we're going to change it from its initial property or I started its initial value which is position and then we're going to change it to position plus whatever Direction vector points in that direction times the tile size we want it to last 0.8 seconds right that's the same duration as our animations have and then we're going to use the trans sign tween method and then we're going to use the ease in out tween direction now we want to start the tween and we're gonna return true and the reason we're doing that is so that whenever we call move we're gonna get back up false if we weren't able to move and we're gonna get back a true if we were and we can use that in our code elsewhere to determine whether the move was successful or not and you can see I've been programming in Python lately so I capitalized true and finally to allow movement again we're gonna connect the signal from the move tween between completed signal just connect that adds our function here and what this is gonna do is set can move back to true so that when the move is completed it's allowed to make another move and that's it that completes our character so now we have a character defined that knows how to move around on the grid and that's the stuff that's the same between the player and NPC so now we need to do the stuff that's different so we're going to make a new scene for our player and the new scene for the player is going to be based on this character scene so we're gonna click scene and instead of clicking new scene we're going to do new inherited scene when we do that it asks us to pick what scene so we're gonna inherit from the character scene okay now I have a new scene that's an inherited scene and you can tell that because it has the little clapper here that tells you it's inherited from another scene I'm gonna rename this to player and save it and now we can go and start making our changes to things we want to change for example the sprite I want to change the sprite I'm going to give this bright a texture I'm gonna use the little green archer guy for my player texture and the rest of the stuff is going to stay the same right I already have the raycast pointing in the right direction I have the collegian shape ready to go everything's good there if you had other things to add to your player like additional nodes to represent weapons or things like that you could just add them in here and they would get added on but what we need to do now is add some functionality to the script because we want to listen to the input actions so the script is currently attached to the player is the same one the same character script that we just made but I don't want that so I'm going to clear the script and add a new one and for this new one we're also going to inherit so right here what says inherits area 2d I'm gonna click the little folder and pick character so now this players script is going to inherit from character GD it create and there we go that's what it says up there at the top so now our script includes everything that the character script had in it and then we can add what additional functionality we want all we really want is to check for input actions so I'm going to do that in the process function there's two ways you could do this you could do this in the input function if you want it to only move once when you push the key and then you've got to push the key to move again by doing it in process I'm gonna allow you to hold the arrow key down and it'll continue to move one square at a time in that direction so if we can move so if the can be variable is true then we're going to check the for input actions so I'm just going to do a loop to do that so we get the keys of the moves dictionary are left right up and down so if input is action pressed and we're gonna use the whatever direction because we named the actions up down left right as well then we're going to move in that direction and you can actually go ahead and try it out play the scene and there's my character by pret hold down the right arrow key you see I'm stepping one square at a time if I just tap it I'll move one square and I can move in whatever direction I want to go so hopefully this inheritance concepts starting to make sense to you now but let's go ahead and make one more just to be clear we're gonna make another new inherited scene that inherits from character and I'm going to call this one NPC and so the NPC scene unlike the player scene is going to sort of wander around the screen randomly so we're gonna leave the texture blank we'll add in our script that we're gonna randomize that and we're gonna go ahead and add the script so we'll remove the one that was there and inherit from character for our script and so for our NPC one thing we want to do is pick a random texture so I'm gonna add a I'm just gonna make a list here you can put whatever ones you want in there but here's a list of a few of the textures that are available in the art folder and I want it to pick randomly so that I need to do that in the ready function so let's make sure we randomize and then we're going to pick a texture out of that list so out of that list we want to pick a random index so we pick a random number and we modulo with the with the textures dot length or sorry size talking Python again with length so we pick whatever texture we want and then we can load it and we'll load it from the folder it's in it's in the art RPG sprites actually I can get a bunch of this and then we'll use the string replacement percent s to stick that file name in there and then we tell the sprite to set its texture to that and we'll also set our facing to a random direction and we'll just take the keys of the move and pick a random value out of it now we can do the same thing here now that one option here is we can in process check if we can move and if we can then we'll try moving remember when we try moving it's going to return false if we were unable to so we can just say if not move so if we weren't able to move then we're gonna randomly change direction again so let's just copy and paste this in there and we'll pick another random direction if we weren't able to move and that would be fine except these NPCs are gonna wander in a totally straight line until they hit a wall and then they're gonna turn and what that's gonna do is make them eventually start clumping up on the walls and just walking along the walls so let's also add a little bit of randomness in here so we'll also randomly change direction if we randomly pick a number between 1 and 10 and it's greater than 5 so that way half the time as they're walking they might just randomly turn left or right and that should do it so now if we were to run this one we should see this little sprite wandering around there it is changing direction sometimes but just sort of wandering now the part we can't test right now is the walls so the last thing we need to do is create a little environment for these characters to walk around in so let's add a new scene and I'm going to just use a node call this the main scene and in this we're going to use a tile map so let's add a tile map and set its cell size to 32 by 32 so that it matches and for the tile set you can go and you could make one out of the grass and stone but I've gone ahead and in the art folder saved a tile set that's already made that makes the stone have a clusion shape on it and the grass not so the stone will be the obstacle so we'll just drag that into tile set and then and we zoom out a little bit you should be able to just sort of paint your world let's just actually put walls along the edges I'm holding down shift and dragging to get these straight lines we'll use the bucket fill to fill the inside with grass and then you can put some walls on the inside if you want to have some other kind of obstacles to go around alright and that's a QuickTime app that we can use and then we want to add some characters to it so let's instance a player in there and let's instance a few NPCs NPC and I'll duplicate it a few times now the problem we have is we're gonna drag these guys around and put them in different places but they're not gonna be lined up with the grid so if my character was right here for example you try to move 32 or if he's this far away he would move 32 and then be sort of offset from the wall and it's gonna look weird we want them to be on the grid so to do that go to your snap to grid settings and then configure snap said to the 32 by 32 but also set the offset to 16 by 16 because we want the character to be placed at the center of a tile and then we'll also turn on the little magnet which is enabled snapping so now you see as I move around I'm snapping directly to the center of a tile so I can now put these and know that they'll be starting on a tile and then since I know they move exactly 32 pixels they will always end up on the next tile so let's hit play and see what happens now there we go they are detecting the walls you see them turning away when they hit a wall and so will the player if I walk up here I can't go through the wall if I keep pressing up nothing happens all right now some other things you could do and if you wanted to go for more of a turnbased kind of game is that you have the player you give the player a signal ah look these two sprites have moved at the same time and they've wound up on top of each other but now they're detecting each other as a collision so they can't move so one way to get around that is to go to the NPC and set them to set their collision just take them out of layer one so they won't they just won't see each other and then they won't have that problem but as I was saying you give the player a signal like a moved signal and whenever the player moves you emit that signal and you make the NPC's listen for that signal you connect that signal to them and they only call their move when they they only call their move when they detect that signal right and so so that way they would move when the player moves if you stand here still so today and that's how you would do something more turnbased and you can extend this in lots of ways if you want to start adding if you want to add monsters they could extend from character if you wanted to add pets that follow you around they could extend from character and so on so the the concept is pretty flexible and hopefully gives you some ideas of how you can apply it to your projects especially as your projects start to get bigger and bigger and more complex this becomes really necessary because if you imagine the alternative we hadn't done this inheritance then our scripts would look both players both the character and the NPC would have to have all of this code in it and if we then decided we wanted to change any aspects of how the movement works we would have to go and change it in every single individual script and make sure that they all match up and that becomes really really tedious especially if you have lots and lots of different types of characters so in any time you're finding yourself repeating code and having different objects that share a lot of either properties or nodes if their scenes are very similar or if their scripts are very similar then you probably want to think about using inheritance to do it alright thanks for watching and I'll see you in the next video you
