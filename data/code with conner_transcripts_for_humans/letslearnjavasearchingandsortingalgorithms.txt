With timestamps:

00:02 - hello humans
00:04 - welcome back to co with connor glad
00:06 - you're here we are covering some more
00:07 - advanced
00:08 - java topics here that are part of the ap
00:10 - computer science a curriculum
00:12 - specifically we're going to be looking
00:14 - at searching and sorting algorithms
00:16 - now we're cherry-picking a bit here from
00:18 - the non-recursive which is part of the
00:20 - arraylist
00:21 - kind of section of the course and the
00:23 - recursive which is part of the last unit
00:25 - in the course
00:25 - we're just going to look at them all
00:26 - together because i think it fits well to
00:28 - kind of analyze them together so we're
00:30 - going to look
00:30 - at a few things we're going to look at a
00:32 - sequential or linear search as well as a
00:34 - binary search
00:35 - and then we're going to look at some
00:36 - sorting algorithms so we'll look at a
00:38 - selection sort we'll look at an
00:40 - insertion sort and finally we'll look at
00:42 - a merge sort
00:43 - now my focus with this is not on code as
00:46 - much as it's on theory and this
00:47 - really just correlates to kind of the
00:50 - college board views on this which is
00:51 - that
00:52 - you need to be able to code trace these
00:54 - concepts and
00:55 - understand and read code for these
00:57 - searching and sorting algorithms
00:58 - you don't necessarily need to be able to
01:00 - code your own versions
01:02 - of them from scratch okay so
01:05 - particularly things like merge sort
01:06 - which get fairly advanced from a coding
01:08 - perspective
01:08 - with the recursive writing we'll kind of
01:11 - code trace a little bit but we're not
01:13 - going to go too heavy
01:14 - into writing the code now that being
01:16 - said i'm going to put some links in the
01:17 - description
01:18 - for some sites that break down the code
01:20 - okay and i'm actually pulling my code
01:22 - from geeksforgeeks
01:23 - so props to them for the great website
01:25 - and i will put that in the description
01:27 - so you can go and have a look at the
01:28 - code in more detail
01:29 - if you want to do that all right let's
01:31 - jump right in and talk about
01:33 - searching all right so we're gonna have
01:35 - a look at some searching algorithms
01:36 - we're gonna start with the sequential or
01:38 - linear
01:38 - which is kind of your straightforward
01:40 - you know left to right
01:41 - searching for something in a list or in
01:44 - a data structure
01:45 - all right so you can imagine not super
01:47 - efficient
01:48 - now that i say that let's just talk
01:50 - briefly we are not going to be talking
01:52 - efficiency
01:53 - in this kind of lesson if we wanted to
01:56 - window efficiency that's a whole other
01:57 - thing
01:58 - okay so we're not going to touch it i
01:59 - know you're going to get cranky of me if
02:01 - you're a higher level
02:02 - person and you know about this stuff you
02:03 - aren't sure about efficiency well
02:05 - it's a choice we're not doing that today
02:07 - sorry
02:08 - okay moving on i've got a list of
02:10 - numbers here i'm going to say i'm going
02:11 - to look for the 679
02:13 - so i'm just going to do a really quick
02:14 - linear search of this okay so here we go
02:17 - and you see it's just tracing
02:18 - left to right it's going one index
02:20 - iterate the index check the value
02:22 - iterate the index check the value
02:24 - and so on and it's just checking are
02:25 - they equal to 679 that's it
02:28 - so you can see with a sequential or a
02:30 - linear search like this
02:31 - there's no prerequisite the list has to
02:33 - already be sorted
02:34 - because we're just going to scan the
02:36 - whole list from left to right
02:37 - until we find the value so that is a
02:39 - benefit of a linear or sequential is
02:41 - that it doesn't rely on the list being
02:42 - sorted
02:43 - you can see when it reached index 20 the
02:45 - value 679 was equal to the value in
02:47 - question
02:48 - so it stopped didn't finish it doesn't
02:50 - need to go the whole list it can have a
02:52 - stopping point
02:53 - but there's no requirement the list is
02:54 - in order when we're doing a linear or a
02:57 - sequential search
02:58 - let's hop over and look quickly at the
02:59 - code for a linear search
03:02 - so here's my code for linear search i'm
03:04 - taking an array
03:05 - okay and i'm taking a value and i'm
03:07 - going to search that array for that
03:09 - value
03:10 - all right if i don't find it i'm going
03:11 - to return negative 1. that's a very
03:13 - common practice anytime we're searching
03:15 - for an
03:15 - index of something in a data structure
03:17 - because negative one does not refer to
03:19 - an index
03:20 - so i start by finding the length of the
03:22 - array and is the array.length
03:24 - and then i do my for loop from zero to n
03:27 - iterating by one if the array
03:30 - value is equal to the value that was
03:32 - passed to my method
03:34 - then return the index in question if i
03:37 - make it all the way to the end of this
03:38 - loop and that if statement was never
03:39 - triggered it means it did not find the
03:41 - value
03:42 - therefore return negative one okay
03:45 - so that's what we're looking at with a
03:46 - linear search super straightforward just
03:48 - scan the array from left to right
03:50 - all right we're going to move on and
03:52 - talk binary search
03:54 - okay so this time we're going to look
03:55 - for that same number that's 679 using a
03:57 - binary search the way the binary search
03:59 - works
04:00 - is it's going to start at the beginning
04:02 - and the end index
04:03 - of our data structure then it's going to
04:05 - calculate the middle index
04:07 - okay and it's going to check if that
04:09 - middle index is the value we want
04:11 - and if it's not it's going to shrink the
04:13 - list either the first half or the second
04:15 - half
04:15 - and then continue the process so let's
04:17 - trace through it so we can understand it
04:18 - a bit better
04:19 - so i'm going to search that 679 you'll
04:22 - see that it set
04:23 - my low value to zero and it set my high
04:26 - value
04:26 - to 31. those are the indices okay now
04:29 - it's going to calculate my mid so let's
04:31 - step forward
04:33 - so my mid has been calculated to be 15.
04:36 - so again
04:37 - 31 minus 0 divided by 2 and then casa as
04:40 - an integer we're looking at 50.
04:42 - all right cool so it's going to check
04:44 - the value that 456.
04:46 - is that equal to my number no it's not
04:48 - but not just is it equal
04:50 - is it less than or is it greater than
04:52 - that value so because our number is
04:54 - bigger than 456 and
04:55 - it can't possibly come before because
04:57 - remember we are working with an
04:59 - ordered list so back when we did our
05:02 - first one
05:03 - you know when we did uh back when we did
05:05 - sequential or linear
05:06 - listed need to be an order didn't matter
05:08 - but when we do a binary there's a
05:09 - precondition here
05:10 - and the list must already be in order
05:12 - from smallest to greatest
05:14 - okay and that allows us to work so now i
05:16 - know my number comes after 456.
05:19 - so i can actually just ignore everything
05:21 - that came before index 15.
05:23 - so here we go how are we going to do
05:24 - that we're going to bring our low value
05:27 - up to 16 because 15 is out
05:31 - everything from 0 to 15 is out so we're
05:33 - going to set our low to 15 and we're
05:34 - going to recalculate our mid
05:36 - so we recalculate our mid to 23 again 31
05:39 - minus 16 divided by two cast as an
05:41 - integer
05:42 - we find our mid okay now we're going to
05:44 - check our mid value
05:46 - 696 is bigger than 679 so now i know
05:49 - it's
05:49 - not in the right hand side of this so
05:51 - it's got to be in the left so i'm going
05:53 - to bring my high value down
05:55 - so my high value is going to come down
05:56 - to index 22 recalculate my mid
06:00 - recalculates my mid to 19. okay i'm
06:02 - going to check that
06:03 - 678 ooh just too small so i got to move
06:07 - to the right
06:07 - got to bring my low up bring my low up
06:10 - to 20
06:11 - okay recalculate my mid get 21
06:14 - i'm going to check that value 683 it's
06:17 - too big
06:17 - so i can go back but guess what there's
06:20 - nowhere to go back to because there's
06:21 - only one value
06:22 - left to the left-hand side so our low
06:24 - comes to 20
06:25 - our high comes to 20. our mid gets
06:28 - calculated to 20
06:29 - and our value is 679 and we found the
06:32 - value
06:33 - okay if we got to this point and the
06:35 - value still wasn't there
06:37 - then we would return negative one all
06:40 - right because it didn't find it
06:41 - it tried it got close but it didn't find
06:43 - it all right
06:45 - so at some point binary search is going
06:46 - to narrow down to a single vowel
06:48 - that value may or may not be the value
06:50 - but it'll be like kind of through this
06:52 - less than greater than less than greater
06:53 - than less than greater than
06:54 - at some point it reaches a point where
06:55 - it's like okay it's either this or it's
06:57 - not here
06:58 - and that's what happened here in this
07:00 - case it was here so it would return
07:01 - index 20.
07:03 - okay let's jump over look at the code
07:05 - now binary search is a recursive
07:07 - algorithm so we are going to be calling
07:09 - our function from within our function
07:11 - makes sense okay because again we're
07:12 - starting big and then we kind of recall
07:14 - it on the smaller
07:15 - we recall it on the smaller we recall it
07:17 - on the smaller
07:18 - until eventually there's really nothing
07:20 - left okay so let's have a look
07:22 - so we're going to take the array we're
07:23 - going to take a left value a right value
07:26 - and we're going to take the value we're
07:27 - looking for
07:29 - so if the right is greater than or equal
07:31 - to the left awesome
07:33 - then we find the mid all right it's left
07:36 - plus
07:36 - right minus one and then divide by two
07:38 - all right so the average in between them
07:41 - awesome so we check the value
07:44 - so if the value at mid is equal then
07:46 - we're done and we return the index
07:48 - awesome okay if the value is bigger than
07:52 - x
07:52 - then that means we need to move to the
07:54 - left so we need to bring our high dam
07:56 - okay so we're going gonna call it again
07:58 - but you can see our right now
08:00 - our right value is no longer the actual
08:02 - right value we started with it's the
08:03 - middle minus one
08:05 - so we're recalling it by shifting that
08:07 - high value shifting that right value
08:08 - down okay otherwise
08:12 - you'll notice we're recalling on
08:15 - on new left so we're bringing up the
08:17 - left to mid plus one so that's our else
08:19 - so that's if it's less than
08:21 - okay so what are we doing we're
08:23 - returning a recursive call to binary
08:25 - search
08:26 - and at some point binary search has only
08:28 - two choices
08:29 - it either has to return mid as a base
08:32 - case
08:32 - because we found the value or if it's
08:35 - not equal to and it's not less than and
08:37 - it's not greater than
08:39 - it's going to return negative 1 right
08:41 - and guess when that happens
08:42 - look at this if statement if right is
08:44 - greater than equal to the left do the
08:45 - check
08:46 - well guess what's going to happen at
08:47 - some point if we don't find this value
08:49 - we're going to keep iterating this mid
08:52 - right
08:53 - minus one plus one each time we
08:54 - recursively call at some point
08:56 - we're going to cross mid over and our
08:59 - left and rights are gonna cross and
09:00 - they're gonna be backwards
09:01 - and then the if statement's gonna fail
09:03 - and in the base case it's gonna return
09:04 - negative one
09:05 - okay so our recursive function has a
09:07 - base case where it'll return negative
09:09 - one if it doesn't find it
09:10 - it has the second base case where it'll
09:12 - return the actual index if it does find
09:14 - it
09:14 - and then otherwise it's returning that
09:16 - recursive call
09:17 - okay so that's where we're gonna see
09:19 - that recursion eventually kind of filter
09:20 - its way
09:21 - down so if the base case returns the
09:24 - actual index
09:25 - then it just returns that returns every
09:26 - time it returns until the end
09:28 - of the recursive call returns that same
09:29 - index so there's our binary search
09:32 - now binary search required that we were
09:34 - sorted
09:35 - well that's a whole other animal we got
09:37 - to talk about sorting algorithms so
09:39 - let's jump over and look at our first
09:40 - one
09:40 - all right so we're going to start here
09:42 - we're going to talk about a selection
09:43 - sort
09:44 - all right selection's already going to
09:45 - look very familiar too so i'm going to
09:47 - run
09:47 - the visualization and then i'll kind of
09:49 - pause it and talk through it as we look
09:50 - so you can see how it's traversing the
09:52 - array and it's got that red on the three
09:54 - what it's doing is it's scanning the
09:56 - array looking for the lowest
09:58 - number so it finds two it now flags that
10:00 - as the minimum value
10:02 - it's going to keep going all the way to
10:03 - the end of the array when it reaches the
10:05 - end of the array
10:07 - it's going to take that lowest value and
10:09 - shoot it to the front
10:11 - mark it as orange because now we're done
10:12 - with it we're not going to look at it
10:13 - anymore
10:14 - so we're actually going to start
10:15 - scanning now from the second position
10:17 - from index one
10:18 - and again we're scanning for the minimum
10:20 - in the remaining array
10:21 - so currently it's five now it's going to
10:23 - be three it's going to keep scanning
10:26 - four is no good 19 no good it's going to
10:28 - get to the end
10:29 - and it's going to swap that three with
10:31 - index 1
10:33 - swapped now that's locked in now we're
10:35 - starting at index 2
10:37 - and we're going to continue the scan
10:38 - looking for the minimum value
10:40 - and we're going to continue this kind of
10:42 - process of going
10:43 - from our kind of new starting position
10:45 - to the end of the array
10:46 - looking for a min once we finish the
10:49 - scan we swap them in
10:51 - with that starting position iterate the
10:53 - starting position
10:54 - and then keep going until we've reached
10:56 - the end of the array
10:58 - with the starting position okay we're
11:00 - going to reach the end of the array many
11:01 - times
11:02 - it's that starting position once that
11:04 - has shifted to the end of the array
11:06 - then we know that the array is in order
11:08 - it's been sorted
11:09 - okay so i'm just going to speed this up
11:11 - we're going to watch it finish
11:13 - [Music]
11:23 - [Music]
11:39 - and now our starting has reached the end
11:42 - and therefore our list
11:43 - has been sorted and we can see that it's
11:45 - in order from smallest
11:47 - to biggest all right so we call this a
11:50 - selection
11:50 - sort okay and you can see the pseudo
11:53 - code above my head
11:54 - all right so we're going to repeat a
11:56 - bunch of times
11:57 - we're going to set that first unsorted
11:59 - element as our min
12:01 - go through the whole thing looking for
12:03 - if something is actually lower than it
12:04 - and then we'll do the swap with that
12:06 - first unsorted and then enter it
12:08 - okay let's have a look at the code for
12:10 - how we can do this
12:12 - all right so here's our selection sort
12:13 - code so we start by finding the length
12:15 - of the array
12:16 - awesome okay now we're gonna kind of
12:18 - move that boundary over so we have one
12:20 - loop that outer loop is gonna start at
12:22 - zero and it's going to go to the end and
12:24 - that's going to be our starting position
12:26 - okay are we going to start at zero but
12:27 - then the next time it loops we're
12:29 - starting at one and
12:30 - each time we're going to go to the
12:31 - answer we have a nested loop here so you
12:33 - can see our nested loop here
12:35 - so this one is starting at i
12:38 - plus one okay so we've set zero to be
12:42 - our minimum
12:42 - and then we're gonna loop the remaining
12:44 - then we're gonna set one to be our
12:45 - minimum
12:46 - we're gonna loop from two on we're gonna
12:48 - set two to be the minimum loop from
12:49 - three on
12:50 - okay and that's kind of holding our
12:51 - starting position in the i value
12:54 - and then our j value is our looper as
12:56 - we're working our way through the array
12:58 - okay so my minimum index is our i value
13:01 - and then we're going to loop through
13:02 - from there
13:03 - so we're just checking if our current
13:05 - value is less than
13:07 - the value that's at our minimum index
13:10 - okay
13:11 - then we reassign our minimum index to
13:12 - that new index
13:15 - all right and then once we finish the
13:18 - loop
13:18 - that min index should point to the
13:20 - smallest value in the remaining array
13:23 - okay and that gives us a chance to do
13:26 - the swap
13:27 - so then we do remember with a swab you
13:28 - have to use a temporary variable
13:30 - okay you can't do a direct swap you've
13:32 - got a store one move one
13:34 - and then store back so we do a temp is
13:37 - whatever was at the minimum index so
13:39 - that's our minimum and the remaining
13:40 - array
13:41 - then we overwrite that with whatever was
13:43 - at our starting position
13:45 - that's all and then we override our
13:47 - starting position with the value of 10.
13:49 - so that's a completing our swap
13:51 - and then i is going to iterate we've got
13:52 - a new starting position and we loop
13:54 - again
13:55 - all right so a little tricky you got the
13:57 - nested loops there you've got
13:59 - you know there's a little play you gotta
14:01 - take your time to get that code and kind
14:02 - of understand how it works
14:04 - so that's our selection sort that's the
14:05 - easiest of our sorts
14:07 - now we're gonna jump over we're gonna
14:08 - look at insertion sort okay so this is
14:11 - insertion sort
14:12 - so again we'll trace through we'll
14:13 - explain as it goes so insertion sort you
14:15 - can see right away
14:18 - kind of what's happening we're looking
14:19 - at the 38 deciding where it fits
14:22 - in the array to the left now we're going
14:24 - to go to the five would be okay no it's
14:26 - smaller than 44
14:27 - shift that over smaller than 38 shift
14:29 - that over is it smaller than three
14:31 - no okay we found the spot stick it there
14:34 - let's go to 47.
14:35 - okay it's good leave it where it is 15
14:38 - okay no
14:39 - smaller than that shift smaller than
14:42 - that
14:43 - shift smaller than 38 shift
14:46 - is it smaller than 5 no up we go
14:49 - 36 and we're going to work our way
14:51 - through so we are going
14:52 - one time through and with each value
14:55 - we're kind of going to the left
14:57 - until we find its position in order of
15:01 - the values that are there
15:02 - so the deeper we get the more swaps we
15:05 - might have to make working our way to
15:07 - the left
15:07 - to find the correct place for each value
15:10 - so 26
15:11 - one more move always do the compare back
15:13 - to 15
15:14 - okay stop place it 27 and we work our
15:17 - way through
15:18 - all right so let's watch this finish and
15:20 - then we'll look at the code of how this
15:21 - [Music]
15:24 - works
15:28 - so the two is going to have to go all
15:30 - the way to the left a lot of compares
15:32 - compare compare compare compare
15:34 - compare hey we're at the beginning we
15:35 - already know where it goes
15:37 - before again we're going way back until
15:39 - it compares with the three
15:42 - compare and there we go and continue
15:44 - till we reach the end
15:50 - and there we go we've got a sorted list
15:52 - using an insertion sort
15:54 - algorithm let's look at the code for how
15:56 - we pull this off
15:58 - all right so our insertion sort we're
15:59 - going to start by setting up the length
16:01 - okay we have our outer loop from 1 up to
16:04 - the end
16:05 - all right and then our j value is going
16:07 - to be one less than our y value
16:09 - okay and that that is because we're kind
16:11 - of pulling out that key value
16:13 - at i and then we want to move to the
16:16 - left from it
16:17 - so we need to store that key value and
16:19 - then as we shift to the left we need
16:20 - room to kind of move everything up
16:22 - so we'll go starting from one less okay
16:25 - and then we can shove everything up out
16:26 - of the way until we find a place to put
16:28 - the key value
16:29 - so our j starts at one less than i
16:32 - and our key is kind of the pulled out
16:34 - value at our position
16:36 - as we work our way through the array so
16:38 - we work our way through the array we
16:40 - pull key out
16:41 - and then using a while loop so while j
16:43 - is greater than or equal to zero so as
16:44 - we move to the left
16:46 - and the value at j
16:49 - is bigger than my key value then that
16:51 - means i need to move that value over
16:53 - and get ready to check if my key goes
16:55 - there okay
16:56 - so while i'm greater than zero and while
16:59 - the left value is bigger than my key
17:02 - okay then i'm going to move that value
17:05 - over
17:06 - bring my key down and then move that
17:08 - value over bring my key down and i'm
17:10 - going to keep while looping that
17:11 - until one of those two statements is
17:13 - false so
17:15 - either i reach the end of the array in
17:16 - which case i found my home
17:18 - or the value kind of j
17:22 - is not bigger than key which means that
17:24 - i've found my location for key
17:27 - it's at i all right so array j plus one
17:30 - is now equal to key and i lock that in
17:33 - the value of j is not
17:35 - not touched we just checked it okay so
17:37 - now i've locked my key position in
17:39 - i iterate i and i repeat the process
17:41 - over and over again
17:42 - again this code's a little sticky you've
17:44 - got to take some time type it out trace
17:46 - it yourself kind of play with it
17:48 - you know again we're not writing this
17:49 - code from scratch so i'm kind of burning
17:50 - through it
17:51 - a little quicker than i would otherwise
17:53 - hopefully that makes you know a little
17:54 - bit of sense
17:55 - all right now we're going to move on
17:56 - with the most complex one which is a
17:58 - recursive sorting
17:59 - it's called a merge sort and again i'm
18:01 - going to visualize it
18:03 - i'm going to go through this code pretty
18:04 - quick okay if you really want to dive
18:06 - into merge short go dive into merge sort
18:08 - the links will be in the description
18:09 - i'm not going to go too crazy with it
18:11 - just because it does get a little bit
18:13 - more complex because we're
18:14 - running a two method structure uh in
18:16 - terms of merging
18:17 - two arrays together which shouldn't be
18:18 - too hard for you you should be able to
18:19 - do that
18:20 - that part absolutely you need to be able
18:22 - to do and then the second piece is the
18:23 - recursive merge short piece which uses
18:25 - the merge anyways i'll get ahead of
18:27 - myself
18:27 - let's go visualize virtual okay merge
18:30 - sort here we go
18:31 - let's see if we can make any sense of
18:33 - this here's our whole thing
18:34 - start with those two elements okay cool
18:38 - they're in order let's go to the next
18:39 - two elements
18:41 - okay oh they're not in order let's fix
18:42 - them now they're in order okay
18:44 - now let's pull those two pairs of two
18:46 - elements
18:47 - into one array that has four elements
18:50 - and let's put them in order
18:52 - okay we've merged that okay let's repeat
18:55 - that process
18:56 - over again with the next two elements 47
18:58 - and 15. we're going to put those in
19:00 - order
19:00 - okay we're going to shove those back up
19:02 - kind of temporary as an array let's grab
19:04 - the next two
19:05 - 26 36 we're going to put those in order
19:07 - okay let's merge those two arrays is to
19:09 - one sorted array of four
19:10 - so 15 okay and then the 26 okay and then
19:14 - the 36
19:15 - and then the 47 okay now let's take our
19:17 - two four arrays and let's merge those
19:18 - into a sorted array
19:20 - so we're going to take the three from
19:22 - the red array okay and then the
19:24 - 15 and the five note we're going to take
19:25 - the five the 15 the 38 take the 15
19:28 - take the 26 take 36 take the 38
19:31 - take the 44 anything left over we'll
19:32 - take the 47 okay
19:34 - we're gonna run this whole shebang again
19:36 - on the right hand side so we're going to
19:37 - take the twos
19:38 - the two and the 27 the 4 and the 46
19:40 - we're going to merge them
19:42 - take the 19 and the 50 take the 48 we're
19:44 - going to merge them
19:45 - and repeat the process let's watch it go
19:48 - 2 and 27 put it back
19:50 - 4 and 46 merge it sort it
19:54 - and put it back take those two arrays of
19:57 - 2 and merge them into an array of 4 in
19:59 - order
19:59 - 2 and then the 4 and then the 27 and
20:02 - then the 46 and then shove it back
20:08 - okay let's take a 19 in the 50 put them
20:11 - in order
20:11 - okay 48's alone will kind of treat it
20:14 - like it's a thing anyway
20:16 - 48 okay let's merge those three okay
20:19 - good
20:20 - and we're merged and back up and now
20:22 - we'll take all seven
20:23 - and we're gonna merge those two
20:26 - and then four and then 19 and then 27
20:31 - 46 and anything that's left over okay
20:34 - beautiful
20:34 - now let's merge our eight in our seven
20:36 - into our final sorted
20:38 - list
20:41 - [Music]
20:43 - all right so the two and the three we
20:44 - take the two the three and the four we
20:46 - take the three we take the four over the
20:48 - five then we take the five over the 19
20:50 - and we take the 15 over the 19. 19 over
20:53 - 26
20:54 - 26 then 27. now we got 36 then we got
20:57 - 46.
20:58 - oh sorry 38 then 44 then 46 47
21:02 - 48 and then 50. it's all merged it's all
21:05 - sorted
21:06 - and it's done and it's complicated but
21:09 - it's also beautiful
21:10 - okay so we're kind of taking these mini
21:12 - arrays we're sorting them
21:14 - and then we're merging them together
21:15 - into a new sorted array
21:18 - and then taking other arrays merging
21:20 - them sorting them
21:21 - right it's this kind of repeated process
21:23 - of merging the arrays
21:25 - and then sorting the merged arrays all
21:28 - right and we're going to look at the
21:28 - code for how we do this
21:30 - again it's a little bit complex that's
21:32 - okay
21:33 - all right so there's two pieces here
21:35 - there's our merge method which
21:36 - serves the purpose of merging
21:40 - two arrays okay so it takes our main
21:43 - array it takes
21:45 - a left a mid and a right okay a left and
21:48 - mid and a right
21:49 - so we're going to find the sizes of the
21:50 - two sub arrays to be merged
21:52 - remember merge does some sorting this
21:54 - isn't just slapping two arrays together
21:56 - in any order
21:57 - so we're going to take our first which
21:59 - is our middle
22:00 - minus our left plus one and then our
22:03 - right minus our middle
22:04 - so those are going to be the two sizes
22:06 - of our sub arrays
22:07 - we'll call them the left array and the
22:08 - right array l and r
22:10 - set them up to their sizes cool now
22:13 - we're going to copy the data
22:15 - into these arrays so just raw data
22:19 - again we're just going to take
22:21 - everything that was an array and just
22:22 - dump it into the left and the right or
22:24 - right just a perfectly even split no
22:25 - sorting yet
22:26 - so everything up to n1 goes into the
22:29 - left array everything from n1 up to n2
22:33 - right goes into the right array all
22:35 - right so this starts at zero goes to n2
22:37 - so that's the number of times it'll
22:38 - repeat
22:39 - but it actually starts at that mid plus
22:41 - one and then plus j so mid plus one and
22:43 - then one
22:44 - and and add on from there so that's
22:46 - going to fill the left and the right
22:47 - with whatever values
22:48 - we're on the left hand side and the
22:49 - right hand side of the original array
22:50 - that was passed
22:51 - now we're going to sort them back into
22:53 - the array
22:54 - okay so we have to have an i and a j so
22:57 - the i
22:58 - is for the left array the j is for the
22:59 - right array and they're both starting at
23:00 - zero of those respective arrays
23:02 - because we might iterate i three times
23:04 - and then iterate j once it's not going
23:06 - to be consistent
23:07 - okay because it all depends on the size
23:09 - of the values in those arrays
23:11 - so while i is less than n1 so that's
23:13 - keeping us within the size of the
23:15 - l of the left array and j is less than
23:17 - n2 again keeping us in the size of the
23:19 - right array
23:20 - then if the left value is less than or
23:23 - equal to the right value
23:24 - then we're going to keep the left value
23:26 - so the main array position k which is
23:28 - starting at
23:30 - l which is the left value that we wanted
23:31 - this whole shebang to start at
23:33 - is equal to that value and then we
23:35 - iterate
23:37 - i which is our left iterator otherwise
23:41 - okay so otherwise if left is not less
23:43 - than or equal to right
23:44 - then that means right must be bigger
23:45 - than left so array k is now equal to the
23:48 - right and we're going to iterate
23:49 - the right iterate or the jet okay and
23:51 - then when all that's done
23:53 - we're going to iterate our k so that now
23:55 - we're ready to check
23:57 - the next one and whether we pull it from
23:59 - the left we pull up the right doesn't
24:00 - matter
24:00 - this is going to run until one of the
24:02 - arrays left or right runs out of values
24:04 - okay so we've pulled everything from
24:05 - either the left or right or the right
24:06 - array
24:07 - so at that point we just need to get
24:09 - anything that's left over because one of
24:10 - them is going to have something left
24:11 - over
24:12 - so if i is less than n1 then we're going
24:15 - to run the while loop
24:16 - which means there's something left over
24:17 - in the left array and we're just going
24:19 - to literally just pull
24:20 - array k is equal to left iterate the
24:22 - left iterate k grab the next
24:23 - until the left array is empty we're
24:25 - never going to have the situation where
24:27 - both of these while loops run
24:28 - because the only reason we got here is
24:30 - because one of the left or right array
24:32 - has already been kind of blood drawn so
24:34 - one of them is going to run
24:35 - so either the left one's going to run or
24:37 - the right one's going to run but when
24:38 - the merge method is done
24:40 - the array that it was passed
24:44 - is now going to be sorted okay and it's
24:46 - going to be sorted using this kind of
24:48 - merge
24:48 - style so this array from its left to
24:51 - right value
24:52 - will be sorted okay so let's look at the
24:56 - merge sort it's the second method
24:58 - so this takes an array a left and a
24:59 - right if left is less than right
25:02 - okay good we're allowed to do our thing
25:05 - then we find our mid
25:07 - all right average we call merge short
25:10 - recursively
25:12 - passes the array the left and the middle
25:14 - so that's the left half
25:16 - then we pass it the array and the right
25:18 - half
25:19 - okay and then we're going to merge those
25:22 - two halves
25:23 - stay with me i'm going to merge those
25:25 - two halves
25:26 - okay now you'll notice no returns here
25:31 - no return statements in any of these
25:33 - okay so they're going to run until
25:35 - they're done
25:36 - and then our base case is literally just
25:38 - code execution stops
25:39 - and code execution is going to stop
25:41 - essentially
25:42 - because we're going to reach a point
25:45 - where
25:46 - the right and the left kind of overlap
25:48 - again
25:49 - okay and that's going to stop our
25:50 - execution chain all right
25:52 - so essentially we take a big array we
25:55 - split it in half
25:56 - and we call merge sort on the left half
25:58 - so we call merge sort
26:00 - on the left and what that does is it
26:01 - calls this same method recursively
26:04 - okay now the right value is mid okay so
26:06 - if left is
26:07 - less than right then we still have room
26:09 - to go so it's going to call it again
26:11 - on the new left to mid and then it's
26:13 - going to call it again on the new left
26:14 - to mid
26:14 - and you can see all the recursive calls
26:16 - happening here so it's essentially going
26:18 - to go left
26:19 - to half to half until it reaches that
26:21 - last little list of two
26:23 - then it's going to merge that which is
26:24 - then going to allow the right-hand call
26:26 - to happen
26:27 - which is going to sort that which is
26:28 - then going to allow the merge call to
26:30 - happen the greater merge call
26:32 - which is going to sort those four items
26:34 - but now that kind of recursive chain is
26:36 - done
26:36 - but the next recursive chain is still
26:38 - happening which was on the right hand
26:40 - part
26:41 - of the last call and then that all gets
26:43 - woven down to two and then back
26:45 - out and you can kind of see from the
26:47 - visualization how it works
26:48 - again if that code didn't make sense in
26:51 - my short little video explanation
26:52 - that's okay i'd be surprised if it
26:55 - really did
26:56 - you've gotta code it you've gotta work
26:57 - with the code you gotta play with the
26:59 - code
26:59 - you gotta go look at it it's not gonna
27:01 - happen just from one explanation i'm
27:02 - sorry
27:03 - it's just not that easy okay so the
27:05 - links are in the description go check it
27:06 - out
27:07 - and then see how you get with it let me
27:08 - know again it's a high level concept
27:10 - it's one of the last things you learn
27:12 - in ab computer science so if it's easy
27:14 - then
27:15 - good for you that's awesome if not then
27:17 - you might have to put in some work
27:19 - that's okay so put in the work play with
27:21 - it a little bit see what you can do with
27:22 - it
27:23 - hop on over to some different websites
27:24 - like practice it or coding bat
27:26 - and try some practice problems and see
27:27 - if you can pull them off good luck
27:29 - thanks for checking it out if it's your
27:31 - thing like share subscribe
27:32 - i like making videos so if that's your
27:34 - thing keep doing it and i'll keep doing
27:36 - my thing and hopefully people learn
27:37 - something
27:38 - it's a goal see you humans have a good
27:41 - one

Cleaned transcript:

hello humans welcome back to co with connor glad you're here we are covering some more advanced java topics here that are part of the ap computer science a curriculum specifically we're going to be looking at searching and sorting algorithms now we're cherrypicking a bit here from the nonrecursive which is part of the arraylist kind of section of the course and the recursive which is part of the last unit in the course we're just going to look at them all together because i think it fits well to kind of analyze them together so we're going to look at a few things we're going to look at a sequential or linear search as well as a binary search and then we're going to look at some sorting algorithms so we'll look at a selection sort we'll look at an insertion sort and finally we'll look at a merge sort now my focus with this is not on code as much as it's on theory and this really just correlates to kind of the college board views on this which is that you need to be able to code trace these concepts and understand and read code for these searching and sorting algorithms you don't necessarily need to be able to code your own versions of them from scratch okay so particularly things like merge sort which get fairly advanced from a coding perspective with the recursive writing we'll kind of code trace a little bit but we're not going to go too heavy into writing the code now that being said i'm going to put some links in the description for some sites that break down the code okay and i'm actually pulling my code from geeksforgeeks so props to them for the great website and i will put that in the description so you can go and have a look at the code in more detail if you want to do that all right let's jump right in and talk about searching all right so we're gonna have a look at some searching algorithms we're gonna start with the sequential or linear which is kind of your straightforward you know left to right searching for something in a list or in a data structure all right so you can imagine not super efficient now that i say that let's just talk briefly we are not going to be talking efficiency in this kind of lesson if we wanted to window efficiency that's a whole other thing okay so we're not going to touch it i know you're going to get cranky of me if you're a higher level person and you know about this stuff you aren't sure about efficiency well it's a choice we're not doing that today sorry okay moving on i've got a list of numbers here i'm going to say i'm going to look for the 679 so i'm just going to do a really quick linear search of this okay so here we go and you see it's just tracing left to right it's going one index iterate the index check the value iterate the index check the value and so on and it's just checking are they equal to 679 that's it so you can see with a sequential or a linear search like this there's no prerequisite the list has to already be sorted because we're just going to scan the whole list from left to right until we find the value so that is a benefit of a linear or sequential is that it doesn't rely on the list being sorted you can see when it reached index 20 the value 679 was equal to the value in question so it stopped didn't finish it doesn't need to go the whole list it can have a stopping point but there's no requirement the list is in order when we're doing a linear or a sequential search let's hop over and look quickly at the code for a linear search so here's my code for linear search i'm taking an array okay and i'm taking a value and i'm going to search that array for that value all right if i don't find it i'm going to return negative 1. that's a very common practice anytime we're searching for an index of something in a data structure because negative one does not refer to an index so i start by finding the length of the array and is the array.length and then i do my for loop from zero to n iterating by one if the array value is equal to the value that was passed to my method then return the index in question if i make it all the way to the end of this loop and that if statement was never triggered it means it did not find the value therefore return negative one okay so that's what we're looking at with a linear search super straightforward just scan the array from left to right all right we're going to move on and talk binary search okay so this time we're going to look for that same number that's 679 using a binary search the way the binary search works is it's going to start at the beginning and the end index of our data structure then it's going to calculate the middle index okay and it's going to check if that middle index is the value we want and if it's not it's going to shrink the list either the first half or the second half and then continue the process so let's trace through it so we can understand it a bit better so i'm going to search that 679 you'll see that it set my low value to zero and it set my high value to 31. those are the indices okay now it's going to calculate my mid so let's step forward so my mid has been calculated to be 15. so again 31 minus 0 divided by 2 and then casa as an integer we're looking at 50. all right cool so it's going to check the value that 456. is that equal to my number no it's not but not just is it equal is it less than or is it greater than that value so because our number is bigger than 456 and it can't possibly come before because remember we are working with an ordered list so back when we did our first one you know when we did uh back when we did sequential or linear listed need to be an order didn't matter but when we do a binary there's a precondition here and the list must already be in order from smallest to greatest okay and that allows us to work so now i know my number comes after 456. so i can actually just ignore everything that came before index 15. so here we go how are we going to do that we're going to bring our low value up to 16 because 15 is out everything from 0 to 15 is out so we're going to set our low to 15 and we're going to recalculate our mid so we recalculate our mid to 23 again 31 minus 16 divided by two cast as an integer we find our mid okay now we're going to check our mid value 696 is bigger than 679 so now i know it's not in the right hand side of this so it's got to be in the left so i'm going to bring my high value down so my high value is going to come down to index 22 recalculate my mid recalculates my mid to 19. okay i'm going to check that 678 ooh just too small so i got to move to the right got to bring my low up bring my low up to 20 okay recalculate my mid get 21 i'm going to check that value 683 it's too big so i can go back but guess what there's nowhere to go back to because there's only one value left to the lefthand side so our low comes to 20 our high comes to 20. our mid gets calculated to 20 and our value is 679 and we found the value okay if we got to this point and the value still wasn't there then we would return negative one all right because it didn't find it it tried it got close but it didn't find it all right so at some point binary search is going to narrow down to a single vowel that value may or may not be the value but it'll be like kind of through this less than greater than less than greater than less than greater than at some point it reaches a point where it's like okay it's either this or it's not here and that's what happened here in this case it was here so it would return index 20. okay let's jump over look at the code now binary search is a recursive algorithm so we are going to be calling our function from within our function makes sense okay because again we're starting big and then we kind of recall it on the smaller we recall it on the smaller we recall it on the smaller until eventually there's really nothing left okay so let's have a look so we're going to take the array we're going to take a left value a right value and we're going to take the value we're looking for so if the right is greater than or equal to the left awesome then we find the mid all right it's left plus right minus one and then divide by two all right so the average in between them awesome so we check the value so if the value at mid is equal then we're done and we return the index awesome okay if the value is bigger than x then that means we need to move to the left so we need to bring our high dam okay so we're going gonna call it again but you can see our right now our right value is no longer the actual right value we started with it's the middle minus one so we're recalling it by shifting that high value shifting that right value down okay otherwise you'll notice we're recalling on on new left so we're bringing up the left to mid plus one so that's our else so that's if it's less than okay so what are we doing we're returning a recursive call to binary search and at some point binary search has only two choices it either has to return mid as a base case because we found the value or if it's not equal to and it's not less than and it's not greater than it's going to return negative 1 right and guess when that happens look at this if statement if right is greater than equal to the left do the check well guess what's going to happen at some point if we don't find this value we're going to keep iterating this mid right minus one plus one each time we recursively call at some point we're going to cross mid over and our left and rights are gonna cross and they're gonna be backwards and then the if statement's gonna fail and in the base case it's gonna return negative one okay so our recursive function has a base case where it'll return negative one if it doesn't find it it has the second base case where it'll return the actual index if it does find it and then otherwise it's returning that recursive call okay so that's where we're gonna see that recursion eventually kind of filter its way down so if the base case returns the actual index then it just returns that returns every time it returns until the end of the recursive call returns that same index so there's our binary search now binary search required that we were sorted well that's a whole other animal we got to talk about sorting algorithms so let's jump over and look at our first one all right so we're going to start here we're going to talk about a selection sort all right selection's already going to look very familiar too so i'm going to run the visualization and then i'll kind of pause it and talk through it as we look so you can see how it's traversing the array and it's got that red on the three what it's doing is it's scanning the array looking for the lowest number so it finds two it now flags that as the minimum value it's going to keep going all the way to the end of the array when it reaches the end of the array it's going to take that lowest value and shoot it to the front mark it as orange because now we're done with it we're not going to look at it anymore so we're actually going to start scanning now from the second position from index one and again we're scanning for the minimum in the remaining array so currently it's five now it's going to be three it's going to keep scanning four is no good 19 no good it's going to get to the end and it's going to swap that three with index 1 swapped now that's locked in now we're starting at index 2 and we're going to continue the scan looking for the minimum value and we're going to continue this kind of process of going from our kind of new starting position to the end of the array looking for a min once we finish the scan we swap them in with that starting position iterate the starting position and then keep going until we've reached the end of the array with the starting position okay we're going to reach the end of the array many times it's that starting position once that has shifted to the end of the array then we know that the array is in order it's been sorted okay so i'm just going to speed this up we're going to watch it finish and now our starting has reached the end and therefore our list has been sorted and we can see that it's in order from smallest to biggest all right so we call this a selection sort okay and you can see the pseudo code above my head all right so we're going to repeat a bunch of times we're going to set that first unsorted element as our min go through the whole thing looking for if something is actually lower than it and then we'll do the swap with that first unsorted and then enter it okay let's have a look at the code for how we can do this all right so here's our selection sort code so we start by finding the length of the array awesome okay now we're gonna kind of move that boundary over so we have one loop that outer loop is gonna start at zero and it's going to go to the end and that's going to be our starting position okay are we going to start at zero but then the next time it loops we're starting at one and each time we're going to go to the answer we have a nested loop here so you can see our nested loop here so this one is starting at i plus one okay so we've set zero to be our minimum and then we're gonna loop the remaining then we're gonna set one to be our minimum we're gonna loop from two on we're gonna set two to be the minimum loop from three on okay and that's kind of holding our starting position in the i value and then our j value is our looper as we're working our way through the array okay so my minimum index is our i value and then we're going to loop through from there so we're just checking if our current value is less than the value that's at our minimum index okay then we reassign our minimum index to that new index all right and then once we finish the loop that min index should point to the smallest value in the remaining array okay and that gives us a chance to do the swap so then we do remember with a swab you have to use a temporary variable okay you can't do a direct swap you've got a store one move one and then store back so we do a temp is whatever was at the minimum index so that's our minimum and the remaining array then we overwrite that with whatever was at our starting position that's all and then we override our starting position with the value of 10. so that's a completing our swap and then i is going to iterate we've got a new starting position and we loop again all right so a little tricky you got the nested loops there you've got you know there's a little play you gotta take your time to get that code and kind of understand how it works so that's our selection sort that's the easiest of our sorts now we're gonna jump over we're gonna look at insertion sort okay so this is insertion sort so again we'll trace through we'll explain as it goes so insertion sort you can see right away kind of what's happening we're looking at the 38 deciding where it fits in the array to the left now we're going to go to the five would be okay no it's smaller than 44 shift that over smaller than 38 shift that over is it smaller than three no okay we found the spot stick it there let's go to 47. okay it's good leave it where it is 15 okay no smaller than that shift smaller than that shift smaller than 38 shift is it smaller than 5 no up we go 36 and we're going to work our way through so we are going one time through and with each value we're kind of going to the left until we find its position in order of the values that are there so the deeper we get the more swaps we might have to make working our way to the left to find the correct place for each value so 26 one more move always do the compare back to 15 okay stop place it 27 and we work our way through all right so let's watch this finish and then we'll look at the code of how this works so the two is going to have to go all the way to the left a lot of compares compare compare compare compare compare hey we're at the beginning we already know where it goes before again we're going way back until it compares with the three compare and there we go and continue till we reach the end and there we go we've got a sorted list using an insertion sort algorithm let's look at the code for how we pull this off all right so our insertion sort we're going to start by setting up the length okay we have our outer loop from 1 up to the end all right and then our j value is going to be one less than our y value okay and that that is because we're kind of pulling out that key value at i and then we want to move to the left from it so we need to store that key value and then as we shift to the left we need room to kind of move everything up so we'll go starting from one less okay and then we can shove everything up out of the way until we find a place to put the key value so our j starts at one less than i and our key is kind of the pulled out value at our position as we work our way through the array so we work our way through the array we pull key out and then using a while loop so while j is greater than or equal to zero so as we move to the left and the value at j is bigger than my key value then that means i need to move that value over and get ready to check if my key goes there okay so while i'm greater than zero and while the left value is bigger than my key okay then i'm going to move that value over bring my key down and then move that value over bring my key down and i'm going to keep while looping that until one of those two statements is false so either i reach the end of the array in which case i found my home or the value kind of j is not bigger than key which means that i've found my location for key it's at i all right so array j plus one is now equal to key and i lock that in the value of j is not not touched we just checked it okay so now i've locked my key position in i iterate i and i repeat the process over and over again again this code's a little sticky you've got to take some time type it out trace it yourself kind of play with it you know again we're not writing this code from scratch so i'm kind of burning through it a little quicker than i would otherwise hopefully that makes you know a little bit of sense all right now we're going to move on with the most complex one which is a recursive sorting it's called a merge sort and again i'm going to visualize it i'm going to go through this code pretty quick okay if you really want to dive into merge short go dive into merge sort the links will be in the description i'm not going to go too crazy with it just because it does get a little bit more complex because we're running a two method structure uh in terms of merging two arrays together which shouldn't be too hard for you you should be able to do that that part absolutely you need to be able to do and then the second piece is the recursive merge short piece which uses the merge anyways i'll get ahead of myself let's go visualize virtual okay merge sort here we go let's see if we can make any sense of this here's our whole thing start with those two elements okay cool they're in order let's go to the next two elements okay oh they're not in order let's fix them now they're in order okay now let's pull those two pairs of two elements into one array that has four elements and let's put them in order okay we've merged that okay let's repeat that process over again with the next two elements 47 and 15. we're going to put those in order okay we're going to shove those back up kind of temporary as an array let's grab the next two 26 36 we're going to put those in order okay let's merge those two arrays is to one sorted array of four so 15 okay and then the 26 okay and then the 36 and then the 47 okay now let's take our two four arrays and let's merge those into a sorted array so we're going to take the three from the red array okay and then the 15 and the five note we're going to take the five the 15 the 38 take the 15 take the 26 take 36 take the 38 take the 44 anything left over we'll take the 47 okay we're gonna run this whole shebang again on the right hand side so we're going to take the twos the two and the 27 the 4 and the 46 we're going to merge them take the 19 and the 50 take the 48 we're going to merge them and repeat the process let's watch it go 2 and 27 put it back 4 and 46 merge it sort it and put it back take those two arrays of 2 and merge them into an array of 4 in order 2 and then the 4 and then the 27 and then the 46 and then shove it back okay let's take a 19 in the 50 put them in order okay 48's alone will kind of treat it like it's a thing anyway 48 okay let's merge those three okay good and we're merged and back up and now we'll take all seven and we're gonna merge those two and then four and then 19 and then 27 46 and anything that's left over okay beautiful now let's merge our eight in our seven into our final sorted list all right so the two and the three we take the two the three and the four we take the three we take the four over the five then we take the five over the 19 and we take the 15 over the 19. 19 over 26 26 then 27. now we got 36 then we got 46. oh sorry 38 then 44 then 46 47 48 and then 50. it's all merged it's all sorted and it's done and it's complicated but it's also beautiful okay so we're kind of taking these mini arrays we're sorting them and then we're merging them together into a new sorted array and then taking other arrays merging them sorting them right it's this kind of repeated process of merging the arrays and then sorting the merged arrays all right and we're going to look at the code for how we do this again it's a little bit complex that's okay all right so there's two pieces here there's our merge method which serves the purpose of merging two arrays okay so it takes our main array it takes a left a mid and a right okay a left and mid and a right so we're going to find the sizes of the two sub arrays to be merged remember merge does some sorting this isn't just slapping two arrays together in any order so we're going to take our first which is our middle minus our left plus one and then our right minus our middle so those are going to be the two sizes of our sub arrays we'll call them the left array and the right array l and r set them up to their sizes cool now we're going to copy the data into these arrays so just raw data again we're just going to take everything that was an array and just dump it into the left and the right or right just a perfectly even split no sorting yet so everything up to n1 goes into the left array everything from n1 up to n2 right goes into the right array all right so this starts at zero goes to n2 so that's the number of times it'll repeat but it actually starts at that mid plus one and then plus j so mid plus one and then one and and add on from there so that's going to fill the left and the right with whatever values we're on the left hand side and the right hand side of the original array that was passed now we're going to sort them back into the array okay so we have to have an i and a j so the i is for the left array the j is for the right array and they're both starting at zero of those respective arrays because we might iterate i three times and then iterate j once it's not going to be consistent okay because it all depends on the size of the values in those arrays so while i is less than n1 so that's keeping us within the size of the l of the left array and j is less than n2 again keeping us in the size of the right array then if the left value is less than or equal to the right value then we're going to keep the left value so the main array position k which is starting at l which is the left value that we wanted this whole shebang to start at is equal to that value and then we iterate i which is our left iterator otherwise okay so otherwise if left is not less than or equal to right then that means right must be bigger than left so array k is now equal to the right and we're going to iterate the right iterate or the jet okay and then when all that's done we're going to iterate our k so that now we're ready to check the next one and whether we pull it from the left we pull up the right doesn't matter this is going to run until one of the arrays left or right runs out of values okay so we've pulled everything from either the left or right or the right array so at that point we just need to get anything that's left over because one of them is going to have something left over so if i is less than n1 then we're going to run the while loop which means there's something left over in the left array and we're just going to literally just pull array k is equal to left iterate the left iterate k grab the next until the left array is empty we're never going to have the situation where both of these while loops run because the only reason we got here is because one of the left or right array has already been kind of blood drawn so one of them is going to run so either the left one's going to run or the right one's going to run but when the merge method is done the array that it was passed is now going to be sorted okay and it's going to be sorted using this kind of merge style so this array from its left to right value will be sorted okay so let's look at the merge sort it's the second method so this takes an array a left and a right if left is less than right okay good we're allowed to do our thing then we find our mid all right average we call merge short recursively passes the array the left and the middle so that's the left half then we pass it the array and the right half okay and then we're going to merge those two halves stay with me i'm going to merge those two halves okay now you'll notice no returns here no return statements in any of these okay so they're going to run until they're done and then our base case is literally just code execution stops and code execution is going to stop essentially because we're going to reach a point where the right and the left kind of overlap again okay and that's going to stop our execution chain all right so essentially we take a big array we split it in half and we call merge sort on the left half so we call merge sort on the left and what that does is it calls this same method recursively okay now the right value is mid okay so if left is less than right then we still have room to go so it's going to call it again on the new left to mid and then it's going to call it again on the new left to mid and you can see all the recursive calls happening here so it's essentially going to go left to half to half until it reaches that last little list of two then it's going to merge that which is then going to allow the righthand call to happen which is going to sort that which is then going to allow the merge call to happen the greater merge call which is going to sort those four items but now that kind of recursive chain is done but the next recursive chain is still happening which was on the right hand part of the last call and then that all gets woven down to two and then back out and you can kind of see from the visualization how it works again if that code didn't make sense in my short little video explanation that's okay i'd be surprised if it really did you've gotta code it you've gotta work with the code you gotta play with the code you gotta go look at it it's not gonna happen just from one explanation i'm sorry it's just not that easy okay so the links are in the description go check it out and then see how you get with it let me know again it's a high level concept it's one of the last things you learn in ab computer science so if it's easy then good for you that's awesome if not then you might have to put in some work that's okay so put in the work play with it a little bit see what you can do with it hop on over to some different websites like practice it or coding bat and try some practice problems and see if you can pull them off good luck thanks for checking it out if it's your thing like share subscribe i like making videos so if that's your thing keep doing it and i'll keep doing my thing and hopefully people learn something it's a goal see you humans have a good one
