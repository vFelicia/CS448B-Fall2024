00:00 - hello and welcome I'm your codm welcome
00:02 - to the free beginner section of my C
00:04 - Mastery course by going through this
00:06 - course you'll be able to make games
00:07 - website apps Robotics and literally
00:09 - anything C is an extremely versatile
00:11 - language starting from the absolute
00:12 - Basics like how code executes line by
00:14 - line and what is a variable then
00:16 - covering the intermediate topics like
00:17 - what are interfaces generics and events
00:19 - and how you can use them to build some
00:20 - really awesome things you will also
00:22 - learn the theory behind how to choose
00:24 - good naming rules clean code guidelines
00:26 - and learn about design patterns and
00:28 - finally the advanced section which will
00:29 - be coming in a future free update we'll
00:31 - cover lots of very Advanced topics now
00:33 - this free YouTube video this one
00:34 - contains all the video lectures from the
00:36 - beginner section in the previous video I
00:38 - spoke about my goals to make the video
00:40 - lectures free over here on YouTube if
00:42 - the premium version course sells 100
00:43 - copies then one month after this video I
00:45 - will publish intermediate section for
00:47 - free here on YouTube and same thing for
00:48 - the advance section one month after that
00:50 - and yep since the last video there's
00:52 - already been 100 people who picked up
00:53 - the premium version so one month from
00:55 - now stay tuned for the intermediate
00:57 - section or if you're watching this in
00:58 - the future then check the pin comment
00:59 - down below the premium version of the
01:01 - course has the video lectures just like
01:02 - this video plus all of the intermediate
01:04 - lectures and the advanced section coming
01:06 - soon as well as all of these really nice
01:08 - bonuses So speaking of that here are the
01:10 - bonuses for the premium version I came
01:11 - up with some that I think are really
01:13 - awesome and definitely worth it if you
01:14 - can't afford them well at the same time
01:16 - not putting any knowledge behind the pay
01:18 - wall so even people who can't afford it
01:19 - they can still learn from the free video
01:21 - lectures they really just need to do a
01:23 - little bit of extra work themselves the
01:24 - premium version is really just selling
01:26 - convenience making it really easy for
01:28 - you to truly gain the knowledge the the
01:29 - premium version comes with a companion
01:31 - project this is a Unity project that
01:33 - contains a bunch of extra content
01:35 - basically the video lectures while being
01:37 - preas of themselves there's still really
01:39 - only half the course the other half of
01:40 - it is inside of this project it has a
01:42 - bunch of custom editor Windows to guide
01:44 - you through each lecture and each
01:46 - lecture has a section on frequently
01:47 - asked questions these are common
01:49 - questions that have some really detailed
01:51 - answers that provide even more details
01:52 - on what is covered in the lecture then
01:54 - there are some quizzes these are
01:55 - multiple choice questions again own with
01:57 - very detailed answers it's really not
01:59 - just correct or incorrect if you pay
02:01 - close attention to each lecture you
02:03 - should be able to get most of these
02:04 - right but whether you do or don't by
02:06 - reading the extra explanation that will
02:07 - help you truly learn that topic then the
02:09 - interactive exercises I'm really happy
02:11 - with this feature I think this will
02:13 - really help you learn learning by doing
02:15 - is always much better and these
02:16 - exercises encourage you to put what you
02:18 - learned into practice instead of just
02:19 - blindly watching the video lectures I
02:21 - designed a ton of handcraft exercises
02:23 - for all the lectures to help you put
02:25 - into practice and truly learn the
02:26 - contents of each lecture there are all
02:28 - kinds of exercises some are about
02:30 - spotting and fixing errors others are
02:32 - about asking you to Define some function
02:33 - or class or Implement some kind of logic
02:36 - there are some where you just write code
02:37 - and somewhere you write code and then
02:39 - play the code in unity in order to
02:40 - complete the exercise then each exercise
02:42 - also contains a hint just in case you
02:43 - get stuck or a solution in case you get
02:46 - really stuck as well as a video
02:48 - walkthrough of me going through that
02:49 - exercise and completing it while
02:50 - explaining everything in detail so if
02:52 - you're the kind of person who gets stuck
02:53 - in tutorial hell then I truly believe
02:55 - that this will really help you escape it
02:56 - in order to learn you need to actually
02:58 - do things and this exercise in encourage
03:00 - you to do that they encourage you to do
03:01 - it as opposed to just blindly watching
03:03 - the video lectures then the companion
03:05 - project also has a companion window
03:06 - basically this window is also listening
03:08 - to a bunch of errors and if it finds one
03:10 - it will help guide you in the right
03:11 - direction I manually wrote a ton of text
03:13 - for when text lots of errors all of them
03:16 - based on common errors that I see people
03:17 - ask about in comments in my own videos
03:19 - so this should help prevent you from
03:21 - getting stuck in your Learning Journey
03:22 - and allow you to get helped instantly
03:24 - then the course also has an AI to help
03:26 - you answer questions this one was
03:28 - trained on the contents of the course
03:29 - and my own knowledge so it should be
03:31 - very accurate and helpful but more than
03:33 - that it's simply the fact that it is
03:34 - extremely fast you post a question in
03:36 - the course comments and within a few
03:37 - minutes the AI will respond with
03:39 - probably a very good answer although of
03:41 - course I myself will also still be
03:42 - answering all the questions manually the
03:44 - goal with this AI is really speed so you
03:45 - get a response almost instantly and then
03:48 - within the next few hours I will
03:49 - manually answer myself then a simple
03:51 - bonus is how the premium version has the
03:52 - course split into lectures as opposed to
03:54 - Here on YouTube where it won't be one
03:56 - giant video it has to be that way due to
03:58 - how the YouTube algorithm works works
04:00 - this is a small thing but it can be
04:01 - helpful especially if you take your time
04:03 - to slowly go through the course just
04:04 - like you should do remember that the
04:06 - only goal is really that you actually
04:08 - learning yourself it does not matter how
04:09 - quickly you go through it so separate
04:11 - lectures help with that so that you can
04:13 - pause and actually try out your
04:14 - knowledge before going further and you
04:16 - don't have to memorize specific time
04:18 - stamps and over here on YouTube the
04:20 - videos have the normal YouTube ads as
04:21 - usual whereas the premium version has no
04:23 - ads so there's nothing to interrupt you
04:25 - while you're learning another really
04:26 - nice bonus of the premium version is
04:28 - something that I'm going to try out for
04:29 - the first time which is a live study
04:31 - group basically once or twice per week I
04:33 - will go live and post a link to the live
04:34 - stream so people can join in there I
04:36 - will watch the lectures alongs side of
04:38 - you then we're all going to read the
04:39 - frequently asked questions together do
04:41 - all the quizzes and go through all the
04:42 - exercises naturally I won't be reading
04:44 - the chat so I won't be able to answer
04:46 - any specific questions you have I've
04:48 - really never done anything like this so
04:50 - I'm really curious to hear what you all
04:51 - think some people like to learn more as
04:53 - part of a group so hopefully this should
04:54 - be quite fun the first live study group
04:56 - is happening next Saturday March 9th and
04:59 - if you can't live then as always they
05:00 - will be recorded so you can watch the
05:02 - recordings later and final bonus is
05:04 - really just by knowing that by buying
05:05 - the premium version you won't be helping
05:07 - hit the goal to make the free video
05:08 - version available for everyone so you
05:10 - will be helping to make knowledge
05:12 - available to anyone who wants to learn
05:13 - so these are the nice bonuses that I
05:15 - came up with that I think are really
05:16 - nice and really awesome while not taking
05:18 - away anything or putting any knowledge
05:19 - behind the pay wall if you can afford
05:21 - then I highly recommend the premium
05:23 - version these bonuses will help you
05:24 - truly learn and learn much much faster
05:26 - than the 10 years that it took me but if
05:28 - you can't afford it that's okay like I
05:30 - said there's no hidden knowledge hidden
05:32 - behind the paywall you really just need
05:33 - to put more effort in yourself in order
05:35 - to actually apply knowledge that you
05:36 - gain and if you want you can go ahead
05:38 - and pick up the premium version right
05:39 - now there's a link description I added a
05:41 - nice launch discount so you can get it
05:43 - before the first live study group next
05:44 - Saturday so whether you get the premium
05:46 - version or watch your free lectures I
05:48 - really hope you'll learn a lot also just
05:50 - in case you're new to my channel so a
05:51 - bit about me and my credentials or why
05:53 - you shouldn't listen to what I have to
05:54 - teach for me I've been programming for
05:56 - over 25 years and specifically using C
05:58 - for over 10 years I'm a professional
06:00 - indie game developer with several
06:01 - successful games PO on seam covering a
06:03 - wide range of genres my games are
06:05 - usually focused on complex systems since
06:06 - I am primarily a programmer it's what I
06:08 - really love to do and what I love to
06:09 - teach also a couple of years ago I
06:11 - started over here this YouTube channel
06:13 - making free video tutorials to basically
06:15 - share my knowledge to help you learn how
06:16 - to make your own games there's already
06:18 - over 800 free videos over here on this
06:20 - channel if you want to continue learning
06:21 - Beyond this course also let me make one
06:23 - very important note for beginners which
06:25 - is simply take your time remember this
06:27 - is your Learning Journey no one else's
06:29 - the only thing that matters is that
06:30 - you're learning it does not matter how
06:32 - long it takes you so it does not matter
06:33 - if someone learns all of this much
06:35 - faster than you you are really not in
06:37 - competition with anyone but yourself
06:39 - also you are not expected to go through
06:40 - this course in one day one week or even
06:42 - one month basally all the contents out
06:44 - of this course this contains knowledge
06:46 - that took me 10 years to learn so really
06:48 - just take it slow take your time and
06:50 - really just focus on learning and one
06:52 - final request if you find this video
06:53 - helpful if so go ahead and hit the like
06:55 - button and subscribe to the channel it's
06:57 - a tiny thing but it really does help all
06:58 - right so let's get to the first
07:01 - lecture starting from the very beginning
07:04 - first we're going to learn what is C and
07:06 - what have the many use cases for it then
07:08 - on the getting start lecture we're going
07:09 - to install Visual Studio which is where
07:11 - we're going to run our code then we're
07:13 - also going to install unity and learn
07:14 - the unity Basics this is an optional
07:16 - step but it's important since the
07:18 - interactive exercise and quizzes those
07:20 - exist in a Unity project after that
07:21 - we're going to load up that project to
07:23 - see how the interactive exercise work
07:25 - and then is a really useful lecture
07:26 - covering some very common errors you
07:28 - should refer back to this one whenever
07:29 - you encounter some issues after that one
07:31 - we can finally start writing some code
07:33 - beginning with the absolute Basics
07:35 - learning how the code is written how it
07:37 - executes what is a code block and how
07:39 - code is case sensitive then we're going
07:40 - to learn about variables these are
07:42 - containers for data the data needs to
07:44 - have a specific type so then we're going
07:46 - to learn about the various built-in data
07:48 - types things like int B string and so on
07:50 - next we're going to learn about if
07:51 - statements this is a core pillar of any
07:53 - programming these are conditions which
07:55 - affect how your code will execute after
07:57 - that we'll learn a different way of
07:58 - handling conditions using a switch
08:00 - statement next we'll learn about another
08:02 - core pillar functions this is how we can
08:04 - place logic in separate functions and
08:06 - call them when needed after learning
08:07 - about functions which involves different
08:09 - code blocks then we are going to learn
08:10 - about variable scope which is basically
08:12 - from where that variable can be accessed
08:15 - next we'll learn about comments the
08:16 - Syntax for this one is actually really
08:18 - simple but it does bring up a lot of
08:19 - interesting questions regarding writing
08:21 - good clean code then we're going to
08:22 - learn how to store multiple pieces of
08:24 - data in one container using arrays and
08:26 - lists afterwards we're going to learn
08:28 - all about loops this is how we can run
08:29 - certain logic multiple times like for
08:31 - example looping through all members of a
08:33 - list then another crucial pillar of
08:35 - object-oriented programming we're going
08:36 - to learn the basics of classes how to
08:38 - define one and construct it next we will
08:40 - be ready to learn about static what is
08:42 - the difference between making something
08:44 - static and non-static then learn about
08:46 - access modifiers this is another one
08:48 - that is super simple in terms of syntax
08:49 - and extremely important in terms of
08:51 - learning to write good clean code after
08:53 - that comes one of the most important
08:54 - lectures in this whole entire course
08:56 - it's a lecture on naming rules and how
08:57 - you should be very careful and and very
08:59 - deliberate about the names that you use
09:01 - in your code and after that is yet
09:03 - another extremely important lecture this
09:04 - one covering the theory behind why you
09:06 - should write good clean code as well as
09:08 - some nice simple guidelines that you
09:10 - should follow with all that done we will
09:11 - have learned the absolute Basics so we
09:13 - will be ready to inspect a nice beginner
09:15 - project that involves everything we
09:17 - learned in this section all of that
09:19 - makes up the beginner section and
09:21 - afterwards comes the intermediate
09:22 - section we're going to take things up
09:24 - one level and learn some more complex
09:25 - stuff beginning with something very
09:27 - important that I debated whether I
09:29 - should put in the beginner section it's
09:30 - going to be Visual Studio shortcuts I
09:32 - end up putting it here because for
09:34 - beginners technically it's more
09:35 - important to learn how to write the code
09:37 - and it's not as important to be
09:38 - extremely efficient with how fast you
09:39 - use your ID but for intermediates this
09:42 - is a must have so we're going to learn
09:44 - about a ton of shortcuts to help you
09:45 - write code and navigate your environment
09:47 - much better then comes one of the most
09:49 - important lectures in this whole
09:50 - intermediate section it's all about
09:52 - refactoring this is the process of
09:54 - rewriting your code to make sure it is
09:56 - as readable and understandable as
09:58 - possible as an inter it you absolutely
10:00 - need to know that this is a natural part
10:02 - of the code writing process and
10:03 - something you should not skip next is a
10:05 - lecture on enom pretty simple and very
10:07 - useful it's how you can define a
10:09 - specific list of values that you can use
10:11 - in many ways after that we'll learn
10:13 - about properties which are kind of like
10:14 - a mix between variables and functions
10:17 - then we're going to learn about
10:18 - multi-dimensional arrays meaning arrays
10:20 - that can hold multiple dimensions of
10:21 - data after that we're going to learn
10:23 - about nest and Loops which is especially
10:25 - important in order to cycle through
10:26 - multi-dimensional arrays next we're
10:28 - going to learn another method for doing
10:30 - some looping logic we're going to learn
10:31 - about recursion this is something that
10:33 - for people with a math background it
10:35 - might actually be similar to understand
10:36 - than R Loops then we're going to learn
10:39 - about an extremely useful data type the
10:40 - dictionary this is a key value pair that
10:43 - has tons of really awesome use cases
10:45 - after that we're going to learn about
10:46 - some more collections like q and Sack
10:48 - then we're going to learn about the
10:50 - prams keyword and what exactly does it
10:51 - do in a function next we'll learn about
10:54 - optional parameters how to define them
10:56 - and how to call them from a function
10:58 - then another crucial lecture for
10:59 - intermediates this one is on learning
11:01 - the differences between value and
11:02 - reference types this is extremely
11:04 - important if you don't know this
11:06 - difference then you will go crazy at
11:07 - some point in the future wondering why
11:09 - something isn't changing and it's
11:10 - usually going to be because you don't
11:12 - know you're working with a copy and not
11:13 - a reference related to that is the
11:15 - lecture on structs these are similar to
11:17 - classes but importantly they are a value
11:19 - type next we're going to learn some more
11:21 - intermediate use cases for classes we're
11:23 - going to learn about inheritance
11:24 - polymorphism and a bunch more then learn
11:27 - about interfaces this is one of my
11:29 - favorite features of C it allows you to
11:31 - write some really nice modular code
11:33 - related to that we're going to see
11:34 - various ways of testing for types and
11:36 - converting two and from various types
11:38 - also related is the lecture on switch
11:40 - pattern matching this is a really simple
11:43 - way to do a switch not just on value but
11:45 - also on type then we're going to learn
11:46 - all about delegates lambdas and
11:48 - Anonymous functions this is how we can
11:50 - store a function itself inside a field
11:53 - next we're going to learn the
11:54 - differences between lambdas and local
11:56 - functions after that we'll learn about
11:58 - events which is how we can have one
11:59 - class be notified when something happens
12:01 - then the next lecture that one is going
12:03 - to be all about generics this is another
12:05 - super powerful C feature that makes your
12:07 - code work with multiple types next is a
12:10 - simple lecture on conents and read only
12:12 - what they are and what are the
12:14 - differences between those two after that
12:16 - is in lecture on exceptions and how to
12:18 - handle them with a try catch then in
12:20 - lecture on implementing I enumerable so
12:22 - we can add support for something like a
12:24 - 4 in for some custom types next we're
12:26 - going to learn about namespaces what
12:28 - they are and how to make your own then a
12:30 - really important lecture on one of the
12:32 - most important design patterns the
12:33 - single tent pattern and after that is a
12:35 - general overview of a bunch more design
12:37 - patterns and finally after doing all of
12:39 - that we're going to check out the
12:40 - intermediate project that uses all of
12:42 - this to make something really
12:43 - interesting so that makes up the
12:45 - intermediate section and then comes the
12:47 - advanced section for this one like I
12:49 - said in the beginning I'm still actively
12:50 - working on it so this will be coming
12:51 - later as a free update here are the
12:54 - topics that I'm planning to cover all
12:56 - right so that's everything we're going
12:57 - to learn in this complete C course like
13:00 - I've said many times you are not
13:01 - expected to go through all of this in
13:03 - just one day or one week or even one
13:05 - month it took me 10 years to learn all
13:07 - of this so always remember that and take
13:09 - your time and really just focus on
13:10 - actually learning this is your Learning
13:12 - Journey so that's really all that
13:14 - matters take it slow really pay
13:15 - attention do all the content in the
13:17 - companion project and I guarantee that
13:19 - if you do that then by the end you will
13:21 - have gained a massive amount of
13:23 - knowledge hello and welcome I'm your Cod
13:25 - monkey in this lecture we're going to
13:27 - learn what exactly is C and what it's
13:29 - used for okay so C is a program language
13:32 - it was created by Microsoft in the year
13:33 - 2000 it is an objectoriented General
13:36 - multi-purpose language with tons of use
13:38 - cases for me specifically the main way
13:39 - that I use it is for game development
13:41 - with unity but you can also use it to
13:43 - make websites with asp.net or Blazer you
13:45 - can use it to make Native mobile apps
13:47 - with zamarin you can do tons of stuff in
13:49 - the cloud it's especially easy to use
13:51 - with Azure which is Microsoft's cloud
13:53 - service you can develop on Internet of
13:54 - Things devices or you can use it to make
13:56 - some simple desktop apps to help you in
13:58 - your daily life you can make console
14:00 - programs or visual desktop applications
14:02 - so it has tons of use cases it is
14:04 - multiplatform meaning you write C and
14:06 - you can run on Windows Mac Linux and
14:07 - other platforms the language is
14:09 - constantly evolving despite being 24
14:11 - years old it is still actively being
14:13 - developed with new versions coming out
14:14 - on a regular basis it is also one of the
14:16 - most popular and independ languages so
14:18 - it's a great one to learn personally I
14:20 - also believe that it's a great first
14:21 - language to learn I especially like how
14:23 - it's type save meaning it has very
14:25 - specific types and if you write some
14:27 - code incorrectly you will get a
14:28 - compounder warant instead of having an
14:30 - error suddenly show up while the code is
14:31 - running and if you're not a complete
14:33 - beginner if you already know Java or C++
14:35 - then chances are you won pick up pretty
14:37 - easily since it is relatively similar to
14:39 - those languages so yeah personally I'm a
14:40 - huge fan of C I've been using it pretty
14:42 - much every single day since I started
14:44 - game development with unity over 10
14:45 - years ago I've made tons of games with
14:47 - it and I've also used it to make some
14:49 - personal desktop apps and I also use it
14:50 - when I explore the cloud so it is a
14:52 - great very valuable language to learn
14:54 - and if you pay close attention to this
14:55 - course then by the end you will have
14:57 - gained a massively valuable skill
15:00 - hello and welcome I'm your K monkey in
15:02 - this lecture we're going to go over how
15:03 - you can get help when you need to and
15:05 - how to get the most out of this course
15:07 - okay so learning programming can be a
15:09 - little bit tricky at first especially if
15:10 - you are a complete beginner right away
15:12 - let me say that is perfectly normal if
15:14 - you are a beginner and some things seem
15:16 - quite confusing that is perfectly okay
15:18 - that's all part of the regular learning
15:20 - process so there's really no point in
15:21 - getting frustrated just take your time
15:23 - and really just focus on trying to learn
15:25 - in order to help you learn this course
15:26 - has a bunch of things for every lecture
15:29 - the unity project contains a bunch of
15:30 - helpful common frequently asked
15:32 - questions I highly encourage you to
15:34 - always read through those as you go
15:35 - through each lecture and whenever you
15:36 - have any question then I also highly
15:38 - encourage you to go answer all the
15:40 - quizzes for every lecture and do all of
15:41 - the interactive exercises you will learn
15:43 - so much more if you're being active in
15:45 - your learning as opposed to just
15:46 - passively watching a video so definitely
15:48 - make sure you do those after watching
15:50 - every lecture pause go to the N project
15:52 - and do all of those also on that Unity
15:54 - project if you write some code that has
15:56 - some error the companion can provide
15:58 - some extra clarification on what exactly
15:59 - that error means so if you're having
16:01 - some issues and you're writing code in
16:03 - the C console try writing that same code
16:05 - inside Unity to see what the companion
16:07 - says then there is a really important
16:09 - lecture covering a bunch of common
16:10 - errors if you have errors in your code
16:13 - chances are the error has an explainer
16:14 - in this lecture also when you have some
16:16 - issues the first step is to actually
16:18 - identify what exactly is the issue and
16:20 - for that the best way to find it is to
16:22 - add tons of logs in your code at various
16:24 - places to see exactly what the code is
16:25 - doing line by line there are many cases
16:27 - when beginners think the code is doing
16:29 - something but in reality it's doing
16:30 - something completely different adding
16:31 - logs is a super easy way to help you
16:33 - visualize exactly what the code is doing
16:35 - and of course you can simply post
16:37 - questions in the comments of that
16:38 - lecture one bonus this course is the
16:40 - automatic bot response you can ask
16:41 - something and within two to three
16:43 - minutes the bot will reply I train the
16:45 - bot on the contents of the course and my
16:46 - own knowledge so the answer should be
16:48 - pretty good the main benefit of the bot
16:50 - is the near instant reply so you don't
16:52 - have to wait for me to reply and you can
16:54 - continue learning quickly but also after
16:56 - the bot replies within the next 24 hours
16:58 - I will manually answer your question and
17:00 - confirm or provide some extra
17:02 - clarification on whatever the bot said
17:04 - then here's also a quick guide on how to
17:05 - ask a good question for example do not
17:07 - just say it's not working just saying
17:09 - this is really not helpful technically
17:12 - not working can mean a million different
17:14 - things for example do you have a compile
17:16 - error if so what exactly does it say
17:18 - specifically what line of code is
17:20 - throwing that error or if it's not some
17:22 - kind of compile error how exactly is it
17:24 - not working so did you expect one result
17:26 - but got another did the code seem ly not
17:29 - run are you getting some different
17:31 - results from what you see in the video
17:33 - in order for me to be able to help you I
17:34 - need as much information as possible
17:36 - there's really not much I can do to help
17:38 - if the only message I have is it's not
17:39 - working so when posting some question be
17:41 - very very specific about what exactly is
17:43 - the issue so I can do my best to help
17:45 - all right so that's see many ways you
17:46 - can get help throughout this course just
17:48 - keep in mind what I said in the
17:49 - beginning if you are a beginner It's
17:51 - Perfectly Normal that something seem
17:53 - quite tricky to understand that's all
17:54 - part of the regular learning process so
17:56 - don't get stressed about it all that
17:57 - matters is that you learn learn it
17:59 - really does not matter if it's easy or
18:00 - hard if it's fast or slow as long as
18:03 - you're learning then you're doing great
18:04 - remember that I've been programming for
18:06 - over 25 years so if you manage to get
18:08 - through this entire course and fully
18:10 - learn everything in it in just a few
18:11 - months then you're doing so much better
18:13 - than me so really just take your time
18:15 - use all these tools at your disposal to
18:17 - really learn and let's get started in
18:19 - the next lecture hello and welcome I'm
18:22 - your Cod monkey in this lecture we're
18:23 - going to install and set up visual
18:25 - studio which is where we're going to be
18:26 - writing our code okay so let's see where
18:28 - we're going to write our code you can
18:30 - use whatever ID you want ID stands for
18:32 - integrated development environment some
18:34 - common examples for C are visual studio
18:37 - code jet brains Rider or normal Visual
18:39 - Studio you can follow this course using
18:40 - whatever idea you want but if you're a
18:42 - beginner then it's probably best to use
18:43 - the exact same as me here I will be
18:45 - using visual studio 22 the community
18:47 - version this one is free also an
18:49 - important distinction it is Visual
18:50 - Studio not Visual Studio code it's a bit
18:52 - confusing how the names are very similar
18:54 - but those are two completely different
18:55 - programs here I will be using the
18:57 - regular visual studio so like downloaded
18:59 - go to visual studio. microsoft.com then
19:02 - click on downloads and download the free
19:03 - community version then go ahead and open
19:05 - up the executable file after installing
19:07 - right away it opens up the visual studio
19:09 - installer this is the main program that
19:11 - manages all of your installed versions
19:12 - of visual studio and right away we can
19:14 - install Visual Studio Community
19:16 - alongside a bunch of modules like I
19:17 - mentioned in the previous lecture C can
19:19 - be used for a lot of stuff and visual
19:21 - studio you can also develop on other
19:22 - languages so here you can see tons and
19:24 - tons of modules the ones that we're
19:26 - going to need in this course are the net
19:28 - desktop development this will let us
19:29 - make console apps which is the main
19:31 - template that we're going to use to
19:32 - learn C so make sure to include that one
19:34 - and then since the interactive exercises
19:36 - since those are built in unity also make
19:38 - sure to include game development with
19:39 - unity okay so these are the two main ons
19:42 - that we need so let's go ahead and
19:43 - install this will download all the
19:45 - modules and install
19:48 - them okay it's done and launches visual
19:50 - studio right away now it's asking for a
19:52 - sign in this can be useful to transfer
19:54 - your settings across devices so if you
19:56 - want go ahead and sign in or just click
19:58 - on skip for now then for the theme again
20:00 - you can choose whatever you want
20:01 - personally I'm going to go with the
20:02 - light theme which is what I like but you
20:04 - can use whatever you prefer and right
20:05 - away let me answer the question that I
20:07 - inevitably get every time I say that I
20:09 - prefer the light theme when so many
20:10 - people seem to prefer Dark theme for me
20:12 - my eyes simply get really messed up in
20:14 - dark mode if I try focusing on white
20:16 - letters on a black background I get a
20:18 - massive headache really quickly so
20:19 - personally for me I use light mode but
20:21 - this is really just a visual change so
20:23 - choose whatever you prefer okay with
20:25 - that let's start using visual studio and
20:27 - Y right away we can see the project list
20:29 - although it's empty right now we can
20:31 - open a project or create a brand new one
20:32 - so let's do that then here we can choose
20:34 - the templates let's go ahead and make a
20:36 - simple console app which is the most
20:38 - basic thing possible so you can search
20:39 - for console up here and now yep it is
20:41 - this one right here the one that has the
20:43 - C icon in the corner it is not this one
20:45 - with VB that's for Visual Basic and also
20:47 - not this one for F this is for f and it
20:50 - is also not this one that says C but
20:52 - also says NET Framework it's a bit
20:54 - confusing but net and Net Framework
20:57 - those are two completely different
20:58 - things right now in here we want net and
21:00 - not NET Framework so yep it's this
21:03 - template also if you don't see it then
21:04 - go back into the visual studio installer
21:06 - click on modify and install some modules
21:08 - and then make sure net development is
21:10 - checked okay so this is the template
21:12 - that we want the console application so
21:14 - let's use this one okay now let's give
21:15 - it a name you can name it whatever you
21:17 - want here I'm going to go with the basic
21:19 - hello world then go ahead pick a
21:21 - location to spawn your project and leave
21:23 - the solution the same name as default
21:24 - okay so like this let's go on next then
21:26 - over here we can choose the framework so
21:28 - for this let's go with net 8 and now
21:30 - there's a pretty important option here
21:32 - which is whether or not use top level
21:33 - statements basically if you leave this
21:35 - unticked so like this then the project
21:37 - won't be created and look pretty much
21:38 - empty whereas if you take this then the
21:41 - project will be created and look like
21:42 - this with a namespace program and a main
21:44 - function the option for this difference
21:46 - this was added relatively recently so if
21:48 - you watch all their C tutorials they
21:50 - might show this template but for
21:51 - complete beginners it's completely empty
21:53 - option it's actually easier to follow so
21:54 - we're going to use this one later on
21:56 - after we'll learn the absolute Basics we
21:57 - will make another project with the more
21:59 - complex template but really the main
22:01 - takeaway that I want you to learn from
22:02 - here is really just code is code meaning
22:04 - that for everything we're going to learn
22:06 - in the absolute basics part using this
22:07 - simpar template all of that can also be
22:09 - done in this more complex template the
22:11 - difference is simply in how in the basic
22:12 - template you just write code here but in
22:14 - the more complex template you need to
22:15 - write that same code inside the main
22:17 - function if you write code in a
22:18 - different place you can get some strange
22:20 - errors so that is why for beginners the
22:21 - simpler template is much easier so over
22:23 - here to keep things simple let's first
22:25 - use that basic template so make sure to
22:26 - leave this one unticked so example down
22:28 - like this and let's create all right yep
22:30 - so here is our empty template and by
22:32 - default it already has a standard hell
22:34 - World print you don't need to understand
22:35 - this line of code just yet I will
22:37 - explain all of this in detail soon right
22:39 - now we can just run this test so on the
22:41 - top right on middle you can see this
22:42 - nice little play button or alternatively
22:44 - the default shortcut is F5 so go ahead
22:46 - and press either one of those and up
22:48 - here is the window our program ran it
22:50 - did indeed say hello world and
22:52 - everything finished all right awesome
22:54 - okay so we can already start writing
22:55 - some C code and run it now let's change
22:57 - some things in visual Studio there's a
22:59 - really nice extension that I really like
23:01 - which adds a bit more colors to the code
23:02 - which I find that it makes it much
23:04 - easier to read and write so up here on
23:06 - top let's go into extensions and then
23:07 - manage extensions then go ahead and find
23:10 - Vora you can go to the online Tab and
23:12 - search for it now I believe that this
23:13 - one is actually only available on
23:15 - Windows so if you're on Mac you might
23:17 - not be able to find it maybe there is an
23:18 - alternative but I'm not sure either way
23:20 - this is just an optional extension just
23:22 - to add some visual so technically you
23:23 - don't absolutely need it but if you are
23:25 - on Windows and I highly encourage you to
23:26 - install it let's go ahead close visual
23:28 - Studio to let it install okay great so
23:30 - done let's open up the same project
23:32 - again all right so now for some more
23:33 - settings you can go into tools and
23:35 - options and over here let's scroll down
23:37 - to find vs and here are the settings now
23:40 - for the most part I believe the ones
23:41 - that I have here are the defaults you
23:43 - can pause the video and compare my
23:44 - settings with your own I believe I
23:45 - really only changed some colors over
23:47 - here on the rainbow braces right away if
23:49 - we look at our default hello world code
23:50 - it should already have some colors that
23:52 - make it a bit easier to read again this
23:54 - is not a requirement you don't need this
23:55 - extension but I do find it quite useful
23:57 - I find it helps to make the code more
23:58 - readable than having almost everything
24:00 - is gray next for some text formatting
24:02 - rules let's go up here into tools and
24:04 - then go into options then over here
24:06 - let's scroll down and find the text
24:07 - editor and again pause the video if you
24:09 - want I think over here I think I have
24:11 - everything as a default then let's
24:12 - expand upon this one and look
24:14 - specifically at the C options and over
24:16 - here again pretty much the same default
24:18 - I think the only thing different is over
24:19 - here I disabled the automatic brace
24:21 - completion just because personally I
24:22 - don't like it and let's expand upon it
24:24 - see a few more things so these scrome
24:26 - bars then over here the tabs pretty
24:28 - normal they not Advance again I think
24:30 - all of this is pretty much a default but
24:32 - intellisense right like this and then
24:34 - inside the code style in general I think
24:36 - over here I didn't touch any of this so
24:37 - I think the only thing I touched was
24:39 - over here on formatting and the main
24:40 - thing that I changed was over here on
24:42 - the new lines basically the default is
24:44 - to have all of the currently braces all
24:46 - of them on new line and over here I
24:47 - switch this ones in order to make them
24:49 - spawn on the same line which personally
24:51 - I prefer but again this is very much
24:52 - personal preference the code really
24:54 - doesn't care whether the braces are in
24:55 - the same line or new line so you can use
24:57 - whatever form you prefer personally I
24:59 - prefer it like this I've been using this
25:01 - code sound for 25 years now so this what
25:03 - I won't be using in the course but it's
25:04 - just a visual thing so if you really
25:06 - prefer it on new line then go ahead and
25:07 - place it on new line okay so after all
25:09 - that Visual Studio is set up and ready
25:11 - to go now let's continue on to the next
25:12 - lecture we're going to install unity and
25:14 - learn the absolute
25:15 - Basics hello and welcome I'm your Cod
25:18 - monkey in this lecture we're going to
25:19 - learn the basics of unity now like I
25:21 - said this part is technically optional
25:23 - if you're just looking to learn C then
25:24 - technically you don't need to learn
25:25 - Unity but since I won't be using Unity
25:27 - to build the inter active exercises and
25:29 - also using it to Showcase some example
25:31 - code with some fun visuals to help you
25:32 - learn better because of that even if you
25:34 - don't specifically want to learn Unity
25:35 - still make sure to watch this lecture
25:37 - just so you're not confused when any
25:38 - Unity code shows up first we need to get
25:40 - Unity Hub now since we selected unity
25:42 - game development when we installed
25:44 - Visual Studio it already automatically
25:45 - installed Unity Hub in your case if you
25:47 - accidentally did not take that box you
25:49 - can just manually go to unity.com and
25:51 - download it then open up un Hub this is
25:54 - the program that manages all of the
25:55 - various un versions in case you see
25:57 - something that looks like this this is
25:59 - actually the older version of The Hub so
26:01 - like it says here there's a button to
26:02 - update so let's do that and yep here we
26:04 - are in the updated Unity Hub it asks you
26:06 - to sign in so go ahead and do that if
26:08 - you don't have an account you can create
26:09 - one it's free Unity itself has a free
26:11 - personal version so you don't have to
26:13 - pay anything go ahead create an account
26:14 - and log in and right away it selects a
26:16 - version to install here you can install
26:18 - this version right away but we're
26:19 - actually going to install a specific
26:21 - version that might or might not be the
26:23 - same as the pre-selected version
26:24 - depending on when you're watching this
26:25 - so over here either way you can either
26:27 - install or skip this then here we have
26:29 - un Hub open on the left side we have
26:31 - some buttons we can manage our account
26:33 - we can install various un versions or
26:35 - check out the projects so over here on
26:37 - the projects tab we can add a project
26:39 - but before doing that let's go ahead and
26:40 - download the interactive exercises
26:42 - project go on to the course website on
26:43 - this lecture then scroll down and find
26:45 - the downloadable project files yep it's
26:47 - this one so go ahead and download that
26:49 - it's a simple zip file just open it and
26:51 - extract it somewhere and now back here
26:52 - in unity Hub let's go in the project Tab
26:54 - and then up here let's add a project
26:56 - select the one we just downloaded and
26:57 - let's open okay yep so here it is and
26:59 - over here it says the version that this
27:01 - project was built with if you don't have
27:02 - this version you can click this button
27:04 - to download it and yep it will download
27:05 - the correct Unity version now
27:07 - technically I should say you can load
27:08 - the project with a later Unity version
27:10 - doesn't specifically have to be this one
27:11 - but in order to avoid any confusion with
27:13 - menus being in different places in order
27:15 - to avoid any of that I highly encourage
27:16 - you to use the exact same version so
27:18 - there it is everything is installed
27:19 - everything is ready so now we can click
27:20 - to open up this
27:22 - project and yep here is the project open
27:25 - now let's just do a little bit more
27:26 - setup for example let's go up top over
27:28 - here let's go into edit and then let's
27:30 - open up the preferences then over here
27:31 - on this window on the left side let's
27:33 - scroll down into external tools and over
27:35 - here for the external script editor make
27:37 - sure you select your Visual Studio
27:38 - installation or if you prefer you can
27:40 - obviously use a different ID but if
27:41 - you're following everything along with
27:43 - this course make sure you select Visual
27:44 - Studio okay then for the extra options
27:46 - you can leave everything like this and
27:47 - here's a screenshot of my general
27:48 - options I believe all of this is the
27:50 - default so now we can close this window
27:52 - and now if we have correctly set the
27:53 - external editor if we go up here into
27:56 - assets and then click on open C project
27:58 - Yep this one should open your Visual
27:59 - Studio okay great so far so good now
28:01 - just one thing you should already see
28:03 - the code kind of like this meaning with
28:05 - a bunch of colors so for example if I
28:06 - place the mouse over here on top of mono
28:08 - Behavior it should correctly identify
28:10 - this is a class inside Unity engine this
28:12 - is a Unity specific class if you don't
28:14 - see it if you Mouse over this and
28:15 - doesn't recognize this type or if you
28:17 - see this as written in complely Gray if
28:19 - so then perhaps something went wrong
28:20 - during installation so you might need to
28:22 - manually install the visual studio tools
28:23 - for Unity you can just Google Visual
28:25 - Studio tools for Unity you'll be able to
28:27 - find this page and you can can download
28:28 - it but if you follow everything then
28:29 - everything should be working correctly
28:31 - okay great okay so here we have the
28:33 - default Unity layout now first things
28:35 - first let's just familiarize ourselves
28:36 - with the various Unity Windows and
28:38 - create our custom layout you can see
28:40 - there's a lot of tabs everywhere like
28:41 - for example the scene tab the game Tab
28:42 - and so on you can click and drag and
28:44 - move these tabs anywhere you can make
28:46 - them into separate places or you can
28:47 - dock them into various kinds of places
28:49 - so you can basically set up the editor
28:50 - in any way you want but it won't be
28:52 - easier to follow this course if you're
28:53 - following the same layout as me so let's
28:54 - see the layout that I normally use first
28:56 - is over here the inspector on the right
28:58 - side this way we always have a nice view
28:59 - of the select object and whatever
29:01 - scripts it has then for the Hier key
29:03 - personally I prefer that instead of here
29:05 - I click and drag and I put it right here
29:06 - next to this one I like having the Hier
29:08 - key over here on this lower left corner
29:10 - we're going to make sure our scene is
29:11 - always organized so we don't need the
29:12 - Hier key to take up tons of space then
29:14 - with the project files next to it and
29:16 - with the console tab on the next tab
29:18 - next over here in the center here we
29:20 - have the scene View and right next to it
29:21 - the game view this way we can easily
29:23 - view all of our objects the console
29:25 - project everything is nicely accessible
29:26 - so this is the basic layout that
29:28 - normally use now for just a couple more
29:30 - options over here when the project files
29:32 - window is selected on these three dots
29:34 - on the top right corner on these
29:35 - personally I like to select the one
29:36 - column layout it showcases all the
29:38 - project files in a nice compact view
29:40 - then on the console next to it once
29:41 - again on the three dots over here we
29:43 - have some options for example over here
29:45 - on the log entry I like to set it to one
29:47 - this makes the console nice and compact
29:49 - which personally I prefer you can see a
29:50 - bunch more logs without taking up too
29:51 - much space then the time stamp are
29:53 - either enable or disabled doesn't really
29:55 - matter one very important thing are
29:56 - these three buttons over here these are
29:58 - the type of messages that are going to
29:59 - appear on the console so the left one
30:01 - this one is for regular messages we're
30:03 - going to use this quite a lot the second
30:04 - one is for warnings and finally for
30:06 - errors basically if you un toogle any of
30:08 - these then those types of messages will
30:10 - not show up over here on the console so
30:11 - if you ever come across an issue where
30:13 - nothing is showing up on the console
30:14 - make sure these three buttons are tick
30:16 - then over here on the left side for the
30:17 - clear we have some options so on this
30:18 - little arrow I like to set it to clear
30:20 - on play which means the console will be
30:21 - cleared every time we start playing our
30:23 - game then for the collapse this one
30:25 - basically collapses messages that are
30:26 - exactly the same into just one entry
30:28 - personally I do not like this I think
30:30 - this is very confusing I want to be able
30:32 - to see every single message as it comes
30:33 - out even if it's identical to a previous
30:35 - one I've also seen this lead to a lot of
30:36 - confusion for a lot of beginners they
30:38 - think their code is just firing one
30:39 - message when reality it's SE firing
30:41 - hundreds So to avoid any confusion leave
30:43 - collapse un toggled and then for the
30:45 - error pause this will automatically
30:46 - pause the game when some kind of error
30:47 - occurs so for this one you should
30:49 - definitely have this toggled if there is
30:50 - an error you want to know about it you
30:51 - want to know when it happens so you can
30:53 - actually fix it okay so that's it for
30:54 - the console and now on the game view up
30:56 - here and over here on the button that
30:57 - says free aspect let's select full HD
31:00 - 1920 x 1080 this is the standard 16x9
31:02 - aspect ratio then on that same button
31:04 - you can also enable vsnc this can be
31:06 - helpful because some of these demos are
31:08 - really simple so if you disable it they
31:09 - might run at like a th000 frames per
31:11 - second which is going to put a ton of
31:13 - unneeded stress on your graphics card so
31:14 - just leave it as vsync and then just one
31:16 - thing if you see your game view is
31:18 - looking a little bit too pixelated make
31:19 - sure on this here on this lad you are
31:22 - not fully zoomed in if I fully zoom in I
31:23 - can see this becomes a little bit
31:25 - pixelated this basically just increasing
31:26 - the size of this window so on this this
31:28 - one on the scale make sure it's pushed
31:29 - all the way to the left okay so that's
31:31 - the game view setup then for the scene
31:32 - view for this one pretty much all
31:34 - default should work just fine just one
31:36 - thing to know some demos are in 2D so
31:38 - for that up here on the top right corner
31:39 - there's a button to swap between 2D or
31:40 - 3D this just changes the scene camera
31:43 - and then one important thing is on the
31:44 - top left corner over here there's these
31:46 - two buttons this impacts where the
31:47 - handles are actually going to show up
31:49 - usually you want to keep them just like
31:50 - this meaning this one on pivot and this
31:52 - one on local if you ever see your
31:53 - handles on some weird places always come
31:55 - back to this you almost always want it
31:57 - to be on pivot and local okay so here we
31:59 - have our basic layout it will be easier
32:01 - to follow the course if you're using the
32:02 - exact same layout as me so ideally you
32:04 - should be using this but again all the
32:05 - windows are customizable so if there's
32:07 - something you absolutely prefer
32:08 - differently then go ahead you can drag
32:09 - your windows and place them anywhere
32:11 - once you have layout your happy with you
32:12 - can go on the top right corner and over
32:14 - here where it says default you can click
32:16 - on it and we can basically save a layout
32:18 - so you can go ahead save it to something
32:19 - and then if you ever find any issues you
32:21 - can reload a previous layout so here
32:23 - we're back into default and if I click
32:25 - it yep now back into this one okay so
32:27 - now that the layout is all set up let's
32:28 - go through the basics of the UN editor
32:30 - so first just some basic controls over
32:32 - here with the scene view selected this
32:33 - where we can move around and view the
32:35 - entire game world you can hold the right
32:37 - Mouse button in order to look around
32:38 - then if you're holding the right Mouse
32:40 - button you can press W and in order to
32:42 - move around if you press on shift it
32:43 - increase the speed while holding the
32:45 - mouse button if you use the scroll wheel
32:46 - you can either increase or decrease the
32:48 - speed alternatively you can stop holding
32:50 - the right Mouse button and just press
32:52 - the middle bouse button in order to pan
32:53 - around or hold alt and left click in
32:55 - order to rotate around any kind of
32:57 - object and if you have have some kind of
32:58 - object over here on the hierarchy if you
32:59 - get lost like for example you're moving
33:01 - way far away and you have no idea where
33:02 - the object is you can just select it and
33:04 - then press the F key and it's
33:06 - automatically going to focus that object
33:07 - then here on the hierarchy window this
33:09 - shows all the game objects that exist in
33:10 - this scene a game object is really just
33:12 - a name for an object in unity so each
33:14 - one of these each one is a separate game
33:16 - object to create a game object we can
33:18 - simply click on the plus icon and over
33:20 - here we got a bunch of presets like for
33:21 - example inside the 3D object let's
33:22 - create the 3D cube let's press F in
33:24 - order to zoom in onto it yep there you
33:26 - go there's the basic Cube where an
33:27 - object is selected we can see the
33:29 - various gizmos the various handels that
33:30 - we can move our object so over here by
33:32 - clicking and dragging on these arrows we
33:33 - can move our object in any way then on
33:35 - the left side we see the various tools
33:37 - so the first one is just for panning
33:39 - around the second one is the move tool
33:41 - so we can use it to move our object
33:42 - third one is for rotating in any way
33:44 - then we've got the scale tool we can
33:46 - scale in any direction then the rec tool
33:48 - this one is mostly used for 2D and UI
33:50 - stuff but yeah pretty much also does
33:52 - some scaling and then the multitool
33:54 - which contains pretty much everything
33:55 - and another similar one for editing the
33:57 - bound volume although this one only
33:59 - affects the Coller and not the actual
34:00 - visual mesh so you should probably not
34:02 - be using this one okay so with the game
34:03 - object selected over here on the
34:04 - inspector we can see a bunch of stats
34:06 - for this game object Unity is really
34:08 - based on components so here we can see
34:10 - all the various components attached to
34:11 - this game object each component does all
34:13 - kinds of things for example this Cube
34:15 - game object first of all this one has a
34:16 - transform component all game objects are
34:18 - going to have this component this is
34:19 - basically what gives it a position
34:21 - rotation and scale then specifically for
34:22 - this game object this one as we can see
34:24 - it has a cube visual so that visual is
34:26 - composed of the cube mesh fil component
34:28 - this is what holds the actual mesh that
34:29 - is being rendered and the mesh render
34:31 - component this is what actually renders
34:32 - that mesh and finally by default this
34:34 - one also has a box and letter which is
34:35 - used in physics so in general the main
34:37 - thing to remember is that Unity is made
34:38 - up of scenes then each scene is made up
34:40 - of game objects and each game object is
34:42 - made up of components let's see an
34:44 - example from the interactive exercis
34:46 - they're all split into different scenes
34:47 - they're organized by folders so for
34:49 - example let's go inside the lecture
34:50 - teaching all about if conditions and
34:52 - let's open up this one for the distance
34:54 - the way we open the scene is just with
34:55 - double click and we can see this is a
34:57 - scene because that has a nice Unity logo
34:58 - so let's go in this case I don't want to
35:00 - save the sample scene and Y here's the
35:02 - scene and like I said most of the demos
35:03 - these are actually in 2D so we can click
35:05 - the 2D button in order to visualize it
35:07 - in 2D in order to play the game you
35:08 - simply click on the play button right up
35:10 - here on the middle and you up here the
35:11 - game view now is playing on whatever
35:13 - logic is in this particular scene this
35:15 - one is on the lecture talking about ifs
35:16 - and if I click to move and showcase how
35:18 - doing a simple if in order to test a
35:20 - distance so in this case for example
35:21 - let's inspect the player components so
35:23 - select the player game object on the
35:24 - Hier key and over here on the inspector
35:26 - we can see it as the player script so we
35:27 - can double click in order to open it and
35:29 - yep it opens up visual studio and opens
35:31 - up to the player script so here we can
35:32 - see a bunch of code again don't worry
35:34 - too much about what exactly this is
35:35 - saying what exactly this is doing this
35:37 - course W teach you everything about C so
35:39 - everything that we're seeing here we're
35:40 - going to learn about through the
35:41 - entirety of this course right now the
35:43 - only thing that I want you to learn with
35:44 - regards to Unity and C is that Unity
35:46 - scripts have some default functions
35:47 - they've got an awake function and an
35:49 - update function again I want to cover
35:50 - what exactly are functions in detail in
35:52 - a little bit so just know that the awake
35:54 - or also the start function those only
35:55 - run once whereas the update is going to
35:57 - run on every frame so if our Unity
35:58 - window is running on 60 frames per
36:00 - second then this code will execute 60
36:02 - times per second then for some Unity
36:03 - specific things in order for script to
36:05 - be attach as a component it needs to
36:07 - extend this mono Behavior class in the
36:08 - unity scripts many times we are going to
36:10 - access the transform component so this
36:12 - refers to the transform component
36:13 - attached to whatever game object this
36:15 - script is attached to and finally
36:16 - debug.log this just a way that we can
36:18 - write any messages to the console so
36:20 - pretty much the same thing as the conso
36:21 - right line that we're going to see in a
36:23 - little bit okay so that's the absolute
36:24 - basics of unity like I said you can use
36:26 - C without Unity among using it to make
36:28 - the interactive exercises and to make
36:30 - the lectures a bit more visual which
36:31 - should help you learn better also by the
36:33 - way after you watch this whole course if
36:34 - you want to learn how to make games in
36:36 - unity then check out my entire course on
36:37 - making the game kitchen chaos it's a
36:39 - beginner course starting from the
36:40 - absolute basis of unity and game
36:42 - development and it takes you step by
36:43 - step until we have a nice complete fun
36:45 - game if you fully understand everything
36:46 - in this course you w be able to easily
36:48 - understand everything in that one okay
36:50 - so in this lecture we installed unity
36:51 - and learned the basics now we are ready
36:52 - to learn how the interactive exercises
36:54 - work which we're going to see in the
36:55 - next lecture hello and welcome I'm your
36:58 - KMI in this lecture we're going to learn
37:00 - how the companion project works okay so
37:03 - the companion project is something that
37:04 - I work really hard on to help you truly
37:06 - learn the contents in this course if you
37:08 - do what I say if you make an effort to
37:10 - go through everything all the content
37:12 - inside of this companion project if you
37:13 - do that then by the end you will have
37:15 - definitely Master C if you're following
37:17 - along you already downloaded in sound
37:19 - the project if not go ahead and download
37:20 - it from the link under this lecture so
37:22 - the companion project contains a ton of
37:24 - stuff first of all everything is over
37:26 - here on the project files all separated
37:28 - by lectures so all the demos that I
37:30 - Showcase in the videos you can come here
37:31 - and inspect them in order to see all the
37:33 - code that makes up those demos but also
37:35 - the main way to interact with this
37:37 - project is through a bunch of custom
37:39 - editor Windows the main one is the main
37:41 - window so it should be open already if
37:43 - you import the project if not you can go
37:45 - up here onto the Code Monkey menu and
37:47 - let's open up the main window and yep it
37:49 - is this window now the first thing this
37:51 - window actually has is an update Checker
37:52 - that runs automatically as I add more
37:54 - exercise or quiz or questions to the
37:56 - project as I do that I will update the
37:58 - project so when that happens you will
38:00 - see a nice popup where you can click
38:01 - which will take you to this very lecture
38:03 - where you can always find the latest
38:04 - project version then over here you've
38:06 - got some nice stats so basically it
38:07 - tracks your completion as you go through
38:09 - all the content in the course it will
38:11 - keep track of all of it the goal is for
38:13 - you to get to 100% completion by the end
38:15 - then we have a button that takes us to
38:17 - the lecture list so over here you can
38:19 - select what lecture you're on like for
38:21 - example let's say we are inspecting the
38:22 - variables lecture and now we can browse
38:24 - the three parts for each lecture there
38:26 - are frequently Asked question questions
38:27 - quizzes and exercises each of these has
38:30 - a separate Unity window by clicking on
38:32 - it it should open that window so for
38:34 - example here is the one for frequently
38:35 - asked questions this one shows some
38:37 - common questions and if you click
38:39 - through it you get a very detailed
38:40 - answer so these provide even more
38:42 - clarification on the topic covered in
38:44 - the lecture next we have the quizzes so
38:47 - these are multiple choice questions you
38:49 - get a question and various options again
38:51 - these are related to the contents of
38:52 - that specific lecture so if you fully
38:54 - understood everything you should be able
38:55 - to get all of these questions correctly
38:57 - but whether you get them right or wrong
38:59 - either way you get an answer with nice
39:01 - explanation with some extra
39:02 - clarification and then the exercise
39:04 - window these are exercises that rather
39:06 - than just answering questions you have
39:08 - to actually write code for example
39:10 - here's a basic one from the variables
39:12 - lecture it asks you to define a certain
39:14 - speed variable so here on the text you
39:16 - need to edit some script declare a
39:18 - variable of type int with the name speed
39:20 - and assign the value five to it right
39:22 - away we can click on start exercise this
39:24 - is basically going to load up all the
39:26 - files for that exercise now this one is
39:28 - pretty simple we just need to follow the
39:29 - instructions so in this case we just
39:31 - need to define a speed variable so we
39:33 - can open up the exercise. Cs file it
39:36 - should open up automatically and over
39:37 - here we see some more instructions in
39:39 - the comments so now here all we have to
39:41 - do is just complete whatever the
39:42 - exercise is and if you get stuck in any
39:45 - exercise all of them they all have hints
39:47 - which should help point you in the right
39:48 - direction then if you get really really
39:50 - stuck you can also just view the
39:52 - solution so this will tell you exactly
39:54 - what you need to do in order to manually
39:55 - complete the exercise or alternative
39:57 - there's a button to apply a solution
39:59 - this one is basally going to overwrite
40:01 - the exercise files with the correct
40:02 - solution then once you complete the
40:04 - exercise you can see a nice completion
40:06 - message and something very important is
40:08 - the button here for the video walk
40:09 - through this one is exactly what it says
40:11 - it's basically me going through the
40:13 - exercise explaining how to complete it
40:14 - and what exactly the exercise is
40:16 - teaching then when you're done you can
40:17 - click the button to complete the
40:19 - exercise this will basically clean up
40:21 - all the exercise file so you can go back
40:22 - and go on to the next one also some
40:24 - exercise have a Unity scene like this
40:26 - one so so you need to complete the
40:28 - exercise you need to write the code and
40:30 - then you need to hit play over here
40:31 - inside of unity in order to test your
40:32 - code and see if you have actually
40:34 - successfully completed the exercise if
40:36 - so then again same thing just stop
40:38 - playing complete the exercise and go on
40:40 - to the next one also related to the
40:41 - exercise window is a separate companion
40:43 - window which you should also open it
40:45 - should be opened by default in this
40:46 - corner if not again go into code monkey
40:49 - and open up the companion window so you
40:51 - have this is a really nice companion
40:52 - window that listens to a bunch of
40:53 - compiler errors and gives you some
40:55 - guidance this one is separate from the
40:57 - exercises so this is constantly reading
40:59 - for errors whether there's an exercise
41:01 - active or not so this can be helpful
41:03 - even if you're trying to write some
41:04 - regular code if you're trying to test
41:06 - out how something in some lecture
41:07 - actually works this provides a bunch of
41:09 - useful guidance for tons and tons of
41:11 - compiler errors so you should keep this
41:14 - window open and visible at all times
41:15 - I've said many times that the way that
41:17 - you truly learn is by writing code not
41:19 - just by blindly watching the videos you
41:21 - need to actually do something you need
41:23 - to apply your knowledge in order to
41:24 - truly learn so I'm really happy with
41:26 - this companion project that I built
41:28 - especially these exercises they really
41:30 - encourage you to write code related to
41:32 - the concept of each lecture and in doing
41:34 - so you will actually sidify the
41:35 - knowledge you gained there are many
41:37 - exercises for every lecture this is
41:39 - something that took a ton of work to
41:41 - make so I really hope you make the
41:42 - effort to go through everything in this
41:43 - companion project to help you truly
41:45 - understand all the contents inside of
41:47 - this course so as you're going through
41:48 - the course first watch and listen to the
41:50 - entire video lecture make sure you're
41:52 - paying attention and real learning pause
41:54 - the video and Rewind if you need to then
41:56 - after watching that lecture go on to the
41:58 - companion to project then over here load
42:00 - up the lecture list and go on to
42:02 - whatever lecture you're currently on
42:04 - then read all of the frequently asked
42:05 - questions and the detailed answers then
42:07 - go through all the quizzes and try to
42:09 - answer them all correctly and then go
42:11 - through all the exercises and really put
42:12 - into practice what you learned in that
42:13 - lecture you can see there's a bunch of
42:15 - content already for all the lectures up
42:17 - until this point so take this time right
42:19 - now to pause the video and go through
42:21 - all of this to ensure you are fully
42:22 - understanding everything up until this
42:23 - point by the end of this course you
42:25 - should have all of your totals set up
42:27 - 100% completion if you do that then you
42:29 - will truly have learned C which will
42:31 - then allow you to build anything you can
42:33 - imagine all right so we're almost ready
42:35 - to start learning C but before we do
42:37 - let's go through a bunch of really
42:38 - common errors in the next
42:40 - lecture hello and welcome I'm your kmy
42:43 - in this lecture we're going to learn
42:44 - about a bunch of common errors that you
42:46 - might encounter so here's a list of the
42:48 - many common errors that we're going to
42:49 - cover in this lecture this lecture is
42:51 - really mainly meant to act as a sort of
42:53 - reference whenever you have an error
42:55 - come back to this one to get some
42:56 - guidance on what exactly it means and
42:58 - how you can fix it I add this lecture
43:00 - right here on the beginning of the
43:01 - course before we get into writing any
43:02 - code just so you are aware of these
43:04 - various errors but if you are a complete
43:06 - beginner then don't worry about fully
43:08 - understanding everything in this lecture
43:09 - right now for most lectures I highly
43:11 - encourage you to stick with it and
43:12 - rewatch a lecture if you don't fully
43:14 - understand the contents but for this one
43:16 - this one is special this one is really
43:17 - intended as a reference if you are a
43:19 - complete beginner then watch this
43:21 - lecture just so you are aware of the
43:22 - various possible errors that you might
43:24 - encounter but don't worry too much about
43:26 - understanding all the the individual
43:27 - details in the code that we're going to
43:28 - see everything mentioned here variables
43:30 - classes type scope and so on these are
43:33 - all things that I will cover in detail
43:34 - in future lectures so just remember that
43:36 - this lecture exists and refer back to it
43:38 - if you encounter any of these errors
43:40 - starting with the most common errors of
43:42 - all some variation of these three
43:44 - usually these mean some kind of symbol
43:45 - is missing or it's in the wrong place
43:47 - one of the most crucial things about any
43:49 - kind of programming is how code has to
43:51 - be written absolutely exact if you miss
43:53 - just one symbol then everything breaks
43:55 - this is really something that a lot of
43:57 - complete beginners have a lot of trouble
43:58 - with for example here this code has an
44:00 - error and thankfully this one is
44:02 - actually a very helpful error it is
44:04 - correctly telling us that a parenthesis
44:06 - is expected here we have an opening but
44:08 - we have no close you always need to
44:10 - match the same number of opening and
44:12 - closing parentheses so the solution here
44:13 - is pretty simple just close it yep then
44:16 - here is another similar error this one
44:18 - is saying there's an ending currently
44:19 - braces expected and again same thing
44:22 - different numbers so we've got one two
44:24 - three openings but only one two closings
44:26 - so we're missing one here and here is
44:29 - another really common error this one is
44:31 - because we have a missing semicolon the
44:33 - semicolon is what actually defines the
44:35 - end of an instruction without it the
44:37 - compiler doesn't know that this
44:38 - instruction has ended in C SHP new lines
44:40 - don't really matter so I can paste
44:42 - another line down here and hope these
44:44 - are still errors having one line of code
44:46 - on each line does not matter what
44:48 - matters is the semicolon so always need
44:50 - to add it to this one and to this one
44:53 - then on these same mistakes if you make
44:54 - something slightly different so if
44:56 - instead of the ending one you get rid of
44:57 - the first one now there's a whole ton of
44:59 - errors in this case they're not quite as
45:02 - helpful so that is why you always got to
45:04 - keep in mind you have to write the code
45:05 - perfectly and here we have tons of
45:08 - Errors so this is quite messy the one
45:10 - that truly matters over here is this one
45:12 - it's at the main function must declare a
45:14 - body so the missing here is once again
45:16 - has to do with the currently braces
45:17 - we've got three closing but only two
45:19 - opening so we're missing an opening on
45:20 - this one and again same thing if for
45:22 - example we forget to add this one then
45:25 - again tons of Errors so again this this
45:27 - one is really tricky to figure out what
45:28 - is going on the issue here is our
45:30 - missing opening parentheses so these are
45:32 - really the most common syntax errors if
45:34 - you see any of these pay very very close
45:36 - attention to how your code is written
45:38 - remember it has to be written perfectly
45:40 - so don't write some messy text write it
45:42 - properly with all the required
45:44 - parentheses all the currently braces and
45:46 - semicolons next really important common
45:48 - error is simply this one the type for
45:50 - namespace could not be found so here I
45:52 - am trying to Define a variable but as we
45:55 - can see we have this are in the code
45:57 - this is yet another way as to how code
45:59 - must be written perfectly it is not just
46:01 - the words that matter code is case
46:03 - sensitive this is something that I see a
46:05 - lot of beginners having trouble with
46:07 - they think for example this and this
46:10 - they think these two are the exact same
46:11 - thing but they are not in terms of
46:13 - English sure they sound the same they
46:14 - look similar but in terms of the code
46:16 - these are two completely separate things
46:18 - the code really doesn't understand
46:19 - meaning doesn't understand English it
46:21 - really just understands syntax so always
46:23 - always remember how code is case
46:25 - sensitive changing something from
46:26 - uppercase and lower case just doing that
46:28 - one tiny change all of that suddenly
46:30 - refers to something completely separate
46:32 - again this is something that I see a lot
46:33 - of beginners struggling with so this is
46:34 - something I will repeat quite a lot
46:36 - throughout the beginner section of this
46:37 - course if you have some error like this
46:39 - one the type or Nam space could not be
46:41 - found first thing you should do is
46:43 - always double check the capitalization
46:44 - double check that you wrote actually
46:46 - perfect so in this case it is lowercase
46:48 - int and yep that works also since we're
46:50 - here one thing that is not an error but
46:52 - rather a warning sometimes you might see
46:54 - these green squigle lenses these are
46:56 - warnings or suggestions for how you can
46:57 - improve your code in this case just says
46:59 - the variable is assigned but it's never
47:01 - used again that's because just just some
47:02 - testing code in general just know
47:04 - warnings are not errors so for example I
47:06 - can compile this code and works
47:08 - perfectly the warning is simply a
47:10 - message that tells you that you're
47:11 - probably doing something that you
47:12 - probably don't mean to now here's a
47:14 - similar error it says the name age does
47:16 - not exist in this context and again same
47:18 - thing capitalization problem age on
47:20 - lower case and age with upper case on
47:22 - the a these are two completely different
47:24 - symbols same thing over here which is
47:26 - saying tap namespace player cannot be
47:28 - found and again some beginners might see
47:30 - but it is the finest right here except
47:31 - no it isn't once again same problem over
47:34 - here player is on lowercase and that one
47:36 - is capitalized so over here it needs to
47:38 - be written exactly perfectly and yep now
47:40 - it works and up here also perfectly and
47:42 - yep now it works so as a beginner the
47:44 - first question you should always ask
47:45 - yourself is did I write the code
47:46 - correctly and specifically in terms of
47:48 - case sensitivity is everything written
47:50 - perfectly exactly as it should be or not
47:52 - that should be your very first question
47:53 - another common error is this one it says
47:55 - use of unassigned local variable this
47:57 - one is pretty self-explanatory basically
47:59 - you need to initialize a variable in
48:01 - order to use it so in this case we
48:02 - really just need to give it some value
48:04 - and Y the error is gone related to
48:06 - variables and data types a common error
48:08 - is some variation of this one cannot
48:10 - implicitly convert one type into another
48:12 - one like it says this has to do with
48:13 - trying to convert one type into another
48:15 - for which there is no implicit
48:16 - conversion this is a common problem over
48:18 - here defining something as a float and
48:20 - then assigning that float onto something
48:22 - that sores an INT inss can really only
48:23 - sore whole numbers so that is why this
48:25 - does not work floats or decimal points
48:27 - but ins cannot if you absolutely need to
48:30 - do this then one thing you can do is
48:31 - simply cast the value so over here put
48:33 - int so you cast like that there's no
48:35 - error anymore however if you do it then
48:37 - this will lose some data for example if
48:39 - over here for number I store 5.6 if I do
48:42 - this and then I C it the value stored
48:44 - over here in h this one is going to be
48:45 - just five if you force the conversion
48:47 - then basically anything after the
48:49 - decimal is going to be ignored or the
48:51 - same error can be due to the data type
48:53 - that you're trying to store the data
48:55 - type this one represents a 6 4bit int
48:57 - whereas the int this one is only 32bit
48:59 - int meaning that along can store
49:01 - everything inside an INT and more you
49:03 - can define an INT and then assign that
49:05 - int onto a long this does work there's
49:07 - no error on this line however there is
49:09 - an error on this line that is because an
49:10 - INT cannot hold all the values of a long
49:12 - so you cannot implicitly convert a long
49:14 - onto an end again if you really really
49:16 - want to do it you can simply cast it
49:18 - onto an end or alternatively trying to
49:20 - do this again same thing cannot convert
49:22 - a string onto an INT if you want to
49:23 - basically parse a string then you can do
49:25 - it like this so X is the convert class
49:27 - and convert it onto an n32 related to
49:29 - data types is doing some math so a
49:31 - common error is doing something like
49:32 - this so basically you got 1 divid by 10
49:35 - and you expect the result to be 0.1 but
49:37 - nope the result is actually zero that is
49:39 - because when doing math between two inss
49:41 - the result is going to be an INT and in
49:43 - an INT we cannot sort the number 0.1 so
49:46 - again it ignores everything after the
49:48 - decimal point and returns just zero the
49:50 - solution here is to cast one of the
49:52 - numbers included in the calculation onto
49:53 - a float and if another result is correct
49:56 - always keep in mind mind what data type
49:57 - you're using and make sure you're
49:58 - assigning the right data for the right
50:00 - type then another common mistake is when
50:02 - doing some conditions you might write an
50:04 - N like this so one condition and another
50:06 - one but this is not correct with just
50:08 - one % this is actually a completely
50:10 - different operation this is a bitwise
50:12 - and and not a logical and so once again
50:14 - goes back to how you have to write the
50:15 - code perfectly for a logical and you
50:17 - need two erss or for a logical or it's
50:20 - also not just one pipe it's actually two
50:22 - also for equating values it is two
50:24 - equals if you use just one equals that
50:26 - actually is the assignment operator so
50:28 - that is something completely different
50:30 - if you want equality you need two equals
50:32 - then after we learn about functions a
50:34 - common is going to be this one the name
50:36 - age does not exist in the current
50:37 - context now in this case the
50:39 - capitalization is correct these are both
50:41 - written perfectly exactly the problem
50:43 - here is that this one up here this one
50:44 - is a local variable and by being local
50:46 - it means that this variable only exists
50:48 - over here inside the main function and
50:50 - down here inside this other function
50:52 - down here does not exist at all this is
50:54 - a problem to do with variable scope and
50:56 - later on there is a detailed lecture on
50:57 - that specific topic also after we learn
50:59 - about functions and parameters one
51:01 - common error is this kind of error this
51:02 - is not a compile error it's just some
51:04 - Behavior difference here a beginner
51:06 - might think that if you define this then
51:07 - you add this and this one in turn is
51:09 - going to add two you might think that
51:11 - over here is going to add two onto that
51:12 - number but the answer is no when we run
51:14 - this line this one still says 35 so the
51:17 - value inside the age variable that one
51:18 - is still 35 this has to do with
51:20 - difference between working with
51:22 - something as a copy versus a reference
51:24 - there's a dedicated lecture on the topic
51:26 - of value types versus reference types in
51:28 - the intermediate section int is a value
51:30 - type which means that it is passed in as
51:32 - a copy so when we call this function
51:34 - what this one receives is a copy of the
51:36 - original data meaning it's just a copy
51:38 - it has absolutely no connection to the
51:40 - original variable so when we modify this
51:42 - one we're just modifying the copy and
51:43 - not the original value that is why over
51:45 - here when we call this the original
51:46 - value still stays exactly the same so
51:48 - always remember whether you're working
51:50 - with a copy or the original data then
51:52 - when we start using classes this is a
51:54 - common error it says an object
51:56 - references required for the non-static
51:58 - field method or property to be called in
52:00 - the class lecture and in the static
52:02 - lecture I talk a lot about the
52:03 - difference between the class definition
52:05 - and an instance of that class and that
52:07 - is exactly the problem here this
52:08 - function over here this one is not
52:09 - marked as static but we are trying to
52:11 - access it through the class name itself
52:13 - as if it were static like the a says we
52:15 - need an object reference meaning we need
52:17 - to create an object of this type in
52:19 - order to create an instance of that
52:21 - class so we can define a player equals a
52:23 - new player and now using this object
52:25 - this instance of that class now we can
52:27 - call it and yep everything works or
52:29 - alternatively we can keep the same thing
52:31 - we had previously and simply mark this
52:33 - one as static so always be very very
52:35 - careful are you intentionally trying to
52:36 - access something through the class
52:37 - itself or through some instance of that
52:39 - class another common error that we're
52:41 - going to run into once we start learning
52:43 - about classes is this one it says
52:45 - something is inaccessible due to its
52:46 - protection level this has to do with the
52:48 - access modifiers there's also a d
52:50 - lecture on this Topic near the end of
52:52 - the beginner section by default if you
52:54 - omit the access modifier then it's going
52:56 - to default to making it private and
52:57 - private means that only this class over
52:59 - here only this one can access this
53:01 - function so if you want to access it
53:02 - from elsewhere like for example from
53:04 - this function up here if so then we need
53:06 - to mark this as public and yep now it
53:07 - does work then when writing some more
53:09 - intermediate code you might encounter
53:11 - something that does something like this
53:12 - like require some encoding in order to
53:14 - save some bytes onto some text but if
53:16 - you just try using the encoding type if
53:18 - you do then it says like this once again
53:20 - the same thing the typew word namespace
53:21 - could not be found now this one is not a
53:23 - capitalization problem the class is
53:25 - indeed called encoding however this one
53:27 - exists inside the system. text namespace
53:29 - so before we can actually use it we need
53:30 - to be using that namespace so on top of
53:32 - f we need to add using system. text in
53:36 - this case and yep the errors go away and
53:38 - this now works alternatively you can
53:40 - place a mouse over the error then click
53:42 - on this little light bulb icon and this
53:44 - tells you a bunch of things like for
53:45 - example it needs using text and if there
53:47 - you go it does and it works all right so
53:49 - those are a bunch of common errors again
53:51 - like I said if you're a complete
53:53 - beginner and you didn't understand
53:54 - anything in this lecture that's
53:55 - perfectly fine all these Concepts
53:57 - variables functions classes and so on
53:59 - all this will be explained in detail in
54:01 - future lectures just keep in mind that
54:02 - this lecture exists if you ever get suck
54:04 - chances are you're going to encounter
54:06 - one of these errors if so come back here
54:08 - for an explanation on what might be
54:09 - going wrong and how you might fix it so
54:11 - remember this lecture and use it as a
54:13 - reference throughout the entire course
54:15 - now that we've covered this we are ready
54:16 - to begin learning the absolute basis of
54:18 - programming so let's learn that in the
54:19 - next lecture hello and welcome I'm your
54:22 - Cod monkey in this lecture we're going
54:24 - to learn the absolute basics of
54:25 - programming so how the computer executes
54:27 - code how code is Cas sensitive matching
54:30 - parentheses and a bunch more okay so in
54:31 - the getting stting lecture we built this
54:33 - default consol app project here we have
54:35 - a bunch of code again I will explain all
54:37 - this in detail in a little bit this one
54:39 - over here is a comment and here we've
54:40 - got something running a function order
54:42 - to print some text onto the console we
54:44 - can run this code so again we can go up
54:45 - here press F5 and yep it runs the
54:48 - console and right away it does say our
54:49 - message now the first thing to learn is
54:51 - how the code actually runs and that is
54:53 - how the code runs from top to bottom
54:54 - meaning if we have four instruction it
54:56 - is going to first run this line of code
54:58 - then it's going to run this line of code
55:00 - then this one and finally this one it is
55:01 - always going to execute one after the
55:03 - other always from top to bottom now
55:05 - later on when we'll learn more about
55:06 - functions we will see how the code
55:07 - execution jumps a little bit but in the
55:09 - end it's really all just sequentially
55:10 - running from one to the other from top
55:12 - to bottom so up here if I copy this line
55:15 - and I run this function twice and on the
55:16 - second time I say something else again
55:18 - code runs from top to bottom so it just
55:20 - going to first execute this one and
55:21 - print this line onto the console and
55:23 - then it's going to execute this one you
55:24 - know that it is exactly like that also
55:26 - one very important thing is in C the end
55:28 - of an instruction is denoted by a
55:30 - semicolon if we do not have it if I
55:33 - erase this then the code basically
55:35 - assumes that the instruction is not over
55:37 - another thing is how new lines don't
55:38 - really matter to the compiler so I can
55:39 - add a bunch of new lines and then the
55:41 - semicolon and now this is perfectly
55:42 - valid code all same thing when accessing
55:44 - a function so over here I can add a ton
55:46 - of new lines right after the dot I can
55:48 - add a ton of new lines now you can't add
55:50 - it in the middle of something like in
55:51 - the middle of this function name if I
55:52 - split it then it does cause an error but
55:54 - otherwise new lines generally do not
55:55 - matter in terms of running the code all
55:57 - that really matters is the semicolon
55:59 - that is what actually defines the end of
56:01 - an instruction a lot of beginners make
56:02 - the mistake of forgetting about that
56:04 - they usually forget about the semicolon
56:05 - and they get a whole bunch of Errors
56:07 - which by the way if you see a red
56:08 - squiggly line and you just put the mouse
56:10 - over it it won't tell you the error in
56:11 - this case the error is simple and our
56:13 - helper function actually helps us see
56:15 - what the error is so in here there's
56:17 - just an expect semicolon if we add it
56:18 - everything's fine so you find any
56:20 - strange issues always make sure to
56:21 - remember that you need a semicolon in
56:23 - order to end an instruction and also
56:24 - speaking of things that don't matter so
56:26 - new lines generally don't matter and
56:28 - another thing that does not matter is
56:29 - identation so right now I can ident this
56:31 - line just like this and it's going to
56:32 - run and I can have another one ented a
56:35 - bunch more so I can have code written
56:36 - like this and if I run it y everything
56:38 - still runs exactly the same if you've
56:40 - done some Python Programming then in
56:41 - that language initation does matter but
56:43 - over here in C it does not this is
56:45 - perfectly valid code although of course
56:46 - bad initation like this one can make the
56:48 - code hard to read so even though
56:49 - technically it does not matter for the
56:50 - compiler it definitely matters to you in
56:52 - order to make the code easy to read so
56:54 - always make sure you ident your code
56:55 - properly another extremely extremely
56:57 - important thing is how code is case
56:59 - sensitive meaning for example over here
57:01 - we've got an instruction a console.
57:02 - right line if I said right right line
57:05 - within lowercase L nope there is an
57:07 - error there is no such thing called
57:09 - right line within lowercase L there only
57:11 - exists one with an upper CASL so you
57:12 - need to always pay very very close
57:14 - attention to how you write your code
57:16 - this is one of the main things that I
57:17 - see a lot of beginners make their
57:19 - mistake they write code like this and
57:20 - they don't know why it's not working
57:22 - they assume that as long as the words
57:23 - are correct so for example if I write it
57:25 - like this they assume since this is
57:27 - technically the same thing as over here
57:29 - in terms of English they both say the
57:30 - same thing they assume that because that
57:32 - it should work but in reality no this
57:33 - does not work and the answer is always
57:35 - because they did not write the code
57:36 - exactly as it needs to be it needs to be
57:38 - 100% exact including capitalization so
57:41 - it cannot be in lowercase C it has to be
57:43 - an uppercase C only that actually
57:44 - matches the console and right line
57:46 - cannot be written like this the W needs
57:48 - to be uppercase and the L also needs to
57:50 - be uppercase so if you have issues in
57:51 - your code the first thing you should
57:53 - check is see if you are writing the
57:54 - capitalization correctly it is is not
57:56 - just the words that matter it's
57:58 - everything it's the capitalization it's
57:59 - the place where you put the dot the
58:01 - place where you open and close
58:02 - parentheses the semicolon all of that
58:04 - all of that matters so always make sure
58:06 - you write your code very carefully
58:07 - because every single detail matters and
58:09 - of course you can always rely on code
58:10 - autoc completion to help you write
58:12 - usually after writing a DOT you see the
58:13 - auto completion and if you start writing
58:15 - right line over here it shows you
58:17 - exactly as it should be you can just
58:18 - press enter and everything won't be
58:19 - written properly now the next important
58:21 - thing is knowing where to write the code
58:23 - now over here in the new template over
58:25 - here it's easy you can just just write
58:26 - code and all of this will execute
58:27 - without problems but now here on the
58:29 - previous Center template on this one
58:31 - note there's a bunch of currently braces
58:33 - these currently braces form what is
58:35 - known as a code block code is group
58:37 - between blocks for example everything
58:38 - inside of this code block everything
58:40 - here belongs to this namespace then
58:42 - everything inside this code block
58:43 - belongs to this class and everything
58:45 - inside this code block belongs to this
58:46 - function again don't worry what is a
58:48 - namespace class or function right now I
58:50 - will cover all of those in detail later
58:51 - on for now all I want you to learn is
58:53 - what is a code block which is everything
58:55 - inside a currently bracet and that
58:56 - impacts what kind of code you can write
58:58 - within each code blog so for example in
59:00 - this whole template in this one here we
59:01 - need to write the code inside the main
59:03 - function this is where the program
59:04 - actually starts executing like I said
59:06 - the code executes from top to bottom and
59:08 - as soon as we run this program it is
59:09 - going to start right here from inside
59:11 - the main function it starts running from
59:13 - this first line if we run just like this
59:15 - if there go it still works say exactly
59:16 - the same thing however if I take this
59:18 - code and I remove it from the function
59:20 - and let's say I paste it just over here
59:21 - so just inside the class code block if I
59:24 - do then obviously I get a whole bunch of
59:25 - error this because we are writing code
59:27 - inside a class block and inside a class
59:29 - block you cannot execute a normal
59:31 - instruction you can only Define Fields
59:33 - functions and so on now in this case the
59:34 - error isn't very helpful so really just
59:36 - remember where you are writing your code
59:38 - if you're writing a regular instruction
59:40 - that you want to execute then chances
59:41 - are you want to write it inside a
59:42 - function in this case chances are you
59:44 - want to write it inside the main
59:45 - function so always keep this in mind
59:47 - like I said it's very important how you
59:49 - actually write your code but it's also
59:50 - extremely important where you write it
59:52 - if you're writing code inside of this
59:53 - own template then make sure to not write
59:55 - the code out here here or directly
59:57 - inside namespace or directly inside the
59:58 - class if you're writing some kind of
60:00 - regular instruction make sure you write
60:01 - inside main although in the beginning
60:03 - portion of this course we're really just
60:04 - going to be writing our code in the
60:05 - simpler newer template just to avoid any
60:07 - confusion over here we have no currently
60:09 - braces so there's no issues like that we
60:11 - can just write all of our instructions
60:12 - over here sequentially and everything
60:14 - will execute once again top to bottom
60:16 - and finally very important is to always
60:17 - make sure you have matching opening and
60:19 - closing symbols that refers to for
60:21 - example code blocks every opening
60:23 - currently brace needs to have an ending
60:24 - one and same thing over here here for
60:26 - parenthesis every time there's one
60:27 - beginning there has to be a matching any
60:29 - one if I go ahead and I erase one of
60:31 - these like for example over here opening
60:33 - namespace we've got one then inside the
60:34 - class we've got two and inside the main
60:36 - we've got three and over here we have
60:37 - three closing ones but if I get rid of
60:39 - one of these if there you go now we have
60:41 - an error and this one is a nice up error
60:43 - so it tells us that one more is expected
60:45 - so always double check that you have the
60:47 - exact same number of both opening and
60:48 - closing braces and parentheses over here
60:50 - same thing if I raise one of these
60:52 - parentheses y that's also an error
60:53 - because we did not finish the
60:55 - parentheses that are calling the
60:56 - function so always make sure the same
60:58 - number of matching opening and closing
61:00 - if you put the cursor inside of it it
61:02 - should highlight the opening and the
61:03 - closing braces so if I put the cursor
61:05 - here it highlights both those if I put
61:06 - it here it highlights both those and so
61:08 - on and in general whenever you make some
61:09 - sort of error like let's say you forgot
61:11 - to write that you forgot to terminate
61:13 - the instruction you see the red
61:14 - squidling line so always remember you
61:16 - can place your mouse over it and gives
61:17 - you a bit more information sometimes the
61:19 - eror is super helpful like this one but
61:21 - sometimes might be a little bit more
61:22 - confusing so also remember you can refer
61:24 - back to the common errors lection sure
61:26 - to see some common issues or of course
61:27 - remember you can always post questions
61:29 - in the comments and I'll do my best to
61:30 - help okay so here we'll learn how code
61:32 - executes from top to bottom we'll
61:33 - learned how it's extremely important
61:35 - that code is case sensitive and you
61:36 - should always double check that you
61:38 - wrote the code exactly as it should be
61:39 - and we learned what is a code block and
61:41 - where we should write code as well as
61:42 - importance on making sure we always have
61:44 - a matching number of opening and closing
61:46 - symbols now with this basic knowledge we
61:47 - are now ready to learn one of the basic
61:49 - building blocks of programming which are
61:51 - variables so let's learn that in the
61:52 - next
61:54 - lecture
61:56 - hello and welcome I'm your KMI in this
61:59 - lecture we're going to learn all about
62:00 - variables what they are and what we can
62:02 - do with them okay so variables are one
62:04 - of the most important parts about
62:05 - programming in literally any language
62:07 - they are basically containers for data
62:09 - so we can define a variable which is
62:10 - going to be our container and then we
62:12 - can take some data and put it inside
62:14 - that container now variables also have
62:16 - data types which means different
62:17 - containers can hold different things so
62:19 - if a variable is meant to store a whole
62:21 - number I cannot place a text string
62:22 - inside of it there are some containers
62:24 - that can only hold numbers some
62:25 - containers Can Only Hold text others can
62:27 - hold true or false and a bunch more
62:29 - those are the data types which we're
62:30 - going to cover in detail in the next
62:32 - lecture and then we can also have some
62:33 - code I use a variable and basically when
62:35 - the code is executing that line of code
62:37 - in there when it reaches this point it
62:38 - is going to access this variable and
62:40 - grab the value from that variable so
62:41 - basically goes inside that container in
62:43 - order to grab the value that is stored
62:44 - so on the same line of code if we modify
62:46 - the value that is actually stored inside
62:48 - the variable basically we modify the
62:49 - behavior of our code so by writing code
62:51 - that uses variables instead of values
62:53 - directly by doing that we have a lot
62:54 - more control over exactly what our code
62:56 - is doing for example the exact same code
62:58 - to move a player can make it move fast
62:59 - or make it move slow depending on what
63:01 - value we store inside that variable okay
63:03 - so that's the theory now let's see how
63:05 - to make variables in code and the way we
63:07 - Define a variable in C is first we write
63:09 - the data type now there are various data
63:10 - types depending on what type of data we
63:12 - want to store like I said some store
63:14 - strings of text others store whole
63:16 - numbers others decimals and so on I'm
63:17 - going to cover a bunch of data types in
63:19 - detail in the next lecture for example
63:21 - over here let's store the simplest data
63:23 - type just whole numbers and for that we
63:25 - write in for the int data type this is
63:27 - an integer so basically whole numbers
63:29 - and also again like I mentioned in the
63:30 - last lecture it is extremely important
63:32 - that you write the code exact always
63:34 - remember how it's case sensitive so for
63:36 - defining the int data type it is exactly
63:37 - like this so int on lowercase if I make
63:40 - this an uppercase i then the code no
63:42 - longer knows what this refers to if I
63:44 - put the whole thing in caps then nope
63:46 - this is not recognized that as data type
63:47 - so once again always remember always
63:49 - write the code properly and perfectly so
63:51 - in this case on lowercase int so first
63:53 - we Define the data type and then we
63:55 - write the name for the variable the name
63:56 - can be pretty much anything you want
63:58 - there are only a handful of limitation
64:00 - like for example it cannot start with a
64:01 - number so this is not a valid name but
64:03 - for the most part picking a proper name
64:05 - like for example let's say age yep there
64:07 - you go just like this basically over
64:08 - here we are defining a variable called
64:10 - age which is of type int and now after
64:12 - defining the H variable we can do an
64:14 - equal sign and basically we can assign a
64:16 - value to this variable so let's say 35
64:18 - with this we are assigning the value 35
64:20 - onto the age variable so basically
64:22 - picking the value 35 and placing it
64:24 - inside the age container also it's very
64:26 - important that the value matches the
64:28 - type expected by the variable so over
64:29 - here I cannot write for example 35.2
64:32 - this does not work this is an error
64:33 - because again in can only store whole
64:35 - numbers so I cannot store a decimal here
64:37 - so over here let's make sure to write a
64:39 - whole number let's say 35 and also as
64:40 - you write code you might see some
64:42 - symbols appear in kind of a faded gray
64:45 - as well as having the screens quickly
64:47 - lined underneath these are not errors
64:49 - these are pretty much as code
64:50 - suggestions so in this case it is saying
64:51 - that we are assigning this variable but
64:53 - the value is never used again that's
64:55 - because I'm writing the code slowly as I
64:56 - teach what it's doing so basically just
64:58 - don't get concerned with these green
65:00 - squiggle lines these won't go away as we
65:02 - actually use this variable so just
65:03 - remember these are not errors so don't
65:05 - worry about them okay so yep here we
65:07 - have defined the variable H and the
65:08 - variable is basically a container which
65:10 - is currently holding the value 35 if we
65:12 - want to inspect a value inside a
65:14 - variable for example one way we can do
65:16 - it is with the very helpful console that
65:17 - right line that we've seen up here so
65:19 - let's write the exact same thing and
65:20 - once again always make sure to write the
65:22 - code exactly perfectly so you can just
65:24 - do right line age and this basically
65:26 - going to print the age onto the console
65:27 - so if you go ahead and run this and if
65:29 - there it is it printed the value 35 so
65:31 - basically as the code goes to execute
65:33 - this line of code when it reaches this
65:34 - point it then looks inside this variable
65:36 - and pretty much just replace over here
65:38 - with what is the contents inside that
65:39 - variable so yeah great it's this simple
65:41 - here I have a demo in unity with this
65:43 - player character it is being moved using
65:45 - this move speed variable and basically
65:47 - it is currently moving at this speed and
65:48 - now if I take and I modify the value
65:50 - inside this variable there you go now it
65:51 - moves much faster or much slower so
65:53 - basically every time the movement
65:55 - function is running it is always
65:56 - grabbing the value inside this move
65:57 - speed so if we modify this then it
65:59 - modifies the actual Behavior so back in
66:01 - our symol console here here we have set
66:03 - the AG to a value then we can also
66:04 - modify variables so for example let's
66:06 - print the current age so that it should
66:08 - print 35 then let's go inside the age
66:10 - and do something to it for example let's
66:12 - assign it to a brand new value and let's
66:14 - print the age exactly the same and let's
66:15 - see and if there you go now it prints
66:17 - both values both the original value and
66:19 - the updated value now instead of
66:20 - assigning to modify the entire value we
66:22 - can also do some math to it and we can
66:24 - also use the variable in whatever meth
66:25 - we want to do so for example let's say h
66:27 - equals H + 1 so this should increase by
66:29 - one so it should say 36 and if that go
66:32 - 35 and 36 also another way of doing
66:34 - exactly this so incrementing by one is
66:36 - you just do Plus+ so both these lines of
66:38 - code are doing exactly the same thing
66:40 - both are incrementing age by one and yet
66:42 - another method of doing this is plus
66:44 - equals and then one so what we have here
66:46 - is exactly the same thing as we have up
66:48 - here so basically takes the age and
66:49 - equals H + 1 so over here h plus equals
66:52 - this does the exact same thing as up
66:54 - here so all these are really just
66:55 - different ways of writing the exact same
66:57 - operation although on this one on the
66:58 - Plus+ we can only do this once so this
67:00 - one only increments by one whereas these
67:02 - we can modify and put any value and of
67:04 - course here we are doing addition but we
67:05 - can do the same thing with subtraction
67:07 - so minus minus in order to decrement by
67:09 - one so all these also work and then on
67:11 - these two we can also do multiplication
67:13 - or division yep so over here we are
67:15 - taking the age and multiplying it by two
67:17 - and over here we are taking the age and
67:18 - dividing it by two however this short
67:20 - hand this one only works for
67:21 - incrementing and decrementing if we try
67:23 - doing slash slash nope this one becomes
67:25 - a the common doesn't actually make a
67:26 - division so there's lots of math
67:28 - operations you can do with variables and
67:30 - also up here when you define a variable
67:31 - you don't necessarily need to assign a
67:33 - value right away so this over here is
67:35 - perfectly valid code however like the
67:37 - red Squig line says over here use of
67:39 - unassigned local variable meaning we
67:41 - need to actually assign a value before
67:42 - we actually use it so this is valid code
67:44 - but before we use it we need to assign
67:45 - it to something so for example like this
67:47 - and Yep this does work also another
67:49 - thing is how you can Define multiple
67:50 - variables at once so you define the type
67:52 - and then Define the variable and then a
67:54 - comma and then any other variable you
67:56 - want so for example an in for age in for
67:58 - health in for power something like that
68:00 - so we have defined three variables and
68:02 - then we can just assign values to them
68:04 - Yep this works or alternatively we can
68:06 - also just Define and assign multiple of
68:09 - them right here Yep this is also valid
68:11 - code then I should also point out that
68:13 - you can do math directly on the
68:14 - variables like this or you can also do
68:16 - it directly inside a function call so
68:18 - for example over here H+ 2 let's just
68:20 - erase both of these so that one should
68:22 - say first 25 and then 25 + 2 and if you
68:25 - go 25 and 27 but for example let's say
68:27 - you want to print out the age and then
68:29 - the health if you do age plus Health if
68:31 - you do this the that actually prints 125
68:33 - instead of actually printing out both
68:35 - values both as separate things that's
68:37 - because both of these These are both
68:38 - numeric values so it basically ends up
68:40 - doing math with both these if you want
68:41 - to print out both values then you
68:43 - basically just need to convert these
68:44 - into a string that way they won't do any
68:46 - mathematical operations so the easiest
68:48 - way is up here we just had a quotation
68:50 - marks this basically marks the beginning
68:52 - of a string and then another one to Mark
68:54 - the end of it again remember all have
68:55 - matching ones so inside the string we
68:57 - can add anything like for example a
68:58 - comma and then we add a plus and like
69:00 - this basically an INT Value Plus a
69:02 - string it's going to convert the whole
69:03 - thing into a string then add another int
69:05 - which is also going to be a string so
69:07 - that should now print a string that will
69:08 - both print the age and the health and if
69:10 - there it is just like this okay so here
69:12 - we'll learn how variables are really
69:14 - basically just containers for some data
69:16 - and then you can do some operations to
69:17 - modify that data and speaking of data
69:19 - importantly is how each variable has a
69:21 - specific data type so let's learn about
69:23 - those in the next lecture
69:26 - hello and welcome I'm your Cod monkey so
69:28 - here let's do a walk through of
69:29 - everything in the variables lecture so
69:31 - basically I'm going to manually do
69:32 - everything that you should do after
69:34 - every single lecture so we just saw the
69:36 - variables lecture so let's open up over
69:38 - here the main window let's go inside the
69:40 - lecture list and this case we were
69:41 - following the variables lecture so let's
69:43 - go inside of that one and let's do them
69:44 - one by one so let's begin with the
69:46 - frequently asked questions these usually
69:48 - provide some extra clarifications on the
69:49 - topic on the lecture so in this case
69:51 - starting off with the basics so what
69:52 - exactly is a variable a variable is a
69:54 - container for data so think of it as a
69:56 - box and inside that box you can place
69:58 - some kind of value then you can write
70:00 - code that uses a variable instead of a
70:01 - value and by doing so when the code
70:03 - executes it will go inside that variable
70:05 - grab the current sord value and continue
70:07 - running the logic using that value this
70:09 - also means you can have different
70:10 - Behavior depending on the value stored
70:11 - inside the variable the simplest example
70:13 - is just a player object with some
70:15 - movement code instead of writing the
70:16 - movement speed directly you can define a
70:18 - variable and by modifying the value
70:20 - stored inside that variable you modify
70:21 - how fast or slow the player moves so
70:23 - variables are basically just containing
70:25 - to contain some value next why are data
70:27 - types important so each variable needs
70:30 - to have a certain data type and that
70:32 - data type defines what type of data we
70:33 - can store inside that variable there are
70:35 - data types for storing numbers and if
70:37 - you define a variable of that type then
70:39 - you cannot store a string of text inside
70:41 - that variable you always need to use the
70:42 - correct data type for whatever dat
70:44 - you're trying to store and the next
70:45 - lecture covers data types in detail so
70:47 - yep every variable needs to have a
70:49 - certain data type and based on what type
70:51 - you choose that defines what type of
70:53 - data you can store within that variable
70:55 - next what is a good name for a variable
70:57 - this is a great question so a good name
70:59 - is something that describes exactly what
71:00 - that variable represents ideally just by
71:03 - reading the variable name you should be
71:04 - able to understand what it represents
71:05 - and how it might be used for example a
71:08 - move speed variable this is a good
71:09 - variable name it clearly communicates
71:11 - that this is a variable that is used as
71:13 - some kind of movement speed whereas a
71:15 - bad name would be X just by reading it
71:17 - you have no idea what it represents
71:19 - unless of course you're making some kind
71:20 - of meth equation and X really is the
71:22 - correct name for that element so you
71:23 - should avoid abbreviations and acronyms
71:26 - those might be perfectly clear to one
71:27 - person and very confusing to someone
71:29 - else there is a very very important
71:31 - lecture later on in the course all about
71:32 - naming rules and how to choose good
71:34 - names next question what happens if I
71:36 - write int with capital i instead of int
71:38 - and the answer is you get an error
71:40 - because there is no such type named int
71:41 - with a capital I so always remember that
71:44 - code is Kate sensitive the compiler does
71:46 - not know English so as far as the
71:47 - compiler is concerned int with uppercase
71:49 - and in lowercase these are two
71:51 - completely separate types with no
71:52 - relation between them whenever you get
71:54 - an error the first thing you should
71:55 - should check is if you're writing the
71:56 - code absolutely perfectly pay very close
71:58 - attention to capitalization this
72:00 - something that a a lot of me mistake and
72:01 - Y this is something that I will continue
72:03 - repeating many times throughout this
72:04 - course code is case sensitive I see many
72:07 - beginners make this mistake on the many
72:09 - comments that I receive so I'm repeating
72:10 - it nonstop because I want to make sure
72:12 - that you don't make the same mistake
72:14 - next question what is console. Right
72:15 - line so this is a function that rites to
72:18 - the C console the console this is
72:20 - actually a class and right line is a
72:21 - function within that class but like it
72:23 - says here don't worry about functions in
72:24 - class right now those are all explained
72:26 - in detail in future lectures for now
72:28 - just know that it prints something to
72:29 - the console and the alternative in unity
72:31 - is this it is a simple debug.log
72:33 - basically if you're working in a console
72:35 - app use console. right line and if
72:36 - you're writing some code inside a Unity
72:38 - script for that the related one is
72:40 - debug.log and in doing so it will print
72:42 - some kind of message down here on the
72:43 - console next question what are the
72:45 - various ways to increment a variable and
72:47 - yep all of these lines of code are doing
72:48 - the exact same thing incrementing a
72:50 - variable by one so you can do H equals
72:52 - H+ one that will increment by one you
72:54 - can do AG plus equals 1 that won't do
72:57 - the exact same thing so grab age and
72:58 - increment by one or h++ which again same
73:01 - thing increments age by one all three of
73:03 - these lines of code these all do the
73:04 - exact same thing like it says here these
73:06 - are just short hands the last one is
73:08 - especially useful when working with
73:09 - loops which we're going to learn in a
73:10 - future lecture next and final frequently
73:12 - Asked question what if I Define a
73:14 - variable but don't give it a value if
73:16 - you don't give it a value then the
73:17 - variable is uninitialized and cannot be
73:19 - used until you give it a value so if you
73:21 - do something like this you get an error
73:22 - so defining int age and then trying to
73:24 - do a constant on the right line using AG
73:26 - if you do this you get an error because
73:27 - it says that the variable age is
73:29 - uninitialized although later on in the
73:30 - course we are going to cover classes and
73:32 - class variables and if you don't Define
73:34 - a value for those it won't default to a
73:36 - zero value so the zero value that means
73:38 - something like zero for an N Field means
73:40 - false for a b field or known for a
73:41 - string field again class are covered in
73:43 - detail in a future lecture all right so
73:45 - yep those are all the frequently asked
73:47 - questions as you can see they contain a
73:48 - bit more detail a bit more specifics on
73:50 - what was covered in the lecture going
73:52 - back in the main window we can see we
73:53 - have completed all seven frequently
73:54 - asked questions now let's go through all
73:56 - the quizzes starting off with the first
73:57 - one right here what is the primary
73:59 - purpose of a variable in C so is it to
74:01 - name a function to store data to execute
74:03 - commands or to create new data types
74:05 - hopefully if you fully paid attention to
74:07 - the contents of the lecture you should
74:09 - be able to answer all of these quizzes
74:10 - correctly so in this case the primary
74:12 - purpose if variable in C the primary
74:15 - purpose is to store data and if that is
74:17 - indeed correct here is the answer with
74:19 - some more details variables are
74:20 - containers for data you define the
74:22 - variable and then put inside whatever
74:23 - value you want based on the data type
74:25 - then you can write code that uses that
74:26 - variable in some way and when that code
74:28 - executes it goes inside the variable
74:29 - container grabs the value that is stored
74:31 - inside it and uses that value to
74:33 - continue running the code next question
74:35 - which of the following is a correct way
74:36 - to declare an integer variable so is it
74:39 - integer age equals 35 is it int AG int
74:42 - with uppercase i or all uppercase int
74:45 - again yet another example of how
74:46 - important case sensitivity is for
74:48 - example if you were to incorrectly
74:50 - choose let's say this one with capital I
74:52 - nope this one is not correct the correct
74:53 - one is that all lowercase
74:55 - answer always be very careful with how
74:57 - code is case sensitive int and uppercase
74:59 - int might look similar but they are two
75:01 - completely different things the biggest
75:03 - mistake that beginners make is writing
75:04 - code carelessly and then have no idea
75:06 - why it isn't working so always pay very
75:08 - very close attention to capitalization
75:10 - write the code exactly as it should be
75:12 - next Quiz how can you modify the value
75:14 - of a variable is it by assigning a new
75:16 - value to the variable by using the
75:18 - modify keyword or by redeclaring the
75:20 - variable with a new value so if you
75:22 - redeclare you're going to get an error
75:24 - because you cannot declare two variables
75:25 - of the exact same name and there's no
75:27 - such thing as a modifi keyword so the
75:28 - correct answer is by assigning a new
75:30 - value the answer here you can define a
75:32 - variable and then assign a new value to
75:34 - replace the previous value so Define in
75:36 - h equal 35 and then replace it with 25
75:39 - like it says here you don't redeclare it
75:40 - if you do you get an error since you
75:42 - cannot Define two variables in the same
75:43 - scope with the exact same name so over
75:45 - here if you do this yep you get an error
75:47 - age is already defined however you can
75:49 - also have multiple variables of the same
75:51 - name as long as they are on completely
75:52 - different scopes for example you can
75:54 - have a local variable named age inside
75:56 - one function and a different local
75:58 - variable on a different function also
75:59 - named age there is a detail lecture on
76:01 - scope later on in the course next Quiz
76:04 - what does the statement h++ do so does
76:06 - it reset the value of H to zero does it
76:08 - divide the value of H by itself does it
76:11 - increase the value of H by one or
76:13 - multiply the value of H by two this one
76:15 - is a short hand for increasing by one so
76:16 - yep it increased the value of H by one
76:19 - like it says here the shorthand for
76:20 - increasing the value sorted in the
76:21 - variable by one this is a really super
76:24 - useful shorthand especially when working
76:25 - with loopes which we're going to cover
76:27 - in a future lecture these are the two
76:28 - main shorthands so h++ and H minus minus
76:31 - although these two do not work you
76:33 - cannot do age multiply multiply this
76:35 - doesn't work or divide divide also
76:36 - doesn't work so this shorthand only
76:38 - works for these two but if you want to
76:40 - do this kind of math so multiplication
76:41 - and division if so you can use these
76:43 - other short hands so plus equal 2us
76:45 - equals 2 time equals divide equals next
76:47 - Quiz question what math operations can
76:49 - you do on a variable so is it only
76:51 - addition is it addition subtraction
76:53 - multiplication and division or is it
76:55 - only assignment of values any up with
76:57 - variables you can do pretty much all
76:58 - kinds of math so the answer is this one
77:00 - you can add plus Subtract with minus
77:02 - multiply and you can divide although of
77:05 - course this assumes that the data type
77:06 - being used in the variable is a number
77:08 - type naturally you cannot multiply a
77:10 - string or divide an object next multiple
77:12 - choice question is it possible to
77:13 - declare multiple variables in one line
77:15 - so yes by separating them with a comma
77:17 - or no each variable must be declared in
77:19 - a separate line and yep if you use a
77:20 - comma you can indeed Define multiple
77:22 - variables in one line so yep you can do
77:24 - this this is perectly valid code so int
77:26 - age comma in health and so on this works
77:28 - although at the same time while this is
77:30 - valid code personally I tend to avoid
77:31 - doing this because I feel like it makes
77:33 - the code a bit more confusing so while
77:35 - you can do this personally I would
77:36 - always Define each variable in a
77:38 - separate line just to keep the code nice
77:39 - and readable next Quiz question how do
77:41 - you print the value of a variable to the
77:43 - console is it with console. right line
77:46 - and the variable name is it console.
77:47 - print or just right line and this is
77:49 - something that you're going to do tons
77:51 - and tons of times so even if you get it
77:53 - wrong right now you will certainly get
77:54 - this right soon enough the answer is
77:56 - this one consant outright line a very
77:57 - common function you use consant outright
77:59 - line whenever you want to print anything
78:01 - onto the C console and by the way if you
78:03 - don't understand this syntax then don't
78:04 - worry this is a function and a static
78:06 - class all of that is explained in detail
78:08 - in future lectures or alternatively when
78:10 - working with unity the similar function
78:12 - that prints with unity console that one
78:14 - is called debug.log and then you print
78:15 - whatever you want okay so final quiz
78:18 - question what does the statement age
78:20 - star equals two do does it divide value
78:23 - of age by two does it in by two or
78:25 - multiplies by two and yep I'm pretty
78:27 - sure that the star is the universal
78:29 - symbol for multiplication so yep this
78:31 - one is the multiplication the srisk
78:33 - means multiplication and this syntax is
78:35 - a shorthand for doing sum function on
78:37 - the left side so these two lines of code
78:40 - are doing the exact same thing so H star
78:42 - equals 2 or H equals H * 2 yep both
78:44 - these are doing the exact same thing all
78:46 - right so that's the questions and we
78:48 - have 8 out of8 done now let's go into
78:50 - the exercise and let's go through all
78:52 - these one by one this one is a really
78:54 - really important part after you go
78:56 - through every lecture definitely make
78:57 - sure you do all of the exercise so let's
78:59 - do them beginning with this one okay so
79:01 - lecture variables exercise titled Define
79:04 - speed variable the goal is to edit the
79:06 - script exercise. CS we need to declare a
79:08 - variable of type int with the name speed
79:10 - and assign the value five to it so pay
79:12 - close attention to where you write the
79:13 - code so here's a quick hint right inside
79:16 - the main function so let's open up
79:18 - exercise. CS okay here is the file and
79:20 - right away there's just a quick
79:21 - explainer about what are these things in
79:23 - green these are commons these are just
79:25 - text the compiler completely ignores
79:26 - this so none of this is read as code
79:28 - comments are going to be covered in
79:30 - detail in a future lecture so the goal
79:32 - is to write some code after this line
79:34 - but again very important like I
79:35 - mentioned in the lecture on programming
79:36 - Basics we need to write it inside the
79:37 - main function so right here the goal is
79:39 - to declare a variable of type int with a
79:41 - name speed and the value five so like we
79:43 - learned in the lecture first we write
79:45 - the type name so in this case we want an
79:47 - INT and again always keep in mind code
79:50 - is case sensitive so it's in all
79:51 - lowercase it is not uppercase if you do
79:53 - it like this we got a red squiggle line
79:56 - int is not being recognized so the type
79:58 - name is int then after the type we write
80:00 - the name so in this case we want it to
80:01 - be named speed and then in order to
80:03 - assign a value we need to use the equal
80:05 - sign and then whatever value so in this
80:07 - case let's assign it to the value five
80:08 - and Yep this is it now since this is the
80:10 - first exercise let me just show a few
80:12 - things so for example if we make a
80:14 - mistake here so if we write int with
80:16 - uppercase again very important before
80:18 - you go back into Unity you have to save
80:21 - so either go up here into file and then
80:23 - save or just press contrl s so as soon
80:26 - as you save Unity should see the changes
80:29 - and it should start to compile or in
80:30 - this case we have a compiler error so it
80:31 - doesn't actually compile and like I
80:33 - mentioned on the lecture on how the
80:35 - exercise work always make sure you have
80:36 - the companion window open that way if
80:38 - you make some kind of mistake that leads
80:39 - to some kind of error here you can see a
80:41 - little bit more text that might help
80:43 - clarify exactly what the issue is so
80:45 - over here the issue is pretty simple
80:46 - it's because we wrote in incorrectly so
80:48 - as always remember how code is case
80:50 - sensitive so over here we need to make
80:51 - sure to type in and again if we also
80:53 - make another mistake St here like we
80:55 - named sped instead of speed right now
80:57 - the code is compelling because we have
80:58 - no syntax errors any you the exercise is
81:00 - still in progress because we didn't
81:02 - actually compl it perfectly and again
81:04 - down here on the companion window we can
81:05 - see some nice helpful message so did you
81:08 - accidentally write something different
81:09 - again the goal with this exercise is to
81:11 - teach you how to write things absolutely
81:12 - perfectly so now let's properly
81:14 - construct our exercise so just like this
81:16 - so Define a variable of type in named
81:18 - speed with the value five and if we save
81:21 - and just let the code compile and if
81:23 - there it is we have the ex SI completed
81:25 - then we can also show the hint like the
81:27 - hint says here remember the Syntax for
81:29 - how variables are declared so first the
81:31 - type and then the name and then
81:32 - optionally assign some value always
81:34 - remember how code is case sensitive so
81:37 - Define variable named exactly speed not
81:39 - uppercase speed or anything else and if
81:41 - we were to get really stuck we can just
81:42 - show the solution and up here we see the
81:44 - goal is to Define a variable of type in
81:46 - named speed with the value five so the
81:48 - solution is exactly this so in speed
81:50 - equals 5 and if we want we could click
81:52 - on apply solution any if that overrides
81:54 - file with one with the solution which is
81:56 - exactly what we wrote so yep just like
81:57 - this so like it says here congrats in
81:59 - this exercise you applied what you
82:00 - learned about how variables are defined
82:02 - how they have a type a name and a value
82:05 - so if that's it now click the complete
82:06 - exercise button order to finish the
82:08 - exercise all right here is the lecture
82:10 - on variables let's see the exercise
82:12 - titled fix error in so like it says here
82:14 - edit the script exercise. Cs and fix all
82:16 - of the compile errors and by the way as
82:18 - soon as you start the exercise or click
82:20 - on this button to open the file and if
82:22 - you do and if you see Unity kind of
82:23 - breaking like this if so then go into
82:25 - your visual studio and over here you
82:27 - might see this window telling you that
82:29 - some file has been changed externally
82:31 - that's because the whole setup for
82:32 - starting the exercises so whenever you
82:34 - see this window just go ahead click on
82:36 - yes to all and yep it should reload
82:38 - everything and yep here is the exercise
82:39 - file again the goal is to fix this error
82:42 - and here's a quick tip place the mouse
82:44 - over the red line in order to see the
82:45 - actual error so if we place the mouse
82:47 - over here directly on top of the int Red
82:49 - Square line if so we can see this here
82:51 - the typ Oro namespace int could not be
82:53 - found and like it says here
82:55 - alternatively we can check the unity
82:56 - console or check the companion window so
82:59 - here in unity if we look at the console
83:01 - yep we see exactly that error tyer name
83:03 - space in could not be found and over
83:05 - here on the companion window over here
83:06 - we can see a nice little hint on what
83:08 - exal the is might be and Y in this case
83:10 - this teaches us exactly what is the
83:11 - solution what is the problem that we
83:13 - have here as always remember how code is
83:15 - case sensitive then we can also show the
83:17 - hint so in this case the hint is pretty
83:19 - simple so remember how code is Kate
83:20 - sensitive and we can also see the show
83:22 - solution so there's an that says int
83:25 - uppercase i does not exist and that is
83:27 - because code is cons sensitive and the
83:29 - proper name is in all lowercase so the
83:31 - compile error here is pretty simple
83:34 - remember how you have to write code
83:35 - perfectly so in this case it is not int
83:37 - uppercase but int all lower case so y
83:40 - that's really it let's go ahead and save
83:42 - the code is compiling and if there it is
83:44 - exercise completed okay so congrats in
83:47 - this exercise you'll learn how to solve
83:49 - the most common error that beginners
83:50 - encounter which is issues with
83:52 - capitalization always remember how how
83:54 - code is case sensitive so in on
83:56 - lowercase and int with an uppercase i
83:59 - those are two completely different
84:00 - things one exists and one does not same
84:02 - thing for all the other types so float
84:04 - versus float bull bull true true and so
84:06 - on so once again another exercise to
84:08 - really make sure you fully understand
84:09 - code is K sensitive the reason why I'm
84:12 - repeating this so often is really
84:13 - because this is the main error that
84:15 - beginners encounter okay so we can now
84:17 - complete the exercise all right so
84:19 - lecture on variables here is the
84:21 - exercise change unit speed so the goal
84:23 - with this one is modify the speed
84:25 - variable to make the player reach the
84:26 - Target in time this exercise has a Unity
84:29 - scene it should be unloaded
84:30 - automatically so click on play in unity
84:32 - to test your code and just a quick tip
84:34 - just in case the scene doesn't load
84:35 - automatically it should do that but in
84:37 - case it doesn't just go into your
84:39 - project files and if you scroll down you
84:41 - go into whatever lecture you're
84:42 - currently on So currently we're on the
84:44 - variables lecture and over here if we go
84:46 - inside the exercise folder we should be
84:48 - able to see all the files for this
84:49 - exercise so over here we have the
84:50 - exercise scene and yep it is this one so
84:52 - like it says here the goal is to modify
84:54 - the speed variable now before we check
84:55 - the code let's try running this code and
84:57 - see what happens so the player is moving
84:59 - some kind of player character it is
85:01 - moving and nope it did not reach the
85:02 - Target in time okay so we need to modify
85:04 - the speed in order to make sure it gets
85:05 - there on time so here is the code and
85:08 - again you can ignore these lines that
85:09 - start with two for slashes these are
85:11 - comments and the code ignores all of
85:13 - these lines comments are covered in
85:14 - detail in a future lecture so here we
85:17 - have a line of code that is setting some
85:18 - kind of player speed variable so all we
85:20 - need to modify is this value and then we
85:22 - can press play in unity to test our code
85:24 - and again something that is going to
85:25 - happen more and more as we see some more
85:27 - complex exercises is some of them have
85:29 - some testing codes so just make sure you
85:31 - don't modify these lines of code
85:33 - otherwise the exercise breaks so in this
85:35 - case all we want to modify is this one
85:37 - and if we get stuck we can always show
85:38 - the hint and like it says here variables
85:40 - are containers for data so when the code
85:42 - runs it gets to the variable and it
85:44 - grabs whatever value stored in that
85:46 - variable and uses that so in this case
85:47 - if we want the player to move faster
85:49 - then we just need to modify the value
85:50 - that is stored inside the player speed
85:52 - variable or as always you can click show
85:54 - solution in order to see it so in this
85:56 - case the player speed variable just
85:57 - needs a value that is big enough in
85:59 - order to get to the Target on time so
86:00 - for example float player speed equals
86:02 - six so let's say let's put it on 3F so
86:05 - let's go ahead save and over here back
86:07 - into Unity let's make sure it compiles
86:09 - and let's hit on play and it is moving
86:12 - forward and nope it still did not appre
86:15 - in time so let's increase by a little
86:16 - bit so instead of three let's go with
86:18 - six okay let's run the cone and it is
86:21 - moving forward really fast and Y there
86:22 - you go success we didn't get in time all
86:25 - right awesome so in this exercise you'll
86:27 - learn how variables are used in the
86:28 - actual code meaning how their value
86:30 - actually affects how the code behaves so
86:32 - over here by just modifying the value
86:34 - that we stored inside a variable we
86:36 - managed to see how that actually
86:37 - impacted the behavior for the code which
86:39 - in turn allowed us to achieve our
86:40 - results okay so let's go ahead stop
86:42 - playing and let's complete our exercise
86:45 - all right let's see the lecture on
86:46 - variables with the exercise titled fix
86:48 - the error uninitialized so like it says
86:51 - here fix the error in the console a
86:52 - variable is being used while unassigned
86:54 - so here is our exercise Phile and as
86:56 - usual let's place the mouse over the red
86:58 - line order to see the error and our
87:00 - error here thankfully this one is predy
87:02 - descriptive so it says use of unassigned
87:04 - local variable AG this is teaching us
87:06 - that before we can use a variable we
87:08 - need to actually assign some kind of
87:09 - value to it so this exercise is pretty
87:11 - simple and the way that we assign a
87:13 - value like we saw in the lecture is by
87:14 - using the equal sign and then using some
87:17 - kind of value but again remember how the
87:18 - values also dependent on the type that
87:20 - we're using so since this is an INT
87:22 - variable We cannot put some kind of
87:24 - string of text this does not work we
87:26 - also can output some kind of decimal
87:28 - value nope here it has to be an integer
87:31 - so let's put just a whole number and Y
87:33 - just like this and we no longer have any
87:35 - errors the variable is correctly being
87:37 - assigned with some kind of value so then
87:39 - we can indeed use it so let's save our
87:41 - code and c and let it compile and if
87:43 - there it is our exercise has been
87:45 - completed so good job here you learn
87:48 - another common error using variables
87:50 - before assigning a value to them so
87:52 - always always make sure a variable has a
87:54 - value and the best way to avoid this
87:56 - error is to always give it a default
87:57 - value whenever you define a variable so
87:59 - yep always keep that in mind remember
88:01 - how before you can use a variable it
88:03 - needs to have some kind of value okay
88:05 - let's complete the exercise all right so
88:07 - here is the lecture on variables and
88:09 - let's do the exercise title double
88:11 - variable so the goal with this one is
88:12 - double the value inside the age variable
88:15 - do not modify the code defining the
88:16 - variable or calling the function result
88:18 - so we should really just double the
88:20 - value inside the age variable so we
88:21 - should only double the value inside the
88:23 - age variable and then we can play the
88:25 - scene in unity in order to test our code
88:27 - all right so here's the script and again
88:28 - we've got some comments that again are
88:30 - ignored by the compiler these are just
88:32 - text just to guide us then over here
88:34 - first thing we have is an INT variable
88:36 - named H and it is being initialized with
88:38 - the value 20 and then like it says here
88:40 - modify this line down here set it to
88:42 - double the value stored inside of H and
88:45 - as a quick hint remember how you can use
88:47 - math with variables now one obvious
88:49 - thing is you can just do math within
88:50 - your own head so you can just set it to
88:53 - 40 which is indeed the of 20 and if we
88:55 - hit play unity and technically we got a
88:58 - success we did get double however while
89:00 - the result is accurate there doesn't
89:01 - seem to be any multiplication so the
89:03 - goal with this exercise is to teach you
89:04 - how you can use mathematical operations
89:06 - within your variables so setting it to a
89:08 - fixed value that doesn't make much sense
89:10 - so let's complete this exercise properly
89:12 - let's set it to double by using actual
89:14 - math by actually multiplying by two so
89:16 - over here instead of the Direct Value we
89:18 - can use math so we can take our age
89:20 - variable so that is the one that we
89:21 - defined up here so it is currently with
89:23 - the value 20 we can take this and then
89:25 - we can do multiplications using an
89:27 - asterisk and then we can multiply it by
89:29 - something so in order to double it
89:30 - pretty simple just multiply it by two so
89:32 - y this is going to assign the age double
89:34 - variable it is going to be assigned to
89:36 - the value of AG multipli by two and the
89:38 - value of age contains the value 20 so in
89:40 - this case 20 * 2 and H double won't be
89:42 - set to 40 okay so that's it always
89:44 - remember to save your file just let
89:47 - Unity compile the changes and let's set
89:49 - on play and if there it is we have our
89:51 - success and our exercise has been
89:53 - completed so good job in this exercise
89:55 - you'll learn how you can do math with
89:57 - variables Yep this is definitely
89:58 - something that is very valuable always
90:00 - remember how you can take your variables
90:01 - and do math with them now we can
90:03 - complete the exercise and yep we have
90:05 - five out of five exercises completed so
90:07 - everything is Fally completed there it
90:09 - is the variable's lecture all fully on
90:11 - green so what we did here basically what
90:13 - I want you to do after every single
90:15 - lecture so watch a video lecture then
90:17 - come here and do all of that go on to
90:19 - the main window select the lecture that
90:20 - you want go through all the frequently
90:22 - asked questions all the quizzes do all
90:24 - the exercises and make sure that
90:25 - everything is nice and green if you
90:27 - truly want to learn C then this is
90:29 - really what you need to
90:31 - do hello and welcome I'm your Cod monkey
90:33 - in this lecture we're going to learn all
90:35 - about the various built-in data types
90:37 - that exist okay so in the previous
90:38 - lecture we learned about variables which
90:40 - are essentially just data containers and
90:42 - those containers they need to have a
90:43 - specific type there's a bunch of
90:45 - built-in types we can use for example
90:47 - some containers can only store whole
90:48 - numbers other containers can store
90:50 - strings of text then other ones can
90:52 - store the value either true or false and
90:54 - some can sore decimal numbers so there's
90:56 - a bunch of interesting built-in typs we
90:57 - can use here is the same demo that we
90:59 - saw in the previous lecture with the
91:00 - Sprite just bouncing up and down and
91:02 - this one has a parameter for a movement
91:04 - speed this one is defined as an INT
91:06 - variable so that means that over here we
91:07 - can only write whole numbers if I try
91:09 - writing some text nope that does not
91:11 - work if I try adding a decimal point
91:13 - nope I can't put it over here since this
91:15 - type is of type int it can only hold
91:17 - whole numbers here is the code that we
91:19 - wrote in the previous lecture so I've
91:20 - got an in for an age and over here if I
91:22 - try assigning a decimal number like
91:24 - let's say 35.5 and no this one has an
91:27 - error like I said ins can only store
91:29 - whole numbers if you want to store a
91:30 - decimal value then one of the types we
91:32 - can use is a double so we literally just
91:34 - swap in for double and now this variable
91:36 - this one is now of type double and with
91:38 - this yep we have no errors so we can
91:39 - indeed write a value with a decimal
91:41 - point and everything works now there are
91:43 - actually three types that we can use for
91:44 - decimals we can use float double or
91:47 - decimal there's a nice sa directly over
91:49 - here on the C docs that shows the
91:50 - maximum numbers and precision which is
91:52 - what affects all those types as you can
91:54 - see they've got different sizes and
91:55 - different Precision the smallest one is
91:57 - a float which is stored in just four
91:59 - bytes then a double is stored in eight
92:01 - bytes and a decimal in 16 bytes and over
92:03 - here we can see the Precision so
92:04 - basically if you're dealing with
92:05 - something where Precision is Paramount
92:07 - like for example when dealing with money
92:08 - for that you really want to use the
92:09 - decimal type but for all other use case
92:11 - you can either use a double or a float
92:13 - in regular C applications I believe
92:15 - doubles are actually used most often
92:16 - since in order to write a double you
92:18 - really just put a decimal point and Yep
92:19 - this one is a double whereas the other
92:21 - type the flow type for this one if you
92:23 - just find something with a decimal nope
92:25 - it does not work this one shows an error
92:27 - and the error is because if we just put
92:28 - a dot then this one simply becomes a
92:30 - double in order to make it an act float
92:32 - we need to append the F onto it so like
92:33 - I said in regular C applications I
92:35 - believe doubles are mostly used since
92:37 - you don't even need to append anything
92:38 - you just write the number whereas for
92:40 - floats you need to open F and in unity
92:42 - game development which is the thing that
92:44 - I do most most of logic is usually done
92:45 - with floats so personally that's the
92:47 - decimal type that I normally tend to use
92:49 - now for Unity beginners one of the
92:50 - things that trips them up is forgetting
92:52 - to place the F at the end end like we
92:54 - saw if we don't do it yep we get an
92:55 - error because this is a double and
92:57 - double is not automatically convertible
92:59 - into a float so if you ever see an error
93:01 - like this always remember that if you're
93:02 - defining a float make sure to add F at
93:04 - the end okay so these are the main types
93:06 - for holding decimals and then there's
93:07 - also a bunch more types for holding
93:09 - whole numbers Beyond int again the
93:11 - documentation has a really nice table
93:12 - over here so int is the one that you're
93:14 - probably going to use most often this is
93:16 - a s 32bit integer you can store values
93:18 - between minus 2.1 billion to plus 2.1
93:21 - billion but there are use cases where
93:22 - you don't need that much Precision there
93:24 - are some cases where you are memory
93:25 - limited so you want to use as fewer bits
93:27 - as possible so in those case you've got
93:29 - all of these values and on the other
93:30 - hand if you want to store a real large
93:32 - number like for example the age of the
93:33 - universe for that you would normally use
93:35 - either long or you long but for the most
93:37 - part you will really just be using inss
93:39 - so don't worry about the rest just know
93:40 - that those also exist and also since
93:42 - we're talking about maximum and minimum
93:44 - let me just show you what happens if you
93:45 - go above the maximum so for example here
93:47 - we've got age defined as an INT now here
93:49 - we can give it the maximum value for an
93:51 - INT for that we can access the int class
93:53 - and pass in a DOT this one lets us
93:56 - access a bunch of constants or functions
93:58 - inside the in class again I will cover
94:00 - class in detail in a future lecture for
94:01 - now over here we can just check the max
94:03 - value and this one is basically going to
94:05 - represent the largest possible value
94:07 - that we can sort inside an in which like
94:08 - we saw a while ago the maximum is 2.1
94:10 - billion so let's do a console di right
94:12 - line on this one and see what the
94:14 - maximum is and then let's do something
94:16 - interesting so let's take the age and
94:18 - incremented by just one and let's print
94:20 - again and see what this one prints and Y
94:22 - that's a result so basically first we've
94:23 - got the maximum so 214 Yep this is the
94:26 - maximum value for n and then if we have
94:27 - that value and we increment it by just
94:29 - one then we get what is called an
94:31 - overflow and essentially it really just
94:32 - Loops back the value to the absolute
94:34 - minimum so if you go past the maximum
94:36 - you really just end up on the minimum
94:37 - when working with data types always make
94:38 - sure you define some type that is enough
94:40 - to store whatever value you need to
94:42 - store okay so here we have instant
94:44 - floats for most of our number needs then
94:45 - we can also do operations on them so on
94:47 - a float you can do a float time two
94:51 - something like this you can do division
94:53 - you can do addition you can do
94:55 - subtraction so all the usual things now
94:57 - there are some quirks if you do some
94:58 - mathematical operation using different
95:00 - types like for example floats and ins I
95:02 - won't cover type conversions in a little
95:03 - bit but in terms of numbers usually
95:05 - you're going to work with mostly with
95:06 - ins and floats and then another very
95:08 - important data type are strings these
95:10 - are strings of text so you define a
95:11 - string by typing in string so just like
95:13 - the same as any other variable then
95:15 - let's call this one name and let's
95:16 - assign a string value onto it now when
95:18 - making a string you do it using double
95:20 - quotation marks and remember to add both
95:22 - the beginning and the end quotation mark
95:24 - and as usual every instruction needs to
95:26 - end with a semicolon so over here do not
95:28 - make the mistake of putting the
95:29 - semicolon inside the quotation marks
95:30 - this one is an error because over here
95:32 - we just have a string with a semicolon
95:33 - instead of heading a semicolon to end
95:35 - instruction so don't make that mistake
95:37 - and also it's very important how these
95:38 - are double quotation marks these are not
95:41 - the single quotation marks these are
95:42 - completely different things those are
95:43 - used for another type that I'm going to
95:45 - cover in a little bit so it's double
95:46 - quotation marks we have the start we
95:48 - have the end and then inside we can
95:49 - write whatever Tex we want so for
95:51 - example writing Code Monkey and then we
95:54 - can do a console down right line and
95:56 - let's print out our name variable and if
95:58 - there it is it prints exactly as
95:59 - intended as for making some operations
96:01 - with strings the most basic one is just
96:03 - a pinning or concatenating a string for
96:05 - that you just take a string and then do
96:06 - plus and then another string like for
96:08 - example my name is and then plus and
96:10 - then the name this is basically going to
96:12 - add this ring onto the end of this ring
96:13 - if we run this and if there you go my
96:15 - name is Code Monkey okay great now also
96:17 - important over here are the spaces
96:19 - inside the quotation marks these spaces
96:21 - do matter if we don't put a space here
96:23 - give there you go it says is and then
96:24 - code monkey with no space between them
96:26 - and on the other hand if we add a ton of
96:27 - spaces y there you go now it adds a ton
96:29 - of spaces so basically just be aware
96:31 - that spaces do matter these are not just
96:32 - empty and then when concatenating
96:34 - strings you can also use it to mix
96:36 - multiple types so for example our age up
96:38 - here so we can do my name is then plus
96:40 - and add the name onto it then we can add
96:42 - some more again let's start by adding a
96:44 - space and I'm another space and then
96:47 - let's print the H was years old okay
96:49 - let's see this any if there's our final
96:51 - string putting together all the values
96:52 - from all of our VAR so this is one way
96:54 - to do it you basically just make one
96:56 - string then plus add another string and
96:57 - so on this is one way to do it or
96:59 - alternatively you can use a string
97:00 - interpolation method to use that one you
97:02 - basically just put everything inside one
97:04 - string so let's get rid of all the
97:05 - pluses and all the things creating brand
97:08 - new strings so let's write it just like
97:10 - this except of course just like this
97:11 - this just going to print my name is name
97:13 - and I'm a years own so this is not what
97:14 - we want for string interpolation we have
97:16 - an entire string and then before it we
97:18 - add a dollar sign and now inside
97:20 - whenever we have something that is a
97:21 - variable we can add some currently
97:23 - braces
97:24 - open and close them again don't forget
97:25 - to open and close let's add on both
97:27 - these variables and now if you print if
97:29 - there it is now it says the same thing
97:30 - so these you are basally doing the exact
97:32 - same thing they achieve the exact same
97:33 - output you can add a construct a long
97:35 - string by building different pieces and
97:37 - adding them onto one another or you can
97:39 - just make an entire one and use string
97:40 - interpolation in order to Define what is
97:42 - a value and what is a string also here's
97:44 - yet another more advanced zp on strings
97:46 - let's say for example you want to store
97:47 - a string that contains quotation marks
97:49 - so let's do a right line and let's print
97:51 - my name is Code Monkey but now let's say
97:54 - that I want to print some quotation
97:55 - marks directly in there now if we do it
97:57 - like this obviously there's an error
97:58 - basically over here we are starting and
98:00 - finishing one string then over here
98:01 - starting and finishing another one and
98:03 - over here we've got some symbols that c
98:05 - does not understand so this does not
98:06 - work basically we do not want this
98:08 - quotation mark to end this first
98:10 - quotation mark instead we want this one
98:11 - to be seen as just a character so if you
98:13 - need to put quotation marks directly
98:15 - inside a string for that you can just go
98:16 - before it and add a backslash and this
98:18 - is basically going to escape this
98:20 - character which means it is going to
98:22 - consider it as text instead inad of
98:23 - interpreting as a string quotation mark
98:25 - so we can just add that one to that one
98:27 - and to that one and if there you go Exel
98:28 - like this and if there's a text in the
98:30 - string does print with all the quotation
98:31 - marks okay great so another thing that I
98:33 - mentioned is how it's important that you
98:35 - use double quotation marks the reason
98:37 - for that is because there is another
98:38 - type that is specific to single
98:39 - quotation marks and that type is sh that
98:42 - stands for some kind of character and
98:43 - for that you use the single quotation
98:46 - marks and inside you can place a single
98:47 - character like for example the letter A
98:49 - again this type Only Stores a character
98:51 - so if I try putting a bunch more stuff
98:52 - nope does not work this one only
98:54 - represents one character so that's the
98:55 - only thing that I can sore inside it now
98:57 - another very important type is bullan or
98:59 - bull so for that you write bull then
99:01 - give it some name like let's say is
99:02 - player and then for this one there are
99:04 - only two values we can sort inside a bow
99:06 - it can be either true or for example
99:08 - let's say is enemy and can be false so
99:10 - the bowling type can only have these two
99:12 - values nothing else and again it's
99:13 - extremely important that you write the
99:15 - code exactly so it's true like this all
99:17 - in lower case it is not capital T true
99:19 - nope this does not exist it is not
99:21 - everything in true nope does not exist
99:23 - so it's all lowercase now this type
99:25 - bullan this one is extremely important
99:26 - in if statements and conditions which
99:28 - we're going to see in detail in the next
99:30 - lecture and there is one more special
99:32 - sort of type that you should know
99:34 - although it's not really a type and that
99:35 - is how simply instead of defining a
99:37 - specific type like ball Shar string and
99:39 - so on instead of that you can just write
99:41 - VAR then give it some kind of name my
99:43 - variable and then give it some kind of
99:44 - value and basically with this the
99:46 - compiler will essentially look at the
99:47 - value that is assigned and infer some
99:49 - type of type for this variable so for
99:51 - example for this one since we assigned
99:52 - the value 10 this one correctly Define
99:54 - this variable as an INT whereas if I put
99:56 - 10.2 for this one now yep now it
99:58 - correctly identifies it as a double if I
99:59 - put an F yep now it correctly identifies
100:01 - as a float if I put false and Yep this
100:04 - one is now a bull and if I put false in
100:06 - quotation marks and Yep this one is now
100:08 - a string so rather than explicitly
100:10 - defining the type if you want you can
100:11 - just Define it as VAR and let the
100:13 - compiler infer the type for you some
100:14 - people like this because it tends to
100:16 - make the code a little bit more compact
100:18 - especially when we're working with
100:19 - complex names when we're working with
100:21 - types like list and so on however
100:23 - personally I am not a fan of VAR
100:25 - personally I like being as explicit as
100:27 - possible so that I know exactly what
100:28 - type I'm working with so personally I
100:30 - never use V I always very explicitly
100:32 - write the type that I'm using but there
100:34 - is nothing wrong with VAR it's really
100:35 - just personal preference so if you like
100:37 - using it then yep by all means use it
100:39 - here is a demo that I built included in
100:41 - the interactive exercises so we've got a
100:43 - bunch of valys up here and a bunch of
100:44 - containers down here of various types
100:46 - now this valy the value 56 this when is
100:48 - selected and we need to place it in the
100:49 - correct container now if we try putting
100:51 - this in a bullan nope that does not work
100:53 - because this is not a bullion this one
100:54 - is a whole number so for whole numbers
100:56 - we can place them inside the int
100:57 - container then over here we've got a
100:58 - string so this one cannot be a flow it
101:00 - cannot be a bow nope this one is a
101:02 - string then we've got false this one is
101:03 - a bulling value seven this a whole
101:05 - numbers let's put it inside the int Iron
101:07 - Man this is another string let's put it
101:08 - on string Black Widow same thing it's a
101:10 - string 35 this one is a whole number so
101:12 - goes into int 33.3 F this one is a float
101:15 - so go inside the floats true this is a
101:17 - bullion so go in there this one is a
101:19 - float and this one is also a float all
101:20 - right yep all done go ahead and give it
101:22 - a try yourself and see if you get a all
101:23 - right now I just see one more thing on
101:25 - types which is type conversion and we
101:27 - actually already saw that if we do a
101:29 - console. right line and on this one
101:31 - let's print out the age if we do this
101:33 - and run y there you go we did print out
101:35 - the age so the code is automatically
101:37 - converting our int age into a string
101:39 - that is printed onto the console
101:40 - basically all types can be automatically
101:42 - converted into a string then you can
101:44 - also mix types together for example
101:45 - let's say number five plus and then a
101:47 - string say number and Y this code Works
101:49 - however like I mentioned in the
101:50 - programming Basics lecture code runs
101:52 - from top to bottom but also left to
101:54 - right meaning over here let's see what
101:56 - happens if we place first the string
101:58 - number then let's add the number five
102:00 - and then let's add the number six so
102:01 - let's see what this evaluates to and if
102:03 - there it is a string number 56 okay
102:05 - great however now let's reverse the
102:07 - order so let's put 5 + 6 and then the
102:10 - string number now let's see what this
102:11 - one evaluates to and if there it is now
102:13 - it says 11 number so this is the
102:15 - difference between how the code runs
102:16 - from left to right basically over here
102:18 - the code is going to see okay this is a
102:19 - string and this is an INT and the result
102:22 - form adding a string onto an end the
102:24 - result from that is going to be a string
102:25 - so this one is going to concatenate into
102:27 - the string number five and then it's
102:29 - going to have another string against
102:30 - another end so it's going to add the six
102:32 - onto it however on this one first left
102:33 - to right it is going to check an INT
102:35 - plus another int that is a simple
102:37 - mathematical operation so it is going to
102:38 - add these two numbers together and then
102:40 - the result is an INT which then adds
102:42 - onto a string so it is going to do
102:43 - string concatenation so the second one
102:45 - ends up with 11 number whereas the first
102:47 - moon is number 56 so remember code
102:49 - executes from top to bottom and left to
102:51 - right always keep that in mind now in
102:52 - terms of of converting to a string
102:54 - anything can be converted onto a string
102:56 - however for other ones some types can be
102:58 - converted into others automatically some
103:00 - have to be done explicitly and some
103:02 - can't be done at all when it comes to
103:03 - numeric types these can be automatically
103:05 - converted if the target type can hold
103:07 - that data for example over here let's
103:09 - Define along and over here the value
103:10 - that we put doesn't really matter so it
103:12 - doesn't have to be a massive value and
103:13 - then if we Define an INT and we try
103:16 - assigning this int onto the one that we
103:17 - had inside long and nope this does not
103:20 - work if we look at it we see the error
103:22 - which is you cannot impl ently convert
103:23 - the long onto an INT the reason for that
103:25 - once again goes back into this chart the
103:27 - long type this one can store a lot more
103:29 - values than the int can store so because
103:31 - of that the compiler does not let us
103:33 - automatically convert this because the
103:35 - conversion might imply some loss of data
103:37 - and the compiler protects you from that
103:38 - however we can do the opposite since
103:40 - over here the long this one can sore
103:42 - these many values whereas the in can
103:43 - sore this many so basically a long can
103:45 - sort everything inside an INT and a
103:46 - bunch more so because that we can do the
103:48 - opposite so we can Define age Universe
103:50 - inside an INT and then for the long we
103:52 - can put it age Universe in and Yep this
103:54 - one does work again that is because long
103:56 - can store more values than just the int
103:58 - so we have a guarantee that whatever we
104:00 - Define inside the end can be stored
104:02 - inside a long and then same thing for
104:03 - doubles and floats doubles have more
104:05 - Precision so we can store a float inside
104:07 - a double but we cannot do the opposite
104:09 - and also like we saw we cannot have an
104:11 - INT and assign it some kind of decimal
104:13 - value this does not work however like
104:15 - the error says here these are implicit
104:17 - conversions however we can be explicit
104:20 - and it will force a conversion even
104:22 - though it might end up with lot of data
104:23 - and the way we do that is we just cast
104:25 - it onto a type so we open parentheses we
104:27 - put the target type and then close it so
104:29 - this is a cast I'm actually going to
104:30 - cover casting in more detail later on
104:33 - this course if we do it nope we no
104:34 - longer have an error however like I said
104:36 - you might end up with a loss of data for
104:38 - example over here we are forcing the
104:40 - 35.5 to be placed inside an INT so let's
104:42 - see what this actually returns so let's
104:44 - do a console. right line let's see what
104:46 - this prints and if there go it prints 35
104:48 - since ins can only store whole numbers
104:50 - basically when it gets to decimal point
104:51 - it just ignores everything out of it
104:53 - importantly it does not round the value
104:55 - so even if I put this 35.9 nope it still
104:57 - says just 35 so basically when we are
104:59 - forcing the conversion onto an INT it is
105:01 - basically going to ignore everything
105:02 - after the decimal point now on this
105:04 - topic one of the most common mistakes
105:06 - that beginners make is actually when
105:07 - dividing inss so for example let's say
105:09 - the player has some kind of health and
105:11 - it's stored in an in let's say they
105:13 - currently have one Health and then let's
105:14 - say they've got a health max and the
105:16 - health max is 10 and then you're trying
105:18 - to normalize this value so you do Health
105:20 - divide by health max so now what do you
105:22 - think this will actually output in
105:24 - theory the mathematical answer would be
105:26 - 0.1 so we've got 1 divid by 10 that
105:28 - should be 0.1 but nope here the result
105:30 - is zero again it's the exact same reason
105:32 - it's because of type limitations we are
105:34 - dividing an INT by another int so the
105:36 - result of that cation will also be an
105:38 - INT and inside an end we cannot store
105:39 - the value 0.1 so it does the same thing
105:41 - that we saw a while ago it ignores the
105:43 - decimals and just sores the whole number
105:45 - which in this case just ends up storing
105:46 - zero now in solution this problem is
105:48 - really simple we just need to convert
105:49 - one of these values into a float so we
105:51 - can just cast it onto a float so now
105:53 - here we have some math doing between a
105:54 - float and int so the final result will
105:56 - be a float and if we test yep now it
105:58 - does return the correct result 0.1 so if
106:01 - you ever have any strange results when
106:02 - doing calculations always double check
106:04 - that you're using the correct type so
106:05 - you're not losing any data and like I
106:07 - said there are some types you can
106:08 - convert even with a cast for example you
106:11 - cannot forcefully cast a false onto an
106:13 - INT this does not work and same thing
106:15 - for a string onto a number nope this
106:17 - does not work if you do want to convert
106:18 - a string onto a number for that you have
106:20 - two methods one method is using a class
106:22 - called called convert and then inside it
106:24 - converts a whole bunch of functions in
106:26 - order to convert from all kinds of types
106:28 - like for example convert to n32 which is
106:30 - going to be the regular int the N64 this
106:33 - one is going to be the long and the n16
106:34 - this one is the short if you're
106:35 - wondering what those numbers are it's
106:37 - over here it's the size of the actual
106:39 - value so the int that is a 32bit int
106:41 - whereas the long is a 64-bit and so on
106:43 - and on the right side we can actually
106:44 - see the full name for the types what we
106:46 - see on the left typ is usually what we
106:47 - use but these are really just aliases
106:49 - the actual types are the ones over here
106:50 - so an INT is really a system. in 32 the
106:53 - long is R system. N64 and so on so
106:56 - anyways yep here we have a whole bunch
106:58 - of functions and again don't worry about
106:59 - what our functions for now I will cover
107:01 - them in detail in future lectures but if
107:03 - we were to use this function then we can
107:05 - convert the value 56 into the health and
107:07 - Yep this does work although of course
107:08 - this only works if the ring actually has
107:10 - number if you write something you
107:12 - actually going to get an error all right
107:13 - so that's a lot of info on variables
107:15 - data types and type conversion this is
107:17 - one of the most important part of the
107:18 - basics of programming so definitely make
107:19 - sure you fully understand this topic
107:21 - before going further if you need go
107:22 - ahead and rewatch this lecture to really
107:24 - solidify this knowledge it is really
107:26 - important that you fully understand
107:27 - variables and types before going any
107:29 - further next we're going to learn
107:30 - another extremely important part of
107:31 - programming if statements and conditions
107:33 - so let's learn that in the next
107:35 - lecture hello and welcome I'm your codm
107:38 - in this lecture we're going to learn
107:39 - about IFL statements and conditions
107:41 - we're going to learn how conditions are
107:43 - evaluated how to do mathematical tests
107:45 - and logical operations so let's learn
107:47 - about ifs and conditions this has to do
107:49 - with one type that we already saw in the
107:50 - previous lecture bullion this is a type
107:52 - that can only be either true or false
107:55 - those are the only two possible values
107:57 - basically we write a condition and then
107:59 - the code evaluates that condition to
108:00 - either true or false now the simplest
108:03 - condition is just equality so for
108:04 - example is one equal to one the answer
108:06 - is yep so when the code evaluates this
108:08 - one it evaluates it to true and if we
108:10 - check is one equals to two that is
108:12 - obviously false one is not equal to two
108:13 - so this one evaluates a false then we
108:15 - can use these conditions inside an if
108:17 - the if has a condition and then a code
108:19 - block and if the condition is true then
108:20 - it is going to execute this code block
108:22 - and if it is false then it does not
108:24 - execute this codee block and again going
108:25 - back to what I mentioned in the
108:26 - programming Basics lecture the code
108:28 - executes from top to bottom so first it
108:30 - executes this if then checks the
108:32 - condition and the condition is true so
108:34 - it goes inside and executes the code
108:35 - inside then goes back outside then
108:37 - executes this if checks the condition
108:38 - this one is false so it skips that one
108:40 - and continues running afterwards so the
108:42 - code is still executing from top to
108:44 - bottom as usual but by using ifs we can
108:46 - control what code actually runs when
108:48 - here is a visual demo in the interactive
108:50 - exercises we've got a simple if
108:52 - condition test in if a distance is under
108:54 - a certain amount if so then we're going
108:55 - to set this target color to green and if
108:57 - not we're going to set it to White so I
108:58 - can click to move the player and as the
109:00 - distance goes under that amount yep that
109:02 - one turns green and if goes above then
109:04 - that one turns white so depending on
109:06 - whether this condition is true or not it
109:07 - is running either this line or this line
109:09 - of code here in the code let's see our
109:10 - syntax and the syntax for an if is
109:12 - really simple we just write if and again
109:14 - remember how code is case sensitive so
109:17 - it is not if all uppercase it is not
109:19 - uppercase and lower case it is neither
109:21 - of these instead it is if on lowercase
109:23 - again very important if you write it
109:25 - properly it should change color then we
109:27 - write the condition inside parentheses
109:29 - remember to have a matching closing
109:30 - parenthesis for every opening the
109:32 - condition can be all kinds of things
109:34 - they will eventually be evaluated into a
109:36 - bullan so either true or false so over
109:38 - here we can just write through for
109:39 - testing so we have if then the condition
109:41 - and then we just do a code block and
109:43 - this is the code that will be executed
109:44 - if the condition is true so for example
109:46 - over here just say console. right line
109:48 - let's say inside if and if we run this
109:50 - and if there it is we are inside the if
109:52 - so we did run that code whereas now if
109:54 - instead of true if we change this into
109:55 - false and run it and if now that one
109:57 - does not run because that one is false
109:59 - so the code goes to execute this line
110:01 - then it says this condition is false so
110:02 - it is going to skip this one and
110:03 - continue afterwards now it obviously
110:05 - doesn't make much sense manually write
110:07 - either true or false over here on the
110:08 - condition usually you want to test some
110:10 - kind of thing some kind of proper
110:11 - condition and the most basic thing is
110:13 - simply mathematical operations so if we
110:15 - test 1 equals 1 if we test this if that
110:18 - is inside goes inside the if
110:19 - alternatively instead of just equality
110:21 - we can simply do some meth medical
110:23 - operations like for example let's see if
110:25 - we are testing if two is bigger than one
110:27 - so pretty simple and the result of this
110:28 - test is true since two is indeed bigger
110:30 - than one so if we run this yep there's
110:32 - our message it works basically what the
110:33 - code is doing is when it gets over here
110:35 - to the if it gets to this condition then
110:37 - it evaluates this condition and again it
110:39 - is going to evaluate in whether true or
110:40 - false and then if it is true goes inside
110:42 - it if it is false skips it there's a
110:44 - bunch of mathematical operations you can
110:45 - do you can do bigger than he can do less
110:47 - than he can do bigger or equal less than
110:50 - or equal so all the standard
110:52 - mathematical operations and of course
110:54 - over here I'm using values directly but
110:56 - you could replace this with a variable
110:57 - so like n for the age 35 then let's say
111:01 - if age is under or equal to 40 and yep
111:03 - obviously this works so you have all
111:05 - kinds of operations and then you also
111:07 - have the equals now here's another
111:08 - extremely extremely important thing when
111:10 - you want to test for equality you do a
111:12 - double equals not just one it's a double
111:15 - equal sign the single equals this one is
111:17 - meant for assignment like for example we
111:19 - Define a variable then we do a single
111:21 - equals and we are assigning the value 35
111:23 - onto our variable but when we want to
111:24 - test for equality we do a double equals
111:27 - again this is very important this is a
111:28 - mistake that a lot of beginners do they
111:30 - do something like a single equals and
111:31 - they have no idea why there's an error
111:33 - over here the error isn't very helpful
111:35 - it says in left hand side of the
111:36 - assignment must be a variable so if
111:37 - you're a beginner this makes no sense
111:39 - but that's because the single equals
111:40 - this one stands for assignment and
111:42 - double equals this one is for equality
111:43 - and if you try putting that inside a
111:45 - right line so let you Conant that right
111:47 - line if we do age double equals 35 if we
111:50 - do this if there I go that does return
111:51 - true however if now we put just a single
111:54 - equals and if now instead of either true
111:55 - or false it just says 35 that is because
111:57 - the single equals this one is assigning
111:59 - the value over there and it's not
112:00 - actually doing any comparison so again
112:02 - don't make this mistake single equals is
112:04 - for assignment and double equals is for
112:06 - equality so related to equals is the not
112:08 - equal sign and for this one we do an
112:10 - exclamation point and then an equals so
112:12 - the exclamation point means not so not
112:15 - equals so in this case this one will not
112:17 - run because one is equals to one so one
112:19 - not equals one is false whereas if we
112:21 - put a two one does not equal two yep
112:23 - that's true so yep it does run and of
112:25 - course over here we can simply use
112:26 - bulling variable so bull is player let's
112:29 - define this as true and then over here
112:31 - just if is player if so then Yep this
112:33 - works so over here we have the code
112:35 - block that is going to execute if the if
112:37 - condition is true and then we have
112:39 - another keyword that we can add after
112:40 - the if we can add the keyword else and
112:42 - then another code block and now this
112:44 - code block will execute if the first if
112:46 - is not true so let's do another right
112:48 - line inside else and over here we Define
112:51 - players true then we test if is player
112:53 - so it is going to be inside this one so
112:54 - it is not going to run this one if we
112:56 - test if there you go it just says inside
112:57 - the if but then if I swap player to
112:59 - false so now it is not going to run the
113:01 - if and instead it's going to run the
113:02 - else if that it is just like that so for
113:04 - example instead of having two ifs like
113:06 - if is player and if not is player which
113:08 - by the way the not equals that one can
113:10 - also be applied like this if you put the
113:12 - exclamation point that is basically
113:13 - going to negate whatever comes
113:14 - afterwards so over here we have not is
113:16 - player so we are testing if it is player
113:18 - or not is player which is really the
113:20 - same thing so if you want to test this
113:22 - kind of thing then using an else makes
113:23 - it much simpler that's exactly what the
113:25 - code over here in the demo is doing it
113:26 - is testing if distance is under four and
113:28 - if so then it's going to set the target
113:30 - color to Green if not it is going to set
113:32 - it to White if I had not written this
113:34 - else statement then as soon as became
113:35 - green even if we stood outside of it it
113:37 - would not change it back whereas like
113:38 - this if it's inside turns green if not
113:41 - else it turns white and now here we are
113:43 - testing a single condition but we can
113:45 - also combine multiple conditions let's
113:47 - say for example we want to test if two
113:48 - is bigger than one and if three is
113:51 - bigger than one the way we write a
113:52 - logical land is just like this with two
113:54 - ense again it's very very important just
113:57 - like the double equals this is a double
113:59 - ense if you put just one this is a
114:01 - completely different operation this is a
114:03 - bitwise end which is something that I
114:04 - covered in the advanced portion of this
114:06 - course but over here for a logical end
114:08 - we do not want just one so we want two
114:10 - of them again don't make this mistake so
114:12 - let's see what this outputs and if there
114:14 - it is it runs the code inside the if so
114:17 - basically here we have two conditions
114:18 - and when the code gets to this point it
114:20 - is basically going to evaluate each
114:21 - condition from from left to right so
114:23 - first evaluates this one is two bigger
114:25 - than one the answer is yes so this one
114:26 - evaluates true and is three bigger than
114:29 - one the answer is also yes so this one
114:30 - also evaluates the true and then we've
114:32 - got an end operation between a true and
114:34 - a true and this end operation the output
114:37 - of this one will only be true if both
114:39 - conditions are true which is the case
114:41 - over here so that's why this one runs
114:42 - inside the F if we change one of these
114:44 - so let's say true and false if so then
114:47 - the output for this one will be false so
114:48 - it is not going to run this one instead
114:50 - it's going to run the else in order to
114:51 - know what combinations make true or
114:53 - false you can look at what is called a
114:55 - truth table so over here we've got the
114:57 - values A and B and then we've got the
114:59 - result of doing an and operation or an
115:01 - or operation between both those A and B
115:04 - can be either true or false which by the
115:06 - way sometimes true or false is
115:07 - represented as simply ones and zeros so
115:10 - 0 equals false and one equals true
115:11 - really just different representations of
115:13 - the same thing so over here we have the
115:15 - end operator and like I said the end
115:17 - this one is only true if both conditions
115:18 - are true so if a is false and B is false
115:21 - both are are false so the end output is
115:23 - going to be false if a is false but B is
115:26 - true again we still don't have the
115:27 - condition that both them are true so the
115:29 - output is still false same thing over
115:30 - here if a is true B is false the output
115:32 - is still false it is only if we have
115:34 - both A and B both of them are true if so
115:37 - then the output of the end is also true
115:39 - so the result of an and is only true if
115:41 - both components are true then the other
115:43 - operation that we can see here is the or
115:45 - operator this one is going to be true if
115:47 - either A or B is true so if both them
115:49 - are false if so then the or is going to
115:51 - be false but if just one of them is true
115:53 - then the output of the or is going to be
115:54 - true or if both of them are true if so
115:57 - then the output is also going to be true
115:59 - over here in the code the way we write
116:00 - an or operator is denoted by two pipes
116:03 - again pay close attention to the fact
116:05 - that it is two if you write just one
116:06 - this is a completely different operation
116:08 - this is another bitwise operation which
116:10 - again I cover in detail in the advanced
116:11 - section so also pay close attention here
116:13 - it is two pipes so this makes an or
116:16 - operation like I said this one is going
116:17 - to run our code block if either of these
116:19 - are true so if this one is true then Yep
116:21 - this one is going to run and yep it does
116:23 - run the r only returns false if both of
116:25 - them are false and if we set this yep we
116:28 - run the code inside the else there is an
116:30 - interactive truth table in the exercises
116:32 - here up top we have the inputs and down
116:34 - here we have the outputs so for the end
116:35 - the end is only true if both are true so
116:37 - if that one is true and false the output
116:39 - is false false true that one and if both
116:41 - are true that one is true the or is only
116:43 - true if either of them are true so if
116:45 - either of these are true the output is
116:46 - going to be true and the not simply
116:48 - inverse it so if it's false become true
116:50 - and if it's true becomes false now these
116:52 - conditions doing an or or an and doing
116:54 - this always works just between two
116:56 - elements but you can also have multiple
116:58 - conditions not just two you can have as
117:00 - many conditions as you want so here in
117:02 - true or false you can have as many as
117:04 - you want however it's also important to
117:06 - know they are evaluated from left to
117:07 - right meaning that whenever doing some
117:09 - kind of or or and operation it is always
117:11 - done just between two conditions so when
117:13 - the code gets here first it evaluates
117:15 - this one and gets a result from this
117:16 - evaluation then after having that result
117:18 - then it does the result of this one
117:20 - alongside the result of that one and
117:21 - finally from this one along with the
117:23 - result of all these so it does all those
117:25 - evaluations and importantly always from
117:26 - left to right so for example let's write
117:28 - if 1al 2 or 1 equal 1 and 5 is bigger
117:34 - than one so if we have these conditions
117:36 - if you want pause the video and try to
117:37 - figure out if the code is going to run
117:39 - or not like I said left or right so
117:40 - first it evaluates this one does one
117:42 - equal two the answer is no so this one
117:44 - evaluates into false then it is going to
117:46 - evaluate this one does one equal one the
117:48 - answer is true yep then it's going to do
117:50 - an or operation between false or true
117:53 - and again the or is true if just either
117:55 - of them is true so in this case this one
117:56 - outputs is true then it evaluates this
117:59 - one is five bigger than one that is true
118:01 - and then we have a true and true this
118:03 - one returns true and yep we do run this
118:05 - code then if you want you can also have
118:06 - more control over the order of testing
118:08 - simply by using parentheses just like
118:10 - you do in normal math so for example
118:12 - let's write some code like this so for
118:14 - example we have false or true this one
118:16 - is going to evaluate in true then it's
118:18 - going to do true and false that is going
118:20 - to evaluate to false and then then false
118:22 - or true that is going to evaluate in
118:24 - true so it is going to run this one so
118:25 - over here we can add some parentheses so
118:27 - we want to do this condition first and
118:29 - then this condition first and this way
118:31 - first it is going to evaluate theu then
118:33 - evaluate theu and only then evaluate the
118:35 - whole thing another important thing is
118:36 - also how conditions can short circuit
118:38 - meaning let's say we have an or and with
118:41 - an or it is going to return true if
118:43 - either of them is true so if we have
118:45 - true or false or actually in this case
118:47 - let's put some proper conditions so one
118:49 - bigger than two that is going to be
118:51 - false and two bigger than one so if we
118:53 - have this basically over here two bigger
118:54 - than one this going to evaluate to True
118:56 - one bigger than two this going to
118:57 - evaluate to false now like I said the or
118:59 - this one is going to be true when either
119:01 - of them is true so when the compiler
119:03 - starts to evaluate these conditions it
119:05 - starts to evaluate the first one again
119:06 - left to right and evaluates this one
119:08 - into true and since that is the case the
119:10 - compiler is smart enough to know not to
119:12 - waste any power on evaluating this
119:14 - second condition because the first one
119:15 - is true then it's already going to run
119:17 - inside the if so after here we can have
119:19 - a bunch more Ores and it does not matter
119:21 - the compiler would only test this one
119:23 - since this one is true it just ignores
119:24 - everything after this however on the
119:26 - other hand if we have an end if so then
119:29 - it's going to valid this one this one is
119:30 - true but then the end is only true if
119:33 - both of them are true so it cannot stop
119:35 - executing here it needs to execute this
119:36 - one in order to see if it's true or
119:37 - false in order to know does it run
119:39 - inside if or not so in this case the
119:41 - short circuit for the end would be if
119:42 - this one is false if this one is false
119:44 - right here then doesn't even bother
119:45 - evaluating this condition because if the
119:47 - first one is false then the end is
119:48 - always going to return false this is the
119:50 - kind of thing that becomes really
119:51 - important in some performance intensive
119:52 - applications especially when you're
119:54 - running some expensive function to test
119:55 - something for example if you have true
119:58 - or and then over here you've got some
120:00 - kind of function that costs quite a lot
120:02 - in terms of performance if so then the
120:03 - compiler is going to be smart enough and
120:04 - it's not even going to waste any time
120:06 - running this condition because the first
120:07 - one is already true now over here let me
120:09 - also make one quick note ifs technically
120:11 - do not require a code block so if you
120:13 - just have an F without an else if so
120:15 - technically you can just do this so you
120:16 - can raise the code block and just write
120:18 - the condition afterwards if you have
120:20 - just a single instruction inside the if
120:21 - then this is perfectly valid code so
120:23 - let's put this one true so it goes
120:24 - inside and if there you go it does run
120:26 - the code inside the if however I highly
120:28 - highly advise you to always write a code
120:30 - block the reason is simply because it is
120:31 - very easy to write an if like this and
120:33 - then later on you want to write another
120:35 - instruction so let's say inside if2 so
120:38 - you add this but you forget the righty
120:39 - code lock and you assume this one is
120:41 - still going to run inside the if and in
120:43 - this case if we try running this we do
120:44 - see if and then the F2 but if we change
120:47 - this into false ideally we would not
120:49 - want either of these to run but yep the
120:51 - second one does run that is because if
120:52 - you don't include a code block then the
120:53 - only thing that is considered to be
120:55 - inside the if is just the next line
120:56 - immediately afterwards remember that in
120:58 - C identation does not matter so the fact
121:00 - that this one has as many spaces that
121:02 - does not matter at all the only thing
121:03 - that matters are code blocks and
121:05 - semicolons if you don't include a code
121:07 - block then basically just executes a
121:08 - code inside the if which is going to be
121:09 - until the first semicolon till the first
121:11 - instruction so in order to avoid this
121:13 - mistake my advice is to always write
121:15 - code blocks in all your ifs so always
121:17 - put it like this even if you have just
121:18 - one instruction inside it and speaking
121:20 - of ination like I said it does not
121:21 - matter so you can event the code like
121:23 - this or do anything crazy anything you
121:25 - want as far as the compiler is concerned
121:27 - all this is valid code inside this if
121:29 - but for your own personal sanity
121:30 - definitely make sure to take some time
121:31 - to ENT things properly now here we have
121:33 - our ifs and we saw the else as well
121:36 - something we can do is simply chain ifs
121:38 - so let's do an if true and then else and
121:40 - after the else we can write if
121:42 - immediately afterwards so for example
121:44 - here's some code we Define some kind of
121:45 - age then we do the first if testing if
121:47 - age is under 20 in this case it is not
121:49 - so we're just going to run the else
121:51 - related to this if and then inside that
121:52 - else we've got another if so if under 30
121:55 - meaning the code inside here is going to
121:56 - run if the age is not inside this if so
121:59 - if it's above or equal to 20 and under
122:01 - 30 and if not then it's going to go into
122:03 - the else connected to this if and
122:05 - finally run this line of code and if we
122:07 - test Y correct ag35 is indeed above 30
122:10 - so you can chain a bunch of L FS
122:12 - together or you can simply just do a
122:14 - bunch of ifs or if we want we can also
122:16 - chain a bunch of them just like this so
122:17 - basically just having some ifs one after
122:19 - the other Yep this is also perfectly
122:21 - valid code all right so here we learned
122:22 - about ifs and the last thing that we did
122:24 - was chain a bunch of ifs together this
122:26 - code works correctly we have all of our
122:28 - ifs one after the other but with this
122:29 - many ifs it becomes really hard to
122:31 - understand what the code is doing so to
122:32 - solve this particular problem we have
122:34 - another way to run conditional logic
122:35 - which is by using a switch so that's
122:37 - what we're going to cover in the next
122:38 - lecture hello and welcome I'm your Cod
122:41 - Mony in this lecture we're going to
122:42 - learn about the switch this lets us very
122:44 - easily test comparisons against multiple
122:46 - possible cases okay so here we have the
122:48 - code that we wrote in the previous
122:49 - lecture we have a bunch of ifs chained
122:51 - together technically this works but it
122:53 - becomes a bit hard to read to do this
122:55 - kind of logic there is a much better way
122:56 - when we want to test multiple different
122:58 - cases and for that we want a switch to
123:00 - do that first we write switch and then
123:02 - we write the value or variable that we
123:04 - want to use in our comparison so in this
123:06 - case let's use the same name variable
123:07 - then we open and close our code block
123:09 - and now inside here we write case and
123:11 - then afterwards what we want to compare
123:13 - against so in this case let's compare
123:15 - against the name Code Monkey then we do
123:17 - a colon and down here we write whatever
123:19 - code we want to execute if the switch
123:21 - variable matches this value so let's do
123:23 - the exact same thing and finally we end
123:24 - the case by using a break yep just like
123:27 - this this is a valid switch case let's
123:29 - just add the other two yep just like
123:31 - this so basically what we have down here
123:33 - is exactly the same thing as we have up
123:34 - here except instead of having a ton of
123:36 - separate ifs we just have a switch we
123:38 - just write our name variable once and
123:40 - then individually each value we want to
123:42 - compare against and if the value in here
123:44 - it exactly matches the one here then
123:46 - it's going to run this code if it
123:47 - perfectly matches this one it's going to
123:48 - run this one and so on basically when
123:50 - the code gets to this line it is going
123:52 - to grab whatever value is stored inside
123:53 - of name then it's going to compare
123:55 - against each one of those cases and when
123:57 - it finds a match like this one then the
123:59 - code goes inside and runs this line of
124:00 - code then when it reaches the break this
124:02 - one tells it to break out of the switch
124:04 - so it skips all of these and jumps and
124:06 - continues executing down here basically
124:07 - the switch is really great when you want
124:08 - to compare one value against many
124:10 - different values it is much simpler to
124:12 - use a switch as opposed to a ton of if
124:14 - eles then the switch also has a special
124:16 - case called default and basically the
124:18 - code here is going to run if the value
124:20 - that we choose up here doesn't not match
124:22 - any of the values inside any of the
124:23 - cases if it does not match any of them
124:25 - it is going to run the default so here
124:27 - is the interactive demo I've got a bunch
124:28 - of buttons up here that I can use to
124:30 - modify the string name and Y we can see
124:32 - which switch is going to run so if the
124:33 - name is code Mony then it's going to run
124:35 - this case and it's going to change the
124:36 - outline color into white if I click on
124:38 - irman then the name is now irman so it's
124:40 - going to run this one and put the
124:41 - outline in white and put the outline in
124:43 - yellow if I choose black wiow it's going
124:45 - to run this one and if I choose
124:46 - Spider-Man which does not match any of
124:48 - these three if so then it's going to run
124:49 - default and run like this now if you
124:51 - forget to write a break so if I remove
124:53 - this technically this is still valid
124:54 - code as long as there's it this one
124:57 - causes an error it tells you that
124:59 - control cannot fall through from one
125:00 - case label onto another one however if
125:03 - we raise this line of code yep now this
125:05 - one is perfectly valid so if up here I
125:07 - change the name into Iron Man let's see
125:09 - what this code runs and if it says hello
125:10 - black widow basically what this is doing
125:12 - is if the value up here matches either
125:14 - this case or this case if it matches
125:16 - either of those then it's going to run
125:18 - this line of code so you can have
125:19 - multiple cases run the same line of code
125:21 - although normally you usually want the
125:23 - code to execute only the code inside
125:25 - that case you want each value to execute
125:27 - a different thing so in most cases you
125:29 - want to use a break at the end of each
125:30 - one that way it is very clear what code
125:32 - runs on what case also if you don't
125:34 - assign a default so if I raas this and I
125:37 - put let's say Spider-Man if I put it
125:38 - twitch does not match any of these cases
125:40 - then y it simply does nothing so if it
125:42 - does not match any of the cases then
125:43 - nothing inside the switch runs and just
125:45 - continues running afterwards and over
125:46 - here I'm using a string but you can use
125:48 - literally almost anything else like an
125:49 - in or a sh so we can do int age and then
125:52 - do a switch do a switch on the age and
125:55 - inside do the same thing so K 10 and
125:57 - over here we've got h10 we can do a
125:59 - default we can do all kinds of things
126:01 - and yep all of this works okay so here
126:02 - we learned about the switch which is
126:04 - extremely useful next let's finally
126:06 - learn one extremely powerful feature in
126:07 - any programming functions so let's learn
126:09 - about those in the next lecture hello
126:12 - and welcome I'm your codm in this
126:14 - lecture we're going to learn all about
126:15 - functions this is an extremely crucial
126:17 - thing so make sure you fully understand
126:19 - everything in this lecture so functions
126:20 - are another core Concept in programming
126:22 - a function is basically putting some
126:24 - code inside a box so let's say over here
126:26 - we've got a bunch of code this is all in
126:28 - just one main function this is our
126:30 - entire program but instead we can build
126:31 - like this we basically put some code in
126:33 - a separate box so this is going to be
126:34 - our function and then we can easily call
126:36 - that function meaning run the code
126:38 - inside that box by just calling one line
126:40 - of code one big benefit of this is
126:42 - simply organization our code becomes
126:44 - much easier to understand if we have
126:45 - some clear functions with some clear
126:47 - names that do one very specific thing
126:49 - that is much better for organization as
126:50 - opposed to having a giant wall of text
126:52 - for your entire program another big
126:53 - benefit is how it cuts down on copy
126:55 - pasted code without functions we would
126:57 - need to write the function code every
126:59 - time we wanted that behavior so for
127:00 - example let's say here we got some code
127:02 - that we are copy pasting and repeating
127:04 - three times right away it's bad that we
127:06 - are copy pasting the same code multiple
127:07 - times but even worse than that is
127:09 - imagine if we wanted to modify some
127:11 - behavior on on this code that we are
127:13 - repeating multiple times in order to
127:14 - modify it we need to apply those
127:16 - modifications to every single version
127:18 - every single place where we are calling
127:19 - essentially the same code whereas if
127:21 - we're using a function it doesn't matter
127:22 - how many times we call it if we need to
127:24 - modify anything in this logic we just
127:25 - modify it in one place and automatically
127:27 - updates in every other
127:29 - place also just one quick note like I've
127:31 - said several times code runs from top to
127:33 - bottom and that is still true when it
127:35 - comes to functions except the code jumps
127:36 - around a little bit so it starts
127:38 - executing up here executes all these and
127:40 - gets to the function and then it jumps
127:41 - inside the function then it runs the
127:43 - code top to bottom from that function
127:45 - and when it reaches the end basically
127:46 - goes back and continues executing from
127:48 - there so the execution jumps around a
127:50 - bit but it's still pretty much the same
127:51 - in terms of working from top to bottom
127:53 - and now before we see the Syntax for
127:54 - functions we should look into the other
127:56 - more advanced template so far we've been
127:58 - using this really basic template where
127:59 - we just write our code here this is
128:01 - really great for the basics but by now
128:03 - we already have enough knowledge to be
128:04 - able to use the more thorough template
128:06 - so go ahead and open up visual studio
128:08 - then let's go to create a brand new
128:09 - project once again let's pick a console
128:11 - app you should be able to see it on the
128:13 - recent project templates or again search
128:15 - for it and again remember it's this one
128:16 - with the c icon it is not the one with
128:19 - vision basic or F and it is not the one
128:21 - with NET Framework it is the one that
128:23 - just says console app in C so let's pick
128:25 - this one then let's give it some name
128:26 - I'm going to go with Code Monkey C
128:28 - course place it anywhere and leave it
128:30 - the same solution name let's go next
128:32 - then over here yep let's use net8 and
128:34 - importantly is over here let's make sure
128:35 - to take this box we do not want to use
128:37 - the top level statements which is the
128:38 - simplified template we don't want to use
128:40 - that we want to use the standard code so
128:42 - that's it just like this let's head on
128:43 - Create and up here is the brand new
128:45 - template for now you really don't need
128:46 - to worry about the specifics of this so
128:48 - don't worry about what is a namespace
128:49 - what is a class what is static and so on
128:51 - for now you can ignore all that just
128:53 - know that the only difference in this
128:54 - template is all the code that we've been
128:56 - writing right now we would simply write
128:57 - it directly in here inside the main
128:59 - function if we run this we should see
129:00 - the exact same hello world if there it
129:02 - is Hello World exactly the same as
129:03 - previously the one very important thing
129:05 - is here being very careful over where
129:07 - you writ your code meaning it needs to
129:08 - be over here inside the main function
129:10 - inside this code block it cannot be for
129:12 - example over here just inside the class
129:14 - code block this does not work this
129:16 - causes an error and it also cannot be
129:18 - outside here inside namespace or
129:20 - completely outside of anything so all
129:21 - the syntaxes all still exactly the same
129:23 - as we've been seeing so far just make
129:25 - sure to write it over here directly
129:26 - inside the main function and now before
129:28 - we see the syntax ins set a function
129:30 - those are usually referring to the exact
129:31 - same thing technically in C the correct
129:33 - term is Method but both terms are really
129:35 - used interchangeably sometimes I call
129:37 - them functions sometimes I call them
129:38 - methods just know that in most cases
129:40 - when someone says either term they're
129:42 - really referring to the same thing now
129:43 - in order to define a function We Begin
129:45 - writing let's say outside the main
129:46 - function again it's very important that
129:48 - you write the code in the correct place
129:49 - we want to start writing over here
129:51 - which is after closing the main code
129:53 - block but still inside the class code
129:56 - block so inside this one but outside the
129:58 - main So Right Here We Begin by defining
130:00 - the data type that we're going to return
130:01 - from that function if we don't want to
130:03 - return any data we can use a special
130:05 - type called void void means nothing so
130:07 - pretty much exactly the same thing as
130:08 - our main function here which also does
130:09 - not return anything so we have the
130:11 - return type and then we give the
130:12 - function some kind of name I'm actually
130:14 - going to talk about the importance of
130:15 - good names later on in the course in a
130:17 - dedicated lecture it is an extremely
130:18 - important thing you should always always
130:20 - give it a proper name name and not
130:21 - something that has no meaning like for
130:22 - example just the letter X if you do that
130:24 - then you have no idea what that is
130:25 - actually doing so over here let's give
130:27 - it a proper name let's say we want to
130:28 - make a function that just prints hello
130:30 - to the console so let's give it a proper
130:31 - name and just call it say hello so
130:33 - that's the name of our function and then
130:34 - we open our parentheses and inside we
130:36 - add any parameters that we want our
130:38 - function to have although optionally we
130:39 - can also have it with no parameters so
130:42 - let's just close the parenthesis again
130:44 - always keep in mind matching opening and
130:45 - closing so we Define this and then we
130:47 - just write our code block so just
130:48 - currently braces open and close and yep
130:50 - over here we have the function code now
130:52 - here we can write whatever code we want
130:54 - our function to do so for example let's
130:55 - just do a simple console. right line and
130:58 - let's just print out hello all right yep
130:59 - that's it pretty simple here we have
131:01 - defined a function also just one more
131:03 - thing in order for our demo to work we
131:04 - actually need to mark this function as
131:06 - static so over here we need to write
131:08 - static just like we have on the main now
131:09 - like I said a while ago for now don't
131:11 - worry about understanding static I will
131:12 - cover it in detail later on the course
131:14 - for now just know that in order for our
131:16 - code to work we need both the main
131:17 - function and the say hello function we
131:19 - need both of these to be marked as
131:20 - static okay so our function is ready
131:23 - however if we try running this and if we
131:25 - still just see Hello World we do not see
131:27 - our second function hello that's because
131:29 - over here we are defining the function
131:30 - but we didn't actually run it remember
131:32 - how code executes it executes from top
131:34 - to bottom and the entry point is over
131:35 - here inside the main function so right
131:37 - now all our program is doing is it
131:38 - starts executing over here then runs
131:40 - this one prints hello world onto the
131:42 - console and it reaches the end the main
131:43 - function and it Clos our program so just
131:45 - defining a function doesn't actually do
131:47 - anything we need to actually call it or
131:49 - run that function and in order to do
131:50 - that we just need to write our function
131:52 - name so let's say say hello and then the
131:54 - parentheses for any parameters which in
131:55 - this one doesn't have any so let's just
131:57 - open and close and again terminate our
131:59 - instruction with a semicolon also again
132:01 - very important remember how code is case
132:02 - sensitive so you have to write the name
132:04 - of the function exactly if I replace
132:05 - this age with a lowercase age nope does
132:08 - not work at Reddit squiggling line needs
132:10 - to be perfect if I replace the S with s
132:12 - nope does not work so always remember
132:14 - code is K sensitive so just with this if
132:16 - we test and yep we do see Hello World
132:18 - and then hello so basically like I
132:20 - showed in the diagram
132:21 - the code is running from top to bottom
132:23 - so starts executing here then goes to
132:25 - execute this one which in turn cause the
132:26 - execution to jump onto this one and when
132:28 - this function terminates then it goes
132:30 - back into the original execution which
132:32 - in turn simply finishes the program
132:34 - another extremely useful thing about
132:35 - functions is simply how you can call
132:36 - them as many times as you want so for
132:38 - example let's make a bunch more
132:40 - instructions over here let's print out
132:42 - hello vertically okay just like this now
132:45 - let's say we want to print this out
132:46 - three times so we could either copy
132:48 - paste the code literally three times but
132:50 - obviously this looks quite messy
132:51 - or using functions we can simply call
132:53 - the function three times and if we test
132:55 - and if there is it did run our function
132:57 - did run our print three times and also
132:59 - like I mentioned diagram if we want to
133:00 - modify any Behavior inside this function
133:02 - we just need to modify it over here just
133:04 - once in the function and basically
133:06 - automatically updates whatever that
133:07 - function is called as opposed to if we
133:09 - were copy pasting we would need to make
133:11 - that modification multiple times so just
133:13 - with this simple example we can already
133:14 - see a ton of benefits from functions
133:16 - they help us organize our code by
133:18 - splitting our code into functions that
133:19 - each do a specific thing and also helps
133:21 - us avoid tons of copy pasted code by
133:23 - putting any code we want inside a
133:25 - function and simply calling it now that
133:27 - we've seen the super basic function next
133:28 - thing are parameters and the way you add
133:30 - parameters is inside the parenthesis
133:32 - parameters are essentially just
133:34 - variables so we start by writing the
133:35 - data type for the parameter let's say we
133:37 - want one of type string so we just write
133:39 - string then we give it some kind of name
133:41 - so let's say a player name again make
133:42 - sure you choose good names that clearly
133:44 - represent what this parameter should be
133:46 - what it should represent and obviously
133:47 - inside this function we can use our
133:49 - player name in any way you want so for
133:50 - example let's say hello and then print
133:53 - out the player name all right yep just
133:54 - like this and now up here we can already
133:56 - see a bunch of errors and the error is
133:58 - saying there is no argument given which
133:59 - also by the way you might hear the name
134:01 - argument instead of parameter these are
134:03 - again these are again sort of
134:04 - interchangeable names just like method
134:06 - and function now technically the
134:08 - definition is that over here when
134:09 - defining the function this one is
134:11 - technically called a parameter whereas
134:12 - when you use it to call something that
134:14 - one is technically called an argument so
134:15 - that's what's technically correct but in
134:16 - reality most people use both terms
134:18 - interchangeably so parameter or argument
134:20 - really refers to the same thing and out
134:22 - here we can see the error and the error
134:23 - says that there is no argument given
134:25 - that requires that corresponds to the
134:26 - required parameter for our player name
134:28 - so inside the parameters we need to pass
134:29 - in a string for our player name we can
134:31 - either pass in a variable so Define a
134:32 - string variable and pass it in or just
134:34 - write over here a string directly so
134:36 - let's say code monkey and Y just like
134:38 - this and if we test and Y it does say
134:39 - hello Code Monkey which of course means
134:41 - that you can call the function multiple
134:42 - times with multiple different parameters
134:44 - and yep it runs the logic with multiple
134:46 - parameters and speaking of multiple we
134:47 - can also have more than one over here
134:49 - we've already seen zero parameters and
134:51 - one parameter but we can have as many as
134:52 - we want you really just add a comma and
134:54 - then again any type of name let's say
134:56 - int age like hello player name you are
134:59 - age years old then over here on say
135:01 - hello just pass in another parameter
135:03 - just like this and if there it is hello
135:04 - Code Monkey you are 35 years old the
135:06 - next very important thing about
135:07 - functions are return types right now we
135:09 - Define this function as returning void
135:11 - and void means nothing so it means that
135:13 - this function doesn't return anything
135:14 - but now let's make a function that does
135:16 - return something let's make a function
135:17 - to Simply add two numbers together to
135:19 - get the result let's play Just around
135:21 - with simple whole numbers so let's put
135:23 - int we're going to return an INT let's
135:25 - call it add numbers then inside
135:27 - parentheses let's add two numbers so
135:28 - let's define int X int y okay like this
135:31 - and right away Visual Studio is showing
135:32 - us an error and it says not on code pass
135:34 - return a value meaning if we Define some
135:37 - kind of return type other than void we
135:38 - have to return something and the way we
135:40 - do that is simply with the keyword
135:42 - return and then whatever value we want
135:44 - to return so in this case adding two
135:45 - numbers let's just do X Plus Y and Y
135:47 - there it is super simple again in order
135:49 - to call this we need to add in static
135:51 - just make sure that it works and out
135:52 - here now we can call add numbers let's
135:54 - add the number one and two and let's see
135:56 - let's actually put this inside a
135:57 - constant out right line just to see the
135:59 - result okay let's test and if there it
136:00 - is the result is indeed three so 1 plus
136:02 - 2 equals 3 another thing you can do is
136:04 - Def find multiple functions with the
136:05 - exact same name they just need to have
136:07 - different parameters either a different
136:09 - number of parameters or different types
136:11 - so here we cannot Define another
136:12 - function named exactly add numbers with
136:14 - also two in parameters we cannot do this
136:17 - but if we swap one of these into B then
136:19 - all of a sudden this function definition
136:20 - is is indeed valid or alternatively if
136:22 - we have int but then we have a final one
136:25 - if we do then Yep this one is also valid
136:26 - and then up here when calling add
136:28 - numbers as soon as you open the
136:29 - parenthesis you see this one and you see
136:31 - one of two so this is basically showing
136:32 - all the various versions of this
136:34 - function so the first version takes an X
136:36 - and A Y both inss and the second version
136:38 - takes x y and Zed and for the types we
136:40 - can just look inside the conso down
136:42 - right line so add the parenthesis and
136:44 - over here we see this one has 18
136:45 - versions so this one takes no parameters
136:47 - this one takes a bullan a character a
136:49 - character way double float and so on and
136:52 - then of course you can also chain
136:53 - functions together so basically the
136:55 - return value this means that whenever
136:57 - this function runs it is going to run
136:59 - this logic and return some kind of thing
137:01 - so just like we saw on the ifs and the
137:02 - conditions basally the code gets it here
137:04 - evaluates this function gets some kind
137:05 - of returned value so for example up here
137:07 - instead of passing in number 35 we can
137:09 - call add numbers and pass in something
137:12 - as long as the return type on this
137:13 - function matches the parameter type as
137:15 - long as it's like that then Yep this
137:16 - works if there it is that's correct and
137:18 - of course we can simply put the result
137:20 - of a function into inside some kind of
137:21 - varable so in number we can just add
137:23 - numbers and now if we do a conso now
137:26 - right line on our number if we do this
137:28 - if there it is it does print the same
137:30 - thing now one very useful type to return
137:32 - from a function is bullion so for
137:34 - example let's make another function
137:35 - let's make it return Bull and let's say
137:37 - for example just is positive we want to
137:39 - return if a certain number is positive
137:42 - let's receive an INT X and we can do if
137:44 - and compare X to two so if X is bigger
137:47 - than or equal to zero I think Z equals
137:50 - as a positive number I'm not sure but I
137:52 - think so so if so then this return true
137:55 - and if not then return false and if
137:58 - there it is and again just in here we
138:00 - need to make sure to add static in order
138:01 - to make this work so now up here let's
138:03 - do a console do right line and let's
138:06 - pass in is positive let's say the number
138:08 - five then let's add a semicolon just
138:10 - separated and let's say is positive and
138:13 - let's say minus Z okay let's see what
138:15 - this does and yep it says true and false
138:17 - so yep that is correct five is indeed
138:19 - positive minus 2 is indeed not positive
138:21 - also by the way here instead of doing
138:22 - these returns instead of doing these ifs
138:24 - instead we can really just return the
138:26 - condition itself so we can just do
138:28 - return and just return the condition so
138:30 - just like this and yep everything still
138:32 - works exactly the same when the code
138:33 - gets it here it is going to evaluate
138:34 - this condition which is going to return
138:36 - true or false and then Returns the whole
138:37 - thing and then prints it out now back
138:39 - over here on the void return type on
138:41 - this one you don't have to call return
138:42 - over here we have no errors however if
138:44 - you want you can also call return and
138:46 - for this one since this returns nothing
138:48 - it returns no type instead of calling
138:49 - return then passing in some value we
138:51 - just call return Then semicolon that's
138:52 - it basically what this will do is it
138:54 - will stop the execution of the function
138:55 - directly at this point so visual studio
138:57 - actually helps us is you can see this
138:59 - line is in a dark ray and that is
139:01 - because like it says here unreachable
139:02 - code detected since we are always
139:04 - calling return over here then this line
139:05 - of code will never ever run speaking of
139:07 - functions and parameters this also a
139:09 - great type to see how things work with
139:11 - regards to value types versus reference
139:13 - types this is something that I cover in
139:15 - detail later on in the intermediate
139:16 - section but I want to make a quick
139:17 - mention up here for example let's keep
139:19 - just he say h hell let's actually get
139:22 - rid of all these okay so let's say I
139:24 - Define an N for the age and let's say I
139:25 - put it at something and then I call say
139:27 - hello and then let's put the exact same
139:29 - thing so that and passing the H and now
139:32 - over here inside the say hello let's do
139:34 - h++ so basically we are incrementing the
139:36 - value of H so when this line of code
139:38 - runs instead of printing 35 it should
139:40 - print 36 but now the important thing is
139:42 - now out here let's say we print out the
139:44 - age again so right line on the H so
139:47 - let's print this one out and now let's
139:48 - see what this one says and if there it
139:49 - is so inside the function it says you
139:51 - are 36 years old but outside the
139:53 - function it says 35 basically what is
139:55 - happening is when we call a function
139:57 - over here when we pass in a parameter
139:59 - when we do that we are actually passing
140:00 - in a copy of the value stored inside
140:02 - this variable so when we increment a
140:04 - variable in here we are really just
140:06 - incrementing the copy and we are not
140:08 - actually modifying the original value
140:09 - that is why when we run here we see 36
140:11 - because we are working with this copy
140:13 - that we did modify but when we exit the
140:15 - function and we run this line of code
140:17 - when we do that we are using the
140:18 - original piece of data which has not
140:20 - been modified again this has to do with
140:22 - the fact that some types like int those
140:24 - aren't passed in as copies meaning that
140:25 - the function receives a copy of the
140:27 - original value and if you modify that
140:29 - inside the function you are modifying
140:30 - the copy and not the original value and
140:32 - then there are other types which are
140:34 - reference types which is going to have
140:35 - some different Behavior those are passed
140:37 - in as reference setad of a copy so for
140:39 - those if you modify them inside the
140:40 - function then you will also modify them
140:42 - outside the function now if you're a bit
140:44 - confused don't worry like I said I talk
140:45 - about in detail about value types versus
140:47 - reference types I talk about what they
140:49 - are and what that actually means later
140:51 - on in the intermediate section right now
140:53 - I really just want you to be aware of
140:54 - that difference when working for example
140:56 - with primitive types like over here the
140:58 - int when you pass it in always remember
141:00 - you are working with a copy so just be
141:01 - aware that if you modify something
141:03 - inside a function it will not
141:04 - necessarily modify it outside the
141:06 - function all right so here we'll learn
141:07 - another really crucial thing about
141:09 - programming functions they are extremely
141:11 - powerful and you will be writing tons of
141:12 - functions with all sort of return types
141:14 - and all sorts of number of parameters so
141:16 - definitely do make sure you fully
141:17 - understand functions before going any
141:18 - further watch this lecture a second time
141:20 - if you need to they are really that
141:21 - crucial and now that we have introduced
141:23 - functions which allows us to have
141:25 - multiple separated code blocks because
141:26 - of that you should really learn the
141:27 - basics of variable scope so let's learn
141:29 - that in the next lecture hello and
141:32 - welcome I'm your Cod monkey in this
141:33 - lecture we're going to learn about scope
141:35 - which covers the lifetime of variables
141:37 - and from where they are accessible okay
141:38 - so scope is very important it's another
141:40 - one of those things that trips up
141:42 - beginners it comes back again to how
141:44 - code is organized in different code
141:45 - blocks and variables defined within a
141:47 - code block can only be accessed by that
141:49 - code block and any child code locks so
141:51 - for example if I Define a variable up
141:53 - here I can indeed access it in here in
141:55 - here in here and here yep it is
141:57 - accessible everywhere however if I
141:59 - Define a variable in here it is
142:00 - accessible from Within These child code
142:02 - blocks but it is not accessible from a
142:04 - completely separate code block and it is
142:06 - not accessible from a code marck that is
142:08 - above it in the previous lecture we
142:09 - covered function so here there is a
142:11 - function and now up here in the main
142:13 - let's define some kind of variable let's
142:15 - say bull is player let's define this
142:17 - variable over here and now if down here
142:19 - on the function if I I try accessing
142:21 - this and modifying it nope this does not
142:23 - work we have an error the name is player
142:25 - does not exist in the current context
142:27 - context is really just another word for
142:28 - scope basically when we Define a
142:30 - variable up here inside the main
142:32 - function code block inside of here we
142:33 - are defining a local variable meaning
142:35 - this variable is player this variable
142:37 - only exists inside this function within
142:39 - this code block as soon as we exit this
142:41 - code block for something else like for
142:42 - example this other function down here
142:44 - that variable literally does not exist
142:46 - this local variable only exists inside
142:48 - this code block and it only also o
142:50 - exists after it is defined again code
142:52 - runs from top to bottom so afterwards we
142:55 - can set is player into true but before
142:57 - we Define it we cannot do this nope this
142:59 - one does not work we cannot use the
143:00 - local variable before it is declared so
143:02 - this is yet another mistake that I see a
143:04 - lot of beginners having trouble with
143:06 - they Define some kind of variable and
143:07 - they have no idea why they cannot use it
143:09 - in a complete separate code block so
143:10 - always remember where you are writing
143:12 - code in which code block and remember
143:14 - that local variables defined within a
143:15 - code block they are not accessible from
143:17 - a completely separate code block also if
143:19 - you define a parameter variable like
143:20 - these two that we have here parameters
143:22 - are also local variables and they also
143:24 - only exist inside this code block so for
143:26 - example if out here after calling say
143:28 - hello if I try to access the player name
143:30 - nope that does not exist because again
143:32 - player name is essentially a local
143:34 - variable which only exists within this
143:35 - code block now these questions of scope
143:37 - apply to complely separate code blocks
143:39 - like these but it also applies to code
143:41 - blocks within code blocks like for
143:42 - example over here if I Define an if if
143:45 - something and then I make a code block
143:46 - within this code block which is
143:47 - essentially a nested code block inside
143:49 - the main within this this one I can
143:51 - indeed access player and do something to
143:52 - it so again back to diagram if we Define
143:54 - something over here we can access it
143:56 - from any nested code block however if we
143:58 - do the opposite so if instead of
144:00 - defining it in there let's say we Define
144:02 - inside that code block and then over
144:03 - here trying to modify it and nope this
144:05 - player does not exist over here it does
144:07 - not exist because the code block where
144:08 - we are writing player the code block
144:09 - inside main that one is a parent code
144:11 - block of the if code block which is
144:13 - where the variable is actually defined
144:14 - so as you go deeper inside code blocks
144:16 - you can access variables that were
144:17 - defined outside of it above it but when
144:20 - outside you cannot access things that
144:21 - were defined inside now if you have a
144:23 - variable that you'd like to access and
144:25 - modify between multiple functions like
144:27 - something that I want to access both
144:29 - inside the main and inside the say hello
144:30 - function for that you can simply make it
144:32 - a class variable I'm going to cover
144:34 - classes and also the static keyword in
144:35 - detail in future lecture so don't worry
144:37 - too much about what they are for now
144:39 - just again remember it's all about code
144:40 - blocks so here we've got the program
144:42 - class and it exists inside this code
144:44 - block and inside this class we have our
144:45 - two functions so just out here we can
144:48 - Define some kind of variable so let's
144:49 - say bull is player and again to make
144:51 - this work we need to mark it as static
144:52 - so with this one defined we can then
144:54 - access it over here inside the main and
144:56 - also over here inside the hello because
144:58 - again these two code blocks are
144:59 - basically nested code blocks of the
145:01 - class code block but on the other hand
145:02 - if we Define a complet separate class
145:04 - then over here on this class which is
145:06 - again another completely separate code
145:07 - block from the one up here if over here
145:09 - we make some kind of function then
145:11 - inside this function code if we try
145:12 - accessing is player nope does not exist
145:14 - because this player does not exist
145:16 - inside this class we Define up here so
145:18 - it only exists inside this program class
145:20 - and any nested functions so in general
145:22 - if you ever find some kind of issues if
145:23 - you ever see this error message saying
145:25 - that some kind of variable does not
145:26 - exist in the current context if so then
145:28 - always double check your code to make
145:30 - sure that the variable that you are
145:31 - trying to access you can actually access
145:33 - it from wherever you are trying to
145:34 - access if you do want to pass in some
145:36 - data some kind of local variable to
145:38 - within a function if you want to do that
145:40 - then you can literally do exactly what
145:42 - we've been doing so you define a
145:43 - function with some kind of parameter you
145:44 - def find the local variable over here
145:46 - and then simply put it in there and then
145:47 - again remember the thing that I
145:48 - mentioned in the previous lecture about
145:50 - how parameters these are really copies
145:52 - so if we do h++ in here it is actually
145:55 - not going to modify this one so if you
145:57 - did want to modify that one you would
145:58 - simply return some kind of thing so
146:01 - return the age and up here simply put
146:03 - age equals that and now if we do a
146:05 - console out right line on our Ag and if
146:07 - this one does print 36 so we pass in the
146:10 - local variable to inside the function
146:11 - then the function we do something we
146:13 - return it and with that return value we
146:15 - put it back on the local variable all
146:17 - right so that's scope this is another
146:19 - cruci thing that I see a lot of
146:21 - beginners struggleing with so definitely
146:23 - make sure you fully understand this
146:24 - anytime you see that error again make
146:26 - sure to come back to this lecture in
146:28 - order to fully understand why it's
146:29 - happening next we're going to learn
146:31 - about something very simple but also
146:32 - very important comments so let's learn
146:34 - about those in the next
146:36 - lecture hello and welcome I'm your Cod
146:38 - monkey in this lecture we're going to
146:40 - learn all about comments these are
146:42 - basically just some text annotation that
146:43 - you can add to your code to provide some
146:45 - extra clarification on anything you need
146:47 - okay so comments are really super simple
146:49 - this is how you can pretty much write
146:51 - any text you want directly inside your
146:52 - code however that text is not
146:54 - interpreted as text meaning comments are
146:56 - just for you the programmer the compiler
146:58 - completely ignores them so as the code
147:00 - is executing line by line it is
147:02 - executing it gets to the comment and
147:03 - skips it and continues executing so as
147:05 - far as the compiler is concerned the
147:07 - comment literally does not exist in
147:08 - terms of syntax they are really simple
147:10 - you just write two forward slashes and
147:12 - then write whatever code you want like I
147:14 - said this is not interpreted as any
147:15 - instruction or any code or anything the
147:18 - compiler completely ignores all of this
147:19 - so I could write some kind of valid code
147:21 - but nope this is not registered as code
147:24 - as far as the compiler is concerned this
147:25 - line over here does not exist so you can
147:27 - make single line comments with two
147:29 - forward slashes or you can make
147:30 - multi-line comments with a forward slash
147:32 - and any Star and then you end it with
147:34 - another star and another forward slash
147:36 - so with this anything you put anywhere
147:38 - inside of this all of this is considered
147:40 - a comment all of this is ignored by the
147:41 - compiler also comments do not have to be
147:44 - just in their online you can write some
147:46 - regular code and then afterwards write
147:47 - some kind of comment so Yep this is
147:49 - valid code and alternatively for this
147:51 - multi-line comment you don't technically
147:53 - need to do it in multi-line so you can
147:55 - just you open up that one and close it
147:57 - and write anything right inside there
148:00 - then also this comment right after the
148:02 - forward slashes anything afterwards is
148:03 - considered a comment meaning that you
148:05 - can't actually make a comment before so
148:07 - this do not work the compiler is going
148:09 - to ignore all of this it is not going to
148:10 - execute this instruction so technically
148:12 - if you absolutely need to do this you
148:14 - would simply do the for/ star then close
148:17 - it and yep now this would indeed work
148:19 - this is a common order by the compiler
148:21 - this is a normal instruction which would
148:22 - run another comment although you
148:24 - probably really don't want to do this
148:25 - comments right before any kind of
148:27 - instruction that just makes the code
148:28 - really hard to read so whilst
148:30 - technically you can do this you probably
148:31 - really shouldn't with this we can see
148:33 - how in technical terms comments are
148:35 - really super simple to understand
148:36 - there's a super simple syntax and then
148:38 - you can write whatever text you want now
148:40 - the more important thing when it comes
148:41 - to comments is knowing what to comment
148:43 - something that we understand to do is
148:44 - pretty much just explain what the code
148:46 - is doing so here's an example of some
148:48 - really bad comments these are bad
148:50 - because they are completely useless they
148:51 - are really just repeating what the code
148:53 - is doing so by looking at the code we
148:54 - can see we've got a variable with the
148:57 - name a being defined with type int so
148:59 - this comment is completely useless all
149:00 - of this just adds just some needless
149:02 - noise and comments like this also have
149:04 - the problem that you might simply forget
149:05 - to updated for example if I update the
149:07 - codes over here instead of incrementing
149:08 - by two increment by one and all of a
149:10 - sudden now this comment is completely
149:12 - wrong so in general the general rule is
149:14 - your comments should focus on the why
149:16 - and not the how meaning instead of
149:18 - saying what the code is doing line by
149:19 - line instead of that you should write
149:21 - why you wrote that code what problem is
149:23 - trying to solve although at the same
149:25 - time comments are actually something you
149:26 - should aim to avoid what I mean by that
149:28 - is your code should have good names for
149:30 - your variables your functions and
149:32 - classes all that should have great names
149:34 - so that just by reading their name you
149:36 - should be able to understand what it's
149:38 - actually doing that means that your code
149:40 - should ideally be self-documented in
149:42 - many cases if you find that your code
149:43 - has a whole bunch of comments chances
149:45 - are that's a sign that you should
149:47 - refactor your code for example over here
149:49 - if we were to rename name this to use
149:50 - some terrible names so I named the
149:52 - function just to say let's rename this
149:54 - parameter to just p and this parameter
149:56 - to just H beginners might do this
149:58 - because for some reason beginners like
150:00 - to make their parameters as small as
150:01 - possible and then they might say prints
150:03 - out a hello to a player and then need to
150:06 - clarify P this one means the player name
150:10 - and how a this one means the age so this
150:12 - is an example of comments that are
150:14 - technically not as useless as the ones
150:15 - up here but at the same time these are
150:17 - very clearly telling you that instead of
150:19 - having these comments you should
150:20 - refactor this code in order to make the
150:22 - function in order to make what this is
150:23 - doing much much more understandable you
150:25 - can just do a direct comparison between
150:27 - this and what we had previously and
150:28 - obviously this version with no comments
150:30 - this one is much easier to read much
150:32 - easier to understand that is why being
150:33 - able to come up with good names when
150:35 - writing good C though that is why that
150:36 - is so important that's a very important
150:39 - topic and something that I'm going to
150:40 - cover in detail in a future lecture so
150:42 - for now when it comes to comments I just
150:43 - want you to learn what comments are how
150:45 - you can write them and also to encourage
150:47 - you to avoid writing any useless
150:49 - comments all right so those are comments
150:51 - and with that by now we have already
150:53 - learned quite a lot about the absolute
150:54 - basics of programming we are now ready
150:56 - to take it one step further and learn
150:58 - about some more complex types we're
150:59 - going to learn about arrays and lists so
151:01 - let's do that in the next
151:03 - lecture hello and welcome I'm your codm
151:06 - in this lecture we're going to learn
151:07 - about arrays and lists this is how you
151:09 - can store multiple pieces of data
151:10 - together okay so previously we covered
151:12 - the basic data types for example you've
151:14 - got int B string and so on the variables
151:16 - are essentially just containers for data
151:18 - and for example if you make an in
151:19 - variable and then you can store some
151:21 - kind of int or whole number value like
151:23 - for example the number 56 I can take it
151:24 - and I can indeed put it inside an INT
151:26 - variable however when I want to store
151:28 - more than one number so now let's say I
151:29 - want to store this one nope that does
151:31 - not work I can only store one value
151:32 - inside a single int variable so when you
151:34 - want to store multiple values that is
151:36 - where arrays come in you define an array
151:38 - of a certain type like for example an
151:40 - interray you give it some sort of size
151:42 - which is going to be fixed you define
151:43 - that size when you create the array and
151:45 - that basically creates multiple boxes
151:46 - multiple containers on which you can put
151:48 - any kind of data you want of that type
151:50 - so for example now on index zero I can
151:52 - place this value and on the next one I
151:54 - can place this one then I can place this
151:56 - one and so on Sample like this I can
151:58 - place multiple pieces of data on a
151:59 - single variable one important thing
152:01 - about arrays are the indexes note how
152:03 - the array has a length of five meaning
152:05 - it has five elements but for these five
152:07 - elements the first one is over here on
152:08 - index zero then the second one is on
152:10 - index one and so on so the positions in
152:12 - the array are always index space and
152:14 - they only start at zero using the index
152:16 - we can individually either set or read
152:18 - values directly from the array okay
152:19 - that's e theory now let's see the syntax
152:21 - the way that we Define an array is
152:23 - actually really simple we Define the
152:24 - data typ as usual so for example let's
152:26 - say an INT array where we want to store
152:28 - ins so we Define data type and then open
152:30 - and close the square braces important it
152:32 - is this one it is not parentheses is not
152:34 - curring braces Noe it is the square ones
152:36 - so you do this and yep that's it this
152:38 - variable is now defined as an interray
152:40 - let's give it some kind of name like
152:41 - numbers array so Yep this is our
152:43 - interray and afterwards we can
152:45 - initialize the array and for this there
152:46 - are actually several ways to do it if we
152:48 - want to initialize it with some elements
152:50 - the simplest way we can do it is just
152:52 - open currently braces and inside put any
152:54 - kind of elements like let's say a whole
152:55 - bunch of numbers so if there you go like
152:57 - this we are initializing the array
152:58 - alternatively you can be a little bit
153:00 - more explicit with the tab creation you
153:02 - can do new int array and then pass in
153:04 - all of the elements personally for me
153:06 - this is my preferred method like I said
153:08 - I like my code to be as explicit as
153:09 - possible so personally I do like to be
153:12 - very explicit with how I Define the
153:13 - array the exact type that I'm using or
153:15 - alternatively you can simply create an
153:16 - array without any elements and just give
153:18 - it a certain size like this there's an
153:20 - error you have to give it a size so for
153:21 - example let's say with five and there
153:23 - you go this creates an array the numbers
153:24 - array this is an array with five
153:26 - elements and like this if you don't
153:28 - initialize to anything then pretty much
153:29 - all the elements will be initialized to
153:31 - zero so speaking of the size this
153:33 - actually brings up a very important
153:34 - topic about AR Rays there size is fixed
153:36 - and after being created the size cannot
153:38 - be changed over here we are creating an
153:40 - array with size of five and that's it
153:42 - that cannot change if you want to check
153:44 - the side of the array we can see that
153:45 - through the length property and the way
153:47 - we do that is first we access our
153:49 - variable so that see numbers array and
153:50 - then we write a DOT and this dot
153:52 - basically means that we want to access
153:54 - something inside this variable inside
153:55 - this variable type and in this case this
153:57 - variable is an array so by tying dot we
153:59 - are accessing all the functions and
154:00 - properties that exist in the array type
154:02 - so it's kind of similar to how
154:03 - previously we saw console. right line
154:05 - basically right Line This is a function
154:07 - that exists inside the console class
154:09 - that's what the dot means it means we
154:11 - are accessing something on the symbol
154:12 - previously defined okay so like this we
154:14 - are accessing something on the array and
154:16 - if we want to get the size the array for
154:18 - that we can access the property for the
154:19 - link so if we just do a console right
154:22 - line on this one just to see what this
154:23 - says let's see and if there it is it
154:25 - says five which is exactly the size that
154:27 - we Define for our array if we modify
154:29 - this to three and run and yep now it
154:30 - says three so the length this is going
154:32 - to return the size of the array then
154:34 - another thing you are going to do quite
154:35 - a lot with arrays simply accessing them
154:37 - to read an element on a certain index
154:39 - and the way we do that is we simply
154:41 - write the array so numbers array and
154:43 - then we write the square brackets and
154:45 - inside it we put some index like for
154:46 - example let's say index zero again
154:48 - remember how in C indexes start with
154:50 - zero so the one on index zero is going
154:52 - to be the first element the one on index
154:54 - one is the second element and so on so
154:56 - if first let's initialize the array so
154:58 - let's initialize it with something let's
155:00 - put a whole bunch of numbers okay so we
155:02 - initialize with a bunch of numbers and
155:03 - now let's print out the one on index
155:05 - zero so let's do a console d right line
155:07 - on that and let's just get rid of this
155:10 - previous log okay let's see and if there
155:12 - you go it does print out the number 56
155:14 - which is indeed the very first element
155:15 - on this array however also something
155:17 - very important is that we actually
155:19 - initialize array first and like I said
155:21 - we can initialize like this with some
155:22 - values or we can simply omit this and
155:24 - simply initialize with a certain size if
155:26 - we run this code yep we return zero
155:28 - basically the array initializes
155:29 - everything to zero however if we don't
155:31 - do this if we just find the array then
155:33 - nope here we have a compiler error so we
155:35 - need to actually initialize the array
155:36 - before we can use it and like I said the
155:38 - arrays have a fixed size so when
155:40 - accessing an index that also becomes
155:41 - important for example if we try to
155:43 - access after the size so for example
155:45 - over here we have three elements if we
155:46 - try and access the one on index five
155:48 - which does not exist if we do this then
155:50 - yep we get an index out of range
155:51 - exception that is because the index
155:52 - index five that does not exist that is
155:54 - outside the boun Z array same thing if
155:55 - we try to go the other way so if we try
155:57 - to go minus three if we do this then yep
155:59 - same thing same error now if we do want
156:02 - to change the size the array like for
156:03 - example if we want to add another
156:05 - element to the array like I said that
156:06 - literally cannot be done the size cannot
156:08 - change so the only thing we can do is
156:10 - simply make yet another array add it
156:12 - with one more element of space and then
156:14 - copy all these elements on the new array
156:16 - and then add the new element so you'd
156:17 - have to make all that logic manually if
156:19 - you wanted to add an element to this
156:20 - array or alternatively for removing an
156:22 - element once again same thing you cannot
156:24 - change the size so You' create a new
156:25 - array with one less length and then copy
156:27 - the remaining elements onto that array
156:29 - you can manually write that logic with
156:30 - the help of Loops which we're going to
156:31 - learn about in the next lecture or in
156:33 - order to add or remove elements to an
156:35 - array you can simply use a different
156:36 - collection type namely the list the list
156:39 - is actually built on top of the arrays
156:40 - and basically has a bunch of helper
156:41 - functions to make it super easy to add
156:43 - or move elements or do a bunch more
156:45 - things and to use a list first we write
156:47 - list and then we write the angle bracket
156:50 - so this is a less than sign then we
156:52 - write the data type that we want to
156:53 - store in the list like for example an
156:54 - INT and then the closed angle brackets
156:56 - so the greater than S again don't
156:58 - confuse the symbols make sure you are
157:00 - using these symbols like for example
157:02 - there is a double character it is not
157:03 - this one it is a single one the same one
157:05 - you use for mathematical comparisons now
157:07 - the technical term for what we have
157:09 - written here inside the brackets the
157:11 - technical term for this is a generic
157:13 - which we're going to cover later on in
157:14 - detail in the intermediate section for
157:16 - now just make sure you write this syntax
157:18 - exactly so with this we have defined the
157:20 - list of ins so let's call it int list or
157:22 - actually to keep it the same name let's
157:23 - call it numbers list okay and then to
157:25 - create our list we have pretty much the
157:27 - same options we have for the array we
157:29 - can do the full type declaration so over
157:31 - here put any kind of values Yep this is
157:33 - our list however on this one we cannot
157:34 - initialize it just like this this
157:36 - specific initializer only works for AR
157:38 - Race So for list we cannot use this one
157:40 - but we also have the third option of
157:42 - Simply initializing a list just like
157:43 - this and here note how I did not put any
157:45 - number inside the parenthesis whereas
157:47 - over here when defining a new interray
157:49 - we have to give it a size but for a list
157:51 - like I said lists don't have a fixed
157:53 - size they can grow in shrink so when
157:54 - creating a brand new one you don't have
157:56 - to give it a size although technically
157:57 - if we actually inspect this Constructor
157:59 - we can see there is a version that does
158:01 - take a capacity now this is a more
158:03 - performance optimization thing if you
158:04 - know you're going to need a certain
158:06 - number of elements you can preset that
158:07 - capacity but in most cases and
158:09 - especially right now on this beginner
158:10 - section you can just ignore it just do
158:12 - it like this and to create a brand new
158:13 - empty list so we have created on list
158:15 - and now we can do let's say the same
158:17 - thing that we did on the numbers array
158:18 - let's first print out how many elements
158:20 - are on this list it's pretty much the
158:21 - same thing we just access the same
158:23 - number of list except right now on a
158:24 - list this one is actually not called
158:26 - length if we find links we can't find
158:28 - anything so it doesn't have that name in
158:30 - length it is instead called count for
158:32 - counting the number of elements in the
158:33 - list but in terms of logic it's really
158:35 - the same thing so it Returns the amount
158:36 - of elements within that list so let's do
158:38 - a right line on this one and since we
158:40 - just created this one should return zero
158:43 - and if there it is this one does have
158:44 - zero okay great then like I said one of
158:46 - the big benefits of lists as opposed to
158:47 - arrays is we can very easily add or
158:49 - remove elements the way we do that is we
158:51 - just access the list and then use the
158:53 - add function and this one takes an item
158:55 - that we want to add so let's add the
158:57 - number 12 and if we do this and
158:58 - afterwards let's print out the right
159:00 - line on the numbers list. count let's
159:02 - see this and yep that one does indeed
159:04 - have one element and if we access the
159:06 - list on the Zero index in order to see
159:08 - our first element and if we do see our
159:10 - list contains the number 12 okay great
159:12 - so just like this we can already see
159:14 - just how much better it is to work with
159:15 - list as opposed to Ray with this there's
159:17 - no need to manually create a new array
159:19 - with the size plus one we don't need to
159:21 - do that and copy all data basically all
159:23 - of that is handled automatically by the
159:25 - list we just call add or alternatively
159:27 - we go inside the numbers list and we
159:29 - call remove either one of these and
159:30 - we'll either add or remove an element
159:32 - over here on the remove the way this one
159:34 - works is you give it some kind of item
159:35 - so in this case the only element inside
159:37 - is the number 12 so if we call 12 this
159:39 - is going to remove the number 12 or
159:41 - alternatively there's another one
159:42 - there's the remove at which then takes
159:44 - an index so if we do this and pass in
159:46 - the index zero it is going to remove the
159:47 - element on index zero and related to the
159:50 - ad there's also another one which is the
159:51 - insert basically the ad that one is
159:53 - always going to add the new element to
159:55 - the end of that list whereas with insert
159:57 - over here you can pass in an index where
159:59 - you want to insert that new element
160:01 - another Super useful function in our
160:02 - list is for finding elements let's add
160:04 - some more elements just a test so let's
160:06 - add 12 0 and let's say 89 so we did this
160:10 - and now let's say we want to find if the
160:12 - number 89 exists inside this list if so
160:14 - we can go through the list and we can
160:16 - call the contains function and like name
160:18 - implies this one tests if it contains a
160:19 - certain element so if we test for 89 and
160:22 - c and it returns true because does have
160:24 - that element whereas if we put some
160:25 - different number and nope does not have
160:27 - that element another similar way to find
160:29 - elements within a list is to use the
160:31 - index of this basically going to return
160:33 - the index of an item if it finds it so
160:35 - for example the index of 89 this one is
160:37 - the third element on the list so it
160:39 - should return two and if there it is
160:40 - does have a two or if we include
160:42 - something that is not found so if you
160:44 - include something does not exist if so
160:45 - then yep when it doesn't find anything
160:47 - it Returns the index minus one since
160:48 - minus one is not a valid index minus one
160:51 - usually means not found and by the way
160:52 - actually over here on the array you can
160:54 - also do something similar to this you
160:56 - can do an index of however it's a bit
160:58 - different so it is not like this. index
161:00 - of this does not exist there's no
161:02 - function called index of within the
161:03 - array however it actually exists as a
161:05 - static method again don't worry what
161:07 - static means right now we'll explain in
161:08 - detail in a later lecture but basically
161:10 - we just need to access through the
161:12 - system. array we access through that and
161:14 - we can do index of and this one takes
161:16 - our array so the numbers array and then
161:18 - whatever we're trying trying to find
161:19 - let's say we want to find the element 23
161:22 - and if we do a console. log on this do a
161:24 - right line let's see and if that one
161:26 - does find it on index one and yep number
161:28 - one to three is over here indeed on
161:30 - index one so as you can see arrays and
161:32 - lists are really excellent really very
161:34 - useful tools for handling multiple
161:35 - pieces of data the technical term for
161:37 - these are collections an array is a
161:39 - collection and a list is also a
161:40 - collection there's a bunch more
161:42 - collection types for more advanced use
161:43 - cases you have stacks dictionaries hash
161:45 - hats and a bunch more I cover all those
161:47 - in detail in the lecture in the
161:48 - intermediate section section for now
161:50 - just knowing about arrays and lists it
161:51 - is going to be more than enough whenever
161:52 - you need to store multiple pieces of
161:54 - data you can use either one of these in
161:56 - most case you probably want to use a
161:57 - list just because they are so easy to
161:59 - use and when you need absolute maximum
162:00 - performance for that arrays can be quite
162:02 - useful all right so here we learn about
162:04 - something very useful arrays and lists
162:05 - you won't be using these a lot in your
162:07 - programming career and now in the next
162:08 - lecture we're going to learn about one
162:10 - of the core tools of just about any
162:12 - programming which are Loops so let's
162:13 - learn that in the next
162:15 - lecture hello and welcome I'm your cod
162:17 - mck in this lecture we're going to learn
162:19 - learn one of the more fascinating and
162:20 - Powerful features of any programming
162:22 - Loops this is how we can run certain
162:24 - logic multiple times okay so let's learn
162:26 - everything about loops this is another
162:28 - really crucial core part of pretty much
162:30 - any programming there are so many
162:31 - scenarios where Loops are used it can be
162:33 - a little bit tricky at first for
162:34 - beginners especially since the code
162:35 - jumps a little bit so we do pay close
162:37 - attention normally the code runs from
162:39 - top to bottom and when it comes to Loops
162:41 - that is still true although it also
162:42 - jumps and runs the same instructions
162:44 - multiple times for example if this Loop
162:46 - over here was defined to run three times
162:48 - if so then it was run this line then
162:50 - this line then this line and then
162:51 - instead of exiting and continuing down
162:53 - it would jump back to the beginning and
162:55 - run this line again this one again jump
162:56 - back run this one this one and then
162:58 - finally exit the loop we're going to see
163:00 - how this is very useful especially when
163:01 - combined with the arrays that we learned
163:03 - in the previous lecture it's how you
163:05 - don't even have to know the size of the
163:06 - array in advance you don't need to copy
163:08 - paste a whole bunch of code to it rate
163:10 - through each element you can just write
163:11 - a loop that will jump through all the
163:13 - elements of the array and then you can
163:14 - do whatever logic you want on each
163:15 - element we're going to learn about these
163:17 - four Loop types so we've got wild do
163:19 - while four and a four each let's begin
163:21 - by learning the most basic Loop possible
163:23 - which is a simple while loop this one
163:25 - simply has a condition and it will
163:27 - basically execute the code inside the
163:29 - currently braces while that condition is
163:30 - true as soon as the condition becomes
163:32 - false the code stops executing and jumps
163:34 - after to write a one loop it's really
163:36 - simple we just write the keyword while
163:38 - then we put some kind of condition
163:40 - inside parentheses like for example
163:41 - let's just put true and then we put a
163:43 - code block with currently braces all
163:44 - right so that's it basically now with
163:46 - this we are going to run the code inside
163:48 - this code block for it as long as this
163:49 - condition is true now what I have
163:51 - written here is actually something that
163:52 - usually you want to avoid for the
163:54 - condition I just wrote through and like
163:56 - I said this code block will run for as
163:57 - long as the condition is true which
163:59 - right now is forever since true this
164:00 - will never change by itself so what we
164:02 - have here is an endless loop if we try
164:04 - putting in log here console. right line
164:06 - and we try to see what this does and if
164:08 - there it is the log is simply printing
164:10 - towards Infinity forever and ever until
164:12 - the end of time so usually this is
164:14 - something you don't want to do and by
164:15 - the way quick tip over here if you want
164:17 - to cancel this you can either click on
164:18 - the button over there or you can press
164:20 - contrl C and that will automatically
164:22 - stop the code from executing okay so
164:24 - here we made our while with an infinite
164:25 - Loop now sometimes this is actually
164:27 - desirable like for example in a game
164:29 - engine you do want your update code to
164:31 - run every single frame until the player
164:32 - quits the game but right now we want the
164:34 - loop that actually ends so for that we
164:36 - just need some kind of condition that
164:38 - eventually becomes false and the most
164:39 - basic one is just having some kind of
164:41 - counter so before let's just Define a
164:43 - simple in I by the way usually when
164:45 - working with loops the variable I is
164:47 - commonly used it stands for the iterator
164:49 - variable and usually we want to
164:51 - initialize this one at zero and not at
164:53 - one techically you don't have to but
164:54 - usually you want to start things with
164:56 - zero that comes back to what we covered
164:58 - with arrays on the previous lecture how
164:59 - array indexes always start at zero so
165:01 - for iterator variables usually you do
165:03 - the same thing now over here one very
165:05 - important thing is make sure you are
165:06 - defining the variable before the loop
165:08 - meaning don't place this code inside of
165:09 - here if you do then you are basically
165:11 - always defining the variable with the
165:12 - same value so every time the loop runs
165:14 - it is always going to have the same
165:15 - value it would never increment and the
165:16 - loop would never end so make sure you
165:18 - define this one outside of the loop so
165:20 - right before now over here instead of
165:21 - true let's cycle while I is under three
165:24 - and in order to make sure that this
165:25 - condition actually ends that it
165:26 - eventually becomes false because right
165:28 - now it is still infinite in order to do
165:29 - that at the end of our one Loop let's
165:31 - simply increase our iterator by one so
165:33 - just I ++ okay so that's it pretty
165:35 - simple let's see what this is doing over
165:37 - here let's just print out Loop and then
165:40 - let's print out the I okay so let's see
165:42 - and if there is Loop 0 1 and two so y
165:45 - that is correct the code inside this
165:47 - code block is running while this is true
165:49 - and when we first run the iter rate is
165:51 - going to be zero so is zero and three
165:53 - the answer is true so the first time it
165:55 - is going to execute this one and then
165:56 - this one which is going to increment the
165:58 - I into one then it goes back loops and
166:01 - test the condition once again so now is
166:03 - one under three it's still yes so once
166:05 - again runs increases it next Loop is two
166:08 - under three still yes so it still prints
166:10 - for the third time but now it increase
166:11 - this one increase the I to three so the
166:13 - next time goes is three lower than three
166:15 - the answer is no 3 equals 3 so at that
166:18 - point it drops out of the loop and
166:19 - continues executing down here also by
166:21 - the way what we just did here is
166:23 - actually a great tip for when you're
166:24 - confused about loops just go through
166:26 - them in your head line by line to see
166:28 - exactly what things are doing and of
166:30 - course always write some logs in order
166:31 - to remember what you're doing with your
166:33 - iterator variable like for example here
166:34 - if you made the simple mistake of doing
166:36 - iusus instead of i++ if you did that yep
166:39 - there you go the loop never ends it's an
166:40 - endless loop again or alternatively if
166:42 - you did increase but for some reason you
166:44 - forgot and you increased it just after
166:46 - the loop and you once again still an
166:48 - endless loop it's constantly at zero so
166:49 - always pay very close to your conditions
166:51 - and how exactly you are eventually
166:53 - exiting that Loop also let me mention
166:55 - another common mistake that beginners or
166:57 - really every programmer makes which is
166:58 - off by one errors meaning they think
167:00 - they're running a certain amount of
167:01 - times but it's actually running that
167:03 - many times plus one so usually the
167:05 - mistake is instead of doing for example
167:06 - lower than lower than or equals so let's
167:09 - say you wanted to run this three times
167:10 - but if you put less than equals if so
167:12 - then yep the loop actually runs four
167:14 - times so always double check that your
167:16 - condition is correct exactly as you
167:17 - intended so that the Loop runs as many
167:19 - times as you actually think it does now
167:21 - one really important thing about the one
167:23 - Loop is how it tests condition before
167:25 - going inside the loop so for example for
167:26 - the iterator variable If instead of
167:28 - initializing on zero let's initialize it
167:30 - on five which is immediately going to
167:31 - have false on this one so let's see if
167:33 - our code prints anything to the console
167:35 - and Noe the answer is it does not if
167:37 - this condition is false right away then
167:39 - the code inside the loop never runs not
167:40 - even once so related to that let's see
167:42 - the other similar Loop the do while this
167:45 - one is very similar to the while loop
167:46 - the only difference is really when the
167:48 - condition is is testing so for this one
167:50 - first we write the keyword do and then
167:52 - we open and close our C braces so we
167:54 - have our code block and then we have the
167:56 - while and then parenthesis our condition
167:58 - so let's put the same condition I under
168:00 - three so yep just like this and let's do
168:01 - a console. right line do one Loop and
168:05 - let's print out the iterated variable
168:07 - and inside the loop again always
168:08 - remember to increase your iterated
168:10 - variable okay so here we can directly
168:11 - compare is this one going to run the one
168:13 - inside well which I already saw is not
168:15 - going to run and then let's see if this
168:17 - one does run let's test and y there's
168:19 - the result so the regular well Loop this
168:21 - one did not run not even once but the do
168:23 - well even though this condition is
168:25 - always false even on the first iteration
168:27 - it is already going to be false despite
168:29 - that it is still going to run the code
168:30 - block inside the loop at least once so
168:32 - that's the difference between these two
168:34 - Loop types this one tests in the very
168:35 - beginning so it might not even run once
168:37 - whereas this one tests the condition at
168:38 - the end so it is guaranteed that the
168:40 - code inside of here is always going to
168:42 - run at least once and if we put the I
168:44 - back into zero and then remember to
168:46 - reset it on this one and if there it is
168:48 - both them be similarly both them run
168:50 - three times okay so while and do while
168:52 - these are the most basic Loops you just
168:54 - have a condition and then you do
168:56 - something while that condition is true
168:57 - but another one that you're probably
168:59 - going to use most of the time is the for
169:01 - Loop this one can sometimes look complex
169:03 - with beginners so definitely pay close
169:04 - attention this one is split into three
169:06 - parts the first part is the initializer
169:08 - so here usually we initialize some kind
169:11 - of iterator variable then we have the
169:13 - condition so same thing it is going to
169:14 - continue running while this one is true
169:16 - and finally we have the increment so
169:18 - usually over here you increase the
169:19 - iterate variable by one so let's see the
169:21 - syntax let's just comment this out and
169:23 - let's go up here and write our four so
169:25 - first We Begin by writing the keyword
169:27 - for and then let's open and close the
169:29 - parenthesis and now in here the for Loop
169:31 - has three components and they are split
169:33 - by semicolon so the first component is
169:35 - going to be where we're going to
169:37 - initialize our iterator variable like I
169:38 - said the very common thing is usually
169:40 - just Define an INT name it I and
169:42 - initialize it on zero okay so then we do
169:45 - a semicolon and then we can write the
169:47 - second component the second one is going
169:49 - to be the condition so let's put the
169:51 - same thing we had in ouri so I under
169:53 - three and yet again another semicolon
169:55 - and now we have the third component this
169:57 - is going to be the increment so here
169:59 - usually you want to increase the
170:01 - iterator variable by one so i++ yep so
170:04 - just like this we have our three
170:05 - components then we just have our regular
170:07 - code block now over here we can do
170:08 - whatever we want like the right line for
170:10 - the for Loop and print out the it
170:12 - variable all right so let's test and Y
170:14 - once again the same result it runs the
170:16 - code inside the loop three times now
170:17 - let's go through this piece by piece to
170:19 - see exactly how the code is executing so
170:21 - basically when the code gets to this
170:23 - line over here when it does the first
170:24 - thing it's going to run is this part
170:26 - over here which is going to initialize
170:27 - the iterated variable right after that
170:29 - it is going to test for the condition so
170:31 - very much like the one Loop meaning if
170:33 - it is false it is going to skip it
170:34 - entirely but if it is true then the next
170:36 - thing it goes is it goes inside the for
170:38 - Loop and runs all of the code inside the
170:40 - code block and then after running the
170:42 - entire code block after that it runs the
170:44 - third component which is going to
170:46 - increment the iterator variable and
170:47 - after doing that then it it jumps back
170:49 - and tests for the condition once again
170:51 - then again keeps doing the same thing if
170:52 - it's true continue running this one and
170:54 - then jump back to the iterator test
170:55 - again and so on until finally it becomes
170:57 - false and then it jums outside basically
170:59 - the one great benefit for the for loop
171:01 - as opposed to something like a while or
171:02 - a do while the one big benefit is how it
171:04 - makes it much easier to handle the
171:06 - iterator variable although I should also
171:08 - note that while this does help handle
171:10 - the iterator variable a bit more easily
171:12 - the same issues that we had with infin
171:14 - loops those can also occur here so for
171:16 - example if for the itat instead of doing
171:18 - app Plus you do IUS minus then Yep this
171:20 - one now becomes an infinite Loop or if
171:22 - you put i++ but then over here for some
171:24 - reason you put some condition that is
171:25 - always true then once again this is also
171:27 - going to be an infinite Loop so really
171:28 - the potential for an infinite Loop that
171:30 - is always there regardless of what Loop
171:32 - type you're using but generally since
171:33 - the four Loops since that one at least
171:35 - force you to use an iterator variable
171:37 - and increment it for that it should help
171:39 - avoid those unwanted infinite loops and
171:41 - also remember what we covered on the
171:42 - electure on scope the iterator variable
171:44 - over here the in I this one is being
171:46 - defined in this special place inside the
171:48 - for Loop and doing it like that makes it
171:50 - a local variable specifically local to
171:52 - this for Loop so we can access it in
171:54 - here so here we are printing it but if
171:55 - we try accessing out here then nope this
171:58 - does not happen this variable only
171:59 - exists inside the code block inside the
172:01 - for Loop so after ending the loop this
172:03 - variable no longer exists whereas for
172:05 - example over here on the while on this
172:07 - one we Define the in iterator outside of
172:09 - the while so after the while we can
172:11 - still do anything we want with that
172:12 - variable this is actually usually
172:14 - something you don't want to do so that's
172:15 - another reason why the for Loop is one
172:17 - of the most useful ones now now the for
172:19 - Loop can be used for running some code a
172:21 - certain number of times or something
172:22 - very useful is when used with what we
172:24 - covered in the last lecture arrays or
172:26 - list so here let's define a string array
172:28 - for the name array and let's just create
172:31 - the new string array all right so here
172:33 - we have a nice array of various strings
172:35 - and now if we want to cycle through this
172:36 - array then a for Loop is one of the
172:38 - great ways to do it we use usual
172:40 - iterator variable we increment by one
172:42 - and then over here for the condition we
172:43 - want to iterate through the array for as
172:45 - long as we have elements so for that we
172:47 - can check if I is under and then go
172:49 - inside the name array and access the
172:50 - arrays like this property is going to
172:52 - contain the number of elements inside
172:53 - the array and once again don't make the
172:55 - mistake of the one off by one errors so
172:57 - over here make sure it's always less
172:59 - than the length and not less than equals
173:01 - because this length for example this one
173:03 - is going to return four we have four
173:04 - elements but again remember how the
173:06 - indexes start at zero so this is index 0
173:08 - 1 2 and three so there is nothing on
173:11 - index 4 and if you put it less than and
173:12 - equals then the final one is going to be
173:14 - on I of4 and on I of4 would give an
173:16 - array because nothing exists on index
173:18 - four so always pay attention to that
173:20 - very common error and now with this we
173:22 - can just print out just this name so
173:24 - let's just go inside the name array and
173:25 - access on the I index yep like this
173:27 - let's test and if there it is we are
173:29 - printing all the elements in our array
173:30 - all right awesome also one quick note to
173:32 - cycle through a list is pretty much the
173:34 - same thing so here if we make this a
173:36 - list of string instead of an array so a
173:38 - list of string let's do it like this and
173:41 - initialize our list and the only
173:43 - difference is like we saw in the
173:44 - previous one instead of the list calling
173:46 - length it is called count so y just like
173:49 - this and yep the code is running the
173:50 - same way okay so this is great this is
173:52 - how you can cycle through all the
173:53 - elements in an array or a list however
173:55 - there's actually an even simpler method
173:57 - specifically designed for lists and
173:58 - arrays instead of a four in handling the
174:01 - iterator variable ourselves instead of
174:02 - that we have the 4 in and for this one
174:04 - we Define an iterator which in this one
174:06 - instead of being an index it is actually
174:08 - going to be an iterator of the type that
174:10 - contains our collection elements we have
174:12 - an iterator in some kind of collection
174:14 - so basically this one helps us
174:15 - automatically handle all that Cy logic
174:17 - without keeping need of some kind of
174:19 - index doing a for each is really simple
174:22 - we just write for each and then over
174:24 - here we write the name for our iterator
174:26 - variable however this time again it is
174:27 - not an index so we're not going to use
174:29 - an INT we're going to use whatever type
174:31 - we're cycling so in this case we are
174:32 - cycling through an array of strings so
174:34 - for each string then give it some kind
174:36 - of name so in this case let's call it
174:37 - name then the keyword in and then the
174:39 - name array and yep now here we can just
174:41 - do console the right line and just print
174:43 - out this name variable let's see what it
174:45 - does and you basically the same thing so
174:47 - the four and the 4 in work the same way
174:49 - basically over here this is going to
174:50 - loop as many times as we have elements
174:52 - in our array and every time it Loops the
174:54 - 4 each itself is going to handle
174:56 - updating this name variable over here so
174:58 - when this runs the very first time it is
174:59 - going to assign Code Monkey to that name
175:02 - then the second time it runs it assigns
175:03 - Airmen and so on so it basically handles
175:05 - updating everything updating the
175:07 - iterator variable without you needing to
175:08 - keep track of indexes or anything like
175:10 - that now technically I should also say
175:12 - that the 4 in this one works with
175:14 - anything that is enumerable like any
175:15 - collection it works with arrays it works
175:17 - with list and a bunch more I cover more
175:19 - collection types and how to make your
175:21 - own custom types inumerable in a lecture
175:23 - in the intermediate section here is the
175:25 - demo for this lecture this is kind of
175:27 - like a mini RTS game so I've got a list
175:29 - of all my units and over here are the
175:31 - various units in the world here in the
175:32 - code the units are simply a list of
175:34 - units and then I have the simple code
175:36 - that just test when the player presses
175:37 - the left Mouse button when it does then
175:39 - does a 4 each through the entire unit
175:41 - list and tells each unit to go to that
175:43 - Target position so with all the units
175:45 - inside the list if I click if there you
175:46 - go they all move straight towards the
175:48 - Target and now by using the exact same
175:50 - code if I modify the list and remove all
175:53 - kinds of units so let's remove a bunch
175:54 - of them and leave just one unit if I do
175:56 - that and now I click and if there you go
175:58 - the same logic is now moving just one
176:00 - unit so this is a great practical
176:01 - example of how useful Loops are and
176:03 - specifically the for each Loop you can
176:04 - write some kind of logic that applies to
176:06 - some kind of list and that logic will
176:08 - work regardless of how many elements are
176:10 - on that list also a note it is perfectly
176:12 - fine to do a four each or even a four on
176:15 - a list or array with no elements so if
176:17 - we raises so that it's pretty much just
176:19 - an empty array and if there you go
176:21 - everything still runs there's no errors
176:23 - basically over here if the length is
176:24 - zero then zero under zero that is
176:25 - already fall so it's going to skip it
176:27 - and over here on the 4 in if the array
176:29 - is empty then it's also going to skip so
176:31 - these are the main four Loops while is
176:33 - the simplest one but personally I never
176:35 - really use it and same thing for du I
176:37 - very very rarely use these two then down
176:39 - here the four this one is extremely
176:41 - useful in tons of scenarios and for each
176:43 - this one is perfect for doing any kind
176:44 - of logic on list or array all right so
176:46 - that's Loops it's another really
176:48 - important core component of programming
176:50 - so definitely make sure you fully
176:51 - understood everything in this lecture
176:52 - before moving on next we're going to
176:54 - learn one of the core pillars of
176:55 - objectoriented programming which are
176:57 - classes so let's learn that in the next
177:00 - lecture hello and welcome I'm your Cod
177:02 - Mony in this lecture we're going to
177:03 - learn about classes what they are how we
177:05 - Define them how we create objects of a
177:07 - type of class and what we can do with
177:09 - them all right so let's learn about
177:10 - classes this is one of the Core Concepts
177:13 - about C and other objectoriented
177:15 - languages a class is really just a type
177:17 - for example the list that we saw a while
177:18 - ago the inist type is a class and an
177:20 - object is simply an instance of that
177:22 - type so in any of those objectoriented
177:24 - languages you define an object type
177:26 - meaning some kind of class and then
177:28 - create individual instances or objects
177:30 - of that type for example we can define a
177:32 - class named player and inside of it we
177:33 - can define a field for a string name and
177:35 - an in health and then we can create two
177:38 - instances of that class and on this one
177:40 - let's say we set the name equals Code
177:41 - Monkey on this one name equals Iron Man
177:43 - so importantly note how each instance of
177:45 - this type each instance is completely
177:47 - separate the class defines the structure
177:49 - of the type but then the instances that
177:51 - are created from that type each of those
177:52 - has their own memory with whatever that
177:54 - is inside those fields so the class
177:56 - definition is kind of like a blueprint
177:58 - and using that blueprint to then create
177:59 - different objects so here we are in our
178:01 - code let's begin by defining our class
178:03 - and again it's very important where you
178:05 - write the code for example you cannot
178:06 - start writing a class directly here
178:08 - inside a function this throws an error
178:10 - because we cannot define a class
178:11 - directly inside a function so make sure
178:13 - you are writing outside the function and
178:15 - now we can either write inside the
178:16 - program class or we can make it
178:18 - separately either one works in this case
178:19 - let's make it inside the program code
178:21 - block so write in here if you write
178:22 - inside the program class code block if
178:24 - so then we're basically making a n class
178:26 - which in this case is perfectly fine so
178:27 - let's do this we start writing the
178:29 - keyword class and then the name of our
178:31 - class let's say we're defining a player
178:33 - and then open and close our currently
178:35 - braces all right so this is it just with
178:37 - this we have already defined our class
178:38 - which like I said a class is really just
178:40 - a type so it's similar to like an ENT or
178:42 - something so up here usually we've seen
178:44 - Define for example an in for the age and
178:46 - over here we can Define our custom
178:48 - player type player and if there it is
178:49 - just like this this works perfectly note
178:51 - how the color over here is different
178:53 - that is because this one is correctly
178:54 - identifying the player type and again if
178:56 - you're seeing compile errors once again
178:58 - the unlikely culprit is due to being
179:00 - case sensitive so here if instead of
179:01 - player I just write player this is an
179:03 - error there is nothing named player with
179:05 - p on lowercase so always remember that
179:07 - code is case sensitive and of course
179:09 - just to clarify the name over here can
179:10 - be whatever you want doesn't have to be
179:12 - named player the name of the class can
179:13 - be whatever you want and the name of the
179:15 - variable that you create from that class
179:17 - that can also be whatever you want so
179:18 - with this we have defined a variable of
179:20 - our custom type however we just defined
179:22 - it we didn't actually initialize it just
179:24 - yet if we try doing a console. right
179:26 - line then here nope we have an error we
179:28 - cannot do this so it's the same thing as
179:29 - if we try printing the age we also
179:31 - cannot do it we need to First initialize
179:33 - it now in order to initialize it usually
179:35 - for something like an in for this you
179:37 - can usually just sign a value and Yep
179:39 - this works but our custom type isn't a
179:41 - number like I said it's some kind of
179:42 - object so to initialize we need to
179:44 - create our object and the way we do that
179:46 - is with a new keyword so pretty much
179:47 - Exel like we saw with the list so we
179:49 - just do new and then our type so in this
179:51 - case it's called player and then just
179:53 - add the parenthesis so open and close
179:55 - and yep just like this and if we do a
179:56 - log on our player variable let's see and
179:59 - yep it does say it does print a log and
180:00 - it pretty much prints the type and the
180:02 - type is inside Code Monkey C course.
180:04 - program inside the program class and
180:06 - then it's finally called player so y we
180:08 - have indeed created a new player object
180:10 - and we assigned it to this player field
180:12 - so here we have created an instance of
180:14 - our type and now you might be hearing me
180:16 - say that word instance without fully
180:18 - understanding what I mean by that so I
180:19 - mean goes back to the idea of the class
180:21 - definition being some kind of blueprint
180:22 - and then when we do new player we are
180:24 - essentially creating a new object of our
180:26 - type so we're using that blueprint to
180:27 - create an instance of that type meaning
180:29 - that we can create as many instances as
180:31 - we want like for example let's rename
180:32 - this into the Code Monkey player and
180:34 - then let's make another one another one
180:36 - of type player let's call it Iron Man
180:38 - player and let's also do new player and
180:40 - Y just like this we have two completely
180:42 - separate objects that both share the
180:43 - same class so both were made from the
180:45 - same blueprint but each of these two
180:47 - objects is are complete separate object
180:49 - if you want you can actually verify this
180:51 - so let's print out the code monkey
180:52 - player and then let's print out the get
180:54 - hash code this is a default built-in C
180:57 - function that every object has by
180:58 - default it basically returns a hash code
181:00 - for that object so we can print this one
181:02 - out and then print out the one for the
181:04 - Iron Man player so Iron Man player.
181:05 - getet Has code we can print this and Y
181:07 - we can see our two objects are indeed
181:09 - two different objects since they have
181:10 - different hashes so this part is really
181:12 - important for you to understand the type
181:13 - definition itself is kind of like a
181:15 - blueprint and then we use that blueprint
181:17 - to create instances of that type each
181:19 - instance is different and each instance
181:20 - has their own memory and their own
181:22 - Fields their own values and so on okay
181:23 - so now that we've seen the absolute
181:25 - Basics defining a class and creating an
181:27 - instance of it let's see what else we
181:28 - can do one of the main things is
181:29 - actually what we're already doing over
181:31 - here when creating a brand new player
181:33 - this kind of looks like we're calling a
181:34 - function and it kind of is now
181:36 - technically this isn't a function this
181:38 - is what is called a Constructor which is
181:39 - basically what constructs an object of
181:41 - AR type by default any class that you
181:43 - define it will automatically have a
181:45 - Constructor just like this so one with
181:46 - zero parameters but if you want you can
181:48 - also explicitly Define it you just write
181:50 - the exact same name as a class so in
181:52 - this case player and then open the
181:54 - parenthesis and then we can add whatever
181:55 - parameters we want or none so let's just
181:57 - close the parenthesis and then just
181:59 - write a code block all right so Yep this
182:01 - is a Constructor and over here you can
182:02 - write whatever logic you want now again
182:04 - it's very very important that the name
182:05 - perfectly matches the class name if it
182:07 - does not match there won't be an error
182:09 - if it does not match and this assumes
182:10 - we're just defining a regular function
182:12 - and requires a return type in order to
182:14 - define a Constructor which again is a
182:16 - kind of like a special function for that
182:17 - one it has to be named exactly the same
182:19 - name as the class okay so here we have
182:21 - our Constructor and here we can pretty
182:23 - much build whatever logic we want that
182:24 - is going to be run whenever the player
182:26 - is created up here for example we can
182:28 - add a console. right line and over here
182:30 - let's just say creating player okay
182:32 - great like this except we are actually
182:34 - seeing some errors over here it says
182:36 - that player is inaccessible due to it
182:38 - protection level now this has to do with
182:40 - access modifiers which is a topic that
182:42 - I'm going to cover in a few lectures for
182:43 - now let's not worry too much about it
182:45 - just know that over here on the player
182:47 - Constructor over here before we need to
182:49 - add the keyword public so it has to be
182:51 - like this public player and then the
182:53 - parenthesis so make sure you write that
182:54 - and there are no errors now and if we
182:56 - test and if there it is we can see we
182:58 - are indeed creating two players all
182:59 - right awesome now another thing we can
183:01 - do is Define functions inside of our
183:03 - class and we Define them just like we
183:05 - already saw the only difference is right
183:06 - now we actually don't need to mark it as
183:08 - static I won't cover what static means
183:09 - in detail in the next lecture but for
183:11 - now just know that if you're writing a
183:13 - function directly inside the program
183:14 - that you call it from Main for that you
183:16 - need to mark it as static because main
183:18 - itself is marked as static but down here
183:19 - when working with our class over here we
183:21 - don't need to mark it as static so for
183:23 - example let's define some kind of
183:24 - function let's return nothing so void
183:27 - and let's call it say hello and over
183:29 - here pretty simple we just do a console
183:31 - d right line and just print out hello
183:33 - okay great so with this our custom type
183:35 - now has a function as to how we're going
183:37 - to call this well up here we have an
183:39 - instance of our player class so we
183:40 - created our object we can simply access
183:42 - that object and then press on dot which
183:44 - again the dot means that we are
183:45 - accessing something inside the previous
183:47 - Sy so we're accessing something inside
183:49 - the Code Monkey player which is of the
183:51 - player type and now we can call our
183:52 - function except actually right now we
183:54 - can't again it's the same thing that I
183:55 - mentioned a while ago it has to do with
183:57 - the access modifiers that I'm going to
183:58 - cover in detail in a few lectures so
184:00 - again for now in order to make this
184:01 - testing work let's just make sure to
184:03 - mark this one as public so public void
184:04 - say hello and now if we go up here and
184:06 - press on thatt yep we do see our say
184:08 - hello function and now we can call it
184:10 - just like we call any other function yep
184:12 - just like this now importantly is we are
184:14 - going through an instance of our object
184:16 - so we're not going through the object
184:18 - class itself rather an instance of it if
184:20 - instead you do write the class name so
184:22 - you do player. say hello then know this
184:24 - is an error this does not work to call
184:26 - this function we want to call it through
184:28 - the actual object that is created of the
184:29 - player type and now at this point
184:31 - perhaps you might be noticing that for
184:32 - example over here the console not right
184:34 - Line This one is different for this one
184:35 - we are not actually creating a console
184:37 - object we simply access the function the
184:39 - right line function directly through the
184:40 - console class and again that has to do
184:42 - with static which I'm going to cover in
184:44 - detail later on so for now just make
184:46 - sure that the say hello function this
184:47 - one is is not marked the static and up
184:49 - here make sure we are calling say hello
184:51 - on the created Code Monkey player okay
184:53 - so with this if we test and if there it
184:54 - is creating the player and then calls
184:56 - hello okay great here we can see we are
184:58 - running a custom function inside of our
185:00 - custom type so since we can Define
185:02 - functions another thing we can do is
185:03 - also Define some class variables and for
185:05 - that we write them inside the class
185:07 - block so not inside a function we don't
185:09 - want to create a local variable we want
185:11 - to define a class variable so let's go
185:13 - up here just before the Constructor
185:14 - let's Define a variable like for example
185:16 - string name and if we want we can even
185:18 - give it a default value so let's say
185:20 - Code Monkey okay great so here we have
185:22 - defined a name variable and now if you
185:24 - remember from the scope leure from that
185:26 - one basically anything that we Define in
185:28 - a code block like a variable over here
185:29 - defined inside the class code block that
185:31 - means we can access this variable inside
185:33 - any of these nested code blocks so for
185:35 - example over here inside the hello
185:37 - function over here let's print out so
185:39 - let's use the string interpolation
185:40 - method and let's print out the player
185:42 - name okay so like this let's see and yep
185:44 - it does say hello Code Monkey okay great
185:46 - so far so good now by the way I'm
185:48 - calling this a class variable or member
185:50 - variables but sometimes I use the term
185:52 - Fields again it's another example of
185:54 - interchangeable names technically the
185:55 - more correct name for this is actually a
185:58 - field the word variable is more used for
186:00 - when it's a local variable defined
186:01 - inside a function but those terms are
186:03 - pretty interchangeable so if you show
186:04 - someone this code and you call this a
186:06 - variable they will understand what you
186:07 - mean okay so here we have defined a
186:09 - class variable or a field and like we
186:11 - saw up here we can access our object and
186:13 - call this function and we can access
186:14 - this field in the same way however again
186:16 - the same thing in order for that to work
186:17 - we need to mark this field also has
186:19 - public so we can access it from up here
186:21 - so over here we can go through the Code
186:22 - Monkey player and access the name and I
186:24 - can set it to something I can read it or
186:26 - modify it so for example for this one
186:28 - let's set it to code monkey and then for
186:31 - this other player down here for the Iron
186:32 - Man player let's set it to Iron Man and
186:35 - then let's call the say hello function
186:36 - on this one okay so let's test and see
186:38 - what this does and if there it is
186:40 - creating player then says hello Code
186:42 - Monkey creating the second player and
186:43 - says hello Iron Man so here we are
186:45 - creating objects modifying values inside
186:47 - of it and also calling some functions
186:49 - with this we can also go back and see
186:51 - exactly what I covered in the diagram in
186:53 - the beginning on how the objects that we
186:54 - create these are essentially objects
186:56 - that are separate from one another they
186:57 - are created from the same blueprint
186:59 - class but each of them are different
187:01 - each of them can have different values
187:02 - that is why over here we are creating
187:04 - two instances of our player type and
187:06 - then on one of them we are setting the
187:07 - name to Code Monkey the other one to
187:08 - Iron Man and that works because they are
187:10 - completely separate objects each with
187:11 - their own data so when over here we are
187:13 - modifying the name inside the Ironman
187:15 - player we are only modifying the name
187:16 - inside this specific object meaning it
187:18 - does not modify the name on The Code
187:20 - Monkey and does not modify the name on
187:22 - any other player object we have when we
187:24 - modify this we are only modifying this
187:25 - data on this object this is another
187:27 - really crucial thing to understand how
187:29 - each object each instance of a class
187:31 - each of those has its own data stored in
187:33 - memory Okay so we've already learned
187:34 - quite a lot about functions fields and
187:36 - Constructors another thing we can do
187:38 - over here on the Constructor is we can
187:39 - Define some parameters so pretty much
187:41 - like we would for a function for example
187:43 - let's say we receive a parameter for the
187:45 - string name then over here let's print
187:46 - out the name so creating player and then
187:48 - pass in that name okay like this and now
187:51 - up here when constructing our players
187:53 - for this one let's pass in Code Monkey
187:55 - and for this other one let's pass in
187:56 - Iron Man and for now let's just get rid
187:58 - of this other code so let's just leave
188:00 - those two so just doing this just
188:02 - constructing a Code Monkey player and an
188:03 - Iron Man player and yep it works
188:05 - creating each of them okay good so now
188:07 - here's an interesting scenario let's say
188:08 - we want to define the name over here on
188:10 - the Constructor and then we want to
188:12 - update this field and then we want to
188:13 - use that field down here right now that
188:15 - is actually not going to work so let's
188:17 - put the default name to something else
188:19 - let's put it just a dash just to make
188:20 - sure that it isn't updating on the first
188:22 - one let's test let's just go here Code
188:24 - Monkey player and let's call say hello
188:26 - and same thing on the iron man. say
188:28 - hello and yep look at that so it does
188:29 - create the player and does receive the
188:31 - Code Monkey string but then when saying
188:32 - hello it just has the default Dash that
188:34 - is because even though we called all of
188:36 - these we call them all name even though
188:38 - these are actually two separate symbols
188:40 - when we receive the name over here as a
188:42 - parameter in the Constructor this
188:44 - parameter over here is just a local
188:45 - variable by itself this parameter has no
188:48 - connection to this variable even though
188:50 - the name is exactly the same that still
188:51 - does not mean that they have any
188:53 - connection we need to explicitly Define
188:55 - that connection also by the way here's a
188:56 - quick tip on visual studio if you just
188:58 - place the cursor on top of a symbol it
189:00 - automatically highlights all instances
189:02 - of that symbol so note how over here it
189:04 - is highlighting this one and this one
189:06 - and does not highlight this one and this
189:07 - one that is a clue that these are two
189:09 - completely separate symbols even though
189:11 - they do have the same name if we click
189:12 - on this one yep it does highlight this
189:14 - one and this one but not these two so
189:15 - these are completely disconnected piece
189:17 - of data in order to connect them
189:18 - basically we just need to assign this
189:20 - variable to the one that we receed here
189:22 - so over here you might think to write
189:23 - name equals name with the assumption
189:25 - that the first name is going to refer to
189:27 - this one and the second one is going to
189:28 - return to this one but nope this doesn't
189:29 - really work we have a green squiggling
189:31 - line if and if we put it inside
189:33 - assignment made to the same variable so
189:35 - here once again we can use the cursor
189:36 - trick in order to see yep here we are
189:38 - referencing the same symbol we have no
189:39 - reference to this one itself so one
189:41 - option that we have here is choose a
189:43 - different name sometimes people like to
189:45 - solve this problem by adding an
189:46 - underscore n their parameters so you
189:48 - could add underscore here then one here
189:50 - and one here and doing so yep now this
189:52 - works so now these three instances are
189:54 - instances of this symbol but if we
189:55 - select that one yep now that one is that
189:57 - one and if we run this code and yep now
189:59 - it does work creates the player and says
190:01 - hello with the correct name so this
190:02 - works this is one option you can simply
190:04 - Define your parameter names to have
190:06 - different names from your class
190:07 - variables or another alternative method
190:09 - the one that I actually prefer is to
190:11 - write the exact same name so over here
190:12 - let's name this one exactly the same
190:15 - name name and also this one also name
190:17 - but here we have the problem we're
190:18 - always accessing the same thing so the
190:19 - way we change that the way we access
190:21 - this field specifically the way we do
190:23 - that is with a keyword this this is a
190:25 - special keyword that like name implies
190:27 - refers to this object it refers to the
190:29 - object itself where the code is running
190:30 - on so by using this we can essentially
190:32 - reference this object and doing that we
190:35 - can reference this class variable again
190:36 - we can put the cursor over in order to
190:38 - highlight and Y now we do see these
190:39 - three are referencing this symbol and
190:41 - these three are referencing this symbol
190:43 - and if we run this any of now this word
190:45 - creates both players and correctly
190:46 - assigns their name so once again we have
190:48 - two separate instances of our player
190:50 - class each with their own data and each
190:51 - with their own name we are setting that
190:53 - data through the Constructor itself and
190:55 - then we are using that data in some kind
190:56 - of function okay great so here we learn
190:59 - about classes this is one of the core
191:01 - building blocks of any object-oriented
191:03 - language like C this is yet another
191:05 - topic that you must make sure you fully
191:07 - understand rewatch this lecture if you
191:08 - need to classes are one of those things
191:10 - you are going to use a ton through your
191:11 - programming career so definitely make
191:13 - sure you fully understand it now in this
191:14 - lecture I briefly mention two things
191:16 - access modify and static so let's
191:18 - finally learn about those beginning with
191:20 - static in the next
191:21 - lecture hello and welcome I'm your kmy
191:24 - in this lecture we're finally going to
191:26 - learn what is the static keyword and
191:27 - what does it do okay so since the very
191:29 - beginning we've been working with this
191:31 - default code in the beginning I told you
191:32 - to just ignore the static over here but
191:35 - now since we have already learned what
191:36 - are classes now we can finally start to
191:38 - learn what is static in the previous
191:40 - video we wrote this code and I told you
191:42 - to make sure not to write static inside
191:44 - any of this either the field or the
191:45 - function what it means is when you you
191:47 - define something as static when you do
191:49 - that you are making that belong to the
191:51 - class itself as opposed to any instance
191:53 - of that class so if you make something
191:54 - static like a static score field if you
191:57 - do that then now that symbol that score
191:59 - that only exists on the class itself and
192:01 - does not exist as a separate copy for
192:03 - each individual object you create of
192:05 - that type so here when we made our
192:07 - custom class we wanted this function and
192:09 - this field we wanted that to belong to
192:11 - each instance of that class we wanted
192:13 - that as opposed to belonging to the
192:14 - class itself so that is why we made
192:16 - these intentionally non static and by
192:18 - doing that we made it so that up here in
192:19 - order to call this function we need to
192:21 - call the function on some kind of
192:22 - instance of our type so that is why we
192:23 - need to create a Code Monkey player in
192:25 - order to call the say hello and if we
192:27 - try doing player. say hello nope this
192:29 - does not work this is an error because
192:31 - we marked this as non-static means that
192:32 - we need an instance of our type in order
192:34 - to call this function and it's the same
192:36 - thing for the console. right line that
192:38 - we've been using for this one we can
192:39 - inspect this function so we can right
192:41 - click in here and then let's go into
192:42 - this one go to definition and if you do
192:44 - that yep it opens up this window which
192:46 - basically shows the code inside the
192:47 - right line function and over here we can
192:49 - see this function is indeed marked as
192:50 - static that is why when we use it we use
192:52 - it through the console class itself
192:54 - meaning we never do a new console and
192:56 - then using that console we call right
192:58 - line we don't do that since that one is
192:59 - Mark as static we access the console
193:01 - class itself and then call the function
193:03 - directly on the class itself so static
193:05 - means this belongs to the class itself
193:07 - and not any instance of that class as to
193:10 - when would you use this one example is
193:11 - over here on the console it's super easy
193:13 - to just write console. right line write
193:15 - something to the console is much easier
193:17 - as opposed to having to create a new
193:18 - console object having to keep track of
193:20 - that object in order to call the
193:21 - function we just access the function
193:22 - directly makes it super easy to use and
193:24 - then it can make sense if you have some
193:25 - kind of behavior or some kind of data
193:27 - that you want to belong to the class
193:29 - itself and not all the instances of that
193:31 - class like for example if you have some
193:32 - kind of score that is meant to be shared
193:34 - between all the other objects if so then
193:35 - it might make sense to Define that in
193:36 - class that way we have just one score
193:38 - field that is shared between all the
193:40 - various players in order to make
193:41 - something static it's really simple we
193:43 - just add the static keyword like for
193:45 - example over here on the say hello
193:46 - function let's mark this as static
193:48 - however in doing so we can already see
193:49 - two errors there's one over here on the
193:51 - name and one up here on our players so
193:53 - let's actually for now just comment out
193:54 - this code and let's just do player. say
193:57 - hello yep now this one does work because
193:59 - that function is now marked as static
194:01 - but now the are down here on the name
194:03 - like it says here an object's reference
194:04 - is required for a non-static field
194:06 - object reference is really just another
194:07 - word for object instance this basically
194:09 - means that we cannot access non-static
194:11 - Fields whilst inside a static function
194:13 - that is because again static means that
194:15 - it belongs to the class itself and not
194:17 - any instance so since this function does
194:18 - not belong to any instance naturally we
194:20 - cannot access any instance variables
194:22 - that is also why quite a while ago on
194:23 - the variables lecture when we were
194:25 - creating some class variables up here I
194:27 - said that if you want to create a
194:28 - variable that you wanted to access
194:29 - inside main you need to mark it as
194:31 - static if we just make an in age over
194:33 - here and over here try to access age
194:35 - equals something and over here try to
194:36 - access age equals something nope this
194:38 - does not work we cannot access it in
194:39 - order to make it work this needs to be
194:41 - static because main is static so whil
194:43 - inside a static function we can only
194:45 - access static fields in order to make
194:46 - our code would work here we can really
194:48 - just mark this one as static with the
194:50 - obvious side effect which is like I said
194:51 - this field now belongs to the class
194:53 - itself so with this we could not have
194:55 - multiple players each with different
194:56 - names by doing this there's pretty much
194:57 - just one name field regardless of how
195:00 - many player instances we have and by
195:01 - adding static over here we created yet
195:03 - another error right here and once again
195:05 - it has to do with this keyword which
195:06 - like I said this one refers to the
195:08 - object that this code is running on but
195:09 - once again this one is a static field
195:11 - meaning it does not belong to any
195:13 - instance so we cannot access it through
195:14 - a this which refers to a specific
195:16 - instance and if we remove this then we
195:18 - have the exact same problem we had which
195:19 - is all of these are referring to the
195:21 - same symbol so we want to access this
195:22 - one and as how we access a static field
195:25 - if we can't do it through this the
195:26 - answer is we access it through the class
195:28 - name so over here player. name and once
195:31 - again put the cursor over in order to
195:32 - highlight and yep now it is correctly
195:33 - referencing these two okay so we have no
195:36 - more errors now let's see what this is
195:37 - doing so first let's call player. hello
195:40 - and then let's create a new code monkey
195:41 - player and let's print player. say hello
195:44 - again and then let's create an Iron Man
195:46 - player and now let's print say hello
195:48 - again now if you want a quick challenge
195:49 - try to pause the video right now and try
195:51 - to guess what all of this is going to
195:53 - print on the console so which name is
195:54 - going to be printed over here on this
195:56 - function call which one on this one and
195:58 - which one on this one so if you want
195:59 - pause the video right now and try to
196:00 - give that a go try to get a guess over
196:02 - here let's run the code and see what
196:03 - this says and yep it says hello nothing
196:05 - then hello code monkey and finally hello
196:07 - Iron Man here we can clearly see how
196:09 - static data belongs to the class itself
196:11 - and not any instance of that class
196:13 - basically the first time we say hello
196:15 - the name is going to default to a dash
196:16 - so that is why print stash then we
196:18 - create code monkey and when creating
196:19 - that object that individual instance of
196:21 - that object is going to access the
196:23 - global name field that is inside the
196:25 - player class so the static field so
196:27 - we're going to update that one from Dash
196:28 - into code monkey that is why it prints
196:30 - that and finally create an Iron Man and
196:32 - again same thing that is going to modify
196:33 - and update and override the name so the
196:35 - name no longer says Code Monkey by the
196:37 - end it only says Iron Man the important
196:39 - takeaway here is that even though we are
196:40 - creating two instances of that object
196:42 - since over here we are accessing a
196:44 - static field remember the static field
196:46 - belongs to the class itself so we have
196:47 - just one of these even though we have
196:49 - two instances of our player now it might
196:51 - seem like I'm repeating myself a little
196:52 - bit too much in this lecture but this
196:54 - really is a crucial thing to understand
196:56 - the difference between making a field
196:57 - static or non-static the difference
196:59 - between how many instances of a field
197:01 - you have this is really crucial to fully
197:03 - understand so you don't get confused if
197:04 - it's static you have just one field that
197:06 - is shared between all the classes and if
197:08 - it's non-static then each instance of
197:10 - that type will have its own field like
197:11 - back here in the diagram we Define a
197:13 - static in score and this one is
197:14 - basically shared between all the other
197:16 - objects but then we have a non-static
197:18 - string name and inal and each object has
197:20 - their own copy has their own data within
197:22 - that field now we already saw how we
197:24 - cannot access a non-static field from a
197:26 - static function but the opposite is
197:27 - valid so here on say hello if I remove
197:30 - the static to make this a non-static
197:31 - function and if there is no eror down
197:33 - here while on a non-static function we
197:35 - can indeed access static Fields although
197:37 - again remember how a static field This
197:38 - one belongs to the class itself and
197:40 - there's really only one field that is
197:41 - shared between all instances of that
197:43 - class so for example up here let's
197:44 - create a new Iron Man Code Monkey so
197:46 - let's actually Al uncommon this code up
197:48 - here for example let's create a new code
197:49 - monkey player then let's create an Iron
197:51 - Man player and then let's print hello on
197:53 - the Code Monkey player itself so once
197:54 - again if you want a mini challenge try
197:56 - pausing the video right now and try to
197:58 - guess what this one will say and if we
198:00 - test and yep look at that it says hello
198:02 - Iron Man even though we are calling the
198:03 - say hello on the code Mony player object
198:06 - and the reason is once again because
198:07 - this field is static so when we create a
198:09 - new Iron Man that One is updating that
198:10 - static field to just say Iron Man so
198:12 - down here when we access static field we
198:14 - are accessing the only field that exists
198:16 - within the entire class now let's just
198:17 - learn one more tiny thing about static
198:19 - which is how you can mark the class
198:20 - itself as static so here you can write
198:23 - static class and basically by doing this
198:24 - the compiler forces you to make
198:26 - everything inside that class as static
198:28 - so we cannot have a regular instance of
198:30 - our player Constructor we cannot have
198:31 - this and we cannot have a non-static
198:33 - function it needs to be marked as static
198:35 - so just like this so this can be helpful
198:37 - for example when you want to make sure
198:38 - that everything is static if there are
198:40 - some kind of class like for example the
198:41 - console here if we once again right
198:43 - click and go to the definition we can
198:45 - see yep the console is smart as static
198:47 - you are never ever intended to create a
198:49 - new object of type console that is never
198:51 - supposed to happen everything inside
198:53 - this console class all of this should be
198:55 - static all the functions all the fields
198:57 - all of this should be static and use as
198:59 - static so in order to enforce that you
199:01 - can just add the static keyword and
199:02 - basically the compiler won't force you
199:04 - to make everything within that class
199:05 - marked as static so when you want that
199:06 - add static but when you want to mix
199:08 - between static and nonstatic then just
199:10 - don't add it and simply add static to
199:12 - the things that you do want to make
199:13 - static all right so that's static now if
199:15 - you're a beginner and you're slightly
199:17 - confused go ahead and watch this lecture
199:18 - again learning the difference between
199:20 - static and non-static is really
199:21 - important you need to fully understand
199:22 - the difference between what belongs to
199:24 - an object and what belongs to a class
199:25 - itself next let's learn about access
199:27 - modifiers this is something that is
199:29 - extremely important in order to write
199:30 - good clean code so let's learn that in
199:32 - the next
199:33 - lecture hello and welcome I'm your Cod
199:36 - monkey in this lecture we're going to
199:37 - learn all about access modifiers
199:39 - specifically private and public learn
199:41 - what they do and just how important they
199:42 - are okay so access modifiers like name
199:44 - implies it controls what kind of access
199:46 - we have with something we've already
199:48 - seen them a little bit a while ago when
199:49 - we defined these functions inside our
199:51 - class I told you that you need to make
199:52 - this public this is the access modifier
199:54 - in general you have two access modifiers
199:56 - you have public and private now
199:58 - technically there are more there's also
200:00 - protected and there's also internal and
200:02 - a bunch more so technically there are
200:03 - more but most case you will only be
200:05 - using either private or public now here
200:07 - I told you to make this public because
200:09 - if we don't Define the access modifier
200:10 - if we just do this just like this then
200:12 - up here we can see our function has an
200:13 - error it is saying the say hello
200:15 - function is inex accessible due to its
200:17 - protection level that is because if we
200:19 - don't specifically say public if we omit
200:21 - the access modifier then this one
200:22 - basically defaults to private so if we
200:24 - write nothing is the same thing as if we
200:26 - explicitly write private and like the
200:27 - eror says we cannot call the function
200:29 - because we have no access it is private
200:31 - when we make something private it is
200:32 - only accessible to that class and
200:34 - nothing else so up here we cannot call
200:35 - the sayell function but for example over
200:37 - here inside any code inside of the
200:39 - player class over here we can call say
200:41 - hello and Yep this one works perfectly
200:43 - so by making something private it means
200:45 - it can only be accessed by that class
200:47 - where it's been defined and what I'm
200:49 - saying here applies to functions but
200:50 - also to fields for example if this one
200:52 - is public then up here on the main we
200:54 - can access Iron Man player. name and we
200:56 - can set it to something so this works
200:58 - this is valid code however again if we
201:00 - omit this which again is going to
201:01 - default into private if so then yep now
201:03 - this one is inaccessible if we do want
201:05 - this field or this function to be
201:07 - accessible from outside then we do need
201:08 - to mark them as public so public string
201:11 - and over here public void now if you a
201:13 - beginner you might be thinking this is
201:14 - just adding needless confusion to the
201:16 - code you might be thinking why wouldn't
201:17 - you just make everything public so you
201:19 - can access everything from everywhere
201:21 - and that is one of those questions that
201:22 - is perfectly reasonable for a beginner
201:23 - to ask and as you grow your skills you
201:25 - will actually see just how valuable this
201:27 - is the next two lectures are going to be
201:28 - on the theory behind how and why to
201:31 - write good clean code and one of the
201:32 - main clean code principles is simply to
201:34 - limit access the reason why public and
201:36 - private exists the reason for this is
201:37 - all about helping you manage complexity
201:39 - and the best way to manage complexity is
201:40 - to limit accessibility so access
201:42 - modifiers are really extremely important
201:44 - like I said I'm going to cover this
201:45 - topic in much more detail in the next
201:47 - few lectures for now just know these are
201:49 - extremely important and as a general
201:50 - rule you should always default to making
201:52 - everything private and only make it
201:53 - public when you have a very good reason
201:55 - to do it so by default we should Define
201:57 - all of these as private so this one is
201:59 - private this one make it private and the
202:01 - public string make it private yep so by
202:02 - default we should start writing our code
202:04 - like this and then for each piece of
202:05 - code we write we should be able to ask
202:07 - ourselves okay does this need to be
202:08 - public and if so like for example over
202:10 - here we do intentionally want to create
202:11 - some player objects so we do want this
202:13 - one to be public then for the function
202:15 - we also want this code up here to be
202:16 - able to call the function so this one
202:17 - should be public however for the name
202:19 - field this one is meant to be an
202:20 - internal piece of data that is only used
202:22 - by this class so this one should be
202:23 - marked as private and out here we should
202:25 - not have access to that field so as
202:27 - general rule just follow that basic
202:29 - guideline default to making everything
202:30 - private and only make it public if you
202:32 - absolutely need to if you just follow
202:33 - that one very simple rule you will write
202:35 - much better much more high quality code
202:37 - and like we saw technically we don't
202:38 - need to write the access modifier if you
202:40 - want it private you can just submit it
202:42 - and this is going to default to private
202:43 - however personally I like being as
202:45 - explicit as possible so even though
202:46 - technically you don't have to write it
202:48 - personally I always write it every time
202:50 - I want to be very very clear that I want
202:51 - this to be private I don't want to have
202:53 - to remember where are the defaults
202:54 - because actually defaults default to
202:56 - different things depending on what code
202:57 - you're working on there is a great guide
202:59 - on the C docs that goes into this topic
203:01 - in a lot more detail so you can see all
203:03 - the various access modifiers and from
203:05 - where you can call some kind of thing or
203:06 - access some kind of variable and then
203:08 - down here if we scroll down we can see
203:10 - yep the default access summary table and
203:11 - you can see how for some things if we
203:13 - omit it it defaults to private but for
203:15 - other things it defaults to public and
203:17 - for others defaults to internal I'm
203:19 - going to cover all this in detail in
203:20 - future lectures interface strs inom and
203:22 - so on since the default actually
203:24 - defaults to various different things
203:25 - depending on what type we're working
203:26 - with that is yet another reason why I
203:28 - really believe you should be as
203:29 - extremely explicit as possible so over
203:31 - here do not just submit this let's write
203:33 - properly private and now that I've
203:35 - taught you what are access modifiers I
203:36 - can finally explicitly Define them over
203:38 - here on this code honestly this is
203:39 - something that has been driving me crazy
203:41 - throughout this whole course I didn't
203:42 - want to use them until I explained them
203:44 - I really don't like how this default
203:45 - code is set up but but now that you know
203:47 - what they are now I can finally refactor
203:48 - this code over here for the player class
203:50 - this one is only going to be used inside
203:51 - the program class so let's make it as
203:53 - private Again by defining this one as
203:55 - private means that we can use it inside
203:56 - of anything within this program class
203:58 - code block then for main let's also
204:00 - default this to private this our main
204:02 - entry point for our code so we don't
204:04 - want any other code calling this
204:05 - function and then for our program class
204:07 - instead of making internal let's make it
204:08 - public public because in this case this
204:10 - one is a global class inside this
204:12 - namespace and if we try making this as
204:14 - private then no this actually throws
204:16 - error basically elements defined in a
204:17 - name space itself these need to be
204:19 - either internal or public so let's put
204:21 - it as public okay so now the code is
204:23 - much more explicit everything is much
204:25 - more clear we can know for certain that
204:26 - the main is only going to be the entry
204:28 - point and it's never going to be called
204:29 - from anywhere else we can see that this
204:31 - player class is only going to be used
204:32 - inside the program class and within the
204:34 - player class we can see that the
204:35 - Constructor is meant to be accessible
204:37 - from outside this function also
204:38 - accessible outside but this name field
204:40 - this one is meant to be only used by
204:41 - this class okay so with that we have
204:43 - learned about the basic access modifiers
204:45 - and this pretty much concludes the
204:46 - absolute Basics so now like I said in
204:48 - the next few lectures let's learn a
204:49 - little bit more on the theory behind how
204:51 - to write good clean code starting with
204:53 - one of the most important guidelines for
204:55 - that which is naming rules so let's
204:56 - learn that in the next
204:58 - lecture hello and welcome I'm your Cod
205:00 - Maki in this lecture we're going to
205:02 - learn something extremely important
205:03 - let's learn about naming rules this is a
205:05 - very very important lecture that you
205:07 - should definitely refer back to whenever
205:08 - you have any questions following good
205:10 - naming rules is something that will make
205:11 - you a 10 times better program so first
205:13 - what exactly are naming rules these are
205:15 - really just rules you define and then
205:17 - follow while writing your code it is
205:19 - extremely extremely important that you
205:20 - are consistent in applying your rules
205:22 - you don't want one class in your project
205:23 - to be written a certain way and a
205:25 - different class using a completely
205:26 - different naming scheme that would
205:27 - create a ton of confusion make it really
205:29 - hard to read the code so naming rules
205:31 - and writing code correctly is very very
205:32 - important one mistake that I see a lot
205:34 - of beginners do is they send me some
205:35 - code and ask why it's not working then I
205:37 - take a quick look and see all the code
205:39 - written in a very messy way some
205:40 - functions are in lower case others using
205:42 - snake case some fields are in Pascal
205:44 - case some in camel case always remember
205:46 - remember code is case sensitive so it is
205:48 - really extremely important that you
205:49 - write the code correctly if you change a
205:51 - character from lowercase to uppercase
205:52 - then you are suddenly referring to
205:53 - something completely different if you
205:55 - are a beginner always keep that in mind
205:56 - code is case sensitive so don't just
205:58 - write code semi- randomly write it
206:00 - properly as if you were doing some kind
206:02 - of English test now with that said when
206:03 - it comes to naming rules you can use
206:05 - whatever rules you want different people
206:07 - like different rules for example some
206:08 - people like to use a prefix and
206:10 - variables they like to add an underscore
206:11 - or M underscore or other people like to
206:14 - use a postfix some people like capitals
206:15 - for Capal case for properties St case
206:18 - for fields which by the way here are the
206:20 - definitions for those terms Pascal case
206:22 - this one starts with a capital letter
206:24 - and then it is lower case and then a
206:26 - capital for every word afterwards then
206:28 - chemel case this one also has a capital
206:30 - for every second word but the first one
206:31 - is lowercase and finally snake case for
206:34 - this one you just use an underscore to
206:35 - separate the various words these are
206:37 - usually the various ways you have of
206:38 - naming some kind of symbol and like I
206:40 - said the specific rules you follow don't
206:41 - necessarily matter every rule can be
206:43 - valid the most important thing is just
206:44 - that you are consistent and always
206:46 - always following through your rules so
206:47 - Define some kind of code style and
206:49 - always stick with it for me here are the
206:50 - rules that I follow and the code style
206:52 - that I use for function names I like to
206:54 - use Pascal case this is also the C
206:56 - standard so always capitalize the first
206:57 - letter of every word then for the
206:59 - function parameters for that I use
207:00 - chamel case so it starts lower case and
207:02 - then upper case after every word then
207:04 - for properties this is something that
207:06 - I'm coming to cover in detail in the
207:07 - intermediate section for these I use
207:09 - Pascal case for Conant again another
207:11 - thing I cover in the intermediate for
207:13 - this one normally use uppercase snake
207:15 - case so everything is uper case and use
207:17 - a little underscore to separate the
207:18 - words events are in Pascal Cas and then
207:21 - films these are in cam then another one
207:23 - of my personal rules is something that I
207:25 - mentioned in the beginning lectures
207:26 - which is a position for the opening of
207:28 - the curly braces now personally I do
207:30 - like opening it on the same line but
207:31 - some people prefer to place the opening
207:33 - on new line I know some people have some
207:35 - really strong opinions about this but
207:36 - really this is just the visual style
207:37 - that I personally prefer it's probably
207:39 - due to the fact that when I started
207:40 - learning programming when I was 10 years
207:42 - old I was writing some Mir scripts which
207:43 - you use this style so I'm very used to
207:45 - it and I like it but it's really just a
207:47 - visual thing if you like the currently
207:48 - brace on new line then by all means go
207:50 - ahead and use it and for some more very
207:51 - useful general rules first is spend time
207:53 - deciding on a proper name don't just use
207:55 - the first name that comes to your head
207:56 - actually think what would be the proper
207:58 - name for this symbol also do not use
208:00 - single letter names a lot of beginners
208:01 - like use this just because for some
208:03 - reason they want to be as compact as
208:04 - possible but remember the goal with code
208:06 - is not really to be compact it's to be
208:08 - understandable and single letter names
208:09 - usually are terrible the only exception
208:11 - for that would be it readers on a for
208:13 - Loop for those it's perfectly fine to
208:14 - use just an i or a j but for Prem much
208:16 - anything else use a proper name and not
208:18 - a single letter related to that also
208:19 - don't use acronyms or abbreviations
208:21 - those might seem really clear to you
208:23 - right now when you're writing the code
208:24 - but in a few weeks when you yourself get
208:26 - back to the code you might not remember
208:27 - what those mean again don't be afraid of
208:29 - being verbose if the most accurate name
208:31 - you can come up with is somehow 20
208:33 - characters long then really that's a
208:34 - name remember you don't get bonus points
208:36 - for writing extremely compact code so
208:38 - always always value making your code
208:39 - readable and understandable even if it
208:41 - requires functions and variables with
208:43 - very long names and the final extremely
208:44 - extremely important rule is simply don't
208:46 - be afraid to rename things if you come
208:48 - up with a name and later on you come up
208:49 - with a much better name then just take a
208:51 - second to rename it with Visual Studio
208:52 - shortcut it's insanely easy you just
208:54 - place the cursor over something like for
208:56 - example the player class let's say
208:57 - instead of this being used just for
208:58 - Players let's say it was also used for
209:00 - enemies so I want to really name this
209:02 - unit the shortcut is Control Plus RR and
209:04 - it shows up this window and now we can
209:06 - easily rename it and yep look at that it
209:08 - renames every instance of this type so
209:09 - renaming things is really super easy so
209:11 - definitely make sure to do it if you
209:13 - come up with a better name come back and
209:14 - rename that symbol always remember code
209:16 - is not fixed it is meant to adapt and
209:18 - grow as you work on it and part of
209:20 - working on it is refactoring and
209:21 - renaming things so don't be afraid to do
209:23 - that okay so these are my general rules
209:25 - and the code style that I personally
209:26 - follow like I said you don't have to
209:28 - follow my rules figure out what works
209:30 - for you and follow your own rules but
209:31 - naturally here in this course I won't be
209:33 - using my code style so if when following
209:34 - this course you're not sure how to write
209:36 - some type of code come back to this
209:37 - lecture and watch it again like I've
209:39 - mentioned many times the code that I
209:40 - teach you how to write in my courses
209:42 - that is on the same level of quality as
209:43 - my Professional Steam games so as such
209:45 - this lecture this topic on Main rules
209:47 - this is extremely important if you just
209:48 - follow these rules or whatever rules you
209:50 - can come up with if you just do that you
209:52 - will save yourself a ton of
209:54 - headaches hello and welcome I'm your
209:56 - codm in this lecture we're going to
209:58 - learn more on the theory on how to write
210:00 - good clean code so first of all what
210:02 - exactly is clean code now there are many
210:05 - definitions for this for me it simply
210:07 - means writing code that is easy to
210:09 - understand and easy to modify with bat
210:11 - code you need to look at it for a real
210:13 - long time to try and work out what on
210:15 - Earth that code is doing whereas with
210:17 - clean code the intent of the code should
210:18 - be immediately obvious everything is
210:21 - very clear and straightforward and
210:22 - requires no effort to understand what
210:24 - exactly it's doing that's the goal the
210:26 - most important thing is simply following
210:27 - a good set of naming rules like I
210:29 - covered in the previous lecture always
210:31 - always choose good descriptive names for
210:33 - all your variables all your functions
210:35 - classes and really anything if you just
210:37 - do that then your code won't be
210:39 - infinitely higher quality than someone
210:40 - who does not follow any naming roles
210:42 - beyond that here's some more General
210:44 - guidelines starting off with a simple
210:46 - one try to avoid magic numbers these are
210:49 - numbers that are used directly in the
210:50 - code with no context for what exactly
210:52 - they mean like for example in this code
210:54 - this one has a bunch of numbers and just
210:57 - by looking at it you can't really tell
210:58 - what those numbers are supposed to mean
211:00 - after studying the code for a little bit
211:02 - you might be able to tell that for
211:03 - example over here this is supposed to be
211:05 - the Super bonus damage amount and for
211:07 - example over here if you see an if
211:09 - testing if the distance is under five
211:11 - and if so call the attack then probably
211:13 - this means this is the attack distance
211:15 - and over here test tesing if the
211:16 - distance is above 10 then go to jump so
211:18 - this should be some kind of jump
211:19 - distance so it requires spending some
211:21 - time in order to understand what the
211:22 - code is doing so by using magic numbers
211:24 - it Opus skates what the code is actually
211:26 - doing so instead of this we can improve
211:28 - this code by quite a bit by simply
211:30 - defining proper named local variables so
211:33 - over here just Define int for the super
211:36 - damage amount multiplier just set it to
211:38 - two and over here instead of that just
211:40 - use this one and now it is very clear
211:42 - what exactly this line of code is doing
211:44 - same thing over here let's def find n
211:46 - for the attack distance and over here n
211:49 - for let's say the jump distance and Y so
211:52 - now the code is much more clear much
211:54 - more understandable you can literally
211:56 - just read this and it makes perfect
211:57 - sense as if it's in proper English so if
212:00 - the distance is under the attack
212:01 - distance you attack if the distance is
212:03 - above the jump distance you jump super
212:05 - simple so with this there's no need to
212:07 - waste any brain power trying to
212:08 - understand the code all of it is
212:10 - immediately understandable another
212:12 - simple one is how you should never ever
212:14 - use strings as identifiers strings are
212:16 - terrible as identifiers because they
212:18 - make it extremely easy to make all kinds
212:20 - of mistakes for example look at this
212:21 - code over here I'm using a string
212:24 - identifier in order to find the name of
212:26 - a chall object and here in unity you can
212:28 - see that this code actually throws an
212:30 - error it throws a non reference
212:31 - exception here the code is doing a
212:33 - transform. fine to get the chn Sprite
212:35 - then goes gets the Sprite run and
212:36 - changes the color so quick question can
212:39 - you spot the air instantly and I'll give
212:41 - you a hint the a is actually not in here
212:43 - the is actually over here in the editor
212:45 - so again Can you spot it and the answer
212:47 - is no I know for certain that you cannot
212:49 - spot it because the air is literally
212:50 - invisible here in the code I'm looking
212:52 - for a child that is named exactly Sprite
212:55 - and here in the editor doesn't look
212:56 - correct over here looking in the
212:58 - hierarchy it does look like it has a
212:59 - child name Sprite however if I go on the
213:02 - inspector and I click over here on the
213:03 - name y look at that that's the issue it
213:06 - turns out that this child name this one
213:08 - has an invisible space at the end so the
213:10 - code is indeed perfectly correct there
213:12 - are no compiler errors here because
213:13 - everything is correct but it is looking
213:16 - for a child with this exact same name
213:17 - just Sprite and since the actual object
213:20 - has an invisible space at the end it
213:21 - does not 100% match the Sprite name
213:23 - identifier this exact mistake is
213:25 - something that has happened to me
213:26 - several times and drove me insane every
213:28 - time it happened or here is another
213:30 - example look at all of these strengths
213:32 - so can you quickly add a glance on the
213:33 - difference between all of these it
213:35 - probably takes you a little bit because
213:37 - visually they all look quite similar but
213:39 - identifiers are case sensitive so
213:41 - looking quite similar does not matter if
213:44 - it is now 100% exact it will not work so
213:47 - if you had an object with any of these
213:48 - names and you accidentally mistyped or
213:50 - wrote any of these other names if you
213:52 - did that you would get an error and you
213:53 - would not know what exactly is going
213:55 - wrong whereas if you don't use strings
213:57 - like for example over here I've got a
213:59 - variable named player 10 I construct a
214:01 - brand new player and I call some kind of
214:02 - function on the player if I use this
214:05 - instead of using a string if so if over
214:07 - here I mistype like for example I change
214:09 - this one into a lowercase L which looks
214:11 - quite similar but right away the
214:12 - compiler tells me there's an error so
214:15 - with this I can fix the eror without
214:16 - ever needing to run the code strings
214:18 - should pretty much only ever be used for
214:20 - text so you use them to store the player
214:22 - name or the name of some kind of object
214:24 - but never ever use a string to identify
214:26 - an object if you need to identify an
214:28 - object use a direct reference or some
214:30 - kind of strip long object or an enum or
214:32 - a tack component literally anything
214:34 - except a string name now as always with
214:36 - every rule there are exceptions
214:38 - sometimes especially when working with
214:39 - things like web development that usually
214:41 - involves a lot of Json and some simple
214:43 - HTTP text requests sometimes times you
214:46 - really have no choice and have to use
214:47 - some kind of string identifier in those
214:49 - case you should still avoid strings
214:51 - whenever possible if you need a string
214:53 - to Define some type of data consider
214:55 - defining a consant and never use the
214:56 - string itself only use the Conant if you
214:59 - do that and you mistype the Conant name
215:00 - the compiler will tell you but basically
215:03 - try to avoid using strings that
215:04 - identifiers at all costs then one
215:06 - extremely important principle in writing
215:08 - good clean code is the concept of
215:10 - managing complexity that's really the
215:12 - main difficulty as you write bigger and
215:14 - more complex projects the difficulty is
215:16 - in successfully avoiding becoming
215:18 - overwhelmed by managing that complexity
215:20 - as the project grows and for that your
215:22 - best tool is called information hiding
215:25 - meaning for any code that you write like
215:27 - a class you should only expose as little
215:29 - as possible in order for the class to be
215:31 - usable for example specifically in unity
215:33 - a lot of unity tutorials tget that
215:35 - beginners teach you to make every single
215:37 - fi public but this is absolutely a
215:39 - terrible Code Practice I made the entire
215:41 - video on this subject by making it
215:44 - public it makes this field easily
215:45 - accessible in the unity editor which is
215:47 - usually the goal however it has a side
215:49 - effect because it makes it also
215:51 - accessible from any other script now for
215:53 - a beginner this might sound like a good
215:55 - thing you can easily access anything
215:56 - from anywhere but that means that every
215:58 - single class in your entire code base
216:00 - which could be a thousand classes long
216:02 - every single one of those could
216:04 - potentially access and modify that field
216:06 - so as you write your code you have to
216:07 - constantly keep in mind that scenario so
216:09 - that's a lot of Wast of brain power so
216:11 - like I said the simple but extremely
216:13 - important guideline to follow is simply
216:14 - only exposed as as much as you need to
216:16 - and no more so do not default to making
216:18 - everything public all the time instead
216:20 - default everything to private and only
216:22 - use public when absolutely necessary if
216:25 - a field is only ever used in that class
216:28 - then there's no reason to make it public
216:30 - it should always be private that way
216:32 - when working inside of this class you
216:34 - don't have to keep in mind the entire
216:36 - code base you can just focus on this one
216:38 - single class since you know for certain
216:40 - no other class can ever touch any of
216:42 - these fields you could have a project
216:43 - with a million classes but but if this
216:46 - field is marked as private then it does
216:47 - not matter nothing else can touch this
216:49 - field other than this class same thing
216:51 - for functions if you have a function
216:53 - that is only ever used by a single class
216:55 - then keep that function private do not
216:57 - make it public if you do then some other
216:59 - class in your thousands of classes some
217:01 - other one could call that function which
217:03 - could cause some unintended results and
217:05 - if there is some kind of field that you
217:07 - need to access instead of making it
217:08 - public consider instead keeping it
217:11 - private and simply exposing some
217:12 - functions to get it and set it that way
217:14 - you have a lot more control control over
217:15 - how the underlying field is modified and
217:18 - you can even add some logs over here if
217:19 - you need to alternatively properties
217:21 - work as well you can make it a property
217:23 - and add some code in the getter or
217:24 - Setter I cover properties in the lecture
217:26 - in the intermediate section so in
217:28 - general whenever you write a field or
217:30 - function or anything always default to
217:32 - making it private always switch to
217:33 - public if you absolutely need to just
217:35 - following this one simple guideline will
217:37 - help you limit how much access different
217:39 - pieces of your codebase have towards
217:41 - other parts of your codebase which in
217:42 - turn helps you minimize the total number
217:44 - of connections which in turn helps you
217:46 - manage complexity even as the project
217:48 - grows one great principle is the single
217:50 - responsibility principle this means that
217:52 - each class or functions should do one
217:54 - thing and one thing only so if you have
217:56 - a game and you have some kind of player
217:58 - class you probably should not keep any
218:00 - kind of enemy logic directly inside that
218:02 - class that should probably exist in a
218:04 - separate enemy class same thing for
218:06 - functions each function should do one
218:08 - thing and one thing only don't write a
218:10 - thousand line functions that do 10
218:12 - different things at once one good
218:14 - heuristic for seeing if a function is
218:16 - too big is simply if the best name that
218:18 - you can come up with contains the word
218:20 - and if so that probably means that
218:22 - function is doing more than one thing
218:23 - and would probably be best split into
218:25 - separate functions another related one
218:27 - is to keep your functions short so this
218:29 - kind of follows the same as the previous
218:31 - principle if your functions only do one
218:33 - thing they will probably be quite short
218:35 - if they are big then chances are they
218:36 - are doing more than one thing but this
218:38 - is also a very adaptable guideline that
218:40 - you should adapt to the situation for
218:42 - example in my game dinky Gardians I have
218:44 - quite a few relatively large functions
218:47 - breaking those apart into smaller
218:48 - functions would actually make the code
218:49 - hard to understand instead of easier so
218:52 - all of these guidelines do depend on the
218:54 - specific use cases but on average your
218:56 - function should be relatively short if
218:58 - your program is mainly composed of five
219:00 - underline functions chances are there's
219:02 - some room for improvement remember that
219:04 - refactoring is your friend and a
219:06 - Perfectly Natural part of the process
219:07 - another good one is group logic together
219:10 - meaning for example let's say I have
219:11 - some stats in my player class I've got
219:13 - these in my player class and let's say
219:15 - I've got some sort of UI class that I
219:16 - want to display these since these three
219:19 - separate Fields these are all really
219:20 - part of the same thing these are all
219:22 - player stats instead of working with
219:24 - three separate Fields instead of having
219:26 - to for example call some function on the
219:27 - UI that takes in three separate
219:29 - parameters instead of that consider
219:31 - making a custom type just to hold these
219:34 - stats so something like player stats
219:36 - that inside contains all those and then
219:38 - you would simply have a field just one
219:40 - field of typ player sets that contains
219:41 - all of the player sets that way thata
219:44 - that belongs together is actually
219:46 - together this simplifies things and
219:47 - makes it quite easier to understand in
219:49 - terms of comments the guidelines are the
219:51 - ones that already mentioned in the
219:52 - comments lecture in general you should
219:54 - avoid using comments if you need a
219:56 - comment before you actually write that
219:58 - comment see if you couldn't just rename
220:00 - some variables to make the code intent a
220:02 - bit more clear in most cases
220:04 - well-written code is going to be
220:05 - self-documenting but at the same time
220:07 - comments can be useful if your code is
220:09 - already extremely clear but you'd still
220:11 - like to provide some extra information
220:12 - on something like for example why you're
220:15 - doing doing that code or how that
220:16 - function should be used another good one
220:18 - is simply called dry or don't repeat
220:20 - yourself basically if there's some code
220:23 - that you need to run three times you
220:24 - probably should have a dedicated
220:26 - function instead of copy pasting that
220:27 - code three times although remember these
220:29 - are just guidelines meant to help you so
220:31 - don't look at these as some unbreakable
220:33 - laws in general code should be unique
220:36 - although sometimes you might need to
220:37 - copy paste twice in some scenarios
220:39 - that's fine but if you find that you
220:40 - need the exact same code copy pasted
220:42 - three or four times chances are that's a
220:44 - signal for some refactoring and speaking
220:46 - of refactoring this is an extremely
220:48 - important process that you should be
220:49 - doing at all times refactoring is the
220:51 - act of rewriting or reorganizing code to
220:54 - keep the code quality as high as
220:55 - possible this is a very very important
220:57 - topic and there is a dedicated lecture
220:59 - on refactoring in the beginning of the
221:01 - intermediate section so these are just a
221:03 - handful of nice guidelines to keep in
221:05 - mind to help you write good clean code
221:07 - that will help you a lot as your
221:08 - projects grow in scale and complexity
221:10 - although also do keep in mind these are
221:12 - just guidelines they are not holy rules
221:14 - that must never be broken the ultimate
221:16 - goal of all of these guidelines is to
221:18 - help you achieve your goals always
221:19 - remember that it is always up to you as
221:22 - a programmer to figure out when to
221:23 - follow the guidelines and when it's okay
221:25 - to break them there are some people that
221:27 - follow some specific code rules so
221:28 - rigidly that it actually makes the code
221:30 - worse so don't be like that follow these
221:32 - guidelines which will help you in most
221:33 - scenarios but also always be willing to
221:36 - adapt to the specific code you're
221:37 - writing now on this topic personally I'm
221:39 - a huge believer in writing good clean
221:41 - code if you're a regular on my YouTube
221:42 - channel certainly you've heard me talk
221:44 - quite a lot about it the reason why I
221:46 - love it so much is because I spent a lot
221:48 - of time writing a ton of code where I
221:49 - did not care about code quality I've
221:51 - been writing code since I was 10 years
221:53 - old and I really only started being very
221:55 - careful with the code that I write since
221:56 - I was some like 25 so I've already
221:58 - suffered quite a lot because of code
222:00 - that I would write with some nonsense
222:01 - variable names or some obscure acronyms
222:04 - and then later on when getting back to
222:05 - that code I would have no idea what I
222:07 - wrote or how I could expand upon it
222:09 - because that I really hope to help you
222:11 - avoid the suffering that I went through
222:13 - if you are a beginner I hope you can
222:14 - start off with on the right foot by
222:16 - focusing on writing good clean code
222:17 - right from the start if you do that it
222:19 - will help you learn faster and grow your
222:21 - skills by a massive amount now if you're
222:23 - looking for some more info on this topic
222:25 - there are tons of sources to learn from
222:27 - the one that I highly High recommend is
222:29 - the book code complete reading this book
222:31 - alone massively improved my code skills
222:33 - by 100 fold it really is that good it's
222:36 - a pretty massive book it's over 800
222:38 - pages long and all really technical so
222:40 - it takes quite a while to get through it
222:42 - but if you do read through it and you
222:44 - fully understand everything
222:45 - if so you will come out the other side
222:47 - an excellent programmer capable of
222:48 - building any program or any game you can
222:50 - think
222:51 - of hello and welcome I'm your Cod monkey
222:54 - in this lecture we're going to see a
222:56 - nice beginner project that incorporates
222:57 - everything we've learned so far okay so
222:59 - let's inspect this project to see how
223:01 - everything we've learned so far is being
223:02 - used it's in the unity project so just
223:05 - go inside lectures then inside the
223:06 - beginner project and load up this scene
223:08 - then let's go ahead head on play and yep
223:10 - so here is the mini game running there
223:12 - is a player and I can move it by
223:14 - pressing either the arrow keys or W ASD
223:16 - every time I press I move a certain
223:18 - amount we can see the player is
223:19 - currently holding zero coins so I can
223:21 - move around and as I approach and touch
223:23 - one of these coins yep it picks it up so
223:24 - I can pick up a whole bunch of them yep
223:27 - that works then there are two buildings
223:29 - I can approach to interact with them and
223:31 - when I'm close enough I can press space
223:33 - and this building this gives me one coin
223:35 - and if I go onto the other building so I
223:37 - go straight to the right and once again
223:39 - I interact and yep now this one gives me
223:40 - three coins all right awesome so this is
223:42 - a super simple demo and importantly it's
223:44 - using everything that we've learned so
223:46 - far so let's inspect how this is working
223:48 - here in the project files we can see how
223:50 - this demo is really pretty simple we
223:52 - just have two files for our two classes
223:54 - and the coin file this one is super
223:55 - small let's go ahead and open it this
223:57 - one is mostly meant to just tag an
223:59 - object as of being of the coin type by
224:01 - the way right now you can ignore this
224:02 - syntax where it has a colon that says
224:05 - mono Behavior this is a Unity specific
224:07 - thing and this column here has to do
224:08 - with class inheritance I'm going to
224:10 - cover that in detail in a lecture in the
224:12 - intermediate section but for now don't
224:13 - worry about this here coin this one is
224:15 - really just a simple class so just like
224:17 - we covered and inside we can see the use
224:19 - of a nice function it is called destroy
224:21 - self returns nothing and has no
224:23 - parameters and in turn really this one
224:25 - just destroys this game object if we
224:27 - look in the editor over here in the
224:28 - hierarchy we can see a whole bunch of
224:29 - coins so all the coin spread out
224:31 - throughout the world each coin is really
224:33 - just a game object and in turn it has a
224:35 - spread render in order to show the coin
224:36 - Visual and then just has a coin script
224:38 - that we attached so on this function all
224:40 - we're doing is just destroying that game
224:42 - object and also note how the function is
224:44 - marked as public this is important
224:46 - because we're not going to call this
224:47 - function from inside the coin class but
224:49 - rather from the player class so let's
224:50 - look at that one here is the player
224:52 - class so most Logic for this little mini
224:55 - games over here inside this class so
224:57 - first of all the player itself is yet
224:58 - another class then we can see up top we
225:00 - have some nice class fields we have a
225:02 - field for a text mesh Pro object looking
225:05 - in the inspector we can select the
225:06 - player and we can look in the inspector
225:08 - looking in the editor we can select the
225:10 - player game object and look in the
225:11 - inspector and again this one also has a
225:13 - Sprite render for the visual and then we
225:15 - have our player script here we have the
225:16 - reference to the coin text mesh object
225:18 - and that's really just a child object of
225:20 - the player this is really just what
225:21 - shows the text then we can also see that
225:23 - we have a float for the move spein and
225:26 - the movement logic that one is handled
225:28 - over here inside the update function now
225:30 - this update this is a special Unity
225:32 - thing that runs automatically on every
225:34 - single frame so don't worry about the
225:35 - fact that technically we're not calling
225:37 - this function from anywhere as you can
225:38 - see this is actually called
225:39 - automatically by Unity on their backend
225:41 - so we have the update function and then
225:43 - over here we have some examples of some
225:45 - simple ifs so we're doing an if and then
225:47 - for the condition here we have two
225:49 - conditions and first we are testing for
225:51 - the input get key down for the double
225:53 - key this is a function from Unity that
225:55 - checks if the player is pressing some
225:56 - key so in this case pressing the double
225:58 - key and this function we can expect and
225:59 - see this one is going to return a
226:01 - bullion so when the player presses the
226:02 - double key this is going to return true
226:04 - and then here we also see an example of
226:06 - a logical or so we are testing if the
226:08 - player is pressing the double key or if
226:10 - they are pressing the up Arrow this way
226:12 - the game is playable with either W ASD
226:15 - or with the arrow keys so it evaluates
226:16 - these two conditions and when the player
226:18 - presses either W or the up Arrow when so
226:20 - this is going to return true so we're
226:22 - going to run the code inside if and over
226:24 - here this logic simply takes the
226:25 - transform this refers to the transform
226:27 - that this script is attached to so in
226:29 - this case the player transform the
226:30 - transform field itself this is another
226:32 - Unity specific thing so don't worry
226:34 - about the fact there's no reference of
226:35 - it up here that is actually inside the
226:37 - monob behavior based class which again
226:39 - I'm going to cover inheritance in detail
226:41 - in a future lecture so here we access
226:43 - the transform and we're going to modify
226:44 - the position we do plus equals meaning
226:46 - we're going to add onto that position
226:48 - and then we are creating a vector three
226:49 - which is a type inside the position so
226:51 - this really just a strug that contains
226:53 - an x y and Zed again it's another Unity
226:55 - type so we take that and we're going to
226:56 - increase it by zero on the X zero on the
226:59 - Zed but plus one on the Y meaning we're
227:01 - going to move our player upwards and for
227:03 - the movement amount we're going to
227:04 - multiply it by move speed which is our
227:06 - variable that we have exposed in the
227:07 - editor that way we can easily modify how
227:10 - fast we move so that's logic just a
227:12 - basic if some conditions and doing some
227:14 - basic movement applying that to all of
227:16 - the keys ws and D so moving up down left
227:19 - and right and here in the game we can
227:21 - test it so like this if I move I moving
227:23 - by this amount and if over there in the
227:25 - move speed I modify this let's say put
227:26 - it on five and if now it moves quite a
227:28 - lot more Okay so we've already seen
227:30 - classes functions variables and if
227:32 - statements In Action Now up here we can
227:34 - also see two lists there is a list of
227:36 - type coin for our coin list and a list
227:38 - of type transform for the building
227:40 - transform list here in the editor again
227:42 - selecting the player and we can see both
227:43 - of our lists and these are referencing
227:45 - the objects that are assigned in the
227:47 - hierarchy so basally what I did is this
227:49 - list started off as empty and I just and
227:51 - I just dragged and dropped each element
227:52 - individually so I dragged all the
227:54 - references to all the coins as well as
227:55 - all these buildings so back in the code
227:57 - here we have our lists and then over
227:59 - here on the update we are calling this
228:01 - function handle coins and the function
228:02 - does exactly what it says it handles all
228:04 - the coin logic it is being called up
228:06 - here on update meaning that this
228:08 - function is going to run on every single
228:09 - frame and inside here we have an example
228:12 - of Loops we are cycling through all the
228:14 - coins in the coin list using a 4 in and
228:16 - then first we do a test to check if the
228:18 - coin is not null and then first we do a
228:20 - test to check if the coin is not null
228:22 - meaning that the coin has not been
228:23 - destroyed just yet so here we see an
228:25 - example of a useful comment it is easier
228:27 - to understand this code by reading the
228:29 - comment rather than the code the comment
228:31 - provides some extra clarification on
228:33 - what exactly this code is doing since
228:34 - checking for n that could technically
228:36 - mean a bunch of things so in this case
228:38 - we are checking if it hasn't been
228:39 - destroyed we do that and then we're
228:40 - going to test the distance so we're
228:42 - going to use the static function inside
228:44 - the Vector three this tests the distance
228:46 - between two points so we're testing
228:48 - distance between transform. position
228:49 - meaning the position of the actual
228:51 - player and then the coin. transform.
228:53 - position meaning the position of the
228:54 - coin if that is under a certain amount
228:57 - so again over here we're keeping our
228:59 - code clean and using a proper local
229:01 - variable in order to make this much
229:02 - easier to understand so it test it and
229:04 - if it is under this amount if so then
229:06 - we're going to pick up the coin so here
229:08 - we add a coin to the player and then we
229:09 - tell the coin to destroy itself so again
229:11 - this is why it's important that the
229:12 - destroy itself is marked as public it's
229:14 - so that the player class can call it if
229:16 - this function was marked as private then
229:17 - the player would not be able to call it
229:19 - so we have this and on the add coin
229:20 - function it's all super simple it just
229:22 - increments a coin amount so this is just
229:24 - a simple INF field that we have up here
229:26 - so just a coin amount we have that and
229:28 - then we assign the coin amount to the
229:30 - text object in order to update the text
229:32 - however also note how coin amount is an
229:34 - INT whereas the text field this one
229:36 - expects a string so that is why we need
229:38 - to convert our in into a string which we
229:40 - can do by calling two string so here in
229:41 - the game I can move around and as I
229:43 - approach a coin yep I can pick it up any
229:45 - up it works it increments the text and
229:46 - everything works okay great then here on
229:49 - the update another function we have is
229:50 - over here the interact action for this
229:52 - we're doing the same thing that we were
229:54 - doing up here so we're testing if the
229:55 - player is pressing down the space bar
229:57 - and if so we're going to run this code
229:58 - so we're going to run our hand on
230:00 - building interaction function and this
230:02 - function like it says is going to handle
230:03 - the building interaction over here we're
230:05 - cycling through all the buildings now
230:07 - here I went with a for Loop instead of a
230:08 - 4 each normally I would also use a 4
230:10 - each over here but I just want to use
230:12 - different Loops in this demo so just do
230:14 - a simple for cycling through the entire
230:15 - list so we cyle through it and we access
230:18 - the list on that index in order to get
230:19 - the current building transform then does
230:21 - pretty much the same distance logic that
230:22 - we saw so it has the current player
230:24 - position against the building position
230:26 - if it's under a certain interact
230:28 - distance and the player is close enough
230:29 - to interact with this building and then
230:30 - over here we have an example of a switch
230:32 - so this one does a switch on the
230:34 - building transform. name here in the
230:36 - editor in the hierarchy we can see our
230:38 - two buildings and we can see they have
230:39 - different names directly on the game
230:41 - object so we're doing a switch on that
230:42 - and if it is named this building coin
230:44 - one if so then we're going to add just
230:46 - one coin case it is named building coin
230:48 - 3 if so then we're going to add three
230:50 - coins and then on default if it does not
230:52 - match any of these two names if so that
230:54 - shouldn't happen so over here I just
230:56 - fire the unlog error so over here if I
230:58 - move towards this building and I'm close
231:00 - enough and I press on space and if there
231:02 - you go it does add one coin and if I go
231:05 - here and I press on space and if this
231:07 - one adds three coins okay so that's
231:09 - really it for this simple demo here we
231:11 - can see examples of variables being used
231:14 - we can see how we're using various data
231:15 - types we have both simple types like ins
231:18 - and floats as well as more complex types
231:20 - like list then we see some simple if
231:22 - statements these are going to make sure
231:24 - that we only run the move logic if the
231:26 - player is actually pressing a button
231:28 - then on the buildings we can see a
231:29 - switch in action doing different types
231:31 - of logic depending on the name of the
231:32 - building we can also see how we define
231:34 - various functions we can see how those
231:36 - functions have different access
231:38 - modifiers so all of these that are only
231:39 - used by the player class these are all
231:41 - marked as private whereas this one on
231:43 - the coin this one is marked as public so
231:44 - player can call it then we also see how
231:46 - we're using multiple different classes
231:48 - and then we also see how we're using
231:49 - different types of Loops A4 each and A4
231:52 - and very important note how throughout
231:53 - this whole script there are only a
231:55 - handful of comments very few there are
231:57 - really no useless comments instead all
231:59 - the code was written carefully with good
232:00 - names every function variable has a
232:03 - proper name that makes it very clear
232:04 - what exactly it represents so this way
232:06 - all the code is self-documenting there's
232:08 - no need for comments you can just read
232:10 - the code directly itself and easily
232:12 - understand what exactly it's doing so
232:13 - here in this nice Syble project we have
232:15 - indeed Incorporated everything we have
232:17 - learned so far now here let me also make
232:19 - a quick note just in case you're a more
232:20 - experienced user and not a beginner I
232:23 - made this demo intentionally as simple
232:25 - as possible normally for building a demo
232:27 - like this properly I would use multiple
232:29 - classes to separate all kinds of logic
232:31 - instead of putting it pretty much all in
232:32 - just one player class I would use events
232:34 - and various other things to massively
232:36 - increase the code quality and
232:37 - readability I would make these fields
232:39 - serialized private I would make these
232:41 - serialized private Fields instead of
232:43 - making them public I would remove coins
232:44 - from the list when they were destroyed
232:46 - or I would simply use continue to skip
232:48 - them I would perhaps use collisions
232:50 - instead of distance checks so there are
232:52 - plenty of ways to improve upon this code
232:54 - but on this demo I wanted to all use as
232:55 - much as was taught by this point so that
232:57 - is why I simplified it so much if you
232:59 - are an intermediate user and you want a
233:01 - simple challenge then perhaps try
233:02 - refactoring this demo to make it work
233:04 - with some good clean code and if you are
233:06 - a complete beginner and you have no idea
233:07 - what I'm talking about and don't worry
233:09 - about it just keep watching the course
233:11 - and after you get to the end of the
233:12 - intermediate section maybe come back
233:13 - here and do that mini challenge all
233:15 - right so that's our beginner project
233:17 - hopefully you fully understood
233:18 - everything in this beginner section and
233:20 - had no problem understanding everything
233:22 - in how this project works if there is
233:24 - something you found confusing maybe go
233:25 - back and rewatch that lecture or just
233:27 - post a question in the comments I highly
233:29 - encourage you to make sure you fully
233:31 - understand absolutely everything in this
233:32 - beginner section before continuing on to
233:34 - the intermediate
233:35 - section hello and welcome I'm your Cod
233:38 - Maki and congrats on completing the
233:40 - beginner section in this section we'll
233:41 - learn a lot of stuff starting with
233:43 - installing and setting up visual studio
233:44 - and unity we also learned the absolute
233:46 - basics of unity which isn't necessarily
233:48 - needed if all you want is just learn C
233:50 - but I really hope you've been following
233:51 - the course using the companion project I
233:53 - really hope you've been doing all the
233:54 - interactive exercises answering all the
233:56 - quiz and reading all the frequently
233:57 - asked questions you really learn so much
233:59 - more by doing rather than just watching
234:01 - then we learned about various common
234:03 - errors what they mean and how to solve
234:04 - them like I said this one is a great
234:06 - lecture that works as a general
234:07 - reference so even in the intermediate
234:09 - and Advance section still come back to
234:11 - this one if you get stuck on some kind
234:12 - of error then we start learning from the
234:14 - basis of programming learning how code
234:16 - executes line by line what is a code
234:18 - block and just how important it is that
234:19 - code is case sensitive then we start
234:21 - writing some code and learn about
234:22 - variables how they store some data and
234:24 - what are those data types then was about
234:26 - if statements which help us do some
234:28 - conditional logic related to that we'll
234:30 - learned about the switch statement very
234:31 - useful to have tons of conditions after
234:33 - that we learned about functions one of
234:35 - the crucial components of any kind of
234:36 - programming then we learned about scope
234:38 - this one of those things that's a little
234:40 - bit tricky for beginners so I truly hope
234:41 - you understood this one after that was a
234:43 - lecture on comment what they do and
234:45 - importantly whether you should and
234:46 - should not use them next was the lecture
234:48 - on arrays and lists this is a really
234:50 - important data type for storing multiple
234:52 - piece of data then was another crucial
234:54 - thing in all of programming we learn
234:55 - about loops this is how we can execute
234:57 - logic multiple times and then since C is
235:00 - an objectoriented language we finally
235:02 - learned about objects which we build
235:03 - using classes then we learned about the
235:05 - static keyword and what it means also
235:07 - what are the access modifiers public and
235:09 - private after that we had one of the
235:10 - most important lectures of all it's all
235:12 - about what makes a good name and how to
235:14 - define some good naming rules and then
235:16 - yet another really important one about
235:17 - how to write good clean code by
235:19 - following some simple guidelines and
235:20 - finally in the end we put it all
235:22 - together in a nice beginner project
235:23 - involving every single element that we
235:25 - learned about so congrats again on
235:27 - completing the beginner section I really
235:28 - hope you did all the exercise and all
235:30 - the questions I hope you learned a ton
235:32 - and I'll see you on the intermediate
235:34 - section hello and welcome I'm your kmy
235:37 - all right so congrats on watching this
235:38 - whole video I hope you really took your
235:40 - time and focus on learning all the
235:42 - contents over here for this beginner
235:43 - section if so then hopefully you are
235:45 - much more skilled now than when you
235:47 - started if you're watching this in the
235:48 - future then check the pen comment down
235:50 - below to see whether the intermediate
235:51 - section video is already available like
235:53 - I said my goal is to make that video
235:55 - section free over here on YouTube if the
235:57 - premium core sells over 100 copies and
235:59 - I'm happy to report it thankfully
236:00 - there's already been over 100 people
236:01 - picking it up so one month after the
236:03 - launch of this video that video should
236:04 - be out or if you want you can just go
236:06 - ahead and pick up the premium version
236:07 - right now and continue on to the
236:08 - intermediate section right away along
236:10 - with all of the awesome bonuses that the
236:12 - premium version also has if you haven't
236:14 - been forcing yourself in order to put
236:15 - what you learn into practice throughout
236:17 - this video then now would be a great
236:18 - time to pick up the premium version and
236:20 - go through all the content in the
236:21 - companion project especially doing all
236:22 - the interactive exercises you only truly
236:25 - learn by doing so that is why I designed
236:27 - those exercises to put your skills into
236:28 - practice in order for you to truly learn
236:30 - and the first session of the weekly live
236:31 - study group that one is happening this
236:33 - Saturday March 9th so if you can't
236:35 - afford then check out the premium
236:36 - version with a link in the description
236:38 - if not then stay tuned for the free
236:40 - video covering the intermediate section
236:41 - one month from now also if you haven't
236:43 - already go ahead and like this video and
236:44 - hit the Subscribe button it's a tiny
236:46 - thing but it really does help all right
236:48 - so thanks for watching and I'll see you
236:49 - next time