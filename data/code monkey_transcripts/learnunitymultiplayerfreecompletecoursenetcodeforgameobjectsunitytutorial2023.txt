00:00 - hello and welcome I'm your code monkey
00:02 - and here is a free complete course on
00:04 - making a really nice multiplayer game if
00:07 - you have lots of multiplayer game ideas
00:08 - but don't know where to start then this
00:10 - course is for you here we are going to
00:12 - build a simple game but also one that
00:14 - involves using lots of multiplayer tools
00:16 - so while learning how to build this game
00:18 - you won't by the end have the knowledge
00:19 - required to be able to build just about
00:21 - any multiplayer game in any genre you
00:23 - can think of we're going to use unity's
00:26 - official multiplayer solution called
00:27 - netcode for game objects this is a very
00:29 - robust tool set and once you understand
00:31 - how it works it's actually surprisingly
00:33 - easy this is a complete free course
00:35 - video but it has the same level of
00:37 - quality as my paid courses or my Steam
00:39 - games you can download the project file
00:41 - so far along or inspect the final game
00:43 - you can even play the final game right
00:45 - now directly from scene this course is a
00:47 - follow-up to my free ceiling player
00:48 - course in that one we built this project
00:51 - completely from scratch every line of
00:53 - code was written on screen during that
00:54 - course and now we're going to pick up
00:56 - from where we left off and Implement
00:58 - multiplayer also just like the cylinder
01:00 - course one very important thing is how
01:02 - everything we're going to do here it's
01:03 - all going to be focused on writing good
01:05 - easy to understand clean code the code
01:07 - that we're going to write here is
01:08 - production quality code this is not a
01:10 - throwaway demo the quality of the code
01:12 - and structure of the game that we're
01:14 - going to build is on the same level of
01:15 - quality as my own Steam games as you can
01:17 - see from the video link this is indeed
01:19 - one complete very thorough course so
01:21 - don't try and watch this whole thing in
01:23 - one setting take your time and take it
01:25 - slow and just focus on learning there
01:27 - are chapters for every lecture in the
01:28 - video here's a quick overview of the
01:30 - entire course all the steps that we're
01:32 - going to take to reach the final polish
01:33 - game
01:34 - so first we will Begin by taking a brief
01:36 - look at the starting game this is what
01:38 - was made currently from scratch in the
01:40 - ceiling Point course so here we're just
01:42 - going to do a quick overview as a
01:43 - refresher to see how all the code is set
01:45 - up then we're going to begin by
01:46 - installing netcode for game objects this
01:48 - is unity's official multiplayer solution
01:50 - we're going to install the package and
01:52 - do the basic setup with all of these
01:54 - settings and spawn a player object after
01:56 - that we're going to begin by
01:57 - synchronizing the player movement and
01:59 - also at this point we're going to talk
02:01 - about one extremely important thing in
02:02 - multiplayer games which is server
02:04 - authoritative versus client
02:06 - authoritative with the movement synced
02:08 - we are then going to synchronize the
02:09 - animations this one is pretty simple to
02:11 - do thanks to the built-in components
02:13 - next we're going to synchronize our
02:15 - first proper gameplay logic we're going
02:17 - to begin with the delivery manager so
02:20 - we're going to synchronize how the
02:21 - recipes are spawned make sure only the
02:23 - server spawns them and all the clients
02:24 - see the same list and also synchronize
02:27 - delivering the recipes either correctly
02:28 - or incorrect one after that is just a
02:30 - quick lecture to fix the selected
02:32 - counter visual this is something that is
02:34 - one of the many differences between
02:36 - making single player games and
02:37 - multiplayer games we need to think in
02:39 - different ways especially because in
02:41 - multiplayer we no longer have just a
02:43 - single player object then we're going to
02:45 - synchronize picking up objects this
02:47 - involves learning how to spawn objects
02:48 - on the network so that all of the
02:50 - players can see it after unlearning how
02:51 - to spawn them we're going to synchronize
02:53 - the kitchen object parent so that
02:55 - multiple players can hold objects and
02:57 - everything is correctly synchronized
02:58 - across the network then we're going to
03:00 - synchronize the plates counter make it
03:02 - so that only the server responds points
03:04 - then for the trash counter this one
03:06 - involves learning how to destroy Network
03:08 - objects after that is synchronizing the
03:10 - cutting counter so this one will involve
03:12 - thinking about what parts we need to
03:14 - synchronize and what logic can be just
03:16 - local then for the stove counter for
03:18 - this one instead of using rpcs we're
03:20 - actually going to use a network variable
03:21 - the server won't keep track of the stove
03:23 - State and sync it to the clients next is
03:26 - synchronizing the logic for adding
03:28 - ingredients onto the plates after that
03:30 - for an optional design question we're
03:31 - going to implement some player
03:33 - collisions then then we're going to
03:34 - synchronize the complete Game State SO
03:37 - waiting for all of the players to be
03:38 - ready before starting the game and also
03:40 - synchronize the game timer and game over
03:42 - next we're going to learn how to deal
03:44 - with pausing so do we unlock it or not
03:46 - in this case we are going to allow it
03:48 - and all of the other players must wait
03:50 - until everyone is unpaused then for
03:52 - something very important which is how do
03:54 - we handle disconnects how do we clean up
03:56 - all the objects so the game doesn't
03:57 - crash when a player leaves in the middle
03:59 - related to that are only joins so how do
04:01 - we handle a player that joined after the
04:03 - game has already started or should we
04:05 - even allow that then comes a really
04:07 - important and relatively complex lecture
04:09 - in this one we're going to handle the
04:11 - complete connection scene flow how we
04:13 - begin in the main menu in single player
04:15 - then we have an online lobby after that
04:17 - we create a netcode connection and go
04:19 - into the character select scene then
04:21 - when all the players are ready we then
04:22 - go into the main game scene and after
04:25 - that just play the game as normal this
04:26 - is one of the most important lectures in
04:28 - this entire course after that with the
04:30 - connection firmware working we're going
04:31 - to build out a nice character select
04:33 - scene this one is of the main things
04:35 - that I saw people ask about in my
04:36 - netcode video so we're going to make a
04:38 - nice scene where the players can join
04:39 - and customize their character next we're
04:41 - going to build the game lobbying so the
04:43 - player can create a Lobby or Join one
04:45 - then we're going to implement relay in
04:47 - order to allow our players to connect to
04:48 - one another easily without having to
04:50 - open ports next we're going to talk
04:52 - about some more Unity multiplayer Tunes
04:54 - dedicated servers with game server
04:56 - hosting Matchmaker and vvox after that
04:58 - we're going to talk a bit about all the
05:00 - tools at your disposal to test your
05:02 - multiplayer games then just before the
05:04 - end we're also going to add a really
05:05 - important option we want the game to
05:07 - work in both multiplayer and single
05:09 - player so we're going to make it so you
05:10 - can basically bypass all the multiplayer
05:12 - connections and play in an offline
05:14 - single player mode and with that
05:15 - everything is done so we're going to
05:17 - inspect the funnel game and have some
05:18 - fun so as you can see you will learn
05:20 - about a ton of Topics by following this
05:22 - course by the end you will have the
05:24 - knowledge required to build just about
05:25 - any multiplayer game now if you're new
05:27 - to the channel then welcome and here's a
05:29 - bit about me and my credentials or why
05:31 - you shouldn't listen to what I have to
05:33 - teach my name is Hugo and I've been
05:35 - running this Code Monkey YouTube channel
05:36 - for five years now in total almost 700
05:38 - videos on all kinds of topics including
05:40 - tons of tutorials sharing my knowledge
05:42 - to help you on your own Game Dev Journey
05:44 - I'm also a professional indie game
05:46 - developer making games for over 10 years
05:47 - with 8 successful Games published on
05:49 - Steam so what I'm teaching here is based
05:51 - on a lot of years of experience making a
05:53 - lot of games just like with my paid
05:54 - courses I'm always in the comments
05:56 - answering your questions every single
05:57 - day so if you get stuck on a particular
05:59 - point or need extra clarification on
06:01 - something go ahead post a comment and
06:03 - I'll do my best to help do make sure to
06:05 - include a timestamp of what you're
06:06 - referring to I will also be updating the
06:08 - pin comment with any frequently asked
06:10 - questions that I see especially right
06:11 - now pause the video and scroll down a
06:13 - bit and look at that comment since on
06:15 - YouTube I cannot update a video after
06:16 - it's published I will be updating that
06:18 - comment over the next months and years
06:20 - and I also made a dedicated course on my
06:22 - website in there you can download the
06:24 - complete project files for every single
06:26 - lecture so if you get stuck at any point
06:27 - you can download the code for the deck
06:29 - Ledger and compare with your own there's
06:31 - also links to all of the reference
06:32 - videos for each lecture and I won't be
06:35 - including the frequently asked questions
06:37 - if you have a common question then
06:38 - chances are I've already answered it in
06:40 - that page so it's faster to just check
06:42 - that page where then wait for me to
06:43 - reply to your comment so definitely do
06:45 - keep that page open in a second tab as
06:47 - you follow along each lecture now both
06:49 - this free course and the single player
06:50 - one took a ton of work to make so I
06:52 - really hope you find both these courses
06:54 - home phone go ahead and hit the like
06:55 - button if it helps you it's a small
06:57 - thing but it generally does help this
06:59 - video on the YouTube algorithm making
07:01 - this course was a ton of work and by
07:02 - making it completely free means that it
07:04 - won't obviously never make as much money
07:05 - as if I just made this a paid course I'm
07:07 - perfectly okay with that decision with
07:09 - the Hope set by making it free it won't
07:11 - reach and help many more people I'm also
07:13 - a big believer that education should be
07:15 - free so if you can't afford one of my
07:16 - big courses like if you're just a kid or
07:19 - if you're going through a rough time I
07:20 - still want you to have access to high
07:22 - quality education so you can achieve
07:23 - your Game Dev dreams one easy way it can
07:26 - help me for free is similar on liking
07:27 - this video subscribing to the channel
07:29 - and just watching this video that will
07:31 - hopefully help push the video on the
07:32 - YouTube algorithm and help it reach many
07:34 - more people another free way to support
07:36 - what I do is so I'm currently working on
07:38 - my next steam game called term 1
07:39 - Liberation you can wishlist the game on
07:41 - Steam wishlist met a lot for scene
07:43 - visibility so just by doing that he'll
07:45 - be helping me and just in case you can't
07:47 - afford it and you find both these three
07:49 - courses useful you can also support what
07:50 - I do in a few other ways I added this
07:52 - exact same course on my website as a
07:54 - regular paid course although I want to
07:56 - be very very clear there's absolutely no
07:58 - difference between this free video and
08:00 - the paid course there's absolutely
08:02 - nothing behind any kind of payroll all
08:04 - the lectures are free only purchase
08:06 - files are free everything is free you
08:08 - don't have to pay anything if you can't
08:10 - afford it or you just don't want to the
08:12 - paid version is essentially a donation
08:13 - the only difference is this free YouTube
08:15 - video has regular YouTube ads whereas
08:17 - the paid version on the website doesn't
08:18 - have any ads that's it so the only
08:21 - reason why I made that paid version is
08:22 - just in case some of you can afford it
08:24 - and you want to support what I do but
08:25 - again only do that if you can afford it
08:27 - if you can't then that's perfectly fine
08:29 - I hope you'll learn a ton from watching
08:31 - and following this free course beyond
08:33 - that if you follow this course and you
08:34 - enjoy my teaching sound perhaps log into
08:36 - my other one if you like this video then
08:38 - I think you will really like my
08:40 - turn-based strategy course that is the
08:42 - perfect course to follow up on this one
08:43 - it Dives even deeper into some of the
08:45 - concepts used here and it will help you
08:47 - make the jump from beginner to Advanced
08:48 - and since you're interested in unity
08:50 - then I think my ultimate unity over your
08:52 - course would also be very useful to you
08:54 - each lecture in that course is focused
08:56 - on teaching one entity two more feature
08:58 - there's already over 15 lectures
08:59 - including plenty of small but very
09:01 - important things that just wouldn't work
09:03 - as a regular YouTube video if you're
09:04 - interested in visual scripting I have a
09:06 - course on making three unique games
09:08 - internally with visual scripting and no
09:09 - code at all or if you prefer you can
09:12 - learn how to make a nice Builder
09:13 - Defender game so if you enjoy my
09:15 - teaching style in these three courses
09:16 - then check out my paid ones but of
09:18 - course YouTube has Channel memberships
09:20 - and super thanks so you can use those if
09:22 - you want I also have my patreon if you
09:24 - prefer that and a lot of my videos I
09:26 - have film links for the NTS store or
09:28 - Humble Bundle if you ever pick up
09:30 - anything from those I get a nice
09:31 - commission and I also have some of my
09:33 - own assets on the unity store so if you
09:35 - enjoy these three courses and you want
09:37 - to support what I do there's plenty of
09:38 - ways but again don't feel obligated if
09:41 - you can't afford it or you just don't
09:42 - want to then that's perfectly fine I
09:44 - hope you learned a ton from watching and
09:45 - following this free course
09:47 - alright so that's enough time for that
09:48 - for now before we begin building the
09:50 - game Let's inspect the final game that
09:52 - we're going to build so let's see that
09:53 - in the next lecture
09:56 - hello and welcome I'm your code monkey
09:58 - in this lecture we're going to take a
09:59 - look at the final game that we're going
10:01 - to build in this multiplayer course
10:03 - okay so here's the final game that we're
10:05 - going to build in this course and right
10:07 - away on the main menu you see a very
10:08 - important feature the goal is indeed to
10:10 - make a multiplayer game but thanks to
10:12 - how netcode works it actually makes it
10:14 - really easy to support both multiplayer
10:16 - and single player
10:17 - so here we have buttons for both we can
10:20 - go into single player and if there go
10:22 - the game starts playing so exactly the
10:24 - same as we made in the Singapore course
10:25 - so everything works perfectly offline
10:27 - everything works great so we can move
10:29 - act and everything works great so it
10:31 - works in single player or of course we
10:33 - can go into multiplayer and as soon as
10:35 - we do we go over here into a Lobby scene
10:37 - this is where we can view all the
10:39 - lobbies that other players have created
10:41 - right now the game is sent out so there
10:43 - are no lobbies here but if there were
10:44 - they would appear on this list since I'm
10:46 - the first player I can go ahead and
10:48 - create a Lobby
10:49 - I can give it a name so my awesome game
10:51 - Lobby
10:53 - I can make it either private or public
10:54 - so if I make it public as soon as I
10:57 - click if there go it creates a Lobby and
10:59 - this one goes into the character select
11:00 - scene and over here I have a bunch more
11:03 - clients so on these let's go ahead into
11:05 - multiplayer then load up the lobby scene
11:07 - and you all of them can see the same
11:08 - Lobby
11:09 - so I can join Lobby either by clicking
11:12 - on the lobby name directly there you go
11:13 - joining Lobby connecting any of this
11:15 - client is now joined Lobby alternatively
11:18 - I can press quick join and unity won't
11:20 - automatically try to find a found Lobby
11:22 - to join and also as we saw the lobby can
11:24 - either be public or private if we had
11:26 - made it private then the lobby would
11:28 - generate this kind of code so you could
11:30 - take this code give this code to a
11:32 - friend they would put that code over
11:33 - here on these input box they would join
11:36 - by code and they would end up joining
11:37 - the same Lobby also one very very
11:40 - important thing actually happened in the
11:41 - background without the player even
11:42 - knowing that is the entire relay
11:45 - as a host I did not have to handle any
11:47 - port forwarding or dealing with any
11:49 - firewall when I created the lobby in the
11:51 - background the game actually created a
11:53 - relay allocation and connected through
11:54 - there same thing for all of the other
11:56 - clients they all automatically handled
11:58 - getting the relay code from the lobby
12:00 - host and connected perfectly so like
12:02 - this the game supports connecting any
12:04 - two players anywhere in the world
12:05 - without any issues with ports or
12:07 - firewalls okay so then here we are all
12:09 - on the nice character select scene we
12:12 - can look at the players and choose a
12:13 - color also over here on the host the
12:15 - host has extra buttons on top of each
12:17 - player in order to kick that player then
12:19 - for each we can select any kind of color
12:21 - we want for our character so I'd say
12:22 - instead of yellow I want to be purple
12:24 - and there you go I change the color and
12:26 - yep look at all of those synchronized
12:28 - correctly then the server also does some
12:30 - Foundation to ensure two players don't
12:32 - end up with the same color
12:33 - so if I try to select purple nope does
12:35 - not work so each player can really
12:37 - select their color and once they're all
12:40 - happy with their colors there's a ready
12:41 - button so each player can Mark
12:43 - themselves as ready and ready
12:44 - synchronized but the game is not
12:46 - starting just yet
12:47 - instead it must have all of the players
12:49 - great in order for the game to start so
12:51 - let's set ready on this one on this one
12:52 - and finally on this one and once they're
12:54 - all ready yep the server automatically
12:56 - unloads the game scene and all the other
12:57 - clients load the same scene and now here
13:00 - just like in the single player game we
13:01 - have our controls so each player can
13:03 - take their time to read the rules before
13:05 - moving on then when they do and let's
13:07 - interact any of the server is currently
13:08 - waiting for the players so all the
13:10 - players must go through the controls
13:11 - before the game actually begins so let's
13:14 - go ahead interact on all of them and
13:15 - when I do on the last one if there you
13:17 - go it goes into the countdown it counts
13:19 - on the timer and after you go the game
13:21 - is now playing
13:22 - alright great and as you notice the
13:24 - countdown all of that was perfectly
13:25 - synchronized and now here everything
13:27 - else is exactly like we built in the
13:29 - single player course except obviously
13:30 - the big difference is everything is
13:32 - synchronized so on the recipes over here
13:34 - on the side all the players are
13:35 - receiving the same recipes I can move
13:37 - around on either player and yep all of
13:40 - them are perfectly synchronized
13:41 - then I can go ahead pick up objects and
13:44 - yep all of them they get the objects
13:45 - funding all of them get the object
13:47 - parent changing all of that works
13:48 - perfectly
13:49 - then I can place the objects anywhere
13:51 - and yep it works so I can place it on
13:52 - the cutting counter I can do the ont
13:54 - interact action and yep all of them see
13:56 - the object is being cut and you all of
13:58 - them see the cheese slices then I can
14:00 - also go into the stove pick it up drop
14:02 - it and yep the timer for the serve that
14:04 - one is actually being synchronized by
14:05 - the server so there it is and if I leave
14:08 - it to burn yep all of them are giving
14:09 - the warning and if I leave yep there go
14:11 - that one is charred and it's charred on
14:13 - every single client so now I can trash
14:15 - it so this involves destroying a network
14:17 - object
14:18 - now let's do a proper one so let's go
14:20 - ahead that one sets it on coke then this
14:22 - one let's say this one picks a plate
14:23 - tries to pick up that one and goes and
14:25 - grabs that one then this client down
14:27 - here go ahead pick up a brand drop it
14:29 - and now we can go ahead and deliver any
14:31 - of their delivery success synced on all
14:33 - of the other ones and of course the game
14:35 - timer itself is also being synchronized
14:36 - and as soon as that timer ends up if
14:39 - they go they all get a nice game over
14:41 - scene alright awesome so this is the
14:44 - complete multiplier game we're going to
14:46 - take our single player game and
14:47 - synchronize all of this game logic to
14:49 - make it all multiplayer and we're also
14:51 - going to implement the two homes for
14:52 - Lobby and relay to make our game easy to
14:55 - play for any player anywhere okay so now
14:57 - that we've seen the final goal let's go
14:59 - to the next lecture and see what you
15:01 - should know
15:03 - hello and welcome I'm your code monkey
15:06 - in this lecture we're going to see what
15:08 - you need to know in order to be able to
15:09 - follow everything in this multiplier
15:11 - course
15:12 - okay so for this course like I mentioned
15:14 - it's a follow-up to my film player
15:16 - course the starting project files here
15:18 - are exactly the project files from the
15:20 - last lecture on that course so I will
15:22 - assume you've watched that and you are
15:23 - familiar with that code base and how the
15:25 - project is structured in the next
15:27 - lecture I will do a brief overview of
15:28 - the code base so if you've seen the
15:30 - course a few weeks ago then just
15:31 - watching that lecture should be enough
15:33 - to quickly remember how everything works
15:35 - in this specific multiplayer course we
15:37 - are going to be using unity's net code
15:38 - for game objects this is their official
15:40 - multiplayer tool set I've covered it in
15:43 - a general video previously and like I
15:45 - said in the single player course here I
15:47 - will mostly be using it to achieve our
15:48 - goal with this game rather than covering
15:50 - every part of the tool set itself so
15:52 - first go watch that video to learn about
15:54 - the tool set in general here I will
15:56 - assume you know the general idea for how
15:58 - it works meaning what is a network
15:59 - manager what is a host and a client what
16:02 - are rpcs and network variables you don't
16:04 - need to memorize that video just watch
16:06 - it once just to get an idea for how it
16:08 - works in general then here as we use
16:10 - each part of the tool set I will explain
16:12 - what it does also I would highly highly
16:14 - encourage you to follow the course
16:15 - website as you're following along with
16:16 - these lectures I saw a bunch of comments
16:19 - on the cylinder course asking the same
16:20 - questions over and over again
16:22 - those people could have gotten those
16:24 - answers much faster if they had just
16:26 - read the website FAQs rather than
16:27 - waiting for me to reply so definitely
16:29 - keep that tab open and read through it
16:31 - as you go through each lecture but at
16:33 - the same time I answer comments every
16:34 - single day so any questions you have
16:36 - post them here and I'll do my best to
16:37 - help just like the Salem player course
16:39 - this one is pointed to lectures they are
16:41 - all as chapters in the video so you can
16:43 - navigate around and once again let me
16:45 - remind you that you are not expected to
16:47 - follow this course in one sitting
16:49 - take your time focus on actually
16:50 - learning remember that's the only goal
16:52 - you're not competing with anyone you're
16:54 - just gaining knowledge for yourself so
16:57 - take as much time as you need re-watch
16:58 - some lectures if you feel you didn't
17:00 - fully Get It Go watch your related
17:02 - videos read the frequently asked
17:03 - questions or just ask a comment mainly
17:06 - take your time and just focus on
17:07 - learning okay so all of that to say that
17:09 - you should know the contents of the
17:11 - cylinder course and the netcode for game
17:12 - objects video as long as you've seen
17:14 - those two you should be able to follow
17:15 - everything here and now before we begin
17:18 - let's take a quick look at the starting
17:19 - ceiling Point project and how it's set
17:21 - up so let's do that in the next lecture
17:24 - hello and welcome I'm your code monkey
17:26 - in this lecture we're going to take a
17:28 - look at a quick overview of the code and
17:30 - the game that we made in the single
17:32 - player course okay so here we are in the
17:34 - game built from scratch on that single
17:36 - point of course we start off in a super
17:38 - simple main menu with a bunch of buttons
17:39 - then we can go into play and right away
17:42 - it loves the game scene and here we can
17:44 - see a bunch of basic controls it's
17:46 - selling as the base game rules the
17:47 - controls and asking for interact to
17:49 - continue
17:50 - so now as I press interact button yep
17:52 - the game starts a countdown and with
17:54 - that I can now move around then on the
17:56 - left side I can see a bunch of recipes
17:58 - being generated so I can approach any
18:00 - counter and interact with it for example
18:02 - there's a container counter from where I
18:04 - can pick up some objects when I pick up
18:06 - the object hovers in front of the player
18:07 - then over here is a clear counter so I
18:10 - can place and drop some objects now over
18:13 - here is a cutting counter so I can place
18:14 - on some objects and with the alternate
18:16 - interaction I can start to cut them
18:18 - after cutting a bunch of slices I can
18:21 - cut the entire object
18:23 - when that happens is cheese Moab became
18:25 - cheese slices then for the other one is
18:27 - over here the stove if I place some
18:29 - uncooked meat on the stove a timer
18:31 - starts counting up that timer is the
18:33 - meat cooking so as it goes yep there you
18:35 - go the meat is cooked but the timer
18:36 - keeps going so if I don't take it out
18:38 - then it suddenly becomes burn
18:40 - so yeah there you go the meat is Charn
18:42 - so down here there's a counter to
18:43 - destroy it so let's destroy it and let's
18:45 - cook some more meat and now let's pick
18:47 - it up correctly so for picking up
18:49 - there's also a plate and when carrying a
18:51 - plate we can pick up ingredients of the
18:52 - plates so there you go pick up meat pick
18:55 - up some cheese and let's also drop some
18:57 - bread on there so we have a complete
18:59 - recipe so this is the cheeseburger that
19:00 - the clients are requesting so let's go
19:02 - ahead drop it and if there you go we
19:03 - have a successful delivery now finally
19:05 - the game itself has a game timer and
19:08 - when the game timer elapses yep here we
19:10 - have a nice game over screen alright
19:12 - awesome so this is the game that we
19:14 - built in the single player course now
19:16 - let's see the main Concepts and how the
19:18 - code works the core of it is the kitchen
19:20 - object class
19:22 - this is the class that represents a
19:23 - kitchen object like for example some
19:25 - cheese or tomato then for the type
19:27 - itself we have defined a kitchen object
19:29 - so a script on object which holds the
19:31 - prefab reference and a bunch more data
19:32 - for the counters they all extend this
19:34 - base counter class this class has a
19:36 - bunch of logic and importantly it over
19:38 - here has an interact function this one
19:41 - is marked as virtual some of the other
19:43 - different counters all of them extend
19:44 - this base less and they override this
19:46 - function for example here on the
19:48 - container counter on the interact it
19:49 - checks if the player is carrying
19:50 - anything if not if the player isn't
19:52 - carrying anything then just spawns the
19:54 - object
19:54 - we also wrote some clean code so we used
19:57 - events all over the place in order to
19:58 - separate the logic from the visuals so
20:00 - in this case this event is what triggers
20:02 - the animation on the container counter
20:03 - now over here this one spawns a kitchen
20:05 - object and gives it to the player so the
20:07 - player in here is a kitchen object
20:09 - parent importantly each kitchen object
20:11 - can only have one parent and then each
20:14 - kitchen object parent which is the
20:15 - finest interface each of these can only
20:18 - have one kitchen object basically the
20:20 - interaction between kitchen objects
20:22 - parents counters and players all of that
20:24 - is really most of how the game works
20:26 - beyond that here we have the delivery
20:28 - manager this is a script that handles
20:29 - generating recipes and keeping a list of
20:32 - all of the wedding recipes for the
20:34 - recipes themselves they are also defined
20:36 - in a recipe so this is a scriptable
20:38 - object just only a list of kitchen
20:40 - objects so for all the ingredients
20:41 - there's only three counter simply calls
20:43 - they deliver recipe function passes in
20:45 - the plate and then over here we do some
20:47 - validation to check if it is the correct
20:49 - recipe and if so then once again we have
20:51 - some nice events which then have the
20:52 - visuals hooked onto it another important
20:55 - script is the kitchen game manager this
20:57 - is the general script that handles most
20:59 - of the Lobo game logic importantly it
21:01 - handles the state of the game
21:03 - SO waiting to start doing the countdown
21:05 - playing the game or game over and that's
21:07 - really it for how the project and the
21:09 - code base set up it's a relatively
21:11 - simple game so hopefully this quick
21:13 - refresher him to you remember how all of
21:15 - it works finally before we begin let me
21:17 - just quickly talk about the two main
21:18 - options you have with regards to making
21:20 - a multiplayer game one option is to do
21:22 - just like I ended up doing with these
21:24 - two free courses first make your game in
21:26 - single player and then convert it to
21:28 - multiplayer that's one option and the
21:30 - other option is to get the multiplayer
21:32 - working right from the start both are
21:34 - perfectly found options which one you go
21:36 - with really depends on the game you're
21:37 - making specifically with how complex it
21:39 - is
21:40 - for very simple games this approach
21:42 - works great first make it internally in
21:44 - single player and then convert it to
21:45 - multiplayer but if multiplayer is a very
21:48 - core part of your game then implementing
21:50 - it from the very start is likely the
21:51 - best and of course there is a third
21:53 - option where it's really a mix for
21:55 - example if I were making this game all
21:57 - by myself instead of making these two
21:58 - courses if it was just me making this
22:01 - game in multiplayer I would end up with
22:03 - a mix of both approaches
22:04 - I would first get the basics working in
22:06 - somewhere like just the character moving
22:08 - interacting with the counter and pick up
22:10 - something then before I went further I
22:12 - would synchronize just that part in
22:13 - multiplayer after that I would build one
22:16 - mechanic in Sound Player then
22:17 - synchronize it and so on so you have
22:19 - lots of options for how you can build
22:21 - your multiplayer games okay so hopefully
22:23 - by now you have a good knowledge of the
22:25 - starting code base and how all the
22:26 - elements and systems are connected with
22:28 - that knowledge now let's begin building
22:30 - our multiplayer game we're going to
22:31 - start off by installing the netcode for
22:33 - game R6 package so let's do that in the
22:35 - next lecture
22:37 - hello and welcome I'm your code monkey
22:39 - in this lecture we're going to begin
22:41 - making our game we're going to install
22:43 - net code for game objects which is
22:45 - unity's official multiplayer solution
22:46 - and we're going to set up a basic scene
22:48 - with a spawn player for a host and
22:50 - client
22:51 - all right so here I have the project
22:53 - this is where we left off on the single
22:56 - player free course so everything here in
22:58 - this project was built during that
22:59 - course from scratch again definitely go
23:02 - watch that if you haven't seen it it
23:03 - won't be quite tricky to follow this
23:05 - multiplayer course if you're not
23:06 - familiar with the code base you can
23:08 - download the starting project files from
23:09 - the course website if you follow the
23:11 - course yourself and you built your own
23:12 - project then perhaps you can start from
23:14 - there although depending on how much you
23:16 - went off script from the course code
23:17 - perhaps it might be best to start from
23:19 - the exact same project files that I have
23:21 - here just to avoid any confusion the
23:23 - only difference is I updated my Unity
23:25 - version to the latest version as the
23:27 - time of this recording which is 22.2.7
23:29 - like I said in the single player portion
23:31 - make sure you're using the same version
23:33 - as me the last number the 0.7 over here
23:35 - doesn't matter but make sure you're
23:36 - using 22.2 or if you're watching a few
23:39 - months in the future then you can use
23:40 - the 22 LTS but if you're watching this
23:43 - many years in the future and there's
23:45 - version 23 or later then still stick
23:47 - with the 22 LTS okay so let's begin
23:49 - making our multiplayer game now for
23:51 - making this multiplayer course I won't
23:53 - be using unity's official multiplier
23:55 - solution called netcode for game objects
23:56 - here I'm going to assume that you've
23:58 - watched my dedicated netcode for game
24:00 - objects video so I will assume that you
24:02 - know what is a network manager what is
24:04 - Unity transport what is a network object
24:06 - and so on you don't need to memorize
24:08 - that video I will still do a brief
24:10 - description introduction of the
24:11 - components as we use them but I will
24:13 - assume that you've seen that video and
24:15 - have a general understanding for how the
24:17 - tool stack works so let's begin by
24:19 - installing the package let's go into
24:20 - window the package manager then up here
24:23 - let's go into the NT registry and let's
24:25 - make sure we are on all then just scroll
24:27 - down and down here we can find the
24:30 - netcode for game objects and as the time
24:32 - of this recording the latest version is
24:34 - 1.2.0
24:36 - so we want to install this but again
24:38 - like I mentioned with the NT version
24:39 - here let me say the same thing if you're
24:42 - watching this a long time in the future
24:43 - I would still highly highly recommend
24:45 - you use this version 1.2.0 and not
24:47 - whatever is the latest version the
24:49 - reason for that is because I cannot see
24:51 - the future so I don't know what changes
24:52 - feature versions will bring
24:54 - for the most part they won't probably be
24:56 - very minor but even so if just a
24:58 - function changes name that could be a
25:00 - breaking change so I would highly highly
25:02 - encourage you to follow this course
25:04 - using this exact same version just to
25:06 - avoid any confusion then afterwards
25:08 - after following this entire course you
25:10 - can go and look in the netcode package
25:12 - and read the change along to see what
25:13 - changes I've had it since
25:15 - like I mentioned in the single player
25:16 - course don't worry about using a
25:18 - quote-unquote older version of the
25:20 - knowledge you will gain from this course
25:21 - will still help you many years in the
25:23 - future even when netcode for game
25:25 - objects is on a different version for
25:27 - example right now we can see the change
25:28 - log for the developed branch which is
25:30 - what they're currently working on and
25:32 - over here we can read that change log
25:33 - and we can see for example the only
25:35 - significant difference that I can see is
25:37 - really over here the network prefabs
25:38 - apparently in this feature version
25:40 - instead of being on the network manager
25:42 - it won't be on a separate certain wrong
25:44 - object so that's the kind of very minor
25:46 - thing that changes in the versions but
25:48 - despite being very minor if you're
25:49 - trying to follow this course with a
25:51 - different version it can still be quite
25:52 - confusing and as usual I will be
25:54 - updating the pin comment and the course
25:55 - page to reflect any important updates so
25:57 - if you're watching this in the future
25:58 - and there's a different version still
26:00 - make sure to install this one and the
26:01 - way you do it is instead of using this
26:03 - and sound button here let's click on the
26:05 - plus icon on the package manager and
26:07 - let's add a package by name then let's
26:09 - type the exact name that we see there so
26:12 - com.unity.netcode.game objects and let's
26:15 - make sure we don't have any typos so
26:16 - that's the exact same name and then over
26:18 - here for the version let's go 1.2.0 okay
26:21 - so let's go ahead click on ADD there you
26:24 - go it's installing the correct version
26:25 - and yep everything was installed so we
26:27 - have netcode 1.2.0 and on dependencies
26:30 - we can see we also have the ND transport
26:32 - 1.3.1 okay so with the packages and so
26:35 - on let's begin using it so let's close
26:36 - this and let's begin working on the game
26:39 - scene so let's go inside of that now the
26:41 - first thing that we need is a network
26:42 - manager so let's create a new empty game
26:44 - object for the network manager
26:47 - as usual let's reset transform keep
26:49 - things nice and clean and let's add a
26:51 - component and let's add the network
26:52 - manager okay so this is the main
26:55 - component that netcode for game objects
26:57 - uses
26:58 - then for the setup down here the main
27:00 - thing is we need to select a transport
27:01 - this is what will actually send the
27:03 - packets so let's go ahead and select the
27:05 - NT transport and that's it and add this
27:08 - component down here with a whole bunch
27:09 - of fields for now we don't need to touch
27:11 - any of this so just leave them all in
27:13 - defaults importantly make sure that over
27:14 - here the connection data make sure for
27:17 - the address we have
27:19 - 127.0.0.1 this one is in localhost so we
27:22 - can develop and test the game in our own
27:23 - machine now if just with this if we had
27:26 - on play right now nothing really happens
27:28 - because we're still not synchronizing
27:29 - anything so let's do that first thing is
27:32 - over here on network manager we have a
27:33 - film for a player prefab
27:35 - this is what gets instantiated
27:37 - automatically when a player connects so
27:39 - the way we want our game is over here on
27:41 - the scene view we've got our player game
27:42 - object this one is just placed in the
27:44 - scene in single player we only had one
27:46 - so we had no need to make the same
27:47 - prefab but for now we do need it to be a
27:49 - prefab
27:51 - so let's make it let's just drag it over
27:53 - onto our prefabs folder there it is
27:54 - there's the player prefab and let's
27:56 - delete the one from the scene okay so
27:58 - far so good now we can go into the
28:00 - network manager and just drag the player
28:02 - and drag it in there okay we have
28:03 - assigned a player prefab but just like
28:05 - this it won't actually do anything
28:07 - that is because every object that exists
28:09 - on the network must have a network
28:11 - object component so let's select the
28:13 - player prefab and over here on let's add
28:15 - a component and let's search for the
28:16 - network object okay that makes sure that
28:19 - this object can exist on the network now
28:21 - let's open up the player script here is
28:23 - our script
28:24 - again all of this would be ultimately
28:26 - from scratch in the single player course
28:28 - so I assume you are familiar with all of
28:29 - this code and over here to make this a
28:31 - network object instead of extending mono
28:33 - Behavior instead of that let's extend
28:35 - the network behavior and this one we can
28:38 - see that this one exists inside using
28:40 - unity.netcode so let's set that and yep
28:42 - there you go this one is now a network
28:43 - Behavior so just by doing this change
28:46 - this script is already marked as a
28:47 - network script and by the way over here
28:49 - in the editor if we didn't add the
28:51 - network object so for example if I
28:53 - remove this
28:54 - and if now I click away and I select it
28:56 - if there you go now we've got a nice
28:58 - pop-up window telling us that we need a
29:00 - network object component so if you're
29:02 - ever making Network behavior and you
29:03 - forget to add the network object
29:06 - and you get this nice pop of windows
29:08 - then you can either manually edit just
29:09 - like within or you can automatically so
29:11 - just click on yes and if there you go
29:13 - now the player does have a network
29:14 - object again remember it must have this
29:16 - component in order for this to exist on
29:18 - the network okay so we have the player
29:20 - we have a network Behavior we have a
29:22 - network object and on the network
29:23 - manager we have it set as the player
29:25 - prefab
29:26 - so like this the network manager
29:28 - shouldn't automatically instantiate the
29:29 - player as soon as the player connects so
29:31 - if we test this and nope we have a ton
29:34 - of Errors right away basically what we
29:36 - have here is the first of many errors
29:37 - that we're going to see that showcase
29:39 - the difference between making a game in
29:40 - single player and multiplayer this
29:43 - specific error is over here on the
29:45 - slight counter visual over here we are
29:46 - accessing the player instance now in our
29:49 - single player game the player was added
29:51 - onto the scene by default so it was
29:53 - there right as soon as the scene was
29:54 - loaded which means that the player
29:56 - instance reference was already set but
29:58 - here in multiplayer the player is really
30:00 - only created when a connection is
30:02 - established so as soon as the game
30:04 - starts running there is still no player
30:06 - just yet so this instance is going to be
30:07 - set to null again remember how making
30:09 - multiplayer games requires a bit of a
30:11 - different mindset this is just the first
30:13 - of many examples that showcase why that
30:15 - is so important so over here for now
30:16 - let's just comment out the logic that
30:18 - uses this instance so let's go ahead
30:20 - change this and save and we can go over
30:22 - here onto the player script and we can
30:24 - find the other references so using
30:26 - visual studio I can right click and find
30:28 - all the references and I can see that
30:30 - there's just two more over there on The
30:31 - Sound Manager so let's go on to this
30:33 - line and over here let's comment this
30:35 - out and down here we've got another
30:36 - player instance and let's also comment
30:38 - this out then same thing over here on
30:40 - the player itself let's comment out this
30:42 - one just like this
30:44 - basically in multiplayer we are going to
30:46 - have just a single instance of a player
30:48 - there is no Singleton Since By
30:50 - definition we're going to have multiple
30:51 - players however we will have just one
30:54 - local player so this logic will still be
30:56 - useful in a little bit so that is why we
30:58 - are commenting instead of just deleting
30:59 - it but then down here on the awake we've
31:02 - got a test if the instance is already
31:03 - set if so we have more than one player
31:05 - again that's a mistake in single player
31:07 - but in multiplayer this is Perfectly
31:08 - Natural so let's cut these lines and
31:10 - then on this one just commented okay so
31:12 - that should fix some of the instance
31:14 - errors let's try playing again and okay
31:16 - so far so good we have no errors then
31:19 - over here on the network manager when
31:21 - the game is running we can see these
31:23 - three buttons we can start as a host
31:25 - server or as a client again I cover them
31:28 - in detail in the netcode video server is
31:30 - just a server the client is just a
31:32 - client and the host access both a server
31:34 - and a client so for our first player
31:36 - let's make it a host so if I click on
31:38 - this and if we still have yet another
31:40 - error let's see where this one is and if
31:43 - it's right here it's on the name input
31:45 - reference again this is yet another
31:46 - thing related to the different setup in
31:48 - single player versus multiplayer in
31:50 - single player the player was placed on
31:52 - the scene which allowed us to directly
31:54 - drag the reference to the game input but
31:56 - when we made the player into a prefab
31:58 - like this on this prefab we can no
32:00 - longer drag a scene reference the reason
32:02 - is because this prefab can be spawned
32:04 - anywhere on any scene so you cannot drag
32:06 - scene references onto a prefab but later
32:09 - on in the chorus over here for the game
32:10 - input we also made it use the Singleton
32:12 - pattern so over here on the player we
32:14 - can just modify that so for the game
32:16 - input instead of having a field let's go
32:18 - into the game input let's access the
32:19 - static instance just like this on all of
32:21 - these references so wherever we have
32:23 - that one replace it and down here
32:25 - replaced okay we have fixed another
32:27 - error so let's test again also by the
32:30 - way if you don't see the network manager
32:32 - game object that one isn't over here
32:34 - inside your scene it is actually inside
32:35 - the don't destroy unload scene so over
32:38 - here we have our buttons let's start as
32:39 - a host and the up now it works we have
32:41 - no more errors okay so far so good now
32:44 - using the inspector buttons obviously
32:46 - isn't very useful we cannot access these
32:48 - buttons from the game view itself which
32:50 - means we can't really click on it if we
32:51 - make a second build so let's make some
32:53 - simple in-game buttons on the hurricane
32:55 - let's go inside the canvas and inside
32:57 - let's create an empty game object call
32:59 - this the testing netcode UI then let's
33:02 - make it stretch to occupy everything so
33:04 - put 0 0 on everything now inside let's
33:07 - make a new UI image call this the
33:09 - background let's make this one in phone
33:11 - black and once again stretch it to
33:13 - occupy everything and put it wrong on
33:15 - zero okay then let's make a button so
33:19 - let's regularly create a new UI button
33:21 - conversely start host button and inside
33:25 - for the text let's say host let's change
33:28 - the vision a little bit so let's put the
33:29 - text in white let's put it in bold a
33:32 - tiny bit bigger and let's increase the
33:34 - size of the button as well
33:36 - so something like this and let's put it
33:38 - on a dark gray and put it on an X of
33:41 - zero okay so that's our basic host
33:43 - button let's lift it up a little bit
33:45 - then duplicate it push it down here this
33:47 - one is going to be the start client
33:49 - button and inside let's just say client
33:53 - okay we have our two simple testing
33:55 - buttons which is make sure they are on
33:57 - top of everything else so we can click
33:59 - on them remember how the Sorting
34:01 - ordering DUI works it is all based on
34:03 - the order in the hierarchy so in order
34:05 - to make this one always on top drag it
34:07 - to the bottom of the canvas hierarchy
34:08 - okay now let's make a script to run this
34:11 - so let's go into our scripts into our UI
34:13 - scripts let's create a brand new c-sharp
34:15 - script for the testing netcode UI let's
34:18 - attach it to our object and by the way
34:20 - if you're following along this specific
34:21 - entity version has this strange bug or
34:23 - if you drag a component that actually
34:25 - adds twice if you're using a later Unity
34:27 - version probably won't have this bug but
34:29 - if this is still the latest version by
34:30 - the time this video goes on just go
34:32 - ahead and remove the second one okay so
34:33 - let's open and over here let's just add
34:36 - some simple references to our buttons
34:38 - so as usual let's make it a serialized
34:40 - field of type button
34:42 - for the start host button and then we
34:45 - have another one for the start client
34:47 - button
34:48 - then over here in the editor let's drag
34:50 - the references so the host and the
34:51 - client okay and now let's add our click
34:53 - events so let's go make an awake and go
34:56 - into the start host button let's add an
34:58 - on click let's add in listener
35:01 - and for the enlistener
35:04 - when we click on start host let's go
35:07 - into the network manager let's access
35:08 - the class itself which again is inside
35:10 - using unity.netcode
35:13 - then inside that one there is a static
35:15 - Singleton and from there we can then
35:17 - call the function start in this case
35:19 - start host
35:20 - okay so this will start the host let's
35:22 - just do a debug.log so we can see so we
35:25 - are starting a host and then afterwards
35:27 - we want to hide this testing window so
35:29 - let's make a simple import void hide and
35:32 - on high just set this game object to
35:33 - active as false so that will hide it so
35:37 - we post a message start host and then
35:39 - hide and then same thing for the client
35:42 - so on the start client button on this
35:45 - one start as a client and just call the
35:47 - different function so start client okay
35:49 - that's it a very simple script
35:51 - make sure you drag the references and
35:53 - now we're ready for testing with
35:54 - multiple builds so let's go up here into
35:57 - file and let's go into build settings
35:58 - now importantly for our single player
36:01 - game we were starting from the main menu
36:03 - but here when we're developing our
36:05 - multiplier game we really don't want to
36:07 - have to go through the main menu every
36:08 - single time so let's just drag the game
36:10 - scene on top so that is the one that we
36:12 - start with then over here select your
36:13 - target platform for me I'm going with
36:15 - Windows and then for some other settings
36:17 - let's go down here into player settings
36:19 - this opens up the project settings and
36:21 - goes into the player Tab and over here
36:24 - let's go inside the resolution and
36:25 - presentation and now in order to make
36:27 - testing easier let's make it with
36:29 - Windows instead of full screen so put it
36:31 - on windowed then the Size Doesn't Really
36:32 - Matter let's just make sure we run it on
36:34 - background so the game keeps running
36:36 - even as we switch between the windows
36:37 - and then down here let's make it a
36:39 - resizable window that way we can stretch
36:42 - and fit them in order to fit multiple
36:43 - windows on our screen okay so these are
36:45 - the settings let's just close out of the
36:47 - project settings and over here let's go
36:48 - ahead and make a build just go ahead
36:50 - choose a folder and build
36:52 - alright so here is the build so let's
36:54 - open it any up here is the build running
36:56 - now in the editor let's head on play as
36:58 - well so we've got both of them now in
37:01 - the editor let's click on host and down
37:03 - here let's click on client and here both
37:05 - are connected and we can verify that so
37:07 - on the editorial let's minimize this and
37:10 - we can look in the game scene over here
37:11 - see yep we do have indeed two player
37:13 - clones alright awesome now of course
37:16 - this is just a Bare Bones connection so
37:18 - if I move this player there you go both
37:20 - players are moving
37:21 - and obviously the movement isn't being
37:23 - synchronized so we're going to need to
37:25 - fix this in the next lecture but the
37:27 - important thing is that we have a nice
37:29 - network connection on fully established
37:31 - this is the absolute Basics and
37:32 - basically all we need now is just to
37:34 - synchronize everything now before we end
37:36 - this lecture let's just do some more
37:38 - small things first of all on the game
37:40 - state right now the way we made our
37:42 - single player game is we have this
37:44 - controls window then we go into a three
37:46 - two one countdown and only then the game
37:48 - is actually active now this is great in
37:50 - terms of the funnel game but it's a bit
37:52 - annoying while developing and testing
37:54 - the multiplayer game so let's just
37:55 - modify the code to skip this part let's
37:58 - go over here onto the kitchen game
37:59 - manager and down here we have all of our
38:01 - various things
38:03 - so we have that we start off on waiting
38:05 - to start end to end when we get some
38:07 - input we go into the countdown which
38:09 - then counts down the countdown timer so
38:11 - let's basically just make this start
38:12 - playing automatically so let's go over
38:14 - here on start
38:16 - and let's just run the code to
38:17 - automatically start it so let's run this
38:19 - let's put a comment here so we remember
38:21 - why we made this so just say debug
38:23 - trigger game to start automatically
38:26 - okay and also same thing for the
38:27 - countdown timer so Pierre for this one
38:30 - instead of starting on three seconds
38:31 - let's start in just one second and then
38:33 - also important over here for the game
38:34 - playing timer Max
38:36 - pretty soon let's make sure we leave
38:37 - enough time so let's say something like
38:39 - 300 basically we don't want to trigger a
38:41 - game of well we're still busy doing some
38:43 - testing okay so let's test here in the
38:46 - editor I click on host and there you go
38:47 - the game starts playing right away okay
38:48 - great now for one more important thing
38:51 - when testing our multiplayer game we're
38:53 - going to need to read the logs now here
38:55 - in the editor we can just access the
38:57 - console and read it
38:58 - but in the build we don't really have
39:00 - this so to some of that there is one
39:02 - extremely useful asset that I like which
39:03 - is called the quantum console although I
39:05 - should point out this step is optional
39:07 - you don't need this asset to make
39:08 - multiplier games it just makes it a bit
39:10 - easier
39:11 - so before I show the yes let's see how
39:13 - you can read logs without it so over
39:15 - here I have both builds running so on
39:17 - the editor I can read the console but on
39:19 - the build I cannot if you go on to the
39:21 - ENT documentation here you can see the
39:23 - path for where all of the unlock files
39:25 - are now in this case we want the build
39:27 - log so that's not the add to roll in log
39:29 - so let's scroll down and down here we
39:30 - see the player related logs in this case
39:33 - I'm running on windows so this is the
39:34 - path that I want to find so it's under
39:37 - user profile app data local low then the
39:39 - company name and the product name now
39:41 - for the company name and product name
39:43 - for that you go into file let's go into
39:44 - build settings and let's go over here
39:46 - into the player settings
39:47 - and over here on the player tab up here
39:49 - you see the company name and the product
39:51 - name so make sure you write these before
39:53 - you actually make the build and if you
39:55 - go to that path you won't see these logs
39:57 - so if you go ahead and open this text
39:59 - file if there you go here we do see the
40:01 - logs for the actual build so over here
40:03 - on the build I just started as a client
40:04 - so it just allowed the client message
40:06 - and it is exactly what we see over here
40:08 - also by the way you can just keep this
40:10 - file open and just press F5 to refresh
40:12 - it for example if I exit out of the
40:14 - build it is going to update the log so
40:15 - if I exit this and over here I press on
40:17 - F5 and there you go it updates
40:19 - everything so this is the minimum wage
40:21 - read it you just go to this file and
40:22 - refresh it so that works but having to
40:25 - have this file open all the time and
40:26 - having to refresh it is a bit annoying
40:28 - so personally I really like using
40:30 - Quantum console which easily adds a
40:32 - console that you can also see in the
40:33 - build and in general it's just a great
40:35 - asset all around really useful for all
40:37 - kinds of testing I made a fully detailed
40:40 - review on it if you want to learn about
40:41 - it and there's also in the film Link in
40:43 - description if you want to get it but
40:45 - again this is completely optional if you
40:47 - don't want to buy this asset you can
40:48 - just keep that file open and hit refresh
40:50 - just to read the console
40:52 - now since I do have that asset I'm going
40:54 - to use it to make developing easier so
40:56 - I'm going to go into window package
40:57 - manager I'm going to go into the my
40:59 - assets
41:00 - then just search for the quantum console
41:02 - and up here I have the asset so I'm just
41:04 - going to import it I'm going to import
41:06 - everything
41:07 - then over here in the project files
41:09 - inside the plugins folder qfsw Quantum
41:11 - console source and over here is the
41:13 - prefabs any of there are two prefabs
41:15 - this game is made using urp which is an
41:18 - SRP so let's drag this one there you go
41:20 - there's the quantum console now I'm just
41:22 - going to resize this a little bit so
41:23 - inside on the console rect I'm just
41:26 - going to move this make this a little
41:27 - bit thinner okay something like this and
41:29 - that's it there's nothing else we need
41:31 - to do so now if we just go ahead build
41:33 - and run any up here is a console which
41:36 - we can now easily read the editor
41:37 - unlocks for both the editor and the
41:39 - build okay great now just one more tiny
41:42 - thing related to the setup if we unlock
41:44 - in the network manager over here there's
41:46 - something called the unlock level
41:48 - you can put it on normal error nothing
41:50 - or developer mode now normally I would
41:53 - put it on developer to get as much info
41:54 - as possible but it seems that this
41:56 - version of NGO has a bit of a weird bug
41:58 - during my testing later on when we add
42:01 - some animations it was constantly
42:02 - pushing a weird warning which was
42:03 - causing tons of issues so because of
42:06 - that over here I'm going to leave this
42:07 - on the normal out alright so that's it
42:09 - over here we created the basic setup we
42:11 - installed all of the packages that we
42:13 - need and we set up the network manager
42:15 - so we have a player prefab that we can
42:16 - then instantiate all of the basics are
42:18 - perfectly set up now that's left is
42:20 - really just synchronizing the entire
42:21 - game so let's begin doing that in the
42:23 - next lecture
42:26 - hello and welcome I'm your code monkey
42:28 - in this lecture we're going to handle
42:30 - player movement and as we're doing that
42:32 - we're also going to talk about something
42:34 - extremely important whether to make your
42:36 - multiplayer game server authoritative or
42:38 - client authoritative both methods are
42:40 - valid I'm going to Showcase both them
42:42 - and then it's up to you to decide which
42:44 - one best fits your game okay so the
42:46 - basic setup is already working we have
42:48 - the network manager set up so over here
42:50 - with these two builds I can start this
42:52 - one as a host this one as a client and
42:53 - yep both of them are connected so far so
42:56 - good however if now I move with some
42:58 - input yep both objects are both on the
43:01 - exact same position and they are both
43:02 - moving with the same input and of course
43:04 - the movement is on local so nothing is
43:06 - being synchronized so let's end on this
43:08 - for the first problem we just need to
43:09 - make one small change over here on the
43:11 - player script like we saw right now the
43:13 - input is moving both players but we
43:15 - don't want that and the movement is down
43:17 - here we have our update where we are
43:19 - handling the movement and interactions
43:20 - both players have this grip so both
43:23 - players are running this code but we
43:25 - only want a player that is local to that
43:27 - building to run this code and how we do
43:28 - that is very simple on the network
43:30 - Behavior we have a bunch of nice
43:31 - properties we can check out a bunch of
43:33 - is things so we can check his client is
43:36 - host his local player his owner is
43:38 - server and so on and basically for this
43:40 - one in this case for checking if this
43:42 - player is in local player we can check
43:44 - his owner that is because the player
43:46 - game object won't be owned by the player
43:47 - when that player joins and that object
43:49 - is spawned so if we checked his owner
43:51 - this one is only going to be true for
43:52 - the unlock on player so we only want in
43:54 - local player to run this so over here we
43:56 - can just check if this one is not the
43:58 - owner if not then we just return so this
44:01 - one will only be true for the local
44:03 - players so only the local player is
44:04 - going to run the movement and the
44:06 - interactions okay that's it that's the
44:07 - only change now if we test so here are
44:10 - the two players and if I move just this
44:11 - one up here yep it only moves one and
44:14 - down here and yep it only moves on okay
44:16 - great however of course as I move it the
44:19 - movement is still not being synchronized
44:20 - the client down here still thinks that
44:22 - the host is over there on the spawn
44:23 - position same thing on the host some
44:24 - things that the client is over there so
44:26 - let's synchronize the movement and we
44:29 - can do this using a super simple
44:30 - component let's go over here onto the
44:32 - player prefab and we can just have the
44:34 - component search for our Network and
44:36 - let's add the network transform
44:37 - basically this one synchronized all the
44:39 - transform data we can even use these
44:41 - check boxes here to help reduce the
44:43 - bandwidth by only synchronizing the
44:44 - things that can actually change
44:46 - for example in this game the player only
44:48 - ever moves Left Right further than back
44:50 - there's no jumping involved in this game
44:52 - so there's no need to synchronize the Y
44:54 - position
44:55 - for the rotation we're only going to
44:57 - rotate on the Y so there's no need to
44:58 - synchronize these two and for the scale
45:01 - the scale is never going to change so we
45:02 - can also not synchronize these two okay
45:04 - so this won't synchronize the transform
45:06 - and only the things that actually matter
45:08 - and this is where the question of server
45:10 - versus client auth comes in the way this
45:12 - component works this one is only server
45:14 - authoritative so if we try like this let
45:16 - me go back outside save the changes and
45:18 - make a build so here are both builds up
45:20 - here the hose down here the client now
45:22 - if I move on the host if there go the
45:24 - host does move and it does get
45:25 - synchronized over there on the client so
45:27 - that's great that looks like it does
45:28 - work however if now I go down here onto
45:31 - the client and I move and nope the
45:33 - client doesn't even move I'm pressing
45:34 - the buttons the animation is actually
45:36 - playing so the input is being received
45:38 - but nope there is no movement that is
45:40 - because that component the network
45:41 - transform that one is only server
45:43 - authoritative meaning that only the
45:45 - server which is also the host only this
45:48 - one has authority to move this transform
45:50 - if this local client down here tries to
45:52 - move it then basically just snaps back
45:54 - to where the server says that object is
45:56 - like I said I'm going to Showcase both
45:57 - methods because both methods are valid
45:59 - let's begin by looking at the client
46:01 - auth method and for this one we are
46:03 - going to use a different component we
46:05 - can go into this page so onto the docs
46:08 - you can just go into the docs themselves
46:10 - and go into the netcode for game objects
46:12 - then go under components and go into the
46:14 - network transform page so on this one if
46:16 - we scroll down down here we can see a
46:19 - client Network transform this is exactly
46:21 - what we want it allows for client
46:22 - authoritative gameplay so we can either
46:25 - import the entire samples from git or
46:27 - just down here we have on the code so I
46:28 - just go ahead and copy all of this code
46:30 - then over here in the editor let's just
46:32 - make a new c-sharp script
46:34 - call this the client Network transform
46:36 - and then over here just select all and
46:38 - paste entire code that's it so here
46:40 - basically all it does is just extends
46:42 - the network transform and just does an
46:44 - override on is server authoritative and
46:46 - returns phones so this way this one is
46:48 - no longer server out and works as client
46:50 - out so now if we select the player
46:52 - prefab and over here let's replace the
46:53 - natural transform for the other one so
46:55 - the client Network transform
46:57 - and let's add the syncing on the same
46:59 - thing okay that's the same setup so we
47:01 - just change the component now if we test
47:03 - this so here is a host and as I move it
47:06 - yep it does get synchronized and down
47:08 - here the client as I move it any up now
47:10 - this one does get synchronized so we can
47:12 - move both independently and both of them
47:14 - are being synchronized alright awesome
47:17 - so this is how you can make your game
47:19 - client off meaning that the client has
47:21 - the authority to make changes on the
47:23 - server State this has some pros and cons
47:25 - which I'm going to talk about in a bit
47:26 - but before that let's actually look at
47:28 - how to make this internally server auth
47:30 - basically in order to make this server
47:32 - authoritative we need to make sure that
47:33 - only the server can move the objects the
47:36 - client can request a move but it's up to
47:38 - the server to decide whether to actually
47:39 - move it so we're here on the player
47:41 - script let's go down into where we are
47:44 - handling the movement so on the handle
47:45 - movement function let's go to this one
47:47 - and basically what we want is over here
47:49 - we are moving the transform position
47:50 - directly and again remember this
47:52 - function is going to run on the unlock
47:54 - on client every client is going to run
47:56 - this whether they are the server or just
47:57 - a regular client and to make this server
48:00 - out we need to make sure that only the
48:01 - server runs this code so how we can do
48:03 - this is basically do a server RPC to
48:05 - tell the server where we would like to
48:07 - move now if you don't know what is an
48:09 - RPC at all make sure you watch my
48:10 - netcode video basically it's a remote
48:13 - procedure column meaning it's a way to
48:15 - run code on the server or the client
48:16 - from another place so here the clients
48:19 - will tell the server where they would
48:20 - like to move also by the way for this
48:22 - section I'm going to rewrite this code
48:24 - to make it several auth but then I'm
48:25 - going to come back to this state the
48:27 - rest of the game won't be client Earth
48:28 - so if you're following along there's no
48:30 - need to follow this part
48:31 - so for that we're going to have a
48:33 - function like handle movement
48:36 - call it server auth this one is going to
48:39 - run on every client so on this one all
48:41 - we get is the input and then we're going
48:43 - to send the input to the server so we're
48:44 - going to do that with an RPC so private
48:46 - void handle movement server RPC and on
48:49 - this one we are going to read a vector 2
48:52 - for the input vector
48:54 - then we need to mark this as a server or
48:56 - PC
48:57 - up here we are going to call this
48:59 - function and pass in the input vector
49:01 - and then down here we're going to run
49:03 - the exact same code so I'm just going to
49:04 - copy all of this so just copy and paste
49:07 - the exact same thing so we get the input
49:09 - converted into a move Direction and then
49:10 - the server itself is actually going to
49:12 - move the object and that's really it
49:14 - that's how you make it server out so
49:15 - let's go up here instead of running this
49:17 - function let's run the one with server
49:19 - auth okay that's it here then in the
49:22 - editor let's just go into the player and
49:23 - once again let's remove this one and add
49:25 - the other one
49:27 - so the network transform let's add the
49:30 - regular one this one is server auth and
49:32 - again the same thing then now we can
49:35 - test so here we are and if the host
49:37 - moves and yep everything does move
49:38 - that's correct and down here on the
49:40 - client if the client does move and yep
49:42 - it does still move all right awesome so
49:45 - in this case making it server auth is
49:47 - actually pretty easy the basic idea is
49:49 - you only actually modify the game say
49:51 - just on the server the clients can make
49:53 - some requests but the server is the
49:55 - final source of Truth now let me talk
49:57 - about the differences between server and
49:59 - client auth and where you'd want one
50:00 - versus the other
50:02 - the obvious Pro for server auth is
50:04 - security if the server is the only
50:06 - source of Truth for the game say that
50:07 - makes it much more difficult to hack the
50:09 - game the server gets requests from the
50:11 - clients and then can validate those
50:12 - requests to see if the values are valid
50:14 - meaning for example if the client down
50:16 - here if it tries to move on to an
50:18 - impossible position the server can just
50:20 - say nope you cannot move there whereas
50:22 - if the game is client off with that
50:24 - technically a hacker could modify the
50:26 - game files to change something like the
50:28 - player speed and make the player move
50:29 - much much faster
50:31 - since the server would just receive an
50:33 - accept the player position that would
50:34 - actually work a hacker could modify the
50:36 - game and suddenly the player can walk
50:38 - through walls because the server just
50:39 - accepts whatever the client gives it but
50:42 - if it is server auth then the client
50:44 - just sends an input and if that input
50:46 - has a bit of a weird magnitude then is
50:48 - it expected
50:49 - if so then the server can just
50:51 - revalidate that input and that way the
50:52 - hacker can no longer move faster than
50:54 - expected so when it comes to multiplayer
50:56 - the big question is really about trust
50:57 - so do you want to trust a client or not
50:59 - if you do and the client is malicious
51:02 - then they might break the game they
51:03 - might get some infinite money or just
51:05 - walk through walls so with that said you
51:07 - might be thinking that means server auth
51:08 - is the way to go all the time but the
51:10 - answer is it really depends on what kind
51:12 - of game you're making server auth also
51:14 - has some downsides building a purely
51:17 - server off the game really requires
51:18 - quite a bit more complexity you need to
51:20 - validate every single input and
51:22 - everything coming from the player that
51:24 - really complicates things so there is a
51:26 - cost to making it server auth it does
51:27 - require some effort one example as to
51:30 - how server auth is much more complex is
51:31 - simply with regards to client-side
51:33 - prediction so right now the game
51:34 - actually looks pretty normal New
51:36 - Movement looks pretty good so I'm moving
51:38 - around over here on the client and
51:39 - everything does seem pretty correct but
51:41 - that is really because I'm only hosting
51:43 - the game locally so right now I'm seeing
51:45 - pretty much no lag now thankfully the
51:47 - unity transport over here actually has
51:48 - some nice debug fields we can for
51:51 - example over here put 500 milliseconds
51:52 - of DNA to test the difference
51:54 - so now here I am playing with the same
51:56 - server auth and if I move on the server
51:58 - over here the host is nice and
52:00 - responsive everything works fine because
52:02 - this one is actually the host so as I
52:03 - move it does move automatically however
52:06 - down here on the client I'm going to
52:08 - press a button hard so you can see so
52:10 - move and yep look at that it takes half
52:13 - a second for the player to actually move
52:14 - so I press the button and it takes 500
52:17 - milliseconds before that one actually
52:19 - responds to input
52:20 - now if you launch your game like this
52:22 - every player would find this completely
52:23 - unacceptable you cannot have the player
52:26 - press a button and then have to wait a
52:27 - long time for the changes to reflect in
52:29 - their own build so if you implement
52:30 - server off then you absolutely must
52:32 - Implement client-side prediction which
52:34 - is a pretty complex topic basically you
52:36 - would need to create just a local object
52:38 - then when the player press a button you
52:40 - would move that local object to where
52:41 - you think it won't be when the message
52:43 - actually gets the server whereas if you
52:45 - just make it clean dot you don't really
52:46 - have to worry about any of that the
52:48 - client updates automatically and then
52:50 - the changes are sent to the server so
52:51 - when working on games kind of like this
52:53 - something casual in Co-op for this
52:55 - client auth is usually somewhere and
52:57 - won't work just as well people will be
52:59 - playing in co-op with their friends so
53:01 - if a friend really starts cheating they
53:02 - won't just stop playing with Aspirin
53:04 - in the end the basic General answer is
53:06 - if you're building some kind of PVP
53:08 - competitive game then you probably want
53:10 - to go with several to some cheaters but
53:13 - if you're making something Co-op
53:14 - something more for fun rather than
53:16 - competition then those cases you're
53:18 - probably best to go with clientot now
53:20 - this game is exactly that it's a casual
53:22 - Co-op game so for this game I won't be
53:24 - going with the client auth approach so
53:26 - with all that said let me revert back
53:28 - the changes to make it client off so
53:29 - over here I'm going to get rid of this
53:31 - function and go back into the general in
53:33 - the movement and down here I'm just
53:34 - going to take these and both these
53:36 - functions Get Rhythm so exactly the same
53:39 - as previously then back in the editor on
53:41 - the player let's once again remove this
53:42 - one and add the client Network transform
53:44 - instead same thing let's not synchronize
53:47 - all of these and finally on the network
53:49 - manager down here let us not add some
53:51 - debug delay okay so let's test again
53:54 - so here I am if I'm moving the host yep
53:56 - everything works down here on the client
53:58 - move it and yep everything still works
54:00 - alright awesome
54:02 - so here we'll learn how to synchronize
54:03 - basic layer movement and importantly we
54:06 - also learn the differences between
54:07 - server and client auth and which one you
54:09 - should choose depending on what game
54:11 - you're working on now like this so far
54:13 - we only have the movement synchronized
54:14 - our nice animations aren't actually
54:16 - playing so let's solve that in the next
54:18 - lecture
54:20 - hello and welcome I'm your code monkey
54:22 - in this lecture we're going to
54:24 - synchronize the player animations this
54:26 - is actually extremely simple to do in
54:27 - netcode for game objects so this is
54:29 - actually going to be a super quick
54:30 - lecture okay so here we have our players
54:33 - and both the hosts up here and the
54:35 - client down here both of them can move
54:36 - and the movement is indeed correctly
54:38 - being synchronized so it's all good
54:40 - except only the movement is
54:41 - synchronizing so as I move this one up
54:43 - here it's playing the animation but down
54:45 - there nope no animation
54:47 - so let's fix this and in order to fix
54:49 - this once again we have two options the
54:52 - default way is using the built-in
54:54 - component the network animator so let's
54:56 - go inside the player prefab and over
54:58 - here we've got the player visual this is
55:00 - the game object that has the animator so
55:02 - we can add a component and let's add a
55:04 - network animator
55:05 - this one takes an animator film so let's
55:07 - just drag this animator put it on there
55:09 - yep there it is now this will
55:10 - automatically synchronize the animator
55:12 - and all of its parameters now before we
55:14 - test let's just see one very important
55:16 - thing over here on the player animator
55:18 - this is the script that we made in the
55:19 - single player game over here for this
55:21 - grip we need to make sure that this one
55:23 - only runs on the owner otherwise this
55:25 - script will then override the network
55:26 - animator so instead I'm going to be here
55:28 - and let's make this a network Behavior
55:31 - let's add unity.net code and down here
55:34 - on update if not is owner
55:37 - so if not is owner just return okay and
55:40 - by the way this object doesn't need a
55:42 - network object because there's already
55:43 - one on the parent player game object
55:45 - okay so like this we've got the network
55:47 - animator something like this it should
55:48 - work so let's test so up here if we move
55:52 - on the host and if they're going with
55:53 - that the animations are indeed being
55:54 - synchronized okay so that's great all we
55:57 - really had to do was just add this
55:58 - component and the entire animator state
56:00 - is already perfectly synchronized so
56:02 - that's awesome however if I go over here
56:04 - onto the client and as I move it let's
56:06 - see and nope over there we do not have
56:08 - the animations being synchronized again
56:10 - we have the exact same issue that we had
56:12 - previously with the network transform
56:13 - the network animator just like the
56:16 - network transform is server
56:17 - authoritative so it will only work if
56:20 - the server is the one sending out the
56:22 - commands and it will not work when the
56:24 - client is the one trying to send out the
56:25 - commands that is why over here the host
56:27 - does synchronize with the client does
56:29 - not so again we have our usual two
56:31 - options we could modify this code to
56:34 - make it server auth basically use some
56:36 - server rpcs to tell the server what
56:38 - state the animator should be in or
56:40 - alternatively we can make the network
56:41 - and meta client auth let's go with that
56:43 - approach and again the docs have a nice
56:46 - simple script to make this so if we go
56:48 - into the multiplayer docs if we go over
56:50 - here into netcode for game objects then
56:51 - under components and under the network
56:53 - animator over here if we scroll down we
56:56 - can see yep the owner authoritative mode
56:58 - so if the client is the owner which it
57:00 - is on the player if so then this becomes
57:02 - a client authoritative mode and you've
57:04 - got the script and literally is just
57:06 - this super simple so let's go ahead and
57:07 - copy this then back in unity over here
57:10 - let's create a new c-sharp script
57:12 - for the owner Network animator
57:15 - and over here let's just select
57:17 - everything in paste the code okay that's
57:19 - it super simple now let's go inside the
57:21 - player prefab and over here on the
57:23 - visual let's get rid of the network
57:24 - animator and instead at the other one
57:26 - the owner Network animator this has the
57:28 - exact same field so let's just paste it
57:30 - and just like this some of our animation
57:32 - should already be perfectly synced so
57:34 - let's just go outside save the prefab
57:36 - and make a build so up here is the host
57:38 - and as I move it yep the host is indeed
57:40 - synchronized and down here on the client
57:42 - if I move it any of the client is also
57:44 - nice and synchronized alright awesome so
57:47 - as you can see really is this simple to
57:48 - synchronize animations in multiplayer
57:50 - you just set a component and that's
57:52 - really it so with that we now have the
57:54 - movement and the animations both of it
57:56 - working perfectly and synchronized DC
57:58 - were pretty simple thanks to the
57:59 - built-in components and now we can start
58:01 - handling how to synchronize some proper
58:03 - game logic like for example the delivery
58:05 - manager and that's exactly what we're
58:07 - going to do in the next lecture
58:10 - hey there here's a quick intermission so
58:12 - how are you doing are you enjoying the
58:14 - course so far are you having any trouble
58:16 - with anything is there something you
58:17 - didn't understand multiplayer can be
58:20 - complex but once you understand it I
58:21 - think this tool set is actually pretty
58:23 - easy to use just make sure you fully
58:25 - understand the differences between all
58:26 - the types so what is the server and what
58:28 - is a client if you get that part then
58:30 - everything starts to become pretty
58:32 - straightforward so from that let me ask
58:34 - you what has been the most challenging
58:35 - part so far
58:37 - remember that I'm always active in the
58:39 - comments answering all the questions
58:40 - every day so if there's anything you
58:42 - need extra clarification go ahead and
58:44 - ask and I'll do my best to help also
58:46 - remember to check out the course website
58:47 - I will keep that page updated with
58:49 - frequently asked questions so you can
58:51 - see what others have asked for each
58:52 - lecture and you can also download the
58:54 - project files at each point and compare
58:56 - with your own so keep that page open on
58:58 - the second Tab and check it out every
59:00 - time you start watching a lecture I hope
59:02 - you are enjoying the course and already
59:03 - learned quite a few things go ahead and
59:05 - hit the like button and subscribe to the
59:07 - channel if you haven't already Okay so
59:09 - let's go to the next lecture
59:12 - hello and welcome I'm your code monkey
59:14 - in this lecture we're going to begin
59:15 - synchronizing some proper game logic by
59:18 - handling the delivery manager okay so
59:20 - for our first lecture synchronizing the
59:22 - game logic let's begin with the simplest
59:23 - one which is really just the delivery
59:25 - manager so here we have the game playing
59:27 - right now we have two players connected
59:29 - the movement and the animations of it is
59:32 - being synchronized but for example over
59:34 - here on the recipes note that each
59:36 - client is generating their own recipes
59:37 - that is not correct we only want the
59:40 - server to generate recipes and we want
59:42 - all clients to be seeing the exact same
59:44 - recipe waiting list then we also want to
59:46 - synchronize whenever a player delivers a
59:48 - recipe either correctly or incorrectly
59:50 - and again here we have to answer the
59:52 - same question as always do we make the
59:53 - server auth or client off but before
59:55 - that let's start from the beginning
59:57 - let's first go up here onto the delivery
59:59 - manager script and as usual let's swap
60:01 - out the mono behavior for a network
60:03 - behavior and let's go ahead and add
60:06 - unity.netcode then over here in the
60:08 - editor let's find the object with the
60:10 - delivery manager and as soon as you so
60:12 - like that yep we've got the nice window
60:13 - so let's go ahead click on yes and there
60:15 - you go it does have the network object
60:17 - so back onto the delivery manager like I
60:20 - said we only want the server to generate
60:22 - recipes the other clients should just
60:24 - receive the recipes from the server so
60:26 - let's go down here and where we have the
60:28 - update where we count on the timer and
60:29 - spawn the recipes over here we want to
60:31 - make sure this logic only runs on the
60:33 - server so like we saw if we have a
60:35 - network Behavior we've got all kinds of
60:37 - is properties in this case for running
60:40 - things on the server we can ask is
60:41 - server so if the Nissan is not the
60:44 - server if not then we just return okay
60:47 - so let's do a quick test and yep both
60:49 - the host and the client both of them are
60:51 - connected but only they're the host only
60:52 - that one is generating recipes okay so
60:55 - far so good now we need to do is really
60:57 - just synchronize e-spawn recipes so that
60:59 - the client knows about them and for that
61:00 - we basically have two options we can use
61:03 - rpcs or we can use a network variable
61:06 - both are valid options I cover them both
61:08 - in detail in the netcode video the one
61:11 - big difference between them is mostly
61:12 - related to late joiners so if a player
61:15 - joins late they won't receive the
61:17 - current state of a network variable but
61:19 - they will not receive the client
61:21 - services that were sent before that time
61:22 - this means that it is actually very
61:24 - important for you to decide whether you
61:26 - want to allow late joining in your game
61:27 - or not that is a very important decision
61:29 - that will decide how you implement
61:31 - certain features for this game this is a
61:33 - simple game with a short session
61:35 - duration each game session is really
61:36 - just only about 2 minutes so for this
61:39 - game I'm going to decide to not allow
61:40 - late joining so all the players join in
61:43 - the beginning of the game and they play
61:44 - until the very end no player can join
61:46 - the middle making this Choice really
61:48 - helps cut down on the complexity needed
61:50 - to make this game and near the end of
61:52 - course I will have a lecture talking
61:53 - about this difference in more detail and
61:55 - what you would have to change if you
61:57 - want to enable the game to support late
61:58 - joiners the main takeaway right now is
62:01 - that this is a very important question
62:02 - you need to ask yourself when making
62:03 - your game in my case like I said for
62:06 - this game we are going to not allow late
62:08 - joiners so for synchronizing the
62:09 - standard we going to do it through the
62:11 - simpler RPC method although also don't
62:13 - be confused rpcs and network variables
62:16 - can both be used regardless of what you
62:17 - choose it's just that in a design that
62:20 - is meant to support light joiners you
62:21 - probably want to use Network variables
62:23 - more often but even if you don't want to
62:25 - allow it you can still use Network
62:26 - variables just like we will use later on
62:29 - in this course okay so with all that
62:30 - said let's implement the synchronization
62:32 - with rpcs back in the delivery manager
62:35 - over here on the update basically the
62:37 - server is generating all of the recipes
62:38 - and when it does we want to tell the
62:41 - clients that this specific recipe has
62:43 - been generated so let's make a client
62:44 - RPC to tell the clients to spawn a new
62:46 - waiting recipe so let's go up here make
62:48 - a new function private ruined let's call
62:51 - it spawn new waiting recipe
62:54 - and as we know from seeing the other
62:56 - netcode for game objects video on the
62:58 - client rpcs must end with client RPC so
63:01 - let's end this with client RPC then to
63:03 - make this an RPC we also need to add the
63:05 - attribute so client RPC and finally the
63:08 - goal is to spawn a new winning recipe so
63:10 - let's receive the recipe so that we want
63:11 - to spawn so this is the waiting recipe
63:13 - so again remember the RPC rooms that I
63:16 - covered in netcode video so first one is
63:19 - make sure the name ends exactly with
63:20 - client RPC so it has to be like this it
63:22 - cannot be in lowercase and so on so it
63:24 - has to be exactly client RPC then make
63:27 - sure you add the attribute and also
63:29 - remember how the client rpcs actually
63:31 - work basically the server will call this
63:33 - function so up here when we generate
63:35 - something we are going to call this and
63:36 - pass in the waiting rest PSL so the
63:39 - server itself is running this code and
63:40 - calling this function but in reality
63:42 - this function will actually run on every
63:44 - single client also remember that the
63:46 - host access both a server and a client
63:48 - so the host will be running the code up
63:50 - here and also the code over here for the
63:52 - client RPC so up here we trigger the
63:54 - client enter PC to spawn the recipe and
63:56 - then down here we just do our local
63:58 - logic so we add it to the list and we
64:00 - fire off the event okay so this looks
64:02 - like valid code we have no errors
64:04 - however if we go back in the editor you
64:06 - appear in the console we do see a bunch
64:08 - of errors this is also important server
64:11 - and client rpcs have various rules and
64:13 - Foundation which does not run on Visual
64:15 - Studio but it does show up over here on
64:17 - the console in the editor so when you
64:19 - make an RPC always check the console to
64:20 - make sure you didn't break any of these
64:22 - rules for example this rule here is
64:24 - telling us that the netcode library does
64:26 - not know how to serialize our recipe so
64:28 - object basically for rpcs we can only
64:30 - synchronize value types or we have to
64:32 - tell netcode how to serialize them the
64:34 - more complex option is to implement I
64:36 - Network serializable I cover that in the
64:39 - netcode video but a much more simple
64:40 - option is to just use a type that can
64:43 - already be serialized for example over
64:45 - here on this script we already have a
64:46 - recipient list so and for deciding which
64:49 - one is going to be the wedding recipe we
64:51 - are really just randomly generating an
64:53 - INT so generally a random index so we
64:56 - can just modify this code so that
64:58 - instead of sending a recipe so instead
65:00 - of that we can just send the index of
65:02 - where it is on the list since all the
65:04 - clients have the exact same list by
65:05 - sending the index we're actually going
65:07 - to be able to get the exact same ASO so
65:09 - let's do that so over here instead of a
65:10 - recipe so let's receive a parameter of
65:12 - type int this is the waiting recipe so
65:15 - index and then up here let's also Define
65:17 - that so the in for the wedding recipe is
65:19 - on index and we do our random.range so
65:22 - the usual stuff
65:23 - then we pass in in this as our parameter
65:26 - and then down here we can simply get the
65:28 - waiting Rest vso by just going into the
65:31 - exact same array and grabbing it from
65:32 - there okay so that's it very simple
65:34 - again remember that the host access both
65:37 - a server and a client so the host will
65:40 - run both the code up here as well as the
65:42 - code down here so importantly make sure
65:43 - you only add this local code adding it
65:46 - to the list and spawning the event make
65:48 - sure you only add this one down here and
65:49 - not also down here as well as up here if
65:52 - you add it in both places then the host
65:54 - will end up spawning two recipes every
65:55 - time now before we test let's just go up
65:57 - here for the spawn recipe timer here
66:00 - this one starts off at zero and we count
66:02 - down meaning that literally on the first
66:04 - frame it is going to spawn right away
66:05 - let's add a bit of time over here let's
66:07 - say for F this is just so we have some
66:10 - time to press the host and the client
66:12 - buttons before anything is actually
66:13 - spawned okay so with that let's test so
66:16 - up here let's connect the host down here
66:18 - the client and now let's wait a little
66:19 - bit and see if the recipe is spawned and
66:21 - you better go down and spawn the recipe
66:23 - and yep that one did yet the recipe
66:25 - synchronized so it's one that one and
66:27 - then that one so they both have the
66:28 - exact same recipes and if we ate a bit
66:31 - yep both have the exact same max amount
66:33 - of recipes alright awesome now here let
66:35 - me make one point later on in this
66:37 - course we're eventually going to
66:39 - synchronize the game start the game
66:40 - countdown and so on so when we do this
66:43 - code will work perfectly but right now
66:45 - you do need to make sure that you
66:46 - connect the host and the client as
66:48 - quickly as possible if instead I connect
66:50 - the hose here and I wait four seconds to
66:52 - spawn a recipe so just wait a bit I want
66:55 - to spawn and now I connect down here on
66:57 - the client
66:58 - if I do that then you have to look how
67:00 - now we have two recipes but down here
67:02 - only one recipe so this is a good
67:04 - example of the difference between
67:05 - Network variables and rpcs basically
67:08 - this client joined late so because of
67:10 - that it missed the RPC spawning the
67:12 - first recipe but again like I said for
67:14 - the design we're going to do this
67:15 - scenario where the player joins late
67:17 - this one is never going to happen just
67:19 - make sure that during testing you click
67:21 - on host and then on client as quickly as
67:22 - possible so you get the actual improper
67:24 - behavior and not just a testing bug okay
67:26 - so now that we have the spawning
67:28 - synchronized let's handle the delivery
67:29 - if I go on the host and I just try to
67:31 - delivering something right now there you
67:33 - go only that one receives it this one
67:34 - down here has no idea something was
67:36 - delivered so we need to synchronize the
67:38 - actual delivery back in our delivery
67:40 - manager let's go down into the function
67:42 - here it is the delivery recipe here we
67:44 - are going to have the exact same
67:46 - question as always so do we make the
67:48 - server auth or client auth meaning do we
67:50 - validate the delivered plate on the
67:52 - client and then the client tells the
67:54 - server whether it was a correct or an
67:56 - incorrect delivery or does the client
67:58 - pretty much only send the Plate Kitchen
68:00 - object and then the server validates the
68:02 - contents again for this Co-op game let's
68:04 - just trust the client and go with client
68:06 - art so the client is going to run all of
68:08 - this logic and then down the end it
68:10 - won't tell the server whether it was
68:11 - correct or incorrect In this case we
68:13 - want the client to tell the server so
68:15 - instead of a client RPC we're going to
68:17 - use a server RPC
68:19 - so let's go up here and make a private
68:21 - void deliver correct recipe
68:25 - server RPC
68:27 - and we're going to add the attribute
68:29 - server RPC okay this is it however this
68:33 - will only run on the server again
68:35 - remember the very very important
68:36 - differences between server host and
68:38 - client if we do it just like this and I
68:41 - copy the code so the local code for
68:44 - delivering the correct recipe and I just
68:46 - put it like this
68:47 - if we don't like this then only the
68:49 - server will run this function so if you
68:51 - do it just like this the client will not
68:53 - know that the recipe has been delivered
68:55 - so always remember those two types
68:57 - server and client basically we want the
68:59 - client to tell the server that it
69:01 - delivered a correct recipe but then the
69:03 - server needs to broadcast you all of the
69:05 - clients that that behavior just happened
69:07 - so when the server receives a server RPC
69:09 - we then need to send a client RPC to
69:11 - broadcast that message to all the
69:13 - clients so let's go down here make a
69:15 - private void deliver correct recipe this
69:18 - time it's a client RPC and we mark it as
69:21 - a client RPC and then it's down here
69:24 - that we do the actual behavior for
69:26 - actually delivering the correct recipe
69:27 - so then on the server PC it just calls
69:30 - the client RPC which again remember how
69:33 - this runs remember how the host is both
69:36 - a client and a server so if we run this
69:38 - on the host the host is going to run
69:40 - this function and then the host is going
69:42 - to run this code and then the host is
69:44 - also going to run this one whereas a
69:46 - client a client is going to call this
69:47 - function but then the client itself does
69:49 - not run this the server runs this calls
69:51 - the client RPC and then the client will
69:53 - also run this function so with this the
69:55 - logic should be working correctly on the
69:57 - all of the correct places we just need
69:59 - over here we need the index so this is
70:01 - the index of the recipe that has been
70:03 - delivered so I just added over here as a
70:05 - parameter since it's an INT we can use
70:07 - it on a server and a client RPC so let's
70:10 - just find an end for the waiting recipe
70:12 - SL list index
70:14 - and up here we pass in the eye then we
70:17 - pass that one in onto the client RPC
70:19 - and then we just use it over here okay
70:21 - so the correct delivery has been
70:23 - synchronized now let's do the exact same
70:25 - thing for the incorrect recipe
70:27 - so let's do a private Droid deliver
70:29 - incorrect recipe for the server RPC
70:33 - and then we're going to have another one
70:34 - but this one is going to be the client
70:36 - RPC
70:37 - then let's say the attribute so client
70:39 - RPC and up here we've got the server RPC
70:43 - then the server is going to call the
70:45 - client RPC to deliver the incorrect
70:47 - client RPC yep just like this and then
70:50 - on all the clients we're really just
70:51 - going to fire off this event so just
70:52 - like this and we're going to trigger the
70:54 - server RPC up here okay so that's it
70:57 - some pretty simple logic as long as you
70:58 - understand the flow for how the server
71:00 - rpcs in the client rpcs work as long as
71:02 - you understand that then all of this is
71:04 - pretty straightforward so let's do a
71:06 - test and see if this works so up here on
71:08 - the host let's deliver a correct recipe
71:10 - so let's make a quick Burger so just put
71:12 - that on the fryer let's grab some bread
71:14 - pick up some plates pick up the meat
71:18 - pick up the bread and now if we go ahead
71:20 - and deliver it and if there go it does
71:22 - work both them so it only re-success and
71:24 - both of them removed it from the recipe
71:25 - list okay that's great but now down here
71:28 - if we do it on the client
71:30 - so let's try to deliver a cheeseburger
71:32 - so let's pick up some meat cook it let's
71:35 - pick it up we just need this
71:37 - and let's try delivering it over here on
71:39 - the client and nope over there we have
71:41 - an error this error has to do with
71:43 - ownership and just like it says only the
71:45 - owner can invoke a server RPC that
71:47 - requires ownership since the delivery
71:49 - manager belongs to the server and not
71:51 - the client that means that only the
71:53 - server can trigger that server IPC that
71:55 - is the default behavior for Server PCS
71:57 - they can only be called by who has
71:58 - ownership and to solve this problem we
72:01 - actually have a very simple solution
72:03 - over here on the server RPC attribute we
72:05 - can have some optional parameters and
72:07 - one of them is down here the second one
72:09 - the require ownership so we can set
72:11 - require ownership equals phones and this
72:14 - way the server RPC no longer requires
72:16 - ownership in order to trigger the server
72:17 - RPC that means that the client that does
72:20 - not own this network object will be able
72:22 - to trigger This Server RPC so let's see
72:24 - this both appear on the incorrect recipe
72:26 - and down here on the correct one
72:27 - okay so just with this change Let's test
72:30 - so down here on the client let's try
72:32 - deliver a salad so let's pick up the
72:34 - tomato and just slice it then pick up
72:37 - some cabbage and slice it pick up some
72:40 - plates put both of them in there and
72:42 - let's go ahead and deliver and if there
72:43 - you go delivery success alright awesome
72:46 - now let's try delivering a final recipe
72:48 - and yep that one also works and up here
72:51 - on the host deliver a film recipe yep
72:53 - also works and now we success so let's
72:56 - cook a nice burger now let's go ahead
72:58 - and delivery correct and if there go
73:00 - delivery success alright awesome so we
73:02 - have everything everyone logic working
73:04 - now with this working let me just
73:06 - quickly talk about how you could make
73:08 - this system server off the answer is
73:10 - really just like I mentioned a while ago
73:11 - so over here instead of running the
73:14 - validation here and then telling the
73:15 - server whether correct or incorrect
73:17 - instead of doing that the client would
73:19 - simply tell the server I want to deliver
73:20 - this Plate Kitchen object then the
73:22 - server will check the contents of the
73:24 - plate and basically validate them as
73:26 - long as you make every step of the
73:27 - process for ADD adding ingredients onto
73:29 - the plate as long as you make all of
73:30 - that server off then the internal logic
73:32 - would be fully server off but again in
73:34 - our case for our simple game let's just
73:36 - stick with the simpler client off so
73:38 - here the client validates the plate and
73:40 - then just tells the server whether it
73:41 - was correct or incorrect then the server
73:43 - receives that RPC and simply broadcasts
73:45 - the message to every single one end okay
73:48 - great so over here we handle
73:50 - synchronizing our very first custom game
73:52 - logic to make our game fully multiplayer
73:54 - we really just need to apply the same
73:56 - process to every other part of our game
73:57 - but before we get to synchronizing some
74:00 - more things let's quickly fix just one
74:01 - minor thing when we first converted this
74:04 - game to multiplayer we had to get rid of
74:06 - the player Singleton which in turn broke
74:08 - the selected counter visual so let's fix
74:10 - that in the next lecture
74:12 - hello and welcome I'm your code monkey
74:14 - in this lecture we're going to fix the
74:16 - interact selected visual okay so here is
74:19 - the game so far I can move around as
74:21 - either the host or down here as the
74:23 - client but when I look at a counter nope
74:26 - there's no selected visual there's no
74:27 - select Vision down here nor over here on
74:30 - the host so let's fix that
74:32 - now this is actually super simple the
74:35 - issue was over here on the player script
74:37 - we had our instance but in multiplayer
74:39 - we don't have a single player instance
74:41 - and it's also not spawned automatically
74:44 - however we still have just a single
74:46 - local player and that is really all we
74:48 - want for the select visual
74:50 - so let's uncomment this code and instead
74:53 - of instance let's rename this to a local
74:54 - instance so this is going to be the
74:56 - local player and for assigning it
74:58 - usually we do it down here on awake
75:01 - however when dealing with multiplayer in
75:03 - netcode for game objects for networked
75:05 - objects you really don't want to usually
75:07 - use the awake or the start
75:09 - inside there is a similar function that
75:11 - is specific to netcode
75:13 - that one is called on network spawn so
75:15 - we're here public let's override
75:17 - override the void on network spawn so
75:20 - this one
75:21 - basically this function is called when
75:23 - this object is spawned on the network
75:25 - so over here we can just test if is
75:28 - owner
75:29 - so that will mean that this is the
75:30 - unlocking player so if so then just set
75:32 - local instance set to this
75:36 - so you do this and over here on awake we
75:38 - don't do anything
75:39 - okay so that should pretty much set the
75:41 - in local player over here on the local
75:43 - instance
75:44 - then let's go over here onto the
75:45 - selected counter visual script
75:48 - over here we were listening to the event
75:49 - and we just do the exact same thing
75:51 - except now it's called local instance
75:54 - then the rest of the code is exactly the
75:56 - same however if we do it like this we're
75:58 - actually going to have the same problem
76:00 - that we saw previously again that is
76:01 - because the player is not going to spawn
76:04 - by default it is only going to spawn
76:05 - when we press the host button so if we
76:08 - run this then this is still going to
76:10 - give a non-reference exception we don't
76:11 - want that
76:13 - so basically we need to know when the
76:14 - player spawns so let's go back into our
76:17 - supply script and up here and let's make
76:19 - a nice static event
76:21 - so a public static event event handler
76:24 - and let's call it on any player spawn
76:27 - we're making this static because we want
76:29 - this event to be long to the player
76:30 - class itself and not any specific player
76:33 - so we have this event and then down here
76:35 - when we have the onetwork spawn when
76:37 - this one happens let's just invoke this
76:39 - event as usual so this an event
76:40 - args.empty
76:43 - okay so now we have this nice event
76:46 - now we can go back into the selected
76:48 - counter Visual and over here first let's
76:49 - test if it already exists so if the
76:51 - local instance is not known if so then
76:54 - just assign it right away but if it is
76:56 - known if so then let's go into the
76:58 - player and the on any player spawned
77:00 - event and let's listen to this event and
77:03 - when this happens we're just going to
77:04 - run the exact same code so check if
77:06 - there's any local instance and if so
77:07 - listen to the event
77:09 - however yet another potential sneaky
77:11 - issue here this event won't fire
77:13 - multiple times for multiple players so
77:16 - if the first one were the in local
77:17 - instance then we could end up with
77:19 - multiple listeners which would cause a
77:21 - lot of duplicate logic
77:22 - so in order to make sure that doesn't
77:24 - happen let's just duplicate this and we
77:27 - do unsubscribe and then we subscribe
77:29 - this way we make sure that no matter how
77:31 - many times this event is fired that
77:33 - we're only going to have a single
77:35 - listener
77:36 - okay so that should fix it however
77:38 - unless you do one more thing like we saw
77:40 - at the end of the single player course
77:42 - for static events like the one that we
77:44 - just made those can cause problems when
77:47 - changing scenes
77:48 - that is why we made this class at the
77:50 - end of The Seven Player course
77:52 - so since we added a static event on the
77:54 - player let's also clear it
77:56 - so we can just copy the function from
77:58 - one of these so it's just a static
77:59 - function to do that so let's copy this
78:01 - let's go into the player and over here
78:03 - on let's paste our reset static data
78:05 - function and we just set the event to no
78:07 - then we just need to go into the reset
78:09 - static data manager go into the player
78:11 - and Trigger that function so this won't
78:13 - clear up and not cause any problems okay
78:16 - so with this let's test so up here let's
78:19 - make a host down here make the client
78:20 - and now on the host if I move and I
78:23 - approach that yep there you go that
78:24 - counter is now selected and down here on
78:26 - the client we can see that one does not
78:28 - show up as selected and now if down here
78:30 - I select a different counter yeah there
78:31 - you go now that one does show up and
78:33 - selected so the selection logic is fully
78:35 - working and it is local to the local
78:36 - player alright awesome
78:39 - let's just fix one more related thing
78:41 - over here on The Sound Manager down here
78:44 - we were also listening to the player
78:46 - event when the player picked up
78:47 - something so we could uncomment this and
78:49 - listen to the local instance however now
78:52 - we're going to have more than one player
78:53 - and we don't want to listen to this
78:55 - event only on this local player we won't
78:57 - listen it on any of them so if any
78:59 - player picks up something we want to
79:00 - play that sound
79:02 - so as usual let's make another static
79:03 - event so back here on the player class
79:05 - let's make another one public static
79:08 - event event handler and let's count on
79:10 - any picked something so just following
79:13 - the same pattern as usual and we're
79:15 - going to fire this on the exact same
79:16 - place where we fired the unpicked
79:18 - something so let's go down here where we
79:20 - set the kitchen object so it's on this
79:22 - one and let's just invoke the event
79:23 - passing this and even RX not empty so
79:27 - over here instead of listening just on
79:28 - your local instance let's listen to the
79:30 - on any picked something and that is
79:33 - going to run this function and again
79:34 - let's uncomment this code
79:36 - and over here we also don't want to play
79:39 - this on the local instance position we
79:41 - want to play it on the position of the
79:42 - player that actually picked something so
79:44 - we can just grab the player and grab the
79:47 - play reference from the sender as player
79:49 - so over here just use the player
79:51 - transform that position
79:53 - okay so that should do it let's test
79:55 - okay so up here is the host down here's
79:57 - the client and now if I go ahead and I
79:59 - pick up something and technically this
80:01 - did work so we don't have any errors
80:03 - anywhere but we can really test that
80:05 - this is working because we haven't yet
80:06 - handled syncing and picking up the
80:08 - objects so when the host appear picks up
80:10 - something the client down here doesn't
80:11 - know that actually happened but we don't
80:13 - have any error so the code is not
80:14 - working perfectly with that now let's
80:16 - hand on synchronizing the object pickup
80:18 - in the next lecture
80:20 - hello and welcome I'm your code monkey
80:22 - in this lecture we're going to
80:24 - synchronize picking up objects now this
80:26 - one and the next lecture are going to be
80:28 - some quite tricking lectures it requires
80:30 - us to learn various quirks with how
80:32 - netcode for game objects works so
80:33 - definitely do pay attention if you
80:35 - manage to understand everything in this
80:37 - lecture in the next one then you will
80:38 - understand pretty much most of what is
80:40 - required to build any multiplayer game
80:41 - okay so right now we can walk around as
80:44 - either the host or the client but if one
80:47 - of them picks up something like for
80:48 - example appear the host the host picks
80:49 - it up and nope the client down there
80:51 - does not see it so we need to
80:53 - synchronize this now this topic involves
80:55 - first of all spawning objects so when we
80:58 - pick up a kitchen object from a
80:59 - container we are going to spawn it and
81:01 - for spawning objects you always need to
81:02 - do it on the server
81:04 - so let's go over here onto the kitchen
81:06 - object script
81:07 - and like we already saw in order to make
81:09 - this script multiplayer inside amount of
81:11 - behavior let's implement the network
81:12 - behavior and this was in inside using
81:15 - unity.netcode okay
81:17 - so let's go ahead Swap this and save and
81:20 - back in the editor we need to attach a
81:21 - network object so let's select every
81:23 - single kitchen object over here and
81:25 - let's click on no just to be able to
81:27 - select all of them and now just add
81:29 - component and let's add a network object
81:32 - okay so like this all of them have a
81:34 - network object okay so far so good now
81:36 - we're going to spawn these objects
81:38 - dynamically and for any object that we
81:40 - want to spawn the server we need to add
81:42 - it to the network objects list so let's
81:44 - go into the network manager and over
81:45 - here we've got the natural prefabs every
81:48 - object we want to spawn needs to be here
81:49 - so let's go ahead and drag all of these
81:52 - so just add all the entries and drag
81:59 - alright so here are all the references
82:00 - make sure you add all of them so you
82:02 - don't get any strange errors so over
82:04 - here we got 3 6 9 10 11. and over here 3
82:09 - 6 9 10 11. okay great so now that this
82:13 - network match is set up let's see how
82:14 - we're going to spawn it
82:16 - let's go over here onto the container
82:18 - counter this is where we are spawning
82:19 - some kitchen objects so let's inspect
82:22 - this function so here it is the spawn
82:24 - kitchen object function and to do that
82:26 - we are just going to the script more
82:27 - object and in searching it in the prefab
82:29 - now like I said spawning objects needs
82:31 - to be done on the server and how we are
82:33 - going to enforce that is by using a
82:35 - server RPC so technically we could just
82:37 - mark this function as a server RPC
82:40 - however for this function we made it
82:42 - static and we cannot make a server RPC
82:44 - static it needs to be a non-static
82:45 - function so technically one alternative
82:48 - would be to remove static over here make
82:50 - this a non-static function but then we
82:52 - would need a reference to a kitchen
82:53 - object in order to spawn more kitchen
82:55 - objects so that's not very good
82:57 - instead let's make a general class to
82:59 - handle our specific multiplier logic so
83:02 - we can get return let's create a brand
83:03 - new c-sharp script
83:05 - this is going to be the kitchen game
83:07 - multiplayer
83:08 - let's make a game object with the same
83:10 - name
83:12 - let's reset the transform and attach the
83:14 - script and let's open it again just one
83:17 - there's this weird bug in the CMT
83:18 - version so just one let's open
83:20 - now over here first of all as usual
83:22 - instead of monobehavior let's make this
83:24 - a network Behavior
83:26 - so back in the editor let's just set the
83:28 - network object component okay great
83:30 - over here let's begin by making this a
83:33 - Singleton so the usual stuff so public
83:35 - static kitchen game multiplayer call it
83:37 - instance and we've got a public get and
83:40 - a private set and on private void awake
83:42 - on awake let's set the instance equals
83:44 - this
83:45 - okay we have the nice Singleton that we
83:47 - can use now let's just copy pretty much
83:50 - the code exactly so let's copy this
83:51 - let's go into the multiplier and over
83:53 - here let's paste it except this one is
83:55 - not going to be stunning so like this
83:57 - then back over here on the kitchen
83:59 - object is essentially just going to be a
84:01 - pass-through function so let's go into
84:02 - the kitchen game multiplayer access the
84:04 - incense and spawn this kitchen object so
84:06 - passing the kitchen object the so and
84:09 - the kitchen object parent
84:10 - so this just like this
84:13 - also the return type is going to cause
84:15 - some issues with the rpcs you cannot
84:17 - have a return other than void when
84:19 - you're working with an RPC now in the
84:21 - single player game we made this return a
84:22 - kitchen object just in case we needed it
84:24 - but we never actually end up using it
84:27 - so just swapping this out for a void
84:29 - shouldn't break anything and same thing
84:31 - on this other one so let's go in there
84:33 - and over here inside return kitchen
84:34 - object just return void
84:37 - okay so far so good so now we have this
84:40 - function where we want to spawn a
84:41 - kitchen object now again this one is
84:43 - still not a server RPC we're going to
84:45 - add that in a little bit
84:46 - here we are instantiating to spawn the
84:48 - object and then we get the kitchen
84:50 - object script and then we set the parent
84:53 - then here on the function for setting
84:54 - the kitchen object parent we do a bunch
84:56 - of logic and then importantly we modify
84:58 - this transform.parent now changing the
85:00 - transform parent is actually going to
85:02 - cause a lot of issues with netcode so
85:04 - for now let's just comment out this part
85:06 - so this doesn't run
85:08 - let's just do it like this first the
85:10 - test that spawning is working and then
85:11 - we'll worry about this
85:12 - so here we are spawning the object
85:14 - however just like this we are really
85:16 - just finding the object locally in
85:18 - multiplayer when spawning something we
85:20 - need to go into the network object and
85:21 - spawn it so it actually spawns on the
85:23 - network
85:24 - so let's grab this kitchen object
85:26 - transform and let's see we get component
85:28 - of type Network object
85:31 - so we get this network object so the
85:34 - kitchen object the network object
85:37 - we get this one and then we can call the
85:39 - function spawn and this is actually
85:40 - going to spawn non-nentor then takes the
85:43 - parameter for destroyed scene so let's
85:45 - make this work just like any other game
85:47 - object so by default game object gets
85:49 - destroyed when you change scenes over
85:50 - here let's do the same behavior
85:53 - okay so let's test and see if the object
85:55 - is being spawned on the network
85:57 - okay so here we have a host and a client
86:00 - and on the host I approach this and I
86:01 - pick it up and if there go it did work
86:03 - the object will spawn over there on the
86:05 - host and also over there on the client
86:07 - okay so so far so good but now if I go
86:10 - down here on the client and let's try to
86:12 - pick up something so let's go in there
86:14 - and pick it up and nope there you go
86:15 - we've got an error as it says only the
86:18 - server can spawn Network objects so this
86:20 - is the error that I mentioned we need to
86:22 - use a server RPC to make sure the spawn
86:24 - code only runs on the server
86:27 - so we're here on the kitchen game
86:28 - multiplier script
86:30 - let's make a server PC that will
86:31 - actually run this code
86:34 - so let's do a private void spawn kitchen
86:37 - object
86:38 - server RPC
86:41 - and let's mark this as a server RPC and
86:44 - we're going to want the client to be
86:46 - able to call this so as usual let's make
86:48 - sure the set require ownership equals
86:50 - false so that the client can call this
86:53 - and over here we are just going to run
86:55 - this code
86:56 - just like this so now we need to pass in
86:58 - the kitchen object that so as well as
87:00 - the parent so let's put these as
87:02 - parameters so just like this
87:04 - and okay we see no errors here and up
87:06 - here we are really just going to call
87:07 - this so kitchen object this so and then
87:10 - the kitchen object parent
87:11 - okay it looks good but if we go in the
87:14 - editor and I hope we see a bunch of
87:16 - Errors so this code is not valid it's
87:18 - pretty much the same problem that we saw
87:20 - previously we cannot pass in a script
87:22 - object because it does not know how to
87:24 - serialize it
87:25 - so over here let's use really the same
87:26 - solution
87:28 - let's just convert this crypto object
87:29 - onto an index so for that we need to
87:32 - define a list of kitchen objects so now
87:34 - we could go up here and just find a
87:36 - serialized film for a list that would
87:38 - work or let's do it just like we did
87:40 - with the recipe and make a proper
87:41 - kitchen object list
87:43 - so if you remember in the single player
87:45 - course we made the recipient list this
87:48 - is a scribble object that holds only
87:49 - several of our recipes so let's do the
87:51 - exact same thing to home a list of all
87:53 - of our kitchen object SOS
87:54 - so let's go ahead and make a new script
87:56 - in you on these script mode objects
87:58 - let's create a brand new sharp script
88:00 - call this the kitchen object list so
88:04 - and over here on let's make this a
88:06 - scriptable object
88:08 - and inside we just have a public it is
88:11 - going to be a list and it's going to be
88:13 - a list of kitchen object SL
88:16 - and just call it kitchen object that's
88:18 - selling list
88:19 - okay now in order to construct it let's
88:21 - add the create asset menu
88:23 - and now in order to be able to construct
88:25 - an object we need to be able to compound
88:26 - the code so let's go back into the
88:28 - multiplayer and over here let's just
88:29 - come without the RPC just so our code
88:31 - compiles so just comment on this okay
88:35 - so now making the editor the code
88:37 - compiles so let's go inside the kitchen
88:38 - object so folder and create the new a
88:40 - new kitchen object list of so
88:43 - and let's give the name and start with
88:44 - underscore just so it shows up on the
88:46 - top of the list
88:47 - and okay now here we have the list so
88:49 - let's just populated so let's use the
88:51 - nice inspector unlock button or unlock
88:52 - it and just select all of them and just
88:55 - drag all of them onto the list
88:57 - okay great so now we have this group
88:59 - magic that holds a list for all of the
89:01 - kitchen objects it shows and just make
89:03 - sure we don't accidentally create more
89:04 - of them which is coming out the create
89:06 - SM menu so we cannot create any more and
89:08 - if we go over here on the kitchen game
89:10 - multiplayer we can add a serialized film
89:13 - and we can make it a type kitchen object
89:15 - list so
89:18 - so we have now this field and back in
89:21 - the editor let's just select it and just
89:23 - write down list okay great so with that
89:25 - we can now access the list and pass it
89:27 - in as an index instead so let's
89:28 - uncomment this code and then for the
89:31 - parameter instead of receiving kitchen
89:32 - object so let's receive an end for the
89:34 - kitchen object as so index and then here
89:37 - we convert it back so kitchen object as
89:39 - so we grow into the kitchen object
89:42 - Melissa cell then access the list inside
89:44 - of it
89:46 - and then we'll text us on the kitchen
89:48 - object so index
89:51 - so now here we can pass in the index and
89:53 - let's actually make some nice helper
89:54 - functions so we don't have to write all
89:56 - this code over and over again
89:57 - so a private return end get kitchen
90:00 - object so index
90:03 - and this one receives a kitchen object a
90:05 - cell
90:07 - and very simply just returns just goes
90:09 - inside the kitchen object Melissa so we
90:12 - grab the English inside of it and we do
90:14 - index of this kitchen object
90:16 - okay so that one converts into an index
90:18 - number to the opposite
90:20 - so return a kitchen object to sell get
90:23 - kitchen object so from index
90:26 - and receive an end for the kitchen
90:28 - object so index
90:30 - and over here we do the code that we're
90:32 - doing up here
90:33 - so just going to list and access on this
90:36 - and just return it
90:38 - okay so we have these two nice sample
90:40 - functions so over here let's just grab
90:42 - the index and pass it in and then on
90:45 - this one for the kitchen object itself
90:47 - let's use the function and grab it from
90:49 - this index
90:51 - okay so that solves that problem now we
90:53 - are only synchronizing the server RPC
90:55 - with a nice int index however here in
90:57 - the editor we saw as the same error this
90:59 - one is related to the kitchen object
91:01 - parent again does not know how to
91:02 - serialize it
91:03 - and to solve this one we are going to
91:05 - use a really useful netcode type which
91:07 - is a network object reference
91:10 - so over here instead of receiving that
91:11 - one let's receive a network object
91:13 - reference and let's name this kitchen
91:15 - object parent Network object reference
91:19 - this is how you can pass in an object
91:20 - reference through an RPC and then on the
91:22 - other side convert the reference back
91:24 - into the actual object if we just
91:26 - comment out this function call and look
91:27 - in the code as well as this one down
91:29 - here
91:30 - and if we have no more errors so this is
91:32 - now if only the RPC
91:34 - so we can now call this function and
91:36 - everything should work but of course now
91:38 - the question is how do we get the
91:39 - network object reference from this
91:41 - interface in order to get a network
91:42 - object reference really all we need is
91:44 - to pass in a network object then in the
91:46 - background to automatically convert into
91:48 - a reference
91:49 - so we need a network object from the
91:51 - kitchen object parent
91:52 - and how we do that is super simple this
91:55 - one is an interface so really let's just
91:56 - make another function this one is going
91:58 - to return a network object just get
92:01 - network object
92:03 - okay so that's it super simple now we
92:04 - just need to implement this function on
92:06 - all of our interfaces so for example
92:08 - over here on the player the player has
92:09 - an eye kitchen object parent so let's go
92:11 - down to the bottom and let's Implement
92:13 - our function
92:15 - and the player is already Network
92:16 - behavior and from Network Behavior we
92:19 - can access the network object that is
92:21 - attached to this network Behavior so
92:22 - just like this then the other place we
92:24 - need to implement is on the base counter
92:26 - so here we are on the base counter and
92:28 - let's implement the same function
92:31 - and now for this one we still haven't
92:32 - yet made the base counter into a network
92:34 - Behavior
92:36 - we're going to do that in a little bit
92:38 - but for now we don't want to worry about
92:39 - it so just make sure the code compounds
92:41 - over here and let's just return no right
92:43 - now we really just want to handle the
92:45 - player picking up objects then
92:46 - afterwards we'll handle the counters
92:48 - okay so back here on the multiplayer
92:50 - class now we can just access the
92:51 - interface and through the interface we
92:53 - can just get the function get the
92:55 - network object and yep there you go the
92:57 - type Network object gets automatically
92:59 - converted into a network object
93:00 - reference so that's right so this one is
93:03 - now valid now of course we need to get
93:05 - the kitchen object parent back from this
93:06 - reference
93:07 - and how we do that is super simple so we
93:09 - can access the network object reference
93:12 - and in there we have a function try get
93:14 - this one basically lets you get the
93:16 - network object that was originally sent
93:18 - so let's get out of type Network object
93:21 - for the kitchen object parent Network
93:24 - object
93:26 - so we get that and then from this one we
93:28 - can just do a get component of type I
93:30 - kitchen object parent
93:32 - and with that we have the kitchen object
93:34 - parents so then we can just run the
93:36 - original code just like this now here
93:38 - let me point out one thing perhaps you
93:40 - might be thinking that these variable
93:42 - names are way too long and again it goes
93:44 - back to what I mentioned in the naming
93:46 - rules on the single player course naming
93:48 - rules can really be whatever you want
93:50 - them to be in my case personally I
93:52 - prefer to have extremely descriptive
93:53 - variable names even if they become a bit
93:55 - too long
93:56 - I prefer that over having compact names
93:58 - which then might cause confusion because
94:00 - I don't know what variable actually
94:01 - contains but again this is personal
94:03 - preference so if you don't like the
94:06 - super long variable names then by all
94:07 - means go ahead and follow your own rules
94:10 - okay so over here we wrote quite a bit
94:12 - of code but everything should now be
94:13 - working we have no errors some of the
94:15 - parameters for the server RPC of these
94:17 - are valid
94:19 - so we pass in the so as an index and we
94:21 - pass in the parent as a network object
94:23 - then on the server side we just get the
94:25 - other references and we use them okay so
94:28 - we definitely test so here we are and up
94:30 - on the client let's try to pick up some
94:32 - cheese and you better go with that work
94:34 - again don't worry about the fact that
94:35 - it's on the floor that is because we
94:37 - disabled the parenting we're going to
94:38 - handle that later right now we just want
94:40 - the spawning and that did work and then
94:42 - if we go down here onto the client let's
94:43 - try to pick up some meat and if they go
94:45 - with that work nowhere is nothing
94:47 - everything worked perfectly all right
94:49 - awesome so here we learned how to spawn
94:51 - an object and synchronize it across a
94:53 - network however like you can see that
94:55 - object is still being spawned just in
94:56 - metal on the ground instead it should
94:58 - really be being held by the player so
95:01 - let's handle that tricky part in the
95:02 - next lecture
95:04 - hello and welcome I'm your code monkey
95:06 - in this lecture we're going to
95:07 - synchronize the kitchen object parents
95:09 - so that the objects are actually being
95:10 - held by who owns them okay so here's
95:13 - what we have so far I have both a host
95:15 - as well as a client and I can interact
95:18 - with the container counter any update
95:19 - does spawn the object correctly but as
95:21 - you can see the object is spawned on
95:22 - four it is not being held by the player
95:25 - so let's handle that and this is
95:26 - actually going to be the really tricky
95:28 - part which is parenting the object let's
95:30 - go over here onto the kitchen object
95:32 - script and down here we have the lines
95:34 - that we come to the one here modifying
95:36 - the parents so let's uncomment these
95:37 - let's save and let's test again
95:40 - so here we are and now if I try to pick
95:42 - up something from the container counter
95:43 - and if there you go got an error right
95:45 - away right away the message says in
95:47 - valid parenting the network object is
95:49 - moved onto a non-network object parent
95:51 - and that is something you cannot do so
95:53 - the issue here is because when we made
95:55 - the game we made it so that the spawn
95:57 - kitchen object becomes a child of some
95:59 - transform in order to automatically
96:00 - follow it around so over here the player
96:03 - has in front of it an empty point so
96:04 - that is where the kitchen object would
96:06 - be placed this is an excellent approach
96:08 - to do in single player but in
96:10 - multiplayer handling object parenting
96:12 - becomes a lot more complex the specific
96:14 - issue that we can see down here is that
96:16 - the player itself so the player the main
96:18 - game object this one is indeed a network
96:19 - object but the empty container over here
96:22 - this game object this one does not have
96:24 - a network object so we cannot make it a
96:27 - direct channel of this object and beyond
96:29 - that netcode for game objects actually
96:31 - has one more limitation which is you
96:34 - cannot set a network object as a child
96:36 - of another Network object that will
96:37 - spawn dynamically if you have objects
96:40 - that are already placed in the scene
96:41 - like for example our counters here if
96:43 - you have that you can make a network
96:44 - object like for example a spawn cheese
96:46 - you can make it a Channel of one of
96:48 - these counters but the players they are
96:50 - spawned dynamically so you cannot make
96:52 - one of these a child of the player so
96:55 - basically everything that has to do with
96:56 - parents becomes really tricky in
96:57 - multiplayer the best option is really to
96:59 - avoid doing that altogether and really
97:01 - just come up with a different solution
97:02 - the only reason why we made it using
97:05 - this pattern of changing the appearance
97:06 - was just to make the movement simpler by
97:08 - making an object the Channel with
97:09 - another one it means it automatically
97:11 - moves along with the parent but if we
97:13 - can change the parent we can still make
97:15 - it just follow some object without
97:16 - having to modify the parent the end
97:18 - result won't visually be exactly the
97:20 - same so let's do exactly that let's make
97:22 - a script to phone object so let's create
97:24 - a brand new c-sharp script call this the
97:26 - follow transform
97:28 - and let's go ahead and attach the script
97:30 - to every single kitchen object so let's
97:32 - go inside the prefabs the kitchen object
97:34 - select all of them and let's attach this
97:36 - script so the phone will transform let's
97:39 - add this okay now let's open so over
97:41 - here we really just want to store the
97:43 - target transform that we want to follow
97:45 - so let's define a private for our
97:48 - transform for the Target transform
97:50 - then let's just make a function we can
97:52 - expose in order to set it so set Target
97:55 - transform and receive a transform for
97:58 - the Target transform
98:00 - and we just do this not Target transform
98:02 - equals this target transform
98:05 - okay so this way we can set it and then
98:07 - for actually moving the object for that
98:09 - let's go with a private void late update
98:12 - let's go with the late so it happens
98:13 - after all the updates
98:15 - and first of all let's do just a quick
98:17 - safety check
98:18 - so if the target transform if it is null
98:20 - that means we have nothing to follow so
98:22 - let's just return let's stop but if it
98:24 - isn't known let's just set this
98:25 - transform.position equals the target
98:27 - transform dot position and same thing
98:30 - for the rotation so rotation and
98:32 - rotation
98:34 - okay so we have a very basic script that
98:36 - only does it receives a Target transform
98:37 - and just follows it and rotates
98:39 - alongside it
98:40 - now let's go over here onto the kitchen
98:42 - object and first of all we need to get
98:44 - that component so let's define up here a
98:46 - field for the follow transform the phone
98:49 - will transform and we're going to get
98:51 - this let's make a product wide awake so
98:53 - let's see we get component of time
98:54 - follow transform and set this on the
98:57 - phone load transform okay we have our
98:59 - script reference
99:00 - and then down here instead of modifying
99:03 - the pairing instead of that let's go
99:04 - into that one and set the target
99:06 - transform and pass in the exact same one
99:08 - so this target transform okay so let's
99:10 - do this instead of modifying the parent
99:12 - all right with this let's test okay so
99:14 - up here on the host let's pick up
99:16 - something and if there go it does work
99:18 - so as you can see the object is indeed
99:19 - perfectly following it as if it were
99:21 - with a change parent but without
99:22 - actually changing the parent so that's
99:24 - right that works but down here the
99:26 - client has no idea that the host is
99:28 - holding something and now if I try to
99:30 - pick up something on the client so let's
99:31 - pick up a tomato down here and look at
99:33 - that very strange Behavior
99:35 - so if you see the object was indeed
99:37 - spawned over here on the client and on
99:39 - the host the client did indeed pick up
99:41 - that object
99:42 - so everything is working perfectly over
99:44 - here on the host but as you can see
99:45 - everything is on the floor right down
99:47 - there on the client
99:48 - honestly this one part confused me for
99:50 - quite a bit as I was making the
99:51 - Prototype the issue is actually over
99:53 - here on the function to spawn a kitchen
99:55 - object
99:56 - if you want pause the video and look at
99:58 - this code and try to figure out what
99:59 - might be the issue it's actually very
100:01 - obvious once you remember how
100:03 - multiplayer actually works always
100:05 - remember the big difference between
100:06 - server host and client and you also have
100:09 - to remember how the various things you
100:11 - do in netcode are synced here we are
100:13 - instantiating and then spawning a
100:15 - network object
100:16 - when you do that it gets actually
100:17 - spawned in the network so that gets
100:19 - synchronized automatically all declines
100:21 - will receive this brand new spawn object
100:23 - however down here the code for setting
100:26 - the parent for this one the clients will
100:28 - not receive this automatically so this
100:30 - code is only running on the server that
100:32 - is why the client was holding the object
100:34 - on the host but not on the actual client
100:36 - build that is because only the host
100:37 - actually ran this code so that means
100:39 - that we need to synchronize this parent
100:41 - data somehow for that let's go ahead and
100:43 - do it with a nice RPC
100:45 - let's go over here onto the kitchen
100:46 - object script and when setting the
100:49 - parent
100:50 - first we need to tell the server that
100:52 - this object should change parent
100:54 - so let's begin by making a server RPC
100:57 - so a private void set kitchen object
101:00 - parent server RPC
101:03 - this one is going to be marked as a
101:05 - server PC and again we want the client
101:07 - to be able to do this so as usual let's
101:09 - set require ownership equals false
101:11 - okay we have this parent RPC and now we
101:14 - want to pass in the kitchen object
101:16 - parent except of course again if you
101:18 - remember we cannot pass in a kitchen
101:20 - object parent directly this is not yet
101:22 - serialized so we cannot use this
101:24 - so let's pass it in as a reference exam
101:27 - like we did on the multiplayer class
101:29 - so we're here on the multiplier class we
101:31 - had this reference and then we did a try
101:33 - get to get it so let's see exactly this
101:35 - code so first let's copy the parameter
101:38 - and then let's paste the code to
101:40 - actually get the kitchen object parent
101:42 - okay so now we have the kitchen object
101:44 - parent but again this is just a server
101:46 - RPC meaning this is only going to run
101:48 - the server that is not what we want
101:50 - if we want all of the clients to update
101:52 - the parent then this code this code to
101:54 - actually set the pairing this one needs
101:56 - to run on all the clients
101:58 - so basically the client won't have the
101:59 - server and then the server tells every
102:01 - single client what the new parent is so
102:03 - let's make another one let's make a
102:04 - private void and for this one set
102:06 - kitchen object
102:08 - parent client RPC
102:11 - let's make this a client RPC and let's
102:14 - pass in the exact same parameters
102:16 - so let's pass in this and it's over here
102:19 - on this one that we actually run this
102:20 - code
102:21 - and then for the rest of the RPC we're
102:23 - actually going to run the regular set
102:25 - parent code so let's copy this and paste
102:27 - it over here okay so we've got the nice
102:29 - line RPC and then of course when we call
102:31 - the logo function we're going to call
102:33 - the server RPC in order to tell the
102:35 - server that this object should have this
102:37 - new parent
102:38 - and for this one lets you get network
102:40 - object okay so we have that then the
102:43 - server receives the server RPC and
102:44 - recently just broadcast it to all the
102:46 - client rpcs and tells every single
102:48 - client that this object now has a brand
102:50 - new parent okay so with this all the
102:52 - client should receive the message that
102:54 - the parent has changed now it says to
102:56 - see if the client can pick up a new
102:58 - object so here we are and up here on the
103:00 - host let's pick up some cheese and if
103:01 - there you go it does get synchronized
103:03 - okay great and then down here on the
103:05 - client let's try to pick up something
103:06 - else pick it up and if there go it does
103:09 - get synchronized so both of them have
103:10 - the exact same state all right awesome
103:13 - so this part is working perfectly now if
103:16 - I go over here on the host and I try
103:17 - placing this object somewhere and there
103:20 - you go we've got an error there is that
103:22 - the argument is returning null and this
103:24 - is actually if we follow it we can
103:25 - actually find where we're finding this
103:27 - here it is it's on this line on the
103:29 - kitchen object so this one goes into the
103:31 - parent gets the network object and
103:33 - apparently this one is returning null
103:34 - and again this is the issue that we saw
103:36 - a while ago so if we go on the base
103:38 - counter a while ago down here we had to
103:40 - implement this for the interface but we
103:42 - just made return known so this is the
103:44 - issue the solution is very simple let's
103:46 - just go ahead and make the base counter
103:47 - instead of moderate behavior let's make
103:49 - this a network behavior and then down
103:51 - here inside return no let's return the
103:53 - proper Network object okay so that's
103:55 - good now all we need to do is make sure
103:57 - to attach a network object to every
103:58 - single base counter
104:00 - so back in the editor here let's go into
104:02 - our prefabs onto our counters and here
104:04 - we have on counters and the way we made
104:06 - them is they are all variants of this
104:07 - base counter so we can just select this
104:09 - one and just add the network object
104:12 - so there you go just have this one onto
104:14 - the base and now all the others yep all
104:16 - the others now have the network object
104:18 - okay great so if we test like this so
104:21 - here we have the host and let's pick up
104:23 - something yep that is synchronized just
104:24 - as previously and now if I go and I drop
104:26 - it there and if there go that one also
104:28 - does work same thing on the client down
104:30 - here let's pick up some bread yep picks
104:32 - it up everything works perfectly now
104:33 - drop it and you'll ever go everything is
104:35 - synchronized perfectly alright great
104:37 - again here we have yet another excellent
104:39 - example of the power of writing good
104:41 - clean code because we center part game
104:43 - with some very good code by using our
104:45 - interface and the base counter class
104:47 - because of that just by making a few
104:49 - changes we already have a ton of the
104:51 - game working in multiplayer so that's
104:53 - great however we also actually have one
104:55 - slight issue here so if I try to pick up
104:58 - something from a container counter yep
105:00 - it does work all of them work however if
105:02 - now I go over here onto the plates
105:03 - counter and I try to pick it up and nope
105:05 - there's our error let's see where this
105:07 - error is actually coming from so over
105:09 - here kitchen object 50.
105:11 - and this is actually a pretty sneaky
105:13 - error so something in here is set as no
105:15 - now we already know that we added the
105:18 - kitchen object parent correctly so this
105:20 - one cannot be null so the only thing
105:21 - that I can possibly know is over here
105:23 - the final transform
105:24 - and the final transform is actually set
105:26 - up here on the awake so it seems like
105:28 - that should always work however the
105:30 - reason why this error only happens on
105:32 - the plate that's actually a nice clue
105:34 - if we go over here on the Plate Kitchen
105:36 - object script over here we already
105:37 - defined an awake in order to initialize
105:39 - our list
105:40 - so the plate has this awake and then the
105:42 - kitchen object also has an awake so like
105:45 - this we are defining two commonly
105:46 - separate functions so the plate is
105:48 - actually hiding the other awake that is
105:50 - why over here for the plate when
105:52 - interacting with the plate the plate is
105:53 - not going to run this so the final
105:54 - transform will always be known this is
105:56 - something that actually took me quite a
105:58 - bit of time as I was building the
105:59 - Prototype that's because Unity for some
106:01 - reason doesn't show you a warning for
106:03 - hiding functions if they are mono
106:04 - Behavior functions if this was a regular
106:07 - function it would show that warning but
106:09 - for some reason on the Model Behavior
106:10 - functions this one does not show
106:12 - anyway thankfully the solution is
106:14 - actually pretty simple let's just go
106:16 - over here on the kitchen object and for
106:18 - this way instead of private let's make
106:19 - it protected and let's make it virtual
106:22 - okay so this is your rank
106:24 - and over here on the Plate Kitchen
106:26 - object we can make this protected and
106:28 - then make an override
106:30 - now this one will override the other one
106:32 - but we still want to run that one so up
106:33 - here we can just do base dot awaken or
106:36 - to run that code
106:38 - okay so now it should work
106:41 - so over here I can drag you into the
106:42 - plate and pick it up and if there you go
106:44 - now it does work okay great now by the
106:47 - way we still have one issue where we
106:49 - cannot pick up an object onto the plate
106:51 - so if I try to grab some bread over
106:53 - there and try to drop it
106:54 - like this the plate contents are not yet
106:56 - being synchronized that's normal we're
106:58 - going to handle that later on the course
106:59 - for now we just care about changing the
107:01 - kitchen object parent and that part is
107:03 - indeed working perfectly so on either
107:06 - build I can pick up interact with the
107:07 - container counter to pick up something
107:09 - oh if it works so now this one is now
107:11 - picking up something so that's great
107:12 - however the counter interaction itself
107:15 - is actually not being synchronized so
107:17 - for example if I'm controlling the hose
107:18 - up here and if I go and I pick up
107:20 - something look what happens down there
107:21 - on the client I pick it up and if there
107:23 - you go it does spawn the object but
107:24 - there no animation played the animation
107:27 - only played locally on the actual object
107:29 - that was interacting with the counter
107:31 - again that's because the interact
107:33 - function this one is only local so far
107:35 - so let's synchronize this as well let's
107:37 - go over here onto the container counter
107:39 - and over here we're basically spawning a
107:41 - kitchen object and firing off an event
107:43 - this is what actually plays the
107:44 - animation now for spawning the event
107:46 - this one is already being synchronized
107:48 - so that's great all we need is really
107:49 - just to synchronize this part
107:51 - so let's basically make a function to
107:53 - synchronize the interact logic so let's
107:55 - make a private Point call it interact
107:58 - logic server RPC because we're going to
108:01 - first on the server so this one is a
108:03 - server PC and as usual let's make
108:05 - require ownership as false so that all
108:07 - the clients can call this so we do this
108:10 - so we can tell the server that this
108:11 - counter was interacted with and then the
108:14 - server needs to broadcast that message
108:15 - to every single client so over here
108:17 - let's make a private void for the
108:19 - interact logic client RPC
108:23 - and this one at the client RPC
108:26 - announced on this one that we do the
108:27 - actual local logic so we run this logic
108:29 - there we call the client RPC from the
108:32 - server and we trigger the server RPC
108:35 - logo
108:36 - okay so that's it pretty simple
108:38 - Let's test
108:40 - so he ran up on the host I'm going to
108:42 - pick it up and see if it's synchronized
108:43 - any of there go the animation does
108:45 - synchronize so that's great and if I go
108:46 - down here on the client and I try to
108:49 - interact and see if that one
108:50 - synchronizes and if there you go
108:51 - everything worked perfectly alright
108:53 - awesome so with that the container
108:55 - counter is now fully synchronized and
108:57 - with that we have quite a lot of stuff
108:59 - already working perfectly now these past
109:01 - even lectures are some of the more
109:03 - complex ones so if you didn't fully
109:05 - understand something maybe go back and
109:06 - re-watch it also remember to read the
109:08 - course page FAQ I'll keep that updated
109:11 - as more people ask questions
109:12 - and of course I'm always available
109:14 - answering any specific questions you
109:16 - have basically if you do manage to fully
109:18 - understand everything in these passing
109:19 - lectures then you already have most
109:21 - knowledge required to make any
109:22 - multiplayer game okay so with this with
109:25 - the container counter working everything
109:27 - is looking great so far next let's work
109:29 - on a bit of a simpler one let's
109:31 - synchronize the plates counter so let's
109:32 - do that in the next lecture
109:36 - hey again here's another quick
109:37 - intermission I hope you've already
109:39 - learned a ton in this course how are you
109:41 - handling the multiplayer is it being
109:43 - difficult or relatively easy do you
109:46 - understand how the rpcs work the
109:48 - difference between server and client RPC
109:51 - remember to follow the course page
109:52 - website as you follow along I'm
109:54 - constantly adding frequently asked
109:56 - questions to every lecture if you ever
109:58 - get stuck you can just download the
109:59 - project files for each lecture and
110:01 - compare with your own and by the way if
110:03 - you're listening to this let's say this
110:04 - is the secret come out so go ahead post
110:06 - a timestamp with the monkey emoji in the
110:08 - comments I want to see how many people
110:10 - get this far and if you are finding it
110:12 - helpful and if you can afford it then
110:14 - check out the optional pick course or
110:16 - post a super thanks okay that's it for
110:18 - now let's go to the next lecture
110:22 - hello and welcome I'm your code monkey
110:24 - in this lecture we're going to
110:25 - synchronize the plates counter we want
110:27 - to make sure that all of the clients
110:29 - have the same number of plates this is a
110:31 - pretty simple encounter so this one is
110:32 - going to be a quick lecture okay so
110:34 - let's synchronize the plate counter so
110:36 - it's this one right here which spawns a
110:38 - plate and then the player can pick up a
110:39 - plate right now this logic is only
110:41 - working in single player all of the
110:43 - clients are spawning their own plates so
110:45 - if I pick one up over here on the host
110:46 - it does not synchronize down there this
110:48 - is not correct only the server should be
110:50 - spawning them and everything should be
110:51 - synchronized so let's do that first
110:53 - let's go over here onto the plates
110:55 - counter script and then down here we've
110:57 - got the update where we count on the
110:58 - timer and spawn the plates now first of
111:00 - all we're only going to run this Logic
111:02 - on the server
111:03 - so as usual let's see where it is server
111:06 - so if we are not the server then return
111:09 - and don't run this logic so like this
111:11 - only the server is going to spawn some
111:12 - planes now we need to do is tell the
111:14 - clients that the server has spawned
111:16 - something so as usual let's use some
111:17 - rpcs so let's go over here make a
111:20 - product void first of all let's make a
111:21 - spawn plate server or PC
111:25 - and then a spawn plate client RPC let's
111:29 - add the attributes on both them in this
111:32 - case this one was only going to run the
111:33 - server so we don't need to add the
111:35 - required ownership so we do this from
111:37 - the server RPC we call the client RPC
111:40 - and on the client RPC we're basically
111:41 - going to run our local code so just like
111:44 - this
111:45 - also by the way technically since the
111:46 - code up here is always only going to run
111:48 - the server typically we could avoid
111:50 - using a server RPC here but just to keep
111:52 - the same logic the same pattern that
111:54 - we've been using let's do it like this
111:55 - so in the regular logic we trigger a
111:57 - server RPC which then broadcasts a
111:59 - message to all the clients okay so
112:01 - that's it super simple this will handle
112:03 - synchronizing the spawning then for
112:05 - picking up let's do the same thing that
112:07 - we did on the container counter so we're
112:09 - here on the container counter we've got
112:11 - the interact and then we use a server
112:13 - and client RPC parent or to synchronize
112:15 - antenna so let's do the exact same thing
112:16 - let's use the exact same name so let's
112:18 - actually copy all this and over here on
112:20 - the plates let's just paste them and
112:22 - then we're going to fire off the event
112:24 - so over here
112:25 - and also count down the number of plates
112:28 - for the spawning the kitchen object that
112:30 - one is already synchronized so that's
112:31 - already great
112:32 - so just like this and Trigger the server
112:34 - FPC up here alright so that's it as you
112:37 - can see it's also pretty simple logic
112:38 - now that you understand how server PCS
112:40 - and coin Services work that is why I
112:43 - said those previous home lectures were
112:44 - extremely important since we already
112:46 - learned how to do all those things all
112:47 - of this suddenly becomes extremely easy
112:49 - okay so let's test
112:51 - so here are both builds and let's see if
112:53 - they synchronize both have one plate and
112:55 - a little bit you both got two plates and
112:57 - so on okay so the spawning of the plates
112:59 - that timer is indeed working so let's
113:01 - wait for it to reach the maximum so yeah
113:03 - it goes up to four plates now if I pick
113:05 - one up let's see if both of them count
113:06 - down and if they go both them did count
113:08 - down so just like this yep we do have
113:11 - all of our plates the play counter
113:13 - everything perfectly synchronized all
113:15 - right great so once again because of
113:17 - writing some good clean code this was
113:19 - super easy to implement also because we
113:21 - already took the time to really
113:22 - understand how multiple your code works
113:24 - and how to use rpcs because of that this
113:26 - is really one of the shortest lectures
113:28 - as you can see once you understand how
113:29 - the tool set Works making multiplayer
113:31 - games is actually super simple now we
113:33 - want to handle a bit of a more complex
113:35 - counter the trash counter so let's do
113:37 - that in the next lecture
113:39 - hello and welcome I'm your code monkey
113:41 - in this lecture we're going to
113:43 - synchronize the trash counter this one
113:45 - is very important because we're going to
113:47 - learn how to destroy a network object
113:48 - okay so here on let's handle the trash
113:50 - counter right here this one just
113:52 - destroys whatever you place on it so I
113:55 - want to be able to pick up something
113:56 - like a tomato approach it interact with
113:58 - it and destroy the object now remember
114:00 - how all of the spawn objects the kitchen
114:02 - objects those are all Network objects so
114:05 - this is excellent to learn how to
114:06 - properly destroy if Network objects so
114:08 - first of all let's go over here onto the
114:10 - trash counter script and let's make the
114:12 - usual server and client RPC pair in
114:14 - order to run this Logic on the client
114:17 - so a private void interact logic let's
114:20 - start with a server RPC
114:22 - and then we're going to have another one
114:24 - for the client RPC okay we have both
114:26 - knees let's add the usual things so the
114:29 - server RPC and for this one let's add
114:31 - require ownership as false
114:34 - okay we have our usual pair from the
114:36 - server IPC we call on the client RPC and
114:39 - from up here we trigger the server PC
114:42 - and down here let's just fire off the
114:44 - event okay so just like this let's leave
114:46 - the destroy itself up here to see what
114:47 - that happens so it says this so here all
114:50 - it says and there's the host let's pick
114:52 - up an object go into the trash counter
114:54 - and trash it and if there you go it did
114:56 - work it disappeared over there on the
114:57 - client and we have no errors okay so
114:59 - that seems like it's working but now
115:01 - down here on the client let's try doing
115:03 - the same thing pick up something go into
115:04 - the trash counter and interact and nope
115:06 - we've got an error the area is exactly
115:09 - what it says which is destroying a spawn
115:11 - object on a non-host client is not valid
115:13 - so only the server can destroy objects
115:16 - if you want to look over here on the
115:17 - kitchen object the story sound function
115:19 - over here yep we are indeed calling
115:21 - destroy on this game object to actually
115:22 - destroy it and again the issue is that
115:24 - only the server can do this so basically
115:26 - we need to make sure that only the
115:27 - server runs this code and for that let's
115:29 - do the same thing that we did down here
115:30 - with the spawning let's make a function
115:33 - to destroy it so let's let's make a
115:34 - public static void destroy kitchen
115:36 - object and let's receive a kitchen
115:39 - object
115:40 - so we're going to destroy this one by
115:42 - the way here let me point out that
115:44 - obviously you wouldn't need to make this
115:45 - a static function itself for the spawn
115:47 - we made it static because we didn't want
115:49 - to require a kitchen object reference in
115:51 - order to spawn another kitchen object
115:53 - but over here we already have one so we
115:54 - could make this non-satic to destroy it
115:56 - I'm doing it just like this just to
115:58 - match the same pattern that we defined
115:59 - up here so let's do this and then let's
116:01 - make a function on the kitchen game
116:02 - multiplayer to actually destroy that
116:03 - object so over here on the kitchen game
116:05 - multiplayer and let's go down and make a
116:07 - function to do exactly that so a public
116:09 - void call it destroy kitchen object and
116:12 - this one receives a kitchen object this
116:15 - is the one that we're going to destroy
116:16 - then in order to make sure that destroy
116:18 - code only runs on the server let's make
116:20 - a server RPC
116:23 - destroy kitchen object server RPC
116:27 - and this one as usual is going to be
116:28 - marked as server IPC and we want the
116:30 - clients to be able to destroy objects so
116:32 - let's require ownership equals false
116:34 - okay we have our function and for this
116:37 - first of all we're going to need a
116:38 - reference to what kitchen object we're
116:40 - actually trying to destroy so in order
116:42 - to pass in that reference let's pass in
116:43 - a network object reference
116:45 - so we're here for a parameter Network
116:47 - object reference this is going to be the
116:50 - kitchen object Network object reference
116:52 - so you have this and then from this one
116:54 - we can do a try get in order to get the
116:57 - network object this is going to be the
116:59 - kitchen object Network object and then
117:01 - from this one we can just do get
117:03 - component
117:04 - and get the component of type kitchen
117:06 - object and then we have our kitchen
117:08 - object okay so we have the kitchen
117:10 - object and on this one this code is only
117:12 - running on the server so over here now
117:13 - we can indeed do our destroy sound
117:15 - function and up here when we got the
117:17 - usual function let's just trigger the
117:19 - one with the server RPC okay just like
117:22 - this let's pass in the object reference
117:25 - so that's that one we just need to get
117:27 - the network object
117:28 - okay so this is all great and back here
117:31 - on the kitchen object for destroying it
117:32 - let's go into the kitchen game
117:34 - multiplayer let's access the instance
117:37 - and call the destroy kitchen object
117:39 - function okay so just like this it looks
117:41 - like it works so basically this function
117:43 - goes into the kitchen game multiplayer
117:45 - and that one destroys the object only on
117:47 - the server however if we inspect over
117:49 - here the destroy sound function we are
117:52 - not only destroying the game object but
117:53 - we are also clearing the kitchen object
117:55 - on the parent this is something that we
117:57 - must do on every single client it's
117:59 - basically the same thing that we had up
118:01 - here when setting the kitchen object
118:02 - parent we had to make sure that we use a
118:04 - client RPC to broadcast it to all the
118:06 - clients and not just do it on the server
118:08 - so basically let's just split this logic
118:10 - into two functions so this one runs on
118:12 - the server and this one on only cleans
118:13 - so let's make up here a public void
118:16 - clear kitchen object on parent and we're
118:20 - going to just run this code so just like
118:22 - this so we now have the two separate
118:24 - functions and then back in the kitchen
118:26 - game multiplier script over here let's
118:28 - just make another one so this one is
118:30 - going to be a client RPC let's make a
118:33 - private void call it clear kitchen
118:35 - object on parent client RPC
118:38 - let's pass in the same network object
118:40 - reference
118:41 - and let's grab the kitchen object from
118:43 - that reference and then on this one we
118:45 - can call the Clear the object on the
118:48 - parent and this one is going to be a
118:50 - client RPC
118:52 - okay so just like this and up here
118:53 - before we destroy the object on the
118:55 - server let's just sell all of the
118:57 - clients all of them to unparent the
118:58 - subject so let's just pass in the
119:00 - reference just like this okay so now we
119:02 - have all the logic running on all of the
119:04 - correct places all of the clients are
119:06 - going to clear the parent they're on
119:08 - local parent and then only the server is
119:10 - going to actually destroy the object
119:12 - which in turn is automatically
119:13 - synchronized and all of the clients get
119:15 - that object destroyed so let's left this
119:17 - back here on the trash counter instead
119:19 - of going through the kitchen object and
119:20 - accessing the destroy sound function
119:22 - instead of that let's just use the other
119:23 - one so let's go inside kitchen object
119:25 - and let's use our static function in
119:27 - order to destroy a kitchen object and
119:29 - just pass in this player.kitchenobject
119:32 - so let's do just like this okay so this
119:34 - is going to handle everything on the
119:36 - client and the server and then we've got
119:38 - the Israel interact logic and we fired
119:40 - the event over here only on the client
119:42 - okay so this should do it it should
119:43 - clear the parent on all the clients and
119:45 - it should destroy the object on the
119:47 - server which is also then destroyed on
119:48 - only clients what says okay so here we
119:51 - are and if I'm up here on the host and I
119:53 - try to trash something and if there go
119:55 - does work no errors everything is
119:56 - synchronized and then down here on the
119:58 - client pick up something and let's try
120:00 - to trash it and if there you go it also
120:01 - works nowhere is nothing alright awesome
120:03 - so in order to destroy a kitchen object
120:06 - we really just need to run this function
120:07 - instead of doing it through the destroy
120:09 - itself directly now we can use Visual
120:11 - Studio to find all the references so if
120:13 - we right click over here and find all
120:15 - the references so we see all the places
120:17 - where we're calling destroy self and
120:18 - basically we're going to need to replace
120:19 - all of these to go through this separate
120:21 - function we're going to do that as we go
120:23 - through all of the counters in the
120:24 - following lectures over here let's just
120:26 - quickly synchronize the delivery counter
120:27 - because that one is so simple so here we
120:29 - are on delivery counter script here it
120:32 - just calls a function to deliver a
120:33 - recipe on delivery manager we already
120:35 - synchronized this part all that's left
120:37 - is really just destroying the plate
120:38 - object so again instead of doing this
120:40 - let's call the other function that goes
120:41 - through the server so the kitchen object
120:43 - destroy the kitchen object and just pass
120:45 - in this kitchen object so just like this
120:48 - okay that's it let's test okay so here
120:51 - we here and if as a host I try to
120:53 - deliver something if there go it does
120:55 - work no errors okay and now down here if
120:57 - I try on the client to deliver and if
120:59 - there you go it also works no errors
121:01 - nothing so the client can also deliver
121:02 - something and destroy an object and we
121:04 - have no problems okay great so here we
121:07 - added yet another very important
121:08 - synchronization to our multiplayer game
121:10 - and in doing so we also learned how to
121:12 - destroy Network objects now we want to
121:14 - synchronize the remaining counters so
121:15 - let's begin by synchronizing the cutting
121:17 - counter in the next lecture
121:21 - hello and welcome I'm your code monkey
121:22 - in this lecture we're going to
121:24 - synchronize The Cutting counter this
121:26 - involves synchronizing placing the right
121:27 - objects then doing the alternate
121:29 - interact action and handling converting
121:31 - an uncut object onto a cut object okay
121:34 - so let's synchronize The Cutting counter
121:36 - let's try it first to see what we need
121:38 - to think so if I pick up some cheese and
121:40 - I drop it over there on the cutting
121:41 - counter yep there you go dropping the
121:42 - object that one is already being
121:44 - perfectly synchronized
121:45 - so that part works fine but then if I
121:47 - try to cut the cheese there you go it
121:49 - works in there but nothing is being
121:50 - synchronized so we need to do that
121:53 - let's go over here onto the cutting
121:54 - counter
121:55 - and really let's do the usual server
121:57 - client RPC pair so just like we did on
122:00 - the other counters
122:01 - this is going to be on the interact
122:03 - alternate so let's go down here and
122:05 - start running our functions so let's
122:07 - call this the cut object server RPC
122:11 - and let's make another one the cut
122:13 - object the client RPC
122:15 - let's add the client RPC attribute and
122:18 - the server RPC
122:20 - and again as always let's make it
122:22 - require ownership
122:24 - equals false so that the clients can
122:26 - trigger the server RPC
122:28 - okay so as usual from the server RPC we
122:31 - trigger the action on the coins and on
122:33 - the clients over here we run the actual
122:35 - regular logic so let's just copy all of
122:37 - this and paste it over there and from
122:40 - here when we cut let's just do this
122:42 - okay so just like this we don't have any
122:45 - errors so let's try it and see what
122:47 - happens
122:48 - so if you're in the host if I pick it up
122:50 - and I cut and if there go the cut is
122:52 - indeed being perfectly synchronized so
122:54 - that's great
122:55 - however we actually do have a problem if
122:58 - instead of the hose if I do it down here
122:59 - on the client so let's pick up some
123:01 - cheese drop it onto one down here and
123:03 - there you go we have an error we have
123:05 - the usual null reference exception let's
123:07 - actually swap the order so we can see it
123:08 - up here in the editor okay so now I have
123:11 - the host down here and the client up
123:12 - here so on the client go and drop it and
123:15 - there you go there's the error the no
123:16 - reference exception and let's see what
123:18 - is this line
123:20 - this line is throwing in non-reference
123:21 - exception and just by looking at this we
123:23 - can immediately tone which one of these
123:25 - is actually possible as being null and
123:27 - the answer is over here the get kitchen
123:28 - object this is the only one that can
123:30 - possibly be known which we're then
123:32 - accessing and returns no so that has our
123:34 - exception and the issue that we have
123:36 - here is very very important basically
123:39 - the issue is that in single player all
123:41 - of this code this will all run
123:42 - sequentially right away whereas in
123:44 - multiplayer some code like for example
123:46 - using rpcs that will not run immediately
123:49 - basically the issue that we have here is
123:51 - that we are changing the parent over
123:53 - here on the kitchen object that the
123:54 - player is holding so that makes sense
123:56 - but while in single player and this
123:58 - changes the parent right away so then
124:00 - the code down here this kitchen object
124:01 - on this counter has already been
124:03 - switched so when the code gets down here
124:05 - on the host that is not going to be
124:07 - known so that is correct however in
124:09 - multiplayer the kitchen object will only
124:11 - change parent when the message goes to
124:13 - the server and back so when the client
124:15 - is running this line this code modifying
124:17 - the kitchen object parent this one isn't
124:19 - going to handle immediately
124:21 - however even as that message is being
124:23 - sent through the multiplayer netcode
124:24 - even through that this code is going to
124:26 - continue executing so when it gets down
124:28 - here that message hasn't yet reached the
124:30 - server so this object that is on the
124:32 - player is still going to be on the
124:33 - player by the time we get down here
124:35 - this is a very very important thing you
124:37 - always need to be very careful with when
124:39 - making multiplayer games you have to
124:41 - remember when the functions run
124:43 - so on the host all of the code won't run
124:45 - in a certain way whereas on a client
124:47 - things might take a bit more time
124:49 - so that is something you always need to
124:51 - keep in mind here thankfully the
124:53 - solution is actually very simple we
124:55 - don't really need the object to change
124:56 - parent
124:57 - all we're doing down here is accessing
124:59 - the exact same object so we can just
125:01 - cache the object up here and we don't
125:03 - mind that it takes a little bit of time
125:04 - to change parent
125:06 - so we can just go up here to find the
125:08 - kitchen object kitchen object and go
125:10 - into the player and get the kitchen
125:12 - object
125:13 - so then we take that one and we modify
125:15 - the parent and then down here we use the
125:17 - exact same reference just like this this
125:19 - way the client code is not waiting not
125:21 - expecting the server code to run
125:23 - immediately this way it will always work
125:25 - okay so let's test so here on let's
125:28 - start a host down here and a client up
125:29 - here okay so now on the client if I go
125:31 - pick it up and I drop it and there you
125:33 - go it does work no errors okay great
125:36 - now if I cut on the client if there you
125:38 - go that action is also already
125:40 - synchronized same thing on the host if I
125:42 - go up there and I cut that object yep
125:43 - there you go everything works perfectly
125:44 - alright awesome
125:46 - so everything is working great so far
125:48 - however if I finish cutting on either of
125:50 - these and there you go we have an error
125:53 - this is showing an issue with the
125:55 - kitchen object parent but in reality
125:57 - this is really because when we finish
125:58 - cutting we try destroying the previous
126:00 - object but we are still using the old
126:01 - method which no longer clears the parent
126:03 - so this is really related to destruction
126:05 - not really parenting
126:07 - the solution is the same thing that
126:08 - we've already done so many times
126:10 - so let's just go down to where we are
126:12 - destroying the object so it's over here
126:13 - we are calling the story itself instead
126:15 - let's go through the kitchen object and
126:17 - destroy the kitchen object and pass in
126:19 - this kitchen object okay so now the
126:21 - structure should be working let's see
126:24 - so here we are and I'm going to test
126:25 - just with the hose here no clients so
126:28 - just with one hose let's go there pick
126:30 - it up go there drop it and let's cut one
126:32 - two and three times and if there you go
126:34 - everything seems to be working perfectly
126:35 - however now if I test with the host
126:38 - appear and a client down here and on the
126:40 - host let's go there and cut it one two
126:42 - there you go everything synchronized cut
126:43 - one more and there you go we have an
126:45 - error so again always remember that when
126:47 - you make any modifications in
126:49 - multiplayer you need to verify that it
126:50 - works on the host and on the client so
126:52 - you always need to verify every possible
126:54 - use case Okay so let's see exactly what
126:56 - this error is this one is a much more
126:58 - sneaky issue
126:59 - note how in this code here for running
127:02 - the server and the client RPC this one
127:04 - is a client RPC meaning this code is
127:06 - going to run on every single client so
127:09 - all the clients are going to run all of
127:10 - this code meaning that all of the
127:12 - clients are going to increase their own
127:13 - cutting process and all of the clients
127:16 - are going to run the sieve so all of the
127:18 - clients are going to basically try to
127:20 - cut the object as many times as we have
127:21 - clients
127:22 - that obviously creates a conflict when
127:24 - it comes over here to destroying and
127:25 - spawning objects because these things
127:27 - are only going to happen on the server
127:29 - but we're going to run it as many times
127:30 - as we have clients so that is why we
127:33 - just one Host this isn't actually
127:34 - causing problems but as soon as we have
127:36 - two clients and two clients are going to
127:38 - run this code meaning that both of them
127:40 - will attempt to destroy the same object
127:41 - and then spawn a new object so we have
127:43 - duplicate logic that is not good the
127:46 - solution here is basically for the code
127:47 - that we have down here we really only
127:49 - want to run this once regardless of how
127:51 - many clients we have
127:52 - so basically let's split this cutting
127:54 - process testing into another function
127:56 - and make it just a server RPC
127:59 - so let's go down here make a private
128:01 - Point call it test cutting progress done
128:04 - server RPC
128:06 - let's make this a server RPC with
128:09 - required ownership as phones
128:11 - and then over here we're actually going
128:13 - to run just this logic so we also need
128:15 - the cutting recipe so like this
128:18 - and then for calling this function let's
128:20 - just go up here to where we're calling
128:21 - the cut object server RPC and then let's
128:23 - call the other RPC okay so that way now
128:25 - we know that this function this code is
128:27 - only going to execute on the server
128:30 - so it is no longer dependent on how many
128:31 - clients we have so let's test so over
128:34 - here up here I've got the host so if I
128:36 - go and I cut so one two and three and if
128:39 - there you go it does work it cut
128:40 - perfectly
128:41 - and now let's go down here and try it
128:43 - out on the client so let's pick it up go
128:45 - down there drop it
128:47 - and let's cut once two three times
128:50 - and yep it also worked so it seems like
128:52 - everything is working
128:54 - however now let's say on the client I'm
128:56 - going to reuse the cutting counter up
128:57 - there so let's pick this one up let's
128:58 - drop another one paste there and now if
129:01 - I cut and there you go look at that
129:03 - issue the client cut just once over
129:05 - there the progress is correct but on the
129:07 - server and look how the process is
129:08 - already maximized and the object was
129:10 - immediately cut
129:11 - basically the issue is that the host is
129:13 - now resetting the progress
129:14 - if we only look back in our code here
129:17 - when we're placing an object on the
129:19 - counter we're going to run this code so
129:21 - first of all unfortunately the parent
129:22 - this is already going to be
129:23 - automatically synchronized but then down
129:25 - here setting the cuttering progress to
129:26 - zero this one is not automatically
129:28 - synchronized
129:29 - so as usual we have two options we could
129:31 - just make the same network variable or
129:33 - let's just keep using the usual server
129:35 - client RPC pair
129:37 - so let's go down here to make that
129:38 - function a private void call it
129:41 - interactlogic Place object on counter
129:44 - this is a server RPC
129:47 - so it's a server RPC would require
129:49 - ownership as phones then let's make the
129:52 - corresponding client RPC so let's go for
129:55 - the client RPC and the exact same name
129:58 - just end with client RPC okay
130:01 - then from this one we run the other one
130:03 - the client RPC and now on the client RPC
130:06 - we're going to run the regular logic
130:07 - again the parent that one is already
130:09 - automatically synchronized so let's just
130:11 - cut this and paste it down here and for
130:13 - the server RPC let's just run it all the
130:16 - way up here okay so like this so we run
130:18 - the server RPC that one then runs this
130:20 - code on all the clients
130:22 - and over here we actually have an issue
130:23 - with the kitchen object reference so we
130:25 - could pass it in but actually we're
130:27 - really not going to need this at all
130:28 - we're using it down here to set the
130:30 - cutting progress Max
130:31 - but the progress normalized only is
130:33 - going to be zero because getting
130:34 - progress is zero so instead let's just
130:37 - not do that and just pass in zero f okay
130:39 - that should do it let's test okay so up
130:42 - here on the host let's drop it cut one
130:44 - two three okay great now on the client
130:46 - pick it up go there drop it and cut it
130:48 - and there you go the progress is
130:50 - synchronized one two three and there you
130:52 - go it does cut perfectly all right
130:54 - awesome with this we no longer have any
130:56 - errors and our cutting counter logic is
130:58 - all fully synchronized like I mentioned
131:01 - one alternative here would be to
131:02 - synchronize The Cutting process using a
131:04 - network variable and that's exactly what
131:06 - we're going to learn about with the
131:07 - stove counter in the next lecture
131:11 - hello and welcome I'm your code monkey
131:13 - in this lecture we're going to
131:15 - synchronize the stove counter this is
131:17 - the more complex counter but thanks to
131:18 - what we have already learned this isn't
131:20 - actually going to be too difficult we
131:22 - need to synchronize the timer the object
131:24 - conversion from uncooked to cook to
131:26 - burnt and handle the various States
131:28 - okay so let's handle the self counter we
131:31 - can start off with a quick test
131:33 - so I'm going to create a host down here
131:35 - and a client over here on the editor and
131:37 - now on the client if I go ahead and I
131:39 - put something on stove so let's drop it
131:41 - and there you go we have an error right
131:42 - away here it is on this stove counter
131:44 - line so let's see it and the issue is
131:46 - we're only the exact same issue that we
131:48 - saw previously which is the host is
131:49 - going to run this code sequentially but
131:51 - on the client setting the parent is
131:52 - going to take quite a bit of time so
131:54 - when it gets on here this kitchen object
131:56 - hasn't yet switched parents so let's do
131:58 - the exact same solution let's just cache
132:00 - the kitchen object
132:01 - so kitchen object
132:03 - and we grab the player get the kitchen
132:05 - object
132:07 - then we use this one both in here as
132:09 - well as in here okay so that won't fix
132:12 - that issue then we need all of the
132:13 - clients to know what Frank recipe was
132:15 - selected
132:16 - so let's make the usual server client
132:18 - RPC pair for our interact logic so let's
132:21 - go down here and make those functions
132:22 - sorry private void interact logic Place
132:26 - object on counter server RPC
132:30 - and the same thing for the client RPC so
132:33 - just change this let's add the usual
132:35 - client RPC attribute and the server RPC
132:38 - as well as required ownership as false
132:41 - okay our standard functions then on the
132:44 - server RPC we call the client
132:47 - and up here when we are dropping
132:49 - something so in here we're going to
132:51 - trigger our server IPC okay
132:53 - so let's copy this little code cut it
132:55 - from here let's go down to the connect
132:57 - RPC and paste it okay now in order for
132:59 - this to work we need some reference to
133:01 - the kitchen object or we can also grab
133:03 - the frame recipe just by using the
133:04 - kitchen object so
133:06 - so basically those are the three options
133:08 - we have we could add a parameter here
133:10 - and synchronize directly the Frameworks
133:12 - PSO we can synchronize just the kitchen
133:13 - object or the kitchen object that so all
133:16 - of those options are valid let's go with
133:18 - the kitchen object so method since we
133:19 - already have these functions on the
133:21 - multiplier class to convert it into an
133:22 - index
133:23 - so here on the kitchen game multiplayer
133:25 - we already made these functions to
133:26 - convert an so into an index let's just
133:29 - make them public so we can count from
133:30 - there so both of these make them public
133:32 - okay
133:33 - so now we can hear for our rpcs let's
133:36 - receive an INT for the kitchen object so
133:38 - index we have one here and one down here
133:41 - and then we get there
133:43 - okay so now up here when we are calling
133:45 - the server RPC let's just go inside the
133:49 - kitchen game multiplayer let's access
133:51 - the instance and get the kitchen object
133:53 - that's so index
133:55 - and now we pass in this kitchen object
133:56 - dot get kitchen object the cell
134:00 - okay so that way we get the index and
134:02 - then down here really just need to
134:03 - convert the index back into the kitchen
134:05 - object the cell so the kitchen object as
134:08 - so
134:09 - we're going to go into the kitchen game
134:12 - multiplayer the incense get the kitchen
134:14 - object that so from the index and pass
134:16 - in the index
134:18 - so we have this and then we can grab the
134:20 - frying or spso based on this okay great
134:22 - no more errors
134:24 - with this we are now going to have the
134:26 - same frame recipe so synchronized across
134:28 - all of the clients
134:29 - so let's test it out and see if the
134:31 - client can now place an object on stove
134:34 - okay so let's put the host on here the
134:36 - client up here and on the client let's
134:37 - pick up some meat and cook it and there
134:39 - you go it did work no errors both of
134:41 - them are being synchronized and if we
134:43 - wait until it gets cooked and then we've
134:45 - got an error
134:46 - so this is actually going to be the same
134:47 - issue that we already saw previously
134:49 - which is destroying the object however
134:51 - before we actually love that issue and
134:53 - let's solve another issue right now all
134:55 - of the clients they're all running their
134:56 - own timer on the stove we really don't
134:59 - want that we just want one source of
135:01 - Truth so only the server should be
135:03 - handling the stove timer
135:05 - and when we have that then we're going
135:07 - to need to synchronize the same timer to
135:08 - all the clients so technically like
135:10 - we've been doing we could use a client
135:12 - RPC fire it on every single update in
135:14 - order to update the clients that would
135:16 - work but that would be quite wasteful so
135:18 - instead let's use the other method for
135:20 - synchronizing data let's use a network
135:21 - variable again I cover the bottom all in
135:24 - detail in my dedicated net code for game
135:26 - objects video go re-watch that section
135:28 - to see everything that Network variables
135:30 - can do
135:31 - so over here if we scroll down on the
135:33 - frame timer instead of using a simple
135:35 - float let's use a network variable of
135:38 - type float
135:39 - then for natural variables we need to
135:41 - initialize them so let's do new network
135:42 - variable and start off on 0f for the
135:45 - other parameters we can leave them all
135:46 - as defaults
135:48 - so everyone can read and only the server
135:50 - can write to it so now what we need is
135:52 - to fix all of these errors
135:54 - and first of all before the only with
135:55 - any actual errors over here for the
135:57 - update we only want to run this on the
135:59 - server so it said if not is server if
136:02 - this is running not on the server let's
136:04 - just return okay so this logic is only
136:06 - going to run on the server then for
136:08 - increasing the value we want to increase
136:09 - by the same amount the only difference
136:11 - is when working with a network variable
136:12 - we increase it by dot value okay then
136:15 - for the on progress changed event if
136:17 - we're leaving like this and the event is
136:19 - really only going to be fired on the
136:20 - server and not on all the clients so you
136:23 - need to make sure that all the clients
136:24 - fire off this event whenever the frying
136:26 - timer changes
136:27 - now thankfully the network variable
136:29 - itself this one also fires off an event
136:31 - when variable changes in any way
136:34 - so let's listen to that and usually for
136:36 - listening to an event you would do it on
136:37 - awake or on start but remember we're
136:40 - working in multiplayer so when listening
136:42 - to a network variable event you really
136:44 - shouldn't listen to it on a on network
136:46 - spawn like we already saw this is kind
136:48 - of like an awake but for Network objects
136:50 - so let's do a public override
136:52 - and let's override the void on network
136:54 - spawn so let's override this one
136:57 - and over here we can listen to it so
136:59 - let's go into the frying timer and it's
137:01 - called the on Valley changed and now
137:03 - this one is actually just a delegate and
137:05 - not an actual event so the home phone
137:07 - Visual Studio shortcut where we hit Tab
137:09 - and automatically writes that doesn't
137:10 - work here so we need to manually write
137:12 - it so let's just do a private void call
137:14 - it frying timer then underscore on value
137:17 - change so pretty much the same naming
137:19 - format for the parameters going to have
137:21 - a float for the previous value and
137:23 - another float for the new value so we
137:26 - make this function and we assign it to
137:28 - our event
137:30 - okay great and over here we can actually
137:32 - run the on progress change event so
137:35 - let's fire off this one just like this
137:38 - then instead of using the front timer we
137:40 - use the frying timer dot value because
137:41 - again all of the clients can read this
137:43 - network variable however over here we
137:45 - actually still have one potential
137:47 - problem that problem is going to be if
137:49 - the frying timer changes in any way like
137:51 - it gets initialized before the frying
137:53 - recipe associate if that happens this
137:55 - one is going to fire off a non-reference
137:56 - exception we don't want that so let's
137:58 - just add a simple node check so let's
138:00 - define a float for the frying timer Max
138:03 - and basically we just check if the
138:05 - frying or spso if this one is not known
138:07 - if so then let's use the frying recipe
138:10 - so dot frying timer Max
138:12 - but if it is then let's use one f one F
138:14 - basically it's a default since over here
138:16 - we're dividing by it if you divide
138:17 - anything by one you always get that
138:19 - something also by the way if you're not
138:21 - familiar with this code this is called
138:22 - the if shorthand
138:24 - so what we're doing here is pretty much
138:26 - the exact same thing as this so if
138:27 - frying recipe so if it is not null
138:31 - if so then the frying timer Max becomes
138:34 - a frying recipe so
138:36 - dot frying timer Max and if not the
138:39 - frying timer Max becomes 1f so this line
138:42 - up here is doing the exact same code as
138:43 - this down here
138:45 - so just a much more simpler way of doing
138:47 - a simple if
138:49 - so let's do that just like this okay
138:51 - great
138:52 - now let's continue our update logic
138:54 - let's fix all these errors so again on
138:56 - the frying timer we need to access the
138:57 - value okay
138:59 - then here we have the problem with
139:00 - destruction but again we're going to
139:02 - handle that in a little bit for now
139:03 - let's just fix the rest of the errors so
139:05 - let's scroll down and find them okay so
139:07 - down here this one is dot value
139:10 - and same thing over here for resetting
139:12 - the timer this one dot value
139:14 - but again here we are working inside a
139:16 - client RPC and the network variable only
139:19 - the server can write to it so if we do
139:21 - it just like this we're going to have an
139:22 - error because the client cannot write to
139:24 - this variable so let's just make sure to
139:26 - do this on the server RPC instead
139:28 - then also for the on-preg exchange this
139:31 - one is automatically going to be fired
139:32 - whenever we modify the frame timer so we
139:34 - can actually also remove it from here
139:37 - okay so no more errors so everything
139:39 - should be working so let's test so up
139:42 - here on the client let's pick it up and
139:43 - drop it and there you go everything is
139:45 - nice and synchronized okay so great
139:47 - so now let's fix this error when
139:49 - destroying the cooked object so as usual
139:51 - in the fix is super simple example like
139:53 - we've already done so let's go down into
139:54 - the update okay so here we've got the
139:56 - frying and we are calling this right
139:58 - self so instead of that one let's use
139:59 - the other function so kitchen object
140:01 - let's destroy this kitchen object so
140:04 - this one down here let's destroy this so
140:07 - that is going to handle that let's see
140:08 - where else we're destroying it's also
140:09 - down here on the Fright State going from
140:11 - fried into burned let's also call the
140:14 - same function
140:15 - okay so it says
140:18 - so here we go let's pick up some meat
140:20 - and cook it and there you go the timer
140:21 - is synchronizing let's wait a bit and
140:23 - see if it actually cooks and yep there
140:26 - you go it did work all right the object
140:27 - was indeed replaced okay so that's great
140:29 - except we can already see on the timer
140:31 - not exactly great
140:33 - basically what happened is that the burn
140:35 - State isn't really synchronizing but at
140:37 - least the object transformation did work
140:38 - so that part is great
140:40 - so we have the correct object just not
140:42 - yet synchronizing the actual States
140:45 - so for synchronizing the burn state
140:48 - we really need to synchronize two things
140:50 - first of all is the burning timer just
140:52 - like we did the frying timer
140:54 - and then we're also going to need to
140:55 - synchronize the state itself so first
140:57 - let's in the burning timer so exactly
140:59 - like the frying timer so if here a
141:01 - network variable of type float and let's
141:04 - start off sorry off on zero f okay there
141:07 - it is then down here let's listen to the
141:09 - same change event so on the burning
141:11 - timer let's listen to the unfail change
141:13 - we're going to make another function so
141:15 - burning timer on value change let's just
141:18 - copy this and just replace all the names
141:20 - so this is the burning timer and for
141:23 - here we have the burning time Max and
141:27 - we're going to access the burning recipe
141:29 - so and from the burning recipe so get
141:33 - the burning timer Max
141:35 - so we have that and on the progress
141:36 - normalized your strength timer replaces
141:38 - with burning timer
141:40 - and up here I actually made a mistake
141:42 - that I only noticed just now
141:43 - we made this one to avoid any null
141:45 - checks over here with the frame spso but
141:47 - then I forgot to use this one so let's
141:49 - actually remember to use that one and
141:51 - down here same thing let's use this one
141:53 - okay that's good again make sure all of
141:55 - the references have been replaced so you
141:58 - can do a quick search for frying and
141:59 - make sure there are no frying references
142:01 - down here okay great
142:02 - now let's continue solving of the errors
142:05 - so let's go down for the burning timer
142:06 - we need to modify the value the progress
142:08 - change this one is going to happen
142:09 - automatically so move it first burning
142:12 - timer this one is the value okay
142:14 - and finally up here when modifying also
142:17 - Modified by the valid
142:19 - okay we have no more errors
142:21 - like this the client will indeed
142:23 - synchronize the burning timer but it
142:25 - will not synchronize the state
142:26 - now since we used an enum for our state
142:29 - we can easily make this a network
142:30 - variable enums are serializable so you
142:33 - can just go up here and make this a
142:34 - network variable of type State and let's
142:37 - initialize it over here instead of doing
142:39 - it on start so let's initialize on state
142:41 - DOT idle so let's do this instead of
142:44 - doing it over here on sart
142:45 - and now let's fix some of the usual bugs
142:47 - so instead of doing a switch on safe
142:49 - switch on state DOT value
142:52 - then for modifying the state so state
142:54 - DOT value
142:55 - for firing Deon say change event let's
142:57 - do the exact same thing let's go up here
142:59 - onto the state and the on value change
143:02 - let's see one so State on Valley change
143:05 - let's make this function
143:07 - so down here on a private void State on
143:10 - valid change so we've got a state for
143:12 - the previous state and a state for the
143:16 - new state
143:17 - so you have this in over here on this
143:19 - one let's fire off the unlockable event
143:20 - so let's cut this and paste it in there
143:23 - so we have this state DOT value
143:25 - okay so that is going to fire off all
143:27 - the events locally so that's great let's
143:29 - keep solving all the errors so over here
143:31 - on this logic is already working great
143:32 - all right now working on fried let's
143:34 - modify the state.value and we don't need
143:37 - to modify the state.changed and over
143:39 - here for the promise change we're doing
143:41 - this basically just to hide the progress
143:43 - bar it gets hidden automatically if the
143:45 - progress normalizes zero f but again
143:47 - over here this code is only going to run
143:49 - the server so we want to run this on
143:51 - every client
143:52 - so on sectionally put this on the on say
143:54 - changed event but only when the state is
143:56 - either burned or idle so let's go up
143:58 - here onto this one Let's do an if if the
144:01 - state DOT value
144:03 - if this one is State DOT burned or state
144:06 - DOT value if we are on the state DOT
144:09 - idle
144:10 - see if you are on either of these states
144:12 - then let's fire off the progress
144:13 - normalize zero just so we hide the bar
144:15 - okay great now let's fix the remaining
144:17 - errors
144:18 - so down here on the interact when we are
144:21 - resetting the state let's say dot value
144:22 - back into idle and let's get rid of the
144:25 - events since those are already happening
144:26 - then over here same thing state DOT idle
144:29 - and get rid of this
144:30 - and down here on our server inclinator
144:33 - PCS modify the state so state DOT value
144:35 - and then say change get rid of this
144:37 - except of course always remember that
144:40 - Network variable this one can only be
144:41 - modified on the server whereas here
144:43 - we're working inside a client RPC so we
144:45 - need to make sure to do this up here
144:47 - just like that
144:48 - so by now we can probably just rename
144:50 - this function since all this is doing is
144:52 - setting the frame rest BSO Sun
144:54 - sectionally rename this so let's use the
144:56 - visual studio shortcut just right click
144:58 - and let's go ahead and rename this let's
145:00 - call this set frying recipe so client
145:03 - RPC
145:05 - okay so that won't set the frame recipe
145:07 - so and then we're also going to need the
145:09 - function just like this for setting the
145:10 - burning rest PSO so let me just copy
145:12 - this and do the exact same thing so this
145:14 - one's going to set the burning rest vso
145:17 - so get burning rest BSO with input and
145:20 - this is the burning recipe so also by
145:22 - the way one note several people in
145:24 - commented on my single player course and
145:26 - yes you could refactor this code to have
145:28 - just a single unscriptable object to
145:30 - Define both the frying and the burning
145:32 - you could definitely do that that is an
145:33 - equally valid option I just went with
145:36 - this pattern to keep the states a bit
145:37 - more separated so you could potentially
145:39 - expand upon this with more States and
145:41 - more custom Logic for each state
145:43 - okay so now let's just call the function
145:45 - to set the burning rest BSO also down
145:47 - here let's fix this last remaining error
145:49 - okay so for setting the burning rest BSL
145:51 - that one is going to be up here so the
145:53 - update the frying
145:55 - we're going to get the burning recipe so
145:57 - but just like this it will only happen
145:58 - on the server we want it to happen on
146:00 - every single client so let's go ahead
146:02 - call this we go into the kitchen game
146:04 - multiplayer the instance let's get the
146:06 - kitchen object there so index
146:09 - and let's press in this kitchen object
146:11 - this kitchen object is so okay so just
146:13 - like this we've got no more errors so
146:16 - all of this logic should now be working
146:18 - so let's test
146:20 - so up here on the host let's cook
146:22 - something and there you go it is being
146:23 - synchronized okay great let's wait for
146:25 - the timer to reach the end and yep both
146:28 - objects were synchronized as well as
146:29 - that and there you go once it gets there
146:31 - it also spawns the burning timer warning
146:33 - and yeah both of them get burned and
146:35 - both them stop okay so with that
146:37 - everything works perfectly awesome now
146:39 - we just have one error if we go down
146:41 - here on the client and I try to pick up
146:42 - something there you go got an error
146:44 - invalid operation basically it's telling
146:46 - us that the client is not allowed to
146:48 - ride to a natural variable
146:49 - if you look in the code it's over here
146:51 - on the interact function when we go down
146:53 - when there's a kitchen object here and
146:55 - the player tries to pick it up so this
146:56 - issue right here we have the client
146:58 - trying to set the state value
147:00 - again only the server can do this
147:03 - so let's go ahead and do this through a
147:04 - server RPC so a private void set State
147:08 - idle server RPC
147:10 - make this a server RPC with required
147:13 - ownership as false
147:15 - and over here we just set the state DOT
147:17 - value just like this
147:20 - okay that's it super simple change now
147:22 - let's test
147:24 - so down here on the client let's go
147:26 - ahead pick up some meat drop it cook it
147:28 - and there you go it is working let's
147:29 - wait for it to cook a little bit and
147:31 - there you go it's cooked now pick it up
147:33 - and there you go it works no errors same
147:35 - thing up here on the host pick it up
147:37 - drop it everything works perfectly wait
147:39 - for it to cook for a little bit
147:41 - and there you go it's almost burned
147:43 - there you go now if I pick it up and if
147:45 - there you go it does work no errors
147:46 - nothing anywhere all right so with that
147:49 - we have essentially all of our counters
147:51 - all of them if only working of the
147:53 - multiplayer state for all of them all of
147:55 - that is being perfectly synchronized the
147:57 - interactions work perfectly except for
147:58 - one thing which is adding an ingredient
148:00 - onto the plate so let's handle that in
148:02 - the next lecture
148:05 - hey again quick intermission you're past
148:07 - the halfway point so congratulations
148:09 - looking at my regular corsets it seems
148:12 - about 80 of people give up by this point
148:14 - so great job on sticking with it and
148:16 - actually if you are following this
148:18 - course I'm assuming that you've also
148:19 - completed the single player course so
148:21 - really double congratulations I really
148:23 - hope these two courses have humped you
148:25 - out a lot in your Game Dev Journey now
148:27 - my question is are you finding this
148:29 - course to be more difficult than the
148:30 - single player or just about the same
148:32 - remember to post in the comments if you
148:34 - need extra clarification on anything and
148:36 - I'll do my best answer also check out
148:38 - the website to see what questions others
148:40 - best and of course remember this is your
148:42 - Learning Journey you're not competing
148:43 - with anyone but yourself so take your
148:46 - time re-watch some lectures if you need
148:47 - to just focus on learning okay let's go
148:50 - to the next lecture
148:52 - hello and welcome I'm your code monkey
148:54 - in this lecture we're going to
148:56 - synchronize the logic to add ingredients
148:58 - onto the plate okay so right now we
149:01 - already have quite a lot of the game
149:02 - logic working in multiplayer I can pick
149:04 - up items and it's synchronize I can drop
149:06 - them synchronize I can cut some objects
149:08 - I can cook some meat everything is
149:10 - working great the one big thing still
149:12 - missing is picking up ingredients onto a
149:14 - plate if I go ahead and I pick up a
149:16 - plate and then try to pick up some
149:17 - cheese
149:18 - and yep it didn't really work on the
149:20 - host it looks like it works but down
149:22 - here nope there's no synchronization so
149:24 - this client does not know that cheese
149:25 - was added to that plate and if I try
149:27 - doing it down here on the client so try
149:29 - to pick it up and there you go the
149:30 - client does itself get an error okay so
149:33 - let's fix this
149:34 - for handling that logic it's on the
149:36 - various counters so let's go first over
149:37 - here onto the clear counter
149:39 - let's go down to where we are seeing if
149:42 - it is a plate so if the player is
149:44 - holding a plate then it's going to call
149:45 - this function to try to add an
149:46 - ingredient so let's see this function
149:48 - this one goes over here does a bunch of
149:50 - validation and then adds the kitchen
149:52 - object so onto the enlist on the plate
149:54 - so we really just need to synchronize
149:56 - this and as usual we have our two
149:58 - options one option would be to make the
150:01 - list itself make it a natural variable
150:03 - or alternatively there is actually a
150:05 - networking list
150:06 - that would work we would need to make
150:08 - the kitchen object Association which we
150:10 - could do since we already handled the
150:12 - index functions so that wouldn't be one
150:14 - option but perhaps another similar
150:17 - option is simply to use the usual server
150:19 - client RPC combo
150:20 - so let's do exactly that let's make
150:23 - those two functions
150:24 - so let's make a private void call it add
150:27 - ingredient server RPC
150:30 - and we're going to have another one for
150:32 - the client RPC let's add the attribute
150:35 - so call enter PC and up here the server
150:37 - RPC and as usual we want the clients to
150:40 - be able to call this okay
150:42 - then up here when we have our
150:44 - interaction let's trigger the server RPC
150:47 - and down here on the planet RPC we do
150:49 - this and pass it into that okay so
150:52 - that's our simple logic now obviously
150:54 - down here we need a reference to the
150:55 - kitchen object so so as usual let's
150:57 - receive an end for the kitchen object so
151:00 - index
151:01 - let's also receive it on the client RPC
151:03 - over here we pass it in
151:05 - then down here let's go into the kitchen
151:07 - game multiplayer the instance and get
151:10 - the kitchen object that so from the
151:11 - index and let's grab it from this index
151:14 - and this is going to be our kitchen
151:16 - object so kitchen object so and you
151:20 - haven't liked this the rest of this code
151:21 - is indeed working so now up here let's
151:23 - just grab the index
151:25 - go into the kitchen game multiplier the
151:28 - incense and get the kitchen object is so
151:30 - index of this kitchen object itself
151:33 - alright so that's it all this is pretty
151:35 - simple now back here in the clear
151:37 - counter so basically we already handled
151:39 - the synchronization of the try and
151:40 - ingredient so the next thing is just
151:42 - over here the story self we need to use
151:44 - the other function so let's just replace
151:46 - this so going to Kitchen object and call
151:49 - destroy a kitchen object
151:51 - and let's pass in this kitchen object
151:54 - okay so that's it and same thing down
151:56 - here let's also replace this function
151:58 - and destroy this kitchen object
152:01 - okay so just like this some of the logic
152:03 - should work so let's test so first let's
152:06 - test up here on the host let's pick up
152:08 - some bread and drop it on equal counter
152:10 - okay now let's pick up a plate and try
152:13 - to pick up the bread and if they go it
152:15 - did work it picked up the bread and the
152:16 - client down there does see that this
152:18 - host is carrying the brand okay great
152:21 - now let's do the same thing on the
152:22 - client so down here in the client pick
152:24 - up some bread drop it on there pick up a
152:26 - plate go and grab it and there you go it
152:28 - does work and both of them are
152:29 - synchronized okay great
152:31 - now let's do the opposite so let's drop
152:34 - the bread in there let's pick up a plate
152:36 - drop it in there pick up some bread drop
152:38 - it on the plate any other go it does
152:40 - work and same thing over here on the
152:42 - client pick up some bread drop it pick
152:44 - up a plate and let's go ahead pick up
152:46 - the bread any of there you go everything
152:47 - does work all right awesome so once
152:50 - again because the power of writing good
152:52 - clean code we didn't really need to
152:53 - modify many things we really just
152:55 - modified one single function and
152:57 - everything already works perfectly now
152:59 - really all we need to do is just apply
153:01 - the same logic to every single counter
153:03 - so let's go here onto the cutting
153:05 - counter and we have our interact
153:07 - function okay we have the usual
153:08 - interaction and over here we've got the
153:10 - plate logic
153:11 - for this one we already handled the
153:13 - triangle green so that one's already
153:14 - going to be synchronized so really all
153:16 - we need is just going to Kitchen object
153:17 - and use the other destroy kitchen object
153:19 - method
153:21 - so let's just use this one like this
153:24 - and yep that's it nothing else we need
153:25 - to change next is over here on the stove
153:28 - counter so again let's go down into our
153:30 - interact function and let's find where
153:32 - the player has a plate and really the
153:35 - same thing the adding the ingredients
153:36 - that's already synchronized so let's
153:38 - just replace the kitchen object dot
153:40 - destroy kitchen object just replace this
153:42 - one with that one and then over here
153:44 - we're also sending the state so this one
153:46 - is going to give the same error that we
153:47 - saw previously the client cannot set the
153:50 - state so that is why one year we made
153:51 - the server RPC so it just also replaces
153:53 - like this
153:54 - okay so that should really do it these
153:57 - are the only three counters where the
153:58 - player can pick up something onto a
154:00 - plate so everything else should already
154:01 - be working let's test so up here on the
154:04 - host let's cook some meat let's also cut
154:06 - some cheese so both counters now pick it
154:08 - up let's pick up the cheese and you
154:10 - better go it does work it will
154:11 - synchronize pick up the meat and yep it
154:13 - also works okay great and then down here
154:16 - on the client let's do the same thing so
154:18 - cut some cheese it works cook some meat
154:20 - it does work pick up the cheese and yep
154:23 - it does work now pick up the meat and
154:25 - yep it also works both of them are
154:27 - perfectly synchronized
154:28 - then we can even make it delivery so
154:30 - let's pick up some bread delivery over
154:32 - here and yep there you go it does work
154:34 - perfectly all right awesome so with this
154:37 - the plates are fully working pretty much
154:39 - everything is perfectly synchronized
154:40 - next we want to sort something pretty
154:43 - basic handling some player collisions so
154:45 - let's do that in the next lecture
154:48 - hello and welcome I'm your code monkey
154:49 - in this lecture we're going to hand on
154:52 - player collisions
154:53 - okay so a lot of the games already
154:55 - working great I can cook some meat cut
154:57 - some cheese and so on so everything
154:58 - works perfectly however one thing we
155:00 - don't have are some player collisions so
155:02 - right now the players can just face
155:04 - through one another now this is actually
155:06 - a design question for some co-op games
155:09 - they usually have no collisions at all
155:10 - but some of them do have them and for
155:13 - this game I think either approach works
155:15 - if you want to make it more casual and
155:17 - easier to play then no collisions works
155:19 - fine but if you want to make the game a
155:21 - bit more challenging a bit more rage
155:22 - inducing in a good way then adding
155:24 - collisions is a simple way to do that
155:26 - that allows you to be more complex we
155:28 - Journal level design by making some
155:30 - small levels where for example one
155:31 - player can only go through one tiny
155:33 - corner so here on let's add that then
155:35 - it's up to you if you want to keep it or
155:37 - remove it now thankfully due to the way
155:39 - we built our game this is actually going
155:40 - to be super simple so this is going to
155:42 - be yet another quick lecture over here
155:44 - on the player script if we go down into
155:47 - our handle movement function so let's go
155:49 - down to this function so here it is
155:51 - for this one we are already testing four
155:53 - collisions we're doing a capsule cast to
155:55 - see if we can collide with something see
155:57 - if we can move or not so this code is
155:59 - already working but actually let's first
156:01 - refactor this code to be a bit more
156:03 - adaptable I saw some people trying to
156:05 - expand upon the single player game by
156:07 - adding some trigger colliders to do some
156:09 - external logic and like this using this
156:11 - capsule cast
156:13 - this cast won't hit every single home
156:14 - either so that means of the counters as
156:17 - well as any other colliders that you
156:18 - probably don't want to hit
156:20 - so to solve that let's Usain layer mask
156:22 - to make sure we only Collide against
156:23 - things we want to collide with suddenly
156:26 - our mask is going to be exactly like we
156:27 - did appear on the handle interactions we
156:29 - made it in layer mask just to be able to
156:30 - hit some counters so let's do the exact
156:32 - same thing down here
156:34 - let's look at all the versions of the
156:36 - capsule cast to see which one we can use
156:39 - so let's use this one down here version
156:41 - number four which is exactly the same so
156:42 - has the same parameters and at the end
156:44 - we have the layer mask
156:45 - so at the end we can just add and we can
156:47 - just reuse the counters layer mask so
156:49 - let's do that and this way this capsule
156:51 - cast will only hit things on the
156:52 - counters layer let's make sure to apply
156:55 - it here as well as these two other caps
156:57 - on casts
156:59 - so on this one and also the one down
157:02 - here
157:02 - okay so let's do a quick test just to
157:05 - make sure that nothing really changed
157:07 - so here I am I can move around and yep
157:09 - it is in the testing for collisions okay
157:11 - so far so good except now if we wanted
157:13 - we could add some things so let's say I
157:16 - would add a cube this one has a boxed on
157:18 - either I don't want any visuals so let's
157:19 - say this was just a trigger collider so
157:21 - I wanted to place it somewhere in here
157:23 - as long as this one is not on the
157:25 - counter's layer as long as it isn't
157:28 - then over here on the game I can move
157:29 - around and yep there you go there's no
157:31 - issues I can go through that invisible
157:32 - Cube so this allows you to expand upon
157:35 - the game in order to add some more logic
157:36 - based on colliders okay great
157:38 - so back to our original goal let's add
157:40 - some player collisions
157:42 - right now this is only testing against
157:44 - counters and only we really need to make
157:46 - this work is also test against players
157:48 - but for the interaction up here we still
157:51 - only want this one to hit just the
157:52 - counters so real let's just make two
157:54 - layer masks
157:55 - so here we have the counter's layer mask
157:57 - and let's go with another one and for
158:00 - this one let's go with a more generic
158:01 - name so let's say collisions layer mask
158:04 - okay so we have this we're going to set
158:05 - this in the other term a little bit
158:07 - let's just go down here and really just
158:08 - replace it with this one so replace it
158:11 - on that one
158:12 - and over here on this one and then down
158:15 - on this one okay great
158:17 - that's it there's nothing else we need
158:19 - to change in the code here and now if we
158:21 - go in the editor and we select the
158:22 - employer prefab
158:24 - and even down here we have the Collision
158:25 - Slayer mask so let's make sure to
158:27 - include the counters and now we also
158:29 - want to include the players so let's go
158:31 - into our layer let's add a brand new
158:33 - layer let's call it the players layer
158:36 - then over here on the employer game
158:37 - object let's put this one on the
158:39 - player's layer and for this case let's
158:41 - not apply it to all channels let's leave
158:43 - the children on the similar they are so
158:45 - let's apply to this object only okay so
158:47 - this one is on the players and on the
158:49 - collisions layer Max let's just include
158:50 - them
158:51 - okay that's it now really all we need is
158:53 - just a physics shape and we can use
158:55 - whatever shape we want since we made the
158:57 - movement work with the colliders on the
158:59 - counters which are really boxing letters
159:01 - over here let's use the same thing let's
159:03 - also use a box collector let's actually
159:05 - go inside the player prefab so we can
159:07 - scale it and now here just a quick tip
159:10 - usually for physics and letters you want
159:11 - to make them a bit smaller than the
159:12 - visual
159:13 - usually that makes for a better
159:15 - experience for the players so up here
159:17 - this one is a bit too big so let's make
159:18 - it a bit smaller so on the X let's put
159:20 - it on 0.7 on the Y we can leave with one
159:22 - and Z of also 0.7 so it's a bit smaller
159:25 - than the actual visual now let's also
159:28 - lift it up by half of the height so
159:30 - let's put it up 1.5 so there you go it
159:32 - is exactly like that by the way
159:34 - important make sure that the collider
159:36 - essentially touching the zero on the Y
159:37 - so pure don't lift it up by more than
159:40 - half the height
159:41 - that is because at the bottom that is
159:43 - where we're finding the cast on the
159:44 - player if you lift it up by too much it
159:47 - might not hit it depending on the size
159:48 - you use
159:49 - okay so that's really it if we test it
159:52 - just like this let's just exit save the
159:53 - prefab and let's test so here I have two
159:56 - players and moving around it still
159:58 - doesn't go through the counters okay
159:59 - great now if I go into the player and
160:00 - there you go now it no longer goes
160:02 - through the players all right so that's
160:04 - great it works over here on the host and
160:06 - down here on the client same thing it
160:08 - also does not go through okay awesome
160:11 - now one more minor thing for the
160:14 - Collision detection for the player shape
160:16 - we used a caption now in most cases this
160:19 - is actually a good shape for the player
160:20 - but due to how we handle the Collision
160:22 - detection here how we handle that code
160:25 - for checking the X and Y in order to
160:26 - make it easily slide around
160:28 - this method isn't it great but it works
160:30 - best on straight colliders meaning that
160:33 - if I try to hit the player on the corner
160:35 - like this there you go and look at that
160:36 - the player is stuck I try to move
160:37 - straight down or straight to the right
160:39 - and nope it does not work basically
160:41 - that's because the caption collider that
160:43 - one has a round Edge
160:44 - so if we hit perfectly on the corner
160:46 - based on the code that we have here it
160:48 - will not slide around it will just be
160:49 - stuck
160:50 - some people mention this in the single
160:52 - player course because they made the map
160:53 - different from mine
160:55 - In My Map There's never an issue because
160:57 - there are never any corners but if you
160:59 - do have corners then you have swapping
161:00 - it out makes sense
161:02 - so one option would be we can modify the
161:04 - Collision detection code to work better
161:05 - against some Corners we could use the
161:07 - Collision normal to move or something
161:09 - like that or perhaps a similar approach
161:11 - which is refactor the code to instead of
161:13 - using a capsule cast to use a boxes that
161:16 - way we don't have any round corners
161:18 - so back in the pointer code instead of
161:20 - using a Capstone cast let's use a
161:21 - boxcast
161:22 - then just need to modify the parameters
161:25 - let's use this one version six so first
161:28 - parameter is the center so let's use
161:29 - transform the opposition okay great then
161:32 - the half extends
161:34 - for this one let's use Vector 3.1
161:36 - this is just a shorthand for writing one
161:38 - one one
161:39 - so let's do this multiply it by the
161:41 - player radius that way we have the box
161:44 - has size
161:45 - so next we have Direction so that is
161:47 - going to be the move there
161:49 - then we have the quaternion this is the
161:51 - rotation for the Box cast we don't want
161:53 - any rotation so let's just use
161:55 - quaternion.identity this essential means
161:57 - no rotation
161:59 - then we use the move distance and the
162:01 - layer mask collisions
162:02 - okay that's great so this is exactly the
162:04 - same thing so let's use the exact same
162:07 - parameters down here so we use a boxcast
162:10 - let's use the same version version six
162:12 - so we have that then for this one we
162:15 - have the vector 3.1 times the play
162:17 - radius then we move the ear x then we
162:20 - have quaternion.identity and then we
162:23 - have the other two okay great and same
162:24 - thing down here also a boxcast
162:27 - then replace the 0.2 with this one then
162:30 - we have the move there and again
162:32 - quaternion identity just like this
162:35 - again make sure you don't make any
162:36 - mistakes on the parameters
162:38 - I saw a bunch of questions in the same
162:40 - employer course because a bunch of
162:41 - people got confused over here would move
162:42 - to your ex and move to your Z so make
162:44 - sure you don't make any mistakes so
162:46 - that's it let's test this okay so here
162:49 - we are and if I touch a player from a
162:51 - corner and there you go it no longer
162:52 - gets stuck so if I go straight into a
162:54 - corner now the code does behave the same
162:56 - as we have up here on the corners so it
162:58 - goes in and it slides around either up
163:01 - down left or right all right awesome
163:04 - okay so that's it with this everything
163:06 - already works perfectly just one thing
163:08 - which is the fact that when they spawn
163:10 - they will spawn the exact same position
163:11 - so let's just make a minor change to
163:13 - make them spawn on different positions
163:15 - this is also super simple over here on
163:17 - the player script let's go down into our
163:20 - on network spawn function
163:22 - and over here to know the player name we
163:24 - can just access the owner client ID we
163:27 - can basically use this as an index in
163:28 - order to access a list to get the
163:30 - position so let's remove that just so it
163:32 - compiles so let's go up here make
163:34 - another serialized field
163:35 - a private let's make it a list of vector
163:38 - three and come with the spawn position
163:40 - list
163:42 - then back here in the editor let's
163:43 - select the player and on the player
163:45 - script let's put in four elements so for
163:48 - positions we're going to have four
163:49 - players for the first one minus two zero
163:52 - zero then plus two zero zero then minus
163:55 - two zero and minus two and plus two zero
163:58 - minus zero so we have four positions
164:00 - and over here it's pretty simple so we
164:03 - just go we just set the transform dot
164:04 - position and we go into the spawn
164:06 - position list and access it on the index
164:08 - of the owner client ID and this one is a
164:10 - yo long not an end so we can just cast
164:12 - it down to an end
164:14 - okay that really should do it so let's
164:16 - test so here connect as the host and yep
164:19 - it's on that position down here on the
164:20 - client and if there go it is on that
164:22 - position all right great now I should
164:24 - point out that this code actually causes
164:26 - an error if a player disconnects another
164:28 - one connects
164:29 - that is because the owner client ID this
164:31 - one is not really sequential but don't
164:33 - worry about that for now we're going to
164:35 - refactor this code later on when we
164:36 - handle the lobby and the character
164:38 - selection okay so here we have our
164:40 - perfect conditions between all of our
164:42 - players again like I said this is a
164:43 - design decision so it's up to you
164:45 - whether you want to keep it or disable
164:46 - it you would just go into that layer
164:48 - mask and either include or not include
164:50 - the players so that's it and with that
164:53 - we have pretty much our game commonly
164:54 - synchronized the one thing we still
164:56 - don't have synchronized is the game
164:58 - state so the countdown starting to play
165:00 - game over and so on so let's do that in
165:03 - the next lecture
165:05 - hello and welcome I'm your code monkey
165:07 - in this lecture we're going to
165:08 - synchronize the game state so that's the
165:10 - waiting game start game timer and game
165:12 - over okay so we already have quite a lot
165:15 - synchronized but one of the main things
165:17 - that is not synchronized is the game
165:18 - state in the beginning of this course we
165:20 - skipped the states just to make testing
165:22 - easier so let's get those back now let's
165:24 - go over here onto the kitchen game
165:25 - manager and let's remove the auto start
165:27 - code this debug trigger that we added
165:29 - quite a while ago so let's get rid of
165:30 - this and for the countdown timer let's
165:33 - reset this one back into 3F and that's
165:35 - it nothing else okay so let's test okay
165:38 - so it starts off and yep it is indeed
165:40 - showing the controls and as I interact
165:42 - if there you go it starts the countdown
165:44 - okay so it's back to normal except
165:46 - obviously now this one is actually
165:47 - playing the game where this one down
165:49 - here is still staring at the controls we
165:50 - want to synchronize these two Saints
165:52 - basically we want to start off by
165:54 - showing all of the players the controls
165:55 - window then as each player presses the
165:57 - interact action instead of going to the
165:59 - countdown on that player instead of that
166:01 - we want to go to another state waiting
166:03 - for all the players to be ready and then
166:04 - when and all the players are ready then
166:06 - we do start the countdown so let's do
166:08 - that over here in the kitchen game
166:10 - manager basically we need another state
166:12 - for when the player is ready and waiting
166:14 - for the rest so one option could be to
166:17 - make another state here for waiting for
166:18 - the players to be running however
166:20 - actually in a little bit we're going to
166:22 - synchronize this state across all of the
166:24 - clients in order to synchronize the
166:25 - countdown the game playing and so on so
166:27 - since we're going to synchronize the
166:29 - same state across all the clients we
166:30 - cannot have one that is different on a
166:32 - perkaline basis so instead of adding a
166:34 - brand new state right here let's just
166:35 - make a simple Boolean so a private ball
166:38 - let's call it is local player ready so
166:41 - we have this and then down here when we
166:43 - have the interact action instead of
166:44 - going straight to countdown start
166:45 - instead of this one what you said is
166:47 - local Point ready into true okay so now
166:50 - we want to hide the tutorial when this
166:51 - player is running so for that let's
166:53 - basically fire off an event and then
166:55 - expose this Boolean so first of all
166:57 - let's expose this bullion let's go down
166:59 - here and make a public boom is local
167:02 - player ready and we just returned the
167:05 - islow complete ready okay so we returned
167:07 - this and then up here let's make an
167:09 - event so a public event event handler
167:12 - let's call it on local player ready
167:15 - changed and then down here when we have
167:18 - our input over here let's invoke this
167:20 - event okay so we have this event now
167:23 - let's go over here onto the Eternal UI
167:25 - script and previously we were listening
167:27 - on the state change and we were only
167:29 - hiding the controls when the countdown
167:30 - was active now we don't want this one so
167:32 - let's go into the kitchen game manager
167:34 - instance and this time see on local
167:36 - Ready Player change so let's just rename
167:39 - this to the kitchen game manager okay we
167:42 - have this function and then over here if
167:45 - let's go into the kitchen game manager
167:46 - the instance and let's test if the
167:48 - unlockable player is ready if so then
167:50 - let's hide this and we know we'll do
167:52 - anything on the state changed okay yep
167:55 - just like this and now by the way some
167:57 - of you might be thinking if we have this
167:59 - event why do we need to test for the
168:01 - bullying couldn't we just hide it when
168:02 - we get the event regardless of any
168:04 - bullying and yet that would indeed work
168:06 - the only reason I did it this way is
168:08 - just in case you want to add the ability
168:09 - for the player to unwrite themselves in
168:11 - this case I made it stay stuck and ready
168:13 - but you could easily modify this to let
168:15 - the player go back by combining the
168:17 - event in the Boolean you can easily add
168:18 - that feature okay so with this the
168:20 - tutorial UI should hide now we just need
168:23 - some visual to tell the player that they
168:24 - are waiting for the others so back in
168:26 - the editor let's go inside the canvas
168:28 - and let's start off by duplicating the
168:30 - external UI so let's duplicate this and
168:33 - let's zoom in the camera put it into D
168:35 - and go in there okay for this one let's
168:37 - call this the waiting for other players
168:39 - UI and let's put it on the same sorting
168:41 - order so just under the tutorial UI okay
168:44 - like that and over here we basically
168:46 - just want some text so let's just keep
168:47 - the same background and get rid of all
168:49 - these objects and instead let's create a
168:52 - new UI text and for the text let's say
168:54 - waiting for players let's put it in bond
168:58 - let's put that one put it on overflow
169:01 - down the center let's put it in black
169:03 - and lift it up a little bit okay so very
169:05 - simple window now let's make this quick
169:07 - to run this so with the exact same name
169:09 - so let's go into our UI folder and let's
169:12 - create the Brandy c-sharp script waiting
169:13 - for players UI then on the game object
169:16 - let's not forget to get rid of the own
169:18 - Eternal UI instead let's add this one so
169:20 - waiting for other players UI and let's
169:22 - open this script and over here let's
169:24 - begin by making the usual show and
169:25 - height functions so private void show
169:27 - and then a private Droid hide
169:30 - and over here game objects and active
169:32 - into phones so the same thing we've
169:33 - already done so many times okay so we
169:36 - have this now let's listen to the unlock
169:37 - on play Red event so let's make a
169:39 - private start go into the kitchen game
169:41 - manager and let's listen to the on local
169:43 - Ready Player change
169:45 - let's just rename this to give it a
169:47 - proper name okay so we have this one
169:50 - then let's do the same thing so the
169:52 - instance is the local play ready if so
169:55 - then let's show okay so that handles the
169:57 - showing which by the way over here on
169:59 - start we listen to the event then we
170:01 - hide it okay so it will start off hidden
170:03 - by default and then show when the player
170:04 - is ready then we need to know when to
170:06 - hide it and that is going to be when the
170:08 - countdown actually starts so let's also
170:10 - go into the kitchen game manager
170:11 - instance and let's subscribe to the on
170:13 - stay changed event so let's go kitchen
170:16 - game manager okay so we have this event
170:19 - so when the state changes let's test if
170:21 - the instance if the event is on the
170:23 - countdown to start active so if the
170:26 - countdown is active then let's hide this
170:27 - window okay so that's it pretty simple
170:30 - let's do a quick test so here we are and
170:33 - both of them are looking at the controls
170:34 - now press interact and there you go
170:35 - instead of starting the countdown now it
170:37 - is waiting for players same thing down
170:39 - here interact and waiting for players
170:40 - okay so far so good now we basically
170:43 - just need to check if all the player
170:45 - States if all of them are ready in order
170:46 - to know when to start the game now there
170:48 - are actually many ways we can do this
170:49 - but recently we just need to synchronize
170:51 - a simple Boolean to know when a player
170:53 - is ready the only tricky part about this
170:55 - is it depends on how you want to handle
170:57 - the number of players so do you want the
170:59 - game to forcefully only work with 4
171:00 - players or maybe two or make it work
171:02 - with any number that's another design
171:04 - question that will impact what data type
171:06 - you use so over here and let's make it
171:08 - work with any player mount back in the
171:10 - kitchen game manager script over here
171:12 - let's use a dictionary that way we can
171:14 - support any number of players and also
171:16 - the reason for using a dictionary
171:18 - instead of a list is because the player
171:19 - calling Teddy is not necessarily
171:21 - sequential for example if one player
171:23 - connects and then disconnects it will
171:25 - not reuse that ID so if in the end you
171:27 - end up with four players connected it is
171:29 - not guaranteed they won't have ID 0
171:31 - through 3. so because of that a
171:33 - dictionary using a client ID for the key
171:35 - that one is a much better approach than
171:37 - using a network list okay so let's build
171:39 - our dictionary so a private a dictionary
171:42 - for the key and let's use Yong long
171:44 - which is the time for the client IDs and
171:46 - for them let's use a simple Boolean so
171:49 - let's call this one the player ready
171:51 - dictionary
171:52 - okay so we have this and over here on
171:55 - the Wake let's initialize our dictionary
171:57 - so by default all of the keys with all
171:59 - the possible client IDs they're all
172:01 - going to be unset then down here when we
172:04 - have the interact action when we set
172:05 - this player to ready over here let's
172:07 - tell the server that this player is
172:09 - ready so for that as usual let's make a
172:11 - server IPC so a private void let's call
172:14 - it set player ready server RPC
172:17 - and as usual mark this as a server RPC
172:20 - with require ownership as phones okay
172:23 - and now in order for the server RPC to
172:25 - work we need to make sure to mark this
172:26 - one not as a mono Behavior but as a
172:28 - network Behavior okay great so we have
172:30 - our server IPC we just need to also go
172:33 - back here in the editor let's select the
172:34 - kitchen game manager and yep let's set
172:37 - the network object component okay great
172:38 - so now here on this function basically
172:40 - the server needs to know which player is
172:42 - ready so technically up here when we
172:45 - call this function to set its player as
172:47 - ready when we call this function we
172:49 - could pass in the owner client ID this
172:51 - is going to contain the client ID of the
172:53 - player that set the ready so this could
172:55 - work but on the empty docs themselves
172:57 - they don't encourage us the reason is
172:59 - because technically a hacker could fake
173:00 - their client ID and possibly break
173:02 - everything now in this simple Co-op game
173:04 - we're really not worried about hackers
173:06 - but still let's do it the proper way so
173:09 - instead of having the clients and its
173:11 - own owner client ID instead of that
173:14 - let's go down here into the server RPC
173:16 - and let's add a parameter of type server
173:19 - RPC params this is a built-in type part
173:21 - of Neko for game objects so let's
173:23 - receive this one as a printer and let's
173:25 - just default it meaning that up here we
173:27 - don't need to pass in anything it gets
173:29 - defaulted then now here when we're on
173:31 - the server side we can access the server
173:34 - RPC params and inside we've got a
173:36 - receive and Ascend so in this case the
173:38 - server is receiving the server PC so
173:41 - let's go inside the receive and over
173:42 - here we have the sender client ID this
173:45 - is going to be the ID of who sent this
173:47 - server RPC we can do a quick unlock just
173:49 - to verify so let's see we debug the
173:51 - unlock on This Server client ID so let's
173:53 - see okay so up here on the host if I
173:56 - press a button if there go the host sent
173:58 - the sender client ID which is zero and
174:00 - now down here if I interact that one
174:02 - should say one which should be default
174:04 - client ID for this one so interact and
174:06 - there you go got one
174:07 - okay great so with this we know which
174:10 - player set already now to sort that that
174:12 - is really super simple
174:13 - let's just go inside our player ready
174:15 - dictionary and let's access it on this
174:18 - key the key of this sender client ID and
174:20 - let you set this to true so this will
174:22 - set the play ready for this length I
174:24 - need then we just need a basic Loop to
174:26 - check if they are already so let's do a
174:28 - four inch to cycle through all the
174:30 - clients so you long for the client ID
174:32 - and let's do a for each inside the
174:35 - network manager let's go inside the
174:37 - Singleton and let's cycle through the
174:40 - connected client IDs so this won't go
174:42 - through every single client ID then over
174:44 - here let's do a basic test to see if
174:46 - this length ID is not ready
174:48 - so if and there are two ways that it can
174:51 - be not ready so it can either have
174:53 - phones on that key or you can simply not
174:55 - have that key at all so let's go into
174:57 - the playwritten dictionary and let's
174:58 - test contains the key of this client ID
175:01 - so if it does not contain that key then
175:03 - this one is unready
175:06 - or it does contain that key but that key
175:08 - is false so on the client ID is false
175:11 - so if it is like this then this player
175:13 - is not ready so to check if they are
175:16 - already up here and let's first Define a
175:18 - Boolean let's say all clients ready and
175:21 - let's defaulted to true and over here if
175:23 - just one of them is not ready then we
175:25 - set this one to false and let's break
175:27 - out of the cycle okay so then down here
175:29 - now we know if all the coins are ready
175:31 - so let's do a debug the homework just
175:32 - see this so all clients ready
175:36 - and let's print the alt lines ready next
175:38 - one over here I forgot the nut so if it
175:41 - does not contain this key or this one is
175:43 - not ready then this one is not ready
175:45 - okay so with this one says okay so here
175:48 - we are with the host and the client now
175:50 - from the hostess I set it as ready and
175:52 - if there go online ready is phones
175:55 - because only the host is ready but now
175:57 - down here if I already on this one and
175:58 - if they go all coins are indeed ready
176:00 - alright awesome so with this all that's
176:03 - left is really to start the countdown
176:04 - and for doing that we have two options
176:07 - we can use a client RPC to tell all the
176:09 - clients to go to the next state that's
176:11 - one option however that wouldn't be very
176:13 - good basically we would end up with each
176:15 - client having their own local state
176:17 - technically that could work but I think
176:19 - it makes more sense for the say to be
176:20 - synchronized just once for the home game
176:22 - so instead of synchronizing both the
176:24 - state as well as the timers instead of
176:26 - doing that through client rpcs I think
176:28 - it makes more sense to use Network
176:29 - variables so let's do just that first
176:31 - let's go here on the state let's make
176:34 - this a network variable and and because
176:36 - state is an enum we can just make a
176:38 - dragon like this so let's make a new
176:40 - state and for the default instead of
176:42 - defaulting it down here on the way let's
176:43 - see if under appears so default on
176:44 - waiting to start
176:46 - okay we do that instead okay now let's
176:49 - fix the remaining errors so over here
176:51 - when we have the input let's get the
176:53 - state.value okay and then down here on
176:55 - the update for this update this logic is
176:58 - only going to run the server so it says
176:59 - if not is server if this one is running
177:02 - not on the server let's return so we
177:04 - don't want to do anything outside the
177:05 - server then we do a switch on the
177:07 - state.value we do a bunch of things then
177:10 - we modify the state.value and over here
177:12 - modify the state.value okay let's see
177:15 - some more errors over here all of them
177:17 - pretty much the same thing we just have
177:18 - to access the value in order to fix all
177:21 - this okay so that's almost all the
177:23 - errors now an important thing is since
177:25 - over here on the update we made it so
177:27 - that only the server runs this code just
177:29 - like this only the server is going too
177:31 - far off these events we need to modify
177:33 - where we are firing this since we also
177:35 - want the clients to listen to these
177:36 - events so let's listen when the network
177:39 - variable changes so let's go up here and
177:42 - as usual let's first of all make an
177:43 - override for the on network spawn
177:46 - so we have this one and then let's go
177:48 - into that one so that's the state so
177:51 - state DOT on value change let's make a
177:53 - function called State on value changed
177:56 - and let's use Visual Studio over here to
177:58 - Auto generate the function okay so here
178:00 - it is with the previous value and the
178:01 - new value and when the value changes
178:04 - when the state changes then we fire off
178:05 - this same event so just like this and
178:08 - get rid of all of these instances yep
178:10 - only this one just like this okay so
178:13 - modify the network variable and all the
178:14 - clients are going to listen to this
178:16 - event which in turn fires off this local
178:17 - event so just like this all of the
178:20 - clients should have all these states
178:21 - synchronized now we can go down here to
178:24 - when we are sending deploy ready
178:26 - so if all the clients are ready if so
178:29 - let's modify the state.value and let's
178:31 - begin the countdown so let's go into not
178:33 - waiting to start but into the countdown
178:35 - to start
178:36 - okay so just like this it should work so
178:38 - it says so here we are and on the host
178:40 - I'm going to set as ready and there you
178:42 - go it's waiting for players now down
178:44 - here I'm going to press and it should
178:46 - start the countdown so let's press and
178:48 - there you go all of them are ready and
178:49 - we've got our nice countdown okay so
178:52 - that's great however if you notice down
178:54 - here the client down was stuck on the
178:56 - countdown timer of three and we also
178:58 - noticed that the timer over here is not
178:59 - being synchronized with that one so
179:01 - let's synchronize both these as well
179:02 - basically we have the countdown timer
179:04 - and the game playing timer we need to
179:06 - synchronize both these so let's make
179:07 - them as Network variables
179:10 - so this is one and this one is another
179:12 - one for the countdown timer let's do a
179:15 - new let's start off on 3F and for this
179:18 - one do a new and start off on zeroth
179:21 - okay now let's clean up all of these
179:23 - errors so let's see down here this is
179:25 - the server code so let's just do value
179:27 - in order to test that one
179:28 - and same thing for here and same thing
179:31 - on this one pretty much just have to
179:32 - modify to access the value like that and
179:35 - down here to get the countdown timer get
179:37 - the value and over here same thing get
179:40 - the value okay so that fixes all the
179:42 - errors and let's also go up here in
179:44 - order to also test out the game over
179:46 - State let's go for the game playing
179:48 - timer Max let's put this one just
179:49 - antenna just for testing okay so let's
179:51 - test all right so up here let's connect
179:54 - the host then on all of these let's make
179:56 - them coins okay great now if I ready
179:58 - let's say on this one if I ready you
180:00 - better go waiting for players now you're
180:02 - going to this one ready yep still
180:03 - waiting for players now I go into this
180:06 - one ready and yep still waiting they're
180:07 - on waiting for the last one and as I
180:09 - ready this one yep it started playing
180:11 - the countdown the countdown timers are
180:12 - all synchronized and the game starts yep
180:15 - and over there we can see the timers yep
180:16 - those are also being synchronized and as
180:19 - soon as they reach the end let's see if
180:20 - they all synchronize the game over Saint
180:22 - as soon as they reach yep there you go
180:24 - we have the game over all right awesome
180:26 - okay so here we synchronize the main
180:29 - game State waiting for all the players
180:31 - to be ready synchronizing the countdown
180:33 - timer the game timer and finally the
180:34 - game over now just one more thing
180:36 - there's a minor bug that only noticed
180:38 - right now if instead of setting ready
180:40 - first on the host if we set it first
180:42 - over here on the client and then set it
180:44 - as ready on the host if there go this
180:46 - one say stuck on the wedding for players
180:47 - so let's fix this this is a super simple
180:50 - fix basically the issue is that when
180:52 - this event is fired that's when that
180:54 - window becomes active but when we set
180:56 - the player ready server RPC that one if
180:59 - only coins are ready is going to trigger
181:00 - this start countdown so basically when
181:02 - this one happens that window hides
181:04 - itself but then this code runs and that
181:05 - window shows itself so just a minor
181:07 - issue and The Simple Solution is just
181:09 - make sure to fire the event before we
181:10 - set the server RPC to send the ready so
181:12 - if you didn't like this now here on the
181:15 - client let's go ready on the host
181:16 - already any up there you go everything
181:17 - works okay great now before we end this
181:19 - lecture let's just go over here to the
181:21 - game playing timer Max and let's reset
181:23 - this back to the normal value of 90
181:24 - seconds okay so with that the game State
181:27 - The Zone working perfectly one thing we
181:29 - still don't have synchronize is the
181:30 - pause date so let's do that in the next
181:32 - lecture
181:34 - hello and welcome I'm your code monkey
181:36 - in this lecture we're going to
181:37 - synchronize the pause state
181:39 - so here we have our game where we
181:41 - already have tons of stuff already
181:43 - perfectly synchronized however if I
181:45 - pause the game on this one and if there
181:47 - go now this one is not playing and
181:49 - everything still works and if instead of
181:51 - pausing on the server if now I pause
181:53 - over here on the client so the client is
181:55 - paused with the server is still moving
181:56 - and we can see over there the countdown
181:57 - timer is still moving so we need to sort
182:00 - this out some way and for the pause
182:02 - multiplayer games can handle it in
182:04 - different ways the simplest option is
182:06 - simply to not allow pausing at all
182:08 - adding that ability is super easy we're
182:11 - handling the pause over here on the
182:12 - kitchen game measure so we have over
182:16 - here we have a toggle pause game and
182:18 - when we pause we set the time scale to
182:20 - zero and when unpause set it back to one
182:22 - so the simple option to not allow
182:24 - pausing to modify the M state would be
182:26 - just to not do this so we don't modify
182:28 - the time scale that's the simplest
182:29 - option with that basically the local
182:31 - player can check the settings and so on
182:33 - but for everyone else the game will keep
182:35 - playing just the same so this is the
182:37 - simplest option that a lot of games
182:38 - implement the main reason for that is
182:40 - usually to keep things Fair if you have
182:42 - for example a shooter game you don't
182:44 - want one player to pause just as the
182:46 - other player is winning so in those
182:47 - games pause usually doesn't happen but
182:49 - on a co-op game like the one we have
182:51 - here usually you do want to allow
182:53 - pausing just because it's a useful
182:54 - feature to have and in Co-op it's not
182:56 - much of a problem as it is in PvP games
182:59 - so let's go back to our code and let's
183:01 - also Implement some simple power syncing
183:03 - meaning that any player can pause the
183:05 - game and the other players will need to
183:07 - wait for the game to be unpaused how we
183:09 - do this is actually pretty simple
183:11 - we're going to do pretty much exactly
183:12 - the same thing that we did for the
183:13 - player radian logic we're going to have
183:15 - a dictionary if one of the players are
183:17 - unpaused the game is going to unpause
183:19 - and if at least one of them is paused
183:21 - then the entire game for all the clients
183:22 - will be paused so first of all we need
183:25 - to tell the server if you want to pause
183:26 - so let's use a server RPC so a private
183:29 - world let's call it pause game server
183:31 - RPC
183:32 - this one will be a server RPC with
183:35 - require ownership as phones okay
183:38 - then just like we did with the ready the
183:40 - server needs to know which client paused
183:42 - the game so let's receive the server RPC
183:44 - params and as usual let's put it as
183:47 - default okay so we have a pause function
183:49 - and we're going to have another one
183:50 - pretty much exactly the same for the UN
183:52 - pause
183:54 - okay we have these two and up here when
183:56 - we do this let's trigger a pause and
183:59 - Trigger the unpause
184:02 - so now for starting the prostate let's
184:04 - use the dictionary just like we saw so
184:05 - let's go up here and let's make another
184:07 - dictionary it's going to be exactly the
184:09 - same so we're also going to have a young
184:10 - long for the client ID and then a volume
184:11 - for is player paused or unpause so let's
184:14 - call this the player pause dictionary
184:17 - and let's initialize it so up here let's
184:20 - do a new dictionary okay so we have this
184:23 - and then down here pretty much the exact
184:25 - same thing so let's go into the
184:26 - dictionary let's use the server RPC
184:28 - params on the receive let's grab the
184:31 - sound sender client ID
184:33 - and for pause let's set this one to true
184:35 - so this one is paused and this one won't
184:37 - be unpaused okay so with this now the
184:39 - server knows which players are paused
184:41 - and which are unpaused then let's make a
184:43 - function to see if any of them are
184:45 - paused so let's make a product Droid
184:47 - call it test game pause state
184:50 - and over here let's cycle through all
184:52 - the client ID so let's do the usual for
184:54 - each you'll own for the client ID
184:57 - in and let's go into the network manager
185:00 - let's go into Singleton and let's grab
185:03 - the list of client connected client IDs
185:06 - so we have this now let's see if any
185:08 - player is paused so if the player pause
185:11 - dictionary contains a key with this
185:13 - client ID
185:15 - so faraziki and the player pause
185:17 - dictionary on this client any
185:19 - if that one is true that means this
185:21 - player is currently paused so this
185:23 - player is paused if so then we're going
185:26 - to want to pause the entire game and if
185:28 - we get down here so we do that and then
185:30 - let's return we don't need to go through
185:32 - the 4H anymore and if we do get down
185:34 - here then at least all the players are
185:36 - unpaused so all players are unpaused and
185:39 - of course we're going to run this
185:40 - function after we set one of these so
185:43 - after a player pauses or unpauses we run
185:45 - this code to test if the entire game
185:47 - should be paused or unpaused so now
185:49 - let's leave this to tell the clients to
185:51 - either pause or unpause their game we
185:53 - can do that either with a client or PC
185:55 - or we can use a network variable for
185:57 - this one let's use a network variable so
185:59 - up here let's go and we have the is game
186:02 - paused let's rename this to be more
186:03 - accurate this one refers to the unlock
186:05 - comp player so let's rename this and
186:08 - instead let's name it is local game post
186:10 - and then we're going to have a network
186:12 - variable for the actual Network set so
186:14 - private Network variable of type bone
186:17 - for is game pause
186:19 - so we have this one and start off as
186:22 - phones so the game starts off on pause
186:25 - then we can go down here into the
186:26 - function testing the percent so at least
186:29 - one of them is paused let's go into this
186:31 - one that value and set it to true and if
186:33 - all of them are unpaused let's set this
186:34 - one into false okay so that's really it
186:37 - now we can listen to the event when this
186:38 - network variable changes so let's go up
186:41 - here to our on network spawned let's go
186:43 - these game paused and let's listen to
186:45 - the on value change so is game pause on
186:48 - value change and let's use Visual Studio
186:51 - to write out this function
186:53 - so here it is okay now when this one
186:56 - changes now here we can set the actual
186:57 - time scale so if is gamepause dot value
187:01 - so if the game is pause let's set the
187:03 - time dot time scale into zero f because
187:06 - the game is paused and if not let's set
187:09 - the time.time scale into one app okay so
187:12 - with this the pause State and the time
187:13 - scale won't be synchronized across all
187:15 - the clients let's just go down here
187:16 - because we don't want to make sure to
187:17 - modify that somewhere else so down here
187:20 - let's get rid of the time scale and this
187:21 - time scale now for these events we're
187:24 - using these events in order to show the
187:26 - pause window so these are still useful
187:28 - let's just rename them to make them a
187:30 - bit more accurate these are only going
187:32 - to be fired based on the unlock on pause
187:34 - date so let's rename this to on local
187:36 - game pause and this one on local game
187:39 - unpaused now let's rename also The
187:42 - Listener functions so it's over here on
187:44 - the game plus UI so we have these
187:46 - functions let's rename them quickly so
187:49 - on local game pause and over here for
187:52 - this one on local game unpause
187:55 - okay so just like this the game pause
187:57 - window should be working correctly so
187:59 - the unlock on pause should be working
188:01 - with a nice visual but we also want the
188:03 - visual to reflect the synchronized State
188:05 - we need something to say that it is
188:07 - waiting for all of the players to
188:08 - unpause
188:09 - so back in the editor let's go inside
188:11 - the canvas and let's begin by
188:13 - duplicating the game pause UI so let's
188:15 - duplicate this one let's name this the
188:17 - pause multiplayer UI
188:19 - then inside let's keep the background
188:22 - keep the pause tags just get rid of
188:24 - these buttons and for the pause text
188:26 - let's just say waiting for all players
188:29 - to unpause
188:31 - let's put it a little bit smaller okay
188:33 - so like this then for the soaring order
188:36 - let's put this one behind the game pause
188:37 - so let's put it right above there okay
188:39 - great now let's make sure to remember to
188:42 - get rid of the script and we're going to
188:43 - make a script to run this so let's go
188:46 - into our scripts create a brand new one
188:47 - with the same name so pause multiplier
188:49 - UI
188:50 - and let's attach a script so the pause
188:52 - multiplier UI and let's open
188:54 - here let's begin making the usual show
188:56 - height function so proud void show
188:58 - and they approach void hide
189:01 - and game objects at active either into
189:04 - false or up here into true okay
189:07 - now we need to know when to show this
189:09 - one so we need to know when the global
189:10 - game state is paused so back here on the
189:13 - kitchen game manager let's just make
189:14 - some more events
189:19 - let's call it on multiplayer game pause
189:23 - and on multiplayer game unpause so we
189:26 - have these two events and for these
189:28 - we're going to fire them when the
189:29 - network variable changes so over here is
189:31 - game pause on value change
189:33 - so on this one invoke so this one is
189:35 - going to be paused
189:38 - and on this one it is going to be on
189:40 - pause so the on multiplayer game
189:42 - unpaused okay so we have these two
189:44 - events and now back in the script let's
189:46 - just listen to them as usual so make a
189:48 - proud void start don't start go into the
189:50 - kitchen game manager and listen to the
189:52 - on multiplayer game paused and unpause
189:55 - let's just rename this to give it a
189:57 - proper name so kitchen game manager
190:00 - and then the other one so same thing on
190:03 - the instance on the multiplayer game
190:05 - unpause
190:07 - let's rename this one as usual
190:11 - okay we have our two events so when the
190:13 - multiplayer game is paused let's show
190:15 - and when it is unpaused let's hide and
190:18 - on start after win listen let's hide
190:21 - okay so that's it pretty simple Let's
190:23 - test okay so here we are I have the
190:26 - hosts and two clients now if I pause in
190:28 - the host if there go all of these are
190:30 - waiting for on players to unpause and if
190:32 - I unpause on the host if there you go
190:34 - the game is back to normal now if I
190:36 - pause on this one yep there you go the
190:37 - game is indeed paused and we can see
190:39 - over there the timer is now counting
190:41 - down so yep everything is indeed paused
190:42 - and if I try moving also doesn't happen
190:44 - because the game is paused now let's go
190:47 - into this other one and let's pause this
190:49 - one
190:49 - so now two of them are paused now up
190:51 - here if I unpause this one if there goes
190:54 - still waiting until I go down here I
190:56 - unpause and you have to go everything
190:57 - back to normal the timers are running
190:58 - everything is working all right awesome
191:01 - okay so here we implemented some nice
191:03 - pause syncing this way our Co-op game is
191:06 - very friendly to people who might have
191:07 - to pause an online game for any reason
191:09 - now one scenario would still haven't
191:11 - handled is what happens when a client
191:13 - disconnects so I sort that out in the
191:15 - next lecture
191:17 - hello and welcome I'm your code monkey
191:19 - in this lecture we're going to handle
191:21 - player disconnects and this is actually
191:23 - going to be super simple okay so our
191:25 - multiplayer game is really coming along
191:26 - now in single player we don't really
191:29 - need to worry about the player randomly
191:30 - quitting but in multiplayer we need to
191:32 - make sure that the game actually keeps
191:34 - working correctly if a player does
191:35 - decide to leave so for example if down
191:37 - here on this client if I just close this
191:39 - window and right away we can see that it
191:41 - does work very well so the player object
191:43 - was removed from the world so it looks
191:45 - like it already Works basically when the
191:47 - player disconnects all of the network
191:48 - objects that player own are destroyed
191:50 - with them so the player prefab is
191:52 - destroyed automatically really the only
191:54 - issue we have is if that player is
191:55 - holding something
191:57 - so if down here on this player I just
191:59 - pick up some meat and now I quit and if
192:01 - there you go now we have some meat
192:02 - holding along in midair that's the issue
192:05 - that we have to solve the player object
192:07 - is destroyed automatically but we need
192:08 - to make sure to manually destroy the
192:09 - kitchen object the player is holding so
192:11 - for that let's go here on to the player
192:13 - script and first we need to know when a
192:15 - player disconnects and for that we can
192:17 - access a comeback so let's go over here
192:19 - onto the on networks Bond and we're
192:22 - going to go into the network manager
192:23 - next to see Singleton and over here
192:25 - we've got a comeback on claim disconnect
192:27 - compact so let's listen to this one
192:30 - let's rename this to network manager on
192:34 - client disconnect come back okay great
192:36 - and for the you along over here this is
192:38 - going to be the client ID so the client
192:40 - ID of the client that was disconnected
192:42 - and we can see over here on the
192:44 - documentation this comeback will be ran
192:46 - both on the server and on the local
192:48 - client that disconnects now in this case
192:50 - for the client that disconnects we don't
192:52 - really want to worry about them so we
192:53 - really just want to listen to this on
192:55 - the server so we can just add here if is
192:57 - server and if so we're going to listen
193:00 - to this
193:01 - also remember that the is server here
193:03 - this one refers to the state of this
193:04 - build and not this specific player so
193:07 - this one will still touch on listener on
193:09 - the server side even on players that
193:10 - aren't actually the host okay so with
193:12 - this comeback now the server knows when
193:14 - a player disconnects with the client ID
193:16 - that we have here we can check if this
193:18 - is the one that was disconnected so
193:20 - let's check if this client ID so the one
193:22 - that disconnected does match the owner
193:24 - client ID
193:26 - so if so then it was this one then next
193:28 - thing we want is to check if this player
193:30 - is holding any catch an object so if it
193:32 - is this one and has kitchen object if so
193:35 - then we want to destroy it so as usual
193:37 - let's use the kitchen object and destroy
193:39 - the kitchen object and pass in this dot
193:42 - kitchen object we can only destroy the
193:44 - server but over here we already attach
193:45 - The Listener only on the server so yep
193:47 - this should be working okay so just like
193:49 - this let's test okay so here with the
193:52 - client let's pick up something and now
193:53 - let's quit on the client and if there
193:55 - you go the object is indeed destroyed
193:56 - alright awesome so just with this we
193:59 - already have the entire game logic
194:00 - working perfectly with disconnects
194:02 - there's nothing else the player can do
194:03 - that could affect the gameplay itself if
194:05 - they disconnect in the middle of cutting
194:07 - or frying an object that doesn't cause
194:08 - any issues the one thing that can cause
194:10 - issues is if they pause the game and
194:12 - then disconnect so here are both and
194:14 - down here on the client I'm going to
194:16 - pause the game and then I'm going to
194:17 - quit and if there go this one did clean
194:19 - up the player but now this one is stuck
194:21 - waiting for unpause now thankfully the
194:23 - way that we handle the power
194:24 - synchronization we made it over here
194:26 - here by cycling through the network
194:27 - manager connected client IDs meaning
194:29 - this is actually only going to test the
194:31 - state for the external connected clients
194:32 - so because of that this here isn't
194:34 - actually a game breaking bug if on this
194:36 - remaining client I just pause and
194:37 - unpause and you better go another player
194:39 - now the game is back to normal but
194:41 - obviously it should automatically
194:42 - unpause if the only pause player quits
194:44 - so let's fix that this is also going to
194:46 - be a pretty simple fix so let's go over
194:48 - here onto the kitchen game manager this
194:50 - is the class where we're handling of the
194:52 - pausing so on this one just like we did
194:54 - on the other one let's listen to the
194:55 - disconnect comeback so we're here on the
194:57 - onet respond let's check if is server so
195:00 - on the server let's listen to it so
195:02 - network manager the Singleton on
195:05 - disconnect convex and let's listen to it
195:07 - and as usual rename this keep things
195:09 - clean so network manager okay so we
195:12 - don't listen to this and over here for
195:14 - the parameter this is the client ID
195:16 - although right now we really don't need
195:18 - the client ID because afterwards we
195:20 - really just need to run the function
195:21 - test The Game Pass State this will then
195:23 - test all of the clients and see if any
195:25 - of them are dollars and if the one that
195:27 - disconnected was the only one that was
195:28 - paused and this one will unpause the
195:29 - game however this won't actually work
195:31 - the reason is because when this comeback
195:34 - is fired when this happens the client is
195:36 - still going to be on the connecting list
195:37 - so if it Cycles through this it's still
195:39 - going to cycle through the client that
195:41 - is just disconnecting so basically to
195:43 - solve this we need to wait one frame to
195:44 - make sure that this list is updated so
195:47 - it's basically making a Boolean and then
195:48 - after that update then we're going to
195:50 - run this function so up here let's make
195:52 - a private bone call it auto test game
195:55 - pause State we're going to test that
195:57 - automatically so then when we have our
196:00 - disconnect let's set this one into true
196:02 - and over here we are not going to run
196:04 - this function all right then let's go
196:06 - down and we're going to make late update
196:08 - so let's go over here a private void
196:11 - late update and on late update let's
196:14 - check if this one is true if so then
196:16 - first of all let's set it to phones and
196:18 - over here we run the test Game Pass
196:19 - State okay so like this it should work
196:21 - so let's test okay so here we are and on
196:24 - the client down here let's pause and now
196:25 - let's quit and if there you go that One
196:27 - automatically unpauses and everything
196:29 - works okay great
196:31 - so the pause disconnect logic is working
196:33 - now let's see basically the opposite
196:35 - which is what happens if the host quits
196:37 - so with the host appear and the client
196:40 - down there if on the host I stop playing
196:41 - and if they're going like that
196:43 - everything shuts down all the players
196:45 - get destroyed the network manager
196:47 - automatically stops running so in terms
196:49 - of logic it already works so the game
196:50 - definitely stopped working but obviously
196:52 - there's no visual for the players so
196:54 - let's make one let's go inside our
196:56 - canvas and over here let's begin by
196:58 - duplicating the game over UI let's name
197:00 - this one the host disconnect UI and
197:04 - let's put it on the Sorting just before
197:05 - the game pause UI so just like that okay
197:07 - then over here for the text let's rename
197:11 - this to just say text and inside let's
197:14 - just say host has disconnected
197:17 - let's put it a little bit smaller move
197:20 - it a little bit down and we don't need
197:21 - these other ones so let's get rid of
197:23 - these two just like that and we can
197:25 - leave the play again button okay now
197:26 - let's make the script to run this so
197:28 - with the same name let's go ahead create
197:29 - a brand new c-sharp script for the host
197:32 - disconnect UI over here let's get rid of
197:34 - the game over UI and had the host
197:36 - disconnect UI okay let's open now on
197:38 - this one let's first of all add the
197:40 - reference to the button
197:41 - so a serialized filmed private button
197:44 - for the play again button okay like this
197:48 - back in the editor let's drag that
197:50 - reference on right so now let's make the
197:52 - usual show and height functions so
197:53 - private void show and a proud void hide
197:57 - just set game object
198:00 - set active into false and over here into
198:03 - true okay we have our functions then for
198:06 - showing it we need to know when the host
198:08 - has shut down and for that we can
198:10 - actually listen to the same callback so
198:12 - let's make a private void start on start
198:14 - let's go into the network manager the
198:16 - Singleton and let's listen to the on
198:18 - disconnect comeback so let's add a
198:20 - listener to this one
198:22 - network manager okay
198:24 - so we have this one and again over here
198:26 - we have the client ID and now to know if
198:28 - the server was the one that shut down
198:31 - we can basically just compare this
198:32 - client ID to the server ID
198:34 - so let's check if this client ID equals
198:37 - the one on the network manager dot
198:40 - server client ID this is a constant the
198:43 - server is always on ID of zero so let's
198:45 - do this
198:46 - so if it is then this means the server
198:48 - is shutting down
198:50 - and if so then let's show this window
198:51 - and on start let's start off hidden okay
198:54 - that's it a simple script okay so up
198:57 - here is the host and the client and if
198:59 - on the host I quit and if there go host
199:01 - has disconnected all right awesome so
199:04 - with this we have handled pretty much
199:05 - every single possible scenario except
199:07 - perhaps the more obvious one which is
199:09 - enabling the player to minimally quit
199:11 - out of the game right now if I'm here in
199:13 - the editor let's say I start off as a
199:14 - host then I go into the pause menu and
199:17 - go back into the main menu yep here I am
199:19 - in main menu and if I look in the
199:20 - hierarchy you have the network manager
199:22 - yep it is still running we still have an
199:24 - active connection obviously we don't
199:26 - want this to happen
199:27 - so let's go over here onto the Game Pass
199:29 - UI and this is where we have the main
199:31 - menu button so we unload the main menu
199:32 - scene but before we do that let's go
199:35 - into the network manager the Singleton
199:37 - and let's call the shutdown function so
199:39 - this is going to shut down our
199:40 - connection
199:41 - really we just need to do this in every
199:43 - place where we hit the game so that's
199:45 - over here on the game plus UI and the
199:47 - other one is over here on the game over
199:49 - rewind so we unload the main menu and
199:51 - before we do that let's shut down the
199:52 - network manager okay so let's test here
199:55 - we are let's host and let's go back into
199:58 - the main menu any up in the inspector we
200:00 - can see network manager no longer has an
200:01 - active connection alright awesome so
200:04 - here we have hand on every single
200:06 - disconnect scenario the players can
200:07 - disconnect and the server handles
200:09 - everything gracefully so now that the
200:11 - disconnects are working let's think
200:13 - about the opposite which is what do we
200:15 - do to handle client rejoins let's talk
200:17 - about that in the next lecture
200:21 - hello and welcome I'm your code monkey
200:23 - in this lecture we're going to talk a
200:25 - little bit about the concept of late
200:27 - player joins okay so here's our game
200:29 - which is actually pretty small each
200:31 - session of this game is only a few
200:33 - minutes long so because of that we're
200:35 - not going to allow light joints doing so
200:37 - adds quite a bit of complexity so for a
200:40 - game like this one we're going to make
200:41 - it so that everyone joins in the very
200:43 - beginning and they all play until the
200:44 - very end if someone drops in Middle they
200:47 - can simply just restart the session but
200:49 - still I want to talk about the topic of
200:51 - light training because for other game
200:52 - genres this is indeed extremely
200:54 - important now the reason why handling
200:56 - that is so complex is YouTube potential
200:58 - problems with data desync there are two
201:00 - main methods we have for synchronizing
201:02 - data we have rpcs and we have Network
201:04 - variables the one big difference between
201:06 - both of them is that when a client joins
201:08 - linked they won't receive the current
201:10 - state of a network variable but they
201:12 - will now receive all the rpcs that have
201:14 - been sent since the very beginning of
201:15 - the game in here in this game we use
201:17 - rpcs quite a lot to synchronize tons of
201:20 - stuff we use them because they are quite
201:22 - simple to use and very easy to
201:23 - understand like for example on setting
201:25 - the kitchen object parent so let's do a
201:28 - quick test okay so with the two builds
201:30 - down here I'm going to connect the host
201:31 - but I'm not going to connect the client
201:33 - just yet so I'm going to start playing
201:35 - with host County countdown timer now I'm
201:38 - going to pick up something let's say I
201:39 - pick up some meat okay and now if I
201:41 - connect with a client and now actually
201:43 - we have the thing where we synchronize
201:45 - this window so let's manually just hide
201:46 - this so I'm just going to find the
201:48 - window the tutorial UI and just hide it
201:50 - and if there you go look at that we can
201:52 - now see the desync basically this second
201:55 - player joined late so this one knows
201:57 - that an object will spawned so that
201:58 - object is indeed spawned but it does not
202:00 - know that the first player is actually
202:02 - the one holding the object so we have a
202:04 - data desync the second line did not
202:06 - receive which one is the kitchen object
202:08 - parent for this game object again this
202:10 - is the difference between spawned
202:11 - objects and rpcs the kitchen object
202:13 - itself that one was indeed synchronized
202:15 - but for the apparent data that one is
202:17 - only synchronized through an RPC so the
202:19 - second player doesn't know what happened
202:21 - there and now if over here on this one
202:23 - if I just drop it somewhere there you go
202:25 - now everything is indeed synchronized
202:26 - because this one is now connected so
202:28 - this will now receive the new RPC so in
202:30 - this case it's not necessarily a big
202:31 - issue since it does end up sorting
202:33 - itself out but another thing we have
202:35 - synchronized through rpcs are the
202:36 - recipes so I'm going to start again on
202:39 - this one down here I'm going to connect
202:40 - as the host and start playing and there
202:42 - you go this one is now going to generate
202:44 - some recipes and if there go generate
202:46 - one so now on this one connect on the
202:48 - client let let me hide that UI and if
202:51 - I'm looking there nope it did not
202:52 - receive the very first recipe so now
202:54 - they have different amounts of recipes
202:55 - again that is because we used an RPC in
202:58 - order to send the new recipes Bond so
203:00 - this one joined late so it missed the
203:01 - spawning of the very first recipe so now
203:03 - the two clients have different data for
203:05 - what recipes are waiting also same thing
203:07 - over here on the plates counter again
203:09 - this one is using an RPC so you can see
203:11 - over there the plates come to his phone
203:12 - but that one missed the message spawning
203:14 - the first plate so this is the main
203:16 - tricky thing if you want to make a game
203:18 - where you want to allow only joining
203:19 - then you need to design your game in
203:21 - such a way that all of the important
203:23 - data is synchronized in a way that is
203:24 - automatically synced one option like I
203:26 - said is using network variables those
203:28 - are synchronized automatically when
203:30 - someone new joins so even though this
203:32 - second player this one joined late you
203:34 - can see over there the actual timer for
203:35 - the game that one is being synchronized
203:37 - correctly even though this one joined
203:38 - late that is because that one is using a
203:40 - network variable so if you made the
203:42 - waiting response Network variable it
203:43 - would synchronize correctly however the
203:45 - reason why I used rpcs is because we
203:47 - cannot directly put a script mode object
203:49 - inside a network variable so over here
203:51 - on the delivery manager it would require
203:52 - a different code in order to synchronize
203:54 - this list you could either make a
203:56 - network variable with a list of hints to
203:58 - hold the index for each recipe so or you
204:00 - could implement the inetwork
204:02 - serializable to teach NGO how to
204:03 - serialize this specific script note
204:05 - object I cover that in the netcode video
204:07 - so it's definitely possible it just
204:09 - requires a different approach another
204:11 - option would be to keep using rpcs just
204:13 - like we're doing here but when a new
204:15 - player joins you would have the server
204:16 - send the player all the data they need
204:18 - to synchronize so for example over here
204:20 - on delivery manager you could add a
204:22 - convex listener when a client connects
204:24 - you can listen to that through the
204:26 - network manager the Singleton and here
204:28 - is the client connect comeback so you
204:30 - couldn't listen into this on the server
204:32 - then when this happens you could have
204:34 - the servers and a client RPC just that
204:36 - client to tell them all the recipes that
204:38 - have already been spawned then from that
204:40 - point on everything would already be
204:41 - synced so adding support for only
204:43 - joiners adds a bit of complexity but it
204:45 - is certainly doable
204:46 - as to whether you need it or not really
204:48 - depends on the game you're making if
204:50 - it's a quick session game like the one
204:52 - that we have here then I think it's not
204:53 - really worth it to add that extra
204:54 - complexity but if you have a game with
204:57 - longer sessions then of course that one
204:58 - is a must so keep that in mind when
205:00 - building your game from the very
205:02 - beginning and deciding whether to use
205:03 - rpcs or network variables so here for
205:06 - this game let's not allow only joiners
205:08 - and how we do that is actually very
205:10 - simple if we look over here on the
205:12 - network manager game object if we scroll
205:14 - down down here there's a toggle for
205:15 - connection approval right now every
205:17 - client that connects gets automatically
205:19 - accepted we don't want that so let's
205:21 - instead enable this and then let's go
205:23 - here on to the kitchen game multiplayer
205:25 - script and on this one we can listen to
205:27 - a comeback however one very very
205:29 - important thing is we need to listen to
205:30 - The Comeback before we currently start
205:32 - host so let's make a start host function
205:34 - over here on this class let's make a
205:36 - public void start host and then we're
205:39 - going to have a public void start client
205:42 - and over here we have the testing
205:44 - netcode UI so these are the two testing
205:46 - buttons that we using instead of
205:48 - directly going to the network manager
205:50 - and calling it let's go into the kitchen
205:51 - game multiplayer the instance and use
205:54 - that function so the start host and then
205:57 - the start client
205:59 - okay so we go through those functions
206:01 - then over here on these let's do the
206:03 - same thing so network manager the
206:04 - Singleton start the client and on this
206:07 - one network manager Singleton and
206:09 - Starkey host
206:11 - and now here before we start the host
206:13 - let's go into the network manager
206:17 - the Singleton and let's listen to the
206:20 - connection approval comeback let's add a
206:22 - listener to this delegate now this isn't
206:25 - an event so visual studio isn't going to
206:27 - automatically run this so let's call
206:28 - this network manager connection approval
206:33 - comeback
206:35 - and now let's use the visual studio
206:36 - automatic things to generate this method
206:38 - okay so here it is
206:40 - so we take an argument for the
206:42 - connection approval request and then
206:44 - another one this one is for the
206:46 - connection approval response and now
206:49 - here how we either approve or disapprove
206:51 - of a connection is very simple we just
206:53 - go inside the connection approval
206:54 - response and over there there's
206:56 - something called approve that is a
206:58 - Boolean so we can set it to true to
207:00 - allow our phones to not allow so for
207:02 - right now let's make sure we only
207:03 - approve connections when we are in the
207:05 - waiting to start state so over here on
207:07 - the kitchen game manager let's just
207:08 - expose the waiting to start state so
207:10 - let's go down here where we have a whole
207:12 - bunch of functions so let's go a public
207:14 - ball
207:15 - is waiting to start and just return if
207:19 - the state.value equals the state that
207:21 - waiting to start okay so then over here
207:23 - let's check so check if the kitchen game
207:26 - manager instance is waiting to start
207:29 - if so then we are going to approve the
207:31 - connection
207:32 - and if not we are going to disapprove
207:34 - the connection now actually in a bit
207:36 - we're going to refactor this to make it
207:38 - so that the connection is actually
207:39 - established in the lobby but for now
207:41 - this testing code should work so let's
207:42 - try it okay so over here first let's
207:45 - create a host all right and now this one
207:47 - let's join right away alright so both of
207:49 - them are on waiting to start so if I
207:51 - click on client this one is going to
207:52 - connect but instead of that let's start
207:54 - this one okay waiting for players this
207:56 - one start and if there you go it starts
207:57 - the countdown and actually here we see
207:59 - one thing that I forgot you can see that
208:01 - the players weren't automatically
208:02 - spawned that is because when you enable
208:04 - this connection approval you need to
208:06 - manually tell it to create a player
208:08 - object so over here when we approve we
208:10 - also need to go into the response and
208:12 - over here set create player object into
208:14 - true so this will now revert the same
208:16 - behavior we had previously where the
208:18 - player object won't be spawned
208:19 - automatically okay so let's try again
208:20 - over here create the host over here join
208:23 - as the client all right now let's start
208:25 - this one waiting for players this one's
208:26 - starting there you go the game has
208:27 - turned these two players are connected
208:29 - so now it shouldn't be accepting any
208:31 - more players so down here if I try to
208:33 - join and if there you go it does not
208:35 - work the host has disconnected so that
208:37 - one can no longer join our clients
208:38 - alright awesome okay so here we talked
208:41 - about whether you want to allow only
208:43 - joining or not and the various
208:44 - challenges that come with adding that
208:46 - feature and we also limited how the
208:48 - players can join our game with that our
208:50 - entire game logic is now working in
208:52 - multiplayer what's left is really
208:53 - handling of the other scenes but before
208:56 - we build those scenes let's actually set
208:57 - up the entire connection flow so let's
208:59 - do that in the next lecture
209:02 - hey again here's another quick
209:04 - intermission good job on syncing with
209:06 - the course by now I really hope you've
209:09 - already learned a ton from the course
209:10 - almost all of the core multiplayer logic
209:13 - is already done by now although the
209:15 - following lectures and also actually
209:16 - some of the more important ones handling
209:19 - the connection scene flow the character
209:21 - selection Lobby relay and so on they can
209:24 - be a bit tricky so definitely do take
209:26 - your time I hope you've been following
209:28 - the website as you go through the
209:29 - lectures and I hope reading the
209:30 - frequently asked questions has helped
209:31 - you in some way if you enjoy my teaching
209:34 - style then check out my other course
209:35 - after finishing this one especially the
209:37 - turn-based strategy course that one
209:39 - would be an excellent follow-up to this
209:41 - one alright let's go to the next lecture
209:44 - hello and welcome I'm your code monkey
209:46 - in this lecture we're going to handle
209:48 - the connection scene flow meaning we're
209:50 - going to hand on the changing of scenes
209:52 - and set up where we're going to actually
209:53 - create the netcode connection in order
209:55 - to prepare for the future and Lobby and
209:57 - character select scenes we're going to
209:58 - start from the main menu with no
210:00 - connection then the in lobby scene
210:02 - handles the unlocking list as soon as
210:04 - the player joins the lobby it
210:05 - automatically creates a netcode
210:06 - connection and goes into the character
210:08 - select scene on that scene the player
210:10 - will then select the character and set
210:12 - as ready when all players are ready the
210:14 - game will load the final game scene and
210:16 - start the game okay so let's handle the
210:18 - connection scene flow let's begin by
210:20 - making the scenes so let's go into our
210:23 - scenes folder and let's create a brand
210:25 - new scene
210:26 - let's name this one the lobby scene and
210:29 - let's duplicate this one to make the
210:30 - character select scene okay now let's
210:33 - first go inside the lobby scene and over
210:36 - here let's create a brand new canvas and
210:38 - let's set it up as usual so screen space
210:40 - overlay then over here scale with screen
210:42 - size reference resolution of 1920 by
210:45 - 1080 and match with the height so the
210:47 - usual setup now inside the canvas let's
210:49 - create an empty game object come with
210:51 - the testing Lobby UI
210:53 - let's put the width and height both on
210:55 - zero again for this lecture we only just
210:58 - want to handle the connection foil so
211:00 - we're just going to make some testing
211:01 - buttons we're going to set up the proper
211:03 - Lobby in the enlightened lecture inside
211:04 - this game object let's create a simple
211:06 - button call this the create game button
211:10 - inside let's put create game on the text
211:13 - let's put it a bit in bold a bit bigger
211:16 - and on the button itself also a bit
211:18 - bigger okay great then let's make
211:21 - another button so duplicate this one put
211:23 - it down this one is going to be the join
211:24 - game button and inside for the text for
211:27 - this one join game okay we have our
211:29 - buttons now let's make a script to run
211:31 - this so let's go into our scripts folder
211:33 - inside the UI let's create a brand new
211:35 - c-sharp script with the same name so
211:37 - testing Lobby UI let's wait for it to
211:39 - compound and over here let's add the
211:41 - testing lab UI okay great let's open now
211:43 - this one first of all let's add some
211:45 - references for the buttons so a
211:47 - serialized field private of type button
211:49 - first we have the create game button and
211:52 - then we have the join game button so we
211:55 - have these two
211:56 - here in the editor let's drag the
211:58 - references so the create game button and
212:00 - the join game button all right and over
212:03 - here let's see pretty much exactly what
212:04 - we were doing on the testing UI on the
212:06 - game scene meaning we're just going to
212:08 - start either a host or a client so let's
212:11 - see if I would awake let's go into the
212:13 - create game button the on click let's
212:15 - add a click listener on this one we go
212:18 - into the kitchen game multiplayer the
212:20 - instance and call start host
212:22 - and then for the other one for the join
212:25 - game button on this one we start as a
212:28 - client
212:29 - okay so we have these and this is going
212:31 - to start a host or a client which also
212:33 - means we need to create a network
212:34 - manager in the lobby scene and not on
212:36 - the game scene so let's save the scene
212:38 - and let's go inside the game scene then
212:41 - over here and let's find the network
212:42 - manager okay great so let's copy this so
212:45 - Ctrl C let's go back into the lobby
212:47 - scene over here control V okay we have
212:49 - the network manager let's go back into
212:51 - the game scene
212:52 - and over here let's make sure to delete
212:54 - the network manager remember that the
212:56 - network manager works as a Singleton
212:57 - that does not get destroyed on scene
212:59 - changes so we need to make sure we only
213:01 - spawn it once and we're going to do that
213:03 - just over here on the lobby scene okay
213:05 - great also for the settings we're not
213:07 - going to want to spawn the player right
213:08 - away since there is no player object
213:10 - over here on the lobby so let's click to
213:12 - select the player prefab field and then
213:14 - press on delete in order to clear it
213:15 - okay great so just like this we should
213:18 - have this button which creates a host
213:19 - and this one which joins as a client but
213:21 - if we test right now nothing will
213:23 - actually happen since we just have a
213:24 - connection being established and nothing
213:26 - else according to our connection flow
213:28 - once we connect we want to load the
213:30 - character select scene so let's do that
213:31 - over here on the create game button we
213:34 - first start the host and then afterwards
213:36 - we're going to download the next scene
213:38 - so we're going to loader.com load and
213:41 - let's pass in the next scene so let's
213:43 - actually add them to the list so over
213:45 - here on downloader script let's set our
213:46 - two scenes so don't want to be seen and
213:48 - then we have the character select scene
213:50 - again here make perfectly sure the names
213:52 - perfectly match the actual C names so be
213:54 - very sure the names are perfect and over
213:56 - here we're going to download the
213:58 - character selecting okay like this
214:00 - however this part is actually extremely
214:02 - important
214:03 - for unloading the scenes we're actually
214:05 - going to use the network manager itself
214:07 - to handle scene management that way all
214:09 - the clients are going to be synchronized
214:10 - automatically so in order to do that we
214:13 - need two things first one is over here
214:15 - on the editor on the network manager
214:16 - let's scroll down and over here we do
214:18 - see enable scene management so let's
214:20 - make sure this one is enabled this makes
214:22 - it so that when you change scenes in the
214:24 - server all of the clients will
214:25 - automatically unload that scene as well
214:27 - and the second important thing is that
214:29 - we need to load through a different
214:30 - method so over here on this load
214:32 - function we are going through the
214:34 - regular scene manager in column load
214:35 - scene in order to make it work with the
214:37 - network manager we need to do it through
214:38 - a different function if you don't do it
214:41 - if you just use this function then the
214:42 - objects on new scene will not
214:44 - automatically spawn personally I found
214:46 - this out the hard way while making the
214:47 - Prototype I had no idea why the objects
214:49 - on the game scene weren't being spawned
214:51 - and that is because I was using this
214:52 - using the scene Venture instead of going
214:54 - through the network manager so if you
214:55 - have issues where you're changing the
214:57 - scene and the objects are not spawning
214:58 - on the network double check to make sure
215:00 - you're changing scenes using the scene
215:01 - network manager so over here let's make
215:03 - a function to do exactly that let's make
215:06 - a public static Point call it load
215:08 - Network
215:09 - and we're going to receive the same
215:10 - scene for the Target scene
215:13 - and over here instead of going through
215:15 - this inventure let's go through the
215:16 - network manager the Singleton let's
215:19 - access the scene manager and in there we
215:21 - can now call load team and let's pass in
215:23 - the same scene so the target scene and
215:25 - as usual this one takes these strings so
215:26 - let's do A2 string and then for the
215:29 - unload scene mode you can load as
215:31 - additive but in this game in the simple
215:32 - game we're always using just single so
215:34 - let's go with single okay so that's it
215:36 - so we need to make sure we always use
215:38 - this function and not this function now
215:40 - one note here note how with this we're
215:42 - actually bypassing the unloading scene
215:44 - that we made in the Xeon Player version
215:46 - I'm doing that just because handling
215:48 - that would be quite a bit complex and
215:50 - this connection flow and lecture is
215:51 - already a bit too long basically we
215:53 - would need to wait until all the clients
215:55 - load the unloading scene before the
215:56 - server starts loading the funnel scene
215:58 - so it's definitely doable just requires
216:00 - a bit more complexity here to keep
216:02 - things simple let's leave it just like
216:03 - this in multiplier so it's going to load
216:05 - the scene right away so back here in our
216:06 - testing Lobby why instead of using
216:08 - download let's use the unload Network
216:10 - and also over here on the client on this
216:12 - one we do not need to add it because the
216:14 - client will automatically load to match
216:15 - the scene that is loaded on the server
216:17 - okay so with this we're almost ready to
216:19 - test we just need two more things first
216:21 - of all over here when calling start host
216:23 - or start client in the end we're going
216:25 - through the network manager but right
216:26 - now we're actually going through the
216:27 - kitchen game multiplier so we also need
216:29 - this object on the lobby scene just like
216:31 - we have the network manager so let's
216:33 - save the lobby scene let's go inside the
216:35 - game scene let's find over here the
216:37 - kitchen game multiplayer let's copy this
216:39 - back in the lobby scene paste it and
216:41 - back in the game scene save the changes
216:43 - and clean it up from here okay great so
216:45 - we have it just over here on the lobby
216:47 - scene however we have another sneaky
216:49 - issue like this this object won't be
216:51 - destroyed when you unload the character
216:53 - selecting we don't want that we want
216:55 - this object to persist for as long as
216:57 - the network connection is active pretty
216:58 - much just like the network manager so
217:00 - over here on the kitchen game
217:01 - multiplayer on the awake we can simply
217:03 - do don't destroy and load and pass in
217:06 - this game object that will make sure
217:07 - that this game object does not get
217:09 - destroyed when the scene loads okay
217:10 - great so one more thing it's over here
217:13 - on the connection approval comeback in
217:15 - the lobby we don't have any waiting to
217:17 - start state so for now let's just always
217:19 - accept the connection and then a little
217:20 - bit will handle the proper logic so just
217:23 - set this one as approved as true and
217:25 - let's get rid of the rest okay we're
217:27 - almost done just one final thing which
217:29 - is let's go into file into the bond
217:31 - settings and over here in the build list
217:33 - we need to make sure to add our new
217:34 - scenes so let's go ahead find the lobby
217:37 - scene drag it and the character select
217:39 - scene drag it and also for testing we're
217:41 - going to need to make sure to start from
217:42 - the lobby scene so let's just drag it
217:44 - over to the top so that one is on index
217:46 - 0. okay so we can now test so let's make
217:49 - a regular build and over here in the
217:51 - editor make sure you are on the lobby
217:52 - scene when you hit on play okay so here
217:55 - is the editor in the building both
217:56 - running both working great so there are
217:57 - no errors if you have some errors in
217:59 - your game go check the error chances are
218:01 - you possibly forgot to copy one of the
218:03 - objects onto this scene so with this
218:05 - everything is already working correctly
218:06 - and now on this one I can press the
218:08 - button to create a game and if there go
218:10 - it goes into the character select scene
218:12 - and then on the build down here I'm
218:13 - going to join the game and if there go
218:15 - it also unloads that scene alright
218:17 - awesome so the first part is working
218:19 - we're going from the lobby scene to the
218:21 - character select scene with no errors
218:22 - now let's handle the transition from
218:24 - character select onto the game scene
218:26 - let's go into the character select scene
218:28 - and over here as usual let's make the
218:30 - canvas and set it up so a brand new
218:32 - canvas screen space overlay scale with
218:35 - screen size with 1920 by 1080 and let's
218:38 - match probably with a height okay great
218:40 - now inside let's create an empty game
218:42 - object for the testing character select
218:45 - UI inside let's create a new UI create a
218:48 - new button call this the ready button
218:50 - inside make it say ready okay we have
218:53 - the button now let's make a script to
218:55 - run this so let's go into our URI folder
218:57 - and create an easy sharp script let's
218:59 - add the script so the testing character
219:01 - is like UI okay let's open over here and
219:04 - let's begin by adding a reference to our
219:05 - button
219:06 - so a serialized film private button for
219:09 - the ready button okay let's save
219:12 - back here in the editor let's drag the
219:13 - reference all right and now the goal
219:15 - here is to pretty much use exactly the
219:17 - same logic that we made for the kitchen
219:18 - manager over here on the main game
219:20 - manager script we have the radiant logic
219:23 - so the game would only start when all of
219:24 - the players were ready so the logic is
219:26 - exactly the same so let's actually copy
219:27 - the exact code so let's copy first of
219:29 - all the playwright dictionary except we
219:31 - don't want to run that logic directly
219:33 - over here on the UI script so let's make
219:35 - a proper script let's create a brand new
219:37 - game object for the character select
219:39 - ready and let's make a script with the
219:41 - exact same name so the characters like
219:43 - ready
219:44 - let's reset the transform and add the
219:46 - character select rating okay now this
219:48 - one let's actually paste that code so
219:50 - first of all let's copy over here the
219:52 - playroom dictionary and over here let's
219:54 - paste it okay we have the dictionary
219:55 - then we need to initialize it on awake
219:57 - so on awake the playwright dictionary
219:59 - let's make a brand new one then let's
220:01 - see what other logic we're using with
220:02 - this one and it's down here we have an
220:04 - RPC in order to set it as writing so
220:06 - let's just copy this entire function and
220:08 - over here let's paste them and when you
220:10 - do make sure you add using
220:11 - entity.netcode up here Visual Studio
220:13 - should do it by default but make sure
220:14 - you do it okay so this is really going
220:16 - to do the exact same thing so go through
220:18 - the play around dictionary and see if
220:19 - they are already and if so then it's
220:21 - over here instead of setting the state
220:23 - over here we're just going to load the
220:24 - final scene so going to downloader and
220:27 - again remember to use the unload Network
220:28 - function and we're going to load the
220:30 - game scene okay so that's really it
220:32 - super simple then for calling the server
220:34 - RPC and let's expose a function set
220:37 - player ready and over here we call the
220:39 - set play ready with the server RPC so we
220:42 - just need to call this function from
220:43 - that button in the DUI so let's go up
220:45 - here make a public static character
220:48 - select ready in order to make our static
220:50 - instance they get any private set and
220:53 - over here on the Wake set instance
220:55 - equals this okay great so now back here
220:57 - on the testing character select UI let's
220:59 - make a simple awake let's go into the
221:01 - ready button the unflick let's add a
221:04 - listener and on The Listener let's just
221:06 - go into the character select ready the
221:08 - instance and let's set the player as
221:09 - ready okay so that's it this should be
221:12 - working let's just do one more thing
221:13 - let's go into the game scene so let's
221:16 - first of all save this scene go inside
221:17 - the game scene and over here on this one
221:19 - on the canvas we no longer need the
221:21 - testing netco device and let's just
221:23 - disable this one like this and actually
221:25 - just one final thing that I forgot over
221:27 - here in order for the server RPC to
221:28 - actually work we need to make sure this
221:30 - one is not a Model Behavior but rather a
221:32 - network Behavior then back in the other
221:34 - turn let's go into the character slide
221:35 - scene select the object and yep let's
221:37 - add Network object that way it should
221:39 - work okay great so we're ready to test
221:41 - let's go back into the lobby scene again
221:43 - this is important we always need to
221:45 - start from the lobby because this is
221:47 - where the network manager is created so
221:48 - with this let's make a building test
221:50 - okay so here we are so up here let's
221:52 - create a brand new game and you put on
221:54 - the character select scene now this one
221:55 - down here and let's join the game and
221:56 - yep there you go it does work so both of
221:58 - them are on the character select scene
222:00 - now this one up here I'm going to click
222:01 - on ready and there you go this one is
222:03 - ready but it did not load the game scene
222:05 - it is still waiting for this one down
222:06 - here to be running and as soon as I set
222:08 - ready on this one it is going to tell
222:10 - the server that it's ready and if there
222:11 - you go the server automatically unloads
222:12 - the final game scene and this one loads
222:14 - with it alright awesome so everything is
222:17 - working great now over here we are
222:18 - waiting for players and there you go it
222:19 - works however obviously you might be
222:22 - noticing one issue right now since we
222:24 - removed the automatic spawn player
222:25 - prefab we have nothing over here so we
222:28 - need to manually spawn the player let's
222:29 - do that let's do that over here on the
222:32 - kitchen game manager this script only
222:33 - exists on the game scene and for
222:35 - spawning we only want to spawn when all
222:37 - of the players have loaded so for that
222:39 - let's go down over here onto the on
222:41 - network spawn let's go in the network
222:43 - manager and if we go inside the
222:45 - Singleton and then inside the scene
222:46 - manager over here we have a function on
222:49 - load event complete this one is
222:51 - triggered when all of the clients have
222:52 - loaded the final scene again it's
222:54 - important it's this one not this one
222:55 - this one up here is triggered on a perk
222:58 - like basis whereas this one down here is
222:59 - when all of the clients have loaded so
223:01 - let's go with this one let's listen to
223:03 - this one and over here it's pretty
223:05 - simple we just want to spawn all the
223:07 - players so let's cycle through all the
223:08 - connected clients so you loan for the
223:11 - client ID
223:12 - and the network manager Singleton the
223:16 - connected Client List okay we have all
223:18 - the connected clients then we need to
223:20 - spawn the employer prefab so we need a
223:21 - reference let's add it up here so we
223:24 - serialize filmed private transform for
223:27 - the player prefab so we have this then
223:30 - the editor let's go inside the game
223:31 - scene and let's go into the kitchen game
223:33 - manager and let's make sure to drag the
223:36 - player prefab there it is also one
223:38 - important thing since we are spawning
223:40 - the player let's go into the lobby scene
223:42 - let's make sure to save and on this one
223:44 - on the network manager in order to spawn
223:47 - the player prefab dynamically we need to
223:48 - make sure we add it up here since we
223:50 - removed it from the player prefab up
223:52 - here we need to add it onto the network
223:54 - prefabs so let's add brand new one and
223:56 - drag the player prefab okay great back
223:59 - in the code here we have the employee
224:00 - prefab so down here in let's just call
224:02 - instantiate instantiate the player
224:04 - prefab so this is going to return our
224:06 - player transform
224:08 - so we have this then on this one let's
224:10 - see we get component to grab the network
224:12 - object and on network object we can call
224:14 - the function spawn as player object so
224:16 - not to spawn but the spawn is player
224:18 - object this one takes a client ID so
224:20 - let's press in this client ID and then
224:22 - for the story with scene we do want the
224:24 - player prefab to behave as a regular
224:25 - game object so we do want to destroy the
224:27 - scenes so let's go with true alright so
224:29 - that's it this will spawn the player
224:31 - prefabs and after that the rest of the
224:32 - game should work perfectly okay so let's
224:35 - test and again as always in order to
224:36 - test make sure you test from the lobby
224:38 - scene okay so on this one up here let's
224:40 - create the brand new game alright here
224:42 - we are then down here let's join okay it
224:45 - works now let's set us ready so I'm
224:47 - waiting for this one this one goes as
224:48 - ready and you both have loaded the final
224:50 - game scene now as I start playing and
224:52 - there you go each of them now has their
224:54 - own player controller and now yep all
224:56 - the rest of the game all of it is
224:57 - perfectly synchronized alright awesome
224:59 - next let's handle the connection accept
225:01 - logic so over here on the kitchen game
225:03 - multiplayer we modify this combat in
225:05 - order to always approve now we only want
225:07 - to accept while we are on the character
225:09 - select scene so what it says if the
225:12 - current scene is the character select
225:13 - scene so let's do a simple if let's go
225:16 - into the scene manager let's get the
225:18 - active scene and let's get the scene
225:20 - name
225:22 - then we compare let's compare with
225:24 - unloader.scene and check if we are in
225:26 - the character selecting now we need to
225:28 - compare string with strings so let's use
225:30 - the two string okay so we compare if we
225:33 - are on the character select scene and
225:34 - basically if we are not on the character
225:36 - selecting then let's approve as funks so
225:40 - cannot connect then let's return a
225:42 - reason so on the reason let's just say
225:45 - the game has already started okay so
225:48 - that one we don't approve and then let's
225:50 - return to stop the rest of the execution
225:51 - the next validation is checking the max
225:54 - number of players we only want four
225:56 - players maximum so over here we can do
225:58 - an if let's go into the network measure
226:00 - the Singleton get the connected client
226:02 - IDs and we check the account and we
226:05 - compare it against something so for
226:07 - defining the maximum let's actually go
226:08 - up here and make it a constant so a
226:11 - private constant for the max player
226:14 - amount and let's say we want to maximum
226:16 - of just four players
226:18 - okay with this and now down here we can
226:21 - compare if we already have way too many
226:23 - then once again same thing let's not
226:26 - approve and let's say game is full okay
226:29 - and if it's neither of these then we do
226:30 - accept it okay so that's in logic now
226:33 - let's add a visual the connection starts
226:35 - here on the lobby scene so let's add the
226:37 - visual here let's go inside the canvas
226:39 - and create an empty game object let's
226:40 - call this the connection response
226:43 - message UI let's make it stretch occupy
226:46 - everything and put 0 0 on everything
226:48 - okay then inside let's create a new UI
226:51 - image call this the background and again
226:54 - let's make it stretch to occupy
226:56 - everything
226:57 - and let's put this one on black with a
227:00 - little bit myself okay great then let's
227:02 - also add a text so a new UI text
227:05 - call this the message text
227:07 - and here we're going to say some message
227:10 - so let's put it the usual setup so width
227:12 - and height of zero let's disable
227:14 - wrapping put it down Center down the
227:16 - middle in bold and lift it up by a
227:18 - little bit okay
227:19 - then let's also have a button so a new
227:22 - UI button call this the close button and
227:26 - inside let's say close let's put the
227:28 - button text in bold put it in white and
227:31 - for the parents for this one put it in a
227:33 - dark gray and just like this we have a
227:35 - simple nice button on X of zero okay
227:38 - great we have both elements on this
227:40 - window we're going to show the
227:42 - disconnect reason message now let's
227:44 - duplicate this one for another window
227:45 - which is saying connecting so let's
227:46 - duplicate this window
227:48 - call it connecting UI and on this one
227:51 - get rid of the close button we just have
227:53 - a message and for the message let's just
227:55 - say connecting
227:57 - okay just like this now here obviously
227:59 - you could merge both these windows into
228:01 - just one but let's keep them separate to
228:03 - keep things a bit more clean so we have
228:06 - our UI setup now we basically just need
228:08 - to know when the player tries to connect
228:09 - and when that connection fails so we're
228:12 - here on the kitchen game multiplayer
228:13 - let's make a bunch of events so let's
228:15 - make a public event
228:17 - event handler and let's call it on
228:20 - trying to join game
228:22 - another one on fail to join game okay
228:26 - then let's go down here and the first
228:28 - one is when trying to connect for that
228:30 - one let's fire over here before we call
228:31 - this dark Lane so let's invoke with the
228:34 - usual this event RX dot empty okay and
228:37 - then for the disconnect failure for that
228:39 - let's also go up here where before we
228:41 - call this our client let's listen to the
228:44 - disconnect comeback so the network
228:46 - manager the Singleton on disconnect
228:48 - convac so let's listen to this one let's
228:51 - give it a proper name so the network
228:54 - manager okay so we have a disconnect
228:56 - comeback and here we've got the client
228:57 - ID and on this one let's fire off the
229:00 - event so on failed to join game
229:02 - so let's invoke with this in event
229:04 - arcs.empty okay we have both our events
229:07 - now let's make these scripts for our
229:08 - windows so let's make first over here
229:10 - the connecting UI so let's create a
229:12 - brand new UI script
229:13 - over here let's attach it and open okay
229:17 - now let's make the usual show and hide
229:19 - function so private void show and then
229:21 - we have a private void hide
229:23 - and same thing as always so set active
229:26 - as false or as true
229:28 - okay now let's do a private void start
229:31 - and on start we're going to listen some
229:33 - events and then we hide it so for the
229:35 - events this one let's listen when we try
229:37 - to connect so the kitchen game
229:39 - multiplayer the incense on we are trying
229:42 - to join the game so when this one
229:44 - happens so let's rename this
229:46 - kitchen game multiplayer so when this
229:49 - event happens let's show this window
229:51 - and then let's also hide it when that
229:53 - one does fail so on fail to join game
229:56 - let's add this listener so when it fails
229:59 - to connect let's sign okay great now
230:01 - let's make the other script so the
230:03 - connection response message UI let's
230:05 - build this one
230:06 - over here let's attach the script and
230:08 - let's open okay so here we're going to
230:11 - have pretty much exactly the same thing
230:12 - so let's have the usual private void
230:14 - show and hide then let's add references
230:16 - to the text and the button so let's add
230:18 - a serialized film and first for the text
230:20 - this one is text mesh Pro ugly for the
230:23 - message text and then we have another
230:26 - one this one is a button and this is
230:28 - going to be the close button okay let's
230:31 - save this and here in the editor let's
230:32 - drag the references so the message text
230:34 - and the button all right then let's add
230:37 - our listener so on private void awake
230:38 - let's go into the close button on the on
230:41 - click let's add in listener and this one
230:42 - is going to be just the hide function so
230:44 - that is just going to hide the window
230:46 - then let's do our private void start and
230:48 - on start let's listen so kitchen game
230:50 - multiplayer the instance when it fails
230:53 - to join a game
230:54 - let's listen to this one so on search
230:57 - we'll listen and then we hide by default
230:59 - and when it does fail to join the game
231:01 - let's show this and then let's set the
231:03 - message text and for the disconnect text
231:06 - we can grab it from the network manager
231:08 - the Singleton and we grab the disconnect
231:10 - reason
231:11 - so if that's it just like this both our
231:13 - script should be working however here
231:15 - let me point out one very very important
231:17 - thing one question that I got a lot in
231:19 - the single player course is with regards
231:20 - to unsubscribing from events you might
231:22 - have noticed that we pretty much never
231:24 - unsubscribe to events that is because
231:26 - you only need to unsub if the objects
231:28 - have a different lifetime if both the
231:30 - publisher and subscriber have the exact
231:32 - same lifetime then you don't need to
231:33 - manually unsub however over here these
231:35 - objects do have a different lifetime
231:37 - these UI Windows these only exist on the
231:40 - lobby scene as soon as we change scenes
231:42 - they won't be destroyed but the kitchen
231:44 - game multiplayer this one will live
231:45 - through all the scenes so we need to
231:47 - make sure to unsub because this object
231:49 - is going to have a different lifetime
231:51 - than the kitchen game multiplayer and
231:52 - how we end sub is very simple let's just
231:54 - make a proud void on destroying so this
231:57 - one is a monobehavior function which is
231:58 - called when this object is destroying so
232:01 - on this one we really just unsub so just
232:03 - go into that one and do minus equals so
232:05 - we do it over here and on the connecting
232:07 - UI same thing private void on Destroy
232:10 - let's unsub to both of these so just do
232:13 - minus equals
232:15 - okay great so now we can test all right
232:18 - so here I've got one two three four five
232:20 - coins so on this one up here let's
232:22 - create a game and there you go it did
232:24 - work then on this one let's join a game
232:26 - and yep it did work connected joined on
232:28 - this one join yep it worked this one
232:30 - joined yep it worked so now we have all
232:32 - four clients connected so the game
232:34 - should be full now so on the fifth one
232:36 - if I try to join any up there you go the
232:38 - game is currently full okay great so
232:40 - that worked now let's actually quit one
232:43 - of these so let's quit this one so
232:44 - technically now we do have one slot
232:46 - available so let's not connect right now
232:48 - instead let's set this one is ready this
232:50 - one is ready and this one is ready and
232:52 - if there you go all of them are
232:53 - unloading the final scene so here we
232:55 - have our three players okay great but
232:57 - the game is now playing so on this one
232:59 - if we do try to join and nope the game
233:01 - has already started alright awesome so
233:04 - this logic is working perfectly there's
233:06 - just one more possible connection
233:07 - scenario that is simply if the
233:09 - connection just times out if that
233:11 - happens then the same event won't be
233:13 - fired the only difference is the
233:14 - disconnect reason will not have have any
233:15 - text so we can just check if the
233:18 - disconnect reason is empty so if we have
233:21 - no disconnect reason then let's just set
233:23 - this one to just fail to connect okay so
233:25 - that's the text and also by default it
233:27 - won't take a bit too long to timeout so
233:29 - over here on the lobby scene on the
233:31 - network manager if we scroll down yep
233:33 - over here on DNT transport we do see a
233:35 - bunch of settings so we have the connect
233:37 - timeout milliseconds so meaning after a
233:39 - thousand milliseconds so one second it
233:41 - won't wait one second until that
233:43 - connection times out and then it will
233:45 - try to connect for a maximum of 60 times
233:47 - this seems like a bit too much so let's
233:49 - put it on just 10 tries so if it fails
233:51 - after 10 tries then after 10 seconds it
233:53 - should say fail to connect okay so let's
233:55 - test here we are and without creating a
233:57 - host let's just try to join the game and
233:59 - there you go it is trying to connect but
234:01 - there's no game so it should fail so
234:03 - after 10 tries after 10 seconds if there
234:06 - you go we have our failed to connect
234:07 - message okay great
234:09 - so with that we have almost our entire
234:11 - connection flow working we start from
234:13 - the lobby we can create the game and we
234:15 - can join the game we go into the
234:17 - character select scene and then when all
234:19 - of the players are ready when that
234:21 - happens yep the server loads the final
234:22 - game scene and over here we can play as
234:24 - normal so everything is working great
234:26 - all that's left is the main menu save
234:28 - over here on the host if I go back into
234:31 - the main menu there you go that one
234:32 - disconnects so that's great and I'm back
234:33 - on the main menu so it looks great but
234:35 - if we look in the hierarching up over
234:38 - there and look at that the network
234:39 - manager and the kitchen game multiplayer
234:40 - these objects are still active so if we
234:42 - now went into the lobby scene we would
234:44 - end up with duplicated objects and tons
234:46 - of problems so basically we need to
234:47 - clean up these objects and let's do it
234:49 - when we go back over here on the main
234:50 - menu so let's go into the main many
234:53 - scenes so let's open this and over here
234:55 - let's make a simple script to clean this
234:57 - up so let's create a new one let's call
234:58 - it main menu cleanup let's make a script
235:01 - to run this let's attach the script and
235:04 - open it you know here really all we need
235:06 - to do is just clean up both objects so
235:08 - that's super simple let's make a private
235:10 - void awake and on a wink let's just test
235:13 - if the network manager the Singleton if
235:16 - this one exists so if this one is not
235:18 - known if so then let's really just call
235:20 - destroy on the network manager Singleton
235:23 - game object and same thing for the other
235:24 - one so the kitchen game multiplayer if
235:27 - this instance is not null if so then
235:29 - let's destroy this instance Dot Game
235:31 - object okay so that should work with
235:34 - this the objects should always be
235:35 - cleaned up whenever we go back into the
235:37 - main menu just one more thing let's make
235:38 - sure this play button goes into the
235:40 - lobby scene and not the game scene so on
235:42 - the canvas let's open up the main menu
235:44 - UI and over here let's use the unload
235:46 - because over here we have no connection
235:47 - so let's use the single player load and
235:49 - set the game scene let's just go into
235:51 - the lobby scene and finally we can go
235:53 - into debunk settings and now we can make
235:55 - sure that we start from the main menu
235:57 - scene okay so let's test all right so
236:00 - here let's play we're in the lobby and
236:01 - let's create a game then on this one
236:03 - let's play let's join the game set is
236:05 - ready set is ready any of both of them
236:07 - start playing so even here we are both
236:09 - playing the same game now this one I'm
236:11 - tired of playing so go back into the
236:12 - main menu and if we're looking the
236:14 - hierarchy and if they go no more objects
236:16 - we have everything cleaned up now on
236:18 - this one I can play again I can create
236:20 - another game then on this one go back to
236:22 - the main menu and let's join again ready
236:24 - again ready again and if we are back in
236:26 - a brand new game instance alright
236:28 - awesome so here we handled our complete
236:31 - Game connection flow we start from the
236:33 - main menu in single player then on the
236:35 - lobby we have a button to create the
236:37 - connection in turn downloads the
236:39 - character slicing where more players can
236:41 - join then on that scene each player can
236:43 - set the ready to True when all of the
236:45 - players are ready the normal game scene
236:46 - loads and then the game continues as
236:48 - normal so yep we have all of that
236:50 - working now that's left is actually
236:52 - building out the lobby and the character
236:53 - slight scene so let's do that in the
236:55 - next lecture
236:57 - hello and welcome I'm your code monkey
236:59 - in this lecture we're going to build a
237:01 - nice character select scene where the
237:03 - player can select their player color
237:04 - okay so here on let's build a character
237:06 - select scene this is actually one of the
237:08 - more common questions I've seen in my
237:09 - netcode video lots of games have this
237:12 - sort of thing so let's build it let's go
237:14 - to the character select scene and first
237:16 - of all let's just make some proper
237:17 - buttons so inside our canvas let's
237:20 - create an empty game object call it the
237:22 - character select UI let's make it
237:25 - stretch to occupy everything
237:27 - okay so now inside let's add a UI button
237:30 - call this the main menu button let's
237:33 - anchor it on the top left corner and
237:35 - let's move it a little bit like that
237:37 - okay let's make it a little bit bigger
237:39 - let's make this in a dark gray and
237:41 - inside for the text let's say main menu
237:45 - let's put it in bold in white something
237:47 - like this okay that's the button now
237:49 - let's duplicate this make this the ready
237:51 - button and for this one let's anchor it
237:54 - on the top right and let's put it over
237:56 - there okay then inside just say ready
237:59 - okay now let's make a script run this
238:01 - with the exact same name so let's go
238:03 - into the UI folder create a new c-sharp
238:05 - script let's select the object and let's
238:08 - set the script so the character select
238:09 - UI okay now here first of all let's grab
238:12 - the buttons so as usual a serialized
238:14 - film private button for the main menu
238:16 - button another one for the ready button
238:19 - okay here in the editor let's drag our
238:22 - references so that one and the ready
238:24 - button alright and over here let's add
238:26 - our click Behavior so let's make a
238:28 - private way to wake on awake the main
238:30 - menu button on click let's add a
238:32 - listener in order to go back into the
238:34 - main menu first let's shut down the
238:36 - network manager since on this scene we
238:38 - do have an active connection so let's go
238:40 - to the network manager the Singleton and
238:43 - Kong shutdown and then afterwards we can
238:45 - use in order not load so that's the
238:47 - regular load because right now we have
238:49 - shut down the network connection and
238:51 - let's load back the main menu okay great
238:53 - and then for the other button so the
238:56 - ready button on click add in listener
238:58 - for this one we just want to do the
239:00 - exact same thing we did on the testing
239:01 - script so here the testing character
239:03 - select UI we're running this so let's
239:05 - run the exact same thing so back in this
239:07 - script just run that function okay so
239:09 - that's it let's do a quick test before
239:11 - we do let's just make sure to disable
239:13 - that one all right and again as always
239:15 - for testing let's make sure to start
239:16 - from the lobby scene so not from this
239:18 - one let's go into the lobby okay let's
239:20 - make a build and test okay so on this
239:23 - one let's create the game there you go
239:25 - created then on this one let's play
239:26 - let's join the game yep we have joined
239:28 - now this one set is ready and nope
239:30 - nothing happens just yet now on this one
239:32 - set as ready and after a little bit yep
239:34 - they both load okay great so far so good
239:36 - now let's go back into the character
239:38 - select scene and let's build a proper
239:40 - visual sectionally for that let's first
239:41 - go into the main mini scene and over
239:44 - here let's copy some objects
239:45 - so let's pick up the main camera let's
239:48 - also pick up the virtual camera pick up
239:49 - the floor the global volume and the
239:52 - directional light okay so let's copy all
239:54 - these Ctrl C let's go into the character
239:56 - selection and let's destroy the main
239:58 - camera and directional light so delete
240:00 - these and press Ctrl V and there you go
240:02 - we have our objects okay so with this we
240:04 - have the basic visual let's just zoom in
240:06 - over here all right now let's position
240:09 - the virtual camera so let's put it on
240:11 - position 0 1.4 and minus 3.7 with
240:15 - rotation on two zero zero okay now here
240:18 - let's create a brand new empty game
240:19 - object name this the player zero let's
240:22 - reset the transform and now inside let's
240:25 - add the player visual so inside the S is
240:27 - a prefab here is the player Vision let's
240:29 - drag it on there and there you go
240:30 - there's the player let's just make them
240:33 - rotate to face the camera okay so we
240:35 - have one player now let's just position
240:36 - four players fractionally before that
240:38 - let's make this one a prefab so let's
240:41 - drag the player 0 in order to make it a
240:43 - prefab let's name this the character
240:44 - select its player now here let's make
240:48 - all our four players so the zero the one
240:51 - D2 and play three okay now let's
240:54 - position them let's position them not
240:56 - perfectly so a bit more off just to make
240:59 - it look a bit more interesting so player
241:01 - one player two alright so here we have
241:03 - all of our players now let's make the
241:05 - script to run this so let's create a
241:07 - brand new c-sharp script let's name the
241:09 - same thing so the character select
241:12 - player and now let's make sure to add
241:14 - the script onto the prefab itself so
241:16 - let's open up this prefab and in here
241:18 - let's attach a script okay now let's
241:20 - open it and over here let's add the
241:22 - usual show and hide functions basically
241:24 - we're only going to show as many as we
241:25 - have players connected
241:27 - so a pro void show
241:30 - and a pro void Hind
241:32 - and the usual thing game object set
241:34 - active into either false or true okay
241:37 - great now we need to handle the number
241:40 - of players that are connected so we know
241:41 - which one of these we should show or
241:43 - hide and then afterwards we're also
241:45 - going to need to sort the player data
241:46 - like for example the color or the player
241:48 - name so for that let's go into the
241:51 - kitchen game multiplayer over here on
241:53 - this script and the data type that we're
241:54 - going to use is going to be a networking
241:56 - list so it's kind of like a network
241:58 - variable except obviously it supports a
242:00 - list and for the type let's actually
242:01 - make a custom type this is a great way
242:03 - to learn how to serialize custom types
242:05 - so first for the type connection we're
242:07 - working let's make sure to save the
242:08 - profile go back outside okay and for the
242:10 - time let's create a brain c-sharp script
242:12 - and call it the player data okay so this
242:15 - is where we're going to store all of the
242:16 - data for the player so for this one
242:18 - let's make it instead of a class let's
242:20 - make it a struct since we're just going
242:21 - to hold some data and this one does not
242:23 - extend Model Behavior now for that over
242:25 - here right now let's just Begin by
242:27 - storing just the client ID so a public
242:29 - even long for the client ID so just like
242:31 - this and now back here on the kitchen
242:33 - game multiplayer on this one let's go
242:36 - ahead and make a film so this is going
242:38 - to be a network list of type player data
242:41 - and we have the player Data Network list
242:43 - okay there it is and right away we do
242:46 - see we have an error in order to use a
242:48 - type inside a network list it needs to
242:50 - implement I equatable so let's do that
242:53 - so back in our player data over here we
242:54 - need to implement I equatable with a t
242:58 - of this type so player data now let's
243:00 - use Visual Studio topless implement this
243:02 - so let's implement this interface and
243:04 - just requires us to implement the equals
243:06 - function so let's just return this
243:09 - client ID equals the other document ID
243:11 - okay great and back in here now we do
243:14 - not see any more errors okay so far so
243:16 - good now for initializing this list for
243:19 - a network variable usually we would
243:21 - initialize it right here except you
243:23 - actually can't do it up here if you do
243:25 - it you won't get an error and you also
243:28 - cannot initialize it on a network spawn
243:30 - so in order to initialize a networking
243:32 - list it has to be done over here on the
243:34 - awake so player data equals a new
243:36 - network list okay so now that we have
243:39 - this list let's populate it when a
243:41 - player connects so let's listen to that
243:43 - convex over here on the start host let's
243:45 - go into the network manager the
243:47 - Singleton and let's listen to the on
243:49 - client connected comeback so let's
243:51 - listen to this and let's rename this so
243:54 - the network manager okay great so when
243:57 - the player does connect this parameter
243:59 - in here is the client ID what it does
244:01 - let's go into the player Data Network
244:03 - list and let's add new entry let's
244:06 - create a new player data and inside for
244:09 - the client ID let's just use this client
244:11 - ID okay great so now when the player
244:13 - connects we're going to update this list
244:15 - with new player and over here on the
244:17 - character select player in order to show
244:18 - or hide we need to know when the list
244:20 - changes meaning when a player either
244:22 - joins or quits so over here let's make
244:24 - an event to notify that let's make a
244:27 - public event event handler let's call it
244:29 - on player Data Network list change so
244:33 - when that list change let's fire it off
244:35 - and for knowing when it changes we can
244:37 - either manually turn it off over here or
244:39 - we can also just listen to this so
244:41 - listen with the let's change the event
244:43 - so when this happens we have this and
244:45 - over here we fire off the local event
244:47 - so on the player Data Network has
244:49 - changed let's invoke this okay great so
244:51 - now we have this event and now back in
244:53 - here we can listen to it so on a private
244:55 - void start let's listen to this event so
244:58 - that's on the kitchen game multiplayer
245:00 - the instance let's listen to this event
245:02 - let's rename this as usual when this
245:05 - event happens we want to basically show
245:07 - or hide this character select if this
245:09 - one is meant to be shown or hidden so
245:11 - for that we really just need an index to
245:13 - know which player this object represents
245:15 - so here let's add a serialized film
245:17 - private a simple and and colleges player
245:21 - index then back in the editor let's just
245:23 - assign it so this one start off on Index
245:25 - 0. this one let's give it index one this
245:27 - one index two and this one index three
245:30 - okay great and over here let's make a
245:32 - function to update the player so private
245:35 - void update player and on this function
245:37 - business let's check if this player
245:39 - index is connected so for that let's ask
245:41 - the kitchen game multiplayer so over
245:43 - here on this script let's make a
245:45 - function to do just that
245:47 - let's make a public return Napoleon and
245:49 - just call it is player index connected
245:51 - and we're going to receive an end for
245:53 - the player index and over here we
245:55 - basically just need to know if the
245:56 - player Data Network list if that one has
245:58 - this index inside of it so we just
246:00 - return this player index is under the
246:03 - player.networklist dot count if so then
246:06 - this player index is connected so back
246:08 - in the script we just check if the
246:10 - kitchen game manager the multiplayer if
246:13 - this one is player connected and we pass
246:15 - in this player index so if this one is
246:17 - connected then let's show and if not
246:19 - then let's hide okay great so then for
246:22 - update individual we just update first
246:23 - of all over here on start and then of
246:25 - course over here when the list changes
246:27 - okay so that's it let's test and see if
246:29 - the correct number of players are shown
246:31 - again for testing as always let's make
246:33 - sure the test from the lobby scene okay
246:35 - let's see okay so here on let's create a
246:37 - game and nope right away we do see an
246:39 - error in order to use a custom data
246:42 - point just like we saw we need to
246:43 - implement I network serializable if not
246:46 - then we have this error so over here on
246:48 - the point of that and let's make sure to
246:49 - implement that so Implement I equatable
246:51 - and then I Network serializable so let's
246:54 - implement this one and let's use Visual
246:56 - Studio to help us Implement so we just
246:57 - need to implement this function and
246:59 - actually this is super simple we just go
247:01 - into the serializer so that's this
247:02 - parameter over here and we just call
247:04 - serialize Value and just pass in the
247:07 - reference for all the values in our
247:08 - struct so in this case we only have the
247:10 - client ID so we pass it in although
247:12 - importantly this one is a ref parameter
247:14 - okay so that's it just like this here we
247:16 - are serializing the client ID so we are
247:18 - serializing everything on the player
247:19 - data so like this it should work so it
247:21 - says okay so here let's create a game
247:23 - and if there you go right away we don't
247:25 - see any errors and we also see only one
247:27 - player connecting okay so that is
247:29 - correct now on this one then here if I
247:31 - hit on play and then join and if the
247:33 - regular player 2 is now connected
247:34 - alright awesome so now that we have the
247:37 - visual showing let's show the ready
247:39 - state so for that let's go inside one of
247:41 - these prefabs and over here let's create
247:43 - a new let's go into 3D object and let's
247:46 - create a worm text let's put the width
247:49 - and height on zero this is going to just
247:51 - say ready
247:52 - let's make a much much smaller font size
247:54 - lift it up by bit and as usual let's put
247:57 - it down Center down the middle wrapping
247:59 - disabled okay there it is we have our
248:01 - simple ready marker now this one is
248:03 - actually reversed as you can see that is
248:05 - basically how text works usually for
248:06 - text you see it from behind instead of
248:08 - front ahead but that's super similar to
248:10 - changes over here on the scale let's put
248:12 - just -1 on the X and there you go now it
248:14 - faces perfectly okay so let's name this
248:16 - our ready text and let's go in the
248:19 - character select player and over here
248:20 - let's just add a reference to a
248:22 - serialized film private let's just use a
248:24 - game object because all we want to do is
248:25 - enable I want to show it for the ready
248:27 - game object and back in the editor let's
248:31 - write the reference exit the prefab and
248:33 - save the changes okay so now we have
248:35 - these ready counters all we need to know
248:37 - is when this player is running so for
248:39 - that let's go into the characters like
248:41 - writing this is the one that we made in
248:42 - the previous lecture this script has a
248:44 - dictionary and over here the server is
248:46 - handling on the state so whenever a
248:48 - player set is ready it says that is true
248:49 - however the one issue is that over here
248:52 - this dictionary is only synchronized on
248:54 - the server note how this isn't a network
248:56 - variable or anything it's just a regular
248:58 - normal dictionary meaning that all of
249:00 - the clients have this variable but only
249:02 - the server is actually setting The Ready
249:04 - Set over here in order to show the
249:06 - radiation on only clients we also need
249:08 - the clients to know who is ready so this
249:10 - is pretty simple let's just make a
249:12 - client RPC to tell the clients so a
249:14 - private void let's call it set player
249:17 - ready client RPC let's make this a
249:20 - client RPC and as a printer let's
249:23 - receive a yolong for the client ID then
249:26 - over here we really just access the
249:27 - player ready dictionary on this client
249:30 - ID and we set this one to true so that's
249:32 - it very simple and we just regularly
249:34 - coined RPC up here so on the server the
249:37 - server broadcasts the same message to
249:39 - all the clients so passing the same
249:40 - standard client ID okay so that's great
249:43 - so now all the clients know all the
249:44 - clients that are running all we need is
249:46 - to fire off an event to know when this
249:47 - changes so here let's make a public an
249:51 - event event handler call this on ready
249:54 - change so we have this event and then
249:56 - over here after setting it let's invoke
249:58 - the event
249:59 - so this event Tower is not empty okay so
250:02 - now back in the character select pointer
250:04 - script over here let's listen to that
250:05 - event so that's on the character select
250:07 - ready on the instance let's listen to
250:10 - the on ready changed event let's rename
250:12 - this as usual keep things nice and clean
250:14 - so the characters select ready and when
250:16 - this happens let's call our usual update
250:18 - on your function and over here on this
250:20 - function so we show the player and then
250:22 - for the ready game object we're going to
250:24 - set active based on if this player is
250:26 - true or not so for that let's make a
250:28 - function to get the ready state so back
250:30 - in this script let's make a simple
250:32 - function down here so if I'm like boom
250:34 - just is player ready I'm going to
250:36 - receive a year long for the client ID
250:38 - and simply Returns the player ready
250:40 - dictionary on this client ID okay that's
250:44 - it very simple and over here we're going
250:46 - to access that function so the character
250:47 - select running Let's test if is play
250:51 - Ready except over here an obvious
250:53 - question is we need the Yong long for
250:54 - the client ID so over here we need to
250:57 - somehow get the client ID based on the
250:58 - player index so let's go into the
251:00 - kitchen game multiplayer to get that
251:02 - over here let's make a function to get a
251:04 - certain player data so over here let's
251:06 - make one so a public player data call it
251:09 - get player data from player index and
251:13 - receive an end for the player index and
251:16 - we just return the player Data Network
251:18 - list on this index so the player index
251:20 - okay so that's it this way we can get
251:22 - the player data and then from the player
251:24 - that we can get the client ID so back in
251:26 - the script let's get the player data
251:28 - player data we go into the kitchen game
251:31 - multiplayer the instance let's get the
251:33 - player data from the index let's pass in
251:35 - this player index and then from this one
251:37 - we can grab the client ID and we can see
251:39 - if this one is ready and we also need to
251:41 - make sure that this one has the key so
251:43 - contains the key on this client ID
251:48 - okay so here let's create a game and
251:50 - there you go there it is now on this one
251:52 - let's play let's join the game okay we
251:54 - have two players now on this one let's
251:55 - set it's raining and if there you go we
251:57 - have a nice ready counter and yep it is
251:59 - synchronized and on this one let's ready
252:00 - as well and you have there you go the
252:02 - usual Reagan logic works and the game
252:04 - does start playing all right awesome
252:06 - okay so next let's handle the player
252:08 - colors first let's actually start by
252:10 - defining the colors so let's go over
252:12 - here onto the kitchen game multiplayer
252:14 - and let's make that so let's make
252:15 - another serialized film let's make it a
252:17 - list of type color call it the player
252:19 - color list now back here in the editor
252:21 - let's assign the colors and that object
252:23 - is created on Lobby scene so let's go
252:25 - there here we have the kitchen game
252:26 - multiplier and yep let's add all of the
252:28 - colors so let's add 10 colors let's
252:31 - start off with a simple nice yellow as
252:33 - usual and again importantly over here
252:35 - make sure to set the alpha and one on
252:36 - all the colors so we have a yellow then
252:39 - let's have maybe a nice green after that
252:41 - maybe a nice orange then a nice light
252:44 - blue something like this after that
252:46 - let's go with a nice purple maybe
252:49 - something like this then let's go with a
252:51 - bit more pink then maybe perhaps a
252:54 - darker blue and after that let's go with
252:56 - some basic ones so let's go with one in
252:58 - Pure White let's go one a bit in the
253:01 - middle and let's get one almost black
253:03 - okay great here are all the colors again
253:06 - make sure you have all of them on Alpha
253:08 - set as one you can see the little bar
253:10 - down here the little white bar if the
253:12 - alpha is on zero then it's in Black so
253:14 - make sure this one is fully Alpha as one
253:16 - okay so we have to find all the colors
253:18 - now let's make a script to handle the
253:20 - player Visual and apply a color so let's
253:22 - create a brand new c-sharp script call
253:25 - this the player Visual and now for
253:27 - attaching this we want to attach it to
253:29 - the visual itself so let's go back into
253:31 - the character select scene let's save it
253:33 - and over here on this one we do not want
253:35 - to attach it just on this prefab so
253:37 - let's open up this prefab then we have
253:39 - the point Visual and let's also go
253:41 - inside the player Visual and now here we
253:43 - add it so let's add the player visual
253:45 - component you want to make them like
253:47 - this so that this script is also hatch
253:49 - when we go into the game scene okay
253:50 - let's open this script and on this one
253:52 - let's begin by adding a film for the
253:54 - body and the head mesh so a serialized
253:56 - film private for a mesh render for the
254:00 - head mesh renderer another one for the
254:02 - body mesh Runner okay back in the editor
254:05 - let's drag them so Drag The Head and the
254:08 - body okay great and now in order to make
254:10 - sure that each player uses a different
254:12 - color we need to make sure to use a
254:13 - different material for each of them so
254:15 - over here let's store a material for our
254:18 - material and now importantly let's make
254:20 - a part for the wink and done away for
254:23 - this material let's construct a new
254:24 - material using the current material so
254:26 - basically we're going to clone it so
254:27 - let's go into the head mesh render grab
254:29 - the material and this is going to clone
254:31 - the exact same material so we do that
254:33 - and then we go into the head mesh render
254:34 - set the material onto this material and
254:36 - same thing for the body so this way we
254:39 - are making a clone so it doesn't apply
254:40 - to anything else if you don't do this
254:42 - then changing one material won't change
254:44 - the visual on all the players since they
254:45 - would all share the same material okay
254:47 - so now let's make a nice function to set
254:49 - a color so if only Droid set player
254:51 - color and we're going to receive a call
254:54 - and over here very simple just set the
254:55 - material.collar into this color the
254:58 - material is already being used by the
254:59 - body and the head so just modifying the
255:00 - material color will already change the
255:02 - visual now we want to set the column
255:04 - right away so let's do it on a private
255:06 - start so let's call set player color and
255:09 - to do that obviously we need to know
255:10 - which color to use so let's go here on
255:13 - to the kitchen game multiplayer and
255:15 - let's make a function together color so
255:17 - down here let's make that simple
255:18 - function so public return a color call
255:21 - it get player color and we're going to
255:23 - receive an end and let's call this the
255:25 - caller ID we're going to sort the caller
255:27 - ID in the player that in a little bit
255:29 - over here we just return go into the
255:31 - player color list and let's grab the
255:34 - color ID okay so with this we have a
255:36 - color and over here we can go into the
255:38 - kitchen game manager the instance and
255:40 - get the color and we need a caller ID
255:43 - and for now let's use the player ID as
255:45 - the car ID but again over here we have a
255:47 - problem we don't have any player ID so
255:49 - we can either make a function to set the
255:51 - player and X and sort over here or we
255:54 - can just call it from elsewhere so
255:55 - actually instead of setting the player
255:56 - color over here instead of that let's go
255:58 - over here onto the character select
256:00 - player and let's add a player visual
256:02 - player visual
256:04 - back in the editing let's write
256:06 - reference and let's exit out of this
256:07 - prefab save the changes and on this one
256:09 - let's write the reference to the player
256:11 - Visual and on this one we do have the
256:12 - player index so now here we can do that
256:14 - so when we update the player we're
256:16 - already grabbing the player data so
256:18 - let's go into this one set the color
256:19 - let's go into the kitchen game
256:21 - multiplayer let's get the color and pass
256:24 - in let's pass in the player index okay
256:26 - that should do it so now the second
256:28 - player should have a different color
256:30 - let's test and now here if we create and
256:32 - there you go that one is using default
256:34 - color now on this one if we join and if
256:36 - there go we have the second color all
256:39 - right awesome
256:40 - so now that the columns are working
256:42 - let's make a UI to manually select a
256:44 - different color over here on the
256:45 - character select scene let's go inside
256:47 - the canvas and let's create an empty
256:49 - game object
256:50 - come with the character color select UI
256:53 - let's zoom in on it well it's okay like
256:56 - this now inside of it let's make a
256:59 - button so inside a new UI button let's
257:02 - call this color zero we're going to
257:05 - basically dynamically change the color
257:07 - of this button so let's put it with a
257:09 - width and height of 100 by 100 and
257:11 - inside let's get rid of the text we only
257:13 - want an image okay so this is our
257:15 - counter button but instead of a square
257:16 - and let's go with the circle so let's
257:18 - select let's say the default knobs right
257:21 - basically through code we're going to
257:22 - modify the color here in order to set
257:24 - the color that this one will change and
257:26 - now inside let's make another UI image
257:29 - and call this the selected and for this
257:32 - one for the Sprite let's go let's say
257:34 - over here the circle dashed let's put it
257:36 - to stretch to occupy everything and put
257:37 - it just a little bit smaller so five on
257:40 - all of these and that one is barely
257:41 - visible so let's also add an outline
257:43 - let's make it in full Alpha and put it
257:47 - maybe a little bit bigger okay so just
257:49 - like that this is going to be a single
257:52 - button and now for spawning this we can
257:54 - do it dynamically so just by spawning
257:56 - templates just like we've already done
257:58 - so many times before or we can just make
258:00 - it manually let's make it manually since
258:02 - when we did quite a lot of things
258:03 - dynamically so on the parent for
258:06 - organizing let's create a horizontal
258:08 - layout group let's put it right down the
258:10 - middle Center and let's add a little bit
258:12 - of spacing okay then inside before we
258:15 - duplicate this let's actually make this
258:16 - into a prefab so let's drag it let's
258:19 - rename this to a more proper name so
258:20 - character color select this is the
258:23 - single UI so it's select a single color
258:26 - and now let's place 10 colors okay let's
258:29 - give them proper names and over here on
258:31 - the parent let's stretch it out choose
258:33 - this one so it stretches on the left and
258:35 - the right and then for the position
258:37 - let's put it a bit more down there and
258:39 - also this is a bit way too much space so
258:41 - over here on the channel Force expand
258:42 - let's not expand on the width okay just
258:45 - like that those are some nice buttons
258:46 - now let's make these script to run this
258:48 - so with the exact same name let's create
258:50 - a brand new c-sharp script for our
258:52 - character color select UI and now let's
258:54 - make a script to run this next up we're
258:56 - going to attach the script to each
258:57 - button and now to the actual main
258:59 - container so on each button let's go
259:01 - inside the prefab and let's make a
259:04 - script with the exact same name so let's
259:05 - create a brand new sharp script let's
259:07 - attach it to the prefab itself so right
259:09 - over here so the character color select
259:12 - single UI all right now let's open it
259:15 - and over here first let's add a whole
259:17 - bunch of fields
259:18 - so it's your nice film first let's add
259:20 - an end for the caller ID this is going
259:23 - to be different on a per button basis
259:24 - then let's add an image so it's going to
259:26 - be the image that we're going to modify
259:28 - so that's image not image conversion so
259:30 - image the one inside EMT engine.edui
259:32 - okay we have the image and then a game
259:35 - object for the selected game object okay
259:37 - let's save and back in the editor let's
259:39 - drag all of our references so first of
259:41 - all for the image that's this one up
259:43 - here so let's drag the image then the
259:44 - color ID we're going to set it outside
259:46 - the prefab and drag the selection okay
259:48 - great so now let's go outside let's save
259:50 - the changes and over here and let's set
259:52 - the indexes so this one is on zero this
259:54 - one is on one this one two and so on all
259:58 - right we have all of our caller IDs now
260:00 - over here let's make a simple private
260:02 - void start and on start let's basically
260:04 - set the image color so for that let's go
260:06 - into the kitchen game multiplayer the
260:08 - instance and let's get the player color
260:10 - and this one takes equality so let's
260:12 - grab this caller ID
260:14 - and set the image.color on this color
260:17 - okay so that sets the image color then
260:19 - we need to know if this color is
260:21 - selected so let's make a private void
260:24 - call it update is selected and on this
260:26 - function basically we need to know if
260:28 - the unlockable player is selected or not
260:30 - so for that over here on the kitchen
260:31 - game multiplier let's make a function to
260:33 - get the player data for the local player
260:35 - so let's make a public return the player
260:38 - data and let's call it just get player
260:40 - data with no parameters and with no
260:42 - parameters we can basically just go into
260:44 - the network manager the Singleton and
260:47 - get the unlock client ID so now we just
260:49 - need to get the player data with this
260:51 - client ID so let's make another function
260:53 - to do that so public return player data
260:55 - call it get player data from client ID
260:59 - and we're going to receive a young loan
261:02 - for the client ID and over here it's
261:03 - pretty simple let's just cycle through
261:05 - our player data so player data in our
261:08 - player Data Network list
261:10 - so we second through that and if the
261:12 - player data if the player that the
261:14 - client ID matches this client ID then
261:17 - Yep this is the one that we want so
261:18 - let's return the player data
261:20 - if we get down here then we didn't get
261:22 - it this one is never going to reach here
261:24 - but so we need to return just a basic
261:27 - default okay so we have this one so then
261:29 - down here and let's get the player data
261:31 - with the only compliant ID and return
261:32 - this okay so now we have the player data
261:35 - for the unlocking client and now I can
261:36 - hear the test if this color is selected
261:38 - let's check
261:40 - if the kitchen game multiplayer instance
261:43 - let's get the player data for the local
261:45 - player so get the player data if this
261:47 - one dot Comer ID so we need to store the
261:49 - caller ID on the player data so we're
261:52 - here on the player data we're
261:53 - synchronizing the client ID and let's
261:54 - also store an end for the caller ID and
261:58 - let's make sure to update all these so
261:59 - this one equals if the client ID equals
262:01 - and the caller ID equals the other dot
262:05 - caller ID and for serializing we also
262:08 - need to do the same thing so the caller
262:09 - ID okay great so now back in this script
262:12 - we have the player data let's grab the
262:14 - caller ID and if this one matches the
262:16 - unlock caller ID if so then let's go
262:19 - into the selected game object set active
262:21 - into true and if not let's set active
262:24 - into false and up here on start let's go
262:26 - ahead and modify this and if just like
262:29 - this it should work by default now of
262:31 - course the one missing thing is when we
262:32 - change color but let's actually handle
262:34 - that first before we handle the event
262:35 - for change the color it's going to be by
262:37 - clicking on this UI button so let's make
262:40 - a private it awake and the button is on
262:42 - the subject itself so let's say we get
262:44 - component of type button on this one
262:46 - let's add a listener to the on click
262:48 - event so when we click on this button
262:51 - basically we want to tell the kitchen
262:53 - game multiplier to change the color so
262:55 - let's go into the kitchen game
262:56 - multiplayer onto the instance and let's
262:58 - call some function to change player
263:00 - color and we're going to change the
263:02 - player color onto this new color ID okay
263:05 - so we just need to make this function so
263:07 - back here on the kitchen game
263:08 - multiplayer let's make that function so
263:10 - here public void and we're going to
263:12 - change the player color onto this new
263:14 - color ID
263:15 - and to do that as always we're going to
263:17 - first run it the logic on the server so
263:19 - we're going to need a server RPC so A
263:22 - Private Ryan change player color server
263:24 - RPC we're going to receive an end for
263:26 - the caller ID and then we also need to
263:28 - know which player is changing color so
263:29 - let's receive the usual server RPC
263:32 - params
263:33 - and let's default them okay so this is a
263:36 - server RPC with require ownership as
263:38 - phones so when we change the color let's
263:41 - trigger the server RPC pass in the
263:43 - caller ID alright so here we have a nice
263:46 - server RPC and this player is asking to
263:48 - change their color now first of all
263:50 - let's do some basic validation just make
263:52 - sure the color is unused although this
263:54 - is a design decision if you wanted you
263:56 - could allow the same colors for multiple
263:58 - players but here I'm not going to allow
263:59 - that so let's make a function to check
264:01 - if a color is available
264:04 - so private ball is color available going
264:07 - to receive an in for the caller ID and
264:10 - on this one let's just cycle through all
264:11 - the player data and see if any of them
264:13 - is already using this same caller ID so
264:15 - let's do it for each for your data for
264:17 - your data in the player Data Network
264:19 - list
264:20 - and on this one if the employer data if
264:23 - this one does caller ID matches this
264:25 - caller ID
264:26 - then this one is not available so this
264:28 - one is already in use so let's return
264:30 - false and if we get down here then this
264:33 - color is available so let's return true
264:35 - snap here on the server PC we can check
264:37 - first of all if the color is not
264:38 - available so is color available on this
264:41 - caller ID
264:42 - so if this one is not available then
264:45 - color not available and if so we're not
264:48 - going to do anything so let's just
264:49 - return
264:50 - but if it is available then let's
264:52 - basically update the player data and how
264:55 - you do that remember that on a player
264:56 - network list we're using a struct so we
264:58 - first need to grab it then modify it
265:00 - then update it so in order to grab it we
265:03 - are going to need the player.index so
265:05 - let's make a function to convert a
265:06 - client ID onto a player that index so
265:08 - it's actually going to be very similar
265:10 - logic to this one except we'll return an
265:12 - INT and over here instead of four each
265:14 - let's do a simple four so four
265:17 - cycle through this list account and then
265:20 - we just check if this one on this index
265:23 - if the client ID matches this client ID
265:26 - if so then let's return this index and
265:29 - if not let's return -1 so this Returns
265:32 - the get player data index from the
265:34 - client ID okay great so we have this
265:36 - function and then down here let's grab
265:38 - that so an in for the player.index and
265:41 - we call that function and pass in the
265:43 - server RPC params let's go into the
265:45 - receive and the sender client ID
265:47 - so with that we have the player that
265:49 - index then let's grab the player data
265:51 - player data and we go in the player Data
265:54 - Network list on this player data index
265:56 - so we grab this player data now we
265:58 - modify it so let's modify the counter ID
266:00 - to the new counter ID and then we need
266:02 - to save it back onto the same list so we
266:04 - access it on the same index and we set
266:07 - player data equals this
266:08 - okay just like this when working with
266:11 - networking lists you need to do this if
266:12 - you just were to do just like this dot
266:15 - counter ID equals counter ID if you do
266:17 - it yep you have an error you cannot
266:19 - modify it directly so that is why we
266:21 - need to First grab it then modify it
266:23 - then upload the new changes okay so this
266:25 - will update the color and let's also
266:27 - default the color when a new player
266:29 - joins so if we go up here when we are
266:32 - creating a brand new one we are
266:33 - constructing a new player data so over
266:35 - here let's set the counter ID to
266:37 - something and let's set it to the first
266:38 - and use color so down here let's make
266:40 - another nice Hopper function so probably
266:43 - then get first unused caller ID and
266:47 - let's just cycle through the color array
266:48 - so for INT E equals zero once I go
266:52 - through the player colorless dot count
266:54 - and then just check is color available
266:57 - so is caller available on this color
267:00 - index if it is available return this one
267:02 - if not then we keep cycling and in the
267:05 - end it will never reach here because we
267:06 - are not going to have 10 players but so
267:08 - let's return just minus one okay so we
267:11 - have this function and then up here when
267:14 - a new client joins let's give them the
267:16 - first brand new unused caller ID okay so
267:19 - after all that all the clients should
267:21 - have a different color ID all that's
267:22 - left is over here on the button so we
267:24 - change the button in order to modify the
267:25 - corner ID then we just need to update it
267:27 - and how we're going to do that well
267:29 - since we're modifying the list we can
267:31 - just listen to that event so on the
267:33 - kitchen game multiplier the instance we
267:35 - have the event on the network list
267:37 - change so in this list changes when this
267:40 - happens then let's just update the
267:42 - actual visual so this one just like this
267:45 - okay so with this let's test just one
267:48 - final thing which is over here on the
267:49 - character select player over here we
267:52 - made it just using the player index but
267:53 - now we already have the car index
267:54 - someone's going to play your data grab
267:56 - the caller ID just like this okay so
267:58 - let's test okay so on this one let's
268:00 - create a game and yep right away we do
268:02 - see the whole UI with all the colors and
268:05 - if I click on them if you do see the
268:06 - player does change the color alright so
268:09 - that's awesome now this one down here
268:11 - let's join the game and there you go it
268:13 - does choose the first available counter
268:15 - so we chose the green and if I try
268:16 - selecting a different color and yep it
268:18 - works and if I try selecting the same
268:20 - color and nope that one does not work
268:21 - okay great and now if we both ready and
268:24 - go into the game scene any of this is
268:26 - the only thing that we still need to do
268:27 - we need to update this color so for that
268:29 - we have two options we could go over
268:31 - here onto the player script add a
268:33 - reference to the player Visual and set
268:34 - the color or we could do it over here on
268:36 - the player visual the only thing is we
268:38 - would need to modify the Model Behavior
268:39 - in order to make it into a network
268:41 - behavior that way we could know which
268:43 - owner owns this player visual so both
268:45 - options are valid let's do it over here
268:48 - on the player just so we don't mess up
268:49 - anything and add a network object onto
268:52 - just the visual so let's add a new one
268:55 - for the player visual player visual back
268:58 - in the editor let's go inside the player
268:59 - prefab and let's drag the player visual
269:01 - reference okay there it is and over here
269:04 - on search very simple just call set
269:06 - color so we need to pass in the player
269:08 - color so let's grab the player data
269:10 - player data go into the kitchen game
269:12 - multiplayer the incense get the player
269:15 - data and now we don't want just in local
269:17 - player we want it for this owner client
269:20 - ID so we need to make a function that
269:22 - takes a client ID we already have it's
269:24 - this different one so let's use this one
269:27 - to get the pointer data and then set the
269:29 - player color go into the kitchen game
269:30 - multiplier the instance get the player
269:32 - color and use the player data dot caller
269:35 - ID okay so let's test okay so here let's
269:38 - create the game on this one let's go
269:39 - with a purple then on this one play
269:41 - let's join on this one let's go with a
269:43 - light blue let's ready and on this one
269:45 - ready and the game is loading let's go
269:48 - and there you go we have two players
269:49 - with two different colors alright
269:52 - awesome okay so everything is currently
269:54 - looking great but here on the character
269:56 - selection we actually have one issue now
269:59 - if I disconnect this player and nope
270:01 - that one did not disappear and now if I
270:03 - try connecting a brand new one so join
270:04 - the game and there you go that one took
270:06 - another spot even though that player has
270:08 - now disconnected basically the issue is
270:10 - with our network list we need to remove
270:12 - the players when they leave so over here
270:13 - and let's listen to the other comeback
270:15 - over here on the host we already have
270:16 - one down here on the client so let's
270:19 - actually rename this to give it a more
270:20 - proper name so client on client
270:23 - disconnect comeback then up here let's
270:26 - make another function so network manager
270:28 - Singleton on client disconnect comeback
270:31 - and here let's give it a different name
270:33 - so on the server okay let's make this
270:35 - one it's over here
270:37 - we have the client ID of the client that
270:40 - just is connected so then let's just
270:42 - cycle through it so for end on the
270:45 - player.networklist.com
270:47 - let's cycle through it and see if it was
270:48 - this one so the player data player data
270:51 - so we check if the player data dot
270:54 - client ID matches the one that was
270:56 - disconnected then it's this one that was
270:58 - disconnected so now let's just remove it
271:01 - from the list so player Data Network
271:03 - list and let's call remove at and remove
271:05 - on this index okay and just like that
271:07 - everything else should be working
271:08 - because everything else is listening
271:10 - when this one changes so let's test okay
271:12 - so on this one let's create the game on
271:14 - this one let's join okay now disconnect
271:16 - any after you go that one is gone okay
271:18 - great now one more thing let's set the
271:20 - ability for the server to kick a player
271:22 - so let's go on the character select
271:24 - scene let's go inside this player prefab
271:26 - let's zoom in and look at it and on this
271:29 - one let's add a button so let's go into
271:30 - UI let's create a new UI button let's
271:34 - call this the kick button and for the
271:37 - canvas this one let's make it a warm
271:39 - space for time zero zero zero everything
271:41 - on zero let's lift it up by a little bit
271:44 - and for the kick button let's get rid of
271:46 - the text inside silent we just want an
271:48 - image so let's put this one really small
271:51 - so maybe 0.3.3 and let's lift up the
271:54 - canvas by a little bit okay something
271:56 - like this and for the image instead of
271:58 - this one let's go with the nice cross
272:00 - Sprite okay it's actually a bit too big
272:02 - so maybe on point 2.2 all right now on
272:04 - this script let's add a reference to our
272:07 - brand new button
272:08 - so the button for the kick button and
272:11 - over here let's write the reference to
272:13 - the kick button okay and now first of
272:15 - all we need to make sure that this one
272:17 - is only visible to the server so over
272:19 - here on certain let's put this one game
272:20 - object set active and it's only going to
272:23 - be active if the network
272:26 - manager.singleton.is server so this one
272:28 - is only going to be visible on the
272:29 - server then let's set the click function
272:31 - so private void awake on the kick button
272:34 - the on click let's add in listener to it
272:37 - and now on this one let's make a
272:39 - function to kick the player so let's go
272:41 - in the kitchen game multiplier and over
272:43 - here let's make a function to do just
272:45 - that so probably void kick player and
272:48 - we're going to receive a yield long for
272:49 - the client ID
272:51 - over here it's actually very simple
272:52 - let's access the network manager the
272:54 - Singleton and let's just call disconnect
272:56 - client and over here we pass in the
272:58 - client ID just like this then over here
273:01 - on this one we just need to know the
273:02 - client ID so let's grab the player data
273:04 - from this index
273:06 - and from there on let's go into the
273:08 - kitchen game multiplayer the incense and
273:10 - let's kick this player so the player
273:11 - data and it has a client ID okay so this
273:15 - is going to disconnect that client
273:17 - however just like this there's actually
273:19 - going to be no visual the client won't
273:21 - be disconnected but it will still look
273:23 - like it's still on the same server so
273:25 - let's add a nice visual and for that we
273:27 - can actually go into the game scene and
273:29 - over here inside the canvas we
273:30 - previously already made over here the
273:32 - host disconnect UI the logic is going to
273:34 - be exactly the same so let's just copy
273:36 - this go inside the character select
273:38 - scene inside the canvas and let's paste
273:40 - it and there you go the host disconnect
273:42 - UI although we just have to do one
273:45 - change over here on this script we are
273:47 - listening to the event and one thing
273:49 - like we saw previously on this scene the
273:51 - character select scene this script isn't
273:53 - going to have the same lifetime as the
273:55 - network manager this UI object won't be
273:57 - destroyed as the network management
273:59 - lives on so we need to do just like we
274:01 - did before we need to clean up this
274:02 - event so let's make a private Droid on
274:05 - Destroy and on Destroy and let's make
274:07 - sure to unsubscribe from this event so
274:09 - let's do minus equals like this although
274:11 - at the same time I'm not entirely sure
274:13 - what is the order of execution
274:15 - you know there's still one more sneaky
274:17 - issue for some reason when kicking a
274:19 - player that doesn't actually trigger the
274:21 - disconnect comeback so the function that
274:23 - we have up here to clean up the list
274:25 - this one is not going to be
274:27 - automatically triggered so let's make
274:28 - sure to manually trigger it so when we
274:30 - kick a player let's click them and then
274:33 - call the same function to update the
274:34 - list okay so let's test okay so here on
274:37 - let's create a game then on this one
274:39 - down here let's join it and now the
274:41 - server doesn't like me for some reason
274:43 - so server is going to kick me and there
274:45 - you go Hostess is connected play again
274:46 - and now I can try joining again and yep
274:48 - it works okay great let's just hand on
274:51 - one more final thing that we made quite
274:53 - a while ago so here I joined then I was
274:56 - kicked then I joined again remember that
274:58 - the server does not reuse client IDs so
275:01 - the client IDs are not sequential so
275:03 - actually what we have here is the server
275:05 - is on IDF zero and this one is on ID of
275:07 - 2 because the one was kicked so it's
275:09 - actually kicked this one a few more
275:10 - times so let's kick and join again so
275:13 - now this one has an ID of three now
275:15 - let's kick in and join again so now this
275:18 - one has an ID of zero and this one an
275:20 - idea four so now if we hit on ready and
275:22 - if there go there we have our error we
275:24 - can see where this area is being spawned
275:26 - over here on the player any outputs this
275:29 - code that we wrote quite a while ago so
275:31 - it's using the owner client ID and the
275:33 - spawn position list only has four
275:34 - positions so we're here instead of
275:36 - positioning the players based on the
275:37 - owner client ID instead of that let's
275:39 - use the player index so let's go into
275:41 - the kitchen game multiplayer and let's
275:44 - get the player index
275:46 - and pass in the owner client ID okay so
275:49 - let's see okay so create so this one now
275:51 - has index 0 and let's join and on this
275:55 - one instead of being kicked and let's
275:56 - actually leave voluntarily and let's
275:58 - join again so now this one has index 2
276:00 - and let's leave join again that one has
276:03 - index three leave join again okay so now
276:05 - we have index 0 and 4 and if we both hit
276:08 - on ready and if they go it does work and
276:11 - they are positioned perfectly exactly
276:12 - where they should be all right awesome
276:14 - now there's just one more thing we need
276:16 - to clean up which is over here let's
276:18 - create a game over here on let's play
276:19 - let's join okay let's hit on ready and
276:22 - both start playing the game and yep okay
276:24 - everything seems correct and on this one
276:26 - I'm going to disconnect and there you go
276:28 - we have an error we can go and see where
276:30 - it is
276:31 - and if it's right in here so it's the
276:33 - same problem as previously we got an
276:35 - event but the kitchen game multiplayer
276:37 - this one is leaving longer than this one
276:38 - so we need to make sure to unsubscribe
276:40 - from these so as usual prep void on
276:43 - Destroy and on Destroy let's unsubscribe
276:45 - from this event let's see where else we
276:48 - are adding listeners over here on the
276:50 - character select player the character
276:52 - select already has the same lifetime but
276:53 - the this one we need to unsubscribe so
276:56 - the same thing proud void on Destroy
276:59 - and let's unsub from this event okay I
277:02 - think those are the only two so let's
277:03 - test so let's create the game on this
277:05 - one let's join set is ready and let's go
277:08 - inside and over here yep it's working
277:10 - now let's go outside and if there you go
277:12 - no more errors alright awesome okay so
277:16 - here we created the really nice
277:17 - character select Scene It supports
277:19 - joining players then each player can
277:21 - customize their color the server can
277:23 - kick the players and each player can set
277:25 - their ready State when they are already
277:27 - the game finally begins so with this
277:29 - done the next thing we really need is
277:30 - handling the lobby so let's do that in
277:32 - the next lecture
277:35 - hello and welcome I'm your code monkey
277:37 - in this lecture we're going to create
277:39 - our own Lobby scene where the players
277:40 - can create games and then other players
277:42 - can browse the games and join them okay
277:44 - so here on let's build their own Lobby
277:46 - now this is a tool that I've covered in
277:48 - detail in a previous video so pause the
277:50 - course right now to go watch that one in
277:52 - there I cover pretty much everything
277:53 - about this tool here I'm focused mainly
277:55 - on using the 2 only then explain every
277:57 - single thing so I will assume that
277:59 - you've seen that video
278:00 - okay so first of all we need to install
278:02 - the package so let's open up the package
278:03 - manager let's go over here on dn2
278:06 - registry under all and let's look for
278:08 - the lobby so here it is let's go ahead
278:11 - and install okay there it is it
278:12 - installed and over here in the
278:14 - dependencies it also installed as a
278:15 - dependency of the authentication package
278:17 - okay so that's great let's close this
278:19 - window and right away we see this window
278:21 - basically in order to start using Lobby
278:23 - we need to enable it in the Unity gaming
278:25 - services so that means we need to go on
278:27 - to the project settings but before we do
278:30 - let's make sure we are signed in so up
278:32 - here on the top left corner there should
278:33 - be a button and it should be with your
278:35 - account if this button is disabled then
278:37 - says sign in then go ahead close Unity
278:39 - open the unity Hub and make sure you are
278:41 - signed in there okay so with that then
278:43 - you can click on this button to go to
278:45 - the project settings or just manually go
278:46 - into edit project settings and out go
278:49 - into the services now over here we can
278:52 - create a brand new ENT project or we can
278:54 - use an existing one
278:55 - so if you already have one you can link
278:57 - it or you can also go to the dashboard
278:59 - and create one there so here I am on the
279:01 - NT dashboard I'm going to go and select
279:03 - the projects and create a brand new
279:04 - project I'm going to call this kitchen
279:06 - chaos multiplayer and nope this one does
279:09 - not Target children okay what's great
279:12 - all right the project was created great
279:14 - so now back here into Unity we can
279:16 - select the organization and then go
279:18 - ahead and select the project so I'm
279:20 - going to select the one that I just
279:21 - created so kitchen chaos multiplayer and
279:23 - just go ahead and Link the project ID
279:25 - alright so the project has been linked
279:27 - that's great now let's go back here onto
279:29 - the NT dashboard and we need to enable
279:31 - Lobby so let's make sure the project is
279:33 - selected and then let's go over here on
279:35 - the left side to multiplayer then let's
279:37 - go into the lobby and over here let's
279:39 - click the button to set up Lobby and
279:41 - then we've got a bunch of basic steps so
279:43 - first of all link DNT project and yep we
279:44 - already did this then install the
279:46 - package already did this and finally
279:48 - turn the lobby on so let's click and
279:50 - turn it on and there you go so let's go
279:51 - on next and if there you go we are
279:53 - finished okay great some Lobby is now
279:55 - enabled with that let's begin using it
279:57 - and again here I'm going to assume that
279:59 - you've seen that Lobby video and you
280:01 - have a basic idea for how the API works
280:03 - here we're just mainly going to use it
280:05 - so first over here on the lobby scene
280:07 - let's begin by creating a new empty game
280:09 - object currently the kitchen game
280:12 - lobbying let's reset transform and let's
280:15 - make a script for it so a script with
280:17 - the same name
280:20 - and let's go ahead add the script and
280:23 - open okay so now here on this script
280:25 - we're going to handle everything related
280:27 - to our lobby and since we're also going
280:29 - to need to access the lobby when we
280:31 - enter into the character select scene in
280:33 - order to get things like the unlocking
280:34 - and the code in order to do that let's
280:36 - make sure to also Mark this object as
280:38 - don't destroy and load so let's make a
280:40 - private way to wake
280:42 - and over here let's make sure to set
280:44 - don't destroy unload and don't destroy
280:46 - this game object okay so that's great
280:48 - then since we're doing this we also need
280:50 - to mark it for cleanup
280:51 - it's over here on the main menu cleanup
280:53 - button let's make sure to destroy it so
280:55 - let's also implement the Singleton
280:57 - pattern
280:58 - so if I can hear make a public static
281:00 - kitchen game Lobby for the instance
281:02 - would they get any private set
281:06 - on a way to set this one equals this
281:08 - okay
281:09 - so over here on this side let's do the
281:11 - exact same thing so let's go into the
281:13 - kitchen game Lobby and if this one
281:16 - exists let's clean it up okay great so
281:18 - now over here let's first begin by
281:20 - initializing the unity services so let's
281:23 - make a function to do just that so
281:25 - initialize Unity Authentication
281:30 - here we first go into Unity Services
281:32 - which is inside unity.services.com
281:36 - and let's call initialize async then as
281:39 - usual for these functions these are
281:40 - meant to be available so let's wait and
281:42 - since we are calling it with a weight up
281:44 - here we need to make sure to use async
281:46 - okay so that is going to initialize and
281:48 - we're going to come with appear on our
281:49 - way all right so that is going to
281:51 - initialize Unity services and afterwards
281:53 - let's go inside the authentication
281:55 - Service so it's this one inside Unity
281:57 - Services Authentication
281:59 - let's access the static instance and
282:01 - let's sign in anonymously
282:04 - and once again this one is also an
282:06 - awaitable column okay great now one
282:09 - thing the way we have set up this object
282:11 - is it won't be destroyed and then
282:13 - recreated whenever we go back to the
282:15 - lobby but you cannot initialize the
282:17 - services more than once if we do then
282:19 - we're actually going to have an error so
282:20 - we need to make sure we only run this
282:22 - once and for that we can access the
282:24 - unity services and over here we have a
282:26 - state and there's a bunch of states
282:29 - like for example we can check if it is
282:31 - not initialized so if this one is not
282:33 - initialized so if it is not initialized
282:36 - then we're going to initialize it okay
282:38 - that's good now one more thing which is
282:41 - Lobby Works based on the player ID that
282:43 - the authentication Service generates
282:45 - and if we run multiple Builds on the
282:47 - same PC then we'll actually all have the
282:49 - same player ID so if we do it just like
282:51 - this we can actually test with multiple
282:53 - builds because they're only going to
282:55 - have the same player ID so some of that
282:57 - we can basically initialize with a
282:58 - different profile every time so appear
283:01 - on the initialize async for the entity
283:03 - services
283:04 - this one takes a initialization options
283:06 - so let's create that
283:08 - let's create a new initialization
283:10 - options
283:11 - and on this object we can then call set
283:14 - profile and we can pass in some profile
283:16 - name so basically we want to pass in a
283:19 - new unique name every time just so we
283:20 - can run multiple business for testing so
283:23 - in order to get a new name let's just do
283:25 - random.range and generate a random
283:27 - number
283:29 - this one requires a string so much just
283:31 - do two string like that okay so now this
283:33 - will initialize with different name
283:34 - every time okay that's great so with
283:36 - this we can test with multiple builds so
283:38 - this handles the authentication part now
283:41 - let's end on creating and joining in
283:42 - lobby so over here let's make a simple
283:45 - function let's make it only because
283:47 - we're going to college from the UI
283:48 - script void call it create Lobby and to
283:51 - create on Lobby we're just going to need
283:53 - a string 14 Lobby name and then a
283:55 - Boolean for is private in order to
283:57 - create another pirate or public lobbys
283:59 - then over here the way we create we go
284:01 - inside in lobby service the instance and
284:04 - we call create Lobby async this one
284:06 - takes in a Lobby name so let's press in
284:08 - the unlocking name then it takes the
284:10 - maximum number of players and we
284:12 - actually already defined that over here
284:13 - on the kitchen game multiplier script
284:15 - we've got a content for the max player
284:16 - Mount let's just make this one public
284:19 - so now back in here we can go into the
284:21 - kitchen game multiplayer and grab the
284:23 - max player Mount okay
284:24 - and then for the is private we need to
284:26 - create some options so let's create some
284:29 - new create and Lobby options and over
284:31 - here we can set this private onto this
284:33 - is private
284:35 - okay so this function is going to
284:37 - actually create a Lobby and as usual
284:39 - this one is available and this one is
284:40 - going to return in lobby when it
284:42 - completes so let's first of all put in a
284:44 - weight and we want to keep track of
284:46 - which Lobby we are either creating or
284:48 - joining so let's go up here in order to
284:50 - Define that
284:51 - so let's make a private of type Lobby so
284:54 - it's this one inside Unity services and
284:55 - lobbies models so this is going to be
284:58 - our join Lobby so this Lobby that we
285:00 - have joined and as soon as we create one
285:02 - let's set this one equals this
285:05 - and since we're using a weight up here
285:06 - we also need to mark it as async okay
285:09 - great so this is going to create the
285:11 - unlocking and now one thing that I
285:13 - mentioned in the lobby video which is of
285:15 - these function calls all of these can
285:16 - throw an exception so in order to make
285:18 - sure our game doesn't break we need to
285:20 - put this inside a try catch so let's put
285:22 - a try and then let's see we catch we're
285:24 - going to catch a Lobby service exception
285:28 - and if we have it let's just do debug
285:30 - download unlock on this okay so this is
285:32 - going to create our lobby
285:34 - and following through with our
285:35 - connection flow after creating Lobby we
285:37 - want to join our game we want to
285:39 - actually start the host so you can
285:41 - inspect over here the testing buttons
285:42 - that we were using previously so we
285:44 - can't start host and then load the scene
285:46 - so let's do exactly this
285:48 - over here after creating a brand new
285:50 - Lobby let's see exactly this okay so
285:52 - this will create a Lobby and then we're
285:54 - going to start host and start going into
285:56 - the character selecting before we can
285:58 - test we also need some way to join in
286:00 - lobby so let's also make that function
286:02 - so a public let's call it
286:05 - quick join
286:07 - and over here we're going to use the
286:09 - super useful quick join function so the
286:11 - lobby service let's access the instance
286:13 - and over here let's just do the quick
286:15 - join Lobby async and as usual let's
286:17 - await this which means we need to mark
286:19 - this as async and this one is also going
286:21 - to return the joint Lobby so join Lobby
286:23 - and again we need to put this inside a
286:25 - try catch for the lobby service
286:28 - exception
286:32 - okay so with this we joined the lobby
286:34 - and then for externally joining all we
286:35 - do is start client
286:37 - so let's do exactly that exactly the
286:39 - same thing
286:40 - okay great so with these two basic
286:42 - functions we should now be able to
286:43 - create a Lobby and then join it so for
286:46 - testing that out let's make a nice UI
286:47 - window
286:48 - over here on Lobby scene let's go into
286:50 - the canvas create an empty game object
286:51 - call this the lobby UI let's stretch it
286:55 - to occupy everything so put zero on
286:57 - everything now let's make some proper
286:59 - buttons
287:00 - so inside let's create a new button and
287:03 - this is going to be the main menu button
287:05 - and let's anchor it on the top left
287:07 - corner so something like that push it up
287:09 - there and push it like this then for the
287:12 - button itself let's make it in a dark
287:14 - gray and inside for the text let's put
287:16 - it in bone text in white and say main
287:19 - menu okay that's the main menu button
287:21 - great now we want a button to create a
287:24 - Lobby and want to do a quick join
287:26 - so let's make those two let's simply hit
287:28 - this one
287:29 - for the create Lobby button another one
287:31 - for the quick join button now let's just
287:34 - position these buttons so let's put it
287:36 - over here a bit off to the side some
287:38 - like this
287:39 - and let's modify the text inside of them
287:42 - so this one create Lobby
287:44 - and on the other one let's do a quick
287:46 - join
287:48 - okay we have these buttons and we also
287:50 - normally need the testing Lobby y so
287:52 - let's hide that one okay there you go
287:53 - it's disabled now let's make the script
287:55 - to run this so let's create the new
287:57 - c-sharp script we'll have UI let's go
288:00 - ahead and attach the script and open and
288:03 - now here let's make the usual things so
288:04 - let's grab our buttons so a serialized
288:06 - film
288:08 - private button for the main menu button
288:10 - and another one for the create Lobby
288:13 - button and finally the quick join button
288:17 - back here in the editor let's drag our
288:19 - references so the main menu the create
288:21 - Lobby and also the quick join okay great
288:23 - so now here let's make our Behavior so
288:25 - on awake let's add some listeners so the
288:27 - main menu button the on click let's add
288:30 - a listener
288:31 - and for this one's very simple we just
288:33 - go back to the main menu so we just even
288:35 - loaded it up and load so we use load and
288:37 - upload Network because over here we
288:39 - still don't have an active connection so
288:40 - let's use load and for the scene let's
288:42 - go back into the main menu okay that's
288:44 - it now for the other two buttons so the
288:47 - create Lobby and the quick join
288:50 - for the create Lobby let's go into the
288:51 - kitchen game Lobby the incense and
288:53 - concrete Lobby this one takes in lobby
288:56 - name and then is private or not so for
288:57 - now let's just send in lobby name and
289:00 - then it's private let's put it as phones
289:01 - so we can join with quick join and on
289:03 - this one same thing kitchen game Lobby
289:05 - instance and let's just do a quick join
289:08 - okay great so these buttons should be
289:10 - working let's test okay so now on this
289:13 - one up here let's go ahead and create a
289:14 - Lobby and if there you go it does go
289:16 - into the character selection screen okay
289:18 - so that's great and on this one down
289:20 - here let's hit on play and now let's do
289:21 - a quick join and if there you go they
289:23 - both connected all right awesome now I
289:26 - should point out one very important
289:27 - thing here which is right now this is
289:30 - actually not really joining this
289:31 - specific game
289:32 - if we made a second Lobby it would still
289:35 - join on the exact same game the reason
289:37 - for that is because we are still hosting
289:38 - and connecting to the same IP on the
289:40 - same port
289:41 - if we look on the entity transport in
289:43 - order to connect to an IP you need to
289:44 - set it here we then set anything so we
289:46 - are still hosting on localhost on this
289:48 - board so if we made another Lobby it
289:50 - would still be hosting the exact same IP
289:52 - exact same port so exact same session in
289:54 - order to make an actual separate
289:56 - instance of a game we would need to host
289:57 - on a different IP and then we would need
290:00 - to use that IP in order to make the
290:01 - right connection or the alternative is
290:03 - to use relay which is what we're going
290:05 - to implement in the next lecture
290:07 - so I just wanted to quickly point that
290:08 - out right now right now this is creating
290:11 - separate lobbies but not separate
290:12 - sessions that will be handled when we
290:14 - set up the relay in the next lecture
290:16 - okay so like this we have the basic
290:18 - create and quick join working now let's
290:20 - expand upon it and make a window to
290:22 - Define some options when creating a
290:24 - Lobby
290:24 - so back here in our lobby scene let's
290:26 - create an empty game object call it the
290:28 - lobby create UI inside let's make a UI
290:32 - image let's name it the background let's
290:34 - make this one stretch to occupy
290:36 - everything let's put it in black and
290:38 - let's stretch out the apparent a little
290:40 - bit so let's size it to occupy something
290:42 - like this okay great let's put it on X
290:44 - of zero all right now inside let's also
290:47 - make a simple text just a nice label so
290:50 - for this one let's just say create Lobby
290:53 - let's put it in bold Center middle no
290:55 - wrapping and width and height on zero
290:57 - zero okay so the usual setup then we
291:00 - need some way to input the unlocking
291:01 - name so inside let's create an input
291:03 - field let's call this the lobby name
291:06 - input field let's move it a little bit
291:09 - up there
291:10 - and over here on the inspector we can
291:12 - play around the input field and let's
291:13 - put it on a dark gray something like
291:15 - that then let's go inside it inside the
291:18 - text area
291:19 - and here for the placeholder I actually
291:21 - don't like this so basically there's a
291:22 - visible intertext before you actually
291:24 - input something but personally I don't
291:26 - really like this so I'm going to delete
291:27 - this and for the text let's just put it
291:29 - on white and now if we go back into the
291:32 - unlocking name input field down here we
291:34 - can set default text so let's just say
291:35 - Lobby name okay let's just make it a
291:37 - little bit bigger something like this
291:40 - okay great so we have a Lobby name and
291:42 - then the other option is we're only just
291:44 - creating as either a public or a private
291:45 - lobby so let's make two buttons for that
291:48 - so let's create a new button let's call
291:50 - it create public button inside let's say
291:54 - create public
291:56 - let's put the usual thing so in White in
291:58 - bold and for the button put it in a dark
292:01 - gray something like this okay
292:04 - so we've got the public button and then
292:06 - let's make another one for create
292:07 - private so they create private button
292:10 - inside let's make create private okay so
292:14 - those are really all the settings we
292:15 - need in order to create the lobby and
292:16 - let's just make a close button just to
292:18 - be able to go back and close this create
292:20 - UI so let's create a new UI button
292:23 - and for this one let's put it up there
292:25 - so let's anchor it on the top left
292:26 - corner instead of using the UI Sprite
292:29 - let's use our nice cross Sprite let's
292:31 - make sure to put it on something like
292:33 - 44ing and get rid of the text inside and
292:36 - name this the close button okay so
292:39 - that's the basic layout we need
292:41 - now let's make the square to run this so
292:43 - let's create our script with the exact
292:45 - same name while we create UI let's
292:47 - attach the script and open okay so now
292:50 - here it's going to be super simple
292:52 - first let's grab our input field and our
292:54 - buttons so a serialize field
292:57 - for the button so we have the close
292:59 - button so this is actually of type
293:00 - button
293:02 - then we have another one for the create
293:04 - public button and the create private
293:07 - button and then we also have the input
293:10 - field so for that one the type is
293:12 - actually the TMP input field so it's
293:14 - this one here don't make a mistake we
293:16 - use text mesh Pro so it is not the
293:18 - regular input field it is not this one
293:20 - it is the TMP input field so this is the
293:23 - lobby name input field okay we have all
293:26 - of our fields
293:27 - over here let's set them so the
293:29 - unlocking name input field and the
293:31 - create public button the close button
293:35 - and the create private button all right
293:36 - great so over here the logic is going to
293:39 - be super simple so on private Wide Awake
293:41 - over here on let you send listeners
293:44 - so on the create public button let's
293:46 - unclick let's add in listener
293:50 - and for the listen we're going to go
293:51 - into the kitchen game Lobby on the
293:54 - instance and let's create a Lobby and
293:56 - for the lobby name let's use the lobby
293:58 - name input field let's grab the text
294:00 - from there and for these private this
294:02 - one is the public button so let's set it
294:03 - as false
294:05 - and for the other button very simple so
294:07 - the create private button for this one
294:09 - just set it as private all right then
294:12 - for the close button so the close button
294:14 - for this one we want to hide this window
294:16 - so let's make the usual show hide
294:17 - function so private void show
294:22 - and the product void hide
294:25 - and the game objects that active into
294:27 - either phones and appear into true
294:29 - then as usual in private start we're
294:32 - going to start off hidden and when we
294:34 - press the close button let's also hide
294:36 - it okay so that's it now for here on the
294:39 - lobby UI we just need to show that so
294:41 - let's actually make another reference of
294:42 - type Lobby create UI for the unlock
294:45 - create UI and here in the editor let's
294:47 - drag that reference so on the unlock UI
294:49 - let's write that one and then super
294:51 - simple over here on create Lobby let's
294:53 - just go into the library create UI and
294:54 - call show
294:55 - so we just need to make that one public
294:57 - so here just make this one public okay
295:00 - that's it super simple so here we just
295:02 - called the exact same function okay
295:03 - great now if we do end up creating a
295:06 - private lobby we need to be able to show
295:07 - the in lobby code so that people can
295:09 - actually join so for that let's actually
295:11 - go into the character select scene let's
295:13 - go into that one and over here for this
295:15 - one we need some element to say that
295:18 - science actually go into our generic
295:19 - character select UI and inside let's
295:21 - create a new text object
295:23 - let's call this the lobby name text and
295:26 - let's put the usual setup and let's
295:28 - actually hide this host disconnected
295:29 - window just so we can actually see that
295:31 - so we're here in the hierarchy and let's
295:33 - side down okay so we have the lobby name
295:35 - let's put it in bond maybe a little bit
295:37 - smaller so 24 and the usual setup so
295:40 - width and height of zero Put It Center
295:42 - down the middle
295:43 - disabled and appear let's Anchor It To
295:46 - The Top corner so let's anchor it to the
295:48 - top and this one is going to say
295:49 - something like Lobby name and then in
295:51 - lobby name
295:52 - okay so that's all we want and then
295:54 - let's duplicate this one and for this
295:55 - one down here let's name this in lobby
295:57 - code text and over here same thing we're
295:59 - going to send Lobby code and then say
296:01 - some kind of code
296:03 - okay that's good
296:04 - so now let's open up this script and
296:06 - let's first of all add our references so
296:09 - the text mesh Pro you're going since
296:10 - we're working the UI for the lobby name
296:13 - text another one for the lobby code text
296:15 - over here let's drag our references so
296:18 - the unlocking name and the in lobby code
296:20 - then all we need to do is set it up so
296:22 - let's do it over here private void start
296:24 - so on start we need to get the actual
296:26 - Lobby so we go into the kitchen game
296:28 - Lobby the instance and we need the
296:30 - function to get the actual Lobby so
296:32 - let's make this function
296:34 - so over here on the kitchen game Lobby
296:35 - recently just need something to return
296:37 - this joint Lobby so let's make that one
296:39 - so you're probably going to return in
296:41 - lobby get Lobby and we just return our
296:44 - join Lobby okay like this so over here
296:47 - we can grab the lobby
296:48 - and the lobby is actually inside this
296:51 - one
296:52 - so we grab the lobby
296:54 - and over here we're going to assume we
296:55 - always have Lobby since we only connect
296:57 - the scene when we have joined the lobby
296:59 - then on this one let's just go on Lobby
297:01 - name dot text
297:03 - and we're going to set it to Lobby name
297:05 - and then let's go into the lobby and
297:07 - grab your lobby name and then for the
297:09 - code same thing we just grabbed the
297:10 - lobby code so this is the lobby code
297:13 - and the lobby code text
297:16 - okay so that won't show both the name
297:18 - and the code all that's left before we
297:20 - can test it's basically just setting a
297:21 - way to join by the code so let's go back
297:24 - into the lobby scene so let's go back
297:26 - into the lobby scene and over here let's
297:28 - make an option to join by the code so
297:30 - let's actually hide over here on the
297:31 - inspector just hide the unlock create UI
297:33 - so we can log behind it so inside the
297:35 - lav UI on this one let's make one more
297:38 - button so let's push it down here
297:40 - let's name this one join code button and
297:43 - then above it let's make a nice UI input
297:46 - field
297:47 - the lobby code input field and let's set
297:50 - it up the same way so let's put it in
297:52 - Black
297:53 - and down here for the text this one is
297:55 - going to say some kind of code then
297:57 - let's go inside inside the text area and
298:00 - personally I don't like the placeholder
298:01 - so let's get rid of that and for the
298:03 - text let's put it in bold put it in
298:05 - white and put it down the middle okay so
298:07 - now let's just position it so just above
298:09 - there just above the join by code and on
298:12 - that button let's also change the text
298:15 - so join code like this okay now let's
298:18 - make this logic so over here on the
298:20 - lobby UI
298:21 - let's first of all add the reference
298:24 - so the join code button
298:27 - and then let's also add another
298:28 - serialized film this one is going to be
298:30 - once again for the TMP input field
298:34 - for the join code input field
298:37 - then here in the editor let's write the
298:38 - references so the lobby code input field
298:41 - and the join code button okay so now
298:44 - joining by code is very simple let's
298:46 - make that one on the lobby script so
298:48 - we're here on the kitchen game Lobby
298:49 - let's go ahead make a function so we
298:51 - probably Point let's go and join with
298:53 - code and we're going to receive a string
298:55 - for the unlock code
298:57 - and over here we're just going to the
298:59 - lobby service access the instance and
299:01 - call join Lobby by code async and this
299:04 - one takes in a library code so just add
299:06 - a Lobby code
299:09 - and as usual let's make this a weight
299:11 - this one is going to return our join
299:13 - Lobby so let's set that one and if we
299:14 - use a weight we need to use async okay
299:16 - and as usual let's put all this inside a
299:19 - try catch
299:27 - and finally after we join the lobby then
299:28 - it's the same thing as over here so we
299:30 - need to start the client
299:31 - finally we just need to call this
299:33 - function so over here on the lobby UI
299:35 - for the join code button let's unclick
299:37 - let's add in listener
299:41 - just go into the kitchen game Lobby the
299:43 - instance join lobby with code and pass
299:46 - in the join code input field and let's
299:48 - pass in the text okay so let's test okay
299:52 - so here on this one down here I'm going
299:54 - to go into play and let's go ahead
299:55 - create a Lobby and this time let's make
299:57 - it a private lobby okay it created
299:59 - there's the code and now on this one if
300:01 - I try to Quick join and hope there's an
300:02 - error because there are no open public
300:04 - lobbies but now if I go in the code and
300:06 - I write the same thing so wnt 4 F6 and I
300:11 - join with the code
300:12 - and if there you go it does connect and
300:14 - we have our connection all right awesome
300:16 - next let's handle one thing which is
300:18 - lobbies need to send out a heartbeat in
300:21 - order to stay alive by default they
300:22 - won't destroy themselves after 30
300:24 - seconds of inactivity for example if
300:27 - here I hit on play and I create Lobby
300:29 - let's make it public
300:30 - okay the lobby has been created now
300:32 - let's wait 30 seconds okay 30 seconds
300:35 - have passed now if I click on quick join
300:37 - and nope there are no Hobbies open so we
300:39 - made this a public hobby but it passed
300:41 - 30 seconds so it was automatically
300:43 - destroying so let's make a function send
300:45 - a periodic heartbeat
300:46 - that's very simple so let's go here onto
300:48 - the kitchen game Lobby and let's make a
300:51 - function to handle our heartbeat and
300:52 - we're going to need to run that on our
300:54 - update so let's make a proud void update
300:56 - and we're going to have the handle
300:58 - heartbeat function so let's make this
301:01 - one so privatoid handle heartbeat
301:05 - so we have this function and now
301:07 - importantly we also only want to run the
301:09 - heartbeat on the lobby host so let's
301:11 - make a nice Humper function so private
301:13 - ball is Lobby host
301:16 - and basically it's going to be a host if
301:18 - well first of all we have a Lobby so the
301:20 - join Lobby it is not known so if we have
301:23 - the lobby and we go into the join Lobby
301:26 - and we ask it for the host ID if that
301:28 - one matches the authentication Service
301:31 - we access the instance in grab this
301:33 - player ID if it does matches then this
301:35 - one is the lobby host so we're here if
301:38 - we are if is Lobby host
301:42 - if so then let's send out the heartbeat
301:44 - and for now on let's just count down a
301:46 - simple timer so appear on let's make a
301:47 - private mode for the heartbeat timer
301:49 - okay
301:51 - then over here heartbeat timer minus
301:53 - equals time dot Delta time and if the
301:56 - heartbeat timer goes under zero
302:00 - if so then let's first reset it so the
302:02 - heartbeat timer let's set it to some
302:04 - kind of heartbeat timer Max
302:06 - so let's say we want to send out a
302:07 - heartbeat every 15 seconds okay so let's
302:10 - first reset the timer and then let's set
302:12 - out the heartbeat so go into the lobby
302:15 - service
302:16 - the instance and over here let's send
302:18 - the heartbeat ping async this one
302:21 - requires Navi ID so let's grab the giant
302:23 - Lobby and let's grab the lobby ID okay
302:25 - that's it let's test okay so here I'm
302:28 - going to go ahead create a Lobby create
302:30 - the public Lobby and now let's wait for
302:32 - one minute okay it has been over a
302:34 - minute and on this one if I try to Quick
302:36 - join and if there you go it does join
302:37 - alright awesome next let's handle
302:40 - synchronizing some player data like for
302:42 - example the player name so let's go
302:44 - inside our lobby UI and inside let's
302:46 - create a new UI let's make it an input
302:49 - field let's anchor it up top and put it
302:52 - up there let's set it up as usual so the
302:55 - color on pretty much a dark gray let's
302:57 - name this one the player name input
302:59 - field
303:00 - then inside Vortex area as always I
303:02 - don't like the placeholder so I'm going
303:04 - to delete it for the text put it in
303:06 - white put it in bone down Center okay
303:08 - great
303:09 - let's also increase the font size by a
303:11 - little bit and for the player in first
303:13 - field let's say player name just default
303:15 - text
303:17 - let's make it a little bit bigger
303:20 - okay so that's our simple player name
303:22 - now let's handle the script so let's go
303:24 - inside and Lobby y and over here let's
303:26 - add the field so the field for the
303:28 - player name input field
303:31 - here in the editor let's just drag the
303:33 - reference okay so now we have this and
303:35 - now we need to set it and listen when it
303:36 - changes so we need some way to store our
303:39 - player name and for that let's go over
303:41 - here onto the kitchen game multiplayer
303:43 - let's define a field for our player name
303:45 - so private screen for the player name
303:49 - in order to sort it between sessions
303:51 - let's also store it on employ prefs so
303:53 - over here on the awake let's go player
303:55 - name and let's set it so let's go inside
303:56 - the player prefs and let's get a string
303:59 - then we need the key so let's go up here
304:01 - to define a constant so a private
304:03 - constring
304:05 - call it player prefs player name
304:09 - multiplayer
304:12 - let's go let's play your name multiplier
304:15 - so this is the key for our player prefs
304:17 - then let's use it down here so get
304:20 - string of this and then for default
304:22 - value so if there's no key recording if
304:25 - not then let's just default to saying
304:26 - player name and then let's add a random
304:28 - number so let's go random.range so
304:31 - actually that's inside Unity
304:33 - engine.random.range let's randomize a
304:35 - number between 100 and a thousand so
304:37 - just get a random number just like this
304:39 - okay so that is going to either get or
304:42 - generate a brand new player name now
304:44 - let's make two functions to get and set
304:47 - so let's make it over here a public void
304:49 - or a public string rather let's call it
304:51 - get the player name and we're just going
304:54 - to return return the player name
304:57 - and another one so a public void set
305:00 - player name and this one we're going to
305:02 - receive a string for the new player name
305:04 - and just set this dot player name equals
305:06 - this player name so we set it and then
305:08 - we need to update it so on the player
305:10 - prefs let's set the string on this same
305:14 - key so let's use the content and let's
305:15 - set this player name
305:17 - okay great so with this we have a nice
305:19 - player name defined then we can go back
305:21 - here on the lobby UI so let's go ahead
305:24 - make a private void start and on start
305:26 - let's grab the player name input field
305:28 - and set the text let's go into the
305:30 - kitchen game multiplayer the instance
305:32 - and let's get the player name
305:34 - okay so that won't update the name
305:36 - and then we need to know when the player
305:39 - actually changes the input field
305:40 - so that is actually also pretty simple
305:42 - so let's just go inside the input field
305:45 - and over here there's a comeback the
305:48 - combat is called on value changed this
305:51 - is a Unity event so let's add a listener
305:53 - just like we do with a click and for the
305:56 - listener this one is going to receive a
305:57 - string which is the new text that the
305:59 - player wrote
306:00 - okay so we have this and over here just
306:02 - go into the kitchen game multiplier the
306:04 - instance set the player name to this new
306:06 - text okay so that will now update the
306:08 - current name and it will save any new
306:10 - name the player writes so with that the
306:12 - player name is being set now we just
306:14 - need to show it on the character select
306:15 - scene so let's go to that one so over
306:18 - here on the project let's go on to the
306:19 - character slide scene and over here
306:21 - let's go inside one of these player
306:23 - prefabs
306:25 - let's open it up okay so over there we
306:27 - already have something called ready and
306:29 - let's duplicate it to make another text
306:31 - object put it above name this the player
306:34 - name text and this one is going to say
306:36 - what it is the player name
306:38 - so let's just go into the script here
306:40 - the character slide player and we're
306:42 - going to add a reference to our player
306:44 - name so let's set in this case it's a
306:46 - text mesh Pro we're using a worm option
306:48 - so it's not the you going so it's this
306:50 - one for the player name text
306:52 - here in the editor let's write the
306:54 - reference like that okay so now we need
306:56 - to set this and for setting it over here
306:58 - we have our general update player
307:00 - function so it's over here that we're
307:02 - going to set the player named text.text
307:04 - and we're going to set it to something
307:06 - and for that something we're actually
307:07 - going to start a player name inside our
307:09 - player data
307:11 - so let's go here inside the player data
307:13 - and let's store a public string for the
307:15 - player name
307:17 - and over here we need to override all
307:19 - these so we do an equals on the client
307:21 - ID the caller ID and also the player
307:24 - name okay
307:25 - and down here on the serializer let's
307:27 - also serialize the player name
307:30 - except if you remember from the other
307:32 - video a string cannot be used here if
307:34 - you're only here in the inspector nope
307:36 - the player data must be a no no don't
307:38 - value type A String can be null so a
307:40 - string cannot be used and over here the
307:43 - alternative is instead of a string let's
307:45 - use the fixed string and then the number
307:47 - of bytes this is the length of the
307:49 - string and for a player name let's go
307:51 - with the 64 64 characters that's big
307:53 - enough for a player name so let's go
307:55 - with this one okay so we have this
307:57 - inside the player data and then back
307:59 - here on the character select player on
308:00 - the update we go inside the player data
308:03 - and let's grab the player name then this
308:06 - one is a fixed ring so let's just call
308:07 - to string to convert it to a regular
308:09 - string okay so that's ring so now the
308:12 - visual for the player should have the
308:13 - player name and we are having that over
308:16 - here stored on the player data all we
308:18 - need is really just to set it on the
308:19 - player data so for that basically we
308:21 - need to tell the server our name when we
308:23 - connect and then the server will update
308:25 - the player data which then is
308:26 - synchronized to all the clients so let's
308:28 - go over here onto the kitchen game
308:29 - multiplayer and to tell the server the
308:31 - name let's do it as soon as we connect
308:33 - so let's go down to where we are doing
308:36 - the start client so here we have the
308:38 - start client we are listening to the
308:39 - client disconnect and let's also listen
308:41 - to the client connect so the other one
308:43 - so on client connected comeback
308:47 - let's listen to this one on the server
308:50 - on client connected compact
308:54 - okay we have this one let's create this
308:57 - function so here it is
308:59 - so on this function we have the client
309:01 - 3D parameter so the same as usual
309:03 - and as soon as we connect let's tell the
309:04 - server what our name is so for that we
309:06 - need an RPC
309:08 - so let's make a private void set player
309:11 - name server RPC
309:13 - and this one is going to be a server RPC
309:15 - we require ownership as false
309:18 - then over here we receive a string for
309:20 - the player name and we receive the
309:22 - server RPC param so we know who sent
309:24 - this and as usual let's default it okay
309:27 - great and over here really going to do
309:29 - the same thing that we did down here
309:31 - so here when changing the color right
309:33 - now we're going to do the same thing so
309:34 - let's just copy this code let's go up
309:37 - here into our function
309:38 - and over here let's face the same code
309:40 - so we grab the player data index from
309:42 - this server RPC params okay that's great
309:44 - instead of modifying the color ID let's
309:46 - modify the player name into this player
309:48 - name
309:49 - okay so all that's left is over here
309:51 - when the client connects let's trigger
309:52 - the server RPC and pass in get player
309:55 - name
309:58 - and update it like this okay so that is
310:00 - going to do it for the client
310:02 - but then the server itself also has a
310:04 - name so here when we have the start host
310:07 - we also have this comeback so over here
310:09 - let's also set the player name okay so
310:11 - that should do it when a player connects
310:13 - it will send the server their name then
310:15 - the name is broadcast to all the clients
310:17 - let's just make sure to save the prefab
310:19 - and as always for testing let's make
310:21 - sure we test starting from the lobby
310:22 - scene okay so let's test okay so yep we
310:26 - do see our nice input field so on this
310:28 - one I can click to modify it so on this
310:30 - one let's say I am code monkey and then
310:32 - on this one down here and let's hit on
310:34 - play and on this one let's give it
310:35 - another name let's say Iron Man okay so
310:38 - we got the two names on this one create
310:39 - and Lobby let's create a public Lobby
310:41 - and if there go it does show the player
310:43 - name and on this other one let's do a
310:45 - quick join and joins any of their yo
310:46 - Iron Man and both the names are
310:48 - synchronized all right awesome so here
310:51 - we have all the names in the character
310:52 - sightseeing although one note here if
310:55 - you wanted you could also show these
310:57 - names on the game scene above the
310:58 - players so if you both go on ready right
311:01 - now the game just starts playing and we
311:03 - just have the characters no names but if
311:04 - you want you could also add the names up
311:06 - here but since the players already have
311:08 - different unique colors I think this
311:09 - scene looks best without the names okay
311:11 - so the next thing we want to handle is
311:13 - in labian Lifetime right now the lobby
311:16 - won't stay alive until we end the entire
311:18 - game session but there's really no need
311:19 - for that once we start the game we no
311:22 - longer accept any connections so we
311:24 - should really just clean up and destroy
311:25 - the lobby as soon as the game starts so
311:27 - first let's go here to the kitchen game
311:29 - Lobby and let's make a function to
311:30 - delete a certain Lobby so let's make a
311:33 - public void call it delete lovey
311:36 - and over here it's very simple the same
311:38 - thing so let's go inside the lobby
311:39 - service the incense and column delete
311:41 - Lobby async and here we pass in the
311:44 - unlock ID
311:46 - so let's just check if the giant Lobby
311:48 - is not known so if we are inside a Lobby
311:50 - if so then let's use the join lobby.id
311:53 - and destroy this one
311:55 - once again let's wait for this one
311:58 - then after we await let's clean up the
312:00 - joint Lobby since that one will now be
312:02 - no and in order to use the weight we
312:04 - also need to use async and finally we
312:06 - must put all this inside a nice try
312:08 - catch catch the Wabi service exception
312:12 - and just do a debug download
312:15 - okay that's it pretty simple now let's
312:17 - see what we're going to call this
312:19 - it's over here on the characters like
312:20 - ready script here we have the playwright
312:23 - dictionary where the player tests if all
312:24 - of the players are ready and if so then
312:26 - loads the game scene so before doing
312:28 - that let's just go into the lobby so the
312:31 - kitchen game Lobby the incense and let's
312:33 - delete the lobby
312:35 - okay so that handles the cleanup when
312:37 - the game starts
312:38 - for something similar which is going to
312:40 - be when we leave the unlock manually for
312:43 - doing that we also need to make sure
312:44 - that client leaves the lobby so back in
312:46 - the kitchen game Lobby script over here
312:48 - let's make another function so this one
312:50 - public void leave Lobby
312:53 - and this one just go into the lobby
312:55 - service the incense and this one we call
312:57 - remove player async this one takes a
312:59 - Lobby ID so that you join lobby.id and
313:02 - then it also takes a player ID so let's
313:04 - go inside the authentication Service
313:06 - access the instance and grab this player
313:09 - ID so this will remove this player from
313:11 - this Lobby so as usual let's do the same
313:13 - thing so await async
313:36 - okay so just like this pretty simple and
313:38 - as to where we're going to leave
313:40 - it is going to be over here on the olive
313:42 - UI so we have a button to go back into
313:44 - the main menu so when we do let's just
313:46 - go into the kitchen game Lobby the
313:48 - instance and let's make sure to leave
313:49 - the level
313:50 - okay so finally the last possible
313:52 - scenario for leaving your lobby is
313:54 - actually if the player is kicked so
313:55 - let's make a function to Kiki player
313:57 - back here on Lobby it's going to be very
313:59 - similar so let's actually copy this
314:02 - and let's call this kick player and
314:05 - inside we're going to receive a string
314:06 - for the player ID then over here we call
314:08 - the exact same function except instead
314:10 - of using this player ID let's use the
314:12 - one that we received over there and of
314:14 - course for kicking we're not leaving the
314:15 - lobby ourselves so let us not do this
314:17 - instead of testing if no Lobby is not
314:19 - known we're only going to be able to
314:21 - kick players if we are the lobby house
314:22 - so Islamic host then we kick this player
314:25 - okay so now for calling this function
314:27 - it's over here on the character select
314:29 - player script we've got our kick button
314:31 - when we kick we get the player data we
314:33 - kick the player from the multiplier so
314:35 - from the netcode itself and then over
314:37 - here we also need to kick them from the
314:38 - lobby so let's go in the lobby instance
314:41 - keep the player and now we need a player
314:43 - ID so the obvious question how do we get
314:45 - that and the obvious answer is the same
314:47 - thing that we did which is let's just
314:49 - store it over here on the player data so
314:51 - let's go here and the player ID is also
314:53 - a string so let's do also a fixed ring
314:55 - so player ID
314:57 - and let's copy all these
315:06 - okay just like this
315:08 - then on the kick function we can go
315:10 - inside the player data and use the
315:13 - player ID
315:14 - all right now we really just need to set
315:17 - this
315:18 - so for that let's go in the multiplayer
315:19 - script
315:20 - and over here we're only just going to
315:22 - do the exact same thing that we did on
315:23 - the set player name so let's copy this
315:25 - RPC except instead of set for your name
315:27 - that's going to be set player ID let's
315:30 - receive a string for the player ID and
315:33 - we're going to set the player data dot
315:35 - player ID
315:36 - okay so that's what we modify and let's
315:39 - just call it when we set the player name
315:41 - so when a client connects let's send
315:43 - this in and for the player ID let's go
315:45 - inside the Authentication
315:47 - let's go inside the instance and grab
315:49 - this player ID
315:51 - so we set it over here when we set the
315:53 - pointer name and same thing up here when
315:54 - we set down okay so let's test
315:57 - okay so starting off let's create a
315:59 - Lobby let's make it a public Lobby and
316:02 - first of all let's just start playing
316:03 - just like this and there you go here we
316:05 - are playing there are no errors okay so
316:07 - everything is working perfectly now on
316:09 - this one down here if I try to do a
316:10 - quick join and nope it does not find any
316:12 - lobbies that's because this one was now
316:14 - destroyed okay great okay now here let's
316:16 - try to create another Lobby
316:18 - then on this one let's do a quick join
316:20 - and on this one let's get them from the
316:22 - lobby and if there you go that does work
316:23 - and now if we try joining again and yep
316:26 - it also still works okay great so all
316:28 - the logic is working perfectly now one
316:30 - issue we have right now is that our
316:32 - lobby isn't really very responsive there
316:34 - are lots of actions that take a little
316:36 - bit of time but that is not visible to
316:37 - the player so let's just add some nice
316:39 - messages previously we already made this
316:41 - window the connection response message
316:43 - UI it shows a message and a close button
316:45 - so we could just make another window
316:47 - just like this one or we can simply
316:49 - reuse this one let's reuse it just so we
316:52 - don't end up with tons of different
316:53 - windows and first of all let's actually
316:55 - put both these windows let's put them on
316:57 - top of the actual Lobby UI okay so like
316:59 - this all right so now let's rename this
317:02 - one to just Lobby message UI so a bit
317:04 - more of a generic name and Lobby just
317:06 - because this object only exists over
317:07 - here on the lobby scene so now that
317:10 - we've renamed the game object let's also
317:12 - rename over here to the script so only
317:14 - so rename to Lobby message UI
317:18 - and obviously this is going to have some
317:19 - errors we need to make sure that the
317:21 - script name actually matches the file
317:23 - name
317:24 - so here inside let's just modify the
317:26 - class name like this
317:27 - okay the name is correct now over here
317:29 - we are showing this message based on
317:31 - these events so it simply make a bunch
317:34 - more we want the window to show when
317:35 - trying to create a Lobby
317:37 - so let's go over here onto the kitchen
317:39 - game Lobby and let's make an event to
317:40 - fire on that
317:41 - so a public event event handler and for
317:45 - this one let's using system okay so in
317:47 - this event let's call it on create Lobby
317:50 - starting so when we start creating the
317:52 - lobby another one on create Moby failed
317:56 - okay so we have these two events also by
317:59 - the way since we added using system now
318:01 - over here we've got a ambiguous
318:03 - reference between the UNT engine random
318:05 - or the system random so over here we can
318:07 - solve this by just using the complete
318:08 - name okay great so let's go down to
318:11 - where we are creating the lobby so let's
318:13 - see the function over here to create the
318:15 - lobby again remember that these are
318:17 - weight functions which means that this
318:18 - code to create and Lobby isn't instant
318:20 - it's actually going to contact the UNT
318:22 - server in order to create Lobby so this
318:23 - is why we need a visual for the player
318:25 - because this is not instant so before we
318:28 - try to create the lobby let's fire off
318:30 - the oncreate Mobby starting so envo with
318:32 - usual this and even arcs
318:36 - okay so we try to create a Lobby and
318:39 - then if we succeed we're going to load
318:40 - the other scene so there's no need to
318:42 - post any message but if we do fail then
318:44 - over here let's post a message
318:46 - so let's use the oncreate lobby field
318:49 - okay these are the two basic events so
318:51 - now back here on the unlock message UI
318:53 - and let's listen to them
318:55 - so let's go into the kitchen game Lobby
318:57 - the instance and first of all the on
318:59 - Lobby starting and as usual let's rename
319:01 - this to give it a proper name so kitchen
319:03 - game Lobby on Lobby starting and the
319:06 - other one which is the oncreate lobby
319:08 - failed let's listen to this one as well
319:16 - okay we have our events and let's also
319:18 - make a generic function in order to show
319:19 - a message so here a private void show
319:22 - message going to receive a string for
319:24 - the message
319:26 - and then we're just going to call show
319:28 - and set the message text Dot text into
319:31 - this message
319:34 - so now up here we can simply show these
319:37 - so do the exact same logic so if
319:39 - disconnect reason is none then let's
319:41 - call show message
319:45 - then let's show the general message fail
319:47 - to connect
319:49 - and if not if we do have a disconnect
319:52 - message then let's show that disconnect
319:54 - message
319:57 - okay great so now the code is a bit
320:00 - simpler so we just have the original
320:01 - message
320:02 - so over here on let's just say so this
320:04 - one is on the create Lobby starting so
320:06 - let's say creating Lobby
320:12 - and on this one up here
320:14 - fail to create Lobby
320:20 - okay so that's great that handles those
320:22 - messages the other place where we want
320:24 - to show some messages is on the quick
320:26 - join so let's do the same thing with two
320:28 - events
320:29 - so let's make an event and one let's
320:31 - call it on join starting so this works
320:34 - for both the quick join and the other
320:35 - ones another one on quick join fails
320:40 - so let's go down and do the exact same
320:42 - thing
320:42 - so let's see over here on the quick join
320:44 - so on join starting let's invoke this
320:47 - event with this and eventars.empty
320:51 - okay we have our event and then if we do
320:53 - join then we're going to download the
320:55 - other scenes underneath and it's over
320:56 - here so on quick join film like this
320:59 - let's also put the same thing over here
321:01 - on the onshine with code so on joint
321:03 - start and then let's make another one so
321:05 - on join failed
321:07 - we'll just go up here to Define this one
321:10 - so on regular join failed
321:14 - okay great so over here let's just
321:16 - listen to those events so the usual
321:17 - thing so the incense let's go with the
321:20 - on join starting let's listen to this
321:22 - one then the other one is the on join
321:25 - failed and finally we have the on quick
321:28 - join failed okay let's rename all these
321:43 - okay we have one of our events now for
321:46 - these messages so on join starting let's
321:48 - just say
321:50 - joining Lobby
321:57 - then this one up here failed to join
322:00 - Lobby
322:04 - and on this one up here on the quick
322:06 - joint failed
322:08 - could not find a Lobby to Quick join
322:12 - alright so that's it here we have all of
322:14 - our messages Let's test okay so here if
322:17 - we try to create the lobby
322:19 - let's go ahead create on public and
322:20 - there you go create a Lobby and it takes
322:22 - a little bit and we have a nice visual
322:23 - so that's great and now on this one
322:25 - let's go ahead click on play and let's
322:27 - go ahead with the quick join and there
322:29 - you go join Lobby connecting any update
322:31 - connects let's see the other ones for
322:32 - fail to join so if I exit both lobbies
322:35 - and if I try to Quick join and there you
322:38 - go it did work it simply fired off the
322:40 - error that's because over here in unity
322:42 - this one throws an exception and UNT
322:43 - treats that as an error so it
322:45 - automatically pause the game but in the
322:47 - build this is not a problem since it one
322:48 - stops over here if we hit on play going
322:50 - to Quick join join Lobby and nope could
322:52 - not finding a Lobby to Quick join and if
322:54 - I try to join by code it also does not
322:55 - find this lobby with this code alright
322:57 - great so just with this our lobby
322:59 - actions are now much more responsive
323:01 - okay great so finally let's do the most
323:03 - obvious Lobby feature that is still
323:05 - missing let's simply enlist all of the
323:07 - available Lobby so the player can choose
323:08 - which one to join so for that first
323:10 - let's go over here onto the kitchen
323:12 - again Lobby and let's make the function
323:14 - to action list of the lobbies so let's
323:16 - go up here make a simple function so for
323:18 - avoid list lobbies
323:21 - and in order to enlist on the lobbies
323:22 - all we need to do is do a query so let's
323:25 - go into the lobby service instance and
323:28 - let's call query and lovies this one
323:30 - takes a query Lobby's options if you
323:32 - don't include this and it will simply
323:33 - show all the lobbies but right now let's
323:36 - actually add a filter let's only show
323:37 - the lobbies that are available so let's
323:39 - not show the ones that our phone
323:41 - so we're here let's make a querying all
323:43 - of these options and let's construct a
323:45 - new object of this type and inside we've
323:48 - got the filters so let's create a new
323:49 - filters this one takes a list of query
323:52 - filter so now inside we can create a new
323:55 - query filter
323:57 - and for this one for the field we only
323:59 - want the ones with the Velma slot so
324:01 - let's go with the Velma slots then for
324:03 - the value we want all the ones that have
324:05 - more than zero so let's go with zero
324:07 - except this one actually is a string
324:09 - value not an end so let's just put this
324:10 - as a string okay and finally for the
324:13 - operation we only want the ones that
324:15 - have more than zero so let's use the GT
324:17 - which means greater than so this will
324:20 - only show of the lobbies that I have
324:21 - available slots greater than zero okay
324:24 - so just like this and over here let's
324:26 - use the aquarium Lobby's options and as
324:28 - usual let's await this and this one we
324:31 - can see what this returns so this
324:32 - section we're going to return on a query
324:34 - response so let's grab the query
324:36 - response
324:42 - and also since we are using a weight up
324:44 - here we need to mark it as async okay so
324:47 - we grab the query response and now
324:49 - inside over here we've got the results
324:51 - and the results is in list of Lobby okay
324:54 - now in order to show them on the UI
324:55 - we're going to fire off an event so
324:57 - let's do that let's go all the way up
324:59 - here make another event
325:00 - for this one let's come with on Lobby
325:03 - list changed
325:05 - and in the event we want to pass in the
325:07 - list of Lobby so let's make a public
325:09 - class online let's change event arcs
325:11 - let's extend event args and inside let's
325:15 - have a public list of Lobby and just
325:17 - call it the lobbying list
325:18 - and now the event is of this time okay
325:21 - great
325:25 - so over here when we have the enlist
325:27 - navies we get the query and then let's
325:29 - invoke this event
325:32 - pass in with this and create our new
325:34 - event arcs and inside we have the
325:36 - unlocking list and we pass in the query
325:37 - response to our results
325:40 - okay so just like this and as usual
325:42 - let's wrap this inside a try catch so
325:45 - try and the usual catch
325:48 - the lobby service exception like this
325:51 - and do a debug download
325:53 - okay so this is going to enlist our love
325:54 - isn't far off the event when we have new
325:56 - list and let's also periodically call
325:58 - this function in order to make it
325:59 - automatically refresh
326:01 - so for that let's go up here onto the
326:03 - update we're going to have another
326:04 - function let's say handle periodic list
326:07 - lobbies
326:10 - let's make this function
326:12 - so on this one we're going to count down
326:15 - a timer so it's called the list Lobby's
326:17 - timer we're going to count it down by
326:19 - time dot the time let's just Define the
326:22 - timer all the way up here just where we
326:24 - Define the heartbeat timer so as usual a
326:26 - private mode for this okay we have this
326:29 - timer
326:30 - so we count down the timer and the usual
326:32 - thing so if it is under zero if so then
326:35 - let's first reset it so put it to some
326:36 - timer Max let's define it in here the
326:39 - timer Max and let's say we want to
326:41 - refresh we don't need to be too specific
326:44 - so let's say maybe three seconds so we
326:46 - reset the timer and then simply call
326:48 - list lobbies which in turn that one is
326:50 - going to fire off the event which the UI
326:51 - won't listen Okay so that's great
326:53 - although here this is going to continue
326:55 - on listing the lobbies even when the
326:57 - player has already joined the lobby so
326:59 - that's a little bit wasteful so let's
327:01 - not do that so we're only going to run
327:03 - this if the joint Lobby equals no
327:05 - meaning if the player has not yet joined
327:07 - the lobby let's automatically refresh
327:09 - but as soon as they do don't bother
327:10 - wasting and also one more thing this is
327:12 - actually going to throw an error if we
327:13 - run it right away that is because over
327:16 - here the authentication this one's
327:18 - signing in this one is going to take a
327:19 - little bit of time so on the very first
327:21 - update it will not already be signed in
327:24 - so we can just simply go into the
327:26 - authentication Service
327:29 - and let's just check is signed in
327:31 - so this is only going to miss lobbies
327:33 - when we are signed in okay great so
327:35 - that's the function form listing of the
327:37 - lobbies now let's just make the UI so
327:39 - we're here in the editor let's open up
327:41 - let's just hide our message window we
327:43 - don't need that and for the lobby one
327:46 - let's go inside of it and over here
327:48 - let's create an empty game object call
327:50 - this the lobby list container and now
327:53 - inside it let's make a new UI button
327:56 - call this the template and inside for
327:59 - the text let's give this a better name
328:00 - so let's say the lobby name text
328:03 - and now let's set it up visually so
328:05 - let's make it a little bit bigger and
328:08 - for the lobby name let's actually anchor
328:10 - it on the left side just move it to the
328:12 - left by a little bit let's put it
328:14 - involved maybe something a bit smaller
328:17 - maybe 22. let's put it in white and for
328:20 - the one the background let's put it in a
328:22 - dark black
328:23 - and make it a little bit bigger so let's
328:25 - say 40 or 50. okay so like this we have
328:28 - our button and this is going to display
328:30 - our lobby name okay great now for
328:33 - positioning these let's go ahead and add
328:35 - a vertical layout group over here onto
328:37 - the container and you can also put the
328:38 - width and height both at zero okay so
328:41 - let's position it somewhere around there
328:42 - and basically we're going to dynamically
328:44 - spawn the template so something like
328:46 - this
328:46 - let's just increase the spacing by a
328:48 - little bit maybe 10
328:50 - okay just like this let's also make a
328:52 - background for our UI so let's create a
328:55 - new UI image let's put it all the way up
328:57 - there and let's scale it something like
329:00 - this maybe put it in white but a little
329:02 - bit transparent
329:04 - okay so that's just a nice visual
329:05 - background also for another visual thing
329:08 - over here in the game the background
329:09 - sound looks a bit odd so you could use a
329:12 - solid color or let's just simply
329:13 - actually go into the main camera so
329:15 - that's what the camera can see and let's
329:17 - just move it up a little bit
329:19 - so over here on the one let's rotate it
329:21 - something like this just so we have a
329:22 - nice gradient okay so that looks good
329:24 - now let's go over here on to the unlock
329:26 - UI script and let's begin by adding
329:28 - references to what we need so we're
329:30 - going to need a transform
329:32 - for the lobby container
329:34 - another one for the lobby templates so
329:38 - now here let's drag our references so
329:39 - the unlocking list container and the
329:41 - template okay and now let's make a
329:43 - simple function in order to update that
329:45 - list
329:46 - so private void call it update lobbying
329:49 - list
329:51 - in order to know what lobbies we want to
329:53 - spawn let's receive a list of Lobby and
329:56 - it's this one inside Unity Services
329:57 - Lobby's model okay this is the unlocking
330:00 - list
330:00 - and on start we're going to start off
330:03 - with an empty list so let's call this
330:05 - with an empty list
330:06 - then we're also going to want to show it
330:08 - on that event so let's go into the
330:09 - kitchen game Lobby the instance and on
330:12 - the unlocking list changed when this one
330:14 - happens
330:18 - when this one happens let's call update
330:20 - login list and pass in the E Dot Login
330:22 - list
330:23 - okay great so now we just need to make
330:25 - this function
330:26 - and here we're going to do the usual
330:28 - setup that we've done so many times on
330:30 - the single player course so let's first
330:32 - handle the cleanup so let's do a for
330:34 - each transform child in the container so
330:38 - that is the lobby container so once I go
330:40 - through all the container let's see if
330:42 - this one is a template if child equals
330:44 - the template the lobby template if so
330:46 - let's skip this we don't want to destroy
330:47 - the template but if not let's destroy
330:51 - and we're in destroy the channel.game
330:53 - object okay so that handles the cleanup
330:55 - then lets you wait for each Lobby in the
330:58 - unlocking list so we second through
331:00 - these let's instantiate our template so
331:03 - the unlocking template and this one is
331:05 - going to be our lobby transform
331:08 - then first thing we want is to actually
331:09 - enable the template so on this one set
331:11 - active into true which also means that
331:14 - we need to disable this one in the
331:15 - beginning
331:16 - so up here on the awake let's set the
331:19 - template game object set active into
331:20 - false okay so then hides the template
331:22 - and over here we are showing it alright
331:24 - so now all that's left is to pass in
331:26 - this Lobby onto this transform so let's
331:28 - make a script to do that let's create a
331:31 - brand new sharp script
331:33 - for the lobby list single UI
331:36 - let's go ahead and select the template
331:38 - and let's say the unlock only single UI
331:40 - so right there also importantly make
331:42 - sure you add it to the right template
331:43 - basically these other ones don't matter
331:45 - those are just to see the positioning so
331:46 - if you want you can even just clean this
331:48 - up just make sure there are no mistakes
331:50 - so there's only one template this is the
331:51 - one that is selected over here and it's
331:53 - on this one that we have the script so
331:55 - now here on this script pretty simple
331:57 - we're going to have a public void in
331:59 - order to set my Lobby and we're going to
332:01 - receive a Lobby object so Lobby let's
332:04 - receive this one and store it so if
332:06 - you're a private for the lobby and do
332:09 - this not Moab equals this Lobby
332:11 - then for the single for this one we're
332:13 - going to want to update the text and
332:15 - then humbly click so for the text let's
332:17 - go up here at a serialized field private
332:19 - text mesh Pro ugly for the lobby name
332:22 - text okay
332:24 - now here in the editor let's drag the
332:26 - reference so the unlocking name text
332:27 - let's drag this reference on there all
332:29 - right and then for the button since we
332:32 - already made this template this one
332:33 - itself as a button what's your pride
332:35 - void awake
332:37 - and on awake let's get component of type
332:40 - button
332:42 - and when we click let's set an unclick
332:43 - add in listener and we're going to want
332:46 - to join this Lobby and also by the way
332:48 - up here we are going to want to update
332:49 - the name so the lobby named text.txt
332:51 - equals this lobby.name okay great
332:54 - and finally for joining we're going to
332:56 - go into the kitchen game Lobby the
332:58 - instance and let's join Lobby and also
333:01 - by the way over here we need to do it by
333:02 - the ID that is because for public
333:04 - lobbies when the enlist Lobby's function
333:06 - calls when that one list on the lobbies
333:09 - the lobby.lobby code this one is
333:11 - actually going to be known so you cannot
333:13 - join a public Lobby through that list by
333:15 - the code we need to join it by the ID
333:18 - so very simple just over here let's make
333:20 - a function exam like the other one so
333:22 - exactly like we have join with code and
333:24 - let's join with ID and we're going to
333:27 - receive a string for the lobby ID
333:31 - and then instead of join live by code
333:33 - join Lobby by ID and everything else is
333:36 - exactly the same
333:39 - then over here let's just use this
333:40 - function and pass in the lobby.id
333:43 - finally back here on the update login
333:45 - list when we grab the unlock transform
333:48 - we need to get the component of our
333:50 - lobby list single UI
333:52 - and let's best in set Lobby and pass in
333:55 - this Lobby also by the way up here when
333:57 - we instantiate we need to instantiate
333:59 - inside the unlocking container all right
334:01 - so let's test and up here we are so it
334:03 - only starts off as empty because there
334:05 - are no lobbies now in this one let's go
334:07 - ahead create a Lobby let's make it a
334:09 - name so my Lobby name and let's go ahead
334:12 - and make it public and it created and if
334:15 - there you go that one did update so we
334:16 - now see it on the list and now if I
334:18 - click on it if there go it does join the
334:21 - lobby okay great
334:23 - now it's also a test to make sure this
334:24 - one only shows lobbies that have
334:26 - available slots okay so here I have a
334:28 - bunch more builds so on this one let's
334:30 - play and you producing Lobby let's join
334:33 - it and if there go joined
334:34 - now this one let's go ahead we do see it
334:37 - and for this one for joining let's joint
334:39 - with a quick join and if there you go
334:40 - everything works perfectly and on this
334:42 - one if I go on to play and nope don't
334:44 - Lobby does not show up the game is now
334:46 - full so it does not show and just one
334:49 - thing that I forgot a while ago over
334:50 - here on the character slightly why we
334:52 - need to make sure to leave the lobby
334:53 - when we go back to the main menu so here
334:55 - for the kitchen game Lobby instance and
334:57 - let's make sure to leave the lobby
334:59 - so now here we are in the lobbyist phone
335:01 - so it does not show up over here now if
335:03 - one of these if we leave and if there go
335:06 - that one left this slot is now available
335:07 - so now this one can indeed join all
335:10 - right awesome
335:11 - okay so here we added yet another
335:13 - extremely important feature to our
335:14 - multiplayer game we added the lobby so
335:16 - that players can create games and other
335:18 - players can join them
335:19 - now like I mentioned one thing we still
335:21 - don't have are different sessions right
335:23 - now all of the lobbies are being created
335:25 - on the same IP same port so let's solve
335:27 - that by implementing int relay in the
335:29 - next lecture
335:31 - hello and welcome I'm your code monkey
335:33 - in this lecture we're going to set up
335:35 - our project to use Unity really this is
335:38 - how we can make our game easy to play by
335:40 - not requiring the players to handle
335:41 - anything to do with port forwarding or
335:43 - firewalls by using this we can easily
335:45 - connect any two players anywhere in the
335:47 - world and it all works seamlessly under
335:49 - the hood okay so here on let's move into
335:51 - relay which is actually pretty easy but
335:53 - before we do that let's actually fix one
335:55 - thing that I forgot in the previous
335:56 - lecture if we are playing the game and
335:59 - over here let's create a Lobby
336:01 - and then I just go into ready and go
336:03 - into the game State and up over here we
336:05 - have an error it's a missing reference
336:07 - exception any of it's right here on the
336:10 - unlock UI script for updating the 11
336:11 - list once again the issue is the same
336:13 - that we already saw which is because the
336:15 - listeners basically this object is
336:17 - destroyed but the kitchen game will be
336:18 - that one continues so let's clean up the
336:21 - event so let's do private void on
336:23 - Destroy
336:24 - and when this object is destroyed let's
336:26 - make sure to unsubscribe from these
336:28 - events so from this one do minus equals
336:30 - okay great also the other one where we
336:33 - used events was on the messages
336:35 - so over here on the 11 message UI we are
336:37 - listening to a home bunch of messages so
336:39 - let's also unsubscribed from these we're
336:42 - already unsubscribing to that one so
336:43 - let's just unsub from all of these so
336:46 - just do minus equals on all of them
336:50 - okay so that handles that problem
336:51 - although actually this error is caused
336:54 - by something that is actually not
336:55 - supposed to happen the issue is because
336:57 - it was still trying to update the
336:59 - unlocking list even though we were in
337:00 - the game scene now that is not correct
337:02 - we should not be refreshing the 11 list
337:05 - when we are already playing the game
337:07 - so we're here on the kitchen game Lobby
337:09 - script let's scroll down to where we are
337:11 - handling the periodic list lobbies and
337:13 - over here we are enlisting if join Lobby
337:15 - is known and when we go into the actual
337:18 - game when we do that we're actually
337:19 - destroying the lobby so this one becomes
337:21 - no so that is why on the game scene this
337:23 - one is still running but we don't want
337:24 - that so let's make sure this one only
337:26 - runs if we are on the lobby scene so
337:28 - super simple let's just add scene
337:30 - manager let's get the active scene and
337:33 - let's compare the name and let's compare
337:35 - with the unloader.scene and we only want
337:38 - to run this on the lobby scene
337:41 - okay so just like this we only want to
337:43 - listen lobbies if we are on the Olympic
337:45 - scene so let's test let's hit on play
337:48 - Let's create a public Lobby let's go as
337:50 - ready and go into the game and now play
337:53 - any of now everything works perfectly
337:54 - okay great so now let's actually handle
337:57 - the relay again I have a dedicated video
337:59 - on relay you can watch that if you want
338:01 - although the relay is super simple so
338:03 - here I will uncover pretty much
338:04 - everything that I also covered in that
338:06 - video if in the future you forget how it
338:08 - really works you can either come back to
338:10 - this lecture or just watch a channel on
338:11 - video first thing we need is just
338:13 - install the package so let's go into the
338:15 - usual package manager on DNT registry
338:18 - under all let's wait for it to fetch and
338:20 - now let's find the relay package
338:22 - so here it is a really currently version
338:25 - 105. let's go ahead and install all
338:27 - right the package was installed now we
338:29 - need to use it so just like we did in
338:31 - lobbying let's go on to the NT dashboard
338:33 - and first of all make sure you are
338:34 - selecting the correct project then over
338:36 - here on the left side let's go into
338:37 - relay and let's go ahead and set up the
338:39 - relay link DNT project we already did
338:42 - that so next install the package we did
338:43 - that next and now here on let's turn it
338:45 - really on
338:46 - if there is done next and yep we are
338:49 - finished okay great
338:50 - so the relay is now set up we can now
338:53 - begin using it and basically the way we
338:55 - use is first we need to allocate the
338:57 - relay and then we need to use it before
338:59 - we start the net good connection so the
339:01 - way we set up our game is we set up the
339:03 - connection immediately as soon as we
339:04 - create a Lobby so let's go then let's go
339:07 - to the create Lobby function so here we
339:08 - are we created a brand new Lobby and we
339:10 - start the host right away so we need to
339:12 - allocate the relay before we start the
339:14 - host so over here let's do that let's
339:15 - make a function to allocate the relay
339:18 - so a private void let's call it allocate
339:22 - relay
339:26 - and now inside here we are going to go
339:28 - inside the relay service
339:30 - also by the way sometimes Visual Studio
339:32 - might not update so just go ahead close
339:33 - it and let's reopen it again
339:36 - and over here if we go inside relay
339:38 - service
339:39 - here visual studio now this thing you we
339:41 - need to add using Unity Services now
339:43 - really so let's add that then here let's
339:45 - access the instance and call the
339:47 - function to create an allocation async
339:50 - this one just requires an end for the
339:53 - maximum number of connections so in our
339:55 - game we already Define the max number of
339:57 - players so let's go into the kitchen
339:58 - game multiplayer and over there we have
340:00 - the max player Mount although
340:02 - importantly over here for the
340:03 - connections it is actually minus the
340:04 - host so we want four players that is
340:07 - what we have here on the maximum wire
340:08 - Mount so mine is the host let's just do
340:10 - minus one and then if you want
340:11 - optionally you can set a region or or
340:13 - the relay itself on the side of the
340:15 - region so let's just let them decide
340:16 - okay so this one is going to return an
340:19 - allocation so allocation so it's this
340:21 - one inside Unity Services relay modeled
340:24 - so this is the relay allocation and as
340:26 - always this one is an awaitable so it's
340:28 - a weight and async
340:30 - okay so this is going to allocator relay
340:32 - and now just like with the login let's
340:34 - put this inside a try catch just to make
340:36 - sure the game doesn't crash so catch and
340:38 - let's cash for anything relay service
340:41 - exception
340:42 - if that happens let's just do a debug
340:45 - download okay great then we basically
340:47 - want to get the allocation so when we
340:49 - have async we can't directly return an
340:52 - allocation here
340:54 - when working with async we must return
340:56 - something tight task now this has
340:58 - nothing to do with unity itself this is
341:00 - regular c-sharp code so in C sharp when
341:02 - using async and a weight we need to use
341:04 - tasks which as you can see you can
341:05 - inspect these functions see they also
341:07 - return a task and inside an allocation
341:09 - so this is how you work with it so over
341:11 - here let's make task and return
341:12 - allocation
341:13 - and then so we allocate it and we return
341:16 - this allocation
341:20 - in case we have an error let's just
341:22 - return the default
341:23 - and also up here we need to make sure to
341:25 - include system threading.tasks
341:29 - okay Sergio so we have this nice
341:30 - function to allocate really so now over
341:33 - here on the lobby let's just call the
341:34 - function and locate our relay
341:39 - and we made it async so let's also await
341:41 - this okay so this is going to allocate
341:44 - our relay and now the reason why I made
341:46 - it return the allocation is because
341:47 - we're going to need it after we allocate
341:49 - we need to actually generate the code in
341:51 - order to be able to use it another
341:53 - reason why I made it return an
341:54 - allocation is because we need the
341:56 - allocation in order to set the ND
341:57 - transport so the way we set it to use
341:59 - the real way is we go inside the network
342:01 - manager let's access the Singleton and
342:03 - from the Singleton let's get the
342:05 - transport attached to it
342:08 - so once you get component of type Unity
342:10 - transport this one right here
342:13 - so inside Unity netcode transport CTP
342:15 - then on the transport we've got a
342:18 - function set relay server data and this
342:20 - is how we can pass in data so let's make
342:22 - a new of this type
342:24 - sets relay server data so let's add this
342:27 - one and over here this one as you can
342:29 - see it takes an allocation so that is
342:30 - why we need over here the allocation for
342:32 - the Relay so let's grab the allocation
342:34 - and location
342:36 - we grab this then we use it over here
342:38 - and the next parameter is the connection
342:40 - type and by default TNT recommends using
342:42 - dtls so this is some type of encryption
342:46 - all right so that's it so now when we
342:47 - call start host it is going to start the
342:49 - host and start the connection going
342:50 - through this relay so this handle is
342:52 - over here the created host and how we
342:55 - join the relay is we have to join
342:57 - through a code
342:58 - so let's generate a brand new really
343:00 - code based on this allocation so let's
343:02 - make a function for that so private void
343:04 - let's call this get relay join code
343:09 - and inside we go inside the relay
343:11 - service grab the instance
343:14 - and we get the join code async and this
343:17 - one as you can see it takes an
343:18 - allocation ID so let's receive a
343:20 - parameter and location and location
343:23 - and over here we use the
343:24 - allocation.allocation ID
343:26 - okay so this one is going to return a
343:28 - string with our relay join code so
343:30 - string for the Relay join code and we
343:32 - get this and as usual let's await this
343:34 - and this one is async okay great
343:37 - so you have this one and then let's do
343:38 - it just like we did so let's return this
343:40 - really join code so let's make it return
343:42 - a task of type string
343:47 - and then we can just return the relay
343:49 - join code
343:50 - now as usual let's put this inside a try
343:52 - catch so let's try and let's catch a
343:55 - relay service exception
343:58 - once we debug download on E
344:01 - and we have to return something so let's
344:03 - just return a default
344:05 - okay so now this function gets us a
344:07 - really join code so now in here after we
344:09 - get the allocation let's get a string
344:11 - for the Relay join code and we get
344:14 - really join code and pass in the
344:15 - allocation and let's make sure to do
344:17 - this on no wait
344:19 - okay great so that's pretty much all we
344:21 - need over here on the create Lobby so we
344:22 - allocate the relay we get the relay join
344:24 - code we set up the NT transport to use
344:26 - this really and then we start the host
344:28 - so that's all great over here the next
344:30 - thing we need is some way of joining the
344:32 - relay through a code so let's make that
344:34 - function
344:35 - so private drawing let's call it join
344:37 - relay
344:39 - and over here let's go inside the relay
344:41 - service the instance and we join
344:44 - allocation async so this one takes a
344:46 - string for the join code so let's
344:47 - receive here this ring for the join code
344:49 - and we use the join code this is how we
344:52 - can join it really and you can note how
344:54 - this one returns a join allocation so
344:57 - that is the same type of allocation that
344:58 - we're going to need in order to set up
345:00 - the network manager UNT transport so
345:02 - let's also make this function return
345:03 - that so let's return a task of type join
345:06 - allocation and as usual let's make this
345:08 - async and on this one let's await and
345:11 - the usual try catch
345:21 - so this one returns a join allocation
345:25 - and we're just going to return this
345:28 - and over here return the default all
345:30 - right so that's this function we pass in
345:33 - a really join code and then it joins the
345:34 - allocation so then let's go down here to
345:37 - where we are joining so for example over
345:39 - here on quick join so we first joined
345:41 - the lobby okay great then afterwards
345:42 - let's join the relay
345:44 - so let's call join relay by code
345:47 - and over here obviously we need the join
345:49 - code but let's worry about that in a
345:51 - little bit so this one is going to
345:52 - return a join allocation so join
345:55 - allocation we await this and we get that
345:58 - and then with this allocation we can do
346:00 - the same thing that we did here in order
346:01 - to set up the NT transport
346:03 - so we just paste this function instead
346:05 - of using the navigation we use the join
346:06 - allocation okay so that's it this is all
346:08 - we need in order to join through the
346:09 - relay now the obvious thing is over here
346:11 - we need the relay join code so the big
346:13 - question is how do we get it and
346:15 - actually that's very simple we're going
346:17 - to use the lobby in order to share the
346:18 - relay join code so let's go up here to
346:21 - when we are getting the allocation
346:22 - getting the railing joint code and let's
346:24 - just set the Rimley code as part of the
346:26 - lobby data so over here let's just go
346:28 - Indian Lobby service the incense and
346:31 - let's call the function update and Lobby
346:32 - async so we're going to update the lobby
346:35 - data this requires nobody ID so let's
346:37 - use the join lobby.id
346:39 - and then for the update Lobby options
346:41 - let's create a new object of this time
346:43 - and over here we can update all of this
346:46 - type and let's update the data so let's
346:48 - make a new one of this time so this one
346:50 - takes a string and a dictionary let's
346:53 - add a brand new entry to this dictionary
346:55 - and first of all for the key let's
346:57 - define a key and as usual let's not
346:58 - Define it over here so let's go to the
347:00 - top of the file and make a nice constant
347:02 - so pure a private con string call it the
347:05 - key relay join code
347:09 - and say relay join code okay so we have
347:13 - this key
347:15 - and over here when we update the lobby
347:17 - let's use this key and then for the
347:19 - value let's just pass in the relay join
347:21 - code although this needs to be inside
347:23 - that object so let's make a new that
347:25 - object and for the visibility we want
347:27 - this to only be visible to members of
347:29 - this Lobby so let's go with member
347:32 - and for the value let's pass in the
347:34 - relay join code
347:36 - okay so this is it and this one as usual
347:38 - is in the weight of Hong Kong like this
347:40 - all right so with this we are updating
347:42 - the lobby to hold the data for the Relay
347:44 - joint code then all we need is to get it
347:46 - when someone joins so down here on the
347:48 - quick join we have joined the lobby and
347:51 - inside the lobby we can simply access
347:53 - the data and inside we can access on the
347:55 - same key and yep over here we have a
347:58 - string for the Relay join code so we
348:00 - have this and then we just use it over
348:02 - here and also by the way this one has a
348:04 - that object so we need to grab the value
348:06 - okay so that's really it really is that
348:08 - simple so when we create we update team
348:10 - Lobby data with really join code and
348:12 - when we join we grab that we use that to
348:14 - join the allocation and we join with
348:16 - unity transport now we need to do is we
348:18 - need to make sure to run this code
348:20 - before everything will start client so
348:22 - over here on the quick join we do that
348:23 - then on join with ID let's do the same
348:26 - thing and same thing down here join with
348:28 - code like that
348:29 - so you always need to make sure to set
348:31 - up DNT transport to use a relay before
348:33 - you start client or start host alright
348:36 - so that's really it with this it really
348:37 - is fully implemented so let's test
348:40 - also on the network manager let's scroll
348:42 - down to the NT transport and over here
348:43 - for the protocol let's swap it out for
348:45 - the really Unity transport all right so
348:47 - here let's go ahead and hit on play
348:49 - Let's create a brand new Lobby
348:51 - its name is my first Lobby let's go
348:53 - ahead create a public and there you go
348:55 - it is creating and it has taken a little
348:57 - bit longer since it is allocating the
348:58 - relay and if you look over here on the
349:01 - console yep we do see the messages it is
349:02 - indeed allocating the relay and it did
349:04 - decide that the best region is your
349:06 - request too okay so this one is now
349:08 - using the relay so now on this one if I
349:10 - hit on play and if there go I do see the
349:12 - lobby right away and if I click on it if
349:14 - there you go it did join the same
349:16 - session note how the player didn't have
349:18 - to bother with inputting any relay code
349:20 - or anything everything happened
349:21 - automatically in the background great
349:23 - and we can also verify that it is indeed
349:25 - working by trying to make another Lobby
349:27 - for a separate section okay so here I
349:30 - have two more clients so on this one
349:31 - let's go ahead create another Lobby I'm
349:33 - not going to join I'm going to create
349:34 - another one my other game let's go ahead
349:37 - create public and if there go now this
349:40 - one created a completely new Lobby
349:42 - and on this one down here let's hit on
349:43 - play and let's choose one let's go and
349:45 - join this one so my other game let's
349:47 - join that Lobby and if there you go note
349:49 - how this one did join a completely
349:51 - different Lobby
349:52 - so with this we now have two completely
349:54 - separate sessions we can now go into
349:56 - regular gameplay so on this one let's
349:57 - hit on ready this one down here let's
349:59 - also ready and yep both of these are now
350:01 - playing their own game there it is just
350:03 - like this and on these let's go into
350:05 - ready and let's go into ready and
350:07 - they're also going to start their own
350:08 - game
350:09 - and there you go now they're also
350:11 - playing a completely different game like
350:12 - this and like this
350:14 - so here we have two unique sessions of
350:16 - our game and both of them working
350:17 - perfectly and separately awesome
350:20 - we can also look in the dashboard over
350:22 - here and see and yep we are indeed using
350:24 - some data so we are indeed connected
350:25 - through the relay okay great so this is
350:29 - really it as you can see using the
350:30 - reality is super simple with this we can
350:32 - now connect any players in any location
350:34 - in the world the players don't have to
350:36 - worry about port forwarding or anything
350:38 - to do with firewalls everything works
350:40 - seamlessly in the background
350:42 - so with this our multiplayer game is
350:44 - pretty much commonly working Unity has
350:46 - some more interesting multiplier tools
350:48 - so let's talk a bit about those in the
350:50 - next lecture
350:52 - hey again quick intermission you're
350:54 - almost at the very end so
350:56 - congratulations on making it this far
350:57 - this one is the second secret call out
351:00 - so go ahead post a timestamp and a
351:02 - monkey emoj in the comments it will be
351:04 - fun to see how many people make it to
351:05 - this point if you've made it this far
351:07 - and understood everything then you
351:09 - already have most of the knowledge you
351:10 - needed to build just about any
351:12 - multiplayer game
351:13 - let me know in the comments what kind of
351:15 - multiplayer ideas you'd like to build
351:16 - maybe you're a fan of something exactly
351:18 - like this a casual Co-op game or maybe
351:21 - you're more interested in building
351:22 - something with some exploration in
351:24 - building kind of like valheim or perhaps
351:27 - you'd like to make some kind of shooter
351:28 - game with notes you can hear really all
351:30 - of those are possible to build so right
351:32 - now let me say thanks for watching the
351:34 - course so far and I really hope you've
351:36 - learned a ton there's only a few more
351:38 - lectures until we get everything built
351:39 - so let's continue to the next lecture
351:43 - hello and welcome I'm your code monkey
351:45 - in this lecture we're going to talk
351:47 - about the various other multiplayer
351:49 - tools that UNT has in order to handle
351:51 - dedicated servers matchmaking and Voice
351:53 - or text chat so here we have already
351:55 - implemented labian relay two great tools
351:58 - that are part of UNT gaming services and
352:00 - there are a few more that ENT provides
352:02 - there is Game Server hosting which also
352:04 - used to be known as multiplay this is
352:07 - how you can easily handle dedicated
352:08 - servers this tool is actually what Apex
352:11 - Legends uses to manage their server
352:13 - infrastructure so it's very robust the
352:15 - way it works is you make a dedicated
352:17 - server build for a game so pretty much
352:19 - just a regular build but with no
352:21 - Graphics then you upload that to the
352:23 - game server hosting platform and after
352:25 - that when a player goes to play your
352:26 - game it automatically spins up an
352:28 - instance of your dedicated server
352:29 - locating in some data center close to
352:31 - where the player is as more and more
352:33 - players play your game more and more
352:34 - servers are automatically started so as
352:37 - your game grows the backhand
352:38 - automatically scales to meet demand then
352:40 - for another Unity gaming Services soon
352:42 - you have Matchmaker with this one you
352:45 - can Define some rules and your players
352:46 - will automatically be matched with one
352:48 - another the most obvious use case is
352:50 - obviously for skill based matchmaking
352:52 - so you'll find some skill number for
352:54 - your players and you can match players
352:56 - with similar skills together but that's
352:58 - not the only case you can also simply
353:00 - Define a room for Ping so search through
353:03 - the regions and look for players under a
353:05 - certain Pang in order to match them or
353:06 - if you have a game with lots of players
353:08 - per server like for example in MMO you
353:10 - could also match players based on server
353:12 - density you can define those rules but
353:14 - then you can also Define secondary rooms
353:16 - that get triggered after some time so
353:18 - for example you can match players with a
353:20 - skill difference of 100 points then if
353:22 - none are found within 10 seconds you can
353:24 - relax that rule and look for players
353:26 - with indifference of 200 points this
353:28 - tool is very well integrated with game
353:30 - server hosting and finally you have vbox
353:33 - this is a tool to help you add text and
353:35 - voice chat to your games Apex Legends
353:37 - also uses this tool this is fully
353:40 - featured so while you could make a basic
353:42 - chat system with just some basic rpcs
353:44 - making something fully featured does
353:46 - take a ton of work and making voice is
353:48 - extremely complex so with vbox you have
353:50 - some high quality audio with low latency
353:52 - it features support for both 2D and 3D
353:55 - positional audio you have some easy
353:57 - volume and mute controls it also
353:59 - apparently supports Speech-to-Text which
354:01 - sounds interesting and you can send DMS
354:03 - to other players send text any group
354:05 - chat and many more features so with
354:07 - these three tools you can further expand
354:09 - upon your multiplayer games in many ways
354:11 - now I did want to include detailed
354:13 - tutorials on all of these three tools
354:15 - but I've been working non-stop for these
354:17 - past few months on both the single
354:18 - player course and now this one I'm quite
354:20 - a bit behind on schedule for some of my
354:22 - other projects like for example my steam
354:23 - game so I don't have the time to really
354:26 - research and cover these tools right now
354:27 - but I also don't want to delay this
354:30 - multiplayer course since the game is
354:31 - already essentially complete so what I
354:33 - will do is launch this multiplayer
354:35 - course which is why you're hearing this
354:36 - right now and in the near future I will
354:38 - do separate videos covering these three
354:40 - tools when I do I will add them to the
354:42 - video references on the course page so
354:44 - if you're watching this in the future
354:45 - pause the video right now and go look at
354:47 - that page so stay tuned for that or you
354:49 - can go read the documentation and learn
354:51 - how to implement it for yourself if
354:53 - you've managed to fully understand
354:54 - everything in this course then I'm sure
354:56 - you'll be able to learn about these
354:57 - tools and use them on your own so here
354:59 - back in this game now that we have
355:01 - pretty much everything working there are
355:03 - some built-in tools to help us debug our
355:05 - multiplayer game let's learn about those
355:07 - in the next lecture
355:09 - hello and welcome I'm your code monkey
355:11 - in this lecture we're going to look at
355:13 - some built-in tools to help us analyze
355:15 - and optimize our game okay so when it
355:18 - comes to the topic of analyzing and
355:19 - optimizing a multiplier game there's
355:21 - really a million things you can do what
355:23 - you should do really depends on a
355:24 - case-by-case basis there are no
355:26 - Universal rules that I can tell you that
355:28 - are going to be applicable to every
355:30 - single possible game so instead of
355:32 - anything too specific here let's just
355:33 - look at the tools and see how they might
355:35 - help the first one is actually something
355:37 - that we already used
355:38 - if we go into the network manager and
355:40 - we'll look down here onto DNT transport
355:42 - down here we have the debug simulator
355:45 - with this we can simulate delay which is
355:47 - how much time packets take to be sent
355:49 - and received again there are no
355:51 - Universal rules so if you're making a
355:53 - super fast paced FPS or some fighting
355:55 - game then for testing maybe you should
355:57 - test with delay up to 15 milliseconds
355:59 - remember the number that you get here is
356:01 - added on top of whatever delay you
356:03 - already have then if you're making a
356:05 - casual Co-op game like the one that we
356:07 - have here you can probably push that up
356:08 - to 150 or 200 milliseconds and if you
356:11 - have something like a turn-based
356:12 - strategy game then perhaps it's even
356:14 - acceptable to go up to 500 or maybe even
356:16 - 1000 milliseconds with this parameter
356:19 - you can basically set the worst case
356:20 - scenario and test your game if only to
356:22 - make sure that it works with definitely
356:23 - and everything soon works as expected
356:25 - then the other option is the Jitter this
356:28 - one is the rate at which the Ping
356:29 - changes basically packets on the
356:31 - internet they are independent and they
356:33 - don't necessarily follow the same path
356:34 - every time so the Jitter here represents
356:37 - a variation in how long each packet will
356:39 - take to arrive maybe one packet takes a
356:42 - really short route and gets a
356:43 - destination in 20 milliseconds and then
356:45 - another packet for some reason takes a
356:47 - much longer route and instead takes 100
356:49 - milliseconds that difference is going to
356:51 - be Jitter this can be important
356:52 - especially with regards to packet
356:54 - ordering by default packets will arrive
356:57 - at the same order as they are sent so in
356:59 - that case if you have a high Jitter that
357:01 - can cause quite some issues so one
357:03 - option you have is for example on the
357:04 - rpcs over here note how this has a film
357:07 - for delivery which is of type RPC
357:09 - delivering and this one you have two
357:11 - options you have reliable and unreliable
357:14 - by default it's reliable which means the
357:16 - packet won't always arrive there or you
357:19 - can also make them unreliable which
357:21 - means they might not arrive in the same
357:22 - order as they are sent or they might not
357:24 - arrive at all which in turn can help
357:26 - reduce problems each other
357:28 - depending on what you're doing what type
357:30 - of data you're synchronizing you might
357:31 - or might not need ordering and of course
357:34 - remember making it unreliable means the
357:36 - packet might never arrive at all again
357:38 - whether that is a problem or not depends
357:40 - on the use case if you're sending an RPC
357:42 - just to trigger a minor visual effect
357:43 - then you probably don't care if the RPC
357:45 - ends up lost so related to that the last
357:47 - option is the packet drop rate meaning a
357:50 - certain percentage of packets will just
357:51 - be lost
357:52 - if you're using reliable rpcs then that
357:55 - means the packet won't be repeatedly
357:56 - sent until the receiver finally gets the
357:58 - packet
357:59 - which in turn obviously that won't slow
358:01 - down all of the other cute packets so
358:04 - drop rate can definitely cause some very
358:05 - strange Behavior basically it's very
358:07 - useful to use this debug simulator to
358:09 - test your game with a bunch of settings
358:11 - for the numbers you define here they are
358:13 - going to depend on your game and
358:14 - basically you should test your game in
358:15 - the worst case scenario and make sure
358:16 - everything still works now before we use
358:19 - this to test let's actually check one
358:21 - other helpful tool let's go and open up
358:23 - the package manager and over here let's
358:25 - look for the multiplayer tools package
358:27 - so here it is this package let's install
358:29 - it this one adds a bunch more tools for
358:33 - example one tool on the sides is the
358:34 - runtime Network stats monitor for that
358:37 - let's go into the game scene and over
358:39 - here let's create an empty game object
358:41 - called the runtime net stats monitor
358:44 - let's go ahead reset transform just keep
358:47 - things clean and now let's add the
358:48 - script runtime netstats Monitor and here
358:50 - we got a bunch of settings you can leave
358:52 - it on defaults for the position let's
358:54 - just put on the right side just for our
358:55 - game okay so that's great now let's set
358:58 - up our test
358:59 - so let's go back into the lobby in order
359:01 - to look at the network manager okay so
359:04 - down here for the values one thing is
359:06 - keep in mind that these values are added
359:07 - on top of whatever connection you have
359:09 - right now we are currently already using
359:11 - relay which adds a little bit of delay
359:13 - so here for this delay let's go with 50
359:16 - milliseconds extra
359:17 - then for package editor let's also go
359:19 - with 50 milliseconds and for the drop
359:21 - rate let's say 10 so this will
359:24 - essentially simulate a pretty bad
359:25 - connection also very important is just
359:27 - like it says here on this tone tip this
359:29 - only gets applied on development builds
359:31 - so when making a build for testing let's
359:33 - go up here into file and build settings
359:35 - and over here we have a toggle for
359:37 - development build so if this one is
359:39 - Untold that will not run so let's make
359:41 - sure to turn on this and let's make a
359:43 - build okay so here we have the build and
359:46 - over here let's try to create a Lobby so
359:48 - let's create a public Lobby and right
359:50 - away you can see that it takes actually
359:51 - quite a bit longer so that's the deal in
359:53 - action now down here let's click on play
359:56 - and let's go ahead and quick join and
359:58 - once again it's going to take a little
359:59 - bit longer so the connection there you
360:01 - go takes quite a little bit let's go
360:03 - headset on ready and this one on ready
360:04 - just like this okay so here we are and
360:07 - right away we see a bunch of things so
360:08 - over there we see the runtime network
360:10 - sets monitor so it's actually interact
360:12 - not to start yep there you go we can see
360:14 - that so first of all over there the rtt
360:16 - this one is round trip time so the time
360:19 - to get to the server and back and this
360:21 - one is a server so this one has zero but
360:22 - this one down here note how it has 200
360:24 - milliseconds and if I move around in
360:26 - order to make an update you can also see
360:28 - it going up and down so that's the
360:29 - generating action so it goes all the way
360:31 - up to 250 then down to 220 and so on so
360:34 - that's because we added 50 in Jitter
360:36 - okay great and right away with this if
360:38 - we look over there on the host we can
360:40 - see quite a big difference in delay look
360:42 - at that everything is quite a bit laggy
360:44 - perhaps this is a little bit too much
360:46 - but some let's just make sure the game
360:48 - works like this and over there we can
360:50 - all see a bunch of sets so you can see
360:51 - the number of RPC packets number of
360:53 - bytes will send and receive so this can
360:55 - be useful for monitoring how much
360:56 - bandwidth your game is using now so
360:58 - related to that is the profiler so over
361:00 - here on the empty editor let's go into
361:02 - analysis profiler and down here if we
361:05 - scroll down we can see a bunch of
361:06 - elements yep over here for the NGO
361:08 - messages and if we click on one of these
361:10 - and we drag it around we can see over
361:13 - here we have client one and client one
361:15 - is sending a network variable on danta
361:17 - and a Time sync with a bunch of bytes
361:18 - and if we scroll around we can see
361:21 - if we try to interact with something you
361:24 - know we can see a client RPC message
361:26 - create object message we can see a whole
361:28 - bunch of interesting things so basically
361:30 - over here we can see how much that is
361:32 - actually being sent either through a
361:33 - network variable or an RPC and who
361:35 - exactly is firing that so again lots of
361:37 - data to analyze how you might optimize
361:39 - your game remember bandwidth is a huge
361:41 - thing and it comes to multiplayer games
361:43 - so now that we have a light connection
361:45 - we can test our game and we actually do
361:48 - have a bunch of bugs so down here if I'm
361:51 - on the laggy client if I go ahead and
361:53 - pick up some cheese then I go into the
361:55 - cutting counter I place there and now
361:57 - I'm going to try to slice as quickly as
361:59 - possible so I'm going to spam the slice
362:01 - button so just Spam and there you go
362:03 - we've got an error on the server so here
362:05 - it is a no reference exception so let's
362:07 - see what this is doing
362:08 - any up here is the error and actually
362:10 - the error is because the cutting recipe
362:11 - is known so over here we have a known
362:13 - reference exception and the reason why
362:15 - this one is null is because we are
362:16 - trying to cut something but the kitchen
362:18 - object is actually going to be the cut
362:19 - object
362:21 - since the cut object doesn't actually
362:22 - then have a cutting recipe for something
362:24 - else it's going to return no basically
362:26 - the problem that we have here is that
362:27 - the client is trying to catch the object
362:29 - way too many times that is because the
362:31 - cutting Foundation actually happens up
362:33 - here on the interact alternate so this
362:35 - is where we decide whether we can slice
362:36 - or not we are running this validation
362:38 - only on the client
362:40 - so if the client has delayed then this
362:42 - will end up trying to slice way too many
362:43 - times causing an error so here even
362:46 - though we are okay with having a client
362:47 - authoritative model we still need to
362:49 - validate the actions of the client in
362:51 - this case it's actually a simple
362:52 - solution we just run these checks over
362:55 - here on the server RPC so let's just
362:57 - check if we have a recipe and if it can
362:59 - be cut then we are going to broadcast
363:01 - the cut object message and same thing
363:04 - down here on the progress done server
363:06 - RPC over here let's also copy the same
363:08 - thing so run this Foundation to make
363:10 - sure the player can actually cut this
363:13 - okay with this simple change Let's test
363:15 - okay so here we are let's pick up some
363:17 - cheese
363:18 - and now let's try spamming the cut like
363:20 - crazy and if there you go even with
363:22 - cutting a ton of times with a bunch of
363:24 - lag now it still works hasn't done now
363:26 - for the next possible issue is on the
363:27 - trash so if I pick up something and then
363:30 - I go and trash it and once again I spam
363:32 - the tracking and if there you go we have
363:34 - no error if unlock the error is here and
363:37 - once again we have the same problem the
363:39 - validation is client side so we're going
363:40 - to get tons of server rpcs in order to
363:42 - destroy that object and only the first
363:44 - one will work so the first one destroys
363:46 - the object and every subsequent one is
363:48 - going to have null in here so once again
363:50 - Simple Solution let's just check if the
363:52 - object is already destroyed if so then
363:54 - do nothing so over here if the kitchen
363:57 - object Network object if this one is
363:59 - already known
364:01 - then this object is already destroyed
364:05 - so if so let's just return okay super
364:07 - simple Let's test
364:09 - so let's pick up an object go in there
364:11 - and trash it let's spam any of their yo
364:14 - no error okay great now for another one
364:16 - it's actually on the pickup so let's go
364:18 - up here and pick it up once again I'm
364:20 - going to spam and there you go we have
364:22 - an err this one says the kitchen object
364:24 - parent already has a kitchen object
364:26 - basically the issue is actually here on
364:28 - the container counter so when we
364:30 - interact we are going to spawn a kitchen
364:31 - object and on this function to spawn it
364:33 - we are going to use a server PC and
364:36 - again if the client takes way too long
364:37 - to receive the message that the server
364:39 - has been spawned if so then they're
364:41 - basically going to call this function a
364:42 - ton of times so the server will try to
364:44 - spawn one object and give it to the
364:46 - player then spawn another object and try
364:48 - to give it to the player which obviously
364:49 - cannot happen so once again we can
364:51 - validate this on the server RPC
364:53 - we can just grab the kitchen object
364:55 - parent and compare it so let's grab this
364:58 - one first so we grab the kitchen object
364:59 - parent
365:00 - and then just check if the parent
365:02 - already has something so if the kitchen
365:04 - object parent has a kitchen object
365:08 - then parent already spawn an object if
365:13 - so let's return and not do anything okay
365:15 - once again let's test
365:17 - okay so let's go and spam to pick it up
365:19 - and if there go it only picks up one
365:21 - okay great
365:22 - so with that I think there are no more
365:24 - errors you to lag so we can spam pick up
365:27 - and drop and that works great we can go
365:29 - there we can slice them like crazy and
365:31 - yep everything works great
365:32 - although again everything that I did
365:34 - here was very specific to this game so
365:36 - you can see how there are no Universal
365:38 - Solutions depending on what problem you
365:40 - have and what your game is like you will
365:42 - have a different solution
365:43 - finally there's one more very important
365:45 - thing over here on the network manager
365:47 - here we have a film for the protocol
365:49 - version this is how you can make
365:51 - versions incompatible with one another
365:53 - usually you really don't want to have
365:55 - different players with different builds
365:56 - playing with each other that's probably
365:58 - going to cause a ton of problems so your
366:00 - players should always update their game
366:01 - and the code should only allow players
366:04 - with the same build to play together so
366:05 - for example let's say we fix some of
366:07 - those issues but someone out there had
366:08 - the old version and they didn't update
366:10 - so that build was made with the protocol
366:12 - version of zero and now if I change from
366:14 - 0 to 1 and now I test here so up here
366:18 - the editor has protocol version of one
366:19 - and down here the build has protocol
366:21 - version of zero and now if I go into
366:24 - test over here if I create a lobbying
366:27 - now this one actually does see the lobby
366:29 - because we didn't add any sort of
366:30 - Virginia on the lobby although we could
366:32 - easily add that in the lobby data and
366:34 - only show on Lobby is on the same
366:35 - version
366:35 - but even without that just like this we
366:37 - are guaranteed to have no connection if
366:39 - I try to join this one joining Lobby
366:41 - connecting and there you go fail to
366:43 - connect because we have different
366:45 - protocol versions so with this only the
366:47 - same version can connect alright so
366:49 - those are a bunch of tools for how you
366:50 - can test your game as you can see the
366:52 - solution is heavily dependent on a
366:54 - case-by-case basis so instead of
366:56 - memorizing these specific Solutions just
366:58 - learn how to use these tools to solve
366:59 - any problem okay so with that our
367:01 - multiplayer game is pretty robust
367:02 - finally since our game is pretty much
367:04 - done let's go over here on to the
367:05 - kitchen game Lobby and down here we have
367:08 - our testing code for initializing how we
367:10 - set the profile we did this just so we
367:12 - could have multiple builds at once but
367:14 - we don't really need this in the final
367:15 - published game so we can just come
367:17 - without this line to set a different
367:19 - profile every time and one last thing in
367:21 - my case I'm going to go over here onto
367:23 - the game scene and I'm going to remove
367:24 - the quantum console
367:26 - finally for testing let's also disable
367:28 - the runtime net sets Monitor and let's
367:30 - go into the build settings and make sure
367:32 - that our builds are not development
367:34 - builds okay great so everything is set
367:36 - up correctly now let's go into the next
367:38 - lecture to add an interesting option
367:39 - let's add the option to play the game
367:41 - internally in single player
367:43 - hello and welcome I'm your code monkey
367:46 - in this lecture we're going to add an
367:48 - option to play the game fully in single
367:50 - player okay so when you make a
367:51 - multiplayer game if it is possible with
367:53 - the design you should include an offline
367:55 - single player mode here in this game of
367:57 - the player units work the same so design
367:59 - doesn't really require multiplayer so
368:01 - let's have that as an option and
368:03 - thankfully that's actually super simple
368:04 - let's begin by going into the main mini
368:07 - scene and over here all we really need
368:09 - is just another button so let's take the
368:11 - play button
368:12 - let's name this play single player
368:15 - button and let's duplicate this and make
368:18 - the play multiplayer button
368:21 - okay let's just position them put that
368:23 - one there that one up there and let's
368:25 - not submit the text
368:27 - so for this one multiplayer let's scale
368:30 - it down a little bit and same thing on
368:32 - this one let's put it sing on player and
368:35 - also scale it down okay great two
368:37 - buttons now let's open up the main menu
368:39 - UI script and over here let's add both
368:41 - button references so let's rename this
368:43 - one to the play multiplayer button
368:46 - another one for the play single player
368:49 - button
368:50 - then here in the editor let's write the
368:52 - references so the single player and the
368:53 - multiplayer okay and now very simply in
368:57 - order to play multiplayer we do go into
368:58 - the lobby scene so pretty much the same
369:00 - as normal and then on this one we really
369:02 - just need to go straight into the game
369:04 - scene and call the start host now the
369:07 - one tricky thing is we don't have the
369:09 - kitchen game multiplayer we don't have
369:10 - this over here on this scene we only
369:12 - have it on the lobby scene
369:13 - so we could rework how our game is
369:15 - organized in order to place those
369:17 - objects over here on the main menu or
369:18 - let's just add some basic automated
369:21 - Logic on the lobby scene so let's go
369:23 - here on the kitchen game multiplayer and
369:25 - for this one let's make a static volume
369:26 - we can sense so public static ball
369:29 - let's go and play multiplayer
369:32 - so we have this standard Boeing it's
369:34 - bowling so we can access it from
369:35 - anywhere so over here on the main menu
369:37 - let's go into the kitchen game
369:38 - multiplayer and we set play multiplayer
369:40 - in this case to true and in this one we
369:42 - set it to false then we both go into the
369:46 - lobby scene and now over here on this
369:48 - one let's go and make a private void
369:50 - start and on start let's check if
369:53 - playing multiplier if so then we're
369:55 - actually not going to do anything
369:57 - so let's actually say not playing
369:59 - multiplayer so playing in single player
370:01 - if so then let's start playing right
370:03 - away so let's go on start host
370:06 - and then loader and let's load and load
370:09 - the usual game scene
370:11 - okay so honestly that's really it let's
370:13 - test so here we are and press on single
370:15 - player and goes into the lobby and
370:18 - immediately goes there
370:19 - and now if I hit play and if there you
370:21 - go everything is indeed working
370:22 - perfectly so I'm playing around I can
370:24 - pick up I can slice objects I can cook
370:26 - them everything works perfectly alright
370:29 - awesome now I can even shut down my
370:31 - internet to verify so I am not connected
370:33 - and over here let's go into single
370:34 - player goes into the lobby and goes and
370:37 - everything works perfect alright awesome
370:39 - now one thing this actually does throw
370:41 - an error on the lobby that's because it
370:43 - cannot access an external location
370:45 - that's obvious but this is not the
370:47 - problem because it's just throwing an
370:48 - error and the game keeps playing as
370:50 - normal so with this the entire game
370:52 - works perfectly fine everything works
370:54 - great all the logic is running but only
370:56 - locally so even though the network
370:58 - manager is indeed running it is only
371:00 - running locally in offline single player
371:02 - so thankfully for this type of game it
371:04 - is really simple to add single player so
371:05 - if possible definitely make sure to add
371:07 - it to your games with that then there's
371:09 - only one final thing we need to do and
371:10 - that is make sure that our game is
371:12 - playable with a Gamepad so let's test
371:14 - that out in the next lecture
371:16 - hello and welcome I'm your code monkey
371:18 - in this lecture we're going to go
371:20 - through our game and make sure
371:21 - everything is playable with the GamePad
371:23 - okay so when we made the single player
371:25 - game we already made it fully playable
371:27 - with the GamePad but now in order to add
371:29 - some multiplayer features we also added
371:31 - a bunch of extra menus so let's go
371:33 - through the game make sure everything is
371:34 - still playable with the GamePad now over
371:36 - here on the main mini scene everything
371:37 - already works so I can go up and down
371:39 - and select all the buttons just one
371:41 - minor thing which is by default the
371:42 - single player button is the one
371:43 - highlighted let's make the multiplier
371:45 - one to one default so very simple just
371:48 - go over here onto the event system
371:49 - instead of selecting the play single
371:51 - player button let's just write that one
371:52 - okay very simple change now from here
371:55 - let's click and go into the lobby scene
371:57 - and first of all we don't see what
371:59 - exactly is selecting so let's do the
372:00 - same thing and change the color for all
372:02 - the buttons so we're here on Lobby scene
372:04 - let's select all those like the main
372:06 - menu button anyways only just go over
372:08 - here on the slide corner and put it on a
372:10 - green so something like this so let's
372:12 - make sure to apply this to all the
372:13 - buttons
372:14 - so there's great Lobby quick join join
372:16 - code button let's put all of these with
372:19 - a slight color on my screen and same
372:21 - thing for the input Fields also put them
372:23 - as selected and finally on the lobbying
372:25 - list for the template let's also put it
372:27 - on selected then beyond that we've got
372:30 - the unlocking message UI so let's put
372:32 - that one also put it on selecton and for
372:34 - the in lobby create UI from these
372:37 - buttons same thing
372:38 - select all the buttons paste it selected
372:42 - select the input field and same thing
372:44 - okay so then the other thing is on the
372:46 - character side scene so let's go there
372:47 - now and over here do the exact same
372:49 - thing so select all the buttons and set
372:51 - the selected color and then down here
372:53 - for the buttons for changing the color
372:55 - for this one this one is a prefab so
372:57 - let's go inside the prefab and modify
372:59 - the entire prefab okay so that's great
373:01 - just one more thing which is on the
373:03 - event system for this one we need to
373:05 - replace it because by default comes with
373:07 - this input model we want the other one
373:09 - so let's defund it so change it on this
373:11 - one and also on the lobby scene let's
373:13 - also go onto the event system also
373:15 - replace it like this also for testing
373:17 - here let's just default deploy
373:18 - multiplier to true and let's make sure
373:21 - to select the default button so let's go
373:23 - in the unlock UI and let's say the
373:25 - create Lobby button put this one as the
373:27 - first selected then on the character
373:28 - select scene let's also assign one so
373:31 - one of these colors down here select
373:32 - them as selected okay let's test so here
373:35 - we are on the create Lobby move down to
373:37 - Quick join okay great and now if I move
373:39 - down it goes into the code input box and
373:43 - now if I move down and nope now I'm
373:44 - somewhat stuck here so I'm not sure if
373:46 - the automatic navigation is meant to
373:48 - intentionally become stuck on an input
373:50 - field
373:51 - I don't know if that's intentional but
373:52 - that's what happens
373:53 - but either way on a Gamepad we can't
373:56 - right now input any text so a simple
373:58 - solution is just make sure that the
374:00 - GamePad buttons do not go through those
374:01 - input fields so over here select the
374:04 - input fields and on navigation instead
374:05 - of automatic let's just go with none for
374:07 - both this one and the player name input
374:09 - field just like this so now if we move
374:11 - any of the go now we can move through
374:13 - all the buttons now obviously in the
374:15 - final multiplayer game you would make
374:16 - some kind of on-screen keyboard for that
374:18 - you would either interact with some kind
374:20 - of platform API like the Xbox API or the
374:23 - PlayStation API or something like that
374:24 - or you get some kind of on-screen
374:26 - keyboard possibly something from the
374:28 - sort but either way right now at least
374:30 - the game is playable so we can create
374:31 - lobbies and we can quick join we just
374:34 - need to also over here on the create and
374:35 - Lobby let's also disable the navigation
374:38 - on this one
374:39 - and when we show this window we need to
374:41 - show one of these buttons
374:43 - so same thing that we did previously
374:44 - when we have the show let's go let's say
374:46 - the create public button let's go and
374:49 - call Select
374:50 - okay so here I am and I'm going to
374:52 - create a Lobby and yep let's go and make
374:54 - it a public Lobby so it's creating any
374:57 - up here it is and down there the buttons
374:58 - are actually selected so I can change
375:00 - the color into this or this something
375:02 - like that and when I'm ready I can go
375:04 - into the ready and if there you go now
375:05 - here I'm playing and everything plays
375:07 - perfectly
375:08 - all right awesome
375:09 - so the game's now fully playable with a
375:12 - nice Gamepad and with that we have our
375:14 - final game completed so let's go into
375:16 - the next lecture and see everything that
375:17 - we've built
375:19 - hello and welcome I'm your code monkey
375:21 - in this lecture we're going to look at
375:23 - all the work we've done and have some
375:25 - fun playing the final multiplayer game
375:26 - okay so we start off on the usual main
375:29 - menu except right now we have an option
375:31 - to play in multiplayer or single player
375:32 - so if we just go in single player and
375:35 - the game starts playing right away in
375:37 - single player so we can play this
375:38 - offline just by ourselves and everything
375:40 - works perfectly so I can move cut
375:42 - deliver recipes and so on perfect
375:44 - then from here we can go back into the
375:46 - main menu and back in here now let's see
375:48 - the proper thing let's play multiplayer
375:50 - and as soon as we do we go into a nice
375:52 - Lobby scene so here if there were more
375:54 - players playing the game we could see
375:55 - only 7 lobbies up top we can see and
375:58 - customize our player name we can go
376:00 - ahead and create a Lobby give it a Lobby
376:02 - name so my awesome game Lobby and let's
376:06 - go ahead create a public Lobby and if
376:08 - there go it creates and here I am inside
376:10 - my character selection now I've got some
376:13 - other comments down here so I can go
376:15 - ahead and I can join Huawei with all of
376:16 - them so I can either join by joining the
376:19 - live directly or use Quick join and it
376:21 - will automatically join and If This Were
376:22 - a private lobby I could use the lobby
376:24 - code to join by code and if there you go
376:26 - all clients are now connected and for
376:28 - character customization now we can
376:30 - choose from a whole bunch of different
376:31 - colors and there's some logic to prevent
376:33 - players from using the exact same color
376:35 - then once everyone installs their color
376:37 - they can Mark as running and the game
376:39 - will only start when they're all ready
376:40 - also over here on the host the host can
376:42 - kick any client so let's go ahead set
376:45 - them all as ready and once they are all
376:47 - ready the host is going to load and yep
376:49 - all of them are going to load with it
376:50 - then we have our controls and we can
376:53 - press interact to continue and it waits
376:55 - for all the other players so in
376:56 - multiplayer all of them must be ready
376:57 - and there you go we get a nice counter
376:59 - so it counts down the time and after I
377:01 - go the game starts playing as I'm moving
377:03 - it's perfectly synchronized and all the
377:05 - others so I can move on any client
377:06 - anywhere any of everything is
377:08 - synchronized then I can pick up objects
377:10 - once again the animation is synchronized
377:11 - the object is synchronized all of that
377:12 - works perfectly I can place the object I
377:15 - can slice it I can pick it up do a bunch
377:17 - of things then on this one I can go
377:19 - ahead pick up some meat cook it then
377:21 - move away then on this one I can pick up
377:23 - a plate in order to grab the meat and
377:26 - everything is working perfectly so the
377:27 - stove works for definitely the container
377:28 - counter works perfectly the ingredients
377:30 - some of them work perfectly so I can
377:32 - pick up do everything and deliver any of
377:34 - all of them see a delivery success then
377:36 - the game set itself so the countdown
377:38 - timer of that was working perfectly over
377:40 - there the game timer that one is also
377:42 - being perfectly synchronized so we're
377:45 - handling all kinds of things we even
377:46 - have some object militants over there we
377:48 - destroy any of the objects destroyed on
377:50 - the network and when we pick up it gets
377:52 - spawned on the network so lots of things
377:54 - and finally as the Tamron lapses yep all
377:57 - the clients came into a nice game over
377:58 - State alright awesome
378:01 - so here we have a fully working
378:03 - perfectly synchronized multiplayer game
378:05 - now if you've made it this far then
378:07 - congratulations let's go to the next
378:09 - lecture where I'll give you my closing
378:10 - thoughts
378:13 - hello and welcome I'm your code monkey
378:14 - and congratulations you have completed
378:17 - this multiplayer course alright awesome
378:19 - that is seriously a great achievement
378:21 - very few people actually complete
378:23 - courses and if you're at the end of this
378:25 - course then that probably means you also
378:26 - got to the end of the serial employer
378:28 - course so really double congratulations
378:29 - to you I generally hope this course has
378:32 - helped you on your own Game Dev journey
378:33 - I hope you now feel capable to build
378:35 - whatever multiplayer game ideas you have
378:37 - throughout this course you'll learn
378:39 - about how to set up netcode for game
378:40 - objects to create a multiplayer
378:42 - connection you'll learn how to use rpcs
378:44 - and network variables to synchronize all
378:46 - kinds of data you'll learn the pros and
378:48 - cons about server authoritative versus
378:50 - client authoritative you'll learn what
378:52 - logic should be on the server and what
378:54 - can be on the client you also learn how
378:56 - to make a nice character selection scene
378:57 - to customize your players and how to
378:59 - handle the scene connection flow you'll
379:01 - learn how to use Unity Lobby and relay
379:03 - and most important thing of all you'll
379:05 - learn how to do all this while writing
379:07 - some good clean code so I really hope
379:09 - you enjoyed learning about all of that
379:10 - let me know in the comments what was the
379:12 - most important thing you want learned
379:13 - throughout this course I hope this was
379:15 - very fun and very educational if you
379:17 - enjoyed my teaching sound then maybe
379:18 - check out my other courses if you
379:20 - haven't yet seen my turn-based strategy
379:22 - course I really think that one would be
379:23 - excellent for you right now
379:24 - it Dives even deeper into some more
379:26 - advanced topics and since you've watched
379:28 - this entire course and this Empire
379:29 - course you know have all the knowledge
379:31 - you needed to follow that course it will
379:33 - help you really solidify all the
379:35 - knowledge you gained especially
379:36 - everything related to writing some good
379:38 - high quality clean code
379:39 - and since you use Unity check out my
379:41 - ultimate TNT overview course it covers
379:43 - lots of the tones and features of the
379:44 - engine so you can really use all the
379:46 - tools at your disposal to make any game
379:48 - you can think of or alternatively if you
379:50 - like visual scripting you also have a
379:51 - course on that or learn how to make a
379:53 - really nice Builder Defender game and
379:55 - definitely make sure you wishlist my
379:56 - upcoming Sim game Total War Liberation I
379:59 - won't be posting some devlogs and in
380:00 - those you will also see how the code
380:02 - that I used in my own Sim games is on
380:03 - the same level of quality as what you
380:05 - learned in these two courses okay so
380:07 - that's it for me both of these courses
380:09 - have been a ton of work so I genuinely
380:11 - hope they helped you a ton on your Game
380:12 - Dev Journey now go ahead take what you
380:14 - learn here and build an original game
380:17 - thank you so much for watching and I'll
380:18 - see you next time