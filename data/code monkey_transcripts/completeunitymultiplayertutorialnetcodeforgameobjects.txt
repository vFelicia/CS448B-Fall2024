00:00 - hello and welcome I'm your code monkey
00:02 - and it's finally here unity's official
00:04 - multiplayer solution is finally fully
00:06 - released I've had tons of requests to
00:08 - cover some multiplayer and my answer was
00:09 - always the same I'm waiting for the
00:11 - official tune to be released and that
00:12 - time has finally come so here let's look
00:14 - at unity's official multiplayer called
00:16 - netcode for game objects this is a
00:18 - pre-comprehensive detailed tutorial one
00:20 - of the longest I've ever done I tried to
00:22 - cover as much as possible related to
00:24 - multiplier we're going to first start
00:25 - with an extremely simple example just to
00:27 - see how the absolute Basics work so
00:30 - first how to install the package and set
00:31 - up the network manager then how to spawn
00:34 - a player and synchronize it across
00:35 - multiple clients learn about Network
00:38 - objects and network transforms how to
00:40 - synchronize custom data with network
00:42 - variables how to run Logic on the server
00:44 - or the client depending on remote
00:46 - procedure calls learn how to spawn and
00:48 - despawn networked objects how to
00:50 - synchronize animations
00:52 - learn how to use the multiplayer tools
00:54 - for help with debugging and learn about
00:56 - peer-to-peer and net there's timestamps
00:58 - in the video if you want to skip ahead
01:00 - or re-watch your particular section by
01:02 - watching the song video you will have
01:03 - enough knowledge to build all kinds of
01:05 - multiplayer games and with this video as
01:07 - a base I want to build upon it and make
01:08 - some nice multiplayer mini games so do
01:11 - let me know in the comments what types
01:12 - of games you'd like to see maybe in a
01:14 - future video I'll build a quick mini
01:15 - game of things like overcooked the
01:17 - mangas or maybe something like valheim
01:19 - this is one of the longest most detailed
01:21 - tutorials that I've ever done so if you
01:22 - like it please hit the like button it
01:24 - really helps and maybe consider getting
01:26 - one of my courses I'm basically
01:27 - sponsoring this video myself
01:29 - if you use unity in any way definitely
01:31 - get my ultimatinity overview course it
01:33 - won't teach you how to use the many
01:35 - tools and features that ENT has so you
01:37 - can be more effective and make better
01:38 - games faster there's no need to build
01:40 - something yourself from scratch if there
01:42 - is already a button tool that works
01:43 - great UNT has tons of them that you
01:45 - might not know about the course already
01:46 - has 15 lectures each covering a
01:48 - different two-hour feature of the engine
01:50 - and is constantly getting free updates
01:52 - or if you prefer step-by-step courses on
01:54 - making a specific game check out my
01:56 - Builder defender course I also have a
01:58 - phone course only on using visual
01:59 - scripting there's a single line of code
02:01 - in any of those games and if you're past
02:03 - the beginner stage and you want a guided
02:05 - path to help you make the jump from
02:06 - beginner to Advanced and get my
02:08 - turn-based strategy course it will help
02:10 - you massively improve your programming
02:12 - and Game Dev skills on all courses I'm
02:14 - always available in the Q a section
02:15 - answering all of your questions every
02:17 - single day so check them out to the link
02:19 - in the description okay so let's learn
02:21 - all about netcode for game objects let's
02:23 - begin by installing the package so for
02:25 - that let's go into window and open up
02:26 - the package manager and over here let's
02:29 - go go into the NT registry and then
02:31 - scroll down until you find the netcode
02:33 - for game objects although I should note
02:35 - one very important thing which is make
02:37 - sure you're using Unity version
02:39 - 2021.3.10 or later if you're using an
02:42 - earlier version it won't show up over
02:44 - here on the package manager for example
02:46 - while researching this topic I was
02:47 - testing with a project on 21.3.0 and in
02:50 - that version it does not show up so do
02:53 - make sure you have 21.3.10 or later or
02:56 - alternatively you can also install it by
02:58 - selecting the path if you go into the
03:00 - official multiplayer docs over here you
03:02 - see the pass so
03:03 - com.unity.netcode.game object so you
03:06 - could copy that and then paste it over
03:07 - here on ADD package by name but like I
03:09 - said make sure you're using 21.3.10 and
03:12 - it won't show up on the package manager
03:13 - so let's just install it
03:16 - all right the package is installed now
03:18 - the first thing we need for multiplayer
03:20 - is a network manager so let's create an
03:23 - empty new game object let's count as the
03:25 - network manager let's reset transform
03:27 - just keep things clean
03:28 - then let's go up here into add component
03:30 - let's find netcode and then inside
03:33 - netcode let's create a network manager
03:35 - this is the main component that handles
03:37 - pretty much everything related to
03:39 - multiplayer also I should point out that
03:41 - you should have only one of these
03:42 - components so make sure you don't have
03:43 - multiple then on this component we see
03:46 - this info warning it's telling us we
03:48 - probably want to install the multiplayer
03:50 - tools package as well we're going to see
03:52 - about that package later on the video
03:53 - but still let's quickly install it just
03:55 - make sure that this warning disappears
03:57 - so over here on the package manager
03:58 - right above the netcode for game objects
04:00 - is the multiplayer tool so let's just
04:01 - install this
04:04 - okay the package doesn't sound so back
04:06 - into the network manager the next thing
04:08 - that we need is to pick over here the
04:10 - network transport layer this is what
04:12 - actually handles sending and receiving
04:13 - the underlying packets one great thing
04:16 - is that this part is modular which means
04:18 - that you can use netcode for game
04:19 - objects with different transports so for
04:21 - example when making a steam game you
04:23 - could swap this out for the scene
04:24 - transport layer and everything else
04:26 - would work but over here on let's check
04:27 - with the basics and let's use included
04:29 - transport layer so let's look over here
04:31 - and select transport and let's select
04:33 - the unity transport alright so it's
04:35 - unladen down here we see a bunch of ENT
04:36 - transport things let's leave all of the
04:39 - parameters with default so with this the
04:41 - basic setup is done now let's create a
04:43 - simple player character so let's create
04:44 - an empty game object name this the
04:46 - player
04:48 - let's reset the transform and now for a
04:50 - visual let's go inside and let's create
04:52 - a simple capsule let's just offset it on
04:55 - the Y by one so there you go there's my
04:57 - simple player visual okay so now to make
05:00 - this an object that is going to exist on
05:01 - the network let's add the component so
05:03 - let's go into that component let's go
05:05 - inside netcode and this time we want to
05:07 - make this a network object all right
05:09 - that's it no need to touch any of these
05:11 - next the way that the system works is by
05:13 - spawning a prefab for each player so
05:15 - let's first make this into a prefab so
05:17 - just drag it over here into the project
05:19 - window this is now prefab so now let's
05:21 - go back into the network manager and
05:23 - over here we've got a film for the
05:24 - player prefab and let's just drag our
05:26 - player prefab so now when the player
05:28 - connects it will automatically spawn
05:30 - this prefab for each player although
05:32 - here and let me also quickly point out
05:33 - that this is not mandatory for example
05:36 - on some strategy games like Civilization
05:38 - or command conquer you might not want to
05:40 - have a player prefab since in those
05:41 - games you don't really have a single
05:43 - player character
05:44 - so for making those types of games you
05:46 - might want to leave this empty or you
05:48 - might still want to assign it just so it
05:49 - spawns a player prefab without any
05:51 - visual just some game object to run the
05:53 - logic of the player without needing to
05:54 - have any visual also an important thing
05:56 - is let's remove the player prefab over
05:58 - here from the scene player prefab should
06:00 - really be spawned dynamically when a
06:01 - player connects so make sure it's not on
06:03 - the scene the next important thing is
06:05 - over here enlist for Network prefabs
06:07 - basically anything that we want to be
06:09 - spawned on a network must be in this
06:11 - list any object that is not on this list
06:13 - pretty much does not exist on the
06:15 - network so here let's click on the pause
06:17 - icon and let's drag our player prefab
06:19 - okay so with this basic setup we are
06:21 - ready to make a quick test so let's just
06:23 - go ahead hit on play
06:24 - and when you do you might also see this
06:26 - warning Pretty much telling you that
06:28 - this scene has not been added to the
06:29 - building list you can add magic only or
06:31 - just click on yes until edit
06:33 - automatically so let's click on yes
06:34 - basically what that does is over here if
06:36 - we're going to file and build settings
06:37 - over here we now see that this scene
06:40 - that we're working on this one has been
06:41 - added over here to the Boneless okay so
06:43 - let's hit on Play There It Is the game
06:45 - is running and right now there is no
06:47 - player spawned so right now there is no
06:49 - connection nothing and on the network
06:51 - manager we have some nice buttons
06:53 - and by the way if you don't see network
06:55 - manager you might notice that it's not
06:56 - over here on the scene anymore that is
06:59 - because like I said the network manager
07:00 - there's only one component that exists
07:02 - and when that component starts it pretty
07:04 - much adds itself over here on the don't
07:06 - destroy on load so over here is the
07:07 - object let's select it and then here we
07:09 - have these buttons so start host server
07:11 - or client now these three types are
07:13 - extremely important to fully understand
07:15 - a lot of the logic that we're going to
07:16 - build depends on understanding which is
07:18 - which first of all the server is just a
07:21 - server so it has no player then for the
07:24 - client that is just a simple player
07:25 - connecting to a server and the host acts
07:28 - as both a server and a client so if you
07:30 - wanted to make your game use a dedicated
07:32 - server architecture for that one you
07:34 - would create just a server and then all
07:36 - of your players would be clients but if
07:38 - you don't want to use dedicated servers
07:40 - then you make just one player be the
07:42 - host and all of the other players will
07:43 - be regular clients so we're here for our
07:46 - test we want to create the server but I
07:48 - also want to play as a player so let's
07:49 - use it as a host so let's click on it
07:51 - and if there it is as you can see it
07:53 - spawned the player prefab and we can see
07:55 - here that we are currently running as a
07:57 - host
07:57 - supposedly what happened is we created
07:59 - the server and then automatically
08:01 - created the player We join that server
08:02 - on the same window okay great so far so
08:05 - good now using these inspector buttons
08:07 - isn't very useful if we make a build we
08:10 - won't be able to see the inspector so
08:12 - let's make some proper UI button just
08:13 - for testing so over here on the
08:15 - hierarchy I already have my basic canvas
08:17 - so inside my basic canvas let's create
08:20 - an empty game object call this the
08:22 - network manager UI let's put the camera
08:24 - in 2D and zoom out to find the UI now
08:28 - this empty game object let's expand the
08:30 - size so let's click over here on the
08:31 - anchor and expand on all edges and put
08:33 - them all on zero just so that this game
08:35 - object occupies the entire canvas window
08:37 - then inside let's create a new UI button
08:41 - so over here the button text mesh Pro
08:43 - let's call this the server button then
08:46 - let's go inside for the text let's call
08:48 - the server
08:49 - and let's anchor this button over there
08:51 - on the top right corner and just move it
08:53 - in there again make sure you anchor it
08:55 - correctly and make sure you set the
08:56 - parent size correctly because later on
08:59 - when we make a build for the build we're
09:01 - going to be using a smaller window so
09:02 - make sure the buttons are always over
09:04 - there on the top right corner regardless
09:06 - of whatever aspect ratio you're using
09:08 - okay so that's the server button let's
09:10 - duplicate it push it down one for the
09:12 - host button and one for the client
09:13 - button so the host button and the client
09:16 - button
09:20 - all right so we have three simple UI
09:23 - buttons now let's make a script to run
09:25 - this so let's right click let's create a
09:27 - new c-sharp script the network manager
09:29 - UI over here let's attach the script and
09:32 - open
09:33 - okay so now here let's add references
09:35 - for all of our buttons so let's make it
09:37 - a serialized field so we can drag them
09:39 - in the editor
09:40 - so this is a button let's say the server
09:43 - button and over here let's use the
09:45 - visual studio Humper to add our using in
09:48 - the engine.ui okay so the server then
09:50 - you've got the host button and the
09:52 - client button
09:54 - also by the way if you're ENT beginner
09:56 - and you don't know why I'm using
09:57 - serialized film private as opposed to
09:59 - public then go watch my video on why you
10:01 - should not make everything public okay
10:03 - so we have these three references let's
10:04 - go back into the editor and over here on
10:06 - let's drag on references so the server
10:08 - then we've got the host and then the
10:10 - client
10:11 - and over here let's add some Behavior so
10:13 - let's go make a private way to wake and
10:16 - on awake let's go into the button so the
10:17 - server button let's add a click listener
10:20 - so let's go into the on click add-in
10:22 - listener and let's add the unlimited
10:24 - expression
10:27 - and again if you're a beginner and
10:28 - you're not familiar with this Lambda
10:30 - syntax
10:31 - if so then go watch my quick video on
10:32 - delegates so when we click for this one
10:35 - we want to start a server and the way
10:36 - that we do that is we access the network
10:38 - manager and for this one you need to add
10:41 - using unity.netcode
10:43 - so on the network manager inside we can
10:45 - access the static Singleton like I said
10:47 - there's only one of these objects at one
10:49 - time so through the Singleton then we
10:51 - can access some functions so we can
10:54 - start a server a host or a client so for
10:56 - this one let's start a server and for
10:58 - the others let's quickly make them
11:02 - all right so those are all the buttons
11:03 - super simple so start a server a host or
11:05 - a client okay with the button set up
11:08 - let's see one more thing back in the
11:10 - editor let's go into the network manager
11:12 - and over here one of the very important
11:14 - settings is over here the unlock level
11:16 - and by default this one is only on
11:18 - normal we can change this to only do
11:20 - logs on errors or developer which is
11:22 - much more verbose so since we're
11:24 - learning how it all works let's choose
11:26 - the most robust option so let's go with
11:27 - the bumper and also before we make a
11:30 - phone build for testing let's see one
11:31 - more optional step like this if we want
11:33 - to make a build and we want to read over
11:35 - here the console logs doing that for the
11:37 - editor is going to work just fine but
11:39 - again since we're working on multiplier
11:40 - we're going to be working with builds
11:42 - for testing and reading the console logs
11:44 - from build isn't really very simple we
11:46 - have to find the build log file which is
11:48 - pretty annoying so it would be nice to
11:50 - be able to see the logs on screen so for
11:52 - that there's an excellent asset that I
11:53 - reviewed a while ago that does exactly
11:55 - that it's a Quantum console again this
11:57 - step is optional you do not need this to
11:59 - use netcode it's just helpful to be able
12:01 - to easily see the logs in a build I
12:03 - think the asset was included in a bundle
12:04 - a while ago so maybe you already have it
12:06 - and again don't worry if you don't have
12:08 - it you don't need it I won't also show
12:10 - you how to read logs the normal way but
12:12 - for me since I already have it I'm going
12:13 - to be using it so I need is just take
12:15 - the prefab and drop it in my scene
12:18 - and there's my console so that's it just
12:20 - a nice window to be able to read the
12:21 - console logs so now let's test with a
12:24 - proper build let's go into file and into
12:26 - our build settings here make sure that
12:29 - our scene is encoded in the build list
12:30 - and one more thing let's go down here
12:32 - into the player settings and then here
12:34 - you've got these two very important
12:36 - Fields the company name and the product
12:37 - name these are going to be important for
12:39 - later on finding the unlock file so
12:41 - write something in here and also
12:43 - importantly over here on the resolution
12:45 - under phone screen mode make sure you
12:46 - select windowed and not phone screen we
12:49 - want to be able to do some testing and
12:50 - have the windows side by side so make
12:52 - sure you set that and default sure yeah
12:53 - 1024 works well okay so with that let's
12:56 - go ahead and build and run alright it's
12:58 - currently building let's wait a bit
13:00 - all right so here's the build and we can
13:03 - see over here are nice Humper buttons If
13:05 - you don't see them go back and check how
13:07 - you anchor the buttons and what size you
13:09 - use for the parent so here it is and now
13:11 - let's run the other client over here in
13:13 - the editor so let's put them side by
13:14 - side all right so here I have two builds
13:17 - running the editor and a separate one so
13:19 - now over here on the editor let's create
13:20 - a host again a host not a server because
13:23 - I want the editor to also have a player
13:25 - so let's make it a host and yep we can
13:27 - see that our hosts start initialize all
13:29 - right so now over here on this one let's
13:30 - create a client and if there you go it
13:32 - does connect and over here we do see
13:34 - client connected and the client connect
13:35 - to the host all right great so here I've
13:38 - got two players connected in a shared
13:40 - world all right awesome
13:42 - so we can see over here on the logs that
13:44 - the connections did work correctly but
13:45 - like I said if you're not using this
13:47 - asset you can manually go read logs you
13:49 - can find the unlock phone location over
13:51 - here on the documentation we want to
13:53 - find the logs related to the build so
13:55 - let's scroll down and over here the
13:56 - employer running logs and in this case
13:59 - I'm working on windows so I need to go
14:00 - into user profile then app data look on
14:03 - low then it's the company name and the
14:04 - product name that we placed and then
14:06 - inside we should find the player log so
14:08 - in my case here it is under a local
14:10 - monkey netcode for game objects because
14:12 - those are the names that I used and
14:13 - inside I do see the player logs so if we
14:15 - open this yep we do see log circle line
14:18 - internationalize connected which is
14:19 - indeed exactly what we see over here on
14:21 - the log so like I said using an asset
14:23 - like the quantum console is super useful
14:25 - but you can also work without it alright
14:27 - so with this we already have our
14:28 - connection working so we've got a host
14:30 - and the client both joined in the same
14:32 - section however we didn't add anything
14:34 - else so right now if I press any keys
14:36 - nope nothing happens there is no
14:37 - movement no nothing so let's add that
14:39 - let's begin by making a script for our
14:41 - player so let's right click let's create
14:43 - an easy sharp script call this the
14:46 - player Network let's select the player
14:48 - prefab and drag our script okay so now
14:51 - here let me just make some super basic
14:53 - movement code so making an update and on
14:57 - an update I'm just going to test for
14:58 - some basic input
15:08 - alright so here it is some basic inputs
15:10 - creating a movement vector and then
15:12 - using it to move this transform some of
15:13 - it's super simple
15:15 - obviously there are million ways to move
15:16 - the player and over here I'm using the
15:18 - Legacy input manager just for Simplicity
15:20 - but of course you could be using the new
15:22 - input system so again just some super
15:24 - basic movement code so with this we
15:26 - should already be able to move our
15:27 - player so let's make a build just like
15:29 - this to test it out all right so I have
15:31 - both builds let's make this one the host
15:33 - there it is and this one is the client
15:34 - okay now let's select this one and let's
15:37 - try moving and if there we go it does
15:38 - indeed move the player okay so my basic
15:41 - movement logic is indeed working however
15:43 - we can already see the first issue which
15:45 - is that moving one player is actually
15:47 - moving both players now that is because
15:49 - I did not add any check to see if a
15:51 - player owns that object so it's
15:53 - currently moving both the script on both
15:54 - objects is running at the same time
15:57 - so back in the code here one very
15:59 - important thing is over here instead of
16:00 - extending mono behavior let's swap this
16:02 - out and let's extend the network
16:04 - Behavior
16:06 - and this one is as well inside
16:09 - unity.netcode
16:11 - so this class Network Behavior this one
16:13 - is an extension of monobehavior with
16:16 - some extra things that are related to
16:18 - multiplayer so you've got a bunch of
16:20 - virtual functions that you can override
16:21 - a bunch of interesting things and over
16:23 - here A bunch of very useful properties
16:25 - we've got these three right here so is
16:27 - server is client and is Host this is
16:30 - very useful to check which type owns
16:32 - this object and an even more important
16:34 - one is over here this one is owner this
16:37 - one won't be true only for the player
16:38 - object that this player owns so you can
16:41 - use this make sure our script only runs
16:42 - on the owner and does not run on the
16:44 - other prefabs so back in our script over
16:46 - here on our update before we do anything
16:48 - let's just do a simple if and we check
16:50 - is owner
16:52 - and if this one is not true so if we are
16:54 - not the owner of this object then let's
16:56 - just return so we're not going to run
16:58 - any code if this script is not attached
17:00 - to this owner so the only one that is
17:02 - going to run this module down here is
17:04 - just the owner all the other connect
17:06 - players that also have this script will
17:07 - not be listening to any input and they
17:09 - will not be moving this okay so just
17:11 - with this let's test again and see if we
17:13 - can only move our own player alright so
17:15 - here I have this host and this client so
17:17 - now let's select the host and now let's
17:19 - try moving and yep it does work I can
17:21 - only move the object that I actually own
17:23 - alright so that's great that some of the
17:25 - first problem that we saw however we can
17:26 - also see another issue and like this we
17:29 - can see that the movement is not being
17:30 - synchronized so over here I'm moving the
17:32 - player over here on the host but over
17:34 - here on the client it is not receiving
17:35 - any position so the movement is not
17:37 - being synchronized we're moving the
17:39 - player object but only locally we're not
17:41 - actually sending the new position
17:42 - anywhere else so for that let's go
17:44 - inside our player prefab
17:46 - and over here on the prefab let's add a
17:48 - component let's once again go inside
17:51 - netcode and this time we want to add the
17:53 - component Network transform this is
17:55 - going to help us synchronize all the
17:57 - values from the transform however in
17:59 - multiplayer bandwidth is an extremely
18:01 - important thing you really don't want to
18:02 - be sending any unnecessary data so over
18:04 - here you've got a bunch of really useful
18:06 - checkboxes to Define what data you
18:08 - actually want to synchronize we do not
18:10 - want to send any data that will never
18:12 - change so in this case for this demo we
18:14 - are only moving so there is no need to
18:16 - send any scale data and again on this
18:18 - super simple demo we also do not have
18:19 - any rotation we're just moving a Sim on
18:21 - capsule so let's also not send the
18:23 - rotation and finally we also do not have
18:26 - any jumping on this demo so let's not
18:27 - send the Y so that's it the only thing
18:29 - we're going to send is the position x
18:31 - and z that's it so let's save this
18:33 - prefab go back let's make a bill to test
18:36 - so here I have both of them connected so
18:38 - if I move this one and yep there you go
18:40 - it does work so it moves over here
18:41 - locally and over here on the client it
18:43 - is also receiving the new transform
18:45 - position okay great so everything is
18:47 - indeed working the client is receiving
18:49 - the synchronized transform position
18:51 - however with this we also see another
18:53 - extremely important detail
18:55 - it works over here if I move this one
18:57 - which is the host however if I jump over
18:59 - here onto the client if I now try moving
19:01 - this one and nope nothing happens it
19:04 - does not even move locally I'm pressing
19:05 - the buttons but this object this local
19:07 - object is not moving nothing is
19:09 - happening so basically what is going on
19:10 - is like I mentioned by default netcode
19:12 - for game objects is server authoritative
19:15 - meaning that the server is the only one
19:17 - with power to change the current state
19:19 - so the reason why the client is not
19:20 - moving is because when I press the
19:22 - button it actually does try to move but
19:24 - the client does not have ownership so
19:26 - that that the client has here when I
19:28 - move it it does not change it does not
19:30 - send anything back to the server so
19:31 - instead the client is constantly
19:33 - receiving the position from the server
19:34 - and the server it never moves so over
19:36 - here as I try move it tries moving it
19:38 - locally then receives the packet from
19:39 - the server and resets it back into zero
19:41 - zero so this is the part we're going to
19:43 - have to make some decisions regarding
19:45 - netcode architecture and what you want
19:47 - to use
19:48 - if you're making a hyper competitive
19:49 - game then the basic rule is you should
19:51 - never trust the client however if you're
19:54 - doing something casual and Co-op then
19:55 - perhaps it can be okay to trust a client
19:57 - depending on which approach you take you
20:00 - have several options here if you do not
20:02 - want to trust a client then you need
20:04 - basically to have the client on the
20:06 - server hey I would like to move in a
20:07 - certain direction and then the server
20:09 - moves the client and sends the new
20:11 - position back we're going to see how to
20:13 - talk to the server with an RPC in a
20:14 - little bit
20:15 - but if you're making a casual Co-op game
20:17 - and you're okay with trusting the client
20:19 - then there's a much simpler approach
20:20 - over here on the docs if we go into the
20:23 - network transform page and we scroll all
20:25 - the way down here we see something
20:26 - called a client Network transform
20:28 - this is basically the same as a regular
20:30 - Network transform except instead of just
20:32 - having ownership on the server you have
20:34 - ownership on the client itself meaning
20:36 - that the client can move itself and then
20:38 - tell the server where that transform
20:40 - should be this class is not included in
20:42 - the default core package so we need to
20:44 - add it here and as we can see we need to
20:46 - add from git URL and copy paste this URL
20:48 - so let's copy this copy this URL then
20:51 - over here in the editor let's open up
20:52 - the package manager click on the plus
20:55 - icon let's add from git URL and let's
20:57 - face URL and add and yep there you go it
21:00 - is downloading and installing and if
21:02 - there it is it installed the multiplayer
21:04 - samples utilities so on this one let's
21:06 - go back into our player prefab and here
21:08 - we are inside and let's get rid of the
21:10 - network transform and instead let's add
21:12 - a component and let's search for client
21:14 - Network transform yep here it is let's
21:16 - add it and this one as you can see has
21:18 - the exact same properties so let's do
21:20 - the same thing so do not want to send
21:21 - any of these okay just like this
21:24 - and by the way if you want to see the
21:25 - difference that makes this one have
21:27 - ownership as opposed to the other one
21:28 - you can just right click on this one and
21:30 - go into edit script this one opens up
21:32 - the script that we download from samples
21:34 - and as you can see this one just extends
21:35 - in network transform and all it does is
21:37 - wrong just overrides this so is server
21:39 - authoritative and makes it false so if
21:42 - you want you can just copy paste this
21:43 - code you don't need to install the
21:45 - entire samples okay so this is really
21:46 - all we need to do just make sure we swap
21:48 - out the network transform for a client
21:50 - Network transform so let's exit the
21:52 - prefab make sure we save the changes
21:54 - okay let's make another build
21:56 - okay here we are let's make this one a
21:57 - host make this one a client let's move
21:59 - the host and yep it sound works the same
22:01 - as previously now if I get into the
22:03 - client and I move this one and yep there
22:04 - you go this one does work so this one
22:06 - moves and the host is over there
22:07 - receiving new position so both of them
22:09 - work both of them are now networked all
22:11 - right awesome
22:12 - again there are many ways to move and
22:14 - synchronize objects which one you choose
22:16 - is really up to you it all depends if
22:18 - you are okay with trusting client or not
22:19 - which is going to depend on the type of
22:21 - game that you're trying to make so we
22:23 - already have a super simple way of
22:25 - synchronizing transforms that is really
22:26 - awesome now let's look at another way of
22:29 - syncing some data we're going to be
22:30 - using something called Network variables
22:32 - which like name implies lets you have a
22:34 - variable that is synced over the network
22:36 - so let's go back here into our player
22:38 - Network script and over here let's add a
22:40 - field so a private we're going to use
22:42 - F-Type Network variable
22:44 - and this one as you can see uses
22:46 - generics for the type if you don't know
22:48 - about c-sharp generics check out my
22:50 - quick video on them so for the time
22:51 - let's start off simple and just
22:53 - synchronize a simple integer that's it
22:57 - now one important thing about Network
22:59 - variable is it must be used inside a
23:01 - network Behavior class if I swap this
23:04 - out for a regular mono Behavior then
23:06 - this will not work
23:07 - so let's try running our code just like
23:09 - this
23:10 - so here we are and as soon as I try to
23:11 - make host and up there you go I've got
23:13 - an error as it says here all Network
23:15 - variables must be initialized so over
23:18 - here when we Define our Network variable
23:20 - let's also initialize it so let's say we
23:22 - knew and then over here we've got a
23:24 - bunch of default parameters if you want
23:26 - to use the defaults and you can use it
23:27 - just like this or you can start off with
23:29 - the default value so let's say start off
23:30 - with one also very important is you need
23:32 - to initialize the network variable
23:34 - either here on definition or as soon as
23:36 - the object is created you can now create
23:38 - it on a later update for example so we
23:41 - have this variable and now let's modify
23:43 - it and modifying it is super simple so
23:45 - we just need to access it and over here
23:47 - and let's do a simple input test so
23:49 - let's go input get key down let's say
23:52 - for the D key so when we press it let's
23:54 - modify it so inside we go inside we
23:56 - modify the value
23:58 - and we set this to whatever value we
23:59 - want so let's get a random number just
24:02 - testing
24:07 - okay so when I press the button it is
24:09 - going to modify the value inside the
24:11 - network variable and now let's see we
24:12 - debut.log just to be able to see all the
24:14 - values so let's go up here let's go
24:16 - before the is owner because we want to
24:18 - see the value stored on every single
24:20 - client so let's go here and let's see we
24:22 - debug down log
24:23 - let's do the random number dot value
24:26 - let's print this and let's also print
24:28 - the client ID just so we know who is
24:30 - printing this message
24:31 - we can use the owner client ID that
24:33 - exists inside Network Behavior so let's
24:36 - print this so the owner client and then
24:37 - the random number
24:40 - all right so let's test this so here are
24:43 - both balance let's make this one a host
24:45 - and this one a client and over there we
24:47 - can already see the random numbers so as
24:49 - you can see both of them client 0 which
24:50 - is going to be this one the host and
24:52 - client one which is this client both of
24:53 - them are receiving the same random
24:55 - number one which is our starting number
24:56 - now let's see what happens when I press
24:58 - the T King and if there go that one
25:00 - didn't update the random number is now
25:02 - 50 and as you can see over here the
25:03 - client the client also received the
25:04 - update this one also received A50 so
25:07 - Network variable is how you can easily
25:09 - synchronize variable across multiple
25:10 - clients you just set the value and
25:12 - automatically gets propagated throughout
25:14 - all of the clients so change to all of
25:16 - them and yep all of them receive the
25:17 - same value however again here we also
25:20 - see another interesting thing related to
25:22 - the same problem which is If instead of
25:24 - generating over here so I'm pressing T
25:25 - I'm generating over here on the host and
25:27 - yep it does work it does again
25:29 - synchronize however if I go into the
25:31 - client and on the client if I press the
25:32 - T key and if there you go we do see our
25:35 - error let me just reverse the order so
25:37 - we can see the error over here on the
25:38 - ENT editor so make this one down here
25:40 - the host this one up here make it the
25:42 - client and now if I press the T key on
25:44 - the client and if there go there's the
25:46 - error client is not allowed to write to
25:48 - this network variable again we go back
25:50 - into the same thing about Network for
25:51 - game objects where by default it is only
25:54 - server authoritative and like I said
25:56 - this is up to you whether you want to
25:58 - keep it this way you could make the
25:59 - client always ask the server to modify
26:01 - the variable or you can also enable the
26:03 - client to be able to modify themselves
26:05 - directly how you do that is over here
26:07 - when we construct our Network variable
26:09 - as you saw we have a bunch of parameters
26:11 - so the first one is the default value
26:13 - and then we have the read permissions
26:15 - and the write permissions you can see
26:17 - defaults are that everyone can read but
26:20 - only the server can break to it
26:22 - and you can modify them so first of all
26:24 - the read permissions we can set it to
26:26 - everyone which is default or only the
26:28 - owner and also the server although I'm
26:30 - not sure I can really see any scenario
26:32 - where you would want a limit reading so
26:34 - for this one you probably really want to
26:36 - leave it on everyone and the important
26:37 - one is over here on the right
26:39 - permissions
26:40 - for this one you can make it so that the
26:42 - only the server can write or you can
26:44 - make it so the server and the owner can
26:46 - write so other clients cannot write to
26:48 - the network variables of other clients
26:50 - only their own and of course the server
26:52 - can write to anything so let's go with
26:54 - this one let's go with owner so on this
26:56 - network variable everyone can read but
26:58 - only the owner and the server can write
27:00 - to it and since I'm here on our code
27:02 - we're only getting down here if we are
27:04 - the owner then now we should be able to
27:05 - modify this so let's test so here we are
27:08 - I have a host appear and a client down
27:10 - here so if I go into the host which
27:12 - again hosts to access both a player and
27:14 - a server so on the host if I press the
27:15 - button if I can indeed modify the
27:17 - variable and get synchronized over here
27:19 - on the client and now if also go into
27:21 - client and if I press the button any of
27:23 - now I am indeed having control and being
27:25 - able to write over that Network variable
27:27 - which then gets synchronized over here
27:29 - on the player so the client can generate
27:31 - something the server receives it the
27:32 - server can generate it and the client
27:34 - also receives it so with this you can
27:36 - make the client be able to write on the
27:38 - definitive variable however again like
27:40 - like I said if the client are to write
27:42 - onto the network variable of this other
27:44 - client then it would not work the client
27:46 - can only write on the network variables
27:48 - that this client owns another thing
27:50 - related to Natural variables is you can
27:52 - listen when the value is actually change
27:53 - so instead of reading the value on every
27:55 - update like we're doing here instead of
27:57 - that we can do something different so
27:59 - over here we can go inside the network
28:00 - variable so let's right click and go
28:02 - into definition and over here yep we do
28:04 - see that we have a nice event on value
28:06 - change so we can hook onto this one
28:09 - although I should point out this does
28:11 - not have the event keyword so this is
28:12 - technically just a callback but it still
28:14 - works the same so we can subscribe to
28:16 - this and usually you would do that on an
28:18 - awake but like I said a while ago when
28:20 - working with networked objects you
28:22 - should not be using the wake or start
28:23 - for anything related to networking
28:25 - instead you should always overwrite over
28:28 - here the on network spawn
28:30 - for anything related to networking make
28:32 - sure you do it over here and not on
28:33 - start or awake so let's copy this and
28:36 - overwrite this one so back in our player
28:38 - script let's make this one and set a
28:40 - virtual let's override it
28:42 - and over here you can subscribe just
28:44 - like you would for any event so on the
28:45 - random number let's go into the on
28:48 - Valley change and subscribe to this we
28:50 - can go check out the delegate to see the
28:52 - signature that we must match which is a
28:54 - previous value and the new value so you
28:57 - can make it a function or just make it
28:58 - over here in Lambda so in this case the
29:00 - type is in so the previous value
29:05 - and then for the new value
29:10 - so instead of doing the debug.log on
29:13 - every update let's do it just on this
29:14 - one okay so let's test
29:17 - so here we are and by default you can
29:18 - see that nothing was synchronized
29:20 - because it's synchronized by default
29:21 - value so that on value change does not
29:23 - trigger on start
29:25 - but now if I select over here the host
29:27 - and I press the button and if there you
29:28 - go it generates a random number modifies
29:30 - Network variable and client does receive
29:31 - it and now move it over here on the
29:33 - client and yep that one is receiving
29:34 - every time I press it receives a new one
29:36 - so everything gets synchronized
29:38 - Everything Changes only when I want to
29:39 - change okay so that's great everything
29:41 - is working exactly as intended now so
29:44 - far over here we've just been using a
29:45 - simple int but you can use any of the
29:48 - basic types here so you can use an end a
29:50 - flow table and so on the only limitation
29:53 - is that the type must be a value type if
29:56 - you don't know the difference between
29:57 - value types and reference types go watch
29:59 - my quick video on that topic basically
30:01 - you can use things like int and Float
30:03 - but you cannot use things that are
30:05 - references which can be known so for
30:07 - example over here you cannot use a game
30:09 - object or a transform you cannot use
30:11 - that here because those can be known
30:13 - however one thing you can do is create
30:16 - your own custom type to organize some
30:17 - data you just need to make sure that
30:19 - entire type is also a value type
30:22 - so over here and let's make it so let's
30:23 - make it public make it a struct again it
30:26 - has to be struck cannot be a class it
30:28 - goes back to the same thing so structs
30:29 - are value types whereas classes are
30:31 - reference types
30:32 - so let's make it a struct come with my
30:34 - custom data and let's open it and now
30:37 - inside we can store whatever fields we
30:39 - want so let's say an INT for a simple
30:41 - end let's say we also have a bow for
30:43 - example ball and so on so this is our
30:46 - custom data and now up here instead of
30:48 - using this let's use of this type and
30:50 - then for defense let's create a new
30:52 - default so my custom dyno let's default
30:55 - with an INT of let's say 56 and with a
30:58 - boom let's save true
31:00 - then let's leave it readable for
31:01 - everyone and we'd own a right permission
31:03 - okay so that is working and just down
31:06 - here just swap it out so the end
31:07 - previous value and the end new value and
31:09 - let's print out the new value
31:11 - so here we have the new value and then
31:14 - inside let's access the end and let's
31:15 - also print out the bone
31:20 - all right so that's logging down here
31:21 - for modifying is the same as you would
31:23 - modify anything
31:25 - so you modify the value and in this case
31:27 - we construct our custom data and let's
31:29 - set whatever values you want
31:31 - so let's put a different number and a
31:34 - different volume
31:35 - okay so just like this let's test
31:38 - so here I have both builds let's make
31:40 - this one a host and this one down here
31:41 - makes the client and yep as soon as I do
31:43 - yep here we do see an error they are
31:46 - selling those that our custom data type
31:48 - is not supported by a network variable
31:49 - that is because this is a custom data
31:52 - type that we made and the network
31:53 - manager does not know how to serialize
31:55 - our custom type so for that when working
31:57 - with custom data types we also need to
31:59 - implement the interface I Network
32:01 - serializable so over here let's use the
32:03 - visual studio quick actions to implement
32:05 - the interface and there you go we must
32:07 - implement this function and now we can
32:09 - just easily serialize these fields by
32:10 - accessing the serializer over here on
32:12 - the parameter and just go and call
32:14 - serialize Value and let's zero let's
32:16 - just put ref and for our int and let's
32:19 - also serialize our bone
32:22 - okay so that's it that's all you need to
32:24 - do you've got the custom types here and
32:25 - you are serializing them here so if we
32:27 - test like this so now here let's make
32:30 - this one the host and this one join the
32:31 - client and yep it does work no bugs no
32:34 - errors and I'll press the T key here and
32:36 - if there go with it synchronize did send
32:38 - that one press the D key here and yep
32:40 - the client id1 also synchronized
32:42 - perfectly so our custom data was indeed
32:44 - correctly serialized and sent over the
32:46 - network okay great everything works
32:48 - perfectly now one data type you might
32:50 - want to use would be a string
32:52 - so a public string for a message
32:55 - however over here we do see a warning
32:57 - all the films inside of here must be not
33:00 - nullable so they must all be value types
33:02 - and the issue here is that string is a
33:04 - reference type it's actually a bit more
33:06 - confusing than that because string is a
33:08 - reference type but also sometimes works
33:10 - like a valley type but over here it is
33:12 - used as a reference so we cannot use it
33:14 - just like this however what you can do
33:16 - is use a different type and that type is
33:19 - called fixed string and to find this
33:21 - type let's use the using so using
33:23 - unity.collections
33:25 - and the fixed ring is just the main
33:27 - class so we cannot use this one directly
33:28 - but if we search for fixed string yep
33:31 - here we do see a whole bunch of them
33:32 - basically a bunch of fixed Rings each of
33:34 - them with different sizes so these
33:36 - basically pre-allocate some memory which
33:38 - you can then use to set with some
33:40 - certain data but since it's
33:42 - pre-allocated it means that the screen
33:43 - cannot grow or Shrink so you must make
33:45 - sure to pick the right size and in terms
33:47 - of size one character equals one byte so
33:50 - if you want to send a message that is
33:51 - let's say 50 characters long then you
33:53 - cannot be using this one with 32 bytes
33:55 - that is not enough space so for sending
33:57 - 50 characters you would use for example
33:59 - this one with 128 bytes also the reason
34:01 - why there are two for each of these just
34:03 - because this one is deprecated so you
34:05 - must be using this one that is named
34:06 - bytes so let's use this fix type and if
34:09 - we use this and yep it does work we no
34:11 - longer have any errors then since we add
34:13 - another field we must over here
34:15 - serialize the value as well so let's see
34:16 - realize the message
34:18 - and then for reading and writing this
34:19 - ring it's pretty much the same as all of
34:21 - the others
34:22 - so let's add another log for our strings
34:24 - so the new value in this case is our
34:26 - message and then down here when creating
34:28 - let's add our new message
34:36 - all right so that's it let's test so
34:39 - here let's make a host let's make this
34:40 - one a client they are connected and over
34:42 - here I press CT key and if there go it
34:44 - did send the string message so this one
34:46 - receives it this one sent everything
34:47 - serialized all of it worked everything
34:49 - worked perfectly all right great so
34:52 - these are network variables which is one
34:54 - way you can synchronize some data like I
34:56 - mentioned previously there are many ways
34:57 - synchronize data for example instead of
35:00 - using the built-in Network Transformer
35:01 - that we saw previously you could just
35:02 - use a network variable to synchronize
35:04 - just a vector 3 for the position and
35:06 - then use that to move the transform
35:07 - another way of synchronizing data is
35:10 - using rpcs which are remote procedure
35:12 - calls you have two types you have server
35:15 - rpcs and you have client rpcs these are
35:18 - super easy to make but it can also be a
35:20 - tiny bit confusing how you make them is
35:22 - super simple so you just make a function
35:24 - and one very important thing is the name
35:27 - must end with server RPC so let's call
35:29 - it test server RPC then to make this a
35:32 - server RPC we just need to add the
35:34 - attribute server RPC by the way this
35:36 - attribute also has some optional
35:38 - parameters related to ownership but for
35:40 - now let's just use the basic default
35:42 - attribute now like I said the name must
35:44 - end with server RPC
35:46 - if we just add the attribute and we do
35:49 - not add that over here in Visual Studio
35:51 - nothing happens so there's no error
35:53 - however here in unity we do see an error
35:55 - so the server RPC method must end with
35:58 - server RPC so you absolutely must follow
36:00 - this naming Rule and the reason for why
36:03 - this wrong exists is so your code can be
36:05 - as clear as possible
36:07 - rpcs can be tricky in terms of where
36:09 - they execute so by forcing you to write
36:11 - the name correctly that really helps
36:12 - with that confusion and the confusion
36:14 - that I'm talking about has to do with
36:16 - where this code is run for example let's
36:18 - call this function so over here in our
36:20 - testing key instead of modifying our
36:21 - Network variable let's just comment this
36:23 - out and let's call our test RPC
36:27 - so that's it we just call this function
36:29 - and then over here let's do a simple log
36:31 - so debug download
36:33 - let's log test server RPC and let's also
36:37 - unlock this client owner ID okay that's
36:40 - it let's do a quick test so as usual
36:42 - I've got the host appear in the client
36:44 - down here if I go into the host and I
36:46 - press the button and yep it does work it
36:48 - does examine what you expect so it runs
36:49 - that function over here on the host okay
36:51 - right however now if I go into the
36:54 - client and on the client I press that
36:55 - button and look at that it did not run
36:58 - the function over here on the client but
36:59 - it is running over here on the host so
37:01 - as I press the button it runs that on
37:03 - the host as you can see the owner ID is
37:05 - on one whereas if I click here and I go
37:07 - this one is on zero this one is on one
37:09 - so this is the tricky thing I'm running
37:12 - the code calling this function over here
37:13 - on the client but the code is running on
37:15 - a completely different place in a normal
37:17 - scenario if the client were to run this
37:19 - function then very simply this would go
37:20 - inside this would run the log that's how
37:22 - it works in the normal case but that is
37:24 - not the case with rpcs basically when
37:27 - the client calls this function which is
37:28 - marked as a server RPC when that happens
37:31 - in the background the system interrupts
37:32 - the function call so this function does
37:35 - not run on the client at all instead it
37:37 - queues up a message for the server that
37:39 - says hey when you have the chance run
37:40 - this function so in using server rpcs
37:43 - remember that the code does not run on
37:45 - the client at all all of it only runs on
37:47 - the server and also the reason why it
37:49 - ran here as I'm clicking on the host is
37:50 - because again the host works as both a
37:52 - client and the server if I were using a
37:54 - dedicated server architecture with just
37:56 - one server and everything else would be
37:58 - clients and only the server would
37:59 - actually run the test server IPC now one
38:02 - more requirement that I didn't mention a
38:04 - while ago regarding the server RPC over
38:06 - here the name must end with server RPC
38:08 - it must have the attribute yep but then
38:10 - this must also be defined inside a
38:12 - network behavior and it must be attached
38:14 - to a game object with a network object
38:16 - now another optional thing is you can
38:18 - also use some parameters here so it
38:20 - doesn't have to be parameter-less
38:21 - however just like with the network
38:23 - variables that we saw those parameters
38:25 - must be value types they cannot be
38:27 - reference types and again yet another
38:29 - weird exception which is over here you
38:31 - can deduce rings so I can can make a
38:33 - several RPC and over here receive a
38:35 - string
38:36 - let's say this is the message
38:39 - and then I can print out the message
38:42 - then up here when calling it I can pass
38:44 - in whatever message you want
38:47 - so if we test this so here in the host
38:49 - if I press a button and yep it does work
38:51 - it did receive the message and on the
38:53 - client if I press a button yep it's also
38:55 - sending a custom message to the host so
38:57 - if you want to do some kind of
38:58 - communication with strings then chances
39:00 - are you want to use a server RPC instead
39:02 - of using a network variable one more
39:04 - thing related over here with server rpcs
39:06 - is you can use the included parameter
39:09 - type which is the server RPC params we
39:13 - can inspect this time so let's
39:14 - frequently go to definition
39:16 - this one contains just two Fields so a
39:18 - send and you receive and we can inspect
39:19 - these so can inspect the send and this
39:22 - one is commonly empty so this one is
39:23 - pretty much just a placeholder that they
39:25 - might use for something in the future
39:26 - and then for the received params and
39:29 - here this one can receive the parameters
39:30 - for the center client ID so you can just
39:32 - make it like this so let's do the server
39:34 - RPC params
39:36 - and then let's print out the owner
39:38 - client ID of this network object and
39:40 - then let's also go into that one go into
39:42 - the receive parameters and let's grab
39:44 - the sender client ID
39:45 - and then up here let's create just an
39:48 - empty object
39:49 - so just new server RPC Brands so let's
39:52 - test so from the host I press the button
39:55 - and if there you go it doesn't receive
39:56 - with the sender ID of 0 and if I go into
39:59 - the client and I press and yep there you
40:00 - go it does receive that one so that's
40:02 - another way that you can figure out
40:03 - which clients and what message okay so
40:05 - that server rpcs it's a way for you to
40:08 - send some messages from the client to
40:10 - the server if you did not want your game
40:12 - to have client ownership in any way then
40:14 - this is the example which you would use
40:16 - basically the client would use server
40:18 - rpcs to ask the server to move or take
40:20 - some action and then the server itself
40:22 - would update the game State and send it
40:24 - back then we have the other type of RPC
40:26 - which is a client RPC and again we have
40:29 - the same naming rules
40:31 - so here let's make a private void call
40:33 - it test client RPC
40:36 - and we add the attribute the client RPC
40:39 - which again also has some parameters but
40:41 - let's leave it
40:43 - then here on let's just do a debug down
40:45 - log
40:48 - now let's do the same test so let's call
40:49 - this from up here get rid of this
40:52 - okay so it says just like this so here
40:55 - we are and on the host I'm going to
40:57 - press a button and yep look at that the
40:59 - client RPC ran on the host which again
41:01 - works as both a server and a client and
41:04 - the client RPC also ran over here on the
41:07 - client client rpcs are meant to be
41:09 - called from the server which are then
41:10 - run on the clients so the server calls
41:13 - the function and all of the clients all
41:15 - of them run that function but like I
41:17 - said client rpcs are meant to be called
41:19 - from the server which then run on the
41:20 - clients so if I go over here onto my
41:23 - client and in here I try to press and
41:25 - nope it does not work nothing happens
41:27 - the client cannot call a client RPC so I
41:30 - can press here as many times as I want
41:31 - and nope it does not run anything here
41:33 - and does not run anything on the host
41:35 - using this using client rpcs is just how
41:38 - you send a message from the server to
41:39 - the clients just like with several rpcs
41:42 - over here you can also use any
41:43 - parameters you want and also just like
41:46 - server rpcs there's also a default
41:48 - struct so in this case it's a client RPC
41:50 - params
41:51 - and again we can inspect this we can see
41:54 - that we have the same structure so we
41:55 - send and they receive and if we inspect
41:57 - the send over here we see something
41:59 - really interesting we see a list of the
42:01 - target client IDs basically with this we
42:04 - can Define which clients get what
42:06 - message as you saw by default the client
42:08 - RPC ran the code on all of the clients
42:10 - by using this we can Define only some to
42:12 - run on and the other thing to receive
42:14 - over here once again no parameters so
42:16 - just a place on there for possibly
42:18 - adding things in the future
42:20 - so let's try sending something just to
42:22 - one specific client so appear on the
42:24 - screen so let's create a new calendar PC
42:27 - prems and then inside we just want to
42:29 - modify the send
42:30 - so let's create a client RPC send prems
42:33 - and then in here let's create a Target
42:35 - clients ID so let's do a new list of
42:38 - uint and let's send to just client with
42:41 - an ID of one okay so let's see if this
42:43 - does run the client RPC but only on the
42:46 - client with an ID of one so here we are
42:48 - and the host appear is on client ID of 0
42:51 - and the client down here is on client ID
42:53 - of one so if I go into the host and I
42:55 - send the client RPC and if there you go
42:57 - look how it does now run here and it
42:59 - only runs down here so we can Define and
43:02 - only send the client RPC to a specific
43:04 - line that we want so for sending
43:06 - messages from the server to one or more
43:08 - clients you use client rpcs for the next
43:11 - topic let's look into spawning objects
43:13 - so over here let's make a simple prefab
43:16 - just to spawn some object so let's
43:19 - create a new empty game object
43:21 - called the spawn object and then inside
43:24 - let's add a nice visual so let's add
43:26 - just a sphere and lift it up a bit a
43:29 - little bit put this one on y of zero
43:32 - okay so this the object let's just make
43:34 - a nice material and just make it visible
43:36 - so up here let's just make a simple
43:38 - material
43:40 - and drag the material onto this one and
43:43 - just put it in a different color all
43:45 - right so that's it just say nice glowing
43:46 - sphere now let's turn this into a prefab
43:49 - so just drag it over here into our
43:50 - founder okay there's our prefab and we
43:53 - want to spawn this so let's delete it
43:54 - from the scene we don't want it to be
43:55 - there by default now before we can
43:58 - actually spawn this we need to make sure
43:59 - that this object can exist on the
44:01 - network and like I said before there are
44:03 - two things that we need to make that
44:04 - happen so let's go into the prefab and
44:06 - first thing we need is the network
44:07 - object component so let's go into that
44:09 - component let's find the network object
44:12 - let's add this one and secondly every
44:14 - object on the network must be added to
44:16 - the network prefabs list so let's go
44:18 - into our network manager and here we've
44:20 - got the network prefabs let's click on
44:22 - the plus icon and drag the spawn object
44:24 - okay great everything is set up now for
44:27 - spawning it let's go into the player
44:29 - script and up here let's say the field
44:31 - to spawn it so let's set up here a
44:32 - centralized field
44:34 - make it of type transform
44:36 - and let's call the spawned object prefab
44:39 - by the way if you're wondering over here
44:41 - why I'm using transform instead of game
44:42 - object it's because those two types are
44:44 - pretty much interchangeable if you want
44:46 - to see differences go watch my quick
44:47 - video on it okay so I've got the spawn
44:50 - object prefab so let's go down here and
44:52 - when we have our input then let's spawn
44:54 - it just like we would do normally
44:56 - so let's call instantiate let's
44:58 - instantiate this transform just like
45:00 - this okay so let's see what this does
45:03 - so here I am with the hosts up here and
45:05 - if I press this button if there you go
45:06 - it does spawn the object however looking
45:09 - down here on the client we can see the
45:10 - client did not see that spawn object so
45:13 - the object will spawned but only locally
45:15 - on the host it did not spawn across the
45:17 - network so back in the code here in
45:18 - order to spawn it on the network we need
45:20 - to grab the network object component so
45:22 - let's first grab a reference to this one
45:24 - so the spawn object transform
45:27 - so we grab the reference of the spawn
45:28 - object then you go into this one and
45:30 - let's call get component and let's grab
45:32 - the network object
45:34 - so we grab that one and then from that
45:36 - one we can call the function spawn
45:38 - this one takes a parameter for destroy
45:40 - with scene let's set this one to true so
45:43 - that this works pretty much like any
45:44 - other object so if we were to change
45:46 - things this object would be
45:47 - automatically destroyed okay so just
45:49 - like this it should work it should now
45:51 - be spawned on the network so it should
45:52 - show up on the client let's see so here
45:55 - on the host if I press a button if there
45:57 - go it does spawn the host and also
45:58 - spawns on the client alright great
46:00 - however one more thing if down here on
46:03 - the client if I press a button to try to
46:05 - spawn it and nope there you go we've got
46:07 - an error we can only spawn Network
46:09 - objects directly on the server in this
46:12 - case there is no way to allow the client
46:13 - to spawn any network objects so if you
46:16 - wanted to spawn a bullet or something
46:17 - like that then what you would do is you
46:19 - would use a server IPC to tell the
46:21 - server to spawn that object and the
46:23 - server would spawn that object and send
46:24 - it over to the client now since we can't
46:27 - spawn objects let's also despond them
46:29 - and for that it's actually very simple
46:31 - we just destroy them like normal
46:33 - so let's store this reference so let's
46:35 - go up here and let's make a film for
46:38 - this so private and spawn are
46:40 - transformed so we save that reference so
46:42 - then down here let's make sure we don't
46:44 - save on to unlock on variable but we
46:46 - save onto that one okay so we have this
46:48 - one let's do another input
46:50 - so input
46:54 - so I'm going to press the y key and
46:56 - let's just destroy so just like usual
46:58 - just called destroy on this game object
46:59 - okay that's it simple Let's test so here
47:03 - we are and let's spawn it on the host
47:04 - and yep spawns on the host and on the
47:06 - client now press the other button any of
47:08 - their go gets destroyed both on the host
47:10 - as well as on the client okay great so
47:12 - as you can see the spawning is super
47:14 - simple although there are some more
47:16 - options when it comes to the spawning
47:17 - objects just like here on the network
47:19 - object you can correspond you can also
47:21 - call on despawn so we can grab this and
47:25 - instead of Spawn we can call despawn we
47:27 - can use it to despawn then optionally
47:29 - destroy or not destroy the object so
47:32 - this can be use only for some reason you
47:34 - want to remove the object from the
47:35 - network but keep the game object itself
47:37 - alive another thing are the options on
47:39 - the network component so if I go into
47:41 - the spawn object over here we've got the
47:43 - network object and there's this film for
47:45 - don't destroy with owner basically by
47:48 - default if the owner is gone for example
47:49 - if the client is the owner of some Bond
47:51 - prefab and the client disconnects then
47:53 - on the objects on by that point player
47:55 - won't be destroyed and if you don't want
47:57 - that to happen you can just stick this
47:58 - and this way those bullets those objects
48:01 - spawned by that client will still remain
48:03 - existent in the world in the server even
48:05 - after the client has disconnected so
48:07 - this could be useful for some more
48:09 - persistent online games with players
48:10 - jumping in and out Okay so we've already
48:12 - learned quite a lot of things about
48:14 - multiplayer so I've got my basic player
48:16 - I've got the hose and over here I've got
48:18 - a client I can move them all and yep
48:19 - everything does work however so far
48:22 - we've been playing just with a simple
48:23 - capsule for the player now thankfully
48:25 - adding a proper player with some proper
48:27 - animations is actually super easy so
48:30 - here I've got another simple demo except
48:32 - instead of just captions I've got a
48:33 - different prefab and this one does have
48:36 - a proper player character this one of
48:38 - these components these are just based on
48:40 - the official free Unity star assets
48:42 - which I covered in another video which
48:43 - is a simple and third person controller
48:45 - the only change I need to make was on
48:47 - the controller maker of type Network
48:49 - Behavior instead of mono Behavior
48:51 - then down here on the update again make
48:53 - sure to only run that logic if it is the
48:55 - owner then on the prefab I also added
48:57 - the network object component for this
48:59 - object to exist on the network and just
49:01 - like we saw previously I also added the
49:03 - client Network transform and since this
49:05 - one the object rotates I also include
49:06 - the Y rotation and finally on the
49:09 - network object itself over here on the
49:11 - network manager on the network prefabs
49:13 - list I swap that one out for the player
49:14 - prefab so let's do a quick test but
49:16 - before that let's make sure to go into
49:18 - file build settings and let's add this
49:20 - scene and drag it up top so that it's
49:22 - the first one on the bill so there you
49:23 - go I want to test out this scene so
49:25 - let's test okay so up here let's create
49:27 - a host and here there you go there's my
49:29 - player and on here let's connect as a
49:31 - client and if there you go both have
49:33 - been connected and up here on this host
49:35 - if I move the player and if there go it
49:37 - does work it does move and down here on
49:39 - the client if I move it yep it does
49:40 - indeed work however as you can see there
49:43 - are no animations being synchronized so
49:45 - as I move the hose down here it does
49:46 - move the position but nope it is not
49:48 - synchronized now like I said thankfully
49:51 - this is super easy to add
49:52 - let's go inside the player third person
49:55 - control prefab then on this one let's
49:57 - add a component let's go down into
49:59 - netcode and now let's add a network
50:01 - animator now over here the only film it
50:03 - has is just an animated film so let's
50:05 - just drag this animator onto this field
50:07 - and that's it nothing else so now this
50:09 - component will automatically sync up all
50:11 - of the parameters on this animator so if
50:14 - we test like this let's just make sure
50:15 - to save this prefab okay let's make a
50:17 - building test so if I'm here on the host
50:19 - and I start moving any up there you go
50:22 - it does work but you can see that the
50:23 - host is indeed moving and all the
50:25 - animations are being synchronized I can
50:26 - even jump and yep all of them work
50:28 - perfectly okay great
50:31 - however if down here I select the client
50:33 - and now I move the client and nope
50:34 - there's our issue so the client is not
50:36 - being synchronized basically the client
50:39 - is indeed receiving the animations from
50:40 - the host but it is not sending its own
50:42 - animations back into the host again this
50:45 - is the usual issue because by default
50:46 - most things on netcode for game objects
50:48 - are based on server authoritative so the
50:51 - animator will only sync if the server
50:53 - tells it to if I were to play an
50:55 - animation on this character on the
50:56 - server then it would work it would
50:58 - indeed synchronize the animations and
51:00 - just like with the network transform we
51:02 - can also modify this to give the client
51:03 - some Authority the docs here contain the
51:06 - code snippet that we need to use so if
51:08 - you go here onto the network animator
51:09 - and we scroll down and down here we see
51:11 - owner authoritative mode and all we do
51:14 - is we only just need to make a component
51:15 - just like this so something that
51:17 - overrides this Boolean and returns false
51:19 - so here I have exactly that so this
51:21 - owner Network animator and here on the
51:23 - pre-film let's just swap it out so
51:25 - instead of the basic Network animator
51:26 - let's use this one instead let's use the
51:29 - same reference for the same animator
51:30 - let's save the prefab and let's test
51:33 - all right so here we are and if I move
51:35 - the host and if there go it does play
51:37 - exactly perfectly so it works on both
51:39 - and if I go here and I move the client
51:41 - and yep it also works perfectly so I can
51:44 - move I can run I can jump and all the
51:45 - animations they are all being synced
51:47 - perfectly all right awesome so as you
51:50 - can see syncing animations is indeed
51:52 - super simple you really just add one
51:54 - component and all the animator
51:55 - parameters regardless of how many you
51:57 - have all of them get synced correctly
51:59 - now the next topic is the multiplayer
52:01 - tools package this is the one that we
52:03 - already installed in the beginning of
52:05 - this video
52:06 - there are two ways we can view Network
52:08 - stats one is with the profiler so if you
52:10 - go up here into window let's go into
52:12 - analysis and let's open up the profiler
52:14 - here is the profiler and the way this
52:16 - setup is by multiple modules so you've
52:18 - got CPU usage rendering memory and so on
52:20 - and if you scroll all the way down then
52:22 - down here you find the network for game
52:24 - object messages and the objects one
52:26 - really important thing is you want to be
52:28 - looking at these two so these ones that
52:29 - say NGO
52:31 - however there are actually two other
52:32 - profiler modules so if you click over
52:34 - here in order to select them you've got
52:36 - over here these two for Network messages
52:38 - and network operations these are not the
52:40 - ones that you want these two are related
52:42 - to the Legacy unit multiplayer so these
52:44 - are not the ones you want to use you
52:45 - want these ones on here the NGO so just
52:48 - with this we can try playing the game
52:49 - and see so here I've got my builds let's
52:52 - make this one the host and this one
52:54 - connect as declined and now we can view
52:56 - over here and we can click on each
52:58 - individual frame so we can click and see
52:59 - over here we are sending something to
53:01 - client one sending a server RPC message
53:03 - Network variable and so on so we can see
53:05 - how many bytes so sending 60 bytes and
53:07 - so on and if I move around yep you can
53:10 - see all the messages and you can inspect
53:11 - them and see everything that is being
53:13 - sent so this one is sending some
53:14 - parameters from the owner Network
53:16 - animator you can see the messages on the
53:18 - client the server and so on so lots of
53:19 - things over here you can play around
53:21 - with so this is one way you can view
53:23 - some data related to networking so both
53:25 - on the client and on the server so
53:27 - receive and send and so on so you can
53:28 - see a bunch of stuff here
53:30 - and there's another useful tool encoded
53:32 - in this multiplayer tools that one is
53:34 - not on the profiler but rather than
53:36 - let's create an empty game object so a
53:37 - new empty game object
53:39 - call this the runtime stats monitor
53:42 - and then let's add a component and let's
53:44 - search for runtime it's this one runtime
53:46 - net stats monitor so let's add this and
53:49 - over here you see a whole bunch of
53:50 - settings however if you look at the
53:52 - object then nothing seems to be
53:53 - happening basically this window gets
53:55 - created dynamically only when the game
53:57 - runs so if I now try running the game
54:00 - and yep over here we do see this window
54:01 - here with both builds we can now see the
54:04 - stats so let's make this one the host
54:05 - and this one the client and up over
54:07 - there we do see some stats so we see the
54:09 - round trip time to server this is how
54:11 - much time a packet takes to get to the
54:13 - server and get back now since we are
54:16 - making this in localhost I want to sing
54:17 - zero if we were playing the game through
54:20 - the internet maybe connect to the UNT
54:21 - really we would see something here then
54:23 - we also see the total number of bytes
54:25 - sent and received so this is super
54:28 - useful for analyzing just how much
54:29 - bandwidth you're using so over here for
54:31 - all of the network parameters all of the
54:34 - objects all the things that we're
54:35 - transforming here some of that data is
54:37 - around 400 bytes per second and now if I
54:40 - start moving we do see quite a bit more
54:42 - data being transformed so all of that
54:44 - being sent and we can see all the ones
54:46 - being sent and if I move this one we can
54:48 - see all the ones being sent and received
54:50 - like I said this is super useful for
54:52 - analyzing just how much bandwidth your
54:53 - game is using then we also see the
54:56 - number of packets both sent and received
54:58 - and then down here the number of rpcs
55:00 - both sent and received so these signals
55:03 - are very useful for analyzing how your
55:05 - game is performing so if you're sending
55:07 - way too much data you're going to be
55:08 - able to easily sit in here and if you're
55:10 - sending just custom data you can verify
55:12 - that it is only sending the exactly the
55:14 - things that you want now let's learn
55:16 - more specifically about Connections so
55:18 - if we go into our network manager object
55:20 - down here you can see that we're using
55:22 - DNT transfer that we set up in the
55:24 - beginning of this video so this is what
55:25 - actually handles sending and receiving
55:27 - all the packets so it's on this
55:29 - component down here on the connection
55:30 - data this is where you set to connect
55:32 - directly to an IP on a certain Port you
55:35 - can use whatever port number you want as
55:37 - long as nothing else is using that port
55:38 - and by default as you can see the IP is
55:40 - connecting to
55:42 - 127.0.0.1 this is the default localhost
55:45 - address this IP always refers to the
55:48 - unlockable machine that the game is
55:49 - running on so if I were to make a build
55:51 - just like this and I tried connecting
55:52 - the client from another PC it would not
55:54 - work work because that other PC would be
55:56 - trying to connect to itself and not to
55:58 - this PC so in order to make an online
56:00 - connection it is very simple you just
56:02 - need to find your local IP and set it
56:04 - here so in my case on my PC my local IP
56:07 - is 192.168.1.8
56:10 - so if I put this that's all I need to
56:12 - change so now if I make a bill just like
56:14 - this so here I've got my bill now I'm
56:16 - just going to copy this onto my laptop
56:18 - which is also connected to the same
56:19 - local layering Network so here I've got
56:21 - my build and on this one let's make it a
56:23 - host and now on my laptop I'm going to
56:25 - click the button to make a client and
56:27 - click and if there go the client at
56:29 - connect so over here on this PC yep I've
56:31 - got my host and on my laptop yep I've
56:34 - got the other client so I can move both
56:35 - of them and Yep they're both fully
56:37 - working so with this I have a connection
56:39 - between two PCS both on the same local
56:41 - area network as you can see making
56:43 - online connection really is that simple
56:44 - however when it comes to connecting
56:47 - online it is a much tougher problem you
56:49 - can attempt to do the same thing so go
56:51 - into the network manager and down here
56:53 - instead of using the internal IP you can
56:54 - use the external IP however in doing
56:56 - that there are many things that can go
56:58 - wrong and the reason for that basically
56:59 - has to do with net or network address
57:01 - translation basically routers have
57:03 - firewalls and they usually are
57:05 - pre-stricked about blocking any
57:06 - seemingly unwanted traffic so if I just
57:09 - put my external IP here that is really
57:10 - all I need to do on DNT signed however
57:13 - if then someone tried to connect through
57:14 - the build it would likely fail that is
57:17 - because by default my router would
57:18 - receive a connection on this port and my
57:21 - router would not know what to do with
57:22 - that connection so it would probably
57:23 - just block it I have both this PC and my
57:26 - laptop on the same local network so my
57:28 - router would not know which of those PCS
57:31 - should receive this incoming connection
57:32 - Nat or network address translation that
57:35 - is connecting from an external IP onto
57:37 - an internal IP so in order for an
57:40 - external connection like this one to
57:41 - work then basically you need to ask the
57:43 - player to go to their router and set up
57:44 - port forwarding they basically need to
57:46 - tell the router that when they get a
57:48 - connection on a certain port that
57:49 - connection on that Port should go to one
57:51 - specific machine on the local area
57:53 - network that is what you need to know in
57:54 - order to make sure that an outside
57:55 - connection doesn't need to go through
57:57 - the router and go into the right PC now
57:59 - as you might imagine asking players to
58:01 - manually hand on port forwarding is not
58:03 - a very good thing players do not want
58:04 - the hassle of dealing with all of that
58:06 - so you have a bunch of alternatives to
58:08 - handle this problem there's a real nice
58:10 - page on docs here if you go into
58:12 - Concepts and FAQs and then over here
58:14 - into a listing server and host
58:15 - architecture down here you see all of
58:18 - the various options that you have so the
58:20 - first option is port forwarding so just
58:21 - like I mentioned the users need to
58:23 - manually open ports on their router in
58:25 - order to forward the packets to the
58:27 - right PC that can be a problem since
58:29 - users might not have the technical
58:30 - knowledge needed to do that or they
58:32 - might simply just not have access to the
58:34 - router another option is using Nat punch
58:37 - through so this is basically a technique
58:39 - to try to handle on port forwarding
58:40 - automatically it basically tries to open
58:42 - a connection between two IPS on a
58:44 - certain port and if the connection does
58:46 - get open then the router essentially
58:48 - automatically handles support for
58:49 - recording if you can force a connection
58:51 - to go through one way then it won't
58:53 - automatically open the other way but as
58:55 - to whether this approach works or not
58:56 - really depends on the technique used
58:58 - over here you can see a whole bunch of
59:00 - links for a bunch of techniques and it's
59:02 - also going to depend on the router in
59:04 - question so maybe it won't work or maybe
59:06 - it won't work these techniques here are
59:08 - pretty complex so I might cover them in
59:10 - a separate video first I need to do a
59:11 - bunch of research and then we've got the
59:13 - third option over here the relay server
59:15 - this is how you can basically have a
59:17 - third party which is a server somewhere
59:19 - on the internet that all of the clients
59:21 - can access to
59:22 - since the server is on the open internet
59:24 - then everyone can automatically connect
59:26 - to it so that means that this one always
59:28 - works however of course by adding that
59:30 - third party into the connection you end
59:32 - up with quite a bit more latency since
59:34 - the packet needs to go let's say from
59:35 - the host to the relay and then back to
59:37 - the client and then we have the final
59:39 - option of all which is pretty simple
59:40 - first you try to do some Nat punch
59:42 - through if that works in great if not
59:44 - then you fall back into the brainly so
59:46 - this is the best option of all if Nat
59:48 - puncher works then you have a direct
59:49 - connection so everything works perfectly
59:51 - but if that fails then you can fall back
59:53 - into the relay which always works this
59:55 - way you always get a connection and you
59:57 - also avoid using the relay whenever
59:58 - possible so with all that said the
60:00 - entity has an official relay tool as
60:02 - part of their Unity gaming Services if
60:04 - you don't know about TNT gaming services
60:06 - this is their brand with tons of game
60:08 - related Services there's about 20 tools
60:10 - I made a video doing a quick overview on
60:12 - all of those so really is the efficient
60:14 - way to handle that and here I wanted to
60:16 - include a guide on how to use enti relay
60:18 - but that requires quite a bit of
60:19 - explanation and the video is already
60:21 - super long so I'm going to include that
60:22 - in a future video alongside two other
60:24 - things which is Lobby and authentication
60:26 - so I'm going to make a separate video on
60:28 - how to get all of that working basically
60:30 - it requires using Unity authentication
60:32 - then you need to ask the relay in order
60:34 - to reserve a server with a certain
60:36 - amount of player slots then when the
60:38 - service is reserved you get a string ID
60:40 - which you can then use on the client to
60:41 - connect to the relay or join a Lobby you
60:43 - can check out documentation over here
60:44 - for the relay in order to learn how it
60:46 - all works so if you want to edit
60:47 - yourself before I make that video or if
60:49 - you're watching this in the future then
60:51 - check the link in the description
60:52 - alright so that's quite a lot of info
60:54 - about netcode for game objects with all
60:56 - that you'll learn here you can already
60:57 - get started making multiplayer games but
61:00 - at the same time this is a massive topic
61:01 - and there's much more to learn so before
61:03 - I end this video let me quickly mention
61:04 - a bunch more features and resources for
61:06 - you to dive further into
61:08 - one interesting thing is connection
61:10 - approval so by default as you saw
61:12 - whenever a client connects then the host
61:13 - simply accepted but let's say you want
61:16 - to limit the number of players well you
61:17 - can use the connection approval in order
61:18 - to get a connection and decide whether
61:20 - you want to approve or disapprove that
61:22 - connection another interesting concept
61:24 - is object visibility this is how you can
61:26 - Define if an object is visible so if it
61:29 - should be receiving some data or not if
61:31 - you use this correctly and you've got a
61:32 - massive game with a huge world that you
61:34 - can really cut down on unnecessary
61:36 - bandwidth then you also have Network
61:38 - object parenting so if you want to
61:40 - change the parent and runtime then you
61:42 - need to do this in a very specific way
61:44 - there is session management so this is
61:46 - how you can handle when a player drops
61:48 - out of the game and then reconnects and
61:49 - you give it the exact same point ID in
61:51 - order to continue from the same data if
61:53 - you're spawning tons of options and
61:54 - definitely make sure you look into
61:55 - object pulling one potentially very
61:58 - useful tool is called parallel sync this
62:00 - is a unofficial tool so it's not made
62:02 - directly by unity what it does is pretty
62:04 - much duplicates your Unity editor
62:06 - instance so you don't need to constantly
62:08 - make a build just like I was doing for
62:09 - all this video you can get it on GitHub
62:11 - so it's all open source another testing
62:14 - thing is on the transport layer you can
62:16 - simulate packet loss over here on the NT
62:18 - transport down here on the debug
62:20 - simulator you can add a DNA in
62:22 - microseconds Jitter and a certain drop
62:24 - rate this is definitely necessary to
62:25 - make sure that your game doesn't break
62:27 - if the player is lagging so you don't
62:28 - have any race conditions or anything now
62:30 - like I said many times you have the
62:32 - option to go with server authoritative
62:34 - or if you want to also give the client
62:36 - some ownership depending on your game
62:38 - that is a possible thing but also make
62:40 - sure that you know about the potential
62:42 - issues so here I made a post in the
62:43 - forms and Chris gave a great reply with
62:46 - a ton of potential issues whether these
62:47 - are a problem or not really depends on
62:49 - the game you're making also now that
62:51 - you've seen this video and you know the
62:52 - basics then you can go ahead and dive
62:54 - deep into Unity samples the most complex
62:56 - one is boss room it's a really awesome
62:58 - sample and by now you should be able to
63:00 - understand everything in that code base
63:02 - and related to multiplayer are the
63:04 - various anti-gaming Services tools again
63:06 - I'm going to cover a bunch of these in a
63:07 - future video so basically we've got the
63:09 - lobby to create various lobbies for your
63:10 - players to join then you've got the
63:12 - relay which is how you handle the
63:14 - connections you've got Matchmaker in
63:16 - order to use some logic to match players
63:17 - with one another and you've got
63:19 - multiplayer which is how you can handle
63:20 - dedicated game servers and of course all
63:22 - of it integrates very well with netcode
63:24 - for game objects alright so that's the
63:26 - video now you know how to use netcode
63:28 - for game objects a lot of people request
63:30 - this topic so I'm happy I was finally
63:31 - able to cover it now that it reached 1.0
63:33 - this video Took a ton of work to make so
63:36 - I really hope it helped you if you liked
63:38 - it please hit the like button it really
63:39 - helps and maybe consider getting one of
63:41 - my courses My ultimate TNT overview
63:43 - course is found with excellent info that
63:45 - is useful for pretty much anyone using
63:46 - ENT alright hope that's useful check out
63:49 - these videos to learn some more thanks
63:51 - to these awesome patreon supporters for
63:53 - making these videos possible thank you
63:55 - for watching and I'll see you next time
64:01 - [Music]