00:00 - hello and welcome I'm your code monkey
00:01 - and here let's do a deep dive on one of
00:04 - unity's official multiplayer samples the
00:06 - galactic kittens game this is a very
00:09 - simple 2D Co-op multiplayer game that
00:11 - works great as a learning project for
00:13 - understanding how to make multiplayer
00:14 - games using unity's official multiplier
00:16 - solution called netcode for game objects
00:18 - of the source code is available so you
00:20 - can download it and pick it apart to
00:22 - understand exactly how it works if
00:24 - you've seen my net code for game objects
00:25 - video you shouldn't be able to easily
00:26 - understand how this project works this
00:28 - project is intended to be as simple as
00:30 - possible it is meant to be a Bare Bones
00:32 - multiplayer sample for something more
00:34 - complex afterwards definitely go take a
00:36 - look at the much more advanced simple
00:37 - Kong boss room that one builds upon this
00:40 - base and includes tons of optimizations
00:42 - that you definitely must learn to make a
00:44 - good multiplayer game the reason why I
00:45 - researched this official project is
00:47 - because I'm currently working on my
00:48 - upcoming free multiplayer course I'm
00:50 - hard to work on it and hopefully should
00:52 - be out within the next few weeks so if
00:54 - you're looking for a guide path stay
00:55 - tuned for that and go watch the free
00:56 - single player course to prepare for it
00:58 - also as the unity they officially
01:00 - sponsored this video so if you want to
01:02 - learn more about this Mo project then
01:04 - check the link in the description to
01:05 - download it and inspect it for yourself
01:06 - and if you want to make multiplayer
01:09 - games then Unity also has tons of useful
01:10 - tools in their Unity gaming Services
01:12 - brand so also check that out with the
01:14 - other Link in the description okay so
01:16 - first let's do a quick look and play
01:18 - through the game and then let's open up
01:20 - the project and inspect how everything
01:21 - works so we can learn how we can build
01:23 - multiplayer games
01:25 - now if you download the projects to try
01:27 - it out there is one very important thing
01:28 - with how the game is set up basically on
01:30 - all the scenes there is one scene called
01:31 - bootstrap this scene starts up all the
01:34 - necessary objects so when testing it out
01:36 - for yourself make sure you go onto this
01:38 - scene before ending play otherwise you
01:39 - might see some errors so here in the
01:41 - scene let's hit a play and try out the
01:43 - game alright so here's the game gonna
01:45 - like the kittens and right away we have
01:46 - a nice scene waiting for input to start
01:48 - so I'm going to click with the mouse
01:49 - there you go we've got a very basic main
01:52 - menu so we can host which is to create a
01:54 - host for the multiplier we can join
01:56 - which is we can join as a client to
01:57 - connect to a host or just quit the game
02:00 - okay so let's go ahead and join as a
02:02 - host and right away we go into a nice
02:04 - character select scene so here as you
02:06 - can see this game supports up to four
02:08 - players and each player can use a
02:10 - different type of spaceship so by
02:12 - pressing a or D as we can see the
02:13 - controls down here by pressing that I
02:15 - can swap out which spaceship which
02:17 - character I want to use so let's select
02:19 - one let's go with cat okay so here I've
02:21 - got another build so on the main one I
02:22 - made as a host on this one I can join
02:24 - and if there go it joins connects the
02:26 - brand new player and sets a new
02:28 - character so now again on this one I can
02:30 - also modify my character and yep it
02:32 - synchronizes perfectly over there with
02:33 - the host so I can change whatever
02:34 - character I want so I can wait for some
02:37 - more players to join or I can go ahead
02:38 - press on ready and there you go now this
02:41 - character is set is ready but the other
02:42 - one is still waiting so the game has
02:44 - some logic waiting for all players to be
02:45 - running so as soon as I press ready on
02:47 - this one there you go it starts the
02:48 - timer and both players load and they
02:50 - both load into the control scene and
02:52 - they both wait a bit so the players can
02:54 - see the controls and once again they
02:55 - both load they both synchronize and here
02:57 - it is the main game scene so I've got a
02:59 - bunch of controls and now I'm playing
03:01 - solo so I have to kind of control both
03:03 - at the same time so as you can see I can
03:05 - play with a client down here I can fire
03:07 - a bunch of bullets or up here I can also
03:09 - fire a bunch of balls
03:11 - okay so there you go as you can see a
03:13 - bunch of enemies are being spawned all
03:14 - of them are being synchronized so all of
03:16 - them are in the exact same position on
03:17 - both scenes I can move around the
03:19 - players anywhere and I can pick up some
03:22 - pickups and with another key I can
03:24 - enable a nice shield and again
03:25 - everything is nicely synchronized so I
03:28 - can play around okay I'm probably going
03:29 - to lose one but okay all right so there
03:32 - you go this player down there was hit so
03:34 - the spaceship has been destroying okay
03:36 - now on this one let me try to make it
03:37 - until the boss fight
03:39 - there you go the boss is coming okay so
03:41 - here is the boss
03:43 - and I just have to shoot it and the boss
03:45 - has various stages and again note how
03:47 - everything is still nice and
03:48 - synchronized
03:50 - so the boss is doing a lot of things and
03:53 - I just gotta take him out
03:58 - and I end up losing so we go into a nice
04:00 - fit menu where we've got a bunch of sets
04:02 - so let's try again
04:04 - so here I am on the second try and here
04:06 - comes the boss again so let's see if I
04:07 - can defeat it also knows how the
04:09 - characters the spaceships they have a
04:11 - different Sprite when moving up or
04:12 - moving down so those Sprites are
04:14 - changing and note how it is indeed being
04:16 - synchronized so everything is working
04:17 - perfectly okay so let's see if this time
04:19 - I can actually defeat the boss
04:21 - and okay just a bunch more shots
04:24 - and just a little bit more
04:26 - and there you go the boss exploding and
04:28 - again note how everything is nice and
04:29 - synchronized and up here we go into a
04:31 - nice Victory scene where we can see the
04:33 - scores enemies destroyed and so on all
04:35 - right great
04:37 - so as you can see it's a simple game but
04:38 - this showcase lots of things that are
04:40 - very useful and very need to learn in
04:42 - order to make multiplayer games okay so
04:44 - that's the game as you can see it's
04:46 - pretty simple which is excellent as in
04:47 - learning project it involves lots of
04:49 - multiplayer topics such as scene loading
04:51 - character selection spawning players
04:53 - firing bullets synchronizing the player
04:55 - enemies and boss
04:57 - handling the win and game oversights and
04:59 - so on so now that we've seen how the
05:01 - game actually works let's inspect to see
05:03 - how all of this is built so for starters
05:05 - over here I'm looking at the project
05:06 - window we can see all of the scenes
05:08 - involved in this game like I said the
05:10 - first one is the bootstrap so this one
05:11 - starts all of the necessary Global
05:13 - objects then after that one we go into
05:15 - the menu so this is the main menu with
05:17 - the main buttons then when we create
05:19 - either a host or join as a client we go
05:21 - into the character selection window over
05:23 - here the players can join and select
05:25 - their character then once all of them go
05:27 - into ready we go into the control scene
05:29 - so this is just a basic window just
05:31 - showing the controls for the players to
05:33 - play and after this one is on screen for
05:35 - a little bit then transitions into the
05:37 - gameplay scene and this is where the
05:39 - game actually happens then through the
05:41 - course of the game either the player
05:42 - wins or losses so either goes into the
05:44 - victory or the defeat scene okay so
05:46 - that's the main way as to how this game
05:48 - is structured so let's inspect the
05:50 - bootstrap scene this one like I said
05:52 - creates all of the global objects needed
05:53 - for the game to work we can see that it
05:55 - has primarily a network manager this one
05:58 - is the main script that you need in
06:00 - order to be able to use netcode for game
06:01 - objects again definitely go watch my net
06:03 - Code 4 game objects video If you haven't
06:05 - seen it yet in there I cover all the
06:07 - required components to make this work so
06:09 - this one has the main network manager
06:11 - and over here has all of the network
06:12 - prefabs also note one important thing
06:15 - which is over here there is no player
06:16 - prefab the reason for this is because
06:18 - the player prefab this one is spawned
06:20 - automatically when someone joins but
06:22 - since we're creating the network manager
06:23 - over here and then when connecting we
06:25 - are going to the character selection
06:26 - scene when we go in there we don't
06:28 - really want to spawn the spaceship right
06:30 - away so that is why in this case we are
06:32 - not using the player prefab in order to
06:34 - automatically spawn any kind of prefab
06:35 - for the player we're going to handle
06:37 - that manually As We join both the
06:39 - character selection scene and the
06:40 - gameplay scene so there's no point
06:42 - prefab then over here all of the various
06:43 - Network prefabs so this is basically the
06:45 - prefab list that needs to be added over
06:47 - here for anything you want to spawn
06:48 - dynamically in the game so if you want
06:51 - the bones to be able to spawn and
06:52 - synchronize and they need to be here on
06:53 - this list then down here for the rest
06:55 - all of it is mostly on default so it's
06:57 - using the entrance password okay great
06:59 - and one very very important thing is
07:01 - over here scene management is enabled so
07:04 - this is how you notice how when the host
07:06 - starts a new scene the client
07:07 - automatically unloads it that is because
07:09 - this one is toggled otherwise you need
07:10 - to handle that manually okay so this one
07:13 - is the network manager pretty basic most
07:14 - of it with defaults then we also have a
07:16 - loading manager visually this one really
07:19 - just has a black screen that's it this
07:21 - one is only used for visually fitting to
07:23 - Black and fitting away we can inspect
07:25 - the script to see what it does here it
07:27 - is and first of all it extends something
07:29 - called a Singleton persistent this is a
07:32 - class that they made for this demo
07:33 - basically just creates a new Singleton
07:35 - so a standard static instance
07:37 - and then just adds don't destroy and
07:39 - load to make sure this one is persistent
07:40 - so it never gets destroyed that way the
07:42 - unloading scene manager there will only
07:44 - ever be one and it won't persist so that
07:46 - is why you start from the bootstrap
07:47 - scene over there it starts the unloading
07:49 - scene manager and then just lives until
07:51 - you quit the game then the other object
07:53 - in this scene is the go to menu this one
07:55 - is a super simple script basically just
07:57 - Waits until the unloading scene manager
07:59 - has been created and when that happens
08:01 - it loads the main menu scene however
08:03 - note how over here it is not using the
08:06 - basic unity scene management instead it
08:08 - is going through this script and if we
08:09 - inspect this here we can see what it's
08:12 - doing so it's starting a CO routine in
08:13 - order to do the fade in effect and so on
08:15 - but then the very important thing is
08:17 - this one takes a parameter for is
08:18 - Network session active basically it's
08:20 - going to do two different types of
08:22 - loading depending on if a network
08:23 - connection has been established or not
08:25 - now we're here in the bootstrap over
08:27 - here we don't have a connection so this
08:29 - one is set to false
08:31 - so then over here when this one runs
08:33 - it's going to go with this one as false
08:35 - so it's going to load the scene locally
08:36 - and this one is going to load the scene
08:38 - as normal so just go and use the unity
08:40 - scene manager and just call load scene
08:42 - but afterwards when the connection is
08:44 - established then instead of using this
08:46 - function it's going to use this function
08:47 - and this one over here note how it does
08:50 - not use the regular scene manager
08:51 - instead it goes through the network
08:52 - manager accesses the scene manager on
08:55 - that network manager and then loads that
08:57 - scene this is important like I mentioned
08:59 - this is why the network manager has
09:00 - scene management enabled this way only
09:03 - the host load scenes and then of the
09:05 - clients all of them will load the target
09:06 - scene automatically
09:08 - because again the network manager has
09:10 - seen management enabled so basically for
09:12 - this bootstrap Scene It just sets up
09:14 - everything locally so there's no
09:15 - connection at all here just as the basic
09:17 - setup and then loads the main menu so
09:19 - let's open up the main menu scene here
09:21 - it is on this one again this scene also
09:23 - has nothing to do with any multiplier
09:25 - everything is still local here it just
09:28 - has this mini controller with this many
09:29 - manager script
09:31 - and over here on this script simply on
09:34 - update just as for a key and if so
09:36 - triggers the transition that transition
09:38 - then shows the regular buttons that we
09:40 - saw the host the join in the quit and
09:42 - down here we can see how that is
09:43 - implemented so we've got our click
09:45 - buttons here so for the host when that
09:47 - happens it goes into the network manager
09:49 - and starts the host right away
09:51 - so again example like are covered in the
09:53 - netcode for game objects video then it
09:55 - plays a sound effect and then
09:56 - constellutes in but again remember how
09:59 - the network scene this one is now going
10:01 - to default to true
10:03 - so when it starts the host when it loads
10:05 - the scene it's going to unload the scene
10:06 - through the network manager and also
10:08 - remember how this has the fade in by
10:10 - default so first it's going to fade in
10:12 - it's going to wait until the unloading
10:14 - fade effect is finished when that
10:15 - finishes then it actually loads and then
10:18 - it fades out so that's how the visuals
10:20 - and logic are connected that's how the
10:22 - host Behavior works and then when
10:24 - clicking join to join as a client
10:27 - for this one it's going to start this Co
10:28 - routine so let's see what this one does
10:30 - and this one is actually interesting
10:32 - it's going to run this function the fade
10:34 - on
10:36 - which we can see what this one is doing
10:37 - so it does another core routine
10:39 - and basically this one does the fade in
10:41 - then waits for one second and then Fades
10:43 - out so this go routine is pretty much
10:45 - just going to play that in Mission so
10:46 - fade in wait fade out and then back in
10:49 - the same join function
10:51 - over here it's going to wait until the
10:53 - load effect is on can load which means
10:56 - until it has been fully faded in and
10:58 - when that happens then it's going to go
11:00 - into the network manager to start the
11:01 - client
11:02 - again remember how because of that
11:04 - setting on the network manager to handle
11:06 - the scene management because of that
11:08 - when you change the scene on the server
11:09 - the clients will automatically unload
11:11 - that scene so that is why over here and
11:13 - locally it is first fading and only when
11:15 - the fade has finished then it starts the
11:17 - client which in turn won't load the
11:18 - scene right away okay so after that both
11:21 - of those will enter the character
11:22 - selection scene and this scene is very
11:24 - interesting basically I saw a bunch of
11:27 - people commenting on my netcode for game
11:28 - objects video on how to do a multiplayer
11:31 - character select scene so this sample is
11:33 - super useful
11:34 - here we see we have two very important
11:36 - scripts so the character selection
11:38 - manager and the client Connection
11:39 - Manager note how both of these have a
11:42 - network object component again this
11:44 - scene is now correctly connected so the
11:46 - previous two scenes they were only in
11:48 - single player no connection but when we
11:49 - get to this one we do have a connection
11:51 - active so in order to synchronize things
11:53 - we need to make sure we use the network
11:54 - object you must add this component
11:56 - whenever you want to synchronize
11:58 - anything across the network
11:59 - so let's begin by inspecting over here
12:01 - the client Connection Manager now the
12:03 - purpose of this class is to handle the
12:05 - number of clients for a game you
12:07 - probably want to limit the number of
12:08 - players you probably don't want an
12:10 - infinite number of them
12:11 - but right now if you just use our client
12:14 - it will always join the network so if
12:16 - you want to add some kind of limit to
12:17 - how many players can join you need to
12:19 - handle that logic and that one is
12:21 - handled over here on this script if we
12:22 - scroll down we can see there is a can
12:24 - connect function so here it is and the
12:26 - main thing it does is over here just
12:28 - gets the players connected so it goes
12:30 - into the network manager in order to
12:31 - grab the list of connected clients and
12:33 - checks if it is above maximum if so then
12:35 - it says we are full and if not this one
12:37 - isn't allowed to enter now as to how
12:39 - this one is used if you go over here
12:41 - onto the unloading scene manager script
12:43 - this script is listening to a comeback
12:45 - over here on the network manager when
12:47 - the scene loads so it goes into this
12:49 - function and here this one visibly gets
12:51 - triggered when a scene is finished
12:52 - loading and this one is triggered on a
12:54 - per client basis so that is why over
12:56 - here we've got the client ID so this one
12:58 - is triggered when this client has
12:59 - finished loading then as usual for
13:01 - handling the player connections or
13:03 - non-connections we want to run the logic
13:05 - only on the server so if it is not the
13:07 - server we will return we don't do
13:08 - anything and then it's over here so when
13:11 - the client finishes loading that's when
13:13 - we're going to call this function can
13:15 - connect client and over here this
13:16 - function is going to run down that we
13:18 - just saw if the client can connect if so
13:20 - then it's going to return true so the
13:21 - client can connect but if not if for
13:24 - example the game is already full if so
13:27 - then it's going to run this remove
13:28 - client function and this function over
13:30 - here essentially kicksey client out and
13:32 - the way it does that is using a client
13:34 - RPC again make sure you watch my phone
13:36 - video if you have no idea what is a RPC
13:38 - client or server RPC basically this one
13:41 - takes a client RPC params and over here
13:44 - on the params you can Define what
13:45 - clients will receive this RPC so you can
13:48 - send a client RPC to all of the clients
13:50 - or just a specific one so in this one in
13:52 - order to remove the client it receives
13:53 - the client ID then creates a new client
13:56 - RPC Brands and make sure this message
13:58 - only goes to this client and basically
14:00 - tells this client to shut down and then
14:02 - down here on that function really just
14:04 - triggers the shutdown which means the
14:05 - client goes into net network manager and
14:07 - call shutdown and goes back into the
14:09 - main menu so this is both how you can
14:11 - click a player in any way so you can use
14:13 - a client or PC on their end in order to
14:15 - shut down network manager and this is
14:17 - also how you can simply prevent more
14:18 - players from joining a phone game
14:20 - although I should point out that there
14:21 - is actually another method for handling
14:23 - this kind of logic if you look over here
14:25 - on the network manager and we scroll
14:27 - down there is something called
14:28 - connection approval in the docs you can
14:31 - see how this works basically this lets
14:33 - you do pretty much the same thing the
14:35 - only difference is this way the player
14:36 - doesn't even fully connect like the game
14:38 - is doing right now you can accept them
14:40 - or reject them directly during the
14:42 - handshake process okay so that's the
14:44 - main Logic for limiting how many maximum
14:46 - amount of players you can have the other
14:48 - important Logic on this scene is
14:49 - handling the character selection so
14:51 - first let's see how does a player
14:53 - actually join
14:54 - like we saw that is over here on the
14:56 - unloading scene manager so it listens to
14:57 - this comeback from the network manager
14:59 - and then on this callback it has if the
15:02 - client can connect if now then it kicks
15:04 - it but if it can connect then it grows
15:06 - over here and just calls this scene
15:08 - initialization function this function
15:10 - then receives a client ID and then
15:13 - simply spawns a new network object and
15:15 - importantly it also changes the
15:17 - ownership
15:18 - so the server is going to spawn this
15:20 - prefab object but it's going to
15:21 - immediately give ownership of that
15:23 - object to the client now we're going to
15:25 - see what this player prefab contains in
15:27 - a little bit then afterwards down here
15:29 - the way the game handles all the players
15:31 - is basically on this array so we can
15:33 - inspect this type so here it is it is an
15:35 - array of type player connection state
15:38 - and this state is defined up here
15:39 - basically this is the type of data that
15:42 - you want to store for each player
15:44 - so it has a connection state which can
15:45 - be disconnected connected or ready then
15:48 - it has the player name the player client
15:49 - and they reference to the player object
15:51 - so back into the init function here
15:53 - basically just Cycles through all that
15:55 - array
15:56 - and then checks for the first slot that
15:58 - is pretty much empty so the first one
16:00 - that is disconnected and set it as
16:02 - connected
16:03 - it assigns this player name this length
16:06 - ID and this player object again remember
16:08 - how all this logic this is only running
16:10 - on the server not in any client so only
16:12 - the server is setting this data
16:14 - then for sending the data to the clients
16:17 - for that server uses a client RPC so
16:19 - after the server sets its own same then
16:21 - over here it's going to sync that state
16:22 - onto the clients and it's going to use
16:24 - this line RPC so it's going to tell all
16:27 - the clients which one is the brand new
16:28 - client ID which one is the state index
16:30 - the player State and the player object
16:32 - then the clients are going to receive
16:34 - this line there are PC and in doing so
16:36 - they are going to update their own site
16:38 - then over here we see one another very
16:40 - very important thing which is look at
16:43 - the type used over here on the last
16:44 - parameter this one is a network object
16:46 - reference
16:47 - basically up here when the server is
16:49 - calling it it is passing in a network
16:51 - object this is essentially how you can
16:54 - send some references over the connection
16:55 - like I mentioned in the net code for
16:57 - game objects video in a client RPC you
16:59 - can only use value types you cannot use
17:01 - reference types so you could not make a
17:03 - client RPC and pass in the player object
17:05 - directly but you can pass it in as a
17:08 - network object reference so you do that
17:10 - and then on the other side on the
17:11 - clients they receive that reference and
17:14 - they can use the function try get in
17:16 - order to try to get the network object
17:17 - that relates to that reference so it can
17:19 - get that player object and then simply
17:21 - gets the component that you want and
17:23 - assigns it like that
17:24 - so this is how you can pass in
17:26 - references through client rpcs okay so
17:29 - that's in Logic for spawning the player
17:31 - now let's look at the player prefab here
17:33 - on the script we can find the player
17:35 - selected character reference
17:37 - here is the prefab so let's open it and
17:40 - we can see this is a commonly empty
17:41 - prefab so there's no visual it just has
17:44 - obviously a network object so that it
17:45 - can be synchronized and then has this
17:47 - nice script so let's see okay so here
17:49 - this script basically handles the
17:51 - character selection and the way it does
17:53 - that is using a nice synchronized
17:54 - Network variable so as to how all of
17:57 - this logic flows we can see it has a
17:59 - start but remember that before the start
18:02 - we are going to run the on enable so
18:04 - basically as soon as the player respond
18:06 - when that happens it is going to add
18:08 - some listeners to these events so it is
18:09 - going to listen when the value changes
18:11 - on all of these Network variables so
18:13 - this one is going to run hook onto these
18:15 - listeners and then up here then the
18:17 - start is going to run and on the server
18:19 - the server is going to set the player ID
18:22 - so that each instance of this prefab
18:24 - knows which player it belongs to and in
18:26 - doing so in modifying display ID value
18:28 - this is once again going to trigger this
18:30 - on value changed event so it is going to
18:32 - run this function and this function is
18:34 - pretty much just going to update the UI
18:36 - and again remember how when the server
18:38 - modifies a network variable on the
18:39 - changes are propagated to all the
18:41 - clients so that's how this code is going
18:43 - to end up running on every single client
18:45 - so the server sets and then when it does
18:47 - it also sets the character selected so
18:49 - this is the other network variable and
18:51 - this one once again it is going to run
18:53 - the Compact and update the UI okay so
18:55 - that makes the default selection logic
18:57 - then as to how the player itself
18:59 - modifies their own character
19:01 - the inputs are handled over here on the
19:03 - update so you can see that it listens to
19:05 - the key a or D in order to select the
19:07 - character going left or right that is
19:09 - going to trigger this function so let's
19:10 - see and this one the first thing that it
19:12 - does is some basic validation just to
19:14 - make sure this value is within the valid
19:15 - ranges and then basically use the server
19:18 - RPC in order to tell the server the new
19:20 - selected character so the client runs
19:22 - this logic and then tells the server and
19:24 - the server then receives this and
19:25 - basically updates the network variable
19:27 - and in turn the network variable when
19:29 - that updates that is then synchronized
19:30 - to all the clients which then update on
19:32 - their UI so as you can see the selection
19:34 - logic is super simple locally the player
19:37 - changes something then use a server RPC
19:39 - in order to save what a change to and
19:41 - then the server updates a value which
19:42 - and gets the update to all the clients
19:44 - also there's one very important thing
19:46 - here which is over here right after
19:48 - sending the server RPC right after doing
19:51 - that note how this client this local
19:53 - client automatically updates a UI
19:55 - basically if you didn't do this there
19:57 - would be a delay the message would have
19:59 - to get to the server and then be
20:00 - propagated back in to all the clients
20:02 - see if he didn't do this right away if
20:04 - you didn't update the UI on locally if
20:06 - so then it would take a differently
20:07 - something like 15 milliseconds which is
20:09 - definitely noticeable and would make the
20:11 - game feel quite a bit unresponsive so
20:13 - when making multiplayer games this thing
20:15 - right here is one very very important
20:17 - thing usually you want to tell the
20:19 - server what to do but then locally you
20:22 - want to reflect those changes right away
20:23 - you want to update the game State
20:25 - instead of waiting for a reply from the
20:26 - server
20:27 - so this is a very very crucial thing you
20:29 - need to know with regards to multiplayer
20:31 - games in general in order to make them
20:32 - feel good you have to update the UI
20:34 - right away even if technically the
20:36 - server hasn't yet received that message
20:37 - okay so this is really all there is to
20:40 - it with regards to the character
20:41 - selection it really is that simple the
20:43 - clients change their value use a server
20:45 - IPC and then the heads broadcast it to
20:47 - all the clients one more thing in this
20:49 - update is we can see over here the
20:51 - Escape so this is basically a simple and
20:53 - quit option if so then checks if this
20:56 - one is the host so if there are no more
20:57 - players if so then starts a shutdown and
21:00 - for the shutdown once again the same
21:01 - thing that we already saw previously
21:04 - so it sends a client RPC to all the
21:06 - clients in order to shut down and for
21:07 - shutting down religious goes into
21:09 - network manager shuts down and then
21:10 - loads back the main menu so that's it
21:13 - super simple now the final important
21:15 - logic in this scene is the play Ready
21:16 - setting again here on the player
21:18 - character the selection on the update so
21:20 - we test for A and D in order to change
21:21 - the character and then we also test for
21:23 - the space bar and it is a server RPC in
21:25 - order to tell the server that this
21:27 - character is running
21:28 - so it's going to run this function only
21:30 - on the server and then on this function
21:32 - basically it tries to start the game
21:34 - timer so here we can see what it does
21:36 - basically goes through all the players
21:37 - and if at least one of them is not yet
21:39 - ready if so then Samsung doesn't
21:41 - actually start a timer but if all of
21:43 - them are ready then goes to enable a
21:45 - simple timer we can see here the Tamil
21:47 - logic again just a basic photo timer so
21:50 - just counts down by time.com time note
21:52 - how this timer is only running on the
21:54 - server and nothing else so it counts on
21:56 - a timer and when that is done it
21:57 - triggers this start game function and
21:59 - this function over here triggers a
22:00 - client RPC in order to tell all the
22:02 - clients to fade in because again
22:04 - remember how the unloading happens
22:05 - automatically
22:07 - so it tells all the coins to fade in and
22:09 - then the server automatically loads the
22:12 - next scene
22:12 - send the clients to the fade in as soon
22:14 - as the fade in complaints the scene they
22:17 - receive the message to load the next
22:18 - scene then load it and everything
22:19 - completes okay so with that we arrive at
22:22 - the main gameplay scene and over here we
22:24 - have another really interesting thing
22:25 - right away
22:26 - so first phone was the same pattern so
22:28 - it starts over here from the unloading
22:30 - scene manager so there's this comeback
22:33 - he checks if the client can connect the
22:35 - server and so on and over here it's
22:36 - going to run this initialization
22:37 - function and over here here is the very
22:39 - interesting thing that I mentioned which
22:41 - is that if you were to spawn the client
22:43 - prefab right away apparently you could
22:45 - get some desync issues in case some of
22:47 - the other clients took a bit too long to
22:49 - load so the solution over here in this
22:51 - function is actually quite simple
22:52 - basically when the client connects it
22:54 - adds the client to a connected list and
22:56 - then it checks if this client is the
22:58 - last client if not then return and
23:00 - doesn't do anything but if it is the con
23:02 - less client then that's when it actually
23:04 - spawns all the prefabs so if you use the
23:06 - automatic scene management make sure you
23:08 - pay attention to this one potential
23:09 - sneak issue
23:11 - so make sure everyone is connected
23:12 - already before you start spawning things
23:14 - then over here for spawning it's pretty
23:16 - much the same thing that we saw so it
23:17 - spawns a network object and again
23:19 - changes ownership to the client so the
23:21 - clients own their own spaceships for the
23:23 - prefab that one is stored inside a
23:25 - circle object we can see here under data
23:28 - the scriptable objects containing all
23:29 - the data for all of the various types
23:31 - inside each of them has a different
23:33 - prefab variant so let's inspect this
23:35 - prefab and this one very simple as usual
23:38 - it has a network object then for
23:40 - controlling this one is a co-op game so
23:43 - the clients actually have authority
23:44 - which means they move the transform
23:46 - directly and that is synchronized using
23:48 - the client Network transform so it's
23:50 - just like I showed in the netcode for
23:52 - game objects video this client tells the
23:54 - server where it should be and then down
23:56 - here we can see that these objects are
23:58 - also based on a rigid body so it has a
24:00 - rigid body to the component and then
24:02 - down here a network rigid body 2D in
24:04 - order to make sure everything is
24:05 - synchronized although also note how the
24:07 - body type over here is set as kinematic
24:09 - so that means there are no synchronized
24:11 - physics so it has this and then down
24:13 - here the various player control scripts
24:14 - so let's see this movement script here
24:17 - it is this one is pretty basic if we go
24:19 - down here we can see how it actually
24:21 - works so it handles the keyboard input
24:23 - so just doing some basic key testing in
24:25 - order to calculate an input vector then
24:28 - with that input Vector it runs this
24:29 - function so it takes the input vector
24:31 - and simply moves the transform directly
24:33 - then in turn when the transfer moves
24:35 - that one is synchronized to the client
24:36 - Network transform component so very
24:38 - simple example like I covered in the
24:40 - other video but if you remember from the
24:42 - gameplay the ships also change visual
24:44 - when moving up or down
24:45 - so that part is actually synchronized
24:47 - over here on this function so it just
24:49 - checks if the player is moving up or
24:51 - down and slice the Sprite and then once
24:53 - again use a server RPC in order to sell
24:55 - the server what Sprite it shouldn't load
24:56 - so then the server receives that message
24:58 - and simply broadcasts it to all the
25:00 - clients then the clients receive that
25:02 - message
25:03 - and based on a simple enum because again
25:05 - you cannot transfer objects so you
25:08 - cannot send a Sprite through a client
25:09 - RPC so over here it just defines an enum
25:11 - for all of the possible Sprites and then
25:13 - over here simply set them on only
25:14 - clients and that's really it for the
25:16 - movement as you can see it's super
25:17 - simple then let's take a look at this
25:20 - ship control script this one handles
25:22 - various player logic like for example
25:24 - using the shield so you can see it has
25:26 - for the input and then use a server RPC
25:29 - to turn the server to activate the
25:30 - shield and in this case the server is
25:32 - actually the one that is going to
25:33 - validate the inputs so when the player
25:35 - presses it is always going to trigger
25:37 - This Server RPC and then the server
25:39 - checks if this player can use it so if
25:41 - it has enough specials if so then counts
25:43 - them down and this one as you can see is
25:45 - a network variable so it gets
25:46 - automatically synchronized and then use
25:48 - a calendar PC in order to tell all the
25:49 - clients to activate this Shield
25:51 - then next thing this script does is
25:53 - testing for collisions with the power
25:54 - ups so that one is handled over here
25:56 - using a simple regular ontrigger enter
25:58 - 2D so this one is only going to run on
26:01 - the server so if the server detects a
26:03 - hit if it detects a hit with a power up
26:05 - special
26:06 - if so then validates if the player can
26:08 - handle more and if so once again updates
26:10 - the network variable it does that and
26:12 - also importantly down here it actually
26:13 - destroys the object so it runs this
26:16 - simple function which calls d-spawn on
26:18 - the network object and again this logic
26:20 - only runs on the server so that gets rid
26:22 - of the power up next for the health and
26:25 - damage
26:26 - if we scroll up we can see this script
26:28 - once again has a network variable for
26:30 - the health and down here it has a hit
26:32 - function this one once again is only
26:34 - going to run on the server and when this
26:36 - spaceship gets hit it is going to count
26:38 - down the value by the damage which in
26:40 - turn this network variable is going to
26:42 - synchronize you all the clients then it
26:44 - also use a client RPC in order to tell
26:46 - the clients to play some kind of hit
26:48 - effect and then down here on the server
26:50 - it checks if the health is below zero
26:52 - meaning if the spaceship is dined if so
26:55 - then once again just goes and spawns a
26:57 - VFX prefab and then despawns the actual
26:59 - employer spacer finally it calls this
27:01 - function to say that this line has died
27:03 - and then this function is going to run
27:05 - this client there PC again with the
27:07 - client ID as a parameter
27:09 - and this one is essentially going to
27:10 - make sure that only this client is going
27:12 - to enable the death UI animation so as
27:14 - you can see all the helpful logic is
27:16 - also pretty basic now the next grip over
27:18 - here is the one for the player shoot
27:20 - bullet so this one actually spawns
27:22 - bullets and the way this script does
27:24 - that is once again using a nice server
27:25 - RPC so when the player presses space it
27:28 - triggers this function
27:30 - it is going to get a new bullet which
27:31 - once again is going to spawn a network
27:33 - object prefab it does that although note
27:35 - one important thing which is over here
27:37 - this one is spawned as a server object
27:40 - meaning this one is not going to change
27:41 - ownership to the player that fire the
27:43 - bullet all of the bullets are always
27:45 - owned by the server so you can then
27:46 - inspect this pre-file to see how the
27:48 - Bonnet works so over here we can find
27:50 - the bullet prefab reference so let's
27:51 - open this and on this one once again it
27:54 - has a network object although this time
27:56 - it has a regular Network transform as
27:58 - opposed to the client Network transform
28:00 - again that's because all of the bullets
28:02 - are going to be owned by the server
28:04 - then once again it has a rigid body a
28:06 - rig a kinematic rigid body it also has a
28:09 - simple collider and then a bunch of
28:11 - scripts for movement it has this basic
28:13 - generic movement script really just all
28:16 - it does is it's only going to run the
28:17 - logic on the server and just going to
28:19 - modify this transform that's it then the
28:21 - other logic is over here the bullet
28:22 - controller this one has an enum for the
28:25 - bullet owner so basically the bullets
28:27 - are always going to be the same object
28:28 - for both the player and the enemy
28:30 - bullets and on start use a client RPC in
28:33 - order to set the color for this moment
28:35 - again different colors for player or
28:37 - enemy Bots and then down here some basic
28:39 - collection detection it is going to test
28:42 - for hits with something that can be
28:43 - damaged if it's a player then it's going
28:45 - to increase some stats it's going to
28:47 - deal on damage to that object and once
28:49 - again going to despawn this network
28:50 - object so all of it very basic so back
28:53 - here on the gameplay scene let's inspect
28:54 - the enemy spawner script so here it is
28:57 - the enemy's funnel script and over here
28:59 - on update we've got the spawning logic
29:01 - and again this is only going to run on
29:02 - the server basically just has a handle
29:05 - enemy spawning function and over here
29:07 - pretty simple just handles a photo timer
29:09 - if it goes above a certain maximum then
29:11 - gets a next random enemy prefab it
29:13 - spawns a prefab and then the enemy
29:15 - handles itself automatically
29:17 - same thing for the meteor so for the
29:19 - meteor over here same thing pretty much
29:20 - as spawns one then the important one is
29:23 - down here on the boss so once again that
29:25 - starts off as a simple timer so when the
29:27 - timer ends it starts this co-routine and
29:29 - first like we saw it first plays a
29:31 - warning UI so that is handled over here
29:33 - through a client RPC so all the clients
29:35 - receive this message to enable the
29:37 - warning UI then just Waits a little bit
29:39 - tells the clients to stop showing the
29:41 - warning UI and finally spawns the boss
29:43 - again just wanting a regular Network
29:45 - object just spawns it and initialize the
29:47 - behavior the boss has this script this
29:49 - boss controller which is actually a
29:51 - really nice State machine but in terms
29:53 - of multiplayer logic everything is
29:54 - really all the same it goes through the
29:56 - various stages firing various bullets
29:58 - and so on and the final important thing
30:00 - is when the boss dies so you can look
30:02 - over here on these scripts for the
30:03 - various boss dates so let's look at the
30:05 - both Nest state so when the boss dies it
30:08 - is going to spawn some random explosions
30:10 - then it destroys the network object and
30:12 - goes into this pasta feed function and
30:15 - again as usual this function does the
30:16 - same thing for any kind of loading that
30:18 - we've already seen so it does a client
30:20 - RPC to tell the clients to load
30:21 - something and then loads in this case
30:23 - the victory scene and finally over here
30:25 - on the victory scene we just see a bunch
30:26 - of basic stats and that's it that's a
30:28 - game and that's how it works as you can
30:30 - see it's a pretty simple and simple
30:31 - project which works great for learning
30:33 - it has some of the basics for making a
30:35 - multiplayer game you have a character
30:37 - selecting multiple characters a maximum
30:40 - player count you have moving spaceships
30:42 - bullets enemy spawning collisions a boss
30:44 - fight and a bunch more here we saw how
30:46 - it all works under the hood by using
30:48 - lots of network objects a bunch of
30:49 - server and command rpcs some interesting
30:51 - scene loading and a bunch more and you
30:54 - probably also notice some things like
30:55 - for example slight delay on the
30:57 - collisions the bones firing movement and
30:58 - so on Unity themselves have said that
31:00 - this project is intended to be the most
31:02 - basic working demo possible so all of
31:05 - those extra things all those things like
31:06 - movement prediction and some more
31:08 - responsive visuals those would be added
31:10 - on top of this starting base for those
31:12 - more complex things definitely go take a
31:14 - look at the more
31:15 - that one builds upon this and includes
31:18 - tons of optimizations that you
31:19 - definitely must learn to make a good
31:21 - multiplayer game again remember you can
31:23 - inspect this entire project for yourself
31:24 - download it with the link in the
31:25 - description if you haven't yet seen my
31:27 - complete detailed tutorial on netcode
31:29 - for game objects and definitely go watch
31:30 - it now
31:31 - and check out the other link to learn
31:33 - all about Unity gaming Services Unity
31:35 - has tons of tools to really help you
31:37 - bring your multiplayer games to life
31:38 - things like Matchmaker and Lobby relay
31:40 - and more so definitely go ahead and read
31:42 - about those I've also covered Lobby and
31:44 - really in two other dedicated videos and
31:46 - of course like I mentioned the reason
31:47 - why I researched this game was to
31:49 - prepare for my upcoming free multiplayer
31:51 - course and in preparation for that make
31:53 - sure you go watch my full free single
31:54 - player course alright hope that's useful
31:57 - check out these videos to learn some
31:58 - more thanks to these awesome patreon
32:00 - supporters for making these videos
32:02 - possible thank you for watching and I'll
32:04 - see you next time
32:08 - foreign