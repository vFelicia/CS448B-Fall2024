00:00 - hello and welcome i'm your code monkey
00:02 - and here let's build a really nice
00:03 - feature complete camera system we want
00:05 - the ability to move rotate zoom in and
00:08 - out enable edge scrolling and touch drag
00:10 - to pan the camera this is a great and
00:12 - very capable system for just about any
00:14 - game where you want the player to have
00:16 - direct control over the camera you can
00:17 - follow this tutorial and download the
00:19 - final project files we're going to build
00:21 - it in a 3d scene but in the end i'll
00:22 - also quickly show a conversion to make
00:24 - it work in 2d
00:25 - now this video ended up pretty long but
00:27 - it's the only video you need to make a
00:29 - fully complete camera system so if this
00:31 - is something that you need make sure you
00:32 - watch the full video to the end if you
00:34 - prefer a more guided path with step by
00:36 - step lectures then check out my complete
00:38 - courses learn how to make a builder
00:40 - defender game using c-sharp or learn how
00:42 - to make games internally using visual
00:43 - scripting perhaps if you're past the
00:45 - beginner stage and want to make the jump
00:47 - to advanced then check out my turn based
00:48 - strategy course to learn how to manage a
00:50 - more complex project and write some good
00:52 - clean code or learn all about unity with
00:55 - the ultimate unity overview course which
00:57 - contains over 15 lectures each covering
00:59 - a different tool feature of the engine
01:00 - i'm always available in the q and a
01:02 - section answering your questions every
01:03 - single day so check them all out with
01:05 - the link in the description all right so
01:07 - let's build our camera system now of
01:09 - course to do it we are going to be using
01:10 - syn machine if you have never used it i
01:13 - covered it in detail in another video
01:15 - basically syn machine is an excellent
01:16 - unity built-in tool that makes
01:18 - everything related to cameras so much
01:20 - easier we're going to see how we can
01:22 - build a basic camera in just a few
01:23 - seconds as opposed to minutes or hours
01:26 - if we built it all ourselves and for the
01:28 - demo scene that i'm using here this one
01:29 - is from the recently released cynthia
01:31 - ancient empire's pack
01:33 - it's a gorgeous pack with a really
01:34 - awesome roman or greek theme there's a
01:36 - link in the description if you want to
01:38 - get it for yourself all right so let's
01:39 - do it first of all let's create a brand
01:42 - new virtual camera so let's go up into
01:44 - game object then down here find
01:46 - cinemachine and then let's create a
01:47 - standard virtual camera let's rename
01:49 - this the scene machine virtual camera
01:52 - and that's it okay so with this here we
01:54 - already have a nice virtual camera
01:56 - and the way that this system is going to
01:58 - work is we are not going to directly
02:00 - move this object so the virtual camera
02:02 - we're not going to directly move this
02:04 - instead we're going to move another
02:05 - object and then set this virtual camera
02:07 - to follow and look at that object so
02:09 - let's do that let's right click on the
02:10 - hierarchy let's create an empty game
02:12 - object quality camera system let's reset
02:15 - transform to zero zero let's go into the
02:17 - virtual camera and just drag the
02:19 - reference as the follow so if we see on
02:21 - the camera it is currently positioned
02:23 - exactly on top of that object which is
02:24 - on zero zero then let's also add the
02:27 - same object reference as the lookout
02:29 - and now with this actually the camera is
02:30 - already working to test that out let's
02:32 - hit on play
02:34 - so here the game is running and the
02:35 - camera is already working let's just
02:37 - play around with the fields here
02:39 - the goal is for this object the camera
02:40 - system so the target object for that one
02:42 - to be right on the floor and the camera
02:44 - is above it looking down so for that on
02:46 - the virtual camera let's expand the body
02:48 - and over here we've got the phone offset
02:50 - by default it's at 0 0 -10 so we can
02:52 - actually look in the scene view to see
02:53 - what the default looks like
02:55 - so yep there's the object right there
02:57 - the target object and virtual camera is
02:58 - 10 units in the z behind it like i said
03:01 - we want an overhead camera
03:03 - so on the virtual camera let's increase
03:04 - the fall offset by quite a bit let's
03:06 - lift it up on the y so put it something
03:08 - like this
03:09 - then on the z also push it quite a bit
03:11 - more back so a bit lower bit higher
03:14 - something like this
03:15 - okay so just with these basic settings
03:17 - you can already see it working here with
03:19 - the game viewing scene view side by side
03:20 - we can already see the object and if i
03:22 - manually move it yep there you go you
03:23 - can see the camera perfectly follows so
03:25 - this is how we're going to do we're
03:26 - going to move this object and the camera
03:28 - will automatically look at it so let's
03:30 - make a script to do that but before we
03:32 - do before we exit play mode let's make
03:34 - sure to go into the virtual camera and
03:36 - over here make sure we take save during
03:37 - play so we don't lose all the changes
03:39 - that we did so far and also let's push
03:41 - this a bit back so a bit more of a front
03:43 - view okay like this all right so those
03:45 - are the settings that i want make sure
03:46 - save the ring play stick now if we exit
03:48 - play mode if there you go all the
03:50 - changes were saved let's just move the
03:52 - camera system game object moved by
03:54 - default something like this also rotate
03:56 - it we're going to see rotation a bit but
03:58 - just right now it already works all
03:59 - right okay so with this like i said
04:01 - let's make that script so let's right
04:03 - click on the project files create a new
04:04 - c sharp script called the camera system
04:08 - let's select the camera system game
04:09 - object and attach the script alright so
04:12 - here let's just do some basic input
04:14 - logic so let's do it by going into
04:16 - private void update now here let's just
04:18 - add some basic input logic
04:28 - all right so here it is so just testing
04:30 - for wasd
04:31 - now naturally you could easily replace
04:33 - this with new input system which i
04:35 - covered in detail in another video
04:37 - so with this we have a move direction
04:39 - also note how since we're working on a
04:40 - 3d game look at how i define a vector3
04:43 - and when pressing the w or the s key i'm
04:45 - modifying the z not the y
04:48 - that's because we're in 3d so when
04:49 - moving forward we want to go four not up
04:52 - so we have this move direction however
04:54 - here you need to be careful with how you
04:55 - actually move this object you might
04:57 - think that you could just add this move
04:59 - vector straight onto the transform
05:00 - position so just go transform.position
05:03 - plus equals the move direction
05:05 - multiply it by a certain move speed and
05:07 - by time dot all the time to make it
05:09 - frame rate independent so here you could
05:11 - define the move speed
05:13 - and put it at some value so you might
05:15 - think to do this but if we do and let's
05:17 - see what happens
05:18 - so here i am and if i press on w yep it
05:20 - does move forward press on s let's go
05:22 - back press on the go right press on a
05:24 - goes left okay so it does seem like it
05:26 - actually works however if i unmaximize
05:29 - this window now with the scene view side
05:31 - by side let's select the camera system
05:33 - game object and over here let's apply a
05:34 - rotation so let's put it maybe 90
05:37 - degrees so the camera is now rotated and
05:40 - right now if i do the same thing so
05:41 - let's see what happens when i press on w
05:43 - and there you go it moves to the left
05:44 - and now if i press on d yep now it moves
05:47 - forward now s a and so on so this is the
05:50 - issue with this code when i press w i
05:52 - want it to move forward but when i do
05:54 - now it's moving to the left that is
05:55 - because moving into the global forward
05:57 - which in this case with the camera
05:58 - rotation the global forward is still
06:00 - pointing in this direction so when i
06:01 - press on w it still goes there now
06:03 - obviously this is not correct this is
06:05 - not what we want
06:06 - we want to take the rotation of this
06:08 - object into account in order to decide
06:10 - how we should move so back in the code
06:12 - here how we solve this actually pretty
06:14 - simple instead of moving directly by the
06:16 - moved ear what we want to do is to use
06:18 - the super useful transform vectors
06:21 - so let's calculate the final move there
06:23 - so let's actually rename this one so for
06:25 - this one instead of moving let's rename
06:27 - it so the visual studio shortcut this
06:29 - ctrl r
06:30 - let's rename this to the input deer
06:32 - then we calculate the final move there
06:34 - and for this one like i said we're going
06:36 - to use the super useful transform
06:37 - vectors we're going to use transform dot
06:40 - forward so this is the forward vector
06:42 - for this transform so this takes
06:43 - rotation into account so we multiply
06:46 - this one by the input dear.zed
06:49 - and then we add the transform.right
06:51 - again this one is also affected by the
06:53 - rotation of this game object we take
06:55 - this one and we multiply it by the input
06:57 - there dot x
06:58 - so with that now we have the correct
07:00 - move direction based on the object's
07:01 - rotation
07:02 - so we now use this in our movement and
07:05 - if we test it like this
07:06 - here it is with the camera rotated on
07:08 - zero so if i press w s a and d yep sound
07:12 - works perfect now if i rotate the camera
07:14 - so again let's apply a 90 degree
07:16 - rotation now press on w and if there you
07:18 - go does move forward s d and a all right
07:21 - awesome all right so here everything is
07:23 - working correctly we can move in any way
07:25 - we want now at this point we should
07:27 - probably tweak some settings
07:29 - here notice how the camera is indeed
07:31 - moving as we want so move up down right
07:33 - left and so on but since we're also
07:35 - looking at the invisible target in front
07:37 - of here due to the smoothing that we
07:38 - have it creates a bit of an odd result
07:40 - so as i press on w you can see the
07:43 - camera kind of shifts a bit upwards and
07:45 - if i go to the right it kind of has a
07:47 - slight delay
07:48 - now perhaps this is what you want if so
07:50 - then don't bother with the tweaks that
07:52 - i'm going to mention but in most cases
07:54 - you want the camera to pin right away
07:56 - instead of going slightly behind the
07:57 - target thankfully like i said since
07:59 - we're using city machine this is super
08:01 - easy to do so much just like the same
08:03 - machine virtual camera
08:05 - let's expand over here the body and then
08:07 - we've got the x y and z damping if we
08:09 - set all of these back down to zero yep
08:11 - there you go now the camera does move
08:13 - much more snappy
08:15 - again like i said this is personal
08:16 - preference and it kind of depends on
08:17 - what type of game you're trying to make
08:19 - but generally i prefer like this i
08:21 - perform my camera to be much snappier
08:23 - okay so with this the movement is
08:24 - working next up let's in on rotation for
08:27 - this one is also going to be super
08:28 - simple we already saw how we're going to
08:30 - do this since we defined the camera over
08:32 - here with the phone offset with a
08:34 - negative on the z that means the camera
08:36 - is always behind the target object so
08:38 - there's the camera and the target object
08:39 - is down there since the camera is
08:41 - already behind all we need to do is
08:43 - rotate this object so over here on the y
08:45 - rotation all we need to do is play
08:46 - around this and we can easily rotate the
08:48 - camera so here in the code it's super
08:50 - simple again let's do some input
09:00 - so again just using some basic input on
09:02 - q and e in order to rotate so we get the
09:04 - rotate direction
09:06 - then in order to rotate the object we
09:07 - can just modify this transform dot euler
09:10 - angles and let's add it based on new
09:12 - vector3
09:13 - for our 3d camera we only want to rotate
09:16 - around the y axis
09:17 - you can verify what rotation you want if
09:19 - you look over here in scene view
09:21 - so if i rotate around the y yep you can
09:23 - notice that it rotates exactly as we
09:25 - want whereas on the x it does this kind
09:27 - of rotation that's not what we want and
09:29 - the z does this kind of rotation also
09:30 - now what we want so what we want is
09:32 - rotate on the y so over here create new
09:34 - vector 3 0 on the x 0 on the z and let's
09:38 - just put over here on the y and for the
09:40 - y let's use rotate direction multiplied
09:43 - by a certain rotate speed
09:47 - and finally just multiply by time dot
09:50 - delta time
09:51 - all right so that's it some extremely
09:53 - simple logic let's test all right so
09:55 - here we are now for press on e yep there
09:57 - you go rotates press on q and yep it
09:59 - does rotate all right so yep it does
10:01 - work
10:02 - now it's going a bit way too fast so
10:03 - let's actually reduce that and also if
10:05 - you want the opposite so if you want to
10:07 - press e and rotate in the other
10:08 - direction then over here just swap these
10:10 - make this one minus in this one pause
10:12 - but in our case it's working exactly as
10:13 - i wanted let's just lower the rotate
10:15 - speed a bit slower
10:16 - so here press on e any of those rotate
10:18 - press on q and does rotate
10:20 - okay great but we do see the same issue
10:23 - that we saw previously so as i rotate
10:25 - the camera is slightly lagging behind so
10:27 - that does not look very good so once
10:29 - again the solution is the same let's go
10:30 - into the virtual camera now let's expand
10:32 - the aim part and over here we've got the
10:34 - horizontal and vertical damping let's
10:36 - just put both these at zero and now the
10:38 - camera yep perfectly nice and snappy so
10:40 - by moving rotating off it works
10:42 - perfectly okay great now remember make
10:44 - sure you toggle save during play before
10:46 - you exit play mode and here it is the
10:48 - camera working really nice really
10:50 - perfect so we can now move anywhere we
10:52 - can rotate anywhere and everything works
10:54 - right all right so that's it next up
10:56 - let's handle edge scrolling this one is
10:58 - also pretty simple over here in our
11:00 - movement code we are testing for player
11:02 - input
11:03 - but we can also create an input
11:05 - direction based on the mouse position
11:07 - for that we have the input.mouseposition
11:10 - this gives us the mouse coordinates in
11:12 - pixel units so if we do a quick debug
11:15 - download and test this
11:17 - if there it is here in the log i can see
11:19 - and if we look in the stats we can see
11:20 - the size of this window
11:22 - so you can see that i've got this window
11:23 - set up as 1080p so that's because over
11:26 - here i've got full hd selecton and to
11:28 - check out what input.most position
11:30 - returns we can see that if i put the
11:31 - mouse over here on the lower left corner
11:33 - yep it returns pretty much zero zero and
11:36 - if i put over there on the top right
11:37 - corner it returns 1920 by 1080. so
11:40 - input.mouseposition gives me the screen
11:42 - pixel coordinates with this we can just
11:44 - do some basic math all we need is to get
11:46 - the total width of the screen get the
11:48 - total height then check if the mouse is
11:50 - within a certain distance from the left
11:52 - side so for example if it's under 10
11:54 - pixels of the left side then we move to
11:56 - the left if it's within 10 pixels at the
11:58 - right then we move to the right and so
11:59 - on okay so here in the code and let's do
12:01 - that let's first define just an edge
12:03 - strong size so an end edge scroll size
12:07 - maybe 20 units maybe 20 pixels maybe
12:09 - that's enough
12:10 - then we just use some simple logic
12:12 - so if the input.mouseposition.x
12:16 - if this one is under this amount under
12:18 - the edge scroll size then that means the
12:20 - mouse is on the left side
12:22 - if so then let's set the input here dot
12:24 - x to minus one f
12:26 - then we test for the mouse position dot
12:28 - y if it's under that one then we want to
12:30 - move down so that's e z minus one next
12:33 - up we want to test if what's on the
12:34 - right side so for that we're going to
12:36 - test the mouseposition.x
12:39 - and we're going to test if it's past the
12:41 - screen dot width this is how we get the
12:44 - screen width so then when we subtract
12:46 - the edge scroll size so if the mouse is
12:47 - to the right of this point then we want
12:49 - to move on the x by plus 0.1
12:52 - and finally the opposite so this one is
12:54 - on the y let's use the screen dot height
12:58 - and this one we move on the z on plus
13:00 - one
13:06 - all right so that's it really super
13:08 - simple let's test so here we are with
13:10 - the mouse in the middle of the screen
13:11 - now five approaching miles on the left
13:13 - side if there go pens left pins right
13:15 - pans forward and backwards all right
13:18 - awesome everything works now when it
13:20 - comes to edge scrolling some people like
13:22 - it and some people don't so usually you
13:24 - want to add it as an option rather than
13:25 - making it always enabled
13:27 - so for that we can just go up here make
13:29 - a private ball
13:31 - use edge scrolling you can default it to
13:35 - either true or false
13:36 - and if you want you can even make this a
13:38 - serialized film in order to make the
13:39 - default shown in the editor
13:41 - and then over here we just use this
13:43 - logic if this one is true so if use edge
13:46 - scrolling then we do all this and if not
13:48 - then we don't do any of this
13:50 - alright so that's it some super simple
13:52 - logic and obviously you would control
13:54 - this boolean based on the player's
13:55 - options all right now for the final
13:57 - movement method let's add a click and
14:00 - drag
14:01 - so i want to be able to for example
14:02 - place the mouse here use the right mouse
14:04 - button keep it hold down
14:06 - then i move the mouse in this direction
14:08 - and the camera moves in that direction
14:10 - so that's what we want to do okay so
14:12 - here in the code so let's begin by
14:13 - testing out our input like i said i want
14:15 - to use the right mouse button so input
14:17 - dot get mouse button
14:19 - test for the get mouse button down so we
14:21 - want to know when we press it so on the
14:23 - right mouse button so that's on one
14:25 - again of course you could swap this out
14:26 - for touch or any other input i'm just
14:28 - using the mouse just because it's nice
14:30 - and simple so when we do press the mouse
14:32 - let's set a certain volume to true
14:35 - so let's go up here and let's define a
14:37 - private ball call it drag pan move
14:40 - active
14:43 - okay and then down here when we press
14:45 - the mouse button let's set this to true
14:47 - and let's add another one for this one
14:49 - let's use get mouse button up so when we
14:51 - release then we set this back into false
14:54 - okay so we have this nice bully knowing
14:56 - when we should pan or not now with this
14:58 - we're only going to run the drag panel
15:00 - logic while this one is true so after
15:01 - this we do if if this logic is true then
15:04 - we're going to apply the drag pen move
15:06 - okay so in order to pan we need to know
15:08 - the less mouse position so we know how
15:10 - much it moved in the last frame so for
15:12 - that let's store it let's define a
15:14 - private vector 2 since the mouse only
15:16 - has a vector 2 for the last mouse
15:19 - position
15:21 - and then with this one let's go down
15:22 - here as soon as we press let's set it so
15:24 - this one equals input dot mouse position
15:28 - and then down here while it's active so
15:30 - while we still have the last mouse
15:32 - position with the last mouse position
15:34 - with this one we can calculate a vector
15:36 - 2 for the mouse movement delta so this
15:38 - is how much the mouse moves in the last
15:40 - frame
15:41 - so we just take the input dot mouse
15:43 - position exceptionally up here is the
15:46 - mouse position not the mouse on delta so
15:48 - we take this one and we subtract the
15:50 - last mouse position and here for some
15:52 - reason the mouse position actually is a
15:54 - vector 3 not a vector 2 so we can easily
15:57 - just cast this down into a vector 2
15:58 - before doing the math all right so with
16:00 - this we have the mouse movement delta so
16:02 - we handle all of that and then in the
16:04 - end after all the logic then we update
16:05 - it with new value now we can do a debug
16:07 - dialog to see what this shows so we
16:09 - understand how this logic is working
16:11 - so here's the log now if i right click
16:14 - and if i hold still it's zero zero now
16:16 - if i move the mouse right and up so move
16:18 - it yep there you go we've got plus and
16:19 - plus over there and if i right click and
16:21 - i go down and left there you go we've
16:23 - got negative values so this is the
16:25 - amount of pixels that the mouse moved
16:26 - since in last update
16:28 - so with this we can now use this delta
16:30 - in order to directly move the transform
16:32 - for that let's actually put all this
16:34 - logic above before we move the transform
16:37 - we're going to refactor all this code in
16:38 - a bit
16:39 - so we've got this now let's just convert
16:41 - the mouse movement delta into the same
16:43 - as the input direction
16:45 - so here we set the input there dot x
16:47 - equals the mouse movement delta dot x
16:49 - but then we modify the input dear dot z
16:52 - based on the mouse movement delta dot y
16:54 - because over here we're working with a
16:56 - vector 2 but with the input we're using
16:57 - the z okay so that's it except with this
16:59 - it's going to move way too slow
17:02 - so let's define a float for the drag pan
17:04 - speed
17:07 - then we just multiply it by the drag
17:09 - band speed
17:11 - okay so let's test so here we are the
17:13 - camera is static now if i right click
17:15 - and i move the mouse and if there you go
17:16 - it is painting there penning there there
17:18 - and there all right awesome
17:20 - so with this we are directly using the
17:22 - mouse in order to pan the camera
17:23 - anywhere we want we've got that filmed
17:26 - if we feel that this is way too
17:27 - sensitive but yep the logic is working
17:28 - perfectly all right awesome so we
17:30 - already have quite a lot of things
17:32 - working now before we move on to the
17:34 - zoom let's actually refactor our code
17:36 - like i said i want this video to serve
17:38 - as the ultimate camera controller so
17:40 - let's refactor all of this to make the
17:41 - code really nice and easy to read and
17:43 - also really easy to define which
17:45 - features you want to use
17:46 - like perhaps you don't want the drag pan
17:48 - or perhaps you don't want edge scrolling
17:49 - so let's do that so first of all let's
17:51 - make two functions one to handle the
17:53 - movement and want to handle the rotation
17:59 - so for the rotation that's just this
18:01 - code so just copy this and we call this
18:03 - on the update all right
18:05 - and for the movement let's first of all
18:06 - copy all of this so all this in there
18:09 - and on update we call handle camera
18:11 - movement
18:12 - okay so right now everything is done
18:14 - working exam the same as previously but
18:15 - like i said we want to refactor this in
18:17 - order to be able to use or not use edge
18:19 - scrolling same thing for the drag pan
18:21 - so let's actually make separate
18:22 - functions for each of these movement
18:24 - types
18:25 - so let's go down here make another
18:27 - function
18:28 - private void handle camera movement edge
18:30 - scrolling
18:32 - and let's make another one
18:35 - so another private void handle camera
18:37 - movement for this one called drag pan
18:41 - and all we do is just copy all this
18:43 - logic so the use edge scrolling let's
18:45 - copy on to this one
18:47 - and then for the other the drag pen
18:48 - let's copy all of this one
18:50 - and of course we this we need to use the
18:52 - input here since we're reusing it so
18:55 - let's define another input here here and
18:57 - also same thing for this one okay so
18:59 - that works now on these two functions we
19:01 - just need to apply the final movement so
19:03 - that's this logic right here so just
19:04 - copy it apply it to the end here
19:07 - and apply to the end here
19:09 - all right so everything's working no
19:10 - more errors now we can just add all the
19:12 - functions depending on all the features
19:14 - that we want for this
19:18 - and now we can easily either enable or
19:20 - disable these based on boeing so we've
19:21 - got to use edge rolling now for another
19:23 - one use drag pan
19:28 - then let's put the ifs on this one
19:31 - so test for the if in here instead of
19:33 - testing inside this function it's over
19:35 - here let's get rid of this one so that
19:36 - one always runs and then same thing
19:39 - another if on this one
19:44 - all right so that's it now it's super
19:45 - simple all we need to do is modify
19:47 - either these variables and the logic
19:48 - won't work exactly as you want it here
19:50 - is the camera system with all the
19:51 - features enabled so i've got edge
19:53 - scrolling if i go to the sides yep i've
19:55 - got the regular movement i've got the
19:56 - regular rotation and the regular pan
19:58 - movement all right awesome
20:00 - okay so with that the code is working
20:03 - all the logic works
20:04 - now the last thing that we need to
20:05 - handle is the zoom and for that there's
20:08 - actually two ways to zoom a camera
20:10 - one way is to bring the camera in closer
20:13 - so on the virtual camera one way to zoom
20:15 - is to get it closer on the z and also
20:17 - closer on the y so this applies certain
20:20 - zoom
20:21 - another alternative is to simply change
20:22 - the fov so as you lower the fov yep it
20:25 - looks like a zoom so both these
20:26 - approaches work as kind of a zoom
20:28 - they're different so it depends on which
20:29 - one you want let's see how both those
20:31 - work
20:32 - okay so over here let's keep writing
20:34 - some good clean code and call
20:36 - handle camera zoom
20:38 - so let's make this function so down here
20:41 - make a broad void and all the camera
20:43 - zoom all right
20:44 - now here the first thing that we need is
20:46 - some input and for zooming what makes
20:48 - most sense is the mouse chrome wheel so
20:50 - let's handle that we can easily access
20:52 - that with the input dot mouse scroll
20:54 - down
20:55 - now this one as you can see it's a
20:56 - vector 2 because apparently there are
20:58 - some mice that scroll on the x but
21:00 - chances are for a zoom you want to
21:01 - scroll on the y so you've got this one.y
21:04 - if we just do a debug.log on this to see
21:06 - what it does
21:07 - here if i scroll forward yep we do see
21:10 - the value change we do see a plus one
21:12 - and if i scroll the wheel backwards so
21:14 - back to me we do see some negative
21:15 - values okay so these are the values that
21:17 - we can use to run our zoom logic so over
21:20 - here let's try handling the field of
21:21 - view method first now this is actually
21:23 - the more complex part due to how sin
21:25 - machine actually works you might think
21:27 - that you can just access the virtual
21:29 - camera and search for a field of view
21:30 - field so first we need a reference to
21:32 - the virtual camera so let's make one
21:35 - let's make it a serialized field so we
21:36 - can set it in the editor
21:38 - for the syn machine virtual camera and
21:41 - for this we need to add using syn
21:42 - machine so we have this for the same
21:45 - machine virtual camera then here in the
21:47 - editor we can drag the virtual camera
21:49 - reference okay so now here like i said
21:51 - you might think to just go inside this
21:53 - object so let's go inside this one and
21:55 - search for some kind of field of view
21:57 - but nope there's no such thing search
21:59 - for fov nope does not exist looking at
22:01 - the inspector here we need to figure out
22:03 - how to modify this field and thankfully
22:06 - cinemachine has all the source code
22:07 - available so you can just right click on
22:09 - the component and click on edit script
22:11 - and when you do you should be able to
22:13 - see the entire source code for send
22:14 - machine and just in case that doesn't
22:16 - work automatically you can just find it
22:18 - manually so you can go into your project
22:21 - window and over here expand the packages
22:23 - now if this one doesn't work then on the
22:24 - project window on the top right corner
22:26 - there's this little icon with an i if
22:28 - this one is toggled then the packages
22:30 - don't show up but if you untoggle it
22:32 - then all of them show up and here you
22:33 - can find cinemachine then inside you can
22:36 - find runtime and then under behaviors
22:38 - over here you can find the same machine
22:40 - virtual camera so just go ahead and open
22:42 - this
22:43 - here like i said contains all the source
22:45 - code
22:46 - however over here if you search for
22:48 - field of view nope nothing shows up
22:50 - search for fov nope nothing shows up
22:53 - so to get another hint we can again look
22:55 - in the inspector and over here we see
22:56 - that the fov exists inside something
22:58 - called lens so then over here on the
23:00 - script if we search for a lens we do
23:02 - find exactly this an object of type 1
23:05 - settings called m underscore lens
23:07 - then we just need to go inside this lens
23:09 - settings so on the project window we can
23:11 - search for lens settings
23:14 - let's make sure to search in all and
23:15 - here we find the online settings so
23:17 - inside the send machine runtime core
23:19 - line settings and inside this script now
23:21 - if we scroll down yep here we do see the
23:23 - field of view so this method that we
23:25 - just did this is how you can figure out
23:26 - how to find any field in order to modify
23:28 - it through code there's an even more
23:30 - advanced version of this method where
23:32 - you can load all of the packages source
23:33 - code directly into visual studio doing
23:35 - that makes it super easy to find exactly
23:37 - where the field is that you want to
23:38 - change
23:40 - in my ultimate tnt overview course one
23:42 - of the lectures is exactly on this topic
23:44 - how to find any class or any field to
23:46 - modify any of the many tools and
23:48 - features that unity has another example
23:50 - of this is the post-processing effect so
23:52 - how do you modify these various films
23:53 - inside these various effects through
23:55 - code
23:56 - that's one of the things that you can do
23:57 - with this method or the other one that i
23:58 - covered in that lecture also that course
24:00 - teaches you how to use many of the tools
24:02 - and features that unt has so check it
24:04 - out to the link in the description okay
24:06 - so back to our demo here we already know
24:08 - how to get the field of view so now
24:09 - let's do that let's go into the camera
24:11 - system so we've got the send machine
24:12 - virtual camera inside we can access the
24:15 - lens and inside the lens access the
24:16 - field of view now with this we can
24:18 - change it whatever we want so first
24:20 - let's just test it out
24:22 - so let's set it to something like 10 and
24:24 - let's do it when we scroll so if the
24:25 - input dot mouse call delta if the y is
24:28 - bigger than zero so if we scroll upwards
24:31 - then we should be able to see the field
24:32 - of view change let's see
24:34 - so here we are regular zoom nice scroll
24:36 - in and there you go it does zoom in
24:38 - alright awesome okay so all we need now
24:41 - is some logic to use some proper values
24:43 - since the zoom is instant we also need
24:45 - to handle some smoothing logic so here
24:47 - in the code first we need to store a
24:49 - field for the target field of view
24:51 - so a private float
24:53 - call it target field of view
24:56 - we can defound it to sunlight 50.
24:58 - then when we handle the camera zoom when
25:01 - we scroll in the positive for this one
25:03 - let's increase so target field of view
25:04 - increase by a certain amount let's say
25:06 - by maybe five and if we have the
25:09 - opposite so if we scroll the wheel
25:10 - backwards
25:12 - so let's reduce it by five now here you
25:15 - don't need to use delta time because
25:16 - this value the muscle delta this one is
25:18 - based on how often you physically scroll
25:20 - the wheel it is not something that
25:22 - happens on every single frame so you
25:24 - don't need time to download time
25:26 - okay so with this we have our target
25:27 - field of view now with that let's add a
25:29 - clamp to keep it within valid values so
25:32 - target field of view let's do in
25:34 - mathf.clamp
25:35 - let's clamp between a certain minimum
25:37 - and maximum so clamp this value for the
25:40 - minimum and maximum
25:42 - we can define them up here perhaps as a
25:45 - serialized field
25:47 - let's make a float for the field of view
25:50 - max
25:51 - another one for the field of view min
25:54 - let's default the maximum to about 50
25:56 - and the minimum let's say 10.
26:00 - so then with these two down here we just
26:01 - use them so the first one is the min
26:04 - so the field of view min
26:06 - and the field of view max
26:10 - okay so we have the target field of view
26:11 - now just apply it so into the syn
26:13 - machine virtual camera access the lens
26:16 - and let's modify the film the view to
26:18 - the target field of view
26:19 - again right now it sound doesn't have
26:20 - any smoothing but let's just make sure
26:22 - this logic works so here we are and if i
26:24 - scroll backwards yep it zooms in and if
26:27 - i scroll forward yup it zooms out
26:29 - alright great
26:30 - except it actually has the opposite
26:32 - behavior that i want obviously this is
26:33 - personal preference but i find better
26:35 - that if i move the wheel forward i want
26:37 - to zoom in and if i push it back i want
26:39 - to zoom out
26:40 - so very simple just up here just swap
26:42 - these so that's a minus and that's a
26:43 - plus
26:44 - okay so final thing that we need is like
26:46 - you saw it's way too snappy so let's add
26:48 - a nice smoothing and we can do this with
26:50 - a simple lerp i actually cover this in a
26:52 - quick short video it's a super simple
26:54 - way to add smoothing to pretty much
26:56 - anything can be a flow to vector 3 or
26:58 - anything you want so in this case target
27:00 - fill in the view is a float so let's use
27:03 - math f doubler
27:04 - this one takes a current value so the
27:06 - current value won't be the current field
27:08 - of view
27:08 - then the b this is going to be the final
27:10 - one so let's use the target as the
27:12 - target field of view and finally t so
27:14 - time dot dot the time
27:16 - and this is probably way too slow so you
27:18 - float for the zoom speed define it as
27:20 - something
27:22 - and we just multiply
27:24 - so that works that applies the smoothing
27:27 - and we just want it to the final field
27:28 - of view
27:29 - okay so let's test and see if it's nice
27:31 - and smooth
27:32 - so here if i scroll yep there you go
27:34 - nice and smooth going back and back all
27:37 - right great so i can zoom in and out in
27:39 - any way i want all right so here the
27:41 - field of view zoom is working now like i
27:43 - said this is just one of the methods
27:46 - the other one would be to leave the
27:47 - field of view exactly as it is and just
27:49 - move the camera closer
27:51 - so let's handle that second method but
27:53 - let's also keep this one
27:54 - let's rename this function to handle
27:56 - camera zoom this is the field of view
27:58 - method
27:59 - now let's make another one so private
28:00 - void handle camera zoom
28:03 - and for this one let's call it the move
28:05 - forward method
28:08 - okay so now let's go up into our update
28:10 - and over here instead of calling that
28:11 - one let's try out this second method so
28:14 - here we're going to leave the field of
28:15 - view on loan we're not going to touch
28:17 - that one instead what we're going to
28:18 - modify is the follow offset and again
28:21 - we're going to need to use that method
28:23 - because if we try accessing this again
28:25 - and we access the phone nope we just see
28:27 - the follow target we don't see default
28:29 - offset so again we need to look into the
28:31 - package source code to figure out what
28:32 - to change and if you look here into the
28:35 - syn machine virtual camera component on
28:37 - this grip if we look around
28:39 - we can see that the waste and machine
28:41 - works is apparently by some kind of cine
28:43 - machine component base
28:44 - so this system is set up in a way to
28:46 - allow for multiple components we can see
28:49 - we have a function to get all of these
28:50 - machine components and we got another
28:52 - one to get a specifics in machine
28:54 - component and then if we look in the
28:56 - project window under the packages under
28:58 - syn machine under runtime and then
29:00 - components if you look here we can see
29:02 - various interesting class names and if
29:04 - we open one of them we can actually see
29:06 - that the extends in machine component
29:08 - base so these are all of the various
29:09 - components that can be attached to the
29:11 - scene machine virtual camera and if you
29:13 - compare these names with the ones on the
29:14 - virtual camera so over here for example
29:16 - on the body if you scroll you can see
29:19 - we've got do nothing which means no
29:20 - component then we've got third person
29:22 - follow framing transposer regular
29:23 - transposon and so on and if in the
29:25 - scripts yep the same thing third person
29:27 - follow a composer framing transposer and
29:29 - so on
29:30 - so we can see that the body field here
29:32 - is essentially an instance of one of
29:33 - these components so in this case we're
29:35 - using the transposer type so let's open
29:38 - up the syn machine transposer script and
29:40 - over on this one if now we search for
29:42 - follow offset
29:44 - here it is we do find this only field m
29:46 - follow offset and you can see it even
29:48 - defaults to vector3.back times 10
29:50 - meaning it's going to be pulled back
29:52 - minus in the zen so that's exactly what
29:54 - we saw happen so we know this is the one
29:56 - that we want to use so this is what we
29:58 - need to modify let's go back into our
30:00 - regular script and up here let's first
30:02 - get the same machine version on camera
30:04 - then we need to get a syn machine
30:05 - component of that type so let's use that
30:08 - function to get a syn machine component
30:10 - then for the type let's use the syn
30:12 - machine transposer
30:14 - and then from this one now we can modify
30:17 - the m follow offset here it is this one
30:20 - again let's do a quick test so let's set
30:22 - this to some random value so maybe this
30:24 - 10 minus 10
30:26 - and once again let's do this on a scroll
30:31 - okay so let's just test and see if the
30:33 - offset changes so here we are and if i
30:35 - scroll any of there go it does indeed
30:37 - change all right great so this is
30:39 - working we just need to add some
30:40 - external logic
30:42 - so we're going to need to change it
30:43 - based on the scroll wheel and then at
30:45 - the end we actually apply the changes
30:47 - and we're going to want it to be smooth
30:49 - as well so let's go up here and do the
30:51 - same thing that we did
30:52 - so private this is a vector 3
30:55 - for the fall offset
30:59 - okay then with this one down here let's
31:00 - do the same thing so on one of these
31:02 - we're going to move forward on the other
31:04 - one move it back
31:05 - now the question is how do we move it
31:07 - forward for this one we wanted to zoom
31:09 - straight in
31:10 - so we're going to need to calculate a
31:13 - vector 3 for the zoom here
31:15 - and now the way that we calculate this
31:17 - one of the simple ways that we can do is
31:19 - we can just say the current offset
31:21 - so let's set this to the following
31:23 - offset
31:24 - now we just want the direction so we
31:26 - normalize this so with this we have the
31:28 - same direction which will go either
31:30 - forward or backwards so then we can just
31:33 - increase the default offset let's
31:34 - increase it by zoom there
31:37 - and on the other one let's decrease it
31:40 - so minus equals
31:41 - this is on under zero then we need to do
31:44 - a quick test for the minimum and maximum
31:47 - so for that let's go up here let's
31:48 - define another private float
31:51 - for the follow offset min
31:53 - another one for default offset max
31:56 - then we can default this to some values
31:58 - maybe five f and maybe 50 f okay
32:02 - now we can compare those by checking the
32:04 - formula offset
32:06 - check the magnitude
32:08 - so we just do if the magnitude is under
32:10 - the fall offset min
32:13 - if so then we want to set it to some
32:15 - minimum
32:16 - so let's set the font offset equals the
32:18 - zoom direction which again is a
32:19 - normalized value multiplied by the fall
32:21 - offset min okay so this gives us a
32:23 - minimum and then the opposite for the
32:25 - maximum
32:26 - so if it goes past the fall offset max
32:28 - then we set this one
32:30 - so we have this now we just need to make
32:31 - sure that we start off fall offset with
32:33 - something so we can actually start off
32:35 - to the one that it has by default
32:38 - so up here let's make a private void
32:40 - let's make an awake
32:42 - then wait just set the final offset and
32:44 - grab the current one
32:47 - okay so then down here we just need to
32:48 - apply this small offset
32:50 - now the issue of course that this is
32:52 - instant we need to apply some smoothing
32:54 - so let's do the same thing that we did
32:56 - except this time we're working with a
32:57 - vector three so let's use vector three
33:00 - downward and all logic is exactly the
33:02 - same
33:03 - so let's grab the current offset
33:06 - then the target fall offset which is our
33:08 - final offset and finally time time dot
33:09 - delta time
33:11 - and of course you need to multiply it so
33:13 - you float for the zoom speed
33:22 - so we have our alert and then we just
33:24 - assign it
33:26 - so like this
33:29 - okay so let's test so here we are and if
33:32 - i move the scroll wheel if there you go
33:33 - and i zoom in and if i go to the maximum
33:35 - yup can't go further and i zoom out any
33:38 - of them out all right great so it's
33:41 - zooming a bit way too little but logic
33:43 - does work except it's also reverse so
33:45 - let's fix that
33:46 - so here just swap these out so this one
33:48 - is a minus and this one is a plus then
33:51 - for the amount float for the zoom amount
33:54 - let's put it at maybe three f and then
33:57 - the zoom direction we just multiply by
33:59 - this zoom amount
34:02 - okay let's test so here we are and if i
34:04 - zoom in if there you go zoom in and zoom
34:07 - out all right awesome so everything is
34:09 - looking really nice so i can move the
34:11 - camera i can rotate around and here
34:12 - we've got the second zoom method okay so
34:15 - with that done let's actually quickly
34:17 - check out the third zoom method
34:19 - now instead of zooming directly onto the
34:21 - position so this is a direct zoom
34:23 - instead of doing that let's just lower
34:25 - the camera closer to the ground so let's
34:27 - make another zoom method so let's make
34:29 - another function
34:30 - so hand on the camera zoom
34:33 - let's call this the lower y
34:35 - we're going to lower the phono offset on
34:37 - the y
34:38 - and logic here is actually going to be
34:40 - pretty similar to this one so let's copy
34:42 - this
34:43 - except for this one instead of moving
34:45 - according to the zoom direction instead
34:47 - of that what we're going to want to move
34:50 - is the fall offset but only on the y so
34:53 - only on the y that's the only one we
34:54 - want to modify
34:56 - so this one just lower it or increase it
34:58 - by the zoom amount then instead of
34:59 - checking for the magnitude we can just
35:01 - check for the fall offset y
35:04 - so the y equals math.clamp
35:07 - let's clamp the y between a certain
35:10 - minimum and maximum
35:11 - so let's define those up here
35:14 - so let's define the min y
35:17 - let's put it at maybe 10 and then the
35:19 - max y let's put it maybe 50.
35:23 - okay so we've got these two
35:25 - and now down here based on the min y and
35:27 - the max y okay so we clamp that value
35:31 - and then we do the exact same thing so
35:33 - we still use default offset and we did
35:35 - that all right so now let's use this
35:37 - method instead of the other one so over
35:39 - here on our update
35:41 - let's use this method instead of this
35:42 - one okay that's it super simple let's
35:44 - test okay so here we are and if i try
35:47 - zooming in yep there you go now it does
35:48 - this so instead of pushing forward it
35:50 - pretty much just gets the camera closer
35:52 - to the ground so personally i really
35:54 - like this method since it lets you look
35:56 - at objects from a different angle so the
35:58 - other one you always have this view and
36:00 - just getting in closer or further away
36:02 - whereas with this one we can zoom in get
36:04 - a different view of all of our map
36:06 - so personally i really like this method
36:08 - since it gives you a different view but
36:10 - either way here you have three zoom
36:11 - methods so choose whichever one you
36:13 - prefer
36:14 - and with that here is our complete
36:15 - camera system
36:17 - we can move with the keys in the
36:18 - keyboard
36:19 - alternatively we can also move the
36:21 - camera by moving to the edges so we've
36:23 - got edge scrolling enabled yet another
36:25 - method is by clicking and dragging the
36:27 - mouse so we can place the camera
36:29 - anywhere we want and again especially
36:31 - for this method you can easily change
36:32 - this to make it work with the new input
36:34 - system so making this work with touch
36:37 - input would be super simple
36:39 - and then we can also rotate the camera
36:40 - so i can look at anything from any angle
36:43 - and finally i can zoom in using any of
36:45 - three unique methods
36:46 - and over here is the 2d version with all
36:48 - the same features the logic is mostly
36:50 - the same the virtual camera is set up in
36:52 - 2d as is the camera the funnel target is
36:55 - the same and for the zoom there's only
36:57 - one method just changing the camera's
36:59 - orthographic size so that's it and here
37:01 - it is this same system working great in
37:03 - 2d alright so here is a fully featured
37:06 - fully working camera system this is
37:08 - perfect for any game where you want to
37:10 - give the player control over the camera
37:12 - there's a link description to download
37:13 - the project phone so go ahead and use
37:15 - this in your next project there's also a
37:17 - link there for this really awesome asset
37:19 - pack if you want to get it and if you
37:20 - found this video helpful check out my
37:22 - complete courses alright hope that's
37:24 - useful check out these videos to learn
37:26 - some more thanks to these awesome
37:28 - patreon supporters for making these
37:29 - videos possible thank you for watching
37:31 - and i'll see you next time
37:37 - [Music]
37:41 - you