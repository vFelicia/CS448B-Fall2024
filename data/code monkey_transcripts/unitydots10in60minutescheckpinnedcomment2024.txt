00:00 - hello and welcome I'm your code monkey
00:02 - and in this video I'm going to do a nice
00:04 - simple project to check out the current
00:06 - state of unity dots version 1.0 is
00:08 - finally here although still technically
00:10 - in preview it's going to be fully
00:12 - released production ready in the 22 LTS
00:14 - stream which will happen sometime early
00:16 - next year but since version 1.0 is now
00:18 - here and leaving experimental very soon
00:20 - that means the API probably won't change
00:22 - too much until the final production
00:24 - Reddit release so while you probably
00:26 - should not be using this in production
00:27 - just yet it isn't an advanced enough
00:29 - state that you can absolutely start
00:31 - learning it if you're watching this
00:32 - video sometime in the future most of it
00:34 - should still be up to date so here on
00:36 - let's learn the basics of how ECS 1.0
00:39 - works the great news is that if you've
00:41 - played around with ECS just like I did
00:43 - two years ago then nowadays everything
00:45 - is a lot simpler with a lot better tools
00:47 - now I initially wanted this video to be
00:49 - just a pretty quick overview something
00:51 - about 15 minutes long but I found it
00:54 - would be a bit of a disservice to you to
00:55 - simplify things so much just to fit a
00:58 - short length so it would end up being
00:59 - quite a lot more more detail than quite
01:01 - a bit longer than I anticipated if you
01:03 - find the video helpful and you want to
01:04 - help me out you can wish list my game on
01:06 - scene it's called total war on
01:07 - Liberation features lots of interconnect
01:09 - systems and I'll probably be using dots
01:11 - in the funnel game or you can get my
01:13 - complete step-by-step courses like my
01:15 - ultimate TNT overview or my turn-based
01:18 - strategy course which is actually the
01:19 - base for my steam game if you know
01:21 - absolutely nothing about dots you can go
01:23 - watch my quick explainer on the theory
01:25 - behind it that video is still up to date
01:27 - in terms of explaining all the Core
01:28 - Concepts from a high level view as a
01:31 - quick refresher the entities package or
01:33 - ECS stands for entities components and
01:35 - systems entities are basically just an
01:38 - identifier components are where you
01:41 - store the data and finally systems do
01:43 - whatever work you want on that data so
01:46 - here let's build a super simple demo
01:48 - we're going to set things up to have a
01:50 - simple character just spawn and randomly
01:51 - move around doing that involves learning
01:54 - about quite a lot of parts of ECS so we
01:56 - need to create the entity and look into
01:58 - the conversion workflow create a
01:59 - component to start the entire position
02:01 - use the baking system create a system to
02:04 - generate a random position and move it I
02:06 - will also cover how to mix ECS and game
02:08 - objects so this is an excellent simple
02:10 - demo to showcase the Epsilon basics of
02:12 - how ECS works and of course in the end I
02:14 - will showcase the performance comparison
02:16 - between ECS and regular Model Behavior
02:18 - code as well as give you some resources
02:20 - if you want to dive deeper into dots
02:22 - alright so let's begin first we need to
02:24 - install the packages so let's go into
02:26 - the package manager and up here let's
02:28 - click on the plus and let's add a
02:30 - package by name and for name let's go
02:32 - with com.unity DOT entities let's add
02:36 - this one
02:38 - and yep there you go it didn't sound
02:40 - over here the entities package as well
02:42 - as all of the required dependencies so
02:44 - we've got burst we've got mathematics
02:46 - relation and so on now another great
02:48 - package we can add is the graphics
02:49 - package that's what used to be called
02:51 - the hybrid renderer so it's going to add
02:54 - factor by name
02:57 - com.unity.entaties.graphics let's add
02:59 - this one
03:00 - okay so with this we have all the
03:02 - packages we need also important is what
03:04 - it says over here on the documentation
03:05 - the way this version of ECS works is
03:08 - heavily based on code generation so you
03:11 - should be using an ID that supports it
03:12 - like for example Visual Studio 2022
03:14 - which is what I'm using and I also
03:16 - recommend that you modify the domain
03:18 - reload settings this helps the editor be
03:20 - quite a lot faster by not reloading the
03:22 - current domain
03:23 - to change that just go up here into edit
03:25 - then into project settings then on the
03:28 - side let's go into editor and over here
03:30 - let's scroll down until we find over
03:32 - here the interplay mode settings make
03:34 - sure that this one is enabled and make
03:35 - sure these two are unticked so just like
03:38 - this however like it says here and be
03:40 - very wary that using this option means
03:42 - that your static Fields will not
03:44 - automatically reset so keep that in mind
03:46 - you can read the docs to be more
03:48 - familiar with what exactly this option
03:49 - does okay so now let's begin making a
03:51 - simple entity and if you like me use
03:54 - dots two years ago then you're going to
03:55 - be very pleased with how easy it is
03:57 - nowadays how you do it is super simple
03:59 - let's go over into the hierarchy let's
04:01 - right click and let's create a brand new
04:03 - subscene so let's create an empty scene
04:05 - then over here just give it a name like
04:07 - for example entities subscene
04:10 - and if there it is we have a subscene
04:12 - and this little toggle here and lets you
04:13 - enable or disable the subscene and then
04:16 - over here A bunch of options for opening
04:17 - or closing the subscene but right now
04:19 - let's leave it open basically what this
04:21 - does is anything inside the subscene
04:23 - will automatically be converted from
04:24 - game objects into entities so let's add
04:27 - a very simple new game object in that
04:29 - subscene so let's right click on top of
04:30 - it and over here game object let's
04:32 - create just an empty game object okay
04:34 - that's it just a super normal regular
04:36 - game object with this if we hit play we
04:39 - can see the object is over there in the
04:40 - hierarchy and I often look over here on
04:42 - the right on the inspector right now as
04:44 - you can see it's normal so it's
04:45 - showcasing a normal game object with
04:47 - transform everything is perfectly normal
04:48 - however now if we unlock over here on
04:51 - the top right corner we see this little
04:52 - circle icon basically just like this
04:55 - it's currently showing the regular game
04:56 - object inspector and if we click on it
04:59 - it goes into this half mode I'm honestly
05:01 - not entirely sure what exactly this one
05:03 - does it's supposed to be kind of a mixed
05:05 - mode but it doesn't seem to change
05:06 - anything at all and if we click again
05:08 - there's actually a slight bug where
05:10 - sometimes this one does not update but
05:13 - we can easily fix it let's just select
05:14 - another random game object and and then
05:16 - back to selecting that game object and
05:17 - now if we click go into mix click again
05:19 - and yep now this showcases The Entity
05:21 - inspector with this we can see that the
05:23 - game object that we created was
05:25 - automatically converted into an entity
05:26 - so yep that's awesome as you can see
05:29 - this is how easy it is we just created
05:31 - an empty game object a normal game
05:33 - object in the subscene and it
05:34 - automatically converted into an entity
05:36 - with all the required default components
05:38 - like for example over here the transform
05:39 - now let's do something even more special
05:42 - let's add a simple visual so on the game
05:44 - object let's right click on top of it
05:46 - and inside let's create a new 3D object
05:49 - let's make a simple caption let's just
05:51 - lift it up a bit off the ground so
05:53 - something like this and just give it a
05:55 - nice fun visual all right there it is
05:57 - again note how we're using regular game
05:59 - object components so we've got a regular
06:01 - game object with a regular transform a
06:03 - mesh filter and mesh render just like
06:05 - you have in any other game object then
06:07 - by default it comes with a Capstone
06:08 - collider let's just remove this we're
06:10 - not using physics in this demo okay so
06:12 - just with this let's hit on play any of
06:14 - the objects is there now there's also
06:16 - another entities hierarchy so we can go
06:18 - over here into window and go down into
06:21 - entities and let's open up the entities
06:22 - hierarchy and it opens up this window
06:25 - which again also has this nice Circle
06:27 - button so over here we are seeing all of
06:29 - the game objects and we click on it it
06:31 - brings the mix mode click again and now
06:33 - we see all of the entities note how the
06:35 - icons here so this little icon the
06:37 - regular Cube that means a game object
06:38 - whereas this one this hexagon means an
06:40 - entity if we click on this and over here
06:43 - I'm looking the inspector make sure you
06:45 - are in the entities inspector mode and
06:47 - yep we can see this game object and the
06:49 - channel was indeed fully converted into
06:50 - entities so this game object which is
06:53 - apparent as you can see has a child
06:54 - component and inside has a reference to
06:56 - the child again this is an entity
06:58 - reference not a game object reference
06:59 - and if we select the Capstone visual yep
07:02 - over here we see that it has all the
07:03 - components required to actually render
07:05 - an entity okay awesome so it literally
07:08 - is that simple to make an entity and add
07:10 - a visual to it you just make a new
07:12 - subscene a game object inside it
07:14 - optionally add a visual and that that's
07:15 - really it everything is automatically
07:17 - converted this process is much much
07:19 - simpler than the previous method which
07:20 - involved tons of product code to get
07:22 - anything rendered on screen so now that
07:24 - we have our very simple entity the next
07:27 - thing we want to do is just store some
07:28 - data so we do that with components let's
07:31 - make a brand new script so in my scripts
07:33 - folder just right click and create a
07:35 - regular new c-sharp script let's call it
07:37 - just speed
07:38 - and open now here on this script for
07:41 - making a component first of all it needs
07:43 - to be a struct not a class so this one
07:45 - is going to be a construct and secondly
07:47 - it does not extend mono Behavior instead
07:50 - it needs to implement I component data
07:52 - as soon as you can see exists inside of
07:54 - the unity.inties namespace so we'll
07:56 - import that as well alright so that's it
07:58 - this is our very basic component now
08:00 - over here we can add whatever fields we
08:02 - want so for example let's add just a
08:04 - public flow just call it value
08:06 - okay that's it super simple now we want
08:09 - to add this component to our entity and
08:11 - the way we do that in version 1.0 is
08:13 - through the baking system which is a
08:14 - conversion that we just saw since this
08:17 - component does not extend amount of
08:18 - behavior we cannot add it directly to
08:20 - our game object
08:21 - so we need to make a separate amount of
08:23 - behavior which will then be used to
08:24 - convert and create into this speed
08:26 - component first over here let's create a
08:28 - new c-sharp script come with speed
08:30 - authoring by the way adding the
08:32 - authoring suffix is not required but it
08:34 - is a nice convention to follow
08:36 - so let's open this here for this one we
08:39 - are indeed going to leave it as a mono
08:40 - Behavior and then we're just going to
08:42 - essentially add the exact same Fields so
08:44 - let's add a public float value however
08:47 - just like this it won't work just yet
08:49 - the system does not know that this mono
08:51 - Behavior belongs to this speed component
08:53 - right now it doesn't know that
08:55 - connection is supposed to exist so how
08:57 - we make that connection is by making a
08:59 - baker now you can make it in a separate
09:01 - script or we can just add it over here
09:03 - right next to the amount of behavior
09:04 - since these are technically connected it
09:06 - makes sense to place it right here so
09:09 - let's make a public a class let's call
09:11 - it the speed Baker and we're going to
09:14 - extend Baker of type and let's include
09:17 - the type speed authoring
09:19 - and Baker as you can see is inside using
09:21 - unity.entries okay so with this we need
09:24 - to implement the abstract method so
09:26 - let's Implement that one so here it is
09:28 - the bake function
09:30 - and from here we can easily add add
09:32 - components and let's add the component
09:34 - that relates to our authoring component
09:36 - so let's create a new speed the speed
09:38 - component and let's construct it with
09:40 - the value and grab the value from the
09:42 - authoring dot value
09:45 - okay so just like this again we have our
09:48 - regular component so this one has no
09:50 - amount of behavior it's not a class then
09:52 - we have the speed authoring this is mono
09:54 - behavior that we attach to our object
09:56 - and then we've got a baker which
09:58 - essentially grabs a reference over here
10:00 - of our speed authoring component and
10:02 - simply grabs that in order to access the
10:04 - value in order to set the value on the
10:05 - speed component now this is the one part
10:07 - of the system that still feels a bit too
10:09 - needlessly complex
10:11 - there should be some way of automating
10:12 - this if the mono behavior is meant to
10:15 - have the exact same Fields as over here
10:16 - the component from what I read in the
10:18 - forms they are actively working on
10:19 - simplifying this process apparently it
10:21 - just didn't make it onto the 1.0 version
10:23 - okay so with this done if we go back in
10:25 - the editor over here let's select our
10:27 - regular game object and let's attach the
10:29 - speed authoring component and over here
10:31 - we can add whatever value we want now if
10:34 - we hit on playing
10:35 - and let's go into our inspector into
10:37 - entities mode and if we scroll down yep
10:40 - over here we do see our component Tower
10:42 - speed component and the value yep it
10:44 - does have the value that we set all
10:45 - right awesome
10:47 - okay so far so good next let's make a
10:49 - system to move our object and when it
10:51 - comes to systems there are two ways you
10:53 - can make them you can make a class that
10:55 - extends system base or you can make a
10:57 - struct that implements I system
10:59 - essentially system base is meant for
11:01 - managed systems and I system is meant
11:03 - for unmanage so that means that system
11:06 - base cannot use the burst compiler
11:07 - whereas I system can if you're doing
11:10 - some super basic code where you want it
11:12 - to run just on the main thread and
11:13 - maximum performance is not necessary
11:15 - then you can use system base but if you
11:17 - want the absolute Max performance and
11:19 - you should be using I system
11:21 - don't worry I'll showcase both methods
11:22 - for Summers let's use the system base
11:25 - so let's create a brand new c-sharp
11:27 - script and for this one let's call it
11:29 - the moving system base
11:32 - now inside instead of a mono behavior
11:34 - let's extend system base inside
11:37 - unity.inthes okay
11:39 - and on this one we need to implement the
11:41 - abstract function the on update so let's
11:43 - do that
11:45 - now just like this if we save and we go
11:47 - back in the editor
11:48 - yep over here we do see a nice error it
11:51 - is telling us that everything that
11:53 - extends system based must be defined
11:54 - with the partial keyword again this is
11:56 - due to how dots 1.0 handles a lot of
11:59 - things based on code generation so we
12:01 - need to make this partial so up here
12:02 - let's make this a public partial class
12:04 - okay just like this we don't have any
12:06 - errors great now here our goal is to
12:09 - move our entity and for that we're going
12:11 - to want to modify the entity position
12:12 - and there are two ways we can do that
12:15 - let's look at the entity as it exists by
12:17 - default also by the way you don't need
12:19 - to head on plane in order to see what
12:21 - entity is converted into if you're just
12:23 - like this with the game not playing you
12:24 - can still go over here in the inspector
12:26 - and swap it out for empties mode again
12:28 - we got this bug so we can just swap out
12:30 - the game object select that one and then
12:32 - click again and yeah there you go we do
12:33 - see the conversion so if you just want
12:35 - to see what this game object will be
12:36 - converted into you don't need to go into
12:38 - play mode you can see it directly over
12:39 - here so as I was saying we want to move
12:41 - and to do that there are many ways we
12:43 - can do that and looking at the entity by
12:45 - default we can see it has a local to
12:46 - World transform so one way to move into
12:48 - would be to access this component and
12:50 - modify over here the position that would
12:53 - work but modifying this position
12:54 - directly sometimes can cause some issues
12:57 - if the object is a child of something
12:58 - else so it requires a bit of validation
13:00 - a bit of external logic rather than just
13:02 - setting this directly and to solve this
13:04 - problem that is where a Brand New
13:06 - Concept in empties 1.0 comes in that is
13:09 - the concept of the aspect if you look
13:11 - over here in the inspector up top we do
13:13 - see a bunch of buttons so we see the
13:14 - components it was we see and then we
13:16 - have the aspects by default we can see
13:18 - that it does have a transform aspect
13:20 - holding the low composition low
13:22 - convertation and the uniform scale so
13:24 - this one is essentially the same as the
13:26 - regular transform what an aspect
13:28 - basically is is just a way to group
13:29 - together several components in a nice
13:31 - logical manner
13:33 - so this transform aspect owns all the
13:35 - logic related to a regular transform so
13:38 - the position rotation scale as well as a
13:40 - bunch of functions for working with
13:41 - those we can actually inspect this
13:43 - built-in aspect to see what it does so
13:45 - in the project let's search for
13:46 - transform aspect and make sure that we
13:49 - are searching over here in packages and
13:51 - let's open up the transform aspect and
13:53 - in here we see what it does it
13:55 - implements the aspect interface which
13:57 - again we're going to cover this in a
13:58 - little bit and then importantly it has a
14:00 - bunch of helpful properties as well as
14:02 - functions in order to interact with this
14:03 - object for example we have a nice
14:05 - function here to translate The Entity it
14:08 - just receives a photo 3 and then does
14:09 - the logic based on whether it's apparent
14:11 - or not so again aspects are basically a
14:14 - nice layer of abstraction so you can
14:15 - combine multiple components and do some
14:17 - custom logic which then allows your code
14:19 - to be much more simplified when you're
14:21 - doing regular things working directly
14:22 - with the aspect instead of the
14:23 - components don't worry if aspects seem a
14:26 - bit confusing now it's only going to
14:27 - become quite a bit more clear once we
14:29 - make our own so going back into our
14:30 - Moving System base over here I'm going
14:33 - let's find all of the objects with that
14:34 - aspect and let's move them and actually
14:36 - over here there are mainly two messes we
14:38 - can use one of those is what is called
14:40 - the entities dot for inch if you've used
14:42 - dots in the past and you're probably
14:44 - familiar with this method but nowadays
14:46 - in NTS 1.0 there is another method which
14:48 - is the one that you should be using it
14:50 - is called the idiomatic four inch so you
14:52 - do a four inch just like you do in any
14:54 - other C sharp code so just a regular 4
14:56 - inch then the type so for now we want to
14:59 - move so let's use the type for the
15:01 - transform aspect transform aspect
15:04 - which again is over here inside using
15:06 - unity.transforms so we do a four inch in
15:09 - and then we do a query so let's access
15:11 - the system API and let's do a query and
15:14 - we're going to query for the type that
15:15 - we want so in this case the transform
15:16 - aspect
15:18 - all right so here it is as you can see
15:20 - super simple just say regular for each
15:22 - like you've always done in C sharp now
15:24 - with this the code that we write here
15:26 - will run on every update for every
15:28 - single entity that has a transform
15:29 - aspect so for now let's just move it to
15:32 - the right
15:33 - so let's just access the transform
15:35 - aspect and into the position and let's
15:37 - increase the position so we're taking a
15:39 - full three which by the way if you don't
15:41 - know this is essentially a vector 3 it's
15:43 - just made with the unity mathematics
15:44 - Library which is meant to be more
15:45 - performant so let's use this and let's
15:48 - actually use our using up here
15:52 - so here using this and we're going to
15:55 - construct a new Fallout 3 and we want to
15:57 - move to the right so let's do just one
15:59 - zero zero although again this is going
16:01 - to run on every update so in order for
16:03 - movement to be frame rate independent we
16:05 - really should be using time dot Delta
16:07 - time so instead of being just one let's
16:09 - use
16:10 - time dot of time although this time is
16:13 - not the one that you should be using
16:14 - when working in ECS you should be using
16:16 - system API dot time dot of time okay so
16:19 - that's brilliant with this every single
16:20 - entity that we have that has a transform
16:22 - aspect should be moving to the right at
16:25 - a speed of one unit per second also here
16:27 - I should point out just like we saw the
16:29 - transform aspects function so if you
16:30 - don't want to add directly to the
16:32 - position over here you could just use
16:34 - translate translate in the world then
16:36 - pass in the same Vector tree so again
16:38 - many options just like you have with
16:40 - regular transforms okay so this is all
16:42 - you need to do in order to move an
16:43 - entity
16:44 - and just for clarity's sake let me
16:46 - quickly show you how the entities for
16:48 - each works
16:59 - so here are both methods basically they
17:02 - are extremely similar with the entities
17:04 - for each instead you have a Lambda
17:06 - instead of doing a regular four inch so
17:08 - you have there then over here you put
17:10 - whatever components you want just like
17:12 - over here we're doing a query and the
17:14 - one big difference is how in entities
17:15 - for each at the end over here we need to
17:17 - call either schedule or schedule on
17:19 - parallel or we call run
17:23 - basically the entities dot for each this
17:25 - one returns a job so then that job needs
17:27 - to be either scheduled or run
17:29 - and what these three options mean is
17:32 - that basically run this one runs a code
17:34 - just on the main thread this one runs
17:36 - the code in a single worker thread or
17:38 - alternatively schedule in parallel this
17:41 - one runs a code on multiple worker
17:42 - threads whereas over here when using the
17:45 - arithmetic four inch over here you don't
17:47 - have an option everything over here is
17:48 - going to be run on the main thread so
17:50 - it's exactly the same as doing run
17:52 - that is why I previously mentioned that
17:54 - when using system base and the ID
17:55 - manifold inch you should only do this
17:57 - for more simple use cases if you want
18:00 - absolute maximum performance and you
18:01 - should be using I system along with some
18:03 - proper jobs that can be paralyzed which
18:06 - again I'm going to cover in a little bit
18:07 - now one more difference is that over
18:09 - here the idiomatic range this one can
18:12 - have multiple nested Cycles so you can
18:13 - do this
18:17 - for example this is a valid necess cycle
18:19 - whereas with nt4 inch you cannot Nest
18:22 - them okay so like I said those are the
18:24 - differences but now as of entities 1.0
18:26 - you should be using the idiomatic four
18:27 - inch so let's get rid of the empties for
18:29 - inch so just with this code Let's test
18:31 - and if there it is the entity moving all
18:33 - right awesome we can even select it and
18:36 - again lock in the entities inspector and
18:38 - you look at that the 11 position
18:39 - constantly increasing on every second
18:41 - also another thing we can look at is go
18:43 - into window then go into entities and
18:45 - down here and look into the systems
18:47 - window and it opens up this nice window
18:49 - let's just anchor it down here and we
18:51 - can view all of the various systems and
18:53 - how they are organized in various groups
18:54 - and if we unlock by default if we look
18:56 - over here in update in the simulation
18:58 - system group if you look here we do see
19:00 - our Moving System base that we just
19:02 - created
19:03 - and yep we can see that it is currently
19:05 - running okay so now instead of moving at
19:07 - this speed let's use the speed data from
19:08 - our components let's just use a proper
19:11 - speeds over here let's say put it a bit
19:13 - faster but just on two okay now how we
19:15 - use our speed is super simple we just
19:17 - add over here yet another field so first
19:19 - on our query let's add the speed
19:21 - component and then over here let's put
19:23 - this inside parentheses so we can add
19:25 - multiple and let's say the transform
19:27 - aspect and then our speed component
19:31 - so here when moving we can simply use it
19:33 - so our Delta time multiplied by speed
19:35 - and we grab the value also one more
19:37 - thing which is up here in our query we
19:39 - can Define if this is going to be a
19:41 - read-only or a read write component
19:43 - so we can add the ref R doubling so this
19:46 - one are the only stands for read ranked
19:48 - but in this case we're just going to
19:49 - read the spin so we can use refro which
19:52 - means reference read only
19:54 - so let's use this and also modify the
19:56 - value up here so this one is the refro
19:58 - for our speed and then we access speed
20:00 - we access the value Ro and then access
20:03 - the value okay so let's see if it's
20:05 - moving twice as fast any update it is
20:07 - and by the way over here you can also
20:08 - modify it in runtime So currently moving
20:10 - at this speed if I put this on three if
20:12 - there go moving quite a bit put it on
20:14 - point one there we go moving really
20:15 - small so it's one of the benefits of ECS
20:18 - is you can easily edit any values at
20:20 - runtime okay so the movement is working
20:22 - now let's make another component to
20:24 - Define our Target position so in our
20:26 - project let's make another c-sharp
20:27 - script
20:28 - let's call this the target position
20:31 - and over here this one is going to be a
20:33 - component so once again let's make this
20:35 - a struct and we're going to implement I
20:37 - component data
20:39 - then over here let's just add a photo 3
20:42 - for our value okay
20:44 - now let's quickly make the authoring
20:46 - component then the baker so over here
20:48 - and let's create new c-sharp script for
20:49 - the Target position authoring
20:53 - over here this one is a monobehavioral
20:55 - let's add a public k43
20:57 - for the value and then we've got another
21:00 - one for the Target position Baker
21:03 - and we extend bigger of type Target
21:06 - position authoring
21:08 - and then over here we simply Implement
21:11 - so let's first of all add using entities
21:13 - and let's implement the abstract class
21:16 - and over here we're simply going to call
21:19 - our add component and let's add new
21:21 - component of type Target position
21:24 - and in some let's add the value to
21:26 - authoring dot Valley
21:27 - okay that's it super simple now here in
21:30 - the editor let's add the target position
21:31 - authoring let's also put it on a regular
21:33 - speed and for them let's make it move up
21:36 - so let's put it just on a z F5 now back
21:39 - into our Moving System base over here
21:41 - let's add our brand new component
21:43 - so here we've got our components in our
21:46 - query so for the query let's add another
21:49 - one so let's add in this case we're
21:51 - actually going to be updating our Target
21:53 - position so let's make this an frw
21:56 - and let's add the target position
22:00 - and then up here let's add a ref R
22:02 - doubling of our Target position
22:27 - so here it is some simple movement code
22:29 - so we've got our Target position we
22:31 - subtract our current position in order
22:32 - to kind of like direction we use math
22:34 - our thermalized to normalize that vector
22:36 - and then as usual we just move along
22:38 - this Direction with time dot of time and
22:40 - using our speed so let's see if it is
22:42 - now going towards the target position
22:44 - and if it is indeed going up instead of
22:46 - going to the right
22:47 - so let's put it to speed a bit faster
22:49 - and let's modify over here Target
22:51 - position let's move it a little bit to
22:53 - the right and yep there we go does move
22:55 - a bit backwards and if there you go it
22:56 - doesn't work okay awesome so all of our
22:59 - logic isn't it working but as we can see
23:01 - over here we're getting quite a lot of
23:03 - components over here in our system so
23:05 - with this this is the perfect example to
23:07 - showcase the benefits of making our own
23:09 - aspect like I said the main purpose of
23:11 - aspects is to group components into one
23:13 - logical unit
23:14 - over here we are grabbing three
23:16 - components and we're using all three in
23:18 - order to make our movement logic so
23:21 - let's refactor this code with a nice
23:22 - aspect to help make this code quite a
23:24 - bit more clear first in the editor let's
23:26 - add an easy sharp script so a new one
23:28 - let's call it the move to position
23:31 - aspect
23:32 - then over here the first thing that
23:33 - we're going to do is instead of mono
23:35 - behavioral we're going to extend I
23:36 - aspect which is inside Unity dot
23:39 - entities
23:41 - in order for it to be an aspect it needs
23:43 - to be a struct then we see a nice error
23:46 - telling us that an aspect must be struck
23:48 - and also must have the partial keyword
23:50 - so let's add that
23:52 - finally this one must also be marked as
23:54 - read only so read only
23:57 - okay so that's our basic aspect
23:59 - definition it needs to be a read-only
24:01 - partial struct I need to implement I
24:03 - aspect now over here we can add whatever
24:05 - components we want it can be regular
24:07 - components or they can also be other
24:08 - aspects so for example let's begin by
24:11 - adding our transform aspect
24:13 - so just a regular transform aspect
24:18 - and all of these films must also be read
24:20 - only
24:23 - then we can add components so in our
24:26 - system we were using the speed
24:27 - components so let's add that as well
24:32 - except in certain aspect we cannot use
24:34 - the component directly we need to use
24:36 - one of these so it needs to be a read
24:38 - write read-only or enabled read write
24:40 - enable read-rolling so we're here for
24:43 - the speed like we saw we're only reading
24:44 - so let's add a ref r o of this
24:47 - the other one we were using was the
24:49 - target position so let's use a private
24:51 - read only and for that one we were
24:52 - writing so ref RW of our Target position
24:58 - finally in our aspect we can optionally
25:00 - add an entity films so over here we can
25:03 - add a private read only entity for our
25:06 - entity
25:07 - this one is optional you don't need to
25:08 - add this
25:09 - but if you do it won't be automatically
25:11 - filmed with whatever entity is currently
25:12 - running this aspect one important thing
25:14 - is you can only have one so if you have
25:16 - multiple entities you get an error so
25:19 - you can only have one field of type
25:20 - entity okay so here we have our nice
25:22 - aspect and now if we go back into our
25:25 - Moving System base over here instead of
25:27 - doing a query for all of these
25:28 - components instead of that we can
25:30 - simplify this and just use our nice
25:32 - aspect so just like this our move to
25:34 - position aspect
25:40 - so it is you can see the code is much
25:41 - much simpler and now if we want we could
25:44 - expose all of the same components from
25:45 - the aspect or since the home point of
25:47 - the aspect is to group together logic
25:49 - then we can just make some functions
25:51 - there so let's copy this code
25:53 - let's go into our aspect and over here
25:55 - let's just make a public void move and
25:57 - in here let's face the exact same code
26:00 - so you do the same thing we access the
26:01 - target position calculate Direction and
26:03 - move our transform aspect then back into
26:05 - our Moving System base over here instead
26:07 - of doing all this we just go into the
26:09 - aspect and we call our move function
26:12 - also one important note is over here
26:14 - once inside I aspect over here we cannot
26:16 - use the system API directly if we try
26:19 - running the code like this we see this
26:21 - error which is not very harmful just
26:23 - invalid operation
26:24 - but real in this case what that means
26:26 - that we cannot use the system API to get
26:27 - the Delta time whilst inside the aspect
26:29 - so instead let's modify this code and
26:31 - let's receive over here a foil for the
26:33 - Delta time
26:34 - and then we just use that one
26:37 - okay just like this so we received that
26:39 - as a parameter and on the moving system
26:41 - base over here we can indeed use system
26:43 - API dot time.time okay let's test and
26:47 - yep now it does work perfectly okay
26:49 - awesome as you can see with all this our
26:51 - system code is extremely simple just a
26:53 - headphone lines of code same thing for
26:56 - the aspect again a really small file
26:57 - everything is super simple super easy to
26:59 - understand and same thing for all the
27:02 - components all of them are pre-symbal so
27:03 - many files but all of them are extremely
27:05 - simple extremely easy to follow this is
27:07 - one of the main benefits of ECS is how
27:10 - the architecture forces you to
27:11 - essentially write good high quality code
27:13 - everything is nicely decoupled nicely
27:16 - separated into separate files each doing
27:18 - just one thing all right so let's
27:20 - continue when we reach the Turning
27:22 - position we want to move to another
27:24 - random position for testing when we get
27:26 - there we can do a simple listen check
27:29 - so we can do a math dot distance also by
27:32 - the way in production code you probably
27:33 - should be using the distance squared
27:34 - since that one is a little bit faster
27:37 - but for this quick demo let's just use a
27:39 - simple distance just so our units make
27:40 - sense so this one just takes our two
27:43 - points so let's use the transform aspect
27:44 - dot position
27:46 - and let's use the target position dot
27:49 - value rw.position
27:52 - okay so if the distance is under a
27:55 - certain amount
28:01 - so if you get there then we want to
28:02 - generate a new random Target position
28:04 - let's make a nice function to generate
28:06 - this so probably going to return a fault
28:08 - 3 get random position
28:13 - and now usually what you would do would
28:15 - be something like this so a new Full
28:16 - three and then let's randomize and let's
28:19 - use the unity engine.random
28:22 - in order to randomize between 0f and
28:24 - let's say 15 enough
28:26 - then no random on the Y another random
28:28 - on the Z
28:33 - so this is what we would normally use
28:35 - but when working with dots we cannot use
28:37 - the random.range this is a class which
28:39 - would break when we eventually try to
28:41 - use bursts so we cannot use this random
28:43 - class but we can use the one inside the
28:45 - mathematics Library so we can use this
28:47 - random inside unity.mathematics however
28:50 - this one works differently for this one
28:51 - we need to initialize it
28:53 - we need to do something like new random
28:56 - which then takes in some kind of scene
29:06 - and then we can use this random which
29:09 - again note how this one is a struct so
29:11 - we can use this one in order to generate
29:13 - a next float
29:18 - so we can do something like this but
29:21 - again the way this works is this
29:22 - receives a seed over there on the
29:23 - Constructor if we were to do this then
29:26 - all of them would get the exact same
29:27 - random position because we were creating
29:28 - the seed and then generating exactly two
29:30 - numbers so if we use it just like this
29:33 - then this would return always the exact
29:34 - same random position in order to make
29:36 - something properly random we need to
29:38 - essentially store just a random instance
29:40 - store this somewhere and then reuse it
29:42 - to generate all of our random values so
29:45 - again back into how ECS Works how we
29:47 - hold some data and random is indeed a
29:49 - piece of data we call this in a
29:51 - component so let's make a component to
29:52 - hold this over here let's create new
29:54 - c-sharp script call it the random
29:57 - components
29:58 - now as usual let's do the same thing so
30:00 - this one is an eye component data and
30:03 - then in here we're just going to store a
30:06 - random again make sure you use the
30:07 - correct type so that's
30:08 - unity.mathematics.random
30:11 - and let's go with just randomly
30:14 - and again component is not a class but
30:16 - rather a struct okay so we have random
30:19 - component
30:20 - now you might think that to add this you
30:22 - could just make a authoring component
30:24 - just like we did and then essentially
30:25 - attach it to our entity
30:27 - however if you didn't and every single
30:29 - entity would add a random component and
30:31 - if you use the same seed for all of them
30:32 - then again you would not really have any
30:34 - Randomness so what we want is not one
30:36 - random per entity but just one random
30:38 - for the home world
30:40 - for that we can use a really nice entity
30:42 - Singleton so let's first of all make a
30:44 - baker which we're going to attach to a
30:46 - different object so let's create an easy
30:48 - sharp script called the random authoring
30:51 - then over here let's make the regular
30:53 - code although in this case we don't even
30:54 - need any fields
31:06 - alright so there it is super simple if
31:09 - you wanted you could input the seed over
31:10 - here if you want to customize the seed
31:12 - on the authoring component and in the
31:14 - final game you probably would want to
31:15 - use a proper scene like perhaps Acorn
31:17 - time but for testing a nice fixed value
31:19 - works great and it's actually quite
31:21 - helpful for debugging okay so we have
31:23 - our component now over here let's create
31:25 - an empty new game object on our empty
31:27 - subscene
31:28 - let's call this our random and over here
31:31 - let's attach the random authoring
31:32 - component okay so with this we have just
31:34 - one entity in the world with our random
31:36 - components now we just need to somehow
31:38 - use that over here in our random
31:40 - position now since we've made it a
31:42 - Singleton so there's only one random in
31:44 - the entire world since we made that we
31:46 - can easily access it so we can go into
31:48 - the system API in order to get the
31:50 - Singleton of type random component and
31:54 - we have access to it and then we can
31:55 - grab our random object
31:57 - so this is how we can grab it however
32:01 - again like I mentioned previously we
32:02 - cannot use the system API once inside an
32:04 - eye aspect if we run this we're going to
32:07 - see the same invalid error that we saw
32:08 - previously we can only call the system
32:10 - API from our actual system
32:13 - so instead let's receive our random as a
32:15 - parameter so let's receive this as our
32:18 - parameter here
32:20 - then over here in our move function
32:21 - we're going to have to generate so let's
32:23 - set this one so let's receive it as a
32:26 - parameter over here as well
32:29 - and when we reach a new position let's
32:31 - set the new one so we just set this one
32:33 - equals the get run position and let's
32:35 - pass in our random okay so we need to do
32:38 - is pass in the random to the move
32:39 - function so here in our system let's
32:42 - grab it so we can access the system API
32:43 - to get the Singleton of type our random
32:46 - component and let's access the random so
32:48 - this is the unity.mathematics dot random
32:53 - so we grab this one and then we pass it
32:55 - into our function okay so with this
32:57 - everything should be working we no
32:59 - longer have any errors so we pass in the
33:01 - random to the move function then the
33:03 - move function takes in the random and
33:05 - uses it to generate a new random
33:06 - position except this is not really going
33:09 - to work but let's test and see what
33:10 - happens
33:11 - so here we are in the unit is indeed
33:13 - going to the Target okay great and once
33:15 - it gets there generates a random
33:16 - position great but now as you can see
33:18 - it's stuck in that position we can test
33:20 - and see what is actually happening over
33:22 - here on the Move position aspect let's
33:24 - do a debug download to see what value is
33:26 - being randomly generated so let's do a
33:29 - debug.log on this okay let's see ideally
33:32 - it should always be different it should
33:33 - always be random so let's test so it's
33:36 - playing goes to the first position gets
33:37 - there okay generates another position
33:39 - gets there and nope there you go there's
33:41 - the issue as you can see the random is
33:43 - always generating the exact same
33:45 - position so we have something going on
33:47 - without random generation the issue that
33:49 - we have here is a very sneak issue due
33:52 - to how ECS works it's one thing that you
33:54 - always have to be very careful with
33:56 - since a lot of these things are structs
33:58 - which means they work as copies and not
34:00 - necessarily as references that's
34:01 - basically the problem that we're getting
34:03 - here we're grabbing the Singleton for
34:05 - the random component and grabbing the
34:06 - random except when you do this we are
34:08 - grabbing a copy so this one gets a copy
34:11 - then move this one passes in another
34:12 - copy so this one receives yet another
34:14 - copy which then does the random position
34:16 - so when this one calls the next one
34:19 - function this is calling next float on a
34:21 - copy ideally this would generate another
34:23 - Fallout and then update the current
34:25 - state on the original random but since
34:27 - we're working on a copy this one
34:28 - generates the next load but then it's
34:30 - always working on the same copy so the
34:32 - actual Singleton object that is never
34:34 - being modified this is something that
34:36 - you always need to be very careful with
34:37 - when working with dots you always got to
34:39 - be careful with are you working with a
34:41 - copy or are you actually referencing the
34:43 - original data the solution over here is
34:45 - pretty simple instead of using get
34:46 - Singleton let's use the get Singleton RW
34:49 - for read write this one returns a
34:52 - referred only so let's store that
34:54 - instead of storing the random component
34:56 - so let's sorry riff RW of type random
35:00 - component
35:03 - and we get just this one example like
35:05 - this again it's like this it's not the
35:08 - value R don't we no let's get exactly
35:10 - the refer going that's what we want then
35:13 - let's pass that one in
35:15 - so we just need to pass in this type so
35:17 - let's go into this one and receive the
35:19 - different type let's just rename this to
35:21 - the random component
35:26 - and then down here the exact same thing
35:29 - so then here we use the random component
35:31 - let's use the value RW and then let's
35:34 - grab the random and then we can call
35:36 - next float basically by doing this we
35:38 - are always accessing the value RW which
35:40 - does have an actual reference to the
35:42 - original data so with this it should be
35:44 - working and our debug download here this
35:46 - one should always be giving us a
35:48 - different random position okay so let's
35:50 - test so there's unit going to random
35:53 - position yup gets there and generates
35:54 - another random if gets air generates
35:56 - another random and so on so as you can
35:58 - see now it is always generating brand
36:00 - new random positions okay great so this
36:03 - was an excellent example of something
36:04 - that you always have to be very careful
36:06 - when working with dots you always have
36:08 - to be very careful with are you working
36:10 - with a copy or the actual original data
36:12 - okay so with this everything is working
36:14 - perfectly we have our unit going between
36:17 - random positions that's great and so far
36:20 - we made it using the system base but
36:22 - like I mentioned for maximum performance
36:23 - you want to be using the Isis instead so
36:26 - let's convert the exact same system onto
36:28 - an i system just to see the difference
36:30 - so over here let's make a new c-sharp
36:33 - script come with the moving eye system
36:36 - and on this one this one is not a mono
36:38 - Behavior instead let's Implement I
36:40 - system which is inside Unity dot
36:43 - entities
36:44 - also for this one since this one is an
36:46 - unmanaged system that means we need to
36:48 - make this a struct and not a class then
36:51 - we need to implement this interface
36:52 - which involves these three functions the
36:54 - uncreate on Destroy and on update this
36:57 - is another thing where I think they
36:58 - could improve the API they could make
37:00 - the interface have default empty
37:02 - implementations for the uncreated
37:04 - non-destroying that way you wouldn't
37:05 - have to implement them unless you wanted
37:07 - to do something complex so basically
37:09 - ideally it would work exactly the same
37:10 - as the moving system over here you can
37:12 - also override the on crate around
37:13 - destroy but you're only forced to
37:15 - implement the on update so any Moving
37:17 - System would be nice to work the exact
37:18 - same way only Force to implement the on
37:20 - update but as for right now we need to
37:23 - implement these but let's leave them as
37:24 - just empty okay so we have our own
37:26 - update
37:28 - now over here we can try putting the
37:30 - exact same code so let's go into the
37:32 - moving system base let's copy exactly
37:34 - this and let's paste it over here and as
37:36 - you can see on the error all I system
37:38 - must be defined with the personal
37:39 - keyword so let's also add that so here
37:41 - it is an i system with the exact same
37:43 - code everything running exactly the same
37:45 - you might notice that it's running at
37:47 - Double the speed that's because both
37:48 - systems are active right now one nice
37:50 - thing is on the systems window which
37:52 - again you can go into window entities
37:53 - and open up these systems on this one
37:55 - you can manually enable or disable
37:57 - systems so for example I've got the
38:00 - movingi system and moving system base
38:01 - and you can click over here to disabling
38:03 - system so disable the moving system base
38:05 - and yep now only the moving AI system is
38:07 - working now I can say on this one and
38:09 - nope nothing happens so just a fun
38:10 - tidbit of information this window is
38:12 - really very useful okay so back in the
38:14 - cone like I said the main benefits of
38:16 - using I system is that you are able to
38:19 - use burstable jobs so instead of running
38:21 - this code this for each which is only
38:23 - running on the main thread instead let's
38:24 - make a proper job that we can then burst
38:27 - and run on multiple threads to make a
38:29 - job you make a new struct so a public
38:31 - struct
38:33 - and let's call this the move job and
38:36 - then you implement one of the many job
38:37 - interface for example you have the eye
38:39 - drop chunk if you want to integrate over
38:41 - multiple chunks and you have the ijob
38:44 - entity which iterates over entities
38:46 - let's use this one
38:47 - now over here we just implement the
38:49 - public void execute method
38:53 - then the job also relies on code
38:55 - generation so over here this one also
38:57 - needs to be a partial instruct so we
39:00 - have the execute method and over here we
39:02 - can include whatever components or Asics
39:04 - that we want so basically inside of this
39:06 - execute function we want to run the same
39:07 - thing we were running on the four each
39:09 - so in order to run this code we need to
39:11 - have our move position aspect so let's
39:13 - add this one so let's add it right here
39:15 - and then we run the exact same code so
39:18 - just run this code this is required that
39:20 - we receive the random component so let's
39:23 - receive it as a field up here so the
39:26 - refrw for our random components
39:29 - and up here on the update instead of
39:31 - doing all this what we do is we
39:33 - construct a new job so a new move jaw
39:36 - we need to set our random components so
39:39 - let's set the random component and let's
39:41 - grab it so let's actually run the same
39:43 - as the other code to grab the field and
39:45 - then we pass in that exact same thing
39:47 - okay
39:48 - so this constructs the job and then
39:50 - afterwards we need to run it and again
39:52 - that's where those options that I
39:53 - mentioned while you'll come in so you
39:55 - can make run if you want to run it on
39:56 - the main thread but that would be kind
39:58 - of silly to do if we're working over
40:00 - here on an i system over here we wanted
40:01 - to make as parallelized as possible so
40:04 - alternatively we have schedule this one
40:06 - is going to run the job on a separate
40:08 - worker thread but only one separate
40:10 - worker thread and then finally we have
40:12 - the schedule in parallel this is going
40:14 - to run on multiple separate worker
40:16 - threads then each of those worker
40:18 - threads will then work on a certain
40:19 - number of entities so for example if you
40:22 - had 10 cores and 100 entities maybe each
40:24 - core would run 10 entities all of them
40:26 - running in parallel okay so with this we
40:28 - are creating and scheduling our job
40:30 - however like this we actually have an
40:32 - issue you might have started the issue
40:34 - already the issue has to do with as you
40:36 - can see over here we are using a refer
40:38 - dummy so we are reading and writing onto
40:40 - our random component and then we're
40:41 - scheduling it in parallel if we try
40:43 - running this and nope there's our issue
40:46 - basically in order to update the random
40:48 - component it uses unsafe pointers and if
40:50 - you do that then you cannot guarantee
40:51 - that you don't have any race conditions
40:53 - so you cannot run this job in parallel
40:55 - because multiple worker threads might be
40:58 - both trying to access and modify the
41:00 - same random component so in this case
41:02 - what we can do is simply split the logic
41:04 - for the movement logic over here we can
41:06 - easily run all of this in parallel so we
41:09 - can do this for all entities at the same
41:11 - time and then after all entities have
41:13 - moved then we can sequentially test if
41:15 - they reach the same position and reuse
41:16 - the same random component to generate
41:18 - another random position so let's just
41:20 - quickly split this code
41:24 - there it is so the move function only
41:26 - moves and this one does test if we reach
41:28 - the new position and if so generate a
41:30 - new random position now here on the
41:32 - system we can essentially make two jobs
41:33 - and the second job won't just test if it
41:36 - reached the target position
41:38 - so let's just give it a different name
41:39 - this one does receive the component and
41:42 - this one receives just the random
41:43 - component then this one up here does not
41:45 - have a random component and also over
41:48 - here the system API we cannot access the
41:50 - Delta time from inside of here
41:52 - so it's a public float Delta time and
41:56 - we're going to use this
41:57 - so then up here when creating a new move
41:59 - job let's hit the Delta time over here
42:01 - we can access the system API
42:04 - time dot Delta time then we don't have
42:06 - the random component so we schedule the
42:08 - move job to run in parallel and then we
42:10 - construct a brand new test reach
42:12 - position job and for this one we do pass
42:15 - in the random component
42:17 - and for this one we are going to run on
42:19 - the main thread now like this we still
42:22 - have some issues if we try testing we
42:25 - get the usual message that is really not
42:27 - very helpful just saying invalid
42:28 - operation no suitable code in this case
42:30 - the reason is because once creating the
42:32 - job over here we cannot access the
42:34 - system API we can access it just not
42:37 - inside the job initializer so we need to
42:40 - go up here to the final float for the
42:42 - Delta time
42:43 - system API
42:45 - access time.com for time
42:48 - and then we can indeed pass in that copy
42:50 - and like this it does work like you said
42:52 - return here just so we don't see the
42:54 - second issue just make sure that this
42:56 - part works and yep it does work it does
42:58 - move for our final issue like I said we
43:01 - want to do all of the move jobs and then
43:03 - we want to test if we reach the target
43:05 - positions so we want to make sure all of
43:08 - these all of these scheduled parallel of
43:10 - these run and complete first before
43:12 - running this one so the final thing we
43:15 - need is really just a job dependency if
43:17 - we look into over here all of the
43:19 - versions for this function one of them
43:21 - as you can see does return a job handle
43:24 - so over here we can grab the job handle
43:28 - and you have handles inside unity.jobs
43:31 - and to return a job handle we need to
43:33 - use the function that takes in a
43:34 - dependency so we can access over here
43:36 - the system state so the state DOT
43:38 - dependency that is going to be the
43:40 - dependencies for this job system okay so
43:42 - now the goal is basically you want to
43:44 - run and complete this job before running
43:46 - this one
43:47 - so when we can do that is just going to
43:49 - jump handle and count complete that is
43:51 - going to ensure that all of these this
43:53 - scheduled parallel is going to complain
43:54 - before we get to this point which is
43:56 - going to run on the main thread okay so
43:58 - like this it's almost working we just
44:00 - need one more tiny thing so let's test
44:01 - and there's our final issue again
44:03 - telling you that unsafe pointers cannot
44:05 - be used which are used in the random
44:07 - component
44:08 - as long as you know what you're doing
44:09 - and you're not messing around with
44:10 - multiple threads you can use this
44:12 - attribute to disable this safety so
44:14 - since here we're going to run this on
44:15 - Main thread and we know what we're doing
44:17 - we're accessing the random struct so
44:19 - we're not doing anything too special so
44:21 - over here we can indeed use the
44:23 - attribute in order to disable that
44:25 - restriction alright so like this
44:27 - everything should be working
44:28 - so we can finally go and see and yep the
44:31 - unit does go to the direct position gets
44:33 - there gets a random position and always
44:34 - goes from random position to random
44:36 - position
44:37 - the final thing that we need which is
44:39 - one of the main benefits of system is
44:41 - being able to use bursts over here let's
44:42 - add the attribute burst compile
44:46 - so we added over here then we also need
44:48 - to add it to all the functions and on
44:51 - the jobs themselves this one I'm not
44:52 - sure if you have to add this but you can
44:54 - also add it alright so now these jobs
44:57 - should be running with bursts which
44:58 - should be insanely fast so let's test
45:00 - and see any everything some works
45:03 - exactly the same and we can even look in
45:05 - the nice profiler so analysis profiler
45:08 - over here we see everything running
45:10 - insanely fast let's click on a random
45:12 - point so over here in this case really
45:14 - need to zoom in or to find it since we
45:16 - really just have one entity and that's
45:17 - how fast this is but over here we can
45:19 - see default World moving ICE system
45:21 - taking 0.02 milliseconds
45:24 - and if we scroll down we can find yep
45:27 - over here our burstable move job
45:28 - completing in 0.003 milliseconds and
45:32 - then finally appear as you can see all
45:34 - of those complete so that job completes
45:36 - and then we've got the test reach
45:37 - position job this one runs after and
45:39 - completes in 0.002 milliseconds so all
45:43 - of it insanely fast even if we were to
45:45 - compare just one entity with one game
45:47 - object this is still much faster okay so
45:49 - our eye system works here we have the
45:52 - two ways of doing a system so we've got
45:54 - the system base we get the on update and
45:56 - we do an idiomatic four inch and we've
45:59 - got the movingi system which manages to
46:01 - use burst in order to be much more
46:02 - efficient and for this one we Implement
46:04 - a system and you do things a bit
46:06 - differently by creating the actual jobs
46:07 - that we're going to execute
46:09 - so for simple and use cases where you
46:11 - want to run some code on Main thread you
46:13 - can use the very simple system base and
46:15 - for more complex code where you really
46:17 - want maximum performance just go ahead
46:18 - Implement an eye system with some jobs
46:20 - and schedule them in parallel as you can
46:22 - see all these syntax is actually pretty
46:24 - straightforward once you learn what all
46:25 - of these terms mean
46:27 - what is a system what is the burst
46:28 - compiler what are jobs how do you get
46:30 - components and so on of it is really
46:33 - relatively simple with the potential of
46:34 - being insanely fast okay so next let's
46:37 - look into instantiating let's go into
46:39 - our empty subscene to create a brand new
46:41 - game object call this the player spawner
46:44 - now let's make a component so an easy
46:47 - sharp script for the player spawner
46:49 - component
46:50 - then over here as usual let's make the
46:52 - say component so first of all it's a
46:54 - struct and Implement I component data
46:58 - then inside here let's add a simple
47:00 - empty film for our prefab so a type
47:02 - entity
47:04 - for our player prefab now let's make the
47:07 - usual authoring in bakerscript
47:14 - okay so here I've got the bigger now the
47:16 - important thing is on the mono behavior
47:18 - on the authoring component I made a Dev
47:19 - type game object but on the component
47:22 - itself it's of type entity so basically
47:24 - we want to convert this prefab into an
47:25 - entity which we can then instantiate in
47:27 - the empty world and how we do that is
47:29 - very simple first let's add our
47:31 - component let's add of type player
47:34 - spawner component
47:36 - and then over here for the player prefab
47:38 - how we convert game object into an NT is
47:41 - super simple we'll literally just call
47:42 - get entity and we pass in go into the
47:45 - authoring component to get the game
47:47 - object player prefab okay so that's it
47:50 - it's really that simple now here in the
47:52 - editor we have the player spawner first
47:54 - of all let's make the player into a
47:55 - prefab let's rename this college player
47:57 - then just drag it over here into the
47:59 - project
48:00 - and let's get rid of the one on the
48:02 - subscene so delete it then on the player
48:04 - spawner over here let's add the player
48:07 - spawner the authoring component and then
48:09 - we just drag our prefab reference okay
48:12 - now let's make a system to use this NTN
48:14 - spawn it so let's make a new c-sharp
48:17 - script
48:18 - for the player spawner system
48:21 - for this one you don't really care about
48:23 - maximum performance only to use the
48:25 - simpler system base
48:26 - so let's go with system base
48:32 - and then over here on update let's spawn
48:33 - a new player every frame until we have a
48:36 - certain amount
48:37 - for identifying players one thing we can
48:39 - do is use a nice tag component
48:41 - so let's create a new script called the
48:44 - player tag
48:46 - then up here let's do the usual thing
48:48 - except for a tab component we're going
48:50 - to make this empty so it's a struct i
48:52 - component data there you go just like
48:55 - this just an empty struct this is our
48:57 - nice player tag then we need to attach
48:59 - it so let's make the authoring
49:05 - and over here the only thing we do is
49:06 - just add the components so just a new
49:08 - player tag
49:10 - okay like this and now I need to
49:12 - actually fix this error just so we can
49:14 - compile it so our system base needs to
49:16 - be partial so just over here and let's
49:18 - make it partial just make that error go
49:20 - away in our code compile now here we can
49:22 - select the prefab and let's also add the
49:25 - player tag authoring okay so that is
49:26 - going to add a nice empty player tag and
49:29 - with that we can basically find all of
49:30 - the players in the world
49:32 - so you can go into the entity manager in
49:34 - order to create an NT query
49:36 - then we pass in the time so type of our
49:39 - player tag
49:41 - so with this we have an NT query
49:46 - and then on this we can calculate the
49:49 - entity count so that is going to tell us
49:50 - how many players exist in the world
49:52 - so we can just check if this is under a
49:55 - certain spawn amount
49:59 - if it is under that certain amount then
50:01 - we want to spawn a brand new one so for
50:03 - spawning one way that you can do it is
50:05 - go into the entity manager and call
50:08 - instantiate and pass in The Entity
50:11 - so we need to get our empty so let's do
50:13 - it just like we did previously
50:15 - so it's going to the system API in order
50:17 - to get the Singleton of our type
50:20 - so our type was the player spawner
50:22 - component
50:25 - and here we're just reading so we can
50:27 - use the regular Singleton we don't need
50:29 - the Singleton read write so you get that
50:31 - and from here we can access the player
50:33 - prefab okay so this would indeed
50:35 - instantiate it in this case since we're
50:37 - working inside of system base and
50:39 - running everything on the main thread in
50:41 - this case this should be working fine so
50:42 - let's do a quick test and if there you
50:44 - go it does work we do have in the two
50:46 - player units okay great so this does
50:49 - work however one very important Concept
50:52 - in ECS is the concept of structural
50:54 - changes these are changes like spawning
50:57 - or destroying entities or modifying an
50:59 - archetype by adding or removing
51:00 - components basically you need to be
51:02 - careful with when you do these types of
51:04 - changes if you do them while some system
51:06 - is cycling through some entities and
51:08 - everything will probably go wrong so for
51:10 - spawning or destroying entities or
51:12 - adding or moving components to do that
51:14 - you should do it at specific points if
51:16 - you look over here in the systems window
51:18 - we see all the systems that we already
51:20 - saw previously we've got a whole bunch
51:22 - of groups and then we also have some
51:24 - things called an enter the command
51:26 - buffer system basically what you can do
51:28 - is you can queue up some commands to run
51:30 - on one of these empty command buffer
51:32 - systems so you can queue up the commands
51:34 - and then they won't be executed the next
51:35 - time this runs basically these are
51:37 - called sync points so when adding or
51:40 - destroying entities when adding or
51:41 - removing components you should probably
51:43 - be using an empty command buffer which
51:45 - one you use is going to depend on what
51:46 - you're trying to do in this case let's
51:48 - use the begin simulation this one to
51:50 - spawn our entity so here let's do that
51:53 - so we go into the system API
51:56 - then we get Singleton as usual and for
51:59 - now let's go into the begin simulation
52:01 - and the command buffer system
52:03 - and let's access the Singleton
52:06 - with this we have the Singleton and then
52:08 - we can call create command buffer this
52:11 - one takes a world and for that we can
52:13 - use World Dot unmanage
52:15 - okay so this is going to return entity
52:17 - command buffer
52:22 - okay so we have this and over here
52:24 - instead of calling instantiate directly
52:25 - on entity manager which will spawn the
52:27 - empty right away instead we're basically
52:29 - going to queue up the command so go in
52:31 - here and concentrate and do the exact
52:32 - same thing so instantiate the exact same
52:34 - prefab
52:35 - then after instantiating this returns an
52:38 - empty reference so entity the spawn
52:40 - entity and if you want you can modify
52:42 - some things so for example let's go into
52:44 - the NT command buffer in order to call
52:46 - set component and let's modify our speed
52:49 - component so let's pass in a new Spin
52:52 - and for the speed let's pass in the
52:54 - value and put the value on something
52:55 - else to add a bit of Randomness let's
52:58 - grab our usual random components
53:03 - except since this one needs to update we
53:05 - need to use the read write
53:08 - so the random component value RW and
53:12 - then let's grab the random in order to
53:14 - get the next float
53:16 - and for the speed let's say between one
53:18 - F and let's say 5f Okay so we're giving
53:21 - a random speed to our brand new entity
53:23 - we just need to use the entity just like
53:26 - this okay so with this we should be
53:28 - spawning our entities and they should
53:30 - have a random speed let's also just
53:32 - increase the spawn amount by a little
53:33 - bit let's say just 20 Let's test any up
53:36 - there we have our 20 players all of them
53:38 - with some random speed and moving to
53:40 - random positions as you can see
53:42 - everything song works is done with the
53:43 - same so all the systems work regardless
53:45 - of how many entities you have for one
53:47 - more interesting thing let's look at how
53:49 - to mix ECS and game objects so over here
53:52 - I've got a very simple Circle Sprite
53:54 - texture then my scene has just created
53:56 - the game object like a regular game
53:58 - object not an entity and inside just
54:00 - play C circle with a nice bright run so
54:02 - pretty simple and again this is a
54:04 - regular game object nothing in here is
54:06 - being converted to any empty at all so
54:08 - now let's make a nice c-sharp script
54:10 - well it's our player visual let's leave
54:13 - this one as a mono behavior and attach
54:14 - it to our regular game object over here
54:17 - let's have a field for our Target entity
54:20 - so private entity for the Target entity
54:22 - and then let's make a function to select
54:25 - a random Target empty so private empty
54:28 - get random entity
54:30 - now here we can do similar to what we
54:33 - did previously
54:34 - so on the player spawner system over
54:36 - here we're using the empty manager to
54:37 - create an empty query however this empty
54:39 - manager this one is not the static
54:41 - entity manager this one is a component
54:43 - of the system base so over here if we
54:46 - use entity manager now we're using the
54:48 - class and not any property so we need to
54:50 - access a specific empty manager and when
54:52 - we can do that we can access the world
54:54 - in order to get the default game object
54:56 - injection world so it's going to be
54:58 - pretty much the default World in our
55:00 - case we know that that is the one that
55:01 - we're using we're not using multiple
55:03 - worlds so from this one then we can now
55:05 - get the empty manager and we can now
55:08 - create an empty query
55:10 - and let's pass in the same thing so type
55:13 - of our player tag
55:16 - so this is going to return an NT query
55:18 - of our player tag into the query
55:23 - and then from this one we can call 2
55:26 - into the array which is basically going
55:28 - to give this an array with all of the
55:30 - entities that have the player tag
55:32 - we need to use an allocator we just need
55:34 - this to be allocated pretty much as one
55:36 - just as soon as we get the random entity
55:38 - then we want that allocated to be
55:39 - disposed so let's use temp that is the
55:41 - shortest live one this returns a native
55:44 - array of entity
55:47 - which by the way native array is inside
55:49 - using unity.connections okay
55:52 - so we have an array of our entities then
55:55 - let's just check if we have any so if
55:57 - this one down length is bigger than zero
55:59 - if so let's return a random one
56:02 - so just go in there and just use now we
56:04 - can use the regular random.range because
56:06 - again now we're in mono behavioral World
56:08 - between 0 and the anti-native array dot
56:11 - length
56:12 - and if there are no entities then we can
56:14 - return the default so the entity.no
56:18 - so this is the constant that always
56:20 - refers to an empty entity all right so
56:22 - now we want this player visual to
56:24 - visually follow our random entity so
56:27 - let's make a private void late update we
56:29 - want to update the visual after all
56:31 - these systems
56:33 - then in this one let's check if the
56:35 - target entity is not null so if it is
56:37 - not entity.no
56:39 - if so then we want to follow so we need
56:41 - to get the position of this target
56:43 - entity and again how we do that let's
56:45 - access the world to go to default World
56:47 - access the empty manager and from this
56:49 - we can call get component
56:53 - and we need a component of type that has
56:55 - the position so we can use the local 2
56:57 - world transform
56:59 - we need to pass in the entity so that is
57:01 - going to be our Target entity
57:03 - and from this one we can access the
57:05 - value and then access the position
57:07 - so that's the vector 3 for the follow
57:09 - position which actually is not a factor
57:12 - three rather a43 but those who get
57:15 - converted automatically
57:16 - so we have our final position and then
57:18 - we just set this transform.position
57:20 - equals this followed position
57:22 - all right so with this we shouldn't have
57:24 - a nice connection between the game
57:25 - object world and the empty world let's
57:27 - just find how to set the target empty so
57:30 - let's do some simple input so input get
57:32 - key down so when I press e space key
57:34 - then let's get a random one so get a
57:37 - random empty
57:39 - all right so let's test any appear is
57:41 - indeed working so again here we have our
57:44 - Circle visual which is a complete normal
57:46 - game object so there's nothing related
57:48 - to entities on this game object itself a
57:50 - regular game object so that one is
57:52 - managing to interact with the empty
57:54 - World in order to follow an entity as it
57:56 - moves so you can see how easy it is to
57:58 - mix game objects and entities and access
58:00 - anything from the empty World while the
58:02 - game object Wireless and vice versa here
58:05 - note how I did it this way I basically
58:07 - made a mono behavior and from inside
58:08 - this I access the entities world but you
58:11 - can also do the opposite so on some kind
58:14 - of system base so something like this
58:16 - you could make a system then over here
58:18 - access some mono Behavior perhaps
58:19 - through a static field access that and
58:22 - then modify that over here so you can do
58:24 - both you can grab the game object worm
58:26 - from the empties world or you can grab
58:27 - the empties worm from the game object
58:29 - world
58:30 - finally let's do some performance
58:32 - comparisons so here I've got two simple
58:34 - Mona Behavior scripts running the exact
58:36 - same code first of all a player spawner
58:38 - game object so I just have a reference
58:40 - to the game object prefab which by the
58:43 - way I'm actually reusing the exact same
58:45 - prefab even though in modern behavior
58:46 - these components won't do anything so I
58:48 - got that then I just cycle through a
58:50 - certain spot amount I can instantiate on
58:51 - prefab then I add my game object move to
58:55 - position component and I set a random
58:57 - spin so for this component here it is
58:59 - again just regular game object code I've
59:02 - got a Target position and a certain
59:04 - speed then on update called the move
59:06 - function and the test reach position
59:07 - function then over here pretty much the
59:10 - exact same thing except using regular 3
59:11 - instead of folder 3 and for the redness
59:14 - using Unity engine.random instead of the
59:16 - mathematics at random so there you go as
59:18 - you can see pretty much exactly the same
59:19 - code and up here it is running as you
59:21 - can see everything looks exactly the
59:24 - same looking in the hierarchy we can see
59:26 - all of these game object loads now let's
59:28 - increase the amount by quite a bit in
59:30 - order to bring the FPS down
59:31 - so here let's try increasing the spawn
59:33 - amount to 10 000. so let's see
59:37 - and up here we have 10 000 game objects
59:40 - and it's running at about 40 frames per
59:42 - second looking over here in the
59:44 - inspector it seems that all of these 10
59:46 - 000 are taking up 10 milliseconds then
59:48 - the rest is related to rendering which
59:49 - is taking another 10 milliseconds now
59:51 - let's bring the game objects back down
59:53 - to zero so spawn no game objects and on
59:55 - the ECS player spawner system let's put
59:58 - this one on Ten Thousand so let's see
60:00 - and if there we go here we have 10 000
60:03 - entities we can see down here the moving
60:04 - eye system is accessing 10 000 entities
60:06 - and the frame rate is around 120 140 FPS
60:09 - and looking over here in the profile we
60:12 - can see quite a big difference so we
60:14 - really have to zoom in order to see just
60:16 - how much so the entire simulation system
60:18 - group is taking just 0.4 milliseconds
60:20 - and the presentation system group
60:22 - another 0.4 milliseconds and then over
60:25 - here for the rendering 2.5 milliseconds
60:27 - so previously we had 10 milliseconds in
60:29 - all the logic and now here we have less
60:32 - than one millisecond on logic so as you
60:34 - can see this is the kind of performance
60:35 - that you can get with ECS it's a pretty
60:37 - massive difference and hopefully with
60:39 - this video you saw that the Syntax for
60:40 - Dots really isn't that much more complex
60:42 - I mean it's definitely more complex than
60:45 - a regular amount of behavior but nothing
60:46 - too intense once you learn the main
60:48 - Concepts everything is actually pretty
60:50 - intuitive now even though this video
60:52 - actually ended up being a lot more
60:54 - detailed than I initially anticipated
60:56 - even with that there's still quite a lot
60:58 - of things that I haven't covered here if
60:59 - you want to continue researching dots in
61:01 - more detail I can help recommend their
61:03 - official tutorial guide over here you've
61:05 - got the introductions talking about on
61:07 - the concepts and then you even have some
61:09 - really nice really in-depth tutorials to
61:11 - learn absolutely everything then of
61:13 - course you have the entities
61:14 - documentation over here there's lots of
61:16 - great info to help you understand all
61:18 - the various Concepts within this and if
61:20 - you want a full-length project then I
61:22 - can also recommend the excellent 2 hour
61:24 - video by terrible mix games it's
61:26 - building a real nice project involving
61:27 - tons of Concepts and putting all
61:29 - together also you can follow his channel
61:31 - if you want to keep up to date with dots
61:32 - Intel 1.0 there's links on the
61:34 - description and I hope this video gave
61:36 - you a nice overview of the current state
61:37 - of the API and how it all works
61:39 - personally I think it's all
61:40 - pre-intuitive and easy to use so I'm
61:42 - very much looking forward to the future
61:44 - as dots hits 1.0 and regular people
61:46 - start using it to build all kinds of
61:48 - very interesting and very ambitious
61:49 - games speaking of that go ahead and add
61:51 - my game to your wish list I'll probably
61:53 - be using dots for some systems and
61:55 - making some nice devlogs from it or if
61:57 - you want to learn ninja in general check
61:59 - out my complete step-by-step courses
62:00 - alright hope that's useful check out
62:03 - these videos to learn some more thanks
62:04 - to these awesome patreon supporters for
62:06 - making these videos possible thank you
62:08 - for watching and I'll see you next time
62:14 - foreign