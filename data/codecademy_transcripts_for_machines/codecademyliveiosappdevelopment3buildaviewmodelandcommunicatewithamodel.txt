all right make sure this is worked and kicked up all right great then we are back here for the continuation of our code academy live stream for our quiz app welcome back to everyone who is here live watching along with us and hello to people who are tuning in later uh if you want to catch up with where we've been so far the link that is in chat right now is a link to the version of the project where we have ended up with last time so i'll go ahead and link that out here so if you'd like to follow along by looking at the code you can feel free to go ahead and follow along with that there if you'd like instead to follow along by just watching and piecing it together you're welcome to do that too so uh without further ado let's go ahead and get back into it here so let's take a look at where we ended up last time and the problem that we were trying to solve so where we ended up we had our application in a state like this here so we built out our initial quiz application we had built out some of the controls that we could kind of play around with to get to see some of the other options so we ended our session with that last time and we built out some of the basic logic that would let us tell learners of users of our application whether or not they got something right or not as they're working through it so let's take a quick look at where we ended up so we have here asking what the first computer bug is we select in this case the month we get a green because that's what it is and then we get a bar showing up here that doesn't do anything and if we collect select something that's not the right answer it turns up red instead so a great start to our quiz app uh but we don't yet have a full game out of this so what we have so far is a way to showcase individual quiz questions to people who are using our application but there's a few things that we have missing as we stop as we're just talking about we'd love to be able to click on this next button and have something show up so that we can transition to the next question have the text here change to two out of four have this question update have all these clear out and have these answer choices update as well and that's what we're going to be doing in the session today is figuring out how we can use the concept of a view model which we'll talk about in a little bit to build out a more fully featured game that can present multiple different questions so let's go ahead and get started first with the easy task of making it so that this thing here is at least a button instead of just being a block of text now that's pretty easy to do with swift ui so let's go ahead into our bottom text and right now we can see that this is just text we'd love for this to be a button instead so that we can click on it we can do that by just adding in a button here and then we can see that the initializer for button takes in an action and a label maybe we don't know what the action is yet but our label can just be this texts that we have made down here for action we can just say uh say print hi we'll figure out something to do with it and now we can see that this should build and compile and then we get a button here we can see it turning blue instead now it's not going to do much yet it's just printing high and that will only actually happen once we have it hooked up a simulator as we saw before but now it's a button and we see that we can click on it let's do one other thing with this we'll do the same kind of trick that we saw inside the game view uh we had an answer button here and we had this on click property which let us decide we didn't know what we're doing with it yet and then pass in something new and hey the question in chat this is uh swift actually which does look very similar to kotlin swift is used for building ios applications uh okay so let's go ahead and then add in the on click here so we can say on click it's going to be something that will get passed in later and then we can go ahead and specify that action here once we add this as a property it's going to tell us anywhere we use this bottom text so we need to specify what we wanted to do just like it's a button so we can go ahead and fix that here we'll have i think one more place where this is going and we'll go ahead and clear that too and hello from uganda that is exciting i hope i hope you're ready to learn some ios development stuff here as we continue adding some features to our game okay so now we fix that we have a place where we can be adding uh to our bottom text nozzle button inside it as well that we can pass some functionality into uh great so now let's get back to that central question we have our game uh we can see it inside this tab view if we like but our game doesn't really accomplish anything we can see one question which is great but it can only ask one question and we really want to have multiple different questions that we can be presenting a single question isn't actually powerful enough in our game view we want our game view to be powered not just by one question but to be powered by an entire game a whole list of different questions that we can be presenting to the user as they're navigating through it in order to do that we're going to want to go ahead and add a game object another model which is going to represent all of the questions and set the way that the users can interact with our application so let's go ahead and do that first inside models we're going to make a new model which is going to represent the whole game that we're working with so to make a new file here you can right click on models click on new file we're going to make it swift file and then this is going to be our game so we have a game class that we're building here now what is a game well in this case it's a list of all of the different questions and figuring out how users can navigate through them and get informed if they're right or wrong uh and hate a new person late for broadcast good to see you here we're building out a quiz application for an io for ios oh yeah and the software for this is xcode which you can download on macs okay so on our game we need to have a list of questions that are available here so let's go ahead and give our game the questions we're going to use our question that we built up before has this static property which is all the questions that we're going to have in our game so we can go ahead and give our game those questions as it's starting questions and because it might be nice if the game was a little bit different each time we can just go ahead and shuffle it so that every time the order is a little bit different so they're presented in different order which is the same thing that academy does on our platform as well just shuffle those quizzes let's close questions okay so we have the questions that we're marching through which is good now we have some concept of multiple questions um but we still need to have a current question and a way for advancing them to represent that what we can do is we can have an index which we're using to store which question that we're currently on we want to start at the first question and move through each question until the user is done with it so we're going to go ahead and make our current question index which tracks what question are we on right now we want to start at question zero because array is start at zero for for developments so this is our current question index and then we can give ourselves a little bit of a convenience property here to say what's the current question we're on we could write out any time we wanted that like questions at this index so let's just make a little helper property to give us that here so that's current question which is going to be the current question index inside of our questions right here so we're starting to build out our game to capture the information that we need in order to have the questions that we're able to answer in order for the users okay so we have these here which is a great start and now the last thing that we're going to need is a way of advancing our game state how do we get to the next question once the user is ready to see the next question they've tapped on that next button we'll need to update our game that that happens so we're going to make a method here called advanced game state and this is going to go to the next question we can do that by just getting the next question so next question index which is going to be equal to the current question index plus one and then assigning that here and yeah absolutely shuffling uh makes the questions appear in a random order so the questions will always be these four questions you can always add your own questions uh but this will make it appear in a shuffled order so that it's not always this question appearing first it'll appear in a random order each time okay so we have our next question index which is going to be the current question index plus one and then we want to assign our current question index to be equal to the next question index when we try to build this we see that we have an error this tells us that self is immutable well we all know that in real life self changes a lot we change over time and there's actually a way to mark that inside of xcode now it expects that unless you specify otherwise that all of these properties should stay the same you can tell it no it's okay i know this is going to change by clicking down here and just clicking on the fix option which tells us that we want to make this function mutable so now it says that this function rather is a mutating function it can change the state of our application so that builds now we have our concept of a game now it's not much of a game but it's a game we have our questions we have a question index we know where the current question is and we can advance the game state there's one other good concept that we should use here which is the concept of encapsulation and what that means is when we are developing with our game structure and the rest of our application we only want to have access to the properties that we need to be using so for example we're going to need to call this advanced gamestate method so we need to be able to have access to it but we don't really need to know what the current question index is that's kind of internal business that this game can deal with by itself that's kind of private like we don't want to get into its inner workings and figure out what its current question index is unless we really need it so what we can do is we can mark that these are private and then these are the default which is internal you can leave that out because that's kind of the default there and then what we can also do is just add a little note for ourselves that these are going to be in internal methods internal methods and properties and that these here are private properties private properties what this mark does here aside from making it show up in a neat kind of green way is as you're looking here you can see that it kind of breaks out the different sections you have and if you're using uh there's this mini map option here and you can see that these marks are added really big so it's really easy to find other plans our files are still pretty short right now but occasionally you might be working with files that are dozens or well hundreds or thousands of lines long and it became can get really easy to get lost for what's where so adding these are called pragma marks can be an easy way to find things you're looking for okay so now we have our game now how do we work with our game we could go to our game view and then just start making a game and working with the game directly however there's a general design principle when building ios applications that tells us that that's not such a good idea and that's called the model view view model question here and before getting into it why is the var current question oh yeah quick note on syntax it's a great question uh this is what's called a computed property what this means is every time you want to know what the current question is it runs the code that's in between these curly braces so this just states what the what kind of thing it is this is called type annotation in swift and then in between here is how it finds the answer to the current question um some languages don't have this we could have also written something like get current question question as a method like this this would have done the same thing but the syntax is a little bit nicer because functions imply that we're doing something or changing things and this is just a property we're just getting it here so there's lots more you can look at for what computed properties look like like technically you write out these get keywords which show the same thing we have all of those in our intermediate swiss course if you want to get deeper into them for now the important thing to get from it is that it's just a way of accessing the current question and then this is type annotation to talk about what it is it's a great question though and the reason why we can't do equals is because it changes over time if we said current question index with an equal sign and then this index changed later our current question would still be stuck in the past so we have to recompute it each time someone asks for it because the current question index might be different okay so now that we've gone and built our game out here we're talking about how to integrate it with the rest of our application now the general design principle to touch on briefly is called a mvvm architecture which stands for model view model and view so m v vm model view view model as architecture the general way that you describe building an application is we have our views which we can see up here and our views are all things that users can see tap on and work with directly they're where information gets presented to users and where the capture intends from users like if they tap on a button or enter text in or take a photo or something our models as we've seen are where the business logic and data are housed so this is kind of the business logic like our questions for application or our core logic about how to advance through the game as we're playing it now how can we relate the game and the game view if we just put it in directly our game would be very tightly coupled to what our game view needs it might have specific things that we need in our ios application that maybe other people wouldn't need as much the idea when you're building models is that they should be reusable in lots of different contexts this question that we've built works great in our ios application but it would also work in a command line application there's no reason why we have to be presenting things visually with this model here maybe we want to build a textbased version of our application we could still use the same question model doesn't use any views it's not talking about anything that the use that learners or users of the app can see so we want our our each of our uh models to be reusable in a lot of different contexts but that means we still have to do the work of translating these abstract businessy data concepts into views that we can actually see while the view could do it itself it would get really bloated pretty quickly because there's going to be some logic it needs to take care of so what we need to do instead is build an intermediate layer called the view model which is responsible for taking in information from the model and then communicating it to the view and so this is uh the new style of architecture that's used for swift ui you might also see mdc or model view controller architecture in older applications but this is a really clean and elegant way to divide out different pieces of your application so the work our view model does is it gets bound to our view so as the view model changes our view is going to go ahead and update automatically which is super convenient and we can keep our model this kind of pure business abstracted layer which we don't have to worry about bleeding in any sort of view logic into it it just gets to know what the state is of our game at any given time okay so that's very theoretical that's kind of like what view models are for what does that actually look like in practice let's go ahead and take a look we want to build a new directory here we have our views we have our models let's build that view models layer where we can be housing those we can do that first by making a file which is going to represent our game view model which is still just going to be a swift file game via model and we're going to go ahead and give it its own directory here which is going to be view models uh generally good to not have spaces in your names it'll work most of the time but occasionally you might get some weird errors from it okay and then what we could do is we could even reorder these so it matches our mvvm style so we can have our models it can also be really hard to like get this in the right spot when you're dragging it takes uh it takes a bit of finesse okay how's that almost almost all right so we've got our models our views and our view models we can expand those out again okay now what is our game view model gonna do well we know it needs to relate between our uh game view and between our game model we're going to make this a class and we'll see why in a little bit here the classes are very similar to structures but there's a key difference we'll get into in a second so our game view model is going to be our way of relating our game to our view so the first thing it's going to need is going to need a game so our game view model now has access to this game here now our view is not actually going to have access to a gate so anything that the view needs to do it has to go through the view model it's the gatekeeper to any of the logic that we're interested in so uh what does it need to do well we can start figuring that out by going into the game view and i'm going to open this up side by side if you hold down option and then click on a file it'll open it up side by side next to it which is pretty neat and open up our game view here we'll not gonna nothing's gonna look different for a little bit so we're just gonna go ahead and hide that and now we can see we have our game view over here on the right and we've got our game view model over here on the left so we really don't want this to just be a question anymore our game view needs to display the whole game it's not just for displaying a single question so we're going to do something dramatic we're going to go ahead and delete this question replace it with a game view model and then see a lot of different errors that we see so let's go ahead and take a look so let's go ahead and make our view model view model and make that a game view model and we can just make a new one with it and get rid of our question entirely as expected that seems like it broke a lot of things so we're going to go through each of the dependencies we had on a question and give those to our viewmodel instead so it knows how to be displaying information uh and before that you can make a trick in a question if they get the right answer you change the question since it becomes wrong i love it uh kind of like a was that game called like the impossible quiz it was like kind of like a classic web kind of thing you can absolutely build something like that if we have time we can see i could mess around with it at the end um but that's absolutely something you could mess with and there's lots of neat stateful tricks you can use there um okay so let's fix some of these bugs now it's important when you're developing to not get scared when there's a bunch of like red errors coming up when you're when you're programming something that's a that's a normal part of refactoring is you make a change you see a bunch of errors and then you work one by one to fix them in our case it's uh the errors are telling us exactly what we need to do which is why selecting a compiled language is super helpful is because once our code compiles again we know that we haven't broken anything too obvious though we still may have introduced some bugs we don't like so let's go ahead and fix these we know that we need to get the questions text is the first thing we're displaying well we need to get the question from here so let's go ahead and get access to that so we're going to need the uh to get the question from the game here from the game view model so we can go ahead and copy i wouldn't just say this here so we want yeah so we want to go ahead and have the question text question text and this is just a string games have a current question and questions have question text so now instead of having this single question we're going all the way back to the game through the view model to figure out what the text should be so here we can replace this with view model dot question text that build error goes away and now we can see some more errors that we can be resolving this is trying to figure out all of the indices to know what the for each looks like we can grab those two so we can say answer indices uh and the type of this is kind of a range of integers all the indices that i can show up uh game.current question that possible answer dot indices and now we have all the indices now we can replace this string here with view model dot answer indices great now we need to get the what should the text be for a particular answer we can build a little method that'll do just that so we can call this like answer text or index which is just going to give us just the text that we should be showing for each question for each index and we can do that by here looking at the current question that current question dot possible answers at whatever the index is and we can go ahead and replace this here with answer view model view model dot answer text for index and then down here we're looking at if the guest index was the correct the questions correct answer index so now we can just go ahead and make that happen from the game here all right we did leave the sugar uncovered too many bugs but we're fixing them all so we can go ahead and then have our correct answer index which is just a c int which is the current questions correct answer index and then we can update this here to be our view model dot correct answer index and last now because our game view here doesn't take in a question it just has a game view model we don't need to give it what question we're working with our game is going to decide that so we can go ahead and get rid of this from here and from our game view that we build inside of the tab view okay so all those build errors went away so let's go ahead as the a good first step let's see let's see if we broke something that's always that's always exciting so let's go back to our game view go ahead and resume and great we can see that it randomized it so we see a different question now so that's great and when we click on something great wrong answer shows up as red and we get that next button which doesn't do anything yet but shows up here as we wanted to okay that's always a good first step of a of a refactor is we want to make sure that we didn't break anything so so far so good we can see it's shuffling to pick new questions each time we're playing it here which is exactly what we're looking for okay so now let's go ahead and build that next function in here uh let's go ahead and click on making it so that clicking on next actually advances the question our game already knows how to advance questions it finds the next index and then goes and reassigns the current question index to be that and then all those places where we're talking about the current question we'll recalculate to find what that answer should be at least that's the hope so let's go ahead and build that into the view model so that it knows how to advance questions by giving it a advanced game state advanced game state and this just passes along uh great so we can see we had an error same thing that we saw before this game we just said was just not supposed to be changing so we can mark that it's okay for interchange okay and last let's go ahead and pass in back in the game view uh whereas it's great so the bottom text here instead of doing nothing let's go ahead and make it go to the next question so view model dot advanced game state okay this looks promising let's see let's see if we got everything hooked up that we need okay we're playing we click on binary we click next nothing happens now we got almost everything hooked up but there's one really crucial concept uh that we need to be using to make sure things are updating remember when before we had the index and we weren't allowed to change it unless it was marked as state there's something very similar happening here just like we need to mark things state so that swift ui knows to update things when they change we need to do something like that here our view model is definitely changing things are things or things are happening we're clicking on the button we are advancing our game state and we can parse that out and kind of prove that so to speak by using some break points so it's a good debugging technique if we go into our game view model uh and we could put a break point here we can just verify that everything's actually connected once our simulator pops up they do take a minute sometimes yeah so these are just clicking on if you haven't seen breakpoints before you can go ahead and just click on the line number and that makes this little bookmark show up and when you have that bookmark show up it means that whenever your code gets to that line uh it just waits there and then you can kind of poke around and get to see some of the internal state that's happening so if we answer here and click next we see that this stops we we got to this line we're really trying to advance the game stage but still nothing's happening so let's take a look at why that is like we mentioned before when we're using uh what we want our views to be updating things have to be marked as state now we can't mark this as state because it's a little bit complicated there's there's a whole object here it's not just a single view that's up it's not just a single thing that's updating it's like this whole game that's updating it might have any number of things that we care about that are updating that change what this looks like so what swift did is they introduced a special keyword for these objects which is called a state object that's the marker we want to have here state objects can change so they need to be variables changing things and not let constants now the problem is that we can only have observable objects as things that we have marked as state objects the reason for that is because things that are marked as observable object so swiftly knows that they can change and knows to update people when they change so we need to go back into our game view model and mark that it's an observable object now we've this should compile and this is indicating that from our views perspective hey this thing here is stateful it's going to change and when it changes all of these things might need to be redrawn a new thing has to be shown to the user the different question which is the goal of this originally um our game view model then has to be marked as observable objects to showcase yeah i can i know i'm a thing that can be observed i'm going to change and the last thing we have to do is mark what are the things we should be looking for again and that's by using this published marker there's other ways of doing this as well but this published marker says i am an observable thing as the game changes publish those changes to whoever is paying attention and because this is paying attention and hasn't marked a state object then it will go and update itself let's actually see if that happens first so we click on play we get this here we click on binary click resume that froze uh we click on something we click on next and great the question changed we see that we have a different question appearing now and the answers all change there's a couple things we're going to need to debug but we definitely are making the right kind of progress here so to recap what what what happened with this process we built our view model and we just built it without any special fancy swift ui markers and we found that even though the code was running things weren't hooked up exactly correctly we clicked the button and nothing happened the way to fix that is to mark what is a and this has to be a class because only classes can be an observable object for kind of lower down swift things but we have to make our view model a class and that's marked with observable object and this marked with is called conforming to a protocol again we have lots more on protocols in our intermediate swift course and then four things that are marked with observable object anything that can change that you want to redraw when they change you have to mark as published then we can mark this whole thing as a state object so great so this is great progress we now have the ability to show other questions in our application as we click on next we can see that we're rotating through the different questions now there's a few buttons all right anyone can type in chat what are some of the bugs that we're looking to fix here what's wrong with this with with the way that this application works right now uh perfect question change but the number of the question did not change totally that's one thing that is wrong with this right so this says one out of four we click next still one out of four that's not good that's a bug we have to fix uh what else what else is wrong with this it's definitely gotta fix that one out of four thing but there's something a little weird happening too once we click the next button right you can see that we're clicking next this changes this stays one out of four but the kind of bottom part looks a little bit out of whack as well looks like there's something not happening there that we'd like so as we click play again we can see that when we click on one of these options this is all good it starts off as green we have the button showing up as the right colors here but once we click on next i didn't click on anything and it just started as the wrong color just started filled in and all these buttons we can't click on that's definitely not the behavior that we're looking for here so in order to make sure that we're uh well having a real quiz that we can present to people we need to make sure that we're updating uh we're clearing this out and resetting every time i click on something so let's go ahead and fix those but first let's take care of the issue that's scott pointed out earlier uh where we are going to fix this little one out of four thing forgive me if i'm not pronouncing your name correctly and yeah absolutely we have to change the button color back there's a little bit of delay on this that's totally right uh okay so how can we go ahead and do that well let's go ahead and take this one out of four oh we just have this hardcoded so we can go ahead and fix that by going back to our view model getting rid of that and then say we need to have our kind of like progress text as a concept that might encapsulate that so we've got our progress text which is text which is a string and our progress text is going to be question something out of something else well we kind of need to know how many questions there are and we don't have access to that yet we can find that out by going back to the game and then here we can start exposing some more properties from the game so we could say something like the count of the questions uh and we also need to get the current index a couple different ways we could do that the easiest way to get the index is just to mark this as private set sorry private set here which means that we can read this but we're not allowed to write it from any other context so that should give us access to it and then we can do the same thing for the questions just to get to know but we only really need to know how many there are so we can actually just grab the question count that's that should do it just fine here and just get the questions count like this here so again this is just some playing around with some other things we can do with encapsulation so what can we do from there now that we have a question count and our current question we can go back into our game view model and we can say that this is not question x it is question uh game dot current question index out of we could say it's out of four but maybe we add more questions we wouldn't have to want to have to remember each time to be adding to be changing this around as we added more questions so now we can just grab it from our question count for what the progress text should look like okay then we can go ahead and build we can see that that updates which is great let's go ahead and see if we fix that bug before getting into the the real serious one of the where the resetting is not working so we stop resume because we made a bunch of model changes we play all right we see first computer bug and now what do we miss let's see so we've got our viewmodels current question text actually what did we miss it's an interesting question okay so that still says one out of four and we're expecting it oh well it's right here we didn't change our view so we can go ahead then and make sure that our view is reading from our view model correctly so view model dot progress text that's why it's always good to make sure that you're testing things as you're developing them because you might not actually be implementing things in the way that you think you are again very normal process for development is things don't work how can we fix them now this is almost right we can see that this is zero out of four now again that's because arrays started zero so we can fix that by just adding one to it inside of our view model just like so now when we go back to our game view and resumed because we updated our model our viewmodel rather now we can see that it has the correct number here and as we play we see that it's going to correctly update to the second question okay so solve the first part of that we fix this we're reading from the game we can advance through the questions correctly great let's go ahead and work on the resetting part now there's a lot going on for the resetting and part of the problem is all the resetting code is just owned by the view it keeps track of our guest index and it figures out what the color is now we could try to do some messy things inside our view by like resetting this to nil each time that someone guessed and doing that in the button and then sending it back again but that's a little bit messy and that's messy because maybe we want to have a feature where we could like go back and look at previous questions voice recognition be fantastic that's uh we'll see if we have time for that at the end uh making no promises but that'd be fun uh siri integration uh yeah so but let's so the reason we want to have the index not inside of our view is maybe we'll want to keep track of this for later on so let's go ahead and add that to our game we would love for our game to keep track of the guesses that have been made for each question now how can we do that well inside of our game we can make a new private property that's representing guesses that have been made so private bar guesses and this type is going to be a dictionary where the keys are the get are the question and the uh value is what index the guests for that particular question i believe we have content on dictionaries in our kind of learn swift course so if that's a new concept you should go ahead and read some more on dictionaries there they're also called maps or hash maps and many other languages but the idea is we want a way that you give a question in and we tell you what the guess index was or if it was nil if no guess was made so we're going to want a type that maps a guess to an integer now it's going to complain a little bit and it's complaining because uh well i guess there's nothing we want a question it's gonna complain because it doesn't know how to have questions be keys this is a little bit more in depth of how hash maps work the basic idea is the things at the beginning have to be hashable which means you need to find a way to turn a question into a single number so you can go ahead and put it into an array that's what hashing is it's a way of turning really complicated things into numbers like if you've been following any of the apple features about uh detecting inappropriate images on people's phones there's a lot of talk about the hashing that they're using for it and that's because hashing is a way of transforming an image into a single number so then you can do things with that number and compare it or store it so we can mark that this is hashable and here it tells us the compiler is very helpful telling us exactly why this isn't working uh we can do that by just adding this keyword right next to our question so our question is now hashable because this is a fairly simple structure swift can figure out on its own yeah so we don't have to worry about it it's really it's really the beauty of it swift is figuring out on its own how to be turning this into a number and storing it we don't have to worry about the process that it's using to do that uh if our structure was more complicated we would need to add in a special uh bit of command like a hash into hash value and hash into and we'd have to define these and tell it hey how do you turn things into numbers and here and how do you get the number back from the original thing but because this is simple enough supposed to do that for us automatically and the real indepth answer is it's it's not just turning a number and storing it the way hash maps work is that there's like an underlying array or list we turn it into a number and then we kind of count buckets in the list until we get back it's kind of like duckduckgo you're just kind of counting one by one until you get to the spot that it should put it at and then you slot it there so lots more on hash maps and on dictionaries on codecademy platform but the basic idea is we want to get a map here and hashable will let us do that uh so back in our game we now have a place to be storing our guesses which is great uh then we can go ahead and give a function so that the user can make a guess and make a guess at an index we're going to make it simple and just always you're only able to guess for current questions uh if there was a different if we need to go back and change guesses around we could add that in that functionality later so we can go ahead and make our guess at the current question and set it equal to whatever the guest index was right here then in our view model we're going to need to have a way to make a guess and to translate that in now our game view still has this guest index we don't want this anymore the guest index should be only part of our view model and our game model but it shouldn't be part of our view we can do the same thing we did before let's open up our view model side by side let's just get rid of this and now let's figure out what we needed it for okay so one thing that we needed to do is we just set the guest index here directly now that we know our now that we have this make guess we can go ahead and add that to our model so we'll call this make guess or current question at index and then this will just go ahead and tell our game to make a guess at the index so we can go ahead and tell our view model to make a guess for the current question index and we'll just go ahead and do that we also have this thing that we're checking for if the guest index isn't nil this has always been a little bit clunky it would be great to have a concept here to have uh a variable called something like guess was made uh what's the point of guessing oh it's a great question so to clarify when i'm talking about guesses here i mean as a user who taps on a button that's the act of making a guess so if we're looking at the application which i can bring up here uh well this doesn't compile right now just slightly unfortunate okay so if i'm looking at this here and then i click on objective c that's making a guess so they're guessing index zero for this particular question or if they're clicking on typescript they're making a guess at index two there could be a more exact phrase naming is always very hard maybe like selected answer or choice maybe that could be a better name for it um but we've been using the phrase guests to kind of refer to how people are using it which now that you mentioned it is not necessarily assuming the best of users of our application uh so maybe maybe choice is a much better concept let's go ahead and fix it first just to get a compiling and then we can change the name around because that's an excellent point uh we'd like people to be making choices rather than guesses they said they should have some idea of what they're doing hopefully let's go ahead and fix these errors first so when we talk about guest index or chosen index or selected index which might be better names for it we're checking to see if they made a guess or if they made a choice so we can make a variable to represent that here we call this something like guess was made and this is a bool it's either yes or no and the answer to it is if the guess at this index isn't nil now in our game we made this private we can do the same thing here where we can get access to it but we can't change it only the game can actually change the passes so then we can go back and ask our game at the youtube guesses yeah selector choice is better we're actually going to change that afterwards i just want to fix these errors first here it's a really good point so we have game dot guesses at what is it the current question index uh current question index here or actually sorry we actually have a um guess this is by question so we have our current question do you actually we don't have a current question that's there we just got it from game dot questions which also don't have all right so we need to get the current question then so we can be passing it in here so let's go back to our game that's a lot of negotiation oh would you have a current question okay cool so we can go ahead i don't know why that wasn't showing up and take our game dot guesses at game dot current question like so and then we want to make sure that this isn't still cool so now we can go ahead and use this guess was made which is much more descriptive and to say it's if a guess was made then display this so that's all pretty straightforward and then the last thing we have to do is take this color for button and figure out how to fix this here and of course these are viewmodel properties so we just have to add that in okay so then our last step here is we're going to want to take this color for button and we're going to want to move it essentially all into the view model the view could own this we could have a way of translating the color back and forth but it's probably going to be simpler to just relate it here and have the view model tell us what the color should be so we're just going to go ahead and get rid of this from here move this into our view model note here that our view model uh we just had foundation it's going to complain because it doesn't know what a color is so we can do that by importing swift ui instead ah swift ui it's a great question this is directly from my mind i i if only i i have built this out before as a way of preparing for it it takes a lot of practice before you can build out something fluently here so i wouldn't expect anyone really to be ever to kind of have everything in place the first time and just put it together usually you have to build something out a few times to get a good sense of it that's a good question though okay so now we can go here and figure out how to fix this guest index and this guest index uh we can now grab from our guesses here so we can do the same thing and grab this guess like so and then we just have the correct answer index already here great so now we have our color for button and then the last thing that we can do is put in that this is a view model in the property instead okay there's a little bit of debate about whether the view model should have swiss ui in it at all it could still make sense to leave this inside the view that wouldn't be necessarily wrong it's just different ways of organizing it okay so everything compiles again which means this is a good time to see if we broke something so let's go ahead and put up our canvas here resume let it reload again and go and play okay so we can see here that as we click on things some virtuously we click next and it clears out it works we oh hopefully it works it works so as we keep clicking on things we can go ahead and see that our game is updating and our view model is also updating to reflect these changes now because our guesses are stored inside of our game instead of inside of the view now this doesn't have to worry about where we are it's all the game view model's responsibility which is a great thing to have so that our views can be simple and not have to worry about more than just how do i show information and how do i collect information uh so let's go ahead and make that last change while we're looking at it i really and you can let me know how you pronounce your name correctly i believe that was uh suggestion uh which if only i could be a wizard uh but for how we can go ahead and update uh the naming convention we're using internally i agree i think that guesses is a worse name than maybe selection i think selection might be a better name so let's go ahead and open up our global find menu by passing shift command s that brings this up and we can see every place in our application where we're using the term guess now we can do the simple answer of if we click on this find and put it down to replace we can just replace guess with selection we can say match case here and that will get rid of all the capital ones ignore in case we'll bring in all of them here so let's go ahead and see so if we're searching we want to change all guests to selection we can see that guesses will change to like selections a little weirdly so let's go ahead and do this first and change guesses to selections uh let's search on this and then we can see here we'll change this to selections and then we can do the same thing for guess and selection then we can go ahead and do the same thing for uh things that are not capitalized here so change guess to selection with a capital g and replace these and i think guest is going to become selection uh which would which one where um we have a guest uh just popped up it was guest index i think so it would be like selection okay make selection for current question that seems okay right was there somewhere else that it might have been messy as well let's ignore case let's still we can kind of scan through these it's always a good thing to look out for though this would be selected index all right so we can go ahead and fix that here and call this selected index that's a great catch thank you okay and then selection index see find and replace is a powerful tool but one that you have to be careful with uh but you can see that with a little bit of tweaking there um this is a great place to be showing like how kind of code review can work in development environments is there is a suggestion from someone looking at code that we could have a name to make things better and then we could just use a global finds to be figuring out the places we're talking about guesses and cha and phrase it instead as selections and i like that i think that makes a lot of sense it's a it's a concept of a selection rather than a guess at random so we can always change it back if we don't like it or we want to change something else but uh it's it's good to be names our names are hard names are always hard when you're when you're developing so appreciate the suggestion from that there and let's uh as always go and make sure we didn't break anything okay click on something we made a selection great okay so great okay perfect and let's check out the last one oh no someone crashed well this has actually always been here i just i just wasn't clicking through all the time but see if you can find out why do we think this crash right here what's going on what a crash the review kind of we can see what it looks like in the simulator as well but the kind of question all you is why did this crash see if we can figure it out uh this is what's called like a run time error so this is pretty bad as a user like imagine that this was your phone and as you are playing this quiz and happily going along and tapping on things suddenly when you click on this next button well this happens here and then your phone just stops or freezes what happens on real phones is that uh your phone knows that this is kind of just totally broken and just kills the application that's a really bad user experience it's one of the worst things that you can do when you're making an application is having just hard crash for people because they can't even use it anymore there's no kind of broken functionality or whatever so why did this happen well as we can see from running it in a simulator it actually crashes and tells us what the problem is and this is why it's always good to occasionally be running things in the simulator instead of just in the preview because the simulator has a lot more powerful functionality like the break points and being able to go and use other bits of the phone change settings and here we can see that it knows where it crashed and it just highlights that line right here uh yeah you're totally right it's because we finished four questions but we're still trying to go to the next question right so if we look here we can use a little bit of a trick to look at what is the current question index this po just stands for printout and we can see that it's four well what are the indices of our questions so if we say what are the questions indices what are the questions indices it'll tell us that the upper bound is four which means has to be less than four four is out of bounds we only have having four questions means that we have a question at index zero index one index two and index three no question index four that'd be a fifth question we don't have a fifth question so we crash well that's not good behavior as we talked about we can go ahead and fix that by having this advanced game state and if we've already been through all the questions we probably shouldn't go to the next question we should just end the game and have something else that we're doing we can do that by checking to make sure that this is a valid index here which is why we wrote this a little bit in a funny way you might be more used to seeing something like uh current question index plus plus or current question x plus equals one we're doing it a little bit more step by step so that we can check to make sure that it's what we want it to be so here we can ask the question to say if the questions uh indices doesn't contain the next question index or then the game is over and if it does then the game continues by going to the next question so what does it mean here for the game to be over well we could just print that the game is over print game over and let's see what happens now so as we run our application and we're doing this in the simulator so we can get those print statements we answer questions answer questions oh and game over great so as we keep tapping this is just still the game's over it's not letting us try to advance the next question it's not displaying anything else advancing game state no longer tries to go to the next question and you can see how powerful all of the swift ui binding is is just with that little bit of publishing changing this index makes everything change automatically which is really cool did not used to be that straightforward for building ios applications so we can end our game here uh and then let's just add a little property here just to represent whether or not the game's over so just make a uh game is over which is a pool and we can go ahead and then just set that here to be game is over is true and it should start off as false and then we don't need to annotate it okay so now we're ending the game it doesn't really do anything it just kind of tells us that the game's over but it doesn't break anymore so that's a good sign so that's as far as we're going to get to in this session here for our application we'll do a little bit of recap in a second but we can see that uh our game ends and where we're gonna end uh land off for for next time is saying hey we can advance through our quiz which is fantastic and we can go ahead and end the game but nothing happens so next time what we're going to look is figuring out how can we transition from this game view to a different type of view entirely so that some happens once the game is over uh okay so let's do a little bit of recap to figure out how our application is working here and what we added uh so let's see if we can still bring up the side by side thing we added in this game structure right here this is all totally new and this is our model that's representing how we're playing the game we have our questions we have our question index we can have some properties that we're exposing to our view model so that i can access them and then the big ways that we're changing it is advancing the game state to go the next question and making a selection to go ahead and reflect the selection that the user has made we added that in we went and then we added in this whole game view model which is just we can see a way to talk from a way to bridge the gap between the view and the model the important things to know for our view model is view models all need to be classes they have to be marked as observable objects so that once they change uh they update things that need to be updated and the thing that is going to be changing has to be marked as published this means as the game changes and the game changes really just by the current question index changing and the selections changing kind of that's how the game changes it's a lot of power from just these two properties right here uh but as these change then our game goes ahead and updates and it knows because it's marked as published that it should make available to anyone who's paying attention to it what those changes are we mark that we're paying attention to it that we care by inside the game view here is marked a state object which means that as this thing changes we know that the view should change as well and that's how all the pieces are connected between our view our view model and our model the view owns all of the views here and owns a state object view model the view model is marked as observable object it's a class and it marks the model as published and then the model is just a swift structure here that owns the core business logic about how the application uh should be should operate as the user interacts with it what the logic should be how how the business should change so that's what we covered here in this section uh in this session that we went over we're gonna pick up next time is figuring out how can we be adding in some the last bit of our application so clicking on this takes us to some final screen and ends the game and we can restart it and get some information about how we did and all those other nice features that would be good to see in a fully featured quiz application so uh that's what we're going to cover here for today that's we're going to cover in for next week thanks everyone who tuned in live for this one uh or if you were able to catch up and watch the video later on uh if you have any questions more for us we'll be back here next week uh and you can also feel free to reach out to us on the codecademy discord or on the uh codecademy forums so it was a pleasure getting to build some more applications with all of you here uh and then we will see all of you here next week for what i believe will be the last session in our ios quiz app development